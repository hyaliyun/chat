import{_ as m,o as s,c as n,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,u,_,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const A=m(q,[["render",R],["__scopeId","data-v-ef03d7f2"]]),S=JSON.parse(`[{"question":"def perform_operations(Q: int, operations: List[str]) -> List[int]: Perform a series of append and delete operations on an initially empty string, and return a list of the counts of each character from 'a' to 'z' in the final string. Parameters: Q (int): the number of operations. operations (List[str]): the list of operations to perform. Returns: List[int]: a list of 26 integers where the i-th integer denotes the number of times the i-th character (from 'a' to 'z') appears in the final string. Examples: >>> perform_operations(6, [\\"append(a)\\", \\"append(b)\\", \\"append(a)\\", \\"delete()\\", \\"append(c)\\", \\"append(c)\\"]) [1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> perform_operations(4, [\\"append(a)\\", \\"append(b)\\", \\"delete()\\", \\"delete()\\"]) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]","solution":"def perform_operations(Q, operations): from collections import defaultdict S = [] char_counts = defaultdict(int) for operation in operations: if operation.startswith(\\"append\\"): _, char = operation.split('(') char = char.rstrip(')') S.append(char) char_counts[char] += 1 elif operation == \\"delete()\\": if S: removed_char = S.pop() char_counts[removed_char] -= 1 result = [char_counts[chr(i)] for i in range(ord('a'), ord('z') + 1)] return result"},{"question":"def reverse_alternating(s: str) -> str: This function takes a single string as input and returns a new string with alternating words reversed, starting from the second word. >>> reverse_alternating(\\"hello world\\") 'hello dlrow' >>> reverse_alternating(\\"keep calm and code on\\") 'keep mlac and edoc on' >>> reverse_alternating(\\"a quick brown fox\\") 'a kciuq brown xof'","solution":"def reverse_alternating(s): This function takes a single string as input and returns a new string with alternating words reversed, starting from the second word. words = s.split() for i in range(1, len(words), 2): words[i] = words[i][::-1] return \\" \\".join(words)"},{"question":"def find_path(maze, n, m): Determine if there is a path from the starting point 'S' to the ending point 'E' in a maze. The maze is represented as a grid where: 'S' is the starting point 'E' is the ending point '.' is a passable cell '#' is an impassable cell Args: maze (List[List[str]]): The maze represented by a 2D list of characters. n (int): Number of rows in the maze. m (int): Number of columns in the maze. Returns: str: \\"YES\\" if there is a path from 'S' to 'E', \\"NO\\" otherwise. Examples: >>> find_path([ ... [\\"S\\", \\".\\", \\".\\", \\"#\\", \\".\\"], ... [\\".\\", \\"#\\", \\".\\", \\".\\", \\"#\\"], ... [\\".\\", \\"#\\", \\".\\", \\".\\", \\"#\\"], ... [\\".\\", \\".\\", \\"#\\", \\"#\\", \\"#\\"], ... [\\".\\", \\".\\", \\".\\", \\"E\\", \\".\\"] ... ], 5, 5) \\"YES\\" >>> find_path([ ... [\\"S\\", \\".\\", \\"#\\", \\".\\"], ... [\\"#\\", \\".\\", \\".\\", \\"#\\"], ... [\\".\\", \\".\\", \\"#\\", \\".\\"], ... [\\".\\", \\"#\\", \\"E\\", \\"#\\"] ... ], 4, 4) \\"NO\\"","solution":"def find_path(maze, n, m): from collections import deque # Find the starting point 'S' for i in range(n): for j in range(m): if maze[i][j] == 'S': start = (i, j) if maze[i][j] == 'E': end = (i, j) # Directions for moving (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # BFS to find the path queue = deque([start]) visited = set() visited.add(start) while queue: current = queue.popleft() if current == end: return \\"YES\\" for direction in directions: ni, nj = current[0] + direction[0], current[1] + direction[1] if 0 <= ni < n and 0 <= nj < m and (ni, nj) not in visited and maze[ni][nj] != '#': queue.append((ni, nj)) visited.add((ni, nj)) return \\"NO\\" # Example usage: n, m = 5, 5 maze = [ \\"S..#.\\", \\".#..#\\", \\".#..#\\", \\"..#\\", \\"...E.\\" ] print(find_path([list(row) for row in maze], n, m)) # Output: YES n, m = 4, 4 maze = [ \\"S.#.\\", \\"#..#\\", \\"..#.\\", \\".#E#\\" ] print(find_path([list(row) for row in maze], n, m)) # Output: NO"},{"question":"def max_elements_with_sum_lte_k(T, test_cases): Given an array of N integers a[1], a[2], ..., a[N] and an integer K, find the maximum number of elements you can choose such that their sum is less than or equal to K. Args: T (int): the number of test cases. test_cases (List[Tuple[int, int, List[int]]]): a list of test cases, where each test case consists of: - an integer N, - an integer K, - a list of N integers. Returns: List[int]: a list of integers where each integer is the results of the corresponding test case. >>> max_elements_with_sum_lte_k(2, [(5, 9, [1, 2, 3, 4, 5]), (4, 7, [2, 2, 2, 2])]) [3, 3] >>> max_elements_with_sum_lte_k(1, [(4, 100, [1, 2, 3, 4])]) [4]","solution":"def max_elements_with_sum_lte_k(T, test_cases): results = [] for i in range(T): N, K, array = test_cases[i] array.sort() current_sum = 0 count = 0 for num in array: if current_sum + num <= K: current_sum += num count += 1 else: break results.append(count) return results"},{"question":"def count_distinct_elements(n: int, q: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of distinct elements in each subarray specified by the queries. :param int n: The size of the array. :param int q: The number of queries. :param list arr: The array of integers. :param list queries: A list of tuples where each tuple contains two integers representing the 1-based start and end indices of the subarray. :return: A list of integers where each integer represents the count of distinct elements in the corresponding subarray. >>> count_distinct_elements(6, 3, [1, 2, 1, 3, 2, 3], [(1, 3), (2, 4), (1, 6)]) == [2, 3, 3] >>> count_distinct_elements(5, 2, [4, 4, 4, 4, 4], [(1, 3), (2, 5)]) == [1, 1] >>> count_distinct_elements(7, 4, [7, 6, 5, 7, 6, 5, 7], [(1, 2), (2, 3), (3, 5), (1, 7)]) == [2, 2, 3, 3]","solution":"def count_distinct_elements(n, q, arr, queries): Returns the number of distinct elements in each subarray specified by the queries. :param int n: The size of the array. :param int q: The number of queries. :param list arr: The array of integers. :param list queries: A list of tuples where each tuple contains two integers representing the 1-based start and end indices of the subarray. :return: A list of integers where each integer represents the count of distinct elements in the corresponding subarray. results = [] for l, r in queries: subarray = arr[l-1:r] # Convert 1-based index to 0-based index distinct_elements = len(set(subarray)) results.append(distinct_elements) return results"},{"question":"from typing import List def sort_names(names: List[str]) -> List[str]: Implement a function that takes a list of strings, each string representing a person's name, and returns a list of names sorted such that all the names starting with a vowel (a, e, i, o, u) appear before the names starting with a consonant. The vowels and consonants should each maintain their original order from the input list. Examples: >>> sort_names([\\"Alice\\", \\"Bob\\", \\"Eve\\", \\"Charlie\\", \\"Oscar\\"]) [\\"Alice\\", \\"Eve\\", \\"Oscar\\", \\"Bob\\", \\"Charlie\\"] >>> sort_names([\\"Zachary\\", \\"Yvonne\\", \\"Uma\\", \\"Quincy\\", \\"Ian\\"]) [\\"Uma\\", \\"Ian\\", \\"Yvonne\\", \\"Zachary\\", \\"Quincy\\"]","solution":"from typing import List def sort_names(names: List[str]) -> List[str]: vowels = {'a', 'e', 'i', 'o', 'u'} vowel_names = [name for name in names if name[0].lower() in vowels] consonant_names = [name for name in names if name[0].lower() not in vowels] return vowel_names + consonant_names"},{"question":"from typing import List def rearrange_array_minimize_difference(arr: List[int]) -> List[int]: Rearrange elements of an array such that the difference between any two adjacent elements is minimized. >>> rearrange_array_minimize_difference([4, 2, 1, 3]) [1, 2, 3, 4] >>> rearrange_array_minimize_difference([10, 1, 5]) [1, 5, 10] pass def test_rearrange_small_list(): assert rearrange_array_minimize_difference([4, 2, 1, 3]) == [1, 2, 3, 4] def test_rearrange_mixed_elements(): assert rearrange_array_minimize_difference([10, 1, 5]) == [1, 5, 10] def test_rearrange_already_sorted(): assert rearrange_array_minimize_difference([1, 2, 3, 4]) == [1, 2, 3, 4] def test_rearrange_single_element_list(): assert rearrange_array_minimize_difference([3]) == [3] def test_rearrange_negative_elements(): assert rearrange_array_minimize_difference([-3, -1, -4, -2]) == [-4, -3, -2, -1] def test_rearrange_large_range(): assert rearrange_array_minimize_difference([1000000, -1000000, 0, 500000, -500000]) == [-1000000, -500000, 0, 500000, 1000000] def test_rearrange_all_negative_and_positive(): assert rearrange_array_minimize_difference([-1, -2, 2, 1, 3]) == [-2, -1, 1, 2, 3]","solution":"from typing import List def rearrange_array_minimize_difference(arr: List[int]) -> List[int]: Rearranges elements of the array such that the difference between any two adjacent elements is minimized. arr.sort() # Sort the array to minimize differences return arr # Return the sorted array"},{"question":"def minimum_weeks_to_complete(n: int, t: int, prerequisites: List[List[int]]) -> int: Determine the minimum number of weeks required to complete module \`t\` given the prerequisites for each module. Args: n (int): Number of training modules. t (int): The target module to complete. prerequisites (List[List[int]]): A list where each element is a list containing the number of prerequisites followed by the prerequisites themselves. Returns: int: The minimum number of weeks required to complete the target module. Examples: >>> minimum_weeks_to_complete(4, 3, [[0], [1, 1], [1, 2], [2, 2, 3]]) 3 >>> minimum_weeks_to_complete(5, 5, [[0], [1, 1], [1, 1], [1, 2], [2, 3, 4]]) 4","solution":"def minimum_weeks_to_complete(n, t, prerequisites): from collections import deque, defaultdict # Create an adjacency list and calculate indegrees of each module adj_list = defaultdict(list) indegree = [0] * (n + 1) # Using 1-based indexing for i in range(1, n + 1): for pre in prerequisites[i - 1][1:]: adj_list[pre].append(i) indegree[i] += 1 # BFS queue initialization queue = deque() weeks = [0] * (n + 1) # Add modules with no prerequisites to the queue for i in range(1, n + 1): if indegree[i] == 0: queue.append(i) weeks[i] = 1 # Process modules in topological order using BFS while queue: current = queue.popleft() for neighbor in adj_list[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) weeks[neighbor] = weeks[current] + 1 return weeks[t]"},{"question":"def first_non_repeating_char(input_string: str) -> str: Finds the first non-repeating character in the given string. >>> first_non_repeating_char(\\"abracadabra\\") == \\"c\\" >>> first_non_repeating_char(\\"swiss\\") == \\"w\\" >>> first_non_repeating_char(\\"aabbcc\\") == \\"\\" >>> first_non_repeating_char(\\"\\") == \\"\\" >>> first_non_repeating_char(\\"abcd\\") == \\"a\\" >>> first_non_repeating_char(\\"aabbccddee\\") == \\"\\" >>> first_non_repeating_char(\\"abcdefg\\") == \\"a\\" >>> first_non_repeating_char(\\"aA\\") == \\"a\\" >>> first_non_repeating_char(\\"Aa\\") == \\"A\\" >>> first_non_repeating_char(\\"a1!a2@b1\\") == \\"!\\" >>> first_non_repeating_char(\\"a\\") == \\"a\\" >>> first_non_repeating_char(\\"1\\") == \\"1\\"","solution":"def first_non_repeating_char(input_string: str) -> str: Finds the first non-repeating character in the given string. from collections import OrderedDict # Dictionary to store character counts char_count = OrderedDict() # Traverse the string and count occurrences of each character for char in input_string: char_count[char] = char_count.get(char, 0) + 1 # Find the first character which has a count of 1 for char, count in char_count.items(): if count == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"def max_bridges(n: int, A: List[int], B: List[int]) -> int: Determine the maximum number of bridges that can be built without any two bridges intersecting. Parameters: n (int): The number of proposed bridge positions on each side of the river. A (List[int]): The positions on the left bank. B (List[int]): The positions on the right bank. Returns: int: The maximum number of bridges that can be built without intersecting. >>> max_bridges(5, [1, 3, 5, 2, 4], [2, 4, 1, 5, 3]) 2 >>> max_bridges(3, [1, 2, 3], [4, 5, 6]) 3 >>> max_bridges(4, [1, 2, 3, 4], [1, 2, 3, 4]) 4 >>> max_bridges(4, [4, 3, 2, 1], [1, 2, 3, 4]) 1 >>> max_bridges(1, [1], [1]) 1 >>> max_bridges(2, [1, 3], [2, 4]) 2 >>> max_bridges(2, [1, 2], [2, 1]) 1 >>> max_bridges(500, list(range(1, 501)), list(range(1, 501))) 500","solution":"def max_bridges(n, A, B): bridges = sorted(zip(A, B)) LIS = [] for bridge in bridges: pos = binary_search(LIS, bridge[1]) if pos == len(LIS): LIS.append(bridge[1]) else: LIS[pos] = bridge[1] return len(LIS) def binary_search(LIS, value): low, high = 0, len(LIS) - 1 while low <= high: mid = (low + high) // 2 if LIS[mid] < value: low = mid + 1 else: high = mid - 1 return low"},{"question":"def max_a0_after_operations(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum possible value of a[0] after performing the prescribed operations any number of times. Args: T : int : The number of test cases. test_cases : List[Tuple[int, List[int]]] : A list of tuples where each tuple contains an integer n and a list of n non-negative integers representing the array a. Returns: List[int] : A list of integers where each integer is the result for the corresponding test case. Examples: >>> max_a0_after_operations(3, [(5, [1, 2, 3, 4, 5]), (3, [100, 4, 1]), (4, [0, 0, 0, 0])]) [15, 105, 0]","solution":"def max_a0_after_operations(T, test_cases): results = [] for i in range(T): n, a = test_cases[i] total_sum = sum(a) results.append(total_sum) return results"},{"question":"def can_transform(s: str, t: str) -> str: Determines if the initial string s can be transformed into the target string t using any number of \\"Shuffle and Replace\\" operations (reversing any substring). Args: s (str): Initial string. t (str): Target string. Returns: str: \\"YES\\" if s can be transformed into t, otherwise \\"NO\\". Examples: >>> can_transform(\\"abcd\\", \\"dcba\\") \\"YES\\" >>> can_transform(\\"abc\\", \\"abc\\") \\"YES\\" >>> can_transform(\\"aabbcc\\", \\"ccbbaa\\") \\"YES\\" >>> can_transform(\\"abc\\", \\"abcd\\") \\"NO\\" >>> can_transform(\\"abc\\", \\"def\\") \\"NO\\" >>> can_transform(\\"a\\", \\"a\\") \\"YES\\" >>> can_transform(\\"a\\", \\"b\\") \\"NO\\" >>> can_transform(\\"a\\"*500 + \\"b\\"*500, \\"b\\"*500 + \\"a\\"*500) \\"YES\\" >>> can_transform(\\"a\\"*1000, \\"b\\"*1000) \\"NO\\"","solution":"def can_transform(s, t): Determines if the initial string s can be transformed into the target string t using any number of \\"Shuffle and Replace\\" operations (reversing any substring). if sorted(s) == sorted(t): return \\"YES\\" else: return \\"NO\\""},{"question":"def get_pascal_row(n): Returns the nth row of Pascal's triangle. >>> get_pascal_row(0) [1] >>> get_pascal_row(1) [1, 1] >>> get_pascal_row(2) [1, 2, 1] >>> get_pascal_row(3) [1, 3, 3, 1] >>> get_pascal_row(4) [1, 4, 6, 4, 1] >>> get_pascal_row(5) [1, 5, 10, 10, 5, 1] >>> get_pascal_row(6) [1, 6, 15, 20, 15, 6, 1]","solution":"def get_pascal_row(n): Returns the nth row of Pascal's triangle. if n == 0: return [1] # Start with the first row row = [1] for i in range(1, n + 1): # Generate the next row using the previous row new_row = [1] * (i + 1) for j in range(1, i): new_row[j] = row[j - 1] + row[j] row = new_row return row"},{"question":"def maxProduct(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Split the array into two non-empty subarrays such that the product of the sums of the elements in the subarrays is maximized. If there are multiple ways to split the array, choose the one that gives the maximum product of the sums. If an array cannot be split into two non-empty subarrays, return -1. >>> maxProduct([(5, [1, 2, 3, 4, 5])]) [54] >>> maxProduct([(3, [1, 1, 1])]) [2] >>> maxProduct([test_cases]) == [(4, [10, 5, 1, 2])]) [80]","solution":"def maxProduct(test_cases): results = [] for case in test_cases: N, array = case if N < 2: results.append(-1) continue total_sum = sum(array) left_sum = 0 max_product = -1 for i in range(N - 1): left_sum += array[i] right_sum = total_sum - left_sum max_product = max(max_product, left_sum * right_sum) results.append(max_product) return results"},{"question":"def highest_scorer(n: int, k: int, scores: List[int]) -> int: Given the number of scores \`n\`, number of players \`k\`, and a list of scores, determines the ID of the player with the highest total score. :param n: int - number of total game scores :param k: int - number of unique players :param scores: List[int] - sequence of game scores :return: int - ID of the player with the highest total score >>> highest_scorer(6, 3, [10, 20, 30, 15, 25, 35]) 3 >>> highest_scorer(4, 2, [5, 15, 10, 20]) 2","solution":"def highest_scorer(n, k, scores): Given the number of scores \`n\`, number of players \`k\`, and a list of scores, determines the ID of the player with the highest total score. :param n: int - number of total game scores :param k: int - number of unique players :param scores: List[int] - sequence of game scores :return: int - ID of the player with the highest total score player_scores = [0] * k games_per_player = n // k for i in range(n): player_id = (i // games_per_player) player_scores[player_id] += scores[i] highest_score = max(player_scores) highest_scorer_id = player_scores.index(highest_score) + 1 return highest_scorer_id"},{"question":"def manage_resources(N: int, M: int, requests: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int, int, int]]: This function processes a list of access requests and determines the final allocation of resources. If multiple employees request the same resource at overlapping times, the requests are considered invalid. :param N: int - Number of employees :param M: int - Number of resources :param requests: List[Tuple[int, int, int, int]] - List of access requests :return: List[Tuple[int, int, int, int]] - List of valid access requests Example: >>> manage_resources(3, 2, [(1, 1, 60, 30), (2, 1, 80, 20), (3, 1, 75, 25), (2, 2, 100, 50)]) [(1, 1, 60, 30), (2, 2, 100, 50)] >>> manage_resources(3, 2, [(1, 1, 60, 30), (2, 1, 100, 20), (3, 2, 120, 25)]) [(1, 1, 60, 30), (2, 1, 100, 20), (3, 2, 120, 25)] >>> manage_resources(2, 1, [(1, 1, 60, 30), (2, 1, 70, 20), (1, 1, 65, 25)]) [(1, 1, 60, 30)] pass def test_valid_requests(): N = 3 M = 2 requests = [ (1, 1, 60, 30), (2, 1, 80, 20), (3, 1, 75, 25), (2, 2, 100, 50) ] assert manage_resources(N, M, requests) == [ (1, 1, 60, 30), (2, 2, 100, 50) ] def test_no_conflicts(): N = 3 M = 2 requests = [ (1, 1, 60, 30), (2, 1, 100, 20), (3, 2, 120, 25) ] assert manage_resources(N, M, requests) == [ (1, 1, 60, 30), (2, 1, 100, 20), (3, 2, 120, 25) ] def test_all_conflicts(): N = 2 M = 1 requests = [ (1, 1, 60, 30), (2, 1, 70, 20), (1, 1, 65, 25) ] assert manage_resources(N, M, requests) == [ (1, 1, 60, 30) ] def test_partial_conflicts(): N = 4 M = 2 requests = [ (1, 1, 60, 30), (2, 1, 100, 50), (3, 1, 120, 10), (4, 2, 200, 40), (1, 2, 180, 30) ] assert manage_resources(N, M, requests) == [ (1, 1, 60, 30), (2, 1, 100, 50), (4, 2, 200, 40) ] def test_overlapping_concurrent_requests(): N = 3 M = 1 requests = [ (1, 1, 0, 600), (2, 1, 300, 200), (3, 1, 500, 500) ] assert manage_resources(N, M, requests) == [ (1, 1, 0, 600) ]","solution":"def manage_resources(N, M, requests): This function processes a list of access requests and determines the final allocation of resources. If multiple employees request the same resource at overlapping times, the requests are considered invalid. :param N: int - Number of employees :param M: int - Number of resources :param requests: List[Tuple[int, int, int, int]] - List of access requests :return: List[Tuple[int, int, int, int]] - List of valid access requests # Dictionary to keep track of resource schedule resource_schedule = {i: [] for i in range(1, M + 1)} valid_requests = [] for employee_id, resource_id, start_time, duration in requests: end_time = start_time + duration is_valid = True # Check for overlap with existing reservations for the resource for existing_start, existing_end in resource_schedule[resource_id]: if not (end_time <= existing_start or start_time >= existing_end): is_valid = False break # If no overlap, add the request to the valid list and update the schedule if is_valid: valid_requests.append((employee_id, resource_id, start_time, duration)) resource_schedule[resource_id].append((start_time, end_time)) resource_schedule[resource_id].sort() # Ensure schedule is sorted by start time return valid_requests"},{"question":"from typing import List, Tuple def min_cameras(n: int, m: int, roads: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Calculates the minimum number of cameras required to monitor all roads in a city, and the list of intersections where these cameras should be installed. Args: n (int): Number of intersections. m (int): Number of roads. roads (List[Tuple[int, int]]): List of tuples indicating the roads between intersections. Returns: Tuple[int, List[int]]: A tuple consisting of the minimum number of cameras and the list of intersections. pass def process_input(input_data: str) -> Tuple[int, List[int]]: lines = input_data.split('n') n, m = map(int, lines[0].split()) roads = [tuple(map(int, line.split())) for line in lines[1:m+1]] return min_cameras(n, m, roads) # Unit Tests import pytest def test_example_1(): input_data = \\"4 3n1 2n2 3n3 4\\" assert process_input(input_data) == (2, [1, 3]) def test_example_2(): input_data = \\"6 5n1 2n2 3n3 4n4 5n5 6\\" assert process_input(input_data) == (3, [1, 3, 5]) def test_single_intersection_no_road(): input_data = \\"1 0\\" assert process_input(input_data) == (0, []) def test_disconnected_graph(): input_data = \\"5 2n1 2n4 5\\" assert process_input(input_data) in [(2, [1, 4]), (2, [4, 1])] def test_multiple_solutions(): input_data = \\"6 6n1 2n2 3n3 4n4 5n5 6n1 6\\" solutions = [ (3, [1, 3, 5]), (3, [1, 4, 6]), (3, [2, 4, 6]), (3, [2, 3, 5]) ] assert process_input(input_data) in solutions","solution":"def min_cameras(n, m, roads): from collections import defaultdict, deque graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) cameras = set() def bfs(start): q = deque([start]) visited[start] = True while q: node = q.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True q.append(neighbor) cameras.add(node) break # Only add one node from this BFS search for i in range(1, n + 1): if not visited[i] and len(graph[i]) > 0: bfs(i) return len(cameras), list(cameras) def process_input(input_data): lines = input_data.split('n') n, m = map(int, lines[0].split()) roads = [tuple(map(int, line.split())) for line in lines[1:m+1]] return min_cameras(n, m, roads) # Example usage example_input = \\"4 3n1 2n2 3n3 4\\" print(process_input(example_input)) # Output: (2, [1, 3]) example_input = \\"6 5n1 2n2 3n3 4n4 5n5 6\\" print(process_input(example_input)) # Output: (3, [1, 3, 5])"},{"question":"def convert_date(date_str: str) -> str: Converts a date from MM/DD/YYYY format to \\"Day Month, Year\\" format. Parameters: date_str (str): The date in MM/DD/YYYY format. Returns: str: The date in \\"Day Month, Year\\" format. >>> convert_date(\\"04/03/2022\\") \\"3 April, 2022\\" >>> convert_date(\\"11/21/1999\\") \\"21 November, 1999\\"","solution":"def convert_date(date_str): Converts a date from MM/DD/YYYY format to \\"Day Month, Year\\" format. Parameters: date_str (str): The date in MM/DD/YYYY format. Returns: str: The date in \\"Day Month, Year\\" format. # Define a mapping of month number to month name months = [ \\"January\\", \\"February\\", \\"March\\", \\"April\\", \\"May\\", \\"June\\", \\"July\\", \\"August\\", \\"September\\", \\"October\\", \\"November\\", \\"December\\" ] # Split the input date string into components mm, dd, yyyy = date_str.split('/') # Convert month and day to integer month = int(mm) day = int(dd) # Get the month name from the list month_name = months[month - 1] # Format the date in the required format formatted_date = f\\"{day} {month_name}, {yyyy}\\" return formatted_date"},{"question":"def motivational_message(n: int) -> str: Write a function that takes an integer \`n\` representing the number of consecutive days a student has completed their homework. The function should return a motivational message based on the number of days: - If the student has completed homework for 7 or more days, return the string \\"Fantastic! Keep up the great work!\\". - If the student has completed homework for less than 7 days, return the string \\"Good start! Try to reach a week.\\" >>> motivational_message(7) 'Fantastic! Keep up the great work!' >>> motivational_message(10) 'Fantastic! Keep up the great work!' >>> motivational_message(6) 'Good start! Try to reach a week.' >>> motivational_message(1) 'Good start! Try to reach a week.' >>> motivational_message(0) 'Good start! Try to reach a week.'","solution":"def motivational_message(n): Returns a motivational message based on the number of consecutive days a student has completed their homework. Parameters: n (int): Number of consecutive days the homework has been completed. Returns: str: Motivational message. if n >= 7: return \\"Fantastic! Keep up the great work!\\" else: return \\"Good start! Try to reach a week.\\""},{"question":"def can_type_word(n: int, m: int, keyboard: List[List[str]], word: str) -> bool: Determines if a given word can be typed on the alien keyboard by traversing through adjacent keys. >>> can_type_word(4, 5, [ ['a', 'b', 'c', 'd', 'e'], ['f', 'g', 'h', 'i', 'j'], ['k', 'l', 'm', 'n', 'o'], ['p', 'q', 'r', 's', 't'] ], 'hello') False >>> can_type_word(3, 3, [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ], 'beg') True def test_can_type_word(): assert can_type_word(4, 5, [ ['a', 'b', 'c', 'd', 'e'], ['f', 'g', 'h', 'i', 'j'], ['k', 'l', 'm', 'n', 'o'], ['p', 'q', 'r', 's', 't'] ], 'hello') == False assert can_type_word(3, 3, [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ], 'beg') == True assert can_type_word(1, 1, [ ['a'] ], 'a') == True assert can_type_word(2, 2, [ ['a', 'b'], ['c', 'd'] ], 'abcd') == True assert can_type_word(2, 2, [ ['a', 'b'], ['c', 'd'] ], 'abdc') == True assert can_type_word(2, 2, [ ['a', 'b'], ['c', 'd'] ], 'abdd') == False","solution":"def can_type_word(n, m, keyboard, word): directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m def dfs(x, y, word_idx): if word_idx == len(word): return True temp = keyboard[x][y] keyboard[x][y] = '#' # Mark as visited for direction in directions: new_x, new_y = x + direction[0], y + direction[1] if is_valid(new_x, new_y) and keyboard[new_x][new_y] == word[word_idx]: if dfs(new_x, new_y, word_idx + 1): return True keyboard[x][y] = temp # Unmark return False for row in range(n): for col in range(m): if keyboard[row][col] == word[0]: if dfs(row, col, 1): return True return False def read_and_solve(): import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) keyboard = [] word = data[-1] index = 2 for _ in range(n): keyboard.append(list(data[index])) index += 1 if can_type_word(n, m, keyboard, word): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"from typing import List def highest_version(versions: List[str]) -> str: Returns the highest version string from the list of version strings. Versions are compared based on their MAJOR, MINOR, and PATCH numbers in that order. >>> highest_version([\\"1.0.0\\", \\"2.1.0\\", \\"2.0.1\\", \\"1.3.4\\", \\"2.1.1\\"]) \\"2.1.1\\" >>> highest_version([\\"1.0.0\\"]) \\"1.0.0\\" >>> highest_version([\\"2.1.0\\", \\"2.1.1\\", \\"2.0.1\\"]) \\"2.1.1\\" >>> highest_version([\\"0.1.0\\", \\"0.1.2\\", \\"0.1.1\\"]) \\"0.1.2\\" >>> highest_version([\\"1.0.0\\", \\"1.0.0\\", \\"1.0.0\\"]) \\"1.0.0\\" >>> highest_version([\\"99999.99999.99999\\", \\"99999.99999.99998\\"]) \\"99999.99999.99999\\"","solution":"def highest_version(versions): Returns the highest version string from the list of version strings. def version_key(version): # Split and convert the version string into a tuple of integers major, minor, patch = map(int, version.split('.')) return (major, minor, patch) # Sort and get the highest version return max(versions, key=version_key)"},{"question":"def encrypt_message(shift: int, message: str) -> str: Encrypts the message by shifting its letters by the given shift value. >>> encrypt_message(3, \\"secure\\") 'vhfxuh' >>> encrypt_message(-1, \\"abcd\\") 'zabc' >>> encrypt_message(3, \\"xyz\\") 'abc' # Implementation here def decrypt_message(shift: int, message: str) -> str: Decrypts the message by reversing the shift of its letters by the given shift value. >>> decrypt_message(3, \\"vhfxuh\\") 'secure' >>> decrypt_message(-1, \\"zabc\\") 'abcd' >>> decrypt_message(3, \\"abc\\") 'xyz' # Implementation here def process_message(operation: str, shift: int, message: str) -> str: Processes the message depending on the operation. >>> process_message(\\"encrypt\\", 3, \\"secure\\") 'vhfxuh' >>> process_message(\\"decrypt\\", 3, \\"vhfxuh\\") 'secure' >>> try: ... process_message(\\"invalid\\", 3, \\"secure\\") ... except ValueError as e: ... assert str(e) == \\"Invalid operation. Use 'encrypt' or 'decrypt'.\\" # Implementation here","solution":"def encrypt_message(shift, message): Encrypts the message by shifting its letters by the given shift value. encrypted_message = [] for char in message: new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) encrypted_message.append(new_char) return ''.join(encrypted_message) def decrypt_message(shift, message): Decrypts the message by reversing the shift its letters by the given shift value. decrypted_message = [] for char in message: new_char = chr(((ord(char) - ord('a') - shift) % 26) + ord('a')) decrypted_message.append(new_char) return ''.join(decrypted_message) def process_message(operation, shift, message): Processes the message depending on the operation. if operation == \\"encrypt\\": return encrypt_message(shift, message) elif operation == \\"decrypt\\": return decrypt_message(shift, message) else: raise ValueError(\\"Invalid operation. Use 'encrypt' or 'decrypt'.\\")"},{"question":"def factorial(n): Compute the factorial of n. :param n: The number to compute the factorial of. :return: The factorial of n. pass def count_unique_words(A, L): Returns the number of unique words of length L that can be formed using the first A letters of the alphabet, with no letter used more than once. :param A: Number of letters in the alphabet to use. :param L: Length of each word. :return: Number of unique words. >>> count_unique_words(3, 2) == 6 >>> count_unique_words(4, 3) == 24 pass def unique_words_from_cases(test_cases): Process multiple test cases to find the number of unique words for each. :param test_cases: List of tuples where each tuple contains (A, L) :return: List of integers where each integer is the number of unique words for the respective test case. >>> unique_words_from_cases([(3, 2), (4, 3)]) == [6, 24] pass","solution":"def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) def count_unique_words(A, L): Returns the number of unique words of length L that can be formed using the first A letters of the alphabet, with no letter used more than once. if L > A: return 0 return factorial(A) // factorial(A - L) def unique_words_from_cases(test_cases): Process multiple test cases to find the number of unique words for each. :param test_cases: List of tuples where each tuple contains (A, L) :return: List of integers where each integer is the number of unique words for the respective test case. results = [] for A, L in test_cases: results.append(count_unique_words(A, L)) return results"},{"question":"def process_queries(Q: int, M: int, queries: List[Tuple[int, ...]]) -> List[int]: Process a list of queries for generating and manipulating a sequence. Each query is either of type 1 or 2. Type 1 generates a sequence and updates elements from L to R modulo a given K. Type 2 calculates the sum of elements from L to R in the current sequence. Args: Q (int): The number of queries M (int): The initial modulo value queries (List[Tuple[int, ...]]): A list of queries where each query is either: - (1, S1, S2, N, L, R, K) - (2, L, R) Returns: List[int]: List of results for each query of type 2. >>> Q = 5 >>> M = 10 >>> queries = [ ... (1, 1, 1, 5, 1, 2, 3), ... (2, 1, 5), ... (1, 2, 3, 6, 3, 4, 5), ... (2, 1, 6), ... (2, 4, 6) ... ] >>> process_queries(Q, M, queries) [4, 25, 7] import pytest def test_simple_case(): Q = 5 M = 10 queries = [ (1, 1, 1, 5, 1, 2, 3), (2, 1, 5), (1, 2, 3, 6, 3, 4, 5), (2, 1, 6), (2, 4, 6) ] expected = [4, 25, 7] assert process_queries(Q, M, queries) == expected def test_case_2(): Q = 3 M = 100 queries = [ (1, 5, 8, 7, 3, 5, 10), (2, 1, 7), (2, 3, 5) ] expected = [165, 8] assert process_queries(Q, M, queries) == expected def test_case_3(): Q = 2 M = 1000 queries = [ (1, 22, 33, 10, 4, 7, 100), (2, 4, 7) ] expected = [236] assert process_queries(Q, M, queries) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def generate_sequence(modulus, S1, S2, N): # Generate sequence \`up to\` Nth number with given modulus sequence = [S1 % modulus, S2 % modulus] for i in range(2, N): next_value = (sequence[i-1] + sequence[i-2]) % modulus sequence.append(next_value) return sequence def process_queries(Q, M, queries): results = [] current_sequence = [] for query in queries: if query[0] == 1: # 1 S1 S2 N L R K _, S1, S2, N, L, R, K = query current_sequence = generate_sequence(M, S1, S2, N) for i in range(L-1, R): # converting to zero-based index current_sequence[i] %= K elif query[0] == 2: # 2 L R _, L, R = query sum_value = sum(current_sequence[L-1:R]) # converting to zero-based index results.append(sum_value) return results"},{"question":"from typing import List, Tuple def most_frequent_char(s: str, queries: List[Tuple[int, int]]) -> List[str]: Returns the most frequently occurring character in the specified substrings for each query. >>> most_frequent_char(\\"abracadabra\\", [(1, 3), (2, 9), (5, 10)]) [\\"a\\", \\"a\\", \\"a\\"] >>> most_frequent_char(\\"mississippi\\", [(1, 4), (2, 5), (6, 11)]) [\\"s\\", \\"i\\", \\"i\\"] pass def test_single_char_string(): assert most_frequent_char(\\"a\\", [(1, 1)]) == [\\"a\\"] def test_all_chars_same(): assert most_frequent_char(\\"aaaaaa\\", [(1, 6)]) == [\\"a\\"] def test_no_repeating_chars(): assert most_frequent_char(\\"abcde\\", [(1, 5), (2, 4), (3, 3)]) == [\\"a\\", \\"b\\", \\"c\\"] def test_example_case1(): s = \\"abracadabra\\" queries = [(1, 3), (2, 9), (5, 10)] assert most_frequent_char(s, queries) == [\\"a\\", \\"a\\", \\"a\\"] def test_example_case2(): s = \\"mississippi\\" queries = [(1, 4), (2, 5), (6, 11)] assert most_frequent_char(s, queries) == [\\"s\\", \\"i\\", \\"i\\"] def test_tie_case(): s = \\"aabbbcc\\" queries = [(1, 7)] assert most_frequent_char(s, queries) == [\\"b\\"] def test_another_tie_case(): s = \\"abccba\\" queries = [(1, 6)] assert most_frequent_char(s, queries) == [\\"a\\"]","solution":"def most_frequent_char(s, queries): Returns the most frequently occurring character in the specified substrings for each query. results = [] for l, r in queries: sub = s[l-1:r] freq = {} for char in sub: if char in freq: freq[char] += 1 else: freq[char] = 1 max_freq = max(freq.values()) max_chars = [char for char in freq if freq[char] == max_freq] results.append(min(max_chars)) return results"},{"question":"def process_sequence(sequence, tasks): Perform specified operations on a given sequence of numbers. Args: sequence (List[int]): The sequence of integers. tasks (List[str]): List of tasks with format \\"task_name n\\". Returns: List[Union[int, float]]: Results of the tasks performed on the sequence. >>> process_sequence([12, 4, 7, 9, 15], [\\"Sumprob 4\\"]) [32] >>> process_sequence([12, 4, 7, 9, 15], [\\"Maxseq 3\\"]) [12] >>> process_sequence([12, 4, 7, 9, 15], [\\"Meanprob 4\\"]) [8.0] >>> process_sequence([12, 4, 7, 9, 15], [\\"Sumprob 4\\", \\"Maxseq 3\\", \\"Meanprob 5\\"]) [32, 12, 9.4] # Example of how to call the function with given inputs def main(): input_sequence = list(map(int, input().split())) t = int(input()) tasks = [input().strip() for _ in range(t)] results = process_sequence(input_sequence, tasks) for res in results: print(res) if __name__ == \\"__main__\\": main() import pytest from solution import process_sequence def test_sumprob(): sequence = [12, 4, 7, 9, 15] tasks = [\\"Sumprob 4\\"] expected = [32] assert process_sequence(sequence, tasks) == expected def test_maxseq(): sequence = [12, 4, 7, 9, 15] tasks = [\\"Maxseq 3\\"] expected = [12] assert process_sequence(sequence, tasks) == expected def test_meanprob(): sequence = [12, 4, 7, 9, 15] tasks = [\\"Meanprob 4\\"] expected = [8.0] # (12 + 4 + 7 + 9) / 4 = 8.0 assert process_sequence(sequence, tasks) == expected def test_mixed_tasks(): sequence = [12, 4, 7, 9, 15] tasks = [\\"Sumprob 4\\", \\"Maxseq 3\\", \\"Meanprob 5\\"] expected = [32, 12, 9.4] # Sumprob 4 = 32, Maxseq 3 = 12, Meanprob 5 = (12 + 4 + 7 + 9 + 15) / 5 = 9.4 assert process_sequence(sequence, tasks) == expected","solution":"def process_sequence(sequence, tasks): results = [] for task in tasks: task_name, n = task.split() n = int(n) if task_name == \\"Sumprob\\": result = sum(sequence[:n]) elif task_name == \\"Maxseq\\": result = max(sequence[:n]) elif task_name == \\"Meanprob\\": result = sum(sequence[:n]) / n results.append(result) return results # Example of how to call the function with given inputs def main(): input_sequence = list(map(int, input().split())) t = int(input()) tasks = [input().strip() for _ in range(t)] results = process_sequence(input_sequence, tasks) for res in results: print(res) if __name__ == \\"__main__\\": main()"},{"question":"def butterfly_forest_operations(N: int, M: int, Q: int, initial_grid: List[List[int]], operations: List[List[int]]) -> List[int]: Perform updates and queries on a grid of butterfly populations. Args: - N (int): Number of rows in the grid. - M (int): Number of columns in the grid. - Q (int): Number of operations to perform. - initial_grid (List[List[int]]): Initial grid of butterfly populations. - operations (List[List[int]]): List of operations to perform on the grid. Returns: - List[int]: Results of the sum queries. Example: >>> N, M, Q = 3, 3, 5 >>> initial_grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> operations = [ ... [2, 1, 1, 2, 2], ... [1, 2, 2, 10], ... [2, 1, 1, 2, 2], ... [2, 1, 1, 3, 3], ... [1, 3, 3, 1] ... ] >>> butterfly_forest_operations(N, M, Q, initial_grid, operations) [12, 17, 50] # Implementation goes here def test_butterfly_forest_operations(): N, M, Q = 3, 3, 5 initial_grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operations = [ [2, 1, 1, 2, 2], [1, 2, 2, 10], [2, 1, 1, 2, 2], [2, 1, 1, 3, 3], [1, 3, 3, 1] ] expected_results = [12, 17, 50] assert butterfly_forest_operations(N, M, Q, initial_grid, operations) == expected_results def test_single_update_query(): N, M, Q = 2, 2, 2 initial_grid = [ [1, 1], [1, 1] ] operations = [ [1, 1, 1, 5], [2, 1, 1, 2, 2] ] expected_results = [8] assert butterfly_forest_operations(N, M, Q, initial_grid, operations) == expected_results def test_no_update_query(): N, M, Q = 2, 2, 1 initial_grid = [ [1, 2], [3, 4] ] operations = [ [2, 1, 1, 2, 2] ] expected_results = [10] assert butterfly_forest_operations(N, M, Q, initial_grid, operations) == expected_results def test_multiple_updates_queries(): N, M, Q = 2, 2, 4 initial_grid = [ [1, 1], [1, 1] ] operations = [ [1, 1, 2, 5], [2, 1, 1, 2, 1], [1, 2, 2, 7], [2, 1, 1, 2, 2] ] expected_results = [2, 14] assert butterfly_forest_operations(N, M, Q, initial_grid, operations) == expected_results","solution":"class ButterflyForest: def __init__(self, grid): self.grid = grid self.N = len(grid) self.M = len(grid[0]) self.prefix_sum = [[0] * (self.M + 1) for _ in range(self.N + 1)] self._calculate_prefix_sum() def _calculate_prefix_sum(self): for i in range(1, self.N + 1): for j in range(1, self.M + 1): self.prefix_sum[i][j] = self.grid[i-1][j-1] + self.prefix_sum[i-1][j] + self.prefix_sum[i][j-1] - self.prefix_sum[i-1][j-1] def update_cell(self, r, c, k): # Update the actual grid old_value = self.grid[r-1][c-1] self.grid[r-1][c-1] = k # Update the prefix sum accordingly diff = k - old_value for i in range(r, self.N + 1): for j in range(c, self.M + 1): self.prefix_sum[i][j] += diff def query_sum(self, r1, c1, r2, c2): return self.prefix_sum[r2][c2] - self.prefix_sum[r1-1][c2] - self.prefix_sum[r2][c1-1] + self.prefix_sum[r1-1][c1-1] def butterfly_forest_operations(N, M, Q, initial_grid, operations): forest = ButterflyForest(initial_grid) results = [] for operation in operations: op = operation[0] if op == 1: _, r, c, k = operation forest.update_cell(r, c, k) elif op == 2: _, r1, c1, r2, c2 = operation result = forest.query_sum(r1, c1, r2, c2) results.append(result) return results"},{"question":"def garden_planner(n, m, q, grid, plants): Emma is planning her garden and wants to allocate space optimally for her plants. She has a plot that is divided into n rows and m columns, forming an n × m grid. Some cells might be blocked due to rocks or other obstacles, and Emma cannot use these for planting. A cell is denoted as blocked if it contains a '1' and available if it contains a '0'. Emma decides to plant q different types of plants. Each plant type requires a certain number of contiguous cells that form a rectangle, but the precise location within the available garden space is flexible. Emma can rotate the rectangle by 90 degrees if necessary to fit it into the available space. Given the garden grid and the required dimensions for each plant, determine if she can accommodate the plants without overlap and within the allowed cells. If possible, provide a way to plant all types of plants. Args: n (int): the number of rows in the garden plot. m (int): the number of columns in the garden plot. q (int): the number of different types of plants. grid (List[str]): a list of strings representing the garden plot, where '0' means available and '1' means blocked. plants (List[Tuple[int, int]]): a list of tuples where each tuple contains two integers representing the dimensions of the rectangle required for each plant type. Returns: str: \\"YES\\" if it is possible to plant all types, otherwise \\"NO\\". Examples: >>> garden_planner(5, 6, 2, [\\"001000\\", \\"000100\\", \\"010000\\", \\"000000\\", \\"100010\\"], [(2, 3), (3, 2)]) \\"YES\\" >>> garden_planner(4, 4, 2, [\\"0010\\", \\"0100\\", \\"0000\\", \\"1001\\"], [(2, 2), (2, 3)]) \\"NO\\"","solution":"def can_place(garden, n, m, r, c, x, y): if x + r > n or y + c > m: return False for i in range(r): for j in range(c): if garden[x + i][y + j] == '1': return False return True def mark_taken(garden, r, c, x, y): for i in range(r): for j in range(c): garden[x + i][y + j] = '1' def garden_planner(n, m, q, grid, plants): garden = [list(row) for row in grid] for r, c in plants: placed = False for x in range(n): for y in range(m): if can_place(garden, n, m, r, c, x, y): mark_taken(garden, r, c, x, y) placed = True break if can_place(garden, n, m, c, r, x, y): # Try rotating mark_taken(garden, c, r, x, y) placed = True break if placed: break if not placed: return \\"NO\\" return \\"YES\\""},{"question":"def is_mirror_string(s: str) -> bool Determines if the given string is a \\"mirror\\" string. A \\"mirror\\" string is one that appears the same when reversed and characters are replaced by their mirror counterparts. Only the characters {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'} are mirror characters. Parameters: - s (str): Input string Returns: - bool: True if the string is a mirror string, False otherwise >>> is_mirror_string(\\"AHA\\") True >>> is_mirror_string(\\"BIM\\") False >>> is_mirror_string(\\"YXY\\") True return ... def check_mirror_strings(test_cases: list[str]) -> list[str]: Processes multiple test cases to determine if each string is a mirror string. Parameters: - test_cases (list): List of strings to be checked Returns: - list: List of results, each \\"YES\\" or \\"NO\\" for the corresponding string >>> check_mirror_strings([\\"AHA\\", \\"BIM\\", \\"YXY\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_mirror_strings([\\"TAT\\", \\"T\\", \\"IAM\\", \\"WOW\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] return ...","solution":"def is_mirror_string(s): Determines if the given string is a \\"mirror\\" string. A \\"mirror\\" string is one that appears the same when reversed and characters are replaced by their mirror counterparts. Only the characters {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'} are mirror characters. Parameters: - s (str): Input string Returns: - bool: True if the string is a mirror string, False otherwise # Define the set of mirror characters mirror_chars = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'} # Check if every character in the string is a mirror character if not all(char in mirror_chars for char in s): return False # Check if the string reads the same forwards and backwards return s == s[::-1] def check_mirror_strings(test_cases): Processes multiple test cases to determine if each string is a mirror string. Parameters: - test_cases (list): List of strings to be checked Returns: - list: List of results, each \\"YES\\" or \\"NO\\" for the corresponding string return [\\"YES\\" if is_mirror_string(s) else \\"NO\\" for s in test_cases]"},{"question":"from typing import List, Tuple def apply_backspace(s: str) -> str: Applies the backspace operation on the string \`s\`. result = [] for char in s: if char == '#': if result: result.pop() else: result.append(char) return ''.join(result) def is_backspace_equal(s: str, t: str) -> bool: Determines if the processed string \`s\` is equal to string \`t\`. processed_s = apply_backspace(s) return processed_s == t def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases. results = [] for s, t in test_cases: if is_backspace_equal(s, t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example test cases test_cases = [ (\\"ab#c\\", \\"ac\\"), (\\"ab\\", \\"c\\"), (\\"a#c\\", \\"b\\") ] print(process_test_cases(test_cases)) # Output: ['YES', 'NO', 'NO']","solution":"def apply_backspace(s): Applies the backspace operation on the string s. result = [] for char in s: if char == '#': if result: result.pop() else: result.append(char) return ''.join(result) def is_backspace_equal(s, t): Determines if the processed string s is equal to string t. processed_s = apply_backspace(s) return processed_s == t def process_test_cases(test_cases): Processes multiple test cases. results = [] for s, t in test_cases: if is_backspace_equal(s, t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_common_stop_pairs(n: int, routes: List[str]) -> int: Counts the number of pairs of routes that have at least one common stop. Parameters: n (int): Number of bus routes. routes (List[str]): List of strings representing bus routes. Returns: int: Number of pairs of routes with at least one common stop. pass # Example n = 3 routes = [\\"abc\\", \\"bcd\\", \\"def\\"] print(count_common_stop_pairs(n, routes)) # Expected output: 2","solution":"def count_common_stop_pairs(n, routes): Counts the number of pairs of routes that have at least one common stop. Parameters: n (int): Number of bus routes. routes (list of str): List of strings representing bus routes. Returns: int: Number of pairs of routes with at least one common stop. # Create a dictionary to map each stop to a set of routes that visit it stop_to_routes = {} for index, route in enumerate(routes): # Use a set to avoid duplicate counting within the same route for stop in set(route): if stop in stop_to_routes: stop_to_routes[stop].add(index) else: stop_to_routes[stop] = {index} # Set to keep track of unique route pairs pairs = set() for route_indices in stop_to_routes.values(): if len(route_indices) > 1: route_indices = list(route_indices) for i in range(len(route_indices)): for j in range(i + 1, len(route_indices)): pairs.add((route_indices[i], route_indices[j])) return len(pairs) # Example use case n = 3 routes = [\\"abc\\", \\"bcd\\", \\"def\\"] print(count_common_stop_pairs(n, routes)) # Expected: 2"},{"question":"from typing import List class LRUCache: def __init__(self, capacity: int): Initialises the LRU Cache with given capacity def get(self, key: int) -> int: Returns the value of the key if present, otherwise returns -1 def set(self, key: int, value: int): Sets or inserts the value if the key is not already present. If the cache is full, it will remove the least recently used item. def process_cache_queries(n: int, queries: List[str]) -> List[int]: Processes a list of cache operations and returns the results of \\"GET\\" operations. Args: n (int): Size of the cache. queries (List[str]): List of cache operations. Returns: List[int]: List of results for \\"GET\\" operations. >>> process_cache_queries(2, [\\"SET 1 10\\", \\"SET 2 20\\", \\"GET 1\\", \\"SET 3 30\\", \\"GET 2\\", \\"GET 3\\"]) [10, -1, 30] >>> process_cache_queries(2, [\\"SET 1 10\\", \\"SET 2 20\\", \\"SET 3 30\\"]) [] from solution import process_cache_queries def test_process_cache_queries_basic(): n = 2 queries = [\\"SET 1 10\\", \\"SET 2 20\\", \\"GET 1\\", \\"SET 3 30\\", \\"GET 2\\", \\"GET 3\\"] assert process_cache_queries(n, queries) == [10, -1, 30] def test_process_cache_queries_no_get(): n = 2 queries = [\\"SET 1 10\\", \\"SET 2 20\\", \\"SET 3 30\\"] assert process_cache_queries(n, queries) == [] def test_process_cache_queries_all_get(): n = 2 queries = [\\"SET 1 10\\", \\"SET 2 20\\", \\"GET 1\\", \\"GET 2\\", \\"GET 3\\"] assert process_cache_queries(n, queries) == [10, 20, -1] def test_process_cache_queries_lru_evicts(): n = 3 queries = [\\"SET 1 10\\", \\"SET 2 20\\", \\"SET 3 30\\", \\"GET 1\\", \\"SET 4 40\\", \\"GET 2\\", \\"GET 3\\", \\"GET 4\\"] assert process_cache_queries(n, queries) == [10, -1, 30, 40] def test_process_cache_queries_same_key_updates(): n = 2 queries = [\\"SET 1 10\\", \\"SET 1 20\\", \\"GET 1\\", \\"SET 2 30\\", \\"GET 2\\"] assert process_cache_queries(n, queries) == [20, 30]","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity): self.capacity = capacity self.cache = OrderedDict() def get(self, key): if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def set(self, key, value): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def process_cache_queries(n, queries): cache = LRUCache(n) results = [] for query in queries: operation, x = query.split()[:2] if operation == 'GET': results.append(cache.get(int(x))) elif operation == 'SET': y = int(query.split()[2]) cache.set(int(x), y) return results"},{"question":"def canPartition(S: str, K: int) -> str: Determines if the string S can be partitioned into K palindromic substrings. >>> canPartition(\\"aabb\\", 2) \\"YES\\" >>> canPartition(\\"abc\\", 2) \\"NO\\" >>> canPartition(\\"aaa\\", 3) \\"YES\\"","solution":"def canPartition(S, K): Determines if the string S can be partitioned into K palindromic substrings. from collections import Counter # Check the length constraint if K > len(S): return \\"NO\\" # Count the occurrences for each character in the string counter = Counter(S) # Count the number of characters that have odd occurrences odd_count = sum(1 for count in counter.values() if count % 2 != 0) # It's only possible to have K palindromic substrings if the number of odd counts is at most K if odd_count > K: return \\"NO\\" return \\"YES\\""},{"question":"def maximum_subsequence_sum(n, k, array): Rotates the array k positions to the right and calculates the maximum sum of any subsequence. Params: - n (int): Number of elements in the array - k (int): Number of positions to rotate the array to the right - array (list): The original array of integers Returns: - int: Maximum sum of any subsequence from the rotated array >>> maximum_subsequence_sum(5, 2, [1, 2, 3, 4, 5]) 15 >>> maximum_subsequence_sum(4, 0, [5, 4, 3, 2]) 14 >>> maximum_subsequence_sum(6, 3, [1, 6, 3, 2, 7, 4]) 23 >>> maximum_subsequence_sum(3, 4, [1, 2, 3]) 6 >>> maximum_subsequence_sum(1, 0, [5]) 5 >>> maximum_subsequence_sum(5, 3, [2, 2, 2, 2, 2]) 10 >>> maximum_subsequence_sum(3, 3, [1, 2, 3]) 6","solution":"def maximum_subsequence_sum(n, k, array): Rotates the array k positions to the right and calculates the maximum sum of any subsequence. Params: - n (int): Number of elements in the array - k (int): Number of positions to rotate the array to the right - array (list): The original array of integers Returns: - int: Maximum sum of any subsequence from the rotated array # Rotate the array k positions to the right k = k % n # To handle cases where k >= n rotated_array = array[-k:] + array[:-k] # The maximum subsequence sum is the sum of all elements max_sum = sum(rotated_array) return max_sum"},{"question":"def is_safe_path(grid): Checks if there is at least one safe path from the top-left corner to the bottom-right corner of the grid. A '1' represents a safe square, while a '0' represents an unsafe one. Args: grid (List[List[int]]): NxN grid representing the map with safe and unsafe squares. Returns: str: \\"YES\\" if there is at least one safe path, otherwise \\"NO\\". Examples: >>> is_safe_path([ ... [1, 0, 0, 1], ... [1, 1, 0, 1], ... [0, 1, 1, 0], ... [1, 1, 1, 1] ... ]) 'YES' >>> is_safe_path([ ... [1, 1, 1], ... [0, 0, 1], ... [1, 1, 1] ... ]) 'YES' >>> is_safe_path([ ... [1, 1, 1], ... [0, 0, 0], ... [1, 1, 1] ... ]) 'NO' pass import pytest def test_single_element_grid_safe(): assert is_safe_path([[1]]) == \\"YES\\" def test_single_element_grid_unsafe(): assert is_safe_path([[0]]) == \\"NO\\" def test_simple_path_exists(): grid = [ [1, 0, 1], [1, 1, 0], [0, 1, 1] ] assert is_safe_path(grid) == \\"YES\\" def test_no_path_due_to_unsafe_squares(): grid = [ [1, 0, 1], [0, 0, 0], [1, 1, 1] ] assert is_safe_path(grid) == \\"NO\\" def test_all_squares_unsafe(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert is_safe_path(grid) == \\"NO\\" def test_path_around_unsafe_region(): grid = [ [1, 1, 1], [0, 0, 1], [1, 1, 1] ] assert is_safe_path(grid) == \\"YES\\"","solution":"from collections import deque def is_safe_path(grid): n = len(grid) if grid[0][0] == 0 or grid[-1][-1] == 0: return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, n-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\" def treasure_hunt(test_cases): results = [] for t in range(test_cases): n = int(input().strip()) grid = [list(map(int, input().strip().split())) for _ in range(n)] results.append(is_safe_path(grid)) return results def main(): T = int(input().strip()) results = treasure_hunt(T) for result in results: print(result)"},{"question":"from typing import List, Tuple def can_send_message(N: int, M: int, channels: List[Tuple[int, int]], S: int, T: int) -> str: Determine if it is possible to send a message from planet S to planet T using the communication channels. Arguments: N -- the number of planets M -- the number of directed communication channels channels -- list of tuples, where each tuple (u, v) represents a communication channel from planet u to planet v S -- source planet T -- target planet Returns: \\"Yes\\" if a message can be sent from S to T, otherwise \\"No\\" >>> can_send_message(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)], 1, 4) \\"Yes\\" >>> can_send_message(4, 3, [(1, 2), (2, 3), (3, 4)], 4, 1) \\"No\\" >>> can_send_message(5, 6, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 5)], 1, 5) \\"Yes\\" >>> can_send_message(1, 0, [], 1, 1) \\"Yes\\" >>> can_send_message(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)], 1, 6) \\"No\\"","solution":"def can_send_message(N, M, channels, S, T): from collections import deque, defaultdict graph = defaultdict(list) for u, v in channels: graph[u].append(v) visited = [False] * (N + 1) queue = deque([S]) while queue: node = queue.popleft() if node == T: return \\"Yes\\" if not visited[node]: visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: queue.append(neighbor) return \\"No\\""},{"question":"def minimum_commute_cost(N, M, options): Determines the minimum cost Alice can spend on her commute without exceeding the maximum allowable travel time. Arguments: N -- Number of commuting options (int) M -- Maximum allowable travel time (int) options -- List of tuples where each tuple contains (travel time, cost) Returns: Minimum cost for commuting without exceeding maximum travel time, or -1 if not possible. >>> minimum_commute_cost(5, 60, [(30, 10), (45, 20), (60, 30), (75, 40), (90, 50)]) 10 >>> minimum_commute_cost(3, 50, [(60, 20), (70, 25), (80, 30)]) -1 >>> minimum_commute_cost(4, 100, [(10, 50), (20, 30), (30, 40), (40, 10)]) 10 >>> minimum_commute_cost(4, 5, [(10, 50), (20, 30), (30, 40), (40, 10)]) -1 >>> minimum_commute_cost(3, 25, [(15, 100), (25, 50), (25, 40)]) 40","solution":"def minimum_commute_cost(N, M, options): Determines the minimum cost Alice can spend on her commute without exceeding the maximum allowable travel time. Arguments: N -- Number of commuting options (int) M -- Maximum allowable travel time (int) options -- List of tuples where each tuple contains (travel time, cost) Returns: Minimum cost for commuting without exceeding maximum travel time, or -1 if not possible. min_cost = float('inf') for travel_time, cost in options: if travel_time <= M: min_cost = min(min_cost, cost) return min_cost if min_cost != float('inf') else -1 # Example usage: # N, M = 5, 60 # options = [(30, 10), (45, 20), (60, 30), (75, 40), (90, 50)] # print(minimum_commute_cost(N, M, options)) # Should output 10"},{"question":"def max_consecutive_digit_sum(s: str, k: int) -> int: Returns the maximum sum of k consecutive digits in the string s. Parameters: s (str): A string containing digits. k (int): The number of consecutive digits to consider. Returns: int: The maximum sum of k consecutive digits. Examples: >>> max_consecutive_digit_sum(\\"123456789\\", 3) 24 >>> max_consecutive_digit_sum(\\"5\\", 1) 5 >>> max_consecutive_digit_sum(\\"0000000\\", 3) 0 >>> max_consecutive_digit_sum(\\"9876543210\\", 10) 45 >>> max_consecutive_digit_sum(\\"123\\", 5) 0 >>> max_consecutive_digit_sum(\\"402151240\\", 2) 6 >>> max_consecutive_digit_sum(\\"111111\\", 3) 3 >>> max_consecutive_digit_sum(\\"98765432123456789\\", 5) 35","solution":"def max_consecutive_digit_sum(s, k): Returns the maximum sum of k consecutive digits in the string s. Parameters: s (str): A string containing digits. k (int): The number of consecutive digits to consider. Returns: int: The maximum sum of k consecutive digits. max_sum = 0 n = len(s) for i in range(n - k + 1): current_sum = sum(int(s[j]) for j in range(i, i + k)) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def is_valid_roman_numeral(numeral: str) -> bool: Determines if the given string is a valid Roman numeral string and falls within the range of 1 to 3999. >>> is_valid_roman_numeral(\\"XII\\") True >>> is_valid_roman_numeral(\\"MMMCMXCIX\\") True >>> is_valid_roman_numeral(\\"IV\\") True >>> is_valid_roman_numeral(\\"IIII\\") False >>> is_valid_roman_numeral(\\"ABC\\") False","solution":"def is_valid_roman_numeral(numeral: str) -> bool: Determines if the given string is a valid Roman numeral string and falls within the range of 1 to 3999. import re # Regular expression for valid Roman numerals within 1 to 3999. roman_numeral_pattern = re.compile( ^ # beginning of the string M{0,3} # Match thousands - 0 to 3000 (CM|CD|D?C{0,3}) # Match hundreds - 0 to 900 (XC|XL|L?X{0,3}) # Match tens - 0 to 90 (IX|IV|V?I{0,3}) # Match units - 0 to 9 # end of the string , re.VERBOSE) # If numeral is empty or not matching the pattern then return False if not numeral or not roman_numeral_pattern.match(numeral): return False return True"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def shortest_paths(N: int, M: int, edges: List[Tuple[int, int, int]], S: int) -> List[int]: Find the shortest path from the start node S to every other node in a weighted undirected graph with N nodes and M edges. Args: - N (int): The number of nodes. - M (int): The number of edges. - edges (List[Tuple[int, int, int]]): The list of edges, where each edge is represented as a tuple (u, v, w) indicating an edge between nodes u and v with weight w. - S (int): The start node. Returns: List[int]: A list of N integers where the ith integer is the minimum distance from the start node S to the ith node. If there is no path from S to the ith node, the distance should be -1. Example: >>> shortest_paths(4, 4, [(1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 7)], 1) [0, 1, 3, 10] >>> shortest_paths(3, 2, [(1, 2, 3), (2, 3, 4)], 1) [0, 3, 7]","solution":"import heapq from collections import defaultdict def shortest_paths(N, M, edges, S): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) distances = {i: float('inf') for i in range(1, N + 1)} distances[S] = 0 priority_queue = [(0, S)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [dist if dist != float('inf') else -1 for dist in distances.values()] # Sample input for an example N = 4 M = 4 edges = [ (1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 7) ] S = 1 # This would produce: [0, 1, 3, 10] print(shortest_paths(N, M, edges, S))"},{"question":"def sort_students(records): Sorts the list of student records first by their house, and then by their name. Args: records: List[Tuple[str, str]] - A list of tuples where each tuple contains a student's name and house. Returns: List[Tuple[str, str]] - The list of student records sorted by house and then by name. Example: >>> records = [ ... (\\"Harry\\", \\"Gryffindor\\"), ... (\\"Hermione\\", \\"Gryffindor\\"), ... (\\"Ron\\", \\"Gryffindor\\"), ... (\\"Draco\\", \\"Slytherin\\"), ... (\\"Cedric\\", \\"Hufflepuff\\") ... ] >>> sort_students(records) [ (\\"Harry\\", \\"Gryffindor\\"), (\\"Hermione\\", \\"Gryffindor\\"), (\\"Ron\\", \\"Gryffindor\\"), (\\"Cedric\\", \\"Hufflepuff\\"), (\\"Draco\\", \\"Slytherin\\") ] pass # Unit tests def test_sort_students_example(): records = [ (\\"Harry\\", \\"Gryffindor\\"), (\\"Hermione\\", \\"Gryffindor\\"), (\\"Ron\\", \\"Gryffindor\\"), (\\"Draco\\", \\"Slytherin\\"), (\\"Cedric\\", \\"Hufflepuff\\") ] expected = [ (\\"Harry\\", \\"Gryffindor\\"), (\\"Hermione\\", \\"Gryffindor\\"), (\\"Ron\\", \\"Gryffindor\\"), (\\"Cedric\\", \\"Hufflepuff\\"), (\\"Draco\\", \\"Slytherin\\") ] assert sort_students(records) == expected def test_sort_students_single_house(): records = [ (\\"Zacharias\\", \\"Hufflepuff\\"), (\\"Hannah\\", \\"Hufflepuff\\"), (\\"Ernie\\", \\"Hufflepuff\\") ] expected = [ (\\"Ernie\\", \\"Hufflepuff\\"), (\\"Hannah\\", \\"Hufflepuff\\"), (\\"Zacharias\\", \\"Hufflepuff\\") ] assert sort_students(records) == expected def test_sort_students_mixed_houses(): records = [ (\\"Seamus\\", \\"Gryffindor\\"), (\\"Luna\\", \\"Ravenclaw\\"), (\\"Cho\\", \\"Ravenclaw\\"), (\\"Pansy\\", \\"Slytherin\\"), (\\"Blaise\\", \\"Slytherin\\") ] expected = [ (\\"Seamus\\", \\"Gryffindor\\"), (\\"Cho\\", \\"Ravenclaw\\"), (\\"Luna\\", \\"Ravenclaw\\"), (\\"Blaise\\", \\"Slytherin\\"), (\\"Pansy\\", \\"Slytherin\\") ] assert sort_students(records) == expected def test_sort_students_all_names_same_house(): records = [ (\\"Dean\\", \\"Gryffindor\\"), (\\"Seamus\\", \\"Gryffindor\\"), (\\"Parvati\\", \\"Gryffindor\\"), (\\"Lavender\\", \\"Gryffindor\\") ] expected = [ (\\"Dean\\", \\"Gryffindor\\"), (\\"Lavender\\", \\"Gryffindor\\"), (\\"Parvati\\", \\"Gryffindor\\"), (\\"Seamus\\", \\"Gryffindor\\") ] assert sort_students(records) == expected","solution":"def sort_students(records): Sorts the list of student records first by their house, and then by their name. sorted_records = sorted(records, key=lambda x: (x[1], x[0])) return sorted_records # Example usage: # records = [ # (\\"Harry\\", \\"Gryffindor\\"), # (\\"Hermione\\", \\"Gryffindor\\"), # (\\"Ron\\", \\"Gryffindor\\"), # (\\"Draco\\", \\"Slytherin\\"), # (\\"Cedric\\", \\"Hufflepuff\\") # ] # sorted_students = sort_students(records) # for student in sorted_students: # print(f'{student[0]} {student[1]}')"},{"question":"def min_max_diff_in_subarray(arr, N, K): Finds the minimum possible value of the maximum difference between any two elements in a subarray of length exactly K. >>> min_max_diff_in_subarray([1, 3, 6, 4, 1, 2], 6, 3) 1 >>> min_max_diff_in_subarray([1, 2, 3, 4, 5], 5, 2) 1 >>> min_max_diff_in_subarray([10, 100, 1000, 10000], 4, 3) 990 >>> min_max_diff_in_subarray([5, 8, 3], 3, 2) 2 >>> min_max_diff_in_subarray([2, 2, 2, 2], 4, 2) 0 >>> min_max_diff_in_subarray([4, 9, 1, 7, 2, 6, 5], 7, 4) 3","solution":"def min_max_diff_in_subarray(arr, N, K): Finds the minimum possible value of the maximum difference between any two elements in a subarray of length exactly K. if K == 1: return 0 arr.sort() min_max_diff = float('inf') for i in range(N - K + 1): current_diff = arr[i + K - 1] - arr[i] min_max_diff = min(min_max_diff, current_diff) return min_max_diff"},{"question":"from typing import List def top_k_frequent_requests(n: int, k: int, requests: List[str]) -> List[str]: Returns the top k most frequent network requests in descending order of their frequency. If multiple requests have the same frequency, they are sorted lexicographically. >>> top_k_frequent_requests(7, 3, [\\"google.com\\", \\"facebook.com\\", \\"google.com\\", \\"yahoo.com\\", \\"google.com\\", \\"facebook.com\\", \\"bing.com\\"]) ['google.com', 'facebook.com', 'bing.com'] >>> top_k_frequent_requests(5, 2, [\\"siteA.com\\", \\"siteB.com\\", \\"siteC.com\\", \\"siteB.com\\", \\"siteC.com\\"]) ['siteB.com', 'siteC.com']","solution":"from collections import Counter def top_k_frequent_requests(n, k, requests): Returns the top k most frequent network requests in descending order of their frequency. If multiple requests have the same frequency, they are sorted lexicographically. request_counter = Counter(requests) sorted_requests = sorted(request_counter.items(), key=lambda x: (-x[1], x[0])) top_k_requests = [request for request, _ in sorted_requests[:k]] return top_k_requests"},{"question":"def can_remove_corridors(n: int, m: int, corridors: List[Tuple[int, int]]) -> List[int]: Given the number of rooms n and the list of corridors m, determine whether each corridor can be removed without disconnecting the castle. Parameters: n (int): The number of rooms. m (int): The number of corridors. corridors (List[Tuple[int, int]]): List of corridors represented as pairs of room numbers. Returns: List[int]: List of 1s and 0s indicating whether each corridor can be removed (1 if it can be removed, 0 if not). Example: >>> can_remove_corridors(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) [1, 1, 1, 1] >>> can_remove_corridors(2, 1, [(1, 2)]) [0]","solution":"def can_remove_corridors(n, m, corridors): from collections import defaultdict, deque def is_connected(adj_list): visited = set() queue = deque([1]) visited.add(1) while queue: node = queue.popleft() for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return len(visited) == n # Build adjacency list adj_list = defaultdict(list) for u, v in corridors: adj_list[u].append(v) adj_list[v].append(u) results = [] for u, v in corridors: # Remove the corridor adj_list[u].remove(v) adj_list[v].remove(u) # Check if the castle is still connected if is_connected(adj_list): results.append(1) else: results.append(0) # Add the corridor back adj_list[u].append(v) adj_list[v].append(u) return results"},{"question":"def can_form_pairs(N: int) -> str: Determines if it is possible to form pairs with the given number of team members N. Parameters: - N (int): The number of team members. Returns: - str: \\"Yes\\" if it is possible to form pairs with all members, otherwise \\"No\\". >>> can_form_pairs(4) \\"Yes\\" >>> can_form_pairs(5) \\"No\\"","solution":"def can_form_pairs(N): Determines if it is possible to form pairs with the given number of team members N. Parameters: - N (int): The number of team members. Returns: - str: \\"Yes\\" if it is possible to form pairs with all members, otherwise \\"No\\". if N % 2 == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def temperature_span(n: int, temps: List[int]) -> List[int]: Returns an array of spans of temperatures over the period of days. :param n: Number of days :param temps: List of temperatures recorded each day :return: List of spans for each day >>> temperature_span(7, [100, 80, 60, 70, 60, 75, 85]) [1, 1, 1, 2, 1, 4, 6] >>> temperature_span(1, [42]) [1] >>> temperature_span(2, [2, 4]) [1, 2] >>> temperature_span(2, [5, 3]) [1, 1] >>> temperature_span(5, [50, 50, 50, 50, 50]) [1, 2, 3, 4, 5] >>> temperature_span(6, [50, 40, 40, 60, 70, 80]) [1, 1, 2, 4, 5, 6] >>> temperature_span(10, [30, 50, 60, 70, 50, 75, 80, 60, 85, 90]) [1, 2, 3, 4, 1, 6, 7, 1, 9, 10]","solution":"def temperature_span(n, temps): Returns an array of spans of temperatures over the period of days. :param n: Number of days :param temps: List of temperatures recorded each day :return: List of spans for each day result = [0] * n # Create a result list of spans initialized to 0 stack = [] # Stack to keep indexes of the temps array for i in range(n): # Pop elements from the stack while stack is not empty and the top of the stack is less or equal to the current temperature while stack and temps[stack[-1]] <= temps[i]: stack.pop() # If stack is empty, it means there are no previous higher temperature days result[i] = i + 1 if not stack else i - stack[-1] # Push index of the current temperature onto the stack stack.append(i) return result"},{"question":"from typing import List def generate_permutations(n: int) -> List[str]: Generates all permutations of the first n letters of the English alphabet in sorted order. Args: n: An integer (2 ≤ n ≤ 20) Returns: A list of strings, each representing a permutation of the first n letters. Examples: >>> generate_permutations(3) ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_permutations(2) ['ab', 'ba'] Raises: ValueError: If n is not in the range 2 ≤ n ≤ 20.","solution":"from itertools import permutations def generate_permutations(n): Generates all permutations of the first n letters of the English alphabet in sorted order. Args: n: An integer (2 ≤ n ≤ 20) Returns: A list of strings, each representing a permutation of the first n letters. if not (2 <= n <= 20): raise ValueError(\\"The value of n should be in the range 2 ≤ n ≤ 20.\\") alphabet = 'abcdefghijklmnopqrstuvwxyz' selected_letters = alphabet[:n] perm = [''.join(p) for p in permutations(selected_letters)] return sorted(perm)"},{"question":"def can_organize_books(n: int, k: int) -> str: Determines if it's possible to organize n books into k sections with equal sums of IDs. >>> can_organize_books(6, 3) 'YES' >>> can_organize_books(5, 2) 'NO' >>> can_organize_books(10, 1) 'YES' >>> can_organize_books(5, 5) 'YES' >>> can_organize_books(1000, 250) 'YES' >>> can_organize_books(3, 10) 'NO'","solution":"def can_organize_books(n, k): Determines if it's possible to organize n books into k sections with equal sums of IDs. total_sum = n * (n + 1) // 2 # Sum of the first n natural numbers if total_sum % k == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def run_quiz(questions_and_answers): Runs a quiz game based on a list of (question, answer) tuples. def parse_input(input_data): Parses the input data to extract the number of questions and a list of (question, answer) tuples. >>> parse_input(\\"3nWhat is the capital of France?,ParisnWhat is 2+2?,4nWho wrote 'Hamlet'?,Shakespeare\\") [(\\"What is the capital of France?\\", \\"Paris\\"), (\\"What is 2+2?\\", \\"4\\"), (\\"Who wrote 'Hamlet'?\\", \\"Shakespeare\\")]","solution":"def run_quiz(questions_and_answers): Runs a quiz game based on a list of (question, answer) tuples. num_correct = 0 for i, (question, answer) in enumerate(questions_and_answers): user_answer = input(f\\"Question {i + 1}: {question} \\") if user_answer == answer: print(f\\"Question {i + 1}: Correct\\") num_correct += 1 else: print(f\\"Question {i + 1}: Incorrect\\") print(f\\"You got {num_correct} out of {len(questions_and_answers)} correct!\\") def parse_input(input_data): Parses the input data to extract the number of questions and a list of (question, answer) tuples. lines = input_data.strip().split('n') n = int(lines[0]) questions_and_answers = [tuple(line.split(',')) for line in lines[1:n + 1]] return questions_and_answers"},{"question":"def min_energy_to_sort_buildings(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Compute the minimum energy required to rearrange the buildings into non-decreasing order by counting the number of swaps needed. >>> min_energy_to_sort_buildings(3, [ (5, [4, 3, 2, 1, 5]), (4, [4, 3, 5, 1]), (3, [3, 3, 3]) ]) [6, 4, 0] >>> min_energy_to_sort_buildings(1, [ (6, [1, 2, 3, 4, 5, 6]) ]) [0] >>> min_energy_to_sort_buildings(2, [ (7, [7, 6, 5, 4, 3, 2, 1]), (4, [1, 3, 2, 4]) ]) [21, 1] >>> min_energy_to_sort_buildings(1, [ (5, [2, 3, 4, 5, 6]) ]) [0] >>> min_energy_to_sort_buildings(2, [ (3, [3, 1, 2]), (4, [4, 1, 4, 1]) ]) [2, 3]","solution":"def min_energy_to_sort_buildings(t, test_cases): This function computes the minimum energy required to rearrange the buildings into non-decreasing order by counting the number of swaps needed using bubble sort strategy. results = [] for i in range(t): n, heights = test_cases[i] energy = 0 swapped = True while swapped: swapped = False for j in range(n - 1): if heights[j] > heights[j + 1]: heights[j], heights[j + 1] = heights[j + 1], heights[j] energy += 1 swapped = True results.append(energy) return results"},{"question":"def minCost(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum cost required to connect all buildings in the city represented by a binary tree. Args: n : int : number of buildings edges : List of Tuple[int, int, int] : A list of tuples where each tuple contains 3 integers representing an edge between two buildings and the cost of installation. Returns: int : the minimum cost to connect all buildings. Examples: >>> minCost(5, [(1, 2, 4), (1, 3, 3), (2, 4, 2), (3, 5, 6)]) 15 >>> minCost(3, [(1, 2, 1), (2, 3, 2)]) 3 # Implementation here def test_minCost(): assert minCost(5, [(1, 2, 4), (1, 3, 3), (2, 4, 2), (3, 5, 6)]) == 15 assert minCost(3, [(1, 2, 1), (2, 3, 2)]) == 3 assert minCost(4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 2)]) == 4 assert minCost(2, [(1, 2, 5)]) == 5 assert minCost(6, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1)]) == 5 assert minCost(5, [(1, 2, 4), (1, 3, 3), (2, 4, 2), (2, 5, 6), (3, 5, 1)]) == 10 if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def minCost(n, edges): Function to compute the minimum cost required to connect all buildings in a binary tree like network. Args: n : int : number of buildings edges : List of Tuple[int, int, int] : A list of tuples where each tuple contains 3 integers u, v and w representing an edge between building u and v with cost w. Returns: int : the minimum cost to connect all buildings. # We can use Kruskal's algorithm to find the Minimum Spanning Tree (MST). # Sort edges by their weight edges.sort(key=lambda edge: edge[2]) # Helper function to find the parent of a node in the disjoint-set def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to apply union of two sets def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Initialize MST cost mst_cost = 0 # Create parent and rank arrays for disjoint-set parent = [] rank = [] # Initialize disjoint set for node in range(n): parent.append(node) rank.append(0) # Iterate through all sorted edges for edge in edges: u, v, w = edge u = u - 1 # Convert to 0-based index v = v - 1 # Convert to 0-based index uroot = find(parent, u) vroot = find(parent, v) # If including this edge doesn't form a cycle if uroot != vroot: # Include it in the result mst_cost += w union(parent, rank, uroot, vroot) return mst_cost"},{"question":"def find_max_sum(nums: List[int]) -> int: Returns the maximum sum that can be obtained by summing a contiguous subarray. :param nums: List of integers :return: Maximum sum of a contiguous subarray >>> find_max_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> find_max_sum([-3, -2, -1, -4]) -1 >>> find_max_sum([5]) 5 >>> find_max_sum([1, -2, 3, 10, -4, 7, 2, -5]) 18 >>> find_max_sum([2, 3, 4, 1, 5]) 15 >>> find_max_sum([0, 0, 0, 0]) 0 def process_input(input_line: str) -> int: Processes input string of integers, and returns maximum sum of a contiguous subarray. :param input_line: A string containing integers separated by spaces. :return: Maximum sum of a contiguous subarray >>> process_input(\\"-2 1 -3 4 -1 2 1 -5 4\\") 6 >>> process_input(\\"1 -2 3 10 -4 7 2 -5\\") 18 >>> process_input(\\"-3 -2 -1 -4\\") -1","solution":"def find_max_sum(nums): Returns the maximum sum of a contiguous subarray. :param nums: List of integers. :return: Integer, the maximum sum. if not nums: return 0 # Initialize our variables max_sum = nums[0] # Max sum so far current_sum = nums[0] # Current sum of the subarray # Iterate over the array starting from the second element for num in nums[1:]: # Update current_sum to be either the current number itself or # the current_sum + current number, whichever is larger current_sum = max(num, current_sum + num) # Update max_sum if current_sum is larger than max_sum max_sum = max(max_sum, current_sum) return max_sum # Helper function to handle input and output def process_input(input_line): nums = list(map(int, input_line.strip().split())) return find_max_sum(nums)"},{"question":"def max_non_adjacent_sum(lst: List[int]) -> int: Returns the maximum possible sum of the list elements such that no two elements chosen in the sum are adjacent in the list. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 >>> max_non_adjacent_sum([2, 1, 4, 9]) == 11","solution":"def max_non_adjacent_sum(lst): Returns the maximum possible sum of the list elements such that no two elements chosen in the sum are adjacent in the list. if not lst: return 0 incl = 0 # Max sum including the previous element excl = 0 # Max sum excluding the previous element for num in lst: # Current max excluding the current element new_excl = max(excl, incl) # Current max including the current element incl = excl + num excl = new_excl # Return max of incl and excl return max(incl, excl)"},{"question":"def fibonacci_upto_n(N): Returns the Fibonacci sequence numbers less than N. >>> fibonacci_upto_n(10) [0, 1, 1, 2, 3, 5, 8] >>> fibonacci_upto_n(1) [0] >>> fibonacci_upto_n(2) [0, 1, 1] >>> fibonacci_upto_n(21) [0, 1, 1, 2, 3, 5, 8, 13]","solution":"def fibonacci_upto_n(N): Returns the Fibonacci sequence numbers less than N. sequence = [] a, b = 0, 1 while a < N: sequence.append(a) a, b = b, a + b return sequence"},{"question":"def min_presses(n: int, speeds: List[int], s: int, t: int) -> int: Calculate the minimum number of presses required to reach from floor s to floor t. Parameters: n (int): Number of floors. speeds (list of int): Speed of the elevator at each floor. s (int): Starting floor. t (int): Target floor. Returns: int: Minimum number of presses required. Examples: >>> min_presses(5, [1, 2, 3, 2, 1], 1, 3) 3 >>> min_presses(4, [1, 1, 1, 1], 2, 4) 2","solution":"def min_presses(n, speeds, s, t): Calculate the minimum number of presses required to reach from floor s to floor t. Parameters: n (int): Number of floors. speeds (list of int): Speed of the elevator at each floor. s (int): Starting floor. t (int): Target floor. Returns: int: Minimum number of presses required. presses = 0 for i in range(s, t): presses += speeds[i-1] return presses"},{"question":"from typing import List def search(nums: List[int], target: int) -> int: Search for the target value in a rotated sorted array. Args: nums (List[int]): A list of integers sorted in ascending order, which is rotated at an unknown pivot. target (int): The value to search for. Returns: int: The index of the target if found, otherwise -1. def test_search_found(): assert search([4,5,6,7,0,1,2], 0) == 4 assert search([4,5,6,7,0,1,2], 4) == 0 assert search([4,5,6,7,0,1,2], 7) == 3 def test_search_not_found(): assert search([4,5,6,7,0,1,2], 3) == -1 assert search([1], 0) == -1 def test_search_single_element(): assert search([1], 1) == 0 def test_search_no_rotation(): assert search([1,2,3,4,5,6,7], 4) == 3 assert search([1,2,3,4,5,6,7], 8) == -1 def test_search_full_rotation(): assert search([1,2,3,4,5,6,7], 1) == 0 assert search([1,2,3,4,5,6,7], 7) == 6","solution":"from typing import List def search(nums: List[int], target: int) -> int: Search for the target value in a rotated sorted array. Args: nums (List[int]): A list of integers sorted in ascending order, which is rotated at an unknown pivot. target (int): The value to search for. Returns: int: The index of the target if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # left part is sorted if nums[left] <= target < nums[mid]: # target in the left part right = mid - 1 else: left = mid + 1 else: # right part is sorted if nums[mid] < target <= nums[right]: # target in the right part left = mid + 1 else: right = mid - 1 return -1"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n matrix from the top-left corner to the bottom-right corner, moving only right or down. :param m: Number of rows :param n: Number of columns :return: Number of unique paths >>> unique_paths(2, 2) 2 >>> unique_paths(3, 2) 3 >>> unique_paths(3, 7) 28 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1","solution":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n matrix from the top-left corner to the bottom-right corner, moving only right or down. :param m: Number of rows :param n: Number of columns :return: Number of unique paths # using dynamic programming to solve the problem # Create a 2D list (m x n) filled with 1s because there's only one way to reach cells in the first row and first column dp = [[1] * n for _ in range(m)] # Calculate paths for each cell in the matrix for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the number of unique paths return dp[-1][-1]"},{"question":"def can_construct_palindrome(s: str, k: int) -> str: Determine if you can construct a palindrome by rearranging the characters in the string s and inserting k or fewer additional characters anywhere in the string. >>> can_construct_palindrome(\\"annb\\", 1) \\"YES\\" >>> can_construct_palindrome(\\"car\\", 1) \\"YES\\" >>> can_construct_palindrome(\\"aabbcc\\", 0) \\"YES\\" >>> can_construct_palindrome(\\"abcdef\\", 2) \\"NO\\"","solution":"def can_construct_palindrome(s, k): from collections import Counter # Count occurrences of each character char_counts = Counter(s) # Count characters with odd occurrences odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # Check if we can turn the string into a palindrome with k or fewer additional characters return \\"YES\\" if odd_count // 2 <= k else \\"NO\\""},{"question":"def update_employees(initial_data, updates): Updates the employee data based on the input and returns the required messages. >>> update_employees([ '6', 'Landon 5', 'Bateman 9', 'Cardoni 2', 'Ellison 7', 'Alford 1', 'Ponder 3' ], [ '2', '- Ellison 4', '+ Truong 6' ]) ['Ellison is working diligently.', 'Truong is now contributing.'] >>> update_employees([ '1', 'Smith 10' ], [ '1', '- Smith 5' ]) ['Smith is working diligently.'] >>> update_employees([ '3', 'Jones 8', 'Davis 4', 'Garcia 6' ], [ '3', '+ Thompson 7', '- Davis 2', '+ Lee 5' ]) ['Thompson is now contributing.', 'Davis is working diligently.', 'Lee is now contributing.'] >>> update_employees(['2', 'Brown 8', 'Williams 3'], ['0']) []","solution":"def update_employees(initial_data, updates): Updates the employee data based on the input and returns the required messages. # parse initial data n = int(initial_data[0].strip()) employees = {} for i in range(1, n + 1): name, workload = initial_data[i].split() employees[name] = int(workload) # parse updates m = int(updates[0].strip()) messages = [] for i in range(1, m + 1): update = updates[i].split() op = update[0] name = update[1] amount = int(update[2]) if op == '-': if name in employees: employees[name] -= amount messages.append(f\\"{name} is working diligently.\\") elif op == '+': employees[name] = amount messages.append(f\\"{name} is now contributing.\\") return messages"},{"question":"def capitalize_first_letter_of_each_word(T: int, test_cases: List[str]) -> List[str]: (int, List[str]) -> List[str] Given an integer T and a list of strings, capitalize the first letter of each word in each string. >>> capitalize_first_letter_of_each_word(1, [\\"hello world\\"]) [\\"Hello World\\"] >>> capitalize_first_letter_of_each_word(1, [\\"this is a test\\"]) [\\"This Is A Test\\"] >>> capitalize_first_letter_of_each_word(2, [\\"hello world\\", \\"this is a test\\"]) [\\"Hello World\\", \\"This Is A Test\\"] >>> capitalize_first_letter_of_each_word(1, [\\"\\"]) [\\"\\"] >>> capitalize_first_letter_of_each_word(1, [\\"hElLo wOrLd\\"]) [\\"Hello World\\"] >>> capitalize_first_letter_of_each_word(1, [\\" hello world \\"]) [\\" Hello World \\"] >>> capitalize_first_letter_of_each_word(1, [\\"word\\"]) [\\"Word\\"] >>> capitalize_first_letter_of_each_word(1, [\\"HELLO WORLD\\"]) [\\"Hello World\\"]","solution":"def capitalize_first_letter_of_each_word(T, test_cases): This function receives the number of test cases and a list of strings. It returns a list of strings with the first letter of each word capitalized. capitalized_sentences = [] for s in test_cases: capitalized_sentences.append(' '.join(word.capitalize() for word in s.split(' '))) return capitalized_sentences"},{"question":"def min_hops(A: int, B: int, C: int, D: int) -> int: Zappy the kangaroo loves hopping around the Outback. He has a peculiar way of hopping: in every hop, he can move exactly A, B, or C meters forward. Now, he wants to reach exactly D meters, starting from 0 meters. Determine the minimum number of hops Zappy needs to reach exactly D meters. If it's not possible to reach exactly D meters using any combination of A, B, and C hops, return \\"Impossible\\". >>> min_hops(2, 3, 5, 11) 3 >>> min_hops(4, 6, 8, 15) 'Impossible' >>> min_hops(1, 2, 3, 5) 2 # Implement the function here from collections import deque def test_min_hops_example_1(): assert min_hops(2, 3, 5, 11) == 3 def test_min_hops_example_2(): assert min_hops(4, 6, 8, 15) == 'Impossible' def test_min_hops_example_3(): assert min_hops(1, 2, 3, 5) == 2 def test_min_hops_impossible_case(): assert min_hops(2, 4, 6, 7) == 'Impossible' def test_min_hops_exact_hop(): assert min_hops(1, 2, 3, 1) == 1 def test_min_hops_large_distance(): assert min_hops(10, 20, 30, 60) == 2 def test_min_hops_multiple_paths(): assert min_hops(1, 2, 5, 7) == 2","solution":"from collections import deque def min_hops(A, B, C, D): Returns the minimum number of hops required to reach exactly D meters, or \\"Impossible\\" if it is not possible. # Queue for BFS containing tuples (current_distance, number_of_hops) queue = deque([(0, 0)]) visited = set() while queue: current_distance, hops = queue.popleft() # If we've reached the exact distance D if current_distance == D: return hops for hop in (A, B, C): next_distance = current_distance + hop if next_distance <= D and next_distance not in visited: visited.add(next_distance) queue.append((next_distance, hops + 1)) return \\"Impossible\\""},{"question":"from typing import List def find_minimum_distance(n: int, distances: List[List[int]]) -> int: Determine the shortest possible path that visits each city exactly once and returns to the starting city. Args: n (int): The number of cities. distances (List[List[int]]): A matrix representing the distances between cities. Returns: int: The minimum distance to visit all cities and return to the starting city. Examples: >>> find_minimum_distance(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> find_minimum_distance(3, [[0, 5, 9], [5, 0, 7], [9, 7, 0]]) 21","solution":"from itertools import permutations def find_minimum_distance(n, distances): # Generate all possible permutations of city visits cities = list(range(n)) min_distance = float('inf') for perm in permutations(cities): current_distance = 0 for i in range(n): current_distance += distances[perm[i]][perm[(i+1) % n]] min_distance = min(min_distance, current_distance) return min_distance"},{"question":"def categorize_students(N: int, scores: List[int]) -> Tuple[int, int, int]: Categorizes student scores into 'Excellent', 'Good', and 'Needs Improvement'. >>> categorize_students(5, [90, 75, 45, 88, 62]) (2, 2, 1) >>> categorize_students(0, []) (0, 0, 0) >>> categorize_students(3, [85, 90, 100]) (3, 0, 0) >>> categorize_students(4, [60, 70, 80, 84]) (0, 4, 0) >>> categorize_students(3, [0, 50, 59]) (0, 0, 3) >>> categorize_students(6, [85, 95, 70, 50, 60, 75]) (2, 3, 1) # Define the counts for each category excellent_count = 0 good_count = 0 needs_improvement_count = 0 # Categorize each score for score in scores: if score >= 85: excellent_count += 1 elif 60 <= score < 85: good_count += 1 else: needs_improvement_count += 1 return (excellent_count, good_count, needs_improvement_count)","solution":"def categorize_students(N, scores): Categorizes student scores into 'Excellent', 'Good', and 'Needs Improvement'. Parameters: N (int): The number of students. scores (list of int): The list of scores of the students. Returns: tuple: A tuple containing counts of 'Excellent', 'Good', and 'Needs Improvement'. excellent_count = 0 good_count = 0 needs_improvement_count = 0 for score in scores: if score >= 85: excellent_count += 1 elif 60 <= score < 85: good_count += 1 else: needs_improvement_count += 1 return (excellent_count, good_count, needs_improvement_count)"},{"question":"class SegmentTree: def __init__(self, data): Initialize a segment tree with the given data. self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Builds the segment tree from the given data. pass def update_range(self, l, r, val): Updates the segment tree for the range l to r with the value val. pass def update(self, index, val): Updates the segment tree at the given index with the value val. pass def query(self, l, r): Queries the maximum value in the range l to r. pass def process_queries(n, q, array, queries): Processes the given queries on the array. >>> n = 5 >>> q = 4 >>> array = [1, 2, 3, 4, 5] >>> queries = [ ... [2, 1, 5], ... [1, 2, 4, 10], ... [2, 1, 5], ... [2, 2, 4] ... ] >>> process_queries(n, q, array, queries) [5, 10, 10] pass","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update_range(self, l, r, val): for i in range(l, r + 1): self.update(i, val) def update(self, index, val): pos = index + self.n self.tree[pos] = val while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l, r): l += self.n r += self.n + 1 max_val = float('-inf') while l < r: if l % 2: max_val = max(max_val, self.tree[l]) l += 1 if r % 2: r -= 1 max_val = max(max_val, self.tree[r]) l //= 2 r //= 2 return max_val def process_queries(n, q, array, queries): seg_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: _, l, r, x = query seg_tree.update_range(l - 1, r - 1, x) elif query[0] == 2: _, l, r = query results.append(seg_tree.query(l - 1, r - 1)) return results"},{"question":"def classify_triangle(a: int, b: int, c: int) -> str: Classifies a triangle based on its side lengths. Parameters: a (int): Side length a of the triangle. b (int): Side length b of the triangle. c (int): Side length c of the triangle. Returns: str: \\"equilateral\\" if all sides are equal, \\"isosceles\\" if exactly two sides are equal, \\"scalene\\" if all sides are different, \\"not a triangle\\" if the sides do not form a valid triangle. >>> classify_triangle(2, 2, 2) 'equilateral' >>> classify_triangle(2, 2, 3) 'isosceles' >>> classify_triangle(2, 3, 4) 'scalene' >>> classify_triangle(1, 1, 2) 'not a triangle'","solution":"def classify_triangle(a, b, c): Classifies a triangle based on its side lengths. Parameters: a (int): Side length a of the triangle. b (int): Side length b of the triangle. c (int): Side length c of the triangle. Returns: str: \\"equilateral\\" if all sides are equal, \\"isosceles\\" if exactly two sides are equal, \\"scalene\\" if all sides are different, \\"not a triangle\\" if the sides do not form a valid triangle. # Check if the sides can form a triangle if a + b <= c or b + c <= a or c + a <= b: return \\"not a triangle\\" # Check for equilateral triangle if a == b == c: return \\"equilateral\\" # Check for isosceles triangle if a == b or b == c or c == a: return \\"isosceles\\" # If it is not equilateral or isosceles, it is scalene return \\"scalene\\""},{"question":"def minimum_total_time(t: int, f: int, v: int) -> int: Computes the minimum total time required to process t items with a fixed overhead time f per batch and variable time v per item. >>> minimum_total_time(1000, 10, 5) 5010 >>> minimum_total_time(20, 15, 1) 35 # Your implementation here from solution import minimum_total_time def test_example_1(): assert minimum_total_time(1000, 10, 5) == 5010 def test_example_2(): assert minimum_total_time(20, 15, 1) == 35 def test_single_item(): assert minimum_total_time(1, 10, 5) == 15 def test_all_zeroes(): assert minimum_total_time(0, 0, 0) == 0 # Technically not a valid input but for boundary testing def test_large_values(): assert minimum_total_time(10**9, 10**6, 10**6) == 10**6 + 10**9 * 10**6 def test_large_overhead_small_items(): assert minimum_total_time(1, 10**6, 1) == 10**6 + 1 def test_large_items_small_overhead(): assert minimum_total_time(10**6, 1, 1) == 10**6 + 1","solution":"def minimum_total_time(t, f, v): Returns the minimum total time required to process t items with a fixed overhead time f per batch and variable time v per item. # It's most efficient to process all items in one batch whenever possible. return f + t * v # Example usage: # print(minimum_total_time(1000, 10, 5)) # Output: 5010 # print(minimum_total_time(20, 15, 1)) # Output: 35"},{"question":"from typing import List, Tuple def shortest_paths(n: int, m: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the shortest path from a starting node S to an ending node E in an undirected graph. Args: n: Number of nodes in the graph. m: Number of edges in the graph. edges: List of edges where each edge is represented by a tuple (u, v, w) meaning there's an edge between u and v with weight w. queries: List of queries where each query is represented by a tuple (S, E) meaning find the shortest path from node S to node E. Returns: A list of integers where each integer represents the shortest distance for the corresponding query or -1 if there is no path. Example: >>> shortest_paths(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1)], [(1, 4), (4, 5), (3, 1)]) [6, 1, 3] >>> shortest_paths(4, 2, [(1, 2, 1), (3, 4, 1)], [(1, 3)]) [-1] >>> shortest_paths(1, 0, [], [(1, 1)]) [0] >>> shortest_paths(3, 3, [(1, 2, 1000000000), (2, 3, 1000000000), (1, 3, 3000000000)], [(1, 3), (1, 2)]) [2000000000, 1000000000] >>> shortest_paths(6, 4, [(1, 2, 5), (2, 3, 5), (4, 5, 6), (5, 6, 6)], [(1, 3), (1, 5)]) [10, -1]","solution":"import heapq def dijkstra(n, adj, start): Use Dijkstra's algorithm to find shortest paths from start node to all other nodes. dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] # (distance, node) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in adj[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist def shortest_paths(n, m, edges, queries): # Create adjacency list adj = [[] for _ in range(n + 1)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) results = [] for s, e in queries: dist = dijkstra(n, adj, s) result = dist[e] if dist[e] != float('inf') else -1 results.append(result) return results"},{"question":"def find_missing_integer(t, test_cases): Identify the smallest positive integer that is missing from a grid of size n x m filled with positive integers. Parameters: t (int): Number of test cases. test_cases (list): A list where each item is a tuple (n, m, grid) describing a test case. n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of lists): The n x m grid itself. Returns: list[int]: A list of integers, where each element is the smallest positive integer missing from the corresponding grid. Example: >>> t = 2 >>> test_cases = [ ... (3, 4, [ ... [1, 2, 3, 10], ... [4, 5, 6, 1], ... [7, 8, 9, 2] ... ]), ... (2, 2, [ ... [1, 3], ... [2, 4] ... ]) ... ] >>> find_missing_integer(t, test_cases) [11, 5] from solution import find_missing_integer def test_case_1(): t = 2 test_cases = [ (3, 4, [ [1, 2, 3, 10], [4, 5, 6, 1], [7, 8, 9, 2] ]), (2, 2, [ [1, 3], [2, 4] ]) ] assert find_missing_integer(t, test_cases) == [11, 5] def test_case_2(): t = 1 test_cases = [ (1, 10, [ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ]) ] assert find_missing_integer(t, test_cases) == [11] def test_case_3(): t = 1 test_cases = [ (2, 2, [ [1, 1], [1, 1] ]) ] assert find_missing_integer(t, test_cases) == [2] def test_case_4(): t = 1 test_cases = [ (3, 1, [ [1], [2], [4] ]) ] assert find_missing_integer(t, test_cases) == [3] def test_case_5(): t = 1 test_cases = [ (3, 3, [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ]) ] assert find_missing_integer(t, test_cases) == [1]","solution":"def find_missing_integer(t, test_cases): Returns the smallest positive integer that is missing from the given list of grids. Parameters: t (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains: - n (int): The number of rows in the grid. - m (int): The number of columns in the grid. - grid (list of lists): The n x m grid itself. Returns: list: A list of integers where each integer is the smallest positive integer missing from the corresponding grid. result = [] for n, m, grid in test_cases: presence = set() for row in grid: for value in row: if value > 0: presence.add(value) missing_integer = 1 while missing_integer in presence: missing_integer += 1 result.append(missing_integer) return result"},{"question":"def find_minimum_cost_route(n: int, distances: List[List[int]]) -> int: Find the minimum cost route that starts and ends at the depot and visits all other delivery points exactly once. >>> find_minimum_cost_route(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) # 80 >>> find_minimum_cost_route(5, [ ... [0, 12, 10, 19, 8], ... [12, 0, 3, 7, 2], ... [10, 3, 0, 6, 20], ... [19, 7, 6, 0, 4], ... [8, 2, 20, 4, 0] ... ]) # 32","solution":"from itertools import permutations def find_minimum_cost_route(n, distances): # Function to calculate the minimum cost route using brute force permutation method # Generate all permutations of points except the starting point (0) points = list(range(1, n)) min_cost = float('inf') # Iterate over all possible permutations for perm in permutations(points): # Calculate the cost of each permutation route starting and ending at 0 current_cost = distances[0][perm[0]] for i in range(len(perm) - 1): current_cost += distances[perm[i]][perm[i+1]] current_cost += distances[perm[-1]][0] # Update minimum cost if the current route has a lower cost min_cost = min(min_cost, current_cost) return min_cost # Example usage: # n = 4 # distances = [ # [0, 10, 15, 20], # [10, 0, 35, 25], # [15, 35, 0, 30], # [20, 25, 30, 0] # ] # print(find_minimum_cost_route(n, distances)) # Output: 80"},{"question":"from typing import List def max_rectangle(grid: List[List[int]]) -> int: Determine the area of the largest rectangle of contiguous vacant cells. >>> max_rectangle([ ... [1, 0, 1, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 0], ... [1, 0, 1, 1] ... ]) == 4 >>> max_rectangle([ ... [0, 1, 0, 0, 1], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 0] ... ]) == 4 >>> max_rectangle([ ... [1, 1], ... [1, 1] ... ]) == 0 >>> max_rectangle([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 16 >>> max_rectangle([ ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) == 4","solution":"def max_histogram_area(histogram): stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_rectangle(grid): if not grid: return 0 n = len(grid) m = len(grid[0]) max_area = 0 height = [0] * m for i in range(n): for j in range(m): height[j] = height[j] + 1 if grid[i][j] == 0 else 0 max_area = max(max_area, max_histogram_area(height)) return max_area"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given N x N matrix 90 degrees clockwise. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1]]) [[1]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given N x N matrix 90 degrees clockwise. :param matrix: list of lists, where each sublist represents a matrix row. :return: rotated matrix. N = len(matrix) # Step 1: Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(N)] for i in range(N)] # Step 2: Reverse each row in transposed matrix rotated_matrix = [row[::-1] for row in transposed_matrix] return rotated_matrix"},{"question":"def min_edit_distance(str1, str2): Returns the minimum number of steps required to transform str1 into str2. >>> min_edit_distance(\\"abc\\", \\"abd\\") 1 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 >>> min_edit_distance(\\"abc\\", \\"abc\\") 0 >>> min_edit_distance(\\"\\", \\"\\") 0 >>> min_edit_distance(\\"a\\", \\"a\\") 0 >>> min_edit_distance(\\"a\\", \\"\\") 1 >>> min_edit_distance(\\"\\", \\"a\\") 1 >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") 2 pass def min_steps_to_transform(t, test_cases): Returns a list of minimum number of steps required for each test case to transform str1 into str2. >>> min_steps_to_transform(3, [(\\"abc\\", \\"abd\\"), (\\"intention\\", \\"execution\\"), (\\"abc\\", \\"abc\\")]) [1, 5, 0] >>> min_steps_to_transform(3, [(\\"\\", \\"\\"), (\\"abc\\", \\"def\\"), (\\"a\\", \\"bcd\\")]) [0, 3, 3] >>> min_steps_to_transform(2, [(\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"lawn\\")]) [3, 2] pass","solution":"def min_edit_distance(str1, str2): Returns the minimum number of steps required to transform str1 into str2. m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[m][n] def min_steps_to_transform(t, test_cases): results = [] for str1, str2 in test_cases: results.append(min_edit_distance(str1, str2)) return results"},{"question":"def analyze_pattern(creature_patterns): Analyze the appearance patterns of mythical creatures and determine the total days of appearance and the days with most appearances. Args: creature_patterns (List[str]): List of strings representing the pattern of appearances of creatures. Returns: List[str]: List of results in the specified output format. >>> analyze_pattern([\\"DRAGON 1101100\\", \\"PHOENIX 1111111\\", \\"UNICORN 1000001\\", \\"MERMAID 0000111\\", \\"-\\"]) [\\"DRAGON: 4\\", \\"Most appearances on: 1 2 4 5\\", \\"PHOENIX: 7\\", \\"Most appearances on: 1 2 3 4 5 6 7\\", \\"UNICORN: 2\\", \\"Most appearances on: 1 7\\", \\"MERMAID: 3\\", \\"Most appearances on: 5 6 7\\"] >>> analyze_pattern([\\"GRIFFIN 1110000\\", \\"-\\"]) [\\"GRIFFIN: 3\\", \\"Most appearances on: 1 2 3\\"]","solution":"def analyze_pattern(creature_patterns): result = [] week_days = [\\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\", \\"6\\", \\"7\\"] for line in creature_patterns: if line == '-': break creature_name, pattern = line.split() total_days = pattern.count('1') most_days = \\" \\".join([week_days[i] for i, value in enumerate(pattern) if value == '1']) result.append(f\\"{creature_name}: {total_days}\\") result.append(f\\"Most appearances on: {most_days}\\") return result"},{"question":"def reserveSeats(seat_request): Reserves seats based on the given seat request list. Parameters: seat_request (list of tuples): A list of (row, col) tuples representing seats to reserve. Returns: dict: A dictionary representing the seat layout with 'available' and 'reserved' statuses. Example: >>> n = 5 >>> m = 7 >>> reserveSeats([(1, 2), (3, 4), (2, 4), (0, 0)]) {(0, 0): 'reserved', (0, 1): 'available', (0, 2): 'available', (0, 3): 'available', (0, 4): 'available', (0, 5): 'available', (0, 6): 'available', (1, 0): 'available', (1, 1): 'available', (1, 2): 'reserved', (1, 3): 'available', (1, 4): 'available', (1, 5): 'available', (1, 6): 'available', (2, 0): 'available', (2, 1): 'available', (2, 2): 'available', (2, 3): 'available', (2, 4): 'reserved', (2, 5): 'available', (2, 6): 'available', (3, 0): 'available', (3, 1): 'available', (3, 2): 'available', (3, 3): 'available', (3, 4): 'reserved', (3, 5): 'available', (3, 6): 'available', (4, 0): 'available', (4, 1): 'available', (4, 2): 'available', (4, 3): 'available', (4, 4): 'available', (4, 5): 'available', (4, 6): 'available'}","solution":"def reserveSeats(seat_request): Reserves seats based on the given seat request list. Parameters: seat_request (list of tuples): A list of (row, col) tuples representing seats to reserve. Returns: dict: A dictionary representing the seat layout with 'available' and 'reserved' statuses. n = 5 # number of rows m = 7 # number of columns seats = {(i, j): 'available' for i in range(n) for j in range(m)} for row, col in seat_request: if 0 <= row < n and 0 <= col < m: # ensure the seat position is within bounds if seats[(row, col)] == 'available': # if the seat is available, reserve it seats[(row, col)] = 'reserved' return seats"},{"question":"def minimum_travel_times(n: int, m: int, edges: List[Tuple[int, int, int]], start: int) -> List[Union[int, str]]: Compute the shortest travel times from the starting bus stop to all other bus stops. Parameters: n: int - Number of bus stops (vertices). m: int - Number of bus routes (edges). edges: List[Tuple[int, int, int]] - List of bus routes (u, v, w) where u and v are bus stops and w is the travel time between them. start: int - Starting bus stop. Returns: List[Union[int, str]] - List of shortest travel times from start to each bus stop. 'INF' if unreachable. >>> minimum_travel_times(4, 4, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 5)], 1) [0, 3, 2, 7] >>> minimum_travel_times(6, 7, [(1, 2, 3), (1, 3, 2), (2, 3, 4), (2, 4, 1), (3, 4, 3), (3, 5, 6), (4, 5, 2)], 1) [0, 3, 2, 4, 6, 'INF'] # Function implementation here","solution":"import heapq def dijkstra(n, graph, start): Compute the shortest travel times from the starting bus stop to all other bus stops. Parameters: n: int - Number of bus stops. graph: List[Tuple[int, int, int]] - List of bus routes (u, v, w). start: int - Starting bus stop. Returns: List[Union[int, str]] - List of shortest travel times from start to each bus stop. 'INF' if unreachable. adj_list = [[] for _ in range(n)] for u, v, w in graph: adj_list[u-1].append((v-1, w)) adj_list[v-1].append((u-1, w)) distances = [float('inf')] * n distances[start-1] = 0 priority_queue = [(0, start-1)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in adj_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return ['INF' if dist == float('inf') else dist for dist in distances] def minimum_travel_times(n, m, edges, start): return dijkstra(n, edges, start)"},{"question":"from typing import List def longest_unique_subarray_in_range(arr: List[int], l: int, r: int) -> int: Returns the length of the longest contiguous subarray within the range [l, r] that does not contain any repeated elements. >>> longest_unique_subarray_in_range([4, 5, 2, 5, 6, 2, 3, 4, 1, 6], 2, 5) 3 >>> longest_unique_subarray_in_range([1, 2, 3, 1, 2, 3], 1, 3) 3 >>> longest_unique_subarray_in_range([1, 1, 1, 1], 1, 1) 1 >>> longest_unique_subarray_in_range([1, 2, 3, 4, 5], 6, 10) 0 >>> longest_unique_subarray_in_range([1, 2, 3, 4, 5], 1, 5) 5 >>> longest_unique_subarray_in_range([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8], 3, 6) 4 >>> longest_unique_subarray_in_range([], 2, 5) 0 >>> longest_unique_subarray_in_range([1], 2, 3) 0","solution":"def longest_unique_subarray_in_range(arr, l, r): Returns the length of the longest contiguous subarray within the range [l, r] that does not contain any repeated elements. n = len(arr) left, right = 0, 0 max_len = 0 seen = {} while right < n: if l <= arr[right] <= r: if arr[right] in seen and seen[arr[right]] >= left: left = seen[arr[right]] + 1 seen[arr[right]] = right max_len = max(max_len, right - left + 1) else: left = right + 1 seen = {} right += 1 return max_len"},{"question":"def can_transform_number(n: int, k: int, digits: List[int]) -> str: Determine if Tom can transform the number n into a strictly greater number after exactly k operations. Parameters: n (int): The initial number chosen by Lina. k (int): The number of increment operations available. digits (list): The allowable digits that can be chosen for the increment operations. Returns: str: \\"Yes\\" if Tom can transform n into a strictly greater number after exactly k operations, \\"No\\" otherwise. >>> can_transform_number(54321, 3, [5, 4, 3]) \\"Yes\\" >>> can_transform_number(12345, 2, [0, 1]) \\"No\\"","solution":"def can_transform_number(n, k, digits): Determine if Tom can transform the number n into a strictly greater number after exactly k operations. Parameters: n (int): The initial number chosen by Lina. k (int): The number of increment operations available. digits (list): The allowable digits that can be chosen for the increment operations. Returns: str: \\"Yes\\" if Tom can transform n into a strictly greater number after exactly k operations, \\"No\\" otherwise. n_str = str(n) digit_changes = [False] * len(n_str) # Try to find k distinct digits from the number which can be increased for digit in digits: for i in range(len(n_str)): if k > 0 and not digit_changes[i] and int(n_str[i]) == digit: digit_changes[i] = True k -= 1 if k == 0: break if k == 0: break # If we ran out of operations, check for changes that result in greater number if k == 0: for i in range(len(n_str)): if digit_changes[i] and n_str[i] != '9': return \\"Yes\\" elif digit_changes[i] and n_str[i] == '9': return \\"Yes\\" return \\"No\\""},{"question":"def chmod_to_binary(sOctalPerms: str) -> str: Converts a three-digit octal permission string to its binary representation. Args: sOctalPerms (str): The three-digit octal permission string. Returns: str: The binary representation of the octal permission. >>> chmod_to_binary(\\"754\\") \\"111101100\\" >>> chmod_to_binary(\\"777\\") \\"111111111\\" >>> chmod_to_binary(\\"000\\") \\"000000000\\" >>> chmod_to_binary(\\"421\\") \\"100010001\\" >>> chmod_to_binary(\\"644\\") \\"110100100\\" >>> chmod_to_binary(\\"755\\") \\"111101101\\"","solution":"def chmod_to_binary(sOctalPerms): Converts a three-digit octal permission string to its binary representation. Args: sOctalPerms (str): The three-digit octal permission string. Returns: str: The binary representation of the octal permission. binary_representation = ''.join(format(int(digit), '03b') for digit in sOctalPerms) return binary_representation"},{"question":"def find_first_palindrome(words): Returns the first palindrome in the list of words. If no palindrome is found, returns 'no palindrome'. >>> find_first_palindrome(['apple', 'banana', 'racecar', 'mango']) 'racecar' >>> find_first_palindrome(['cat', 'dog', 'bird']) 'no palindrome' >>> find_first_palindrome(['level', 'civic', 'madam']) 'level' >>> find_first_palindrome(['noon', 'refer', 'rotor']) 'noon' >>> find_first_palindrome(['hello', 'world']) 'no palindrome' >>> find_first_palindrome([]) 'no palindrome' >>> find_first_palindrome(['a', 'b', 'c', 'd', 'e']) 'a'","solution":"def find_first_palindrome(words): Returns the first palindrome in the list of words. If no palindrome is found, returns 'no palindrome'. for word in words: if word == word[::-1]: return word return 'no palindrome'"},{"question":"from typing import List def min_planks(n: int, L: int, planks: List[int]) -> int: Returns the minimum number of planks required to achieve the required length L. Parameters: - n: Number of available planks - L: Required length for the project - planks: List containing the lengths of available planks Returns: - An integer representing the minimum number of planks required. pass # Unit Tests def test_case_1(): assert min_planks(5, 9, [5, 6, 4, 7, 10]) == 2 def test_case_2(): assert min_planks(4, 8, [3, 8, 2, 1]) == 1 def test_case_3(): assert min_planks(3, 10, [3, 7, 2]) == 2 def test_case_4(): assert min_planks(6, 15, [5, 5, 5, 6, 9, 1]) == 2 def test_case_5(): assert min_planks(1, 5, [5]) == 1 def test_case_6(): assert min_planks(5, 10, [6, 9, 1, 2, 8]) == 2 def test_case_7(): assert min_planks(4, 11, [6, 5, 5, 5]) == 2","solution":"def min_planks(n, L, planks): Returns the minimum number of planks required to achieve the required length L. Parameters: - n: Number of available planks - L: Required length for the project - planks: List containing the lengths of available planks Returns: - An integer representing the minimum number of planks required. planks.sort() if L in planks: return 1 left = 0 right = n - 1 while left < right: if planks[left] + planks[right] == L: return 2 if planks[left] + planks[right] < L: left += 1 else: right -= 1 return 2 # As there's always a combination for the given constraints. # Function to use when manually testing if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) L = int(data[1]) planks = list(map(int, data[2:2 + n])) print(min_planks(n, L, planks))"},{"question":"from typing import List, Tuple def count_knight_moves(t: int, positions: List[Tuple[int, int]]) -> List[int]: Given the number of test cases and the initial positions for each test case, return the number of valid knight moves for each test case on a 2x2 chessboard. >>> count_knight_moves(4, [(1,1), (1,2), (2,1), (2,2)]) [0, 0, 0, 0] >>> count_knight_moves(1, [(1,1)]) [0] >>> count_knight_moves(2, [(1,1), (2,2)]) [0, 0] >>> count_knight_moves(3, [(1,2), (2,1), (2,2)]) [0, 0, 0] pass","solution":"def count_knight_moves(t, positions): Given the number of test cases and the initial positions for each test case, return the number of valid knight moves for each test case on a 2x2 chessboard. results = [] for x, y in positions: # Since the board is 2x2, no knight move is possible # from any given initial position (1,1), (1,2), (2,1), (2,2). results.append(0) return results"},{"question":"def all_unique_characters(s: str) -> bool: Determines if all characters in the given string are unique. >>> all_unique_characters(\\"abc\\") True >>> all_unique_characters(\\"Aa\\") True >>> all_unique_characters(\\"aA\\") True >>> all_unique_characters(\\"abcdefghijklmnopqrstuvwxyz\\") True >>> all_unique_characters(\\"leetcode\\") False >>> all_unique_characters(\\"aabc\\") False >>> all_unique_characters(\\"aa\\") False >>> all_unique_characters(\\"x\\") True >>> all_unique_characters(\\"\\") True # Implementation here","solution":"def all_unique_characters(s): Determines if all characters in the given string are unique. Args: s (str): The input string. Returns: bool: True if all characters are unique, False otherwise. # Loop through each character in the string for i in range(len(s)): # Check if there is any identical character in the rest of the string if s[i] in s[i+1:]: return False return True"},{"question":"from typing import List, Tuple def minimum_energy_required(N: int, coordinates: List[Tuple[int, int]]) -> int: Calculate the minimum energy required to cut down all trees and return to the starting tree. Args: N (int): Number of trees. coordinates (List[Tuple[int, int]]): List of the (x, y) coordinates of each tree. Returns: int: The minimum energy required. >>> minimum_energy_required(3, [(0, 0), (1, 0), (0, 1)]) 4 >>> minimum_energy_required(1, [(0, 0)]) 0 >>> minimum_energy_required(2, [(0, 0), (1, 1)]) 4","solution":"import itertools def calculate_distance(point1, point2): Calculate the Manhattan distance between two points. return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]) def find_min_energy(trees): Find the minimum energy required to cut down all trees and return to the starting tree using the least amount of energy. n = len(trees) # Generate all permutations of the tree indices to evaluate all possible orders of cutting the trees tree_permutations = itertools.permutations(range(1, n)) min_energy = float('inf') for perm in tree_permutations: energy = 0 prev_tree = 0 # starting at the first tree # Calculate the energy for the current permutation for i in perm: energy += calculate_distance(trees[prev_tree], trees[i]) prev_tree = i # Add energy to return to the starting tree (index 0) energy += calculate_distance(trees[prev_tree], trees[0]) # Update minimum energy if the calculated energy is less min_energy = min(min_energy, energy) return min_energy def minimum_energy_required(N, coordinates): Wrapper function to handle input and output formatting. trees = [(coordinates[i][0], coordinates[i][1]) for i in range(N)] return find_min_energy(trees)"},{"question":"from typing import List def perfect_square_sum_sequence(N: int, A: List[int]) -> str: Check if it is possible to find a permutation of the given sequence of integers such that the sum of any two consecutive numbers is a perfect square. >>> perfect_square_sum_sequence(3, [1, 17, 8]) \\"YES\\" >>> perfect_square_sum_sequence(4, [1, 14, 2, 3]) \\"NO\\"","solution":"from itertools import permutations import math def is_perfect_square(n): Helper function to check if a number is a perfect square. root = int(math.sqrt(n)) return root * root == n def can_form_perfect_square_sum_sequence(N, sequence): Check if there exists a permutation of the sequence such that the sum of any two consecutive numbers is a perfect square. if N == 1: return True def can_form_sequence(perm): for i in range(len(perm) - 1): if not is_perfect_square(perm[i] + perm[i + 1]): return False return True for perm in permutations(sequence): if can_form_sequence(perm): return True return False def perfect_square_sum_sequence(N, A): if can_form_perfect_square_sum_sequence(N, A): return \\"YES\\" else: return \\"NO\\""},{"question":"def filter_individuals(data): Filters individuals based on the given criteria: - Age is between 25 and 40 (inclusive) - Income is greater than 50,000 - Height is at least 160 cm Parameters: data (list): List of dictionaries where each dictionary represents an individual Returns: list: List of dictionaries of individuals who meet the criteria Example: >>> data = [ ... {\\"age\\": 30, \\"income\\": 70000, \\"height\\": 175}, ... {\\"age\\": 23, \\"income\\": 48000, \\"height\\": 170}, ... {\\"age\\": 35, \\"income\\": 68000, \\"height\\": 160}, ... {\\"age\\": 40, \\"income\\": 55000, \\"height\\": 158} ... ] >>> filter_individuals(data) [{'age': 30, 'income': 70000, 'height': 175}, {'age': 35, 'income': 68000, 'height': 160}] pass","solution":"def filter_individuals(data): Filters individuals based on the given criteria: - Age is between 25 and 40 (inclusive) - Income is greater than 50,000 - Height is at least 160 cm Parameters: data (list): List of dictionaries where each dictionary represents an individual Returns: list: List of dictionaries of individuals who meet the criteria result = [] for individual in data: if 25 <= individual['age'] <= 40 and individual['income'] > 50000 and individual['height'] >= 160: result.append(individual) return result"},{"question":"def sortedSquares(nums): Given an integer array nums sorted in non-decreasing order, this function returns an integer array result with the property result[i] being the square of nums[i], where the array result is sorted in non-decreasing order. Example: >>> sortedSquares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sortedSquares([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121] result = [] return result","solution":"def sortedSquares(nums): Given an integer array nums sorted in non-decreasing order, this function returns an integer array result with the property result[i] being the square of nums[i], where the array result is sorted in non-decreasing order. left = 0 right = len(nums) - 1 result = [0] * len(nums) position = right while left <= right: left_square = nums[left] * nums[left] right_square = nums[right] * nums[right] if left_square > right_square: result[position] = left_square left += 1 else: result[position] = right_square right -= 1 position -= 1 return result"},{"question":"def largest_clique(n, m, friendships): Find the largest clique in which every student is directly connected to every other student. >>> largest_clique(5, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)]) 4 >>> largest_clique(4, 2, [(1, 2), (3, 4)]) 2","solution":"from itertools import combinations def is_clique(graph, nodes): for i in range(len(nodes)): for j in range(i + 1, len(nodes)): if nodes[j] not in graph[nodes[i]]: return False return True def largest_clique(n, m, friendships): graph = {i: set() for i in range(1, n + 1)} for u, v in friendships: graph[u].add(v) graph[v].add(u) max_clique_size = 0 for size in range(1, n + 1): for comb in combinations(graph.keys(), size): if is_clique(graph, comb): max_clique_size = max(max_clique_size, len(comb)) return max_clique_size # Example usage: n = 5 m = 6 friendships = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)] print(largest_clique(n, m, friendships)) # Output: 4"},{"question":"def generate_new_ids(n: int, ids: List[int]) -> List[int]: Generate new unique IDs for each participant such that the maximum absolute difference between the old ID and the new ID is minimized. Args: n (int): the number of participants. ids (List[int]): the original IDs of the participants. Returns: List[int]: the new unique IDs for the participants. Examples: >>> generate_new_ids(4, [1, 2, 3, 4]) [1, 2, 3, 4] >>> generate_new_ids(3, [10, 10, 1]) [1, 2, 3]","solution":"def generate_new_ids(n, ids): ids.sort() new_ids = [] current_id = 1 for i in range(n): while current_id in new_ids: current_id += 1 new_ids.append(current_id) return new_ids # Example usage if __name__ == \\"__main__\\": n = 3 ids = [10, 10, 1] new_ids = generate_new_ids(n, ids) print(new_ids) # Output: [1, 2, 3]"},{"question":"from typing import List, Tuple def find_unique_numbers(T: int, series_list: List[Tuple[int, List[int]]]) -> List[str]: Given a number T and a list of series of numbers, return a list of unique numbers for each series. Each unique number is a number that appears exactly once in the series, in the order they were first encountered. If no unique numbers are found, return \\"None\\" for that series. Args: T: int - Number of series series_list: List[Tuple[int, List[int]]] - List of series where each series is a tuple containing an integer N (number of elements) and a list of N integers (the series itself) Returns: List[str] - List of space-separated strings containing unique numbers for each series, or \\"None\\" if no unique numbers are found. Example: >>> find_unique_numbers(3, [(7, [4, 5, 6, 5, 4, 7, 8]), (5, [1, 2, 2, 3, 4]), (6, [1, 2, 3, 1, 2, 3])]) ['6 7 8', '1 3 4', 'None'] >>> find_unique_numbers(1, [(4, [5, 5, 5, 5])]) ['None']","solution":"def find_unique_numbers(T, series_list): results = [] for i in range(T): N, series = series_list[i] num_count = {} unique_nums = [] for num in series: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 for num in series: if num_count[num] == 1: unique_nums.append(num) if unique_nums: results.append(\\" \\".join(map(str, unique_nums))) else: results.append(\\"None\\") return results"},{"question":"def min_operations_to_sort(t, test_cases): Returns the minimum number of operations required to sort the string in ascending order for each test case. >>> min_operations_to_sort(1, [(4, \\"dcba\\")]) [6] >>> min_operations_to_sort(1, [(5, \\"aeiou\\")]) [0] >>> min_operations_to_sort(1, [(3, \\"cba\\")]) [3] >>> min_operations_to_sort(3, [(4, \\"dcba\\"), (5, \\"aeiou\\"), (3, \\"cba\\")]) [6, 0, 3]","solution":"def min_operations_to_sort(t, test_cases): Returns the minimum number of operations required to sort the string in ascending order for each test case. results = [] for case in test_cases: n, s = case sorted_s = ''.join(sorted(s)) swap_count = 0 s = list(s) # Bubble sort approach to count the minimum number of swaps for i in range(n): for j in range(n - 1): if s[j] > s[j + 1]: s[j], s[j + 1] = s[j + 1], s[j] swap_count += 1 results.append(swap_count) return results"},{"question":"def can_assign_books(N, M, books, students): Determines if it's possible to assign books to students based on their preferred difficulty range and the number of books they need to read. :param N: Integer, number of books. :param M: Integer, number of students. :param books: List of integers, difficulty levels of the books. :param students: List of tuples, each tuple contains (L, R, K) defining the student's constraints. :return: String, \\"YES\\" if it's possible to assign the books, \\"NO\\" otherwise. >>> can_assign_books(5, 3, [3, 8, 7, 5, 9], [(1, 6, 2), (5, 10, 2), (7, 8, 1)]) 'YES' >>> can_assign_books(5, 3, [3, 8, 7, 5, 9], [(1, 6, 3), (5, 10, 2), (7, 8, 1)]) 'NO' >>> can_assign_books(5, 2, [1, 5, 3, 4, 2], [(1, 3, 3), (4, 5, 2)]) 'YES' >>> can_assign_books(5, 1, [1, 2, 3, 4, 5], [(1, 5, 5)]) 'YES' >>> can_assign_books(3, 1, [1, 2, 3], [(2, 3, 2)]) 'YES' >>> can_assign_books(3, 2, [1, 2, 3], [(1, 1, 2), (2, 3, 1)]) 'NO' pass # Mock the input() and print() to test main() functionality def main(): import sys input = sys.stdin.read data = input().split() # Read the number of books and students N = int(data[0]) M = int(data[1]) # Read the difficulty levels of the books books = list(map(int, data[2:N+2])) # Read the students' constraints students = [] index = N+2 for _ in range(M): L = int(data[index]) R = int(data[index+1]) K = int(data[index+2]) students.append((L, R, K)) index += 3 # Determine if we can assign the books as required result = can_assign_books(N, M, books, students) print(result)","solution":"def can_assign_books(N, M, books, students): Determines if it's possible to assign books to students based on their preferred difficulty range and the number of books they need to read. :param N: Integer, number of books. :param M: Integer, number of students. :param books: List of integers, difficulty levels of the books. :param students: List of tuples, each tuple contains (L, R, K) defining the student's constraints. :return: String, \\"YES\\" if it's possible to assign the books, \\"NO\\" otherwise. # Sort the books by difficulty books.sort() # Try to assign books to students based on the preferred ranges and required counts for L, R, K in students: count = 0 for book in books: if L <= book <= R: count += 1 if count >= K: break if count < K: return \\"NO\\" return \\"YES\\" # Reading Input def main(): import sys input = sys.stdin.read data = input().split() # Read the number of books and students N = int(data[0]) M = int(data[1]) # Read the difficulty levels of the books books = list(map(int, data[2:N+2])) # Read the students' constraints students = [] index = N+2 for _ in range(M): L = int(data[index]) R = int(data[index+1]) K = int(data[index+2]) students.append((L, R, K)) index += 3 # Determine if we can assign the books as required result = can_assign_books(N, M, books, students) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def can_cross_pillars(n:int, d:int, e:int, heights:List[int]) -> str: Determine if Jenish can cross from the first pillar to the last pillar with the given energy. Args: n (int): The number of pillars. d (int): The maximum number of pillars Jenish can jump. e (int): The total energy Jenish has. heights (List[int]): The heights of the pillars. Returns: str: \\"YES\\" if Jenish can cross from the first to the last pillar, \\"NO\\" otherwise. >>> can_cross_pillars(5, 2, 5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_cross_pillars(4, 3, 2, [1, 5, 2, 7]) \\"NO\\" >>> can_cross_pillars(6, 1, 10, [1, 1, 1, 1, 1, 1]) \\"YES\\" pass def solve(test_cases:List[Tuple[int, int, int, List[int]]]) -> List[str]: Solve multiple test cases to determine if Jenish can cross the array of pillars. Args: test_cases (List[Tuple[int, int, int, List[int]]]): The list of test cases. Each test case is a tuple of n, d, e, and heights. Returns: List[str]: A list of results for each test case, \\"YES\\" or \\"NO\\". >>> solve([(5, 2, 5, [1, 2, 3, 4, 5]), (4, 3, 2, [1, 5, 2, 7]), (6, 1, 10, [1, 1, 1, 1, 1, 1])]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass # Unit Test from solution import can_cross_pillars, solve def test_case_1(): test_cases = [ (5, 2, 5, [1, 2, 3, 4, 5]), (4, 3, 2, [1, 5, 2, 7]), (6, 1, 10, [1, 1, 1, 1, 1, 1]) ] expected_results = [\\"YES\\", \\"NO\\", \\"YES\\"] assert solve(test_cases) == expected_results def test_can_cross_pillars(): assert can_cross_pillars(5, 2, 5, [1, 2, 3, 4, 5]) == \\"YES\\" assert can_cross_pillars(4, 3, 2, [1, 5, 2, 7]) == \\"NO\\" assert can_cross_pillars(6, 1, 10, [1, 1, 1, 1, 1, 1]) == \\"YES\\" def test_edge_cases(): assert can_cross_pillars(1, 1, 0, [0]) == \\"YES\\" assert can_cross_pillars(2, 1, 0, [1, 1]) == \\"YES\\" assert can_cross_pillars(2, 1, 0, [1, 2]) == \\"NO\\" assert can_cross_pillars(3, 2, 3, [1, 4, 1]) == \\"YES\\" assert can_cross_pillars(5, 3, 10, [10, 20, 15, 10, 5]) == \\"YES\\" def test_large_cases(): n = 10**5 large_heights = [i for i in range(n)] assert can_cross_pillars(n, 10, 10**9, large_heights) == \\"YES\\" descending_heights = [i for i in range(n, 0, -1)] assert can_cross_pillars(n, 10, 10**9, descending_heights) == \\"YES\\"","solution":"def can_cross_pillars(n, d, e, heights): # Create a list to store the minimum energy needed to reach each pillar min_energy = [float('inf')] * n min_energy[0] = 0 for i in range(n): for j in range(i + 1, min(i + d + 1, n)): jump_cost = abs(heights[i] - heights[j]) min_energy[j] = min(min_energy[j], min_energy[i] + jump_cost) return \\"YES\\" if min_energy[-1] <= e else \\"NO\\" def solve(test_cases): results = [] for n, d, e, heights in test_cases: results.append(can_cross_pillars(n, d, e, heights)) return results"},{"question":"from typing import Dict, Set, List def find_shortest_path(graph: Dict[int, Set[int]], start: int, end: int) -> List[int]: Implement a function that finds the shortest path from a start node to an end node in an undirected graph using BFS. Parameters: graph (Dict[int, Set[int]]): The graph represented as an adjacency list. start (int): The starting node. end (int): The destination node. Returns: List[int]: The shortest path from start to end as a list of nodes. Returns an empty list if no path exists. >>> graph = {1: {2, 3}, 2: {4}, 3: {5}, 4: {5}, 5: {6}, 6: {} } >>> find_shortest_path(graph, 1, 6) in [[1, 3, 5, 6], [1, 2, 4, 5, 6]] True >>> graph = {1: {2}, 2: {3}, 3: {}, 4: {5}, 5: {} } >>> find_shortest_path(graph, 1, 5) [] >>> graph = {1: {2, 3}, 2: {4}, 3: {5}, 4: {5}, 5: {6}, 6: {} } >>> find_shortest_path(graph, 4, 4) [4] >>> graph = {1: {2}, 2: {3}, 3: {4}, 4: {} } >>> find_shortest_path(graph, 1, 4) [1, 2, 3, 4] >>> graph = {1: {2}, 2: {3}, 3: {4}, 4: {}, 5: {6}, 6: {} } >>> find_shortest_path(graph, 1, 6) [] >>> graph = {1: {2}, 2: {3}, 3: {1, 4}, 4: {5}, 5: {} } >>> find_shortest_path(graph, 1, 5) [1, 2, 3, 4, 5]","solution":"from collections import deque from typing import Dict, Set, List def find_shortest_path(graph: Dict[int, Set[int]], start: int, end: int) -> List[int]: if start == end: return [start] queue = deque([(start, [start])]) visited = set([start]) while queue: current_node, path = queue.popleft() for neighbor in graph.get(current_node, []): if neighbor not in visited: if neighbor == end: return path + [end] visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"def reverseStringIfEven(s: str) -> str: Reverses the given string if its length is even, otherwise returns the string as it is. Example: >>> reverseStringIfEven(\\"hello\\") 'hello' >>> reverseStringIfEven(\\"abcd\\") 'dcba' :param s: Input string :return: reversed string if length is even, otherwise the original string","solution":"def reverseStringIfEven(s): Reverses the given string if its length is even, otherwise returns the string as it is. :param s: Input string :return: reversed string if length is even, otherwise the original string return s[::-1] if len(s) % 2 == 0 else s"},{"question":"def next_day(starting_day: int, days_to_add: int) -> str: Calculates the next day of the week given a starting day and a number of days to add. Args: starting_day (int): The starting day of the week (0 to 6). days_to_add (int): The number of days to add. Returns: str: The day of the week after adding the given number of days. Examples: >>> next_day(0, 5) 'Friday' >>> next_day(3, 10) 'Saturday' >>> next_day(6, 0) 'Saturday'","solution":"def next_day(starting_day, days_to_add): Calculates the next day of the week given a starting day and a number of days to add. Args: starting_day (int): The starting day of the week (0 to 6). days_to_add (int): The number of days to add. Returns: str: The day of the week after adding the given number of days. days_of_week = [\\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\"] new_day_index = (starting_day + days_to_add) % 7 return days_of_week[new_day_index]"},{"question":"def max_consecutive_bands(n: int, d: int, performance_times: List[int]) -> int: Returns the maximum number of bands that can be scheduled consecutively given the allowed difference in performance time between consecutive bands. :param n: Number of bands (int) :param d: Maximum allowed difference in performance time (int) :param performance_times: List of performance times of bands (list of ints) :return: Maximum number of consecutive bands (int) >>> max_consecutive_bands(5, 3, [30, 28, 25, 27, 29]) 5 >>> max_consecutive_bands(4, 2, [15, 20, 25, 22]) 2 >>> max_consecutive_bands(6, 1, [1, 5, 9, 13, 17, 21]) 1","solution":"def max_consecutive_bands(n, d, performance_times): Returns the maximum number of bands that can be scheduled consecutively given the allowed difference in performance time between consecutive bands. :param n: Number of bands (int) :param d: Maximum allowed difference in performance time (int) :param performance_times: List of performance times of bands (list of ints) :return: Maximum number of consecutive bands (int) # First, we sort the performance times to make it easier to check consecutive differences performance_times.sort() max_consecutive = 1 current_consecutive = 1 # Iterate through sorted performance times to find the maximum sequence of allowed differences for i in range(1, n): if performance_times[i] - performance_times[i - 1] <= d: current_consecutive += 1 else: current_consecutive = 1 max_consecutive = max(max_consecutive, current_consecutive) return max_consecutive"},{"question":"def count_magic_extractable_stones(n: int, stones: List[int]) -> int: Returns the total number of stones the wizard can extract magic from. Parameters: n (int): Number of stones stones (list): List of integers representing the magical number on each stone Returns: int: Total number of extractable stones >>> count_magic_extractable_stones(5, [2, 4, 1, 5, 3]) 3 >>> count_magic_extractable_stones(4, [1, 2, 3, 4]) 4 >>> count_magic_extractable_stones(6, [6, 5, 4, 3, 2, 1]) 1","solution":"def count_magic_extractable_stones(n, stones): Returns the total number of stones the wizard can extract magic from. Parameters: n (int): Number of stones stones (list): List of integers representing the magical number on each stone Returns: int: Total number of extractable stones if n == 0: return 0 count = 0 max_value = float('-inf') for stone in stones: if stone >= max_value: count += 1 max_value = stone return count"},{"question":"def calculate_total_spell_power(N: int) -> List[int]: Calculate the total spell power exerted on each student after all professors have cast their spells. >>> calculate_total_spell_power(6) [1, 3, 4, 7, 6, 12] >>> calculate_total_spell_power(1) [1] >>> calculate_total_spell_power(2) [1, 3] >>> calculate_total_spell_power(3) [1, 3, 4] >>> calculate_total_spell_power(10) [1, 3, 4, 7, 6, 12, 8, 15, 13, 18] pass def solve_magic_school_problem(test_cases: List[int]) -> List[List[int]]: Solve the magical school problem for a list of test cases. pass","solution":"def calculate_total_spell_power(N): total_spell_power = [0] * (N + 1) for professor_capability in range(1, N + 1): for student in range(professor_capability, N + 1, professor_capability): total_spell_power[student] += professor_capability return total_spell_power[1:] def solve_magic_school_problem(test_cases): results = [] for N in test_cases: results.append(calculate_total_spell_power(N)) return results"},{"question":"from typing import List, Tuple def find_minimum_cost_to_connect_all_nodes(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Given an undirected graph with n nodes and m edges, where each edge has a weight associated with it, find the minimum cost to connect all the nodes in the graph. If it's not possible to connect all the nodes, return -1. Parameters: n (int): Number of nodes m (int): Number of edges edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w) Returns: int: Minimum cost to connect all nodes or -1 if not possible >>> find_minimum_cost_to_connect_all_nodes(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 4), (1, 3, 3), (2, 4, 2)]) 5 >>> find_minimum_cost_to_connect_all_nodes(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> find_minimum_cost_to_connect_all_nodes(1, 0, []) 0 >>> find_minimum_cost_to_connect_all_nodes(2, 1, [(1, 2, 10)]) 10 >>> find_minimum_cost_to_connect_all_nodes(3, 0, []) -1","solution":"def find_minimum_cost_to_connect_all_nodes(n, m, edges): This function returns the minimum cost to connect all nodes in the graph. If it is not possible, it returns -1. # Sort the edges by their weights edges.sort(key=lambda edge: edge[2]) # A function to find the root of a node in the union-find structure def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] # A function to union two nodes def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Initialization of union-find structure parent = list(range(n)) rank = [0] * n cost = 0 num_edges = 0 for u, v, w in edges: root_u = find(parent, u-1) root_v = find(parent, v-1) if root_u != root_v: union(parent, rank, root_u, root_v) cost += w num_edges += 1 if num_edges == n - 1: break if num_edges != n - 1: return -1 return cost"},{"question":"def subset_sum_exists(n: int, t: int, integers: List[int]) -> str: Determine if there is a subset of integers whose sum is equal to target value t. >>> subset_sum_exists(4, 10, [1, 2, 3, 4]) \\"YES\\" >>> subset_sum_exists(3, 7, [3, 1, 2]) \\"NO\\"","solution":"def subset_sum_exists(n, t, integers): Determine if there is a subset of \`integers\` whose sum equals \`t\`. :param n: Number of integers :param t: Target sum :param integers: List of n distinct integers :return: \\"YES\\" if such a subset exists, otherwise \\"NO\\" # Utilizing a dynamic programming approach to solve the subset sum problem dp = [False] * (t + 1) dp[0] = True # There is always a subset with sum 0, the empty subset for num in integers: for i in range(t, num - 1, -1): if dp[i - num]: dp[i] = True return \\"YES\\" if dp[t] else \\"NO\\""},{"question":"def process_operations(n: int, m: int, initial_grid: List[List[int]], incompatible_pairs: List[Tuple[int, int]], operations: List[str]) -> List[int]: Process a series of operations on a garden grid. Args: n (int): number of rows in the garden grid. m (int): number of columns in the garden grid. initial_grid (List[List[int]]): initial state of the garden grid. incompatible_pairs (List[Tuple[int, int]]): list of incompatible flower pairs. operations (List[str]): list of operations to be performed on the garden grid. Returns: List[int]: results of the query operations. Example: >>> process_operations(3, 3, [[1, 2, 2], [3, 1, 1], [1, 3, 3]], [(1, 2), (1, 3)], [\\"Q 1 1\\", \\"C 2 2 2\\", \\"Q 2 2\\", \\"C 3 3 2\\", \\"Q 2 2\\"]) [1, 3, 3]","solution":"class Garden: def __init__(self, n, m, grid, incompatible_pairs): self.n = n self.m = m self.grid = grid self.incompatibilities = {} for a, b in incompatible_pairs: self.incompatibilities.setdefault(a, set()).add(b) self.incompatibilities.setdefault(b, set()).add(a) self.visited = set() def is_incompatible(self, flower1, flower2): return flower2 in self.incompatibilities.get(flower1, set()) def dfs(self, x, y, flower_type): if (x, y) in self.visited or x < 0 or x >= self.n or y < 0 or y >= self.m: return 0 if self.grid[x][y] != flower_type: return 0 self.visited.add((x, y)) size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += self.dfs(x + dx, y + dy, flower_type) return size def change_flower(self, x, y, flower_type): self.grid[x][y] = flower_type def query_largest_group(self, x, y): self.visited = set() return self.dfs(x, y, self.grid[x][y]) def process_operations(n, m, initial_grid, incompatible_pairs, operations): garden = Garden(n, m, initial_grid, incompatible_pairs) result = [] for operation in operations: op = operation.split() if op[0] == 'C': x, y, t = int(op[1]), int(op[2]), int(op[3]) garden.change_flower(x-1, y-1, t) elif op[0] == 'Q': x, y = int(op[1]), int(op[2]) result.append(garden.query_largest_group(x-1, y-1)) return result"},{"question":"def reorder_array(n: int, b: List[int]) -> Tuple[str, List[int]]: This function reorders the array such that for every i < j, c_i + c_j is not divisible by 2. If it's possible, it returns \\"YES\\" and the reordered array, otherwise \\"NO\\". >>> reorder_array(5, [1, 3, 2, 4, 5]) (\\"YES\\", [1, 3, 5, 2, 4]) >>> reorder_array(2, [2, 4]) (\\"NO\\", [])","solution":"def reorder_array(n, b): This function reorders the array such that for every i < j, c_i + c_j is not divisible by 2. If it's possible, it returns \\"YES\\" and the reordered array, otherwise \\"NO\\". odd = [x for x in b if x % 2 == 1] even = [x for x in b if x % 2 == 0] # If both even and odd elements are present, returning them separated fulfills the requirement. if odd and even: return \\"YES\\", odd + even else: return \\"NO\\", [] # Example usage # n = 5 # b = [1, 3, 2, 4, 5] # print(reorder_array(n, b)) # Output: (\\"YES\\", [1, 3, 5, 2, 4])"},{"question":"def fever_detector(participants_temps): Determines if each participant had a fever at least once during the day. :param participants_temps: List of lists of floats, where each inner list contains temperature recordings for one participant. :return: List of boolean values indicating whether each participant had a fever at least once during the day. Example: >>> fever_detector([ ... [98.6, 99.1, 100.2], ... [97.5, 98.7, 101.3], ... [99.9, 100.5, 99.8], ... [98.4, 97.6, 99.0, 98.2] ... ]) [False, True, True, False]","solution":"def fever_detector(participants_temps): Determines if each participant had a fever at least once during the day. :param participants_temps: List of lists of floats, where each inner list contains temperature recordings for one participant. :return: List of boolean values indicating whether each participant had a fever at least once during the day. fever_threshold = 100.4 return [any(temp >= fever_threshold for temp in temps) for temps in participants_temps]"},{"question":"def largest_enclosed_square(n: int, grid: List[str]) -> int: Determine the size of the largest square block of buildings that can be completely enclosed by a border of empty spaces. >>> largest_enclosed_square(5, [\\".....\\", \\".#.\\", \\".#.\\", \\".#.\\", \\".....\\"]) 3 >>> largest_enclosed_square(6, [\\"......\\", \\"......\\", \\"....\\", \\"....\\", \\"......\\", \\"......\\"]) 2 >>> largest_enclosed_square(4, [\\"\\", \\"#..#\\", \\"#..#\\", \\"\\"]) 0","solution":"def largest_enclosed_square(n, grid): def is_enclosed_by_spaces(x, y, size): for i in range(size): if x == 0 or y - 1 < 0 or y + size >= n: return False if grid[x-1][y + i] != '.': return False if x + size > n: return False if grid[x + size][y + i] != '.': return False if y + size >= n or y - 1 < 0: return False if grid[x + i][y-1] != '.': return False if y + size >= n or y + size >= n: return False if grid[x + i][y + size] != '.': return False return True max_size = 0 for x in range(1, n - 1): for y in range(1, n - 1): if grid[x][y] == '#': size = 1 while x + size < n and y + size < n and all(grid[x+i][y+size] == '#' and grid[x+size][y+i] == '#' for i in range(size)) and grid[x+size][y+size] == '#': size += 1 if is_enclosed_by_spaces(x, y, size): max_size = max(size, max_size) return max_size"},{"question":"def count_unique_square_gardens(M): Calculate the number of possible unique square gardens in an MxM grid, modulo 1000000007. >>> count_unique_square_gardens(2) 5 >>> count_unique_square_gardens(3) 14 def unique_square_gardens(t, cases): For each test case, calculate the number of possible unique square gardens and return the results. >>> unique_square_gardens(2, [2, 3]) [5, 14] >>> unique_square_gardens(3, [2, 3, 4]) [5, 14, 30]","solution":"def count_unique_square_gardens(M): MOD = 1000000007 total_squares = 0 # Sum the number of squares of different sizes that can fit within an MxM grid for size in range(1, M+1): total_squares += (M - size + 1) ** 2 total_squares %= MOD return total_squares def unique_square_gardens(t, cases): results = [] for case in cases: results.append(count_unique_square_gardens(case)) return results"},{"question":"def calculate_total_cost(days, meals_per_day, cost_per_day): Calculate the total cost after applying the appropriate discount based on the number of meals purchased. :param days: int - the number of days :param meals_per_day: int - the number of meals per day :param cost_per_day: int - the daily cost :return: float - the total cost after discount >>> calculate_total_cost(1, 9, 100) 100.0 >>> calculate_total_cost(1, 10, 100) 90.0 >>> calculate_total_cost(1, 30, 100) 80.0 >>> calculate_total_cost(15, 3, 200) 2400.0","solution":"def calculate_total_cost(days, meals_per_day, cost_per_day): Calculate the total cost after applying the appropriate discount based on the number of meals purchased. :param days: int - the number of days :param meals_per_day: int - the number of meals per day :param cost_per_day: int - the daily cost :return: float - the total cost after discount total_meals = days * meals_per_day total_cost = days * cost_per_day if total_meals < 10: discount = 0 elif 10 <= total_meals < 30: discount = 0.10 else: discount = 0.20 discounted_cost = total_cost * (1 - discount) return discounted_cost"},{"question":"def is_palindrome(number: int) -> bool: Checks if a given number is a palindrome. str_num = str(number) return str_num == str_num[::-1] def largest_palindrome(n: int) -> int: Write a function that takes an integer \`n\` and returns the largest palindrome number less than \`n\`. >>> largest_palindrome(123) 121 >>> largest_palindrome(1000) 999 >>> largest_palindrome(10) 9 >>> largest_palindrome(1) 0","solution":"def is_palindrome(number): Checks if a given number is a palindrome. str_num = str(number) return str_num == str_num[::-1] def largest_palindrome(n): Returns the largest palindrome number less than n. for num in range(n-1, -1, -1): if is_palindrome(num): return num return 0"},{"question":"def roman_to_integer(roman: str) -> int: Convert a Roman numeral string into its corresponding integer value. >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"MCMXCIV\\") 1994","solution":"def roman_to_integer(roman: str) -> int: roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(roman): current_value = roman_values[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"def maxLengthAlternatingSubstr(S: str) -> int: Given a string consisting of both lowercase and uppercase letters, return the length of the longest alternating case substring such that no two adjacent characters in the substring are of the same case. Example 1: >>> maxLengthAlternatingSubstr(\\"aAbBcCdD\\") 8 Example 2: >>> maxLengthAlternatingSubstr(\\"aabbAABB\\") 2 Constraints: 1 <= |S| <= 10^5 |S| represents the length of the string S.","solution":"def maxLengthAlternatingSubstr(S): Returns the length of the longest alternating case substring such that no two adjacent characters in the substring are of the same case. max_length = 0 current_length = 0 for i in range(len(S)): if i == 0 or S[i].islower() and S[i - 1].isupper() or S[i].isupper() and S[i - 1].islower(): current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def is_isomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. >>> is_isomorphic(\\"egg\\", \\"add\\") True >>> is_isomorphic(\\"foo\\", \\"bar\\") False >>> is_isomorphic(\\"paper\\", \\"title\\") True >>> is_isomorphic(\\"ab\\", \\"aa\\") False","solution":"def is_isomorphic(s, t): if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False else: mapping_s_to_t[char_s] = char_t if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False else: mapping_t_to_s[char_t] = char_s return True # Function to handle input and output def main(): import sys input = sys.stdin.read data = input().split() s = data[0] t = data[1] if is_isomorphic(s, t): print(\\"true\\") else: print(\\"false\\")"},{"question":"def digitSum(num: str) -> int: Returns the sum of digits of the string representation of the number. Parameters: num (str): A non-negative integer represented as a string. Returns: int: The sum of its digits. >>> digitSum(\\"12345\\") 15 >>> digitSum(\\"0000\\") 0","solution":"def digitSum(num: str) -> int: Returns the sum of digits of the string representation of the number. Parameters: num (str): A non-negative integer represented as a string. Returns: int: The sum of its digits. return sum(int(digit) for digit in num)"},{"question":"def check_reorder(products): Determines which products need a reorder based on current stock levels and reorder thresholds. Args: products (List[Tuple[str, int, int]]): A list of tuples where each tuple contains: - A string identifier: unique identifier of the product - An integer S: current stock level of the product - An integer R: reorder threshold of the product Returns: List[str]: List of product identifiers that need a reorder, or [\\"No reorder needed\\"] if none need reordering. Example: >>> check_reorder([(\\"item123\\", 20, 15), (\\"item456\\", 10, 20), (\\"item789\\", 5, 5)]) [\\"item456\\", \\"item789\\"] # Your code here # Function to handle the processing of data from input def process_input(input_str): Processes the input string to extract product details and checks for reorders. Args: input_str (str): Input string where the first line is an integer P, the number of products. Each of the next P lines contains: - A string identifier: unique identifier of the product - An integer S: current stock level of the product - An integer R: reorder threshold of the product Returns: List[str]: List of product identifiers that need a reorder, or [\\"No reorder needed\\"] if none need reordering. Example: >>> input_str = \\"3nitem123 20 15nitem456 10 20nitem789 5 5\\" >>> process_input(input_str) [\\"item456\\", \\"item789\\"] # Your code here","solution":"def check_reorder(products): reorder_list = [] for product in products: identifier, stock, threshold = product if stock <= threshold: reorder_list.append(identifier) if reorder_list: return reorder_list else: return [\\"No reorder needed\\"] # Function to handle the processing of data from input def process_input(input_str): lines = input_str.strip().split('n') P = int(lines[0]) products = [] for i in range(1, P + 1): parts = lines[i].split() identifier = parts[0] stock = int(parts[1]) threshold = int(parts[2]) products.append((identifier, stock, threshold)) return check_reorder(products)"},{"question":"from typing import List def min_operations(arr: List[int]) -> int: Given a list of integers, determine the smallest number of operations required to make all elements equal. In one operation, you can add or subtract 1 from any element. >>> min_operations([1, 2, 3]) 2 >>> min_operations([4, 6, 8]) 4","solution":"def min_operations(arr): Returns the minimum number of operations to make all elements in the list equal. arr.sort() median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"def find_two_sum_indices(arr, target): Find two distinct indices i and j in the array such that the sum of the elements at these indices equals the given target sum S. Parameters: arr (list): a list of integers. target (int): the target sum. Returns: tuple: a tuple of 1-based indices (i, j) if such a pair exists, otherwise (-1,). >>> find_two_sum_indices([2, 7, 11, 15, 1], 9) (1, 2) >>> find_two_sum_indices([1, 2, 3, 4, 5], 10) (-1,) >>> find_two_sum_indices([-1, -2, -3, -4, -5], -8) (3, 5) >>> find_two_sum_indices([10**9, -(10**9), 3, 7, 5], 0) (1, 2) >>> find_two_sum_indices([5, 5], 10) (1, 2)","solution":"def find_two_sum_indices(arr, target): Find two distinct indices i and j in the array such that the sum of the elements at these indices equals the given target sum S. Parameters: arr (list): a list of integers. target (int): the target sum. Returns: tuple: a tuple of 1-based indices (i, j) if such a pair exists, otherwise (-1,). lookup = {} for i, num in enumerate(arr): complement = target - num if complement in lookup: return (lookup[complement] + 1, i + 1) lookup[num] = i return (-1,)"},{"question":"import math from collections import Counter def count_palindromic_permutations(s: str) -> int: Count the number of palindromic permutations of a string. >>> count_palindromic_permutations(\\"aabb\\") 2 >>> count_palindromic_permutations(\\"abc\\") 0 >>> count_palindromic_permutations(\\"aaa\\") 1 def palindromic_permutations_for_strings(strings: List[str]) -> List[int]: For a list of strings, count the number of palindromic permutations for each string. >>> palindromic_permutations_for_strings([\\"aabb\\", \\"abc\\", \\"aaa\\", \\"xyz\\", \\"aabbccddee\\"]) [2, 0, 1, 0, 120]","solution":"import math from collections import Counter def count_palindromic_permutations(s): # Count frequency of each character freq = Counter(s) # Check number of odd frequency characters odd_count = sum(1 for count in freq.values() if count % 2 != 0) # More than one character with odd frequency means no palindromic permutation if odd_count > 1: return 0 # Calculate the number of palindromic permutations half_len = sum(count // 2 for count in freq.values()) freq_half = [count // 2 for count in freq.values()] numerator = math.factorial(half_len) denominator = math.prod(math.factorial(x) for x in freq_half) return numerator // denominator def palindromic_permutations_for_strings(strings): return [count_palindromic_permutations(s) for s in strings]"},{"question":"def is_cyclic_permutation(s1, s2): Determines if one string is a cyclic permutation of another string. >>> is_cyclic_permutation(\\"abcd\\", \\"dabc\\") True >>> is_cyclic_permutation(\\"abcd\\", \\"abdc\\") False >>> is_cyclic_permutation(\\"abc\\", \\"cab\\") True >>> is_cyclic_permutation(\\"aa\\", \\"aa\\") True >>> is_cyclic_permutation(\\"abcd\\", \\"abcd\\") True >>> is_cyclic_permutation(\\"abcd\\", \\"abcdx\\") False >>> is_cyclic_permutation(\\"a\\", \\"a\\") True >>> is_cyclic_permutation(\\"a\\", \\"b\\") False pass def check_cyclic_permutations(pairs): Given a list of string pairs, return a list of \\"yes\\" or \\"no\\" indicating if one string is a cyclic permutation of the other. >>> check_cyclic_permutations([(\\"abcd\\", \\"dabc\\"), (\\"abcd\\", \\"abdc\\"), (\\"abc\\", \\"cab\\"), (\\"aa\\", \\"aa\\"), (\\"abcd\\", \\"abcd\\"), (\\"0\\", \\"\\")]) ['yes', 'no', 'yes', 'yes', 'yes'] >>> check_cyclic_permutations([(\\"0\\", \\"\\")]) [] >>> check_cyclic_permutations([(\\"a\\", \\"a\\"), (\\"b\\", \\"b\\"), (\\"0\\", \\"\\")]) ['yes', 'yes'] pass","solution":"def is_cyclic_permutation(s1, s2): Determines if s1 is a cyclic permutation of s2. if len(s1) != len(s2): return False return s2 in (s1 + s1) def check_cyclic_permutations(pairs): Given a list of string pairs, return a list of \\"yes\\" or \\"no\\" indicating if one string is a cyclic permutation of the other. results = [] for s1, s2 in pairs: if s1 == \\"0\\": break results.append(\\"yes\\" if is_cyclic_permutation(s1, s2) else \\"no\\") return results"},{"question":"from typing import List def trapWater(height: List[int]) -> int: Calculate the total amount of water that could be trapped between the buckets after the rainfall. >>> trapWater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trapWater([4,2,0,3,2,5]) 9","solution":"from typing import List def trapWater(height: List[int]) -> int: if not height: return 0 n = len(height) left, right = [0] * n, [0] * n # Fill left array left[0] = height[0] for i in range(1, n): left[i] = max(left[i-1], height[i]) # Fill right array right[n-1] = height[n-1] for i in range(n-2, -1, -1): right[i] = max(right[i+1], height[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left[i], right[i]) - height[i] return trapped_water"},{"question":"def contains_all_vowels(s: str) -> bool: Determines whether a given string contains all the vowels (a, e, i, o, u) at least once. The function is case insensitive and should return a boolean value: True if all vowels are present, and False otherwise. >>> contains_all_vowels(\\"The quick brown fox jumps over the lazy dog\\") True >>> contains_all_vowels(\\"The quick brown fox jumps over the lzy dog\\") False >>> contains_all_vowels(\\"Th qck brwn fx jmps vr th lzy dg\\") False >>> contains_all_vowels(\\"AEIOU\\") True >>> contains_all_vowels(\\"aEIoU\\") True >>> contains_all_vowels(\\"bcdfghjklmnpqrstvwxyz\\") False >>> contains_all_vowels(\\"A quick brown; dog jumps. over the lazy!! Fox, often\\") True","solution":"def contains_all_vowels(s): Returns True if the input string contains all the vowels (a, e, i, o, u) at least once, case insensitive. Otherwise, returns False. vowels = set(\\"aeiou\\") s_lower = s.lower() return all(vowel in s_lower for vowel in vowels)"},{"question":"def find_longest_special_subarray(messages): Find the length of the longest special subarray for each message. A special subarray is a contiguous segment of the array that contains exactly two distinct integers. >>> find_longest_special_subarray([[4, 1, 2, 1, 4, 4, 1], [1, 1, 1, 1, 1]]) [4, 0] >>> find_longest_special_subarray([[1], [2]]) [0, 0] >>> find_longest_special_subarray([[1, 1, 1], [2, 2, 2, 2]]) [0, 0] >>> find_longest_special_subarray([[1, 2, 1, 3, 4], [2, 3, 2, 2, 3, 4, 4]]) [3, 5] >>> find_longest_special_subarray([[1, 2, 2, 1], [1, 2, 3, 2, 1]]) [4, 3]","solution":"def find_longest_special_subarray(messages): def longest_special_subarray_length(array): n = len(array) if n < 2: return 0 left = 0 right = 0 max_len = 0 count = {} while right < n: if len(count) <= 2: count[array[right]] = count.get(array[right], 0) + 1 if len(count) == 2: max_len = max(max_len, right - left + 1) right += 1 while len(count) > 2: count[array[left]] -= 1 if count[array[left]] == 0: del count[array[left]] left += 1 return max_len result = [] for message in messages: result.append(longest_special_subarray_length(message)) return result"},{"question":"class Library: def __init__(self, n): Initialize the library with n books, all marked as available. pass def borrow_book(self, book_id): Borrow a book with the given ID. pass def return_book(self, book_id): Return a book with the given ID. pass def status(self): Print the current status of the library, showing available and borrowed books. Returns: available_books_sorted - List of available books in increasing order borrowed_books_sorted - List of borrowed books in increasing order pass # Example unit tests for the Library system def test_initial_status(): library = Library(5) available, borrowed = library.status() assert available == [1, 2, 3, 4, 5] assert borrowed == [] def test_borrow_books(): library = Library(5) library.borrow_book(3) library.borrow_book(1) available, borrowed = library.status() assert available == [2, 4, 5] assert borrowed == [1, 3] def test_return_books(): library = Library(5) library.borrow_book(3) library.borrow_book(1) library.return_book(1) available, borrowed = library.status() assert available == [1, 2, 4, 5] assert borrowed == [3] def test_complex_operations(): library = Library(5) library.borrow_book(3) library.borrow_book(1) library.return_book(1) library.borrow_book(2) available, borrowed = library.status() assert available == [1, 4, 5] assert borrowed == [2, 3]","solution":"class Library: def __init__(self, n): self.available_books = set(range(1, n + 1)) self.borrowed_books = set() def borrow_book(self, book_id): if book_id in self.available_books: self.available_books.remove(book_id) self.borrowed_books.add(book_id) def return_book(self, book_id): if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) self.available_books.add(book_id) def status(self): available_books_sorted = sorted(self.available_books) borrowed_books_sorted = sorted(self.borrowed_books) return available_books_sorted, borrowed_books_sorted"},{"question":"def possible_to_rearrange_palindrome(s: str, friends: List[Tuple[str, str]]) -> str: Determine if it's possible to rearrange the string such that it becomes a palindrome by considering the friend pairs. >>> possible_to_rearrange_palindrome(\\"abac\\", [(\\"a\\", \\"b\\"), (\\"a\\", \\"c\\")]) 'YES' >>> possible_to_rearrange_palindrome(\\"abcfbc\\", [(\\"a\\", \\"b\\"), (\\"c\\", \\"d\\")]) 'NO'","solution":"def possible_to_rearrange_palindrome(s, friends): from collections import defaultdict, Counter def find(x): if parent[x] == x: return x parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Initialize each letter's parent as itself parent = {chr(i): chr(i) for i in range(ord('a'), ord('z') + 1)} # union sets based on friend relationships for a, b in friends: union(a, b) # Create a count for each character, considering their root representative char_count = Counter(find(c) for c in s) # To form a palindrome, at most 1 character's count can be odd odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def min_replacements_to_balance(s: str) -> int: Determine the minimum number of characters that need to be replaced to make the string balanced. A string is balanced if no two adjacent characters are the same. Each replacement involves changing a character to any character from 'a' to 'z'. >>> min_replacements_to_balance('aa') 1 >>> min_replacements_to_balance('abcdeba') 0 >>> min_replacements_to_balance('aabbcc') 3","solution":"def min_replacements_to_balance(s: str) -> int: replacements = 0 for i in range(1, len(s)): if s[i] == s[i-1]: replacements += 1 return replacements"},{"question":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the given array. pass def process_test_cases(test_cases): Processes multiple test cases to find the length of the longest increasing subsequence for each. Input: - test_cases: A list of tuples, each containing the length of the array and the array itself. Output: - A list of integers representing the length of the longest increasing subsequence for each test case. pass import pytest def test_single_case(): assert process_test_cases([(6, [5, 8, 3, 7, 9, 1])]) == [3] def test_multiple_cases(): assert process_test_cases([ (6, [5, 8, 3, 7, 9, 1]), (5, [10, 20, 10, 30, 40, 50]) ]) == [3, 5] def test_empty_array(): assert process_test_cases([(0, [])]) == [0] def test_all_increasing(): assert process_test_cases([(5, [1, 2, 3, 4, 5])]) == [5] def test_all_decreasing(): assert process_test_cases([(5, [5, 4, 3, 2, 1])]) == [1] def test_single_element(): assert process_test_cases([(1, [42])]) == [1] def test_mixed_numbers(): assert process_test_cases([ (10, [3, 1, 8, 2, 5, 6, 7, 4, 9, 11]) ]) == [7]","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 n = len(arr) lis = [1] * n # Initialize LIS values for all indexes to 1 for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def process_test_cases(test_cases): Processes multiple test cases to find the length of the longest increasing subsequence for each. Input: - test_cases: A list of tuples, each containing the length of the array and the array itself. Output: - A list of integers representing the length of the longest increasing subsequence for each test case. results = [] for n, arr in test_cases: results.append(length_of_lis(arr)) return results"},{"question":"def max_non_overlapping_tasks(datasets): Determine the maximum number of non-overlapping tasks that can be performed. Given the start and end times of each task, this function returns the maximum number of tasks that can be accomplished without any overlap for multiple datasets. Args: datasets (List[List[Tuple[int, int]]]): A list of datasets, each containing start and end times of tasks. Returns: List[int]: A list of integers indicating the maximum number of non-overlapping tasks for each dataset. Example: >>> datasets = [ ... [(1, 3), (2, 5), (3, 6), (4, 7), (6, 8)], ... [(7, 8), (2, 4), (5, 9)] ... ] >>> max_non_overlapping_tasks(datasets) [3, 2]","solution":"def max_non_overlapping_tasks(datasets): results = [] for tasks in datasets: tasks.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in tasks: if start >= end_time: count += 1 end_time = end results.append(count) return results"},{"question":"def format_date(date: str, format: str) -> str: Formats the date according to the given format string. :param date: a string in the format \\"YYYY-MM-DD\\" :param format: a string containing placeholders {YYYY, MM, DD} :return: the date formatted according to the format string >>> format_date(\\"2023-10-30\\", \\"MM/DD/YYYY\\") '10/30/2023' >>> format_date(\\"2023-10-30\\", \\"DD-MM-YYYY\\") '30-10-2023' >>> format_date(\\"2023-10-30\\", \\"YYYY.MM.DD\\") '2023.10.30' >>> format_date(\\"2023-10-30\\", \\"DD/MM\\") '30/10' >>> format_date(\\"2023-10-30\\", \\"Month: MM, Year: YYYY\\") 'Month: 10, Year: 2023'","solution":"def format_date(date, format): Formats the date according to the given format string. :param date: a string in the format \\"YYYY-MM-DD\\" :param format: a string containing placeholders {YYYY, MM, DD} :return: the date formatted according to the format string year, month, day = date.split(\\"-\\") formatted_date = format.replace(\\"YYYY\\", year).replace(\\"MM\\", month).replace(\\"DD\\", day) return formatted_date"},{"question":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of two numbers using the Euclidean algorithm. If both inputs are zero, the function returns None. >>> gcd(48, 18) # 6 >>> gcd(0, 18) # 18 >>> gcd(0, 0) # None >>> gcd(101, 103) # 1","solution":"def gcd(a, b): Returns the greatest common divisor (GCD) of two numbers using the Euclidean algorithm. If both inputs are zero, the function returns None. if a == 0 and b == 0: return None a = abs(a) b = abs(b) while b: a, b = b, a % b return a"},{"question":"def find_partition_index(N: int, A: List[int]) -> int: Determines whether the array can be partitioned into two non-empty subarrays such that the sum of the elements in the first subarray is equal to the sum of the elements in the second subarray. Input: N - an integer, the length of the array (2 ≤ N ≤ 10^5) A - a list of N space-separated positive integers (1 ≤ Ai ≤ 10^9), the elements of the array Output: A single integer representing the index i for the partition or -1 if no suitable partition exists. Examples: >>> find_partition_index(6, [1, 2, 3, 3, 2, 1]) 3 >>> find_partition_index(5, [1, 1, 1, 1, 1]) -1","solution":"def find_partition_index(N, A): Finds the partitioning index such that the sum of the elements in the first subarray is equal to the sum of the elements in the second subarray. If no partition is possible, returns -1. total_sum = sum(A) left_sum = 0 for i in range(N - 1): left_sum += A[i] if left_sum == total_sum - left_sum: return i + 1 return -1"},{"question":"from typing import List, Dict, Tuple from collections import defaultdict, deque def simulate_datasets(datasets: List[Dict]) -> List[int]: Simulate multiple datasets of network traffic scenarios and return the results of data transfer requests. Arguments: datasets -- List of dictionaries, where each dictionary contains: - meta: A tuple (n, m, r) - n: number of nodes in the network - m: number of bidirectional links - r: number of transfer requests - links: List of tuples (u, v, b) - u, v: nodes which are connected - b: bandwidth of the link - requests: List of tuples (s, d, a) - s: source node - d: destination node - a: amount of data to be transferred Returns: List of integers representing the maximum data that can be transferred for each request. Example: >>> datasets = [{ ... 'meta': (4, 5, 3), ... 'links': [ ... (0, 1, 10), ... (0, 2, 5), ... (1, 2, 15), ... (1, 3, 10), ... (2, 3, 5) ... ], ... 'requests': [ ... (0, 3, 10), ... (1, 2, 7), ... (0, 1, 12) ... ] ... }] >>> simulate_datasets(datasets) [10, 7, 12] pass def test_single_small_case(): datasets = [{ 'meta': (4, 5, 3), 'links': [ (0, 1, 10), (0, 2, 5), (1, 2, 15), (1, 3, 10), (2, 3, 5) ], 'requests': [ (0, 3, 10), (1, 2, 7), (0, 1, 12) ] }] assert simulate_datasets(datasets) == [10, 7, 12] def test_another_small_case(): datasets = [{ 'meta': (3, 3, 2), 'links': [ (0, 1, 4), (1, 2, 5), (2, 0, 7) ], 'requests': [ (0, 2, 6), (1, 0, 5) ] }] assert simulate_datasets(datasets) == [6, 5] def test_no_links(): datasets = [{ 'meta': (2, 0, 1), 'links': [], 'requests': [ (0, 1, 10) ] }] assert simulate_datasets(datasets) == [0] def test_single_node_no_requests(): datasets = [{ 'meta': (1, 0, 0), 'links': [], 'requests': [] }] assert simulate_datasets(datasets) == [] def test_infeasible_transfer(): datasets = [{ 'meta': (3, 1, 1), 'links': [ (0, 1, 4) ], 'requests': [ (0, 2, 6) ] }] assert simulate_datasets(datasets) == [0]","solution":"from collections import defaultdict, deque def bfs(capacity, parent, source, sink): visited = set() queue = deque([source]) visited.add(source) while queue: u = queue.popleft() for v in capacity[u]: if v not in visited and capacity[u][v] > 0: # If there's available capacity visited.add(v) queue.append(v) parent[v] = u if v == sink: return True return False def edmonds_karp(capacity, source, sink): parent = {} max_flow = 0 while bfs(capacity, parent, source, sink): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def analyze_network(n, m, r, links, requests): network = defaultdict(lambda: defaultdict(int)) for u, v, b in links: network[u][v] += b network[v][u] += b results = [] for s, d, a in requests: capacity = defaultdict(lambda: defaultdict(int)) for u in range(n): for v in network[u]: capacity[u][v] = network[u][v] max_data_transfer = edmonds_karp(capacity, s, d) results.append(min(max_data_transfer, a)) return results def simulate_datasets(datasets): results = [] for dataset in datasets: n, m, r = dataset['meta'] links = dataset['links'] requests = dataset['requests'] results += analyze_network(n, m, r, links, requests) return results def main(): import sys input = sys.stdin.read data = input().split() index = 0 datasets = [] while data[index] != '0': n = int(data[index]) m = int(data[index + 1]) r = int(data[index + 2]) index += 3 links = [] for _ in range(m): u = int(data[index]) v = int(data[index + 1]) b = int(data[index + 2]) links.append((u, v, b)) index += 3 requests = [] for _ in range(r): s = int(data[index]) d = int(data[index + 1]) a = int(data[index + 2]) requests.append((s, d, a)) index += 3 datasets.append({ 'meta': (n, m, r), 'links': links, 'requests': requests }) results = simulate_datasets(datasets) for result in results: print(result)"},{"question":"def most_frequent_visitor(logs: List[str]) -> int: Determine the badge ID of the most frequent visitor of the month. If there are multiple employees with the same highest frequency, return the smallest badge ID. Args: logs (List[str]): A list of log entries where each entry is a string containing a timestamp and a badge ID. Returns: int: The badge ID of the most frequent visitor. Examples: >>> most_frequent_visitor([ ... \\"2023-01-01 9999\\", ... \\"2023-01-01 1234\\", ... \\"2023-01-01 1234\\", ... \\"2023-01-02 9999\\", ... \\"2023-01-02 9999\\", ... \\"2023-01-02 1234\\", ... \\"2023-01-03 9999\\", ... ]) == 9999 >>> most_frequent_visitor([ ... \\"2023-01-01 9999\\", ... \\"2023-01-01 1234\\", ... \\"2023-01-02 9999\\", ... \\"2023-01-02 1234\\", ... \\"2023-01-03 1234\\", ... ]) == 1234 >>> most_frequent_visitor([ ... \\"2023-01-01 9999\\", ... ]) == 9999 >>> most_frequent_visitor([ ... \\"2023-01-01 1234\\", ... \\"2023-01-01 5678\\", ... \\"2023-01-01 9101\\", ... \\"2023-01-02 9101\\", ... \\"2023-01-02 5678\\", ... ]) == 5678 >>> most_frequent_visitor([ ... \\"2023-01-01 9999\\", ... \\"2023-01-01 1234\\", ... \\"2023-01-01 6123\\", ... \\"2023-01-02 9999\\", ... \\"2023-01-02 1234\\", ... \\"2023-01-02 6123\\", ... ]) == 1234","solution":"def most_frequent_visitor(logs): from collections import defaultdict badge_counts = defaultdict(int) for log in logs: timestamp, badge_id = log.split() badge_id = int(badge_id) badge_counts[badge_id] += 1 max_visits = max(badge_counts.values()) most_frequent_badges = [badge_id for badge_id, count in badge_counts.items() if count == max_visits] return min(most_frequent_badges) # Example usage: logs = [ \\"2023-01-01 9999\\", \\"2023-01-01 1234\\", \\"2023-01-01 1234\\", \\"2023-01-02 9999\\", \\"2023-01-02 9999\\", \\"2023-01-02 1234\\", \\"2023-01-03 9999\\", ] print(most_frequent_visitor(logs)) # Output: 9999"},{"question":"def longest_contiguous_subsequence(N: int, K: int, array: List[int]) -> int: Returns the length of the longest contiguous subsequence where the difference between the minimum and maximum elements is less than or equal to K. >>> longest_contiguous_subsequence(6, 3, [1, 3, 6, 7, 9, 10]) 3 >>> longest_contiguous_subsequence(5, 2, [4, 4, 4, 4, 4]) 5 >>> longest_contiguous_subsequence(4, 1, [1, 5, 9, 13]) 1 >>> longest_contiguous_subsequence(5, 10, [3, 8, 5, 10, 7]) 5 >>> longest_contiguous_subsequence(7, 4, [1, 2, 3, 5, 6, 8, 10]) 4 >>> longest_contiguous_subsequence(7, 5, [1, 1, 3, 1, 2, 1, 3]) 7","solution":"def longest_contiguous_subsequence(N, K, array): Returns the length of the longest contiguous subsequence where the difference between the minimum and maximum elements is less than or equal to K. max_len = 0 start = 0 for end in range(N): sub_array = array[start:end+1] # Get the current subsequence from start to end if max(sub_array) - min(sub_array) <= K: max_len = max(max_len, end - start + 1) else: while max(array[start:end+1]) - min(array[start:end+1]) > K: start += 1 return max_len"},{"question":"def reverse_characters_in_words(s: str) -> str: Reverses the order of characters in each word while maintaining the order of the words. Parameters: s (str): Input string with words separated by spaces. Returns: str: A new string with each word's characters reversed. Examples: >>> reverse_characters_in_words('Hello World') 'olleH dlroW' >>> reverse_characters_in_words('The quick brown fox jumps over the lazy dog') 'ehT kciuq nworb xof spmuj revo eht yzal god' >>> reverse_characters_in_words('Data Science is fun') 'ataD ecneicS si nuf' >>> reverse_characters_in_words('Python is amazing') 'nohtyP si gnizama'","solution":"def reverse_characters_in_words(s): Reverses the order of characters in each word while maintaining the order of the words. Parameters: s (str): Input string with words separated by spaces. Returns: str: A new string with each word's characters reversed. return ' '.join(word[::-1] for word in s.split())"},{"question":"from typing import List, Union def flatten_and_square(nested_list: List[Union[int, list]]) -> List[int]: Accepts a nested list of integers and returns a list with all the integers flattened and each integer squared. Examples: >>> flatten_and_square([[1, 2, 3], [4, 5], [6]]) [1, 4, 9, 16, 25, 36] >>> flatten_and_square([[-1, -2], [0], [3, 4]]) [1, 4, 0, 9, 16] >>> flatten_and_square([[]]) []","solution":"def flatten_and_square(nested_list): Accepts a nested list of integers and returns a list with all the integers flattened and each integer squared. :param nested_list: Nested list of integers :return: Flattened list with each integer squared flattened_list = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: flattened_list.append(element) flatten(nested_list) return [x**2 for x in flattened_list]"},{"question":"def evaluate(expression: str) -> float: Evaluates a string containing an arithmetic expression. The string will contain non-negative integers and the operators +, -, *, and /. The expression must respect the order of operations (PEMDAS/BODMAS rules). >>> evaluate(\\"3+2*2\\") 7 >>> evaluate(\\"3/2\\") 1.5 >>> evaluate(\\"3+5/2\\") 5.5 >>> evaluate(\\"10 + 2 * 6\\") 22 >>> evaluate(\\"100 * 2 + 12\\") 212 >>> evaluate(\\"100 * ( 2 + 12 )\\") 1400 >>> evaluate(\\"100 * ( 2 + 12 ) / 14\\") 100","solution":"def evaluate(expression): Evaluates a string containing an arithmetic expression. The string will contain non-negative integers and the operators +, -, *, and /. The expression must respect the order of operations (PEMDAS/BODMAS rules). try: # Evaluating the expression using Python's eval function after sanitizing input sanitized_expr = expression.replace(' ', '') result = eval(sanitized_expr) return float(result) if isinstance(result, float) else int(result) except Exception as e: raise ValueError(f\\"Error evaluating expression: {e}\\")"},{"question":"def min_operations_to_one(n: int) -> int: Given a positive integer n, determine the minimum number of operations required to transform n into 1. The operations you can perform are: 1. If n is even, you can divide n by 2. 2. If n is odd, you can either add 1 or subtract 1. >>> min_operations_to_one(8) 3 >>> min_operations_to_one(7) 4 >>> min_operations_to_one(15) 5 >>> min_operations_to_one(1) 0 >>> min_operations_to_one(16) 4 >>> min_operations_to_one(1024) 10 >>> min_operations_to_one(13) 5 >>> min_operations_to_one(3) 2","solution":"def min_operations_to_one(n: int) -> int: Returns the minimum number of operations required to transform n into 1. if n == 1: return 0 operations = 0 while n != 1: if n % 2 == 0: n //= 2 else: if (n == 3) or ((n - 1) // 2 % 2 == 0): n -= 1 else: n += 1 operations += 1 return operations"},{"question":"class Warehouse: def __init__(self, shelves): Initialize the warehouse with the given list of shelves. shelves: List of integers representing the initial number of items on each shelf. pass def add_item(self, shelf_id, count): Add 'count' items to the shelf with id 'shelf_id'. shelf_id: 1-indexed id of the shelf. count: Number of items to add. pass def remove_item(self, shelf_id, count): Remove 'count' items from the shelf with id 'shelf_id'. shelf_id: 1-indexed id of the shelf. count: Number of items to remove. pass def get_total_items(self): Return the total number of items across all shelves. pass from solution import Warehouse def test_initial_setup(): warehouse = Warehouse([10, 20, 30]) assert warehouse.get_total_items() == 60 def test_add_item(): warehouse = Warehouse([10, 20, 30]) warehouse.add_item(1, 5) assert warehouse.get_total_items() == 65 assert warehouse.shelves[0] == 15 def test_remove_item(): warehouse = Warehouse([10, 20, 30]) warehouse.remove_item(2, 15) assert warehouse.get_total_items() == 45 assert warehouse.shelves[1] == 5 def test_remove_more_than_existing_items(): warehouse = Warehouse([10, 20, 30]) warehouse.remove_item(2, 25) assert warehouse.get_total_items() == 40 assert warehouse.shelves[1] == 0 def test_combined_operations(): warehouse = Warehouse([10, 20, 30]) warehouse.add_item(1, 5) assert warehouse.get_total_items() == 65 warehouse.remove_item(3, 15) assert warehouse.get_total_items() == 50 warehouse.remove_item(2, 25) assert warehouse.get_total_items() == 30","solution":"class Warehouse: def __init__(self, shelves): Initialize the warehouse with the given list of shelves. shelves: List of integers representing the initial number of items on each shelf. self.shelves = shelves self.total_items = sum(shelves) def add_item(self, shelf_id, count): Add 'count' items to the shelf with id 'shelf_id'. shelf_id: 1-indexed id of the shelf. count: Number of items to add. self.shelves[shelf_id - 1] += count self.total_items += count def remove_item(self, shelf_id, count): Remove 'count' items from the shelf with id 'shelf_id'. shelf_id: 1-indexed id of the shelf. count: Number of items to remove. actual_remove = min(self.shelves[shelf_id - 1], count) self.shelves[shelf_id - 1] -= actual_remove self.total_items -= actual_remove def get_total_items(self): Return the total number of items across all shelves. return self.total_items"},{"question":"def minimum_effort_to_clear_dungeon(n, p, enemies): Calculate the minimum effort required to clear all the rooms in the dungeon. :param n: Number of rooms :param p: Number of magic potions available :param enemies: List containing the number of enemies in each room :return: Minimum effort required to clear all rooms >>> minimum_effort_to_clear_dungeon(5, 2, [4, 2, 3, 5, 8]) == 9 >>> minimum_effort_to_clear_dungeon(3, 1, [3, 5, 2]) == 5 >>> minimum_effort_to_clear_dungeon(4, 0, [4, 6, 8, 2]) == 20 >>> minimum_effort_to_clear_dungeon(4, 4, [4, 6, 8, 2]) == 0 >>> minimum_effort_to_clear_dungeon(1, 1, [10]) == 0 >>> minimum_effort_to_clear_dungeon(4, 2, [1, 2, 3, 4]) == 3","solution":"def minimum_effort_to_clear_dungeon(n, p, enemies): Calculate the minimum effort required to clear all the rooms in the dungeon. :param n: Number of rooms :param p: Number of magic potions available :param enemies: List containing the number of enemies in each room :return: Minimum effort required to clear all rooms # Sort the list of enemies in descending order enemies_sorted = sorted(enemies, reverse=True) # Use potions on the rooms with the most enemies effort = 0 for i in range(p, n): effort += enemies_sorted[i] return effort"},{"question":"def max_buildings_to_visit(N: int, heights: List[int]) -> int: Determine the maximum number of buildings you can visit starting from any building and only moving to higher or equal buildings. Args: N (int): Number of buildings. heights (List[int]): List of heights of buildings. Returns: int: Maximum number of buildings you can visit. Examples: >>> max_buildings_to_visit(5, [1, 2, 2, 3, 2]) 4 >>> max_buildings_to_visit(3, [5, 4, 3]) 1 >>> max_buildings_to_visit(6, [4, 4, 4, 4, 4, 4]) 6","solution":"def max_buildings_to_visit(N, heights): if N == 0: return 0 max_visits = 1 current_visits = 1 for i in range(1, N): if heights[i] >= heights[i - 1]: current_visits += 1 max_visits = max(max_visits, current_visits) else: current_visits = 1 return max_visits # Example usage: # N = 5 # heights = [1, 2, 2, 3, 2] # print(max_buildings_to_visit(N, heights)) # Output: 4"},{"question":"from typing import List from collections import defaultdict def count_good_subarrays(arr: List[int], K: int) -> int: Returns the number of \\"good subarrays\\" in arr where a \\"good subarray\\" is a subarray whose elements sum to a multiple of K. >>> count_good_subarrays([4, 5, 0, -2, -3, 1], 5) 7 >>> count_good_subarrays([2, 7, 6, 1, 4, 5], 3) 5 >>> count_good_subarrays([1, 2, 3, 4, 5], 1) 15","solution":"from typing import List from collections import defaultdict def count_good_subarrays(arr: List[int], K: int) -> int: Returns the number of \\"good subarrays\\" in arr where a \\"good subarray\\" is a subarray whose elements sum to a multiple of K. count = 0 prefix_sum = 0 remainder_count = defaultdict(int) remainder_count[0] = 1 for num in arr: prefix_sum += num remainder = prefix_sum % K if remainder < 0: remainder += K count += remainder_count[remainder] remainder_count[remainder] += 1 return count"},{"question":"def decorate_stalls(n: int) -> str: Generates a sequence of 'x' and 'o' decorations for n stalls such that no two same decorations are adjacent to each other. >>> decorate_stalls(5) 'xoxox' >>> decorate_stalls(4) 'xoxo' >>> decorate_stalls(7) 'xoxoxox' >>> decorate_stalls(2) 'xo' >>> decorate_stalls(1) 'x' >>> decorate_stalls(3) 'xox'","solution":"def decorate_stalls(n): Generates a sequence of 'x' and 'o' decorations for n stalls such that no two same decorations are adjacent to each other. :param n: int - the number of stalls. :return: str - the sequence of decorations. sequence = [] for i in range(n): if i % 2 == 0: sequence.append('x') else: sequence.append('o') return ''.join(sequence)"},{"question":"import math from typing import List def find_gcd_distances(N: int, positions: List[int]) -> int: Given the positions of N stars on a line, return the GCD of the distances between consecutive stars. Parameters: N (int): Number of stars. positions (list): List of positions of the stars in ascending order. Returns: int: The GCD of the distances between consecutive stars. >>> find_gcd_distances(4, [10, 15, 20, 30]) 5 >>> find_gcd_distances(2, [2, 5]) 3 >>> find_gcd_distances(5, [1, 3, 5, 7, 9]) 2 >>> find_gcd_distances(3, [100000000, 100000500, 100000800]) 100 >>> find_gcd_distances(4, [4, 8, 10, 14]) 2 >>> find_gcd_distances(3, [3, 7, 11]) 4 >>> find_gcd_distances(2, [1, 1]) 0","solution":"import math def find_gcd_distances(N, positions): Given the positions of N stars on a line, return the GCD of the distances between consecutive stars. Parameters: N (int): Number of stars. positions (list): List of positions of the stars in ascending order. Returns: int: The GCD of the distances between consecutive stars. # Calculate the distances between consecutive stars distances = [positions[i] - positions[i-1] for i in range(1, N)] # Compute the GCD of these distances gcd_distance = distances[0] for distance in distances[1:]: gcd_distance = math.gcd(gcd_distance, distance) return gcd_distance"},{"question":"def find_planes(n, cities, a): Given the number of cities in SpaceLand and their coordinates in 3D space, find six distinct planes that divide SpaceLand into 27 parts, each containing a specified number of cities. Args: n (int): The number of cities. cities (List[List[int]]): Coordinates of each city. a (List[int]): A list containing the expected number of cities in each part. Returns: -1 if no solution found. Otherwise, return three lists of two floats each representing the coordinates of the planes. Example: >>> find_planes(27, [[1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 1], [1, 2, 2], [1, 2, 3], [1, 3, 1], [1, 3, 2], [1, 3, 3], [2, 1, 1], [2, 1, 2], [2, 1, 3], [2, 2, 1], [2, 2, 2], [2, 2, 3], [2, 3, 1], [2, 3, 2], [2, 3, 3], [3, 1, 1], [3, 1, 2], [3, 1, 3], [3, 2, 1], [3, 2, 2], [3, 2, 3], [3, 3, 1], [3, 3, 2], [3, 3, 3]], [1]*27) ([1.5, 2.5], [1.5, 2.5], [1.5, 2.5]) def test_find_planes_no_solution(): n = 27 cities = [ [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 1], [1, 2, 2], [1, 2, 3], [1, 3, 1], [1, 3, 2], [1, 3, 3], [2, 1, 1], [2, 1, 2], [2, 1, 3], [2, 2, 1], [2, 2, 2], [2, 2, 3], [2, 3, 1], [2, 3, 2], [2, 3, 3], [3, 1, 1], [3, 1, 2], [3, 1, 3], [3, 2, 1], [3, 2, 2], [3, 2, 3], [3, 3, 1], [3, 3, 2], [3, 3, 3] ] a = [0]*27 assert find_planes(n, cities, a) == -1 def test_find_planes_simple_solution(): n = 27 cities = [ [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 1], [1, 2, 2], [1, 2, 3], [1, 3, 1], [1, 3, 2], [1, 3, 3], [2, 1, 1], [2, 1, 2], [2, 1, 3], [2, 2, 1], [2, 2, 2], [2, 2, 3], [2, 3, 1], [2, 3, 2], [2, 3, 3], [3, 1, 1], [3, 1, 2], [3, 1, 3], [3, 2, 1], [3, 2, 2], [3, 2, 3], [3, 3, 1], [3, 3, 2], [3, 3, 3] ] a = [1]*27 assert find_planes(n, cities, a) == ([1.5, 2.5], [1.5, 2.5], [1.5, 2.5])","solution":"def find_planes(n, cities, a): import itertools from collections import Counter # Sort and find unique x, y, z coordinates x_coords = sorted(set(city[0] for city in cities)) y_coords = sorted(set(city[1] for city in cities)) z_coords = sorted(set(city[2] for city in cities)) # Ensure we have enough unique coordinates if len(x_coords) < 3 or len(y_coords) < 3 or len(z_coords) < 3: return -1 x_planes = [x_coords[0] + (x_coords[1] - x_coords[0]) / 2, x_coords[1] + (x_coords[2] - x_coords[1]) / 2] y_planes = [y_coords[0] + (y_coords[1] - y_coords[0]) / 2, y_coords[1] + (y_coords[2] - y_coords[1]) / 2] z_planes = [z_coords[0] + (z_coords[1] - z_coords[0]) / 2, z_coords[1] + (z_coords[2] - z_coords[1]) / 2] # Group the cities into 27 parts partitions = Counter() for city in cities: x_part = 0 if city[0] < x_planes[0] else (1 if city[0] < x_planes[1] else 2) y_part = 0 if city[1] < y_planes[0] else (1 if city[1] < y_planes[1] else 2) z_part = 0 if city[2] < z_planes[0] else (1 if city[2] < z_planes[1] else 2) partitions[(x_part, y_part, z_part)] += 1 sorted_a = sorted(a) sorted_partitions = sorted(partitions.values()) # Verify if partitions match a values if sorted_a != sorted_partitions: return -1 return x_planes, y_planes, z_planes"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return False return True def count_prime_ages_greater_than_x(N: int, X: int, ages: List[int]) -> int: Counts the number of ages that are both greater than X and prime numbers. >>> count_prime_ages_greater_than_x(6, 10, [11, 14, 17, 18, 19, 21]) 3 >>> count_prime_ages_greater_than_x(5, 20, [22, 23, 24, 29, 30]) 2 pass","solution":"import math def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return False return True def count_prime_ages_greater_than_x(N, X, ages): Counts the number of ages that are both greater than X and prime numbers. prime_ages_count = 0 for age in ages: if age > X and is_prime(age): prime_ages_count += 1 return prime_ages_count # Input and output handling if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) X = int(data[1]) ages = list(map(int, data[2:2 + N])) result = count_prime_ages_greater_than_x(N, X, ages) print(result)"},{"question":"from typing import List, Tuple def longest_common_subsequence(S: str, T: str) -> int: Returns the length of the longest common subsequence between strings S and T. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"xyz\\", \\"yz\\") 2 # Implement the function here def process_test_cases(Q: int, cases: List[Tuple[str, str]]) -> List[int]: Processes multiple test cases and returns the results as a list of integers. >>> process_test_cases(3, [(\\"abcde\\", \\"ace\\"), (\\"xyz\\", \\"yz\\"), (\\"abcdef\\", \\"ghijkl\\")]) [3, 2, 0] >>> process_test_cases(2, [(\\"aa\\", \\"a\\"), (\\"a\\", \\"z\\")]) [1, 0] # Implement the function here","solution":"def longest_common_subsequence(S, T): Returns the length of the longest common subsequence between strings S and T. N = len(S) M = len(T) dp = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[N][M] def process_test_cases(Q, cases): results = [] for case in cases: S, T = case results.append(longest_common_subsequence(S, T)) return results"},{"question":"def minimum_attacks_required(N, K, healths): Calculates the minimum number of attacks required to reduce all monsters' health to zero or less. Parameters: N (int): Number of monsters K (int): Attack power healths (list of int): List containing the health values of the monsters Returns: int: Minimum number of attacks required Examples: >>> minimum_attacks_required(5, 100, [450, 900, 200, 300, 700]) 26 >>> minimum_attacks_required(1, 100, [50]) 1 >>> minimum_attacks_required(1, 100, [250]) 3 >>> minimum_attacks_required(3, 100, [200, 200, 200]) 6 >>> minimum_attacks_required(2, 2000, [1000, 1500]) 2 >>> minimum_attacks_required(2, 500, [1000, 1500]) 5 >>> minimum_attacks_required(4, 250, [750, 600, 200, 800]) 11","solution":"def minimum_attacks_required(N, K, healths): Calculates the minimum number of attacks required to reduce all monsters' health to zero or less. Parameters: N (int): Number of monsters K (int): Attack power healths (list of int): List containing the health values of the monsters Returns: int: Minimum number of attacks required attacks = 0 for health in healths: attacks += (health + K - 1) // K # Adding K-1 for ceiling effect to avoid float division return attacks # Example function call # N = 5 # K = 100 # healths = [450, 900, 200, 300, 700] # print(minimum_attacks_required(N, K, healths)) # Output: 26"},{"question":"from typing import List, Tuple, Union def valley_permutation(n: int, elements: List[int]) -> Union[str, Tuple[str, List[int]]]: Determines whether there exists a valley permutation for the input list of elements. If it exists, returns a tuple of (\\"YES\\", permutation). Otherwise, returns \\"NO\\". >>> valley_permutation(5, [1, 2, 3, 4, 5]) ('YES', [1, 3, 2, 5, 4]) >>> valley_permutation(3, [2, 1, 3]) ('YES', [1, 3, 2]) >>> valley_permutation(2, [1, 2]) 'NO'","solution":"def valley_permutation(n, elements): Determines whether there exists a valley permutation for the input list of elements. If it exists, returns a tuple of (\\"YES\\", permutation). Otherwise, returns \\"NO\\". if n < 3: return \\"NO\\" elements.sort() # Create the valley permutation mid = (n + 1) // 2 left_part = elements[:mid] right_part = elements[mid:] # Merge two parts to make a valley permutation result = [] for i in range(len(left_part)): result.append(left_part[i]) if i < len(right_part): result.append(right_part[i]) return \\"YES\\", result"},{"question":"def calculate_subtree_weights(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Calculate the subtree weights for given nodes in a tree. Args: - n (int): The number of nodes in the tree. - values (List[int]): The values associated with the nodes. - edges (List[Tuple[int, int]]): The edges defining the tree. - queries (List[int]): The nodes for which the subtree weights are required. Returns: - List[int]: The subtree weights corresponding to each query. Example: >>> calculate_subtree_weights(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)], [1, 3, 4]) [15, 12, 4] >>> calculate_subtree_weights(1, [7], [], [1]) [7]","solution":"def calculate_subtree_weights(n, values, edges, queries): from collections import defaultdict, deque adj_list = defaultdict(list) # Building adjacency list for the tree/graph for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # This will store the subtree weights of all nodes subtree_weights = [0] * (n + 1) visited = [False] * (n + 1) def dfs(node): visited[node] = True subtree_sum = values[node - 1] # current node's value for neighbor in adj_list[node]: if not visited[neighbor]: subtree_sum += dfs(neighbor) subtree_weights[node] = subtree_sum return subtree_sum # Start DFS from the root node which is 1 dfs(1) # Answering the queries results = [] for q in queries: results.append(subtree_weights[q]) return results"},{"question":"def get_mst_cost(n: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the total cost of the Minimum Spanning Tree for the given number of locations and edges. Return -1 if it's not possible to connect all nodes. Args: n (int): Number of locations (nodes). edges (List[Tuple[int, int, int]]): List of tuples representing direct routes (u, v, w) with transportation cost w. Returns: int: Total cost of the Minimum Spanning Tree. -1 if not all nodes can be connected. Examples: >>> get_mst_cost(4, [(1, 2, 1), (2, 3, 4), (3, 4, 2), (4, 1, 3)]) 6 >>> get_mst_cost(4, [(1, 2, 1), (2, 3, 4)]) -1","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def get_mst_cost(n, edges): edges.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n mst_cost = 0 edge_count = 0 for u, v, w in edges: u -= 1 v -= 1 x = find(parent, u) y = find(parent, v) if x != y: edge_count += 1 mst_cost += w union(parent, rank, x, y) if edge_count == n - 1: break if edge_count != n - 1: return -1 return mst_cost"},{"question":"from typing import List def most_popular_category(transactions: List[str]) -> str: Returns the category with the highest total sales value. If multiple categories have the same highest sales value, returns the one that appears first alphabetically. >>> most_popular_category([\\"Electronics:200\\", \\"Clothing:100\\", \\"Electronics:150\\", \\"Groceries:300\\", \\"Clothing:200\\"]) 'Electronics' >>> most_popular_category([\\"Toys:50\\", \\"Books:50\\", \\"Toys:100\\", \\"Books:100\\", \\"Clothing:150\\"]) 'Books' # Your implementation here","solution":"def most_popular_category(transactions): Returns the category with the highest total sales value. If multiple categories have the same highest sales value, returns the one that appears first alphabetically. sales_dict = {} for transaction in transactions: category, amount = transaction.split(':') amount = int(amount) if category in sales_dict: sales_dict[category] += amount else: sales_dict[category] = amount # Find the max sales value max_sales = max(sales_dict.values()) # Find all categories with max sales value and return the alphabetically smallest one return min(category for category, sales in sales_dict.items() if sales == max_sales)"},{"question":"from typing import List, Tuple def sum_of_max_and_min(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns a list of sums of the maximum and minimum values for each query. >>> sum_of_max_and_min([1, 3, -1, 5, 4], [(0, 2), (1, 3), (0, 4)]) [2, 4, 4] >>> sum_of_max_and_min([5, 4, 3, 2, 1], [(0, 0), (2, 2), (4, 4)]) [10, 6, 2] >>> sum_of_max_and_min([10, -10, 20, -20, 30, -30], [(1, 4)]) [10] >>> sum_of_max_and_min([10, 10, 10, 10], [(0, 3)]) [20] >>> sum_of_max_and_min(list(range(100000)), [(0, 99999)]) [99999] >>> sum_of_max_and_min([-5, -2, 0, 3, 5], [(0, 4), (1, 3)]) [0, 1]","solution":"def sum_of_max_and_min(arr, queries): Returns a list of sums of the maximum and minimum values for each query. :param arr: List of integers representing the array. :param queries: List of tuples (L, R) representing the range for each query. :return: List of integers representing the sum of max and min values for each query. results = [] for L, R in queries: subarray = arr[L:R+1] max_val = max(subarray) min_val = min(subarray) results.append(max_val + min_val) return results"},{"question":"import random def secret_santa(names): Generate a random Secret Santa gift-giving assignment for a list of friends. Ensure that no one gives a gift to themselves and no one receives more than one gift. Args: names (List[str]): List of names of friends participating in Secret Santa. Returns: List[str]: List of strings in the format \\"X -> Y\\" where X gives a gift to Y. def generate_assignments(test_cases): Generate Secret Santa assignments for multiple test cases. Args: test_cases (List[List[str]]): A list of test cases, where each test case is a list of names. Returns: List[List[str]]: List of assignments for each test case. def parse_input(input_string): Parse the input string to extract test cases. Args: input_string (str): The input string containing number of test cases and the names. Returns: List[List[str]]: Parsed test cases from the input string. def format_output(results): Format the results into a string format suitable for output. Args: results (List[List[str]]): The results of Secret Santa assignments per test case. Returns: str: Formatted string of results. # Unit tests def test_secret_santa(): names = ['alice', 'bob', 'charlie'] assignments = secret_santa(names) givers = [assignment.split(\\" -> \\")[0] for assignment in assignments] receivers = [assignment.split(\\" -> \\")[1] for assignment in assignments] assert len(set(receivers)) == len(names) assert all(giver != receiver for giver, receiver in zip(givers, receivers)) def test_secret_santa_different_sizes(): names1 = ['david', 'emma'] names2 = ['david', 'emma', 'frank'] assignments1 = secret_santa(names1) assignments2 = secret_santa(names2) givers1 = [assignment.split(\\" -> \\")[0] for assignment in assignments1] receivers1 = [assignment.split(\\" -> \\")[1] for assignment in assignments1] givers2 = [assignment.split(\\" -> \\")[0] for assignment in assignments2] receivers2 = [assignment.split(\\" -> \\")[1] for assignment in assignments2] assert len(set(receivers1)) == len(names1) assert len(set(receivers2)) == len(names2) assert all(giver != receiver for giver, receiver in zip(givers1, receivers1)) assert all(giver != receiver for giver, receiver in zip(givers2, receivers2)) def test_generate_assignments(): test_cases = [[\\"alice\\", \\"bob\\", \\"charlie\\"], [\\"david\\", \\"emma\\", \\"frank\\", \\"grace\\"]] results = generate_assignments(test_cases) assert len(results) == len(test_cases) def test_parse_input(): input_string = \\"2n3nalice bob charlien4ndavid emma frank gracen\\" expected_output = [['alice', 'bob', 'charlie'], ['david', 'emma', 'frank', 'grace']] assert parse_input(input_string) == expected_output def test_format_output(): results = [['alice -> bob', 'bob -> charlie', 'charlie -> alice'], ['david -> emma', 'emma -> frank', 'frank -> grace', 'grace -> david']] expected_output = \\"alice -> bobnbob -> charliencharlie -> alicenndavid -> emmanemma -> franknfrank -> gracengrace -> david\\" assert format_output(results) == expected_output","solution":"import random def secret_santa(names): total_friends = len(names) givers = names[:] receivers = names[:] random.shuffle(receivers) # Ensure no one receives their own gift while any(giver == receiver for giver, receiver in zip(givers, receivers)): random.shuffle(receivers) return [f\\"{givers[i]} -> {receivers[i]}\\" for i in range(total_friends)] def generate_assignments(test_cases): results = [] for names in test_cases: result = secret_santa(names) results.append(result) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) current_line = 1 test_cases = [] for _ in range(T): N = int(lines[current_line]) names = lines[current_line + 1].split() test_cases.append(names) current_line += 2 return test_cases def format_output(results): output_lines = [] for result in results: output_lines.extend(result) output_lines.append(\\"\\") # Separate different test case results with a blank line return \\"n\\".join(output_lines).strip()"},{"question":"def is_snake_present(grid: List[str]) -> str: Determine if there is at least one snake on the grid. A snake is defined as a connected sequence of characters '#' that either form a straight horizontal or vertical line with a minimum length of 2 cells. >>> is_snake_present([ ... \\".#.\\", ... \\"#\\", ... \\".#.\\" ... ]) \\"YES\\" >>> is_snake_present([ ... \\".....\\", ... \\"...\\", ... \\".#...\\", ... \\".....\\" ... ]) \\"YES\\" >>> is_snake_present([ ... \\"..\\", ... \\".#\\" ... ]) \\"NO\\" >>> is_snake_present([ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ]) \\"NO\\" >>> is_snake_present([ ... \\".....\\", ... \\".....\\", ... \\"...\\" ... ]) \\"YES\\"","solution":"def is_snake_present(grid): m = len(grid) n = len(grid[0]) # Check for horizontal snakes for i in range(m): for j in range(n-1): if grid[i][j] == '#' and grid[i][j+1] == '#': return \\"YES\\" # Check for vertical snakes for i in range(m-1): for j in range(n): if grid[i][j] == '#' and grid[i+1][j] == '#': return \\"YES\\" return \\"NO\\""},{"question":"def uniquePaths(m: int, n: int, grid: List[List[str]]) -> int: Given a grid of size m x n consisting of '0's (empty spaces) and '1's (boulders), find the number of unique paths that the robot can take to get to the bottom-right corner, avoiding all boulders. Args: m: An integer representing the number of rows in the grid. n: An integer representing the number of columns in the grid. grid: A 2D List of strings representing the grid. Returns: An integer representing the number of unique paths from the top-left corner to the bottom-right corner. Examples: >>> uniquePaths(3, 3, [['0', '0', '0'], ['0', '1', '0'], ['0', '0', '0']]) 2 >>> uniquePaths(3, 3, [['0', '1', '0'], ['0', '1', '0'], ['0', '0', '0']]) 1","solution":"def uniquePaths(m, n, grid): if grid[0][0] == '1' or grid[m-1][n-1] == '1': return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == '1': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def find_missing_number(sequence): Takes a list of integers representing an arithmetic sequence with one missing term. Returns the missing number or \\"invalid input\\" if input is invalid. >>> find_missing_number([3, 6, 9, 15]) 12 >>> find_missing_number([7, 14, 28, 35]) 21 >>> find_missing_number([3, 6, 'a', 15]) \\"invalid input\\" >>> find_missing_number([3, 6]) \\"invalid input\\" >>> find_missing_number([-5, 0, 5, 15]) 10 >>> find_missing_number([-15, -10, -5, 5]) 0 >>> find_missing_number([1, 3, 7]) 5 >>> find_missing_number([2, 4, 8, 10, 12]) 6","solution":"def find_missing_number(sequence): Takes a list of integers representing an arithmetic sequence with one missing term. Returns the missing number or \\"invalid input\\" if input is invalid. # Validate input if not all(isinstance(x, int) for x in sequence) or len(sequence) < 3: return \\"invalid input\\" # Calculate the common difference n = len(sequence) total_diff = (sequence[-1] - sequence[0]) // n current_diff = (sequence[1] - sequence[0]) if total_diff != current_diff: missing_num = sequence[0] + total_diff else: for i in range(n-1): if sequence[i+1] - sequence[i] != current_diff: missing_num = sequence[i] + current_diff break return missing_num"},{"question":"def removeDigit(s: str) -> str: Returns the largest number that can be formed by removing exactly one digit from the string s >>> removeDigit(\\"1234\\") \\"234\\" >>> removeDigit(\\"982756\\") \\"98756\\" >>> removeDigit(\\"1\\") \\"\\" >>> removeDigit(\\"10\\") \\"1\\" >>> removeDigit(\\"54321\\") \\"5432\\" >>> removeDigit(\\"7654321\\") \\"765432\\" >>> removeDigit(\\"1000\\") \\"100\\" >>> removeDigit(\\"999\\") \\"99\\" >>> removeDigit(\\"5210\\") \\"521\\" >>> removeDigit(\\"1111\\") \\"111\\" >>> removeDigit(\\"109\\") \\"19\\" >>> removeDigit(\\"65304\\") \\"6534\\"","solution":"def removeDigit(s): Returns the largest number that can be formed by removing exactly one digit from the string s max_num = \\"\\" for i in range(len(s)): temp_num = s[:i] + s[i+1:] if temp_num > max_num: max_num = temp_num return max_num"},{"question":"def distribute_problems(N: int, M: int, K: int) -> str: Determine if it is possible to distribute N problems among M teams, each solving exactly K problems. Return 'Impossible' if not possible, otherwise return the distribution. >>> distribute_problems(10, 2, 5) '1 2 3 4 5n6 7 8 9 10' >>> distribute_problems(8, 4, 2) '1 2n3 4n5 6n7 8' >>> distribute_problems(6, 3, 3) 'Impossible' >>> distribute_problems(6, 1, 6) '1 2 3 4 5 6'","solution":"def distribute_problems(N, M, K): Determine if it is possible to distribute N problems among M teams, each solving exactly K problems. Return 'Impossible' if not possible, otherwise return the distribution. if M * K != N: return \\"Impossible\\" problems = list(range(1, N + 1)) result = [] for i in range(M): team_problems = [] for j in range(K): # Calculate the index in a circular manner problem_index = (i * K + j) % N team_problems.append(problems[problem_index]) result.append(\\" \\".join(map(str, team_problems))) return \\"n\\".join(result)"},{"question":"import heapq from typing import List, Tuple, Union def find_shortest_paths(test_cases: List[Tuple[int, int, int, int, List[Tuple[int, int, int]]]]) -> List[Union[int, str]]: Find the shortest path between two given nodes in a weighted directed graph. :param test_cases: A list of tuples, each containing the following: - Integer n: Number of junctions - Integer m: Number of road segments - Integer k: Start junction index - Integer d: End junction index - List of tuples: Each containing three integers u, v, w indicating a road segment from junction u to junction v with travel time w :return: A list of integers representing the minimum travel time for each test case. If no path exists, return \\"NO PATH\\". >>> find_shortest_paths([(4, 4, 1, 4, [(1, 2, 5), (2, 3, 10), (3, 4, 1), (1, 3, 15)]), (3, 4, 2, 1, [(1, 2, 3), (2, 3, 4)])]) [16, 'NO PATH'] >>> find_shortest_paths([(2, 1, 1, 2, [(1, 2, 10)])]) [10] >>> find_shortest_paths([(3, 2, 1, 3, [(1, 2, 5), (2, 1, 5)])]) [\\"NO PATH\\"] >>> find_shortest_paths([(4, 5, 1, 4, [(1, 2, 2), (2, 4, 2), (1, 3, 1), (3, 4, 5), (2, 3, 1)])]) [4] >>> find_shortest_paths([(300, 899, 1, 300, [(i, i+1, 1) for i in range(1, 300)])]) [299]","solution":"import heapq import sys def dijkstra(n, edges, start, end): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) pq = [(0, start)] dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 while pq: current_dist, u = heapq.heappop(pq) if u == end: return current_dist if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return \\"NO PATH\\" def find_shortest_paths(test_cases): results = [] for n, m, k, d, edges in test_cases: result = dijkstra(n, edges, k, d) results.append(result if result != float('inf') else \\"NO PATH\\") return results"},{"question":"def diagonal_reflect(grid): Given a square grid, reflects the grid diagonally. >>> diagonal_reflect([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> diagonal_reflect([[10, 20], [20, 30]]) [[10, 20], [20, 30]] pass def process_test_cases(input_data): Processes multiple test cases from provided input data and returns output string. >>> process_test_cases(\\"2n3n1 2 3n4 5 6n7 8 9n2n10 20n20 30\\") \\"1 4 7n2 5 8n3 6 9nn10 20n20 30\\" >>> process_test_cases(\\"1n0\\") \\"\\" pass","solution":"def diagonal_reflect(grid): Given a square grid, reflects the grid diagonally. N = len(grid) reflected_grid = [[None] * N for _ in range(N)] for i in range(N): for j in range(N): reflected_grid[i][j] = grid[j][i] return reflected_grid def process_test_cases(input_data): Processes multiple test cases from provided input data and returns output string. lines = input_data.strip().split('n') T = int(lines[0]) current_line = 1 results = [] for _ in range(T): N = int(lines[current_line]) current_line += 1 grid = [] for _ in range(N): row = list(map(int, lines[current_line].split())) grid.append(row) current_line += 1 reflected_grid = diagonal_reflect(grid) result = \\"n\\".join(\\" \\".join(map(str, row)) for row in reflected_grid) results.append(result) return \\"nn\\".join(results)"},{"question":"def calculateDistance(speedChanges): Calculate the total distance travelled by the car given a list of speed changes. Args: speedChanges (list of int): List of speed changes at each second. Returns: int: Total distance travelled by the car. >>> calculateDistance([1, 2, -1, 3, -3]) 13 >>> calculateDistance([0, -1, 4, -2, 1]) 9 >>> calculateDistance([1, 2, 3, 4]) 20 >>> calculateDistance([-1, -2, -3, -4]) 0 >>> calculateDistance([1, -1, 2, -2, 3, -3, 4, -4]) 10 >>> calculateDistance([0, 0, 0, 0]) 0 >>> calculateDistance([10, -10, 10, -10]) 20","solution":"def calculateDistance(speedChanges): Calculate the total distance travelled by the car given a list of speed changes. Args: speedChanges (list of int): List of speed changes at each second. Returns: int: Total distance travelled by the car. speed = 0 distance = 0 for change in speedChanges: speed += change if speed < 0: speed = 0 distance += speed return distance"},{"question":"def max_score(n: int, m: int, scores: List[int]) -> int: Returns the maximum possible score Nina can achieve by solving at most m problems. Parameters: n (int): The number of problems. m (int): The maximum number of problems Nina can solve. scores (list of int): The scores assigned to each problem. Returns: int: The maximum score Nina can achieve. pass from solution import max_score def test_max_score_example_1(): assert max_score(5, 3, [100, 200, 300, 400, 500]) == 1200 def test_max_score_example_2(): assert max_score(4, 2, [10, 20, 30, 10]) == 50 def test_max_score_edge_case_1(): assert max_score(1, 1, [500]) == 500 def test_max_score_edge_case_2(): assert max_score(5, 5, [100, 200, 300, 400, 500]) == 1500 def test_max_score_with_multiple_same_high_scores(): assert max_score(6, 3, [100, 400, 400, 200, 300, 400]) == 1200 def test_max_score_with_lowest_n_and_m(): assert max_score(1, 1, [5]) == 5 def test_max_score_another_custom_case(): assert max_score(7, 3, [5, 5, 5, 8, 9, 10, 15]) == 34","solution":"def max_score(n, m, scores): Returns the maximum possible score Nina can achieve by solving at most m problems. Parameters: n (int): The number of problems. m (int): The maximum number of problems Nina can solve. scores (list of int): The scores assigned to each problem. Returns: int: The maximum score Nina can achieve. # Sort the scores in descending order sorted_scores = sorted(scores, reverse=True) # Sum the top m scores return sum(sorted_scores[:m])"},{"question":"def flatten_json(json_obj, parent_key='', sep='.'): Flattens a nested JSON object. Args: json_obj (dict): The JSON object to flatten. parent_key (str): The base key path (used for recursion). sep (str): The separator to use between keys in the flattened dictionary. Returns: dict: A flattened dictionary. >>> flatten_json({\\"a\\": 1, \\"b\\": {\\"c\\": 2}}) {'a': 1, 'b.c': 2} >>> flatten_json({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}) {'a': 1, 'b.c': 2, 'b.d.e': 3} >>> flatten_json({\\"name\\": \\"John\\", \\"address\\": {\\"city\\": \\"New York\\", \\"zipcode\\": {\\"first\\": 12345, \\"second\\": 67890}}}) {'name': 'John', 'address.city': 'New York', 'address.zipcode.first': 12345, 'address.zipcode.second': 67890} >>> flatten_json({\\"a\\": 1, \\"b\\": 2, \\"c\\": 3}) {'a': 1, 'b': 2, 'c': 3} >>> flatten_json({}) {}","solution":"def flatten_json(json_obj, parent_key='', sep='.'): Flattens a nested JSON object. Args: json_obj (dict): The JSON object to flatten. parent_key (str): The base key path (used for recursion). sep (str): The separator to use between keys in the flattened dictionary. Returns: dict: A flattened dictionary. items = [] for k, v in json_obj.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_json(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def best_dish(test_cases: List[Dict[str, Any]]) -> List[int]: Determine whether Asha can prepare at least one dish from the available ingredients, and which dish to prepare to maximize the remaining ingredients. Arguments: test_cases -- a list of dictionaries, each containing: 'X': the number of ingredients available 'Y': the number of different types of dishes 'Z': a list of integers representing the number of ingredients required for each dish Returns: A list of integers where each integer represents the index of the dish Asha should prepare for each test case. If Asha cannot prepare any dish, the list contains -1 for that test case. >>> test_cases = [{'X': 10, 'Y': 3, 'Z': [8, 5, 6]}, {'X': 5, 'Y': 2, 'Z': [7, 3]}] >>> best_dish(test_cases) [2, 2] >>> test_cases = [{'X': 10, 'Y': 1, 'Z': [5]}] >>> best_dish(test_cases) [1] >>> test_cases = [{'X': 5, 'Y': 3, 'Z': [6, 7, 8]}] >>> best_dish(test_cases) [-1] >>> test_cases = [{'X': 10, 'Y': 4, 'Z': [2, 4, 6, 8]}, {'X': 15, 'Y': 3, 'Z': [5, 10, 1]}] >>> best_dish(test_cases) [1, 3] >>> test_cases = [{'X': 10, 'Y': 3, 'Z': [2, 2, 2]}] >>> best_dish(test_cases) [1] pass def parse_input(input_data: str) -> List[Dict[str, Any]]: Parse the input data into a list of test cases. Arguments: input_data -- a string containing multiple lines representing the input format described in the problem statement Returns: A list of dictionaries where each dictionary represents a test case with keys 'X', 'Y', 'Z' >>> input_data = \\"2n10 3n8 5 6n5 2n7 3n\\" >>> parse_input(input_data) [{'X': 10, 'Y': 3, 'Z': [8, 5, 6]}, {'X': 5, 'Y': 2, 'Z': [7, 3]}] pass","solution":"def best_dish(test_cases): results = [] for case in test_cases: X, Y, Z = case['X'], case['Y'], case['Z'] best_dish_index = -1 max_remaining_ingredients = -1 for i in range(Y): if Z[i] <= X: remaining_ingredients = X - Z[i] if (remaining_ingredients > max_remaining_ingredients) or (remaining_ingredients == max_remaining_ingredients and best_dish_index == -1): max_remaining_ingredients = remaining_ingredients best_dish_index = i + 1 results.append(best_dish_index) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): X, Y = map(int, lines[index].split()) Z = list(map(int, lines[index + 1].split())) test_cases.append({'X': X, 'Y': Y, 'Z': Z}) index += 2 return test_cases"},{"question":"def distribute_bonus(points): Determine the minimum number of bonus points the company needs to distribute based on the given rules: 1. Each employee must receive at least one bonus point. 2. Employees with a higher performance score than their adjacent employees must receive more bonus points than those adjacent employees. >>> distribute_bonus([5]) == 1 >>> distribute_bonus([1, 2]) == 3 >>> distribute_bonus([2, 1]) == 3 >>> distribute_bonus([1, 2, 2, 3, 1]) == 7 >>> distribute_bonus([4, 6, 4, 5, 6, 2]) == 10 >>> distribute_bonus([1, 1, 1, 1]) == 4 >>> distribute_bonus([10, 20, 10, 40, 30]) == 7 >>> distribute_bonus([i for i in range(1, 1001)]) == 500500 >>> distribute_bonus([i for i in range(1000, 0, -1)]) == 500500 # Implement the function here","solution":"def distribute_bonus(points): n = len(points) if n == 0: return 0 bonus = [1] * n # Forward pass for i in range(1, n): if points[i] > points[i-1]: bonus[i] = bonus[i-1] + 1 # Backward pass for i in range(n-2, -1, -1): if points[i] > points[i+1]: bonus[i] = max(bonus[i], bonus[i+1] + 1) return sum(bonus) def main(): import sys input = sys.stdin.read().strip().split() n = int(input[0]) performance_scores = list(map(int, input[1:])) print(distribute_bonus(performance_scores)) # Calling main function if __name__ == \\"__main__\\": main()"},{"question":"def decodeString(s: str) -> str: Decodes the encoded string according to the encoding rule. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer and that every square bracket pair \\"[]\\" is well-formed. Examples: >>> decodeString(\\"3[a]2[bc]\\") 'aaabcbc' >>> decodeString(\\"3[a2[c]]\\") 'accaccacc' >>> decodeString(\\"2[abc]3[cd]ef\\") 'abcabccdcdcdef' >>> decodeString(\\"4[x]\\") 'xxxx' >>> decodeString(\\"2[2[b]]\\") 'bbbb' >>> decodeString(\\"abc\\") 'abc' >>> decodeString(\\"2[a3[b2[c]]]\\") 'abccbccbccabccbccbcc' >>> decodeString(\\"3[a2[b4[F]c]g]\\") 'abFFFFcbFFFFcgabFFFFcbFFFFcgabFFFFcbFFFFcg' >>> decodeString(\\"10[3[z]]\\") 'zzz' * 10","solution":"def decodeString(s): Decodes the encoded string according to the encoding rule. stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \\"[\\": stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \\"]\\": last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"def max_evenness(sequence: list) -> int: Returns the maximum evenness of the sequence, which is the highest number of even numbers in any subsequence. >>> max_evenness([2]) 1 >>> max_evenness([1]) 0 >>> max_evenness([2, 4, 6, 8]) 4 >>> max_evenness([1, 3, 5, 7]) 0 >>> max_evenness([1, 2, 3, 4, 6]) 3 >>> max_evenness([0, 2, 4, 6]) 4","solution":"def max_evenness(sequence): Returns the maximum evenness of the sequence, which is the highest number of even numbers in any subsequence. return sum(1 for num in sequence if num % 2 == 0) # Example to verify the function # If we input [1, 2, 3, 4, 6] the output should be 3, # since there are 3 even numbers in the sequence (2, 4, 6). print(max_evenness([1, 2, 3, 4, 6])) # Output: 3"},{"question":"def check_access_events(k: int, events: List[Tuple[int, int, int]]) -> str: Checks if there are any duplicate accesses to the same honey token. Args: k : int : Number of access events events : list of tuples : List of tuples where each tuple contains three integers (X_i, Y_i, T_i) representing the coordinates of the cell and the time of access event. Returns: str : \\"DUPLICATE\\" if any honey token is accessed more than once, otherwise \\"UNIQUE\\" pass # Test cases def test_check_access_events_unique(): events = [ (1, 1, 100), (2, 2, 200), (3, 3, 300), (4, 4, 400) ] assert check_access_events(4, events) == \\"UNIQUE\\" def test_check_access_events_duplicate(): events = [ (1, 1, 100), (2, 2, 200), (1, 1, 300), (3, 3, 400), (4, 4, 500) ] assert check_access_events(5, events) == \\"DUPLICATE\\" def test_check_access_events_edge_case(): events = [ (500, 500, 100), (1, 1, 200) ] assert check_access_events(2, events) == \\"UNIQUE\\" def test_check_access_events_minimum(): events = [ (1, 1, 100) ] assert check_access_events(1, events) == \\"UNIQUE\\" def test_check_access_events_same_cell_different_times(): events = [ (1, 1, 100), (2, 2, 200), (1, 1, 300) ] assert check_access_events(3, events) == \\"DUPLICATE\\" def test_check_access_events_high_values(): events = [ (499, 499, 1000000), (499, 499, 0), (500, 500, 123456) ] assert check_access_events(3, events) == \\"DUPLICATE\\"","solution":"def check_access_events(k, events): Checks if there are any duplicate accesses to the same honey token. Args: k : int : Number of access events events : list of tuples : List of tuples where each tuple contains three integers (X_i, Y_i, T_i) representing the coordinates of the cell and the time of access event. Returns: str : \\"DUPLICATE\\" if any honey token is accessed more than once, otherwise \\"UNIQUE\\" seen = set() for x, y, t in events: if (x, y) in seen: return \\"DUPLICATE\\" seen.add((x, y)) return \\"UNIQUE\\""},{"question":"import math from typing import List def findGCD(arr: List[int], queries: List[int], n: int, query_length: int) -> List[int]: Given an array of positive integers and q queries, find the greatest common divisor (GCD) of the numbers in the range l to r (inclusive) for each query. Example 1: >>> findGCD([12, 15, 18, 24, 30], [1, 3, 0, 4], 5, 4) [3, 3] Example 2: >>> findGCD([7, 14, 21], [0, 2], 3, 2) [7] Example 3: >>> findGCD([5], [0, 0], 1, 2) [5] Example 4: >>> findGCD([6, 9], [0, 1], 2, 2) [3] Example 5: >>> findGCD([3, 7, 11], [0, 2], 3, 2) [1] Example 6: >>> findGCD([12, 15, 18, 24, 30], [2, 4, 1, 2, 0, 1], 5, 6) [6, 3, 3]","solution":"import math from typing import List def findGCD(arr: List[int], queries: List[int], n: int, query_length: int) -> List[int]: result = [] q = query_length // 2 for i in range(q): l = queries[2 * i] r = queries[2 * i + 1] gcd = arr[l] for j in range(l + 1, r + 1): gcd = math.gcd(gcd, arr[j]) if gcd == 1: # Early exit since the GCD of 1 with any number is 1 break result.append(gcd) return result"},{"question":"def maximal_rectangle_area(histogram: List[int]) -> int: Find the maximal rectangular area that can be formed using contiguous bars of the histogram. Parameters: histogram (List[int]): The heights of the bars in the histogram. Returns: int: The maximal rectangular area that can be formed in the histogram. Examples: >>> maximal_rectangle_area([2, 1, 4, 5, 1, 3, 3]) 8 >>> maximal_rectangle_area([2, 1, 2, 3, 1, 2]) 6 from solution import maximal_rectangle_area def test_example_1(): assert maximal_rectangle_area([2, 1, 4, 5, 1, 3, 3]) == 8 def test_example_2(): assert maximal_rectangle_area([2, 1, 2, 3, 1, 2]) == 6 def test_single_bar(): assert maximal_rectangle_area([5]) == 5 def test_all_equal_heights(): assert maximal_rectangle_area([5, 5, 5, 5, 5]) == 25 def test_increasing_heights(): assert maximal_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_decreasing_heights(): assert maximal_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_mixed_heights(): assert maximal_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12","solution":"def maximal_rectangle_area(histogram): Function to find the maximal rectangular area in a histogram. n = len(histogram) stack = [] max_area = 0 index = 0 while index < n: if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def findChar(arr: List[str], target: str) -> str: Write a function \`findChar\` that determines the smallest character in a given string that is larger than a given target character. The characters are sequences of lowercase letters, and the string is given in sorted order. If no such character exists, the function should return the first character in the string. >>> findChar([\\"c\\", \\"f\\", \\"j\\"], \\"a\\") \\"c\\" >>> findChar([\\"c\\", \\"f\\", \\"j\\"], \\"k\\") \\"c\\" >>> findChar([\\"a\\", \\"b\\"], \\"z\\") \\"a\\"","solution":"from typing import List def findChar(arr: List[str], target: str) -> str: for char in arr: if char > target: return char return arr[0]"},{"question":"def lcs_length(X: str, Y: str) -> int: Given two strings X and Y, find the length of the longest common subsequence (LCS) present in both strings. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Parameters: X (str): First string. Y (str): Second string. Returns: int: The length of the longest common subsequence. >>> lcs_length(\\"ABCBDAB\\", \\"BDCABA\\") 4 >>> lcs_length(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> lcs_length(\\"ABC\\", \\"DEF\\") 0 >>> lcs_length(\\"\\", \\"\\") 0 >>> lcs_length(\\"A\\", \\"\\") 0 >>> lcs_length(\\"\\", \\"B\\") 0 >>> lcs_length(\\"ABCDE\\", \\"ABCDE\\") 5 >>> lcs_length(\\"aBcDe\\", \\"AdBe\\") 2 >>> lcs_length(\\"ABCDEF\\", \\"AECBDF\\") 4","solution":"def lcs_length(X, Y): Returns the length of the longest common subsequence of X and Y. m = len(X) len_y = len(Y) dp = [[0] * (len_y + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, len_y + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][len_y] # Example usage: # X = \\"ABCBDAB\\" # Y = \\"BDCABA\\" # print(lcs_length(X, Y)) # Output: 4"},{"question":"from typing import List def find_trapped_water(heights: List[int]) -> int: Given an array of non-negative integers representing elevations of bars in a histogram, calculate the maximum area of water that can be trapped after raining. >>> find_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> find_trapped_water([4, 2, 0, 3, 2, 5]) 9 pass","solution":"from typing import List def find_trapped_water(heights: List[int]) -> int: n = len(heights) if n == 0: return 0 left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the water trapped at each position for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def vending_machine(amount, item): Determines if the vending machine can dispense the item based on the amount of money inserted. Parameters: amount (int): The amount of money inserted in cents. item (str): The item the customer wants to purchase. One of \\"chips\\", \\"soda\\", or \\"candy\\". Returns: str: \\"item Dispensed\\" if the machine can dispense the item, otherwise \\"Insufficient funds\\" or \\"Invalid item\\". Examples: >>> vending_machine(50, 'chips') 'chips Dispensed' >>> vending_machine(75, 'soda') 'soda Dispensed' >>> vending_machine(100, 'candy') 'candy Dispensed' >>> vending_machine(25, 'chips') 'Insufficient funds' >>> vending_machine(50, 'soda') 'Insufficient funds' >>> vending_machine(75, 'candy') 'Insufficient funds' >>> vending_machine(100, 'gum') 'Invalid item'","solution":"def vending_machine(amount, item): Determines if the vending machine can dispense the item based on the amount of money inserted. item_prices = { \\"chips\\": 50, \\"soda\\": 75, \\"candy\\": 100 } if item not in item_prices: return \\"Invalid item\\" if amount >= item_prices[item]: return f\\"{item} Dispensed\\" else: return \\"Insufficient funds\\""},{"question":"def union_book_lists(K, keyword_list, keywordA, keywordB): Finds the union of book lists from two given keywords and returns sorted unique book IDs. Parameters: - K (int): Number of keywords. - keyword_list (list of tuples): Each tuple contains a keyword and a list of book IDs. - keywordA (str): The first keyword for union operation. - keywordB (str): The second keyword for union operation. Returns: - List of unique book IDs in ascending order. >>> K = 3 >>> keyword_list = [('a', [1, 2, 3, 4]), ('b', [3, 4, 5, 6]), ('c', [5, 6, 7, 8])] >>> keywordA = 'a' >>> keywordB = 'c' >>> union_book_lists(K, keyword_list, keywordA, keywordB) [1, 2, 3, 4, 5, 6, 7, 8] >>> K = 3 >>> keyword_list = [('a', [1, 2, 3]), ('b', [3, 4, 5]), ('c', [5, 6, 7])] >>> keywordA = 'b' >>> keywordB = 'c' >>> union_book_lists(K, keyword_list, keywordA, keywordB) [3, 4, 5, 6, 7]","solution":"def union_book_lists(K, keyword_list, keywordA, keywordB): Finds the union of book lists from two given keywords and returns sorted unique book IDs. Parameters: - K (int): Number of keywords. - keyword_list (list of tuples): Each tuple contains a keyword and a list of book IDs. - keywordA (str): The first keyword for union operation. - keywordB (str): The second keyword for union operation. Returns: - List of unique book IDs in ascending order. keyword_to_books = {} for keyword, books in keyword_list: keyword_to_books[keyword] = set(books) # Get book IDs for both keywords books_A = keyword_to_books.get(keywordA, set()) books_B = keyword_to_books.get(keywordB, set()) # Find union of both sets of book IDs union_books = books_A | books_B # Return sorted list of unique book IDs return sorted(union_books) # Example usage K = 3 keyword_list = [ ('a', [1, 2, 3, 4]), ('b', [3, 4, 5, 6]), ('c', [5, 6, 7, 8]) ] keywordA = 'a' keywordB = 'c' print(union_book_lists(K, keyword_list, keywordA, keywordB)) # Output: [1, 2, 3, 4, 5, 6, 7, 8]"},{"question":"def process_orders(n, orders): Processes the orders according to specified priorities: 1. By priority (higher values first) 2. By order_time (earlier times first) 3. By cooking_time (lower values first) 4. By customer_name (ascending in lexicographic order) 5. By order_id (ascending) :param n: Integer, number of orders :param orders: List of orders, where each order is a tuple in the format (order_time, cooking_time, priority, customer_name, order_id) :return: List of processed orders in the required sequence def format_orders(orders): Formats the orders for output. :param orders: List of orders, where each order is a tuple in the format (order_time, cooking_time, priority, customer_name, order_id) :return: List of formatted strings, each string representing an order's attributes from solution import process_orders, format_orders def test_empty_orders(): assert process_orders(0, []) == [] def test_single_order(): assert process_orders(1, [(1, 1, 1, 'Alice', 1)]) == [(1, 1, 1, 'Alice', 1)] def test_priority_ordering(): orders = [ (1, 1, 1, 'Alice', 1), (2, 2, 2, 'Bob', 2), (3, 3, 3, 'Charlie', 3) ] expected = [ (3, 3, 3, 'Charlie', 3), (2, 2, 2, 'Bob', 2), (1, 1, 1, 'Alice', 1) ] assert process_orders(3, orders) == expected def test_order_time_ordering(): orders = [ (2, 1, 1, 'Alice', 1), (1, 2, 1, 'Bob', 2) ] expected = [ (1, 2, 1, 'Bob', 2), (2, 1, 1, 'Alice', 1) ] assert process_orders(2, orders) == expected def test_cooking_time_ordering(): orders = [ (1, 2, 1, 'Alice', 1), (1, 1, 1, 'Bob', 2) ] expected = [ (1, 1, 1, 'Bob', 2), (1, 2, 1, 'Alice', 1) ] assert process_orders(2, orders) == expected def test_customer_name_ordering(): orders = [ (1, 1, 1, 'Bob', 1), (1, 1, 1, 'Alice', 2) ] expected = [ (1, 1, 1, 'Alice', 2), (1, 1, 1, 'Bob', 1) ] assert process_orders(2, orders) == expected def test_order_id_ordering(): orders = [ (1, 1, 1, 'Alice', 2), (1, 1, 1, 'Alice', 1) ] expected = [ (1, 1, 1, 'Alice', 1), (1, 1, 1, 'Alice', 2) ] assert process_orders(2, orders) == expected def test_format_orders(): orders = [ (1, 1, 3, 'Alice', 101), (10, 25, 5, 'Bob', 102) ] expected = [ '1 1 3 Alice 101', '10 25 5 Bob 102' ] assert format_orders(orders) == expected","solution":"def process_orders(n, orders): Processes the orders according to specified priorities: 1. By priority (higher values first) 2. By order_time (earlier times first) 3. By cooking_time (lower values first) 4. By customer_name (ascending in lexicographic order) 5. By order_id (ascending) :param n: Integer, number of orders :param orders: List of orders, where each order is a tuple in the format (order_time, cooking_time, priority, customer_name, order_id) :return: List of processed orders in the required sequence sorted_orders = sorted(orders, key=lambda x: (-x[2], x[0], x[1], x[3], x[4])) return sorted_orders def format_orders(orders): Formats the orders for output. :param orders: List of orders, where each order is a tuple in the format (order_time, cooking_time, priority, customer_name, order_id) :return: List of formatted strings, each string representing an order's attributes return ['{} {} {} {} {}'.format(*order) for order in orders] # Example usage: if __name__ == \\"__main__\\": n = 5 orders = [ (12, 30, 3, 'Alice', 101), (10, 25, 5, 'Bob', 102), (11, 20, 5, 'Charles', 103), (10, 15, 4, 'Diana', 104), (15, 40, 3, 'Eve', 105) ] processed_orders = process_orders(n, orders) formatted_orders = format_orders(processed_orders) for order in formatted_orders: print(order)"},{"question":"def validate_IP(ip: str) -> bool: Validate if the given string is a valid IPv4 address. Args: ip (str): The IPv4 address as a string. Returns: bool: True if the ip is a valid IPv4 address, else False. Examples: >>> validate_IP(\\"192.168.0.1\\") True >>> validate_IP(\\"256.100.50.25\\") False >>> validate_IP(\\"0.0.0.0\\") True >>> validate_IP(\\"192.168..1\\") False >>> validate_IP(\\"192.168.00.01\\") False","solution":"def validate_IP(ip): Validate if the given string is a valid IPv4 address. Args: ip (str): The IPv4 address as a string. Returns: bool: True if ip is a valid IPv4 address, False otherwise. parts = ip.split(\\".\\") if len(parts) != 4: return False for part in parts: # Check if the part is a digit and within the valid range if not part.isdigit() or not 0 <= int(part) <= 255: return False # Check if the part has leading zeros if part != \\"0\\" and part.startswith(\\"0\\"): return False return True"},{"question":"from typing import List, Dict def min_moves_to_collect(Q: int, queries: List[Dict[str, object]]) -> List[int]: Determine the minimum number of moves required to collect exactly K units of resource T starting from any cell. >>> queries = [ { 'R': 3, 'C': 3, 'K': 3, 'T': 1, 'grid': [ [1, 0, 2], [1, 1, 0], [2, 1, 1] ] }, { 'R': 4, 'C': 4, 'K': 5, 'T': 2, 'grid': [ [2, 2, 2, 0], [2, 1, 1, 2], [0, 0, 2, 2], [2, 2, 2, 2] ] }, { 'R': 2, 'C': 2, 'K': 4, 'T': 3, 'grid': [ [3, 3], [3, 2] ] } ] >>> min_moves_to_collect(3, queries) [2, 4, -1]","solution":"from collections import deque def min_moves_to_collect(Q, queries): def bfs(grid, start, R, C, K, T): visited = set() queue = deque([(start[0], start[1], 0, 0)]) # (row, col, moves, resources) while queue: r, c, moves, resources = queue.popleft() if (r, c) in visited: continue visited.add((r, c)) if grid[r][c] == T: resources += 1 if resources == K: return moves for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited: queue.append((nr, nc, moves + 1, resources)) return float('inf') results = [] for query in queries: R, C, K = query['R'], query['C'], query['K'] T = query['T'] grid = query['grid'] min_moves = float('inf') for r in range(R): for c in range(C): if grid[r][c] == T: min_moves = min(min_moves, bfs(grid, (r, c), R, C, K, T)) results.append(min_moves if min_moves != float('inf') else -1) return results"},{"question":"def find_lexicographically_smallest_word(grid: List[str]) -> str: Find the lexicographically smallest word in the grid where a word is defined as a sequence of characters with at least length 2 that can be read either horizontally from left to right or vertically from top to bottom. >>> find_lexicographically_smallest_word([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"ab\\" >>> find_lexicographically_smallest_word([\\"zzz\\", \\"zzz\\", \\"zzz\\"]) == \\"zz\\" def process_test_cases(test_cases: List[Tuple[int, int, List[str]]]) -> List[str]: Process multiple test cases and find the lexicographically smallest word in each grid. >>> process_test_cases([(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]), (3, 3, [\\"zzz\\", \\"zzz\\", \\"zzz\\"])]) == [\\"ab\\", \\"zz\\"] def main(input_lines: List[str]) -> List[str]: Main function to process input lines. >>> main([\\"1\\", \\"3 3\\", \\"abc\\", \\"def\\", \\"ghi\\"]) == [\\"ab\\"] >>> main([\\"2\\", \\"3 3\\", \\"abc\\", \\"def\\", \\"ghi\\", \\"3 3\\", \\"zzz\\", \\"zzz\\", \\"zzz\\"]) == [\\"ab\\", \\"zz\\"]","solution":"def find_lexicographically_smallest_word(grid): R = len(grid) C = len(grid[0]) smallest_word = None # Check horizontally in each row for i in range(R): for j in range(C-1): word = grid[i][j:j+2] if smallest_word is None or word < smallest_word: smallest_word = word # Check vertically in each column for j in range(C): for i in range(R-1): word = grid[i][j] + grid[i+1][j] if smallest_word is None or word < smallest_word: smallest_word = word return smallest_word def process_test_cases(test_cases): results = [] for test_case in test_cases: R, C, grid = test_case results.append(find_lexicographically_smallest_word(grid)) return results def main(input_lines): it = iter(input_lines) T = int(next(it)) test_cases = [] for _ in range(T): R, C = map(int, next(it).split()) grid = [next(it).strip() for _ in range(R)] test_cases.append((R, C, grid)) return process_test_cases(test_cases)"},{"question":"def extract_password(s: str) -> str: Given a string with segments formatted as 'Sncharacters', returns the concatenated result of all segments. Parameters: s (str): The input string with segments. Returns: str: The concatenated secret password. pass # Replace this with your implementation # Example test cases if __name__ == \\"__main__\\": # Example 1 input_str = \\"S3abcS5helloS1x\\" expected_output = \\"abchellox\\" assert extract_password(input_str) == expected_output # Example 2 input_str = \\"S5worldS2goS4hack\\" expected_output = \\"worldgohack\\" assert extract_password(input_str) == expected_output","solution":"def extract_password(s): Given a string with segments formatted as 'Sncharacters', returns the concatenated result of all segments. Parameters: s (str): The input string with segments. Returns: str: The concatenated secret password. password = \\"\\" i = 0 while i < len(s): if s[i] == 'S': i += 1 n = 0 while i < len(s) and s[i].isdigit(): n = n * 10 + int(s[i]) i += 1 password += s[i:i+n] i += n return password"},{"question":"from typing import List, Tuple def top_k_trending_topics(n: int, k: int, posts: List[str]) -> List[Tuple[str, int]]: Given the number of posts n and a list of posts containing hashtags, return the top k trending topics. Args: n (int): The number of posts. k (int): The number of top trending topics to return. posts (List[str]): List of posts, where each post contains text and hashtags. Returns: List[Tuple[str, int]]: List of tuples with hashtag and its trending score sorted by score in descending order. Example: >>> top_k_trending_topics(7, 3, [ ... \\"Enjoying the sunny day #weather #sun\\", ... \\"Rainy afternoon, perfect for reading #weather #rain\\", ... \\"Good morning! #morning\\", ... \\"Lunchtime with colleagues #food\\", ... \\"Reading tech news #technology #news\\", ... \\"What a beautiful sunset #weather #sunset\\", ... \\"Stuck in traffic #commute #traffic\\" ... ]) # [('weather', 3), ('#sun', 1), ('#rain', 1)] pass # Unit tests if __name__ == \\"__main__\\": def test_example_case(): posts = [ \\"Enjoying the sunny day #weather #sun\\", \\"Rainy afternoon, perfect for reading #weather #rain\\", \\"Good morning! #morning\\", \\"Lunchtime with colleagues #food\\", \\"Reading tech news #technology #news\\", \\"What a beautiful sunset #weather #sunset\\", \\"Stuck in traffic #commute #traffic\\" ] result = top_k_trending_topics(7, 3, posts) assert result == [('#weather', 3), ('#sun', 1), ('#rain', 1)] def test_all_distinct(): posts = [ \\"Post 1 #a\\", \\"Post 2 #b\\", \\"Post 3 #c\\", ] result = top_k_trending_topics(3, 2, posts) assert result == [('#a', 1), ('#b', 1)] def test_same_hashtag_multiple_times_in_one_post(): posts = [ \\"Post 1 #a #a #a\\", \\"Post 2 #a\\", \\"Post 3 #b\\", ] result = top_k_trending_topics(3, 1, posts) assert result == [('#a', 2)] def test_no_hashtags(): posts = [ \\"Post 1\\", \\"Post 2\\", \\"Post 3\\", ] result = top_k_trending_topics(3, 1, posts) assert result == [] def test_limited_to_top_k(): posts = [ \\"Post 1 #a\\", \\"Post 2 #b\\", \\"Post 3 #c\\", \\"Post 4 #d\\", ] result = top_k_trending_topics(4, 2, posts) assert result == [('#a', 1), ('#b', 1)] test_example_case() test_all_distinct() test_same_hashtag_multiple_times_in_one_post() test_no_hashtags() test_limited_to_top_k()","solution":"from collections import defaultdict def top_k_trending_topics(n, k, posts): hashtag_count = defaultdict(int) hashtag_first_appearance = {} for i, post in enumerate(posts): parts = post.split('#') hashtags_in_post = set() for part in parts[1:]: hashtag = '#' + part.split()[0].split(',')[0].strip() if hashtag not in hashtags_in_post: hashtag_count[hashtag] += 1 if hashtag not in hashtag_first_appearance: hashtag_first_appearance[hashtag] = i hashtags_in_post.add(hashtag) sorted_hashtags = sorted(hashtag_count.items(), key=lambda x: (-x[1], hashtag_first_appearance[x[0]])) return sorted_hashtags[:k]"},{"question":"def max_sum_subarray(n, k, array): Given an array of n non-negative integers and a positive integer k, finds a contiguous subarray of length exactly k whose sum is the maximum among all possible contiguous subarrays of length k. Parameters: n (int): The number of elements in the array. k (int): The length of the subarray. array (list of int): The array of non-negative integers. Returns: int: The maximum sum of any contiguous subarray of length k. Examples: >>> max_sum_subarray(6, 3, [1, 2, 3, 4, 5, 6]) 15 >>> max_sum_subarray(5, 2, [1, 2, 3, 1, 2]) 5 from solution import max_sum_subarray def test_max_sum_subarray_example1(): assert max_sum_subarray(6, 3, [1, 2, 3, 4, 5, 6]) == 15 def test_max_sum_subarray_example2(): assert max_sum_subarray(5, 2, [1, 2, 3, 1, 2]) == 5 def test_max_sum_subarray_single_element(): assert max_sum_subarray(1, 1, [5]) == 5 def test_max_sum_subarray_all_zeroes(): assert max_sum_subarray(5, 2, [0, 0, 0, 0, 0]) == 0 def test_max_sum_subarray_large_numbers(): assert max_sum_subarray(4, 2, [10000, 10000, 10000, 10000]) == 20000 def test_max_sum_subarray_single_subarray(): assert max_sum_subarray(5, 5, [1, 2, 3, 4, 5]) == 15 def test_max_sum_subarray_empty_array(): assert max_sum_subarray(0, 0, []) == 0","solution":"def max_sum_subarray(n, k, array): Given an array of n non-negative integers and a positive integer k, finds a contiguous subarray of length exactly k whose sum is the maximum among all possible contiguous subarrays of length k. Parameters: n (int): The number of elements in the array. k (int): The length of the subarray. array (list of int): The array of non-negative integers. Returns: int: The maximum sum of any contiguous subarray of length k. if n == 0 or k == 0: return 0 # Calculate the sum of the first subarray of length k current_sum = sum(array[:k]) max_sum = current_sum # Use a sliding window to find the maximum sum of any subarray of length k for i in range(k, n): current_sum += array[i] - array[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from collections import defaultdict import heapq from typing import List class FrequencyTracker: def __init__(self): self.word_count = defaultdict(int) def add_word(self, word: str) -> None: Add a word to the document. :param word: str def top_k_frequent(self, k: int) -> List[str]: Return the k most frequent words from the document in descending order of their frequency. If two words have the same frequency, return them in lexicographical order. :param k: int :return: List[str] >>> tracker = FrequencyTracker() >>> tracker.add_word(\\"hello\\") >>> tracker.add_word(\\"world\\") >>> tracker.add_word(\\"hello\\") >>> tracker.top_k_frequent(1) ['hello'] >>> tracker.add_word(\\"programming\\") >>> tracker.add_word(\\"hello\\") >>> tracker.top_k_frequent(2) ['hello', 'world']","solution":"from collections import defaultdict import heapq class FrequencyTracker: def __init__(self): self.word_count = defaultdict(int) def add_word(self, word: str) -> None: self.word_count[word] += 1 def top_k_frequent(self, k: int): min_heap = [] for word, count in self.word_count.items(): heapq.heappush(min_heap, (count, word)) if len(min_heap) > k: heapq.heappop(min_heap) result = [] while min_heap: result.append(heapq.heappop(min_heap)) result.sort(key=lambda x: (-x[0], x[1])) return [word for count, word in result]"},{"question":"from typing import List, Tuple def calculate_distances(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: You are given a binary tree with N nodes, each node has a unique value from 1 to N. Your task is to answer Q queries. For each query, you will be given two nodes U and V, and you need to calculate the distance between these two nodes. The distance is defined as the number of edges on the shortest path connecting nodes U and V. :param n: number of nodes :param edges: list of edges where each edge is represented as a tuple (A, B), which means there is an edge connecting nodes A and B :param queries: list of queries where each query is represented as a tuple (U, V) :return: list of distances for each query >>> calculate_distances(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [(2, 4), (2, 5), (4, 5)]) [3, 3, 2] >>> calculate_distances(3, [(1, 2), (2, 3)], [(1, 3), (1, 2), (2, 3)]) [2, 1, 1] >>> calculate_distances(4, [(1, 2), (2, 3), (3, 4)], [(1, 4), (1, 3), (2, 4)]) [3, 2, 2] >>> calculate_distances(1, [], [(1, 1)]) [0]","solution":"from collections import deque def calculate_distances(n, edges, queries): # Build the graph from edges graph = {i: [] for i in range(1, n+1)} for a, b in edges: graph[a].append(b) graph[b].append(a) # Find distances using BFS from any node, we choose 1 to start with def bfs(start): distances = {i: -1 for i in range(1, n+1)} distances[start] = 0 q = deque([start]) while q: node = q.popleft() for neighbor in graph[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + 1 q.append(neighbor) return distances # We find distances of all nodes from the root node (chosen arbitrarily as node 1) root_distances = bfs(1) # We precompute the distances for all other nodes to reuse in queries all_distances = {i: bfs(i) for i in range(1, n+1)} # Process each query results = [] for u, v in queries: results.append(all_distances[u][v]) return results"},{"question":"def maximum_bandwidth_within_budget(n: int, m: int, B: int, cables: List[Tuple[int, int, int, int]]) -> int: Determine the maximum bandwidth capacity of a connected network that can be established within a given budget. Parameters: n (int): The number of computers. m (int): The number of cables. B (int): The budget. cables (List[Tuple[int, int, int, int]]): List of tuples where each tuple contains four integers representing a cable. Returns: int: The maximum bandwidth or -1 if it is not possible to connect all computers within the budget. Examples: >>> maximum_bandwidth_within_budget(4, 5, 20, [(1, 2, 5, 4), (2, 3, 6, 5), (3, 4, 4, 3), (1, 3, 2, 6), (1, 4, 3, 8)]) 15 >>> maximum_bandwidth_within_budget(3, 3, 7, [(1, 2, 3, 8), (2, 3, 2, 5), (1, 3, 5, 9)]) -1 pass import pytest def test_case1(): assert maximum_bandwidth_within_budget(4, 5, 20, [(1, 2, 5, 4), (2, 3, 6, 5), (3, 4, 4, 3), (1, 3, 2, 6), (1, 4, 3, 8)]) == 15 def test_case2(): assert maximum_bandwidth_within_budget(3, 3, 7, [(1, 2, 3, 8), (2, 3, 2, 5), (1, 3, 5, 9)]) == -1 def test_case3(): assert maximum_bandwidth_within_budget(5, 7, 10, [(1, 2, 1, 1), (2, 3, 1, 1), (3, 4, 1, 1), (4, 5, 1, 1), (1, 5, 10, 20), (2, 4, 3, 5), (3, 5, 3, 5)]) == 4 def test_case4(): assert maximum_bandwidth_within_budget(4, 4, 100, [(1, 2, 10, 20), (2, 3, 5, 10), (3, 4, 15, 30), (1, 4, 20, 40)]) == 30 def test_case5(): assert maximum_bandwidth_within_budget(2, 1, 5, [(1, 2, 5, 4)]) == 5 if __name__ == \\"__main__\\": pytest.main()","solution":"import heapq def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def maximum_bandwidth_within_budget(n, m, B, cables): cables.sort(key=lambda x: x[3]) max_bandwidth = 0 result = [] parent = list(range(n + 1)) rank = [0] * (n + 1) for cable in cables: if find(parent, cable[0]) != find(parent, cable[1]): union(parent, rank, cable[0], cable[1]) result.append(cable) if sum(x[3] for x in result) <= B: max_bandwidth = max(max_bandwidth, sum(x[2] for x in result)) else: return -1 cost = sum(x[3] for x in result) if cost <= B: return max_bandwidth else: return -1 # Example usage: input_data = [ (4, 5, 20, [(1, 2, 5, 4), (2, 3, 6, 5), (3, 4, 4, 3), (1, 3, 2, 6), (1, 4, 3, 8)]), (3, 3, 7, [(1, 2, 3, 8), (2, 3, 2, 5), (1, 3, 5, 9)]) ] for data in input_data: print(maximum_bandwidth_within_budget(*data)) # Output should be 15 and -1 respectively"},{"question":"def count_unique_letters(S: str, queries: List[Tuple[int, int]]) -> List[int]: Given a string S and a list of queries, return a list of counts of unique letters between indices L and R (inclusive) for each query. Parameters: S (str): A string consisting of lowercase English letters. queries (list of tuples): A list of tuples where each tuple contains two integers (L, R) representing the query range. Returns: list: A list of counts of unique letters for each query. >>> count_unique_letters(\\"abcabc\\", [(1, 3)]) [3] >>> count_unique_letters(\\"abcabc\\", [(1, 3), (2, 5), (1, 6)]) [3, 3, 3] >>> count_unique_letters(\\"a\\", [(1, 1)]) [1] from typing import List, Tuple import sys input = sys.stdin.read data = input().split() S = data[0] Q = int(data[1]) queries = [(int(data[2 + i*2]), int(data[3 + i*2])) for i in range(Q)] results = count_unique_letters(S, queries) for res in results: print(res)","solution":"def count_unique_letters(S, queries): Given a string S and a list of queries, return a list of counts of unique letters between indices L and R (inclusive) for each query. Parameters: S (str): A string consisting of lowercase English letters. queries (list of tuples): A list of tuples where each tuple contains two integers (L, R) representing the query range. Returns: list: A list of counts of unique letters for each query. result = [] for L, R in queries: unique_letters = set(S[L-1:R]) result.append(len(unique_letters)) return result def process_input(): import sys input = sys.stdin.read data = input().split() S = data[0] Q = int(data[1]) queries = [(int(data[2 + i*2]), int(data[3 + i*2])) for i in range(Q)] return S, queries if __name__ == \\"__main__\\": S, queries = process_input() results = count_unique_letters(S, queries) for res in results: print(res)"},{"question":"def encrypt_diary_entry(D: int, S: str) -> str: Encrypt the diary entry based on the given day. Parameters: - D: int, the day of the month (between 1 and 31 inclusive) - S: string, the diary entry Returns: - string, the encrypted diary entry >>> encrypt_diary_entry(2, \\"i love coding challenges\\") 'segnellahc gnidoc evol i' >>> encrypt_diary_entry(15, \\"today is a beautiful day\\") 'today is a beautiful day' pass def process_test_cases(test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases to encrypt diary entries based on respective days. Parameters: - test_cases: List of tuples, where each tuple contains: - int: the day of the month - str: the diary entry Returns: - List of strings: encrypted diary entries for each test case >>> process_test_cases([(2, \\"i love coding challenges\\"), (15, \\"today is a beautiful day\\"), (28, \\"hello world\\")]) ['segnellahc gnidoc evol i', 'today is a beautiful day', 'dlrow olleh'] pass","solution":"def encrypt_diary_entry(D, S): Encrypt the diary entry based on the given day. Parameters: - D: int, the day of the month (between 1 and 31 inclusive) - S: string, the diary entry Returns: - string, the encrypted diary entry if D % 2 == 0: return S[::-1] else: return S def process_test_cases(test_cases): results = [] for D, S in test_cases: results.append(encrypt_diary_entry(D, S)) return results"},{"question":"def is_adjacent(x1, y1, x2, y2): Checks if two coordinates are adjacent. >>> is_adjacent(1, 1, 1, 2) True >>> is_adjacent(1, 1, 2, 1) True >>> is_adjacent(1, 1, 2, 2) True >>> is_adjacent(1, 1, 3, 3) False >>> is_adjacent(1, 1, 1, 1) True def max_non_adjacent_treasures(N, locations): Returns the maximum number of non-adjacent treasures that can be hidden. >>> max_non_adjacent_treasures(4, [(1, 1), (1, 3), (2, 2), (4, 4)]) 3 >>> max_non_adjacent_treasures(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 3 def solve_treasure_hunt(T, test_cases): Determines the maximum number of treasures that can be hidden for each test case. >>> T = 2 >>> test_cases = [ ... (4, 4, [(1, 1), (1, 3), (2, 2), (4, 4)]), ... (5, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) ... ] >>> solve_treasure_hunt(T, test_cases) [3, 3]","solution":"def is_adjacent(x1, y1, x2, y2): Checks if two coordinates are adjacent. return abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1 def max_non_adjacent_treasures(N, locations): Returns the maximum number of non-adjacent treasures that can be hidden. from itertools import combinations max_count = 0 M = len(locations) for r in range(1, M + 1): for subset in combinations(locations, r): if all(not is_adjacent(x1, y1, x2, y2) for i, (x1, y1) in enumerate(subset) for x2, y2 in subset[i+1:]): max_count = max(max_count, r) return max_count def solve_treasure_hunt(T, test_cases): results = [] for i in range(T): N, M, locations = test_cases[i] results.append(max_non_adjacent_treasures(N, locations)) return results"},{"question":"def find_missing_positive(nums): Returns the smallest positive integer that is not present in the list nums. >>> find_missing_positive([1, 2, 0]) == 3 >>> find_missing_positive([3, 4, -1, 1]) == 2 >>> find_missing_positive([7, 8, 9, 11, 12]) == 1","solution":"def find_missing_positive(nums): Returns the smallest positive integer that is not present in the list nums. n = len(nums) # Mark numbers (num <= 0) and (num > n) with a special marker number (n+1) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Use the index as a hash and mark the corresponding position negative for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Find the first cell which isn't negative (that means the index+1 is not present in the array) for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def verify_harmony(N: int, K: int, sequence: List[int]) -> str: Verifies if the first K elements of the sequence are in ascending order. Parameters: - N (int): The number of elements in the sequence. - K (int): The required length of the starting ascending subsequence. - sequence (list of int): The permutation of the first N natural numbers. Returns: - str: \\"Good Harmony\\" if the first K elements are in ascending order, otherwise \\"Discord\\". >>> verify_harmony(5, 3, [1, 2, 3, 5, 4]) == \\"Good Harmony\\" >>> verify_harmony(6, 4, [4, 3, 2, 1, 5, 6]) == \\"Discord\\" >>> verify_harmony(4, 2, [2, 1, 3, 4]) == \\"Discord\\" >>> verify_harmony(5, 2, [1, 5, 3, 4, 2]) == \\"Good Harmony\\" >>> verify_harmony(7, 5, [1, 2, 3, 4, 5, 7, 6]) == \\"Good Harmony\\" >>> verify_harmony(3, 3, [3, 1, 2]) == \\"Discord\\" >>> verify_harmony(5, 1, [5, 4, 3, 2, 1]) == \\"Good Harmony\\" >>> verify_harmony(1, 1, [1]) == \\"Good Harmony\\"","solution":"def verify_harmony(N, K, sequence): Verifies if the first K elements of the sequence are in ascending order. Parameters: - N (int): The number of elements in the sequence. - K (int): The required length of the starting ascending subsequence. - sequence (list of int): The permutation of the first N natural numbers. Returns: - str: \\"Good Harmony\\" if the first K elements are in ascending order, otherwise \\"Discord\\". for i in range(1, K): if sequence[i-1] > sequence[i]: return \\"Discord\\" return \\"Good Harmony\\""},{"question":"def count_pairs_with_same_color(n, m, colors, edges): Given an undirected graph with n nodes and m edges, where every node has a certain color, find the number of pairs of nodes (u, v) such that there is a path between u and v and both have the same color. Parameters: n (int): Number of nodes m (int): Number of edges colors (List[int]): The color of each node, 1-indexed edges (List[Tuple[int, int]]): The edges of the graph Returns: int: Number of pairs of nodes with the same color that have a path between them Examples: >>> count_pairs_with_same_color(4, 3, [1, 2, 1, 2], [(1, 2), (2, 3), (3, 4)]) 2 >>> count_pairs_with_same_color(5, 4, [1, 1, 2, 2, 2], [(1, 2), (2, 3), (3, 4), (4, 5)]) 4","solution":"def count_pairs_with_same_color(n, m, colors, edges): from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited[start] = True component = [start] while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) component.append(neighbor) return component # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Find connected components visited = [False] * (n + 1) components = [] for i in range(1, n + 1): if not visited[i]: components.append(bfs(i)) # Count pairs within each component color_count = defaultdict(int) total_pairs = 0 for component in components: color_count.clear() for node in component: color_count[colors[node - 1]] += 1 for count in color_count.values(): if count > 1: total_pairs += count * (count - 1) // 2 return total_pairs # Input example # n = 4, m = 3 # colors = [1, 2, 1, 2] # edges = [(1, 2), (2, 3), (3, 4)] # Output: 2"},{"question":"def max_xor_subarray(arr): Determine the maximum XOR value of any subarray (contiguous elements) of the given array. :param arr: list of integers :return: maximum XOR value of any subarray >>> max_xor_subarray([1, 2, 3, 4]) 7 >>> max_xor_subarray([5]) 5 >>> max_xor_subarray([8, 1]) 9 >>> max_xor_subarray([8, 1, 2, 12, 7, 6]) 15 >>> max_xor_subarray([0, 0, 0, 0]) 0 >>> max_xor_subarray([3, 8, 2, 0, 4, 1, 7]) 15 >>> max_xor_subarray([1, 1000000000, 2, 999999999, 3, 1000000000]) 1000000003","solution":"def max_xor_subarray(arr): Determine the maximum XOR value of any subarray (contiguous elements) of the given array. :param arr: list of integers :return: maximum XOR value of any subarray max_xor = 0 current_xor = 0 prefix_xor_set = set() prefix_xor_set.add(0) for num in arr: current_xor ^= num for prefix in prefix_xor_set: max_xor = max(max_xor, current_xor ^ prefix) prefix_xor_set.add(current_xor) return max_xor"},{"question":"from typing import List, Tuple def max_segment_sum(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum sum of any segment of the list for multiple test cases. >>> max_segment_sum(3, [(5, [1, 2, 3, -2, 5]), (4, [-1, -2, -3, -4]), (6, [-1, 3, -2, 1, -1, 3])]) [9, -1, 4] >>> max_segment_sum(1, [(3, [-2, -1, -3])]) [-1] >>> max_segment_sum(1, [(4, [1, 2, 3, 4])]) [10] >>> max_segment_sum(1, [(1, [5])]) [5] >>> max_segment_sum(1, [(6, [3, -2, 5, -1, 4, -3])]) [9]","solution":"def max_segment_sum(T, test_cases): def kadane(nums): max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global results = [] for case in test_cases: N = case[0] nums = case[1] results.append(kadane(nums)) return results"},{"question":"def trap_water(pole_heights: List[int]) -> int: Given a list of non-negative integers representing the height of poles in a series, returns the maximum amount of water that can be trapped between these poles. >>> trap_water([0, 1, 0, 2, 1, 0]) 1 >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([0, 0, 0]) 0 >>> trap_water([3, 0, 2, 0, 4]) 7 >>> trap_water([]) 0 >>> trap_water([2, 2, 2, 2, 2]) 0 >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([1, 7, 1]) 0","solution":"def trap_water(pole_heights): Given a list of non-negative integers representing the height of poles in a series, returns the maximum amount of water that can be trapped between these poles. if not pole_heights: return 0 n = len(pole_heights) left_max = [0] * n right_max = [0] * n # Fill left_max array where left_max[i] is the maximum height to the left of i including i left_max[0] = pole_heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], pole_heights[i]) # Fill right_max array where right_max[i] is the maximum height to the right of i including i right_max[n - 1] = pole_heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], pole_heights[i]) # Calculate total water trapped total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - pole_heights[i] return total_water"},{"question":"def longest_valid_substring(n: int, s: str) -> int: Finds the length of the longest valid substring consisting of matched parentheses and brackets. :param n: Length of the string :param s: String of parentheses and brackets :return: Length of the longest valid substring >>> longest_valid_substring(6, '()[[()]') == 4 >>> longest_valid_substring(10, '(()))])([') == 4 >>> longest_valid_substring(8, '([[]][[]]') == 8 >>> longest_valid_substring(1, '(') == 0 >>> longest_valid_substring(1, ')') == 0 >>> longest_valid_substring(1, '[') == 0 >>> longest_valid_substring(1, ']') == 0 >>> longest_valid_substring(4, ')))(') == 0 >>> longest_valid_substring(5, '][[[]') == 2 >>> longest_valid_substring(10, '([][()][])') == 10 >>> longest_valid_substring(12, '(([][]))[)]') == 8","solution":"def longest_valid_substring(n, s): Finds the length of the longest valid substring consisting of match parentheses and brackets. :param n: Length of the string :param s: String of parentheses and brackets :return: Length of the longest valid substring # Stack to keep track of indices of opening brackets/parentheses stack = [] # Dict to map closing to opening characters mapping = {')': '(', ']': '['} # Initialize longest valid substring length max_length = 0 # Initialize start of the current valid substring start = -1 for i, char in enumerate(s): if char in mapping.values(): stack.append(i) else: if stack and s[stack[-1]] == mapping[char]: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: max_length = max(max_length, i - start) else: start = i return max_length"},{"question":"from typing import List def maxElevationDifference(elevations: List[int], k: int, m: int) -> int: Find the maximum elevation difference between any two points in the range from 0 to k-1, where the points considered for the difference should not be more than \`m\` steps apart. Args: elevations (List[int]): Array representing the elevations at each point k (int): Maximum number of points to consider from the starting point m (int): Maximum steps she can take from her starting point within the k points Returns: int: Maximum elevation difference found within the constraints Examples: >>> maxElevationDifference([1, 5, 2, 8, 4, 3], 4, 2) 6 >>> maxElevationDifference([3, 3, 1, 6, 9], 3, 1) 2","solution":"def maxElevationDifference(elevations, k, m): max_diff = 0 # Iterate through the first \`k\` elements for i in range(k): for j in range(i + 1, min(i + m + 1, k)): max_diff = max(max_diff, abs(elevations[j] - elevations[i])) return max_diff"},{"question":"from typing import List def longest_consecutive_sequence(card_sets: List[List[int]]) -> List[int]: Determines the length of the longest sequence of consecutive numbers from a list of card sets. :param card_sets: List of card sets where each set is a list of integers. :return: List of integers, each representing the length of the longest consecutive sequence for the corresponding card set. >>> longest_consecutive_sequence([[1, 2, 3, 4, 6, 7, 8], [10, 20, 30, 40, 50]]) == [4, 1] >>> longest_consecutive_sequence([[5], [1]]) == [1, 1] >>> longest_consecutive_sequence([[1, 2, 3, 4, 5], [1000, 1001, 1002, 1003, 1004]]) == [5, 5] >>> longest_consecutive_sequence([[1, 3, 5, 7, 9], [100, 200, 300, 400]]) == [1, 1] >>> longest_consecutive_sequence([[10, 11, 12, 50, 51, 52], [5, 10, 15, 20]]) == [3, 1] >>> longest_consecutive_sequence([[999999999, 1000000000], [1, 2, 3, 4, 5]]) == [2, 5] >>> longest_consecutive_sequence([[]]) == [0] >>> longest_consecutive_sequence([[1,1,1,1,1,2]]) == [2] pass","solution":"def longest_consecutive_sequence(card_sets): Determines the length of the longest sequence of consecutive numbers from a list of card sets. :param card_sets: List of card sets where each set is a list of integers. :return: List of integers, each representing the length of the longest consecutive sequence for the corresponding card set. results = [] for cards in card_sets: if not cards: results.append(0) continue card_set = set(cards) longest_length = 0 for card in cards: if card-1 not in card_set: # Start of a new sequence current_card = card current_length = 1 while current_card + 1 in card_set: current_card += 1 current_length += 1 longest_length = max(longest_length, current_length) # Update the longest length results.append(longest_length) return results"},{"question":"def permutations(n): Returns all permutations of numbers from 1 to n sorted in lexicographic order. If n is not a positive integer greater than zero, returns an empty list. >>> permutations(3) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> permutations(1) [[1]] >>> permutations(0) [] >>> permutations(-1) [] >>> permutations('abc') [] >>> permutations(2.5) [] >>> permutations(4) [[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]]","solution":"def permutations(n): Returns all permutations of numbers from 1 to n sorted in lexicographic order. If n is not a positive integer greater than zero, returns an empty list. if not isinstance(n, int) or n <= 0: return [] def generate_permutations(arr, left, right, result): if left == right: result.append(arr[:]) else: for i in range(left, right + 1): arr[left], arr[i] = arr[i], arr[left] generate_permutations(arr, left + 1, right, result) arr[left], arr[i] = arr[i], arr[left] numbers = list(range(1, n + 1)) result = [] generate_permutations(numbers, 0, n - 1, result) return sorted(result)"},{"question":"import math from typing import List, Tuple def count_detected_obstacles(n: int, m: int, robots: List[Tuple[int, int, int]], obstacles: List[Tuple[int, int]]) -> List[int]: Natalia wants to know how many obstacles each robot can detect in a laboratory. Each robot is represented by its coordinates and detection radius. Each obstacle is represented by its coordinates. A robot can detect an obstacle if the Euclidean distance between them is less than or equal to the detection radius of the robot. >>> count_detected_obstacles(3, 4, [(0, 0, 5), (10, 10, 10), (-5, -5, 1)], [(1, 1), (6, 6), (-1, -1), (11, 11)]) [2, 2, 0] >>> count_detected_obstacles(2, 3, [(1, 1, 3), (4, 5, 6)], [(2, 2), (3, 3), (5, 5)]) [2, 3]","solution":"import math def count_detected_obstacles(n, m, robots, obstacles): result = [] for (xi, yi, ri) in robots: count = 0 for (ojx, ojy) in obstacles: distance = math.sqrt((xi - ojx)**2 + (yi - ojy)**2) if distance <= ri: count += 1 result.append(count) return result"},{"question":"from typing import List, Tuple def sum_game(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Function to find the final remaining element after performing the sum game. Parameters: T - Number of test cases test_cases - List of tuples where each tuple contains: - N: Number of elements in the array - array: List of integers representing the array Returns: List of results for each test case >>> sum_game(2, [(3, [1, 2, 3]), (4, [1, 2, 3, 4])]) [6, 10] >>> sum_game(1, [(5, [10, 20, 30, 40, 50])]) [150]","solution":"def sum_game(T, test_cases): Function to find the final remaining element after performing the sum game. Parameters: T - Number of test cases test_cases - List of tuples where each tuple contains: - N: Number of elements in the array - array: List of integers representing the array Returns: List of results for each test case results = [] for case in test_cases: N, array = case # The optimal strategy is simply summing all elements of the array final_element = sum(array) results.append(final_element) return results"},{"question":"def arrange_flowers(t: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Arrange flowers in a rectangular grid so that no two adjacent flowers are of the same type. Args: t: number of test cases test_cases: a list of tuples, each containing: - r: the number of rows in the grid - c: the number of columns in the grid - f: the number of different flower types Returns: A list of strings representing the resulting grids for each test case. If it is impossible to arrange the flowers, the result will be \\"Impossible\\". pass def test_arrange_flowers(): t = 2 test_cases = [ (3, 3, 3), (2, 2, 2), ] expected_results = [ \\"ABCnBCAnCAB\\", \\"ABnBA\\" ] assert arrange_flowers(t, test_cases) == expected_results def test_single_row(): t = 1 test_cases = [ (1, 5, 3), # 1x5 grid with 3 different flowers ] expected_results = [ \\"ABCAB\\", ] assert arrange_flowers(t, test_cases) == expected_results def test_single_column(): t = 1 test_cases = [ (5, 1, 2), # 5x1 grid with 2 different flowers ] expected_results = [ \\"AnBnAnBnA\\", ] assert arrange_flowers(t, test_cases) == expected_results def test_impossible_case(): t = 1 test_cases = [ (2, 2, 1), # 2x2 grid with 1 different flower ] expected_results = [ \\"Impossible\\", ] assert arrange_flowers(t, test_cases) == expected_results","solution":"def arrange_flowers(t, test_cases): results = [] for case in test_cases: r, c, f = case if f < 2 and (r > 1 or c > 1): results.append(\\"Impossible\\") continue # Create grid grid = [['' for _ in range(c)] for _ in range(r)] flowers = [chr(i) for i in range(65, 65 + f)] # Fill grid for i in range(r): for j in range(c): grid[i][j] = flowers[(i + j) % f] results.append(\\"n\\".join([\\"\\".join(row) for row in grid])) return results # Example usage and input t = 2 test_cases = [ (3, 3, 3), # 3x3 grid with 3 different flowers (2, 2, 2), # 2x2 grid with 2 different flowers ] result = arrange_flowers(t, test_cases) for res in result: print(res)"},{"question":"from typing import List def reppy_min_energy(n: int, m: int, grid: List[str], r1: int, c1: int, r2: int, c2: int) -> int: Determine the minimum amount of energy Reppy needs to reach the target position from the initial position. >>> reppy_min_energy(5, 5, [\\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\"], 1, 1, 5, 5) 8 >>> reppy_min_energy(3, 3, [\\"#\\", \\"#.#\\", \\"#\\"], 2, 2, 1, 3) -1 >>> reppy_min_energy(6, 7, [\\".......\\", \\"...#.\\", \\".......\\", \\".#...\\", \\".......\\", \\".......\\"], 2, 1, 6, 7) 10 >>> reppy_min_energy(3, 4, [\\"....\\", \\"....\\", \\"....\\"], 1, 1, 3, 4) 5 >>> reppy_min_energy(1, 1, [\\".\\"], 1, 1, 1, 1) 0","solution":"from collections import deque def reppy_min_energy(n, m, grid, r1, c1, r2, c2): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False for _ in range(m)] for _ in range(n)] # Converting to zero-indexed r1 -= 1 c1 -= 1 r2 -= 1 c2 -= 1 queue = deque([(r1, c1, 0)]) visited[r1][c1] = True while queue: x, y, energy = queue.popleft() if x == r2 and y == c2: return energy for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, energy + 1)) return -1"},{"question":"def eulerian_circuit_checker(input_data): Determines if the given graph of houses and bridges has an Eulerian Circuit. Parameters: input_data: A list of strings representing multiple datasets in the following format: N M u1 v1 u2 v2 ... uM vM Returns: A list of \\"YES\\" or \\"NO\\" for each dataset indicating if an Eulerian Circuit exists. Example: >>> eulerian_circuit_checker([ \\"3 3\\", \\"1 2\\", \\"2 3\\", \\"3 1\\", \\"0\\" ]) [\\"YES\\"] >>> eulerian_circuit_checker([ \\"3 2\\", \\"1 2\\", \\"2 3\\", \\"0\\" ]) [\\"NO\\"]","solution":"def has_eulerian_circuit(n, edges): Determines if the given graph has an Eulerian circuit. :param n: Number of nodes in the graph :param edges: List of tuples representing the edges :return: \\"YES\\" if an Eulerian circuit exists, \\"NO\\" otherwise from collections import defaultdict, deque if not edges: return \\"NO\\" # Degree count for each node degree = defaultdict(int) # Adjacency list graph = defaultdict(list) for u, v in edges: degree[u] += 1 degree[v] += 1 graph[u].append(v) graph[v].append(u) # Check all vertices with non-zero degree are connected def is_connected(): start = next((node for node in range(1, n + 1) if degree[node] > 0), None) if start is None: return True # Empty graph is trivially Eulerian visited = set() queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return all(v in visited for v in graph if degree[v] > 0) # Check if all vertices with non-zero degree are even if all(deg % 2 == 0 for deg in degree.values()): # Check if the graph is connected if is_connected(): return \\"YES\\" return \\"NO\\" def eulerian_circuit_checker(input_data): Processes multiple datasets to check for Eulerian circuits. :param input_data: A list of strings representing the input data :return: A list of \\"YES\\" or \\"NO\\" for each dataset index = 0 result = [] while index < len(input_data): line = input_data[index] if line == '0': break n, m = map(int, line.split()) edges = [] for i in range(m): index += 1 u, v = map(int, input_data[index].split()) edges.append((u, v)) result.append(has_eulerian_circuit(n, edges)) index += 1 return result"},{"question":"def find_unique_valid_subsequences(n: int, gene_seq: str, m: int, valid_subsequences: List[str]) -> List[str]: Given a gene sequence and a list of valid subsequences, this function finds all unique valid subsequences present in the gene sequence and sorts them lexicographically. >>> find_unique_valid_subsequences(4, 'abac', 3, ['ab', 'ac', 'bc']) ['ab', 'ac', 'bc'] >>> find_unique_valid_subsequences(5, 'abcde', 5, ['abc', 'ace', 'bcd', 'de', 'abcde']) ['abc', 'abcde', 'ace', 'bcd', 'de']","solution":"def find_unique_valid_subsequences(n, gene_seq, m, valid_subsequences): Given a gene sequence and a list of valid subsequences, this function finds all unique valid subsequences present in the gene sequence and sorts them lexicographically. :param n: int - the length of the gene sequence :param gene_seq: str - the gene sequence :param m: int - the number of valid subsequences :param valid_subsequences: list of str - the valid subsequences :return: list of str - the unique valid subsequences found in the gene sequence # Convert the list of valid subsequences to a set for quick lookup valid_set = set(valid_subsequences) def is_valid_subsequence(seq, sub): Helper function to check if sub is a subsequence of seq. it = iter(seq) return all(char in it for char in sub) # Prepare the output list valid_found = [] # Check each valid subsequence for subseq in valid_set: if is_valid_subsequence(gene_seq, subseq): valid_found.append(subseq) # Sort lexicographically valid_found.sort() return valid_found"},{"question":"def has_pair_with_sum(input_list: List[int], k: int) -> bool: Determines if any two distinct numbers from the list add up to k. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False","solution":"def has_pair_with_sum(input_list, k): Determines if any two distinct numbers in the list add up to k. seen = set() for number in input_list: if k - number in seen: return True seen.add(number) return False"},{"question":"def is_valid_path(grid, n, m): Determine if there is a valid path connecting any two open cells in a grid layout. >>> is_valid_path([ ... \\".....\\", ... \\"..#..\\", ... \\".#.\\", ... \\".....\\" ...], 4, 5) \\"YES\\" >>> is_valid_path([ ... \\".#.\\", ... \\".#.\\", ... \\".#.\\" ...], 3, 3) \\"NO\\"","solution":"def is_valid_path(grid, n, m): from collections import deque def bfs(start): queue = deque([start]) visited = set([start]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return visited open_cells = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == '.'] if not open_cells: return \\"NO\\" visited = bfs(open_cells[0]) return \\"YES\\" if visited == set(open_cells) else \\"NO\\""},{"question":"def min_edges_to_connect_graph(test_cases): Given multiple test cases of undirected graphs represented by a set of nodes and edges, determine the minimum number of edges needed to add so that each graph becomes connected. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases, where each test case is represented by a tuple containing the number of nodes, the number of edges, and a list of edges. Returns: List[int]: A list of integers where each integer represents the minimum number of edges needed to add to make the corresponding graph connected. Example: >>> min_edges_to_connect_graph([(4, 2, [(1, 2), (3, 4)]), (5, 3, [(1, 2), (2, 3), (4, 5)]), (3, 0, [])]) [1, 1, 2] 1. For the first graph, we need to add one edge to connect two separate components. 2. For the second graph, it is already connected, so no additional edges are needed. 3. For the third graph, no edges are present, and we need 2 edges to connect all nodes.","solution":"def find_parent(parent, node): if parent[node] != node: parent[node] = find_parent(parent, parent[node]) return parent[node] def union(parent, rank, node1, node2): root1 = find_parent(parent, node1) root2 = find_parent(parent, node2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 def min_edges_to_connect_graph(test_cases): results = [] for n, m, edges in test_cases: if n == 1: results.append(0) continue parent = [i for i in range(n + 1)] rank = [0] * (n + 1) for u, v in edges: union(parent, rank, u, v) unique_parents = len(set(find_parent(parent, i) for i in range(1, n + 1))) results.append(unique_parents - 1) return results"},{"question":"from typing import List def min_moves_maze(grid: List[List[int]]) -> int: Returns the minimum number of moves required to reach the bottom-right corner of the maze. If it is not possible, returns -1. Args: grid (List[List[int]]): The 2D grid representing the maze. Returns: int: The minimum number of moves to reach the bottom-right corner, or -1 if not possible. Examples: >>> min_moves_maze([ ... [0, 0, 1], ... [1, 0, 1], ... [1, 0, 0] ... ]) == 4 >>> min_moves_maze([ ... [0, 1], ... [1, 0] ... ]) == -1 >>> min_moves_maze([ ... [1, 0], ... [0, 0] ... ]) == -1 >>> min_moves_maze([ ... [0, 0], ... [0, 1] ... ]) == -1 >>> min_moves_maze([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 6 >>> min_moves_maze([ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0] ... ]) == 6 >>> min_moves_maze([ ... [0] ... ]) == 0","solution":"from collections import deque def min_moves_maze(grid): Returns the minimum number of moves required to reach the bottom-right corner of the maze. If it is not possible, returns -1. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def largest_connected_component(rows: int, cols: int, matrix: List[List[int]]) -> int: Determine the largest connected component of land cells in the grid. >>> largest_connected_component(4, 5, [ ... [1, 0, 0, 1, 0], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 1]]) 4 >>> largest_connected_component(3, 4, [ ... [0, 0, 1, 0], ... [1, 1, 1, 0], ... [0, 1, 0, 0]]) 5 >>> largest_connected_component(3, 3, [ ... [1, 1, 0], ... [0, 1, 0], ... [0, 0, 1]]) 3 >>> largest_connected_component(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) 0 >>> largest_connected_component(3, 4, [ ... [1, 1, 1, 1], ... [1, 0, 0, 1], ... [1, 1, 1, 1]]) 10 >>> largest_connected_component(1, 1, [ ... [1]]) 1","solution":"def largest_connected_component(rows, cols, matrix): def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or matrix[r][c] == 0: return 0 # Mark this cell as visited matrix[r][c] = 0 size = 1 size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size max_land_size = 0 for r in range(rows): for c in range(cols): if matrix[r][c] == 1: max_land_size = max(max_land_size, dfs(r, c)) return max_land_size"},{"question":"def isPalindrome(s: str) -> bool: Returns True if the input string is a palindrome, ignoring case and non-alphabetical characters. >>> isPalindrome('A man, a plan, a canal, Panama') == True >>> isPalindrome('hello') == False >>> isPalindrome('madam') == True >>> isPalindrome('Madam') == True >>> isPalindrome('nurses run') == True >>> isPalindrome('') == True >>> isPalindrome('No lemon, no melon!') == True","solution":"def isPalindrome(s): Returns True if the input string is a palindrome, ignoring case and non-alphabetical characters. # Filter out non-alphabetical characters and convert to lowercase filtered_s = ''.join(char.lower() for char in s if char.isalpha()) # Check if the filtered string is equal to its reverse return filtered_s == filtered_s[::-1]"},{"question":"def floyd_warshall(n: int, roads: List[Tuple[int, int, int]]) -> List[List[int]]: Compute the minimum time required for a delivery truck to travel between any two intersections in the city. Args: n: Number of intersections. roads: List of tuples where each tuple contains three integers u, v, w representing a road between intersections u and v with time length w. Returns: A 2D list where the element at the i-th row and j-th column represents the minimum time required for a delivery truck to travel from intersection i to intersection j. If there is no path from intersection i to intersection j, the entry will be -1. Example: >>> floyd_warshall(4, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 1, 5)]) [[0, 3, 7, 5], [3, 0, 4, 6], [7, 4, 0, 2], [5, 6, 2, 0]] >>> floyd_warshall(3, [(1, 2, 2), (2, 3, 3)]) [[0, 2, 5], [2, 0, 3], [5, 3, 0]] from typing import List, Tuple from solution import floyd_warshall def test_floyd_warshall_basic(): n = 4 roads = [ (1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 1, 5) ] result = floyd_warshall(n, roads) expected = [ [0, 3, 7, 5], [3, 0, 4, 6], [7, 4, 0, 2], [5, 6, 2, 0] ] assert result == expected def test_floyd_warshall_no_path(): n = 3 roads = [ (1, 2, 2), (2, 3, 3) ] result = floyd_warshall(n, roads) expected = [ [0, 2, 5], [2, 0, 3], [5, 3, 0] ] assert result == expected def test_floyd_warshall_disconnected_graph(): n = 4 roads = [ (1, 2, 5), (3, 4, 7) ] result = floyd_warshall(n, roads) expected = [ [0, 5, -1, -1], [5, 0, -1, -1], [-1, -1, 0, 7], [-1, -1, 7, 0] ] assert result == expected def test_floyd_warshall_single_road(): n = 2 roads = [ (1, 2, 1) ] result = floyd_warshall(n, roads) expected = [ [0, 1], [1, 0] ] assert result == expected","solution":"def floyd_warshall(n, roads): # Initialize the distance matrix with inf and 0s for self-loops dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Populate the initial distances based on given roads for u, v, w in roads: dist[u-1][v-1] = w dist[v-1][u-1] = w # Floyd-Warshall algorithm to find shortest paths for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Replace inf with -1 to indicate no path for i in range(n): for j in range(n): if dist[i][j] == float('inf'): dist[i][j] = -1 return dist # Example to demonstrate usage def main(): n = 4 m = 4 roads = [ (1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 1, 5) ] result = floyd_warshall(n, roads) for row in result: print(' '.join(map(str, row))) if __name__ == \\"__main__\\": main()"},{"question":"def reverse_number_string(s): Reverse the digits in the string while preserving the positions of the special characters. >>> reverse_number_string(\\"12#34\\") \\"43#21\\" >>> reverse_number_string(\\"a1b2#3\\") \\"a3b2#1\\" >>> reverse_number_string(\\"!@345\\") \\"!@543\\" >>> reverse_number_string(\\"ab#c\\") \\"ab#c\\"","solution":"def reverse_number_string(s): Reverse the digits in the string while preserving the positions of the special characters. # Extract digits from the string digits = [char for char in s if char.isdigit()] # Reverse the list of digits digits.reverse() # Create a list to hold the result result = [] digit_index = 0 # Iterate through the original string and construct the result for char in s: if char.isdigit(): result.append(digits[digit_index]) digit_index += 1 else: result.append(char) return ''.join(result)"},{"question":"def min_cost_to_reach_end(grid, N, M): Given a grid with N rows and M columns where each cell contains either a cost or a trap, determine the minimum cost to traverse from the top-left to the bottom-right corner. Args: grid (List[List[Union[int, str]]]): The grid representing costs and traps. N (int): Number of rows. M (int): Number of columns. Returns: int: The minimum cost to reach the end or -1 if it's not possible. >>> min_cost_to_reach_end([ ... [1, 2, 3], ... [4, 'X', 6], ... [7, 8, 9] ... ], 3, 3) 21 >>> min_cost_to_reach_end([ ... [1, 'X'], ... ['X', 1] ... ], 2, 2) -1 def process_datasets(input_data): Process multiple datasets to find minimum costs for each grid. Args: input_data (List[str]): The list of input strings. Returns: List[int]: The list of resulting minimum costs for each dataset. >>> process_datasets([ ... \\"3 3\\", ... \\"1 2 3\\", ... \\"4 X 6\\", ... \\"7 8 9\\", ... \\"2 2\\", ... \\"1 X\\", ... \\"X 1\\", ... \\"0 0\\" ... ]) [21, -1]","solution":"import sys from collections import deque import heapq def min_cost_to_reach_end(grid, N, M): if grid[0][0] == 'X' or grid[N-1][M-1] == 'X': return -1 directions = [(1, 0), (0, 1)] pq = [(grid[0][0], 0, 0)] visited = set((0, 0)) while pq: cost, x, y = heapq.heappop(pq) if (x, y) == (N-1, M-1): return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited: if grid[nx][ny] != 'X': heapq.heappush(pq, (cost + grid[nx][ny], nx, ny)) visited.add((nx, ny)) return -1 def process_datasets(input_data): results = [] i = 0 while i < len(input_data): N, M = map(int, input_data[i].split()) if N == 0 and M == 0: break i += 1 grid = [] for _ in range(N): row = input_data[i].split() grid_row = [] for cell in row: if cell == 'X': grid_row.append(cell) else: grid_row.append(int(cell)) grid.append(grid_row) i += 1 result = min_cost_to_reach_end(grid, N, M) results.append(result) return results # Function for parsing input def main(): import sys input_data = sys.stdin.read().strip().split('n') results = process_datasets(input_data) for result in results: print(result)"},{"question":"from typing import List def transform_words(words: List[str]) -> List[str]: Constructs a new string where each character in the word is followed by its corresponding position in the alphabet. For example, the letter 'a' is in position 1, 'b' is in position 2, and so on up to 'z' which is in position 26. Args: words (List[str]): A list of words containing only lowercase alphabetic characters. Returns: List[str]: A list of transformed strings. >>> transform_words(['abc']) ['a1b2c3'] >>> transform_words(['xyz']) ['x24y25z26'] >>> transform_words(['hello']) ['h8e5l12l12o15']","solution":"def transform_words(words): def transform_word(word): result = '' for char in word: position = ord(char) - ord('a') + 1 result += f'{char}{position}' return result return [transform_word(word) for word in words]"},{"question":"def determine_winner(N, sequence): Determine the winner of the game given the initial sequence of integers. >>> determine_winner(3, [2, 3, 4]) \\"Alice\\" >>> determine_winner(4, [1, 1, 1, 1]) \\"Bob\\" from solution import determine_winner def test_single_element(): assert determine_winner(1, [1]) == \\"Alice\\" assert determine_winner(1, [2]) == \\"Alice\\" assert determine_winner(1, [3]) == \\"Alice\\" def test_two_elements(): assert determine_winner(2, [1, 1]) == \\"Bob\\" assert determine_winner(2, [2, 2]) == \\"Bob\\" assert determine_winner(2, [2, 3]) == \\"Alice\\" def test_multiple_elements(): assert determine_winner(3, [2, 3, 4]) == \\"Alice\\" assert determine_winner(4, [1, 1, 1, 1]) == \\"Bob\\" assert determine_winner(5, [1, 2, 3, 4, 5]) == \\"Alice\\" assert determine_winner(6, [10, 10, 10, 10, 10, 10]) == \\"Bob\\" def test_large_elements(): assert determine_winner(2, [1000000, 1000000]) == \\"Bob\\" assert determine_winner(3, [999999, 1000000, 1000000]) == \\"Alice\\" assert determine_winner(2, [123456, 654321]) == \\"Alice\\" def test_edge_cases(): assert determine_winner(1, [0]) == \\"Bob\\" # Game already won by Bob assert determine_winner(2, [0, 1]) == \\"Alice\\" assert determine_winner(3, [0, 0, 0]) == \\"Bob\\"","solution":"def determine_winner(N, sequence): Determine the winner of the game given the initial sequence of integers. # Calculate the nim-sum (XOR of all elements) nim_sum = 0 for num in sequence: nim_sum ^= num # If nim-sum is zero, Bob wins, otherwise Alice wins if nim_sum == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def product_of_digits(digits: str) -> int: Return the product of all the digits in the given string, excluding zeros. >>> product_of_digits(\\"123405\\") 120 >>> product_of_digits(\\"0000\\") 0 >>> product_of_digits(\\"1\\") 1 >>> product_of_digits(\\"0\\") 0 >>> product_of_digits(\\"1000\\") 1 >>> product_of_digits(\\"20000\\") 2 >>> product_of_digits(\\"234\\") 24 >>> product_of_digits(\\"1020304\\") 24 >>> product_of_digits(\\"987654321\\") 362880 >>> product_of_digits(\\"\\") 0","solution":"def product_of_digits(digits: str) -> int: Returns the product of all the digits in the given string, excluding zeros. if not digits: return 0 product = 1 has_non_zero = False for digit in digits: num = int(digit) if num != 0: product *= num has_non_zero = True return product if has_non_zero else 0"},{"question":"def canFormByInterleaving(str1: str, str2: str) -> bool: Determine if str2 can be formed by interleaving characters of str1 with any arbitrary characters. >>> canFormByInterleaving(\\"abc\\", \\"aebdc\\") True >>> canFormByInterleaving(\\"abc\\", \\"acbd\\") False","solution":"def canFormByInterleaving(str1, str2): Determine if str2 can be formed by interleaving characters of str1 with any arbitrary characters. # Initialize pointers for both strings i, j = 0, 0 # Iterate through str2 with pointer j while i < len(str1) and j < len(str2): if str1[i] == str2[j]: # If characters match, move both pointers i += 1 j += 1 # Always move pointer j in str2 # If we've traversed all characters in str1, return True return i == len(str1)"},{"question":"def water_trapped(heights: List[int]) -> int: Calculate the total amount of water trapped between the elevations in a given 1D list of non-negative integers, representing an elevation map where the width of each bar is 1 unit. >>> water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> water_trapped([4, 2, 0, 3, 2, 5]) == 9 >>> water_trapped([0, 0, 0, 0]) == 0 >>> water_trapped([1, 0, 1]) == 1 from typing import List def test_example_case_1(): assert water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_example_case_2(): assert water_trapped([4, 2, 0, 3, 2, 5]) == 9 def test_no_water_trapped(): assert water_trapped([0, 0, 0, 0]) == 0 def test_simple_trap(): assert water_trapped([1, 0, 1]) == 1 def test_no_trap(): assert water_trapped([1, 2, 3, 4, 5]) == 0 def test_decreasing_heights(): assert water_trapped([5, 4, 3, 2, 1]) == 0 def test_single_peak(): assert water_trapped([2, 0, 2]) == 2 def test_complex_case(): assert water_trapped([3, 0, 2, 0, 4]) == 7","solution":"def water_trapped(heights): Calculate the total water trapped between the elevations. :param heights: List[int] - non-negative integers representing the elevation map :return: int - total units of water trapped if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def decode_message(encoded_str: str) -> str: Decode an encoded string by shifting characters based on given rules. Every alphabetical character (both uppercase and lowercase) should be replaced with the same character that appears three positions down in the alphabetical order (wrapping around from Z to A and from z to a). Every numeric character (0-9) should be replaced with the character that appears three positions up in the numerical order (wrapping around from 9 to 0). Any other characters should be kept unchanged. >>> decode_message(\\"abcXYZ123!?\\") == \\"defABC456!?\\" >>> decode_message(\\"a1A9zZ0!\\") == \\"d4D2cC3!\\"","solution":"def decode_message(encoded_str: str) -> str: def shift_alpha(c): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + 3) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + 3) % 26 + ord('A')) return c def shift_num(c): if '0' <= c <= '9': return chr((ord(c) - ord('0') + 3) % 10 + ord('0')) return c decoded = [] for char in encoded_str: if char.isalpha(): decoded.append(shift_alpha(char)) elif char.isdigit(): decoded.append(shift_num(char)) else: decoded.append(char) return ''.join(decoded)"},{"question":"def find_missing_train(n, observed_trains): Finds the smallest missing train number from the observed train numbers. Parameters: - n (int): Total number of distinct trains. - observed_trains (list): List of observed train numbers. Returns: - int: The smallest missing train number, or \\"NO MISSING TRAIN\\" if all are observed. pass def process_input(input_data): Processes the input data and returns the results for each test case. Parameters: - input_data (str): Multiline string input for the test cases. Returns: - list: List of missing train numbers or \\"NO MISSING TRAIN\\" messages for each test case. pass # Test cases def test_find_missing_train(): assert find_missing_train(5, [1, 2, 4, 5]) == 3 assert find_missing_train(6, [2, 3, 5, 6, 1]) == 4 assert find_missing_train(3, [1, 2, 3]) == \\"NO MISSING TRAIN\\" assert find_missing_train(7, [1, 2, 3, 4, 5, 6]) == 7 assert find_missing_train(10, [7, 8, 9, 10, 1, 2, 3, 4, 5]) == 6 def test_process_input(): input_data = \\"5n1 2 4 5n6n2 3 5 6 1n0n\\" expected_output = [3, 4] assert process_input(input_data) == expected_output input_data = \\"3n1 2 3n7n1 2 3 4 5 6n0n\\" expected_output = [\\"NO MISSING TRAIN\\", 7] assert process_input(input_data) == expected_output input_data = \\"4n1 2 3n4n1 3 4n0n\\" expected_output = [4, 2] assert process_input(input_data) == expected_output","solution":"def find_missing_train(n, observed_trains): Finds the smallest missing train number from the observed train numbers. Parameters: - n (int): Total number of distinct trains. - observed_trains (list): List of observed train numbers. Returns: - int: The smallest missing train number, or \\"NO MISSING TRAIN\\" if all are observed. observed_set = set(observed_trains) for train_number in range(1, n + 1): if train_number not in observed_set: return train_number return \\"NO MISSING TRAIN\\" def process_input(input_data): Processes the input data and returns the results for each test case. Parameters: - input_data (str): Multiline string input for the test cases. Returns: - list: List of missing train numbers or \\"NO MISSING TRAIN\\" messages for each test case. lines = input_data.strip().split('n') results = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break observed_trains = list(map(int, lines[i + 1].split())) results.append(find_missing_train(n, observed_trains)) i += 2 return results"},{"question":"from typing import List def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False pass def nearest_smaller_prime(num: int) -> int: Find the nearest smaller prime number less than the given number. >>> nearest_smaller_prime(10) 7 >>> nearest_smaller_prime(18) 17 >>> nearest_smaller_prime(20) 19 >>> nearest_smaller_prime(22) 19 >>> nearest_smaller_prime(1) 2 >>> nearest_smaller_prime(0) 2 pass def transform_list(nums: List[int]) -> List[int]: Transform the list by replacing non-prime numbers with the nearest smaller prime. >>> transform_list([10, 17, 18, 19, 20, 23]) [7, 17, 17, 19, 19, 23] >>> transform_list([2, 3, 4, 5, 6]) [2, 3, 3, 5, 5] >>> transform_list([1, 2, 3, 10, 15]) [2, 2, 3, 7, 13] >>> transform_list([12, 24, 35, 48, 59]) [11, 23, 31, 47, 59] pass","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def nearest_smaller_prime(num): Find the nearest smaller prime number less than the given number. if num <= 2: return 2 # the nearest smallest prime for any number less than or equal to 2 for i in range(num - 1, 1, -1): if is_prime(i): return i return 2 # this case should not be typically reached because of constraints def transform_list(nums): Transform the list by replacing non-prime numbers with the nearest smaller prime. return [num if is_prime(num) else nearest_smaller_prime(num) for num in nums]"},{"question":"def find_top_user(data): Given a list of user IDs and their respective weekly hours watched, returns the user ID of the user with the highest total hours watched. Args: data: List of strings, where alternate lines represents userID and weekly hours watched Returns: String: userID of the user with the highest total hours watched Example: >>> find_top_user([\\"user1\\", \\"2 3 1 4 0 5 3\\", \\"user2\\", \\"0 0 0 0 0 0 0\\", \\"user3\\", \\"1 2 3 4 5 6 7\\"]) 'user3'","solution":"def find_top_user(data): Given a list of user IDs and their respective weekly hours watched, returns the user ID of the user with the highest total hours watched. :param data: List of strings, where alternate lines represents userID and weekly hours watched :return: String, userID of the user with the highest total hours watched max_hours = -1 top_user = '' for i in range(0, len(data), 2): user_id = data[i] hours = list(map(int, data[i+1].split())) total_hours = sum(hours) if total_hours > max_hours: max_hours = total_hours top_user = user_id return top_user"},{"question":"def chairs_needed(n): Returns the number of complete rows and remaining chairs. :param n: Total number of chairs. :return: A tuple containing the number of complete rows and remaining chairs. Examples: >>> chairs_needed(35) (4, 3) >>> chairs_needed(80) (10, 0) >>> chairs_needed(123) (15, 3)","solution":"def chairs_needed(n): Returns the number of complete rows and remaining chairs. :param n: Total number of chairs. :return: A tuple containing the number of complete rows and remaining chairs. complete_rows = n // 8 remaining_chairs = n % 8 return (complete_rows, remaining_chairs)"},{"question":"def unique_paths_with_obstacles(grid) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of the grid. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0 def solve_number_of_unique_paths(test_cases) -> List[int]: Solve for the number of unique paths for multiple test cases. >>> solve_number_of_unique_paths([[[0, 0, 0], [0, 1, 0], [0, 0, 0]], [[0, 1], [1, 0]]]) [2, 0] def parse_input(raw_input: str) -> List[List[List[int]]]: Parse a raw input string into a format suitable for processing. >>> parse_input(\\"2n3 3n0 0 0n0 1 0n0 0 0n2 2n0 1n1 0n\\") [[[0, 0, 0], [0, 1, 0], [0, 0, 0]], [[0, 1], [1, 0]]] def process_input(raw_input: str) -> List[int]: Process the raw input string and return the number of unique paths for each test case. >>> process_input(\\"2n3 3n0 0 0n0 1 0n0 0 0n2 2n0 1n1 0n\\") [2, 0]","solution":"def unique_paths_with_obstacles(grid): if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 R, C = len(grid), len(grid[0]) dp = [[0] * C for _ in range(R)] dp[0][0] = 1 for r in range(R): for c in range(C): if grid[r][c] == 1: dp[r][c] = 0 elif r > 0 and c > 0: dp[r][c] = dp[r-1][c] + dp[r][c-1] elif r > 0: dp[r][c] = dp[r-1][c] elif c > 0: dp[r][c] = dp[r][c-1] return dp[R-1][C-1] def solve_number_of_unique_paths(test_cases): results = [] for grid in test_cases: results.append(unique_paths_with_obstacles(grid)) return results def parse_input(raw_input): data = raw_input.strip().split(\\"n\\") index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): R, C = map(int, data[index].split()) index += 1 grid = [] for _ in range(R): row = list(map(int, data[index].split())) grid.append(row) index += 1 test_cases.append(grid) return test_cases def process_input(raw_input): test_cases = parse_input(raw_input) return solve_number_of_unique_paths(test_cases)"},{"question":"def min_bricks(n: int, L: int, brick_lengths: List[int]) -> int: Given the number of different types of bricks and the desired wall length, find the minimum number of bricks needed to build the wall of length L, or return -1 if it's not possible. >>> min_bricks(5, 11, [1, 2, 3, 4, 5]) 3 >>> min_bricks(4, 10, [2, 3, 7, 8]) 2 >>> min_bricks(3, 1, [2, 4, 5]) -1","solution":"def min_bricks(n, L, brick_lengths): dp = [float('inf')] * (L + 1) dp[0] = 0 for length in range(1, L + 1): for brick in brick_lengths: if length >= brick: dp[length] = min(dp[length], dp[length - brick] + 1) return dp[L] if dp[L] != float('inf') else -1 # Example function call, you may remove it or comment out. # n = 5 # L = 11 # brick_lengths = [1, 2, 3, 4, 5] # print(min_bricks(n, L, brick_lengths)) # Output: 3"},{"question":"def remove_consecutive_repeated_words(sentence: str) -> str: Removes consecutive repeated words from the given sentence. >>> remove_consecutive_repeated_words(\\"this is is a test test sentence\\") 'this is a test sentence' >>> remove_consecutive_repeated_words(\\"hello world world world\\") 'hello world'","solution":"def remove_consecutive_repeated_words(sentence): Removes consecutive repeated words from the given sentence. words = sentence.split() result = [] for word in words: if not result or result[-1] != word: result.append(word) return ' '.join(result)"},{"question":"def longest_subsequence_with_diff_one(arr): Takes a list of integers and returns the length of the longest subsequence where the absolute difference between any two consecutive elements is 1. Parameters: arr (List[int]): The list of integers. Returns: int: The length of the longest subsequence. >>> longest_subsequence_with_diff_one([1, 2, 2, 3, 3, 4]) 4 >>> longest_subsequence_with_diff_one([1, 1, 1, 1, 1]) 1","solution":"def longest_subsequence_with_diff_one(arr): Takes a list of integers and returns the length of the longest subsequence where the absolute difference between any two consecutive elements is 1. Parameters: arr (List[int]): The list of integers. Returns: int: The length of the longest subsequence. n = len(arr) if n == 0: return 0 # Initialize longest sequence length array longest_seq_len = [1] * n # Compute lengths of longest subsequences for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) == 1: longest_seq_len[i] = max(longest_seq_len[i], longest_seq_len[j] + 1) return max(longest_seq_len)"},{"question":"from typing import List def count_ways_to_label_k_tree(n: int, k: int) -> int: Returns the number of distinct ways to label an n-node k-tree. Args: n (int): The number of nodes in the tree. k (int): The maximum number of children each node can have. Returns: int: The number of distinct ways to label the k-tree. Examples: >>> count_ways_to_label_k_tree(1, 2) 1 >>> count_ways_to_label_k_tree(2, 2) 1 >>> count_ways_to_label_k_tree(3, 2) 2 >>> count_ways_to_label_k_tree(4, 2) 6","solution":"from math import factorial def count_ways_to_label_k_tree(n, k): Returns the number of distinct ways to label an n-node k-tree. if n == 0 or n == 1: return 1 total_ways = factorial(n - 1) return total_ways"},{"question":"def cube_faces_reconstruct(t: int, test_cases: List[Tuple[int, int, int, int, int, int]]) -> List[Union[str, int]]: Determine if it is possible to form a valid cube using the six tiles provided or return the minimum side length of the additional square tile required. >>> cube_faces_reconstruct(2, [(4, 4, 4, 4, 4, 4), (3, 3, 3, 5, 3, 3)]) [\\"VALID\\", 5] >>> cube_faces_reconstruct(1, [(1, 2, 3, 4, 5, 6)]) [6]","solution":"def cube_faces_reconstruct(t, test_cases): results = [] for case in test_cases: side_lengths = sorted(case) # To form a cube, all six sides must be the same. if len(set(side_lengths)) == 1: results.append(\\"VALID\\") else: # We need an additional square with the side of the largest given square results.append(side_lengths[-1]) return results"},{"question":"import re def palindromeCheck(s): Determines if a given string is a palindrome, ignoring case, spaces, and non-alphanumeric characters. If the input is not a string, returns False. >>> palindromeCheck(\\"A man, a plan, a canal, Panama\\") == True >>> palindromeCheck(\\"No 'x' in Nixon\\") == True >>> palindromeCheck(\\"Hello, World!\\") == False >>> palindromeCheck(12345) == False >>> palindromeCheck(\\"Was it a car or a cat I saw?\\") == True","solution":"import re def palindromeCheck(s): Determines if a given string is a palindrome, ignoring case, spaces, and non-alphanumeric characters. If the input is not a string, returns False. if not isinstance(s, str): return False # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is a palindrome return cleaned == cleaned[::-1]"},{"question":"def max_subset_cost(arr: List[int]) -> int: Calculate the maximum possible cost between any two non-overlapping subsets of an array. >>> max_subset_cost([1, 2, 3, 4, 5]) 15 >>> max_subset_cost([1, -1, 2, -2, 3, -3]) 0 >>> max_subset_cost([-5, -10, -3]) 18 >>> max_subset_cost([1000, -1000]) 0 >>> max_subset_cost([1, 1, 1, 1, 1, 1, 1, 1]) 8","solution":"def max_subset_cost(arr): Given an array of integers, the maximum possible cost between any two non-overlapping subsets of the array is the absolute difference between the sum of all elements and zero (which is the sum of an empty subset). Since we want the maximum cost, we always consider the sum of the entire array and an empty subset. total_sum = sum(arr) return abs(total_sum - 0) # abs is redundant here, but for clarity, we use it"},{"question":"def check_code_for_keywords(reserved_keywords, lines_of_code): Determines if any reserved keywords are present in the lines of code. Parameters: reserved_keywords (list of str): List of reserved keywords. lines_of_code (list of str): List of code lines. Returns: str: \\"Disqualified\\" if any reserved keywords are found in the code, otherwise \\"Qualified\\". pass def test_no_keywords(): reserved_keywords = [\\"private\\", \\"public\\"] lines_of_code = [ \\"class Example {\\", \\" void method() {\\", \\" }\\", \\"}\\" ] assert check_code_for_keywords(reserved_keywords, lines_of_code) == \\"Qualified\\" def test_keyword_present(): reserved_keywords = [\\"return\\", \\"while\\", \\"if\\"] lines_of_code = [ \\"int main()\\", \\"{\\", \\" if (a == b) return 0;\\", \\"}\\" ] assert check_code_for_keywords(reserved_keywords, lines_of_code) == \\"Disqualified\\" def test_multiple_keywords_present(): reserved_keywords = [\\"for\\", \\"include\\"] lines_of_code = [ \\"int sum = 0;\\", \\"for(int i = 0; i < 10; i++){\\", \\" sum += i;\\", \\"}\\" ] assert check_code_for_keywords(reserved_keywords, lines_of_code) == \\"Disqualified\\" def test_edge_case_with_empty_code(): reserved_keywords = [\\"class\\", \\"method\\"] lines_of_code = [] assert check_code_for_keywords(reserved_keywords, lines_of_code) == \\"Qualified\\" def test_edge_case_with_empty_keywords(): reserved_keywords = [] lines_of_code = [ \\"import sys\\", \\"def function(x):\\", \\" return x + 1\\" ] assert check_code_for_keywords(reserved_keywords, lines_of_code) == \\"Qualified\\"","solution":"def check_code_for_keywords(reserved_keywords, lines_of_code): Determines if any reserved keywords are present in the lines of code. Parameters: reserved_keywords (list of str): List of reserved keywords. lines_of_code (list of str): List of code lines. Returns: str: \\"Disqualified\\" if any reserved keywords are found in the code, otherwise \\"Qualified\\". for keyword in reserved_keywords: for line in lines_of_code: if keyword in line: return \\"Disqualified\\" return \\"Qualified\\""},{"question":"def manage_guest_list(commands: List[str]) -> int: This function helps to manage the guest list for a movie night. Each friend can accept, decline, or cancel their RSVP. The function keeps track of who has accepted and returns the number of accepted guests at the end. Args: commands (List[str]): A list of strings where each string represents one of the three types of commands: \\"ACCEPT <name>\\", \\"DECLINE <name>\\", \\"CANCEL <name>\\". Returns: int: The count of guests who have accepted the invitation after all commands are processed. Example: >>> manage_guest_list([ \\"ACCEPT Alice\\", \\"ACCEPT Bob\\", \\"DECLINE Alice\\", \\"CANCEL Bob\\", \\"ACCEPT Charlie\\", \\"ACCEPT Alice\\", \\"CANCEL Charlie\\" ]) 1","solution":"def manage_guest_list(commands): accepted_guests = set() for command in commands: action, name = command.split(' ') if action == \\"ACCEPT\\": accepted_guests.add(name) elif action == \\"DECLINE\\" or action == \\"CANCEL\\": accepted_guests.discard(name) return len(accepted_guests)"},{"question":"def shortest_travel_time(N: int, R: int, roads: List[Tuple[int, int, int]], S: int, T: int) -> int: Returns the minimum travel time from town S to town T. If there's no path from S to T, return -1. Args: N (int): The number of towns (nodes). R (int): The number of roads (edges). roads (List[Tuple[int, int, int]]): A list of roads where each road is a tuple (u, v, w), indicating a road between town u and town v with a travel time w. S (int): The starting town. T (int): The destination town. Returns: int: The minimum travel time or -1 if no path exists. Example: >>> shortest_travel_time(5, 6, [(1, 2, 7), (1, 3, 9), (1, 5, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (4, 5, 9)], 1, 4) 20","solution":"import heapq def shortest_travel_time(N, R, roads, S, T): Returns the minimum travel time from town S to town T. If there's no path from S to T, return -1. # Build the graph represented as adjacency list graph = {i: [] for i in range(1, N+1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Priority queue to hold (distance, node) and dictionary to store shortest paths pq = [(0, S)] shortest_paths = {i: float('inf') for i in range(1, N+1)} shortest_paths[S] = 0 while pq: current_distance, current_town = heapq.heappop(pq) if current_distance > shortest_paths[current_town]: continue for neighbor, weight in graph[current_town]: distance = current_distance + weight if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) result = shortest_paths[T] return result if result != float('inf') else -1"},{"question":"def decodeString(encoded: str) -> str: Decode a given encoded string using the rule k[encoded_string]. The encoded_string inside the square brackets is repeated exactly k times. You may assume the input string is always valid. Args: encoded (str): The encoded string. Returns: str: The decoded string. >>> decodeString(\\"3[a]2[bc]\\") 'aaabcbc' >>> decodeString(\\"3[a2[c]]\\") 'accaccacc' def decodeStrings(encoded_list: List[str]) -> List[str]: Given a list of encoded strings, decode each one. Args: encoded_list (List[str]): List of encoded strings. Returns: List[str]: List of decoded strings. >>> decodeStrings([\\"3[a]2[bc]\\", \\"3[a2[c]]\\"]) ['aaabcbc', 'accaccacc'] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split('n') T = int(data[0]) encoded_strings = data[1:T+1] results = decodeStrings(encoded_strings) for result in results: print(result)","solution":"def decodeString(encoded): Decode an encoded string with the format k[encoded_string]. stack = [] current_string = \\"\\" current_num = 0 for c in encoded: if c.isdigit(): current_num = current_num * 10 + int(c) elif c == '[': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif c == ']': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += c return current_string def decodeStrings(encoded_list): Given a list of encoded strings, decode each one. return [decodeString(encoded) for encoded in encoded_list] # Handling input and output if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split('n') T = int(data[0]) encoded_strings = data[1:T+1] results = decodeStrings(encoded_strings) for result in results: print(result)"},{"question":"from typing import List def majority_element(arr: List[int]) -> int: Finds the majority element in the array, which is the element that appears more than ⌊n/2⌋ times. If no majority element exists, returns -1. >>> majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 >>> majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4, 4]) == 4 >>> majority_element([1, 1, 1, 1, 2, 2, 2]) == 1 >>> majority_element([1, 2, 3, 4, 5, 6, 7]) == -1 from solution import majority_element def test_majority_element_exists(): assert majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 assert majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4, 4]) == 4 assert majority_element([1, 1, 1, 1, 2, 2, 2]) == 1 def test_no_majority_element(): assert majority_element([1, 2, 3, 4, 5, 6, 7]) == -1 assert majority_element([1, 2, 3, 1, 2, 3]) == -1 def test_single_element(): assert majority_element([10]) == 10 assert majority_element([-1]) == -1 def test_multiple_elements_with_no_majority(): assert majority_element([1, 1, 2, 2, 3, 3, 4, 4]) == -1 def test_large_input(): assert majority_element([1]*50001 + [2]*49999) == 1","solution":"from typing import List def majority_element(arr: List[int]) -> int: Finds the majority element in the array, which is the element that appears more than ⌊n/2⌋ times. If no majority element exists, returns -1. n = len(arr) count = {} for num in arr: if num in count: count[num] += 1 else: count[num] = 1 if count[num] > n // 2: return num return -1"},{"question":"import heapq from collections import Counter def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If it is not possible, returns an empty string. Args: s (str): The input string. Returns: str: The rearranged string or an empty string if not possible. >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"abcdefg\\") 'abcdefg' pass def solve(t, test_cases): Solves the problem for multiple test cases. Args: t (int): The number of test cases. test_cases (List[str]): A list of test case strings. Returns: List[str]: A list containing the results for each test case. >>> solve(3, [\\"aabb\\", \\"aaab\\", \\"abcdefg\\"]) ['abab', '', 'abcdefg'] pass from solution import solve def test_single_string(): assert solve(1, [\\"aabb\\"]) == [\\"abab\\"] assert solve(1, [\\"aaab\\"]) == [\\"\\"] assert solve(1, [\\"abcdefg\\"]) == [\\"abcdefg\\"] def test_multiple_strings(): assert solve(3, [\\"aabb\\", \\"aaab\\", \\"abcdefg\\"]) == [\\"abab\\", \\"\\", \\"abcdefg\\"] assert solve(2, [\\"abcde\\", \\"aaaaa\\"]) == [\\"abcde\\", \\"\\"] def test_edge_cases(): assert solve(1, [\\"a\\"]) == [\\"a\\"] assert solve(1, [\\"aa\\"]) == [\\"\\"] def test_long_strings(): assert solve(1, [\\"a\\" * 5000 + \\"b\\" * 5000]) == [\\"ab\\" * 5000] assert solve(1, [\\"a\\" * 10000]) == [\\"\\"]","solution":"import heapq from collections import Counter def rearrange_string(s): # Calculate frequency of each character freq = Counter(s) max_heap = [] # Create a max heap based on frequency for char, count in freq.items(): heapq.heappush(max_heap, (-count, char)) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append the character to result list result.append(char) # If there is a previous character to re-insert if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_count and prev_char prev_char = char prev_count = count + 1 # Since we're decreasing frequency grouped with the current char. # Check if we managed to rearrange successfully rearranged = ''.join(result) if len(rearranged) == len(s): return rearranged else: return \\"\\" def solve(t, test_cases): results = [] for case in test_cases: results.append(rearrange_string(case)) return results"},{"question":"def max_trapped_water(grid, n, m): Determine the maximum amount of water that can be trapped between the buildings after a rain on a grid of buildings. Args: grid: List[List[int]]: A n x m grid representing the height of the buildings. n: int: The number of rows in the grid. m: int: The number of columns in the grid. Returns: int: The maximum amount of trapped water. Example: >>> max_trapped_water([[1, 2, 1], [2, 1, 2], [1, 1, 1]], 3, 3) 0 >>> max_trapped_water([[3, 3, 3], [3, 0, 3], [3, 3, 3]], 3, 3) 3 pass def solve_trapped_water(test_cases): Solves multiple test cases of the trapped water problem. Args: test_cases: List[Tuple[int, int, List[List[int]]]]: A list of test cases. Returns: List[int]: A list of results for each test case. Example: >>> solve_trapped_water([((3, 3), [[1, 2, 1], [2, 1, 2], [1, 1, 1]]), ((3, 3), [[3, 3, 3], [3, 0, 3], [3, 3, 3]])]) [0, 3] pass # Example usage with input parsing def parse_input(input_lines): Parses input lines into test cases for the trapped water problem. Args: input_lines: List[str]: The input lines containing the number of test cases and grid dimensions. Returns: List[Tuple[int, int, List[List[int]]]]: Parsed test cases. index = 0 num_tests = int(input_lines[index]) index += 1 test_cases = [] for _ in range(num_tests): n, m = map(int, input_lines[index].split()) index += 1 grid = [] for _ in range(n): grid.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append(((n, m), grid)) return test_cases # Example usage def main(input_lines): Main function to handle input and output for the trapped water problem. Args: input_lines: List[str]: The input lines containing the number of test cases and grid dimensions. test_cases = parse_input(input_lines) results = solve_trapped_water(test_cases) for result in results: print(result)","solution":"def max_trapped_water(grid, n, m): if n < 3 or m < 3: return 0 left_max = [[0]*m for _ in range(n)] right_max = [[0]*m for _ in range(n)] top_max = [[0]*m for _ in range(n)] bottom_max = [[0]*m for _ in range(n)] for i in range(n): left_max[i][0] = grid[i][0] for j in range(1, m): left_max[i][j] = max(left_max[i][j-1], grid[i][j]) for i in range(n): right_max[i][m-1] = grid[i][m-1] for j in range(m-2, -1, -1): right_max[i][j] = max(right_max[i][j+1], grid[i][j]) for j in range(m): top_max[0][j] = grid[0][j] for i in range(1, n): top_max[i][j] = max(top_max[i-1][j], grid[i][j]) for j in range(m): bottom_max[n-1][j] = grid[n-1][j] for i in range(n-2, -1, -1): bottom_max[i][j] = max(bottom_max[i+1][j], grid[i][j]) trapped_water = 0 for i in range(1, n-1): for j in range(1, m-1): min_height = min(left_max[i][j], right_max[i][j], top_max[i][j], bottom_max[i][j]) if min_height > grid[i][j]: trapped_water += min_height - grid[i][j] return trapped_water def solve_trapped_water(test_cases): results = [] for t in test_cases: n, m = t[0] grid = t[1] result = max_trapped_water(grid, n, m) results.append(result) return results # Example usage with input parsing def parse_input(input_lines): index = 0 num_tests = int(input_lines[index]) index += 1 test_cases = [] for _ in range(num_tests): n, m = map(int, input_lines[index].split()) index += 1 grid = [] for _ in range(n): grid.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append(((n, m), grid)) return test_cases # Example usage def main(input_lines): test_cases = parse_input(input_lines) results = solve_trapped_water(test_cases) for result in results: print(result)"},{"question":"import random def generate_password(N: int) -> str: Generate a secure password of exactly N characters that: - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character from the set: !@#%^&*()-+. - Is exactly N characters long. Raises: ValueError: If N is less than 4. :param N: The length of the password to be generated. :type N: int :return: A secure password of length N characters. :rtype: str pass def main(T: int, N_list: list) -> list: Generate a list of secure passwords for each provided length. :param T: Number of test cases. :type T: int :param N_list: List of integers where each integer represents the length of a password to be generated. :type N_list: list :return: A list of generated passwords. :rtype: list pass # Unit testing def test_generate_password_valid_length_8(): password = generate_password(8) assert len(password) == 8 assert any(c.isupper() for c in password) assert any(c.islower() for c in password) assert any(c.isdigit() for c in password) assert any(c in \\"!@#%^&*()-+\\" for c in password) def test_generate_password_valid_length_12(): password = generate_password(12) assert len(password) == 12 assert any(c.isupper() for c in password) assert any(c.islower() for c in password) assert any(c.isdigit() for c in password) assert any(c in \\"!@#%^&*()-+\\" for c in password) def test_generate_password_minimum_valid_length(): password = generate_password(4) assert len(password) == 4 assert any(c.isupper() for c in password) assert any(c.islower() for c in password) assert any(c.isdigit() for c in password) assert any(c in \\"!@#%^&*()-+\\" for c in password) def test_main(): passwords = main(2, [8, 12]) assert len(passwords) == 2 assert len(passwords[0]) == 8 assert len(passwords[1]) == 12 def test_generate_password_error(): with pytest.raises(ValueError): generate_password(3)","solution":"import random def generate_password(N): if N < 4: raise ValueError(\\"Password length must be at least 4 to satisfy all rules.\\") # Character sets uppercase_chars = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" lowercase_chars = \\"abcdefghijklmnopqrstuvwxyz\\" digit_chars = \\"0123456789\\" special_chars = \\"!@#%^&*()-+\\" password = [ random.choice(uppercase_chars), random.choice(lowercase_chars), random.choice(digit_chars), random.choice(special_chars) ] remaining_length = N - 4 all_chars = uppercase_chars + lowercase_chars + digit_chars + special_chars password.extend(random.choices(all_chars, k=remaining_length)) # Shuffle to avoid predictable patterns random.shuffle(password) return \\"\\".join(password) def main(T, N_list): passwords = [] for N in N_list: passwords.append(generate_password(N)) return passwords"},{"question":"def experiencedHeatwave(N: int, temps: List[int]) -> bool: Determine if the town experienced a heatwave by checking for any three consecutive days where the temperature increased each day. Parameters: N : int : number of days temps : list of int : list of daily temperatures Returns: bool : True if there is heatwave, otherwise False >>> experiencedHeatwave(6, [30, 32, 34, 33, 35, 37]) True >>> experiencedHeatwave(5, [30, 29, 32, 28, 35]) False pass def test_experiencedHeatwave_example1(): temps = [30, 32, 34, 33, 35, 37] N = 6 assert experiencedHeatwave(N, temps) == True def test_experiencedHeatwave_example2(): temps = [30, 29, 32, 28, 35] N = 5 assert experiencedHeatwave(N, temps) == False def test_experiencedHeatwave_no_heatwave(): temps = [30, 30, 30, 30, 30] N = 5 assert experiencedHeatwave(N, temps) == False def test_experiencedHeatwave_heatwave_at_end(): temps = [29, 30, 31, 33, 34, 35] N = 6 assert experiencedHeatwave(N, temps) == True def test_experiencedHeatwave_short_list(): temps = [33, 34, 35] N = 3 assert experiencedHeatwave(N, temps) == True def test_experiencedHeatwave_min_boundary(): temps = [30] N = 1 assert experiencedHeatwave(N, temps) == False def test_experiencedHeatwave_two_elements(): temps = [30, 31] N = 2 assert experiencedHeatwave(N, temps) == False def test_experiencedHeatwave_single_negative_heatwave(): temps = [-10, -9, -8] N = 3 assert experiencedHeatwave(N, temps) == True def test_experiencedHeatwave_no_heatwave_with_random_temps(): temps = [30, 32, 31, 30, 32, 29, 34] N = 7 assert experiencedHeatwave(N, temps) == False","solution":"def experiencedHeatwave(N, temps): Determine if the town experienced a heatwave by checking for any three consecutive days where the temperature increased each day. Parameters: N : int : number of days temps : list of int : list of daily temperatures Returns: bool : True if there is heatwave, otherwise False for i in range(N - 2): if temps[i] < temps[i + 1] and temps[i + 1] < temps[i + 2]: return True return False"},{"question":"def calculate_final_scores(n: int, m: int, initial_scores: List[int], shifts: List[Tuple[int, int, int]]) -> List[int]: Calculate the final scores for all participants after applying all the shifts. Args: n (int): The number of participants. m (int): The number of shifts. initial_scores (List[int]): Initial scores of the participants. shifts (List[Tuple[int, int, int]]): List of shifts where each shift is defined by start, end, and value. Returns: List[int]: Final scores of all participants after all shifts. Examples: >>> calculate_final_scores(5, 3, [1, 2, 3, 4, 5], [(1, 3, 10), (2, 5, -5), (1, 5, 3)]) [14, 10, 11, 2, 3] >>> calculate_final_scores(4, 2, [10, 20, 30, 40], [(1, 2, 5), (3, 4, -10)]) [15, 25, 20, 30] >>> calculate_final_scores(3, 1, [5, 5, 5], [(1, 3, 2)]) [7, 7, 7] >>> calculate_final_scores(1, 1, [100], [(1, 1, 50)]) [150] >>> calculate_final_scores(3, 0, [5, 10, 15], []) [5, 10, 15] >>> calculate_final_scores(4, 4, [1, 1, 1, 1], [(1, 1, 5), (2, 2, 5), (3, 3, 5), (4, 4, 5)]) [6, 6, 6, 6] >>> calculate_final_scores(5, 1, [1, 2, 3, 4, 5], [(1, 5, 1)]) [2, 3, 4, 5, 6] >>> calculate_final_scores(5, 1, [0, 0, 0, 0, 0], [(1, 5, 1000000000)]) [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]","solution":"def calculate_final_scores(n, m, initial_scores, shifts): final_scores = initial_scores[:] for start, end, value in shifts: for i in range(start-1, end): final_scores[i] += value return final_scores"},{"question":"def count_valid_palindromic_deletions(s: str) -> int: Return the number of distinct valid palindromic strings obtainable by deleting exactly one character from the input string s. >>> count_valid_palindromic_deletions(\\"aa\\") 1 >>> count_valid_palindromic_deletions(\\"abca\\") 2 >>> count_valid_palindromic_deletions(\\"abc\\") 0 >>> count_valid_palindromic_deletions(\\"racecar\\") 1 >>> count_valid_palindromic_deletions(\\"aaaa\\") 1","solution":"def count_valid_palindromic_deletions(s): Return the number of distinct valid palindromic strings obtainable by deleting exactly one character from the input string s. def is_palindrome(sub): return sub == sub[::-1] count = 0 seen = set() for i in range(len(s)): candidate = s[:i] + s[i+1:] if candidate not in seen and is_palindrome(candidate): seen.add(candidate) count += 1 return count"},{"question":"def create_sequence(b: List[int]) -> List[int]: Create a new sequence c of length n such that each element c_i is the product of all elements in the list b except for the element b_i at the respective position i. >>> create_sequence([1, 2, 3, 4]) [24, 12, 8, 6] >>> create_sequence([2, 3, 4]) [12, 8, 6] >>> create_sequence([5]) [1] >>> create_sequence([3, 5]) [5, 3] >>> create_sequence([1000000, 1000000, 1000000]) [1000000000000, 1000000000000, 1000000000000] >>> create_sequence([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24]","solution":"def create_sequence(b): n = len(b) if n == 1: return [1] # Create an array to store the prefix products prefix_products = [1] * n prefix_products[0] = b[0] for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * b[i] # Create an array to store the suffix products suffix_products = [1] * n suffix_products[n - 1] = b[n - 1] for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * b[i] # Create the result array c = [1] * n c[0] = suffix_products[1] c[n - 1] = prefix_products[n - 2] for i in range(1, n - 1): c[i] = prefix_products[i - 1] * suffix_products[i + 1] return c"},{"question":"def max_non_overlapping_tasks(tasks): Determines the maximum number of non-overlapping tasks that can be completed. :param tasks: List of tuples, where each tuple contains start and end time of a task. :return: Maximum number of non-overlapping tasks. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_tasks([(0, 1), (3, 4), (1, 2), (2, 3)]) 4 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (1, 3), (3, 4)]) 3 >>> max_non_overlapping_tasks([]) 0 >>> max_non_overlapping_tasks([(0, 1)]) 1 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4), (1, 4)]) 3 >>> tasks = [(i, i + 1) for i in range(1000)] >>> max_non_overlapping_tasks(tasks) 1000","solution":"def max_non_overlapping_tasks(tasks): Determines the maximum number of non-overlapping tasks that can be completed. :param tasks: List of tuples, where each tuple contains start and end time of a task. :return: Maximum number of non-overlapping tasks. # Sort tasks based on end time tasks_sorted = sorted(tasks, key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in tasks_sorted: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def max_absolute_difference(nums): Finds the maximum absolute difference between any two distinct elements in the array. >>> max_absolute_difference([1, 2, 3, 4]) == 3 >>> max_absolute_difference([-10, -20, 5, 4, 1]) == 25 >>> max_absolute_difference([1000000000, -1000000000]) == 2000000000 def process_test_cases(T, test_cases): Processes multiple test cases and returns the results. >>> test_cases = [(4, [1, 2, 3, 4]), (5, [-10, -20, 5, 4, 1]), (2, [1000000000, -1000000000])] >>> process_test_cases(3, test_cases) == [3, 25, 2000000000]","solution":"def max_absolute_difference(nums): Finds the maximum absolute difference between any two distinct elements in the array. max_num = max(nums) min_num = min(nums) return abs(max_num - min_num) def process_test_cases(T, test_cases): results = [] for i in range(T): n, nums = test_cases[i] results.append(max_absolute_difference(nums)) return results"},{"question":"def count_subarrays_with_sum(sequence: List[int], target: int) -> int: Counts the number of subarrays in the given sequence that have a sum exactly equal to target. Args: sequence (list of int): List of integers representing the sequence. target (int): The target sum for the subarrays. Returns: int: The count of subarrays with sum equal to target. Example: >>> count_subarrays_with_sum([1, 2, 1, 2, 3], 5) 2 >>> count_subarrays_with_sum([3, 3, 3, 3], 3) 4","solution":"def count_subarrays_with_sum(sequence, target): Counts the number of subarrays in the given sequence that have a sum exactly equal to target. Args: sequence (list of int): List of integers representing the sequence. target (int): The target sum for the subarrays. Returns: int: The count of subarrays with sum equal to target. from collections import defaultdict # Dictionary to store the cumulative sum up to all the indices cum_sum_count = defaultdict(int) cum_sum_count[0] = 1 # to account for the sum from start to current index current_sum = 0 subarray_count = 0 for num in sequence: current_sum += num if (current_sum - target) in cum_sum_count: subarray_count += cum_sum_count[current_sum - target] cum_sum_count[current_sum] += 1 return subarray_count # Read input from user/system def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) x = int(data[1]) sequence = list(map(int, data[2:2+n])) result = count_subarrays_with_sum(sequence, x) print(result)"},{"question":"def travel_possible(S, R, routes, Q, queries): Determines whether it is possible to travel between two given bus stops using the available bus routes in the city. Parameters: S (int): number of stops. R (int): number of bus routes. routes (List[Tuple[int, int]]): list of direct bus routes between the stops. Q (int): number of queries. queries (List[Tuple[int, int]]): queries asking whether travel is possible between two specific bus stops. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each query. Example: >>> travel_possible(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 3, [(1, 5), (2, 4), (1, 3)]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def travel_possible(S, R, routes, Q, queries): from collections import defaultdict, deque # Create an adjacency list for the graph representing the bus stops and routes graph = defaultdict(list) for u, v in routes: graph[u].append(v) graph[v].append(u) def bfs(start, goal): if start == goal: return True visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: if neighbor == goal: return True visited.add(neighbor) queue.append(neighbor) return False results = [] for a, b in queries: if bfs(a, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_subarray_sum_with_indices(nums): Given an array of integers, find a contiguous subarray (containing at least one number) which has the largest sum and return its sum along with the indices of the subarray. If there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. If there is still a tie, return the one with the smallest ending index. Args: nums (List[int]): List of integers. Returns: Tuple[int, int, int]: The maximum sum, starting index, and ending index of the subarray. >>> max_subarray_sum_with_indices([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 4, 7) >>> max_subarray_sum_with_indices([-1]) (-1, 1, 1) >>> max_subarray_sum_with_indices([1, -1, 1, -1, 1, -1, 1, -1, 1, -1]) (1, 1, 1) pass def test_max_subarray_sum_with_indices(): assert max_subarray_sum_with_indices([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == (6, 4, 7) assert max_subarray_sum_with_indices([-1]) == (-1, 1, 1) assert max_subarray_sum_with_indices([1, -1, 1, -1, 1, -1, 1, -1, 1, -1]) == (1, 1, 1) assert max_subarray_sum_with_indices([5, 4, -1, 7, 8]) == (23, 1, 5) assert max_subarray_sum_with_indices([-1, -2, -3, -4]) == (-1, 1, 1) assert max_subarray_sum_with_indices([1, 2, 3, 4]) == (10, 1, 4) assert max_subarray_sum_with_indices([1, 2, 3, -2, 5]) == (9, 1, 5) assert max_subarray_sum_with_indices([4, -1, -2, 1, 5]) == (7, 1, 5) assert max_subarray_sum_with_indices([1, -2, 3, 4, -1, 2, 1, -5, 4]) == (9, 3, 7) test_max_subarray_sum_with_indices()","solution":"def max_subarray_sum_with_indices(nums): Returns the maximum sum of a contiguous subarray and its starting and ending indices (1-based). max_sum = float('-inf') current_sum = 0 start = 0 end = 0 temp_start = 0 for i in range(len(nums)): if current_sum <= 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if (current_sum > max_sum or (current_sum == max_sum and temp_start < start) or (current_sum == max_sum and temp_start == start and i < end)): max_sum = current_sum start = temp_start end = i return max_sum, start + 1, end + 1"},{"question":"def min_subarray_len(arr, T): Finds the minimum length of a contiguous subarray with a sum at least T. Parameters: arr (list of int): Array of positive integers. T (int): Target sum. Returns: int: Minimum length of the subarray, or 0 if no such subarray exists. >>> min_subarray_len([2, 3, 1, 2, 4, 3, 7, 2], 7) 1 >>> min_subarray_len([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_len([1, 2, 3, 4, 5, 6, 7], 100) 0 >>> min_subarray_len([1, 1, 1, 1, 1], 10) 0 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([10], 10) 1 >>> min_subarray_len([1, 4, 4, 3], 8) 2","solution":"def min_subarray_len(arr, T): Finds the minimum length of a contiguous subarray with a sum at least T. Parameters: arr (list of int): Array of positive integers. T (int): Target sum. Returns: int: Minimum length of the subarray, or 0 if no such subarray exists. n = len(arr) min_len = float('inf') left = 0 current_sum = 0 for right in range(n): current_sum += arr[right] while current_sum >= T: min_len = min(min_len, right - left + 1) current_sum -= arr[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"def max_product_of_two(nums): Returns the maximum product of any two elements in the array nums. >>> max_product_of_two([3, 4, 5, 2]) 20 >>> max_product_of_two([1, 5, 3, 2, 4]) 20 >>> max_product_of_two([1, 1, 1, 1]) 1 >>> max_product_of_two([9]) 0 >>> max_product_of_two([]) 0 >>> max_product_of_two([0, 10, 0, 0]) 0 >>> max_product_of_two([0, 10, 5, 2]) 50 >>> max_product_of_two([5, 6, 7, 8, 9]) 72","solution":"def max_product_of_two(nums): Returns the maximum product of any two elements in the array nums. if len(nums) < 2: return 0 # Not enough elements to form a pair first_max = second_max = float('-inf') for num in nums: if num > first_max: second_max = first_max first_max = num elif num > second_max: second_max = num return first_max * second_max"},{"question":"def maxCircularSubarraySum(nums): Determine the maximum sum of a subarray in a circular array of integers. >>> maxCircularSubarraySum([1, -2, 3, -2]) 3 >>> maxCircularSubarraySum([5, -3, 5]) 10 >>> maxCircularSubarraySum([10]) 10 >>> maxCircularSubarraySum([-10]) -10 >>> maxCircularSubarraySum([1, 2, 3, 4, 5]) 15 >>> maxCircularSubarraySum([-1, -2, -3, -4, -5]) -1 >>> maxCircularSubarraySum([2, -7, 3, 8, -2, -1, 4, 5, -5]) 17 >>> maxCircularSubarraySum([8, -8, 9, -9, 10, -11, 12]) 22 >>> maxCircularSubarraySum([10000] * 30000) 300000000 >>> maxCircularSubarraySum([-10000] * 30000) -10000","solution":"def maxCircularSubarraySum(nums): def kadane(nums): max_ending_here = max_so_far = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Special Case when all numbers are negative max_kadane = kadane(nums) if max_kadane < 0: return max_kadane # Sum of the array total_sum = sum(nums) # Inverting sign of the elements for i in range(len(nums)): nums[i] = -nums[i] # Kadane's algorithm on inverted array max_inverted_kadane = kadane(nums) # The case where the circular subarray sum is considered max_circular = total_sum + max_inverted_kadane return max(max_kadane, max_circular)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): Given a binary tree, return the number of paths where the sum of the node values along the path equals a given target sum. Example 1: >>> root = build_tree([10,5,-3,3,2,None,11,3,-2,None,1]) >>> targetSum = 8 >>> pathSum(root, targetSum) 3 Example 2: >>> root = build_tree([1,None,2,None,3,None,4,None,5]) >>> targetSum = 3 >>> pathSum(root, targetSum) 2 def test_example_1(): root = build_tree([10,5,-3,3,2,None,11,3,-2,None,1]) targetSum = 8 assert pathSum(root, targetSum) == 3 def test_example_2(): root = build_tree([1, None, 2, None, 3, None, 4, None, 5]) targetSum = 3 assert pathSum(root, targetSum) == 2 def test_single_node(): root = build_tree([1]) targetSum = 1 assert pathSum(root, targetSum) == 1 def test_empty_tree(): root = build_tree([]) targetSum = 1 assert pathSum(root, targetSum) == 0 def test_no_path(): root = build_tree([1, 2, 3]) targetSum = 5 assert pathSum(root, targetSum) == 0 def test_multiple_paths(): root = build_tree([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, 5, 1]) targetSum = 22 assert pathSum(root, targetSum) == 3 # Helper function to build a tree from a list def build_tree(values): if not values: return None nodes = [None if value is None else TreeNode(value) for value in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): def dfs(node, curr_path): if not node: return 0 # Add current node's value to the path curr_path.append(node.val) path_count, path_sum = 0, 0 # Check if there are any paths that sum to targetSum for val in reversed(curr_path): path_sum += val if path_sum == targetSum: path_count += 1 # Traverse left and right subtrees path_count += dfs(node.left, curr_path) path_count += dfs(node.right, curr_path) # Remove current node's value from the path curr_path.pop() return path_count return dfs(root, []) # Helper function to build a tree from a list def build_tree(values): if not values: return None nodes = [None if value is None else TreeNode(value) for value in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root"},{"question":"from typing import List def average_score(scores: List[int]) -> float: Calculate the average score after dropping the two lowest scores. If there are fewer than three students, return 0. >>> average_score([50, 80, 90, 20, 70]) 80.0 >>> average_score([100, 40, 60]) 100.0 >>> average_score([90, 70]) 0.0 >>> average_score([]) 0.0","solution":"from typing import List def average_score(scores: List[int]) -> float: if len(scores) < 3: return 0.0 sorted_scores = sorted(scores) trimmed_scores = sorted_scores[2:] average = sum(trimmed_scores) / len(trimmed_scores) return round(average, 2)"},{"question":"def determine_winner(t: int, test_cases: List[Tuple[int, int]]) -> List[str]: Determines the winner of the game given the size of the grid for each test case. :param t: Number of test cases. :param test_cases: List of tuples, each containing two integers n and m representing the grid dimensions. :return: List of strings \\"Player 1\\" or \\"Player 2\\" for each test case outcome. >>> determine_winner(1, [(2, 2)]) ['Player 2'] >>> determine_winner(1, [(3, 3)]) ['Player 1'] >>> determine_winner(3, [(2, 2), (3, 3), (4, 5)]) ['Player 2', 'Player 1', 'Player 1']","solution":"def determine_winner(t, test_cases): Determines the winner of the game for each test case. Args: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers n and m representing the grid dimensions. Returns: list of str: \\"Player 1\\" or \\"Player 2\\" for each test case. results = [] for n, m in test_cases: if (n % 2 == 1) or (m % 2 == 1): results.append(\\"Player 1\\") else: results.append(\\"Player 2\\") return results"},{"question":"def min_operations_to_turn_off(s: str) -> int: Determine the minimum number of operations required to turn all the machines OFF. If a machine is ON ('1'), it can switch itself and an adjacent machine OFF. >>> min_operations_to_turn_off(\\"1101\\") 2 >>> min_operations_to_turn_off(\\"0000\\") 0","solution":"def min_operations_to_turn_off(s): Returns the minimum number of operations required to turn all the machines OFF. :param s: A string representing the initial state of the machines. :return: The minimum number of operations to turn all machines OFF. operations = 0 i = len(s) - 1 while i >= 0: if s[i] == '1': operations += 1 i -= 2 else: i -= 1 return operations"},{"question":"def infix_to_postfix(expression: str) -> str: Convert an infix expression to a postfix expression using the Shunting Yard algorithm. >>> infix_to_postfix(\\"3+4*2/(1-5)^2^3\\") \\"342*15-23^^/+\\" >>> infix_to_postfix(\\"(3+4)*5\\") \\"34+5*\\" def convert_expressions_to_postfix(num_cases: int, expressions: List[str]) -> List[str]: Convert multiple infix expressions to postfix notation. >>> convert_expressions_to_postfix(1, [\\"3+4*2/(1-5)^2^3\\"]) [\\"342*15-23^^/+\\"] >>> convert_expressions_to_postfix(2, [\\"3+4*2/(1-5)^2^3\\", \\"3+5*6\\"]) [\\"342*15-23^^/+\\", \\"356*+\\"]","solution":"def infix_to_postfix(expression): Convert an infix expression to a postfix expression using the Shunting Yard algorithm. def get_precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 if op == '^': return 3 return 0 def is_left_associative(op): return op in ('+', '-', '*', '/') output = [] operators = [] for char in expression: if char.isdigit(): output.append(char) elif char in ('+', '-', '*', '/', '^'): while (operators and operators[-1] != '(' and (get_precedence(operators[-1]) > get_precedence(char) or (get_precedence(operators[-1]) == get_precedence(char) and is_left_associative(char)))): output.append(operators.pop()) operators.append(char) elif char == '(': operators.append(char) elif char == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() # pop the '(' while operators: output.append(operators.pop()) return ''.join(output) def convert_expressions_to_postfix(num_cases, expressions): result = [] for expression in expressions: result.append(infix_to_postfix(expression)) return result"},{"question":"def count_partitions(n: int) -> int: Determine the number of distinct ways to partition 'n' as a sum of positive integers where the order of the summands does not matter. >>> count_partitions(4) 5 >>> count_partitions(7) 15 >>> count_partitions(1) 1 >>> count_partitions(2) 2 >>> count_partitions(5) 7 >>> count_partitions(10) 42","solution":"def count_partitions(n): # Initialize a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(n + 1)] # There is one way to partition 0 for i in range(n + 1): dp[i][0] = 1 # Fill the table in bottom-up manner for i in range(1, n + 1): for j in range(1, n + 1): if i <= j: dp[i][j] = dp[i - 1][j] + dp[i][j - i] else: dp[i][j] = dp[i - 1][j] return dp[n][n]"},{"question":"def sum_even_numbers(N: int) -> int: Computes the sum of all even numbers from 1 to N inclusive. >>> sum_even_numbers(10) 30 >>> sum_even_numbers(1) 0 >>> sum_even_numbers(2) 2 >>> sum_even_numbers(11) 30 >>> sum_even_numbers(1000000) 250000500000 >>> sum_even_numbers(1000001) 250000500000","solution":"def sum_even_numbers(N): Returns the sum of all even numbers from 1 to N inclusive. sum_even = 0 for i in range(2, N + 1, 2): sum_even += i return sum_even"},{"question":"def find_stone_position(k: int) -> Tuple[int, int]: Given the overall position k, determine the stone's row number and position within that row. >>> find_stone_position(5) (3, 2) >>> find_stone_position(10) (4, 4) >>> find_stone_position(12) (5, 2) pass def process_test_cases(test_cases: List[int]) -> List[Tuple[int, int]]: Process multiple test cases to determine the stone positions. >>> process_test_cases([5, 10, 12]) [(3, 2), (4, 4), (5, 2)] >>> process_test_cases([1, 3, 6, 7]) [(1, 1), (2, 2), (3, 3), (4, 1)] pass","solution":"def find_stone_position(k): Given the overall position k, determine the stone's row number and position within that row. row = 1 while k > row: k -= row row += 1 return row, k def process_test_cases(test_cases): results = [] for case in test_cases: results.append(find_stone_position(case)) return results"},{"question":"def max_average_difficulty(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Find the maximum possible average difficulty Alice can achieve with an optimal subsequence. >>> max_average_difficulty(1, [(1, [4])]) ['4.00'] >>> max_average_difficulty(1, [(4, [3, 1, 2, 3])]) ['3.00'] >>> max_average_difficulty(1, [(5, [4, 5, 1, 2, 3])]) ['5.00'] from solution import max_average_difficulty def test_single_problem(): assert max_average_difficulty(1, [(1, [4])]) == [\\"4.00\\"] def test_multiple_problems(): assert max_average_difficulty(1, [(4, [3, 1, 2, 3])]) == [\\"3.00\\"] assert max_average_difficulty(1, [(5, [4, 5, 1, 2, 3])]) == [\\"5.00\\"] def test_multiple_test_cases(): test_cases = [ (4, [3, 1, 2, 3]), (5, [4, 5, 1, 2, 3]) ] assert max_average_difficulty(2, test_cases) == [\\"3.00\\", \\"5.00\\"] def test_max_difficulty_edge_case(): assert max_average_difficulty(1, [(5, [100, 100, 100, 100, 100])]) == [\\"100.00\\"] def test_min_difficulty_edge_case(): assert max_average_difficulty(1, [(5, [1, 1, 1, 1, 1])]) == [\\"1.00\\"]","solution":"def max_average_difficulty(t, test_cases): results = [] for test_case in test_cases: n, difficulties = test_case max_difficulty = max(difficulties) results.append(f\\"{max_difficulty:.2f}\\") return results"},{"question":"def smallest_positive_integer(cannot_sum_lists): Function to find the smallest positive integer that cannot be represented as a sum of any subset of a given list of integers. Parameters: cannot_sum_lists (List[List[int]]): List of lists of integers. Returns: List[int]: List of smallest positive integers that cannot be represented as a sum of any subset of the given lists. Examples: >>> process_input(\\"2n1 2 3n1 2 2 7n\\") >>> cannot_sum_lists = process_input(input_string) >>> smallest_positive_integer(cannot_sum_lists) [7, 6] pass def process_input(input_string): This function processes the input string and returns the parsed input needed for the solution function. Parameters: input_string (str): The input string containing the number of test cases followed by lists of integers. Returns: List[List[int]]: Parsed input as a list of lists of integers. Examples: >>> process_input(\\"2n1 2 3n1 2 2 7n\\") [[1, 2, 3], [1, 2, 2, 7]] pass def test_example_cases(): input_string = \\"2n1 2 3n1 2 2 7n\\" cannot_sum_lists = process_input(input_string) result = smallest_positive_integer(cannot_sum_lists) assert result == [7, 6] def test_single_element(): input_string = \\"1n5n\\" cannot_sum_lists = process_input(input_string) result = smallest_positive_integer(cannot_sum_lists) assert result == [1] def test_all_same_elements(): input_string = \\"1n3 3 3n\\" cannot_sum_lists = process_input(input_string) result = smallest_positive_integer(cannot_sum_lists) assert result == [1] def test_missing_number_with_large_elements(): input_string = \\"1n3 5 6 8n\\" cannot_sum_lists = process_input(input_string) result = smallest_positive_integer(cannot_sum_lists) assert result == [1] def test_consecutive_numbers(): input_string = \\"1n1 2 3 4 5 6 7 8 9 10n\\" cannot_sum_lists = process_input(input_string) result = smallest_positive_integer(cannot_sum_lists) assert result == [56] def test_mixed_numbers(): input_string = \\"1n2 1 3 12 4 11n\\" cannot_sum_lists = process_input(input_string) result = smallest_positive_integer(cannot_sum_lists) assert result == [34] def test_large_input(): import random random_list = [random.randint(1, 10**6) for _ in range(10**5)] input_string = f\\"1n{' '.join(map(str, random_list))}n\\" cannot_sum_lists = process_input(input_string) result = smallest_positive_integer(cannot_sum_lists) assert isinstance(result[0], int) assert result[0] > 0","solution":"def smallest_positive_integer(cannot_sum_lists): This function takes a list of lists of integers and returns a list of smallest positive integers that cannot be represented as a sum of any subset of the given lists. results = [] for nums in cannot_sum_lists: nums.sort() smallest = 1 for num in nums: if num > smallest: break smallest += num results.append(smallest) return results def process_input(input_string): This function processes the input string and returns the parsed input needed for the solution function. lines = input_string.strip().split(\\"n\\") T = int(lines[0].strip()) cannot_sum_lists = [] for i in range(1, T + 1): cannot_sum_lists.append(list(map(int, lines[i].strip().split()))) return cannot_sum_lists"},{"question":"def primes(n): Write a function that takes a positive integer \`n\` and returns a list of all prime numbers less than \`n\`, excluding \`n\` itself. >>> primes(10) [2, 3, 5, 7] >>> primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes(2) [] >>> primes(1) []","solution":"def primes(n): Returns a list of all prime numbers less than n. if n < 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for i in range(start*start, n, start): sieve[i] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"from typing import List def min_travel_time(grid: List[List[int]]) -> int: Find the minimum time required for the agent to reach the exit from the entrance. Args: grid (List[List[int]]): 2D list representing the grid with time to bypass the security mechanism. Returns: int: Minimum time required to reach the exit. Examples: >>> min_travel_time([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_travel_time([ ... [1, 2, 5], ... [3, 2, 1] ... ]) 6","solution":"from typing import List def min_travel_time(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize DP table with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"def find_midpoints(n: int, edges: List[Tuple[int, int]], s: int, t: int) -> int: Help Luke find the number of possible midpoint caves along the shortest path from \`s\` to \`t\`. Parameters: n (int): The number of caves. edges (List[Tuple[int, int]]): The passages between caves. s (int): The starting cave. t (int): The ending cave. Returns: int: The number of possible midpoints along the shortest path from \`s\` to \`t\`. Examples: test_find_midpoints_example_1(): n = 6 edges = [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)] s = 1 t = 5 find_midpoints(n, edges, s, t) = 4 test_find_midpoints_small_graph(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] s = 1 t = 4 find_midpoints(n, edges, s, t) = 4 test_find_midpoints_same_point(): n = 3 edges = [(1, 2), (2, 3)] s = 1 t = 3 find_midpoints(n, edges, s, t) = 3 test_find_midpoints_large_graph(): n = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] s = 4 t = 7 find_midpoints(n, edges, s, t) = 5","solution":"def find_midpoints(n, edges, s, t): from collections import defaultdict, deque # Create adjacency list for the graph graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) # BFS to find the shortest path def bfs(start, end): queue = deque([(start, [start])]) visited = set() while queue: node, path = queue.popleft() if node == end: return path if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] shortest_path = bfs(s, t) return len(shortest_path) # Example input n = 6 edges = [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)] s = 1 t = 5 print(find_midpoints(n, edges, s, t))"},{"question":"import math from typing import List def next_power_of_two(n: int) -> int: Returns the smallest power of two greater than or equal to n. >>> next_power_of_two(5) 8 >>> next_power_of_two(15) 16 def solve(test_cases: List[int]) -> List[int]: Given a list of numbers, returns the smallest power of two greater than or equal to each number. >>> solve([5, 15, 20]) [8, 16, 32] >>> solve([1, 2, 64, 70]) [1, 2, 64, 128]","solution":"import math def next_power_of_two(n): Returns the smallest power of two greater than or equal to n. if n <= 0: return 1 power = math.ceil(math.log2(n)) return 2 ** power def solve(test_cases): Given a list of numbers, returns the smallest power of two greater than or equal to each number. results = [] for x in test_cases: results.append(next_power_of_two(x)) return results"},{"question":"from math import factorial from collections import Counter def unique_permutations_count(s: str) -> int: Returns the number of unique permutations of the string s. >>> unique_permutations_count(\\"abc\\") 6 >>> unique_permutations_count(\\"aab\\") 3 pass def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results for each test case. >>> process_test_cases([\\"abc\\", \\"aab\\"]) [6, 3] pass","solution":"from math import factorial from collections import Counter def unique_permutations_count(s): Returns the number of unique permutations of the string s. char_count = Counter(s) denominator = 1 for count in char_count.values(): denominator *= factorial(count) return factorial(len(s)) // denominator def process_test_cases(test_cases): results = [] for s in test_cases: results.append(unique_permutations_count(s)) return results # Gathering Input def gather_input(): T = int(input()) test_cases = [] for _ in range(T): test_cases.append(input()) return T, test_cases # Gathering Output def output_results(results): for result in results: print(result) if __name__ == \\"__main__\\": T, test_cases = gather_input() results = process_test_cases(test_cases) output_results(results)"},{"question":"class FileManager: Create a file management system that supports CREATE, DELETE, RENAME, and LIST commands to manage filenames. Methods: - create(filename: str) -> None - delete(filename: str) -> None - rename(old_filename: str, new_filename: str) -> None - list_files() -> List[str] >>> fm = FileManager() >>> fm.create(\\"file1\\") >>> fm.create(\\"file2\\") >>> fm.rename(\\"file1\\", \\"file3\\") >>> print(fm.list_files()) [\\"file2\\", \\"file3\\"] >>> fm.delete(\\"file2\\") >>> print(fm.list_files()) [\\"file3\\"] >>> fm.create(\\"file2\\") >>> print(fm.list_files()) [\\"file2\\", \\"file3\\"] def __init__(self): self.files = set() def create(self, filename: str) -> None: pass def delete(self, filename: str) -> None: pass def rename(self, old_filename: str, new_filename: str) -> None: pass def list_files(self) -> list: pass def test_create_file(): fm = FileManager() fm.create(\\"file1\\") assert fm.list_files() == [\\"file1\\"] def test_create_file_already_exists(): fm = FileManager() fm.create(\\"file1\\") fm.create(\\"file1\\") assert fm.list_files() == [\\"file1\\"] def test_delete_file(): fm = FileManager() fm.create(\\"file1\\") fm.delete(\\"file1\\") assert fm.list_files() == [] def test_delete_nonexistent_file(): fm = FileManager() fm.delete(\\"file1\\") # file1 does not exist assert fm.list_files() == [] def test_rename_file(): fm = FileManager() fm.create(\\"file1\\") fm.rename(\\"file1\\", \\"file2\\") assert fm.list_files() == [\\"file2\\"] def test_rename_nonexistent_file(): fm = FileManager() fm.rename(\\"file1\\", \\"file2\\") # file1 does not exist assert fm.list_files() == [] def test_rename_to_existing_filename(): fm = FileManager() fm.create(\\"file1\\") fm.create(\\"file2\\") fm.rename(\\"file1\\", \\"file2\\") # file2 already exists assert fm.list_files() == [\\"file1\\", \\"file2\\"] def test_list_files(): fm = FileManager() fm.create(\\"file1\\") fm.create(\\"file3\\") fm.create(\\"file2\\") assert fm.list_files() == [\\"file1\\", \\"file2\\", \\"file3\\"] def test_complex_operations(): fm = FileManager() fm.create(\\"file1\\") fm.create(\\"file2\\") fm.rename(\\"file1\\", \\"file3\\") assert fm.list_files() == [\\"file2\\", \\"file3\\"] fm.delete(\\"file2\\") assert fm.list_files() == [\\"file3\\"] fm.create(\\"file2\\") assert fm.list_files() == [\\"file2\\", \\"file3\\"]","solution":"class FileManager: def __init__(self): self.files = set() def create(self, filename: str) -> None: if filename not in self.files: self.files.add(filename) def delete(self, filename: str) -> None: if filename in self.files: self.files.remove(filename) def rename(self, old_filename: str, new_filename: str) -> None: if old_filename in self.files and new_filename not in self.files: self.files.remove(old_filename) self.files.add(new_filename) def list_files(self) -> list: return sorted(self.files)"},{"question":"def find_missing_identifier(n: int, identifiers: list[int]) -> int: Determines the missing picture identifier from a list of given identifiers. :param n: The total number of pictures initially labeled (integer) :param identifiers: List of remaining picture identifiers (list of integers) :return: The missing picture's identifier (integer) >>> find_missing_identifier(5, [1, 2, 4, 5]) 3 >>> find_missing_identifier(3, [2, 3]) 1 >>> find_missing_identifier(4, [1, 4, 2]) 3","solution":"def find_missing_identifier(n, identifiers): Determines the missing picture identifier from a list of given identifiers. :param n: The total number of pictures initially labeled (integer) :param identifiers: List of remaining picture identifiers (list of integers) :return: The missing picture's identifier (integer) # Calculate the expected sum of first n natural numbers total_sum = n * (n + 1) // 2 # Calculate the sum of provided identifiers current_sum = sum(identifiers) # The missing identifier is the difference missing_id = total_sum - current_sum return missing_id"},{"question":"def canRearrange(S: str) -> int: Determine if the string S can be rearranged so that no two identical characters are adjacent. :param S: Input string of lowercase alphabets :return: 1 if it can be rearranged, otherwise 0 >>> canRearrange(\\"aab\\") 1 >>> canRearrange(\\"aaab\\") 0","solution":"import heapq from collections import Counter def canRearrange(S): Determine if the string S can be rearranged so that no two identical characters are adjacent. :param S: Input string :return: 1 if it can be rearranged, otherwise 0 # Count the frequency of each character freq = Counter(S) # Create a max heap based on character frequencies max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] # Process the heap to rearrange the characters while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # If the previous character still has remaining count, push it back to the heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update the previous character with the current one prev_count, prev_char = count + 1, char # Check if the rearranged string's length matches the original string's length return 1 if len(result) == len(S) else 0"},{"question":"def find_peak_element(nums): Finds a peak element and returns its index. A peak element is an element that is strictly greater than its neighbors. The algorithm runs in O(log n) time using binary search. >>> find_peak_element([1, 2, 3, 1, 0]) 2 >>> find_peak_element([5, 4, 3]) 0 >>> find_peak_element([1, 3, 2, 4]) 1 or 3 >>> find_peak_element([1, 2, 3, 4, 5]) 4 >>> find_peak_element([1]) 0 >>> find_peak_element([1, 2]) 1 >>> find_peak_element([i for i in range(100000)]) 99999","solution":"def find_peak_element(nums): Finds a peak element and returns its index. A peak element is an element that is strictly greater than its neighbors. The algorithm runs in O(log n) time using binary search. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def longest_positive_sum_subarray(t, test_cases): Find the length of the longest subarray with a positive sum for each test case. Args: t (int): number of test cases test_cases (List[Tuple[int, List[int]]]): The list of test cases, where each test case is a tuple containing the number of days and the list of profits/losses. Returns: List[int]: List of integers where each integer represents the length of the longest subarray with a positive sum for the corresponding test case. Test Cases: >>> longest_positive_sum_subarray(2, [ (8, [-1, 2, 3, -5, 4, 6, -1, 2]), (5, [-3, -2, -1, -4, -5]) ]) [4, 0] >>> longest_positive_sum_subarray(1, [ (5, [1, 2, 3, 4, 5]) ]) [5] >>> longest_positive_sum_subarray(1, [ (5, [-1, -2, -3, -4, -5]) ]) [0] >>> longest_positive_sum_subarray(1, [ (6, [-1, 2, -3, 4, -5, 6]) ]) [1] >>> longest_positive_sum_subarray(1, [ (1, [1]) ]) [1] >>> longest_positive_sum_subarray(1, [ (1, [-1]) ]) [0]","solution":"def longest_positive_sum_subarray(t, test_cases): Function to determine the length of the longest subarray with a positive sum for each test case. results = [] for i in range(t): n, a = test_cases[i] max_len = 0 current_len = 0 current_sum = 0 for num in a: if current_sum + num > 0: current_sum += num current_len += 1 max_len = max(max_len, current_len) else: current_sum, current_len = 0, 0 results.append(max_len) return results"},{"question":"def reverseArray(arr): Returns a new array that is the reverse of the input array. Parameters: arr (list of int): The array to be reversed. Returns: list of int: The reversed array. >>> reverseArray([1, 2, 3, 4]) [4, 3, 2, 1] >>> reverseArray([10, 20, 30, 40]) [40, 30, 20, 10] >>> reverseArray([]) [] >>> reverseArray([5]) [5]","solution":"def reverseArray(arr): Returns a new array that is the reverse of the input array. Parameters: arr (list of int): The array to be reversed. Returns: list of int: The reversed array. return arr[::-1]"},{"question":"def get_skyline(buildings): Determine the skyline formed by the given buildings. :param buildings: List of triplets (L, R, H) where L is the left coordinate, R is the right coordinate, and H is the height of the building. :return: List of tuples representing the key points in the skyline. pass from solution import get_skyline def test_single_building(): buildings = [(1, 5, 11)] assert get_skyline(buildings) == [(1, 11), (5, 0)] def test_two_overlapping_buildings(): buildings = [(1, 5, 11), (2, 6, 7)] assert get_skyline(buildings) == [(1, 11), (5, 7), (6, 0)] def test_multiple_overlapping_buildings(): buildings = [(2, 9, 10), (3, 7, 15), (5, 12, 12)] assert get_skyline(buildings) == [(2, 10), (3, 15), (7, 12), (12, 0)] def test_adjacent_buildings(): buildings = [(1, 3, 3), (3, 6, 4)] assert get_skyline(buildings) == [(1, 3), (3, 4), (6, 0)] def test_separated_buildings(): buildings = [(1, 2, 1), (3, 4, 1)] assert get_skyline(buildings) == [(1, 1), (2, 0), (3, 1), (4, 0)]","solution":"from heapq import heappush, heappop def get_skyline(buildings): Determine the skyline formed by the given buildings. :param buildings: List of triplets (L, R, H) where L is the left coordinate, R is the right coordinate, and H is the height of the building. :return: List of tuples representing the key points in the skyline. events = [] # Events are critical points where buildings start or end for L, R, H in buildings: events.append((L, -H, R)) # Building starts events.append((R, 0, 0)) # Building ends events.sort() # Events are sorted by the x coordinate result = [] max_heap = [(0, float(\\"inf\\"))] # Starting with the base ground (y=0) for x, negH, R in events: while max_heap[0][1] <= x: # Remove the past buildings from heap heappop(max_heap) if negH: # if building starts add to heap heappush(max_heap, (negH, R)) max_current_height = -max_heap[0][0] if not result or result[-1][1] != max_current_height: result.append((x, max_current_height)) return result"},{"question":"def minLadders(N: int, arr: List[int], K: int) -> int: Determine the minimum number of ladders needed to climb all buildings given their heights. >>> minLadders(5, [1, 5, 2, 6, 4], 2) 2 >>> minLadders(4, [1, 2, 3, 4], 2) 2","solution":"def minLadders(N, arr, K): import heapq if N == 1: return 0 # Max-Heap to store the largest jumps where we used ladders used_ladders = [] ladder_count = 0 for i in range(N - 1): if arr[i] < arr[i + 1]: # Calculate the jump jump = arr[i + 1] - arr[i] # Always use ladder heapq.heappush(used_ladders, -jump) ladder_count += 1 if ladder_count > K: # We have used more ladders than allowed # Remove the largest ladder used and climb down largest_jump = -heapq.heappop(used_ladders) ladder_count -= 1 return ladder_count"},{"question":"def pair_exists(arr, target_sum): Determines if there exists a pair of elements in the array such that their sum is equal to the given target_sum. Parameters: arr (List[int]): List of integers. target_sum (int): The target sum we want to find. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". >>> pair_exists([1, 2, 3, 9, 5], 8) \\"Yes\\" >>> pair_exists([1, 2, 3, 9, 5], 20) \\"No\\" >>> pair_exists([-1, -2, 3, 6, 4], 2) \\"Yes\\" >>> pair_exists([0, 0, 0, 0], 0) \\"Yes\\" >>> pair_exists([0, 1, 2, 3], 0) \\"No\\" >>> pair_exists([100000, -50000, 40000, 30000, -20000], 50000) \\"Yes\\" >>> pair_exists([5], 10) \\"No\\" >>> pair_exists([], 10) \\"No\\"","solution":"def pair_exists(arr, target_sum): Determines if there exists a pair of elements in the array such that their sum is equal to the given target_sum. Parameters: arr (List[int]): List of integers. target_sum (int): The target sum we want to find. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". seen = set() for num in arr: if target_sum - num in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"from functools import cmp_to_key from typing import List def largest_concatenated_integer(numbers: List[int]) -> str: Reorder integers such that their concatenation forms the largest possible integer. Parameters: numbers (List[int]): List of integers. Returns: String: The largest possible integer as a string. Examples: >>> largest_concatenated_integer([54, 546, 548]) '54854654' >>> largest_concatenated_integer([3, 30, 34, 5]) '534330' >>> largest_concatenated_integer([0, 0, 0]) '0'","solution":"from functools import cmp_to_key def largest_concatenated_integer(numbers): Reorder integers such that their concatenation forms the largest possible integer. Parameters: numbers (List[int]): List of integers. Returns: String: The largest possible integer as a string. def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all integers to strings for easy comparison str_numbers = list(map(str, numbers)) # Sort array in descending order based on custom comparator sorted_numbers = sorted(str_numbers, key=cmp_to_key(compare)) # Join the sorted array into a single string largest_number = ''.join(sorted_numbers) # Return the result but ensure we remove leading zeros (if any) return largest_number.lstrip('0') or '0'"},{"question":"class BinaryTree: Class implementing a Binary Tree to process various queries. Methods: insert(x): Inserts integer x into the binary tree. delete(x): Deletes integer x from the binary tree if present. search(x): Returns \\"YES\\" if integer x is present in the tree, \\"NO\\" otherwise. minimum(): Returns the minimum integer present in the tree, -1 if tree is empty. maximum(): Returns the maximum integer present in the tree, -1 if tree is empty. def __init__(self): self.tree = set() def insert(self, x): pass def delete(self, x): pass def search(self, x): pass def minimum(self): pass def maximum(self): pass def process_queries(queries): bt = BinaryTree() result = [] for query in queries: parts = query.split() command = int(parts[0]) if command == 1: bt.insert(int(parts[1])) elif command == 2: bt.delete(int(parts[1])) elif command == 3: result.append(bt.search(int(parts[1]))) elif command == 4: result.append(bt.minimum()) elif command == 5: result.append(bt.maximum()) return result # Below are the sample test cases for the \`process_queries\` function def test_process_queries(): queries1 = [ \\"1 10\\", \\"1 20\\", \\"3 10\\", \\"4\\", \\"5\\", \\"2 10\\", \\"3 10\\", \\"4\\" ] expected_output1 = [\\"YES\\", 10, 20, \\"NO\\", 20] assert process_queries(queries1) == expected_output1 queries2 = [ \\"1 30\\", \\"1 40\\", \\"1 50\\", \\"5\\", \\"4\\", \\"2 40\\", \\"5\\", \\"4\\" ] expected_output2 = [50, 30, 50, 30] assert process_queries(queries2) == expected_output2 queries3 = [ \\"3 100\\", \\"4\\", \\"5\\" ] expected_output3 = [\\"NO\\", -1, -1] assert process_queries(queries3) == expected_output3 queries4 = [ \\"1 15\\", \\"2 15\\", \\"3 15\\" ] expected_output4 = [\\"NO\\"] assert process_queries(queries4) == expected_output4 def test_binary_tree(): bt = BinaryTree() bt.insert(10) bt.insert(20) assert bt.search(10) == \\"YES\\" assert bt.search(30) == \\"NO\\" assert bt.minimum() == 10 assert bt.maximum() == 20 bt.delete(10) assert bt.search(10) == \\"NO\\" assert bt.minimum() == 20 bt.delete(20) assert bt.maximum() == -1 assert bt.minimum() == -1","solution":"class BinaryTree: def __init__(self): self.tree = set() def insert(self, x): self.tree.add(x) def delete(self, x): self.tree.discard(x) def search(self, x): return \\"YES\\" if x in self.tree else \\"NO\\" def minimum(self): return min(self.tree) if self.tree else -1 def maximum(self): return max(self.tree) if self.tree else -1 def process_queries(queries): bt = BinaryTree() result = [] for query in queries: parts = query.split() command = int(parts[0]) if command == 1: bt.insert(int(parts[1])) elif command == 2: bt.delete(int(parts[1])) elif command == 3: result.append(bt.search(int(parts[1]))) elif command == 4: result.append(bt.minimum()) elif command == 5: result.append(bt.maximum()) return result"},{"question":"def maximum_product(arr): Finds the maximum product of any three distinct integers in the array. >>> maximum_product([1, 10, 2, 6, 5, 3]) 300 >>> maximum_product([0, 0, 1, 2, 3]) 6 >>> maximum_product([1, 1, 1, 1, 1, 1]) 1 >>> maximum_product([1000, 999, 998, 997]) 1000*999*998 >>> maximum_product([-10, -10, 5, 2]) 500","solution":"def maximum_product(arr): Returns the maximum product of any three distinct integers in the array. arr.sort() # Maximum product can either be the product of the three largest numbers # or the product of the two smallest (negative numbers can turn positive) and the largest number. return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"def count_a_in_infinite_string(s, n): Calculate the number of occurrences of the character \\"a\\" in the first n characters of the infinite string formed by repeating string s. >>> count_a_in_infinite_string(\\"abcac\\", 10) 4 >>> count_a_in_infinite_string(\\"a\\", 1000000000000) 1000000000000 >>> count_a_in_infinite_string(\\"b\\", 1000000000000) 0 >>> count_a_in_infinite_string(\\"bcdef\\", 10) 0 >>> count_a_in_infinite_string(\\"abcabcabca\\", 50) 20 >>> count_a_in_infinite_string(\\"a\\", 1) 1 >>> count_a_in_infinite_string(\\"b\\", 1) 0 >>> count_a_in_infinite_string(\\"a\\", 0) 0 >>> count_a_in_infinite_string(\\"ab\\", 1000000000000) 500000000000 >>> count_a_in_infinite_string(\\"abcd\\", 7) 2 >>> count_a_in_infinite_string(\\"aaaaa\\", 7) 7","solution":"def count_a_in_infinite_string(s, n): Calculate the number of occurrences of the character \\"a\\" in the first n characters of the infinite string formed by repeating string s. # Calculate the number of 'a' in the given string count_in_s = s.count('a') length_of_s = len(s) # Determine how many times the string s repeats in the first n characters full_repeats = n // length_of_s # Determine the remaining characters remaining_chars = n % length_of_s # Calculate total 'a's in the full repeats total_count = full_repeats * count_in_s # Add the 'a's in the remaining part total_count += s[:remaining_chars].count('a') return total_count"},{"question":"def longest_consecutive_sequence(binary_strings): Returns the longest consecutive sequence of identical binary strings and its length. >>> longest_consecutive_sequence([\\"110\\", \\"110\\", \\"001\\", \\"001\\", \\"001\\", \\"101\\", \\"101\\", \\"101\\", \\"101\\"]) (\\"101\\", 4) >>> longest_consecutive_sequence([\\"000\\", \\"000\\", \\"111\\", \\"111\\", \\"111\\", \\"000\\", \\"000\\"]) (\\"111\\", 3)","solution":"def longest_consecutive_sequence(binary_strings): Returns the longest consecutive sequence of identical binary strings and its length. if not binary_strings: return None, 0 max_string = binary_strings[0] max_length = 1 current_string = binary_strings[0] current_length = 1 for i in range(1, len(binary_strings)): if binary_strings[i] == current_string: current_length += 1 else: if current_length > max_length: max_string = current_string max_length = current_length current_string = binary_strings[i] current_length = 1 if current_length > max_length: max_string = current_string max_length = current_length return max_string, max_length"},{"question":"def count_standout_athletes(scores): Counts the number of standout athletes in the given list of scores. An athlete is considered a standout athlete if their score is strictly greater than the average score of all athletes. :param scores: List of integers representing the scores of athletes. :return: Integer count of standout athletes. Examples: >>> count_standout_athletes([10, 15, 20, 25, 30]) 2 >>> count_standout_athletes([5, 5, 5, 5, 5]) 0","solution":"def count_standout_athletes(scores): Counts the number of standout athletes in the given list of scores. :param scores: List of integers representing the scores of athletes. :return: Integer count of standout athletes. if not scores: return 0 average_score = sum(scores) / len(scores) standout_count = 0 for score in scores: if score > average_score: standout_count += 1 return standout_count"},{"question":"def does_substring_exist(S: str, K: int) -> str: Checks if there exists a substring of length K in S that contains at least K/2 different characters. Parameters: S (str): The input string consisting of lowercase English letters. K (int): The length of the substring to check. Returns: str: \\"Yes\\" if there exists such a substring, otherwise \\"No\\". >>> does_substring_exist(\\"abacab\\", 4) \\"Yes\\" >>> does_substring_exist(\\"aaaaaabbbbbb\\", 6) \\"No\\" >>> does_substring_exist(\\"abc\\", 3) \\"Yes\\" >>> does_substring_exist(\\"xyzxyz\\", 5) \\"Yes\\" >>> does_substring_exist(\\"a\\", 1) \\"Yes\\" >>> does_substring_exist(\\"aaaaaaa\\", 4) \\"No\\"","solution":"def does_substring_exist(S, K): Checks if there exists a substring of length K in S that contains at least K/2 different characters. Parameters: S (str): The input string consisting of lowercase English letters. K (int): The length of the substring to check. Returns: str: \\"Yes\\" if there exists such a substring, otherwise \\"No\\". n = len(S) for i in range(n - K + 1): substring = S[i:i+K] unique_chars = set(substring) if len(unique_chars) >= K // 2: return \\"Yes\\" return \\"No\\""},{"question":"def smallestSubarray(arr, T): Returns the smallest subarray whose sum is greater than or equal to T. If no such subarray exists, returns -1. >>> smallestSubarray([2, 3, 1, 2, 4, 3], 7) == [4, 3] >>> smallestSubarray([1, 4, 4], 4) == [4] >>> smallestSubarray([1, 1, 1, 1, 1, 1, 1, 1], 11) == -1 >>> smallestSubarray([5], 5) == [5] >>> smallestSubarray([10], 15) == -1 >>> smallestSubarray([2, 1, 5, 2, 8], 7) == [8] >>> smallestSubarray([1] * 100000, 100001) == -1 >>> smallestSubarray([1] * 99999 + [100000], 100000) == [100000]","solution":"def smallestSubarray(arr, T): Returns the smallest subarray whose sum is greater than or equal to T. If no such subarray exists, returns -1. n = len(arr) min_length = float('inf') sum_ = 0 start = 0 result = [] for end in range(n): sum_ += arr[end] while sum_ >= T: if end - start + 1 < min_length: min_length = end - start + 1 result = arr[start:end + 1] sum_ -= arr[start] start += 1 return result if min_length != float('inf') else -1"},{"question":"def isBalanced(S: str) -> bool: Returns true if the parentheses in the string S are properly nested and balanced, otherwise returns false. >>> isBalanced(\\"{[()]}\\") True >>> isBalanced(\\"{[(])}\\") False >>> isBalanced(\\"[]\\") True >>> isBalanced(\\"\\") True >>> isBalanced(\\"(\\") False >>> isBalanced(\\")\\") False >>> isBalanced(\\"(){\\") False >>> isBalanced(\\"({[\\") False >>> isBalanced(\\"{[()()]}\\") True >>> isBalanced(\\"[({{{{}}}}[()])]\\") True >>> isBalanced(\\"{[}]\\") False","solution":"def isBalanced(S): Returns true if the parentheses in the string S are properly nested and balanced, otherwise returns false. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in S: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return False else: # in case there are other characters, which shouldn't be the case here continue return stack == []"},{"question":"def manage_inventory(initial_inventory, updates): Manage the inventory based on initial inventory and updates. Parameters: initial_inventory (list of str): The initial list of product IDs in the inventory. updates (list of tuple): Each tuple contains an operation (\\"ADD\\" or \\"REMOVE\\") and a product ID. Returns: list of str: The final inventory sorted lexically, or [\\"EMPTY\\"] if it is empty.","solution":"def manage_inventory(initial_inventory, updates): Manage the inventory based on initial inventory and updates. Parameters: initial_inventory (list of str): The initial list of product IDs in the inventory. updates (list of tuple): Each tuple contains an operation (\\"ADD\\" or \\"REMOVE\\") and a product ID. Returns: list of str: The final inventory sorted lexically, or [\\"EMPTY\\"] if it is empty. inventory = initial_inventory[:] for operation, product_id in updates: if operation == \\"ADD\\": inventory.append(product_id) elif operation == \\"REMOVE\\": if product_id in inventory: inventory.remove(product_id) if not inventory: return [\\"EMPTY\\"] return sorted(inventory)"},{"question":"from typing import List def rearrange_array(a: List[int]) -> List[int]: Rearrange the given array in-place such that all negative numbers appear before positive numbers while maintaining the relative order of elements in each group. Args: a (List[int]): The input list of integers. Returns: List[int]: The rearranged list of integers. Examples: >>> rearrange_array([-1, 2, -3, 4, -5]) [-1, -3, -5, 2, 4] >>> rearrange_array([1, -1, 3, -2, 5, -3]) [-1, -2, -3, 1, 3, 5]","solution":"from typing import List def rearrange_array(a: List[int]) -> List[int]: Rearrange the given array in-place such that all negative numbers appear before positive numbers while maintaining the relative order of elements in each group. n = len(a) neg = 0 # Pointer for storing the position to place the next negative number for i in range(n): if a[i] < 0: a.insert(neg, a.pop(i)) neg += 1 return a"},{"question":"def minimum_servers(n: int, k: int) -> int: Determine the minimum number of servers required to send out all the invitations within one hour. Args: n (int): the number of participants. k (int): the number of emails each server can send per hour. Returns: int: the minimum number of servers required. >>> minimum_servers(10, 5) 2 >>> minimum_servers(17, 4) 5 >>> minimum_servers(100, 1) 100 >>> minimum_servers(7, 7) 1 >>> minimum_servers(1, 100) 1 >>> minimum_servers(1, 1) 1 >>> minimum_servers(1000, 100) 10","solution":"def minimum_servers(n, k): Returns the minimum number of servers required to send out n invitations within an hour, where each server can send k emails per hour. if n % k == 0: return n // k else: return n // k + 1"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges all overlapping intervals and returns the resulting list of intervals. >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1,4],[4,5]]) [[1, 5]]","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns the resulting list of intervals. if not intervals: return [] # Sort the intervals by start time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: # Merge the current interval with the last merged interval last_merged[1] = max(last_merged[1], current[1]) else: # No overlap, add it to the list merged.append(current) return merged"},{"question":"import math def count_serial_numbers() -> int: Returns the total number of unique serial numbers that can be generated, where each serial number consists of exactly 4 unique uppercase English letters in lexicographical order. pass # Test cases to verify the implementation def test_count_serial_numbers(): assert count_serial_numbers() == 14950","solution":"import math def count_serial_numbers(): Returns the total number of unique serial numbers that can be generated, where each serial number consists of exactly 4 unique uppercase English letters in lexicographical order. # Number of ways to choose 4 letters from 26 letters return math.comb(26, 4) # Printing the result to directly demonstrate the output print(count_serial_numbers())"},{"question":"def top_two_scores(scores): Returns the highest score, the second highest score, and the sum of the top two scores. Parameters: scores (list): An array of unique integers representing scores. Returns: tuple: A tuple containing the highest score, the second highest score, and the sum of the top two scores. >>> top_two_scores([1, 2, 3, 4, 5]) (5, 4, 9) >>> top_two_scores([99, 12, 36, 50, 87]) (99, 87, 186) >>> top_two_scores([45, 78, 31, 89, 22]) (89, 78, 167) >>> top_two_scores([100, 99, 76]) (100, 99, 199) >>> top_two_scores([97, 98, 99, 100]) (100, 99, 199) >>> top_two_scores([1, 2]) (2, 1, 3) >>> top_two_scores([99, 100]) (100, 99, 199) >>> try: top_two_scores([42]) except ValueError as e: str(e) == \\"The array must contain at least two scores.\\"","solution":"def top_two_scores(scores): Returns the highest score, the second highest score, and the sum of the top two scores. Parameters: scores (list): An array of unique integers representing scores. Returns: tuple: A tuple containing the highest score, the second highest score, and the sum of the top two scores. if len(scores) < 2: raise ValueError(\\"The array must contain at least two scores.\\") # Finding the two highest scores first, second = 0, 0 for score in scores: if score > first: first, second = score, first elif score > second: second = score return first, second, first + second"},{"question":"def max_days_of_study_group(q, p, difficulties): Returns the maximum number of days the study group can be sustained. q: int - number of participants p: int - number of unique coding problems difficulties: list[int] - difficulties of each problem Returns: int - maximum number of days >>> max_days_of_study_group(3, 7, [2, 4, 2, 3, 5, 6, 7]) 2 >>> max_days_of_study_group(5, 5, [1, 1, 1, 1, 1]) 1 >>> max_days_of_study_group(1, 3, [6, 8, 9]) 3 >>> max_days_of_study_group(4, 8, [2, 2, 2, 2, 3, 3, 3, 3]) 2","solution":"def max_days_of_study_group(q, p, difficulties): Returns the maximum number of days the study group can be sustained. q: int - number of participants p: int - number of unique coding problems difficulties: list[int] - difficulties of each problem Returns: int - maximum number of days from collections import Counter problem_counts = Counter(difficulties) problems_per_day = sum(min(cnt, q) for cnt in problem_counts.values()) max_days = problems_per_day // q return max_days"},{"question":"def perfect_power(n: int) -> list: Returns [a, b] if n is a perfect power such that a^b = n. Returns None if n is not a perfect power. >>> perfect_power(9) [3, 2] >>> perfect_power(16) [2, 4] >>> perfect_power(27) [3, 3] >>> perfect_power(20) None >>> perfect_power(65536) [2, 16] >>> perfect_power(49) [7, 2] >>> perfect_power(81) [3, 4] >>> perfect_power(123456789) None pass","solution":"def perfect_power(n: int): Returns [a, b] if n is a perfect power such that a^b = n. Returns None if n is not a perfect power. # n must be greater than 1 if n <= 1: return None # Testing for all possible values of a from 2 to sqrt(n) for a in range(2, int(n**0.5) + 1): b = 2 while a**b <= n: if a**b == n: return [a, b] b += 1 return None"},{"question":"def is_leap_year(year): Determines if a given year is a leap year. Parameters: - year: int. The year to be checked (1 <= year <= 10^4) Returns: - 'Yes' if the year is a leap year, 'No' otherwise. Examples: >>> is_leap_year(2000) \\"Yes\\" >>> is_leap_year(1900) \\"No\\" >>> is_leap_year(2024) \\"Yes\\"","solution":"def is_leap_year(year): Determines if a given year is a leap year. Parameters: - year: int. The year to be checked (1 <= year <= 10^4) Returns: - 'Yes' if the year is a leap year, 'No' otherwise. if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return \\"Yes\\" else: return \\"No\\""},{"question":"def max_gems_collected(n, m, r, c, g, grid): Calculates the maximum number of gems a character can collect in a grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. r (int): Starting row position of the character. c (int): Starting column position of the character. g (int): Maximum number of gems the character can collect. grid (list): 2D list representing the grid where '.' is empty space, '#' is an obstacle, and 'G' contains a gem. Returns: int: Maximum number of gems that can be collected. pass def test_max_gems_collected(): grid1 = [ \\".....\\", \\"..G..\\", \\"..#..\\", \\".#.\\", \\".....\\" ] assert max_gems_collected(5, 5, 3, 3, 2, [list(row) for row in grid1]) == 1 grid2 = [ \\"..G.\\", \\".#G.\\", \\"..G.\\", \\"....\\" ] assert max_gems_collected(4, 4, 2, 2, 3, [list(row) for row in grid2]) == 3 grid3 = [ \\".....\\", \\"...#.\\", \\"..G..\\", \\"...\\", \\".....\\" ] assert max_gems_collected(5, 5, 1, 1, 2, [list(row) for row in grid3]) == 1 grid4 = [ \\"#.#..\\", \\"G#G..\\", \\"#.#G.\\", \\".....\\", \\"...G#\\" ] assert max_gems_collected(5, 5, 4, 1, 2, [list(row) for row in grid4]) == 2 grid5 = [ \\"G\\", ] assert max_gems_collected(1, 1, 1, 1, 1, [list(row) for row in grid5]) == 1","solution":"def max_gems_collected(n, m, r, c, g, grid): Calculates the maximum number of gems a character can collect in a grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. r (int): Starting row position of the character. c (int): Starting column position of the character. g (int): Maximum number of gems the character can collect. grid (list): 2D list representing the grid where '.' is empty space, '#' is an obstacle, and 'G' contains a gem. Returns: int: Maximum number of gems that can be collected. from collections import deque # Directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(nx, ny): return 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' queue = deque([(r - 1, c - 1)]) visited = set() visited.add((r - 1, c - 1)) collected_gems = 0 while queue: x, y = queue.popleft() # collect gem if present if grid[x][y] == 'G': collected_gems += 1 if collected_gems == g: return collected_gems grid[x][y] = '.' # collect gem and mark as empty for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return collected_gems"},{"question":"def find_central_logistics_center(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the optimal city to build the central logistics center. The optimal city minimizes the total travel distance from this center to all other cities. Args: n (int): The number of cities (nodes). edges (List[Tuple[int, int, int]]): A list of tuples representing the direct routes between cities along with the distance (weight) of these routes. Returns: int: The node number of the city that should be chosen as the central logistics center. Example: >>> find_central_logistics_center(4, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7)]) 3 pass def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, n: int) -> Dict[int, int]: Perform Dijkstra's algorithm to find the shortest paths from start node to all other nodes in a weighted graph. Args: graph (Dict[int, List[Tuple[int, int]]]): Adjacency list representing the weighted graph. start (int): The starting node for Dijkstra's algorithm. n (int): The number of nodes in the graph. Returns: Dict[int, int]: A dictionary where keys are nodes and values are the shortest distances from the start node. Example: >>> dijkstra({1: [(2, 1), (3, 4)], 2: [(1, 1), (3, 2)], 3: [(1, 4), (2, 2)]}, 1, 3) {1: 0, 2: 1, 3: 3} pass import heapq from typing import List, Tuple, Dict def test_solution(): # Test case 1 n = 4 edges = [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7)] assert find_central_logistics_center(n, edges) == 3 # Test case 2 n = 3 edges = [(1, 2, 1), (2, 3, 1), (1, 3, 2)] assert find_central_logistics_center(n, edges) == 2 # Test case 3 n = 5 edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 5, 3)] assert find_central_logistics_center(n, edges) == 3 # Test case 4 n = 4 edges = [(1, 2, 7), (1, 3, 4), (1, 4, 2), (2, 3, 2), (3, 4, 1)] assert find_central_logistics_center(n, edges) == 3 # Test case 5 n = 2 edges = [(1, 2, 1)] assert find_central_logistics_center(n, edges) == 1 def test_dijkstra(): graph = {1: [(2, 1), (3, 4)], 2: [(1, 1), (3, 2)], 3: [(1, 4), (2, 2)]} start = 1 n = 3 expected_distances = {1: 0, 2: 1, 3: 3} assert dijkstra(graph, start, n) == expected_distances","solution":"import heapq def dijkstra(graph, start, n): Perform Dijkstra's algorithm to find the shortest paths from start node to all other nodes in a weighted graph. distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_central_logistics_center(n, edges): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) min_total_distance = float('inf') optimal_city = None for node in range(1, n + 1): distances = dijkstra(graph, node, n) total_distance = sum(distances.values()) if total_distance < min_total_distance or (total_distance == min_total_distance and node < optimal_city): min_total_distance = total_distance optimal_city = node return optimal_city def solve(): import sys input = sys.stdin.read data = input().splitlines() N, M = map(int, data[0].split()) edges = [tuple(map(int, line.split())) for line in data[1:M + 1]] result = find_central_logistics_center(N, edges) print(result)"},{"question":"def longest_even_sum_subsequence(n: int, sequence: List[int]) -> int: Returns the length of the longest subsequence where the sum of any two elements is even. >>> longest_even_sum_subsequence(5, [1, 2, 3, 4, 5]) 3 >>> longest_even_sum_subsequence(6, [1, 3, 5, 2, 4, 6]) 4 pass # Implement the function here","solution":"def longest_even_sum_subsequence(n, sequence): Returns the length of the longest subsequence where the sum of any two elements is even. # Count the number of even and odd numbers in the sequence evens = sum(1 for x in sequence if x % 2 == 0) odds = n - evens # The longest valid subsequence will be the larger of the counts of evens or odds return max(evens, odds)"},{"question":"def filter_non_negative(numbers: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list that contains only the non-negative integers from the input list. >>> filter_non_negative([-5, 3, 7, -2, 0, -1]) [3, 7, 0] >>> filter_non_negative([-1, -2, -3, -4, -5]) [] >>> filter_non_negative([0, 1, 2, 3, 4, 5]) [0, 1, 2, 3, 4, 5] >>> filter_non_negative([-1]) [] >>> filter_non_negative([0]) [0] >>> filter_non_negative([]) []","solution":"def filter_non_negative(numbers): Returns a list containing only the non-negative integers from the input list. Parameters: numbers (list): The input list of integers. Returns: list: A list of non-negative integers. return [num for num in numbers if num >= 0]"},{"question":"import math def euclidean_distance_3d(x1, y1, z1, x2, y2, z2): Returns the Euclidean distance between two points in 3-dimensional space. >>> euclidean_distance_3d(0, 0, 0, 0, 0, 0) 0.0 >>> euclidean_distance_3d(1, 2, 3, 4, 5, 6) 5.1962 >>> euclidean_distance_3d(-1, -2, -3, 1, 2, 3) 7.4833 >>> euclidean_distance_3d(-1, -1, -1, -4, -4, -4) 5.1962 >>> euclidean_distance_3d(0, 0, 0, 1, 1, 1) 1.7321 >>> euclidean_distance_3d(100, 200, 300, 400, 500, 600) 519.6152","solution":"import math def euclidean_distance_3d(x1, y1, z1, x2, y2, z2): Returns the Euclidean distance between two points in 3-dimensional space. distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2) return round(distance, 4)"},{"question":"def minimize_max_subarray_sum(arr, k): You are given an array of integers and a positive integer \`k\`. Your task is to divide the array into \`k\` contiguous subarrays such that the sum of the maximum sum subarray among them is minimized. Args: arr: List[int] - an array of positive integers. k: int - a positive integer. Returns: int - the minimum possible value of the maximum sum of the \`k\` contiguous subarrays. Examples: >>> minimize_max_subarray_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_subarray_sum([1, 4, 4], 3) 4","solution":"def minimize_max_subarray_sum(arr, k): def is_valid(mid): count = 1 current_sum = 0 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if is_valid(mid): high = mid else: low = mid + 1 return low"},{"question":"def calculate_bmi(weight: float, height: float) -> str: Calculates the BMI and returns the corresponding BMI category. :param weight: weight in kilograms :param height: height in meters :return: String indicating the BMI category >>> calculate_bmi(50, 1.75) 'Underweight' >>> calculate_bmi(70, 1.75) 'Normal weight' >>> calculate_bmi(85, 1.75) 'Overweight' >>> calculate_bmi(95, 1.75) 'Obesity'","solution":"def calculate_bmi(weight, height): Calculates the BMI and returns the corresponding BMI category. :param weight: weight in kilograms :param height: height in meters :return: String indicating the BMI category bmi = round(weight / (height ** 2), 2) if bmi < 18.5: return \\"Underweight\\" elif 18.5 <= bmi < 24.9: return \\"Normal weight\\" elif 24.9 <= bmi < 29.9: return \\"Overweight\\" else: return \\"Obesity\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root, p, q): Finds the lowest common ancestor (LCA) of two nodes in a BST. Parameters: root (TreeNode): The root of the binary search tree. p (int): Value of the first node. q (int): Value of the second node. Returns: int: Value of the LCA node. >>> root = TreeNode(6) >>> root.left = TreeNode(2) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> root.left.right.left = TreeNode(3) >>> root.left.right.right = TreeNode(5) >>> lowestCommonAncestor(root, 2, 8) 6 >>> lowestCommonAncestor(root, 2, 4) 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root, p, q): Finds the lowest common ancestor (LCA) of two nodes in a BST. Parameters: root (TreeNode): The root of the binary search tree. p (int): Value of the first node. q (int): Value of the second node. Returns: int: Value of the LCA node. current = root while current: if p < current.val and q < current.val: current = current.left elif p > current.val and q > current.val: current = current.right else: return current.val return None # Just in case there's no valid LCA which shouldn't happen as per input constraints"},{"question":"def process_numbers(input_str): Processes a string of space-separated integers by sorting them in ascending order and removing duplicates. :param input_str: A string of space-separated integers. :return: A list of sorted, unique integers. >>> process_numbers(\\"4 7 2 8 7 3 2\\") [2, 3, 4, 7, 8] >>> process_numbers(\\"5\\") [5] >>> process_numbers(\\"1 1 1 1 1\\") [1] >>> process_numbers(\\"1 2 3 4 5\\") [1, 2, 3, 4, 5] >>> process_numbers(\\"3 -1 2 -1 3 0\\") [-1, 0, 2, 3] >>> process_numbers(\\"\\") []","solution":"def process_numbers(input_str): Processes a string of space-separated integers by sorting them in ascending order and removing duplicates. :param input_str: A string of space-separated integers. :return: A list of sorted, unique integers. # Convert the input string to a list of integers numbers = list(map(int, input_str.split())) # Remove duplicates by converting to a set unique_numbers = set(numbers) # Sort the unique numbers sorted_numbers = sorted(unique_numbers) return sorted_numbers"},{"question":"def expand_intervals(intervals): Expands a list of intervals into a sorted list of unique integers. Args: intervals (list of tuples): List of tuples where each tuple represents an interval (start, end). Returns: list of int: A sorted list of all individual integers within the given intervals. Examples: >>> expand_intervals([(1, 3), (5, 7), (4, 6)]) [1, 2, 3, 4, 5, 6, 7] >>> expand_intervals([(10, 15), (1, 5)]) [1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15] >>> expand_intervals([(100, 100), (50, 52)]) [50, 51, 52, 100]","solution":"def expand_intervals(intervals): Expands a list of intervals into a sorted list of unique integers. Args: intervals (list of tuples): List of tuples where each tuple represents an interval (start, end). Returns: list of int: A sorted list of all individual integers within the given intervals. result_set = set() for start, end in intervals: result_set.update(range(start, end + 1)) return sorted(result_set)"},{"question":"from typing import List, Tuple def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths in an n x n grid with obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [1, 1, 0]]) 1 pass def solve(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Given the number of test cases and each grid, returns the number of unique paths for each test case. >>> solve(2, [ ... (3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]), ... (3, [ ... [0, 0, 0], ... [0, 1, 0], ... [1, 1, 0] ... ]) ... ]) [2, 1] >>> solve(1, [ ... (2, [ ... [0, 1], ... [0, 0] ... ]) ... ]) [1] pass","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths in an n x n grid with obstacles. n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 # Create a 2D table to store results of subproblems dp = [[0] * n for _ in range(n)] # Initialize the first cell dp[0][0] = 1 # Fill the values for the first column (only down moves) for i in range(1, n): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] # Fill the values for the first row (only right moves) for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][n-1] def solve(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] grid = test_cases[i][1] results.append(unique_paths_with_obstacles(grid)) return results"},{"question":"def leaderboard_ranking(players_scores): Calculate leaderboard rankings based on player scores. Players with the same score get the same rank, and the subsequent rank skips numbers to maintain distinct ranks. >>> leaderboard_ranking([(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 75), (\\"David\\", 55), (\\"Eve\\", 20)]) [('Bob', 1), ('Charlie', 1), ('David', 3), ('Alice', 4), ('Eve', 5)] # your code here # Test Cases def test_leaderboard_ranking_single_player(): assert leaderboard_ranking([(\\"Alice\\", 50)]) == [(\\"Alice\\", 1)] def test_leaderboard_ranking_all_same_scores(): players_scores = [(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Charlie\\", 50)] assert leaderboard_ranking(players_scores) == [(\\"Alice\\", 1), (\\"Bob\\", 1), (\\"Charlie\\", 1)] def test_leaderboard_ranking_distinct_scores(): players_scores = [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 60), (\\"David\\", 55), (\\"Eve\\", 20)] assert leaderboard_ranking(players_scores) == [('Bob', 1), ('Charlie', 2), ('David', 3), ('Alice', 4), ('Eve', 5)] def test_leaderboard_ranking_mixed_scores(): players_scores = [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 75), (\\"David\\", 55), (\\"Eve\\", 20)] assert leaderboard_ranking(players_scores) == [('Bob', 1), ('Charlie', 1), ('David', 3), ('Alice', 4), ('Eve', 5)] def test_leaderboard_ranking_sequential_scores(): players_scores = [(\\"Alice\\", 50), (\\"Bob\\", 70), (\\"Charlie\\", 60), (\\"David\\", 80), (\\"Eve\\", 55)] assert leaderboard_ranking(players_scores) == [('David', 1), ('Bob', 2), ('Charlie', 3), ('Eve', 4), ('Alice', 5)]","solution":"def leaderboard_ranking(players_scores): Returns the leaderboard ranking based on scores. Players with the same score get the same rank, and the subsequent rank skips numbers to maintain distinct ranks. :param players_scores: List of tuples, each containing a player name and their score :return: List of tuples, each containing a player name and their rank # Step 1: Sort the players by score in descending order sorted_scores = sorted(players_scores, key=lambda x: -x[1]) # Step 2: Calculate the ranks rankings = [] current_rank = 1 previous_score = None for i, (name, score) in enumerate(sorted_scores): if score != previous_score: current_rank = i + 1 rankings.append((name, current_rank)) previous_score = score return rankings"},{"question":"def find_max_sum_under_target(N: int, fruits: List[int], T: int) -> int: Find the highest possible sum of health values of consecutive fruits that does not exceed the target T. Args: N : int : number of unique fruits fruits : List[int] : the health values of the fruits T : int : the target health value Returns: int : highest sum of health values of consecutive fruits that does not exceed T >>> find_max_sum_under_target(5, [1, 2, 3, 4, 5], 10) 10 >>> find_max_sum_under_target(6, [-1, 2, 3, -4, 5, -3], 5) 5 >>> find_max_sum_under_target(4, [5, -2, -3, 2], 4) 2 pass def forest_ranger(M: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Determine the highest possible sum of health values of consecutive fruits for multiple test cases. Args: M : int : number of test cases test_cases : List[Tuple[int, List[int], int]] : a list of test cases where each test case is a tuple containing: - an integer N representing the number of unique fruits - a list of N integers representing the health values of the fruits - an integer T representing the target health value Returns: List[int] : a list of highest sums for each test case that do not exceed the target T >>> forest_ranger(3, [(5, [1, 2, 3, 4, 5], 10), (6, [-1, 2, 3, -4, 5, -3], 5), (4, [5, -2, -3, 2], 4)]) [10, 5, 2] pass def test_find_max_sum_under_target(): test_cases = [ (5, [1, 2, 3, 4, 5], 10, 10), (6, [-1, 2, 3, -4, 5, -3], 5, 5), (4, [5, -2, -3, 2], 4, 2), (3, [-1, -2, -3], -1, -1), (3, [10, 20, 30], 15, 10), (6, [3, -1, 2, -1, 2, 1], 4, 4) ] for N, fruits, T, expected in test_cases: assert find_max_sum_under_target(N, fruits, T) == expected def test_forest_ranger(): M = 3 test_cases = [ (5, [1, 2, 3, 4, 5], 10), (6, [-1, 2, 3, -4, 5, -3], 5), (4, [5, -2, -3, 2], 4) ] expected_results = [10, 5, 2] assert forest_ranger(M, test_cases) == expected_results","solution":"def find_max_sum_under_target(N, fruits, T): max_sum = float('-inf') current_sum = 0 for start in range(N): current_sum = 0 for end in range(start, N): current_sum += fruits[end] if current_sum > T: break max_sum = max(max_sum, current_sum) return max_sum if max_sum != float('-inf') else 0 def forest_ranger(M, test_cases): results = [] for case in test_cases: N, fruits, T = case result = find_max_sum_under_target(N, fruits, T) results.append(result) return results"},{"question":"def min_visible_blocks(heights): Determines the minimum number of visible blocks after arranging them into blocks of same height. Each block contains people of the same height or height differing by no more than 1 unit. Args: heights (List[int]): List of integers representing heights of people. Returns: int: The minimum number of visible blocks. Examples: >>> min_visible_blocks([1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 2, 1]) 3 >>> min_visible_blocks([7, 8, 8, 6, 9, 6, 8, 7]) 2","solution":"def min_visible_blocks(heights): Determines the minimum number of visible blocks after arranging them into blocks of same height. if not heights: return 0 heights = sorted(heights) blocks = 1 current_block_min = heights[0] for h in heights: if h > current_block_min + 1: blocks += 1 current_block_min = h return blocks"},{"question":"def determine_sequence_type(sequence): Given a sequence of integers, determine if it is strictly increasing, strictly decreasing, or neither. >>> determine_sequence_type([1, 2, 3, 4, 5]) == \\"increasing\\" >>> determine_sequence_type([5, 4, 3, 2, 1]) == \\"decreasing\\" >>> determine_sequence_type([1, 1, 2, 3]) == \\"neither\\" >>> determine_sequence_type([3, 5, 2, 6]) == \\"neither\\" def process_input(lines): Processes multiple lines of input integers and returns their sequence types. >>> process_input([ \\"1 2 3 4 5\\", \\"5 4 3 2 1\\", \\"1 1 2 3\\", \\"3 5 2 6\\", \\"end\\" ]) == [ \\"increasing\\", \\"decreasing\\", \\"neither\\", \\"neither\\" ]","solution":"def determine_sequence_type(sequence): Given a sequence of integers, determine if it is strictly increasing, strictly decreasing, or neither. if all(sequence[i] < sequence[i + 1] for i in range(len(sequence) - 1)): return \\"increasing\\" elif all(sequence[i] > sequence[i + 1] for i in range(len(sequence) - 1)): return \\"decreasing\\" else: return \\"neither\\" def process_input(lines): Processes multiple lines of input integers and returns their sequence types. results = [] for line in lines: if line == \\"end\\": break sequence = list(map(int, line.split())) result = determine_sequence_type(sequence) results.append(result) return results"},{"question":"def evaluatePrefix(expression: List[str]) -> int: Evaluates a prefix expression (Polish Notation). Args: expression (List[str]): The prefix expression as a list of strings. Returns: int: The evaluated result of the prefix expression. >>> evaluatePrefix([\\"+\\", \\"3\\", \\"4\\"]) == 7 >>> evaluatePrefix([\\"+\\", \\"9\\", \\"*\\", \\"3\\", \\"2\\"]) == 15 >>> evaluatePrefix([\\"-\\", \\"*\\", \\"10\\", \\"2\\", \\"3\\"]) == 17 >>> evaluatePrefix([\\"/\\", \\"+\\", \\"15\\", \\"5\\", \\"3\\"]) == 6 >>> evaluatePrefix([\\"42\\"]) == 42 >>> evaluatePrefix([\\"+\\", \\"-2\\", \\"-3\\"]) == -5 >>> evaluatePrefix([\\"-\\", \\"/\\", \\"10\\", \\"2\\", \\"2\\"]) == 3 >>> evaluatePrefix([\\"/\\", \\"*\\", \\"+\\", \\"5\\", \\"2\\", \\"2\\", \\"3\\"]) == 4","solution":"def evaluatePrefix(expression): Evaluates a prefix expression. Args: expression (List[str]): The prefix expression as a list of strings. Returns: int: The evaluated result of the prefix expression. stack = [] operators = {\\"+\\", \\"-\\", \\"*\\", \\"/\\"} # Traverse the expression from right to left for token in reversed(expression): if token in operators: operand1 = stack.pop() operand2 = stack.pop() if token == \\"+\\": result = operand1 + operand2 elif token == \\"-\\": result = operand1 - operand2 elif token == \\"*\\": result = operand1 * operand2 elif token == \\"/\\": # Ensure integer division with truncation towards zero result = int(operand1 / operand2) stack.append(result) else: stack.append(int(token)) return stack[-1]"},{"question":"def maximize_collective_strength(M: int, strengths: List[int]) -> int: Maximizes the collective strength of the remaining creatures after all possible battles. Parameters: M (int): Number of creatures. strengths (list): List of integers representing the strengths of the creatures. Returns: int: Maximum possible collective strength after all possible battles. >>> maximize_collective_strength(4, [2, 3, 5, 7]) 210 >>> maximize_collective_strength(3, [1, 5, 10]) 50 >>> maximize_collective_strength(1, [7]) 7 >>> maximize_collective_strength(3, [5, 5, 5]) 125 >>> maximize_collective_strength(4, [2, 2, 2, 2]) 16 >>> maximize_collective_strength(2, [0, 10]) 0 >>> maximize_collective_strength(100, [1000] * 100) 1000 ** 50 >>> maximize_collective_strength(2, [3, 7]) 21","solution":"def maximize_collective_strength(M, strengths): Maximizes the collective strength of the remaining creatures after all possible battles. Parameters: M (int): Number of creatures. strengths (list): List of integers representing the strengths of the creatures. Returns: int: Maximum possible collective strength after all possible battles. if M == 1: return strengths[0] # Initial sort to always combine pairs that will maximize the product. strengths.sort(reverse=True) while len(strengths) > 1: a = strengths.pop(0) b = strengths.pop(0) new_strength = a * b strengths.append(new_strength) strengths.sort(reverse=True) return strengths[0]"},{"question":"def maximum_product_triplet(arr): Given an array of integers, find the maximum product of any triplet in the array. >>> maximum_product_triplet([1, 4, 3, -6, -7]) 168 >>> maximum_product_triplet([1, 3, 4, 5, 7, 9, 2]) 315 >>> maximum_product_triplet([-10, -10, 5, 2]) 500 >>> maximum_product_triplet([-1, -2, -3, -4]) -6 >>> maximum_product_triplet([1, 2, 3]) 6 >>> maximum_product_triplet([-1, -2, -3, 4, 5]) 30 >>> maximum_product_triplet([0, -1, -2, -3, -4]) 0 #","solution":"def maximum_product_triplet(arr): arr.sort() # The maximum product of three numbers can be either of the following: # 1. Product of the three largest numbers # 2. Product of the two smallest numbers and the largest number return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]) # Input reading and function execution part for testing/debugging purpose if __name__ == \\"__main__\\": n = int(input().strip()) arr = list(map(int, input().strip().split())) print(maximum_product_triplet(arr))"},{"question":"def add_persistence(n: int) -> int: Calculate the add persistence of a number. Add persistence is the number of times you must sum the digits of a number until you reach a single digit. Args: n (int): A non-negative integer. Returns: int: The number of steps required to reach a single-digit number. Examples: >>> add_persistence(999) 2 >>> add_persistence(1679583) 3 >>> add_persistence(123456) 2 >>> add_persistence(5) 0","solution":"def add_persistence(n): Calculate the add persistence of a number. Add persistence is the number of times you must sum the digits of a number until you reach a single digit. Args: n (int): A non-negative integer. Returns: int: The number of steps required to reach a single-digit number. steps = 0 while n >= 10: n = sum(int(digit) for digit in str(n)) steps += 1 return steps"},{"question":"def generate_bis(n): Generates the Binary Incremental Sequence (BIS) for the given integer n. >>> generate_bis(3) [\\"0\\", \\"1\\", \\"10\\"] >>> generate_bis(5) [\\"0\\", \\"1\\", \\"10\\", \\"11\\", \\"100\\"] pass def process_input(T, cases): Processes the input and generates the BIS for each case. >>> process_input(3, [3, 5, 2]) [\\"0 1 10\\", \\"0 1 10 11 100\\", \\"0 1\\"] >>> process_input(2, [1, 4]) [\\"0\\", \\"0 1 10 11\\"] pass","solution":"def generate_bis(n): Generates the Binary Incremental Sequence (BIS) for the given integer n. bis = [] for i in range(n): bis.append(bin(i)[2:]) return bis def process_input(T, cases): Processes the input and generates the BIS for each case. result = [] for n in cases: result.append(\\" \\".join(generate_bis(n))) return result"},{"question":"def count_likes(posts, queries): Counts the number of posts that received at least T likes within the time window [A, B]. :param posts: List of tuples containing post information (P, Tp, L, likes) :param queries: List of tuples containing query information (A, B, T) :return: List of results for each query >>> posts = [ ... (101, 1, 5, [2, 4, 6, 8, 10]), ... (102, 2, 4, [3, 5, 7]), ... (103, 3, 3, [4, 6, 8]) ... ] >>> queries = [ ... (2, 8, 2), ... (1, 10, 5) ... ] >>> count_likes(posts, queries) [3, 1]","solution":"def count_likes(posts, queries): Counts the number of posts that received at least T likes within the time window [A, B]. :param posts: List of tuples containing post information (P, Tp, L, likes) :param queries: List of tuples containing query information (A, B, T) :return: List of results for each query results = [] for A, B, T in queries: count = 0 for post in posts: _, _, _, likes = post likes_in_window = sum(1 for like in likes if A <= like <= B) if likes_in_window >= T: count += 1 results.append(count) return results # Example usage posts = [ (101, 1, 5, [2, 4, 6, 8, 10]), (102, 2, 4, [3, 5, 7]), (103, 3, 3, [4, 6, 8]) ] queries = [ (2, 8, 2), (1, 10, 5) ] # Expected output: [3, 1] count_likes(posts, queries)"},{"question":"def calculate_express_streets(n: int, m: int, k: int): Determine the minimum number of express streets required to ensure that the express distance between any two intersections does not exceed a given threshold distance k. Args: n (int): The number of intersections in each row. m (int): The number of intersections in each column. k (int): The maximum allowed express distance between any two intersections. Returns: int: The number of express streets added. List[Tuple[int, int, int, int]]: The list of express streets with their coordinates. >>> calculate_express_streets(5, 4, 3) (4, [(1, 1, 3, 3), (2, 2, 4, 4), (1, 4, 4, 1), (3, 1, 5, 4)]) pass # Unit Test def test_calculate_express_streets_basic(): t, streets = calculate_express_streets(5, 4, 3) assert t == 3 assert len(streets) == 3 def test_calculate_express_streets_more_streets(): t, streets = calculate_express_streets(5, 5, 5) assert t == 5 assert len(streets) == 5 def test_calculate_express_streets_less_streets(): t, streets = calculate_express_streets(4, 4, 2) assert t == 2 assert len(streets) == 2","solution":"def calculate_express_streets(n, m, k): Returns the number of express streets and the coordinates of the intersections they connect. streets = [] # For simplicity, we will create express streets in a zigzag pattern # to ensure that express distance is minimized for i in range(1, min(n, m) + 1): if i + 2 <= n and i + 2 <= m: x1, y1, x2, y2 = i, i, i + 2, i + 2 streets.append((x1, y1, x2, y2)) if i + 2 <= n and m - i + 1 >= 1: x1, y1, x2, y2 = i, m - i + 1, i + 2, m - i + 3 - 2 streets.append((x1, y1, x2, y2)) if n - i + 1 >= 1 and i + 2 <= m: x1, y1, x2, y2 = n - i + 1, i, n - i - 1 + 1, i + 2 streets.append((x1, y1, x2, y2)) # Ensure the number of streets is within maximum capacity t = min(len(streets), k) return t, streets[:t] # Read input def main(): import sys input = sys.stdin.read data = input().strip().split() n, m, k = int(data[0]), int(data[1]), int(data[2]) t, streets = calculate_express_streets(n, m, k) # Output the result print(t) for street in streets: print(f\\"{street[0]} {street[1]} {street[2]} {street[3]}\\") if __name__ == \\"__main__\\": main()"},{"question":"def min_docking_time(n: int, m: int, capacities: List[int], docking_times: List[int]) -> int: Determine the minimum total docking time required if the cars are parked in the most optimal manner. >>> min_docking_time(3, 7, [2, 3, 4], [1, 2, 3, 4, 5, 6, 7]) 28 >>> min_docking_time(2, 4, [2, 2], [7, 8, 5, 4]) 24","solution":"def min_docking_time(n, m, capacities, docking_times): capacities.sort(reverse=True) docking_times.sort(reverse=True) total_docking_time = 0 car_index = 0 for capacity in capacities: for _ in range(capacity): if car_index < m: total_docking_time += docking_times[car_index] car_index += 1 return total_docking_time"},{"question":"def calculate_influence(n: int, m: int, edges: List[Tuple[int, int]]) -> List[int]: Compute the number of users influenced by each user in a unique social network. >>> calculate_influence(4, 3, [(1, 2), (2, 3), (3, 4)]) [3, 2, 1, 0] >>> calculate_influence(5, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)]) [2, 2, 2, 1, 1] >>> calculate_influence(3, 2, [(1, 2), (1, 3)]) [2, 0, 0] >>> calculate_influence(3, 0, []) [0, 0, 0] >>> calculate_influence(1, 0, []) [0]","solution":"from collections import defaultdict, deque def calculate_influence(n, m, edges): def bfs(start, graph): visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return len(visited) - 1 # exclude the start node itself graph = defaultdict(list) for u, v in edges: graph[u].append(v) influence_counts = [] for user in range(1, n+1): influence_counts.append(bfs(user, graph)) return influence_counts"},{"question":"from typing import List from collections import defaultdict def group_anagrams(strs: List[str]) -> List[List[str]]: Groups the anagrams in the list of strings. Args: strs (list of str): List of strings to be grouped by anagrams. Returns: list of list of str: A list where each element is a list of anagrams grouped together. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']] >>> group_anagrams([\\"\\"]) [['']] >>> group_anagrams([\\"a\\"]) [['a']]","solution":"from collections import defaultdict def group_anagrams(strs): Groups the anagrams in the list of strings. Args: strs (list of str): List of strings to be grouped by anagrams. Returns: list of list of str: A list where each element is a list of anagrams grouped together. anagrams = defaultdict(list) for s in strs: sorted_s = ''.join(sorted(s)) anagrams[sorted_s].append(s) result = [sorted(group) for group in anagrams.values()] result.sort(key=lambda x: x[0]) return result"},{"question":"def trap_rainwater(heights: List[int]) -> int: Given a list of integers representing the heights of buildings, returns the total amount of trapped rainwater. >>> trap_rainwater([3, 0, 2, 0, 4]) 7 >>> trap_rainwater([1, 2, 3, 4]) 0 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_rainwater(heights): Given a list of integers representing the heights of buildings, returns the total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def has_zero_sum_subarray(arr): Determines if there exists a contiguous subarray whose sum is zero. :param arr: List of integers :return: \\"YES\\" if such a subarray exists, otherwise \\"NO\\" >>> has_zero_sum_subarray([4, 2, -3, 1, 6]) \\"YES\\" >>> has_zero_sum_subarray([1, 2, 3, 4]) \\"NO\\" def test_example_1(): assert has_zero_sum_subarray([4, 2, -3, 1, 6]) == \\"YES\\" def test_example_2(): assert has_zero_sum_subarray([1, 2, 3, 4]) == \\"NO\\" def test_empty_array(): assert has_zero_sum_subarray([]) == \\"NO\\" def test_single_zero(): assert has_zero_sum_subarray([0]) == \\"YES\\" def test_all_positives(): assert has_zero_sum_subarray([1, 2, 3, 4, 5]) == \\"NO\\" def test_all_negatives(): assert has_zero_sum_subarray([-1, -2, -3, -4, -5]) == \\"NO\\" def test_mixed_elements_1(): assert has_zero_sum_subarray([1, 2, -3, 3, 1, -4, 2]) == \\"YES\\" def test_mixed_elements_2(): assert has_zero_sum_subarray([1, -1, 2, -2, 3, -3, 4]) == \\"YES\\" def test_large_element(): assert has_zero_sum_subarray([10**9, -10**9]) == \\"YES\\" def test_no_zero_sum_subarray(): assert has_zero_sum_subarray([3, 4, -7, 1, 2, -1, -2, 1, 2, 3]) == \\"YES\\" def test_no_zero_sum_subarray_ends_with_large_negative(): assert has_zero_sum_subarray([1, 2, 3, 4, -10]) == \\"YES\\"","solution":"def has_zero_sum_subarray(arr): Determines if there exists a contiguous subarray whose sum is zero. :param arr: List of integers :return: \\"YES\\" if such a subarray exists, otherwise \\"NO\\" current_sum = 0 sum_set = set() # Iterate through all elements in the array for num in arr: # Add current number to the cumulative sum current_sum += num # Check if cumulative sum is zero or has been seen before if current_sum == 0 or current_sum in sum_set: return \\"YES\\" # Add the cumulative sum to the set sum_set.add(current_sum) return \\"NO\\""},{"question":"def search_rotated_array(nums, target): Searches for a target value in a rotated sorted array. Args: nums (list of int): Rotated sorted array of distinct integers. target (int): Target value to search for. Returns: int: Index of the target if found, otherwise -1. Examples: >>> search_rotated_array([4,5,6,7,0,1,2], 0) 4 >>> search_rotated_array([4,5,6,7,0,1,2], 3) -1 def test_search_rotated_array(): # Test case where target is found assert search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) == 4 # Test case where target is not found assert search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) == -1 # Test case with single element array and target is found assert search_rotated_array([1], 1) == 0 # Test case with single element array and target is not found assert search_rotated_array([1], 2) == -1 # Test case with array of two elements, target found assert search_rotated_array([2, 1], 1) == 1 # Test case with array of two elements, target not found assert search_rotated_array([2, 1], 3) == -1 # Test case with array where no rotation occurred and target found assert search_rotated_array([1, 2, 3, 4, 5, 6, 7], 5) == 4 # Test case with array where no rotation occurred and target not found assert search_rotated_array([1, 2, 3, 4, 5, 6, 7], 8) == -1 # Test case with array fully rotated back (i.e., same as sorted array) assert search_rotated_array([1, 2, 3, 4, 5, 6, 7], 1) == 0 # Test case with array where target is at the rotation point assert search_rotated_array([6, 7, 1, 2, 3, 4, 5], 7) == 1 test_search_rotated_array()","solution":"def search_rotated_array(nums, target): Searches for a target value in a rotated sorted array. Args: nums (list of int): Rotated sorted array of distinct integers. target (int): Target value to search for. Returns: int: Index of the target if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Determine the sorted part of the array if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from typing import List def find_anagrams(words: List[str]) -> List[str]: Given an array of strings, return an array containing all strings that are anagrams of any other string in the input array. Anagrams are strings that can be formed by rearranging the letters of another string using all the original letters exactly once. >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"vile\\", \\"evil\\"]) [\\"listen\\", \\"silent\\", \\"enlist\\", \\"vile\\", \\"evil\\"] >>> find_anagrams([\\"abcd\\", \\"bcda\\", \\"dabc\\", \\"xyz\\", \\"yxz\\", \\"zxy\\", \\"abc\\"]) [\\"abcd\\", \\"bcda\\", \\"dabc\\", \\"xyz\\", \\"yxz\\", \\"zxy\\"] >>> find_anagrams([\\"catch\\", \\"match\\", \\"batch\\"]) [] >>> find_anagrams([\\"\\"]) []","solution":"from typing import List def find_anagrams(words: List[str]) -> List[str]: from collections import defaultdict anagram_groups = defaultdict(list) result = [] for word in words: key = ''.join(sorted(word)) anagram_groups[key].append(word) for group in anagram_groups.values(): if len(group) > 1: result.extend(group) return result"},{"question":"from typing import List def longest_subsequence_with_two_distinct(nums: List[int]) -> int: Given an array of integers, find the length of the longest contiguous subsequence that contains no more than two distinct integers. >>> longest_subsequence_with_two_distinct([1, 2, 1, 2, 1, 3, 4]) 5 >>> longest_subsequence_with_two_distinct([4, 4, 4, 4, 4]) 5 >>> longest_subsequence_with_two_distinct([1, 2, 3, 4, 5, 6]) 2","solution":"def longest_subsequence_with_two_distinct(nums): This function returns the length of the longest contiguous subsequence with no more than two distinct integers. if not nums: return 0 n = len(nums) max_len = 0 left, right = 0, 0 freq_map = {} while right < n: if nums[right] in freq_map or len(freq_map) < 2: if nums[right] in freq_map: freq_map[nums[right]] += 1 else: freq_map[nums[right]] = 1 right += 1 else: max_len = max(max_len, right - left) while len(freq_map) == 2: freq_map[nums[left]] -= 1 if freq_map[nums[left]] == 0: del freq_map[nums[left]] left += 1 freq_map[nums[right]] = 1 right += 1 max_len = max(max_len, right - left) return max_len"},{"question":"def smallest_subarray_with_sum_greater_equal(arr, M): Determine the smallest subarray (contiguous elements) in the list such that the sum of its elements is greater than or equal to M. If no such subarray exists, return -1. >>> smallest_subarray_with_sum_greater_equal([1, 2, 3, 4, 5, 6, 7, 8], 15) 2 >>> smallest_subarray_with_sum_greater_equal([1, 2, 3, 4, 5], 20) -1 >>> smallest_subarray_with_sum_greater_equal([4, 4, 4, 4], 16) 4 >>> smallest_subarray_with_sum_greater_equal([10], 5) 1 >>> smallest_subarray_with_sum_greater_equal([1], 5) -1 >>> smallest_subarray_with_sum_greater_equal([5, 1, 2, 3, 4], 7) 2 >>> smallest_subarray_with_sum_greater_equal([1, 1, 1, 5, 6], 10) 2","solution":"def smallest_subarray_with_sum_greater_equal(arr, M): n = len(arr) min_len = float('inf') curr_sum = 0 start = 0 for end in range(n): curr_sum += arr[end] while curr_sum >= M: min_len = min(min_len, end - start + 1) curr_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else -1"},{"question":"def can_form_palindrome(n: int, arr: List[int]) -> str: Determines if the array can be rearranged to form a palindrome. Parameters: n (int): The size of the array. arr (list): The elements of the array. Returns: str: \\"YES\\" if the array can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(5, [3, 1, 2, 1, 3]) \\"YES\\" >>> can_form_palindrome(4, [1, 2, 3, 4]) \\"NO\\"","solution":"def can_form_palindrome(n, arr): Determines if the array can be rearranged to form a palindrome. Parameters: n (int): The size of the array. arr (list): The elements of the array. Returns: str: \\"YES\\" if the array can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter # Count the frequency of each element in the array freq = Counter(arr) # Count the number of elements with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A palindrome can have at most one element with an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_strictly_increasing(sequence: List[int]) -> str: Determines whether the provided list of integers forms a strictly increasing sequence. :param sequence: List[int] - A list of integers. :return: str - \\"Yes\\" if the sequence is strictly increasing, otherwise \\"No\\". >>> is_strictly_increasing([1, 2, 3, 4, 5]) \\"Yes\\" >>> is_strictly_increasing([5, 3, 8, 9]) \\"No\\" >>> is_strictly_increasing([10, 20, 30, 40, 50]) \\"Yes\\" >>> is_strictly_increasing([100, 99, 98, 97]) \\"No\\" >>> is_strictly_increasing([1, 1, 2, 3]) \\"No\\" >>> is_strictly_increasing([1, 100]) \\"Yes\\" >>> is_strictly_increasing([2, 1]) \\"No\\" >>> is_strictly_increasing([1, 2, 3, 2, 1]) \\"No\\"","solution":"def is_strictly_increasing(sequence): Determines whether the provided list of integers forms a strictly increasing sequence. :param sequence: List[int] - A list of integers. :return: str - \\"Yes\\" if the sequence is strictly increasing, otherwise \\"No\\". for i in range(1, len(sequence)): if sequence[i] <= sequence[i - 1]: return \\"No\\" return \\"Yes\\" if __name__ == \\"__main__\\": sequence = list(map(int, input().strip().split())) print(is_strictly_increasing(sequence))"},{"question":"def min_moves_to_no_adjacent_same_height(n: int, heights: List[int]) -> int: Given a list of n integers representing the heights of n students, determine the minimum number of students that need to move so that no two adjacent students have the same height. Args: n: int - the number of students heights: list of int - the heights of the students Returns: int - the minimum number of students that need to move >>> min_moves_to_no_adjacent_same_height(6, [1, 1, 2, 3, 3, 1]) 2 >>> min_moves_to_no_adjacent_same_height(1, [1]) 0 >>> min_moves_to_no_adjacent_same_height(5, [2, 2, 2, 2, 2]) 4 >>> min_moves_to_no_adjacent_same_height(0, []) 0 >>> min_moves_to_no_adjacent_same_height(6, [1, 2, 1, 2, 1, 2]) 0 >>> min_moves_to_no_adjacent_same_height(7, [1, 3, 1, 1, 4, 4, 5]) 2","solution":"def min_moves_to_no_adjacent_same_height(n, heights): Given a list of n integers representing the heights of n students, determine the minimum number of students that need to move so that no two adjacent students have the same height. Args: n : int - the number of students heights : list of int - the heights of the students Returns: int - the minimum number of students that need to move if n == 1: return 0 moves = 0 for i in range(1, n): if heights[i] == heights[i - 1]: moves += 1 return moves"},{"question":"def can_split_chocolate(R: int, C: int, k: int, sweetness: List[List[int]]) -> str: Determine if it's possible to split the chocolate bar into k rectangles with equal sweetness. Args: R: the number of rows in the chocolate bar C: the number of columns in the chocolate bar k: the number of rectangles to split the bar into sweetness: a 2D list representing the sweetness level of each piece of chocolate Returns: \\"Yes\\" if it's possible to split the chocolate bar into k rectangles each having the same total sweetness, otherwise \\"No\\". Example: >>> can_split_chocolate(2, 2, 2, [[1, 3], [2, 2]]) \\"Yes\\" >>> can_split_chocolate(2, 2, 2, [[1, 1], [1, 2]]) \\"No\\" import pytest def test_example_case(): assert can_split_chocolate(2, 2, 2, [[1, 3], [2, 2]]) == \\"Yes\\" def test_equal_sweetness_rectangles(): assert can_split_chocolate(2, 2, 4, [[1, 1], [1, 1]]) == \\"Yes\\" def test_no_possible_split(): assert can_split_chocolate(2, 2, 2, [[1, 1], [1, 2]]) == \\"No\\" def test_single_rectangle(): assert can_split_chocolate(1, 1, 1, [[5]]) == \\"Yes\\" def test_full_split(): assert can_split_chocolate(1, 4, 4, [[1, 1, 1, 1]]) == \\"Yes\\"","solution":"def can_split_chocolate(R, C, k, sweetness): Determine if it's possible to split the chocolate bar into k rectangles with equal sweetness. total_sweetness = sum(map(sum, sweetness)) # If total sweetness is not divisible by k, then it's not possible to have k parts with equal sweetness if total_sweetness % k != 0: return \\"No\\" # Target sweetness for each part target_sweetness = total_sweetness / k def can_partition(starting_index, remaining_k, current_sum=0): if remaining_k == 0: return current_sum == 0 if current_sum > target_sweetness: return False if current_sum == target_sweetness: return can_partition(0, remaining_k - 1) for i in range(starting_index, R * C): row, col = divmod(i, C) if can_partition(i + 1, remaining_k, current_sum + sweetness[row][col]): return True return False if can_partition(0, k): return \\"Yes\\" else: return \\"No\\" # Example usage: # R, C, k = 2, 2, 2 # sweetness = [ # [1, 3], # [2, 2] # ] # Output: \\"Yes\\""},{"question":"def num_islands(grid: List[List[str]]) -> int: Finds and returns the number of islands in the given grid. >>> num_islands([['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]) == 3 >>> num_islands([['1', '1', '1'], ['0', '1', '0'], ['1', '1', '1']]) == 1 >>> num_islands([['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0']]) == 0","solution":"def num_islands(grid): Finds and returns the number of islands in the given grid. if not grid: return 0 n = len(grid) m = len(grid[0]) visited = [[False for _ in range(m)] for _ in range(n)] def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == '0' or visited[x][y]: return visited[x][y] = True dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count def islands_from_input(input_data): Parses the input and returns the grid and consists of the main logic to calculate the number of islands. lines = input_data.split('n') n, m = map(int, lines[0].split()) grid = [lines[i+1] for i in range(n)] return num_islands(grid)"},{"question":"def findSpecialElements(nums: List[int]) -> List[int]: Find all special elements in an array. A special element is an element that appears strictly more than ⌊n/3⌋ times, where n is the size of the array. Args: nums (List[int]): List of integers. Returns: List[int]: List of special elements, each element should appear only once. Example: >>> findSpecialElements([3, 2, 3, 5, 2, 2]) [2] >>> findSpecialElements([1, 2, 3]) [] >>> findSpecialElements([1, 1, 1, 2, 2, 2, 3, 3]) [1, 2] >>> findSpecialElements([4] * 10000) [4] >>> findSpecialElements([]) [] >>> findSpecialElements([1]) [1] >>> findSpecialElements([7, 7, 7, 7]) [7] pass","solution":"def findSpecialElements(nums): from collections import Counter n = len(nums) if n == 0: return [] threshold = n // 3 count = Counter(nums) return [key for key, value in count.items() if value > threshold]"},{"question":"def longest_palindromic_subsequence(S: str) -> int: Determine the length of the longest palindromic subsequence that can be formed from the string S. Parameters: S (str): The concatenation of all street names. Returns: int: The length of the longest palindromic subsequence. >>> longest_palindromic_subsequence(\\"ABBDCACB\\") 5 >>> longest_palindromic_subsequence(\\"A\\") 1 >>> longest_palindromic_subsequence(\\"AA\\") 2 >>> longest_palindromic_subsequence(\\"AB\\") 1 >>> longest_palindromic_subsequence(\\"MADAM\\") 5 >>> longest_palindromic_subsequence(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 1 >>> longest_palindromic_subsequence(\\"BBABCBCAB\\") 7 >>>","solution":"def longest_palindromic_subsequence(S): Returns the length of the longest palindromic subsequence in the string S. n = len(S) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n+1): for i in range(n - length + 1): j = i + length - 1 if S[i] == S[j]: dp[i][j] = 2 + dp[i+1][j-1] if length > 2 else 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"def closest_pair(costs, budget): Mina has a list of integers representing the costs of various products in a store. She wants to buy exactly two products such that the sum of their costs is as close as possible to a given budget. Write a function that takes an array of integers (costs) and a target integer (budget) and returns the pair of indices of the products that Mina should buy. If there are multiple pairs with the same closest sum, return any one of them. >>> closest_pair([10, 22, 28, 29, 30, 40], 54) [22, 30] >>> closest_pair([1, 3, 4, 7, 10], 15) [4, 10]","solution":"def closest_pair(costs, budget): costs = sorted(costs) left = 0 right = len(costs) - 1 closest_sum = float('inf') best_pair = [] while left < right: current_sum = costs[left] + costs[right] if abs(current_sum - budget) < abs(closest_sum - budget): closest_sum = current_sum best_pair = [costs[left], costs[right]] if current_sum < budget: left += 1 elif current_sum > budget: right -= 1 else: break return best_pair"},{"question":"def days_to_empty_tank(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Determine after how many days the water tank will be empty. Args: t : int : number of test cases test_cases : List[Tuple[int, int, int]] : a list of tuples, each containing initial capacity of the tank (C), daily water usage (U), and daily water refilling (R) Returns: List[int] : a list of integers representing the number of days after which the water tank will be empty for each test case. If the tank never gets empty, return -1. Examples: >>> days_to_empty_tank(2, [(100, 10, 5), (50, 20, 25)]) [20, -1] >>> days_to_empty_tank(1, [(50, 20, 30)]) [-1]","solution":"def days_to_empty_tank(t, test_cases): results = [] for case in test_cases: C, U, R = case if U <= R: results.append(-1) else: net_usage_per_day = U - R days = C // net_usage_per_day if C % net_usage_per_day != 0: days += 1 results.append(days) return results # Read input values for the function below: # T, and the test cases as a list of tuples for each test case (C, U, R) # For example: (2, [(100, 10, 5), (50, 20, 25)])"},{"question":"def count_stable_pairs(n: int, power_levels: List[int]) -> int: Returns the number of stable pairs in the given permutation of power levels. >>> count_stable_pairs(4, [1, 2, 3, 4]) 6 >>> count_stable_pairs(3, [10, 20, 30]) 3","solution":"def count_stable_pairs(n, power_levels): Returns the number of stable pairs in the given permutation of power levels. stable_pairs_count = 0 for i in range(n): for j in range(i + 1, n): stable_pairs_count += 1 return stable_pairs_count"},{"question":"def shortestDistance(grid: List[List[str]]) -> int: Determine the cell on the road that has the shortest total Manhattan distance to every building in the city, and return that total distance. If there are multiple cells with the same distance, return the smallest. If there are no buildings or only one building, return 0. >>> shortestDistance([['B', '.', '.'], ['.', 'B', 'B'], ['.', '.', '.']]) 4 >>> shortestDistance([['.', 'B', 'B'], ['.', '.', '.'], ['B', 'B', '.']]) 6 >>> shortestDistance([['.', '.', '.'], ['.', 'B', '.'], ['.', '.', '.']]) 0 pass # Test cases def test_shortestDistance(): assert shortestDistance([['B', '.', '.'], ['.', 'B', 'B'], ['.', '.', '.']]) == 4 def test_shortestDistance_no_buildings(): assert shortestDistance([['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) == 0 def test_shortestDistance_one_building(): assert shortestDistance([['.', '.', '.'], ['.', 'B', '.'], ['.', '.', '.']]) == 0 def test_shortestDistance_corner(): assert shortestDistance([['B', '.', '.'], ['.', '.', '.'], ['.', '.', 'B']]) == 4 def test_shortestDistance_complex(): assert shortestDistance([['.', 'B', 'B'], ['.', '.', '.'], ['B', 'B', '.']]) == 6 import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def shortestDistance(grid): from itertools import product from collections import deque rows, cols = len(grid), len(grid[0]) # Function to get all the building positions buildings = [(r, c) for r, c in product(range(rows), range(cols)) if grid[r][c] == 'B'] if len(buildings) <= 1: return 0 # No or only one building total_buildings = len(buildings) # BFS function to compute distance from buildings def bfs(start_r, start_c): visited = [[False] * cols for _ in range(rows)] queue = deque([(start_r, start_c, 0)]) # (row, col, dist) distances = [] while queue: r, c, dist = queue.popleft() if r < 0 or r >= rows or c < 0 or c >= cols or visited[r][c] or grid[r][c] == 'B': continue visited[r][c] = True # If it's a road, we can take distance into account if grid[r][c] == '.': distances.append((dist, r, c)) for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: queue.append((r + dr, c + dc, dist + 1)) return distances best_distance = float('inf') # Find the best (shortest total distance) for r, c in product(range(rows), range(cols)): if grid[r][c] == '.': total_dist = 0 for br, bc in buildings: total_dist += abs(r - br) + abs(c - bc) best_distance = min(best_distance, total_dist) return best_distance"},{"question":"def single_number(nums): Finds the single element that appears only once in the array. Every other element appears exactly twice. >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([4, -1, 2, -1, 2]) 4 >>> single_number([99]) 99 >>> single_number([i for i in range(1, 100001)] * 2 + [100001]) 100001","solution":"def single_number(nums): Finds the single element that appears only once in the array. Every other element appears exactly twice. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"def findMissing(arr, k): Finds the smallest positive integer missing in the array that is greater than or equal to k. >>> findMissing([3, 4, 2, 1, 7, 6], 5) 5 >>> findMissing([1, 2, 3, 4, 5], 3) 6","solution":"def findMissing(arr, k): Finds the smallest positive integer missing in the array and is greater than or equal to k. # Sort the array arr.sort() # Iterate through and find the smallest missing integer >= k current = k for num in arr: if num == current: current += 1 elif num > current: break return current"},{"question":"def running_total_calories(meals): Returns the running total of calories after each meal. Parameters: meals (list of int): List of calories for each meal. Returns: list of int: List of running total of calories after each meal. Example: >>> running_total_calories([200, 300, 100, 400]) [200, 500, 600, 1000] >>> running_total_calories([100]) [100] >>> running_total_calories([100, 100, 100, 100]) [100, 200, 300, 400] >>> running_total_calories([500, 300, 200, 100]) [500, 800, 1000, 1100] >>> running_total_calories([1000]) [1000] >>> running_total_calories([1, 1, 1, 1, 1]) [1, 2, 3, 4, 5]","solution":"def running_total_calories(meals): Returns the running total of calories after each meal. Parameters: meals (list of int): List of calories for each meal. Returns: list of int: List of running total of calories after each meal. running_totals = [] total = 0 for calories in meals: total += calories running_totals.append(total) return running_totals"},{"question":"def restore_string(n: int, s: str, k: int, dictionary: list) -> str: Restores the original string by replacing the corrupted characters. Parameters: n (int): the length of the string s (str): the corrupted string with '?' k (int): the number of entries in the dictionary dictionary (list): list of dictionary entries Returns: str: the restored original string >>> restore_string(5, \\"a?c?e\\", 3, [\\"abcde\\", \\"axcye\\", \\"atcbe\\"]) 'abcde' >>> restore_string(4, \\"?b?d\\", 2, [\\"abcd\\", \\"gbgd\\"]) 'abcd' >>> restore_string(2, \\"a?\\", 2, [\\"ab\\", \\"ac\\"]) 'ab' >>> restore_string(7, \\"?ello??\\", 3, [\\"helloab\\", \\"xellozy\\", \\"jellomg\\"]) 'helloab' >>> restore_string(3, \\"?a?\\", 3, [\\"zay\\", \\"baz\\", \\"faq\\"]) 'zay'","solution":"def restore_string(n, s, k, dictionary): Restores the original string by replacing the corrupted characters. Parameters: n (int): the length of the string s (str): the corrupted string with '?' k (int): the number of entries in the dictionary dictionary (list): list of dictionary entries Returns: str: the restored original string for word in dictionary: if len(word) != n: continue # Check if the word from the dictionary matches the pattern of \`s\` match = True for i in range(n): if s[i] != '?' and s[i] != word[i]: match = False break if match: return word return None # If no matching word is found, which should not be the case with valid constraints # Example usage if __name__ == \\"__main__\\": n = 5 s = \\"a?c?e\\" k = 3 dictionary = [\\"abcde\\", \\"axcye\\", \\"atcbe\\"] print(restore_string(n, s, k, dictionary)) # Output: abcde"},{"question":"from typing import List def longestStrChain(words: List[str]) -> int: Determine the length of the longest possible chain given a list of words. Each word in the chain differs by exactly one letter from the previous word in the chain, and can be formed by removing exactly one letter from the previous word. Parameters: words (List[str]): A list of strings, where each string represents a word. Returns: int: The length of the longest chain. Examples: >>> longestStrChain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) 4 >>> longestStrChain([\\"xbc\\", \\"pcxbcf\\", \\"xb\\", \\"cxbc\\", \\"pcxbc\\"]) 5","solution":"def longestStrChain(words): words.sort(key=len) longest_chain = {} max_length = 1 for word in words: longest_chain[word] = 1 for i in range(len(word)): prev = word[:i] + word[i+1:] if prev in longest_chain: longest_chain[word] = max(longest_chain[word], longest_chain[prev] + 1) max_length = max(max_length, longest_chain[word]) return max_length"},{"question":"from typing import List, Tuple def find_depth(n: int, nodes: List[Tuple[int, int, int]]) -> int: Determine the depth of the binary tree. The depth of a binary tree is the longest path from the root node to any leaf node. Args: n (int): The number of nodes in the binary tree. nodes (List[Tuple[int, int, int]]): A list where each element is a tuple (i, left[i], right[i]) describing the nodes and their children. Returns: int: The depth of the binary tree. Examples: >>> find_depth(5, [(1, 2, 3), (2, 4, -1), (3, -1, 5), (4, -1, -1), (5, -1, -1)]) 3 >>> find_depth(3, [(1, 2, -1), (2, 3, -1), (3, -1, -1)]) 3","solution":"def find_depth(n, nodes): from collections import defaultdict, deque # Build the adjacency list representation of the binary tree tree = defaultdict(list) for i, left, right in nodes: if left != -1: tree[i].append(left) if right != -1: tree[i].append(right) # Depth-first search (DFS) to calculate depth def dfs(node): if node not in tree: return 1 max_depth = 0 for child in tree[node]: max_depth = max(max_depth, dfs(child)) return 1 + max_depth # Tree is rooted at node 1 return dfs(1) # Example usage: # n = 5 # nodes = [ # (1, 2, 3), # (2, 4, -1), # (3, -1, 5), # (4, -1, -1), # (5, -1, -1) # ] # print(find_depth(n, nodes)) # Output: 3"},{"question":"def sum_even_fibonacci(limit: int) -> int: Calculate the sum of all the even Fibonacci numbers up to a given limit. >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(1) 0 >>> sum_even_fibonacci(2) 2 >>> sum_even_fibonacci(8) 10 >>> sum_even_fibonacci(34) 44 >>> sum_even_fibonacci(0) 0 >>> sum_even_fibonacci(100) 44 >>> sum_even_fibonacci(4000000) 4613732 >>> sum_even_fibonacci(-10) 0","solution":"def sum_even_fibonacci(limit): Calculate the sum of all the even Fibonacci numbers up to a given limit. :param limit: The upper bound of the range to check for even Fibonacci numbers. :return: The sum of all even Fibonacci numbers less than or equal to the limit. if limit < 2: return 0 a, b = 0, 1 sum_even = 0 while b <= limit: if b % 2 == 0: sum_even += b a, b = b, a + b return sum_even"},{"question":"def can_cross(planks, s, d): Determine if a villager can move from the start to the destination without falling into a gap between the planks. Parameters: planks: List of tuples representing the planks as (start, end) s: Starting point of the villager d: Destination point of the villager Returns: \\"Safe\\" if the villager can cross without falling into a gap, \\"Danger\\" otherwise pass def process_input(data): Process the input data to determine if villagers can cross the river. Parameters: data: List of strings representing the input data Returns: List of strings representing the output for each villager pass def test_can_cross(): assert can_cross([(1, 5), (6, 10), (12, 15)], 0, 4) == \\"Danger\\" assert can_cross([(1, 5), (6, 10), (12, 15)], 3, 9) == \\"Danger\\" assert can_cross([(1, 5), (6, 10), (12, 15)], 7, 13) == \\"Danger\\" assert can_cross([(1, 5), (6, 10), (12, 15)], 10, 14) == \\"Danger\\" assert can_cross([(0, 10)], 0, 10) == \\"Safe\\" assert can_cross([(5, 15)], 0, 10) == \\"Danger\\" assert can_cross([], 0, 10) == \\"Danger\\" def test_process_input(): data = [ \\"3\\", \\"1 5\\", \\"6 10\\", \\"12 15\\", \\"4\\", \\"0 4\\", \\"3 9\\", \\"7 13\\", \\"10 14\\", \\"0\\" ] expected_output = [\\"Danger\\", \\"Danger\\", \\"Danger\\", \\"Danger\\"] assert process_input(data) == expected_output data = [ \\"1\\", \\"0 10\\", \\"2\\", \\"0 5\\", \\"5 10\\", \\"0\\" ] expected_output = [\\"Safe\\", \\"Safe\\"] assert process_input(data) == expected_output","solution":"def can_cross(planks, s, d): Determine if a villager can move from the start to the destination without falling into a gap between the planks. Parameters: planks: List of tuples representing the planks as (start, end) s: Starting point of the villager d: Destination point of the villager Returns: \\"Safe\\" if the villager can cross without falling into a gap, \\"Danger\\" otherwise if not planks: return \\"Danger\\" # Sort and merge planks intervals planks.sort() merged_planks = [planks[0]] for current in planks[1:]: last = merged_planks[-1] if current[0] <= last[1]: merged_planks[-1] = (last[0], max(last[1], current[1])) else: merged_planks.append(current) # Check if the entire path from s to d is covered by planks for start, end in merged_planks: if start <= s <= end and start <= d <= end: return \\"Safe\\" return \\"Danger\\" def process_input(data): Process the input data to determine if villagers can cross the river. Parameters: data: List of strings representing the input data Returns: List of strings representing the output for each villager results = [] index = 0 while index < len(data): n = int(data[index].strip()) if n == 0: break index += 1 planks = [] for i in range(n): lx, ly = map(int, data[index].strip().split()) planks.append((lx, ly)) index += 1 m = int(data[index].strip()) index += 1 for i in range(m): sx, dx = map(int, data[index].strip().split()) result = can_cross(planks, sx, dx) results.append(result) index += 1 return results"},{"question":"import itertools from typing import List, Tuple def manhattan_distance(x1: int, y1: int, x2: int, y2: int) -> int: Calculate the Manhattan distance between two points. return abs(x1 - x2) + abs(y1 - y2) def find_shortest_route(x0: int, y0: int, addresses: List[Tuple[int, int]]) -> int: Find the shortest possible route that starts at the warehouse, visits each delivery address exactly once, and returns to the warehouse. Args: x0: The x coordinate of the warehouse. y0: The y coordinate of the warehouse. addresses: A list of tuples representing the coordinates of the delivery addresses. Returns: The minimum possible distance of the route. >>> find_shortest_route(0, 0, [(1, 1), (2, 2), (3, 3)]) 12 >>> find_shortest_route(0, 0, [(1, 1)]) 4 pass def test_example_case(): x0, y0 = 0, 0 addresses = [(1, 1), (2, 2), (3, 3)] assert find_shortest_route(x0, y0, addresses) == 12 def test_single_address(): x0, y0 = 0, 0 addresses = [(1, 1)] assert find_shortest_route(x0, y0, addresses) == 4 def test_two_addresses(): x0, y0 = 0, 0 addresses = [(1, 1), (4, 4)] assert find_shortest_route(x0, y0, addresses) == 16 def test_all_same_position(): x0, y0 = 0, 0 addresses = [(0, 0), (0, 0), (0, 0)] assert find_shortest_route(x0, y0, addresses) == 0 def test_large_coordinates(): x0, y0 = 0, 0 addresses = [(1000000, 0), (0, 1000000)] assert find_shortest_route(x0, y0, addresses) == 4000000","solution":"import itertools def manhattan_distance(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) def find_shortest_route(x0, y0, addresses): min_distance = float('inf') address_permutations = itertools.permutations(addresses) for perm in address_permutations: current_distance = 0 current_x, current_y = x0, y0 for x, y in perm: current_distance += manhattan_distance(current_x, current_y, x, y) current_x, current_y = x, y current_distance += manhattan_distance(current_x, current_y, x0, y0) if current_distance < min_distance: min_distance = current_distance return min_distance"},{"question":"def generate_pattern(N: int) -> str: Generate a pattern with stars followed by spaces as described in the problem statement. >>> generate_pattern(1) '*' >>> generate_pattern(2) '* n**' >>> generate_pattern(3) '* n** n***' >>> generate_pattern(4) '* n** n*** n****' >>> generate_pattern(5) '* n** n*** n**** n*****' >>> generate_pattern(10) '* n** n*** n**** n***** n****** n******* n******** n********* n**********' >>> generate_pattern(100) // For N = 100, the pattern will be huge, representing successively larger lines // starting with one star and ending with 100 stars and appropriate spaces at the end of lines.","solution":"def generate_pattern(N): result = [] for i in range(1, N+1): line = '*' * i + ' ' * (N - i) result.append(line) return 'n'.join(result)"},{"question":"def most_frequent_hashtag(posts: List[str]) -> str: A function that takes a list of strings (posts) and returns the most frequently used valid hashtag. If there is a tie, return the hashtag that appears first in the list of posts. >>> most_frequent_hashtag([\\"#hello world this is a #test post\\", \\"#hello again\\", \\"#test the new feature\\", \\"this is a normal sentence with no hashtags\\", \\"another post with #hello\\"]) '#hello' >>> most_frequent_hashtag([\\"#first post\\", \\"#second post\\", \\"#first again\\", \\"#second\\"]) '#first' >>> most_frequent_hashtag([\\"this post has no hashtags\\", \\"neither does this one\\"]) None >>> most_frequent_hashtag([\\"#unique1\\", \\"#unique2\\", \\"#unique3\\"]) '#unique1' >>> most_frequent_hashtag([]) None","solution":"def most_frequent_hashtag(posts): from collections import Counter import re hashtag_counter = Counter() hashtag_pattern = re.compile(r\\"#w+\\") for post in posts: hashtags = hashtag_pattern.findall(post) hashtag_counter.update(hashtags) if not hashtag_counter: return None most_common_hashtag = hashtag_counter.most_common(1)[0][0] return most_common_hashtag"},{"question":"def maximalSubstring(s: str, k: int) -> int: Finds the length of the longest substring that contains at most k distinct characters. Examples: >>> maximalSubstring(\\"araaci\\", 2) 4 >>> maximalSubstring(\\"araaci\\", 1) 2 >>> maximalSubstring(\\"cbbebi\\", 3) 5 >>> maximalSubstring(\\"cbbebi\\", 10) 6","solution":"def maximalSubstring(s: str, k: int) -> int: Finds the length of the longest substring that contains at most k distinct characters. if k == 0: return 0 window_start, max_length, char_frequency = 0, 0, {} for window_end in range(len(s)): right_char = s[window_end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"from typing import List def min_operations_to_make_equal(arr: List[int]) -> int: Returns the minimum number of operations to make all elements of the array equal by replacing elements with their GCD. >>> min_operations_to_make_equal([4, 8]) 1 >>> min_operations_to_make_equal([2, 3, 6]) 2 >>> min_operations_to_make_equal([7, 7, 7, 7]) 0 def process_test_cases(test_cases: List[List[int]]) -> List[int]: Processes multiple test cases to determine the number of operations required for each. >>> process_test_cases([[4, 8], [2, 3, 6], [7, 7, 7, 7]]) [1, 2, 0]","solution":"from math import gcd from functools import reduce def min_operations_to_make_equal(arr): Returns the minimum number of operations to make all elements of the array equal by replacing elements with their GCD. # Calculate the GCD of the entire array array_gcd = reduce(gcd, arr) if array_gcd == arr[0] and all(x == arr[0] for x in arr): return 0 else: return len(arr) - 1 def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(min_operations_to_make_equal(arr)) return results"},{"question":"def trapWater(arr: List[int], n: int) -> int: Returns the maximum amount of water that can be trapped. >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], 12) 6 >>> trapWater([4, 2, 0, 3, 2, 5], 6) 9","solution":"def trapWater(arr, n): Returns the maximum amount of water that can be trapped. if n <= 2: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) water = 0 for i in range(n): water += min(left_max[i], right_max[i]) - arr[i] return water"},{"question":"def max_profit(N: int, prices: List[int]) -> int: Returns the maximum possible profit from a single buy and sell transaction. The input consists of an integer N (2 ≤ N ≤ 200) representing the number of days, followed by a list of N integers representing the stock prices on those days. >>> max_profit(6, [7, 1, 5, 3, 6, 4]) 5 >>> max_profit(5, [7, 6, 4, 3, 1]) 0","solution":"def max_profit(N, prices): Returns the maximum possible profit from a single buy and sell transaction. if N <= 1: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def can_form_palindrome(s: str) -> str: Determine if any permutation of the string can form a palindrome. >>> can_form_palindrome(\\"civic\\") 'YES' >>> can_form_palindrome(\\"ivicc\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO' >>> can_form_palindrome(\\"a\\") 'YES' >>> can_form_palindrome(\\"aaaabbbbccc\\") 'YES'","solution":"def can_form_palindrome(s): Determine if any permutation of the string can form a palindrome. from collections import Counter # Count occurrences of each character char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one odd-count character if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def max_distance_and_count(n: int, points: List[int]) -> Tuple[int, int]: Find the largest distance between any two points on the number line and the number of such pairs of points that have this maximum distance. >>> max_distance_and_count(6, [1, 2, 4, 6, 10, 12]) (11, 1) >>> max_distance_and_count(3, [-5, 0, 5]) (10, 1)","solution":"def max_distance_and_count(n, points): if n < 2: return 0, 0 # Not enough points to find any pairs min_point = min(points) max_point = max(points) max_distance = max_point - min_point return max_distance, 1"},{"question":"from typing import List def can_rearrange_no_adjacent(S: str) -> str: Determine if the string can be rearranged such that no two adjacent characters are the same. :param S: str - The input string. :return: str - \\"YES\\" if the string can be rearranged as needed, otherwise \\"NO\\". >>> can_rearrange_no_adjacent(\\"aaabb\\") \\"YES\\" >>> can_rearrange_no_adjacent(\\"aaab\\") \\"NO\\"","solution":"from collections import Counter def can_rearrange_no_adjacent(S): Determine if the string can be rearranged such that no two adjacent characters are the same. :param S: str - The input string. :return: str - \\"YES\\" if the string can be rearranged as needed, otherwise \\"NO\\". freq = Counter(S) max_freq = max(freq.values()) if max_freq > (len(S) + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"def max_unique_problems(n: int, m: int, participants: List[str]) -> int: Returns the maximum number of problems uniquely solved by at least one participant def test_max_unique_problems_case1(): n, m = 3, 5 participants = [ \\"10101\\", \\"11000\\", \\"01110\\" ] assert max_unique_problems(n, m, participants) == 4 def test_max_unique_problems_case2(): n, m = 2, 4 participants = [ \\"1010\\", \\"0101\\" ] assert max_unique_problems(n, m, participants) == 4 def test_max_unique_problems_case3(): n, m = 4, 6 participants = [ \\"111111\\", \\"000000\\", \\"101010\\", \\"010101\\" ] assert max_unique_problems(n, m, participants) == 6 def test_max_unique_problems_case4(): n, m = 3, 3 participants = [ \\"100\\", \\"010\\", \\"001\\" ] assert max_unique_problems(n, m, participants) == 2 def test_max_unique_problems_case5(): n, m = 1, 5 participants = [ \\"11111\\" ] assert max_unique_problems(n, m, participants) == 0","solution":"def max_unique_problems(n, m, participants): Returns the maximum number of problems uniquely solved by at least one participant max_unique = 0 for i in range(n): for j in range(i + 1, n): set_i = set(idx for idx, ch in enumerate(participants[i]) if ch == '1') set_j = set(idx for idx, ch in enumerate(participants[j]) if ch == '1') unique_problems = len(set_i.symmetric_difference(set_j)) if unique_problems > max_unique: max_unique = unique_problems return max_unique"},{"question":"def max_memory_usage_diff(test_cases): Given the number of test cases with memory usage values, returns the maximum difference between any two memory usage points such that the higher usage comes after the lower usage. results = [] # Implement the function here. return results def process_input(input_data): Parses the input data, processes each test case, and returns the output. Args: input_data (str): The input data as a string. Returns: List[int]: A list of the maximum differences for each test case. input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) memory_usages = list(map(int, input_lines[index + 1].split())) test_cases.append((N, memory_usages)) index += 2 return max_memory_usage_diff(test_cases) def test_max_memory_usage_diff(): input_data = \\"2n5n3 1 4 8 7n4n15 10 8 7n\\" expected_output = [7, 0] assert process_input(input_data) == expected_output input_data = \\"1n3n2 3 10\\" expected_output = [8] assert process_input(input_data) == expected_output input_data = \\"1n2n1 2\\" expected_output = [1] assert process_input(input_data) == expected_output input_data = \\"3n5n7 1 5 3 6 4n3n7 6 4n5n1 2 3 4 5\\" expected_output = [5, 0, 4] assert process_input(input_data) == expected_output input_data = \\"1n5n1 2 3 4 5\\" expected_output = [4] assert process_input(input_data) == expected_output input_data = \\"1n5n5 4 3 2 1\\" expected_output = [0] assert process_input(input_data) == expected_output","solution":"def max_memory_usage_diff(test_cases): Given the number of test cases with memory usage values, returns the maximum difference between any two memory usage points such that the higher usage comes after the lower usage. results = [] for case in test_cases: n, memory_usages = case if n < 2: results.append(0) continue min_usage = memory_usages[0] max_diff = 0 for i in range(1, n): current_diff = memory_usages[i] - min_usage if current_diff > max_diff: max_diff = current_diff if memory_usages[i] < min_usage: min_usage = memory_usages[i] results.append(max_diff) return results # Function to parse input and call the main function for easier testing def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) memory_usages = list(map(int, input_lines[index + 1].split())) test_cases.append((N, memory_usages)) index += 2 return max_memory_usage_diff(test_cases)"},{"question":"def smallest_distinct_substring(s: str) -> int: Returns the smallest number of distinct characters in any non-empty substring of \`s\` such that every character in \`s\` appears in at least one of those substrings. >>> smallest_distinct_substring(\\"abcde\\") 5 >>> smallest_distinct_substring(\\"abac\\") 3 >>> smallest_distinct_substring(\\"a\\") 1 >>> smallest_distinct_substring(\\"aaaa\\") 1 >>> smallest_distinct_substring(\\"abcabcabc\\") 3 >>> smallest_distinct_substring(\\"\\") 0 >>> smallest_distinct_substring(\\"abababab\\") 2","solution":"def smallest_distinct_substring(s): Returns the smallest number of distinct characters in any non-empty substring of \`s\` such that every character in \`s\` appears in at least one of those substrings. from collections import Counter # if string is empty, return 0 if not s: return 0 # count frequency of each character in the string freq = Counter(s) # return the number of unique characters (which is the smallest number of distinct chars) return len(freq)"},{"question":"def largest_sum_subarray(arr): Returns the largest sum of a contiguous subarray within the given array. >>> largest_sum_subarray([1, 2, 3, 4, 5]) == 15 >>> largest_sum_subarray([-1, -2, -3, -4, -5]) == -1 >>> largest_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> largest_sum_subarray([3]) == 3 >>> largest_sum_subarray([-3]) == -3 >>> largest_sum_subarray([]) == IndexError","solution":"def largest_sum_subarray(arr): Returns the largest sum of a contiguous subarray within the given array. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def DistinctElements(nums: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array \`nums\` and a list of \`queries\`, this function returns the number of distinct elements in the sub-array for each query. >>> DistinctElements([4, 1, 2, 2, 3], [(1, 5), (2, 4)]) [4, 2] >>> DistinctElements([1, 2, 3, 4, 5], [(1, 3)]) [3] >>> DistinctElements([1, 2, 3, 4, 5], [(3, 3)]) [1] >>> DistinctElements([3, 3, 3, 3, 3], [(1, 5)]) [1] >>> DistinctElements([1, 2, 1, 3, 1, 4], [(1, 3), (2, 5), (1, 6)]) [2, 3, 4] >>> DistinctElements([1], [(1, 1)]) [1] >>> DistinctElements([5, 2, 4, 4, 3, 1, 6], [(1, 7)]) [6] >>> DistinctElements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [(3, 6), (1, 10)]) [4, 10]","solution":"def DistinctElements(nums, queries): Given an array \`nums\` and a list of \`queries\`, this function returns the number of distinct elements in the sub-array for each query. results = [] for l, r in queries: sub_array = nums[l-1:r] distinct_count = len(set(sub_array)) results.append(distinct_count) return results"},{"question":"def peak_energy_level(n, pulses): Calculate and return the peak energy level observed within the given time span. Parameters: n (int): The number of energy pulses. pulses (List[Tuple[int, int, int]]): A list of tuples, each tuple contains three integers si (start time), ei (end time), and pi (energy level) of pulse i. Returns: int: The peak energy level observed at any time slice. ----- Example Usage ----- >>> peak_energy_level(3, [(1, 4, 10), (2, 5, 7), (3, 6, 5)]) 22 >>> peak_energy_level(2, [(1, 2, 5), (3, 4, 7)]) 7 pass from solution import peak_energy_level def test_sample_input_1(): n = 3 pulses = [(1, 4, 10), (2, 5, 7), (3, 6, 5)] assert peak_energy_level(n, pulses) == 22 def test_non_overlapping_pulses(): n = 2 pulses = [(1, 2, 5), (3, 4, 7)] assert peak_energy_level(n, pulses) == 7 def test_fully_overlapping_pulses(): n = 3 pulses = [(1, 6, 3), (1, 6, 5), (1, 6, 2)] assert peak_energy_level(n, pulses) == 10 def test_single_pulse(): n = 1 pulses = [(1, 3, 8)] assert peak_energy_level(n, pulses) == 8 def test_edge_cases(): n = 3 pulses = [(0, 1, 1), (1, 2, 2), (2, 3, 3)] assert peak_energy_level(n, pulses) == 3","solution":"def peak_energy_level(n, pulses): from collections import defaultdict time_energy_map = defaultdict(int) for s, e, p in pulses: time_energy_map[s] += p time_energy_map[e] -= p current_energy = 0 max_energy = 0 for time in sorted(time_energy_map.keys()): current_energy += time_energy_map[time] max_energy = max(max_energy, current_energy) return max_energy"},{"question":"class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None def findLargestSmallerValue(root, x, N): Function to find the largest value in the BST that is smaller than or equal to x. Args: root (TreeNode): The root of the binary search tree. x (int): The value to compare against. N (int): The number of nodes in the BST. Returns: int: The largest value in the BST that is smaller than or equal to x, or -1 if no such value exists. Examples: >>> root = TreeNode(5) >>> root.left = TreeNode(2) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> findLargestSmallerValue(root, 4, 5) 3 >>> root = TreeNode(8) >>> root.left = TreeNode(3) >>> root.right = TreeNode(10) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(6) >>> findLargestSmallerValue(root, 7, 6) 6 pass","solution":"class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None def findLargestSmallerValue(root, x, N): Function to find the largest value in the BST that is smaller than or equal to x. result = -1 while root: if root.val <= x: result = root.val root = root.right else: root = root.left return result"},{"question":"def mark_highest_sale(sales): Takes a list of 7 unique integers representing daily sales for a week. Returns a list of the sales in ascending order with the highest sale marked with an asterisk. Parameters: sales (List[int]): A list of 7 unique integers representing daily sales. Returns: List[Union[int, str]]: A list of 7 integers in ascending order, with the highest sale marked with an asterisk. Examples: >>> mark_highest_sale([3050, 7498, 1234, 9876, 4321, 5678, 8765]) [1234, 3050, 4321, 5678, 7498, 8765, \\"9876*\\"] >>> mark_highest_sale([12345, 23456, 34567, 45678, 56789, 67890, 78901]) [12345, 23456, 34567, 45678, 56789, 67890, \\"78901*\\"] >>> mark_highest_sale([11000, 21000, 31000, 41000, 51000, 60000, 70000]) [11000, 21000, 31000, 41000, 51000, 60000, \\"70000*\\"] >>> mark_highest_sale([8000, 14000, 22000, 47000, 33000, 52000, 1000]) [1000, 8000, 14000, 22000, 33000, 47000, \\"52000*\\"] >>> mark_highest_sale([50000, 7000, 12000, 24000, 35000, 47000, 18000]) [7000, 12000, 18000, 24000, 35000, 47000, \\"50000*\\"]","solution":"def mark_highest_sale(sales): Takes a list of 7 unique integers representing daily sales for a week. Returns a list of the sales in ascending order with the highest sale marked with an asterisk. # Find the highest sale highest_sale = max(sales) # Sort the sales in ascending order sorted_sales = sorted(sales) # Create the result list, marking the highest sale with an asterisk result = [] for sale in sorted_sales: if sale == highest_sale: result.append(f\\"{sale}*\\") else: result.append(sale) return result"},{"question":"def find_winning_team(scores: List[List[int]]) -> int: Finds the winning team based on the given scores. Parameters: - scores: List of lists, where each sublist contains three integers representing the scores of a team members. Returns: - An integer representing the 1-based index of the winning team. Examples: >>> find_winning_team([[50, 60, 70], [80, 40, 60], [90, 80, 70]]) 3 >>> find_winning_team([[100, 100, 100], [99, 100, 100]]) 1","solution":"def find_winning_team(scores): Finds the winning team based on the given scores. Parameters: - scores: List of lists, where each sublist contains three integers representing the scores of a team members. Returns: - An integer representing the 1-based index of the winning team. def team_ranking_key(team_scores): return (sum(team_scores)/3, max(team_scores), sorted(team_scores, reverse=True)[1]) best_index = 0 best_team = scores[0] for i in range(1, len(scores)): if team_ranking_key(scores[i]) > team_ranking_key(best_team): best_index = i best_team = scores[i] return best_index + 1 # +1 to convert 0-based index to 1-based index"},{"question":"def minimum_tables(N, M, A): Determine the minimum number of tables required to seat all attendees such that all tables are either filled to capacity or one seat short of the maximum capacity. :param N: Number of tables :param M: Maximum capacity of each table :param A: Total number of attendees :return: Minimum number of tables required >>> minimum_tables(5, 4, 10) 3 >>> minimum_tables(10, 7, 70) 10 >>> minimum_tables(3, 5, 12) 3","solution":"def minimum_tables(N, M, A): Determine the minimum number of tables required to seat all attendees such that all tables are either filled to capacity or one seat short of the maximum capacity. :param N: Number of tables :param M: Maximum capacity of each table :param A: Total number of attendees :return: Minimum number of tables required if A <= 0 or M <= 0 or N <= 0: return 0 tables_filled_to_capacity = A // M remaining_attendees = A % M if remaining_attendees == 0: return tables_filled_to_capacity if remaining_attendees == M - 1: return tables_filled_to_capacity + 1 else: tables_needed = (A + M - 1) // M return tables_needed # Read input def process_input(): import sys input = sys.stdin.read() lines = input.strip().split('n') results = [] i = 0 while i < len(lines): if lines[i] == '0': break N, M = map(int, lines[i].split()) A = int(lines[i + 1]) results.append(minimum_tables(N, M, A)) i += 2 for result in results: print(result)"},{"question":"def can_travel_and_min_flights(n: int, m: int, flights: List[Tuple[int, int]]) -> int: Given n cities and m direct flights between them, determine if it is possible to travel between any two cities using only the given flights. If possible, compute the minimum number of flights required to visit all cities starting from any city. >>> can_travel_and_min_flights(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 3 >>> can_travel_and_min_flights(4, 2, [(1, 2), (2, 3)]) -1","solution":"def bfs(start, adj_list, visited): Perform BFS on the graph to mark all reachable nodes from the start node. queue = [start] while queue: node = queue.pop(0) for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) def can_travel_and_min_flights(n, m, flights): from collections import defaultdict if n == 1: return 0 # Only one city, no flights needed. adj_list = defaultdict(list) # Construct the adjacency list. for u, v in flights: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (n + 1) # Perform BFS from city 1. visited[1] = True bfs(1, adj_list, visited) # Check if all cities are visited. if not all(visited[1:]): return -1 # Not all cities are reachable. # If all cities are connected, the number of flights needed is (n - 1) return n - 1"},{"question":"def generate_spiral_matrix(n): Generates an n x n spiral matrix filled with numbers from 1 to n^2 in a clockwise manner. >>> generate_spiral_matrix(3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> generate_spiral_matrix(4) [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] >>> generate_spiral_matrix(1) [ [1] ] >>> generate_spiral_matrix(0) [] >>> generate_spiral_matrix(2) [ [1, 2], [4, 3] ] >>> generate_spiral_matrix(5) [ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ]","solution":"def generate_spiral_matrix(n): Generates an n x n spiral matrix filled with numbers from 1 to n^2 in a clockwise manner. if n <= 0: return [] # Initialize matrix matrix = [[0]*n for _ in range(n)] num = 1 left, right, top, bottom = 0, n-1, 0, n-1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def sortArrayEvenOdd(arr: List[int]) -> List[int]: Sorts an array such that all even numbers appear before all odd numbers while maintaining the relative order of both even and odd numbers. >>> sortArrayEvenOdd([3, 1, 2, 4, 7, 6]) [2, 4, 6, 3, 1, 7] >>> sortArrayEvenOdd([4, 2, 5, 3, 1]) [4, 2, 5, 3, 1]","solution":"def sortArrayEvenOdd(arr): Sorts an array such that all even numbers appear before all odd numbers while maintaining the relative order of both even and odd numbers. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"from typing import List def max_trapped_water(heights: List[int]) -> int: Calculate the maximum area of water that can be trapped between buildings. >>> max_trapped_water([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_trapped_water([3, 9, 3, 4, 7, 2, 12, 6]) 45 >>> max_trapped_water([1, 1]) 1 >>> max_trapped_water([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 25 >>> max_trapped_water([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 25 >>> max_trapped_water([5, 5, 5, 5, 5]) 20 >>> max_trapped_water([1, 0, 0, 0, 1]) 4 # Implement the function here","solution":"def max_trapped_water(heights): Returns the maximum area of water that can be trapped between the buildings. left = 0 right = len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left area = height * width max_area = max(max_area, area) # Move the pointer which is at the smaller height if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def max_equilateral_triangles(N: int, sticks: List[int]) -> int: Determines the maximum number of equilateral triangles that can be formed using the given sticks. Parameters: N (int): The number of sticks. sticks (list): List of stick lengths. Returns: int: The maximum number of equilateral triangles. >>> max_equilateral_triangles(8, [3, 3, 3, 3, 3, 3, 3, 3]) 2 >>> max_equilateral_triangles(5, [1, 1, 1, 2, 2]) 1 >>> max_equilateral_triangles(4, [5, 5, 5, 5]) 1","solution":"def max_equilateral_triangles(N, sticks): Determines the maximum number of equilateral triangles that can be formed using the given sticks. Parameters: N (int): The number of sticks. sticks (list): List of stick lengths. Returns: int: The maximum number of equilateral triangles. from collections import Counter stick_counts = Counter(sticks) triangles = 0 for count in stick_counts.values(): triangles += count // 3 return triangles"},{"question":"def can_partition_array(n: int, t: int, arr: List[int]) -> str: Determines whether it is possible to partition the array into two subsets such that the sum of the elements in both subsets is less than or equal to t. Parameters: n (int): Number of elements in the array. t (int): The threshold value for the sum of each subset. arr (list): List of positive integers. Returns: str: \\"YES\\" if the partition is possible, otherwise \\"NO\\". Examples: >>> can_partition_array(4, 10, [2, 4, 6, 8]) \\"YES\\" >>> can_partition_array(3, 5, [2, 3, 8]) \\"NO\\"","solution":"def can_partition_array(n, t, arr): Determines whether it is possible to partition the array into two subsets such that the sum of the elements in both subsets is less than or equal to t. Parameters: n (int): Number of elements in the array. t (int): The threshold value for the sum of each subset. arr (list): List of positive integers. Returns: str: \\"YES\\" if the partition is possible, otherwise \\"NO\\". total_sum = sum(arr) # If the total sum of the array is greater than 2 * t, it's impossible to partition if total_sum > 2 * t: return \\"NO\\" # Implementing a simple DP solution for subset sum problem possible_sums = [False] * (total_sum + 1) possible_sums[0] = True for num in arr: for j in range(total_sum, num - 1, -1): if possible_sums[j - num]: possible_sums[j] = True for s in range(min(total_sum, t) + 1): if possible_sums[s] and total_sum - s <= t: return \\"YES\\" return \\"NO\\""},{"question":"import re def valid_hex_color(s: str) -> bool: Returns True if the given string s is a valid hexadecimal color code, False otherwise. A valid hexadecimal color code starts with '#' followed by exactly six characters (0-9, A-F, a-f). >>> valid_hex_color(\\"#1A2B3C\\") True >>> valid_hex_color(\\"#123ABC\\") True >>> valid_hex_color(\\"#123abG\\") False >>> valid_hex_color(\\"123ABC\\") False >>> valid_hex_color(\\"#1A2B3C9\\") False >>> valid_hex_color(\\"#1A2B\\") False","solution":"import re def valid_hex_color(s): Returns True if the given string s is a valid hexadecimal color code, False otherwise. A valid hexadecimal color code starts with '#' followed by exactly six characters (0-9, A-F, a-f). pattern = re.compile(r'^#[0-9A-Fa-f]{6}') return bool(pattern.match(s))"},{"question":"def encode_morse(message: str) -> str: Encodes a given message into Morse code. >>> encode_morse(\\"HELLO\\") \\".... . .-.. .-.. ---\\" >>> encode_morse(\\"HELLO WORLD\\") \\".... . .-.. .-.. --- | .-- --- .-. .-.. -..\\" >>> encode_morse(\\"A B\\") \\".- | -...\\" >>> encode_morse(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") ( \\".- -... -.-. -.. . ..-. --. .... .. .--- -.- .-.. -- -.\\" \\" --- .--. --.- .-. ... - ..- ...- .-- -..- -.-- --..\\") >>> encode_morse(\\"\\") \\"\\"","solution":"def encode_morse(message): Encodes a given message into Morse code. morse_code = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', ' ': '|' } encoded_message = ' '.join(morse_code[char] for char in message) return encoded_message"},{"question":"from typing import List, Tuple def min_operations_to_convert(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform string s1 into string s2. >>> min_operations_to_convert(\\"intention\\", \\"execution\\") 5 >>> min_operations_to_convert(\\"horse\\", \\"ros\\") 3 >>> min_operations_to_convert(\\"abc\\", \\"def\\") 3 pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes a list of test cases and returns a list of results. >>> test_cases = [(\\"intention\\", \\"execution\\"), (\\"horse\\", \\"ros\\"), (\\"abc\\", \\"def\\")] >>> process_test_cases(test_cases) [5, 3, 3] pass","solution":"def min_operations_to_convert(s1, s2): Returns the minimum number of operations required to transform string s1 into string s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Min. operations = j (all insertions) elif j == 0: dp[i][j] = i # Min. operations = i (all deletions) elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n] def process_test_cases(test_cases): Processes a list of test cases and returns a list of results. results = [] for s1, s2 in test_cases: results.append(min_operations_to_convert(s1, s2)) return results"},{"question":"def binarySearch(A, X): Perform binary search to find the index of X in array A. Parameters: A (list of int): Sorted array of distinct integers. X (int): The integer to find in the array. Returns: int: The index of X in the array, or -1 if X is not found. Examples: >>> binarySearch([1, 3, 5, 7, 9, 11], 7) 3 >>> binarySearch([2, 4, 6, 8, 10, 12, 14], 5) -1","solution":"def binarySearch(A, X): Perform binary search to find the index of X in array A. Parameters: A (list of int): Sorted array of distinct integers. X (int): The integer to find in the array. Returns: int: The index of X in the array, or -1 if X is not found. left, right = 0, len(A) - 1 while left <= right: mid = left + (right - left) // 2 # To prevent potential overflow if A[mid] == X: return mid elif A[mid] < X: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def sum_and_adjust(arr1, arr2): Returns a new array with element-wise sum of arr1 and arr2. If the sum is odd, replace it with the next even number. >>> sum_and_adjust([1, 2, 3], [4, 5, 6]) [6, 8, 10] >>> sum_and_adjust([2, 4, 6], [1, 3, 5]) [4, 8, 12] >>> sum_and_adjust([1, 1, 1], [1, 1, 1]) [2, 2, 2]","solution":"def sum_and_adjust(arr1, arr2): Returns a new array with element-wise sum of arr1 and arr2. If the sum is odd, replace it with the next even number. result = [] for a, b in zip(arr1, arr2): temp_sum = a + b if temp_sum % 2 != 0: temp_sum += 1 result.append(temp_sum) return result"},{"question":"def max_subarray_sum(arr): Function to find the sum of the contiguous subarray which has the largest sum. Uses Kadane's algorithm to find the maximum sum subarray. >>> max_subarray_sum([1, 2, 3, -2, 5]) == 9 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([4, -1, 2, 1]) == 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([-1, -2, -3, 0]) == 0 >>> max_subarray_sum([0, -3, 1, 1]) == 2 >>> max_subarray_sum([0, -3, 0, -2]) == 0 # Function implementation here def process_test_cases(test_cases): Process multiple test cases and return the results as a list. Each test case contains an integer N (the size of the array) and the array itself. >>> test_cases = [(5, [1, 2, 3, -2, 5]), (4, [-1, -2, -3, -4])] >>> process_test_cases(test_cases) == [9, -1] >>> test_cases = [(3, [2, -1, 2]), (2, [1, 2])] >>> process_test_cases(test_cases) == [3, 3] # Function implementation here","solution":"def max_subarray_sum(arr): Function to find the sum of the contiguous subarray which has the largest sum. Uses Kadane's algorithm to find the maximum sum subarray. max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): results = [] for N, arr in test_cases: results.append(max_subarray_sum(arr)) return results"},{"question":"def compute_sums(m: int, alice_numbers: List[int], bob_numbers: List[int]) -> Tuple[int, int]: Computes the sum of numbers chosen by Alice and Bob. Arguments: m - integer, number of rounds alice_numbers - list of integers, numbers chosen by Alice bob_numbers - list of integers, numbers chosen by Bob Returns: A tuple of two integers: (sum of Alice's numbers, sum of Bob's numbers) >>> compute_sums(3, [1, 3, 5], [6, 4, 2]) (9, 12) >>> compute_sums(4, [1, 2, 3, 4], [8, 7, 6, 5]) (10, 26)","solution":"def compute_sums(m, alice_numbers, bob_numbers): Computes the sum of numbers chosen by Alice and Bob. Arguments: m - integer, number of rounds alice_numbers - list of integers, numbers chosen by Alice bob_numbers - list of integers, numbers chosen by Bob Returns: A tuple of two integers: (sum of Alice's numbers, sum of Bob's numbers) sum_alice = sum(alice_numbers) sum_bob = sum(bob_numbers) return sum_alice, sum_bob"},{"question":"class LogSystem: The LogSystem class is used to store log messages with their timestamp and severity, and to query the highest severity score within a given time range. Example usage: >>> log_system = LogSystem() >>> log_system.add(1, 5) >>> log_system.add(10, 3) >>> log_system.add(15, 7) >>> log_system.query(1, 10) 5 >>> log_system.query(1, 15) 7 >>> log_system = LogSystem() >>> log_system.query(1, 10) -1 >>> log_system = LogSystem() >>> log_system.add(2, 4) >>> log_system.add(8, 10) >>> log_system.query(1, 7) 4 >>> log_system.query(5, 12) 10 def __init__(self): self.logs = [] def add(self, timestamp: int, severity: int): This function adds a new log with the given timestamp and severity. pass def query(self, start_time: int, end_time: int) -> int: This function returns the highest severity score within the given time range. pass","solution":"class LogSystem: def __init__(self): self.logs = [] def add(self, timestamp, severity): self.logs.append((timestamp, severity)) def query(self, start_time, end_time): max_severity = -1 for timestamp, severity in self.logs: if start_time <= timestamp <= end_time: if severity > max_severity: max_severity = severity return max_severity"},{"question":"def most_active_user(users, interactions): Returns the name of the most active user based on the number of interactions initiated. Parameters: users (list): List of dictionaries where each dictionary contains 'id' and 'name'. interactions (list): List of dictionaries where each dictionary contains 'from_user_id', 'to_user_id', and 'interaction_type'. Returns: str: The name of the most active user. Example: >>> users = [ >>> {'id': 1, 'name': 'Alice'}, >>> {'id': 2, 'name': 'Bob'}, >>> {'id': 3, 'name': 'Charlie'} >>> ] >>> interactions = [ >>> {'from_user_id': 1, 'to_user_id': 2, 'interaction_type': 'like'}, >>> {'from_user_id': 2, 'to_user_id': 1, 'interaction_type': 'comment'}, >>> {'from_user_id': 1, 'to_user_id': 3, 'interaction_type': 'follow'}, >>> {'from_user_id': 1, 'to_user_id': 2, 'interaction_type': 'like'} >>> ] >>> most_active_user(users, interactions) 'Alice'","solution":"def most_active_user(users, interactions): Returns the name of the most active user based on the number of interactions initiated. Parameters: users (list): List of dictionaries where each dictionary contains 'id' and 'name'. interactions (list): List of dictionaries where each dictionary contains 'from_user_id', 'to_user_id', and 'interaction_type'. Returns: str: The name of the most active user. # Dictionary to count the number of interactions initiated by each user user_interaction_count = {user['id']: 0 for user in users} # Counting the number of interactions initiated by each user for interaction in interactions: from_user_id = interaction['from_user_id'] if from_user_id in user_interaction_count: user_interaction_count[from_user_id] += 1 # Finding the most active user max_interactions = -1 most_active_user_id = None for user in users: user_id = user['id'] if user_interaction_count[user_id] > max_interactions: max_interactions = user_interaction_count[user_id] most_active_user_id = user_id # Return the name of the most active user for user in users: if user['id'] == most_active_user_id: return user['name']"},{"question":"import math from typing import List, Tuple def non_overlapping_circles(N: int, circles: List[Tuple[int, int, int]]) -> str: Check if it is possible to place all N circles defined by their center coordinates and radius without overlapping. Args: N (int): the number of circles circles (list of tuples): (x_i, y_i, r_i) for each circle's center coordinates and radius Returns: str: \\"YES\\" if no circles overlap, otherwise \\"NO\\" >>> non_overlapping_circles(3, [(0, 0, 1), (3, 3, 1), (6, 0, 1)]) \\"YES\\" >>> non_overlapping_circles(3, [(0, 0, 2), (3, 0, 2), (1, 1, 1)]) \\"NO\\"","solution":"import math def non_overlapping_circles(N, circles): Check if it is possible to place all N circles defined by their center coordinates and radius without overlapping. Args: N (int): the number of circles circles (list of tuples): (x_i, y_i, r_i) for each circle's center coordinates and radius Returns: str: \\"YES\\" if no circles overlap, otherwise \\"NO\\" for i in range(N): x1, y1, r1 = circles[i] for j in range(i + 1, N): x2, y2, r2 = circles[j] distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) if distance < r1 + r2: return \\"NO\\" return \\"YES\\""},{"question":"def calculate_total_manual_time(jobs): Calculate the total manual intervention time required to process all jobs based on priority. Parameters: jobs (list of tuples): A list of tuples where each tuple contains (priority, manual_time). Returns: int: The total manual intervention time. >>> calculate_total_manual_time([(1, 20), (2, 15), (1, 10), (3, 15), (2, 5)]) 65 >>> calculate_total_manual_time([(2, 10), (1, 5), (1, 20)]) 35","solution":"def calculate_total_manual_time(jobs): Calculate the total manual intervention time required to process all jobs based on priority. Parameters: jobs (list of tuples): A list of tuples where each tuple contains (priority, manual_time). Returns: int: The total manual intervention time. # Sort the jobs first by priority, then by the order they appear jobs.sort(key=lambda x: x[0]) # Calculate the total manual intervention time total_manual_time = sum(job[1] for job in jobs) return total_manual_time"},{"question":"def max_gold_protected(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum amount of gold that can be protected if the guards are strategically positioned. >>> max_gold_protected(3, [(4, [5, 5, 10, 100]), (3, [1, 2, 3]), (5, [10, 1, 10, 1, 10])]) [105, 4, 30] >>> max_gold_protected(1, [(1, [4])]) [4] >>> max_gold_protected(1, [(0, [])]) [0] >>> max_gold_protected(1, [(5, [100, 1, 100, 1, 100])]) [300] >>> max_gold_protected(1, [(4, [0, 0, 0, 0])]) [0] >>> max_gold_protected(1, [(4, [100, 1, 100, 1])]) [200]","solution":"def max_gold_protected(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] gold = test_cases[i][1] if N == 0: results.append(0) continue if N == 1: results.append(gold[0]) continue dp = [0] * N dp[0] = gold[0] dp[1] = max(gold[0], gold[1]) for j in range(2, N): dp[j] = max(dp[j-1], dp[j-2] + gold[j]) results.append(dp[-1]) return results"},{"question":"def count_paths(grid) -> int: Calculate the number of distinct paths from the top-left corner to the bottom-right corner of the grid, avoiding traps. Args: grid (List[List[str]]): MxN grid with '.' representing a free cell and '#' representing a trap. Returns: int: The number of distinct paths modulo 10^9 + 7. >>> count_paths([\\"...\\", \\".#.\\", \\"...\\"]) == 2 >>> count_paths([\\".#.\\", \\".#.\\", \\".#.\\"]) == 0 >>> count_paths([\\".\\", \\".\\", \\".\\"]) == 1 >>> count_paths([\\"...\\"]) == 1 >>> count_paths([\\".#.\\", \\"#\\", \\".#.\\"]) == 0 >>> count_paths([\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) == 20 # Your code here def solve(input_str) -> int: Parse the input string and call count_paths function. Args: input_str (str): Input string containing the grid dimensions and the grid itself. Returns: int: The number of distinct paths from the top-left to the bottom-right of the grid. # Your code here","solution":"def count_paths(grid): MOD = 10**9 + 7 M = len(grid) N = len(grid[0]) # Create a dp array for storing number of ways to reach each cell dp = [[0] * N for _ in range(M)] # Start position always has one way to be reached dp[0][0] = 1 for i in range(M): for j in range(N): # If the cell is a trap, no ways to reach here if grid[i][j] == '#': dp[i][j] = 0 else: # If we come from the top cell if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD # If we come from the left cell if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD # The number of ways to reach bottom-right corner return dp[M-1][N-1] def solve(input_str): input_lines = input_str.strip().split('n') M, N = map(int, input_lines[0].split()) grid = [list(line) for line in input_lines[1:]] return count_paths(grid)"},{"question":"MOD = 10**9 + 7 def max_path_beauty(n, roads, A, B): Determine the maximum beauty of any path from city A to city B in a tree of cities. The roads are organized as a tree and each has a beauty index. The function should return the maximum sum of beauty indices of the roads on the path from city A to city B, mod 10^9 + 7. >>> n = 5 >>> roads = [ ... (1, 2, 4), ... (1, 3, 6), ... (2, 4, 5), ... (2, 5, 3) ... ] >>> A = 3 >>> B = 4 >>> max_path_beauty(n, roads, A, B) 15 >>> n = 2 >>> roads = [(1, 2, 1)] >>> A = 1 >>> B = 2 >>> max_path_beauty(n, roads, A, B) 1 >>> n = 3 >>> roads = [(1, 2, 10**9), (2, 3, 10**9)] >>> A = 1 >>> B = 3 >>> max_path_beauty(n, roads, A, B) (2 * 10**9) % (10**9 + 7) >>> n = 4 >>> roads = [ ... (1, 2, 3), ... (2, 3, 5), ... (3, 4, 7) ... ] >>> A = 1 >>> B = 4 >>> max_path_beauty(n, roads, A, B) 15","solution":"MOD = 10**9 + 7 def dfs(graph, node, parent, target, path_sum, path): if node == target: return path_sum for neighbor, weight in graph[node]: if neighbor != parent: result = dfs(graph, neighbor, node, target, path_sum + weight, path + [weight]) if result is not None: return result return None def max_path_beauty(n, roads, A, B): graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) max_beauty = dfs(graph, A, -1, B, 0, []) return max_beauty % MOD"},{"question":"def largest1sSquare(matrix: List[List[int]], R: int, C: int) -> int: Given a matrix of integers with R rows and C columns, find the largest square sub-matrix that contains only 1s and return its area. >>> largest1sSquare([ ... [0, 1, 1, 0, 1], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 1]], 4, 5) 9 >>> largest1sSquare([ ... [1, 1], ... [1, 1]], 2, 2) 4 >>> largest1sSquare([ ... [0, 0], ... [0, 0]], 2, 2) 0 >>> largest1sSquare([ ... [1]], 1, 1) 1 >>> largest1sSquare([ ... [1, 1, 1, 1]], 1, 4) 1 >>> largest1sSquare([ ... [1], ... [1], ... [1], ... [1]], 4, 1) 1","solution":"def largest1sSquare(matrix, R, C): if not matrix or R == 0 or C == 0: return 0 # Initialize a DP table with the same dimensions as the matrix dp = [[0] * C for _ in range(R)] max_side = 0 # To keep track of the maximum side length of the square found for i in range(R): for j in range(C): if i == 0 or j == 0: # First row or first column dp[i][j] = matrix[i][j] elif matrix[i][j] == 1: # Cell becomes part of a 1's square if all three adjacent cells are also part of 1's square dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 0 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"MODULO = 1000000007 def num_paths(m, n, blocked_cells): Calculate the number of distinct paths from the top-left corner to the bottom-right corner through a grid, given certain cells are blocked. Args: m (int): The number of rows in the grid. n (int): The number of columns in the grid. blocked_cells (set): A set containing the blocked cells as tuples (i, j). Returns: int: The number of distinct paths modulo 1000000007. >>> num_paths(3, 3, {(1, 1)}) 2 >>> num_paths(4, 5, {(0, 1), (1, 0), (2, 2), (3, 1)}) 0 >>> num_paths(2, 2, set()) 2 >>> num_paths(2, 2, {(0, 1)}) 1 >>> num_paths(2, 2, {(0, 1), (1, 0)}) 0 pass def solve(test_cases): Solve multiple test cases to find the number of distinct paths from the top-left to the bottom-right corner of a grid, given certain cells are blocked. Args: test_cases (list of tuples): A list containing tuples, each representing a test case with the format (m, n, blocked_cells). Returns: list of int: A list of results for each test case, representing the number of distinct paths modulo 1000000007. >>> solve([(3, 3, [(2, 2)]), (4, 5, [(1, 2), (2, 1), (3, 3), (4, 2)])]) [2, 0] >>> solve([(2, 2, [(1, 2)]), (2, 2, [(1, 2), (2, 1)]), (2, 2, [])]) [1, 0, 2] pass","solution":"MODULO = 1000000007 def num_paths(m, n, blocked_cells): if (0, 0) in blocked_cells or (m-1, n-1) in blocked_cells: return 0 dp = [[0] * n for _ in range(m)] if (0, 0) not in blocked_cells: dp[0][0] = 1 for i in range(m): for j in range(n): if (i, j) in blocked_cells: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MODULO return dp[m-1][n-1] def solve(test_cases): results = [] for m, n, blocked_cells in test_cases: blocked_cells_set = set((r-1, c-1) for r, c in blocked_cells) results.append(num_paths(m, n, blocked_cells_set)) return results"},{"question":"def find_duplicates_and_missing(n: int, bib_numbers: List[int]) -> Tuple[List[int], List[int]]: Identify duplicates and missing bib numbers in a marathon. :param n: Integer, total number of bib numbers supposed to be assigned. :param bib_numbers: List of integers, the assigned bib numbers. :return: A tuple containing two lists: - list of duplicates in ascending order - list of missing numbers in ascending order >>> find_duplicates_and_missing(5, [1, 2, 2, 4, 5]) ([2], [3]) >>> find_duplicates_and_missing(7, [1, 3, 4, 4, 5, 7, 7]) ([4, 7], [2, 6]) >>> find_duplicates_and_missing(3, [2, 2, 2]) ([2], [1, 3]) from typing import List, Tuple","solution":"def find_duplicates_and_missing(n, bib_numbers): Identify duplicates and missing bib numbers. :param n: Integer, total number of bib numbers supposed to be assigned. :param bib_numbers: List of integers, the assigned bib numbers. :return: A tuple containing two lists: - list of duplicates in ascending order - list of missing numbers in ascending order from collections import Counter # Count occurrences of each bib number counter = Counter(bib_numbers) duplicates = [] missing = [] # Check each number from 1 to n for num in range(1, n+1): if counter[num] > 1: duplicates.append(num) if counter[num] == 0: missing.append(num) return sorted(duplicates), sorted(missing) # Example function calls (These should not be included in the final submission): # print(find_duplicates_and_missing(5, [1, 2, 2, 4, 5])) # Expected output: ([2], [3]) # print(find_duplicates_and_missing(7, [1, 3, 4, 4, 5, 7, 7])) # Expected output: ([4, 7], [2, 6]) # print(find_duplicates_and_missing(3, [2, 2, 2])) # Expected output: ([2], [1, 3])"},{"question":"def calculate_sequence_value(N: int) -> int: Calculates the value of S after performing N operations as per the rule. Initialize an integer S to 1. For every integer i starting from 1, if S is odd, add i to S, otherwise multiply S by i. :param N: int :return: int >>> calculate_sequence_value(2) 4 >>> calculate_sequence_value(3) 12 >>> calculate_sequence_value(4) 48 >>> calculate_sequence_value(1) 2 >>> calculate_sequence_value(5) 240 def solve(T: int, cases: List[int]) -> List[int]: Solves the sequence value for multiple test cases. :param T: int :param cases: list of int :return: list of int >>> solve(3, [2, 3, 4]) [4, 12, 48] >>> solve(1, [1]) [2] >>> solve(2, [5, 6]) [240, 1440] >>> solve(4, [1, 2, 3, 4]) [2, 4, 12, 48]","solution":"def calculate_sequence_value(N): Calculates the value of S after performing N operations as per the rule. :param N: int :return: int S = 1 for i in range(1, N + 1): if S % 2 == 1: S += i else: S *= i return S def solve(T, cases): Solves the sequence value for multiple test cases. :param T: int :param cases: list of int :return: list of int results = [] for N in cases: results.append(calculate_sequence_value(N)) return results"},{"question":"def canBePalindrome(s: str) -> str: Determines if the string can be converted to a palindrome by changing at most one character. Parameters: s (str): The input string. Returns: str: \\"YES\\" if it is possible to convert to a palindrome by changing at most one character, \\"NO\\" otherwise. >>> canBePalindrome(\\"abca\\") \\"YES\\" >>> canBePalindrome(\\"racecar\\") \\"YES\\" >>> canBePalindrome(\\"abcdef\\") \\"NO\\" >>> canBePalindrome(\\"a\\") \\"YES\\" >>> canBePalindrome(\\"aa\\") \\"YES\\" >>> canBePalindrome(\\"ab\\") \\"YES\\" >>> canBePalindrome(\\"abcba\\") \\"YES\\" >>> canBePalindrome(\\"ac\\") \\"YES\\" >>> canBePalindrome(\\"a\\"*50 + \\"b\\" + \\"a\\"*50) \\"YES\\"","solution":"def canBePalindrome(s): Determines if the string can be converted to a palindrome by changing at most one character. Parameters: s (str): The input string. Returns: str: \\"YES\\" if it is possible to convert to a palindrome by changing at most one character, \\"NO\\" otherwise. left, right = 0, len(s) - 1 mismatch_count = 0 while left < right: if s[left] != s[right]: mismatch_count += 1 if mismatch_count > 1: return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"def detect_abnormal_change(readings, threshold, time_interval): Detects sensors that have reported abnormal temperature changes within the given time interval. Parameters: - readings: list of tuples (sensor_id, reading) - threshold: float, maximum allowed temperature change - time_interval: int, number of readings to consider for detecting abnormal changes Returns: - List of sensor IDs that reported abnormal temperature changes within the specified time interval. >>> detect_abnormal_change([(1, 25.0), (2, 30.0), (1, 27.0), (1, 32.0), (2, 33.0)], 5.0, 3) [1] >>> detect_abnormal_change([(1, 20.0), (2, 22.0), (1, 21.0), (2, 23.0), (1, 21.5), (2, 23.5)], 5.0, 3) []","solution":"def detect_abnormal_change(readings, threshold, time_interval): Detects sensors that have reported abnormal temperature changes within the given time interval. Parameters: - readings: list of tuples (sensor_id, reading) - threshold: float, maximum allowed temperature change - time_interval: int, number of readings to consider for detecting abnormal changes Returns: - List of sensor IDs that reported abnormal temperature changes within the specified time interval. from collections import defaultdict, deque # Dictionary to keep track of readings by each sensor sensor_data = defaultdict(deque) abnormal_sensors = set() for sensor_id, reading in readings: if sensor_id in sensor_data: previous_reading = sensor_data[sensor_id][-1] if abs(reading - previous_reading) > threshold: abnormal_sensors.add(sensor_id) # Add current reading to the sensor data sensor_data[sensor_id].append(reading) # Maintain only the latest 'time_interval' readings if len(sensor_data[sensor_id]) > time_interval: sensor_data[sensor_id].popleft() return list(abnormal_sensors)"},{"question":"def find_max_distance_indices(n, arr): Find two indices such that the elements at these indices are equal and the absolute difference between the indices is maximized. If there are multiple pairs with the same maximum distance, return the pair with the smallest i. Return -1 if no such pair exists. >>> find_max_distance_indices(6, [1, 3, 1, 4, 5, 1]) (1, 6) >>> find_max_distance_indices(5, [7, 7, 7, 7, 7]) (1, 5) >>> find_max_distance_indices(4, [1, 2, 3, 4]) -1 def solve(t, test_cases): Solve function to handle multiple test cases for the find_max_distance_indices function. >>> solve(2, [(6, [1, 3, 1, 4, 5, 1]), (5, [7, 7, 7, 7, 7])]) [(1, 6), (1, 5)] >>> solve(2, [(4, [1, 2, 3, 4]), (3, [1, 1, 1])]) [-1, (1, 3)]","solution":"def find_max_distance_indices(n, arr): index_dict = {} max_distance = -1 result_pair = (-1,) for i in range(n): if arr[i] in index_dict: first_occurrence = index_dict[arr[i]] current_distance = i - first_occurrence if current_distance > max_distance: max_distance = current_distance result_pair = (first_occurrence + 1, i + 1) else: index_dict[arr[i]] = i return result_pair if max_distance != -1 else -1 def solve(t, test_cases): results = [] for case in test_cases: n, arr = case results.append(find_max_distance_indices(n, arr)) return results"},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Find the length of the longest contiguous subarray that contains at most two distinct integers. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 4, 5, 1, 2]) 4 >>> longest_subarray_with_two_distinct([1]) 1 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 1, 2]) 6 >>> longest_subarray_with_two_distinct([2, 2, 2, 2, 2]) 5 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_two_distinct([1, 2] * 500000) 1000000 >>> longest_subarray_with_two_distinct([i % 1000000 + 1 for i in range(1000000)]) 2","solution":"def longest_subarray_with_two_distinct(nums): n = len(nums) if n == 0: return 0 if n == 1: return 1 left = 0 right = 0 max_length = 0 num_count = {} while right < n: if nums[right] in num_count: num_count[nums[right]] += 1 else: num_count[nums[right]] = 1 while len(num_count) > 2: num_count[nums[left]] -= 1 if num_count[nums[left]] == 0: del num_count[nums[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length # Usage: # Given an array of integers, like the one from the example: n = 9 nums = [1, 2, 1, 2, 3, 4, 5, 1, 2] result = longest_subarray_with_two_distinct(nums) print(result)"},{"question":"def max_satisfaction(n: int, T: int, dishes: List[Tuple[int, int]]) -> int: Calculate the maximum possible total satisfaction value Polycarp can achieve within the given time T using the provided dishes. :param n: Number of dishes (int) :param T: Total available preparation time (int) :param dishes: List of tuples where each tuple is (time_to_cook, satisfaction_value) :return: Maximum total satisfaction value (int) >>> max_satisfaction(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90 >>> max_satisfaction(3, 5, [(4, 10), (3, 20), (2, 30)]) 50 >>> max_satisfaction(1, 5, [(4, 10)]) 10 >>> max_satisfaction(2, 10, [(6, 5), (4, 5)]) 10 >>> max_satisfaction(5, 15, [(5, 50), (6, 60), (3, 40), (4, 30), (2, 20)]) 150","solution":"def max_satisfaction(n, T, dishes): Calculate the maximum possible total satisfaction value Polycarp can achieve within the given time T using the provided dishes. :param n: Number of dishes (int) :param T: Total available preparation time (int) :param dishes: List of tuples where each tuple is (time_to_cook, satisfaction_value) :return: Maximum total satisfaction value (int) # Initialize the dp array with 0 dp = [0] * (T + 1) # Process each dish for time, satisfaction in dishes: # Update dp array from back to avoid reuse of the same dish for t in range(T, time - 1, -1): dp[t] = max(dp[t], dp[t - time] + satisfaction) return dp[T]"},{"question":"def distribute_nuts(n: int, m: int): Distributes \`n\` nuts among \`m\` storage sites. Returns two lists: 1. The number of nuts in each storage site after distribution. 2. The indices of the storage sites with the highest number of nuts. >>> distribute_nuts(10, 3) ([4, 3, 3], [1]) >>> distribute_nuts(15, 5) ([3, 3, 3, 3, 3], [1, 2, 3, 4, 5]) >>> distribute_nuts(7, 2) ([4, 3], [1]) >>> distribute_nuts(6, 3) ([2, 2, 2], [1, 2, 3]) >>> distribute_nuts(7, 1) ([7], [1]) >>> distribute_nuts(5, 10) ([1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 2, 3, 4, 5])","solution":"def distribute_nuts(n, m): Distributes \`n\` nuts among \`m\` storage sites. Returns two lists: 1. The number of nuts in each storage site after distribution. 2. The indices of the storage sites with the highest number of nuts. # Each storage site initially gets \`n // m\` nuts base_num_nuts = n // m # The remaining nuts after even distribution remaining_nuts = n % m # Initial distribution of nuts nut_distribution = [base_num_nuts] * m # Distribute the remaining nuts for i in range(remaining_nuts): nut_distribution[i] += 1 # Find the maximum number of nuts in any storage site max_nuts = max(nut_distribution) # Find all sites with the maximum nuts max_nuts_sites = [i + 1 for i, nuts in enumerate(nut_distribution) if nuts == max_nuts] return nut_distribution, max_nuts_sites"},{"question":"def can_remove_one_to_palindrome(s: str) -> bool: Determine if we can remove exactly one character from string \`s\` to make it a palindrome. >>> can_remove_one_to_palindrome(\\"abca\\") True >>> can_remove_one_to_palindrome(\\"abc\\") False","solution":"def can_remove_one_to_palindrome(s: str) -> bool: def is_palindrome(subs: str) -> bool: return subs == subs[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try removing the character at left or right return is_palindrome(s[left + 1:right + 1]) or is_palindrome(s[left:right]) left += 1 right -= 1 return False"},{"question":"def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts a temperature from Fahrenheit to Celsius. >>> fahrenheit_to_celsius(32) # should return 0.0 >>> fahrenheit_to_celsius(212) # should return 100.0 # implementation def celsius_to_fahrenheit(celsius: float) -> float: Converts a temperature from Celsius to Fahrenheit. >>> celsius_to_fahrenheit(0) # should return 32.0 >>> celsius_to_fahrenheit(100) # should return 212.0 # implementation def test_fahrenheit_to_celsius(): assert fahrenheit_to_celsius(32) == 0 assert fahrenheit_to_celsius(212) == 100 assert fahrenheit_to_celsius(68) == 20 assert fahrenheit_to_celsius(-40) == -40 assert round(fahrenheit_to_celsius(104.9), 2) == 40.5 def test_celsius_to_fahrenheit(): assert celsius_to_fahrenheit(0) == 32 assert celsius_to_fahrenheit(100) == 212 assert celsius_to_fahrenheit(-40) == -40 assert celsius_to_fahrenheit(20) == 68 assert round(celsius_to_fahrenheit(40.5), 2) == 104.9","solution":"def fahrenheit_to_celsius(fahrenheit): Converts a temperature from Fahrenheit to Celsius. Args: fahrenheit (float): Temperature in degrees Fahrenheit. Returns: float: Temperature in degrees Celsius. return (fahrenheit - 32) * 5 / 9 def celsius_to_fahrenheit(celsius): Converts a temperature from Celsius to Fahrenheit. Args: celsius (float): Temperature in degrees Celsius. Returns: float: Temperature in degrees Fahrenheit. return (celsius * 9 / 5) + 32"},{"question":"def min_cost_to_flatten_hills(matrix): Given an n x n matrix of hill heights, return the minimum cost to make all hills the same height. The minimum cost is the sum of the absolute differences between each hill height and the median height. >>> min_cost_to_flatten_hills([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 20 >>> min_cost_to_flatten_hills([ ... [42]]) 0 >>> min_cost_to_flatten_hills([ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5]]) 0 >>> min_cost_to_flatten_hills([ ... [1, 3, 2], ... [6, 8, 4], ... [7, 5, 9]]) 20","solution":"def min_cost_to_flatten_hills(matrix): Given an n x n matrix of hill heights, return the minimum cost to make all hills the same height. The minimum cost is the sum of the absolute differences between each hill height and the median height. n = len(matrix) heights = [] # Flatten the matrix into a single list of heights for row in matrix: heights.extend(row) # Sort the list of heights to find the median heights.sort() # The median height median_height = heights[(n*n)//2] # Calculate the minimum cost to make all hills the same height min_cost = sum(abs(height - median_height) for height in heights) return min_cost"},{"question":"def compressString(S: str) -> str: Compresses the given string such that consecutive characters are replaced by the character followed by their count. If the compressed string is not smaller than the original string, the original string is returned. >>> compressString(\\"aabbcc\\") 'aabbcc' >>> compressString(\\"aaabbbccc\\") 'a3b3c3' >>> compressString(\\"a\\") 'a' >>> compressString(\\"aaaa\\") 'a4' >>> compressString(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compressString(\\"abcdefghij\\") 'abcdefghij' >>> compressString(\\"abcd\\") 'abcd' >>> compressString(\\"bbbbbbbbb\\") 'b9' >>> compressString(\\"aaabbaaa\\") 'a3b2a3' >>> compressString(\\"\\") ''","solution":"def compressString(S): Compresses the given string such that consecutive characters are replaced by the character followed by their count. If the compressed string is not smaller than the original string, the original string is returned. n = len(S) if n == 0: return S compressed = [] count = 1 for i in range(1, n): if S[i] == S[i - 1]: count += 1 else: compressed.append(S[i - 1] + str(count)) count = 1 compressed.append(S[-1] + str(count)) compressed_string = ''.join(compressed) if len(compressed_string) >= n: return S else: return compressed_string"},{"question":"def count_distinct_interleavings(S: str, T: str) -> int: Determine the number of distinct sequences U by interleaving S and T. The result should be modulo 1000000007. >>> count_distinct_interleavings(\\"abc\\", \\"def\\") == 20 >>> count_distinct_interleavings(\\"a\\", \\"b\\") == 2 >>> count_distinct_interleavings(\\"aa\\", \\"bb\\") == 6 >>> count_distinct_interleavings(\\"abcd\\", \\"efgh\\") == 70 >>> count_distinct_interleavings(\\"xyz\\", \\"ab\\") == 10 >>> count_distinct_interleavings(\\"a\\", \\"a\\") == 2 >>> count_distinct_interleavings(\\"abc\\", \\"a\\") == 4 >>> count_distinct_interleavings(\\"\\", \\"\\") == 1 >>> count_distinct_interleavings(\\"a\\", \\"\\") == 1 >>> count_distinct_interleavings(\\"\\", \\"b\\") == 1","solution":"def count_distinct_interleavings(S, T): MOD = 1000000007 N = len(S) M = len(T) # Create a DP table where dp[i][j] represents the number of distinct interleavings # of S[:i] and T[:j] dp = [[0] * (M + 1) for _ in range(N + 1)] # Base cases: dp[0][0] = 1 # There's exactly one way to interleave two empty strings for i in range(1, N + 1): dp[i][0] = 1 # The only way to interleave S[:i] with an empty T is S for j in range(1, M + 1): dp[0][j] = 1 # The only way to interleave an empty S with T[:j] is T # Fill the DP table for i in range(1, N + 1): for j in range(1, M + 1): dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD return dp[N][M]"},{"question":"def min_operations_to_sort_deck(n: int, deck: List[int]) -> int: Returns the minimum number of operations required to reorder the deck in increasing order. Parameters: n (int): The number of cards in the deck. deck (List[int]): The initial order of the cards in the deck. Returns: int: The minimum number of operations required to reorder the deck. Examples: >>> min_operations_to_sort_deck(5, [5, 4, 3, 2, 1]) 4 >>> min_operations_to_sort_deck(5, [3, 1, 2, 5, 4]) 3 >>> min_operations_to_sort_deck(3, [1, 3, 2]) 1 pass","solution":"def min_operations_to_sort_deck(n, deck): Returns the minimum number of operations required to reorder the deck in increasing order. # Find longest increasing subsequence (LIS) longest_increasing = 0 lis_len = [0] * (n + 1) for card in deck: # Update LIS ending with this card lis_len[card] = lis_len[card-1] + 1 longest_increasing = max(longest_increasing, lis_len[card]) # Operations needed to reorder is n minus length of longest increasing subsequence return n - longest_increasing"},{"question":"def longest_equal_even_odd_subarray(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determines the length of the longest contiguous subarray with equal number of even and odd integers for each query. Args: arr (List[int]): An array of integers. queries (List[Tuple[int, int]]): A list of queries, each with two integers representing the bounds (inclusive). Returns: List[int]: A list of results, one for each query. Example: >>> arr = [1, 2, 3, 4, 5, 6, 7, 8] >>> queries = [(0, 7), (1, 4), (2, 6)] >>> longest_equal_even_odd_subarray(arr, queries) [8, 4, 4]","solution":"def longest_equal_even_odd_subarray(arr, queries): n = len(arr) prefix_even = [0] * (n + 1) prefix_odd = [0] * (n + 1) for i in range(n): prefix_even[i + 1] = prefix_even[i] + (1 if arr[i] % 2 == 0 else 0) prefix_odd[i + 1] = prefix_odd[i] + (1 if arr[i] % 2 != 0 else 0) results = [] for l, r in queries: max_len = 0 for start in range(l, r + 1): for end in range(start, r + 1): even_count = prefix_even[end + 1] - prefix_even[start] odd_count = prefix_odd[end + 1] - prefix_odd[start] if even_count == odd_count: max_len = max(max_len, end - start + 1) results.append(max_len) return results"},{"question":"from typing import List import math def number_of_unique_paths(N: int) -> int: Given a grid of size NxN, returns the number of unique paths from the top-left corner to the bottom-right corner, moving only right or down. :param N: the size of the grid :return: the number of unique paths in an NxN grid pass def process_test_cases(test_cases: List[int]) -> List[int]: Given a list of integer test cases, returns a list of results where each result is the number of unique paths for the corresponding test case. :param test_cases: list of integers representing grid sizes :return: list of integers representing the number of unique paths for each grid size pass def test_number_of_unique_paths(): assert number_of_unique_paths(2) == 2 assert number_of_unique_paths(3) == 6 assert number_of_unique_paths(4) == 20 assert number_of_unique_paths(1) == 1 assert number_of_unique_paths(5) == 70 def test_process_test_cases(): assert process_test_cases([2, 3, 4]) == [2, 6, 20] assert process_test_cases([1]) == [1] assert process_test_cases([5, 3, 2]) == [70, 6, 2] assert process_test_cases([15]) == [40116600] # Largest N within constraint def test_edge_cases(): assert process_test_cases([]) == [] # no test cases assert process_test_cases([15, 1, 15]) == [40116600, 1, 40116600] # Mixed including max N # We should run the tests using pytest or similar framework","solution":"import math def number_of_unique_paths(N): Given a grid of size NxN, returns the number of unique paths from the top-left corner to the bottom-right corner, moving only right or down. # Using combinatorial formula: # Number of unique paths in an NxN grid is (2N-2 choose N-1) return math.comb(2 * (N-1), N-1) def process_test_cases(test_cases): Given a list of integer test cases, returns a list of results where each result is the number of unique paths for the corresponding test case. results = [] for case in test_cases: results.append(number_of_unique_paths(case)) return results"},{"question":"def calculate_drink_price(drink_name, shots_of_espresso, to_go): Calculate the price of a drink. Parameters: drink_name (str): The name of the drink. shots_of_espresso (int): The number of shots of espresso added to the drink. to_go (bool): Whether the drink is to-go or not. Returns: float: The total price of the drink.","solution":"def calculate_drink_price(drink_name, shots_of_espresso, to_go): Calculate the price of a drink. Parameters: drink_name (str): The name of the drink. shots_of_espresso (int): The number of shots of espresso added to the drink. to_go (bool): Whether the drink is to-go or not. Returns: float: The total price of the drink. base_price = 5 espresso_cost = shots_of_espresso * 1.5 to_go_cost = 0.5 if to_go else 0 total_price = base_price + espresso_cost + to_go_cost return total_price"},{"question":"def remove_vowels(input_string: str) -> str: Returns a new string with all the vowels removed from the input string. >>> remove_vowels(\\"hello world\\") == \\"hll wrld\\" >>> remove_vowels(\\"bcdfghjklmnpqrstvwxyz\\") == \\"bcdfghjklmnpqrstvwxyz\\" >>> remove_vowels(\\"aeiouAEIOU\\") == \\"\\" >>> remove_vowels(\\"\\") == \\"\\" >>> remove_vowels(\\"HELLO WORLD\\") == \\"HLL WRLD\\" >>> remove_vowels(\\"HeLLo WoRLd\\") == \\"HLL WRLd\\" >>> remove_vowels(\\"h3ll0 w@rld!\\") == \\"h3ll0 w@rld!\\" >>> remove_vowels(\\"1234567890\\") == \\"1234567890\\"","solution":"def remove_vowels(input_string): Returns a new string with all the vowels removed from the input string. vowels = \\"aeiouAEIOU\\" return ''.join(char for char in input_string if char not in vowels)"},{"question":"import heapq from typing import List def min_difficulty_path(heights: List[List[int]]) -> int: Compute the minimum difficulty path from the top-left corner to the bottom-right corner of the matrix. >>> min_difficulty_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_difficulty_path([ ... [1, 2], ... [1, 1] ... ]) == 3 >>> min_difficulty_path([ ... [0] ... ]) == 0 >>> min_difficulty_path([ ... [1000, 1000], ... [1000, 1000] ... ]) == 3000 >>> min_difficulty_path([ ... [1, 10, 1], ... [1, 10, 1], ... [1, 1, 1] ... ]) == 5","solution":"import heapq def min_difficulty_path(heights): n = len(heights) m = len(heights[0]) # Min-heap to store (total difficulty, x, y) heap = [(heights[0][0], 0, 0)] # Directions for moving north, south, east, west directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() while heap: current_difficulty, x, y = heapq.heappop(heap) if (x, y) == (n-1, m-1): return current_difficulty if (x, y) in visited: continue visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: heapq.heappush(heap, (current_difficulty + heights[nx][ny], nx, ny))"},{"question":"def rotate_marbles(N: int, marbles: List[int], R: int) -> List[int]: Returns the final arrangement of marbles after R rotations. Parameters: N (int): The number of marbles. marbles (List[int]): The list of integers representing the colors. R (int): The number of rotations, positive for clockwise, negative for counter-clockwise. Returns: List[int]: The rearranged list of marbles after the rotations. >>> rotate_marbles(5, [1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_marbles(6, [10, 20, 30, 40, 50, 60], -3) [40, 50, 60, 10, 20, 30] pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[List[int]]: Processes multiple test cases and returns the results of marble rotations. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int], int]]): A list of tuples, where each tuple contains: - N (int): The number of marbles. - marbles (List[int]): The list of integers representing marbles colors. - R (int): The number of rotations. Returns: List[List[int]]: A list containing the results of each test case. >>> process_test_cases(2, [(5, [1, 2, 3, 4, 5], 2), (6, [10, 20, 30, 40, 50, 60], -3)]) [[4, 5, 1, 2, 3], [40, 50, 60, 10, 20, 30]] pass","solution":"def rotate_marbles(N, marbles, R): Returns the final arrangement of marbles after R rotations. R = R % N # Normalize R to ensure it is within the bounds of N if R < 0: # left rotate by R R = -R rotated_marbles = marbles[R:] + marbles[:R] else: # right rotate by R rotated_marbles = marbles[-R:] + marbles[:-R] return rotated_marbles def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] marbles = test_cases[i][1] R = test_cases[i][2] result = rotate_marbles(N, marbles, R) results.append(result) return results"},{"question":"def is_valid_parentheses(s: str) -> str: Returns \\"YES\\" if the string s is a valid Parentheses sequence; otherwise, returns \\"NO\\". >>> is_valid_parentheses(\\"()\\") \\"YES\\" >>> is_valid_parentheses(\\"(())\\") \\"YES\\" >>> is_valid_parentheses(\\"(()\\") \\"NO\\" >>> is_valid_parentheses(\\"())\\") \\"NO\\" >>> is_valid_parentheses(\\"\\") \\"YES\\" >>> is_valid_parentheses(\\"()()\\") \\"YES\\" >>> is_valid_parentheses(\\"(()(()))\\") \\"YES\\" >>> is_valid_parentheses(\\"(()))(\\") \\"NO\\"","solution":"def is_valid_parentheses(s): Returns \\"YES\\" if the string s is a valid Parentheses sequence; otherwise, returns \\"NO\\". count = 0 for char in s: if char == '(': count += 1 elif char == ')': count -= 1 if count < 0: return \\"NO\\" return \\"YES\\" if count == 0 else \\"NO\\""},{"question":"def min_distance(A: str, B: str) -> int: Returns the minimum number of operations required to convert string A into string B. The allowed operations are insertion, deletion, and replacement of characters. >>> min_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5 >>> min_distance(\\"apple\\", \\"apple\\") 0 >>> min_distance(\\"apple\\", \\"apples\\") 1 >>> min_distance(\\"abcde\\", \\"fghij\\") 5 >>> min_distance(\\"hello\\", \\"world\\") 4","solution":"def min_distance(A: str, B: str) -> int: Returns the minimum number of operations required to convert string A into string B. The allowed operations are insertion, deletion, and replacement of characters. m, n = len(A), len(B) # Create a DP table to store the minimum edit distance for each substring pair dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): dp[i][0] = i # If B is an empty string, we need to delete all characters of A for j in range(n + 1): dp[0][j] = j # If A is an empty string, we need to insert all characters of B # Fill the table based on the operations for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the characters are the same, no new operation is needed else: dp[i][j] = min(dp[i - 1][j] + 1, # Delete operation dp[i][j - 1] + 1, # Insert operation dp[i - 1][j - 1] + 1) # Replace operation return dp[m][n]"},{"question":"def min_insertions_no_adjacent_duplicates(s: str) -> int: Returns the minimum number of insertions needed to make sure that no two adjacent characters in the string are the same. >>> min_insertions_no_adjacent_duplicates(\\"aabb\\") 2 >>> min_insertions_no_adjacent_duplicates(\\"abcd\\") 0 >>> min_insertions_no_adjacent_duplicates(\\"aaaa\\") 3","solution":"def min_insertions_no_adjacent_duplicates(s): Returns the minimum number of insertions needed to make sure that no two adjacent characters in the string are the same. n = len(s) if n == 0: return 0 insertions = 0 for i in range(1, n): if s[i] == s[i - 1]: insertions += 1 return insertions"},{"question":"def calculate_final_score(operations): Calculate the final score for the robot after all operations. Parameters: operations (list of tuples): A list of tuples where each tuple contains a string ('add' or 'set') and an integer value. Returns: int: The final score of the robot. Examples: >>> calculate_final_score([('add', 10), ('add', 15), ('set', 20), ('add', 5), ('set', 30)]) 30 >>> calculate_final_score([('add', 10), ('add', 15), ('add', 5)]) 30 def test_calculate_final_score_basic(): operations = [('add', 10), ('add', 15), ('set', 20), ('add', 5), ('set', 30)] assert calculate_final_score(operations) == 30 def test_calculate_final_score_all_add(): operations = [('add', 10), ('add', 15), ('add', 5)] assert calculate_final_score(operations) == 30 def test_calculate_final_score_all_set(): operations = [('set', 10), ('set', 15), ('set', 5)] assert calculate_final_score(operations) == 5 def test_calculate_final_score_set_and_add(): operations = [('set', 10), ('add', 5), ('set', 15), ('add', 10)] assert calculate_final_score(operations) == 25 def test_calculate_final_score_empty_operations(): operations = [] assert calculate_final_score(operations) == 0 def test_calculate_final_score_negative_values(): operations = [('add', -10), ('add', -15), ('set', -20), ('add', -5)] assert calculate_final_score(operations) == -25","solution":"def calculate_final_score(operations): Calculate the final score for the robot after all operations. Parameters: operations (list of tuples): A list of tuples where each tuple contains a string ('add' or 'set') and an integer value. Returns: int: The final score of the robot. score = 0 for operation, value in operations: if operation == 'add': score += value elif operation == 'set': score = value return score"},{"question":"def totalRainwater(heights: List[int]) -> int: Given a list of integers representing the height of consecutive buildings, return the total amount of rainwater collected after it rains. >>> totalRainwater([3, 0, 2, 0, 4]) 7 >>> totalRainwater([2, 0, 2]) 2","solution":"def totalRainwater(heights): This function returns the total amount of rainwater collected between buildings. n = len(heights) if n <= 2: return 0 left_max = [0] * n right_max = [0] * n # Initialize the left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Initialize the right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total amount of rainwater trapped total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"def min_additional_trucks(n, m, t, routes, trucks): Determine the minimum number of additional trucks required to ensure all packages are delivered within the constraints of the trucks' maximum distances. Args: n (int): The number of warehouses. m (int): The number of routes (pair of warehouses with distance). t (int): The number of trucks. routes (List[Tuple[int, int, int]]): List of tuples representing routes between warehouses with distances. trucks (List[Tuple[int, int]]): List of tuples representing trucks with maximum distance they can travel and number of warehouses they can visit. Returns: int: The minimum number of additional trucks needed. Examples: >>> n = 4 >>> m = 5 >>> t = 2 >>> routes = [(1, 2, 10), (2, 3, 15), (3, 4, 5), (4, 1, 20), (2, 4, 25)] >>> trucks = [(20, 3), (30, 4)] >>> min_additional_trucks(n, m, t, routes, trucks) 1 >>> n = 3 >>> m = 3 >>> t = 3 >>> routes = [(1, 2, 12), (2, 3, 8), (3, 1, 7)] >>> trucks = [(10, 2), (15, 2), (20, 2)] >>> min_additional_trucks(n, m, t, routes, trucks) 0","solution":"def min_additional_trucks(n, m, t, routes, trucks): total_distance = sum([d for _, _, d in routes]) sum_truck_distance = sum([truck[0] for truck in trucks]) if sum_truck_distance >= total_distance: return 0 else: trucks_needed_distance = (total_distance - sum_truck_distance) additional_trucks_needed = (trucks_needed_distance // max([truck[0] for truck in trucks])) + 1 return additional_trucks_needed"},{"question":"from typing import List, Dict, Union, Tuple def calculate_letter_grades(students: List[Dict[str, Union[str, List[int]]]]) -> List[Tuple[str, str]]: Calculate the average grade for each student and assigns them a letter grade based on the following scale: - A: Average grade >= 90 - B: 80 <= Average grade < 90 - C: 70 <= Average grade < 80 - D: 60 <= Average grade < 70 - F: Average grade < 60 >>> students = [ ... {\\"name\\": \\"Alice\\", \\"grades\\": [95, 85, 92]}, ... {\\"name\\": \\"Bob\\", \\"grades\\": [70, 76, 68, 72]}, ... {\\"name\\": \\"Charlie\\", \\"grades\\": [88, 82, 84]}, ... {\\"name\\": \\"Diana\\", \\"grades\\": [60, 58, 64]}, ... {\\"name\\": \\"Eve\\", \\"grades\\": [45, 50, 48]} ... ] >>> calculate_letter_grades(students) [('Alice', 'A'), ('Bob', 'C'), ('Charlie', 'B'), ('Diana', 'D'), ('Eve', 'F')]","solution":"from typing import List, Dict, Union, Tuple def calculate_letter_grades(students: List[Dict[str, Union[str, List[int]]]]) -> List[Tuple[str, str]]: def average_grade(grades: List[int]) -> float: return sum(grades) / len(grades) def letter_grade(average: float) -> str: if average >= 90: return 'A' elif average >= 80: return 'B' elif average >= 70: return 'C' elif average >= 60: return 'D' else: return 'F' result = [] for student in students: avg = average_grade(student[\\"grades\\"]) grade = letter_grade(avg) result.append((student[\\"name\\"], grade)) return result"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequent character in the string \`s\`. If there are multiple such characters, the lexicographically smallest one is returned. >>> most_frequent_character('abracadabra') 'a' >>> most_frequent_character('mississippi') 'i'","solution":"def most_frequent_character(s): Returns the most frequent character in the string \`s\`. If there are multiple such characters, the lexicographically smallest one is returned. from collections import Counter # Count the frequency of each character in the string frequency = Counter(s) # Find the maximum frequency max_frequency = max(frequency.values()) # Get all characters with the maximum frequency candidates = [char for char, count in frequency.items() if count == max_frequency] # Return the lexicographically smallest one return min(candidates)"},{"question":"def find_combination(numbers: List[int], target: int) -> List[List[int]]: Compute all possible combinations of the integers in the list that sum up to the target. >>> find_combination([2, 3, 6, 7], 7) [[7], [2, 2, 3]] >>> find_combination([2, 4, 6, 8], 5) [] >>> find_combination([5], 10) [[5, 5]] >>> find_combination([1, 2, 3], 4) [[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3]] >>> find_combination([], 7) [] from typing import List def test_find_combination_example(): numbers = [2, 3, 6, 7] target = 7 expected = [[7], [2, 2, 3]] result = find_combination(numbers, target) result_sorted = sorted([sorted(comb) for comb in result]) assert result_sorted == sorted([sorted(comb) for comb in expected]) def test_find_combination_no_solution(): numbers = [2, 4, 6, 8] target = 5 expected = [] result = find_combination(numbers, target) assert result == expected def test_find_combination_single_number(): numbers = [5] target = 10 expected = [[5, 5]] result = find_combination(numbers, target) result_sorted = sorted([sorted(comb) for comb in result]) assert result_sorted == sorted([sorted(comb) for comb in expected]) def test_find_combination_multiple_solutions(): numbers = [1, 2, 3] target = 4 expected = [[1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3]] result = find_combination(numbers, target) result_sorted = sorted([sorted(comb) for comb in result]) assert result_sorted == sorted([sorted(comb) for comb in expected]) def test_find_combination_empty(): numbers = [] target = 7 expected = [] result = find_combination(numbers, target) assert result == expected","solution":"def find_combination(numbers, target): def backtrack(start, path, remaining): if remaining == 0: result.append(path) return for i in range(start, len(numbers)): if numbers[i] > remaining: continue backtrack(i, path + [numbers[i]], remaining - numbers[i]) result = [] numbers.sort() backtrack(0, [], target) return result"},{"question":"def reverse_words(sentence: str) -> str: Takes in a string representing a sentence and returns the sentence with each word reversed, but with the words in their original order. >>> reverse_words(\\"The quick brown fox\\") \\"ehT kciuq nworb xof\\" >>> reverse_words(\\"Hello\\") \\"olleH\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"Hello, world!\\") \\",olleH !dlrow\\" >>> reverse_words(\\" Leading and trailing spaces \\") \\"gnidaeL dna gniliart secaps\\"","solution":"def reverse_words(sentence): Reverses each word in the sentence but maintains the original word order. :param sentence: str, the sentence to process :return: str, the sentence with each word reversed words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List def is_prime(num: int) -> bool: Returns True if the given number is prime, otherwise False. >>> is_prime(2) True >>> is_prime(4) False def find_sequence(k: int, n: int) -> List[int]: Returns the first n elements of the sequence starting with k. >>> find_sequence(1, 5) [1, 2, 3, 5, 7] >>> find_sequence(2, 6) [2, 3, 5, 7, 11, 13] def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(9) == False assert is_prime(11) == True def test_find_sequence_case_1(): assert find_sequence(1, 5) == [1, 2, 3, 5, 7] def test_find_sequence_case_2(): assert find_sequence(2, 6) == [2, 3, 5, 7, 11, 13] def test_find_sequence_case_3(): assert find_sequence(3, 4) == [3, 5, 7, 11] def test_find_sequence_case_4(): assert find_sequence(10, 5) == [10, 11, 13, 17, 19] def test_find_sequence_case_5(): assert find_sequence(0, 1) == [0] assert find_sequence(1, 1) == [1] assert find_sequence(2, 1) == [2]","solution":"def is_prime(num): if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def find_sequence(k, n): sequence = [k] current_num = k + 1 while len(sequence) < n: if is_prime(current_num): sequence.append(current_num) current_num += 1 return sequence"},{"question":"def max_score(cards): Compute the maximum score the first player can achieve if both players play optimally. >>> max_score([1, 2, 9, 4]) 10 >>> max_score([4, 4, 4]) 8 >>> max_score([5, 3, 7, 10]) 15 >>> max_score([8, 15, 3, 7]) 22 >>> max_score([20, 30, 2, 2, 2, 10]) 42 pass def solve_game(test_cases): Given multiple test cases, compute the maximum score the first player can achieve for each case. >>> solve_game([(4, 1, 2, 9, 4), (3, 4, 4, 4)]) [10, 8] >>> solve_game([(4, 5, 3, 7, 10), (4, 8, 15, 3, 7), (6, 20, 30, 2, 2, 2, 10)]) [15, 22, 42] pass","solution":"def max_score(cards): Compute the maximum score the first player can achieve if both players play optimally. n = len(cards) dp = [[0] * n for _ in range(n)] for s in range(n): for i in range(n - s): j = i + s x = dp[i+2][j] if i + 2 <= j else 0 y = dp[i+1][j-1] if i + 1 <= j - 1 else 0 z = dp[i][j-2] if i <= j - 2 else 0 dp[i][j] = max(cards[i] + min(x, y), cards[j] + min(y, z)) return dp[0][n-1] def solve_game(test_cases): results = [] for case in test_cases: n, cards = case[0], case[1:] results.append(max_score(cards)) return results"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to transform the string s into a palindrome. >>> min_operations_to_palindrome(\\"abc\\") == 1 >>> min_operations_to_palindrome(\\"aabb\\") == 2 >>> min_operations_to_palindrome(\\"racecar\\") == 0 >>> min_operations_to_palindrome(\\"abba\\") == 0 >>> min_operations_to_palindrome(\\"abcd\\") == 2 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list containing the minimum number of operations for each case. >>> process_test_cases([\\"abc\\", \\"aabb\\", \\"abcd\\"]) == [1, 2, 2] >>> process_test_cases([\\"racecar\\", \\"abba\\"]) == [0, 0] >>> process_test_cases([\\"a\\", \\"aa\\", \\"ab\\"]) == [0, 0, 1] >>> process_test_cases([\\"\\"]) == [0]","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to transform the string s into a palindrome. n = len(s) operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations def process_test_cases(test_cases): Processes multiple test cases and returns a list containing the minimum number of operations for each case. results = [] for s in test_cases: results.append(min_operations_to_palindrome(s)) return results"},{"question":"def find_missing_match(m, matches): Determines the missing match result. :param m: number of employees :param matches: list of tuples representing the recorded result of the games (winner, loser) :return: tuple (u, v) representing the missing match result (u defeats v) import pytest def test_case_1(): m = 5 matches = [ (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5) ] assert find_missing_match(m, matches) == (1, 2) def test_case_2(): m = 4 matches = [ (1, 2), (1, 3), (1, 4), (2, 3), (3, 4) ] assert find_missing_match(m, matches) == (2, 4) def test_case_3(): m = 6 matches = [ (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6), (4, 5), (4, 6) ] assert find_missing_match(m, matches) == (5, 6) def test_case_4(): m = 3 matches = [ (1, 2), (2, 3) ] assert find_missing_match(m, matches) == (1, 3) def test_case_5(): m = 4 matches = [ (2, 1), (2, 3), (2, 4), (3, 1), (3, 4) ] assert find_missing_match(m, matches) == (1, 4)","solution":"def find_missing_match(m, matches): Determines the missing match result. :param m: number of employees :param matches: list of tuples representing the recorded result of the games (winner, loser) :return: tuple (u, v) representing the missing match result (u defeats v) match_dict = {i: set() for i in range(1, m + 1)} # Record matches in a dictionary for winner, loser in matches: match_dict[winner].add(loser) # Check which match is missing all_employees = set(range(1, m + 1)) for i in range(1, m + 1): for j in range(i + 1, m + 1): if j not in match_dict[i] and i not in match_dict[j]: missing_match = (i, j) break # Determine winner and loser based on existing matches if missing_match[0] in match_dict[missing_match[1]]: return missing_match[1], missing_match[0] else: return missing_match[0], missing_match[1]"},{"question":"from typing import List, Dict, Union def top_student(students: List[Dict[str, Union[str, int]]]) -> Union[str, List[str]]: Determine the student(s) with the highest score and return their name or names in alphabetical order. >>> top_student([ ... {\\"name\\": \\"John\\", \\"score\\": 90}, ... {\\"name\\": \\"Alice\\", \\"score\\": 95}, ... {\\"name\\": \\"Bob\\", \\"score\\": 95}, ... {\\"name\\": \\"Eve\\", \\"score\\": 88} ... ]) [\\"Alice\\", \\"Bob\\"] >>> top_student([ ... {\\"name\\": \\"John\\", \\"score\\": 90}, ... {\\"name\\": \\"Alice\\", \\"score\\": 95}, ... {\\"name\\": \\"Bob\\", \\"score\\": 85} ... ]) \\"Alice\\" >>> top_student([]) []","solution":"from typing import List, Dict, Union def top_student(students: List[Dict[str, Union[str, int]]]) -> Union[str, List[str]]: if not students: return [] max_score = max(student['score'] for student in students) top_scorers = [student['name'] for student in students if student['score'] == max_score] if len(top_scorers) == 1: return top_scorers[0] else: return sorted(top_scorers)"},{"question":"from typing import List, Tuple def has_cycle_in_network(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine if there is a cycle in the communication network for each test case. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases, where each test case is represented by a tuple: - The first value is the number of machines (N). - The second value is the number of communications (M). - The third value is a list of tuples, where each tuple represents a communication from machine X to machine Y. Returns: List[str]: A list of results, where each result is \\"Yes\\" if there is a cycle in the network for the corresponding test case, otherwise \\"No\\". >>> has_cycle_in_network([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 2, [(1, 2), (2, 3)])]) ['Yes', 'No'] >>> has_cycle_in_network([(3, 0, []), (5, 0, [])]) ['No', 'No'] >>> has_cycle_in_network([(5, 3, [(1, 2), (3, 4), (4, 5)])]) ['No'] >>> has_cycle_in_network([(3, 1, [(1, 1)])]) ['Yes'] >>> has_cycle_in_network([(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)])]) ['Yes'] >>> has_cycle_in_network([(6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)])]) ['Yes'] >>> has_cycle_in_network([(6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)])]) ['Yes']","solution":"from collections import defaultdict def detect_cycle_util(v, visited, rec_stack, graph): visited[v] = True rec_stack[v] = True for neighbor in graph[v]: if not visited[neighbor]: if detect_cycle_util(neighbor, visited, rec_stack, graph): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False def detect_cycle(n, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * (n + 1) rec_stack = [False] * (n + 1) for node in range(1, n + 1): if not visited[node]: if detect_cycle_util(node, visited, rec_stack, graph): return True return False def has_cycle_in_network(test_cases): results = [] for n, m, edges in test_cases: if detect_cycle(n, edges): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def max_participants(T: int, cases: List[Tuple[int, int]]) -> List[int]: Given the total number of medals and the number of participants who potentially need them, determine the maximum number of participants that can receive the same number of medals without any remainder. Args: T : int : The number of test cases. cases : List[Tuple[int, int]] : A list of tuples where each tuple contains two space-separated integers N and P. Returns: List[int] : A list of integers where each integer is the maximum number of participants for the corresponding test case. >>> max_participants(3, [(50, 5), (100, 28), (75, 10)]) [10, 3, 7] >>> max_participants(1, [(10**18, 2)]) [5 * 10**17] >>> max_participants(1, [(1, 1)]) [1]","solution":"def max_participants(T, cases): results = [] for N, P in cases: results.append(N // P) return results"},{"question":"def minimize_missing_books(n: int, books: List[int]) -> int: Returns the minimum number of books that need to be rearranged or loaned back to minimize the largest continuous segment of missing books. >>> minimize_missing_books(5, [1, 0, 3, 0, 5]) 1 >>> minimize_missing_books(7, [1, 2, 0, 4, 0, 0, 7]) 2 >>> minimize_missing_books(5, [1, 2, 3, 4, 5]) 0 >>> minimize_missing_books(3, [0, 0, 0]) 3 >>> minimize_missing_books(6, [0, 0, 3, 4, 5, 6]) 2 >>> minimize_missing_books(6, [1, 2, 3, 0, 0, 0]) 3 >>> minimize_missing_books(7, [1, 2, 0, 0, 4, 5, 6]) 2","solution":"def minimize_missing_books(n, books): Returns the minimum number of books that need to be rearranged or loaned back to minimize the largest continuous segment of missing books. # Find the longest contiguous segment of missing books max_missing_segment = 0 current_missing_segment = 0 for book in books: if book == 0: current_missing_segment += 1 else: if current_missing_segment > max_missing_segment: max_missing_segment = current_missing_segment current_missing_segment = 0 # Check at the end in case the array ends with missing books if current_missing_segment > max_missing_segment: max_missing_segment = current_missing_segment return max_missing_segment"},{"question":"from typing import List, Tuple def minimize_max_distance(n: int, roads: List[Tuple[int, int, int]]) -> int: Determine the optimal village to place the fountain so that the maximum distance any village has to travel to get to the fountain is minimized. Parameters: n (int): The number of villages. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing a road between villages u and v with length w. Returns: int: The minimized maximum distance any village has to walk to get to the fountain. Examples: >>> minimize_max_distance(5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]) 9 >>> minimize_max_distance(1, []) 0","solution":"from collections import defaultdict, deque def find_furthest(node, n, graph): dist = [-1] * (n + 1) queue = deque([node]) dist[node] = 0 furthest_node, max_dist = node, 0 while queue: curr = queue.popleft() for nei, length in graph[curr]: if dist[nei] == -1: dist[nei] = dist[curr] + length queue.append(nei) if dist[nei] > max_dist: max_dist = dist[nei] furthest_node = nei return furthest_node, max_dist def minimize_max_distance(n, roads): if n == 1: return 0 graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) node1 = find_furthest(1, n, graph)[0] furthest_from_node1, max_dist1 = find_furthest(node1, n, graph) furthest_from_node2, max_dist2 = find_furthest(furthest_from_node1, n, graph) return max_dist2 // 2 # Example usage: n = 5 roads = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)] print(minimize_max_distance(n, roads)) # Output: 9"},{"question":"def next_permutation(s: str) -> str: Returns the lexicographically smallest permutation of the string \`s\` that is greater than \`s\`. If no such permutation exists, returns \\"no answer\\". >>> next_permutation(\\"ab\\") == \\"ba\\" >>> next_permutation(\\"bb\\") == \\"no answer\\" >>> next_permutation(\\"hefg\\") == \\"hegf\\" >>> next_permutation(\\"dhck\\") == \\"dhkc\\" >>> next_permutation(\\"dkhc\\") == \\"hcdk\\" >>> next_permutation(\\"abcd\\") == \\"abdc\\" >>> next_permutation(\\"dcba\\") == \\"no answer\\" >>> next_permutation(\\"a\\") == \\"no answer\\" pass def solve(t: int, cases: List[str]) -> List[str]: Given the number of test cases \`t\` and list of \`cases\` containing the input strings, returns a list containing the lexicographically smallest permutations for each case. >>> solve(3, [\\"ab\\", \\"bb\\", \\"hefg\\"]) == [\\"ba\\", \\"no answer\\", \\"hegf\\"] >>> solve(2, [\\"abcd\\", \\"dcba\\"]) == [\\"abdc\\", \\"no answer\\"] >>> solve(4, [\\"a\\", \\"ab\\", \\"ba\\", \\"dcba\\"]) == [\\"no answer\\", \\"ba\\", \\"no answer\\", \\"no answer\\"] pass","solution":"def next_permutation(s): Returns the lexicographically smallest permutation of the string \`s\` that is greater than \`s\`. If no such permutation exists, returns \\"no answer\\". # Convert the string to a list of characters lst = list(s) # Step 1: Find the rightmost character which is smaller than its next character. i = len(lst) - 2 while i >= 0 and lst[i] >= lst[i + 1]: i -= 1 # If no such character is found, then all characters are sorted in descending order. # This means we are at the highest possible permutation, so return \\"no answer\\". if i == -1: return \\"no answer\\" # Step 2: Find the smallest character on right side of lst[i] which is larger than lst[i] j = len(lst) - 1 while lst[j] <= lst[i]: j -= 1 # Step 3: Swap the above found characters lst[i], lst[j] = lst[j], lst[i] # Step 4: Reverse the characters after the index \`i\` lst = lst[:i + 1] + lst[i + 1:][::-1] # Convert the list back to string and return return ''.join(lst) def solve(t, cases): results = [] for case in cases: results.append(next_permutation(case)) return results"},{"question":"def paint_grid(N: int, M: int) -> list: Paints all the cells in a grid with N rows and M columns either black ('B') or white ('W') according to the following rules: - The distance between two cells (i1, j1) and (i2, j2) is |i1 - i2| + |j1 - j2|. - If the distance from a cell (i, j) to the top-left cell (1, 1) is even, it should be painted white ('W'). - If the distance is odd, it should be painted black ('B'). Args: N (int): Number of rows. M (int): Number of columns. Returns: list: A grid of N rows and M columns with 'B' and 'W' representing black and white cells respectively. >>> paint_grid(3, 3) [\\"W B W\\", \\"B W B\\", \\"W B W\\"] >>> paint_grid(4, 5) [\\"W B W B W\\", \\"B W B W B\\", \\"W B W B W\\", \\"B W B W B\\"] >>> paint_grid(1, 1) [\\"W\\"] >>> paint_grid(2, 2) [\\"W B\\", \\"B W\\"] >>> paint_grid(5, 4) [\\"W B W B\\", \\"B W B W\\", \\"W B W B\\", \\"B W B W\\", \\"W B W B\\"]","solution":"def paint_grid(N, M): Paints an N x M grid based on the specified rules. Args: N (int): Number of rows. M (int): Number of columns. Returns: list: A grid of N rows and M columns with 'B' and 'W' representing black and white cells respectively. grid = [] for i in range(N): row = [] for j in range(M): if (i + j) % 2 == 0: row.append('W') else: row.append('B') grid.append(' '.join(row)) return grid def main(): import sys input = sys.stdin.read N, M = map(int, input().strip().split()) for row in paint_grid(N, M): print(row)"},{"question":"def find_elements_with_two_duplicates(lst: List[int]) -> List[int]: Identify all the elements that have at least two duplicates in the list. Return a new list sorted in ascending order containing these elements. >>> find_elements_with_two_duplicates([1, 3, 7, 1, 3, 1, 3, 2, 4, 4, 4, 4]) [1, 3, 4] >>> find_elements_with_two_duplicates([1, 2, 2, 3, 3, 4]) [] >>> find_elements_with_two_duplicates([1, 2, 3, 4, 5]) [] >>> find_elements_with_two_duplicates([1, 1, 1, 2, 2, 2, 3, 3, 3]) [1, 2, 3] >>> find_elements_with_two_duplicates([i for i in range(1, 501)] + [500]*3 + [400]*3) [400, 500]","solution":"def find_elements_with_two_duplicates(lst): Identify all the elements that have at least two duplicates in the list. Return a new list sorted in ascending order containing these elements. from collections import Counter # Calculate frequency of each element in the list frequency = Counter(lst) # Create a list of elements with at least two duplicates result = [element for element, count in frequency.items() if count >= 3] # Return the sorted list return sorted(result)"},{"question":"def top_k_participants(participants, k): Returns the IDs of the top k participants sorted by their scores in descending order and by their IDs in ascending order when scores are the same. Parameters: participants (list): A list of tuples where each tuple contains a participant ID and their score. k (int): The number of top participants to return. Returns: list: The list of top k participant IDs. >>> top_k_participants([(1, 92), (2, 87), (3, 92), (4, 85)], 2) [1, 3] >>> top_k_participants([(1, 89), (2, 89), (3, 91)], 1) [3] from solution import top_k_participants def test_top_k_participants_example1(): participants = [(1, 92), (2, 87), (3, 92), (4, 85)] k = 2 assert top_k_participants(participants, k) == [1, 3] def test_top_k_participants_example2(): participants = [(1, 89), (2, 89), (3, 91)] k = 1 assert top_k_participants(participants, k) == [3] def test_top_k_participants_tiebreaker(): participants = [(1, 90), (2, 90), (3, 80)] k = 2 assert top_k_participants(participants, k) == [1, 2] def test_top_k_participants_all_tied(): participants = [(1, 50), (2, 50), (3, 50)] k = 3 assert top_k_participants(participants, k) == [1, 2, 3] def test_top_k_participants_small_k(): participants = [(1, 30), (2, 40), (3, 20)] k = 1 assert top_k_participants(participants, k) == [2] def test_top_k_participants_large_input(): participants = [(i, 100 - i) for i in range(1, 10001)] k = 5 assert top_k_participants(participants, k) == [1, 2, 3, 4, 5]","solution":"def top_k_participants(participants, k): Returns the IDs of the top k participants sorted by their scores in descending order and by their IDs in ascending order when scores are the same. Parameters: participants (list): A list of tuples where each tuple contains a participant ID and their score. k (int): The number of top participants to return. Returns: list: The list of top k participant IDs. # Sort participants based on score (descending) and then by ID (ascending) if scores are identical sorted_participants = sorted(participants, key=lambda x: (-x[1], x[0])) # Extract the top k participant IDs top_k_ids = [participant[0] for participant in sorted_participants[:k]] return top_k_ids"},{"question":"def min_g(n, b, s): Returns the minimum value of the function g(y) for all 0 ≤ y ≤ t. The value g(y) is calculated by: g(y) = ∑(b[i] * (p[i] + q(i))), where p[i] equals one if the i-th bit in the binary representation of y is 0, and q(i) equals one if the i-th bit in the binary representation of y is 1. >>> min_g(2, [5, 9], \\"11\\") 14 >>> min_g(4, [2, 3, 1, 4], \\"1010\\") 10 >>> min_g(1, [5], \\"1\\") 5 >>> min_g(1, [5], \\"0\\") 5 >>> min_g(4, [2, 2, 2, 2], \\"1111\\") 8 >>> min_g(3, [0, 0, 0], \\"000\\") 0 >>> min_g(4, [0, 0, 0, 0], \\"0000\\") 0","solution":"def min_g(n, b, s): Returns the minimum value of the function g(y) for all 0 ≤ y ≤ t. The value g(y) is calculated by: g(y) = ∑(b[i] * (p[i] + q(i))), where p[i] equals one if the i-th bit in the binary representation of y is 0, and q(i) equals one if the i-th bit in the binary representation of y is 1. # Initialize the result result = 0 # Iterate over the bits of t for i in range(n): if s[i] == '1': # If s[i] is 1, then ( for corresponding b[i] * (p[i] + q[i]) ) we can only count q[i] result += b[i] else: # If s[i] is 0, then ( for corresponding b[i] * (p[i] + q[i]) ) we can only count p[i] result += b[i] return result"},{"question":"def twoSum(nums, target): Returns the indices of the two numbers in the list that add up to the target sum. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: list of int: The indices of the two numbers. Examples: >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([3, 2, 4], 6) [1, 2] >>> twoSum([3, 3], 6) [0, 1] >>> twoSum([1, 2, 3, 4, 5], 8) [2, 4]","solution":"def twoSum(nums, target): Returns the indices of the two numbers in the list that add up to the target sum. Args: nums (list of int): The list of integers. target (int): The target sum. Returns: list of int: The indices of the two numbers. hash_map = {} for i, num in enumerate(nums): complement = target - num if complement in hash_map: return [hash_map[complement], i] hash_map[num] = i"},{"question":"def duplicateZeros(arr: List[int]): Duplicates each occurrence of zero in the input list 'arr', shifting the remaining elements to the right. Modifies the list in-place. pass from solution import duplicateZeros def test_duplicate_zeros_example1(): arr = [1, 0, 2, 3, 0, 4, 5, 0] duplicateZeros(arr) assert arr == [1, 0, 0, 2, 3, 0, 0, 4] def test_duplicate_zeros_example2(): arr2 = [0, 0, 0, 0] duplicateZeros(arr2) assert arr2 == [0, 0, 0, 0] def test_duplicate_zeros_no_zeros(): arr = [1, 2, 3] duplicateZeros(arr) assert arr == [1, 2, 3] def test_duplicate_zeros_single_zero(): arr = [1, 0, 3] duplicateZeros(arr) assert arr == [1, 0, 0] def test_duplicate_zeros_multiple_zeros(): arr = [0, 0, 1, 1, 0] duplicateZeros(arr) assert arr == [0, 0, 0, 0, 1] def test_duplicate_zeros_edge_case_all_elements_zeros(): arr = [0, 0, 0] duplicateZeros(arr) assert arr == [0, 0, 0] def test_duplicate_zeros_edge_case_empty_array(): arr = [] duplicateZeros(arr) assert arr == [] def test_duplicate_zeros_with_trailing_elements(): arr = [8, 0, 9, 4, 5, 0] duplicateZeros(arr) assert arr == [8, 0, 0, 9, 4, 5]","solution":"def duplicateZeros(arr): Duplicates each occurrence of zero in the input list 'arr', shifting the remaining elements to the right. Modifies the list in-place. n = len(arr) zeros_to_duplicate = arr.count(0) total_length = n + zeros_to_duplicate # This is the effective length of the array including duplicated zeros for i in range(n - 1, -1, -1): # We fill from the back to avoid overwriting elements if i + zeros_to_duplicate < n: arr[i + zeros_to_duplicate] = arr[i] if arr[i] == 0: zeros_to_duplicate -= 1 if i + zeros_to_duplicate < n: arr[i + zeros_to_duplicate] = 0"},{"question":"def max_non_overlapping_bookings(bookings): Finds the maximum number of non-overlapping bookings. Parameters: bookings (list of tuples): A list of tuples where each tuple contains the start and end time of a booking. Returns: int: The maximum number of non-overlapping bookings that can be accepted. >>> max_non_overlapping_bookings([(1, 2)]) 1 >>> max_non_overlapping_bookings([(1, 3), (3, 5), (5, 7)]) 3 >>> max_non_overlapping_bookings([(1, 4), (2, 5), (4, 7), (6, 8), (8, 10)]) 3 >>> max_non_overlapping_bookings([(1, 4), (2, 6), (3, 5)]) 1 >>> max_non_overlapping_bookings([(1, 2), (2, 3), (3, 4), (1, 5), (5, 6), (6, 7), (7, 8)]) 6 >>> max_non_overlapping_bookings([(0, 1000000000)]) 1 >>> max_non_overlapping_bookings([]) 0","solution":"def max_non_overlapping_bookings(bookings): Finds the maximum number of non-overlapping bookings. Parameters: bookings (list of tuples): A list of tuples where each tuple contains the start and end time of a booking. Returns: int: The maximum number of non-overlapping bookings that can be accepted. # Sort the bookings based on end time bookings.sort(key=lambda b: b[1]) max_bookings = 0 last_end_time = -float('inf') for start, end in bookings: if start >= last_end_time: max_bookings += 1 last_end_time = end return max_bookings def main(): import sys input = sys.stdin.read data = input().strip().split(\\"n\\") N = int(data[0]) bookings = [] for i in range(1, N + 1): start, end = map(int, data[i].split()) bookings.append((start, end)) print(max_non_overlapping_bookings(bookings)) if __name__ == \\"__main__\\": main()"},{"question":"from datetime import datetime from typing import List, Tuple def find_youngest(t: int, test_cases: List[Tuple[int, List[Tuple[str, str]]]]) -> List[str]: Finds the youngest person from each test case. >>> find_youngest(2, [ (3, [(\\"Alice\\", \\"1990-05-01\\"), (\\"Bob\\", \\"1985-12-24\\"), (\\"Charlie\\", \\"1992-08-17\\")]), (2, [(\\"Dave\\", \\"2000-04-30\\"), (\\"Eve\\", \\"1999-01-15\\")]) ]) [\\"Charlie\\", \\"Dave\\"] >>> find_youngest(1, [ (3, [(\\"Alan\\", \\"1980-01-01\\"), (\\"Betty\\", \\"1985-05-23\\"), (\\"Chuck\\", \\"1985-05-23\\")]) ]) [\\"Betty\\"] >>> find_youngest(1, [ (1, [(\\"OnlyOne\\", \\"1995-06-15\\")]) ]) [\\"OnlyOne\\"] >>> find_youngest(1, [ (3, [(\\"Person1\\", \\"2001-09-09\\"), (\\"Person2\\", \\"1995-12-12\\"), (\\"Person3\\", \\"2010-11-11\\")]) ]) [\\"Person3\\"]","solution":"from datetime import datetime def find_youngest(t, test_cases): Finds the youngest person from each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains the number of people (int) and a list of (name, birthdate) tuples. Returns: list of strs: Names of the youngest persons for each test case. results = [] for case in test_cases: n, people = case youngest_name = \\"\\" youngest_date = None for name, birthdate in people: birthdate_obj = datetime.strptime(birthdate, \\"%Y-%m-%d\\") if youngest_date is None or birthdate_obj > youngest_date: youngest_name = name youngest_date = birthdate_obj results.append(youngest_name) return results"},{"question":"def is_back_to_origin(cmd: str) -> str: Determines if the spaceship returns to its original position after executing the command string. Parameters: cmd (str): A string of movement commands where each command is 'G', 'L', or 'R'. Returns: str: \\"Yes\\" if the spaceship returns to (0,0), \\"No\\" otherwise. Examples: >>> is_back_to_origin(\\"GLGLGLG\\") 'Yes' >>> is_back_to_origin(\\"GGRRG\\") 'No'","solution":"def is_back_to_origin(cmd): Determines if the spaceship returns to its original position after executing the command string. Parameters: cmd (str): A string of movement commands where each command is 'G', 'L', or 'R'. Returns: str: \\"Yes\\" if the spaceship returns to (0,0), \\"No\\" otherwise. x, y = 0, 0 # Initial Position direction = 0 # 0: North, 1: East, 2: South, 3: West directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Corresponding movements for N, E, S, W for move in cmd: if move == 'G': x += directions[direction][0] y += directions[direction][1] elif move == 'L': direction = (direction - 1) % 4 elif move == 'R': direction = (direction + 1) % 4 return \\"Yes\\" if x == 0 and y == 0 else \\"No\\""},{"question":"def isMatch(s: str, p: str) -> bool: Returns True if the string s matches the pattern p, otherwise returns False. The pattern p may contain wildcard characters '?' and '*' >>> isMatch(\\"aa\\", \\"a\\") False >>> isMatch(\\"aa\\", \\"*\\") True >>> isMatch(\\"cb\\", \\"?a\\") False >>> isMatch(\\"adceb\\", \\"*a*b\\") True >>> isMatch(\\"acdcb\\", \\"a*c?b\\") False","solution":"def isMatch(s, p): Returns True if the string s matches the pattern p, otherwise returns False. The pattern p may contain wildcard characters '?' and '*'. m, n = len(s), len(p) # Create a DP table with all elements as False initially dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty pattern matches empty string dp[0][0] = True # Handle patterns with * at the start which can match an empty string \`s\` for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '*': # * can match zero or more characters from s dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == '?' or s[i - 1] == p[j - 1]: # Match single character or any character dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"from typing import List def sieve(n: int) -> List[int]: Generates a list of prime numbers up to n using the Sieve of Eratosthenes. primes = [] is_prime = [True] * (n + 1) for p in range(2, n + 1): if is_prime[p]: primes.append(p) for multiple in range(p * p, n + 1, p): is_prime[multiple] = False return primes def generate_factors(n: int) -> List[List[int]]: Generates prime factors for each number up to n. factors = [[] for _ in range(n + 1)] is_prime = [True] * (n + 1) for num in range(2, n + 1): if is_prime[num]: for multiple in range(num, n + 1, num): is_prime[multiple] = False factors[multiple].append(num) return factors def max_possible_sum(B: List[int]) -> int: Calculates the maximum possible sum of elements by replacing each element with either itself or one of its prime factors to achieve the maximum sum. max_val = max(B) factors = generate_factors(max_val) max_sum = 0 for num in B: if num == 1: max_sum += 1 else: max_sum += max([num] + factors[num]) return max_sum def process_test_cases(test_cases: List[tuple]) -> List[int]: Processes multiple test cases and returns the results. results = [] for M, B in test_cases: result = max_possible_sum(B) results.append(result) return results # The primary function to handle the input and output def main(): import sys input = sys.stdin.read data = input().split() index = 0 P = int(data[index]) index += 1 test_cases = [] for _ in range(P): M = int(data[index]) index += 1 B = list(map(int, data[index:index + M])) index += M test_cases.append((M, B)) results = process_test_cases(test_cases) for result in results: print(result)","solution":"def sieve(n): primes = [] is_prime = [True] * (n + 1) for p in range(2, n + 1): if is_prime[p]: primes.append(p) for multiple in range(p * p, n + 1, p): is_prime[multiple] = False return primes def generate_factors(n): factors = [[] for _ in range(n + 1)] is_prime = [True] * (n + 1) for num in range(2, n + 1): if is_prime[num]: for multiple in range(num, n + 1, num): is_prime[multiple] = False factors[multiple].append(num) return factors def max_possible_sum(B): max_val = max(B) factors = generate_factors(max_val) max_sum = 0 for num in B: if num == 1: max_sum += 1 else: max_sum += max([num] + factors[num]) return max_sum def process_test_cases(test_cases): results = [] for M, B in test_cases: result = max_possible_sum(B) results.append(result) return results # The primary function to handle the input and output def main(): import sys input = sys.stdin.read data = input().split() index = 0 P = int(data[index]) index += 1 test_cases = [] for _ in range(P): M = int(data[index]) index += 1 B = list(map(int, data[index:index + M])) index += M test_cases.append((M, B)) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def find_shortest_title(titles): Finds the shortest book title from a list of book titles. Parameters: titles (list): A list of book titles Returns: str: The shortest book title >>> find_shortest_title([\\"The Great Gatsby\\", \\"A Tale of Two Cities\\", \\"Ulysses\\", \\"Don Quixote\\", \\"It\\"]) 'It' >>> find_shortest_title([\\"War and Peace\\", \\"1984\\", \\"Sun\\", \\"War\\"]) 'Sun' >>> find_shortest_title([]) '' >>> find_shortest_title([\\"Alpha\\", \\"Bravo\\", \\"charlie\\", \\"delta\\", \\"Echo\\"]) 'Echo' [[ Your solution goes here ]]","solution":"def find_shortest_title(titles): Finds the shortest book title from a list of book titles. Parameters: titles (list): A list of book titles Returns: str: The shortest book title if not titles: return \\"\\" shortest_title = titles[0] shortest_length = len(shortest_title) for title in titles[1:]: if len(title) < shortest_length: shortest_title = title shortest_length = len(title) return shortest_title # Function to read input and call the core logic def process_book_titles(): import sys input = sys.stdin.read data = input().strip().split('n') N = int(data[0]) titles = data[1:N+1] shortest_title = find_shortest_title(titles) print(shortest_title)"},{"question":"def final_order(n: int, people: List[Tuple[int, int]]) -> List[int]: Determine the final order of people in the queue before they start buying tickets. Args: n (int): The number of people in the queue. people (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, the time a person has already waited and their patience limit. Returns: List[int]: The final order of people in the queue (1-based index). Examples: >>> final_order(5, [(2, 3), (0, 4), (1, 2), (3, 5), (2, 1)]) [2, 3, 5, 1, 4] >>> final_order(3, [(0, 1), (1, 1), (2, 2)]) [1, 2, 3]","solution":"def final_order(n, people): from collections import deque queue = deque([(i + 1, people[i][0], people[i][1]) for i in range(n)]) ordered_people = [] while queue: idx, w, p = queue.popleft() if not queue or w <= queue[0][1]: ordered_people.append(idx) else: queue.append((idx, w, p)) return ordered_people"},{"question":"def count_frequency(arr, x): Returns the frequency of x in the sorted array arr. >>> count_frequency([1, 2, 2, 2, 3, 4, 5], 2) 3 >>> count_frequency([1, 2, 3, 4], 5) 0 >>> count_frequency([-10, -5, 0, 5, 10, 10], 10) 2","solution":"def count_frequency(arr, x): Returns the frequency of x in the sorted array arr. from bisect import bisect_left, bisect_right left_index = bisect_left(arr, x) right_index = bisect_right(arr, x) return right_index - left_index"},{"question":"def find_mirror_words(words): This function takes a list of words and finds pairs of words that are mirrors of each other. >>> find_mirror_words([\\"abc\\", \\"cba\\", \\"xyz\\", \\"zyx\\", \\"def\\"]) [(\\"abc\\", \\"cba\\"), (\\"xyz\\", \\"zyx\\")] >>> find_mirror_words([\\"hello\\", \\"world\\", \\"dlrow\\", \\"olleh\\"]) [(\\"hello\\", \\"olleh\\"), (\\"world\\", \\"dlrow\\")] >>> find_mirror_words([\\"abc\\", \\"def\\", \\"ghi\\"]) [\\"No mirror words found\\"]","solution":"def find_mirror_words(words): This function takes a list of words and finds pairs of words that are mirrors of each other. output = [] used = set() for i, word1 in enumerate(words): if word1 in used: continue for j, word2 in enumerate(words[i+1:], start=i+1): if word2 in used: continue if word1 == word2[::-1]: output.append((word1, word2)) used.add(word1) used.add(word2) break return output if output else [\\"No mirror words found\\"]"},{"question":"def second_smallest_number(arr): Returns the second smallest number in the array or -1 if it does not exist. >>> second_smallest_number([4, 2, 1, 3, 5]) 2 >>> second_smallest_number([7, 7, 7, 7]) -1 >>> second_smallest_number([-1, -2, -3]) -2 >>> second_smallest_number([10, -1, 5, 3, -5, 0]) -1 >>> second_smallest_number([1]) -1 >>> second_smallest_number([2, 3]) 3 >>> second_smallest_number([1, 1, 1, 2]) 2 >>> second_smallest_number([1000000000, -1000000000, 0, 50, -999999999, 999999999]) -999999999","solution":"def second_smallest_number(arr): Returns the second smallest number in the array or -1 if it does not exist. if len(arr) < 2: return -1 unique_elements = list(set(arr)) if len(unique_elements) < 2: return -1 unique_elements.sort() return unique_elements[1]"},{"question":"def can_form_palindrome(s: str) -> str: Determines if it's possible to rearrange the string to form a palindrome. >>> can_form_palindrome(\\"civic\\") == \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") == \\"YES\\" >>> can_form_palindrome(\\"hello\\") == \\"NO\\" >>> can_form_palindrome(\\"a\\") == \\"YES\\" >>> can_form_palindrome(\\"aaaa\\") == \\"YES\\" >>> can_form_palindrome(\\"aabbccdd\\") == \\"YES\\" >>> can_form_palindrome(\\"abcdefgh\\") == \\"NO\\" >>> can_form_palindrome(\\"aabbccddd\\") == \\"YES\\" >>> can_form_palindrome(\\"aabbccc\\") == \\"YES\\" >>> can_form_palindrome(\\"abc\\") == \\"NO\\"","solution":"def can_form_palindrome(s): Determines if it's possible to rearrange the string to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # A string can be rearranged to form a palindrome if at most one character has an odd count odd_count_chars = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count_chars <= 1 else \\"NO\\""},{"question":"from typing import List def longest_palindromic_subsequence_length(s: str) -> int: Determine the length of the longest subsequence of books that can be rearranged to form a palindrome. Parameters: s (str): A string of lowercase English letters. Returns: int: Length of the longest palindromic subsequence. >>> longest_palindromic_subsequence_length(\\"abca\\") 3 >>> longest_palindromic_subsequence_length(\\"abcba\\") 5 >>> longest_palindromic_subsequence_length(\\"abc\\") 1 pass # Sample test cases for the function def test_all_same_characters(): assert longest_palindromic_subsequence_length(\\"aaaa\\") == 4 assert longest_palindromic_subsequence_length(\\"bbb\\") == 3 def test_no_repeating_characters(): assert longest_palindromic_subsequence_length(\\"abcd\\") == 1 assert longest_palindromic_subsequence_length(\\"xyz\\") == 1 def test_one_odd_character(): assert longest_palindromic_subsequence_length(\\"aabb\\") == 4 assert longest_palindromic_subsequence_length(\\"abcca\\") == 5 def test_mixed_characters(): assert longest_palindromic_subsequence_length(\\"abca\\") == 3 assert longest_palindromic_subsequence_length(\\"abcba\\") == 5 assert longest_palindromic_subsequence_length(\\"aabbcc\\") == 6 def test_single_character(): assert longest_palindromic_subsequence_length(\\"a\\") == 1 assert longest_palindromic_subsequence_length(\\"z\\") == 1 def test_two_characters(): assert longest_palindromic_subsequence_length(\\"aa\\") == 2 assert longest_palindromic_subsequence_length(\\"ab\\") == 1","solution":"from collections import Counter def longest_palindromic_subsequence_length(s): Returns the length of the longest palindromic subsequence that can be made from the input string. Parameters: s (str): A string consisting of lowercase English letters. Returns: int: The length of the longest palindromic subsequence. count = Counter(s) length = 0 odd_found = False for char, freq in count.items(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def shortest_path_length(n: int, m: int, grid: List[List[str]]) -> int: A logistics company handles the delivery of packages in a city represented as a grid of size n x m. Each cell in the grid either contains a delivery point (denoted as '*') or is empty (denoted as '.'). The company wants to find the shortest path that visits all the delivery points exactly once and returns to the starting point (0, 0). The path can move up, down, left, or right but cannot move diagonally. Returns the length of the shortest such path, or -1 if it is not possible to visit all the delivery points. >>> grid = [['*', '.', '.'], ['.', '*', '.'], ['.', '.', '*']] >>> shortest_path_length(3, 3, grid) 8 >>> grid = [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']] >>> shortest_path_length(3, 3, grid) -1 >>> grid = [['*', '#', '*'], ['#', '#', '#'], ['*', '#', '*']] >>> shortest_path_length(3, 3, grid) -1 >>> grid = [['*', '.', '.'], ['.', '.', '.'], ['.', '.', '.']] >>> shortest_path_length(3, 3, grid) 0 >>> grid = [['*', '*'], ['*', '*']] >>> shortest_path_length(2, 2, grid) 4","solution":"from itertools import permutations from collections import deque import sys import numpy as np def bfs(start, grid, n, m): Perform BFS to find the shortest path from start to all delivery points. queue = deque([start]) distance = {start: 0} while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in distance and grid[nx][ny] != '#': distance[(nx, ny)] = distance[(x, y)] + 1 queue.append((nx, ny)) return distance def shortest_path_length(n, m, grid): # Check if the starting point is a delivery point; if not, return -1 if grid[0][0] != '*': return -1 # Identify all delivery points delivery_points = [] for i in range(n): for j in range(m): if grid[i][j] == '*': delivery_points.append((i, j)) # Calculate pairwise distances between all delivery points using BFS distances = {} for dp in delivery_points: distances[dp] = bfs(dp, grid, n, m) # Try all permutations of the delivery points to find the shortest path min_path_length = float('inf') for perm in permutations(delivery_points): # make sure the path starts from (0, 0) and ends at the same place if perm[0] == (0, 0): path_length = 0 valid_path = True for i in range(1, len(perm)): if perm[i] in distances[perm[i-1]]: path_length += distances[perm[i-1]][perm[i]] else: valid_path = False break if valid_path and (0, 0) in distances[perm[-1]]: path_length += distances[perm[-1]][(0, 0)] min_path_length = min(min_path_length, path_length) return min_path_length if min_path_length != float('inf') else -1"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in a given string s. Args: s (str): A string consisting of alphanumeric characters. Returns: str: The longest palindromic substring within the input string. Examples: >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" True from solution import longest_palindromic_substring def test_longest_palindromic_substring(): assert longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" assert longest_palindromic_substring(\\"a\\") == \\"a\\" assert longest_palindromic_substring(\\"ac\\") == \\"a\\" assert longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" assert longest_palindromic_substring(\\"banana\\") == \\"anana\\" assert longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" assert longest_palindromic_substring(\\"\\") == \\"\\" def test_longest_palindromic_substring_single_character(): assert longest_palindromic_substring(\\"aaaaa\\") == \\"aaaaa\\" assert longest_palindromic_substring(\\"abcde\\") == \\"a\\" assert longest_palindromic_substring(\\"abccba\\") == \\"abccba\\" def test_longest_palindromic_substring_non_palindromes(): assert longest_palindromic_substring(\\"abcdfg\\") == \\"a\\" assert longest_palindromic_substring(\\"xyz\\") == \\"x\\"","solution":"def longest_palindromic_substring(s): Find the longest palindromic substring in a given string s. if len(s) == 0: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] max_palindrome = \\"\\" for i in range(len(s)): # odd length palindromes odd_palindrome = expand_around_center(s, i, i) if len(odd_palindrome) > len(max_palindrome): max_palindrome = odd_palindrome # even length palindromes even_palindrome = expand_around_center(s, i, i+1) if len(even_palindrome) > len(max_palindrome): max_palindrome = even_palindrome return max_palindrome"},{"question":"def min_containers(N: int, M: int, capacities: List[int]) -> int: Returns the minimum number of containers required to store exactly M liters of water. Parameters: N (int): Number of containers M (int): Total liters of water to store capacities (list): List of capacities of the containers Returns: int: Minimum number of containers to store exactly M liters of water >>> min_containers(5, 13, [5, 8, 3, 7, 9]) == 2 >>> min_containers(1, 10, [15]) == 1 >>> min_containers(3, 10, [3, 3, 4]) == 3 >>> min_containers(4, 10, [2, 7, 1, 3]) == 2 >>> min_containers(4, 10000, [2500, 3000, 2000, 2500]) == 4 >>> min_containers(1, 1, [1]) == 1","solution":"def min_containers(N, M, capacities): Returns the minimum number of containers required to store exactly M liters of water. Parameters: N (int): Number of containers M (int): Total liters of water to store capacities (list): List of capacities of the containers Returns: int: Minimum number of containers to store exactly M liters of water capacities.sort(reverse=True) # Sort capacities in descending order count = 0 for capacity in capacities: if M <= 0: break M -= capacity count += 1 return count"},{"question":"def daily_temperatures(T): Calculates the number of days you would have to wait until a warmer temperature for each day. Args: T (List[int]): List of daily temperatures. Returns: List[int]: List where each index contains the number of days to wait for a warmer temperature. Examples: >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 60, 90]) [1, 1, 0]","solution":"def daily_temperatures(T): Calculates the number of days you would have to wait until a warmer temperature for each day. answer = [0] * len(T) stack = [] for i in range(len(T) - 1, -1, -1): while stack and T[i] >= T[stack[-1]]: stack.pop() if stack: answer[i] = stack[-1] - i stack.append(i) return answer"},{"question":"def minglish_number(n: int) -> str: This function converts a base 10 number to its Minglish number system representation. In Minglish system, the digits are read from right to left, meaning the digits are reversed. Args: n (int): The input number in base 10. Returns: str: The Minglish number representation as a string. >>> minglish_number(12345) \\"54321\\" >>> minglish_number(9876) \\"6789\\" >>> minglish_number(1001) \\"1001\\" >>> minglish_number(0) \\"0\\" >>> minglish_number(789) \\"987\\" >>> minglish_number(121) \\"121\\" >>> minglish_number(12321) \\"12321\\" >>> minglish_number(1000) \\"0001\\" >>> minglish_number(50200) \\"00205\\"","solution":"def minglish_number(n): This function converts a base 10 number to its Minglish number system representation. In Minglish system, the digits are read from right to left, meaning the digits are reversed. Args: n (int): The input number in base 10. Returns: str: The Minglish number representation as a string. return str(n)[::-1]"},{"question":"def can_collect_three_treasures(n, treasures): Determine if Charlotte can collect exactly three treasures without entering overlapping magnetic fields. Args: n (int): The number of treasures. treasures (List[Tuple[int, int, int]]): A list of tuples where each tuple contains the x, y coordinates and radius of the treasure's magnetic field. Returns: str or List[Tuple[int, int]]: If possible, returns the coordinates of the three treasures in order. Otherwise, returns \\"Charlotte cannot collect three treasures.\\" def read_input_and_solve(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) treasures = [] for i in range(1, len(data), 3): x = int(data[i]) y = int(data[i+1]) r = int(data[i+2]) treasures.append((x, y, r)) result = can_collect_three_treasures(n, treasures) if isinstance(result, str): print(result) else: for coord in result: print(f'{coord}')","solution":"def can_collect_three_treasures(n, treasures): import itertools treasures.sort() def are_fields_separate(t1, t2): x1, y1, r1 = t1 x2, y2, r2 = t2 dx = x1 - x2 dy = y1 - y2 distance_squared = dx * dx + dy * dy radius_sum_squared = (r1 + r2) * (r1 + r2) return distance_squared >= radius_sum_squared for comb in itertools.combinations(treasures, 3): if (are_fields_separate(comb[0], comb[1]) and are_fields_separate(comb[1], comb[2]) and are_fields_separate(comb[0], comb[2])): return [tuple(comb[0][:2]), tuple(comb[1][:2]), tuple(comb[2][:2])] return \\"Charlotte cannot collect three treasures.\\" def read_input_and_solve(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) treasures = [] for i in range(1, len(data), 3): x = int(data[i]) y = int(data[i+1]) r = int(data[i+2]) treasures.append((x, y, r)) result = can_collect_three_treasures(n, treasures) if isinstance(result, str): print(result) else: for coord in result: print(f'{coord}') # Assuming read_input_and_solve will be called and supplied via standard input for testing purposes."},{"question":"def common_delivery_point(routes): Determines if all delivery routes have at least one common delivery point. :param routes: List of lists, where each list contains delivery points for a specific route. :return: 'yes' if there is at least one common delivery point, otherwise 'no'. pass def solve(test_cases): Solves the problem for multiple test cases. :param test_cases: A list of test cases where each test case is a list of delivery routes. :return: A list of strings, each being 'yes' or 'no' depending on the result for the test case. pass def parse_input(input_string): Parses the input string into the required format for the \`solve\` function. :param input_string: The input string containing the test case description. :return: A list corresponding to test cases where each element is a list of delivery routes. pass def format_output(results): Formats the output for printing or other usage. :param results: A list of strings containing 'yes' or 'no' for each test case. :return: A string representation suitable for the output. pass # Example usage input_string = \\"3n3n1 2 3n2 3 4n3 4 5n2n1 2 3n4 5 6n4n7 8 9 10n7 8 11 12n7 13 14 15n7 16 17 18\\" test_cases = parse_input(input_string) results = solve(test_cases) output_string = format_output(results) print(output_string) # Example test cases def test_common_delivery_point(): assert common_delivery_point([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == \\"yes\\" assert common_delivery_point([[1, 2, 3], [4, 5, 6]]) == \\"no\\" assert common_delivery_point([[7, 8, 9, 10], [7, 8, 11, 12], [7, 13, 14, 15], [7, 16, 17, 18]]) == \\"yes\\" def test_solve(): test_cases = [ [[1, 2, 3], [2, 3, 4], [3, 4, 5]], [[1, 2, 3], [4, 5, 6]], [[7, 8, 9, 10], [7, 8, 11, 12], [7, 13, 14, 15], [7, 16, 17, 18]] ] assert solve(test_cases) == [\\"yes\\", \\"no\\", \\"yes\\"] def test_parse_input(): input_string = \\"3n3n1 2 3n2 3 4n3 4 5n2n1 2 3n4 5 6n4n7 8 9 10n7 8 11 12n7 13 14 15n7 16 17 18\\" expected_output = [ [[1, 2, 3], [2, 3, 4], [3, 4, 5]], [[1, 2, 3], [4, 5, 6]], [[7, 8, 9, 10], [7, 8, 11, 12], [7, 13, 14, 15], [7, 16, 17, 18]] ] assert parse_input(input_string) == expected_output def test_format_output(): results = [\\"yes\\", \\"no\\", \\"yes\\"] assert format_output(results) == \\"yesnnonyes\\" # Combining everything for a full flow test def test_full_flow(): input_string = \\"3n3n1 2 3n2 3 4n3 4 5n2n1 2 3n4 5 6n4n7 8 9 10n7 8 11 12n7 13 14 15n7 16 17 18\\" expected_output = \\"yesnnonyes\\" test_cases = parse_input(input_string) results = solve(test_cases) output_string = format_output(results) assert output_string == expected_output","solution":"def common_delivery_point(routes): Determines if all delivery routes have at least one common delivery point. :param routes: List of lists, where each list contains delivery points for a specific route. :return: 'yes' if there is at least one common delivery point, otherwise 'no'. # Using set intersection to find common points in all routes common_points = set(routes[0]) for route in routes[1:]: common_points &= set(route) return \\"yes\\" if common_points else \\"no\\" def solve(test_cases): results = [] for routes in test_cases: results.append(common_delivery_point(routes)) return results def parse_input(input_string): Parses the input string into the required format for the \`solve\` function. :param input_string: The input string containing the test case description. :return: A list corresponding to test cases where each element is a list of delivery routes. lines = input_string.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 routes = [] for _ in range(N): routes.append(list(map(int, lines[index].split()))) index += 1 test_cases.append(routes) return test_cases def format_output(results): Formats the output for printing or other usage. :param results: A list of strings containing 'yes' or 'no' for each test case. :return: A string representation suitable for the output. return \\"n\\".join(results)"},{"question":"def solve(t: int, test_cases: List[int]) -> List[str]: Determines if it is possible to arrange n magic stones in a special sequence for each test case. >>> solve(3, [4, 5, 3]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> solve(4, [1, 2, 3, 6]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] def is_prime(num: int) -> bool: # Checks whether a number is a prime number. def can_form_special_sequence(n: int) -> str: # Determines if it's possible to form a special sequence with n stones. # Main logic to solve for all test cases.","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def can_form_special_sequence(n): if n == 1: return \\"YES\\" for i in range(1, n): if not is_prime(i + i + 1): return \\"NO\\" return \\"YES\\" def solve(t, test_cases): results = [] for n in test_cases: results.append(can_form_special_sequence(n)) return results"},{"question":"def maximize_crates_to_market_d(n: int, m: int, d: int, trips: List[Tuple[int, int, int, int]]) -> int: Returns the total number of crates delivered to market destination d if choosing the optimal set of trips. Args: n (int): Number of trips available. m (int): Number of market destinations. d (int): Specific market destination to maximize crate deliveries to. trips (list of tuples): Each tuple contains four integers (s_i, e_i, c_i, t_i) representing the start day, end day, number of crates, and destination market of the trip, respectively. Returns: int: Total number of crates delivered to market destination d >>> n, m, d = 5, 3, 2 >>> trips = [(1, 3, 10, 2), (2, 5, 15, 1), (4, 6, 20, 2), (5, 9, 25, 3), (7, 8, 30, 2)] >>> maximize_crates_to_market_d(n, m, d, trips) 60 >>> n, m, d = 3, 2, 1 >>> trips = [(2, 4, 10, 1), (3, 5, 15, 1), (6, 7, 20, 2)] >>> maximize_crates_to_market_d(n, m, d, trips) 25 >>> n, m, d = 4, 3, 3 >>> trips = [(1, 2, 10, 1), (2, 3, 20, 2), (4, 5, 30, 3), (6, 7, 40, 1)] >>> maximize_crates_to_market_d(n, m, d, trips) 30 >>> n, m, d = 4, 3, 3 >>> trips = [(1, 2, 10, 1), (2, 3, 20, 2), (4, 5, 30, 1), (6, 7, 40, 1)] >>> maximize_crates_to_market_d(n, m, d, trips) 0","solution":"def maximize_crates_to_market_d(n, m, d, trips): Returns the total number of crates delivered to market destination d if choosing the optimal set of trips. crates_to_d = 0 for trip in trips: s_i, e_i, c_i, t_i = trip if t_i == d: crates_to_d += c_i return crates_to_d # Example input n = 5 m = 3 d = 2 trips = [ (1, 3, 10, 2), (2, 5, 15, 1), (4, 6, 20, 2), (5, 9, 25, 3), (7, 8, 30, 2), ] print(maximize_crates_to_market_d(n, m, d, trips)) # Output should be 60"},{"question":"def min_waiting_time(n, m, arrival_times, favorable_stations): Returns the minimum waiting time Brad has to wait at a station after boarding the train. Parameters: n (int): Number of stations. m (int): Number of favorable stations. arrival_times (list of int): Arrival times at each station. favorable_stations (list of int): Indices of the favorable stations (1-based). Returns: int: Minimum waiting time. >>> min_waiting_time(5, 2, [1, 3, 5, 7, 9], [2, 4]) 2 >>> min_waiting_time(2, 1, [1, 4], [2]) 3 >>> min_waiting_time(4, 4, [2, 4, 6, 8], [1, 2, 3, 4]) 0 >>> min_waiting_time(5, 3, [1, 100000, 200000, 300000, 400000], [2, 3, 5]) 99999 >>> min_waiting_time(6, 2, [3, 7, 15, 20, 25, 30], [3, 5]) 12","solution":"def min_waiting_time(n, m, arrival_times, favorable_stations): Returns the minimum waiting time Brad has to wait at a station after boarding the train. Parameters: n (int): Number of stations. m (int): Number of favorable stations. arrival_times (list of int): Arrival times at each station. favorable_stations (list of int): Indices of the favorable stations (1-based). Returns: int: Minimum waiting time. # Convert favorable station indices to zero-based. favorable_stations = [index - 1 for index in favorable_stations] # Compute waiting times for each favorable station waiting_times = [arrival_times[fav] - arrival_times[0] for fav in favorable_stations] # Return the minimum waiting time return min(waiting_times)"},{"question":"def frequency_count(s: str) -> dict: Returns a dictionary where the keys are the characters from the input string (excluding spaces), and the values are the number of times each character appears. >>> frequency_count(\\"hello world\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> frequency_count(\\"The quick brown fox jumps over the lazy dog\\") {'T': 1, 'h': 2, 'e': 3, 'q': 1, 'u': 2, 'i': 1, 'c': 1, 'k': 1, 'b': 1, 'r': 2, 'o': 4, 'w': 1, 'n': 1, 'f': 1, 'x': 1, 'j': 1, 'm': 1, 'p': 1, 's': 1, 'v': 1, 't': 1, 'l': 1, 'a': 1, 'z': 1, 'y': 1, 'd': 1, 'g': 1} >>> frequency_count(\\"\\") == {} True >>> frequency_count(\\"a\\") {'a': 1} >>> frequency_count(\\"AaBbCc\\") {'A': 1, 'a': 1, 'B': 1, 'b': 1, 'C': 1, 'c': 1} >>> frequency_count(\\"abac\\") {'a': 2, 'b': 1, 'c': 1} >>> frequency_count(\\"123 123!\\") {'1': 2, '2': 2, '3': 2, '!': 1} >>> frequency_count(\\"aaaabbbbcccc\\") {'a': 4, 'b': 4, 'c': 4} >>> frequency_count(\\"@#* &%\\") {'@': 1, '#': 1, '*': 1, '&': 1, '%': 1} pass","solution":"def frequency_count(s): Returns a dictionary where the keys are the characters from the input string (excluding spaces), and the values are the number of times each character appears. freq_dict = {} for char in s: if char != ' ': if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return freq_dict"},{"question":"def longest_alternating_subsequence(n: int, dna_sequence: str) -> int: Finds the length of the longest contiguous subsequence in a DNA sequence that strictly alternates between two different nucleotides. Parameters: n (int): Length of the DNA sequence dna_sequence (str): The DNA sequence consisting of characters 'A', 'C', 'G', and 'T'. Returns: int: Length of the longest alternating subsequence. >>> longest_alternating_subsequence(8, \\"ACGTACGT\\") 8 >>> longest_alternating_subsequence(20, \\"AAAACCCCGGGGTTTTTTTT\\") 2 from solution import longest_alternating_subsequence def test_example_cases(): assert longest_alternating_subsequence(8, \\"ACGTACGT\\") == 8 assert longest_alternating_subsequence(20, \\"AAAACCCCGGGGTTTTTTTT\\") == 2 def test_single_character(): assert longest_alternating_subsequence(1, \\"A\\") == 0 assert longest_alternating_subsequence(1, \\"C\\") == 0 assert longest_alternating_subsequence(1, \\"G\\") == 0 assert longest_alternating_subsequence(1, \\"T\\") == 0 def test_two_characters(): assert longest_alternating_subsequence(2, \\"AG\\") == 2 assert longest_alternating_subsequence(2, \\"AA\\") == 1 def test_no_alternation(): assert longest_alternating_subsequence(5, \\"CCCCC\\") == 1 def test_all_alternating_pairs(): assert longest_alternating_subsequence(6, \\"TGTGTG\\") == 6 assert longest_alternating_subsequence(8, \\"CACACACA\\") == 8 def test_large_input(): sequence = \\"ATATATATATATATATATAT\\" # 10 pairs, 20 characters long assert longest_alternating_subsequence(20, sequence) == 20","solution":"def longest_alternating_subsequence(n, dna_sequence): Finds the length of the longest contiguous subsequence in a DNA sequence that strictly alternates between two different nucleotides. Parameters: n (int): Length of the DNA sequence dna_sequence (str): The DNA sequence consisting of characters 'A', 'C', 'G', and 'T'. Returns: int: Length of the longest alternating subsequence. if n < 2: return 0 longest_length = 1 current_length = 1 for i in range(1, n): if dna_sequence[i] != dna_sequence[i-1]: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length"},{"question":"def determine_nature_of_roots(n, coefficients): Determines the nature of the roots of quadratic equations based on the coefficients provided. >>> determine_nature_of_roots(3, [[1, -3, 2], [1, -2, 1], [1, 1, 1]]) [\\"Real and Distinct\\", \\"Real and Equal\\", \\"Complex\\"] >>> determine_nature_of_roots(2, [[1, 3, -4], [2, 5, -3]]) [\\"Real and Distinct\\", \\"Real and Distinct\\"] >>> determine_nature_of_roots(2, [[1, -2, 1], [4, -4, 1]]) [\\"Real and Equal\\", \\"Real and Equal\\"] >>> determine_nature_of_roots(2, [[1, 0, 1], [1, 2, 5]]) [\\"Complex\\", \\"Complex\\"]","solution":"def determine_nature_of_roots(n, coefficients): Determines the nature of the roots of quadratic equations based on the coefficients provided. Args: n (int): Number of quadratic equations. coefficients (list of list of int): A 2D list containing the coefficients of the quadratic equations. Returns: list of str: A list containing the nature of the roots for each equation. nature_of_roots = [] for coef in coefficients: a, b, c = coef discriminant = b**2 - 4*a*c if discriminant > 0: nature_of_roots.append(\\"Real and Distinct\\") elif discriminant == 0: nature_of_roots.append(\\"Real and Equal\\") else: nature_of_roots.append(\\"Complex\\") return nature_of_roots"},{"question":"def increment_elements(n, t, positions): Creates an array of size n initialized to 0 and increments the elements at the specified positions by 1. Parameters: n (int): Size of the array. t (int): Number of elements to be incremented. positions (list of int): Positions to be incremented (1-based index). Returns: list of int: The modified array after incrementing the specified positions. >>> increment_elements(5, 3, [1, 3, 5]) [1, 0, 1, 0, 1] >>> increment_elements(8, 4, [2, 4, 6, 8]) [0, 1, 0, 1, 0, 1, 0, 1]","solution":"def increment_elements(n, t, positions): Creates an array of size n initialized to 0 and increments the elements at the specified positions by 1. Parameters: n (int): Size of the array. t (int): Number of elements to be incremented. positions (list of int): Positions to be incremented (1-based index). Returns: list of int: The modified array after incrementing the specified positions. arr = [0] * n for pos in positions: if 1 <= pos <= n: arr[pos - 1] += 1 return arr"},{"question":"def interpret_assignments(input_lines): Takes a sequence of variable assignments and prints the value assigned to each variable immediately after the assignment, following the format: \`variable: value\`. Args: input_lines (List[str]): A list of assignment strings in the format \\"variable = value\\". Returns: List[str]: A list of strings where each string represents the variable and its assigned value in the format \\"variable: value\\". Examples: >>> interpret_assignments([\\"x = 5\\"]) [\\"x: 5\\"] >>> interpret_assignments([\\"x = 5\\", \\"y = 10\\", \\"x = 7\\"]) [\\"x: 5\\", \\"y: 10\\", \\"x: 7\\"] >>> interpret_assignments([\\"x = 5\\", \\"\\", \\"y = 10\\", \\" \\", \\"x = 7\\"]) [\\"x: 5\\", \\"y: 10\\", \\"x: 7\\"] >>> interpret_assignments([\\" x = 5 \\", \\"y= 10\\", \\" x=7 \\"]) [\\"x: 5\\", \\"y: 10\\", \\"x: 7\\"] >>> interpret_assignments([\\"a = -1\\", \\"b = -100\\"]) [\\"a: -1\\", \\"b: -100\\"]","solution":"def interpret_assignments(input_lines): Takes a sequence of variable assignments and prints the value assigned to each variable immediately after the assignment, following the format: \`variable: value\`. results = [] for line in input_lines: if line.strip(): # Ignore empty lines variable, value = line.split('=') variable = variable.strip() value = value.strip() results.append(f\\"{variable}: {value}\\") return results"},{"question":"def time_to_minutes(time_str: str) -> int: Convert a time string in HH:MM format to minutes since midnight. pass def check_schedule_conflict(sessions: List[str]) -> str: Determine if there is any schedule conflict among the sessions. Each session is represented by a start and end time in the format HH:MM-HH:MM. Returns \\"No conflicts\\" if there are no overlapping sessions, otherwise \\"Schedule conflict\\". pass def organize_workshop(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Organize the workshop by ensuring there is no schedule conflict between multiple sessions. Input: - t: Number of test cases. - test_cases: A list of tuples, where each tuple contains: - n: Number of sessions. - sessions: A list of session times in the format HH:MM-HH:MM. Output: - A list of strings, one for each test case's result, \\"No conflicts\\" or \\"Schedule conflict\\". >>> organize_workshop(2, [(3, [\\"09:00-10:30\\", \\"10:45-12:00\\", \\"11:00-12:30\\"]), (2, [\\"13:00-14:00\\", \\"14:00-15:00\\"])]) [\\"Schedule conflict\\", \\"No conflicts\\"] pass","solution":"def time_to_minutes(time_str): Convert a time string in HH:MM format to minutes since midnight. hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes def check_schedule_conflict(sessions): Determine if there is any schedule conflict among the sessions. Each session is represented by a start and end time in the format HH:MM-HH:MM. Returns \\"No conflicts\\" if there are no overlapping sessions, otherwise \\"Schedule conflict\\". times = [] for session in sessions: start, end = session.split('-') start_minutes = time_to_minutes(start) end_minutes = time_to_minutes(end) times.append((start_minutes, end_minutes)) # Sort sessions by start time times.sort() # Check for overlap for i in range(1, len(times)): if times[i][0] < times[i-1][1]: return \\"Schedule conflict\\" return \\"No conflicts\\" def organize_workshop(t, test_cases): results = [] for i in range(t): n, sessions = test_cases[i] result = check_schedule_conflict(sessions) results.append(result) return results"},{"question":"def can_form_palindrome(arr): Determines if the given array can be rearranged to form a palindrome. Parameters: arr (list): List of integers. Returns: int: 1 if the array can be rearranged to form a palindrome, 0 otherwise. def check_palindrome_arrangements(test_cases): Processes multiple test cases to determine if each array can be rearranged to form a palindrome. Parameters: test_cases (list): List of test cases where each test case is a tuple (M, list of integers). Returns: list: List of results for each test case. # Tests def test_can_form_palindrome(): assert can_form_palindrome([1, 2, 2, 1]) == 1 assert can_form_palindrome([1, 2, 3, 2, 4]) == 0 assert can_form_palindrome([1, 1, 1, 1]) == 1 assert can_form_palindrome([1, 1, 1]) == 1 assert can_form_palindrome([1, 2]) == 0 assert can_form_palindrome([]) == 1 def test_check_palindrome_arrangements(): test_cases = [ (4, [1, 2, 2, 1]), # Test case 1 (5, [1, 2, 3, 2, 4]) # Test case 2 ] expected = [1, 0] assert check_palindrome_arrangements(test_cases) == expected test_cases = [ (1, [1]), # Single element (6, [1, 2, 2, 3, 3, 1]), # Even length, palindrome-possible (5, [1, 2, 3, 3, 2]), # Odd length, palindrome-possible (5, [1, 2, 3, 3, 4]) # Odd length, not palindrome-possible ] expected = [1, 1, 1, 0] assert check_palindrome_arrangements(test_cases) == expected","solution":"def can_form_palindrome(arr): Determines if the given array can be rearranged to form a palindrome. Parameters: arr (list): List of integers. Returns: int: 1 if the array can be rearranged to form a palindrome, 0 otherwise. from collections import Counter count = Counter(arr) # Count how many elements appear an odd number of times odd_counts = sum(1 for freq in count.values() if freq % 2 != 0) # A string can form a palindrome if at most one character has an odd count return 1 if odd_counts <= 1 else 0 def check_palindrome_arrangements(test_cases): Processes multiple test cases to determine if each array can be rearranged to form a palindrome. Parameters: test_cases (list): List of test cases where each test case is a tuple (M, list of integers). Returns: list: List of results for each test case. results = [] for M, arr in test_cases: results.append(can_form_palindrome(arr)) return results"},{"question":"from typing import List def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array in their original order of appearance. Parameters: arr (list): List of integers. k (int): Number of most frequent elements to return. Returns: list: List of k most frequent elements. >>> k_most_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> k_most_frequent_elements([1, 1, 2, 2, 3, 3, 4], 3) [1, 2, 3] >>> k_most_frequent_elements([4, 4, 4, 6, 6, 8, 8, 8], 2) [4, 8]","solution":"from collections import Counter def k_most_frequent_elements(arr, k): Returns the k most frequent elements in the array in their original order of appearance. Parameters: arr (list): List of integers. k (int): Number of most frequent elements to return. Returns: list: List of k most frequent elements. if k == 0 or not arr: return [] frequency = Counter(arr) # Sorted in decreasing frequency, and for tie, based on first appearance most_frequent = sorted(frequency, key=lambda x: (-frequency[x], arr.index(x))) return most_frequent[:k]"},{"question":"def can_complete_tasks(t, test_cases): Determines if all tasks can be completed within their respective time windows in the given order. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int, int]]]]): List containing the test cases. Each test case consists of an integer n (number of tasks) and a list of tuples where each tuple contains three integers t_i, l_i, r_i. Returns: List[str]: List of \\"Yes\\" or \\"No\\" for each test case indicating if the tasks can be completed in order. >>> can_complete_tasks(3, [(3, [(5, 1, 10), (2, 6, 13), (3, 10, 20)]), (2, [(4, 3, 8), (5, 9, 12)]), (4, [(3, 1, 5), (2, 5, 9), (4, 10, 15), (3, 16, 20)])]) ['Yes', 'No', 'Yes']","solution":"def can_complete_tasks(t, test_cases): results = [] for case in test_cases: n = case[0] tasks = case[1] current_time = 0 possible = True for t_i, l_i, r_i in tasks: earliest_start = max(current_time, l_i) latest_start = r_i - t_i if earliest_start <= latest_start: current_time = earliest_start + t_i else: possible = False break if possible: results.append(\\"Yes\\") else: results.append(\\"No\\") return results # Example usage: # test input parsed accordingly t = 3 test_cases = [ (3, [(5, 1, 10), (2, 6, 13), (3, 10, 20)]), (2, [(4, 3, 8), (5, 9, 12)]), (4, [(3, 1, 5), (2, 5, 9), (4, 10, 15), (3, 16, 20)]) ] print(can_complete_tasks(t, test_cases))"},{"question":"def assign_dish_ranks(n: int, preferences: List[int]) -> List[int]: Assigns ranks to dishes such that the sum of preference scores of dishes with the highest and lowest ranks is minimized. >>> assign_dish_ranks(4, [3, 6, 2, 5]) [3, 1, 4, 2] >>> assign_dish_ranks(3, [10, 20, 30]) [3, 2, 1] from typing import List def test_assign_dish_ranks(): assert assign_dish_ranks(4, [3, 6, 2, 5]) == [3, 1, 4, 2] assert assign_dish_ranks(3, [10, 20, 30]) == [3, 2, 1] assert assign_dish_ranks(5, [5, 1, 3, 2, 4]) == [1, 5, 3, 4, 2] assert assign_dish_ranks(1, [100]) == [1] def test_assign_dish_ranks_large(): n = 100000 preferences = list(range(1, 100001)) result = assign_dish_ranks(n, preferences) assert result == list(range(100000, 0, -1)) def test_assign_dish_ranks_with_equal_preferences(): assert assign_dish_ranks(3, [10, 10, 10]) == [1, 2, 3] or [3, 2, 1] or [2, 1, 3]","solution":"def assign_dish_ranks(n, preferences): Assigns ranks to dishes such that the sum of preference scores of dishes with the highest and lowest ranks is minimized. # Create list of (index, preference) and sort by preference in descending order dishes = sorted(enumerate(preferences), key=lambda x: x[1], reverse=True) # Initialize a list to store ranks ranks = [0] * n # Distribute ranks starting from the highest preference for rank, (index, _) in enumerate(dishes): ranks[index] = rank + 1 return ranks"},{"question":"class Grid: def __init__(self, n: int, m: int, grid: List[List[int]]): Initialize the grid with n rows and m columns. Args: n (int): Number of rows. m (int): Number of columns. grid (List[List[int]]): 2D list representing the initial grid. self.n = n self.m = m self.grid = grid def update(self, x: int, y: int, v: int): Update the value at cell (x, y) to v. Args: x (int): Row of the cell to update (1-based). y (int): Column of the cell to update (1-based). v (int): New value to set. def query(self, x1: int, y1: int, x2: int, y2: int) -> int: Query the sum of numbers in the rectangular subgrid from (x1, y1) to (x2, y2). Args: x1 (int): Top-left row of the subgrid (1-based). y1 (int): Top-left column of the subgrid (1-based). x2 (int): Bottom-right row of the subgrid (1-based). y2 (int): Bottom-right column of the subgrid (1-based). Returns: int: Sum of numbers in the specified subgrid. from solution import Grid def test_initial_grid(): grid = Grid(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) assert grid.query(1, 1, 2, 2) == 12 def test_update_and_query(): grid = Grid(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) grid.update(2, 2, 10) assert grid.query(1, 1, 2, 2) == 17 def test_query_whole_grid(): grid = Grid(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) assert grid.query(1, 1, 3, 3) == 45 def test_update_and_query_whole_grid(): grid = Grid(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) grid.update(3, 3, 0) assert grid.query(1, 1, 3, 3) == 36","solution":"class Grid: def __init__(self, n, m, grid): self.n = n self.m = m self.grid = grid def update(self, x, y, v): self.grid[x-1][y-1] = v def query(self, x1, y1, x2, y2): total_sum = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): total_sum += self.grid[i][j] return total_sum"},{"question":"def sort_and_print_employee_records(records): Given a list of employee records, sorts them by salary in ascending order. If two employees have the same salary, sorts them by age in ascending order. Prints the sorted list in the format: Name: <name>, Age: <age>, Salary: <salary>. :param records: List of tuples, each containing (name: str, age: int, salary: float) pass # Example usage: # records = [ # (\\"Alice\\", 30, 60000.0), # (\\"Bob\\", 25, 50000.0), # (\\"Charlie\\", 28, 50000.0), # (\\"David\\", 35, 70000.0) # ] # sort_and_print_employee_records(records)","solution":"def sort_and_print_employee_records(records): Given a list of employee records, sorts them by salary in ascending order. If two employees have the same salary, sorts them by age in ascending order. Prints the sorted list in the format: Name: <name>, Age: <age>, Salary: <salary>. :param records: List of tuples, each containing (name: str, age: int, salary: float) sorted_records = sorted(records, key=lambda x: (x[2], x[1])) for record in sorted_records: print(f\\"Name: {record[0]}, Age: {record[1]}, Salary: {record[2]}\\") # Example usage: # records = [ # (\\"Alice\\", 30, 60000.0), # (\\"Bob\\", 25, 50000.0), # (\\"Charlie\\", 28, 50000.0), # (\\"David\\", 35, 70000.0) # ] # sort_and_print_employee_records(records)"},{"question":"def calculate_tax(income: int) -> int: Calculate the total amount of tax for a given yearly income based on the following rules: - No tax on the first 1000 yen of income. - 10% tax on income between 1001 yen and 5000 yen (inclusive). - 20% tax on income above 5000 yen. >>> calculate_tax(1000) 0 >>> calculate_tax(3000) 200 >>> calculate_tax(7500) 900 >>> calculate_tax(5000) 400 >>> calculate_tax(10000) 1400","solution":"def calculate_tax(income): tax = 0 if income <= 1000: return tax elif income <= 5000: tax += (income - 1000) * 0.1 else: tax += 400 + (income - 5000) * 0.2 return tax"},{"question":"from typing import List, Tuple def analyze_sequences(m: int, sequences: List[str], q: int, queries: List[Tuple[str, str]]) -> List[int]: Alice is working on a secret project that involves analyzing unique sequences of characters. She has a list of \`m\` unique sequences, each of a fixed length of 4. Each character in the sequence is a lowercase letter from 'a' to 'z'. She wants to conduct several queries to check the characteristics of these sequences based on specified conditions. For each query, Alice is given two letters. She needs to determine how many of the sequences contain both of these letters. Args: m (int): Number of sequences. sequences (List[str]): List of m unique sequences. q (int): Number of queries. queries (List[Tuple[str, str]]): List of q pairs of characters to query. Returns: List[int]: List of integers representing the number of sequences containing both specified characters for each query. >>> analyze_sequences(6, [\\"abcd\\", \\"bcda\\", \\"acdb\\", \\"adcb\\", \\"efgh\\", \\"ijkl\\"], 3, [(\\"a\\", \\"b\\"), (\\"c\\", \\"d\\"), (\\"e\\", \\"f\\")]) [4, 4, 1] >>> analyze_sequences(6, [\\"abcd\\", \\"abcd\\", \\"abcd\\", \\"abcd\\", \\"abcd\\", \\"abcd\\"], 2, [(\\"a\\", \\"b\\"), (\\"c\\", \\"d\\")]) [6, 6] pass","solution":"def analyze_sequences(m, sequences, q, queries): # Convert sequences to a more searchable format sequence_sets = [{\\"a\\" in seq, \\"b\\" in seq, \\"c\\" in seq, \\"d\\" in seq, \\"e\\" in seq, \\"f\\" in seq, \\"g\\" in seq, \\"h\\" in seq, \\"i\\" in seq, \\"j\\" in seq, \\"k\\" in seq, \\"l\\" in seq, \\"m\\" in seq, \\"n\\" in seq, \\"o\\" in seq, \\"p\\" in seq, \\"q\\" in seq, \\"r\\" in seq, \\"s\\" in seq, \\"t\\" in seq, \\"u\\" in seq, \\"v\\" in seq, \\"w\\" in seq, \\"x\\" in seq, \\"y\\" in seq, \\"z\\" in seq} for seq in sequences] results = [] for query in queries: char1, char2 = query count = sum(1 for seq in sequences if char1 in seq and char2 in seq) results.append(count) return results"},{"question":"from typing import List, Tuple def is_good_binary_tree(n: int, nodes: List[Tuple[int, int, int]]) -> str: Determine if the binary tree represented by the given nodes is a good binary tree. >>> is_good_binary_tree(5, [(10, 5, 15), (5, 3, 6), (15, -1, 20), (3, -1, -1), (6, -1, -1), (20, -1, -1)]) == \\"YES\\" >>> is_good_binary_tree(6, [(10, 6, 15), (6, 3, 8), (15, 7, -1), (3, -1, -1), (8, -1, -1), (7, -1, -1)]) == \\"NO\\" >>> is_good_binary_tree(5, [(5, 3, 7), (3, 1, 4), (7, -1, 9), (1, -1, -1), (4, -1, -1), (9, -1, -1)]) == \\"YES\\" >>> is_good_binary_tree(1, [(1, -1, -1)]) == \\"YES\\" >>> is_good_binary_tree(3, [(2, 1, 3), (1, -1, -1), (3, -1, -1)]) == \\"YES\\"","solution":"def is_good_binary_tree(n, nodes): from collections import deque, defaultdict if n == 0: return \\"YES\\" tree = {} for v, l, r in nodes: tree[v] = (l, r) levels = defaultdict(list) # BFS to traverse the tree level by level queue = deque([(nodes[0][0], 0)]) # (value, level) while queue: node_value, level = queue.popleft() levels[level].append(node_value) left, right = tree.get(node_value, (-1, -1)) if left != -1: queue.append((left, level + 1)) if right != -1: queue.append((right, level + 1)) # Check if each level's values are strictly increasing for level in levels: if not all(earlier < later for earlier, later in zip(levels[level], levels[level][1:])): return \\"NO\\" return \\"YES\\""},{"question":"def find_pair_with_sum(lst, target): Determine if any two distinct elements in a given list of integers sum up to a specified target value. Return a tuple of the two elements if such a pair exists or None if no such pair is found. The order of elements in the returned tuple does not matter. >>> find_pair_with_sum([5, 20, 3, 4, 2, 10], 8) in [(5, 3), (3, 5)] True >>> find_pair_with_sum([1, 2, 3, 9], 7) None >>> find_pair_with_sum([-1, -2, -3, -4], -6) in [(-2, -4), (-4, -2)] True >>> find_pair_with_sum([4, 7, 11, 15], 18) in [(7, 11), (11, 7)] True","solution":"def find_pair_with_sum(lst, target): Return a tuple of two distinct elements from lst that sum up to the target value. If no such pair exists, return None. :param lst: List of integers :param target: Target sum value :return: A tuple of two elements if a pair exists, or None otherwise seen = set() for num in lst: complement = target - num if complement in seen: return (complement, num) seen.add(num) return None"},{"question":"def min_cards_to_remove(n: int, k: int) -> int: Returns the minimum number of cards that need to be removed from the deck to ensure an even distribution of cards among all players. Parameters: n (int): Total number of cards in the deck. k (int): Number of players. Returns: int: Minimum number of cards to remove. >>> min_cards_to_remove(52, 4) 0 >>> min_cards_to_remove(53, 4) 1 >>> min_cards_to_remove(54, 5) 4 >>> min_cards_to_remove(100, 3) 1 >>> min_cards_to_remove(78, 7) 1 >>> min_cards_to_remove(1, 1) 0 >>> min_cards_to_remove(1, 2) 1 >>> min_cards_to_remove(100000, 1) 0 >>> min_cards_to_remove(100000, 100000) 0 >>> min_cards_to_remove(99999, 100000) 99999","solution":"def min_cards_to_remove(n, k): Returns the minimum number of cards that need to be removed from the deck to ensure an even distribution of cards among all players. Parameters: n (int): Total number of cards in the deck. k (int): Number of players. Returns: int: Minimum number of cards to remove. return n % k"},{"question":"def numMatchingSubseq(s: str, words: List[str]) -> int: Given a string s and a list of words words[], return the number of words that are a subsequence of s. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. >>> numMatchingSubseq(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 3 >>> numMatchingSubseq(\\"\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 0 >>> numMatchingSubseq(\\"xyz\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 0 >>> numMatchingSubseq(\\"abcdef\\", [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) 4 >>> numMatchingSubseq(\\"abcdefg\\", [\\"a\\", \\"bg\\", \\"eg\\", \\"h\\"]) 3","solution":"def is_subsequence(s, word): Helper function to determine if 'word' is a subsequence of 's'. it = iter(s) return all(char in it for char in word) def numMatchingSubseq(s, words): Returns the number of words that are a subsequence of s. count = 0 for word in words: if is_subsequence(s, word): count += 1 return count"},{"question":"def invert_and_reverse(number: int) -> int: Inverts the sign of the input number and then reverses its digits. >>> invert_and_reverse(123) == -321 >>> invert_and_reverse(-456) == 654 >>> invert_and_reverse(5) == -5 >>> invert_and_reverse(-8) == 8 >>> invert_and_reverse(-502) == 205 >>> invert_and_reverse(0) == 0 >>> invert_and_reverse(1234567890) == -987654321","solution":"def invert_and_reverse(number): Inverts the sign of the input number and then reverses its digits. # Invert the sign inverted_number = -number # Convert to string to reverse the digits inverted_number_str = str(inverted_number) # Handle the negative sign position if inverted_number_str[0] == '-': reversed_number_str = '-' + inverted_number_str[-1:0:-1] else: reversed_number_str = inverted_number_str[::-1] # Convert back to integer and return return int(reversed_number_str)"},{"question":"def apply_operations(arr, operations): Apply update operations to an array. Parameters: arr (list of int): The initial array of integers operations (list of lists): The operations to apply, where each operation is a list [l, r, v] Returns: list of int: The modified array after all operations >>> apply_operations([0, 0, 0, 0, 0], [[0, 1, 10], [2, 4, 5], [1, 3, 20]]) [10, 20, 20, 20, 5] >>> apply_operations([1, 2, 3], []) [1, 2, 3] >>> apply_operations([1, 2, 3], [[0, 2, 9]]) [9, 9, 9] >>> apply_operations([1, 2, 3, 4, 5], [[1, 3, 7], [0, 2, 8]]) [8, 8, 8, 7, 5] >>> apply_operations([1, 2, 3, 4, 5], [[0, 4, -1]]) [-1, -1, -1, -1, -1] >>> apply_operations([5], [[0, 0, 10]]) [10]","solution":"def apply_operations(arr, operations): Apply update operations to an array. Parameters: arr (list of int) : The initial array of integers operations (list of lists) : The operations to apply, where each operation is a list [l, r, v] Returns: list of int: The modified array after all operations for op in operations: l, r, v = op for i in range(l, r + 1): arr[i] = v return arr"},{"question":"def largest_square_playground(m: int, n: int, grid: List[List[int]]) -> int: Determine the side length of the largest possible square playground that can be built on the farm. >>> largest_square_playground(4, 5, [[0, 1, 0, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 0, 0], [0, 0, 0, 1, 0]]) 2 >>> largest_square_playground(3, 4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 0 def test_example_1(): grid = [ [0, 1, 0, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 0, 0], [0, 0, 0, 1, 0] ] assert largest_square_playground(4, 5, grid) == 2 def test_example_2(): grid = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] assert largest_square_playground(3, 4, grid) == 0 def test_case_all_empty(): grid = [ [0, 0], [0, 0] ] assert largest_square_playground(2, 2, grid) == 2 def test_case_mixed(): grid = [ [0, 0, 1], [0, 1, 0], [1, 0, 0] ] assert largest_square_playground(3, 3, grid) == 1 def test_single_cell_tree(): grid = [ [1] ] assert largest_square_playground(1, 1, grid) == 0 def test_single_cell_empty(): grid = [ [0] ] assert largest_square_playground(1, 1, grid) == 1","solution":"def largest_square_playground(m, n, grid): if m == 0 or n == 0: return 0 # Initialize dp array with zeros dp = [[0] * n for _ in range(m)] max_side = 0 # Fill dp array for i in range(m): for j in range(n): if grid[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def exists_in_grid(grid, word): Determines if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same cell may not be used twice in the construction of the word. >>> exists_in_grid([['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e']], \\"abcced\\") True >>> exists_in_grid([['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e']], \\"see\\") True >>> exists_in_grid([['a', 'b'], ['c', 'd']], \\"abcd\\") False pass def word_exists_in_grids(grids): For each grid, determines if the corresponding word exists in the grid. >>> word_exists_in_grids([([['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e']], \\"abcced\\"), ([['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e']], \\"see\\"), ([['a', 'b'], ['c', 'd']], \\"abcd\\")]) [\\"Yes\\", \\"Yes\\", \\"No\\"] pass def parse_input(input_string): Parses the input string into a list of grids and corresponding words. >>> parse_input(\\"2 2na bnc dnabcdn0 0\\") [([['a', 'b'], ['c', 'd']], \\"abcd\\")] pass def main(input_string): Main function to parse input, check word existence in grids, and format the result. >>> main(\\"3 4na b c ens f c sna d e enabccedn3 4na b c ens f c sna d e enseen2 2na bnc dnabcdn0 0\\") \\"YesnYesnNo\\" pass","solution":"def exists_in_grid(grid, word): rows = len(grid) cols = len(grid[0]) word_len = len(word) def dfs(x, y, index): if index == word_len: return True if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != word[index]: return False temp = grid[x][y] grid[x][y] = '#' found = (dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1)) grid[x][y] = temp return found for i in range(rows): for j in range(cols): if grid[i][j] == word[0]: if dfs(i, j, 0): return True return False def word_exists_in_grids(grids): results = [] for grid, word in grids: if exists_in_grid(grid, word): results.append(\\"Yes\\") else: results.append(\\"No\\") return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") idx = 0 grids = [] while idx < len(lines): m, n = map(int, lines[idx].split()) if m == 0 and n == 0: break grid = [] for i in range(m): grid.append(list(lines[idx + 1 + i].replace(\\" \\", \\"\\"))) word = lines[idx + 1 + m] grids.append((grid, word)) idx += m + 2 return grids def main(input_string): grids = parse_input(input_string) results = word_exists_in_grids(grids) return \\"n\\".join(results)"},{"question":"def sort_words_and_numbers(s: str) -> str: Sorts words such that all integers appear before all the strings, both sorted in ascending order. Args: s (str): A string containing words and integers separated by spaces. Returns: str: A sorted string with integers first followed by strings. >>> sort_words_and_numbers(\\"apple 34 3 banana 7\\") \\"3 7 34 apple banana\\" >>> sort_words_and_numbers(\\"7 54 dog 2 3 cat 1\\") \\"1 2 3 7 54 cat dog\\" >>> sort_words_and_numbers(\\"coder 100 3 question 4\\") \\"3 4 100 coder question\\" >>> sort_words_and_numbers(\\"3 2 1\\") \\"1 2 3\\" >>> sort_words_and_numbers(\\"zebra alpha 10 5\\") \\"5 10 alpha zebra\\" >>> sort_words_and_numbers(\\"alpha beta gamma\\") \\"alpha beta gamma\\" >>> sort_words_and_numbers(\\"10 20 1\\") \\"1 10 20\\"","solution":"def sort_words_and_numbers(s): Sorts words such that all integers appear before all the strings, both sorted in ascending order. Args: s (str): A string containing words and integers separated by spaces. Returns: str: A sorted string with integers first followed by strings. words = s.split() numbers = [] strings = [] for word in words: if word.isdigit(): numbers.append(int(word)) else: strings.append(word) sorted_numbers = sorted(numbers) sorted_strings = sorted(strings) sorted_numbers = [str(num) for num in sorted_numbers] return ' '.join(sorted_numbers + sorted_strings)"},{"question":"def doesRepeatSubstring(S: str, K: int) -> str: Determine whether there is any substring of S that appears at least K times. Parameters: S (str): The input string consisting of lowercase English letters. K (int): The minimum number of times a substring should appear. Returns: str: \\"YES\\" if any substring appears at least K times, \\"NO\\" otherwise. Examples: >>> doesRepeatSubstring(\\"abcbabc\\", 2) \\"YES\\" >>> doesRepeatSubstring(\\"abcdefg\\", 2) \\"NO\\" def test_doesRepeatSubstring_example1(): assert doesRepeatSubstring(\\"abcbabc\\", 2) == \\"YES\\" def test_doesRepeatSubstring_example2(): assert doesRepeatSubstring(\\"abcdefg\\", 2) == \\"NO\\" def test_doesRepeatSubstring_single_character_repeated(): assert doesRepeatSubstring(\\"aaaaa\\", 4) == \\"YES\\" assert doesRepeatSubstring(\\"aaaaa\\", 5) == \\"YES\\" assert doesRepeatSubstring(\\"aaaaa\\", 6) == \\"NO\\" def test_doesRepeatSubstring_no_repeats(): assert doesRepeatSubstring(\\"abcde\\", 2) == \\"NO\\" def test_doesRepeatSubstring_all_repeats(): assert doesRepeatSubstring(\\"ababab\\", 3) == \\"YES\\" def test_doesRepeatSubstring_mixed_repeats(): assert doesRepeatSubstring(\\"abcabcabc\\", 3) == \\"YES\\" assert doesRepeatSubstring(\\"abcabcabc\\", 4) == \\"NO\\" def test_doesRepeatSubstring_substrings(): assert doesRepeatSubstring(\\"xyzxyzxyzxyz\\", 4) == \\"YES\\" assert doesRepeatSubstring(\\"xyzxyzxyzxyz\\", 5) == \\"NO\\"","solution":"def doesRepeatSubstring(S, K): This function checks if there is any substring that appears at least K times in the given string. Parameters: S (str): The input string. K (int): The number of times a substring should at least appear in the string. Returns: str: \\"YES\\" if any substring appears at least K times, \\"NO\\" otherwise. from collections import defaultdict n = len(S) substring_count = defaultdict(int) # Generate all possible substrings for length in range(1, n+1): for i in range(n - length + 1): substring = S[i:i + length] substring_count[substring] += 1 # Check if any substring appears at least K times for count in substring_count.values(): if count >= K: return \\"YES\\" return \\"NO\\""},{"question":"def can_transform_and_compare(s1: str, s2: str) -> str: Determine if the characters of s1 can be rearranged to match s2. Return \\"Yes\\" if it's possible, otherwise \\"No\\". The comparison is case-sensitive and considers all characters including spaces and punctuation. Examples: >>> can_transform_and_compare(\\"listen\\", \\"silent\\") Yes >>> can_transform_and_compare(\\"apple\\", \\"pleaple\\") No >>> can_transform_and_compare(\\"abc\\", \\"cba\\") Yes >>> can_transform_and_compare(\\"abc\\", \\"AbC\\") No","solution":"def can_transform_and_compare(s1: str, s2: str) -> str: Determine if the characters of s1 can be rearranged to match s2. if sorted(s1) == sorted(s2): return \\"Yes\\" return \\"No\\""},{"question":"def min_edges_remove_keep_connected(num_cases, test_cases): Given a number of test cases, determine the minimum number of edges that can be removed without disconnecting the network for each test case. Args: num_cases (int): Number of test cases test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test cases, each containing: - N (int): Number of nodes - M (int): Number of edges - edges (List[Tuple[int, int]]): List of edges (U, V) Returns: List[int]: List of results for each test case representing the minimum number of edges that can be removed without disconnecting the network >>> min_edges_remove_keep_connected(2, [ ... (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), ... (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) ... ]) [1, 0] >>> min_edges_remove_keep_connected(1, [ ... (3, 2, [(1, 2), (2, 3)]) ... ]) [0] >>> min_edges_remove_keep_connected(1, [ ... (3, 3, [(1, 2), (2, 3), (3, 1)]) ... ]) [1] >>> min_edges_remove_keep_connected(1, [ ... (6, 9, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 5), (3, 4), (3, 6), (4, 6), (5, 6)]) ... ]) [1] >>> min_edges_remove_keep_connected(1, [ ... (5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) ... ]) [1]","solution":"import networkx as nx def min_edges_remove_keep_connected(num_cases, test_cases): results = [] for case in test_cases: N = case[0] M = case[1] edges = case[2] # Create a graph G = nx.Graph() G.add_edges_from(edges) # Check for bridges bridge_count = len(list(nx.bridges(G))) # If there're no bridges, we can remove any edge if bridge_count == 0: results.append(min(1, M)) else: results.append(0) return results"},{"question":"def find_largest_square(matrix: List[List[int]]) -> int: Implement a function that takes a 2D binary matrix as input and returns the area of the largest square containing only 1s in the matrix. >>> matrix = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> find_largest_square(matrix) 4 >>> matrix = [] >>> find_largest_square(matrix) 0 >>> matrix = [[1]] >>> find_largest_square(matrix) 1 >>> matrix = [[0]] >>> find_largest_square(matrix) 0 >>> matrix = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> find_largest_square(matrix) 0 >>> matrix = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> find_largest_square(matrix) 9 >>> matrix = [ ... [1, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 1, 1, 1], ... [0, 1, 1, 1] ... ] >>> find_largest_square(matrix) 9 >>> matrix = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0], ... [1, 1, 1, 1, 1], ... ] >>> find_largest_square(matrix) 4","solution":"def find_largest_square(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def distribute_water(n: int, k: int, m: int) -> Union[List[int], str]: Determines if it is possible to distribute k units of water into n containers such that no container has more than m units of water. Args: n (int): Number of containers k (int): Total units of water to distribute m (int): Maximum units of water any container can hold Returns: list or str: List of integers if distribution is possible, else 'No' >>> distribute_water(5, 10, 3) [3, 3, 3, 1, 0] >>> distribute_water(3, 8, 2) \\"No\\"","solution":"def distribute_water(n, k, m): Determines if it is possible to distribute k units of water into n containers such that no container has more than m units of water. If possible, returns a list of distribution; otherwise, 'No'. Args: n (int): Number of containers k (int): Total units of water to distribute m (int): Maximum units of water any container can hold Returns: list or str: List of integers if distribution is possible, else 'No' # Calculate the minimum total units needed if all containers are to be filled equally min_needed = n max_possible = n * m if k < min_needed or k > max_possible: return \\"No\\" result = [0] * n # Start with zero water in each container for i in range(n): if k > m: result[i] = m k -= m else: result[i] = k k = 0 return result"},{"question":"def min_distance(n: int) -> int: Returns the minimum distance between any two people when all benches are filled, each bench can accommodate up to two people. >>> min_distance(1) 0 >>> min_distance(2) 0 >>> min_distance(3) 1 >>> min_distance(100) 1 >>> min_distance(50000) 1 >>> min_distance(100000) 1","solution":"def min_distance(n): Returns the minimum distance between any two people when all benches are filled, each bench can accommodate up to two people. if n == 1 or n == 2: return 0 else: return 1"},{"question":"from typing import List def largest_island(matrix: List[List[int]]) -> int: Given a 2D binary matrix filled with 0's and 1's, finds the size of the largest island. >>> largest_island([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 1, 1], ... [0, 1, 0, 0, 1] ... ]) 4 >>> largest_island([[1]]) 1 >>> largest_island([[0]]) 0 >>> largest_island([ ... [1, 1], ... [1, 1] ... ]) 4 >>> largest_island([ ... [0, 0], ... [0, 0] ... ]) 0 >>> largest_island([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 1 >>> largest_island([ ... [1, 1, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 1] ... ]) 5","solution":"def largest_island(matrix): Given a 2D binary matrix filled with 0's and 1's, this function returns the size of the largest island. def dfs(matrix, i, j, visited): if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] == 0 or visited[i][j]: return 0 visited[i][j] = True size = 1 size += dfs(matrix, i+1, j, visited) size += dfs(matrix, i-1, j, visited) size += dfs(matrix, i, j+1, visited) size += dfs(matrix, i, j-1, visited) return size if not matrix: return 0 max_island_size = 0 rows, cols = len(matrix), len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] for i in range(rows): for j in range(cols): if matrix[i][j] == 1 and not visited[i][j]: current_island_size = dfs(matrix, i, j, visited) max_island_size = max(max_island_size, current_island_size) return max_island_size"},{"question":"def categorize_books(book_titles, statuses): Categorizes books based on their status. Parameters: book_titles (list of str): List of book titles. statuses (list of str): List of statuses corresponding to each book title. Returns: dict: A dictionary with two keys, \\"Available\\" and \\"Checked Out\\", each containing a list of book titles that match the respective status. Examples: >>> categorize_books([\\"The Hobbit\\", \\"War and Peace\\"], [\\"Available\\", \\"Checked Out\\"]) { \\"Available\\": [\\"The Hobbit\\"], \\"Checked Out\\": [\\"War and Peace\\"] } >>> categorize_books([], []) {} >>> categorize_books([\\"1984\\"], [\\"Checked Out\\", \\"Available\\"]) {}","solution":"def categorize_books(book_titles, statuses): Categorizes books based on their status. Parameters: book_titles (list of str): List of book titles. statuses (list of str): List of statuses corresponding to each book title. Returns: dict: A dictionary with two keys, \\"Available\\" and \\"Checked Out\\", each containing a list of book titles that match the respective status. if not book_titles or not statuses or len(book_titles) != len(statuses): return {} categorized_books = {\\"Available\\": [], \\"Checked Out\\": []} for title, status in zip(book_titles, statuses): if status in categorized_books: categorized_books[status].append(title) return categorized_books"},{"question":"def min_rewards(M: int, ratings: List[int]) -> int: Find the minimum number of rewards needed to distribute to the employees according to the given rules. Parameters: M (int): number of employees ratings (list): list of integers representing productivity ratings for each employee Returns: int: Minimum number of rewards needed >>> min_rewards(5, [1, 2, 2, 3, 1]) 7 >>> min_rewards(1, [10]) 1 >>> min_rewards(4, [5, 5, 5, 5]) 4 >>> min_rewards(3, [3, 4, 5]) 6 >>> min_rewards(3, [5, 4, 3]) 6 >>> min_rewards(5, [1, 2, 3, 2, 1]) 9","solution":"def min_rewards(M, ratings): This function computes the minimum number of rewards needed for the employees based on given criteria. Parameters: M (int): number of employees ratings (list): list of integers representing productivity ratings for each employee Returns: int: Minimum number of rewards needed if M == 0: return 0 rewards = [1] * M # Traverse from left to right for i in range(1, M): if ratings[i] > ratings[i - 1]: rewards[i] = rewards[i - 1] + 1 # Traverse from right to left for i in range(M - 2, -1, -1): if ratings[i] > ratings[i + 1]: rewards[i] = max(rewards[i], rewards[i + 1] + 1) return sum(rewards)"},{"question":"import re from typing import List def count_unique_words(paragraph: str) -> List[str]: Given a paragraph, remove all punctuation and convert the whole text to lowercase, then count the number of unique words and display them in the order they appeared. >>> count_unique_words(\\"This is a simple example. A very simple example.\\") ['this', 'is', 'a', 'simple', 'example', 'very'] >>> count_unique_words(\\"A Test case, another test case.\\") ['a', 'test', 'case', 'another'] pass def process_test_cases(test_cases: List[str]) -> List[List[str]]: Process multiple test cases given as a list of paragraphs and return the unique words for each test case. >>> process_test_cases([ ... \\"This is a simple example. A very simple example.\\", ... \\"A Test case, another test case.\\" ... ]) [['this', 'is', 'a', 'simple', 'example', 'very'], ['a', 'test', 'case', 'another']] pass def main(): T = int(input().strip()) test_cases = [input().strip() for _ in range(T)] results = process_test_cases(test_cases) for result in results: print(len(result)) for word in result: print(word) if __name__ == \\"__main__\\": main()","solution":"import re def count_unique_words(paragraph): # Normalize case and remove punctuation paragraph = paragraph.lower() words = re.findall(r'bw+b', paragraph) seen = set() unique_words = [] for word in words: if word not in seen: seen.add(word) unique_words.append(word) return unique_words def process_test_cases(test_cases): results = [] for paragraph in test_cases: unique_words = count_unique_words(paragraph) results.append(unique_words) return results def main(): T = int(input().strip()) test_cases = [input().strip() for _ in range(T)] results = process_test_cases(test_cases) for result in results: print(len(result)) for word in result: print(word) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def find_sccs(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Identify the number of strongly connected components in a given directed graph of friendships. Args: n (int): Number of people (nodes). m (int): Number of direct communication paths (edges). connections (List[Tuple[int, int]]): List of direct communication paths where each tuple (u, v) represents a path from person u to person v. Returns: int: The number of strongly connected components in the graph. Examples: >>> find_sccs(5, 5, [(1, 2), (2, 3), (3, 1), (3, 4), (4, 5)]) == 3 >>> find_sccs(1, 0, []) == 1 from solution import find_sccs def test_sample_input(): assert find_sccs(5, 5, [(1, 2), (2, 3), (3, 1), (3, 4), (4, 5)]) == 3 def test_single_node(): assert find_sccs(1, 0, []) == 1 def test_disconnected_nodes(): assert find_sccs(3, 0, []) == 3 def test_cyclic_graph(): assert find_sccs(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 1 def test_tree_structure(): assert find_sccs(5, 4, [(1, 2), (1, 3), (3, 4), (3, 5)]) == 5 def test_multiple_sccs(): assert find_sccs(6, 7, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (3, 4)]) == 2","solution":"from collections import defaultdict, deque def find_sccs(n, m, connections): def dfs1(v): visited[v] = True for u in adj[v]: if not visited[u]: dfs1(u) order.append(v) def dfs2(v): visited[v] = True component.append(v) for u in adj_rev[v]: if not visited[u]: dfs2(u) # Build graph and reverse graph adj = defaultdict(list) adj_rev = defaultdict(list) for u, v in connections: adj[u].append(v) adj_rev[v].append(u) # First pass: record the finishing order of the nodes visited = [False] * (n + 1) order = [] for i in range(1, n + 1): if not visited[i]: dfs1(i) # Second pass: reverse graph DFS according to finishing order visited = [False] * (n + 1) scc_count = 0 while order: v = order.pop() if not visited[v]: component = [] dfs2(v) scc_count += 1 return scc_count"},{"question":"def max_coins_distribution(T, test_cases): Determine the maximum number of coins that can be distributed among commanders. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list containing the test cases. Each test case is a tuple where the first element is a tuple of two integers (N, K) and the second element is a list of integers representing the coin handling capacities of commanders. Returns: List[int]: A list containing the maximum number of coins distributed for each test case. >>> max_coins_distribution(2, [((3, 50), [10, 20, 15]), ((4, 100), [35, 40, 25, 50])]) [45, 100] >>> max_coins_distribution(1, [((3, 50), [0, 0, 0])]) [0] >>> max_coins_distribution(1, [((1, 10), [10])]) [10] >>> max_coins_distribution(1, [((3, 1000000), [500000, 300000, 200000])]) [1000000] >>> max_coins_distribution(1, [((4, 100), [25, 25, 25, 25])]) [100]","solution":"def max_coins_distribution(T, test_cases): results = [] for t in range(T): N, K = test_cases[t][0] capacities = sorted(test_cases[t][1], reverse=True) total_distributed = 0 for capacity in capacities: if total_distributed + capacity <= K: total_distributed += capacity else: total_distributed += min(K - total_distributed, capacity) results.append(total_distributed) return results"},{"question":"def valid_palindrome(s: str) -> bool: Given a string s, return true if and only if it is a valid palindrome after deleting at most one character. A palindrome is a string that reads the same forward and backward. >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"racecar\\") True >>> valid_palindrome(\\"hello\\") False","solution":"def valid_palindrome(s): Returns true if the string s can be made into a palindrome by deleting at most one character. def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # If there's a mismatch, check the two possible strings (one with either character removed) return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def merge_and_sort_books(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[List[int]]: Merges and sorts the book IDs from each pair of lists. Parameters: - T: Integer, number of test cases. - test_cases: List of tuples, where each tuple contains two integers N and M, and two lists of N and M integers respectively representing book IDs. Returns: - A list of lists, where each inner list is the sorted list of unique book IDs for a corresponding test case. >>> merge_and_sort_books(1, [(3, 4, [10, 20, 30], [20, 40, 50, 60])]) [[10, 20, 30, 40, 50, 60]] >>> merge_and_sort_books(1, [(5, 3, [1, 2, 3, 4, 5], [6, 7, 8])]) [[1, 2, 3, 4, 5, 6, 7, 8]] >>> merge_and_sort_books(1, [(3, 3, [1, 2, 3], [1, 2, 3])]) [[1, 2, 3]] >>> merge_and_sort_books(2, [(3, 4, [10, 20, 30], [20, 40, 50, 60]), (5, 3, [1, 2, 3, 4, 5], [6, 7, 8])]) [[10, 20, 30, 40, 50, 60], [1, 2, 3, 4, 5, 6, 7, 8]] >>> merge_and_sort_books(1, [(100000, 100000, list(range(1, 100001)), list(range(100000, 200000))]) [list(range(1, 200000))]","solution":"def merge_and_sort_books(T, test_cases): Merges and sorts the book IDs from each pair of lists. Parameters: - T: Integer, number of test cases. - test_cases: List of tuples, where each tuple contains two integers N and M, and two lists of N and M integers respectively representing book IDs. Returns: - A list of lists, where each inner list is the sorted list of unique book IDs for a corresponding test case. results = [] for case in test_cases: N, M, list1, list2 = case combined = set(list1).union(set(list2)) sorted_list = sorted(combined) results.append(sorted_list) return results"},{"question":"def countUniqueTriplets(arr): Returns the number of unique triplets (i, j, k) such that i < j < k and arr[i] + arr[j] + arr[k] == 0. >>> countUniqueTriplets([-1, 0, 1, 2, -1, -4]) 2 >>> countUniqueTriplets([1, 2, -2, -1]) 0 >>> countUniqueTriplets([0, 0, 0, 0]) 1 >>> countUniqueTriplets([3, -2, -1, 0, 1, 2]) 3 >>> countUniqueTriplets([1, 1, -2]) 1 >>> countUniqueTriplets([]) 0 >>> countUniqueTriplets([-1, -1, -1, 2, 2, 0, 0]) 1 >>> countUniqueTriplets([0,0,0,1,1]) 1","solution":"def countUniqueTriplets(arr): Returns the number of unique triplets (i, j, k) such that i < j < k and arr[i] + arr[j] + arr[k] == 0. arr.sort() n = len(arr) count = 0 unique_triplets = set() for i in range(n): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: unique_triplets.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 while left < right and arr[left] == arr[left - 1]: left += 1 while left < right and arr[right] == arr[right + 1]: right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return len(unique_triplets)"},{"question":"def min_employee_transfers(test_cases: List[Tuple[List[List[str]], List[List[str]]]]) -> List[int]: Determine the minimum number of employee transfers required to form proposed teams such that all employees in a team come from the same company. Args: test_cases: A list of tuples, where each tuple contains two elements: - A list of lists, each inner list contains employee IDs for a company. - A list of lists, each inner list contains employee IDs for a proposed team. Returns: A list of integers, each representing the minimum number of transfers required for each test case. Example: >>> min_employee_transfers([ ([['1_1', '1_2'], ['2_1', '2_2']], [['1_1', '2_1'], ['1_2', '2_2']]), ([['1_1', '1_2'], ['2_1'], ['3_1', '3_2']], [['1_1', '2_1', '3_1']]) ]) [2, 2]","solution":"def min_employee_transfers(test_cases): results = [] for companies, teams in test_cases: company_map = {} team_list = [] # Create a mapping from employee ID to their current company for company_id, employees in enumerate(companies, 1): for employee in employees: company_map[employee] = company_id # Parse the proposed teams for team in teams: team_list.append(set(team)) # Calculate transfers transfers = 0 for team in team_list: company_count = {} for employee in team: company_id = company_map[employee] if company_id in company_count: company_count[company_id] += 1 else: company_count[company_id] = 1 max_common = max(company_count.values()) transfers += (len(team) - max_common) results.append(transfers) return results"},{"question":"def highlight_keywords(T, cases): Replace each occurrence of the keyword with a highlighted version. Args: T (int): Number of test cases. cases (List[Dict]): List of test case dictionaries. Each dictionary contains \\"document\\" (str) and \\"keywords\\" (List[str]). Returns: List[str]: List of modified documents with highlighted keywords. Examples: >>> highlight_keywords(2, [{\\"document\\": \\"this is a test document\\", \\"keywords\\": [\\"test\\", \\"document\\"]}, {\\"document\\": \\"hello world\\", \\"keywords\\": [\\"world\\"]}]) [\\"this is a [test] [document]\\", \\"hello [world]\\"] >>> highlight_keywords(1, [{\\"document\\": \\"no keywords here\\", \\"keywords\\": []}]) [\\"no keywords here\\"]","solution":"def highlight_keywords(T, cases): results = [] for case in cases: document = case[\\"document\\"] keywords = case[\\"keywords\\"] for keyword in keywords: document = document.replace(keyword, f\\"[{keyword}]\\") results.append(document) return results def process_input(data): data = data.strip().split(\\"n\\") T = int(data[0]) index = 1 cases = [] for _ in range(T): doc = data[index] K = int(data[index + 1]) keywords = [data[index + 2 + i] for i in range(K)] cases.append({\\"document\\": doc, \\"keywords\\": keywords}) index += 2 + K return T, cases data = 2 this is a test document 2 test document hello world 1 world T, cases = process_input(data) results = highlight_keywords(T, cases) for result in results: print(result)"},{"question":"def generate_triangle_patterns(test_cases): Generate triangle-like patterns based on the number of rows. Arguments: test_cases -- a list of integers, where each integer represents the number of rows for the respective triangle pattern Returns: A list of strings, where each string represents the triangle pattern for the corresponding test case. Example: >>> generate_triangle_patterns([2]) ['1 2n1'] >>> generate_triangle_patterns([3]) ['1 2 3n1 2n1']","solution":"def generate_triangle_patterns(test_cases): results = [] for N in test_cases: pattern = [] for i in range(N, 0, -1): row = ' '.join(map(str, range(1, i+1))) pattern.append(row) results.append('n'.join(pattern)) return results"},{"question":"def max_subarray_sum(T: int, test_cases: list) -> list: Returns the maximum sum of elements from a contiguous subarray for each test case. If the array contains only negative numbers, the result is the maximum single element. Args: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer n (number of elements in array) followed by the list of integers (elements of the array). Returns: list: List containing the maximum sum of contiguous subarray for each test case. >>> max_subarray_sum(2, [(4, [1, -2, 3, 4]), (3, [-3, -2, -1])]) [7, -1] >>> max_subarray_sum(1, [(1, [5])]) [5] >>> max_subarray_sum(1, [(1, [-5])]) [-5] >>> max_subarray_sum(1, [(4, [2, 1, 3, 4])]) [10] >>> max_subarray_sum(1, [(4, [-2, -3, -1, -4])]) [-1] >>> max_subarray_sum(1, [(5, [-1, 2, 3, -5, 4])]) [5] >>> max_subarray_sum(3, [(3, [1, 2, -1]), (3, [-1, -2, -3]), (4, [1, -2, 3, 4])]) [3, -1, 7]","solution":"def max_subarray_sum(T, test_cases): Returns the maximum sum of elements from a contiguous subarray for each test case. If the array contains only negative numbers, the result is the maximum single element. Args: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer n (number of elements in array) followed by the list of integers (elements of the array). Returns: list: List containing the maximum sum of contiguous subarray for each test case. results = [] for n, arr in test_cases: current_max = arr[0] max_so_far = arr[0] for i in range(1, n): current_max = max(arr[i], current_max + arr[i]) max_so_far = max(max_so_far, current_max) results.append(max_so_far) return results # Example usage # T = 2 # test_cases = [(4, [1, -2, 3, 4]), (3, [-3, -2, -1])] # print(max_subarray_sum(T, test_cases)) # Output: [7, -1]"},{"question":"def count_substrings_start_end_same(s: str) -> int: Returns the number of substrings that start and end with the same character. >>> count_substrings_start_end_same(\\"ababa\\") 9 >>> count_substrings_start_end_same(\\"aaaa\\") 10 >>> count_substrings_start_end_same(\\"abc\\") 3 >>> count_substrings_start_end_same(\\"abcba\\") 7 >>> count_substrings_start_end_same(\\"\\") 0 >>> count_substrings_start_end_same(\\"a\\") 1 >>> count_substrings_start_end_same(\\"aa\\") 3 >>> count_substrings_start_end_same(\\"ab\\") 2","solution":"def count_substrings_start_end_same(s): Returns the number of substrings that start and end with the same character. n = len(s) count = 0 # Dictionary to keep track of the count of each character freq = {} for i in range(n): # For each character s[i], all substrings that end at i and start # with character s[i] itself count += 1 # If character s[i] has been seen before, # then it forms substrings with each previous occurrence of s[i] if s[i] in freq: count += freq[s[i]] # Update the frequency of character s[i] if s[i] in freq: freq[s[i]] += 1 else: freq[s[i]] = 1 return count"},{"question":"def more_a_than_b(s: str) -> str: Returns \\"Yes\\" if the number of 'a' characters is greater than the number of 'b' characters in the string s, else \\"No\\". >>> more_a_than_b('aab') \\"Yes\\" >>> more_a_than_b('aaa') \\"Yes\\" >>> more_a_than_b('abb') \\"No\\" >>> more_a_than_b('baa') \\"Yes\\" >>> more_a_than_b('aba') \\"Yes\\" >>> more_a_than_b('bbb') \\"No\\" >>> more_a_than_b('bba') \\"No\\"","solution":"def more_a_than_b(s): Returns \\"Yes\\" if the number of 'a' characters is greater than the number of 'b' characters in the string s, else \\"No\\". count_a = s.count('a') count_b = s.count('b') return \\"Yes\\" if count_a > count_b else \\"No\\""},{"question":"def logistic_robot(n: int, c: int, commands: List[str]) -> List[int]: A logistics company uses an automated delivery robot to distribute packages along a linear series of warehouses. Args: n (int): Total number of warehouses. c (int): Number of commands. commands (List[str]): List containing the commands. Returns: List[int]: Number of packages in each warehouse from index 0 to n-1, separated by spaces. >>> logistic_robot(5, 6, [\\"R 2\\", \\"D 3\\", \\"L 1\\", \\"D 2\\", \\"R 3\\", \\"D 1\\"]) [0, 2, 3, 0, 1] >>> logistic_robot(3, 1, [\\"D 5\\"]) [5, 0, 0] >>> logistic_robot(3, 3, [\\"R 1\\", \\"L 1\\", \\"D 3\\"]) [3, 0, 0] >>> logistic_robot(3, 3, [\\"L 5\\", \\"D 1\\", \\"R 2\\"]) [1, 0, 0] >>> logistic_robot(4, 3, [\\"R 2\\", \\"D 2\\", \\"R 1\\"]) [0, 0, 2, 0] >>> logistic_robot(3, 4, [\\"R 4\\", \\"D 3\\", \\"L 1\\", \\"D 2\\"]) [0, 2, 3]","solution":"def logistic_robot(n, c, commands): warehouses = [0] * n current_position = 0 for command in commands: action, value = command.split() value = int(value) if action == 'L': current_position = max(0, current_position - value) elif action == 'R': current_position = min(n - 1, current_position + value) elif action == 'D': warehouses[current_position] += value return warehouses # Example usage: # n = 5 # c = 6 # commands = [\\"R 2\\", \\"D 3\\", \\"L 1\\", \\"D 2\\", \\"R 3\\", \\"D 1\\"] # print(logistic_robot(n, c, commands)) # Output: [0, 2, 3, 0, 1]"},{"question":"def is_subsequence(s: str, t: str) -> str: Check if string \`t\` is a subsequence of string \`s\`. >>> is_subsequence(\\"abcde\\", \\"ace\\") == \\"Yes\\" >>> is_subsequence(\\"abc\\", \\"acb\\") == \\"No\\" >>> is_subsequence(\\"abcdef\\", \\"abcdef\\") == \\"Yes\\" >>> is_subsequence(\\"abcdef\\", \\"gh\\") == \\"No\\"","solution":"def is_subsequence(s, t): Check if t is a subsequence of s. :param s: String s :param t: String t :return: 'Yes' if t is a subsequence of s, otherwise 'No' t_index = 0 t_len = len(t) for char in s: if t_index < t_len and char == t[t_index]: t_index += 1 return \\"Yes\\" if t_index == t_len else \\"No\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum_any(root: TreeNode, A: int, B: int) -> bool: Return True if there exists a root-to-leaf path in the binary tree where the sum of the node values is equal to A or B. Parameters: - root (TreeNode): The root node of the binary tree. - A (int): An integer representing one target sum. - B (int): An integer representing another target sum. Returns: - bool: True if there is a path in the tree from the root to a leaf such that the sum of the node values along this path equals A or B. Otherwise, False. >>> root = TreeNode(5); root.left = TreeNode(4); root.right = TreeNode(8) >>> root.left.left = TreeNode(11); root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2); root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4); root.right.right.right = TreeNode(1) >>> has_path_sum_any(root, 22, 26) True >>> root = TreeNode(1); root.left = TreeNode(2); root.right = TreeNode(3) >>> has_path_sum_any(root, 5, 6) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): Return True if there exists a root-to-leaf path in the binary tree where the sum of the node values is equal to target_sum. if not root: return False # If we're at a leaf node, check the sum if not root.left and not root.right: return root.val == target_sum # Otherwise, check the subtrees target_sum -= root.val return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum) def has_path_sum_any(root, A, B): Return True if there exists a root-to-leaf path in the binary tree where the sum of the node values is equal to A or B. return has_path_sum(root, A) or has_path_sum(root, B)"},{"question":"from typing import List, Tuple def min_knights_required(t: int, cases: List[Tuple[Tuple[int, int], List[str]]]) -> List[int]: Determine the minimum number of knights required to ensure that every empty cell is reachable by at least one knight. If it is not possible, return -1. Parameters: t (int): The number of test cases. cases (List[Tuple[Tuple[int, int], List[str]]]): A list of tuples where each tuple contains a pair (n, m) representing the dimensions of the grid and a list of strings representing the grid. Returns: List[int]: A list of integers where each integer represents the minimum number of knights required for the corresponding test case. >>> min_knights_required(2, [((3, 3), ['K.#', '.#.', '...']), ((2, 4), ['K...', '.#K.'])]) [1, 2] >>> min_knights_required(1, [((3, 3), ['K.#', '.#.', '#'])]) [-1]","solution":"from collections import deque def bfs(n, m, grid, start): visited = [[False] * m for _ in range(n)] queue = deque([start]) visited[start[0]][start[1]] = True while queue: x, y = queue.popleft() # Traverse in all 4 possible directions (up, down, left, right) for nx, ny in [(x-1,y), (x+1,y), (x,y-1), (x,y+1)]: if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return visited def min_knights_required(t, cases): results = [] for i in range(t): n, m = cases[i][0] grid = cases[i][1] coverage = [[0] * m for _ in range(n)] knights = [] for r in range(n): for c in range(m): if grid[r][c] == 'K': knights.append((r, c)) for kx, ky in knights: visited = bfs(n, m, grid, (kx, ky)) for r in range(n): for c in range(m): if visited[r][c]: coverage[r][c] += 1 empty_cells = [(r, c) for r in range(n) for c in range(m) if grid[r][c] == '.'] # Check if all empty cells are covered covered_counts = [coverage[r][c] for r, c in empty_cells] if all(count > 0 for count in covered_counts): results.append(len(knights)) else: results.append(-1) return results"},{"question":"def are_anagrams(word1, word2): Check if the two words are anagrams of each other. Args: word1 (str): The first word. word2 (str): The second word. Returns: bool: True if the words are anagrams, False otherwise. pass def process_test_cases(tc, test_cases): Process multiple test cases to check for anagrams. Args: tc (int): Number of test cases. test_cases (List[Tuple[str, str]]): List of word pairs to check for anagram status. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case. pass","solution":"def are_anagrams(word1, word2): Check if the two words are anagrams of each other. Args: word1 (str): The first word. word2 (str): The second word. Returns: bool: True if the words are anagrams, False otherwise. # To check if two words are anagrams, we can sort the characters and compare the sorted lists return sorted(word1) == sorted(word2) def process_test_cases(tc, test_cases): Process multiple test cases to check for anagrams. Args: tc (int): Number of test cases. test_cases (List[Tuple[str, str]]): List of word pairs to check for anagram status. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case. results = [] for word1, word2 in test_cases: if are_anagrams(word1, word2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def reorder_sequence(n, elements): Reorders the sequence such that the maximum difference between two adjacent elements is minimized. Args: n (int): The number of elements in the sequence. elements (List[int]): The sequence of positive integers. Returns: List[int]: The reordered sequence. Examples: >>> reorder_sequence(5, [4, 2, 1, 7, 5]) [1, 7, 2, 5, 4] >>> reorder_sequence(6, [10, 20, 30, 40, 50, 60]) [10, 60, 20, 50, 30, 40]","solution":"def reorder_sequence(n, elements): Reorders the sequence such that the maximum difference between two adjacent elements is minimized. Args: n (int): The number of elements in the sequence. elements (List[int]): The sequence of positive integers. Returns: List[int]: The reordered sequence. elements.sort() left, right = 0, n - 1 result = [] while left <= right: if len(result) % 2 == 0: result.append(elements[left]) left += 1 else: result.append(elements[right]) right -= 1 return result"},{"question":"def can_all_coins_show_heads(n: int, flipping_limits: List[int]) -> str: Determines if all coins can be turned to heads given their flipping limits. Parameters: n (int): Number of coins. flipping_limits (list of int): The flipping limits for each coin. Returns: str: \\"YES\\" if it's possible to turn all coins to heads, otherwise \\"NO\\". >>> can_all_coins_show_heads(4, [3, 2, 1, 2]) \\"YES\\" >>> can_all_coins_show_heads(3, [1, 1, 1]) \\"YES\\" >>> can_all_coins_show_heads(5, [2, 2, 2, 2, 2]) \\"YES\\" >>> can_all_coins_show_heads(4, [3, 1, 0, 2]) \\"NO\\" >>> can_all_coins_show_heads(3, [0, 1, 1]) \\"NO\\" >>> can_all_coins_show_heads(5, [2, 2, 2, 2, 0]) \\"NO\\"","solution":"def can_all_coins_show_heads(n, flipping_limits): Determines if all coins can be turned to heads given their flipping limits. Parameters: n (int): Number of coins. flipping_limits (list of int): The flipping limits for each coin. Returns: str: \\"YES\\" if it's possible to turn all coins to heads, otherwise \\"NO\\". for limit in flipping_limits: if limit < 1: return \\"NO\\" return \\"YES\\""},{"question":"def longest_gear_chain(n: int, gears: List[int]) -> int: Function to find the length of the longest chain of gears that can mesh together. Parameters: n (int): Number of gears gears (list of int): List of gear sizes Returns: int: Length of the longest possible chain of gears >>> longest_gear_chain(5, [1, 2, 4, 3, 8]) 4 >>> longest_gear_chain(6, [6, 3, 12, 24, 48, 96]) 6 >>> longest_gear_chain(1, [1]) 1 >>> longest_gear_chain(4, [5, 11, 13, 23]) 1 >>> longest_gear_chain(7, [1, 2, 4, 8, 16, 32, 64]) 7 def solve_all_cases(cases: List[Tuple[int, List[int]]]) -> List[int]: Function to solve multiple test cases for the longest gear chain problem. Parameters: cases (list of tuples): Each tuple contains an integer n and a list of gear sizes Returns: list of int: Results for each test case >>> solve_all_cases([(5, [1, 2, 4, 3, 8]), (6, [6, 3, 12, 24, 48, 96])]) [4, 6]","solution":"def longest_gear_chain(n, gears): Function to find the length of the longest chain of gears that can mesh together. Parameters: n (int): Number of gears gears (list of int): List of gear sizes Returns: int: Length of the longest possible chain of gears from collections import defaultdict # Sort gears and initialize a dictionary to store the chain lengths gears.sort() chain_len = defaultdict(int) longest_chain = 0 for gear in gears: previous_gear = gear // 2 if gear % 2 == 0 and previous_gear in chain_len: chain_len[gear] = chain_len[previous_gear] + 1 else: chain_len[gear] = 1 longest_chain = max(longest_chain, chain_len[gear]) return longest_chain # For testing the solution function with multiple test cases def solve_all_cases(cases): results = [] for case in cases: n, gears = case results.append(longest_gear_chain(n, gears)) return results"},{"question":"def can_fit_in_container(H: int, barrels: List[int]) -> str: Determines if the barrels can fit inside the container without exceeding its height. Parameters: H (int): The height of the container. barrels (list of int): List of heights of the barrels. Returns: str: \\"YES\\" if barrels can be loaded, otherwise \\"NO\\". >>> can_fit_in_container(10, [2, 3, 2]) == \\"YES\\" >>> can_fit_in_container(20, [15, 10]) == \\"NO\\" def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases of container and barrels. Parameters: test_cases (list of tuples): Each tuple contains the height of the container, the number of barrels, and the list of barrel heights. Returns: list of str: List of results for each test case. >>> process_test_cases([(10, 3, [2, 3, 2]), (20, 2, [15, 10]), (5, 2, [3, 3])]) == [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_fit_in_container(H, barrels): Determines if the barrels can fit inside the container without exceeding its height. Parameters: H (int): The height of the container. barrels (list of int): List of heights of the barrels. Returns: str: \\"YES\\" if barrels can be loaded, otherwise \\"NO\\". return \\"YES\\" if sum(barrels) <= H else \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases of container and barrels. Parameters: test_cases (list of tuples): Each tuple contains the height of the container, the number of barrels, and the list of barrel heights. Returns: list of str: List of results for each test case. results = [] for H, N, barrels in test_cases: results.append(can_fit_in_container(H, barrels)) return results"},{"question":"def final_position(n, commands): Returns the final position of the robot after executing all commands. Parameters: - n: number of commands (int) - commands: list of strings where each string represents a command in the format 'DIRECTION STEPS' Returns: - tuple(int, int): The final coordinates of the robot. Examples: >>> final_position(5, [\\"U 3\\", \\"R 2\\", \\"D 1\\", \\"L 4\\", \\"D 2\\"]) (-2, 0) >>> final_position(3, [\\"U 10\\", \\"R 5\\", \\"D 3\\"]) (5, 7) from solution import final_position def test_example_cases(): commands1 = [\\"U 3\\", \\"R 2\\", \\"D 1\\", \\"L 4\\", \\"D 2\\"] assert final_position(5, commands1) == (-2, 0) commands2 = [\\"U 10\\", \\"R 5\\", \\"D 3\\"] assert final_position(3, commands2) == (5, 7) def test_no_movement(): commands1 = [\\"U 0\\", \\"R 0\\", \\"D 0\\", \\"L 0\\"] assert final_position(4, commands1) == (0, 0) def test_all_directions(): commands1 = [\\"U 4\\", \\"D 4\\", \\"L 4\\", \\"R 4\\"] assert final_position(4, commands1) == (0, 0) def test_large_movement(): commands1 = [\\"U 1000\\", \\"R 1000\\"] assert final_position(2, commands1) == (1000, 1000) def test_negative_case(): commands1 = [\\"D 10\\", \\"L 10\\"] assert final_position(2, commands1) == (-10, -10) def test_edge_cases(): commands1 = [\\"U 1000\\", \\"D 1000\\", \\"L 1000\\", \\"R 1000\\"] assert final_position(4, commands1) == (0, 0) commands2 = [\\"U 1000\\", \\"D 999\\", \\"L 1000\\", \\"R 1\\"] assert final_position(4, commands2) == (-999, 1)","solution":"def final_position(n, commands): Returns the final position of the robot after executing all commands. Input: - n: number of commands (int) - commands: list of strings where each string represents a command Output: - tuple (x, y): final coordinates of the robot x, y = 0, 0 for command in commands: direction, steps = command.split() steps = int(steps) if direction == 'U': y += steps elif direction == 'D': y -= steps elif direction == 'L': x -= steps elif direction == 'R': x += steps return (x, y)"},{"question":"def optimal_rearrangement(N: int, heights: List[int]) -> List[int]: Rearrange the heights array to minimize the sum of absolute differences between each corresponding pair of students in the two rows. Parameters: N (int): Number of students heights (List[int]): Heights of the students Returns: List[int]: Heights of students in new arrangement Example: >>> optimal_rearrangement(4, [10, 1, 3, 5]) [1, 3, 5, 10] >>> optimal_rearrangement(3, [3, 2, 1]) [1, 2, 3] pass","solution":"def optimal_rearrangement(N, heights): Rearrange the heights array to minimize the sum of absolute differences between each corresponding pair of students in the two rows. Parameters: N (int): Number of students heights (List[int]): Heights of the students Returns: List[int]: Heights of students in new arrangement # Sorting the array heights.sort() return heights"},{"question":"def most_frequent_element(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the smallest element that appears most frequently in the list for each test case. Args: t (int): number of test cases. test_cases (List[Tuple[int, List[int]]]): List where each element is a tuple containing an integer n and a list of n elements. Returns: List[int]: List of integers where each integer is the result for the corresponding test case. >>> most_frequent_element(1, [(5, [1, 2, 2, 1, 3])]) [1] >>> most_frequent_element(3, [(5, [1, 2, 2, 1, 3]), (6, [4, 4, 4, 6, 6, 6]), (4, [-1, -1, -1, -2])]) [1, 4, -1]","solution":"def most_frequent_element(t, test_cases): results = [] for case in test_cases: n, elements = case frequency = {} for element in elements: if element in frequency: frequency[element] += 1 else: frequency[element] = 1 max_freq = max(frequency.values()) candidates = [key for key, value in frequency.items() if value == max_freq] results.append(min(candidates)) return results"},{"question":"def longest_non_decreasing_period(n: int, temperatures: List[int]) -> int: Sasha enjoys studying weather patterns and often conducts analysis on temperatures recorded over a period of time. Given a list of daily temperature readings, Sasha wants to find out the longest period of days during which the temperature was continuously non-decreasing. >>> longest_non_decreasing_period(10, [5, 6, 6, 3, 4, 5, 7, 7, 8, 2]) 6 >>> longest_non_decreasing_period(0, []) 0 >>> longest_non_decreasing_period(1, [5]) 1 >>> longest_non_decreasing_period(5, [1, 2, 3, 4, 5]) 5 >>> longest_non_decreasing_period(5, [5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_period(7, [5, 5, 5, 5, 5, 5, 5]) 7 >>> longest_non_decreasing_period(6, [1, 3, 2, 4, 3, 5]) 2 >>> longest_non_decreasing_period(6, [1, 2, 2, 1, 4, 4]) 3","solution":"def longest_non_decreasing_period(n, temperatures): if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if temperatures[i] >= temperatures[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def maximize_fruits(n: int, k: int, fruits: List[int]) -> int: Determine the maximum number of magical fruits that can be collected over k years by cutting down exactly one tree each year. Args: n : int : number of trees k : int : number of years fruits : List[int] : yearly production of magical fruits for each tree Returns: int : the maximum number of magical fruits that can be collected in k years Example: >>> maximize_fruits(5, 3, [10, 20, 30, 40, 50]) 120 >>> maximize_fruits(5, 1, [10, 20, 30, 40, 50]) 50 from typing import List def maximize_fruits(n: int, k: int, fruits: List[int]) -> int: Returns the maximum number of magical fruits that can be collected over k years by cutting down exactly one tree each year. ... def test_maximize_fruits_example_case(): assert maximize_fruits(5, 3, [10, 20, 30, 40, 50]) == 120 def test_maximize_fruits_single_year(): assert maximize_fruits(5, 1, [10, 20, 30, 40, 50]) == 50 def test_maximize_fruits_all_years(): assert maximize_fruits(5, 5, [10, 20, 30, 40, 50]) == 150 def test_maximize_fruits_identical_trees(): assert maximize_fruits(5, 3, [10, 10, 10, 10, 10]) == 30 def test_maximize_fruits_two_equal_partitions(): assert maximize_fruits(4, 2, [30, 20, 20, 30]) == 60 def test_maximize_fruits_minimum_values(): assert maximize_fruits(1, 1, [1]) == 1 assert maximize_fruits(2, 1, [1, 2]) == 2 assert maximize_fruits(2, 2, [1, 2]) == 3 def test_maximize_fruits_maximum_values(): assert maximize_fruits(20, 10, [100] * 20) == 1000 assert maximize_fruits(20, 20, [100] * 20) == 2000","solution":"def maximize_fruits(n, k, fruits): Returns the maximum number of magical fruits that can be collected over k years by cutting down exactly one tree each year. # Sort the list to ensure we cut down the trees with the most fruits first sorted_fruits = sorted(fruits, reverse=True) # Sum the top k elements from the sorted list return sum(sorted_fruits[:k])"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(level_order): if not level_order or level_order[0] == -1: return None root = TreeNode(level_order[0]) queue = [(root, 0)] front = 0 while front < len(queue): node, index = queue[front] front += 1 left_index = 2 * index + 1 right_index = 2 * index + 2 if left_index < len(level_order) and level_order[left_index] != -1: node.left = TreeNode(level_order[left_index]) queue.append((node.left, left_index)) if right_index < len(level_order) and level_order[right_index] != -1: node.right = TreeNode(level_order[right_index]) queue.append((node.right, right_index)) return root def tree_height(root): Given a binary tree root node, find the height of the tree. >>> root = build_tree([1, 2, 3, -1, -1, 4, 5, -1, -1, -1, -1, 6, 7]) >>> tree_height(root) 4 pass def teardrop_forest_height(test_cases): Given list of test cases with binary tree node values, find the height of each tree. >>> test_cases = [[1, 2, 3, -1, -1, 4, 5, -1, -1, -1, -1, 6, 7], [1, 2, 3, -1, 4, -1, 5]] >>> teardrop_forest_height(test_cases) [4, 3] pass # Helper function to process input and call main function def main(input_str): Given an input string, process it to obtain test cases, then find and return the heights of the corresponding binary trees. >>> input_str = \\"2n9n1 2 3 -1 -1 4 5 -1 -1 -1 -1 6 7n7n1 2 3 -1 4 -1 5\\" >>> main(input_str) [4, 3] pass def test_teardrop_forest_height(): input_str = \\"2n9n1 2 3 -1 -1 4 5 -1 -1 -1 -1 6 7n7n1 2 3 -1 4 -1 5\\" expected_output = [4, 3] assert main(input_str) == expected_output def test_single_node(): input_str = \\"1n1n5\\" expected_output = [1] assert main(input_str) == expected_output def test_all_null_nodes(): input_str = \\"1n7n-1 -1 -1 -1 -1 -1 -1\\" expected_output = [0] assert main(input_str) == expected_output def test_only_root_node(): input_str = \\"1n1n1\\" expected_output = [1] assert main(input_str) == expected_output def test_unbalanced_tree(): input_str = \\"1n5n1 2 -1 3 -1\\" expected_output = [3] assert main(input_str) == expected_output def test_no_nodes(): input_str = \\"1n0\\" expected_output = [0] assert main(input_str) == expected_output","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(level_order): if not level_order or level_order[0] == -1: return None root = TreeNode(level_order[0]) queue = [(root, 0)] front = 0 while front < len(queue): node, index = queue[front] front += 1 left_index = 2 * index + 1 right_index = 2 * index + 2 if left_index < len(level_order) and level_order[left_index] != -1: node.left = TreeNode(level_order[left_index]) queue.append((node.left, left_index)) if right_index < len(level_order) and level_order[right_index] != -1: node.right = TreeNode(level_order[right_index]) queue.append((node.right, right_index)) return root def tree_height(root): if not root: return 0 left_height = tree_height(root.left) right_height = tree_height(root.right) return 1 + max(left_height, right_height) def teardrop_forest_height(test_cases): results = [] for nodes in test_cases: if not nodes: results.append(0) continue root = build_tree(nodes) height = tree_height(root) results.append(height) return results # Helper function to process input and call main function def main(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) if N == 0: test_cases.append([]) else: nodes = list(map(int, input_lines[index + 1].split())) test_cases.append(nodes) index += 2 return teardrop_forest_height(test_cases)"},{"question":"def max_items(N: int, B: int, costs: List[int]) -> int: Returns the maximum number of items that can be bought within the budget B. >>> max_items(3, 50, [20, 10, 5]) 10 >>> max_items(1, 100, [25]) 4 >>> max_items(3, 30, [1, 2, 5]) 30 >>> max_items(3, 7, [10, 20, 30]) 0 from typing import List # Add your test cases here if you have more def test_max_items(): assert max_items(3, 50, [20, 10, 5]) == 10 assert max_items(1, 100, [25]) == 4 assert max_items(1, 101, [25]) == 4 assert max_items(1, 23, [25]) == 0 assert max_items(3, 30, [1, 2, 5]) == 30 assert max_items(3, 0, [1, 2, 3]) == 0 assert max_items(3, 100, [10, 50, 1]) == 100 assert max_items(3, 7, [10, 20, 30]) == 0","solution":"def max_items(N, B, costs): Returns the maximum number of items that can be bought within the budget B. :param N: Number of different item costs :param B: Budget :param costs: List of item costs :return: Maximum number of items that can be bought costs.sort() total_items = 0 for cost in costs: if B >= cost: items = B // cost total_items += items B -= items * cost if B == 0: break return total_items"},{"question":"def common_subsequence_exists(n, m, seq_a, seq_b): Determines if there exists a non-empty subsequence that is common to both sequences. :param n: int - the size of the first sequence :param m: int - the size of the second sequence :param seq_a: list of int - the elements of the first sequence :param seq_b: list of int - the elements of the second sequence :return: str - \\"YES\\" if a common subsequence exists, otherwise \\"NO\\" # Your implementation here Unit Test: from solution import common_subsequence_exists def test_common_subsequence_exists_yes(): assert common_subsequence_exists(3, 4, [1, 2, 3], [4, 5, 2, 6]) == 'YES' def test_common_subsequence_exists_no(): assert common_subsequence_exists(5, 5, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) == 'NO' def test_common_subsequence_all_common(): assert common_subsequence_exists(3, 3, [6, 7, 8], [8, 7, 6]) == 'YES' def test_common_subsequence_no_common_empty(): assert common_subsequence_exists(4, 3, [10, 20, 30, 40], [50, 60, 70]) == 'NO' def test_common_subsequence_single_element_common(): assert common_subsequence_exists(1, 1, [1], [1]) == 'YES' def test_common_subsequence_single_element_no_common(): assert common_subsequence_exists(1, 1, [2], [3]) == 'NO' def test_common_subsequence_large_input(): seq_a = list(range(1, 100001)) seq_b = list(range(50000, 150000)) assert common_subsequence_exists(100000, 100000, seq_a, seq_b) == 'YES' def test_common_subsequence_large_input_no_common(): seq_a = list(range(1, 100001)) seq_b = list(range(100001, 200001)) assert common_subsequence_exists(100000, 100000, seq_a, seq_b) == 'NO'","solution":"def common_subsequence_exists(n, m, seq_a, seq_b): Determines if there exists a non-empty subsequence that is common to both sequences. :param n: int - the size of the first sequence :param m: int - the size of the second sequence :param seq_a: list of int - the elements of the first sequence :param seq_b: list of int - the elements of the second sequence :return: str - \\"YES\\" if a common subsequence exists, otherwise \\"NO\\" set_a = set(seq_a) set_b = set(seq_b) common_elements = set_a.intersection(set_b) if common_elements: return 'YES' else: return 'NO'"},{"question":"def solve(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine whether there exists a Hamiltonian cycle in each given graph (set of cities and roads). Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test cases where each test case is a tuple containing an integer number of cities, an integer number of roads, and a list of tuples representing roads between cities. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case based on whether a Hamiltonian cycle exists or not. Example: >>> test_cases = [ (4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]), (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)]) ] >>> solve(test_cases) ['YES', 'YES', 'NO']","solution":"from itertools import permutations def is_hamiltonian_cycle(graph, n): # Generate all permutations of vertices to check for Hamiltonian cycle vertices = list(range(n)) for perm in permutations(vertices): valid_cycle = True # Check if the permutation forms a valid Hamiltonian cycle for i in range(n): if perm[i] not in graph[perm[(i+1) % n]]: valid_cycle = False break if valid_cycle: return True return False def solve(test_cases): results = [] for n, m, edges in test_cases: graph = { i: set() for i in range(n) } for u, v in edges: u -= 1 v -= 1 graph[u].add(v) graph[v].add(u) if is_hamiltonian_cycle(graph, n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def contest_participation(E, A, B, C): Returns the count of employees who participated only in Contest A, only in Contest B, and those who did not participate in any contest. Parameters: E (int): Total number of employees A (int): Number of employees who participated in Contest A B (int): Number of employees who participated in Contest B C (int): Number of employees who participated in both contests Returns: tuple: three integers representing the number of employees who participated only in Contest A, only in Contest B, and those who did not participate in any contest. Examples: >>> contest_participation(10, 4, 5, 2) (2, 3, 3) >>> contest_participation(50, 20, 30, 10) (10, 20, 10)","solution":"def contest_participation(E, A, B, C): Returns the count of employees who participated only in Contest A, only in Contest B, and those who did not participate in any contest. only_A = A - C only_B = B - C neither = E - (A + B - C) return only_A, only_B, neither # Example usage if __name__ == \\"__main__\\": E, A, B, C = map(int, input().split()) results = contest_participation(E, A, B, C) for result in results: print(result)"},{"question":"def find_unique_integer(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of integers where each integer appears exactly twice, except for one integer which appears exactly once. Your task is to find the integer that appears only once. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, where each tuple contains an integer n and a list of 2n+1 integers. Returns: List[int]: List of integers which appear only once for each test case. Example: >>> find_unique_integer(1, [(1, [2, 2, 1])]) [1] >>> find_unique_integer(2, [(1, [2, 2, 1]), (3, [4, 1, 2, 1, 2, 3, 4])]) [1, 3]","solution":"def find_unique_integer(t, test_cases): results = [] for case in test_cases: n, arr = case unique = 0 for num in arr: unique ^= num results.append(unique) return results # Example usage: # t = 2 # test_cases = [ # (1, [2, 2, 1]), # (3, [4, 1, 2, 1, 2, 3, 4]), # ] # Output should be [1, 3]"},{"question":"def longest_word_chain(words: List[str]) -> int: Given a list of words, find the length of the longest chain of words that can be formed such that each word in the chain is one character longer than the previous word and contains all the characters of the previous word. Each word in the list is unique. >>> longest_word_chain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) 4 >>> longest_word_chain([\\"a\\"]) 1 >>> longest_word_chain([\\"a\\", \\"b\\"]) 1 >>> longest_word_chain([\\"a\\", \\"ab\\"]) 2 >>> longest_word_chain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) 5 >>> longest_word_chain([\\"cat\\", \\"dog\\", \\"mouse\\"]) 1 >>> longest_word_chain([\\"a\\", \\"bat\\", \\"b\\", \\"ba\\", \\"bta\\", \\"bcat\\", \\"bca\\"]) 4","solution":"def longest_word_chain(words): words.sort(key=lambda x: len(x)) word_map = {word: 1 for word in words} max_chain_length = 1 for word in words: for i in range(len(word)): prev_word = word[:i] + word[i+1:] if prev_word in word_map: word_map[word] = max(word_map[word], word_map[prev_word] + 1) max_chain_length = max(max_chain_length, word_map[word]) return max_chain_length"},{"question":"import re def is_palindrome(phrase: str) -> bool: Write a function that takes in a string as an input and returns true if it is a palindrome ignoring spaces, capitalization, and punctuation; otherwise, false. Args: phrase (str): Input string to check for palindrome Returns: bool: True if the input string is a palindrome, False otherwise Examples: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"Madam\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"!\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"Able was I ere I saw Elba\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"12321\\") True","solution":"import re def is_palindrome(phrase): Returns true if the given phrase is a palindrome ignoring spaces, capitalization, and punctuation; otherwise, false. # Remove all non-alphanumeric characters and convert to lowercase cleaned_phrase = re.sub(r'[^a-zA-Z0-9]', '', phrase).lower() # Check if cleaned_phrase is a palindrome return cleaned_phrase == cleaned_phrase[::-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class ListNode: def __init__(self, x): self.val = x self.next = None from collections import deque def createLevelLinkedList(root): Given a binary tree, create a linked list for each level of the tree. Args: root (TreeNode): The root of the binary tree. Returns: List[ListNode]: A list of linked lists, where each linked list contains the nodes at each level of the tree. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> linked_lists = createLevelLinkedList(root) >>> [linked_list_to_list(lst) for lst in linked_lists] [[1], [2, 3], [4, 5, 6, 7]] >>> root = TreeNode(10) >>> root.left = TreeNode(20) >>> root.right = TreeNode(30) >>> root.left.left = TreeNode(40) >>> root.right.right = TreeNode(50) >>> linked_lists = createLevelLinkedList(root) >>> [linked_list_to_list(lst) for lst in linked_lists] [[10], [20, 30], [40, 50]] def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result def test_createLevelLinkedList_example1(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) linked_lists = createLevelLinkedList(root) result = [linked_list_to_list(lst) for lst in linked_lists] assert result == [[1], [2, 3], [4, 5, 6, 7]] def test_createLevelLinkedList_example2(): root = TreeNode(10) root.left = TreeNode(20) root.right = TreeNode(30) root.left.left = TreeNode(40) root.right.right = TreeNode(50) linked_lists = createLevelLinkedList(root) result = [linked_list_to_list(lst) for lst in linked_lists] assert result == [[10], [20, 30], [40, 50]] def test_createLevelLinkedList_single_node(): root = TreeNode(1) linked_lists = createLevelLinkedList(root) result = [linked_list_to_list(lst) for lst in linked_lists] assert result == [[1]] def test_createLevelLinkedList_empty_tree(): linked_lists = createLevelLinkedList(None) result = [linked_list_to_list(lst) for lst in linked_lists] assert result == []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class ListNode: def __init__(self, x): self.val = x self.next = None def createLevelLinkedList(root): if not root: return [] result = [] current_level = deque([root]) while current_level: level_size = len(current_level) level_head = level_tail = ListNode(0) # Dummy head node for current level linked list for _ in range(level_size): tree_node = current_level.popleft() level_tail.next = ListNode(tree_node.val) level_tail = level_tail.next if tree_node.left: current_level.append(tree_node.left) if tree_node.right: current_level.append(tree_node.right) result.append(level_head.next) # Append the actual head (skipping dummy node) return result"},{"question":"def library_system(operations: List[str]) -> List[str]: Manage the genre distribution of books in a library. This function takes a list of operations related to borrowing and returning books in a library, and it returns the current distribution of genres on the library's shelves after each QUERY operation. Each operation is a string in the following format: - \\"BORROW book_id genre\\" - \\"RETURN book_id genre\\" - \\"QUERY\\" - \\"STOP\\" The function returns a list of strings, where each string represents the genre distribution after a QUERY operation, in the format \\"GENRE:count\\", one genre per line, sorted lexicographically by the genre names. If the library has no books, the output should be \\"EMPTY\\". Example: >>> operations = [\\"BORROW 1 Fiction\\", \\"BORROW 2 Non-Fiction\\", \\"RETURN 1 Fiction\\", \\"QUERY\\", \\"BORROW 3 Science\\", \\"QUERY\\", \\"STOP\\"] >>> library_system(operations) ['Non-Fiction:1', 'Non-Fiction:1nScience:1']","solution":"def library_system(operations): genre_count = {} borrowed_books = {} def borrow(book_id, genre): if book_id not in borrowed_books: if genre not in genre_count: genre_count[genre] = 0 borrowed_books[book_id] = genre genre_count[genre] += 1 def return_book(book_id, genre): if book_id in borrowed_books: borrowed_genre = borrowed_books.pop(book_id) genre_count[borrowed_genre] -= 1 if genre_count[borrowed_genre] == 0: del genre_count[borrowed_genre] def query(): if not genre_count: return \\"EMPTY\\" result = [f\\"{genre}:{count}\\" for genre, count in sorted(genre_count.items())] return \\"n\\".join(result) result = [] for operation in operations: parts = operation.split() if parts[0] == \\"BORROW\\": _, book_id, genre = parts borrow(book_id, genre) elif parts[0] == \\"RETURN\\": _, book_id, genre = parts return_book(book_id, genre) elif parts[0] == \\"QUERY\\": result.append(query()) elif parts[0] == \\"STOP\\": break return result"},{"question":"def longest_increasing_sequence(d, temp_data): Returns the length of the longest sequence of strictly increasing temperatures for each day. >>> longest_increasing_sequence(3, [ ... [5, 1, 2, 3, 2, 4], ... [6, -3, -2, -1, 0, 1, 2], ... [4, 5, 4, 3, 2] ... ]) [3, 6, 1] >>> longest_increasing_sequence(1, [ ... [4, 3, 3, 3, 3] ... ]) [1] >>> longest_increasing_sequence(1, [ ... [1, 5] ... ]) [1] >>> longest_increasing_sequence(2, [ ... [7, -1, 0, 1, 2, 1, 2, 3], ... [5, -5, -4, -3, -2, -1] ... ]) [4, 5] >>> longest_increasing_sequence(3, [ ... [0], ... [3, 1, 2, 3], ... [0] ... ]) [0, 3, 0] >>> longest_increasing_sequence(1, [ ... [8, 1, 2, 1, 2, 1, 2, 1, 2] ... ]) [2] >>> longest_increasing_sequence(1, [ ... [5, 10, 9, 8, 7, 6] ... ]) [1]","solution":"def longest_increasing_sequence(d, temp_data): Returns the length of the longest sequence of strictly increasing temperatures for each day. results = [] for day_data in temp_data: n = day_data[0] temperatures = day_data[1:] if n == 0: results.append(0) continue longest, current_streak = 1, 1 for i in range(1, n): if temperatures[i] > temperatures[i - 1]: current_streak += 1 longest = max(longest, current_streak) else: current_streak = 1 results.append(longest) return results"},{"question":"class Warehouse: def __init__(self): Initializes a new warehouse with an empty inventory. pass def add_item(self, i: int, q: int): Adds 'q' quantity of item 'i' to the inventory. pass def remove_item(self, i: int, q: int): Removes 'q' quantity of item 'i' from the inventory. If the quantity of item 'i' is less than 'q', this operation should not be performed. pass def count_item(self, i: int) -> int: Returns the current quantity of item 'i' in the inventory. pass def total_unique_items(self) -> int: Returns the total number of different items that have a non-zero quantity in the inventory. pass def total_all_items(self) -> int: Returns the total quantity of all items combined in the inventory. pass # Example usage and test cases def test_add_and_count_item(): wh = Warehouse() wh.add_item(1, 50) wh.add_item(2, 30) assert wh.count_item(1) == 50 assert wh.count_item(2) == 30 assert wh.count_item(3) == 0 def test_remove_item(): wh = Warehouse() wh.add_item(1, 50) wh.remove_item(1, 10) assert wh.count_item(1) == 40 wh.remove_item(1, 40) assert wh.count_item(1) == 0 wh.remove_item(1, 10) # Removing more than available should do nothing assert wh.count_item(1) == 0 def test_total_unique_items(): wh = Warehouse() assert wh.total_unique_items() == 0 wh.add_item(1, 50) wh.add_item(2, 30) assert wh.total_unique_items() == 2 wh.remove_item(2, 30) assert wh.total_unique_items() == 1 def test_total_all_items(): wh = Warehouse() assert wh.total_all_items() == 0 wh.add_item(1, 50) wh.add_item(2, 30) assert wh.total_all_items() == 80 wh.remove_item(1, 20) assert wh.total_all_items() == 60 def test_integrated_case(): wh = Warehouse() wh.add_item(1, 50) wh.add_item(2, 30) assert wh.count_item(1) == 50 wh.remove_item(2, 10) assert wh.count_item(2) == 20 assert wh.total_unique_items() == 2 assert wh.total_all_items() == 70 wh.remove_item(1, 60) # Should not remove because not enough quantity assert wh.total_unique_items() == 2 assert wh.total_all_items() == 70 wh.remove_item(1, 50) assert wh.total_unique_items() == 1 assert wh.total_all_items() == 20","solution":"class Warehouse: def __init__(self): self.inventory = {} def add_item(self, i, q): if i in self.inventory: self.inventory[i] += q else: self.inventory[i] = q def remove_item(self, i, q): if i in self.inventory and self.inventory[i] >= q: self.inventory[i] -= q if self.inventory[i] == 0: del self.inventory[i] def count_item(self, i): return self.inventory.get(i, 0) def total_unique_items(self): return len(self.inventory) def total_all_items(self): return sum(self.inventory.values())"},{"question":"def is_valid_parentheses(s: str) -> str: Determine if a given string of parentheses is valid. A valid string follows these rules: 1. Open parentheses must be closed by the same type of parentheses. 2. Open parentheses must be closed in the correct order. The parentheses considered in this task are \`()\` (round brackets), \`[]\` (square brackets), and \`{}\` (curly brackets). Args: s: A string containing only the characters \`(\`, \`)\`, \`{\`, \`}\`, \`[\` and \`]\`. Returns: \\"Yes\\" if the string is valid, and \\"No\\" otherwise. Examples: >>> is_valid_parentheses(\\"[{()}]\\") \\"Yes\\" >>> is_valid_parentheses(\\"[(])\\") \\"No\\" >>> is_valid_parentheses(\\"([]{})\\") \\"Yes\\" >>> is_valid_parentheses(\\"())\\") \\"No\\"","solution":"def is_valid_parentheses(s): Returns 'Yes' if the string of parentheses is valid according to the specified rules, otherwise returns 'No'. stack = [] matching_parentheses = {')': '(', ']': '[', '}': '{'} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return \\"No\\" else: return \\"No\\" return \\"Yes\\" if not stack else \\"No\\""},{"question":"import heapq import sys def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: You are given an undirected graph with \`n\` nodes and \`m\` edges. Each node has a unique ID from 1 to \`n\`. Each edge connects a pair of nodes and has a weight associated with it. Your task is to find the length of the shortest path (in terms of total weight) from node 1 to node \`n\`. If no such path exists, return -1. Input: n (int): The number of nodes (2 ≤ n ≤ 10^5) m (int): The number of edges (1 ≤ m ≤ 10^5) edges (List[Tuple[int, int, int]]): Each tuple contains three integers \`u\`, \`v\` and \`w\` (1 ≤ u, v ≤ n, 1 ≤ w ≤ 10^9). Output: int: The length of the shortest path from node 1 to node \`n\`, or -1 if no path exists. pass def test_example1(): n = 5 m = 6 edges = [ (1, 2, 3), (1, 3, 1), (2, 3, 7), (2, 4, 5), (3, 4, 2), (4, 5, 7) ] assert shortest_path(n, m, edges) == 10 def test_example2(): n = 3 m = 2 edges = [ (1, 2, 4), (2, 3, 5) ] assert shortest_path(n, m, edges) == 9 def test_example3(): n = 3 m = 1 edges = [ (2, 3, 10) ] assert shortest_path(n, m, edges) == -1 def test_no_edges(): n = 2 m = 0 edges = [] assert shortest_path(n, m, edges) == -1 def test_direct_connection(): n = 2 m = 1 edges = [ (1, 2, 5) ] assert shortest_path(n, m, edges) == 5 def test_large_values(): n = 4 m = 4 edges = [ (1, 2, 1000000000), (2, 3, 1000000000), (3, 4, 1000000000), (1, 4, 3000000000) ] assert shortest_path(n, m, edges) == 3000000000 def test_disconnected_graph(): n = 4 m = 2 edges = [ (1, 2, 1), (3, 4, 1) ] assert shortest_path(n, m, edges) == -1","solution":"import heapq import sys def shortest_path(n, m, edges): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(start, target): min_heap = [(0, start)] distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 visited = set() while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node in visited: continue visited.add(current_node) if current_node == target: return current_distance for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 return dijkstra(1, n)"},{"question":"def filter_important_messages(messages: List[str], keyword: str) -> List[str]: Returns a list of messages containing the keyword. The comparison is case-insensitive, and if the keyword is an empty string, it returns all messages. :param messages: List of message strings. :param keyword: The keyword string to look for. :return: List of messages containing the keyword. # Example Test Cases messages = [\\"Don't forget the meeting tomorrow\\", \\"lunch at noon?\\", \\"Project deadline is next week\\", \\"Meeting notes have been shared\\"] keyword = \\"meeting\\" assert filter_important_messages(messages, keyword) == [\\"Don't forget the meeting tomorrow\\", \\"Meeting notes have been shared\\"] messages = [\\"Don't forget the meeting tomorrow\\", \\"Lunch at noon?\\", \\"Project deadline is next week\\", \\"Meeting notes have been shared\\"] keyword = \\"dinner\\" assert filter_important_messages(messages, keyword) == [] messages = [\\"Don't forget the meeting tomorrow\\", \\"Lunch at noon?\\", \\"Project deadline is next week\\", \\"Meeting notes have been shared\\"] keyword = \\"\\" assert filter_important_messages(messages, keyword) == messages messages = [\\"Don't forget the Meeting tomorrow\\", \\"Lunch at noon?\\", \\"Project Deadline is next week\\", \\"Meeting notes have been shared\\"] keyword = \\"meeting\\" assert filter_important_messages(messages, keyword) == [\\"Don't forget the Meeting tomorrow\\", \\"Meeting notes have been shared\\"] messages = [\\"OMG! This is amazing\\", \\"I can't believe it\\", \\"Amazing things are happening\\"] keyword = \\"amazing\\" assert filter_important_messages(messages, keyword) == [\\"OMG! This is amazing\\", \\"Amazing things are happening\\"]","solution":"def filter_important_messages(messages, keyword): Returns a list of messages containing the keyword. The comparison is case-insensitive, and if the keyword is an empty string, it returns all messages. :param messages: List of message strings. :param keyword: The keyword string to look for. :return: List of messages containing the keyword. keyword = keyword.lower() return [message for message in messages if keyword in message.lower()]"},{"question":"from typing import List, Tuple def secure_trade_route(n: int, m: int, k: int, q: int, edges: List[Tuple[int, int, int]], zombies: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determine the shortest secure trade route between cities avoiding zombie-infested areas. Parameters: n (int): Number of cities. m (int): Number of edges. k (int): Number of zombie-infested cities. q (int): Number of queries. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w). zombies (List[int]): List of zombie-infested cities. queries (List[Tuple[int, int]]): List of queries where each query is represented as a tuple (S, T). Returns: List[int]: List of shortest distances for each query. If no path exists, the distance is -1. pass def test_case_1(): n = 10 m = 10 k = 2 q = 1 edges = [ (1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 5, 3), (4, 5, 4), (5, 6, 11), (4, 6, 1), (3, 7, 8), (7, 8, 6), (4, 9, 7), (7, 10, 2), (5, 7, 3) ] zombies = [10, 5] queries = [(1, 6)] expected = [15] assert secure_trade_route(n, m, k, q, edges, zombies, queries) == expected def test_no_edges(): n = 5 m = 0 k = 1 q = 1 edges = [] zombies = [1] queries = [(2, 3)] expected = [-1] assert secure_trade_route(n, m, k, q, edges, zombies, queries) == expected def test_all_cities_zombie(): n = 6 m = 7 k = 5 q = 1 edges = [ (1, 2, 7), (2, 3, 10), (3, 4, 1), (4, 5, 4), (5, 6, 3), (6, 1, 6), (2, 4, 12) ] zombies = [1, 2, 3, 4, 6] queries = [(5, 1)] expected = [-1] assert secure_trade_route(n, m, k, q, edges, zombies, queries) == expected def test_queries_with_direct_zombie_cities(): n = 6 m = 6 k = 1 q = 1 edges = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7), (3, 6, 1) ] zombies = [5] queries = [(1, 5)] expected = [-1] assert secure_trade_route(n, m, k, q, edges, zombies, queries) == expected def test_reachable_with_zombie_cities(): n = 4 m = 5 k = 1 q = 1 edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 4), (2, 4, 5) ] zombies = [2] queries = [(1, 4)] expected = [5] assert secure_trade_route(n, m, k, q, edges, zombies, queries) == expected","solution":"import heapq def dijkstra(graph, start, target, zombie_cities, n): Calculate the shortest path using Dijkstra's algorithm avoiding zombie-infested cities. inf = float('inf') dist = [inf] * (n + 1) dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if u == target: return dist[target] if current_dist > dist[u]: continue for v, weight in graph[u]: if v in zombie_cities and v != target: continue new_dist = current_dist + weight if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(pq, (new_dist, v)) return -1 if dist[target] == inf else dist[target] def secure_trade_route(n, m, k, q, edges, zombies, queries): Solve the secure trade route problem. # Initialize the graph as an adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for start, target in queries: if start in zombies and start != target or target in zombies: results.append(-1) else: distance = dijkstra(graph, start, target, set(zombies), n) results.append(distance) return results"},{"question":"def most_frequent_color_of_sizes(marble_data): Determine the color of marbles that appears the most frequently for each size category. If there is a tie, choose the color that appears alphabetically first. >>> most_frequent_color_of_sizes([(\\"small\\", \\"red\\"), (\\"large\\", \\"blue\\"), (\\"medium\\", \\"green\\"), (\\"small\\", \\"blue\\"), (\\"medium\\", \\"green\\"), (\\"large\\", \\"red\\"), (\\"small\\", \\"red\\")]) ['large blue', 'medium green', 'small red'] >>> most_frequent_color_of_sizes([(\\"small\\", \\"red\\"), (\\"small\\", \\"blue\\"), (\\"small\\", \\"blue\\")]) ['small blue'] def parse_input(data): Parse the input data into marble size and color tuples. >>> parse_input(\\"7nsmall rednlarge bluenmedium greennsmall bluenmedium greennlarge rednsmall red\\") [(\\"small\\", \\"red\\"), (\\"large\\", \\"blue\\"), (\\"medium\\", \\"green\\"), (\\"small\\", \\"blue\\"), (\\"medium\\", \\"green\\"), (\\"large\\", \\"red\\"), (\\"small\\", \\"red\\")] def main(data): Main function to parse input and determine the most frequent color for each size. >>> main(\\"7nsmall rednlarge bluenmedium greennsmall bluenmedium greennlarge rednsmall red\\") \\"large bluenmedium greennsmall red\\"","solution":"def most_frequent_color_of_sizes(marble_data): from collections import defaultdict, Counter size_color_counts = defaultdict(Counter) # Parse the input list of marble data for size, color in marble_data: size_color_counts[size][color] += 1 result = [] for size in sorted(size_color_counts.keys()): color_count = size_color_counts[size] most_common_color = min(color_count.items(), key=lambda x: (-x[1], x[0])) result.append(f\\"{size} {most_common_color[0]}\\") return result def parse_input(data): lines = data.strip().split(\\"n\\") n = int(lines[0]) marble_data = [tuple(line.split()) for line in lines[1:n + 1]] return marble_data def main(data): marble_data = parse_input(data) result = most_frequent_color_of_sizes(marble_data) return \\"n\\".join(result)"},{"question":"import heapq import sys from typing import List, Tuple def find_emergency_station(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the best intersection to place an emergency service station with minimal maximum distance to all other intersections. Args: n : int : Number of intersections. m : int : Number of roads. roads : List[Tuple[int, int, int]] : List of tuples where each tuple consists of two intersections u, v and the distance d between them. Returns: int : The intersection index that should be the location of the emergency service station. Examples: >>> find_emergency_station(4, 5, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 1, 2), (1, 3, 1)]) 1 >>> find_emergency_station(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 4)]) 2 pass # Unit tests def test_example_1(): n = 4 m = 5 roads = [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 1, 2), (1, 3, 1)] assert find_emergency_station(n, m, roads) == 1 def test_example_2(): n = 3 m = 3 roads = [(1, 2, 1), (2, 3, 2), (1, 3, 4)] assert find_emergency_station(n, m, roads) == 2 def test_example_3(): n = 5 m = 7 roads = [(1, 2, 3), (1, 3, 5), (2, 3, 1), (3, 4, 2), (4, 5, 3), (5, 2, 2), (1, 4, 4)] assert find_emergency_station(n, m, roads) == 2 def test_two_intersections(): n = 2 m = 1 roads = [(1, 2, 10)] assert find_emergency_station(n, m, roads) == 1 def test_disconnected_graph(): n = 4 m = 2 roads = [(1, 2, 1), (3, 4, 1)] assert find_emergency_station(n, m, roads) == 1 def test_large_graph(): n = 5 m = 10 roads = [(1, 2, 1), (1, 3, 2), (1, 4, 3), (1, 5, 4), (2, 3, 1), (2, 4, 2), (2, 5, 3), (3, 4, 1), (3, 5, 2), (4, 5, 1)] assert find_emergency_station(n, m, roads) == 3","solution":"import heapq import sys def find_emergency_station(n, m, roads): def dijkstra(start, n, graph): distances = [float('inf')] * (n + 1) distances[start] = 0 queue = [(0, start)] heapq.heapify(queue) while queue: current_dist, u = heapq.heappop(queue) if current_dist > distances[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(queue, (distance, v)) return distances # Construct the graph from the road inputs graph = [[] for _ in range(n + 1)] for u, v, d in roads: graph[u].append((v, d)) graph[v].append((u, d)) min_max_distance = float('inf') optimal_intersection = 1 for i in range(1, n + 1): distances = dijkstra(i, n, graph) max_distance = max(distances[1:]) if max_distance < min_max_distance or (max_distance == min_max_distance and i < optimal_intersection): min_max_distance = max_distance optimal_intersection = i return optimal_intersection # Example usage: # n = 4 # m = 5 # roads = [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 1, 2), (1, 3, 1)] # print(find_emergency_station(n, m, roads)) # Output: 1"},{"question":"def min_machines_to_fulfill_order(machines, order): Determine the minimum number of machines required to fulfill the production order, or return -1 if it is not possible. Parameters: machines (List[str]): A list of strings where each string represents the types of parts a machine can produce. order (str): A string representing the production order. Returns: int: The minimum number of machines required to fulfill the order, or -1 if not possible. Examples: >>> min_machines_to_fulfill_order([\\"ABC\\", \\"DEF\\", \\"AC\\", \\"BD\\"], \\"AABBCC\\") 3 >>> min_machines_to_fulfill_order([\\"ABC\\", \\"DEF\\", \\"AC\\"], \\"XXYYZZ\\") -1 pass def process_input(input_data): Process the input data to determine the output for each test case. Parameters: input_data (str): The input data as a single string. Returns: List[int]: A list of results for each test case. Examples: >>> input_data = \\"1n4nABC DEF AC BDnAABBCCn\\" >>> process_input(input_data) [3] >>> input_data = \\"1n3nABC DEF ACnXXYYZZn\\" >>> process_input(input_data) [-1] pass def test_minimum_machines(): input_data = \\"1n4nABC DEF AC BDnAABBCCn\\" results = process_input(input_data) assert results == [3], f\\"Expected [3], but got {results}\\" def test_not_possible(): input_data = \\"1n3nABC DEF ACnXXYYZZn\\" results = process_input(input_data) assert results == [-1], f\\"Expected [-1], but got {results}\\" def test_single_machine(): input_data = \\"1n1nABCnABCn\\" results = process_input(input_data) assert results == [1], f\\"Expected [1], but got {results}\\" def test_multiple_machines_needed(): input_data = \\"1n5nA B C D EnABCDEn\\" results = process_input(input_data) assert results == [5], f\\"Expected [5], but got {results}\\" def test_min_length_strings(): input_data = \\"2n1nAnAn1nAnBn\\" results = process_input(input_data) assert results == [1, -1], f\\"Expected [1, -1], but got {results}\\"","solution":"def min_machines_to_fulfill_order(machines, order): from collections import Counter import itertools order_counter = Counter(order) def can_fulfill_order(selected_machines): combined_parts = Counter() for machine in selected_machines: combined_parts.update(machine) for part, count in order_counter.items(): if combined_parts[part] < count: return False return True M = len(machines) for r in range(1, M + 1): for selected_machines in itertools.combinations(machines, r): if can_fulfill_order(selected_machines): return r return -1 def process_input(input_data): data = input_data.strip().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): M = int(data[index]) index += 1 machines = [] for _ in range(M): machines.append(data[index]) index += 1 order = data[index] index += 1 results.append(min_machines_to_fulfill_order(machines, order)) return results"},{"question":"def can_arrange_students(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[str, Optional[List[int]]]]: Determine if it's possible to arrange students in such a way that no student is exactly between two students of the same height. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of tuples where each tuple contains an integer N (number of students) and a list of N integers (heights of the students) Returns: List[Tuple[str, Optional[List[int]]]] : For each test case, return \\"YES\\" and the possible arrangement if an arrangement is possible, otherwise return \\"NO\\", None. Example: >>> can_arrange_students(2, [(3, [1, 2, 2]), (4, [1, 2, 3, 4])]) [('NO', None), ('YES', [1, 2, 3, 4])]","solution":"def can_arrange_students(T, test_cases): results = [] for t in range(T): N, heights = test_cases[t] sorted_heights = sorted(heights) possible = True arrangement = [] for i in range(1, N): if sorted_heights[i] == sorted_heights[i-1]: possible = False break if possible: results.append((\\"YES\\", sorted_heights)) else: results.append((\\"NO\\", None)) return results"},{"question":"import re from typing import List def convert_dates_eu_to_us(text: str) -> str: Converts dates from European format (DD/MM/YYYY) to American format (MM/DD/YYYY) within a given text. Only valid dates are converted. Args: text (str): The input text containing dates to be converted. Returns: str: The text with dates converted from European to American format. >>> convert_dates_eu_to_us(\\"I have meetings on 25/12/2023 and 01/01/2024.\\") 'I have meetings on 12/25/2023 and 01/01/2024.' >>> convert_dates_eu_to_us(\\"The report was dated 12/30/2020 and will be revised on 45/50/9999.\\") 'The report was dated 12/30/2020 and will be revised on 45/50/9999.' >>> convert_dates_eu_to_us(\\"Meeting on 25/12/2023, end 45/50/9999.\\") 'Meeting on 12/25/2023, end 45/50/9999.' >>> convert_dates_eu_to_us(\\"Holiday on 01/01/2024 and 31/12/2023.\\") 'Holiday on 01/01/2024 and 12/31/2023.' >>> convert_dates_eu_to_us(\\"Deadline 12/31/2020.\\") 'Deadline 12/31/2020.' >>> convert_dates_eu_to_us(\\"Hello world!\\") 'Hello world!'","solution":"import re def convert_dates_eu_to_us(text: str) -> str: Converts dates from European format (DD/MM/YYYY) to American format (MM/DD/YYYY) within a given text. Only valid dates are converted. def is_valid_date(dd, mm, yyyy): try: import datetime datetime.datetime.strptime(f\\"{dd}/{mm}/{yyyy}\\", \\"%d/%m/%Y\\") return True except ValueError: return False date_pattern = re.compile(r'b(d{2})/(d{2})/(d{4})b') def replace_date(match): dd, mm, yyyy = match.groups() if is_valid_date(dd, mm, yyyy): return f\\"{mm}/{dd}/{yyyy}\\" else: return match.group(0) return date_pattern.sub(replace_date, text)"},{"question":"from datetime import datetime from typing import List, Tuple, Optional def average_temperature(data: List[Tuple[str, str, float]], region: str, start_time: str, end_time: str) -> Optional[float]: Calculate the average temperature for the given region and time period. Args: data (list of tuples): Each tuple contains timestamp (str), location (str), temperature (float). region (str): The region for which the average temperature is to be calculated. start_time (str): Start of the time period (format \\"YYYY-MM-DD HH:MM:SS\\"). end_time (str): End of the time period (format \\"YYYY-MM-DD HH:MM:SS\\"). Returns: float: The average temperature rounded to two decimal places, or None if no data is available. Examples: >>> data = [ (\\"2023-04-01 01:00:00\\", \\"North\\", 20.0), (\\"2023-04-01 02:00:00\\", \\"North\\", 22.0), (\\"2023-04-01 03:00:00\\", \\"North\\", 24.0), (\\"2023-04-01 01:00:00\\", \\"South\\", 25.0), ] >>> average_temperature(data, \\"North\\", \\"2023-04-01 01:00:00\\", \\"2023-04-01 03:00:00\\") 22.0 >>> average_temperature(data, \\"South\\", \\"2023-04-01 01:00:00\\", \\"2023-04-01 03:00:00\\") 25.0 >>> average_temperature(data, \\"East\\", \\"2023-04-01 01:00:00\\", \\"2023-04-01 03:00:00\\") is None True","solution":"from datetime import datetime def average_temperature(data, region, start_time, end_time): Calculate the average temperature for the given region and time period. Args: data (list of tuples): Each tuple contains timestamp (str), location (str), temperature (float). region (str): The region for which the average temperature is to be calculated. start_time (str): Start of the time period (format \\"YYYY-MM-DD HH:MM:SS\\"). end_time (str): End of the time period (format \\"YYYY-MM-DD HH:MM:SS\\"). Returns: float: The average temperature rounded to two decimal places, or None if no data is available. start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") temperature_sum = 0.0 count = 0 for entry in data: timestamp, location, temperature = entry entry_dt = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if location == region and start_dt <= entry_dt <= end_dt: temperature_sum += temperature count += 1 if count == 0: return None average_temp = round(temperature_sum / count, 2) return average_temp"},{"question":"def can_be_valid_by_deleting_one(s: str) -> str: Given a string consisting of lowercase alphabets and parentheses, determine if it is possible to obtain a valid string by deleting at most one character. A valid string is defined as a string that has balanced parentheses. >>> can_be_valid_by_deleting_one(\\"a(b)c)\\") \\"YES\\" >>> can_be_valid_by_deleting_one(\\"())z(\\") \\"NO\\"","solution":"def can_be_valid_by_deleting_one(s): Returns \\"YES\\" if it is possible to obtain a valid string by deleting at most one character, otherwise returns \\"NO\\". def is_valid(string): count = 0 for char in string: if char == '(': count += 1 elif char == ')': if count == 0: return False count -= 1 return count == 0 # Check if the original string is valid if is_valid(s): return \\"YES\\" # Check if removing one character makes it valid for i in range(len(s)): if is_valid(s[:i] + s[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Returns True if there are two distinct numbers in the list that add up to the target sum. Returns False otherwise. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False","solution":"def has_pair_with_sum(nums, target): Returns True if there are two distinct numbers in the list that add up to the target sum. Returns False otherwise. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def knapsack(capacity: int, weights: List[int]) -> int: Given an array of integers called \\"weights\\" representing the weights of various gold pieces and an integer \\"capacity\\" representing the maximum weight that a knapsack can hold, this function returns the maximum total weight of gold that fits into the knapsack without exceeding the capacity. >>> knapsack(50, [10, 20, 30]) 50 >>> knapsack(20, [10, 9, 8, 7]) 19 pass from solution import knapsack def test_knapsack_example1(): assert knapsack(50, [10, 20, 30]) == 50 def test_knapsack_example2(): assert knapsack(20, [10, 9, 8, 7]) == 19 def test_knapsack_single_weight(): assert knapsack(100, [100]) == 100 def test_knapsack_no_capacity(): assert knapsack(0, [10, 20, 30]) == 0 def test_knapsack_exceeding_weights(): assert knapsack(5, [10, 20, 30]) == 0 def test_knapsack_all_weights_fitting(): assert knapsack(100, [10, 20, 30, 40]) == 100 def test_knapsack_partial_weights_fitting(): assert knapsack(60, [10, 20, 30, 40]) == 60 def test_knapsack_large_capacity(): assert knapsack(1000, [150, 300, 200, 350]) == 1000 def test_knapsack_random_weights(): assert knapsack(50, [1, 4, 8, 5, 6, 7, 10, 3, 9, 10]) == 50","solution":"def knapsack(capacity, weights): Given an array of integers called \\"weights\\" representing the weights of various gold pieces and an integer \\"capacity\\" representing the maximum weight that a knapsack can hold, this function returns the maximum total weight of gold that fits into the knapsack without exceeding the capacity. n = len(weights) dp = [0] * (capacity + 1) for weight in weights: for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + weight) return dp[capacity]"},{"question":"from collections import deque def min_steps_to_spread_rumor(M: int, N: int, grid: List[str], start: Tuple[int, int], target: Tuple[int, int]) -> int: Determine the minimum number of steps required for the rumor to reach the target junction point from the starting junction point. If it is impossible, return -1. Args: M (int): The number of rows in the grid. N (int): The number of columns in the grid. grid (List[str]): The M rows of the grid each containing N characters ('.' for junction point, '#' for impassable area). start (Tuple[int, int]): The starting junction point coordinates. target (Tuple[int, int]): The target junction point coordinates. Returns: int: The minimum number of steps to reach the target or -1 if not possible. Examples: >>> M, N = 5, 5 >>> grid = [ >>> \\".....\\", >>> \\"..#..\\", >>> \\".\\", >>> \\".....\\", >>> \\".....\\" >>> ] >>> start, target = (0, 0), (4, 4) >>> min_steps_to_spread_rumor(M, N, grid, start, target) 8 >>> M, N = 4, 4 >>> grid = [ >>> \\"..\\", >>> \\".#..\\", >>> \\"\\", >>> \\"..#.\\" >>> ] >>> start, target = (0, 0), (3, 2) >>> min_steps_to_spread_rumor(M, N, grid, start, target) -1 pass","solution":"from collections import deque def min_steps_to_spread_rumor(M, N, grid, start, target): def is_valid(x, y): return 0 <= x < M and 0 <= y < N and grid[x][y] == '.' Sx, Sy = start Tx, Ty = target if not is_valid(Sx, Sy) or not is_valid(Tx, Ty): return -1 queue = deque([(Sx, Sy, 0)]) # (x, y, steps) visited = set((Sx, Sy)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, steps = queue.popleft() if (x, y) == (Tx, Ty): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # Example usage: M = 5 N = 5 grid = [ \\".....\\", \\"..#..\\", \\".\\", \\".....\\", \\".....\\" ] start = (0, 0) target = (4, 4) print(min_steps_to_spread_rumor(M, N, grid, start, target)) # Output: 8 M2 = 4 N2 = 4 grid2 = [ \\"..\\", \\".#..\\", \\"\\", \\"..#.\\" ] start2 = (0, 0) target2 = (3, 2) print(min_steps_to_spread_rumor(M2, N2, grid2, start2, target2)) # Output: -1"},{"question":"def max_remaining_number(n, nums): Compute the maximum possible value of the remaining number. Args: n (int): The number of elements in the list. nums (list of int): The list of integers. Returns: int: The remaining number modulo 10^9 + 7. pass def test_max_remaining_number(): assert max_remaining_number(3, [1, 2, 3]) == 6 assert max_remaining_number(5, [10, 20, 30, 40, 50]) == 150 % (10**9 + 7) assert max_remaining_number(1, [100]) == 100 assert max_remaining_number(4, [1, 1, 1, 1]) == 4 assert max_remaining_number(2, [10**9, 10**9]) == (2 * 10**9) % (10**9 + 7)","solution":"def max_remaining_number(n, nums): Compute the maximum possible value of the remaining number. Args: n (int): The number of elements in the list. nums (list of int): The list of integers. Returns: int: The remaining number modulo 10^9 + 7. MOD = 10**9 + 7 return sum(nums) % MOD"},{"question":"def max_items_per_bag(n: int, items: List[int]) -> Tuple[int, int]: Determine the maximum possible number of items in each gift bag and the number of such gift bags. Args: n (int): An integer representing the number of types of items. items (List[int]): A list of integers where each integer represents the number of available items of the i-th type. Returns: Tuple[int, int]: Two integers, max_items and num_bags, where max_items denotes the maximum number of items that each gift bag can have, and num_bags denotes the number of such gift bags. Examples: >>> max_items_per_bag(5, [8, 12, 5, 15, 7]) (6, 8) >>> max_items_per_bag(3, [10, 20, 30]) (20, 3) >>> max_items_per_bag(4, [25, 50, 75, 100]) (62, 4)","solution":"def max_items_per_bag(n, items): Returns the maximum number of items each gift bag can have and the number of such gift bags. total_items = sum(items) max_items = total_items // n num_bags = n return max_items, num_bags"},{"question":"def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases where each test case contains an integer n (the length of the array) and an array of integers, find the length of the longest subsequence such that every element in the subsequence is either divisible by its immediate predecessor or divides its immediate predecessor. Args: test_cases: List of tuples, where each tuple contains an integer and a list of integers. Returns: A list of integers representing the length of the longest subsequence for each test case. Example: >>> solve([(4, [3, 6, 7, 18]), (5, [10, 5, 3, 15, 30])]) [3, 4] from typing import List, Tuple def test_single_element(): assert solve([(1, [1])]) == [1] def test_no_valid_subsequence(): assert solve([(3, [2, 3, 5])]) == [1] def test_all_elements_divisors(): assert solve([(4, [1, 2, 4, 8])]) == [4] # Every element is a multiple of the previous one def test_mixed_elements(): assert solve([(4, [3, 6, 7, 18])]) == [3] # One possible valid subsequence: [3, 6, 18] assert solve([(5, [10, 5, 3, 15, 30])]) == [4] # One possible valid subsequence: [10, 5, 15, 30] def test_multiple_cases(): assert solve([(4, [3, 6, 7, 18]), (5, [10, 5, 3, 15, 30])]) == [3, 4]","solution":"def longest_subsequence(arr): n = len(arr) dp = [1] * n # dp[i] will store the length of the longest valid subsequence ending with arr[i] for i in range(1, n): for j in range(i): if arr[i] % arr[j] == 0 or arr[j] % arr[i] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def solve(test_cases): results = [] for n, arr in test_cases: results.append(longest_subsequence(arr)) return results"},{"question":"import re def is_valid_password(password: str) -> bool: Determines if the given string is a valid password based on predefined rules. - At least 8 characters long. - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one numeral. - Contains at least one special character. Args: password (str): The password string to be validated. Returns: bool: True if the password meets all criteria, False otherwise. >>> is_valid_password(\\"Aa1!aaaa\\") == True >>> is_valid_password(\\"Password1!\\") == True >>> is_valid_password(\\"Aa1!aa\\") == False >>> is_valid_password(\\"aa1!aaaa\\") == False >>> is_valid_password(\\"AA1!AAAA\\") == False >>> is_valid_password(\\"Aa!aaaaa\\") == False >>> is_valid_password(\\"Aa1aaaaa\\") == False >>> is_valid_password(\\"\\") == False >>> is_valid_password(\\"!@#%^&*()\\") == False >>> is_valid_password(\\"ABCDEFGH\\") == False >>> is_valid_password(\\"abcdefgh\\") == False pass","solution":"import re def is_valid_password(password: str) -> bool: Determines if the given string is a valid password based on predefined rules. - At least 8 characters long. - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one numeral. - Contains at least one special character. Args: password (str): The password string to be validated. Returns: bool: True if the password meets all criteria, False otherwise. if len(password) < 8: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[0-9]', password): return False if not re.search(r'[!@#%^&*(),.?\\":{}|<>]', password): return False return True"},{"question":"def is_permutation_of_substring(s1: str, s2: str) -> bool: Returns True if s2 is a permutation of some substring of s1, False otherwise. >>> is_permutation_of_substring(\\"abcdefg\\", \\"cde\\") True >>> is_permutation_of_substring(\\"abcdefg\\", \\"hij\\") False >>> is_permutation_of_substring(\\"hello\\", \\"ole\\") False >>> is_permutation_of_substring(\\"hello\\", \\"leh\\") True pass","solution":"def is_permutation_of_substring(s1, s2): Returns True if s2 is a permutation of some substring of s1, False otherwise. from collections import Counter len_s1, len_s2 = len(s1), len(s2) if len_s2 > len_s1: return False s2_counter = Counter(s2) window_counter = Counter(s1[:len_s2]) if s2_counter == window_counter: return True for i in range(len_s2, len_s1): window_counter[s1[i]] += 1 window_counter[s1[i - len_s2]] -= 1 if window_counter[s1[i - len_s2]] == 0: del window_counter[s1[i - len_s2]] if s2_counter == window_counter: return True return False"},{"question":"def is_palindrome_permutation(s: str) -> bool: Returns True if any permutation of the string is a palindrome, ignoring cases and non-alphabet characters, otherwise returns False. >>> is_palindrome_permutation(\\"Tact Coa\\") True >>> is_palindrome_permutation(\\"Hello\\") False >>> is_palindrome_permutation(\\"A man a plan a canal Panama\\") True >>> is_palindrome_permutation(\\"abcdefg\\") False","solution":"from collections import Counter def is_palindrome_permutation(s): Returns True if any permutation of the string is a palindrome, ignoring cases and non-alphabet characters, otherwise returns False. s = ''.join(filter(str.isalpha, s)).lower() char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 == 1) return odd_count <= 1"},{"question":"def execute_operations(n: int, q: int, initial_elements: List[int], operations: List[str]) -> List[int]: Executes the given operations on the initial list of elements. Args: n (int): Initial number of integers in the list. q (int): Number of operations to be performed. initial_elements (list of int): Initial elements of the list. operations (list of str): List of operations to be executed. Returns: list of int: Results of the \\"query\\" operations. Example: >>> execute_operations(5, 5, [1, 2, 3, 4, 5], [\\"query 1 3\\", \\"append 6\\", \\"query 2 4\\", \\"append 7\\", \\"query 0 6\\"]) [9, 12, 28] >>> execute_operations(3, 2, [10, 20, 30], [\\"append 40\\", \\"query 0 3\\"]) [100] pass def test_execute_operations(): # Sample input test n = 5 q = 5 initial_elements = [1, 2, 3, 4, 5] operations = [ \\"query 1 3\\", \\"append 6\\", \\"query 2 4\\", \\"append 7\\", \\"query 0 6\\" ] expected_output = [9, 12, 28] assert execute_operations(n, q, initial_elements, operations) == expected_output def test_single_append_and_query(): n = 3 q = 2 initial_elements = [10, 20, 30] operations = [ \\"append 40\\", \\"query 0 3\\" ] expected_output = [100] assert execute_operations(n, q, initial_elements, operations) == expected_output def test_multiple_appends(): n = 1 q = 3 initial_elements = [5] operations = [ \\"append 10\\", \\"append 15\\", \\"query 0 2\\" ] expected_output = [30] assert execute_operations(n, q, initial_elements, operations) == expected_output def test_only_queries(): n = 6 q = 3 initial_elements = [1, 1, 1, 1, 1, 1] operations = [ \\"query 0 5\\", \\"query 1 4\\", \\"query 2 3\\" ] expected_output = [6, 4, 2] assert execute_operations(n, q, initial_elements, operations) == expected_output def test_query_entire_range(): n = 4 q = 1 initial_elements = [1, 2, 3, 4] operations = [ \\"query 0 3\\" ] expected_output = [10] assert execute_operations(n, q, initial_elements, operations) == expected_output","solution":"def execute_operations(n, q, initial_elements, operations): Executes the given operations on the initial list of elements. Args: n (int): Initial number of integers in the list. q (int): Number of operations to be performed. initial_elements (list of int): Initial elements of the list. operations (list of str): List of operations to be executed. Returns: list of int: Results of the \\"query\\" operations. lst = initial_elements[:] results = [] for operation in operations: parts = operation.split() if parts[0] == \\"append\\": x = int(parts[1]) lst.append(x) elif parts[0] == \\"query\\": l = int(parts[1]) r = int(parts[2]) results.append(sum(lst[l:r+1])) return results"},{"question":"def calculate_monthly_spending(n: int, ledger_entries: List[str], query_month: str) -> Dict[str, int]: Calculate the total spending for each category in a given month. Args: n: int - the number of entries in the ledger. ledger_entries: List[str] - the ledger entries in the format 'date category amount'. query_month: str - the month for which to calculate spending, in the format 'YYYY-MM'. Returns: Dict[str, int] - a dictionary with categories as keys ('Food', 'Transport', 'Entertainment', 'Utilities') and total amounts spent in each category for the given month as values. Example: >>> n = 5 >>> ledger_entries = [ ... '2023-08-15 Food 20', ... '2023-08-16 Transport 15', ... '2023-08-15 Entertainment 30', ... '2023-08-16 Food 25', ... '2023-09-01 Utilities 50' ... ] >>> query_month = '2023-08' >>> calculate_monthly_spending(n, ledger_entries, query_month) {'Food': 45, 'Transport': 15, 'Entertainment': 30, 'Utilities': 0}","solution":"def calculate_monthly_spending(n, ledger_entries, query_month): categorised_spending = { 'Food': 0, 'Transport': 0, 'Entertainment': 0, 'Utilities': 0 } for entry in ledger_entries: date, category, amount = entry.split() if date.startswith(query_month): categorised_spending[category] += int(amount) return categorised_spending"},{"question":"from typing import List def four_sum(arr: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in the array which gives the sum of the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 50) [] >>> four_sum([1, 0, -1, 0, -2, 2, 2, -2], 0) [[-2, -2, 2, 2], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([0, 0, 0, 0], 0) [[0, 0, 0, 0]] >>> four_sum([1000000000, 1000000000, 1000000000, 1000000000], 4000000000) [[1000000000, 1000000000, 1000000000, 1000000000]]","solution":"from typing import List def four_sum(arr: List[int], target: int) -> List[List[int]]: arr.sort() quadruplets = [] for i in range(len(arr) - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, len(arr) - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, len(arr) - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def longest_pattern_length(sequence): Returns the length of the longest repeating pattern in the sequence. If no such pattern exists, returns 0. def main(input_data): Parses the input data and prints the length of the longest repeating pattern for each test case. # Example usage: # >>> longest_pattern_length([1, 2, 3, 1, 2, 3, 4, 5, 1, 2]) # 3 # >>> longest_pattern_length([1, 2, 3, 4, 5, 6]) # 0 # >>> longest_pattern_length([1, 1, 2, 2, 1, 1, 2, 2]) # 4 # >>> longest_pattern_length([7, 7, 7, 7, 7, 7, 7, 7, 7, 7]) # 9 # >>> longest_pattern_length([1]) # 0 def test_longest_pattern_length(): assert longest_pattern_length([1, 2, 3, 1, 2, 3, 4, 5, 1, 2]) == 3 assert longest_pattern_length([1, 2, 3, 4, 5, 6]) == 0 assert longest_pattern_length([1, 1, 2, 2, 1, 1, 2, 2]) == 4 assert longest_pattern_length([7, 7, 7, 7, 7, 7, 7, 7, 7, 7]) == 9 assert longest_pattern_length([1]) == 0 def test_main(capsys): input_data = '2n10n1 2 3 1 2 3 4 5 1 2n6n1 2 3 4 5 6n' expected_output = '3n0n' main(input_data) captured = capsys.readouterr() assert captured.out == expected_output","solution":"def longest_pattern_length(sequence): Returns the length of the longest repeating pattern in the sequence. If no such pattern exists, returns 0. n = len(sequence) max_len = 0 lps = [0] * n i = 1 length = 0 while i < n: if sequence[i] == sequence[length]: length += 1 lps[i] = length max_len = max(max_len, length) i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return max_len def main(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) results = [] index = 1 for _ in range(T): N = int(input_lines[index]) sequence = list(map(int, input_lines[index + 1].split())) results.append(longest_pattern_length(sequence)) index += 2 for result in results: print(result)"},{"question":"def robotic_arm(sequence): Returns the final position of the arm and the total number of items picked. Args: sequence (str): The sequence of actions ('L', 'R', 'P') for the robotic arm. Returns: tuple: The final position of the arm and the total number of items picked. Example: >>> robotic_arm(\\"RLRPPPLR\\") (1, 3) >>> robotic_arm(\\"LLLPPP\\") (-3, 3) >>> robotic_arm(\\"\\") (0, 0)","solution":"def robotic_arm(sequence): Returns the final position of the arm and the total number of items picked. Args: sequence (str): The sequence of actions ('L', 'R', 'P') for the robotic arm. Returns: tuple: The final position of the arm and the total number of items picked. position = 0 items_picked = 0 for action in sequence: if action == 'L': position -= 1 elif action == 'R': position += 1 elif action == 'P': items_picked += 1 return position, items_picked"},{"question":"def find_triplet_sum(nums: List[int], target: int) -> List[int]: Implement a function \`find_triplet_sum(nums, target)\` that takes a list of integers \`nums\` and an integer \`target\`. The function should return a list of three integers from the input list that sum up to the target value. If there are multiple such triplets, return any one of them. If no such triplet exists, return an empty list. >>> find_triplet_sum([1, 2, 3, 4, 5], 9) in [[1, 3, 5], [2, 3, 4]] True >>> find_triplet_sum([-1, 0, 1, 2], 1) [-1, 0, 2] from test_solution import find_triplet_sum def test_triplet_exists(): assert find_triplet_sum([1, 2, 3, 4, 5], 9) in [[1, 3, 5], [2, 3, 4]] def test_triplet_with_negative_numbers(): assert find_triplet_sum([-1, 0, 1, 2], 1) == [-1, 0, 2] def test_triplet_no_solution(): assert find_triplet_sum([1, 2, 4, 5], 20) == [] def test_triplet_with_duplicates(): assert find_triplet_sum([1, 2, 2, 3], 7) == [2, 2, 3] def test_triplet_large_elements(): assert find_triplet_sum([100, 200, 300, 400], 900) == [200, 300, 400] def test_triplet_with_mixed_sign_numbers(): assert find_triplet_sum([-5, -2, 0, 2, 5], 0) == [-5, 0, 5]","solution":"def find_triplet_sum(nums, target): nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: triplet_sum = nums[i] + nums[left] + nums[right] if triplet_sum == target: return [nums[i], nums[left], nums[right]] elif triplet_sum < target: left += 1 else: right -= 1 return []"},{"question":"class StudentGrades: A class to manage a list of students and their grades. Methods: - add_student(name: str, grade: int) -> None: Adds a student with the given name and grade to the list. - remove_student(name: str) -> bool: Removes the student with the given name from the list. Returns True if the student was successfully removed, and False if the student didn't exist. - get_average_grade() -> float: Returns the average grade of all students. If there are no students, returns 0.0. Example Usage: ------------------- >>> students = StudentGrades() >>> students.add_student(\\"Alice\\", 90) >>> students.add_student(\\"Bob\\", 80) >>> print(students.get_average_grade()) # Output: 85.0 >>> students.remove_student(\\"Alice\\") >>> print(students.get_average_grade()) # Output: 80.0 >>> students.remove_student(\\"Dave\\") # Output: False (Dave not in the list) >>> students.remove_student(\\"Bob\\") >>> print(students.get_average_grade()) # Output: 0.0 def add_student(self, name: str, grade: int) -> None: pass def remove_student(self, name: str) -> bool: pass def get_average_grade(self) -> float: pass","solution":"class StudentGrades: def __init__(self): self.students = {} def add_student(self, name: str, grade: int) -> None: self.students[name] = grade def remove_student(self, name: str) -> bool: if name in self.students: del self.students[name] return True return False def get_average_grade(self) -> float: if not self.students: return 0.0 return sum(self.students.values()) / len(self.students)"},{"question":"def min_nodes_in_magic_infinity_tree(T: int, values: List[int]) -> List[int]: Determine the minimum number of nodes required to form the Magic Infinity Tree with the given root value. Args: T: Integer representing the number of test cases values: List of integers representing the values of the root node for each test case Returns: List of integers representing the minimum number of nodes for each test case >>> min_nodes_in_magic_infinity_tree(3, [0, 1, 10]) [1, 2, 11] >>> min_nodes_in_magic_infinity_tree(1, [100]) [101] >>> min_nodes_in_magic_infinity_tree(2, [999999999, 1234567890]) [1000000000, 1234567891] >>> min_nodes_in_magic_infinity_tree(4, [0, 1, 2, 3]) [1, 2, 3, 4] >>> min_nodes_in_magic_infinity_tree(5, [0, 0, 0, 0, 0]) [1, 1, 1, 1, 1]","solution":"def min_nodes_in_magic_infinity_tree(T, values): def compute_min_nodes(V): if V == 0: return 1 return V + 1 results = [] for value in values: results.append(compute_min_nodes(value)) return results"},{"question":"def min_operations_to_group_chars(s: str) -> int: Returns the minimum number of operations required to arrange the string such that all identical characters are grouped together. >>> min_operations_to_group_chars(\\"abacb\\") 3 >>> min_operations_to_group_chars(\\"aaaa\\") 0","solution":"def min_operations_to_group_chars(s): Returns the minimum number of operations required to arrange the string such that all identical characters are grouped together. from collections import Counter counter = Counter(s) char_counts = list(counter.values()) max_count = max(char_counts) # To group all identical characters, we need to move all other characters at least once return len(s) - max_count"},{"question":"def count_odd_sum_pairs(n, nums): Counts the number of pairs (i, j) such that 1 <= i < j <= n and the sum of the i-th and j-th integer is odd. Parameters: n (int): The number of integers. nums (list): List of integers. Returns: int: The number of pairs with odd sum. Examples: >>> count_odd_sum_pairs(5, [1, 3, 2, 4, 5]) 6 >>> count_odd_sum_pairs(3, [2, 4, 6]) 0","solution":"def count_odd_sum_pairs(n, nums): Counts the number of pairs (i, j) such that 1 <= i < j <= n and the sum of the i-th and j-th integer is odd. Parameters: n (int): The number of integers. nums (list): List of integers. Returns: int: The number of pairs with odd sum. count_odd = 0 count_even = 0 for num in nums: if num % 2 == 0: count_even += 1 else: count_odd += 1 return count_odd * count_even"},{"question":"def sort_scores(n, data): Sorts friends' names based on their scores in descending order. If scores are the same, sorts names alphabetically. Parameters: n (int): Number of friends. data (list of tuple): List of tuples, each containing a friend's name and score. Returns: list of str: Sorted list of friends' names. >>> sort_scores(5, [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 50), (\\"David\\", 100), (\\"Eve\\", 75)]) [\\"David\\", \\"Bob\\", \\"Eve\\", \\"Alice\\", \\"Charlie\\"] >>> sort_scores(5, [(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Charlie\\", 50), (\\"David\\", 50), (\\"Eve\\", 50)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"] >>> sort_scores(1, [(\\"Alice\\", 80)]) [\\"Alice\\"] >>> sort_scores(3, [(\\"Charlie\\", 100), (\\"Alice\\", 90), (\\"Bob\\", 80)]) [\\"Charlie\\", \\"Alice\\", \\"Bob\\"] >>> sort_scores(3, [(\\"Alice\\", 99), (\\"Bob\\", 50), (\\"Charlie\\", 75)]) [\\"Alice\\", \\"Charlie\\", \\"Bob\\"]","solution":"def sort_scores(n, data): Sorts friends' names based on their scores in descending order. If scores are the same, sorts names alphabetically. Parameters: n (int): Number of friends. data (list of tuple): List of tuples, each containing a friend's name and score. Returns: list of str: Sorted list of friends' names. # Sort considering the score in descending order and then the names in ascending order sorted_data = sorted(data, key=lambda x: (-x[1], x[0])) # Extracting only names sorted_names = [entry[0] for entry in sorted_data] return sorted_names"},{"question":"from typing import List, Tuple def shortest_path(N: int, M: int, edges: List[Tuple[int, int, int]]) -> List[int]: Determine the length of the shortest path from node 1 to every other node in the graph with N nodes and M edges. Each edge has a non-negative weight. If a node is unreachable from node 1, return -1 for that node. >>> shortest_path(5, 6, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 4, 3), (4, 5, 1)]) [1, 3, 6, 7] >>> shortest_path(4, 2, [(1, 2, 1), (3, 4, 1)]) [1, -1, -1] >>> shortest_path(3, 3, [(1, 2, 1), (1, 3, 2), (2, 3, 2)]) [1, 2] >>> shortest_path(1, 0, []) [] >>> shortest_path(3, 2, [(1, 2, 1000000), (2, 3, 1000000)]) [1000000, 2000000]","solution":"import heapq import sys def shortest_path(N, M, edges): graph = [[] for _ in range(N+1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) dist = [float('inf')] * (N + 1) dist[1] = 0 pq = [(0, 1)] # (distance, node) visited = set() while pq: d, node = heapq.heappop(pq) if node in visited: continue visited.add(node) for neighbor, weight in graph[node]: if dist[neighbor] > d + weight: dist[neighbor] = d + weight heapq.heappush(pq, (dist[neighbor], neighbor)) result = [] for i in range(2, N + 1): if dist[i] == float('inf'): result.append(-1) else: result.append(dist[i]) return result"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from top-left to bottom-right of the grid, avoiding obstacles represented by 1. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right of the grid, avoiding obstacles represented by 1. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def contains_nearby_duplicate(nums, k): Determines if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Parameters: nums (list): List of integers. k (int): The maximum allowed index difference. Returns: bool: True if such indices exist, False otherwise. >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) False","solution":"def contains_nearby_duplicate(nums, k): Determines if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Parameters: nums (list): List of integers. k (int): The maximum allowed index difference. Returns: bool: True if such indices exist, False otherwise. index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"def max_fields_irrigated(W, F, water_requirements): Determines the maximum number of fields that can be fully irrigated given the reservoir’s water capacity and the water requirements of the fields. Args: W (int): The total amount of water available in the reservoir (1 ≤ W ≤ 1000). F (int): The number of fields (1 ≤ F ≤ 100). water_requirements (List[int]): A list of F integers where each integer represents the amount of water required to fully irrigate the respective field (1 ≤ wi ≤ 100). Returns: int: The maximum number of fields that can be fully irrigated. Examples: >>> max_fields_irrigated(100, 5, [30, 20, 50, 10, 40]) 4 >>> max_fields_irrigated(200, 3, [60, 80, 120]) 2 >>> max_fields_irrigated(150, 4, [70, 40, 20, 90]) 3 >>> max_fields_irrigated(50, 3, [60, 80, 120]) 0 >>> max_fields_irrigated(90, 3, [30, 30, 30]) 3","solution":"def max_fields_irrigated(W, F, water_requirements): Determines the maximum number of fields that can be fully irrigated given the reservoir’s water capacity and the water requirements of the fields. water_requirements.sort() total_water_used = 0 fields_irrigated = 0 for requirement in water_requirements: if total_water_used + requirement <= W: total_water_used += requirement fields_irrigated += 1 else: break return fields_irrigated def process_input(input_data): results = [] for data in input_data: W, F, water_requirements = data if W == 0 and F == 0: break results.append(max_fields_irrigated(W, F, water_requirements)) return results"},{"question":"def min_minutes(M: int) -> int: Returns the minimum number of minutes required to ensure no two adjacent tiles in the mosaic have the same color. Args: M (int): The number of tiles. Returns: int: The minimum number of minutes required. >>> min_minutes(1) 0 >>> min_minutes(2) 0 >>> min_minutes(3) 0 >>> min_minutes(100) 0 >>> min_minutes(100000) 0","solution":"def min_minutes(M): Returns the minimum number of minutes required to ensure no two adjacent tiles in the mosaic have the same color. return 0"},{"question":"def min_operations_to_equalize(t, test_cases): This function calculates the minimum number of operations required to make all elements of each array equal. Parameters: - t: int, number of test cases - test_cases: list of tuples, each containing an integer n (size of the array) and a list of integers (the array itself) Returns: - list of integers, each representing the minimum number of operations for the corresponding test case >>> min_operations_to_equalize(1, [(5, [3, 7, 1, 9, 4])]) [12] >>> min_operations_to_equalize(1, [(3, [10, 15, 20])]) [10]","solution":"def min_operations_to_equalize(t, test_cases): This function calculates the minimum number of operations required to make all elements of each array equal. Parameters: - t: int, number of test cases - test_cases: list of tuples, each containing an integer n (size of the array) and a list of integers (the array itself) Returns: - list of integers, each representing the minimum number of operations for the corresponding test case results = [] for n, arr in test_cases: arr.sort() # choose the median of the sorted array as the target median = arr[n // 2] # calculate the total number of operations to make all elements equal to the median operations = sum(abs(x - median) for x in arr) results.append(operations) return results"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the string s. >>> count_distinct_substrings(\\"abcab\\") 12 >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"aaaa\\") 4 >>> count_distinct_substrings(\\"ab\\") 3 >>> count_distinct_substrings(\\"\\") 0 >>> count_distinct_substrings(\\"abcdef\\") 21","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of the string s. n = len(s) # Using a set to keep track of all unique substrings substrings = set() # Generating all possible substrings for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def has_pair_with_sum(numbers, x): Determine if there are two distinct integers in the list that add up to x. :param numbers: list of integers :param x: target sum :return: \\"YES\\" if there exists a pair of distinct integers that add up to x, otherwise \\"NO\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 8) \\"YES\\" >>> has_pair_with_sum([1, 1, 1], 3) \\"NO\\"","solution":"def has_pair_with_sum(numbers, x): Determine if there are two distinct integers in the list that add up to x. :param numbers: list of integers :param x: target sum :return: \\"YES\\" if there exists a pair of distinct integers that add up to x, otherwise \\"NO\\" seen = set() for num in numbers: if x - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def largest_connected_component(grid): Returns the size of the largest connected component of 1s in the grid. >>> grid = [ ... [1, 1, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 1], ... [1, 0, 1, 1] ... ] >>> largest_connected_component(grid) 4 >>> grid = [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ] >>> largest_connected_component(grid) 1","solution":"def largest_connected_component(grid): Returns the size of the largest connected component of 1s in the grid. M = len(grid) N = len(grid[0]) def dfs(x, y): # If out of bounds or the cell is not 1, return 0 if x < 0 or x >= M or y < 0 or y >= N or grid[x][y] != 1: return 0 # Mark the cell as visited grid[x][y] = -1 # Count the cell itself size = 1 # Explore the four possible directions size += dfs(x - 1, y) size += dfs(x + 1, y) size += dfs(x, y - 1) size += dfs(x, y + 1) return size max_size = 0 for i in range(M): for j in range(N): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size # Example run M = 4 N = 4 grid = [ [1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1], [1, 0, 1, 1] ] print(largest_connected_component(grid)) # Output: 4"},{"question":"def reverse_group(arr: List[int], k: int) -> List[int]: Reverses the elements of arr in groups of size k. >>> reverse_group([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [3, 2, 1, 6, 5, 4, 9, 8, 7] >>> reverse_group([1, 2, 3, 4, 5], 2) [2, 1, 4, 3, 5]","solution":"def reverse_group(arr, k): Reverses the elements of arr in groups of size k. n = len(arr) for i in range(0, n, k): arr[i:i+k] = arr[i:i+k][::-1] return arr"},{"question":"def generate_checkerboard(n: int, m: int) -> List[List[int]]: Generates a n x m grid such that no two adjacent cells contain the same value. >>> generate_checkerboard(1, 1) [[0]] >>> generate_checkerboard(2, 2) [[0, 1], [1, 0]] >>> generate_checkerboard(3, 3) [[0, 1, 0], [1, 0, 1], [0, 1, 0]] >>> generate_checkerboard(4, 5) [[0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1]]","solution":"def generate_checkerboard(n, m): Generates a n x m grid such that no two adjacent cells contain the same value. grid = [] for i in range(n): row = [] for j in range(m): # We achieve alternating pattern by using (i + j) % 2 row.append((i + j) % 2) grid.append(row) return grid"},{"question":"from typing import List, Tuple def process_queries(n: int, array: List[int], queries: List[Tuple[str, int, int]]) -> List[int]: Process a list of queries on the given array, where queries can either be sum or update operations. Args: - n (int): The size of the array. - array (List[int]): The array of integers. - queries (List[Tuple[str, int, int]]): A list of queries, with each query being a tuple. - ('S', L, R) : Find the sum of elements from index L to R (1-based indexing). - ('U', i, x) : Update the element at index i to new value x. Returns: - List[int]: A list of results for the sum queries in the order they appear in the input. Examples: >>> process_queries(5, [1, 2, 3, 4, 5], [('S', 2, 4), ('U', 3, 10), ('S', 1, 5)]) [9, 22] >>> process_queries(5, [1, 2, 3, 4, 5], [('U', 1, 10), ('U', 5, 20), ('S', 1, 5)]) [39] class ArrayOperations: def __init__(self, array): self.array = array self.n = len(array) self.prefix_sum = [0] * (self.n + 1) self._construct_prefix_sum() def _construct_prefix_sum(self): for i in range(1, self.n + 1): self.prefix_sum[i] = self.prefix_sum[i - 1] + self.array[i - 1] def sum_range(self, L, R): return self.prefix_sum[R] - self.prefix_sum[L - 1] def update(self, i, x): diff = x - self.array[i - 1] self.array[i - 1] = x for j in range(i, self.n + 1): self.prefix_sum[j] += diff op = ArrayOperations(array) results = [] for query in queries: if query[0] == 'S': _, L, R = query results.append(op.sum_range(L, R)) elif query[0] == 'U': _, i, x = query op.update(i, x) return results def test_process_queries(): assert process_queries(5, [1, 2, 3, 4, 5], [('S', 2, 4)]) == [9] assert process_queries(5, [1, 2, 3, 4, 5], [('U', 3, 10)]) == [] assert process_queries(5, [1, 2, 3, 4, 5], [('S', 2, 4), ('U', 3, 10), ('S', 1, 5)]) == [9, 22] assert process_queries(5, [1, 2, 3, 4, 5], [('U', 1, 10), ('U', 5, 20), ('S', 1, 5)]) == [39] array = [i for i in range(1, 100001)] queries = [('S', 1, 100000), ('U', 50000, 0), ('S', 1, 100000)] result = process_queries(100000, array, queries) assert result[0] == sum(range(1, 100001)) assert result[1] == sum(range(1, 50000)) + 0 + sum(range(50001, 100001))","solution":"class ArrayOperations: def __init__(self, array): self.array = array self.n = len(array) self.prefix_sum = [0] * (self.n + 1) self._construct_prefix_sum() def _construct_prefix_sum(self): for i in range(1, self.n + 1): self.prefix_sum[i] = self.prefix_sum[i - 1] + self.array[i - 1] def sum_range(self, L, R): return self.prefix_sum[R] - self.prefix_sum[L - 1] def update(self, i, x): diff = x - self.array[i - 1] self.array[i - 1] = x for j in range(i, self.n + 1): self.prefix_sum[j] += diff def process_queries(n, array, queries): op = ArrayOperations(array) results = [] for query in queries: if query[0] == 'S': _, L, R = query results.append(op.sum_range(L, R)) elif query[0] == 'U': _, i, x = query op.update(i, x) return results"},{"question":"def max_happiness(n: int, happiness_values: List[int]) -> int: Returns the maximum possible total happiness of any continuous segment of flowers' happiness values. Parameters: n (int): Number of flowers. happiness_values (list of int): Happiness values of the flowers. Returns: int: The maximum possible total happiness of any segment. pass # Example test cases def test_example_1(): assert max_happiness(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_example_2(): assert max_happiness(5, [-1, -2, -3, -4, -5]) == -1 def test_example_3(): assert max_happiness(6, [3, -2, 5, -1, 4, -3]) == 9 def test_single_element(): assert max_happiness(1, [7]) == 7 assert max_happiness(1, [-7]) == -7 def test_all_positive_elements(): assert max_happiness(3, [1, 2, 3]) == 6 def test_all_negative_elements(): assert max_happiness(3, [-1, -2, -3]) == -1 def test_mixed_elements_resulting_in_non_continuous_max_sum(): assert max_happiness(5, [4, -1, 2, 1, -5]) == 6 def test_edge_case_large_values(): assert max_happiness(2, [1000, -1000]) == 1000 assert max_happiness(2, [-1000, 1000]) == 1000","solution":"def max_happiness(n, happiness_values): Returns the maximum possible total happiness of any continuous segment of flowers' happiness values. Parameters: n (int): Number of flowers. happiness_values (list of int): Happiness values of the flowers. Returns: int: The maximum possible total happiness of any segment. max_sum = current_sum = happiness_values[0] for i in range(1, n): current_sum = max(happiness_values[i], current_sum + happiness_values[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def is_beautiful_string(s: str) -> str: Determines if it is possible to rearrange the given string to form a beautiful string. A beautiful string is defined as a string where every character appears exactly twice. :param s: A string of lowercase English letters :return: 'YES' if it is possible to rearrange to form a beautiful string, otherwise 'NO' >>> is_beautiful_string(\\"aabb\\") 'YES' >>> is_beautiful_string(\\"abc\\") 'NO'","solution":"def is_beautiful_string(s): Determines if it is possible to rearrange the given string to form a beautiful string. A beautiful string is defined as a string where every character appears exactly twice. :param s: A string of lowercase English letters :return: 'YES' if it is possible to rearrange to form a beautiful string, otherwise 'NO' from collections import Counter # Count frequency of each character char_count = Counter(s) # Check if each character appears exactly twice for count in char_count.values(): if count != 2: return \\"NO\\" return \\"YES\\""},{"question":"def is_palindrome(number: int) -> bool: Determines if a given integer is a palindrome without converting the integer to a string. :param number: int, a non-negative integer :return: bool, True if number is a palindrome, False otherwise >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(12321) == True >>> is_palindrome(1234321) == True >>> is_palindrome(1234567) == False >>> is_palindrome(1001) == True >>> is_palindrome(10) == False pass","solution":"def is_palindrome(number): Determines if a given integer is a palindrome without converting the integer to a string. :param number: int, a non-negative integer :return: bool, True if number is a palindrome, False otherwise if number < 0: return False original_number = number reversed_number = 0 while number > 0: digit = number % 10 reversed_number = reversed_number * 10 + digit number //= 10 return original_number == reversed_number"},{"question":"def maxProfit(arr: List[int]) -> int: You are given a list of integers \`arr\` representing a sequence of stock prices, and you need to maximize the profit by completing at most one transaction (i.e., buy one and sell one share of the stock). Write a function that returns the maximum profit you can achieve from this transaction. If no profit is possible, return 0. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(arr): Returns the maximum profit that can be made by buying and selling a single share of stock. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def is_palindrome(N: int) -> str: Determines whether the given number N is a palindrome. Returns \\"Palindrome\\" if it is, otherwise returns \\"Not Palindrome\\". >>> is_palindrome(121) == \\"Palindrome\\" >>> is_palindrome(12321) == \\"Palindrome\\" >>> is_palindrome(1234) == \\"Not Palindrome\\"","solution":"def is_palindrome(N): Determines whether the given number N is a palindrome. Returns \\"Palindrome\\" if it is, otherwise returns \\"Not Palindrome\\". str_N = str(N) if str_N == str_N[::-1]: return \\"Palindrome\\" else: return \\"Not Palindrome\\""},{"question":"def max_consecutive_ones(N, K, binary_string): This function returns the maximum number of consecutive '1's that can be achieved by flipping at most K bits in the input binary_string of length N. Args: N (int): The length of the binary string. K (int): The maximum number of flips allowed. binary_string (str): A binary string consisting of '0's and '1's. Returns: int: The maximum number of consecutive '1's that can be achieved. >>> max_consecutive_ones(10, 2, \\"1101001100\\") 5 >>> max_consecutive_ones(5, 1, \\"00000\\") 1 >>> max_consecutive_ones(8, 3, \\"11001011\\") 8 >>> max_consecutive_ones(5, 0, \\"00000\\") 0 >>> max_consecutive_ones(5, 0, \\"11111\\") 5 >>> max_consecutive_ones(7, 1, \\"1010101\\") 3 # Test cases def test_sample_input_1(): assert max_consecutive_ones(10, 2, \\"1101001100\\") == 5 def test_sample_input_2(): assert max_consecutive_ones(5, 1, \\"00000\\") == 1 def test_sample_input_3(): assert max_consecutive_ones(8, 3, \\"11001011\\") == 8 def test_all_zeros_no_flips(): assert max_consecutive_ones(5, 0, \\"00000\\") == 0 def test_all_ones_no_flips(): assert max_consecutive_ones(5, 0, \\"11111\\") == 5 def test_all_zeros_one_flip(): assert max_consecutive_ones(5, 1, \\"00000\\") == 1 def test_all_ones(): assert max_consecutive_ones(5, 2, \\"11111\\") == 5 def test_mixed_string(): assert max_consecutive_ones(7, 1, \\"1010101\\") == 3 def test_no_flips(): assert max_consecutive_ones(10, 0, \\"1100110011\\") == 2 def test_large_input(): binary_string = \\"0\\" * 2500 + \\"1\\" * 2500 assert max_consecutive_ones(5000, 2500, binary_string) == 5000","solution":"def max_consecutive_ones(N, K, binary_string): This function returns the maximum number of consecutive '1's that can be achieved by flipping at most K bits in the input binary_string of length N. left = 0 max_length = 0 zero_count = 0 for right in range(N): if binary_string[right] == '0': zero_count += 1 while zero_count > K: if binary_string[left] == '0': zero_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def parking_management(n: int, slots: List[int], q: int, queries: List[str]) -> List[str]: Manage parking slots for a busy city based on given queries and return the status of parking slots. :param n: The number of parking slots. :param slots: A list with the capacities of each parking slot. :param q: The number of queries. :param queries: A list of queries, where each query is a string of the form \\"+ x y\\", \\"- x y\\", or \\"?\\". :return: A list of strings representing the current number of parked vehicles for each slot after each \\"?\\" query. >>> n = 3 >>> slots = [10, 15, 5] >>> q = 7 >>> queries = [\\"+ 1 5\\", \\"+ 2 10\\", \\"+ 3 3\\", \\"?\\", \\"- 2 4\\", \\"?\\", \\"+ 3 1\\", \\"?\\", \\"+ 1 6\\", \\"?\\", \\"- 3 2\\", \\"?\\"] >>> parking_management(n, slots, q, queries) ['5 10 3', '5 6 3', '5 6 4', '11 6 4', '11 6 2'] >>> n = 2 >>> slots = [1000, 1000] >>> q = 4 >>> queries = [\\"+ 1 500\\", \\"+ 2 1000\\", \\"?\\", \\"- 1 300\\", \\"?\\"] >>> parking_management(n, slots, q, queries) ['500 1000', '200 1000']","solution":"def parking_management(n, slots, q, queries): parked_vehicles = [0] * n status_output = [] for query in queries: parts = query.split() command = parts[0] if command == \\"+\\": x = int(parts[1]) - 1 y = int(parts[2]) parked_vehicles[x] += y elif command == \\"-\\": x = int(parts[1]) - 1 y = int(parts[2]) parked_vehicles[x] -= y elif command == \\"?\\": status_output.append(\\" \\".join(str(parked_vehicles[i]) for i in range(n))) return status_output # Let's include a function to handle the input and output for completeness def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) slots = [int(data[i + 1]) for i in range(n)] q = int(data[n + 1]) queries = data[n + 2 : n + 2 + q] result = parking_management(n, slots, q, queries) for line in result: print(line) # For example usage, we would replace sys.stdin with actual input data, for testing: # Example usage: # main()"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the input string can form a palindrome. Ignore spaces, punctuation, and consider only alphabetical characters. The function should be case insensitive. Parameters: s (str): The input string Returns: bool: True if a permutation can form a palindrome, False otherwise Examples: >>> can_form_palindrome(\\"Tact Coa\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"abc\\") False","solution":"def can_form_palindrome(s): Determines if any permutation of the input string can form a palindrome. Parameters: s (str): The input string Returns: bool: True if a permutation can form a palindrome, False otherwise # Filter out non-alphabetic characters and convert to lowercase filtered_s = ''.join(c.lower() for c in s if c.isalpha()) # Dictionary to count the frequency of each character freq = {} for char in filtered_s: freq[char] = freq.get(char, 0) + 1 # Count the number of characters with an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"def sort_activities(n, activities): Sort activities primarily by their priority in descending order. Activities with same priority are sorted alphabetically. :param n: int - number of activities :param activities: list - list of activities with their priorities :return: list - sorted list of activities >>> sort_activities(3, [\\"Write report,2\\", \\"Morning Exercise,5\\", \\"Team Meeting,5\\"]) [\\"Morning Exercise,5\\", \\"Team Meeting,5\\", \\"Write report,2\\"] >>> sort_activities(3, [\\"Write report,2\\", \\"Read book,2\\", \\"Go for a walk,2\\"]) [\\"Go for a walk,2\\", \\"Read book,2\\", \\"Write report,2\\"] >>> sort_activities(3, [\\"A,1\\", \\"B,2\\", \\"C,3\\"]) [\\"C,3\\", \\"B,2\\", \\"A,1\\"] >>> sort_activities(1, [\\"Only Activity,10\\"]) [\\"Only Activity,10\\"] >>> sort_activities(4, [\\"Z Activity,5\\", \\"A Activity,5\\", \\"N Activity,5\\", \\"M Activity,4\\"]) [\\"A Activity,5\\", \\"N Activity,5\\", \\"Z Activity,5\\", \\"M Activity,4\\"]","solution":"def sort_activities(n, activities): Sort activities primarily by their priority in descending order. Activities with same priority are sorted alphabetically. :param n: int - number of activities :param activities: list - list of activities with their priorities :return: list - sorted list of activities # Split the activities and priorities split_activities = [activity.split(',') for activity in activities] # Sort primarily by -int(priority) to get descending order and secondly by activity name sorted_activities = sorted(split_activities, key=lambda x: (-int(x[1]), x[0])) return [','.join(activity) for activity in sorted_activities]"},{"question":"def largest_square_area(n, m, grid): Find the area of the largest square subgrid filled with 1's. >>> largest_square_area(4, 5, [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 4 >>> largest_square_area(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9 pass","solution":"def largest_square_area(n, m, grid): if n == 0 or m == 0: return 0 dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def sum_of_unique_elements(test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of integers. Your task is to find the sum of all the unique elements in the array. >>> sum_of_unique_elements([(5, [1, 2, 2, 3, 4])]) [10] >>> sum_of_unique_elements([(4, [1, 1, 1, 1])]) [1] >>> sum_of_unique_elements([(6, [1, 2, 3, 4, 5, 6])]) [21]","solution":"def sum_of_unique_elements(test_cases): results = [] for case in test_cases: N, array = case unique_elements_sum = sum(el for el in set(array)) results.append(unique_elements_sum) return results"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def find_influence_score(n: int, follows: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Calculate the influence score of each user in a social network. Args: n (int): Number of follow relationships. follows (List[Tuple[int, int]]): List of follow relationships where user u follows user v. Returns: List[Tuple[int, int]]: List of tuples where each tuple contains the user ID and their influence score. Example: >>> find_influence_score(5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]) [(1, 0), (2, 1), (3, 2), (4, 3), (5, 4)]","solution":"from collections import defaultdict, deque def find_influence_score(n, follows): graph = defaultdict(list) reverse_graph = defaultdict(list) users = set() for u, v in follows: graph[u].append(v) reverse_graph[v].append(u) users.add(u) users.add(v) max_user_id = max(users) influence_scores = {user: 0 for user in users} def bfs(start_user): visited = set() queue = deque([start_user]) visited.add(start_user) while queue: current = queue.popleft() for follower in reverse_graph[current]: if follower not in visited: visited.add(follower) queue.append(follower) influence_scores[start_user] += 1 for user in range(1, max_user_id + 1): if user in reverse_graph: bfs(user) return [(user, influence_scores[user]) for user in range(1, max_user_id + 1)] # Example usage: # n = 5 # follows = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)] # result = find_influence_score(n, follows) # for r in result: # print(f'{r[0]} {r[1]}')"},{"question":"def max_rectangle_area(heights: List[int]) -> int: This function takes a list of integers representing building heights and returns the maximum area of a rectangle formed by any contiguous subset of buildings. >>> max_rectangle_area([5]) 5 >>> max_rectangle_area([1, 2]) 2 >>> max_rectangle_area([2, 1]) 2 >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([4, 4, 4, 4]) 16 >>> max_rectangle_area([6, 5, 4, 3, 2, 1]) 12 >>> max_rectangle_area([1, 2, 3, 4, 5, 6]) 12 >>> max_rectangle_area([3, 6, 5, 7, 4, 8, 1, 0]) 20 >>> max_rectangle_area([1, 2, 3, 4, 5, 4, 3, 2, 1]) 15","solution":"def max_rectangle_area(heights): This function takes a list of integers representing building heights and returns the maximum area of a rectangle formed by any contiguous subset of buildings. # Initialize maximum area max_area = 0 # Create a stack to store indices of the buildings stack = [] # Traverse buildings in the height array for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) # Clean up any remaining indices in the stack while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"def has_pair_with_sum(arr, k): Determines if there exists a pair (i, j) such that arr[i] + arr[j] equals k (i ≠ j). :param arr: List of integers :param k: Integer representing the target sum :return: 'Yes' if such a pair exists, otherwise 'No' >>> has_pair_with_sum([1, 4, 3, 5], 8) 'Yes' >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) 'No'","solution":"def has_pair_with_sum(arr, k): Determines if there exists a pair (i, j) such that arr[i] + arr[j] equals k (i ≠ j). :param arr: List of integers :param k: Integer representing the target sum :return: 'Yes' if such a pair exists, otherwise 'No' seen = set() for num in arr: if k - num in seen: return 'Yes' seen.add(num) return 'No'"},{"question":"def two_sum_exists(arr: List[int], k: int) -> str: Checks if there exist two indices i and j in the array such that arr[i] + arr[j] = k and i != j. Parameters: arr (list of int): List of integers. k (int): Target sum. Returns: str: \\"YES\\" if such indices exist, \\"NO\\" otherwise. # Your code here def find_two_sum_in_test_cases(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes each test case and returns the result. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains (n, k, arr) where \`n\` is the number of integers, \`k\` is the target sum, and \`arr\` is the list of integers. Returns: list of str: The result for each test case with format \\"Case i: {YES/NO}\\". # Your code here from solution import two_sum_exists, find_two_sum_in_test_cases def test_two_sum_exists(): assert two_sum_exists([2, 7, 11, 15], 9) == \\"YES\\" assert two_sum_exists([1, 5, 3], 10) == \\"NO\\" assert two_sum_exists([1, 2, 3, 4, 5], 7) == \\"YES\\" assert two_sum_exists([1], 2) == \\"NO\\" assert two_sum_exists([], 0) == \\"NO\\" assert two_sum_exists([-1, -2, -3, -4], -6) == \\"YES\\" def test_find_two_sum_in_test_cases(): T = 3 test_cases = [ (4, 9, [2, 7, 11, 15]), (3, 10, [1, 5, 3]), (5, 7, [1, 2, 3, 4, 5]) ] expected_output = [ \\"Case 1: YES\\", \\"Case 2: NO\\", \\"Case 3: YES\\" ] assert find_two_sum_in_test_cases(T, test_cases) == expected_output T = 2 test_cases = [ (1, 2, [1]), (0, 0, []) ] expected_output = [ \\"Case 1: NO\\", \\"Case 2: NO\\" ] assert find_two_sum_in_test_cases(T, test_cases) == expected_output def test_case_with_negative_numbers(): T = 1 test_cases = [ (4, -1, [-2, -1, 0, 1]) ] expected_output = [ \\"Case 1: YES\\" ] assert find_two_sum_in_test_cases(T, test_cases) == expected_output","solution":"def two_sum_exists(arr, k): Checks if there exist two indices i and j in the array such that arr[i] + arr[j] = k and i != j. Parameters: arr (list of int): List of integers. k (int): Target sum. Returns: str: \\"YES\\" if such indices exist, \\"NO\\" otherwise. seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" def find_two_sum_in_test_cases(T, test_cases): Processes each test case and returns the result. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains (n, k, arr) where \`n\` is the number of integers, \`k\` is the target sum, and \`arr\` is the list of integers. Returns: list of str: The result for each test case with format \\"Case i: {YES/NO}\\". results = [] for i in range(T): n, k, arr = test_cases[i] result = two_sum_exists(arr, k) results.append(f\\"Case {i + 1}: {result}\\") return results"},{"question":"def max_area_of_island(grid): Given a 2D grid, each cell in the grid contains either a 0 or a 1. If a cell contains a 1, it can move to any of its adjacent cells (up, down, left, right) that also contain a 1. A group of connected 1s forms an island. Compute the maximum area of an island in the provided grid. An island is defined as a group of contiguous cells containing 1, connected either vertically or horizontally. The area of the island is the total count of 1 cells in that island. Examples: >>> max_area_of_island([[0,0,1,0], [1,1,1,0], [0,1,0,0], [1,0,0,0]]) 5 >>> max_area_of_island([[0,0,0,1], [1,1,0,1], [1,0,0,0], [0,0,0,1]]) 3 >>> max_area_of_island([[0,0,0,0], [0,1,1,0], [0,0,0,0], [1,1,1,1]]) 4 >>> max_area_of_island([[1,1,1], [0,1,0], [1,1,1]]) 7 >>> max_area_of_island([[0]]) 0","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the provided grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return 0 visited[r][c] = True return 1 + dfs(r+1, c) + dfs(r-1, c) + dfs(r, c+1) + dfs(r, c-1) max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"from typing import List, Tuple def find_show_index(queries: List[str], schedule: List[Tuple[str, str]]) -> List: Determines the index of the show airing at each query time for a single channel. :param queries: List of query times in \\"HH:MM\\" format. :param schedule: List of tuples with start and end times of shows in \\"HH:MM HH:MM\\" format. :return: List of integers corresponding to the index (1-based) of the show airing at each query time or \\"None\\". # Write your solution here # Unit Tests def test_find_show_index_basic(): assert find_show_index([\\"08:00\\"], [(\\"08:00\\", \\"10:00\\")]) == [1] assert find_show_index([\\"07:59\\"], [(\\"08:00\\", \\"10:00\\")]) == [\\"None\\"] assert find_show_index([\\"10:00\\"], [(\\"08:00\\", \\"10:00\\")]) == [1] def test_find_show_index_multiple_shows(): schedule = [(\\"08:00\\", \\"10:00\\"), (\\"10:30\\", \\"12:00\\"), (\\"13:00\\", \\"14:30\\")] queries = [\\"09:00\\", \\"13:30\\", \\"14:31\\"] assert find_show_index(queries, schedule) == [1, 3, \\"None\\"] def test_find_show_index_overlap(): schedule = [(\\"08:00\\", \\"10:00\\"), (\\"09:30\\", \\"12:00\\")] queries = [\\"09:00\\", \\"10:00\\", \\"11:00\\"] assert find_show_index(queries, schedule) == [1, 1, 2] def test_find_show_index_edge_cases(): schedule = [(\\"00:00\\", \\"23:59\\")] queries = [\\"00:00\\", \\"23:59\\", \\"12:00\\"] assert find_show_index(queries, schedule) == [1, 1, 1] schedule = [(\\"12:00\\", \\"13:00\\")] queries = [\\"11:59\\", \\"13:01\\", \\"13:00\\"] assert find_show_index(queries, schedule) == [\\"None\\", \\"None\\", 1] def test_find_show_index_none(): assert find_show_index([\\"12:00\\"], [(\\"08:00\\", \\"10:00\\")]) == [\\"None\\"]","solution":"from datetime import datetime def find_show_index(queries, schedule): Determines the index of the show airing at each query time for a single channel. :param queries: List of query times in \\"HH:MM\\" format. :param schedule: List of tuples with start and end times of shows in \\"HH:MM HH:MM\\" format. :return: List of integers corresponding to the index (1-based) of the show airing at each query time or \\"None\\". def time_in_show_range(query_time, show_start, show_end): Helper function to determine if a query time is within a show's start and end time. query = datetime.strptime(query_time, \\"%H:%M\\") start = datetime.strptime(show_start, \\"%H:%M\\") end = datetime.strptime(show_end, \\"%H:%M\\") return start <= query <= end results = [] for q in queries: found = False for index, (start, end) in enumerate(schedule): if time_in_show_range(q, start, end): results.append(index + 1) # 1-based index found = True break if not found: results.append(\\"None\\") return results"},{"question":"def sum_of_interior_angles(n: int) -> int: Calculate the total sum of the interior angles of a simple polygon with n sides. >>> sum_of_interior_angles(3) 180 >>> sum_of_interior_angles(4) 360 >>> sum_of_interior_angles(5) 540 def sum_of_interior_angles_for_polygons(sides: List[int]) -> List[int]: Process multiple datasets of polygon sides and return the corresponding interior angles sums. >>> sum_of_interior_angles_for_polygons([3, 4, 5, 0]) [180, 360, 540] >>> sum_of_interior_angles_for_polygons([6, 7, 8, 0]) [720, 900, 1080] >>> sum_of_interior_angles_for_polygons([3, 0]) [180] >>> sum_of_interior_angles_for_polygons([10, 12, 0]) [1440, 1800]","solution":"def sum_of_interior_angles(n): Calculate the total sum of the interior angles of a simple polygon with n sides. Args: n (int): Number of sides of the polygon Returns: int: Total sum of the interior angles in degrees return (n - 2) * 180 def sum_of_interior_angles_for_polygons(sides): Process multiple datasets of polygon sides and return the corresponding interior angles sums. Args: sides (list of int): List of integers representing the number of sides of each polygon Returns: list of int: List of integers representing the sum of the interior angles for each polygon results = [] for n in sides: if n == 0: break results.append(sum_of_interior_angles(n)) return results"},{"question":"def find_unique_element(n: int, arr: list) -> int: Finds the unique element in an array where every other element appears exactly twice except for one element which appears only once. Parameters: n (int): The number of elements in the array. arr (list): A list of integers. Returns: int: The unique element. >>> find_unique_element(5, [2, 3, 1, 2, 3]) 1 >>> find_unique_element(7, [4, 1, 2, 1, 2, 3, 4]) 3 >>> find_unique_element(1, [7]) 7 >>> find_unique_element(11, [10, 10, 3, 7, 7, 5, 5, 3, 8, 8, 6]) 6 >>> find_unique_element(3, [-1, -1, 0]) 0","solution":"def find_unique_element(n, arr): Finds the unique element in an array where every other element appears exactly twice except for one element which appears only once. Parameters: n (int): The number of elements in the array. arr (list): A list of integers. Returns: int: The unique element. unique_element = 0 for num in arr: unique_element ^= num return unique_element # Example Usage: # if __name__ == \\"__main__\\": # n = int(input().strip()) # arr = list(map(int, input().strip().split())) # print(find_unique_element(n, arr))"},{"question":"def find_secret_word(N: int, grid: List[str]) -> str: Finds the lexicographically smallest permutation that appears in each row of the grid. Parameters: N (int): Size of the grid and length of the secret word. grid (list): List of N strings, each having N permutations of the secret word. Returns: str: The lexicographically smallest permutation that appears in each row of the grid. >>> find_secret_word(4, [\\"bcad\\", \\"adcb\\", \\"dbac\\", \\"cabd\\"]) 'abcd' >>> find_secret_word(3, [\\"bca\\", \\"acb\\", \\"cab\\"]) 'abc' >>> find_secret_word(5, [\\"pqrst\\", \\"qrstu\\", \\"sturp\\", \\"trups\\", \\"rputq\\"]) 'pqrst' >>> find_secret_word(1, [\\"a\\"]) 'a' >>> find_secret_word(4, [\\"zxyw\\", \\"xywz\\", \\"ywzx\\", \\"wxyz\\"]) 'wxyz' >>> find_secret_word(4, [\\"cccc\\", \\"cccc\\", \\"cccc\\", \\"cccc\\"]) 'cccc' >>> find_secret_word(4, [\\"bcda\\", \\"acdb\\", \\"dbac\\", \\"cadb\\"]) 'abcd'","solution":"def find_secret_word(N, grid): Finds the lexicographically smallest permutation that appears in each row of the grid. Parameters: N (int): Size of the grid and length of the secret word. grid (list): List of N strings, each having N permutations of the secret word. Returns: str: The lexicographically smallest permutation that appears in each row of the grid. # Since each row is a permutation of the secret word # we can use one row's sorted version as the smallest # possible permutation correctly sorted_permutation = \\"\\".join(sorted(grid[0])) return sorted_permutation"},{"question":"def truncate_division(x: int, y: int) -> int: Compute x divided by y and truncate the fractional part. :param x: Dividend, an integer (1 <= X <= 10^18) :param y: Divisor, an integer (1 <= Y < 10^6) :return: Truncated integer result of x divided by y >>> truncate_division(1000000000000000000, 3) 333333333333333333 >>> truncate_division(100, 10) 10 >>> truncate_division(10, 3) 3 >>> truncate_division(10**18, 999999) 1000001000001 >>> truncate_division(1, 1) 1","solution":"def truncate_division(x, y): Compute x divided by y and truncate the fractional part. :param x: Dividend, an integer (1 <= X <= 10^18) :param y: Divisor, an integer (1 <= Y < 10^6) :return: Truncated integer result of x divided by y return x // y"},{"question":"def is_valid_path(n, roads, order): Verify if the given order of visiting cities is a valid path. Args: n (int): The number of cities and roads. roads (List[Tuple[int, int]]): List of road connections. order (List[int]): The order of visiting the cities. Returns: str: \\"YES\\" if the order of visiting cities is a valid path, otherwise \\"NO\\". >>> is_valid_path(4, [(1, 2), (2, 3), (3, 4)], [1, 2, 3, 4]) 'YES' >>> is_valid_path(4, [(1, 2), (2, 3), (3, 4)], [1, 3, 2, 4]) 'NO'","solution":"def is_valid_path(n, roads, order): from collections import defaultdict # Construct the adjacency list of the graph graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) # Check if each consecutive city in the order has a direct connection for i in range(1, n): if order[i] not in graph[order[i - 1]]: return \\"NO\\" return \\"YES\\""},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in string s. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"abcde\\") 1 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"abcdefedcba\\") 11 def process_datasets(input_lines: List[str]) -> List[int]: Processes multiple datasets to find longest palindromic subsequences. The input is a list of strings, with each string being a dataset. The list ends with an '*' string to signify the end of input. >>> process_datasets([\\"bbbab\\", \\"abcde\\", \\"racecar\\", \\"a\\", \\"abcdefedcba\\", \\"*\\"]) [4, 1, 7, 1, 11]","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] def process_datasets(input_lines): Processes multiple datasets to find longest palindromic subsequences. The input is a list of strings, with each string being a dataset. The list ends with an '*' string to signify the end of input. results = [] for line in input_lines: if line == '*': break results.append(longest_palindromic_subsequence(line)) return results"},{"question":"def findPairs(arr, k): This function returns the number of unique pairs (a, b) in the array that add up to the target integer k. >>> findPairs([1, 2, 3, 4, 3], 6) 2 >>> findPairs([1, 1, 1, 1], 2) 1 >>> findPairs([1, 5, 7, -1], 6) 2 >>> findPairs([1, 2, 3], 10) 0 >>> findPairs([-1, -2, -3, -4, -5], -8) 1 >>> findPairs([2, -3, 1, -1, 3, 4, -2], 1) 3 >>> findPairs([1000000, 999999, -1000000, -999999], 0) 2","solution":"def findPairs(arr, k): This function returns the number of unique pairs (a, b) in the array that add up to the target integer k. seen = set() pairs = set() # to store unique pairs for num in arr: complement = k - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"import re from typing import Dict def count_named_entities(input_string: str) -> Dict[str, int]: Counts named entities in the input string. Named entities are denoted by <person></person>, <place></place>, and <date></date> tags. Args: input_string (str): The input string containing named entities. Returns: dict: A dictionary containing the count of each type of named entity. Examples: >>> count_named_entities(\\"Hello <person>John Doe</person>, welcome to <place>New York</place>. Your appointment is on <date>15th September</date>.\\") {'people': 1, 'places': 1, 'dates': 1} >>> count_named_entities(\\"Today, <person>Alice</person> and <person>Bob</person> are visiting <place>Paris</place> on <date>10th October</date>.\\") {'people': 2, 'places': 1, 'dates': 1} >>> count_named_entities(\\"Just a simple sentence with no named entities.\\") {'people': 0, 'places': 0, 'dates': 0} pass def test_count_named_entities_example1(): input_string = \\"Hello <person>John Doe</person>, welcome to <place>New York</place>. Your appointment is on <date>15th September</date>.\\" result = count_named_entities(input_string) assert result['people'] == 1 assert result['places'] == 1 assert result['dates'] == 1 def test_count_named_entities_example2(): input_string = \\"Today, <person>Alice</person> and <person>Bob</person> are visiting <place>Paris</place> on <date>10th October</date>.\\" result = count_named_entities(input_string) assert result['people'] == 2 assert result['places'] == 1 assert result['dates'] == 1 def test_count_named_entities_example3(): input_string = \\"Just a simple sentence with no named entities.\\" result = count_named_entities(input_string) assert result['people'] == 0 assert result['places'] == 0 assert result['dates'] == 0 def test_count_named_entities_nested(): input_string = \\"<person>John <place>Doe</place></person> is working at <place>ABC Corp</place> since <date>1st Jan 2020</date>.\\" result = count_named_entities(input_string) assert result['people'] == 1 assert result['places'] == 2 assert result['dates'] == 1 def test_count_named_entities_no_entities(): input_string = \\"No entities here!\\" result = count_named_entities(input_string) assert result['people'] == 0 assert result['places'] == 0 assert result['dates'] == 0 def test_count_named_entities_multiple_entities(): input_string = \\"<person>Person1</person> <person>Person2</person> <place>Place1</place> <place>Place2</place> <date>Date1</date> <date>Date2</date>\\" result = count_named_entities(input_string) assert result['people'] == 2 assert result['places'] == 2 assert result['dates'] == 2","solution":"import re def count_named_entities(input_string): Counts named entities in the input string. Named entities are denoted by <person></person>, <place></place>, and <date></date> tags. Args: input_string (str): The input string containing named entities. Returns: dict: A dictionary containing the count of each type of named entity. people = len(re.findall(r'<person>.*?</person>', input_string)) places = len(re.findall(r'<place>.*?</place>', input_string)) dates = len(re.findall(r'<date>.*?</date>', input_string)) return { 'people': people, 'places': places, 'dates': dates }"},{"question":"def shiftString(s: str) -> str: Returns a new string with each letter shifted to the next one in the alphabet. 'z' wraps around to 'a'. >>> shiftString(\\"abcdef\\") 'bcdefg' >>> shiftString(\\"xyz\\") 'yza'","solution":"def shiftString(s): Returns the string with each letter shifted to the next one in the alphabet. 'z' wraps around to 'a'. shifted = [] for char in s: if char == 'z': shifted.append('a') else: shifted.append(chr(ord(char) + 1)) return ''.join(shifted)"},{"question":"def unique_book_combinations(n, original_books, exchanged_books): Returns the number of unique book combinations used for the exchange. Args: n : int : number of students original_books : list of int : number of books each student originally had exchanged_books : list of int : types of books each student has after the exchange Returns: int : number of possible unique book combinations >>> unique_book_combinations(3, [2, 3, 4], [2, 3, 6, 7, 8, 9, 10]) 7 >>> unique_book_combinations(2, [1, 2], [5, 6, 7]) 3","solution":"def unique_book_combinations(n, original_books, exchanged_books): Returns the number of unique book combinations used for the exchange. Args: n : int : number of students original_books : list of int : number of books each student originally had exchanged_books : list of int : types of books each student has after the exchange Returns: int : number of possible unique book combinations unique_books = set(exchanged_books) return len(unique_books)"},{"question":"def find_longest_word(strings, s): Finds the longest string in the list \`strings\` which can be formed by deleting some characters of \`s\` without reordering the remaining characters. If there are multiple possible results, returns the one which is smallest in lexicographical order. If there is no possible result, returns an empty string. >>> find_longest_word([\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"], \\"abpcplea\\") \\"apple\\" >>> find_longest_word([\\"a\\", \\"b\\", \\"c\\"], \\"abpcplea\\") \\"a\\" >>> find_longest_word([\\"a\\", \\"b\\", \\"c\\"], \\"xyz\\") \\"\\"","solution":"def find_longest_word(strings, s): Finds the longest string in the list \`strings\` which can be formed by deleting some characters of \`s\` without reordering the remaining characters. If there are multiple possible results, returns the one which is smallest in lexicographical order. If there is no possible result, returns an empty string. def can_form_by_deleting(word, s): it = iter(s) return all(char in it for char in word) strings = sorted(strings, key=lambda x: (-len(x), x)) for word in strings: if can_form_by_deleting(word, s): return word return \\"\\""},{"question":"from collections import defaultdict, deque def find_communication_hub(T: int, cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Find the communication hub for each case that minimizes the maximum distance to any other node. Args: T (int): The number of test cases. cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of tuples representing the test cases, where each tuple contains: - The number of nodes (int) - The number of edges (int) - A list of edges (List[Tuple[int, int]]), which are tuples representing the bidirectional roads between nodes. Returns: List[int]: A list of integers representing the optimal node for each test case. pass # Unit Tests import pytest def test_example_case1(): T = 2 cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]), ] expected = [1, 3] assert find_communication_hub(T, cases) == expected def test_single_node(): T = 1 cases = [ (1, 0, []), ] expected = [1] assert find_communication_hub(T, cases) == expected def test_disconnected_graph(): T = 1 cases = [ (4, 2, [(1, 2), (3, 4)]), ] # In a disconnected graph, all distances are technically infinite, # but since input guarantees a connected graph by problem statement, we don't handle this. # Hence this test should normally not be used, but showing for sake of completeness. expected = [1] # Or 2 or 3 or 4, as they are all equivalently optimal in this invalid trigger case assert find_communication_hub(T, cases) == expected def test_cycle_graph(): T = 1 cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), ] expected = [1] assert find_communication_hub(T, cases) == expected def test_balanced_tree_graph(): T = 1 cases = [ (7, 6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) ] expected = [1] assert find_communication_hub(T, cases) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import defaultdict, deque def find_communication_hub(T, cases): def bfs_distance(graph, start, N): distances = [-1] * (N + 1) queue = deque([(start, 0)]) while queue: node, dist = queue.popleft() if distances[node] == -1: distances[node] = dist for neighbor in graph[node]: if distances[neighbor] == -1: queue.append((neighbor, dist + 1)) return distances results = [] for N, M, edges in cases: graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) min_max_distance = float('inf') optimal_node = -1 for node in range(1, N + 1): distances = bfs_distance(graph, node, N) max_distance = max(distances[1:]) if max_distance < min_max_distance or (max_distance == min_max_distance and node < optimal_node): min_max_distance = max_distance optimal_node = node results.append(optimal_node) return results # Parsing input for the example cases def parse_input(): T = int(input().strip()) cases = [] for _ in range(T): N, M = map(int, input().strip().split()) edges = [] for _ in range(M): u, v = map(int, input().strip().split()) edges.append((u, v)) cases.append((N, M, edges)) return T, cases if __name__ == \\"__main__\\": T, cases = parse_input() result = find_communication_hub(T, cases) for hub in result: print(hub)"},{"question":"from typing import List, Tuple def can_communicate(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if every computer in a network can communicate with a central server (node 1) and vice versa. >>> can_communicate(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (4, 2)]) \\"YES\\" >>> can_communicate(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> can_communicate(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"NO\\"","solution":"from collections import defaultdict, deque def can_communicate(n, m, edges): def bfs(start, graph): visited = [False] * (n + 1) q = deque([start]) visited[start] = True while q: node = q.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True q.append(neighbor) return visited graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Check from node 1 visited_from_1 = bfs(1, graph) if not all(visited_from_1[1:]): return \\"NO\\" # Check to node 1 (using reverse graph) visited_to_1 = bfs(1, reverse_graph) if not all(visited_to_1[1:]): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def longest_palindrome(word: str) -> str: Given a string 'word', return the longest palindrome that can be formed by rearranging its characters. If no palindrome can be formed, return -1. >>> longest_palindrome(\\"civic\\") == \\"civic\\" >>> longest_palindrome(\\"axxz\\") == \\"-1\\" >>> longest_palindrome(\\"aabb\\") == \\"abba\\" >>> longest_palindrome(\\"a\\" * 100000) == \\"a\\" * 100000 >>> result = longest_palindrome(\\"aabbcc\\") >>> result == \\"abccba\\" or result == \\"acbbca\\" >>> longest_palindrome(\\"abcba\\") == \\"abcba\\" >>> longest_palindrome(\\"x\\") == \\"x\\" >>> longest_palindrome(\\"ab\\") == \\"-1\\"","solution":"from collections import Counter def longest_palindrome(word): Given a string 'word', return the longest palindrome that can be formed by rearranging its characters. If no palindrome can be formed, return -1. count = Counter(word) odd_count_chars = [char for char, cnt in count.items() if cnt % 2 == 1] if len(odd_count_chars) > 1: return \\"-1\\" half_palindrome = [] middle_char = [] for char, cnt in sorted(count.items()): if cnt % 2 == 1: middle_char = [char] half_palindrome.append(char * (cnt // 2)) half_palindrome = ''.join(half_palindrome) return half_palindrome + ''.join(middle_char) + half_palindrome[::-1]"},{"question":"def highest_two_round_avg(n, scores_a, scores_b): Determine the highest possible two-round average score for each student. Args: - n (int): number of rounds - scores_a (List[int]): scores of the first student in each round - scores_b (List[int]): scores of the second student in each round Returns: - Tuple[float, float]: the highest two-round average for the first and second student, rounded to one decimal place. >>> highest_two_round_avg(3, [50, 80, 70], [60, 90, 85]) (75.0, 87.5) >>> highest_two_round_avg(5, [10, 20, 30, 40, 50], [15, 25, 35, 45, 55]) (45.0, 50.0)","solution":"def highest_two_round_avg(n, scores_a, scores_b): def highest_avg(scores): max_avg = 0 for i in range(n - 1): avg = (scores[i] + scores[i + 1]) / 2 max_avg = max(max_avg, avg) return round(max_avg, 1) return highest_avg(scores_a), highest_avg(scores_b) # Example usage: # n = 3 # scores_a = [50, 80, 70] # scores_b = [60, 90, 85] # print(highest_two_round_avg(n, scores_a, scores_b)) # Output: (75.0, 87.5)"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Determine the length of the longest substring of s that contains at most k distinct characters. >>> longest_substring_k_distinct(\\"abcba\\", 2) == 3 >>> longest_substring_k_distinct(\\"aaabbcc\\", 2) == 5 >>> longest_substring_k_distinct(\\"a\\", 1) == 1 >>> longest_substring_k_distinct(\\"aaaaaaa\\", 1) == 7 >>> longest_substring_k_distinct(\\"abcdef\\", 6) == 6 >>> longest_substring_k_distinct(\\"abcdef\\", 0) == 0 # Your code here","solution":"def longest_substring_k_distinct(s, k): from collections import defaultdict if k == 0: return 0 char_count = defaultdict(int) left = 0 max_length = 0 for right in range(len(s)): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def shortestBridge(grid: List[List[int]]) -> int: Given a grid of size m x n, where each cell is either a land cell (1) or a water cell (0), determine the shortest bridge. A bridge here means the smallest number of 0s that must be flipped to 1s such that we create a connection between two separate islands (two separate groups of connected 1s). >>> shortestBridge([[0,1],[1,0]]) 1 >>> shortestBridge([[0,1,0],[0,0,0],[0,0,1]]) 2 >>> shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) 1 pass","solution":"from collections import deque def shortestBridge(grid): def dfs(i, j): stack = [(i, j)] island = [] while stack: ci, cj = stack.pop() if 0 <= ci < m and 0 <= cj < n and grid[ci][cj] == 1: grid[ci][cj] = -1 island.append((ci, cj)) for ni, nj in [(ci+1, cj), (ci-1, cj), (ci, cj+1), (ci, cj-1)]: stack.append((ni, nj)) return island def bfs(queue): level = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: for _ in range(len(queue)): ci, cj = queue.popleft() for ni, nj in directions: ni, nj = ci + ni, cj + nj if 0 <= ni < m and 0 <= nj < n: if grid[ni][nj] == 1: return level if grid[ni][nj] == 0: grid[ni][nj] = -1 queue.append((ni, nj)) level += 1 m, n = len(grid), len(grid[0]) island1 = [] # Find the first island for i in range(m): found = False for j in range(n): if grid[i][j] == 1: island1 = dfs(i, j) found = True break if found: break # Initialize the BFS with the first island queue = deque(island1) return bfs(queue)"},{"question":"def can_fulfill_requests(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Processes multiple user requests and checks if the required books can be lent out. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): A list of test case tuples, where each tuple consists of an integer 'n', a list of 'n' integers denoting the number of copies available for each book, and a list of 'n' integers denoting the number of copies requested for each book. Returns: List[str]: A list of results for each test case. Each result is either \\"Fulfills\\" or \\"Not Fulfills\\". >>> can_fulfill_requests(2, [(3, [5, 3, 10], [2, 1, 7]), (2, [2, 2], [3, 1])]) [\\"Fulfills\\", \\"Not Fulfills\\"] >>> can_fulfill_requests(1, [(2, [1, 2], [1, 1])]) [\\"Fulfills\\"]","solution":"def can_fulfill_requests(t, test_cases): results = [] for case in test_cases: n = case[0] available_books = case[1] requested_books = case[2] fulfill = True for i in range(n): if requested_books[i] > available_books[i]: fulfill = False break if fulfill: results.append(\\"Fulfills\\") else: results.append(\\"Not Fulfills\\") return results"},{"question":"def divideRecipes(prepTimes): Divide recipes as evenly as possible between two chefs. Args: prepTimes (list): A list of integers representing preparation times. Returns: tuple: A tuple of two lists, each list containing preparation times assigned to one chef. Example: >>> divideRecipes([10, 20, 30, 40, 50]) ([10, 20, 50], [30, 40])","solution":"def divideRecipes(prepTimes): Divide recipes as evenly as possible between two chefs. Args: prepTimes (list): A list of integers representing preparation times. Returns: tuple: A tuple of two lists, representing the division of recipes. # Total sum of all preparation times total_time = sum(prepTimes) n = len(prepTimes) # Dynamic programming approach to find the subset sums close to total_time / 2 dp = [False] * (total_time // 2 + 1) dp[0] = True for time in prepTimes: for j in range(total_time // 2, time - 1, -1): dp[j] = dp[j] or dp[j - time] # Find the largest j for which dp[j] is True for j in range(total_time // 2, -1, -1): if dp[j]: sum1 = j break # Now we need to determine which items are in this subset subset1 = [] subset2 = prepTimes.copy() w = sum1 for i in range(n-1, -1, -1): if w >= prepTimes[i] and dp[w-prepTimes[i]]: subset1.append(prepTimes[i]) subset2.remove(prepTimes[i]) w -= prepTimes[i] return (subset1, subset2)"},{"question":"def is_bipartite(V: int, E: int, edges: List[Tuple[int, int]]) -> str: Determine whether the given undirected graph is bipartite or not. Args: V : int : Number of vertices E : int : Number of edges edges : List[Tuple[int, int]] : List of edges in the graph Returns: str : \\"YES\\" if the graph is bipartite, \\"NO\\" otherwise Examples: >>> is_bipartite(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) \\"NO\\" >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" pass # ---- Unit tests ---- import pytest def test_example1(): V, E = 5, 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert is_bipartite(V, E, edges) == \\"NO\\" def test_example2(): V, E = 4, 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert is_bipartite(V, E, edges) == \\"YES\\" def test_single_vertex(): V, E = 1, 0 edges = [] assert is_bipartite(V, E, edges) == \\"YES\\" def test_disconnected_graph(): V, E = 4, 2 edges = [(1, 2), (3, 4)] assert is_bipartite(V, E, edges) == \\"YES\\" def test_non_bipartite_graph(): V, E = 3, 3 edges = [(1, 2), (2, 3), (3, 1)] assert is_bipartite(V, E, edges) == \\"NO\\" def test_bipartite_large_graph(): V, E = 6, 6 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)] assert is_bipartite(V, E, edges) == \\"YES\\" def test_bipartite_disconnected_components(): V, E = 6, 5 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)] assert is_bipartite(V, E, edges) == \\"NO\\"","solution":"def is_bipartite(V, E, edges): from collections import defaultdict, deque def bfs(start): queue = deque([start]) color[start] = 1 while queue: node = queue.popleft() current_color = color[node] for neighbor in adj_list[node]: if color[neighbor] == -1: color[neighbor] = 1 - current_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) color = [-1] * (V + 1) for i in range(1, V + 1): if color[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\" # Example usage (would be placed outside the function in a real scenario): V = 4 E = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] print(is_bipartite(V, E, edges)) # Output should be \\"YES\\""},{"question":"def complete_sentences(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Determine how many complete sentences each participant can type in the given time. Args: T (int): the number of test cases. test_cases (List[Tuple[int, int, int]]): each test case is a tuple containing the number of words the participant can type per minute (WPM), the number of words in the given sentence (sentence_length), and the duration of the competition in minutes (D). Returns: List[int]: a list of integers representing the number of complete sentences each participant can type within the given time. Example: >>> complete_sentences(2, [(120, 20, 10), (150, 30, 5)]) [60, 25] >>> complete_sentences(1, [(100, 25, 4)]) [16] >>> complete_sentences(1, [(10**9, 10**9, 1)]) [1]","solution":"def complete_sentences(T, test_cases): results = [] for case in test_cases: WPM, sentence_length, D = case total_words = WPM * D complete_sentences = total_words // sentence_length results.append(complete_sentences) return results"},{"question":"def find_duplicates(names: List[str]) -> str: Given a list of names, this function returns the names that appear more than once, each on a new line, in the order they first appear. If there are no duplicates, it returns \\"No duplicates\\". pass def test_find_duplicates_with_duplicates(): assert find_duplicates(['alice', 'bob', 'alice', 'eve', 'bob']) == \\"alicenbob\\" def test_find_duplicates_no_duplicates(): assert find_duplicates(['charlie', 'david', 'eve']) == \\"No duplicates\\" def test_find_duplicates_single_name(): assert find_duplicates(['alice']) == \\"No duplicates\\" def test_find_duplicates_all_same(): assert find_duplicates(['alice', 'alice', 'alice']) == \\"alice\\" def test_find_duplicates_mixed(): assert find_duplicates(['alice', 'bob', 'alice', 'charlie', 'bob', 'charlie', 'bob']) == \\"alicenbobncharlie\\" def test_find_duplicates_case_insensitivity(): assert find_duplicates(['Alice', 'bob', 'ALICE', 'Bob']) == \\"No duplicates\\" def test_find_duplicates_adjacent_duplicates(): assert find_duplicates(['alice', 'alice', 'bob', 'bob', 'charlie', 'charlie']) == \\"alicenbobncharlie\\"","solution":"def find_duplicates(names): Given a list of names, this function returns the names that appear more than once, each on a new line, in the order they first appear. If there are no duplicates, it returns \\"No duplicates\\". name_count = {} duplicates = [] for name in names: if name in name_count: name_count[name] += 1 else: name_count[name] = 1 for name in names: if name_count[name] > 1 and name not in duplicates: duplicates.append(name) if duplicates: return 'n'.join(duplicates) else: return \\"No duplicates\\" # Example usage: # n = int(input().strip()) # names = [input().strip() for _ in range(n)] # print(find_duplicates(names))"},{"question":"from typing import List def reduce_string(s: str) -> str: Function to reduce a string s containing only 'a' and 'b' according to given rules. pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Function to process multiple test cases and return their results. pass def test_reduce_string(): assert reduce_string('ab') == 'c' assert reduce_string('aa') == 'a' assert reduce_string('bb') == 'b' assert reduce_string('aab') == 'c' assert reduce_string('abb') == 'c' assert reduce_string('aabba') == 'c' assert reduce_string('abba') == 'c' assert reduce_string('abab') == 'c' assert reduce_string('aaaa') == 'a' assert reduce_string('bbbb') == 'b' def test_process_test_cases(): test_cases = ['ab', 'aa'] T = len(test_cases) results = process_test_cases(T, test_cases) assert results == ['c', 'a'] test_cases = ['abab', 'aaaa', 'bbbb', 'aabba', 'bbbbb', 'ababab'] T = len(test_cases) results = process_test_cases(T, test_cases) assert results == ['c', 'a', 'b', 'c', 'b', 'c']","solution":"def reduce_string(s): Function to reduce a string s containing only 'a' and 'b' according to given rules. while len(s) > 1: new_s = [] i = 0 while i < len(s) - 1: if s[i] == 'a' and s[i+1] == 'a': new_s.append('a') elif s[i] == 'b' and s[i+1] == 'b': new_s.append('b') else: new_s.append('c') i += 2 if i < len(s): new_s.append(s[-1]) s = ''.join(new_s) return s def process_test_cases(T, test_cases): Function to process multiple test cases and return their results. results = [] for s in test_cases: results.append(reduce_string(s)) return results"},{"question":"def file_management(operations: List[str]) -> List[str]: Processes a series of file and directory operations, maintaining the hierarchical structure. Args: operations (List[str]): List of operations to be applied on the file system. Each operation is a string of the form: - \\"CREATE path\\" - \\"DELETE path\\" - \\"MOVE source_path destination_path\\" Returns: List[str]: All paths of existing files and directories in the file system in lexicographical order. >>> operations = [\\"CREATE /a\\", \\"CREATE /a/b\\", \\"CREATE /a/b/c\\", \\"DELETE /a/b\\", \\"CREATE /a/d\\", \\"MOVE /a /e\\", \\"CREATE /e/f\\"] >>> file_management(operations) [\\"/e\\", \\"/e/d\\", \\"/e/f\\"] >>> operations = [\\"CREATE /a/b\\", \\"CREATE /a/c\\"] >>> file_management(operations) [] >>> operations = [\\"CREATE /a\\", \\"DELETE /b\\"] >>> file_management(operations) [\\"/a\\"] >>> operations = [\\"CREATE /a\\", \\"MOVE /a /b/c\\"] >>> file_management(operations) [\\"/a\\"] >>> operations = [\\"CREATE /a\\", \\"CREATE /a/b\\", \\"CREATE /a/b/c\\", \\"CREATE /d\\", \\"MOVE /a /e\\", \\"DELETE /e/b\\", \\"CREATE /f\\"] >>> file_management(operations) [\\"/d\\", \\"/e\\", \\"/f\\"]","solution":"class FileSystem: def __init__(self): self.fs = set() def create(self, path): if path in self.fs: return parent_path = '/'.join(path.rstrip('/').split('/')[:-1]) if parent_path == '' or parent_path in self.fs: self.fs.add(path.rstrip('/')) def delete(self, path): path = path.rstrip('/') if path in self.fs: for p in list(self.fs): if p == path or p.startswith(path + \\"/\\"): self.fs.remove(p) def move(self, src, dst): src = src.rstrip('/') dst = dst.rstrip('/') if src not in self.fs: return parent_path = '/'.join(dst.split('/')[:-1]) if parent_path != '' and parent_path not in self.fs: return to_move = sorted([p for p in self.fs if p.startswith(src)], key=len) for p in to_move: new_path = dst + p[len(src):] self.fs.remove(p) self.fs.add(new_path) def process_operations(self, operations): for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"CREATE\\": self.create(parts[1]) elif cmd == \\"DELETE\\": self.delete(parts[1]) elif cmd == \\"MOVE\\": self.move(parts[1], parts[2]) return sorted(self.fs) def file_management(operations): fs = FileSystem() return fs.process_operations(operations)"},{"question":"def is_unique_candy_distribution_possible(n: int, candies: List[int]) -> str: Determine if it is possible to distribute candies such that no two children have the same amount of candies, unless it's inevitable due to the total number of candies being a perfect multiple of the number of children. Parameters: n (int): Number of children candies (list): List of integers representing the quantity of candies each child has Returns: str: \\"Yes\\" if it is possible to make all candy counts unique, otherwise \\"No\\" Examples: >>> is_unique_candy_distribution_possible(5, [1, 5, 9, 3, 7]) \\"Yes\\" >>> is_unique_candy_distribution_possible(3, [2, 2, 2]) \\"No\\"","solution":"def is_unique_candy_distribution_possible(n, candies): Determine if it is possible to distribute candies such that no two children have the same amount of candies, unless it's inevitable due to the total number of candies being a perfect multiple of the number of children. Parameters: n (int): Number of children candies (list): List of integers representing the quantity of candies each child has Returns: str: \\"Yes\\" if it is possible to make all candy counts unique, otherwise \\"No\\" unique_candies = set(candies) if len(unique_candies) == len(candies): return \\"Yes\\" return \\"No\\""},{"question":"def is_formation_possible(r: int, t: int, e: int) -> str: Determines if it is possible to form exactly r teams with t members each using e employees. Returns \\"Possible\\" if it is possible to form the teams, otherwise returns \\"Impossible\\". >>> is_formation_possible(3, 4, 12) 'Possible' >>> is_formation_possible(5, 2, 9) 'Impossible' >>> is_formation_possible(2, 3, 9) 'Impossible' def test_possible_scenario(): assert is_formation_possible(3, 4, 12) == \\"Possible\\" def test_impossible_due_to_less_employees(): assert is_formation_possible(5, 2, 9) == \\"Impossible\\" def test_impossible_due_to_more_employees(): assert is_formation_possible(2, 3, 9) == \\"Impossible\\" def test_minimum_values_all_cases(): assert is_formation_possible(1, 1, 1) == \\"Possible\\" # exactly 1 employee for 1 team def test_exact_match(): assert is_formation_possible(4, 5, 20) == \\"Possible\\" # exactly 20 employees for 4 teams def test_more_complex_case(): assert is_formation_possible(3, 3, 10) == \\"Impossible\\" # need 9 or 12 but have 10 employees def test_large_values_case(): assert is_formation_possible(10, 10, 100) == \\"Possible\\" # exactly 100 employees for 10 teams assert is_formation_possible(10, 10, 99) == \\"Impossible\\" # one less than needed def test_edge_of_upper_bound(): assert is_formation_possible(1, 100, 100) == \\"Possible\\" # exactly 100 employees for 1 team def test_impossible_big_values(): assert is_formation_possible(99, 1, 100) == \\"Impossible\\" # requires exactly 99 employees not 100","solution":"def is_formation_possible(r, t, e): Determines if it is possible to form exactly r teams with t members each using e employees. required_employees = r * t if required_employees == e: return \\"Possible\\" return \\"Impossible\\""},{"question":"def min_max_diff(n: int, d: List[int], s: List[int]) -> int: Computes the minimum possible value of the maximum difference between the number of problems in any two primary difficulty levels. >>> min_max_diff(5, [1, 2, 2, 3, 3], [5, 5, 4, 6, 7]) 1 >>> min_max_diff(4, [1, 1, 2, 2], [4, 3, 2, 1]) 0","solution":"from collections import Counter def min_max_diff(n, d, s): Computes the minimum possible value of the maximum difference between the number of problems in any two primary difficulty levels. # Count the number of problems for each difficulty level difficulty_count = Counter(d) # Extract the counts and sort them counts = sorted(difficulty_count.values()) # If there's only one difficulty level, the difference is 0 if len(counts) == 1: return 0 # The minimum possible value of the maximum difference will be between the smallest and largest counts min_max_diff = counts[-1] - counts[0] return min_max_diff"},{"question":"def collatz_sequence_length(S: int) -> int: Returns the total number of integers in the Collatz sequence starting from S and ending at 1. >>> collatz_sequence_length(1) 1 >>> collatz_sequence_length(2) 2 >>> collatz_sequence_length(3) 8 >>> collatz_sequence_length(4) 3 >>> collatz_sequence_length(5) 6 pass def process_collatz_sequences(test_cases: List[int]) -> List[int]: Process multiple Collatz sequence test cases. :param test_cases: List of integers, where each integer starts a Collatz sequence. :return: List of integers, where each integer is the length of the respective Collatz sequence. >>> process_collatz_sequences([1, 2, 3, 4, 5]) [1, 2, 8, 3, 6] pass from typing import List","solution":"def collatz_sequence_length(S): Returns the total number of integers in the Collatz sequence starting from S and ending at 1. length = 1 while S != 1: if S % 2 == 0: S //= 2 else: S = 3 * S + 1 length += 1 return length def process_collatz_sequences(test_cases): Process multiple Collatz sequence test cases. :param test_cases: List of integers, where each integer starts a Collatz sequence. :return: List of integers, where each integer is the length of the respective Collatz sequence. results = [] for S in test_cases: results.append(collatz_sequence_length(S)) return results"},{"question":"def min_jumps_to_end(jumps: list) -> int: Computes the minimum number of jumps required for the frog to reach the last index in the list of jumps. Args: jumps (list): List of non-negative integers representing jump lengths. Returns: int: Minimum number of jumps to reach the last index, or -1 if not possible. Returns \\"Invalid input\\" if the input is not a list of non-negative integers. Examples: >>> min_jumps_to_end([2, 3, 1, 1, 4]) 2 >>> min_jumps_to_end([1, 1, 1, 1, 1]) 4 >>> min_jumps_to_end([0, 2, 3]) -1 >>> min_jumps_to_end(\\"invalid\\") \\"Invalid input\\" >> min_jumps_to_end([]) -1 >> min_jumps_to_end([2, -1, 1, 1, 4]) \\"Invalid input\\" >> min_jumps_to_end([2.5, 3, 1, 1, 4]) \\"Invalid input\\" pass","solution":"def min_jumps_to_end(jumps): Computes the minimum number of jumps required for the frog to reach the last index in the list of jumps. Args: jumps (list): List of non-negative integers representing jump lengths. Returns: int: Minimum number of jumps to reach the last index, or -1 if not possible. Returns \\"Invalid input\\" if the input is not a list of non-negative integers. if not isinstance(jumps, list) or not all(isinstance(i, int) and i >= 0 for i in jumps): return \\"Invalid input\\" n = len(jumps) if n == 0: return -1 if n == 1: return 0 # Initialize variables jumps_required = 0 max_reach = 0 steps = 0 current_end = 0 for i in range(n-1): max_reach = max(max_reach, i + jumps[i]) if i == current_end: jumps_required += 1 current_end = max_reach if current_end >= n - 1: break if current_end < n - 1: return -1 return jumps_required"},{"question":"def max_steal(n: int, houses: List[int]) -> int: You are given a list of non-negative integers representing the amount of money each house in a street has. There is a thief who wants to steal the maximum amount of money but cannot steal from two adjacent houses because the owners of the two adjacent houses will call the police. Args: n (int): The number of houses in the street. houses (List[int]): The amount of money in each house. Returns: int: The maximum amount of money the thief can steal. Examples: >>> max_steal(4, [1, 2, 3, 1]) 4 >>> max_steal(5, [2, 7, 9, 3, 1]) 12 >>> max_steal(1, [10]) 10","solution":"def max_steal(n, houses): if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"def manage_tasks(n: int, m: int, operations: List[str]) -> List[int]: Manage the tasks based on given operations. :param n: number of tasks :param m: number of operations :param operations: list of operations to perform :return: list of results from each query operation >>> manage_tasks(5, 6, [\\"increase 1 10\\", \\"increase 2 5\\", \\"query 1\\", \\"increase 1 3\\", \\"query 1\\", \\"query 2\\"]) [10, 13, 5] >>> manage_tasks(3, 4, [\\"increase 1 5\\", \\"increase 2 3\\", \\"increase 3 7\\", \\"query 3\\"]) [7] >>> manage_tasks(2, 6, [\\"increase 1 10\\", \\"query 1\\", \\"query 2\\", \\"increase 2 20\\", \\"query 1\\", \\"query 2\\"]) [10, 0, 10, 20] >>> manage_tasks(1, 0, []) [] >>> manage_tasks(100000, 100000, [f\\"increase 1 1\\" for _ in range(50000)] + [f\\"query 1\\"]) [50000]","solution":"def manage_tasks(n, m, operations): Manage the tasks based on given operations. :param n: number of tasks :param m: number of operations :param operations: list of operations to perform :return: list of results from each query operation # Initialize progress dictionary progress = {i: 0 for i in range(1, n + 1)} results = [] for operation in operations: parts = operation.split() command = parts[0] task_id = int(parts[1]) if command == \\"increase\\": amount = int(parts[2]) progress[task_id] += amount elif command == \\"query\\": results.append(progress[task_id]) return results"},{"question":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> longest_common_prefix([\\"single\\"]) == \\"single\\" >>> longest_common_prefix([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"\\" >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) == \\"test\\" >>> longest_common_prefix([\\"interview\\", \\"internet\\", \\"internal\\", \\"int\\"]) == \\"int\\" >>> longest_common_prefix([]) == \\"\\" >>> longest_common_prefix([\\"\\", \\"\\", \\"\\"]) == \\"\\"","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. if not strs: return \\"\\" prefix = strs[0] for string in strs[1:]: while string[:len(prefix)] != prefix: prefix = prefix[:len(prefix) - 1] if not prefix: return \\"\\" return prefix"},{"question":"def character_frequencies(text: str, queries: List[Tuple[int, int]]) -> List[List[int]]: Given a string \`text\` and a list of \`queries\` where each query specifies a starting and ending index, returns the frequency of each character ('a' to 'z') within the specified segment for each query. :param text: str, the input text consisting of lowercase letters :param queries: list of tuple, each tuple contains two integers (l, r) for the segment indices (1-indexed) :return: list of list of int, each inner list contains 26 integers corresponding to the character frequencies >>> character_frequencies(\\"abcabcabc\\", [(1, 3)]) [[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> character_frequencies(\\"abcabcabc\\", [(1, 3), (4, 6), (1, 9)]) [[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> character_frequencies(\\"aaaaa\\", [(1, 5), (2, 4), (1, 1)]) [[5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> character_frequencies(\\"abcdefg\\", [(1, 7), (2, 4), (3, 3)]) [[1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]","solution":"def character_frequencies(text, queries): Given a string \`text\` and a list of \`queries\` where each query specifies a starting and ending index, returns the frequency of each character ('a' to 'z') within the specified segment for each query. :param text: str, the input text consisting of lowercase letters :param queries: list of tuple, each tuple contains two integers (l, r) for the segment indices (1-indexed) :return: list of list of int, each inner list contains 26 integers corresponding to the character frequencies result = [] # Build prefix sum array of character counts prefix_counts = [[0] * 26 for _ in range(len(text) + 1)] for i, char in enumerate(text): for j in range(26): prefix_counts[i + 1][j] = prefix_counts[i][j] prefix_counts[i + 1][ord(char) - ord('a')] += 1 for l, r in queries: freq = [0] * 26 for j in range(26): freq[j] = prefix_counts[r][j] - prefix_counts[l - 1][j] result.append(freq) return result"},{"question":"def max_magic_power(n: int, m: int, power_levels: List[int]) -> int: Returns the highest possible total magical power that can be achieved with the given stones under the contest rules. >>> max_magic_power(4, 2, [1, 2, 3, 4]) 10 >>> max_magic_power(3, 5, [100, 200, 300]) 600 >>> max_magic_power(5, 0, [5, 5, 5, 5, 5]) 25 >>> max_magic_power(3, 2, [0, 0, 0]) 0 >>> max_magic_power(1, 0, [7]) 7 >>> max_magic_power(0, 0, []) 0 >>> max_magic_power(2, 1, [0, 1]) 1","solution":"def max_magic_power(n, m, power_levels): Returns the highest possible total magical power that can be achieved with the given stones under the contest rules. if n == 0: return 0 return sum(power_levels)"},{"question":"from typing import List, Tuple def process_packages(N: int, Q: int, weights: List[int], operations: List[Tuple[int, ...]]) -> List[int]: Process packages and perform operations as per the given specifications. Parameters: N (int): Number of packages. Q (int): Number of operations. weights (List[int]): List of weights of the packages. operations (List[Tuple[int, ...]]): List of operations to be performed. Returns: List[int]: Results of Type 1 operations. Example: >>> process_packages(5, 3, [10, 20, 30, 40, 50], [(1, 25), (2, 2, 4, 10), (1, 25)]) [3, 2] >>> process_packages(5, 2, [10, 20, 30, 40, 50], [(1, 55), (1, 5)]) [-1, 1] pass def test_example_case(): N = 5 Q = 3 weights = [10, 20, 30, 40, 50] operations = [ (1, 25), (2, 2, 4, 10), (1, 25) ] assert process_packages(N, Q, weights, operations) == [3, 2] def test_case_no_matching_weight(): N = 5 Q = 2 weights = [10, 20, 30, 40, 50] operations = [ (1, 55), (1, 5) ] assert process_packages(N, Q, weights, operations) == [-1, 1] def test_case_single_package(): N = 1 Q = 2 weights = [1] operations = [ (1, 1), (1, 2) ] assert process_packages(N, Q, weights, operations) == [1, -1] def test_case_large_updates(): N = 5 Q = 2 weights = [10, 20, 30, 40, 50] operations = [ (2, 1, 5, 1000000), (1, 1000000) ] assert process_packages(N, Q, weights, operations) == [1] def test_case_multiple_queries_updates(): N = 4 Q = 4 weights = [5, 10, 15, 20] operations = [ (2, 2, 3, 5), # weights become [5, 15, 20, 20] (1, 15), # return 2 (2, 1, 4, -5), # weights become [0, 10, 15, 15] (1, 5) # return 2 ] assert process_packages(N, Q, weights, operations) == [2, 2]","solution":"def process_packages(N, Q, weights, operations): results = [] for operation in operations: if operation[0] == 1: W = operation[1] min_index = -1 min_weight = float('inf') for i in range(N): if weights[i] >= W and weights[i] < min_weight: min_weight = weights[i] min_index = i + 1 results.append(min_index) elif operation[0] == 2: L, R, X = operation[1], operation[2], operation[3] for i in range(L-1, R): weights[i] += X return results"},{"question":"def can_form_odd_sum(t: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if it is possible to choose exactly two integers from the list such that their sum is odd. >>> can_form_odd_sum(3, [(4, [1, 2, 3, 4]), (3, [2, 4, 6]), (5, [1, 3, 5, 7, 9])]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> can_form_odd_sum(2, [(3, [1, 2, 2]), (4, [4, 4, 4, 4])]) [\\"YES\\", \\"NO\\"]","solution":"def can_form_odd_sum(t, cases): results = [] for i in range(t): n, a = cases[i] count_odd = sum(1 for num in a if num % 2 != 0) count_even = n - count_odd if count_odd > 0 and count_even > 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def remove_k_digits(num: str, k: int) -> str: You are given a string containing digits from '0' to '9'. You can remove at most k digits from the string so as to obtain the smallest possible number. Find the smallest possible number after removing at most k digits. Parameters: num (str): A string of digits representing the number. k (int): An integer representing the maximum number of digits that can be removed Returns: str: A string representing the smallest possible number that can be obtained. >>> remove_k_digits(\\"1432219\\", 3) '1219' >>> remove_k_digits(\\"10200\\", 1) '200' >>> remove_k_digits(\\"10\\", 2) '0'","solution":"def remove_k_digits(num: str, k: int) -> str: stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # Remove the remaining k digits from the end if necessary stack = stack[:-k] if k else stack # Build the final number and remove leading zeroes result = ''.join(stack).lstrip('0') return result if result else \\"0\\""},{"question":"def rotate(matrix): Rotates an NxN matrix by 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> expected = [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> assert matrix == expected >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate(matrix) >>> expected = [ ... [15, 13, 2, 5], ... [14, 3, 4, 1], ... [12, 6, 8, 9], ... [16, 7, 10, 11] ... ] >>> assert matrix == expected","solution":"def rotate(matrix): Rotates an NxN matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def mostFrequentChar(s: str) -> str: Returns the character that appears most frequently in the string s. If multiple characters have the same highest frequency, return the one that appears first in the string. Example usage: >>> mostFrequentChar(\\"aabbbccde\\") == \\"b\\" >>> mostFrequentChar(\\"xyzabcdxyz\\") == \\"x\\"","solution":"def mostFrequentChar(s): Returns the character that appears most frequently in the string s. If multiple characters have the same highest frequency, the one that appears first in the string is returned. from collections import Counter counter = Counter(s) max_count = max(counter.values()) for char in s: if counter[char] == max_count: return char # Example usage: # print(mostFrequentChar(\\"aabbbccde\\")) # Output: \\"b\\" # print(mostFrequentChar(\\"xyzabcdxyz\\")) # Output: \\"x\\""},{"question":"# Global inventory dictionary to hold product quantities inventory = {} def inventory_management(command): Handles the provided command for managing the inventory. Args: - command (str): The command string indicating the action and parameters. Returns: - For the \\"VIEW\\" command, returns a dictionary with product names as keys and their quantities. - For the \\"CHECK <product_name>\\" command, returns \\"In Stock\\" or \\"Out of Stock\\". - For the \\"ADD\\" and \\"UPDATE\\" commands, returns None. >>> inventory_management(\\"ADD apple 10\\") >>> inventory_management(\\"ADD banana 5\\") >>> inventory_management(\\"UPDATE banana 20\\") >>> inventory_management(\\"VIEW\\") {'apple': 10, 'banana': 20} >>> inventory_management(\\"CHECK apple\\") 'In Stock' >>> inventory_management(\\"CHECK orange\\") 'Out of Stock'","solution":"# Global inventory dictionary to hold product quantities inventory = {} def inventory_management(command): Handles the provided command for managing the inventory. Args: - command (str): The command string indicating the action and parameters. Returns: - For the \\"VIEW\\" command, returns a dictionary with product names as keys and their quantities. - For the \\"CHECK <product_name>\\" command, returns \\"In Stock\\" or \\"Out of Stock\\". - For the \\"ADD\\" and \\"UPDATE\\" commands, returns None. parts = command.split() action = parts[0] if action == \\"ADD\\": product_name = parts[1] quantity = int(parts[2]) if product_name not in inventory: inventory[product_name] = quantity elif action == \\"UPDATE\\": product_name = parts[1] quantity = int(parts[2]) if product_name in inventory: inventory[product_name] = quantity elif action == \\"VIEW\\": return inventory elif action == \\"CHECK\\": product_name = parts[1] return \\"In Stock\\" if product_name in inventory else \\"Out of Stock\\""},{"question":"class HackCraft: def __init__(self): self.teams = {} self.members = {} def add(self, team_name, member_name, score): Adds a member with the given score to the specified team. pass def score(self, team_name, member_name, new_score): Updates the score of the specified member in the given team to the new score. pass def max_score(self): Returns the name of the team with the highest score. pass def process_operations(operations): Processes a list of operations and returns the result of max_score operations. >>> process_operations([\\"add TeamA Alice 50\\", \\"add TeamA Bob 30\\", \\"max_score\\"]) [\\"TeamA\\"] >>> process_operations([\\"add TeamA Alice 50\\", \\"add TeamA Bob 30\\", \\"add TeamB Charlie 70\\", \\"score TeamA Alice 100\\", \\"max_score\\"]) [\\"TeamA\\"] >>> process_operations([\\"add TeamA Alice 50\\", \\"add TeamB Charlie 70\\", \\"max_score\\", \\"score TeamA Alice 100\\", \\"max_score\\", \\"add TeamC Dave 150\\", \\"max_score\\"]) [\\"TeamB\\", \\"TeamA\\", \\"TeamC\\"] >>> process_operations([\\"add TeamA Alice 50\\", \\"add TeamB Bob 50\\", \\"max_score\\"]) [\\"TeamA\\"] >>> process_operations([\\"add TeamA Alice 50\\", \\"add TeamB Charlie 70\\", \\"score TeamA Alice 50\\", \\"max_score\\"]) [\\"TeamB\\"]","solution":"class HackCraft: def __init__(self): self.teams = {} self.members = {} def add(self, team_name, member_name, score): if team_name not in self.teams: self.teams[team_name] = 0 self.teams[team_name] += score self.members[member_name] = (team_name, score) def score(self, team_name, member_name, new_score): old_score = self.members[member_name][1] self.teams[team_name] += new_score - old_score self.members[member_name] = (team_name, new_score) def max_score(self): return max(sorted(self.teams), key=lambda k: self.teams[k]) def process_operations(operations): hc = HackCraft() result = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": hc.add(parts[1], parts[2], int(parts[3])) elif parts[0] == \\"score\\": hc.score(parts[1], parts[2], int(parts[3])) elif parts[0] == \\"max_score\\": result.append(hc.max_score()) return result"},{"question":"def max_people_in_museum(n: int, log_entries: List[str]) -> int: Determines the maximum number of people in the museum at any given time based on the log. Args: n: int - Number of log entries log_entries: list of str - List of \\"entry\\" or \\"exit\\" log entries Returns: int - Maximum number of people in the museum at any given time >>> max_people_in_museum(6, [\\"entry\\", \\"entry\\", \\"exit\\", \\"entry\\", \\"entry\\", \\"exit\\"]) 3 >>> max_people_in_museum(3, [\\"entry\\", \\"exit\\", \\"entry\\"]) 1","solution":"def max_people_in_museum(n, log_entries): Determines the maximum number of people in the museum at any given time based on the log. Args: n: int - Number of log entries log_entries: list of str - List of \\"entry\\" or \\"exit\\" log entries Returns: int - Maximum number of people in the museum at any given time current_count = 0 max_count = 0 for log in log_entries: if log == 'entry': current_count += 1 if current_count > max_count: max_count = current_count elif log == 'exit': current_count -= 1 return max_count # Example usage: # n = 6 # log_entries = [\\"entry\\", \\"entry\\", \\"exit\\", \\"entry\\", \\"entry\\", \\"exit\\"] # print(max_people_in_museum(n, log_entries)) # Output: 3"},{"question":"def analyse_competitions(T, cases): Analyze T test cases for competition times. Each case consists of multiple competitions. For each competition, the times for three events are given. Arguments: T : int : number of test cases cases : list of tuples : Each tuple with (n, competition_times) n: int : number of competitions competition_times: list of tuples : Each tuple (S, C, R) indicating times for swimming, cycling, and running Returns: list of tuples : Each tuple with (competition_index, max_event_time) competition_index: int : 1-based index of the competition with the least total time. max_event_time: int : Maximum time taken for a single event across all competitions. # Implementation here def test_analyse_competitions(): # Test case 1 T = 2 cases = [ (3, [(10, 20, 30), (15, 25, 35), (5, 8, 12)]), (2, [(50, 60, 70), (45, 55, 65)]) ] expected = [(3, 35), (2, 70)] assert analyse_competitions(T, cases) == expected # Test case 2 T = 1 cases = [ (4, [(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12)]) ] expected = [(1, 12)] assert analyse_competitions(T, cases) == expected # Test case 3 T = 1 cases = [ (3, [(30, 40, 50), (30, 40, 10), (20, 20, 20)]) ] expected = [(3, 50)] assert analyse_competitions(T, cases) == expected # Test case 4 T = 1 cases = [ (1, [(20, 25, 30)]) ] expected = [(1, 30)] assert analyse_competitions(T, cases) == expected # Test case 5 T = 3 cases = [ (2, [(15, 30, 45), (25, 25, 25)]), (3, [(0, 0, 0), (1, 1, 1), (2, 2, 2)]), (2, [(300, 200, 100), (100, 200, 300)]) ] expected = [(2, 45), (1, 2), (1, 300)] assert analyse_competitions(T, cases) == expected","solution":"def analyse_competitions(T, cases): Analyze T test cases for competition times. Each case consists of multiple competitions. For each competition, the times for three events are given. Arguments: T : int : number of test cases cases : list of tuples : Each tuple with (n, competition_times) n: int : number of competitions competition_times: list of tuples : Each tuple (S, C, R) indicating times for swimming, cycling, and running Returns: list of tuples : Each tuple with (competition_index, max_event_time) competition_index: int : 1-based index of the competition with the least total time. max_event_time: int : Maximum time taken for a single event across all competitions. results = [] for i in range(T): n, competition_times = cases[i] min_total_time = float('inf') competition_index = -1 max_event_time = 0 for j in range(n): S, C, R = competition_times[j] total_time = S + C + R if total_time < min_total_time: min_total_time = total_time competition_index = j + 1 max_event_time = max(max_event_time, S, C, R) results.append((competition_index, max_event_time)) return results"},{"question":"def determine_list_order(N: int, integers_list: List[int]) -> str: Determines whether the list of integers is strictly increasing, strictly decreasing or neither. Args: N: int - Number of integers in the list. integers_list: List[int] - The list of integers. Returns: str: \\"INCREASING\\", \\"DECREASING\\" or \\"NEITHER\\" >>> determine_list_order(4, [1, 2, 3, 4]) \\"INCREASING\\" >>> determine_list_order(5, [9, 7, 5, 3, 1]) \\"DECREASING\\" >>> determine_list_order(6, [5, 10, 2, 8, 6, 3]) \\"NEITHER\\" >>> determine_list_order(2, [1, 2]) \\"INCREASING\\" >>> determine_list_order(2, [2, 1]) \\"DECREASING\\" >>> determine_list_order(4, [1, 3, 2, 4]) \\"NEITHER\\"","solution":"def determine_list_order(N, integers_list): Determines whether the list of integers is strictly increasing, strictly decreasing or neither. Args: N: int - Number of integers in the list. integers_list: List[int] - The list of integers. Returns: str: \\"INCREASING\\", \\"DECREASING\\" or \\"NEITHER\\" if all(integers_list[i] < integers_list[i+1] for i in range(N-1)): return \\"INCREASING\\" elif all(integers_list[i] > integers_list[i+1] for i in range(N-1)): return \\"DECREASING\\" else: return \\"NEITHER\\""},{"question":"def process_grades(n, student_data, q, queries): Processes student grades and handles AVG, MAX, and MIN queries. Parameters: n (int): Number of students student_data (list of tuples): A list where each tuple contains (name, grade) q (int): Number of queries queries (list of str): List of queries each being 'AVG', 'MAX', or 'MIN' Returns: list: Results of the queries in the order they were provided Examples: >>> process_grades(5, [(\\"Alice\\", 78), (\\"Bob\\", 82), (\\"Charlie\\", 91), (\\"David\\", 76), (\\"Eve\\", 88)], 3, [\\"AVG\\", \\"MAX\\", \\"MIN\\"]) [\\"83.00\\", \\"91\\", \\"76\\"] >>> process_grades(1, [(\\"Alice\\", 100)], 3, [\\"AVG\\", \\"MAX\\", \\"MIN\\"]) [\\"100.00\\", \\"100\\", \\"100\\"] >>> process_grades(5, [(\\"Alice\\", 85), (\\"Bob\\", 85), (\\"Charlie\\", 85), (\\"David\\", 85), (\\"Eve\\", 85)], 3, [\\"AVG\\", \\"MAX\\", \\"MIN\\"]) [\\"85.00\\", \\"85\\", \\"85\\"] >>> process_grades(6, [(\\"Alice\\", 70), (\\"Bob\\", 85), (\\"Charlie\\", 90), (\\"David\\", 65), (\\"Eve\\", 95), (\\"Frank\\", 80)], 3, [\\"MAX\\", \\"AVG\\", \\"MIN\\"]) [\\"95\\", \\"80.83\\", \\"65\\"]","solution":"def process_grades(n, student_data, q, queries): Processes student grades and handles AVG, MAX, and MIN queries. Parameters: n (int): Number of students student_data (list of tuples): A list where each tuple contains (name, grade) q (int): Number of queries queries (list of str): List of queries each being 'AVG', 'MAX', or 'MIN' Returns: list: Results of the queries in the order they were provided grades = [grade for _, grade in student_data] results = [] for query in queries: if query == 'AVG': avg_grade = sum(grades) / n results.append(f\\"{avg_grade:.2f}\\") elif query == 'MAX': max_grade = max(grades) results.append(str(max_grade)) elif query == 'MIN': min_grade = min(grades) results.append(str(min_grade)) return results"},{"question":"def uniquePaths(M: int, N: int) -> int: Calculate the number of unique paths in a MxN grid from the top-left to the bottom-right corner, where you can only move to the right or down. Args: M: int - number of rows in the grid N: int - number of columns in the grid Returns: int - number of unique paths modulo 10^9 + 7 Examples: >>> uniquePaths(2, 3) 3 >>> uniquePaths(3, 3) 6 pass # Implementation here # Unit tests def test_uniquePaths_example1(): assert uniquePaths(2, 3) == 3 def test_uniquePaths_example2(): assert uniquePaths(3, 3) == 6 def test_uniquePaths_single_row(): assert uniquePaths(1, 5) == 1 def test_uniquePaths_single_column(): assert uniquePaths(4, 1) == 1 def test_uniquePaths_large_grid(): assert uniquePaths(100, 100) == 690285631 def test_uniquePaths_square_grid(): assert uniquePaths(10, 10) == 48620","solution":"def uniquePaths(M, N): Calculate the number of unique paths in a MxN grid from the top-left to the bottom-right corner MOD = 10**9 + 7 # Create a 2D list to store the number of paths to each cell dp = [[0] * N for _ in range(M)] # There is exactly 1 way to reach each cell in the first row and first column for i in range(M): dp[i][0] = 1 for j in range(N): dp[0][j] = 1 # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD # The value at the bottom-right corner of the grid return dp[M - 1][N - 1]"},{"question":"def filter_integers_by_digit_sum(integers: List[int], X: int) -> List[int]: Filters the provided list of integers to include only those whose digit sum is divisible by X. :param integers: List of integers to filter. :param X: The divisor for the digit sum. :return: Filtered list of integers. >>> filter_integers_by_digit_sum([123, 456, 789, 987, 654], 3) [123, 456, 789, 987, 654] >>> filter_integers_by_digit_sum([10, 20, 30], 7) [] >>> filter_integers_by_digit_sum([111, 222, 333, 444, 555], 3) [111, 222, 333, 444, 555] >>> filter_integers_by_digit_sum([294], 5) [294] >>> filter_integers_by_digit_sum([1024, 2048, 123456789, 987654321], 9) [123456789, 987654321]","solution":"def filter_integers_by_digit_sum(integers, X): Filters the provided list of integers to include only those whose digit sum is divisible by X. :param integers: List of integers to filter. :param X: The divisor for the digit sum. :return: Filtered list of integers. return [ num for num in integers if sum(int(digit) for digit in str(num)) % X == 0 ]"},{"question":"def maximize_variance(n: int, k: int) -> List[int]: Returns a sequence of n integers representing the number of items in each chest such that the variance of the number of items is maximized. >>> maximize_variance(3, 5) [1, 1, 5] >>> maximize_variance(4, 10) [1, 1, 10, 10] >>> maximize_variance(2, 10) [1, 10]","solution":"def maximize_variance(n, k): Returns a sequence of n integers representing the number of items in each chest such that the variance of the number of items is maximized. if n == 1: return [k] elif n == 2: return [1, k] # To maximize the variance, we distribute the items as follows: # Assign the minimum (1) to n//2 chests and the maximum (k) to the other n - n//2 chests. sequence = [1] * (n // 2) + [k] * (n - n // 2) return sequence"},{"question":"def find_largest_elements(arr, n): Create a function that takes an array of integers and an integer \`n\` and returns an array of the \`n\` largest unique elements from the original array. The return array should be sorted in descending order. If there are fewer than \`n\` unique elements in the input array, return those elements sorted in descending order. >>> find_largest_elements([4, 5, 6, 3, 2, 7], 3) [7, 6, 5] >>> find_largest_elements([4, 4, 4, 3, 2], 2) [4, 3] >>> find_largest_elements([1, 5, 3, 5, 2, 1, 4], 4) [5, 4, 3, 2] >>> find_largest_elements([1, 2, 3], 5) [3, 2, 1] >>> find_largest_elements([], 3) [] >>> find_largest_elements([4, 5, 6], 0) [] >>> find_largest_elements([4, 5, 6], -1) [] >>> find_largest_elements([1, 2, 3], 3) [3, 2, 1] >>> find_largest_elements([1, 1, 1, 1], 2) [1] >>> find_largest_elements([10, 20, 30, 40, 50], 10) [50, 40, 30, 20, 10]","solution":"def find_largest_elements(arr, n): Returns the \`n\` largest unique elements from the original array sorted in descending order. If there are fewer than \`n\` unique elements, returns those elements sorted in descending order. if n <= 0 or not arr: return [] unique_elements = list(set(arr)) unique_elements.sort(reverse=True) return unique_elements[:n]"},{"question":"def separateAndConcatenate(s: str) -> str: Separates alphabetical characters and digits, then concatenates them with alphabets first followed by digits. >>> separateAndConcatenate(\\"a1b2c3\\") \\"abc123\\" >>> separateAndConcatenate(\\"h3e4l5l6o\\") \\"hello3456\\" >>> separateAndConcatenate(\\"123Ab@C\\") \\"AbC123\\"","solution":"def separateAndConcatenate(s): Separates alphabetic characters and digits into two different strings and concatenates them with alphabets first followed by digits. Parameters: s (str): The input string containing alphanumeric and possibly other symbols. Returns: str: The resultant string with alphabets followed by digits. alphabets = ''.join([char for char in s if char.isalpha()]) digits = ''.join([char for char in s if char.isdigit()]) return alphabets + digits"},{"question":"def update_scores(T: int, test_cases: List[Tuple[int, int, List[str], List[Tuple[Dict[str, int], Dict[str, int]]]]]) -> List[str]: Alisha loves playing board games with her friends. However, she noticed that keeping track of the scores can be quite hectic, especially when there are multiple rounds and various penalties/rewards affecting the scores within each round. To make things easier, she decided to create a program that will help update the scores accurately after each round. Input: - The first line contains an integer T indicating the number of test cases. - For each test case, the first line contains two integers N and R where N is the number of players and R is the number of rounds. - N lines follow, each containing the name of a player. Each name will be distinct and will be a single word composed of lowercase or uppercase letters only. - R rounds follow, each formatted as follows: - The first line contains an integer K representing the number of players who gained points in the round. - The next K lines each contain a player's name followed by an integer P indicating the points gained. - The next line contains an integer L representing the number of players who lost points in the round. - The next L lines each contain a player's name followed by an integer M indicating the points lost. Output: - For each test case, print N lines showing the final scores of each player in the given format: \\"<Player_Name> has a score of <Score>\\" Constraints: - 1 ≤ T ≤ 10 - 2 ≤ N ≤ 50 - 1 ≤ R ≤ 50 - 1 ≤ K, L ≤ N - 1 ≤ length of each name ≤ 20 - -1000 ≤ P, M ≤ 1000 Sample Input: 1 3 2 John Emma Ryan 2 John 50 Emma 30 1 Ryan 20 1 Emma 15 2 John 20 Ryan 50 Sample Output: John has a score of 30 Emma has a score of 15 Ryan has a score of -30 Example usage: T = 1 test_cases = [ (3, 2, ['John', 'Emma', 'Ryan'], [ ({\\"John\\": 50, \\"Emma\\": 30}, {\\"Ryan\\": 20}), ({\\"John\\": 20}, {\\"Emma\\": 15, \\"Ryan\\": 50}) ]) ] print(update_scores(T, test_cases))","solution":"def update_scores(T, test_cases): results = [] for i in range(T): N, R, players, rounds = test_cases[i] scores = {player: 0 for player in players} for round_ in rounds: gainers, losers = round_ for player, points in gainers.items(): scores[player] += points for player, points in losers.items(): scores[player] -= points for player in players: results.append(f\\"{player} has a score of {scores[player]}\\") return results # Example usage: T = 1 test_cases = [ (3, 2, ['John', 'Emma', 'Ryan'], [ ({\\"John\\": 50, \\"Emma\\": 30}, {\\"Ryan\\": 20}), ({\\"John\\": 20}, {\\"Emma\\": 15, \\"Ryan\\": 50}) ]) ] print(update_scores(T, test_cases))"},{"question":"def min_flips_to_sort(arr): Given an array of integers, returns the minimum number of flips required to sort the array in non-decreasing order. Args: arr (List[int]): The list of integers to be sorted. Returns: int: The minimum number of flips required to sort the array. Examples: >>> min_flips_to_sort([3, 2, 1, 4, 5]) 1 >>> min_flips_to_sort([4, 3, 1, 2, 6, 5]) 2 >>> min_flips_to_sort([1, 2, 3]) 0","solution":"def min_flips_to_sort(arr): Returns the minimum number of flips required to sort the array in non-decreasing order. n = len(arr) sorted_arr = sorted(arr) # If the array is already sorted, return 0 flips if arr == sorted_arr: return 0 start, end = 0, n-1 # Find the first element from the left that is out of order while arr[start] == sorted_arr[start]: start += 1 # Find the first element from the right that is out of order while arr[end] == sorted_arr[end]: end -= 1 # Flip the subarray once and check if it becomes sorted arr[start:end+1] = arr[start:end+1][::-1] if arr == sorted_arr: return 1 # If one flip is not sufficient, return 2 as maximum flips needed as per examples return 2"},{"question":"from collections import OrderedDict class LRUCache: Implement a caching system that supports the following operations: 1. get(key) - Retrieves the value associated with the key if it exists in the cache, otherwise returns -1. 2. put(key, value) - Inserts or updates the value associated with the key. If the cache reaches its capacity, it should invalidate the least recently used (LRU) item before inserting the new item. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) -1 >>> cache.put(4, 4) # evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int): pass","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"def calculate_time_inside(swipe_data): Calculate the total time spent inside the building given a list of swipe times. Args: swipe_data (list of tuples): Each tuple contains a timestamp (in 24-hour format) and a swipe action ('E' or 'X'). Returns: str: The total time inside the building in \\"HH:MM\\" format or an error message if the swipe order is invalid. Examples: >>> calculate_time_inside([('09:00', 'E'), ('12:30', 'X'), ('13:15', 'E'), ('17:45', 'X')]) '08:00' >>> calculate_time_inside([('09:00', 'E'), ('12:30', 'E'), ('13:15', 'X'), ('17:45', 'X')]) 'Error: Invalid swipe order' >>> calculate_time_inside([('12:30', 'X'), ('09:00', 'E'), ('17:45', 'X'), ('13:15', 'E')]) '08:00' >>> calculate_time_inside([]) '00:00' >>> calculate_time_inside([('09:00', 'E'), ('10:00', 'X')]) '01:00' >>> calculate_time_inside([('09:00', 'X'), ('10:00', 'E')]) 'Error: Invalid swipe order' >>> calculate_time_inside([('09:00', 'E')]) 'Error: Invalid swipe order'","solution":"def calculate_time_inside(swipe_data): Calculate the total time spent inside the building given a list of swipe times. Args: swipe_data (list of tuples): Each tuple contains a timestamp (in 24-hour format) and a swipe action ('E' or 'X'). Returns: str: The total time inside the building in \\"HH:MM\\" format or an error message if the swipe order is invalid. from datetime import datetime, timedelta # Sort the swipe data based on timestamp swipe_data = sorted(swipe_data, key=lambda x: x[0]) total_time = timedelta() last_entry_time = None for time, action in swipe_data: current_time = datetime.strptime(time, '%H:%M') if action == 'E': if last_entry_time is not None: return \\"Error: Invalid swipe order\\" last_entry_time = current_time elif action == 'X': if last_entry_time is None: return \\"Error: Invalid swipe order\\" total_time += current_time - last_entry_time last_entry_time = None if last_entry_time is not None: return \\"Error: Invalid swipe order\\" total_hours, remainder = divmod(total_time.total_seconds(), 3600) total_minutes = remainder // 60 return f\\"{int(total_hours):02}:{int(total_minutes):02}\\""},{"question":"def park_rides(R, ride_capacities, V, visitors_preferences): Determine if it's possible to assign each visitor to a ride based on their preferences and the ride capacities. Parameters: R : int : number of rides ride_capacities : List[int] : List of integers denoting capacities of each ride V : int : number of visitors visitors_preferences : List[List[int]] : List of lists where each sublist contains integers of rides that a visitor is willing to go on Returns: str : \\"Yes\\" if it is possible to assign each visitor to a ride based on their preferences, otherwise \\"No\\" Examples: >>> park_rides(3, [2, 1, 3], 4, [[1, 3], [1, 2], [2, 3], [1, 3]]) \\"Yes\\" >>> park_rides(3, [2, 1, 1], 4, [[1, 3], [1, 2], [2, 3], [2]]) \\"No\\" pass","solution":"def assign_rides(ride_capacities, visitors_preferences): R = len(ride_capacities) V = len(visitors_preferences) # Initial ride allocation rides_allocation = [0] * R for preferences in visitors_preferences: assigned = False for pref in preferences: if rides_allocation[pref - 1] < ride_capacities[pref - 1]: rides_allocation[pref - 1] += 1 assigned = True break if not assigned: return \\"No\\" return \\"Yes\\" # Example usage def park_rides(R, ride_capacities, V, visitors_preferences): R - number of rides ride_capacities - List of integers denoting capacities of each ride V - number of visitors visitors_preferences - List of lists where each sublist contains integers of rides that a visitor is willing to go on return assign_rides(ride_capacities, visitors_preferences)"},{"question":"def calculate_discounted_prices(components: List[str]) -> List[str]: Calculate the discounted prices of the components. Each component is represented by a string in the format \\"name_price_discount\\". Args: components (List[str]): List of components in the format \\"name_price_discount\\". Returns: List[str]: List of components with their discounted prices. >>> calculate_discounted_prices([\\"resistor_50_10\\", \\"capacitor_100_25\\", \\"inductor_200_15\\"]) [\\"resistor 45\\", \\"capacitor 75\\", \\"inductor 170\\"] >>> calculate_discounted_prices([\\"resistor_50_0\\", \\"capacitor_80_0\\", \\"inductor_200_0\\"]) [\\"resistor 50\\", \\"capacitor 80\\", \\"inductor 200\\"] >>> calculate_discounted_prices([\\"resistor_50_100\\", \\"capacitor_80_100\\", \\"inductor_200_100\\"]) [\\"resistor 0\\", \\"capacitor 0\\", \\"inductor 0\\"]","solution":"def calculate_discounted_prices(components): result = [] for component in components: # Split the component string into its respective parts name, price, discount = component.split('_') price = int(price) discount = int(discount) # Calculate the discounted price discount_amount = (discount / 100) * price discounted_price = round(price - discount_amount) # Append the result as name and discounted price result.append(f\\"{name} {discounted_price}\\") return result # Example usage: # components = [\\"resistor_50_10\\", \\"capacitor_100_25\\", \\"inductor_200_15\\"] # print(calculate_discounted_prices(components))"},{"question":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def spiralOrder(root): Given a binary tree, perform spiral level order traversal. Args: root (TreeNode): The root of the binary tree. Returns: List[int]: A list containing the spiral level order traversal of the tree. Examples: >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> spiralOrder(root) [1, 3, 2, 4, 5, 6, 7] >>> root = TreeNode(10, TreeNode(20, TreeNode(40), TreeNode(60)), TreeNode(30, None, TreeNode(50))) >>> spiralOrder(root) [10, 30, 20, 40, 60, 50] pass # Unit Test def test_spiral_order_complete_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) output = spiralOrder(root) assert output == [1, 3, 2, 4, 5, 6, 7] def test_spiral_order_incomplete_tree(): root = TreeNode(10) root.left = TreeNode(20) root.right = TreeNode(30) root.left.left = TreeNode(40) root.left.right = TreeNode(60) root.right.right = TreeNode(50) output = spiralOrder(root) assert output == [10, 30, 20, 40, 60, 50] def test_spiral_order_single_node(): root = TreeNode(1) output = spiralOrder(root) assert output == [1] def test_spiral_order_empty_tree(): root = None output = spiralOrder(root) assert output == [] def test_spiral_order_only_left_children(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) output = spiralOrder(root) assert output == [1, 2, 3] def test_spiral_order_only_right_children(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) output = spiralOrder(root) assert output == [1, 2, 3]","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def spiralOrder(root): if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) level_nodes = [] for _ in range(level_size): if left_to_right: node = current_level.popleft() level_nodes.append(node.value) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) else: node = current_level.pop() level_nodes.append(node.value) if node.right: current_level.appendleft(node.right) if node.left: current_level.appendleft(node.left) result.extend(level_nodes) left_to_right = not left_to_right return result"},{"question":"def can_partition_into_two_sorted_subarrays(n, arr): Determine if the array can be partitioned into two non-decreasing contiguous subarrays. Args: n : int : length of the array arr : List[int] : input array Returns: str : \\"YES\\" if possible to partition, otherwise \\"NO\\" >>> can_partition_into_two_sorted_subarrays(5, [2, 2, 3, 1, 4]) 'YES' >>> can_partition_into_two_sorted_subarrays(5, [3, 1, 4, 2, 2]) 'NO' >>> can_partition_into_two_sorted_subarrays(3, [1, 2, 3]) 'YES'","solution":"def can_partition_into_two_sorted_subarrays(n, arr): Determine if the array can be partitioned into two non-decreasing contiguous subarrays. Args: n : int : length of the array arr : List[int] : input array Returns: str : \\"YES\\" if possible to partition, otherwise \\"NO\\" for i in range(1, n): # Check if the left part [0:i] is non-decreasing left_sorted = all(arr[j] <= arr[j + 1] for j in range(i - 1)) # Check if the right part [i:n] is non-decreasing right_sorted = all(arr[j] <= arr[j + 1] for j in range(i, n - 1)) if left_sorted and right_sorted: return \\"YES\\" return \\"NO\\""},{"question":"def minimum_absolute_difference(arr): Given a list of integers, find the minimum absolute difference between any two distinct integers. Args: arr (List[int]): A list of integers Returns: int: The minimum absolute difference Examples: >>> minimum_absolute_difference([3, -7, 0]) 3 >>> minimum_absolute_difference([1, 2, 3, 4, 5]) 1","solution":"def minimum_absolute_difference(arr): Given a list of integers, find the minimum absolute difference between any two distinct integers. Args: arr (List[int]): A list of integers Returns: int: The minimum absolute difference # Sort the array to bring closest values next to each other arr.sort() # Initialize the minimum difference to a large value min_diff = float('inf') # Iterate through the sorted array and compute the minimum difference for i in range(len(arr) - 1): min_diff = min(min_diff, abs(arr[i+1] - arr[i])) return min_diff"},{"question":"from typing import List def can_form_palindrome(s) -> bool: Determines if the characters of the string \`s\` can be rearranged to form a palindrome. # Implement your solution here def palindrome_possibility(test_cases: List[str]) -> List[str]: Determines if for each string in the \`test_cases\`, it is possible to rearrange its characters to form a palindrome. :param test_cases: List of strings to be tested :return: List of \\"YES\\" or \\"NO\\" for each string >>> palindrome_possibility([\\"carrace\\", \\"hello\\", \\"aabbcc\\"]) ['YES', 'NO', 'YES'] >>> palindrome_possibility([\\"a\\", \\"abb\\", \\"abc\\"]) ['YES', 'YES', 'NO'] results = [] # Implement your solution here return results","solution":"def can_form_palindrome(s): Determines if the characters of the string \`s\` can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def palindrome_possibility(test_cases): Determines if for each string in the \`test_cases\`, it is possible to rearrange its characters to form a palindrome. :param test_cases: List of strings to be tested :return: List of \\"YES\\" or \\"NO\\" for each string results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def fibonacci(n): Returns the nth Fibonacci number. pass def preprocess_fibonacci(elements): Precompute the Fibonacci number for each element in the list to handle queries efficiently. pass def precompute_sums(elements, fib_cache): Precompute prefix sum of Fibonacci numbers of the elements in the list. pass def sum_of_fibonacci_in_range(prefix_sums, l, r): Returns the sum of Fibonacci numbers for the subarray defined by l and r. pass def process_queries(n, elements, m, queries): Main function to process all queries and return the results. >>> process_queries(5, [3, 1, 4, 1, 5], 3, [(1, 3), (2, 5), (1, 5)]) [6, 10, 12] >>> process_queries(4, [0, 1, 2, 3], 2, [(1, 2), (2, 4)]) [1, 4] >>> process_queries(3, [10, 10, 10], 1, [(1, 3)]) [165] pass","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def preprocess_fibonacci(elements): Precompute the Fibonacci number for each element in the list to handle queries efficiently. fib_cache = {} # fill the cache with Fibonacci numbers for all elements in the list for element in elements: if element not in fib_cache: fib_cache[element] = fibonacci(element) return fib_cache def precompute_sums(elements, fib_cache): Precompute prefix sum of Fibonacci numbers of the elements in the list. n = len(elements) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + fib_cache[elements[i - 1]] return prefix_sums def sum_of_fibonacci_in_range(prefix_sums, l, r): Returns the sum of Fibonacci numbers for the subarray defined by l and r. return prefix_sums[r] - prefix_sums[l - 1] def process_queries(n, elements, m, queries): Main function to process all queries and return the results. fib_cache = preprocess_fibonacci(elements) prefix_sums = precompute_sums(elements, fib_cache) results = [] for l, r in queries: results.append(sum_of_fibonacci_in_range(prefix_sums, l, r)) return results"},{"question":"def first_missing_positive(nums: List[int]) -> int: Given an array of integers, return the smallest missing positive integer. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([]) 1 >>> first_missing_positive([1, 2, 3]) 4 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1, 1, 2, 2]) 3 >>> first_missing_positive([-1, -2, -3]) 1 >>> first_missing_positive([2, 3, 4]) 1 >>> first_missing_positive(list(range(1, 10000))) 10000","solution":"def first_missing_positive(nums): Given an array of integers, return the smallest missing positive integer. n = len(nums) # First pass: Place each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] with the number at its correct position nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Second pass: Find the first index whose value is incorrect for i in range(n): if nums[i] != i + 1: return i + 1 # If all values are correct, return the next number return n + 1"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_map = {} left = 0 max_length = 0 for right in range(n): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def print_diamond(n): Prints a diamond pattern with '*' symbols given an odd integer n (3 ≤ n ≤ 19). Example: >>> print_diamond(3) * *** * >>> print_diamond(5) * *** ***** *** *","solution":"def print_diamond(n): Prints a diamond pattern with '*' symbols given an odd integer n (3 ≤ n ≤ 19). if n < 3 or n > 19 or n % 2 == 0: raise ValueError(\\"n must be an odd integer between 3 and 19\\") middle = n // 2 for i in range(n): stars = '*' * (2 * (middle - abs(middle - i)) + 1) spaces = ' ' * abs(middle - i) print(spaces + stars)"},{"question":"def hardness_of_sorting(n: int, labels: List[int]) -> int: This function determines the hardness of sorting for any initial sequence of box labels provided in the list \`labels\`. The hardness is defined as the number of cycles required for the boxes to be fully sorted using a specific sorting mechanism. :param n: int, the number of boxes :param labels: list of int, each integer is a label of a box :return: int, the hardness of sorting >>> hardness_of_sorting(5, [4, 3, 2, 1, 5]) 4 >>> hardness_of_sorting(6, [1, 3, 5, 7, 9, 11]) 1 >>> hardness_of_sorting(3, [1, 2, 3]) 1","solution":"def hardness_of_sorting(n, labels): This function determines the hardness of sorting for any initial sequence of box labels provided in the list \`labels\`. The hardness is defined as the number of cycles required for the boxes to be fully sorted using a specific sorting mechanism. :param n: int, the number of boxes :param labels: list of int, each integer is a label of a box :return: int, the hardness of sorting cycles = 0 while True: swapped = False for i in range(1, n): if labels[i - 1] > labels[i]: labels[i - 1], labels[i] = labels[i], labels[i - 1] swapped = True cycles += 1 if not swapped: break return cycles"},{"question":"from typing import List, Any def has_consecutive_duplicates(lst: List[Any]) -> bool: Returns True if the provided list contains any consecutive duplicates, otherwise False. >>> has_consecutive_duplicates([1, 2, 3, 4, 4, 5]) True >>> has_consecutive_duplicates(['a', 'b', 'c', 'd', 'e']) False >>> has_consecutive_duplicates([5, 5, 5, 6, 6, 7]) True >>> has_consecutive_duplicates([8, 8, 9, 10]) True >>> has_consecutive_duplicates([2, 3, 2, 3, 4, 5]) False >>> has_consecutive_duplicates([4]) False >>> has_consecutive_duplicates(['x', 'y', 'z', 'a', 'b']) False >>> has_consecutive_duplicates([1, \\"1\\", 1.0, \\"a\\", \\"a\\"]) True >>> has_consecutive_duplicates([True, False, True]) False >>> has_consecutive_duplicates([False, False, True]) True","solution":"def has_consecutive_duplicates(lst): Returns True if the provided list contains any consecutive duplicates, otherwise False. :param lst: List containing elements of any data type :return: True if there are consecutive duplicates, otherwise False for i in range(len(lst) - 1): if lst[i] == lst[i + 1]: return True return False"},{"question":"from typing import List def sum_of_divisors(n: int, a: List[int]) -> List[int]: Given a list of integers, return a new list where each integer is replaced by the sum of its proper divisors. A proper divisor of a number is any divisor of the number except the number itself. >>> sum_of_divisors(6, [6, 28, 12, 10, 15, 21]) [6, 28, 16, 8, 9, 11] >>> sum_of_divisors(3, [1, 16, 20]) [0, 15, 22]","solution":"from typing import List def sum_of_divisors(n: int, a: List[int]) -> List[int]: def proper_divisors_sum(x): if x <= 1: return 0 total = 1 for i in range(2, int(x**0.5) + 1): if x % i == 0: total += i if i != x // i: total += x // i return total return [proper_divisors_sum(num) for num in a]"},{"question":"def count_single_char_substrings(s: str) -> int: Counts the number of substrings that contain exactly one distinct character. Parameters: s (str): The input string made up of lowercase English letters. Returns: int: The number of substrings with exactly one distinct character. >>> count_single_char_substrings(\\"aaab\\") == 7 >>> count_single_char_substrings(\\"abc\\") == 3 \`\`","solution":"def count_single_char_substrings(s): Counts the number of substrings that contain exactly one distinct character. Parameters: s (str): The input string made up of lowercase English letters. Returns: int: The number of substrings with exactly one distinct character. n = len(s) if n == 0: return 0 total_count = 0 i = 0 while i < n: char_count = 1 while i + 1 < n and s[i] == s[i + 1]: char_count += 1 i += 1 total_count += (char_count * (char_count + 1)) // 2 i += 1 return total_count"},{"question":"from typing import List def search_sorted_matrix(matrix: List[List[int]], target: int) -> bool: Determines if the target integer exists in the sorted n x n matrix. Each row and column of the matrix is sorted in ascending order. Parameters: matrix (List[List[int]]): The n x n matrix of integers. target (int): The integer to search for. Returns: bool: True if target is found in the matrix, otherwise False. Examples: >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30]] >>> search_sorted_matrix(matrix, 5) True >>> search_sorted_matrix(matrix, 20) False pass def test_search_sorted_matrix_target_exists(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_sorted_matrix(matrix, 5) == True assert search_sorted_matrix(matrix, 11) == True assert search_sorted_matrix(matrix, 30) == True def test_search_sorted_matrix_target_not_exists(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_sorted_matrix(matrix, 20) == False assert search_sorted_matrix(matrix, 0) == False assert search_sorted_matrix(matrix, 31) == False def test_search_sorted_matrix_empty_matrix(): assert search_sorted_matrix([], 5) == False assert search_sorted_matrix([[]], 5) == False def test_search_sorted_matrix_one_element_matrix(): assert search_sorted_matrix([[5]], 5) == True assert search_sorted_matrix([[5]], 1) == False def test_search_sorted_matrix_negative_numbers(): matrix = [ [-10, -5, -1, 3, 5], [-8, -4, 0, 4, 9], [-7, -2, 2, 6, 11], [-6, -1, 3, 7, 12], [-3, 1, 5, 8, 15] ] assert search_sorted_matrix(matrix, -5) == True assert search_sorted_matrix(matrix, 6) == True assert search_sorted_matrix(matrix, 10) == False assert search_sorted_matrix(matrix, -11) == False","solution":"def search_sorted_matrix(matrix, target): Determines if the target integer exists in the sorted n x n matrix. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from the top-right corner of the matrix while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 # Move left else: row += 1 # Move down return False"},{"question":"def calculate_ranking(n: int, m: int, scores: List[List[int]]) -> List[int]: Calculate the ranking of each participant based on their scores in multiple challenges. Parameters: n (int): Total number of participants. m (int): Total number of challenges. scores (List[List[int]]): A list of m lists, each containing n scores for each challenge. Returns: List[int]: A list containing the rank of each participant from 1 to n. >>> calculate_ranking(4, 3, [[10, 20, 30, 40], [40, 30, 20, 10], [20, 30, 40, 50]]) [4, 3, 2, 1] >>> calculate_ranking(3, 2, [[90, 80, 70], [70, 80, 90]]) [3, 2, 1] >>> calculate_ranking(2, 2, [[50, 50], [60, 70]]) [2, 1] >>> calculate_ranking(2, 3, [[20, 30], [30, 30], [40, 30]]) [1, 2] >>> calculate_ranking(1, 1, [[100]]) [1]","solution":"def calculate_ranking(n, m, scores): Calculate the ranking of each participant based on their scores in multiple challenges. # Calculate total scores total_scores = [sum(scores[i][j] for i in range(m)) for j in range(n)] # Combine total scores with most recent challenge scores and participant indices participants = [(total_scores[i], scores[m-1][i], i) for i in range(n)] # Sort participants based on total_score (descending), most recent score (descending) participants.sort(key=lambda x: (-x[0], -x[1])) # Allocate ranking based on sorted participants ranks = [0] * n rank = 1 for _, _, idx in participants: ranks[idx] = rank rank += 1 return ranks"},{"question":"def process_notifications(N: int, M: int, notifications: List[Tuple[int, str]]) -> List[str]: Processes notifications and determines whether each new notification is a duplicate of a recent one within the last M minutes. Parameters: N (int): Total number of notifications M (int): Time frame in minutes to check for duplicates notifications (list): List of tuples containing timestamp and notification content Returns: list: A list containing 'SEND' or 'IGNORE' for each notification >>> N = 5 >>> M = 10 >>> notifications = [ >>> (1, \\"Notification1\\"), >>> (5, \\"Notification2\\"), >>> (8, \\"Notification1\\"), >>> (12, \\"Notification3\\"), >>> (15, \\"Notification1\\") >>> ] >>> process_notifications(N, M, notifications) ['SEND', 'SEND', 'IGNORE', 'SEND', 'SEND'] # Sample Input N = 5 M = 10 notifications = [ (1, \\"Notification1\\"), (5, \\"Notification2\\"), (8, \\"Notification1\\"), (12, \\"Notification3\\"), (15, \\"Notification1\\") ] print(process_notifications(N, M, notifications))","solution":"def process_notifications(N, M, notifications): Processes notifications and determines whether each new notification is a duplicate of a recent one within the last M minutes. Parameters: N (int): Total number of notifications M (int): Time frame in minutes to check for duplicates notifications (list): List of tuples containing timestamp and notification content Returns: list: A list containing 'SEND' or 'IGNORE' for each notification from collections import deque result = [] recent_notifications = deque() for t_i, s_i in notifications: # Remove old notifications while recent_notifications and recent_notifications[0][0] <= t_i - M: recent_notifications.popleft() # Check if current notification is a duplicate if any(content == s_i for _, content in recent_notifications): result.append('IGNORE') else: result.append('SEND') recent_notifications.append((t_i, s_i)) return result # Sample Input N = 5 M = 10 notifications = [ (1, \\"Notification1\\"), (5, \\"Notification2\\"), (8, \\"Notification1\\"), (12, \\"Notification3\\"), (15, \\"Notification1\\") ] # Printing Output for sample input print(process_notifications(N, M, notifications))"},{"question":"from typing import List def find_majority_elements(nums: List[int]) -> List[int]: Find all elements that appear more than n/3 times in the list. >>> find_majority_elements([3, 2, 3]) [3] >>> find_majority_elements([1, 1, 1, 3, 3, 2, 2, 2]) [1, 2] >>> find_majority_elements([1, 2, 3]) [] >>> find_majority_elements([]) [] >>> find_majority_elements([5, 5, 5, 5]) [5] >>> find_majority_elements([1, 2, 3, 1, 2, 3, 1, 2, 1]) [1]","solution":"from typing import List from collections import Counter def find_majority_elements(nums: List[int]) -> List[int]: Find all elements that appear more than n/3 times in the list. if not nums: return [] n = len(nums) threshold = n // 3 counter = Counter(nums) majority_elements = [num for num, count in counter.items() if count > threshold] return majority_elements"},{"question":"def min_swaps_to_equal_strings(t: int, test_cases: List[Tuple[int, str, str]]) -> List[int]: Determine the minimum number of character swaps required to make the strings a and b equal for each test case. If it is impossible to make the strings equal, return -1 for that pair. t: The number of test cases. test_cases: A list of tuples, each containing an integer n (length of strings a and b), and two strings a and b. >>> min_swaps_to_equal_strings(3, [(5, 'ababa', 'baaba'), (4, 'abcd', 'dcba'), (6, 'abcabc', 'cbacba')]) [1, 2, 2] >>> min_swaps_to_equal_strings(2, [(3, 'aaa', 'aaa'), (1, 'a', 'a')]) [0, 0] >>> min_swaps_to_equal_strings(2, [(3, 'abc', 'abd'), (2, 'aa', 'bb')]) [-1, -1]","solution":"def min_swaps_to_equal_strings(t, test_cases): def count_swaps(a, b): if sorted(a) != sorted(b): return -1 return sum(1 for x, y in zip(a, b) if x != y) // 2 results = [] for n, a, b in test_cases: results.append(count_swaps(a, b)) return results"},{"question":"def isSubsequence(main_str: str, sub_str: str) -> bool: Determines if sub_str is a subsequence of main_str. Args: main_str (str): The main string. sub_str (str): The string to check as a subsequence. Returns: bool: True if sub_str is a subsequence of main_str, False otherwise. Examples: >>> isSubsequence(\\"abcdef\\", \\"ace\\") True >>> isSubsequence(\\"abcdef\\", \\"aec\\") False","solution":"def isSubsequence(main_str, sub_str): Determines if sub_str is a subsequence of main_str. Args: main_str (str): The main string. sub_str (str): The string to check as a subsequence. Returns: bool: True if sub_str is a subsequence of main_str, False otherwise. sub_len = len(sub_str) main_len = len(main_str) if sub_len == 0: return True sub_index = 0 for char in main_str: if char == sub_str[sub_index]: sub_index += 1 if sub_index == sub_len: return True return False"},{"question":"def process_queries(n, m, sequence, queries): Given a sequence of n integers, process m queries of two possible types. Type 1: Increment the value of the i-th element in the sequence by d. Type 2: Find the length of the longest contiguous subarray that is strictly increasing. Parameters: n (int): the number of elements in the sequence m (int): the number of queries sequence (List[int]): the initial sequence of integers queries (List[List[int]]): the list of queries Returns: List[int]: the results for each query of the second type Examples: >>> process_queries(5, 5, [2, 1, 3, 2, 5], [[1, 3, 1], [2], [1, 5, 1], [2], [2]]) [2, 2, 2] >>> process_queries(1, 1, [5], [[2]]) [1] >>> process_queries(5, 1, [1, 2, 3, 4, 5], [[2]]) [5] >>> process_queries(5, 1, [5, 4, 3, 2, 1], [[2]]) [1] >>> process_queries(6, 3, [1, 2, 1, 2, 1, 2], [[1, 3, 1], [2], [2]]) [2, 2]","solution":"def process_queries(n, m, sequence, queries): def get_longest_increasing_subarray_length(seq): # Initialize the variables for the current max length and the overall max length max_len = 1 current_len = 1 for i in range(1, len(seq)): if seq[i] > seq[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len results = [] for query in queries: if query[0] == 1: # Increment the value of i-th element by d i, d = query[1] - 1, query[2] sequence[i] += d elif query[0] == 2: # Find the length of the longest contiguous subarray that is strictly increasing results.append(get_longest_increasing_subarray_length(sequence)) return results"},{"question":"def n_trees_ways(n: int) -> int: Given the dimensions of a garden, determine the number of ways to plant exactly one tree in each row and column such that no two trees are in the same row, column, or diagonal. >>> n_trees_ways(1) 1 >>> n_trees_ways(2) 0 >>> n_trees_ways(3) 0 >>> n_trees_ways(4) 2 >>> n_trees_ways(5) 10 >>> n_trees_ways(6) 4 >>> n_trees_ways(7) 40 >>> n_trees_ways(8) 92","solution":"def is_valid(board, row, col, n): Function to check if a tree can be planted at board[row][col]. for i in range(row): if board[i] == col or abs(board[i] - col) == abs(i - row): return False return True def solve_n_trees(n, row, board, solutions): Function to recursively solve the n-trees problem by backtracking. if row == n: solutions.append(board[:]) return for col in range(n): if is_valid(board, row, col, n): board[row] = col solve_n_trees(n, row + 1, board, solutions) def n_trees_ways(n): Function to return the number of ways to plant the trees in the garden. board = [-1] * n solutions = [] solve_n_trees(n, 0, board, solutions) return len(solutions) # Example usage # print(n_trees_ways(4)) # Expected output: 2"},{"question":"def sum_of_digits(nums): Given a list of non-negative integers, returns a list of sums of digits for each integer. :param nums: List of non-negative integers. :return: List of sums of digits. >>> sum_of_digits([123]) == [6] >>> sum_of_digits([123, 456, 789]) == [6, 15, 24] >>> sum_of_digits([2021, 999, 1000, 505]) == [5, 27, 1, 10] >>> sum_of_digits([0]) == [0] >>> sum_of_digits([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> sum_of_digits([9876543210, 1234567890]) == [45, 45] >>> sum_of_digits([10, 100, 1000]) == [1, 1, 1]","solution":"def sum_of_digits(nums): Given a list of non-negative integers, returns a list of sums of digits for each integer. :param nums: List of non-negative integers. :return: List of sums of digits. def digit_sum(n): return sum(int(digit) for digit in str(n)) return [digit_sum(num) for num in nums]"},{"question":"def modified_collatz_sequence(n: int) -> List[int]: Computes a modified Collatz sequence for a given integer n, continuing in reverse back to n. >>> modified_collatz_sequence(5) == [5, 16, 8, 4, 2, 1, 2, 4, 8, 16, 5] >>> modified_collatz_sequence(3) == [3, 10, 5, 16, 8, 4, 2, 1, 2, 4, 8, 16, 5, 10, 3]","solution":"def modified_collatz_sequence(n): Returns the modified Collatz sequence for a given integer n. # Start with the initial value sequence = [n] # Generate sequence until we reach 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(n) # Add the reverse sequence back except for the last element (1) sequence.extend(sequence[-2::-1]) return sequence"},{"question":"def can_reach_all_cities(n: int, m: int, roads: List[Tuple[int, int, int]]) -> str: Determine if every city can be reached from any other city. Args: n (int): The number of cities. m (int): The number of roads. roads (List[Tuple[int, int, int]]): The list of roads where each road is represented by a tuple (u, v, type). Returns: str: \\"YES\\" if every city can be visited from any other city, otherwise \\"NO\\". Example: >>> can_reach_all_cities(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)]) 'YES' >>> can_reach_all_cities(4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 2)]) 'NO' def test_example_1(): n, m = 4, 4 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1) ] assert can_reach_all_cities(n, m, roads) == \\"YES\\" def test_example_2(): n, m = 4, 3 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 2) ] assert can_reach_all_cities(n, m, roads) == \\"NO\\" def test_example_3(): n, m = 3, 3 roads = [ (1, 2, 2), (2, 3, 2), (3, 1, 2) ] assert can_reach_all_cities(n, m, roads) == \\"YES\\" def test_single_city(): n, m = 1, 0 roads = [] assert can_reach_all_cities(n, m, roads) == \\"YES\\" def test_disconnected_cities(): n, m = 4, 2 roads = [ (1, 2, 1), (3, 4, 1) ] assert can_reach_all_cities(n, m, roads) == \\"NO\\" def test_all_two_way_roads(): n, m = 5, 5 roads = [ (1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (5, 1, 2) ] assert can_reach_all_cities(n, m, roads) == \\"YES\\"","solution":"def can_reach_all_cities(n, m, roads): from collections import defaultdict, deque def bfs(start_node, graph): visited = set() queue = deque([start_node]) while queue: current = queue.popleft() if current not in visited: visited.add(current) queue.extend(graph[current] - visited) return visited # Create adjacency graphs adj = defaultdict(set) reverse_adj = defaultdict(set) for u, v, type in roads: adj[u].add(v) reverse_adj[v].add(u) if type == 2: adj[v].add(u) reverse_adj[u].add(v) # Check if all nodes can reach from node 1 reachable_from_1 = bfs(1, adj) if len(reachable_from_1) != n: return \\"NO\\" # Check if all nodes can reach node 1 reachable_to_1 = bfs(1, reverse_adj) if len(reachable_to_1) != n: return \\"NO\\" return \\"YES\\""},{"question":"def sumOfPrimes(n: int) -> int: Returns the sum of all prime numbers less than or equal to n. >>> sumOfPrimes(10) 17 >>> sumOfPrimes(1) 0 >>> sumOfPrimes(2) 2 >>> sumOfPrimes(3) 5 >>> sumOfPrimes(100) 1060 >>> sumOfPrimes(4) 5 >>> sumOfPrimes(29) 129","solution":"def sumOfPrimes(n): Returns the sum of all prime numbers less than or equal to n. if n < 2: return 0 # Sieve of Eratosthenes sieve = [True] * (n + 1) sieve[0] = sieve[1] = False p = 2 while p * p <= n: if sieve[p]: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 # Sum up all prime numbers return sum(p for p in range(n + 1) if sieve[p])"},{"question":"def max_jewels(N: int, M: int, grid: List[List[int]]) -> int: Calculate the maximum number of jewels that can be collected from the top-left to the bottom-right of the grid. >>> max_jewels(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 29 >>> max_jewels(1, 5, [ ... [1, 2, 3, 4, 5]]) 15 >>> max_jewels(5, 1, [ ... [1], ... [2], ... [3], ... [4], ... [5]]) 15 pass","solution":"def max_jewels(N, M, grid): # Create a 2D list to store the maximum jewels collected to reach each cell dp = [[0]*M for _ in range(N)] # Initialize the first cell with the number of jewels in the top-left cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the grid for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Maximum jewels collected is in the bottom-right cell return dp[N-1][M-1]"},{"question":"def count_palindromic_substrings(s: str) -> int: Determines the number of palindromic substrings in a string. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"level\\") 7 >>> count_palindromic_substrings(\\"abc\\") 3","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string. n = len(s) count = 0 # Create a 2D array to store the palindrome status dp = [[False] * n for _ in range(n)] # Single letter substrings are palindromes for i in range(n): dp[i][i] = True count += 1 # Check for two-character palindromes for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for palindromes of length greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count"},{"question":"def find(parent, u): if parent[u] != u: parent[u] = find(parent, parent[u]) return parent[u] def union(parent, rank, u, v): root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 def remove_redundant_tunnels(n, m, tunnels): Remove the minimum number of redundant tunnels so that the remaining structure forms a tree. Input: - n: an integer, representing the number of locations - m: an integer, representing the number of tunnels - tunnels: a list of tuples, where each tuple contains three integers (u, v, w) representing a tunnel between locations u and v with length w. Output: - The number of tunnels removed and the total length of the remaining tunnels in the tree. Example: >>> remove_redundant_tunnels(5, 6, [(1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 5, 1), (1, 3, 5), (2, 5, 6)]) (2, 10) >>> remove_redundant_tunnels(4, 5, [(1, 2, 3), (1, 3, 2), (3, 4, 4), (2, 4, 1), (2, 3, 5)]) (2, 6) tunnels.sort(key=lambda x: x[2]) # Sort by tunnel length parent = list(range(n+1)) rank = [0] * (n+1) total_length = 0 remaining_tunnels = 0 for u, v, w in tunnels: if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_length += w remaining_tunnels += 1 tunnels_removed = m - (n - 1) return tunnels_removed, total_length def main(input_data): input_lines = input_data.strip().split(\\"n\\") n, m = map(int, input_lines[0].split()) tunnels = [list(map(int, line.split())) for line in input_lines[1:]] tunnels_removed, total_length = remove_redundant_tunnels(n, m, tunnels) return f\\"{tunnels_removed}n{total_length}\\" # Unit Tests def test_example_1(): input_data = 5 6n1 2 3n2 3 2n3 4 4n4 5 1n1 3 5n2 5 6 assert main(input_data) == \\"2n10\\" def test_example_2(): input_data = 4 5n1 2 3n1 3 2n3 4 4n2 4 1n2 3 5 assert main(input_data) == \\"2n6\\" def test_minimum_case(): input_data = 2 1n1 2 1 assert main(input_data) == \\"0n1\\" def test_maximum_tunnels(): input_data = 4 7n1 2 5n2 3 10n3 4 15n4 1 20n2 4 25n1 3 30n1 4 35 assert main(input_data) == \\"4n30\\" def test_redundant_tunnel(): input_data = 3 3n1 2 10n2 3 15n1 3 20 assert main(input_data) == \\"1n25\\"","solution":"def find(parent, u): if parent[u] != u: parent[u] = find(parent, parent[u]) return parent[u] def union(parent, rank, u, v): root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 def remove_redundant_tunnels(n, m, tunnels): tunnels.sort(key=lambda x: x[2]) # Sort by tunnel length parent = list(range(n+1)) rank = [0] * (n+1) total_length = 0 remaining_tunnels = 0 for u, v, w in tunnels: if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_length += w remaining_tunnels += 1 tunnels_removed = m - (n - 1) return tunnels_removed, total_length def main(input_data): input_lines = input_data.strip().split(\\"n\\") n, m = map(int, input_lines[0].split()) tunnels = [list(map(int, line.split())) for line in input_lines[1:]] tunnels_removed, total_length = remove_redundant_tunnels(n, m, tunnels) return f\\"{tunnels_removed}n{total_length}\\" # Example usage input_data = 5 6 1 2 3 2 3 2 3 4 4 4 5 1 1 3 5 2 5 6 print(main(input_data)) # Output: 2n10"},{"question":"def count_failed_parkings(T, test_cases): Count the number of drivers who fail to find a suitable parking lot immediately upon arrival. Args: T (int): The number of test cases. test_cases (List[Dict]): A list of dictionaries, each containing: - N (int): Number of parking lots. - capacities (List[int]): The capacities of the parking lots. - M (int): Number of arriving drivers. - requirements (List[int]): Space requirements for each driver. - durations (List[int]): Duration for which each driver will occupy the parking lot. Returns: List[int]: Number of drivers who fail to park immediately for each test case. pass from solution import count_failed_parkings def test_single_case(): T = 1 test_cases = [{ 'N': 3, 'capacities': [10, 5, 8], 'M': 5, 'requirements': [3, 6, 2, 5, 4], 'durations': [2, 3, 1, 4, 2] }] assert count_failed_parkings(T, test_cases) == [1] def test_all_park(): T = 1 test_cases = [{ 'N': 2, 'capacities': [10, 10], 'M': 3, 'requirements': [3, 4, 2], 'durations': [2, 5, 1] }] assert count_failed_parkings(T, test_cases) == [0] def test_no_capacity(): T = 1 test_cases = [{ 'N': 3, 'capacities': [1, 1, 1], 'M': 3, 'requirements': [3, 2, 1], 'durations': [2, 1, 1] }] assert count_failed_parkings(T, test_cases) == [2] def test_multiple_cases(): T = 2 test_cases = [ { 'N': 3, 'capacities': [10, 5, 8], 'M': 5, 'requirements': [3, 6, 2, 5, 4], 'durations': [2, 3, 1, 4, 2] }, { 'N': 2, 'capacities': [4, 6], 'M': 4, 'requirements': [5, 6, 2, 3], 'durations': [1, 4, 2, 3] } ] assert count_failed_parkings(T, test_cases) == [1, 2]","solution":"def count_failed_parkings(T, test_cases): results = [] for i in range(T): N = test_cases[i]['N'] P = test_cases[i]['capacities'] M = test_cases[i]['M'] R = test_cases[i]['requirements'] D = test_cases[i]['durations'] parking_lots = [{'capacity': p, 'free': p} for p in P] failed_drivers = 0 for j in range(M): requirement = R[j] parked = False for lot in parking_lots: if lot['free'] >= requirement: lot['free'] -= requirement parked = True break if not parked: failed_drivers += 1 results.append(failed_drivers) return results"},{"question":"def color_sentence(colors: str, sentence: str) -> str: Returns the sentence with each word colored based on its position, following the cyclic pattern of the given list of colors. >>> color_sentence(\\"red blue green\\", \\"Hello this is a fun chatbot feature\\") 'Hello(red) this(blue) is(green) a(red) fun(blue) chatbot(green) feature(red)' >>> color_sentence(\\"red green\\", \\"Test sentence\\") 'Test(red) sentence(green)' >>> color_sentence(\\"orange\\", \\"Only one color here\\") 'Only(orange) one(orange) color(orange) here(orange)' >>> color_sentence(\\"a b c d e\\", \\"Less words\\") 'Less(a) words(b)' >>> color_sentence(\\"x y\\", \\"cycling through colors in a sentence\\") 'cycling(x) through(y) colors(x) in(y) a(x) sentence(y)'","solution":"def color_sentence(colors, sentence): Returns the sentence with each word colored based on its position, following the cyclic pattern of the given list of colors. Parameters: colors (list of str): The list of colors. sentence (str): The sentence to be colored. Returns: str: The colored sentence formatted as \\"word(color)\\". color_list = colors.split() words = sentence.split() result = [] for i in range(len(words)): color = color_list[i % len(color_list)] result.append(f\\"{words[i]}({color})\\") return ' '.join(result)"},{"question":"def unique_paths(n, m): Calculate the number of unique synchronized paths in a n x m grid for two robots. >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 3) 3 >>> unique_paths(3, 2) 3 >>> unique_paths(4, 4) 20 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(n, m): Calculate the number of unique synchronized paths in a n x m grid for two robots. # Initialize a 2D dp array with 0s dp = [[0] * m for _ in range(n)] # Base case: there's one way to reach each cell in the first row and first column for i in range(n): dp[i][0] = 1 for j in range(m): dp[0][j] = 1 # Calculate number of ways to reach each cell (i, j) for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][m-1]"},{"question":"def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int: Return the length of the longest substring that contains at most \`k\` distinct characters. >>> lengthOfLongestSubstringKDistinct(\\"eceba\\", 2) 3 >>> lengthOfLongestSubstringKDistinct(\\"abcde\\", 1) 1","solution":"def lengthOfLongestSubstringKDistinct(s, k): from collections import defaultdict n = len(s) if k == 0 or n == 0: return 0 left, right = 0, 0 max_length = 0 char_map = defaultdict(int) while right < n: char_map[s[right]] += 1 right += 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"from typing import List, Tuple def calculate_total_distance(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Calculate the minimum distance a drone will cover to complete all deliveries and return to the docking station for each and every return trip. Args: T: an integer representing the number of test cases. test_cases: a list of tuples where each tuple contains an integer N (number of delivery points) and a list of N tuples with each tuple containing two integers X and Y (denoting the X and Y coordinates of the ith delivery point). Returns: A list of integers where each integer is the total minimum distance the drone has to travel to complete all deliveries and return to the docking station for each and every return trip for a test case. Example: >>> calculate_total_distance(1, [(3, [(1, 1), (2, 2), (3, 3)])]) [24] >>> calculate_total_distance(2, [(2, [(5, 5), (6, 6)]), (3, [(-1, -1), (-2, -2), (-3, -3)])]) [44, 24]","solution":"def calculate_total_distance(T, test_cases): results = [] for i in range(T): N, points = test_cases[i] total_distance = 0 for x, y in points: total_distance += 2 * (abs(x) + abs(y)) results.append(total_distance) return results # Parsing input def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(data[idx]) idx += 1 points = [] for _ in range(N): x = int(data[idx]) y = int(data[idx+1]) points.append((x, y)) idx += 2 test_cases.append((N, points)) results = calculate_total_distance(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def can_serve_all_friends(n: int, k: int, q: int, preferences: List[int]) -> str: Determine if it is possible to serve every friend their preferred dish. >>> can_serve_all_friends(6, 3, 2, [1, 2, 3, 1, 2, 3]) \\"YES\\" >>> can_serve_all_friends(5, 2, 2, [1, 1, 1, 2, 2]) \\"NO\\"","solution":"def can_serve_all_friends(n, k, q, preferences): dish_count = [0] * (k + 1) for preference in preferences: dish_count[preference] += 1 for count in dish_count: if count > q: return \\"NO\\" return \\"YES\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = list(map(int, input().strip().split())) n = data[0] k = data[1] q = data[2] preferences = data[3:] print(can_serve_all_friends(n, k, q, preferences))"},{"question":"from typing import List def countRectangles(grid: List[str]) -> int: Count the number of rectangular sub-grids with all the same characters in a given grid. The sub-grid must have at least 2 rows and 2 columns. >>> countRectangles([ ... \\"aaaa\\", ... \\"aaaa\\", ... \\"aaaa\\" ... ]) 10 >>> countRectangles([ ... \\"abab\\", ... \\"baba\\", ... \\"abab\\" ... ]) 0","solution":"from typing import List def countRectangles(grid: List[str]) -> int: n = len(grid) m = len(grid[0]) count = 0 for r1 in range(n): for r2 in range(r1 + 1, n): for c1 in range(m): for c2 in range(c1 + 1, m): if all(grid[r][c] == grid[r1][c1] for r in range(r1, r2 + 1) for c in range(c1, c2 + 1)): count += 1 return count"},{"question":"def minimum_cost_to_connect(N, M, roads): Determine the minimum number of roads and their cost to upgrade so that every house can be reached from any other house via the upgraded road network at the minimum cost. Args: N : int : Number of houses M : int : Number of roads roads : List[Tuple[int, int, int]] : A list of tuples where each tuple contains three integers u, v, and c, representing a road between houses u and v with upgrade cost c Returns: int : The minimum cost required to ensure that all houses are reachable from each other Example: >>> minimum_cost_to_connect(4, 5, [ >>> (1, 2, 3), >>> (1, 3, 1), >>> (2, 3, 2), >>> (3, 4, 4), >>> (2, 4, 5) >>> ]) 7","solution":"def minimum_cost_to_connect(N, M, roads): Returns the minimum cost required to ensure that all houses are reachable from each other by upgrading the roads. # Helper function to find the root of a node def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to union two subsets def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rank[rootX] < rank[rootY]: parent[rootX] = rootY elif rank[rootX] > rank[rootY]: parent[rootY] = rootX else: parent[rootY] = rootX rank[rootX] += 1 # Initialize parent and rank arrays parent = [i for i in range(N)] rank = [0] * N # Sort all edges in non-decreasing order of their cost roads.sort(key=lambda x: x[2]) total_cost = 0 num_edges = 0 for u, v, cost in roads: root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: total_cost += cost num_edges += 1 union(parent, rank, root_u, root_v) # If we already have N-1 edges, we can stop early if num_edges == N - 1: break return total_cost"},{"question":"class FileSystem: A class to represent a basic file system which supports creating, deleting, and listing directories. Methods: mkdir(path: str) -> None: Create a new directory at the specified path. rmdir(path: str) -> None: Remove a directory at the specified path along with its subdirectories. ls(path: str) -> List[str]: List all directories and subdirectories from the specified path in lexicographical order. def __init__(self): # Initialize the file system self.fs = {} def mkdir(self, path): Create a directory specified by the path. pass def rmdir(self, path): Remove the directory and its subdirectories specified by the path. pass def ls(self, path): List all directories and subdirectories from the specified path. pass # Example driver code: fs = FileSystem() commands = [ \\"mkdir /home\\", \\"mkdir /home/user\\", \\"mkdir /home/user/docs\\", \\"mkdir /home/user/music\\", \\"ls /home\\", \\"rmdir /home/user/docs\\", \\"ls /home/user\\" ] for command in commands: cmd, path = command.split() if cmd == \\"mkdir\\": fs.mkdir(path) elif cmd == \\"rmdir\\": fs.rmdir(path) elif cmd == \\"ls\\": print(fs.ls(path))","solution":"class FileSystem: def __init__(self): self.fs = {} def mkdir(self, path): dirs = path.split('/')[1:] # split path and remove empty first element current = self.fs for d in dirs: if d not in current: current[d] = {} current = current[d] def rmdir(self, path): dirs = path.split('/')[1:] current = self.fs for d in dirs[:-1]: current = current[d] del current[dirs[-1]] def ls(self, path): dirs = path.split('/')[1:] current = self.fs for d in dirs: current = current[d] return sorted(current.keys()) # Example driver code: fs = FileSystem() commands = [ \\"mkdir /home\\", \\"mkdir /home/user\\", \\"mkdir /home/user/docs\\", \\"mkdir /home/user/music\\", \\"ls /home\\", \\"rmdir /home/user/docs\\", \\"ls /home/user\\" ] for command in commands: cmd, path = command.split() if cmd == \\"mkdir\\": fs.mkdir(path) elif cmd == \\"rmdir\\": fs.rmdir(path) elif cmd == \\"ls\\": print(fs.ls(path))"},{"question":"def calculate_net_investment(N, transactions): Calculate Sarah's net investment given the number of transactions and a list of transaction amounts. :param N: Number of transactions (1 <= N <= 100) :param transactions: List of transaction amounts (-10000 <= transaction <= 10000) :return: Net investment as an integer >>> calculate_net_investment(3, [500, -200, 300]) == 600 >>> calculate_net_investment(5, [-1000, 2000, 300, -500, 100]) == 900","solution":"def calculate_net_investment(N, transactions): Calculate Sarah's net investment given the number of transactions and a list of transaction amounts. :param N: Number of transactions (1 <= N <= 100) :param transactions: List of transaction amounts (-10000 <= transaction <= 10000) :return: Net investment as an integer return sum(transactions)"},{"question":"def single_digit_product(num: int) -> int: Computes the product of digits of a given number until the product is a single digit. >>> single_digit_product(9875) 0 >>> single_digit_product(39) 4 >>> single_digit_product(7) 7 >>> single_digit_product(25) 0 >>> single_digit_product(36) 8 >>> single_digit_product(123456789) 0 >>> single_digit_product(5060) 0 >>> single_digit_product(1023) 0 >>> single_digit_product(1111) 1 >>> single_digit_product(111111111) 1","solution":"def singleDigitProduct(num): Computes the product of digits of a given number repeatedly until the product is a single digit. while num >= 10: product = 1 while num > 0: digit = num % 10 num //= 10 product *= digit num = product return num"},{"question":"def maxBatchSize(patience: List[int], min_patience: int) -> int: Returns the size of the maximum batch of friends with patience levels meeting or exceeding the minimum required. Parameters: - patience: List[int]: list of integers representing the patience levels of each friend - min_patience: int: integer representing the minimum patience level required to join the ride Returns: - int: the size of the maximum batch of friends that can join the ride together >>> maxBatchSize([2, 4, 5, 8, 9], 4) 4 >>> maxBatchSize([1, 7, 3, 6, 5, 2], 5) 3 >>> maxBatchSize([1, 2, 3, 4, 5], 6) 0 pass # Unit tests def test_maxBatchSize(): assert maxBatchSize([2, 4, 5, 8, 9], 4) == 4 assert maxBatchSize([1, 7, 3, 6, 5, 2], 5) == 3 assert maxBatchSize([1, 2, 3, 4, 5], 6) == 0 assert maxBatchSize([10, 20, 30, 40, 50], 25) == 3 assert maxBatchSize([5, 5, 5, 5, 5], 5) == 5 assert maxBatchSize([1], 1) == 1 assert maxBatchSize([3], 4) == 0 def test_maxBatchSize_with_edge_cases(): assert maxBatchSize([1]*1000, 1) == 1000 assert maxBatchSize([1000]*1000, 1000) == 1000 assert maxBatchSize([1]*999 + [1000], 1) == 1000 assert maxBatchSize([1]*999 + [1000], 1000) == 1","solution":"def maxBatchSize(patience, min_patience): Returns the size of the maximum batch of friends with patience levels meeting or exceeding the minimum required. Parameters: - patience: list of integers representing the patience levels of each friend - min_patience: integer representing the minimum patience level required to join the ride Returns: - int: the size of the maximum batch of friends that can join the ride together # List to store friends who meet or exceed the minimum patience level valid_friends = [p for p in patience if p >= min_patience] # The size of the valid friends is the maximum batch size return len(valid_friends)"},{"question":"def count_paths(grid: List[str], R: int, C: int) -> int: Computes the number of different paths from the top-left corner to the bottom-right corner in a rectangular grid. You can move to an adjacent cell either to the right or downwards and cannot move into cells containing obstacles. Args: grid (List[str]): The grid of the obstacle course. R (int): Number of rows in the grid. C (int): Number of columns in the grid. Returns: int: The number of different paths from the top-left to the bottom-right corner. >>> count_paths(['...','.#.','...'], 3, 3) 2 >>> count_paths(['.#','#.'], 2, 2) 0","solution":"def count_paths(grid, R, C): if grid[0][0] == '#' or grid[R-1][C-1] == '#': return 0 dp = [[0]*C for _ in range(R)] dp[0][0] = 1 for i in range(R): for j in range(C): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[R-1][C-1] # Read input def read_input(): R, C = map(int, input().split()) grid = [input().strip() for _ in range(R)] return grid, R, C if __name__ == \\"__main__\\": grid, R, C = read_input() print(count_paths(grid, R, C))"},{"question":"def hiking_journey(n: int, m: int, trails: List[Tuple[int, int, int]]) -> int: Find the minimum possible value of the maximum difficulty rating on the path from peak 1 to peak n. Args: n (int): Number of peaks. m (int): Number of trails. trails (List[Tuple[int, int, int]]): List of trails where each trail is represented as a tuple of (u, v, d). Returns: int: The minimum possible value of the maximum difficulty rating on the path from peak 1 to peak n. >>> hiking_journey(4, 5, [(1, 2, 5), (1, 3, 6), (2, 3, 2), (2, 4, 3), (3, 4, 4)]) 5 >>> hiking_journey(2, 1, [(1, 2, 1)]) 1 >>> hiking_journey(3, 3, [(1, 2, 3), (2, 3, 2), (1, 3, 5)]) 3","solution":"import heapq def find_min_max_difficulty(n, m, trails): def dijkstra(src, des, adj_list): max_difficulty = [float('inf')] * (n + 1) max_difficulty[src] = 0 pq = [(0, src)] while pq: curr_difficulty, u = heapq.heappop(pq) for v, d in adj_list[u]: max_difficulty_on_path = max(curr_difficulty, d) if max_difficulty_on_path < max_difficulty[v]: max_difficulty[v] = max_difficulty_on_path heapq.heappush(pq, (max_difficulty_on_path, v)) return max_difficulty[des] adj_list = [[] for _ in range(n + 1)] for u, v, d in trails: adj_list[u].append((v, d)) adj_list[v].append((u, d)) return dijkstra(1, n, adj_list) def hiking_journey(n, m, trails): return find_min_max_difficulty(n, m, trails)"},{"question":"def find_most_logged_hours(log_entries: List[str]) -> Tuple[str, str]: Find the project with the most total logged hours and the employee with the most total logged hours. >>> find_most_logged_hours([\\"emp1 projA 4\\", \\"emp2 projB 5\\", \\"emp1 projA 3\\", \\"emp3 projA 6\\", \\"emp2 projB 2\\"]) (\\"projA\\", \\"emp1\\") >>> find_most_logged_hours([\\"emp1 proj1 5\\", \\"emp2 proj2 5\\", \\"emp1 proj1 2\\", \\"emp3 proj3 7\\"]) (\\"proj1\\", \\"emp1\\")","solution":"def find_most_logged_hours(log_entries): project_hours = {} employee_hours = {} for entry in log_entries: employee_id, project_id, hours = entry.split() hours = int(hours) if project_id in project_hours: project_hours[project_id] += hours else: project_hours[project_id] = hours if employee_id in employee_hours: employee_hours[employee_id] += hours else: employee_hours[employee_id] = hours # Find project with most total hours max_project_hours = max(project_hours.values()) most_logged_project = None for project_id, hours in project_hours.items(): if hours == max_project_hours: most_logged_project = project_id break # Find employee with most total hours max_employee_hours = max(employee_hours.values()) most_logged_employee = None for employee_id, hours in employee_hours.items(): if hours == max_employee_hours: most_logged_employee = employee_id break return most_logged_project, most_logged_employee"},{"question":"from typing import List def arrangeArray(arr: List[int]) -> List[int]: Arranges the numbers in the array such that the difference between any adjacent pair is minimized. Returns the lexicographically smallest sequence if there are multiple answers. >>> arrangeArray([4, 2, 1, 3]) [1, 2, 3, 4] >>> arrangeArray([4, 3, 2, 2]) [2, 2, 3, 4] pass def test_example1(): arr = [4, 2, 1, 3] assert arrangeArray(arr) == [1, 2, 3, 4] def test_example2(): arr = [4, 3, 2, 2] assert arrangeArray(arr) == [2, 2, 3, 4] def test_single_element(): arr = [1] assert arrangeArray(arr) == [1] def test_all_same_elements(): arr = [4, 4, 4, 4] assert arrangeArray(arr) == [4, 4, 4, 4] def test_negative_elements(): arr = [-2, -5, -3, -4] assert arrangeArray(arr) == [-5, -4, -3, -2] def test_mixed_elements(): arr = [3, -1, 2, -2, 0] assert arrangeArray(arr) == [-2, -1, 0, 2, 3] def test_large_numbers(): arr = [1000000000, -1000000000, 0] assert arrangeArray(arr) == [-1000000000, 0, 1000000000]","solution":"def arrangeArray(arr): Arranges the numbers in the array such that the difference between any adjacent pair is minimized. Returns the lexicographically smallest sequence if there are multiple answers. return sorted(arr)"},{"question":"def max_energy(n: int, energies: List[int]) -> int: Returns the maximum energy that can be gathered by any participant starting from any house and running to any other house. >>> max_energy(5, [1, 3, 5, 4, 2]) 15 >>> max_energy(3, [10, 20, 30]) 60","solution":"def max_energy(n, energies): Returns the maximum energy that can be gathered by any participant starting from any house and running to any other house. # Since the houses are in a circular arrangement, the maximum energy is simply the sum of all energies. return sum(energies)"},{"question":"def remove_vowels(s: str) -> str: Remove all vowels from the input string. >>> remove_vowels(\\"aeiou\\") \\"\\" >>> remove_vowels(\\"AEIOU\\") \\"\\" >>> remove_vowels(\\"bcdfg\\") \\"bcdfg\\" >>> remove_vowels(\\"Hello World\\") \\"Hll Wrld\\" >>> remove_vowels(\\"\\") \\"\\" >>> remove_vowels(\\"Python 3.8\\") \\"Pythn 3.8\\"","solution":"def remove_vowels(s): Removes all vowels from the input string s. vowels = \\"aeiouAEIOU\\" return ''.join([char for char in s if char not in vowels])"},{"question":"def smallest_rotation(s: str) -> str: Returns the lexicographically smallest rotation of the given string s. def process_rotations(test_cases: List[str]) -> List[str]: Process each test case and return the results. Args: test_cases: list of strings. Returns: list of strings - lexicographically smallest rotations for each input string.","solution":"def smallest_rotation(s): Returns the lexicographically smallest rotation of the given string s. n = len(s) s = s + s # Concatenate string to itself for easy rotations min_rotation = s[:n] # Initial rotation for i in range(1, n): rotation = s[i:i+n] if rotation < min_rotation: min_rotation = rotation return min_rotation def process_rotations(test_cases): Process each test case and return the results. Args: test_cases: list of strings. Returns: list of strings - lexicographically smallest rotations for each input string. results = [] for s in test_cases: results.append(smallest_rotation(s)) return results"},{"question":"def is_valid_parentheses(expression: str) -> bool: Determines if the input string contains valid sets of parentheses. Each opening parenthesis has a corresponding closing parenthesis of the same type, and parentheses close in the correct order. :param expression: A string containing any characters :return: True if the string has valid parentheses, otherwise False >>> is_valid_parentheses(\\"a + b - (c * d)\\") True >>> is_valid_parentheses(\\"a + b - {c * (d] }\\") False >>> is_valid_parentheses(\\"[{(a + b) * (c + d)} - e]\\") True","solution":"def is_valid_parentheses(expression): Determines if the input string contains valid sets of parentheses. :param expression: A string containing any characters :return: True if the string has valid parentheses, otherwise False stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in expression: if char in matching_parentheses.values(): # opening brackets stack.append(char) elif char in matching_parentheses.keys(): # closing brackets if stack == [] or matching_parentheses[char] != stack.pop(): return False return stack == []"},{"question":"from typing import List, Tuple def find_anagram_groups(n: int, test_cases: List[Tuple[int, List[str]]]) -> List[List[List[str]]]: Process a list of test cases to find anagram groups. Args: n (int): Number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of tuples, each representing a test case. Each tuple contains an integer k and a list of k strings. Returns: List[List[List[str]]]: A list of lists, where each sublist represents the anagram groups for a test case. Example: >>> input_data = [(5, [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\"]), (3, [\\"cat\\", \\"dog\\", \\"tac\\"])] >>> find_anagram_groups(2, input_data) [[[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"]], [[\\"cat\\", \\"tac\\"], [\\"dog\\"]]]","solution":"def find_anagram_groups(n, test_cases): def group_anagrams(words): anagram_dict = {} for word in words: sorted_word = ''.join(sorted(word)) if sorted_word in anagram_dict: anagram_dict[sorted_word].append(word) else: anagram_dict[sorted_word] = [word] return list(anagram_dict.values()) result = [] for case in test_cases: k, strings = case anagram_groups = group_anagrams(strings) result.append(anagram_groups) return result"},{"question":"def findRepeat(s: str) -> int: Finds the first smallest unique character that repeats consecutively in the substring up to the first non-digit character. :param s: The input string containing digits and a single non-digit character :return: The first smallest unique character that repeats consecutively or None if no such character exists Examples: >>> findRepeat(\\"2314555x42\\") 5 >>> findRepeat(\\"7643111a987\\") 1 >>> findRepeat(\\"282828b123\\") None","solution":"def findRepeat(s): Finds the first smallest unique character that repeats consecutively in the substring up to the first non-digit character. substring = \\"\\" # Get the substring up to the first non-digit character for char in s: if char.isdigit(): substring += char else: break # Find the first smallest unique character that repeats consecutively for i in range(len(substring) - 1): if substring[i] == substring[i + 1]: return int(substring[i]) return None"},{"question":"from typing import List def find_substring_indices(s: str, substring: str) -> List[int]: Write a function \`find_substring_indices(s: str, substring: str) -> List[int]\` that takes a string \`s\` and a substring \`substring\`, and returns a list of all starting indices where the given substring is found within \`s\`. If the substring is not found, return an empty list. >>> find_substring_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_substring_indices(\\"hello world\\", \\"l\\") [2, 3, 9] >>> find_substring_indices(\\"test\\", \\"xyz\\") [] >>> find_substring_indices(\\"\\", \\"a\\") [] >>> find_substring_indices(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] from solution import find_substring_indices def test_find_substring_indices_single_occurrence(): assert find_substring_indices(\\"abracadabra\\", \\"abra\\") == [0, 7] def test_find_substring_indices_multiple_occurrences(): assert find_substring_indices(\\"hello world\\", \\"l\\") == [2, 3, 9] def test_find_substring_indices_not_found(): assert find_substring_indices(\\"test\\", \\"xyz\\") == [] def test_find_substring_indices_empty_string(): assert find_substring_indices(\\"\\", \\"a\\") == [] def test_find_substring_indices_overlapping_occurrences(): assert find_substring_indices(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] def test_find_substring_indices_entire_string(): assert find_substring_indices(\\"aaaaa\\", \\"aaaaa\\") == [0] def test_find_substring_indices_substring_longer_than_string(): assert find_substring_indices(\\"short\\", \\"longer\\") == [] def test_find_substring_indices_one_character_string(): assert find_substring_indices(\\"a\\", \\"a\\") == [0] assert find_substring_indices(\\"a\\", \\"b\\") == []","solution":"from typing import List def find_substring_indices(s: str, substring: str) -> List[int]: Returns a list of all starting indices where the substring is found within s. If the substring is not found, returns an empty list. indices = [] index = s.find(substring) while index != -1: indices.append(index) index = s.find(substring, index + 1) return indices"},{"question":"def process_inventory_operations(operations): Processes a list of inventory operations and returns the final quantities of each product, sorted by product type. Args: operations: List of strings, each representing an operation. Each operation is either \\"RECEIVE p q\\", \\"SHIP p q\\", or \\"RESET\\". (1 ≤ length of list ≤ 1000) Returns: List of tuples containing product type and its final quantity, sorted by product type. Examples: >>> process_inventory_operations([\\"RECEIVE 3 A\\", \\"RECEIVE 5 B\\", \\"SHIP 2 A\\", \\"RESET\\", \\"RECEIVE 8 A\\"]) [('A', 8)] >>> process_inventory_operations([\\"RECEIVE 10 C\\", \\"SHIP 5 C\\", \\"RECEIVE 20 B\\", \\"RESET\\", \\"RECEIVE 2 B\\", \\"SHIP 1 B\\"]) [('B', 1)]","solution":"def process_inventory_operations(operations): Processes a list of inventory operations and returns the final quantities of each product, sorted by product type. Args: operations: List of strings, each representing an operation. Returns: List of tuples containing product type and its final quantity, sorted by product type. inventory = {} for operation in operations: operation_parts = operation.split() command = operation_parts[0] if command == \\"RESET\\": inventory.clear() else: amount = int(operation_parts[1]) product = operation_parts[2] if product not in inventory: inventory[product] = 0 if command == \\"RECEIVE\\": inventory[product] += amount elif command == \\"SHIP\\": inventory[product] -= amount sorted_inventory = sorted(inventory.items()) return sorted_inventory"},{"question":"def min_rotations_to_unlock(n, initial_combination, target_combination): Returns the minimum number of rotations needed to unlock the device. Args: n (int): Number of wheels on the lock. initial_combination (str): The initial combination of the lock. target_combination (str): The target combination to unlock the lock. Returns: int: Minimum number of rotations needed to unlock the device. >>> min_rotations_to_unlock(3, \\"123\\", \\"321\\") 4 >>> min_rotations_to_unlock(2, \\"00\\", \\"99\\") 2 >>> min_rotations_to_unlock(4, \\"1234\\", \\"1234\\") 0 >>> min_rotations_to_unlock(1, \\"0\\", \\"5\\") 5 >>> min_rotations_to_unlock(1, \\"0\\", \\"9\\") 1 pass # Replace this with your implementation","solution":"def min_rotations_to_unlock(n, initial_combination, target_combination): Returns the minimum number of rotations needed to unlock the device. def min_single_wheel_rotations(start, end): Helper function to calculate minimum rotations for a single wheel. return min(abs(start - end), 10 - abs(start - end)) rotations = 0 for i in range(n): start_digit = int(initial_combination[i]) target_digit = int(target_combination[i]) rotations += min_single_wheel_rotations(start_digit, target_digit) return rotations"},{"question":"def max_card_power(cards, k): Returns the maximum possible total power level of the selected cards. Args: cards (list of int): The power levels of the cards. k (int): The number of cards to pick. Returns: int: The maximum total power level of the selected cards. >>> max_card_power([1, 3, 5, 2, 8, 7], 3) 20 >>> max_card_power([4, 4, 4, 4], 2) 8 >>> max_card_power([10, 20, 30], 0) 0 >>> max_card_power([], 3) 0","solution":"def max_card_power(cards, k): Returns the maximum possible total power level of the selected cards. Args: cards (list of int): The power levels of the cards. k (int): The number of cards to pick. Returns: int: The maximum total power level of the selected cards. if not cards or k == 0: return 0 # Sort cards in descending order of power levels. sorted_cards = sorted(cards, reverse=True) # Pick the top k cards. return sum(sorted_cards[:k])"},{"question":"from typing import List def can_form_row(h: List[int], k: int) -> List[int]: Returns a rearranged array that represents a valid row of people or an empty array if it's not possible. >>> can_form_row([1, 3, 8, 6, 4], 2) [1, 3, 4, 6, 8] >>> can_form_row([5, 1, 9, 2], 1) []","solution":"def can_form_row(h, k): Returns a rearranged array that represents a valid row of people or an empty array if it's not possible. h.sort() for i in range(1, len(h)): if h[i] - h[i-1] > k: return [] return h # Example Testing print(can_form_row([1, 3, 8, 6, 4], 2)) print(can_form_row([5, 1, 9, 2], 1)) print(can_form_row([7, 5, 5, 5, 6], 1))"},{"question":"def longestSubarray(N: int, S: int, data: List[int]) -> int: Finds the length of the longest contiguous subarray where the sum of the elements is less than or equal to a specified value S. >>> longestSubarray(5, 10, [1, 2, 3, 4, 5]) 4 >>> longestSubarray(3, 5, [2, 2, 2]) 2 Unit Test: def test_example1(): assert longestSubarray(5, 10, [1, 2, 3, 4, 5]) == 4 def test_example2(): assert longestSubarray(3, 5, [2, 2, 2]) == 2 def test_single_element(): assert longestSubarray(1, 5, [5]) == 1 assert longestSubarray(1, 3, [5]) == 0 def test_all_elements_equal(): assert longestSubarray(4, 8, [2, 2, 2, 2]) == 4 def test_max_S_value(): assert longestSubarray(5, 1000000000, [100, 300, 700, 200, 500]) == 5 def test_end_elements_largest(): assert longestSubarray(6, 7, [1, 2, 1, 2, 1, 10]) == 5 def test_repeated_elements(): assert longestSubarray(7, 10, [2, 2, 2, 2, 2, 2, 2]) == 5 def test_empty_subarray(): assert longestSubarray(3, 1, [2, 2, 2]) == 0","solution":"def longestSubarray(N, S, data): max_len = 0 current_sum = 0 start = 0 for end in range(N): current_sum += data[end] while current_sum > S: current_sum -= data[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def ticket_price(age: int, C: int) -> int: Determines the ticket price for a given attendee based on their age. Parameters: age (int): The age of the attendee. C (int): The full ticket price (must be an even number) Returns: int: The ticket price for the attendee. >>> ticket_price(20, 200) 200 >>> ticket_price(15, 600) 300 >>> ticket_price(10, 800) 200 >>> ticket_price(5, 400) 0 >>> ticket_price(0, 1000) 0","solution":"def ticket_price(age, C): Determines the ticket price for a given attendee based on their age. Parameters: age (int): The age of the attendee. C (int): The full ticket price (must be an even number) Returns: int: The ticket price for the attendee. if age >= 18: return C elif 13 <= age <= 17: return C // 2 elif 6 <= age <= 12: return C // 4 elif 0 <= age <= 5: return 0 # Example usage: # age = 20 # C = 200 # print(ticket_price(age, C)) # Output: 200"},{"question":"from typing import List, Union class ToDoList: def __init__(self): pass def add_task(self, priority: int): pass def remove_task(self): pass def get_highest_priority_task(self) -> Union[int, str]: pass def process_operations(self, operations: List[str]) -> List[Union[int, str]]: pass def run_todo_list_operations(q: int, operations: List[str]) -> List[Union[int, str]]: Processes a list of to-do list operations. >>> run_todo_list_operations(7, [\\"1 4\\", \\"1 9\\", \\"1 2\\", \\"3\\", \\"2\\", \\"3\\", \\"2\\"]) [9, 4] >>> run_todo_list_operations(5, [\\"1 5\\", \\"1 5\\", \\"3\\", \\"2\\", \\"3\\"]) [5, 5] pass","solution":"import heapq class ToDoList: def __init__(self): self.tasks = [] self.removed = set() self.counter = 0 def add_task(self, priority): # Using negative priority because Python's heapq is min-heap by default heapq.heappush(self.tasks, (-priority, -self.counter)) self.counter += 1 def remove_task(self): while self.tasks and self.tasks[0] in self.removed: heapq.heappop(self.tasks) if self.tasks: self.removed.add(heapq.heappop(self.tasks)) def get_highest_priority_task(self): while self.tasks and self.tasks[0] in self.removed: heapq.heappop(self.tasks) if self.tasks: return -self.tasks[0][0] return 'No tasks available' def process_operations(self, operations): results = [] for operation in operations: if operation.startswith('1 '): _, priority = operation.split() self.add_task(int(priority)) elif operation == '2': self.remove_task() elif operation == '3': results.append(self.get_highest_priority_task()) return results def run_todo_list_operations(q, operations): todo_list = ToDoList() return todo_list.process_operations(operations)"},{"question":"def total_salary_increase(n, A, B, m, C, k): Calculates the total salary increase for employees in array C. :param n: int: number of employees in the company :param A: list[int]: employee ids :param B: list[int]: employee salaries :param m: int: number of employees whose salaries might be increased :param C: list[int]: employee ids of employees whose salaries are considered to be increased :param k: int: amount to increase the salary :return: int: the total increase in salary >>> total_salary_increase(4, [101, 102, 103, 104], [5000, 6000, 5500, 7000], 3, [102, 103, 105], 200) 400 >>> total_salary_increase(5, [201, 202, 203, 204, 205], [3000, 4000, 3500, 4500, 5000], 4, [202, 204, 206, 207], 150) 300 >>> total_salary_increase(3, [1, 2, 3], [1000, 2000, 3000], 2, [4, 5], 100) 0 >>> total_salary_increase(3, [1, 2, 3], [1000, 2000, 3000], 3, [1, 2, 3], 100) 300 >>> total_salary_increase(4, [101, 102, 103, 104], [5000, 6000, 5500, 7000], 3, [102, 105, 106], 200) 200","solution":"def total_salary_increase(n, A, B, m, C, k): Calculates the total salary increase for employees in array C :param n: int: number of employees in the company :param A: list[int]: employee ids :param B: list[int]: employee salaries :param m: int: number of employees whose salaries might be increased :param C: list[int]: employee ids of employees whose salaries are considered to be increased :param k: int: amount to increase the salary :return: int: the total increase in salary id_set = set(A) increase_count = sum(1 for employee_id in C if employee_id in id_set) return increase_count * k"},{"question":"def length_of_longest_substring_k_distinct(s: str, m: int) -> int: Determine the length of the longest substring of s that contains at most m distinct characters. >>> length_of_longest_substring_k_distinct(\\"abcba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aaa\\", 1) 3 >>> length_of_longest_substring_k_distinct(\\"aabacbebebe\\", 3) 7 >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aaaa\\", 1) 4 >>> length_of_longest_substring_k_distinct(\\"a\\", 1) 1 >>> length_of_longest_substring_k_distinct(\\"\\", 2) 0 >>> length_of_longest_substring_k_distinct(\\"abaccc\\", 2) 4 def process_test_cases(t: int, test_cases: List[Union[int, str]]) -> List[int]: Process multiple test cases for finding the longest substring with at most m distinct characters. >>> process_test_cases(3, [2, \\"abcba\\", 1, \\"aaa\\", 3, \\"aabacbebebe\\"]) [3, 3, 7] >>> process_test_cases(2, [2, \\"eceba\\", 1, \\"aa\\"]) [3, 2]","solution":"def length_of_longest_substring_k_distinct(s, m): from collections import defaultdict n = len(s) if n == 0 or m == 0: return 0 left, right = 0, 0 max_length = 0 char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 while len(char_count) > m: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length def process_test_cases(t, test_cases): results = [] for i in range(t): m = test_cases[i * 2] s = test_cases[i * 2 + 1] results.append(length_of_longest_substring_k_distinct(s, m)) return results"},{"question":"def find_missing_number(arr): Finds the missing number in an unsorted array containing integers from 0 to n. >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> find_missing_number([0]) 1 >>> find_missing_number([0, 1, 2, 3]) 4 >>> find_missing_number(list(range(100000)).remove(45678)) 45678","solution":"def find_missing_number(arr): Finds the missing number in an unsorted array containing integers from 0 to n. n = len(arr) total_sum = n * (n + 1) / 2 array_sum = sum(arr) return int(total_sum - array_sum)"},{"question":"def networkAnalysis(N, M, edges, start): Find the shortest path from the start node to all other nodes in a directed network. Args: N (int): Number of nodes. M (int): Number of directed edges. edges (List[List[int]]): A 2-D list where each element is a list [u, v, w] representing a directed edge from node \`u\` to node \`v\` with a weight \`w\`. start (int): The starting node. Returns: List[int]: A list of integers where the integer at index i represents the shortest time required to reach node \`i\` from the start node. If a node is not reachable from the start node, the corresponding entry should be -1. Examples: >>> networkAnalysis(5, 6, [[0, 1, 2], [0, 2, 4], [1, 2, 1], [1, 3, 7], [2, 4, 3], [3, 4, 1]], 0) [0, 2, 3, 9, 6] >>> networkAnalysis(3, 2, [[0, 1, 10], [1, 2, 5]], 0) [0, 10, 15]","solution":"import heapq def networkAnalysis(N, M, edges, start): # Initialize the graph from edges graph = {i: [] for i in range(N)} for u, v, w in edges: graph[u].append((v, w)) # Initialize distances with infinity and set distance to start node as 0 distances = [float('inf')] * N distances[start] = 0 # Use a priority queue to store nodes to be processed pq = [(0, start)] # (distance, node) while pq: curr_dist, u = heapq.heappop(pq) if curr_dist > distances[u]: continue for v, weight in graph[u]: distance = curr_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return [d if d != float('inf') else -1 for d in distances]"},{"question":"def count_palindromic_numbers(a: int, b: int) -> int: Returns the count of palindromic numbers in the inclusive range [a, b]. >>> count_palindromic_numbers(1, 100) 18 >>> count_palindromic_numbers(100, 200) 10","solution":"def count_palindromic_numbers(a, b): Returns the count of palindromic numbers in the inclusive range [a, b]. def is_palindromic(n): s = str(n) return s == s[::-1] count = 0 for num in range(a, b + 1): if is_palindromic(num): count += 1 return count"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\"dvdf\\") 3 >>> longest_substring_without_repeating_characters(\\"a\\") 1 >>> longest_substring_without_repeating_characters(\\"\\") 0","solution":"def longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_map = {} left = 0 max_length = 0 for right in range(n): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def num_paths(n, m, k, blocked_cells): Determine the number of ways to reach the bottom-right corner from the top-left corner in an n x m grid with some blocked cells. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of blocked cells. blocked_cells (list of tuples): List containing tuples of blocked cell positions. Returns: int: Number of unique paths from top-left to bottom-right corner. Here are some examples to illustrate functionality: >>> num_paths(3, 3, 0, []) 6 >>> num_paths(3, 3, 1, [(2, 2)]) 2 >>> num_paths(3, 3, 3, [(2, 2), (2, 1), (1, 2)]) 0 # Write your code here from solution import num_paths def test_no_blocked_cells(): assert num_paths(3, 3, 0, []) == 6 assert num_paths(2, 2, 0, []) == 2 assert num_paths(1, 1, 0, []) == 1 def test_single_blocked_cell(): assert num_paths(3, 3, 1, [(2, 2)]) == 2 assert num_paths(3, 3, 1, [(1, 2)]) == 3 assert num_paths(3, 3, 1, [(2, 3)]) == 3 def test_multiple_blocked_cells(): assert num_paths(4, 4, 2, [(2, 2), (3, 3)]) == 4 assert num_paths(4, 4, 3, [(2, 2), (3, 3), (2, 3)]) == 3 def test_path_completely_blocked(): assert num_paths(3, 3, 3, [(2, 2), (2, 1), (1, 2)]) == 0 assert num_paths(2, 2, 2, [(1, 2), (2, 1)]) == 0","solution":"def num_paths(n, m, k, blocked_cells): Determine the number of ways to reach the bottom-right corner from the top-left corner in an n x m grid with some blocked cells. # Initialize a grid with zeros grid = [[0] * m for _ in range(n)] # Mark blocked cells in the grid for r, c in blocked_cells: grid[r-1][c-1] = -1 # Start position if grid[0][0] == -1: return 0 grid[0][0] = 1 # Fill the grid with number of ways to reach each cell for i in range(n): for j in range(m): if grid[i][j] == -1: continue # skip blocked cells if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] return grid[n-1][m-1] # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n, m, k = map(int, data[:3]) blocked_cells = [] for i in range(3, 3 + 2*k, 2): blocked_cells.append((int(data[i]), int(data[i+1]))) print(num_paths(n, m, k, blocked_cells))"},{"question":"def is_happy_string(s: str) -> bool: Determine if the string s is a happy string. A happy string is defined as a string where no two adjacent characters are the same. :param s: Input string consisting of lowercase letters :return: True if the input string is a happy string, False otherwise >>> is_happy_string(\\"abc\\") True >>> is_happy_string(\\"happy\\") False >>> is_happy_string(\\"aab\\") False >>> is_happy_string(\\"baza\\") True from solution import is_happy_string def test_happy_string(): assert is_happy_string(\\"abc\\") == True assert is_happy_string(\\"baza\\") == True def test_unhappy_string(): assert is_happy_string(\\"happy\\") == False assert is_happy_string(\\"aab\\") == False def test_single_character(): assert is_happy_string(\\"a\\") == True def test_empty_string(): assert is_happy_string(\\"\\") == True def test_repeating_characters(): assert is_happy_string(\\"aa\\") == False assert is_happy_string(\\"hhh\\") == False def test_alternating_characters(): assert is_happy_string(\\"ababab\\") == True assert is_happy_string(\\"xyxyxy\\") == True def test_edge_case(): assert is_happy_string(\\"ab\\"*100000) == True assert is_happy_string(\\"aa\\"*100000) == False","solution":"def is_happy_string(s): Determine if the string s is a happy string. A happy string is defined as a string where no two adjacent characters are the same. :param s: Input string consisting of lowercase letters :return: True if the input string is a happy string, False otherwise for i in range(len(s) - 1): if s[i] == s[i + 1]: return False return True"},{"question":"from collections import Counter def can_form_palindrome(s: str) -> str: Determine if a string can be rearranged to form a palindrome. Args: s: A string with 1 ≤ |s| ≤ 100,000. Returns: 'YES' if the characters of the string can be rearranged to form a palindrome, otherwise 'NO'. Examples: >>> can_form_palindrome('aabb') 'YES' >>> can_form_palindrome('abc') 'NO'","solution":"from collections import Counter def can_form_palindrome(s): Determine if the string can be rearranged to form a palindrome. # Count the frequency of each character in the string freq = Counter(s) # Count the number of characters with an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged to a palindrome if it has at most one character with an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def update_participants(n: int, q: int, participants: List[int], updates: List[Tuple[int, int, int]]) -> List[int]: Handle updates to the number of participants at marathon checkpoints. Args: n (int): The number of checkpoints. q (int): The number of updates. participants (List[int]): The initial number of participants at each checkpoint. updates (List[Tuple[int, int, int]]): The list of updates. Each update is a tuple (op, i, x) where \\"1 i x\\" means \`x\` participants join at checkpoint \`i\`, and \\"2 i x\\" means \`x\` participants withdraw from checkpoint \`i\`. Returns: List[int]: The number of participants at the specified checkpoint after each update. >>> update_participants(5, 6, [10, 20, 30, 40, 50], [(1, 3, 5), (2, 2, 10), (1, 5, 20), (2, 4, 15), (1, 1, 10), (2, 3, 10)]) [35, 10, 70, 25, 20, 25] >>> update_participants(4, 4, [1, 2, 3, 4], [(1, 1, 1), (1, 2, 2), (1, 3, 3), (1, 4, 4)]) [2, 4, 6, 8] >>> update_participants(3, 3, [10, 20, 30], [(2, 1, 5), (2, 2, 10), (2, 3, 15)]) [5, 10, 15] >>> update_participants(3, 4, [10, 10, 10], [(1, 1, 5), (2, 2, 3), (1, 3, 7), (2, 1, 10)]) [15, 7, 17, 5] >>> update_participants(1, 1, [100], [(2, 1, 50)]) [50]","solution":"def update_participants(n, q, participants, updates): result = [] for update in updates: op, i, x = update if op == 1: participants[i-1] += x elif op == 2: participants[i-1] -= x result.append(participants[i-1]) return result"},{"question":"def find_max_availability(n: int, schedules: List[List[int]]) -> Tuple[int, int]: Determine the day and time slot with the maximum number of available employees. Args: n (int): The number of employees. schedules (List[List[int]]): A list of availability schedules for each employee. Each schedule consists of sets of [day, start, end]. Returns: Tuple[int, int]: The day of the week and the starting hour of the time slot with the maximum number of available employees. >>> find_max_availability(3, [[0, 9, 17], [1, 12, 15], [0, 10, 18, 2, 14, 20]]) (0, 10) >>> find_max_availability(2, [[0, 8, 12], [0, 10, 14]]) (0, 10) >>> find_max_availability(4, [[5, 8, 20], [6, 12, 16], [5, 9, 11], [5, 10, 12]]) (5, 10) >>> find_max_availability(1, [[0, 0, 24]]) (0, 0) pass","solution":"def find_max_availability(n, schedules): availability = [[0] * 24 for _ in range(7)] for schedule in schedules: i = 0 while i < len(schedule): day, start, end = schedule[i], schedule[i + 1], schedule[i + 2] for hour in range(start, end): availability[day][hour] += 1 i += 3 max_available = 0 best_day = 0 best_hour = 0 for day in range(7): for hour in range(24): if availability[day][hour] > max_available: max_available = availability[day][hour] best_day = day best_hour = hour return best_day, best_hour"},{"question":"def min_cut_cost(n, l, rod_lengths, c): Returns the minimum cost to cut all the rods to the maximum allowed length. n: number of rods l: maximum allowed length of each piece rod_lengths: list of rod lengths c: fixed cost per cut >>> min_cut_cost(3, 3, [9, 15, 12], 2) 18 >>> min_cut_cost(2, 10, [20, 5], 5) 5 >>> min_cut_cost(2, 15, [10, 5], 3) 0 >>> min_cut_cost(3, 4, [7, 8, 5], 1) 3 >>> min_cut_cost(1, 10, [30], 100) 200","solution":"def min_cut_cost(n, l, rod_lengths, c): Returns the minimum cost to cut all the rods to the maximum allowed length. n: number of rods l: maximum allowed length of each piece rod_lengths: list of rod lengths c: fixed cost per cut total_cost = 0 for rod in rod_lengths: if rod > l: cuts_needed = (rod - 1) // l # Using (rod - 1) to avoid extra cut if perfectly divisible total_cost += cuts_needed * c return total_cost"},{"question":"def is_yummy(recipe_book): Determine whether each string in the recipe book is \\"yummy\\" or not. A string is called \\"yummy\\" if it contains the substring \\"chef\\" at least once. >>> is_yummy([\\"chefisgreat\\", \\"ilovechefcooking\\", \\"chef\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> is_yummy([\\"greatday\\", \\"hello\\", \\"world\\"]) [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def is_yummy(recipe_book): results = [] for s in recipe_book: if 'chef' in s: results.append('YES') else: results.append('NO') return results def process_input(N, strings): return is_yummy(strings) # Example usage: # N = 3 # recipe_book = [\\"chefisgreat\\", \\"ilovechefcooking\\", \\"greatday\\"] # print(process_input(N, recipe_book)) # ['YES', 'YES', 'NO']"},{"question":"def max_height_difference(n, heights): Returns the maximum difference between heights of any two trees where the shorter tree is to the left of the taller tree. >>> max_height_difference(5, [1, 2, 6, 4, 8]) == 7 >>> max_height_difference(5, [5, 5, 5, 5, 5]) == 0 >>> max_height_difference(1, [5]) == 0 >>> max_height_difference(2, [2, 10]) == 8 >>> max_height_difference(2, [10, 2]) == 0 >>> max_height_difference(4, [1, 2, 3, 4]) == 3 >>> max_height_difference(4, [4, 3, 2, 1]) == 0 >>> max_height_difference(8, [10, 1, 3, 7, 6, 13, 5, 13]) == 12 >>> max_height_difference(5, [3, 3, 3, 3, 5]) == 2","solution":"def max_height_difference(n, heights): Returns the maximum difference between heights of any two trees where the shorter tree is to the left of the taller tree. if n < 2: return 0 min_height = heights[0] max_diff = 0 for i in range(1, n): if heights[i] > min_height: max_diff = max(max_diff, heights[i] - min_height) min_height = min(min_height, heights[i]) return max_diff"},{"question":"def findSecondLargest(arr): Returns the second largest element in the array. If the second largest doesn't exist, return -1. >>> findSecondLargest([10, 5, 8, 3, 12]) 10 >>> findSecondLargest([7, 7, 7]) -1 >>> findSecondLargest([]) -1 >>> findSecondLargest([5]) -1 >>> findSecondLargest([1, 3, 4, 2, 5, 5, 4]) 4 >>> findSecondLargest([1, 2, 3, 4, 4, 4]) 3 >>> findSecondLargest([1, 1, 1, 2, 2, 2, 3, 3, 3]) 2 >>> findSecondLargest([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 9 >>> findSecondLargest([20, 20, 20, 10, 10, 10, 5, 5, 5]) 10","solution":"def findSecondLargest(arr): Returns the second largest element in the array. If the second largest doesn't exist, return -1. if len(arr) < 2: return -1 first = second = float('-inf') for number in arr: if number > first: second = first first = number elif number > second and number != first: second = number return second if second != float('-inf') else -1"},{"question":"def shortest_path_in_labyrinth(N: int, M: int, grid: List[str], start: Tuple[int, int], treasure: Tuple[int, int]) -> int: Determine if there is a path from the starting position to the treasure that only passes through empty cells. >>> shortest_path_in_labyrinth(5, 5, [\\".....\\", \\".#.#.\\", \\".#.#.\\", \\".#...\\", \\"...#.\\"], (0, 0), (4, 4)) 8 >>> shortest_path_in_labyrinth(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"], (0, 0), (2, 2)) -1","solution":"from collections import deque def shortest_path_in_labyrinth(N, M, grid, start, treasure): x1, y1 = start x2, y2 = treasure if grid[x1][y1] == '#' or grid[x2][y2] == '#': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False] * M for _ in range(N)] queue = deque([(x1, y1, 0)]) # Store (x, y, distance) visited[x1][y1] = True while queue: x, y, dist = queue.popleft() if (x, y) == (x2, y2): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def highest_average_student(students): Given a list of dictionaries, where each dictionary represents a student and contains their name and test scores in various subjects, calculates and returns the name of the student with the highest average score. If multiple students have the highest average score, return the name of the student who appears first in the list. >>> highest_average_student([ {\\"name\\": \\"Alice\\", \\"scores\\": {\\"Math\\": 90, \\"English\\": 80, \\"Science\\": 70}}, {\\"name\\": \\"Bob\\", \\"scores\\": {\\"Math\\": 80, \\"English\\": 70, \\"Science\\": 80}}, {\\"name\\": \\"Charlie\\", \\"scores\\": {\\"Math\\": 90, \\"English\\": 90, \\"Science\\": 90}} ]) \\"Charlie\\" >>> highest_average_student([ {\\"name\\": \\"Anna\\", \\"scores\\": {\\"Math\\": 85, \\"English\\": 95, \\"History\\": 90}}, {\\"name\\": \\"Elsa\\", \\"scores\\": {\\"Math\\": 80, \\"English\\": 90, \\"History\\": 85}}, {\\"name\\": \\"Mia\\", \\"scores\\": {\\"Math\\": 85, \\"English\\": 95, \\"History\\": 90}} ]) \\"Anna\\"","solution":"def highest_average_student(students): highest_avg = -1 top_student = \\"\\" for student in students: scores = student['scores'].values() avg_score = sum(scores) / len(scores) if avg_score > highest_avg: highest_avg = avg_score top_student = student['name'] return top_student"},{"question":"from typing import List def sort_digits_in_string(s: str) -> str: Given a string containing both letters and digits, return a new string where the digits are sorted in ascending order and the letters remain in their original positions. >>> sort_digits_in_string(\\"a3b2c1e\\") == \\"a1b2c3e\\" >>> sort_digits_in_string(\\"5a1b3c2\\") == \\"1a2b3c5\\" >>> sort_digits_in_string(\\"abc\\") == \\"abc\\" >>> sort_digits_in_string(\\"4A3b2C1\\") == \\"1A2b3C4\\" :param s: string containing both letters and digits :return: string with sorted digits and original letters' positions","solution":"def sort_digits_in_string(s): Returns a string with digits sorted in ascending order and letters in their original positions. digits = sorted([char for char in s if char.isdigit()]) result = [] digit_index = 0 for char in s: if char.isdigit(): result.append(digits[digit_index]) digit_index += 1 else: result.append(char) return ''.join(result)"},{"question":"def max_water_distribution(N: int, reservoir_capacities: List[int], pipelines: List[Tuple[int, int, int]]) -> int: Determine the maximum amount of water that can be distributed from reservoir 1 to reservoir N considering both the reservoir capacities and the pipeline limits. Args: N : int : the number of reservoirs reservoir_capacities : List[int] : a list of integers indicating the maximum capacity of each reservoir pipelines : List[Tuple[int, int, int]] : a list of tuples representing the pipelines, each tuple contains three integers indicating the endpoints and the capacity of the pipeline Returns: int : the maximum amount of water that can be distributed from reservoir 1 to reservoir N Examples: >>> max_water_distribution(5, [10, 20, 30, 40, 50], [(1, 2, 15), (2, 3, 10), (3, 4, 25), (4, 5, 20)]) 10 >>> max_water_distribution(4, [50, 60, 70, 80], [(1, 2, 100), (2, 3, 100), (3, 4, 50)]) 50 pass","solution":"def max_water_distribution(N, reservoir_capacities, pipelines): from collections import defaultdict import heapq # Create an adjacency list for the graph graph = defaultdict(list) for u, v, c in pipelines: graph[u].append((v, c)) graph[v].append((u, c)) # Dijkstra-like algorithm to find the minimum capacity in the path from 1 to N def dijkstra(source, destination): # Priority queue for BFS pq = [(-reservoir_capacities[source-1], source)] # Minimum pipeline capacity to each node min_capacity = {i: float('-inf') for i in range(1, N+1)} min_capacity[source] = reservoir_capacities[source-1] while pq: cur_cap, u = heapq.heappop(pq) cur_cap = -cur_cap if u == destination: return cur_cap for v, cap in graph[u]: flow_cap = min(cur_cap, cap, reservoir_capacities[v-1]) if flow_cap > min_capacity[v]: min_capacity[v] = flow_cap heapq.heappush(pq, (-flow_cap, v)) return 0 # If no path found return dijkstra(1, N) # Example Usage N = 5 reservoir_capacities = [10, 20, 30, 40, 50] pipelines = [ (1, 2, 15), (2, 3, 10), (3, 4, 25), (4, 5, 20) ] print(max_water_distribution(N, reservoir_capacities, pipelines)) # Output: 10"},{"question":"def can_borrow_books(n: int, m: int, book_list: List[int]) -> str: Determines if all residents can borrow their desired list of books following given rules. Parameters: n (int): Number of residents. m (int): Maximum number of books each resident can hold at any time. book_list (list of int): Desired books for each resident in order. Returns: str: \\"YES\\" if all residents can follow the borrowing rules, otherwise \\"NO\\". >>> can_borrow_books(5, 2, [3, 2, 3, 2, 1]) \\"NO\\" >>> can_borrow_books(4, 3, [1, 2, 3, 4]) \\"YES\\" >>> can_borrow_books(7, 1, [5, 4, 3, 2, 1, 6, 7]) \\"YES\\"","solution":"def can_borrow_books(n, m, book_list): Determines if all residents can borrow their desired list of books following given rules. Parameters: n (int): Number of residents. m (int): Maximum number of books each resident can hold at any time. book_list (list of int): Desired books for each resident in order. Returns: str: \\"YES\\" if all residents can follow the borrowing rules, otherwise \\"NO\\". borrowed_books = {} current_books = 0 for book in book_list: if book in borrowed_books: # If the book is already borrowed, that's a problem return \\"NO\\" if current_books < m: # If the resident can borrow more books borrowed_books[book] = True current_books += 1 else: # If the resident needs to return a book before borrowing if book_list[-m] in borrowed_books: del borrowed_books[book_list[-m]] borrowed_books[book] = True return \\"YES\\""},{"question":"def minimum_paintings_to_remove(n: int, years: List[int]) -> int: Determines the minimum number of paintings that must be removed to achieve strictly increasing order of painting creation years. >>> minimum_paintings_to_remove(7, [1985, 1985, 1990, 1992, 1992, 1992, 2001]) == 3 >>> minimum_paintings_to_remove(0, []) == 0 >>> minimum_paintings_to_remove(5, [1985, 1990, 1992, 2001, 2020]) == 0 >>> minimum_paintings_to_remove(5, [1985, 1985, 1985, 1985, 1985]) == 4 >>> minimum_paintings_to_remove(10, [1990, 1985, 1990, 1992, 1985, 2001, 2001, 1990, 1985, 1992]) == 6","solution":"def minimum_paintings_to_remove(n, years): Determines the minimum number of paintings that must be removed to achieve strictly increasing order of painting creation years. Parameters: n (int): The number of paintings. years (list of int): The list of creation years of the paintings. Returns: int: Minimum number of paintings to remove. if n == 0: return 0 # Calculate the length of strictly increasing subsequence unique_years = sorted(set(years)) # The number of paintings to remove is the total count of paintings # minus the count of paintings in the longest increasing subsequence return n - len(unique_years)"},{"question":"def max_path_sum(grid): Returns the maximum sum of numbers collected starting from the top-left corner to the bottom-right corner of the grid, where you can only move either down or right. >>> max_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_path_sum([[1, 2], [3, 4]]) 8 >>> max_path_sum([[5]]) 5 >>> max_path_sum([[1, 2, 3, 4]]) 10 >>> max_path_sum([[1], [2], [3], [4]]) 10 >>> max_path_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29","solution":"def max_path_sum(grid): Returns the maximum sum of numbers collected starting from the top-left corner to the bottom-right corner of the grid, where you can only move either down or right. m = len(grid) n = len(grid[0]) # Create a 2D dp array to store the maximum path sums dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def count_stones_in_grid(T, test_cases): Counts the total number of 1s (stones) in the given grids. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains an integer N and a list of N lists representing the grid. Returns: list: List of integers representing the total number of stones in each grid.","solution":"def count_stones_in_grid(T, test_cases): Counts the total number of 1s (stones) in the given grids. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains an integer N and a list of N lists representing the grid. Returns: list: List of integers representing the total number of stones in each grid. results = [] for N, grid in test_cases: stone_count = sum(sum(row) for row in grid) results.append(stone_count) return results"},{"question":"def isPowerOfFour(N: int) -> int: Determines if a number is a power of 4. If it is, returns the exponent k such that 4^k = N. Otherwise, returns -1. >>> isPowerOfFour(16) 2 >>> isPowerOfFour(15) -1","solution":"def isPowerOfFour(N): Determines if a number is a power of 4. Arguments: N -- the number to check (integer) Returns: The exponent k such that 4^k = N if N is a power of 4, otherwise -1. if N <= 0: return -1 k = 0 while N % 4 == 0: N //= 4 k += 1 return k if N == 1 else -1"},{"question":"from typing import List def find_peak_element(nums: List[int]) -> int: Write a function that takes an array of integers and returns the index of the first peak element. A peak element is an element that is strictly greater than its neighbors. For the elements at the edges of the array, we only consider one neighbor. If multiple peak elements exist, return the index of the first one. If no peak element exists, return -1. :param nums: List[int] :return: int >>> find_peak_element([1]) == 0 >>> find_peak_element([1, 1, 1, 1]) == -1 >>> find_peak_element([3, 1, 2]) == 0 >>> find_peak_element([1, 2, 3]) == 2 >>> find_peak_element([1, 3, 2]) == 1 >>> find_peak_element([1, 3, 2, 3, 1]) == 1 >>> find_peak_element([1, 2, 3, 4, 5]) == 4 >>> find_peak_element([5, 4, 3, 2, 1]) == 0 >>> find_peak_element([10, 20, 15, 25, 30, 5, 40, 50]) == 1 >>> find_peak_element([]) == -1","solution":"def find_peak_element(nums): Returns the index of the first peak element in the array of integers. A peak element is an element that is strictly greater than its neighbors. :param nums: List[int] :return: int if not nums: return -1 n = len(nums) if n == 1: return 0 for i in range(n): if i == 0: if nums[i] > nums[i + 1]: return i elif i == n - 1: if nums[i] > nums[i - 1]: return i else: if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: return i return -1"},{"question":"def can_rearrange(nums: List[int]) -> str: Determine if the array can be rearranged such that the absolute difference between any two consecutive integers is 1. >>> can_rearrange([1, 3, 2, 4, 5]) 'Yesn1 2 3 4 5' >>> can_rearrange([1, 3, 5, 7]) 'No' from typing import List","solution":"def can_rearrange(nums): nums.sort() for i in range(1, len(nums)): if abs(nums[i] - nums[i-1]) != 1: return \\"No\\" return f\\"Yesn{' '.join(map(str, nums))}\\""},{"question":"def min_operations_to_equalize_heights(N, heights): Calculate the minimum number of operations required to make all elements in the array equal by either increasing or decreasing the value by 1. Parameters: N (int): Number of elements in the heights array heights (list of int): List of heights Returns: int: Minimum number of operations Examples: >>> min_operations_to_equalize_heights(3, [3, 3, 3]) 0 >>> min_operations_to_equalize_heights(5, [1, 2, 3, 4, 5]) 6","solution":"def min_operations_to_equalize_heights(N, heights): Calculate the minimum number of operations required to make all elements in the array equal by either increasing or decreasing the value by 1. Parameters: N (int): Number of elements in the heights array heights (list of int): List of heights Returns: int: Minimum number of operations median_height = sorted(heights)[N // 2] operations = sum(abs(height - median_height) for height in heights) return operations"},{"question":"def can_form_palindrome(s: str) -> str: Determines if any permutation of the given string can be a palindrome. Args: s (str): Input string containing only lowercase alphabets. Returns: str: \\"YES\\" if any permutation can form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"a\\") \\"YES\\" >>> can_form_palindrome(\\"ab\\") \\"NO\\" >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\"","solution":"def can_form_palindrome(s): Determines if any permutation of the given string can be a palindrome. Args: s (str): Input string containing only lowercase alphabets. Returns: str: \\"YES\\" if any permutation can form a palindrome, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def is_valid_peak_pattern(n: int, sequence: List[int]) -> str: Determines if the sequence forms a valid peak pattern. The sequence first strictly increases to a peak and then strictly decreases afterwards. There should be at least one element before and after the peak. >>> is_valid_peak_pattern(7, [1, 2, 4, 5, 3, 2, 1]) == \\"YES\\" >>> is_valid_peak_pattern(5, [1, 3, 5, 4, 2]) == \\"YES\\" >>> is_valid_peak_pattern(4, [1, 2, 2, 1]) == \\"NO\\" >>> is_valid_peak_pattern(6, [6, 4, 3, 2, 1, 0]) == \\"NO\\"","solution":"def is_valid_peak_pattern(n, sequence): Determines if the sequence forms a valid peak pattern. :param n: int, number of positions in the line :param sequence: list of ints, number of stones at each position :return: str, \\"YES\\" if the sequence forms a valid peak pattern, otherwise \\"NO\\" if n < 3: return \\"NO\\" up = False down = False peak_reached = False for i in range(1, n): if sequence[i] > sequence[i-1]: if down: return \\"NO\\" up = True elif sequence[i] < sequence[i-1]: if not up: return \\"NO\\" down = True else: return \\"NO\\" if up and down: return \\"YES\\" return \\"NO\\""},{"question":"def maxBuildingIndex(heights: List[int]) -> int: Write a function that takes a list of integers where each integer represents the height of a building in a row of buildings. The goal is to find the index of the building that has the maximum height closest to the beginning of the array. If there are multiple buildings with the same maximum height, return the index of the first occurrence. >>> maxBuildingIndex([3, 4, 1, 8, 8, 2, 7]) 3 >>> maxBuildingIndex([1, 1, 1, 1, 1, 1, 1]) 0 pass from solution import maxBuildingIndex def test_single_height(): assert maxBuildingIndex([1]) == 0 def test_all_same_height(): assert maxBuildingIndex([1, 1, 1, 1, 1, 1, 1]) == 0 def test_unique_max_height(): assert maxBuildingIndex([2, 5, 3, 5, 1]) == 1 assert maxBuildingIndex([3, 4, 1, 8, 8, 2, 7]) == 3 def test_max_height_at_beginning(): assert maxBuildingIndex([7, 7, 4, 7]) == 0 def test_max_height_at_end(): assert maxBuildingIndex([1, 2, 3, 4, 5, 10]) == 5 def test_max_height_in_middle(): assert maxBuildingIndex([1, 3, 7, 4, 2]) == 2 def test_large_set(): heights = [1] * 99999 + [1000000] assert maxBuildingIndex(heights) == 99999","solution":"def maxBuildingIndex(heights): Returns the index of the building that has the maximum height closest to the beginning of the array. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The index of the first occurrence of the building with the maximum height. max_height = max(heights) return heights.index(max_height)"},{"question":"from typing import List, Tuple def max_sum_of_k_items(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determines the maximum possible sum of values of at most k contiguous items from any one rack. Args: t (int): the number of test cases. test_cases (List[Tuple[int, int, List[int]]]): a list of tuples, each containing: - an integer n, the number of items in the rack - an integer k, the maximum number of contiguous items - a list of integers representing the values of the items in the rack Returns: List[int]: a list of integers, each representing the maximum possible sum of values of at most k contiguous items for the respective test case. >>> max_sum_of_k_items(2, [(7, 3, [10, -2, 1, 3, -1, 2, 5]), (5, 2, [4, -1, 2, 1, 5])]) [10, 6] >>> max_sum_of_k_items(1, [(1, 1, [10])]) [10] >>> max_sum_of_k_items(1, [(5, 2, [-1, -2, -3, -4, -5])]) [-1] >>> max_sum_of_k_items(1, [(5, 5, [1, 2, 3, 4, 5])]) [15] >>> max_sum_of_k_items(1, [(7, 3, [2, 3, -2, 5, -3, 2, 1])]) [6] >>> max_sum_of_k_items(1, [(10**5, 50000, [1] * 10**5)]) [50000]","solution":"def max_sum_of_k_items(t, test_cases): results = [] for test_case in test_cases: n, k, items = test_case max_sum = float('-inf') current_sum = 0 for i in range(n): current_sum += items[i] if i >= k: current_sum -= items[i - k] max_sum = max(max_sum, current_sum) results.append(max_sum) return results # Read input from the user if __name__ == \\"__main__\\": t = int(input().strip()) test_cases = [] for _ in range(t): n, k = map(int, input().strip().split()) items = list(map(int, input().strip().split())) test_cases.append((n, k, items)) results = max_sum_of_k_items(t, test_cases) for result in results: print(result)"},{"question":"def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: You are given a connected, undirected graph with n nodes and m edges. The nodes are numbered from 1 to n. Your task is to determine whether it is possible to split the nodes of the graph into two non-empty subsets such that there are no edges between the nodes within each subset. In other words, you need to determine if the graph is bipartite. If such a partition is possible, output \\"YES\\" and the two subsets. Otherwise, output \\"NO\\". Parameters: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of edges in the graph where each edge is represented as a tuple (u, v). Returns: str: \\"YES\\" if it is possible to split the nodes into two subsets such that no edges exist within each subset, along with the sizes and nodes of each subset. Otherwise, \\"NO\\". Examples: >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YESn2 2n1 3n2 4' >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) 'NO'","solution":"def is_bipartite(n, m, edges): from collections import deque # Create adjacency list adj = [[] for _ in range(n + 1)] for u, v in edges: adj[u].append(v) adj[v].append(u) # Initialize colors array, 0: uncolored, 1: color 1, -1: color 2 color = [0] * (n + 1) def bfs(start): queue = deque([start]) color[start] = 1 while queue: u = queue.popleft() for v in adj[u]: if color[v] == 0: color[v] = -color[u] queue.append(v) elif color[v] == color[u]: return False return True for i in range(1, n + 1): if color[i] == 0: if not bfs(i): return \\"NO\\" set1 = [i for i in range(1, n + 1) if color[i] == 1] set2 = [i for i in range(1, n + 1) if color[i] == -1] return f\\"YESn{len(set1)} {len(set2)}n{' '.join(map(str, set1))}n{' '.join(map(str, set2))}\\""},{"question":"def calculate_quantities(N: int, quantities: List[int], M: int, conversions: List[Tuple[int, int, int]]) -> List[Union[int, str]]: Calculate the total quantity of ingredients after applying each recipe exactly once. >>> calculate_quantities(3, [200, 300, 400], 2, [(2, 300, 150), (3, 400, 800)]) [750, 1300] >>> calculate_quantities(3, [200, 300, 400], 1, [(2, 250, 150)]) [\\"Invalid\\"] def main(): import sys input = sys.stdin.read data = input().split() index = 0 N = int(data[index]) index += 1 quantities = [] for _ in range(N): quantities.append(int(data[index])) index += 1 M = int(data[index]) index += 1 conversions = [] for _ in range(M): A = int(data[index]) B = int(data[index + 1]) C = int(data[index + 2]) conversions.append((A, B, C)) index += 3 results = calculate_quantities(N, quantities, M, conversions) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def calculate_quantities(N, quantities, M, conversions): results = [] for A, B, C in conversions: temp_quantities = quantities.copy() if temp_quantities[A - 1] == B: temp_quantities[A - 1] = C results.append(sum(temp_quantities)) else: results.append(\\"Invalid\\") return results def main(): import sys input = sys.stdin.read data = input().split() index = 0 N = int(data[index]) index += 1 quantities = [] for _ in range(N): quantities.append(int(data[index])) index += 1 M = int(data[index]) index += 1 conversions = [] for _ in range(M): A = int(data[index]) B = int(data[index + 1]) C = int(data[index + 2]) conversions.append((A, B, C)) index += 3 results = calculate_quantities(N, quantities, M, conversions) for result in results: print(result)"},{"question":"from typing import List def smallest_flower_lineup(flowers: str) -> str: Given a string of uppercase English letters representing flowers' colors, this function returns the lexicographically smallest string that can be formed while ensuring no two consecutive flowers are of the same color. pass def process_test_cases(test_cases: List[str]) -> List[str]: Given a list of test cases, each representing a string of uppercase English letters for flowers' colors, this function returns a list of the lexicographically smallest strings that can be formed for each test case while ensuring no two consecutive flowers are of the same color. pass def test_single_test_case(): assert smallest_flower_lineup(\\"BACCDBE\\") == \\"ACDE\\" assert smallest_flower_lineup(\\"ABBCCA\\") == \\"ABCA\\" assert smallest_flower_lineup(\\"ABC\\") == \\"ABC\\" assert smallest_flower_lineup(\\"\\") == \\"\\" assert smallest_flower_lineup(\\"AAAA\\") == \\"A\\" assert smallest_flower_lineup(\\"AABBAABB\\") == \\"ABAB\\" assert smallest_flower_lineup(\\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\") == \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" def test_multiple_test_cases(): test_cases = [\\"BACCDBE\\", \\"ABBCCA\\", \\"ABC\\", \\"\\", \\"AAAA\\", \\"AABBAABB\\", \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\"] expected_results = [\\"ACDE\\", \\"ABCA\\", \\"ABC\\", \\"\\", \\"A\\", \\"ABAB\\", \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\"] assert process_test_cases(test_cases) == expected_results def test_large_input(): large_test_case = \\"A\\" * 100000 # A very long string of the same character assert smallest_flower_lineup(large_test_case) == \\"A\\"","solution":"def smallest_flower_lineup(flowers): Given a string of uppercase English letters representing flowers' colors, this function returns the lexicographically smallest string that can be formed while ensuring no two consecutive flowers are of the same color. if not flowers: return \\"\\" result = [] result.append(flowers[0]) # Always pick the first flower for c in flowers[1:]: if c != result[-1]: result.append(c) return ''.join(result) def process_test_cases(test_cases): results = [smallest_flower_lineup(flowers) for flowers in test_cases] return results"},{"question":"from functools import lru_cache from typing import List, Tuple def count_x_digit_numbers_with_sum(x: int, y: int) -> int: Returns the number of available x-digit numbers whose digits sum up to y. @lru_cache(None) def count(length: int, total: int, leading: bool) -> int: if length == 0: return 1 if total == 0 else 0 if total < 0: return 0 if length == 1: if leading and 1 <= total <= 9: return 1 if not leading and 0 <= total <= 9: return 1 return 0 count_numbers = 0 for i in range(0 if not leading else 1, 10): count_numbers += count(length-1, total-i, False) return count_numbers return count(x, y, True) def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Given a list of test cases (tuples of X and Y), returns the number of valid X-digit numbers whose sum of digits equals Y for each test case. >>> solve([(2, 4), (3, 6)]) [4, 21] results = [] for x, y in test_cases: result = count_x_digit_numbers_with_sum(x, y) results.append(result) return results","solution":"from itertools import combinations_with_replacement from functools import lru_cache def count_x_digit_numbers_with_sum(x, y): Returns the number of available x-digit numbers whose digits sum up to y. @lru_cache(None) def count(length, total, leading): if length == 0: return 1 if total == 0 else 0 if total < 0: return 0 if length == 1: if leading and 1 <= total <= 9: return 1 if not leading and 0 <= total <= 9: return 1 return 0 count_numbers = 0 for i in range(0 if not leading else 1, 10): count_numbers += count(length-1, total-i, False) return count_numbers return count(x, y, True) def solve(test_cases): results = [] for x, y in test_cases: result = count_x_digit_numbers_with_sum(x, y) results.append(result) return results"},{"question":"def maximize_usefulness_score(N: int, K: int, items: List[Tuple[int, int]]) -> int: Calculate the maximum total usefulness score achievable by distributing N items into K kits such that each kit is given to one person. :param N: Integer, number of items (1 <= K <= N <= 100) :param K: Integer, number of kits/friends :param items: List of tuples, each containing the weight and usefulness score of the i-th item (weight, usefulness) :return: Integer, the maximum total usefulness score achievable >>> maximize_usefulness_score(6, 3, [(2, 10), (3, 15), (4, 20), (2, 25), (3, 30), (4, 10)]) == 110 >>> maximize_usefulness_score(1, 1, [(5, 30)]) == 30 >>> maximize_usefulness_score(4, 2, [(2, 20), (2, 20), (2, 20), (2, 20)]) == 80 >>> maximize_usefulness_score(5, 2, [(0, 5), (0, 15), (0, 25), (0, 10), (0, 20)]) == 75 >>> maximize_usefulness_score(100, 100, [(1, i+1) for i in range(100)]) == sum(range(1, 101))","solution":"def maximize_usefulness_score(N, K, items): This function calculates the maximum total usefulness score achievable by distributing N items into K kits such that each kit is given to one person. :param N: Integer, number of items (1 <= K <= N <= 100) :param K: Integer, number of kits/friends :param items: List of tuples, each containing the weight and usefulness score of the i-th item (weight, usefulness) :return: Integer, the maximum total usefulness score achievable items.sort(key=lambda x: x[1], reverse=True) # Sorting items based on usefulness score on descending order. total_score = 0 # Initialize an array to store the total weight of each kit kits_weight = [0] * K # In the sorted order, place each item in the kit with the least current total weight for weight, usefulness in items: min_idx = kits_weight.index(min(kits_weight)) kits_weight[min_idx] += weight total_score += usefulness return total_score # Example usage: N = 6 K = 3 items = [(2, 10), (3, 15), (4, 20), (2, 25), (3, 30), (4, 10)] print(maximize_usefulness_score(N, K, items)) # Output: 110"},{"question":"def check_supply(num_passengers, available_meals, available_drinks): Determines if there are enough meals and drinks for all passengers. Parameters: - num_passengers (int): The number of passengers on the flight. - available_meals (int): The number of meals available. - available_drinks (int): The number of drinks available. Returns: - str: A string indicating the supply status. # Your code here if __name__ == \\"__main__\\": # Test cases print(check_supply(100, 100, 100)) # \\"All set!\\" print(check_supply(100, 80, 120)) # \\"Not enough meals!\\" print(check_supply(100, 120, 80)) # \\"Not enough drinks!\\" print(check_supply(100, 80, 80)) # \\"Not enough meals and drinks!\\"","solution":"def check_supply(num_passengers, available_meals, available_drinks): Determines if there are enough meals and drinks for all passengers. Parameters: - num_passengers (int): The number of passengers on the flight. - available_meals (int): The number of meals available. - available_drinks (int): The number of drinks available. Returns: - str: A string indicating the supply status. if available_meals >= num_passengers and available_drinks >= num_passengers: return \\"All set!\\" elif available_meals < num_passengers and available_drinks < num_passengers: return \\"Not enough meals and drinks!\\" elif available_meals < num_passengers: return \\"Not enough meals!\\" else: return \\"Not enough drinks!\\""},{"question":"def rotate(nums: List[int], k: int) -> None: Rotates the list of integers 'nums' to the right by 'k' steps. >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate(nums, 3) >>> nums [5, 6, 7, 1, 2, 3, 4] >>> nums = [-1, -100, 3, 99] >>> rotate(nums, 2) >>> nums [3, 99, -1, -100] >>> nums = [1, 2, 3, 4] >>> rotate(nums, 0) >>> nums [1, 2, 3, 4] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 5) >>> nums [1, 2, 3, 4, 5] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 7) >>> nums [4, 5, 1, 2, 3] >>> nums = [1] >>> rotate(nums, 3) >>> nums [1] # Your code here","solution":"def rotate(nums, k): Rotates the array 'nums' to the right by 'k' steps. n = len(nums) k = k % n # in case k is larger than the list length nums[:] = nums[-k:] + nums[:-k] # rotate the array in place"},{"question":"def count_unique_substrings(S: str, K: int) -> int: Returns the number of unique substrings of length K in the string S. >>> count_unique_substrings(\\"abacab\\", 3) 4 >>> count_unique_substrings(\\"abcdef\\", 2) 5 >>> count_unique_substrings(\\"aaaaaa\\", 1) 1 >>> count_unique_substrings(\\"abababab\\", 2) 2 >>> count_unique_substrings(\\"abcdef\\", 6) 1 >>> count_unique_substrings(\\"aaa\\", 2) 1 >>> count_unique_substrings(\\"abcabcabc\\", 3) 3 def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[int]: Processes a list of test cases and returns the number of unique substrings of length K for each test case. >>> process_test_cases([(\\"abacab\\", 3), (\\"abcdef\\", 2)]) [4, 5] >>> process_test_cases([(\\"aaaaaa\\", 1), (\\"abababab\\", 2), (\\"abcdef\\", 6)]) [1, 2, 1] >>> process_test_cases([(\\"aaa\\", 2), (\\"abcabcabc\\", 3)]) [1, 3]","solution":"def count_unique_substrings(S, K): Returns the number of unique substrings of length K in the string S. unique_substrings = set() for i in range(len(S) - K + 1): substring = S[i:i+K] unique_substrings.add(substring) return len(unique_substrings) def process_test_cases(test_cases): Processes a list of test cases and returns the number of unique substrings of length K for each test case. results = [] for S, K in test_cases: result = count_unique_substrings(S, K) results.append(result) return results"},{"question":"def determine_winner(n: int, player1_deck: List[Tuple[int, int]], player2_deck: List[Tuple[int, int]]) -> str: Determine the outcome of the game between two players. Each player has a deck of cards with attack and defense values. The game continues until both players run out of cards. The player with more remaining health wins. If both players have equal health, the game is a draw. >>> determine_winner(3, [(10, 5), (6, 8), (4, 7)], [(9, 6), (6, 7), (3, 9)]) \\"Player 1 wins\\" >>> determine_winner(2, [(5, 5), (6, 6)], [(5, 5), (6, 6)]) \\"Draw\\" >>> determine_winner(2, [(3, 3), (2, 2)], [(5, 3), (4, 5)]) \\"Player 2 wins\\" >>> determine_winner(1, [(50, 20)], [(10, 10)]) \\"Player 1 wins\\" >>> determine_winner(1, [(10, 10)], [(10, 10)]) \\"Draw\\"","solution":"def determine_winner(n, player1_deck, player2_deck): player1_health = 100 player2_health = 100 for i in range(n): p1_attack, p1_defense = player1_deck[i] p2_attack, p2_defense = player2_deck[i] if p1_attack > p2_attack: damage = p1_attack - p2_defense if damage > 0: player2_health -= damage elif p1_attack < p2_attack: damage = p2_attack - p1_defense if damage > 0: player1_health -= damage else: if p1_defense > p2_defense: pass # Player 1 wins the turn but deals no damage elif p1_defense < p2_defense: pass # Player 2 wins the turn but deals no damage else: pass # Draw, no damage dealt if player1_health > player2_health: return \\"Player 1 wins\\" elif player1_health < player2_health: return \\"Player 2 wins\\" else: return \\"Draw\\""},{"question":"def swap_first_last(s: str) -> str: Swaps the first and last integers in the string s. If the string contains less than two integers, returns the original string unchanged. Parameters: s (str): A string of integers separated by spaces. Returns: str: A new string with the first and last position values swapped. >>> swap_first_last(\\"1 2 3 4 5\\") '5 2 3 4 1' >>> swap_first_last(\\"10 20\\") '20 10' >>> swap_first_last(\\"100\\") '100' >>> swap_first_last(\\"\\") '' >>> swap_first_last(\\"8 15 22 35 44 90\\") '90 15 22 35 44 8' >>> swap_first_last(\\"5 5 5 5 5\\") '5 5 5 5 5' >>> swap_first_last(\\"1 -2 3 -4 5\\") '5 -2 3 -4 1' >>> swap_first_last(\\"4 20 6 11 3\\") '3 20 6 11 4'","solution":"def swap_first_last(s): Swaps the first and last integers in the string s. If the string contains less than two integers, returns the original string. Parameters: s (str): A string of integers separated by spaces. Returns: str: A new string with the first and last position values swapped. parts = s.split() if len(parts) < 2: return s parts[0], parts[-1] = parts[-1], parts[0] return ' '.join(parts)"},{"question":"def find_longest_non_decreasing_subarray(temperatures): Finds the longest continuous sub-array where each temperature is greater than or equal to the previous temperature. Params: temperatures (list of int): List of temperatures Returns: list of int: The longest continuous non-decreasing sub-array Examples: >>> find_longest_non_decreasing_subarray([3, 5, 7, 6, 9, 10, 12, 1, 2, 3]) [6, 9, 10, 12] >>> find_longest_non_decreasing_subarray([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> find_longest_non_decreasing_subarray([5, 4, 3, 2, 1]) [5] >>> find_longest_non_decreasing_subarray([1, 1, 1, 1]) [1, 1, 1, 1] >>> find_longest_non_decreasing_subarray([10]) [10] # Your implementation here def process_input(input_string): Processes the input string and returns the longest continuous non-decreasing sub-arrays for each test case. Params: input_string (str): Input string containing the number of test cases and the temperatures for each test case. Returns: str: Output string containing the results for each test case, with each result on a new line. Examples: >>> process_input(\\"1n10n3 5 7 6 9 10 12 1 2 3\\") \\"6 9 10 12\\" >>> process_input(\\"2n5n1 2 3 4 5n5n5 4 3 2 1\\") \\"1 2 3 4 5n5\\" >>> process_input(\\"3n7n5 6 3 4 5 6 7n4n1 2 3 2n6n1 2 2 2 1 0\\") \\"3 4 5 6 7n1 2 3n1 2 2 2\\" # Your implementation here","solution":"def find_longest_non_decreasing_subarray(temperatures): Finds the longest continuous sub-array where each temperature is greater than or equal to the previous temperature. Params: temperatures (list of int): List of temperatures Returns: list of int: The longest continuous non-decreasing sub-array max_length = 0 max_start_index = 0 current_start_index = 0 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] >= temperatures[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length max_start_index = current_start_index current_start_index = i current_length = 1 if current_length > max_length: max_length = current_length max_start_index = current_start_index return temperatures[max_start_index:max_start_index + max_length] def process_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) results = [] line_index = 1 for _ in range(T): N = int(input_lines[line_index]) temperatures = list(map(int, input_lines[line_index + 1].split())) line_index += 2 result = find_longest_non_decreasing_subarray(temperatures) results.append(\\" \\".join(map(str, result))) return \\"n\\".join(results)"},{"question":"def smallest_char_in_substrings(n: int, s: str, queries: List[Tuple[int, int]]) -> List[str]: Returns the lexicographically smallest character in the substring for each query. Parameters: n (int): Length of the string s s (str): The string containing lowercase English letters queries (list of tuple): List of queries in the form (l_i, r_i) Returns: list: List of smallest characters for each substring query Examples: >>> smallest_char_in_substrings(5, \\"abcde\\", [(2, 4), (1, 5)]) ['b', 'a'] >>> smallest_char_in_substrings(6, \\"fghijk\\", [(1, 4), (2, 5), (3, 6)]) ['f', 'g', 'h'] from typing import List, Tuple def test_smallest_char_simple_case(): n = 5 s = \\"abcde\\" queries = [(2, 4), (1, 5)] assert smallest_char_in_substrings(n, s, queries) == ['b', 'a'] def test_smallest_char_full_string(): n = 5 s = \\"abcde\\" queries = [(1, 5)] assert smallest_char_in_substrings(n, s, queries) == ['a'] def test_smallest_char_single_character_substrings(): n = 5 s = \\"abcde\\" queries = [(1, 1), (2, 2), (3, 3)] assert smallest_char_in_substrings(n, s, queries) == ['a', 'b', 'c'] def test_smallest_char_repeating_patterns(): n = 7 s = \\"abbacca\\" queries = [(1, 3), (4, 7)] assert smallest_char_in_substrings(n, s, queries) == ['a', 'a'] def test_smallest_char_different_queries(): n = 6 s = \\"fghijk\\" queries = [(1, 4), (2, 5), (3, 6)] assert smallest_char_in_substrings(n, s, queries) == ['f', 'g', 'h']","solution":"def smallest_char_in_substrings(n, s, queries): Returns the lexicographically smallest character in the substring for each query. Parameters: n (int): Length of the string s s (str): The string containing lowercase English letters queries (list of tuple): List of queries in the form (l_i, r_i) Returns: list: List of smallest characters for each substring query results = [] for l, r in queries: substring = s[l-1:r] # Substring from l to r results.append(min(substring)) # Find the smallest character in the substring return results"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Compute the minimum number of swaps required to rearrange the array into a continuous sequence from 1 to n. >>> min_swaps_to_sort([4, 3, 2, 5, 1]) 3 >>> min_swaps_to_sort([1, 2, 4, 3]) 1 >>> min_swaps_to_sort([6, 5, 4, 3, 2, 1]) 3 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_swaps_to_sort([2, 1]) 1","solution":"def min_swaps_to_sort(arr): This function computes the minimum number of swaps required to sort the array into a continuous sequence from 1 to n. n = len(arr) # Compute the correct positions correct_positions = {val: idx for idx, val in enumerate(sorted(arr))} # Track visited elements to avoid cycles revisits visited = [False] * n swaps = 0 for i in range(n): if visited[i] or correct_positions[arr[i]] == i: continue cycle_length = 0 x = i while not visited[x]: visited[x] = True x = correct_positions[arr[x]] cycle_length += 1 if cycle_length > 1: swaps += (cycle_length - 1) return swaps"},{"question":"def is_subsequence(S: str, P: str) -> str: Returns 'Yes' if P is a subsequence of S, otherwise returns 'No'. >>> is_subsequence(\\"abcde\\", \\"ace\\") 'Yes' >>> is_subsequence(\\"abcde\\", \\"aec\\") 'No' >>> is_subsequence(\\"abc\\", \\"abc\\") 'Yes' def process_test_cases(test_cases: list) -> list: Processes multiple test cases to determine if P is a subsequence of S for each case. >>> process_test_cases([(\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aec\\"), (\\"abc\\", \\"abc\\")]) ['Yes', 'No', 'Yes'] >>> process_test_cases([(\\"a\\"*100000, \\"a\\"*100000)]) ['Yes'] >>> process_test_cases([(\\"a\\"*100000, \\"b\\"), (\\"a\\"*50000 + \\"b\\", \\"ab\\")]) ['No', 'Yes']","solution":"def is_subsequence(S, P): Returns 'Yes' if P is a subsequence of S, otherwise returns 'No'. m, n = len(S), len(P) i, j = 0, 0 while i < m and j < n: if S[i] == P[j]: j += 1 i += 1 return 'Yes' if j == n else 'No' def process_test_cases(test_cases): Processes multiple test cases to determine if P is subsequence of S for each case. results = [] for S, P in test_cases: results.append(is_subsequence(S, P)) return results"},{"question":"def smallest_subarray_with_sum(array, n, k): Finds the smallest subarray with sum greater than or equal to \`k\`. Parameters: array (list of int): List of integers. n (int): Number of elements in the array. k (int): Target sum. Returns: int: Length of the smallest subarray with sum >= \`k\`, or -1 if no such subarray exists. >>> smallest_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10, 15) 2 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 5, 20) -1 >>> smallest_subarray_with_sum([1, 4, 45, 6, 0, 19], 6, 8) 1","solution":"def smallest_subarray_with_sum(array, n, k): Finds the smallest subarray with sum greater than or equal to \`k\`. Parameters: array (list of int): List of integers. n (int): Number of elements in the array. k (int): Target sum. Returns: int: Length of the smallest subarray with sum >= \`k\`, or -1 if no such subarray exists. min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += array[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= array[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def unique_products_count(queries: List[str]) -> int: Returns the number of unique products in the warehouse after performing a series of addition and deletion operations. Parameters: queries (list of str): List of queries in the form of \\"ADD x\\" or \\"DELETE x\\" Returns: int: Number of unique products remaining in the warehouse Examples: >>> unique_products_count([\\"ADD 1\\", \\"ADD 2\\", \\"ADD 1\\", \\"DELETE 2\\", \\"DELETE 3\\"]) 1 >>> unique_products_count([\\"ADD 10\\", \\"DELETE 10\\", \\"ADD 20\\", \\"ADD 30\\", \\"DELETE 20\\", \\"ADD 10\\", \\"ADD 30\\"]) 2","solution":"def unique_products_count(queries): Returns the number of unique products in the warehouse after performing a series of addition and deletion operations. Parameters: queries (list of str): List of queries in the form of \\"ADD x\\" or \\"DELETE x\\" Returns: int: Number of unique products remaining in the warehouse products = set() for query in queries: operation, x_str = query.split() x = int(x_str) if operation == \\"ADD\\": products.add(x) elif operation == \\"DELETE\\" and x in products: products.remove(x) return len(products)"},{"question":"from typing import List def largest_alliance_size(n: int, strengths: List[int]) -> int: Find the largest possible size of an alliance that can be formed among the creatures. Args: n (int): the number of different types of creatures. strengths (List[int]): the strengths of the creatures. Returns: int: the size of the largest possible alliance. Examples: >>> largest_alliance_size(6, [2, 3, 5, 7, 11, 14]) 5 >>> largest_alliance_size(5, [4, 6, 8, 10, 12]) 1","solution":"from math import gcd from itertools import combinations def is_coprime(x, y): return gcd(x, y) == 1 def largest_alliance_size(n, strengths): max_alliance_size = 1 for r in range(2, n+1): for subset in combinations(strengths, r): if all(is_coprime(pair[0], pair[1]) for pair in combinations(subset, 2)): max_alliance_size = max(max_alliance_size, len(subset)) return max_alliance_size"},{"question":"def count_paths(grid: List[List[int]]) -> int: Find the number of distinct paths from the top-left corner to the bottom-right corner of a grid. The grid is represented by a 2D list where 0 denotes an obstacle and 1 denotes a passable cell. >>> count_paths([ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) == 2 >>> count_paths([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) == 20 >>> count_paths([ ... [1, 0, 0, 0], ... [1, 1, 1, 1], ... [0, 0, 0, 1], ... [1, 1, 1, 1] ... ]) == 1","solution":"def count_paths(grid): M = len(grid) # Create a 2D dp array to store the number of paths to each cell dp = [[0] * M for _ in range(M)] # Starting point dp[0][0] = 1 # Loop through each cell in the grid for i in range(M): for j in range(M): if grid[i][j] == 1: # If the cell is passable, update the paths if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] # The result is the number of paths to the bottom-right corner return dp[M - 1][M - 1]"},{"question":"from typing import List def generate_unique_substrings(s: str) -> List[str]: Write a function that accepts a string of alphanumeric characters and returns a list of all unique substrings that can be formed using the characters of the input string. The substrings should be arranged in lexicographical order. >>> generate_unique_substrings(\\"abc\\") ['a', 'ab', 'abc', 'b', 'bc', 'c'] >>> generate_unique_substrings(\\"a1b2\\") ['1', '1b', '1b2', '2', 'a', 'a1', 'a1b', 'a1b2', 'b', 'b2']","solution":"from typing import List def generate_unique_substrings(s: str) -> List[str]: substrings = set() # Generate all substrings and add them to the set for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) # Convert the set to a list and sort it lexicographically result = sorted(substrings) return result"},{"question":"def maxFrequencyCharacter(N: int, s: str) -> str: Given a string str of length N consisting of only lowercase alphabetical characters, determine the character that appears the maximum number of times. If there are ties, return the lexicographically smaller character. >>> maxFrequencyCharacter(6, \\"geekss\\") 'e' >>> maxFrequencyCharacter(7, \\"abracad\\") 'a'","solution":"def maxFrequencyCharacter(N, s): Returns the character that appears the maximum number of times in the string s of length N. In case of ties, returns the lexicographically smaller character. frequency = [0] * 26 for char in s: frequency[ord(char) - ord('a')] += 1 max_frequency = 0 max_char = '' for i in range(26): if frequency[i] > max_frequency: max_frequency = frequency[i] max_char = chr(i + ord('a')) return max_char"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome. >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"aa\\") == True >>> is_palindrome(\\"ab\\") == False >>> is_palindrome(\\"aba\\") == True >>> is_palindrome(\\"abc\\") == False pass def min_palindromic_substrings(s: str) -> int: Returns the minimum number of contiguous substrings that can be formed from s such that each substring is a palindrome. >>> min_palindromic_substrings(\\"abac\\") == 4 >>> min_palindromic_substrings(\\"aaaa\\") == 1 >>> min_palindromic_substrings(\\"abc\\") == 3 >>> min_palindromic_substrings(\\"a\\") == 1 >>> min_palindromic_substrings(\\"racecar\\") == 1 >>> min_palindromic_substrings(\\"abccba\\") == 1 >>> min_palindromic_substrings(\\"abab\\") == 4 pass","solution":"def is_palindrome(s): Checks if the given string is a palindrome. return s == s[::-1] def min_palindromic_substrings(s): Returns the minimum number of contiguous substrings that can be formed from s such that each substring is a palindrome. if is_palindrome(s): return 1 return len(s)"},{"question":"def longest_increasing_subsequence_length(nums: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in a list of integers. >>> longest_increasing_subsequence_length([5, 2, 8, 6, 3, 6]) 3 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([10]) 1 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length([]) 0 >>> longest_increasing_subsequence_length([1, 2, 2, 3, 4, 4, 5]) 5","solution":"def longest_increasing_subsequence_length(nums): Returns the length of the longest strictly increasing subsequence in a list of integers. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example Usage: # length = longest_increasing_subsequence_length([5, 2, 8, 6, 3, 6]) # print(length) # Output: 3"},{"question":"def solve(t: int, cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determines the longest path between any two nodes in a tree (the diameter of the tree). Args: t (int): Number of test cases. cases (List[Tuple[int, List[Tuple[int, int]]]]): For each test case, an integer N (number of nodes) and a list of (N-1) edges. Returns: List[int]: The diameter of the tree for each test case. Example: >>> solve(2, [(4, [(1, 2), (2, 3), (2, 4)]), (5, [(1, 2), (1, 3), (3, 4), (3, 5)])]) [2, 3] >>> solve(1, [(3, [(1, 2), (2, 3)])]) [2] >>> solve(1, [(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)])]) [5] >>> solve(1, [(1, [])]) [0] >>> solve(1, [(100000, [(i, i + 1) for i in range(1, 100000)])]) [99999]","solution":"from collections import deque, defaultdict def find_farthest_node(start, n, graph): visited = [-1] * (n + 1) max_distance = 0 farthest_node = start queue = deque([(start, 0)]) visited[start] = 1 while queue: node, dist = queue.popleft() for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = 1 queue.append((neighbor, dist + 1)) if dist + 1 > max_distance: max_distance = dist + 1 farthest_node = neighbor return farthest_node, max_distance def tree_diameter(n, edges): if n == 1: return 0 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) farthest_node, _ = find_farthest_node(1, n, graph) _, diameter = find_farthest_node(farthest_node, n, graph) return diameter def solve(t, cases): results = [] for n, edges in cases: results.append(tree_diameter(n, edges)) return results"},{"question":"def max_temperature_after_t_updates(n: int, m: int, t: int, initial_matrix: List[List[int]], addend_matrix: List[List[int]]) -> int: Returns the maximum temperature observed after t updates on the temperature grid. >>> max_temperature_after_t_updates(3, 3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 11 >>> max_temperature_after_t_updates(2, 2, 3, [[0, 0], [0, 0]], [[2, 3], [1, 4]]) == 12 # Your code here","solution":"def max_temperature_after_t_updates(n, m, t, initial_matrix, addend_matrix): Returns the maximum temperature observed after t updates on the temperature grid. max_initial_temperature = max(max(row) for row in initial_matrix) max_addend = max(max(row) for row in addend_matrix) # Maximum temperature after t updates max_temperature = max_initial_temperature + t * max_addend return max_temperature # Example usage # print(max_temperature_after_t_updates(3, 3, 2, # [[1, 2, 3], [4, 5, 6], [7, 8, 9]], # [[1, 1, 1], [1, 1, 1], [1, 1, 1]])) # This should output 11"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def printLevel(root: TreeNode, target: int) -> List[int]: Given a Binary Tree and a node, print the entire level of the Binary Tree in which the given node is present. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> root.left.left.left = TreeNode(8) >>> printLevel(root, 5) [4, 5, 6, 7] >>> printLevel(root, 8) [8] >>> printLevel(root, 42) [] >>> printLevel(root, 1) [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> printLevel(root, 4) [4] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> printLevel(root, 3) [3]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def find_level(root, target, level): if root is None: return 0 if root.val == target: return level downlevel = find_level(root.left, target, level + 1) if downlevel != 0: return downlevel downlevel = find_level(root.right, target, level + 1) return downlevel def printGivenLevel(root, level, result): if root is None: return if level == 1: result.append(root.val) elif level > 1: printGivenLevel(root.left, level - 1, result) printGivenLevel(root.right, level - 1, result) def printLevel(root, target): found_level = find_level(root, target, 1) if found_level == 0: return [] result = [] printGivenLevel(root, found_level, result) return result"},{"question":"def min_vegetable_types_needed(N: int, beds: List[int]) -> int: Returns the minimum number of different types of vegetables needed to be planted in the empty beds such that no two adjacent beds contain the same type of vegetable. >>> min_vegetable_types_needed(6, [1, 0, 2, 0, 3, 4]) 1 >>> min_vegetable_types_needed(7, [0, 0, 0, 1, 0, 0, 0]) 1 >>> min_vegetable_types_needed(5, [0, 1, 2, 3, 4]) 1 >>> min_vegetable_types_needed(8, [1, 0, 0, 2, 0, 0, 3, 4]) 1","solution":"def min_vegetable_types_needed(N, beds): Returns the minimum number of different types of vegetables needed to be planted in the empty beds such that no two adjacent beds contain the same type of vegetable. def find_next_type(exclude=set()): Returns the first vegetable type not in the exclude set. num = 1 while num in exclude: num += 1 return num i = 0 while i < N: if beds[i] == 0: left_type = beds[i-1] if i > 0 else -1 j = i while j < N and beds[j] == 0: j += 1 right_type = beds[j] if j < N else -1 required_types = set() if left_type != -1: required_types.add(left_type) if right_type != -1: required_types.add(right_type) # Fill the empty segment with the required types avoiding each other tmp_type = find_next_type(required_types) for k in range(i, j): beds[k] = tmp_type required_types.add(tmp_type) i = j else: i += 1 return 1 # Example Usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) beds = list(map(int, data[1:])) print(min_vegetable_types_needed(N, beds))"},{"question":"from typing import List def most_frequent_character(s: str) -> str: Returns the character which appears the most times in the string s. If there's a tie, the lexicographically smallest character is returned. >>> most_frequent_character(\\"a\\") == \\"a\\" >>> most_frequent_character(\\"abcde\\") == \\"a\\" >>> most_frequent_character(\\"aabbcc\\") == \\"a\\" >>> most_frequent_character(\\"abbbc\\") == \\"b\\" >>> most_frequent_character(\\"a\\" * 1000 + \\"b\\" * 999) == \\"a\\" >>> most_frequent_character(\\"ab\\" * 500) == \\"a\\"","solution":"def most_frequent_character(s): Returns the character which appears the most times in the string s. If there's a tie, the lexicographically smallest character is returned. from collections import Counter char_count = Counter(s) max_freq = max(char_count.values()) candidates = [char for char, count in char_count.items() if count == max_freq] return min(candidates)"},{"question":"class SegmentTree: def __init__(self, nums): Initialize the Segment Tree with the given list of numbers. self.n = len(nums) self.tree = [0] * (2 * self.n) self.build(nums) def build(self, nums): Build the Segment Tree from the list of numbers. for i in range(self.n): self.tree[self.n + i] = nums[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, idx, value): Update the element at index \`idx\` in the Segment Tree. pos = idx + self.n self.tree[pos] = value while pos > 1: pos = pos // 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): Compute the sum of elements from index \`left\` to \`right\` in the Segment Tree. result = 0 left += self.n right += self.n while left <= right: if left % 2 == 1: result += self.tree[left] left += 1 if right % 2 == 0: result += self.tree[right] right -= 1 left //= 2 right //= 2 return result def process_queries(n, q, nums, queries): Process the update and range sum queries on the integer array \`nums\` of size \`n\`. >>> n, q = 5, 3 >>> nums = [1, 2, 3, 4, 5] >>> queries = [ [2, 1, 3], [1, 3, 10], [2, 2, 4] ] >>> process_queries(n, q, nums, queries) [6, 16] seg_tree = SegmentTree(nums) results = [] for query in queries: if query[0] == 1: _, i, x = query seg_tree.update(i - 1, x) elif query[0] == 2: _, L, R = query results.append(seg_tree.range_sum(L - 1, R - 1)) return results","solution":"class SegmentTree: def __init__(self, nums): self.n = len(nums) self.tree = [0] * (2 * self.n) self.build(nums) def build(self, nums): for i in range(self.n): self.tree[self.n + i] = nums[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, idx, value): pos = idx + self.n self.tree[pos] = value while pos > 1: pos = pos // 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): result = 0 left += self.n right += self.n while left <= right: if left % 2 == 1: result += self.tree[left] left += 1 if right % 2 == 0: result += self.tree[right] right -= 1 left //= 2 right //= 2 return result def process_queries(n, q, nums, queries): seg_tree = SegmentTree(nums) results = [] for query in queries: if query[0] == 1: _, i, x = query seg_tree.update(i - 1, x) elif query[0] == 2: _, L, R = query results.append(seg_tree.range_sum(L - 1, R - 1)) return results"},{"question":"def can_rearrange_to_sum_k(n: int, k: int, A: List[int], B: List[int]) -> Union[str, Tuple[str, List[int]]]: Determines if we can rearrange sequence B so that for every i, A[i] + B'[i] == k. If possible, return \\"YES\\" and the rearranged sequence B. Otherwise, return \\"NO\\". :param n: Number of elements in sequences A and B. :param k: Desired sum of corresponding elements of A and rearranged B. :param A: List of integers A. :param B: List of integers B. :return: Tuple containing either \\"YES\\" and the rearranged B, or \\"NO\\". pass from typing import List, Union, Tuple def test_example_1(): n, k = 3, 5 A = [1, 2, 3] B = [4, 3, 2] assert can_rearrange_to_sum_k(n, k, A, B) == (\\"YES\\", [4, 3, 2]) def test_example_2(): n, k = 3, 6 A = [1, 2, 3] B = [4, 3, 2] assert can_rearrange_to_sum_k(n, k, A, B) == \\"NO\\" def test_case_all_elements_same(): n, k = 4, 6 A = [3, 3, 3, 3] B = [3, 3, 3, 3] assert can_rearrange_to_sum_k(n, k, A, B) == (\\"YES\\", [3, 3, 3, 3]) def test_case_repeated_elements(): n, k = 3, 7 A = [2, 4, 3] B = [5, 4, 3] result = can_rearrange_to_sum_k(n, k, A, B) assert result == (\\"YES\\", [5, 3, 4]) or result == (\\"YES\\", [5, 4, 3]) def test_case_impossible(): n, k = 2, 10 A = [1, 1] B = [1, 1] assert can_rearrange_to_sum_k(n, k, A, B) == \\"NO\\"","solution":"def can_rearrange_to_sum_k(n, k, A, B): Determines if we can rearrange sequence B so that for every i, A[i] + B'[i] == k. If possible, return \\"YES\\" and the rearranged sequence B. Otherwise, return \\"NO\\". :param n: Number of elements in sequences A and B. :param k: Desired sum of corresponding elements of A and rearranged B. :param A: List of integers A. :param B: List of integers B. :return: Tuple containing either \\"YES\\" and the rearranged B, or \\"NO\\". B_sorted = sorted(B, reverse=True) result_B = [] for a in A: b = k - a if b in B_sorted: result_B.append(b) B_sorted.remove(b) else: return \\"NO\\" return \\"YES\\", result_B"},{"question":"def count_distinct_merged_melodies(melody1: str, melody2: str) -> int: Returns the number of distinct merged melodies that can be formed by interleaving melody1 and melody2 while preserving the order of characters in each melody. >>> count_distinct_merged_melodies(\\"abc\\", \\"def\\") 20 >>> count_distinct_merged_melodies(\\"a\\", \\"b\\") 2 >>> count_distinct_merged_melodies(\\"xyz\\", \\"xyz\\") 20 >>> count_distinct_merged_melodies(\\"\\", \\"abcd\\") 1 >>> count_distinct_merged_melodies(\\"abcd\\", \\"\\") 1 >>> count_distinct_merged_melodies(\\"a\\", \\"a\\") 2 >>> count_distinct_merged_melodies(\\"abc\\", \\"abc\\") 20","solution":"def count_distinct_merged_melodies(melody1, melody2): Returns the number of distinct merged melodies that can be formed by interleaving melody1 and melody2 while preserving the order of characters in each melody. from functools import lru_cache @lru_cache(None) def count_ways(i, j): # Base case: If we've reached the end of both melodies, there's exactly one way to merge (the empty string) if i == len(melody1) and j == len(melody2): return 1 # If we've reached the end of melody1, the rest comes from melody2 if i == len(melody1): return 1 # If we've reached the end of melody2, the rest comes from melody1 if j == len(melody2): return 1 # Calculate the number of ways by considering the next step could come from either melody1 or melody2 ways = 0 if i < len(melody1): ways += count_ways(i + 1, j) if j < len(melody2): ways += count_ways(i, j + 1) return ways return count_ways(0, 0)"},{"question":"def arrange_toys(toy_list): Takes a list of toys and sorts them first by type, then by popularity in descending order, and then by name lexicographically if two toys have the same popularity. pass # Implement the sorting logic here def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] toys = test_cases[i][1] arranged_toys = arrange_toys(toys) results.append(arranged_toys) return results def main(): import sys input = sys.stdin.read data = input().splitlines() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 toys = [] for _ in range(N): toy_info = data[index].split() toy_name = ' '.join(toy_info[:-2]) toy_type = toy_info[-2] popularity = int(toy_info[-1]) toys.append((toy_name, toy_type, popularity)) index += 1 test_cases.append((N, toys)) results = process_test_cases(T, test_cases) for result in results: for toy in result: print(f\\"{toy[0]} {toy[1]} {toy[2]}\\")","solution":"def arrange_toys(toy_list): Takes a list of toys and sorts them first by type, then by popularity in descending order, and then by name lexicographically if two toys have the same popularity. from collections import defaultdict # Group toys by their type toys_by_type = defaultdict(list) for toy in toy_list: toy_name, toy_type, popularity = toy toys_by_type[toy_type].append((toy_name, int(popularity))) sorted_toys = [] for toy_type in sorted(toys_by_type): toys_of_type = sorted(toys_by_type[toy_type], key=lambda x: (-x[1], x[0])) for toy in toys_of_type: sorted_toys.append((toy[0], toy_type, toy[1])) return sorted_toys def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] toys = test_cases[i][1] arranged_toys = arrange_toys(toys) results.append(arranged_toys) return results def main(): import sys input = sys.stdin.read data = input().splitlines() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 toys = [] for _ in range(N): toy_info = data[index].split() toy_name = ' '.join(toy_info[:-2]) toy_type = toy_info[-2] popularity = int(toy_info[-1]) toys.append((toy_name, toy_type, popularity)) index += 1 test_cases.append((N, toys)) results = process_test_cases(T, test_cases) for result in results: for toy in result: print(f\\"{toy[0]} {toy[1]} {toy[2]}\\")"},{"question":"def can_remove_k_chars_to_make_palindrome(k, s): Determine if it's possible to remove exactly \`k\` characters from the string \`s\` to end up with a string that is a palindrome. Args: k (int): The number of characters to remove. s (str): The input string. Returns: str: \\"YES\\" if it is possible to remove \`k\` characters to make \`s\` a palindrome, otherwise \\"NO\\". >>> can_remove_k_chars_to_make_palindrome(1, \\"abca\\") \\"YES\\" >>> can_remove_k_chars_to_make_palindrome(2, \\"abcba\\") \\"YES\\" >>> can_remove_k_chars_to_make_palindrome(1, \\"abcd\\") \\"NO\\" def process_test_cases(T, test_cases): Process multiple test cases to determine if it's possible to remove exactly \`k\` characters from the string to make it a palindrome. Args: T (int): The number of test cases. test_cases (list of tuples): A list of tuples where each tuple contains \`k\` and \`s\`. Returns: list: List of results for each test case, \\"YES\\" or \\"NO\\". >>> process_test_cases(3, [(1, \\"abca\\"), (2, \\"abcba\\"), (1, \\"abcd\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_remove_k_chars_to_make_palindrome(k, s): def is_palindrome(s): return s == s[::-1] def helper(i, j, k, memo): if k < 0: return False if i >= j: return True if (i, j, k) in memo: return memo[(i, j, k)] if s[i] == s[j]: memo[(i, j, k)] = helper(i + 1, j - 1, k, memo) else: memo[(i, j, k)] = helper(i + 1, j, k - 1, memo) or helper(i, j - 1, k - 1, memo) return memo[(i, j, k)] if is_palindrome(s): return \\"YES\\" if k % 2 == 0 or len(s) % 2 == 1 else \\"NO\\" return \\"YES\\" if helper(0, len(s) - 1, k, {}) else \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): k, s = test_cases[i] results.append(can_remove_k_chars_to_make_palindrome(k, s)) return results"},{"question":"def min_coins(amount: int, coins: List[int]) -> int: Determines the minimum number of coins needed to make a given amount of change from an unlimited supply of coins of given denominations. Parameters: amount (int): The total amount of change needed. coins (list): A list of integers representing the denominations of the coins available. Returns: int: The minimum number of coins needed to make the change, or -1 if change is not possible. >>> min_coins(11, [1, 2, 5]) 3 >>> min_coins(3, [2]) -1","solution":"def min_coins(amount, coins): Determines the minimum number of coins needed to make a given amount of change. Parameters: amount (int): The total amount of change needed. coins (list): A list of integers representing the denominations of the coins available. Returns: int: The minimum number of coins needed to make the change, or -1 if change is not possible. # Initialize a list to store the minimum number of coins for each amount up to the target amount. dp = [float('inf')] * (amount + 1) # Base case: 0 amount requires 0 coins. dp[0] = 0 # Iterate over each coin denomination. for coin in coins: for x in range(coin, amount + 1): # Update the dp array for the current amount dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, it means it's not possible to make the change. return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def uniquePathsWithObstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, where 0 represents an open cell and 1 represents an obstacle. >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]) 2 >>> uniquePathsWithObstacles([ ... [0, 1], ... [0, 0]]) 1","solution":"def uniquePathsWithObstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, where 0 represents an open cell and 1 represents an obstacle. if not grid or grid[0][0] == 1: return 0 N, M = len(grid), len(grid[0]) dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1]"},{"question":"def can_reach_bottom_right(n: int, m: int, grid: List[List[int]]) -> str: Determines if there's a path from the top-left to the bottom-right in a grid. >>> can_reach_bottom_right(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 'Yes' >>> can_reach_bottom_right(3, 3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]]) 'No' pass def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]: Process a number of test cases to determine if the farmer can reach the bottom-right corner. >>> process_test_cases(2, [(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]), (3, 3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]])]) ['Yes', 'No'] pass import pytest def test_single_case_yes(): n = 3 m = 3 grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert can_reach_bottom_right(n, m, grid) == \\"Yes\\" def test_single_case_no(): n = 3 m = 3 grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert can_reach_bottom_right(n, m, grid) == \\"No\\" def test_process_test_cases(): T = 2 test_cases = [ (3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]), (3, 3, [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) ] results = process_test_cases(T, test_cases) assert results == [\\"Yes\\", \\"No\\"] @pytest.mark.parametrize(\\"n, m, grid, expected\\", [ (1, 1, [[0]], \\"Yes\\"), (1, 1, [[1]], \\"No\\"), (2, 2, [[0, 0], [1, 0]], \\"Yes\\"), (2, 2, [[0, 0], [1, 1]], \\"No\\"), ]) def test_various_cases(n, m, grid, expected): assert can_reach_bottom_right(n, m, grid) == expected","solution":"def can_reach_bottom_right(n, m, grid): Determines if there's a path from the top-left to the bottom-right in a grid. if grid[0][0] == 1 or grid[n-1][m-1] == 1: return \\"No\\" from collections import deque # Directions (down, right) directions = [(1, 0), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == n-1 and y == m-1: return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return \\"No\\" def process_test_cases(T, test_cases): results = [] for n, m, grid in test_cases: result = can_reach_bottom_right(n, m, grid) results.append(result) return results"},{"question":"def is_possible(m: int, n: int, k: int, grid: List[str]) -> str: Determines if it is possible to reach the bottom-right cell (m-1, n-1) from the top-left cell (0,0) in exactly k steps. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. k (int): Exact number of steps required to reach the goal. grid (List[str]): The grid itself, with '.' denoting empty cells and '#' denoting obstacles. Returns: str: Output a single line containing \\"POSSIBLE\\" if it's possible to reach the bottom-right cell in exactly k steps from the top-left cell. Otherwise, output \\"IMPOSSIBLE\\". >>> is_possible(3, 3, 4, [\\"...\\", \\".#.\\", \\"...\\"]) \\"POSSIBLE\\" >>> is_possible(3, 3, 2, [\\"...\\", \\".#.\\", \\"...\\"]) \\"IMPOSSIBLE\\"","solution":"def is_possible(m, n, k, grid): Determines if it is possible to reach the bottom-right cell (m-1, n-1) from the top-left cell (0,0) in exactly k steps. def dfs(x, y, steps): if (x, y) == (m - 1, n - 1): return steps == k if steps >= k: return False visited.add((x, y)) for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)): nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': if dfs(nx, ny, steps + 1): return True visited.remove((x, y)) return False visited = set() if grid[0][0] == '#' or grid[m-1][n-1] == '#': return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\" if dfs(0, 0, 0) else \\"IMPOSSIBLE\\""},{"question":"def find_smallest_missing_confirmation_number(n: int, confirmation_numbers: List[int]) -> int: Find the smallest missing confirmation number in a list. Args: n : int : the number of confirmation numbers confirmation_numbers: list : a list of confirmation numbers Returns: int : the smallest missing confirmation number >>> find_smallest_missing_confirmation_number(5, [1, 2, 4, 5, 6]) 3 >>> find_smallest_missing_confirmation_number(4, [3, 2, 5, 1]) 4 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find the smallest missing confirmation number for each. Args: test_cases : list : a list of tuples, each containing the number of confirmation numbers and the list of those numbers Returns: list : a list of results, each the smallest missing confirmation number for the corresponding test case >>> process_test_cases([(5, [1, 2, 4, 5, 6]), (4, [3, 2, 5, 1])]) [3, 4] pass","solution":"def find_smallest_missing_confirmation_number(n, confirmation_numbers): This function finds the smallest missing confirmation number in a list. Args: n : int : the number of confirmation numbers confirmation_numbers: list : a list of confirmation numbers Returns: int : the smallest missing confirmation number confirmation_numbers = set(confirmation_numbers) for i in range(1, n + 2): if i not in confirmation_numbers: return i def process_test_cases(test_cases): Process multiple test cases to find the smallest missing confirmation number for each. Args: test_cases : list : a list of tuples, each containing the number of confirmation numbers and the list of those numbers Returns: list : a list of results, each the smallest missing confirmation number for the corresponding test case results = [] for n, numbers in test_cases: results.append(find_smallest_missing_confirmation_number(n, numbers)) return results"},{"question":"def maximize_books_in_good_condition(n: int, w: List[int], c: int) -> List[int]: Determine the order of books that allows the maximum number of books to remain in good condition after undergoing wear during maintenance. Parameters: n (int): The number of books. w (list): The wear tolerance values of the books. c (int): The wear factor applied during the maintenance. Returns: list: Order of books that maximizes the number of books in good condition. >>> maximize_books_in_good_condition(5, [10, 2, 3, 7, 5], 3) in [[1, 4, 5, 3, 2], [1, 4, 5, 2, 3], [1, 5, 4, 3, 2], [1, 5, 4, 2, 3]] True >>> maximize_books_in_good_condition(1, [5], 3) == [1] True >>> maximize_books_in_good_condition(4, [5, 5, 5, 5], 1) == [1, 2, 3, 4] True >>> maximize_books_in_good_condition(3, [8, 5, 6], 2) == [1, 3, 2] True","solution":"def maximize_books_in_good_condition(n, w, c): Function to determine the order of books that allows the maximum number of books to remain in good condition after undergoing wear during maintenance. Parameters: n (int): The number of books. w (list): The wear tolerance values of the books. c (int): The wear factor applied during the maintenance. Returns: list: Order of books that maximizes the number of books in good condition. # Creating a list of tuples (wear tolerance, index) books = list(enumerate(w)) # Sort the books by wear tolerance, highest to lowest books.sort(key=lambda x: x[1], reverse=True) # Extracting the order of indices order = [index + 1 for index, tolerance in books] return order"},{"question":"def is_prime(n: int) -> str: Returns \\"Prime\\" if n is a prime number, otherwise returns \\"Not Prime\\". >>> is_prime(5) \\"Prime\\" >>> is_prime(97) \\"Prime\\" >>> is_prime(2) \\"Prime\\" >>> is_prime(10) \\"Not Prime\\" >>> is_prime(1) \\"Not Prime\\" >>> is_prime(1000) \\"Not Prime\\" >>> is_prime(0) \\"Not Prime\\" >>> is_prime(4) \\"Not Prime\\" >>> is_prime(9) \\"Not Prime\\" >>> is_prime(15) \\"Not Prime\\"","solution":"def is_prime(n): Returns \\"Prime\\" if n is a prime number, otherwise returns \\"Not Prime\\". if n < 2: return \\"Not Prime\\" for i in range(2, int(n**0.5) + 1): if n % i == 0: return \\"Not Prime\\" return \\"Prime\\""},{"question":"from typing import List, Tuple def longest_parking_vehicle(n: int, entries: List[Tuple[str, str, str]]) -> str: Determine the vehicle that has stayed the longest in the parking lot among a provided set of vehicle entries. >>> longest_parking_vehicle(5, [(\\"ABC123\\", \\"08:00\\", \\"09:30\\"), (\\"XYZ789\\", \\"07:00\\", \\"09:00\\"), (\\"LMN456\\", \\"10:15\\", \\"12:00\\"), (\\"DEF000\\", \\"09:45\\", \\"11:30\\"), (\\"GHI111\\", \\"07:30\\", \\"08:45\\")]) == \\"XYZ789\\" >>> longest_parking_vehicle(1, [(\\"AB123\\", \\"08:00\\", \\"09:00\\")]) == \\"AB123\\" >>> longest_parking_vehicle(3, [(\\"CAR1\\", \\"09:00\\", \\"10:00\\"), (\\"CAR2\\", \\"08:00\\", \\"09:00\\"), (\\"CAR3\\", \\"07:00\\", \\"08:00\\")]) == \\"CAR1\\" >>> longest_parking_vehicle(2, [(\\"CAR1\\", \\"09:00\\", \\"10:00\\"), (\\"CAR2\\", \\"09:00\\", \\"11:00\\")]) == \\"CAR2\\" >>> longest_parking_vehicle(2, [(\\"CAR1\\", \\"10:00\\", \\"11:00\\"), (\\"CAR2\\", \\"11:00\\", \\"12:00\\")]) == \\"CAR1\\"","solution":"from datetime import datetime def calculate_duration(entry_time, exit_time): format = \\"%H:%M\\" entry = datetime.strptime(entry_time, format) exit = datetime.strptime(exit_time, format) duration = exit - entry return duration.total_seconds() def longest_parking_vehicle(n, entries): max_duration = -1 longest_vehicle = \\"\\" for i in range(n): license_plate, entry_time, exit_time = entries[i] duration = calculate_duration(entry_time, exit_time) if duration > max_duration: max_duration = duration longest_vehicle = license_plate return longest_vehicle # Example Usage: # n = 5 # entries = [ # (\\"ABC123\\", \\"08:00\\", \\"09:30\\"), # (\\"XYZ789\\", \\"07:00\\", \\"09:00\\"), # (\\"LMN456\\", \\"10:15\\", \\"12:00\\"), # (\\"DEF000\\", \\"09:45\\", \\"11:30\\"), # (\\"GHI111\\", \\"07:30\\", \\"08:45\\") # ] # print(longest_parking_vehicle(n, entries)) # Output: XYZ789"},{"question":"def rearrange_array(n: int, arr: List[int]) -> List[int]: Rearrange the array such that the difference between any two adjacent elements is maximized. Parameters: n : int : number of elements in the array arr : List[int] : list of integers to be rearranged Returns: List[int] : rearranged list of integers Examples: >>> rearrange_array(5, [1, 3, 5, 2, 4]) [5, 1, 4, 2, 3] >>> rearrange_array(4, [6, 2, 9, 3]) [9, 2, 6, 3]","solution":"def rearrange_array(n, arr): Rearrange the array such that the difference between any two adjacent elements is maximized. arr.sort() left = 0 right = n - 1 result = [] while left <= right: if right > left: result.append(arr[right]) right -= 1 if left <= right: result.append(arr[left]) left += 1 return result"},{"question":"import bisect class TrainSchedule: def __init__(self, num_stations): Initialize the TrainSchedule with the number of stations. self.schedules = [[] for _ in range(num_stations)] def add_train(self, s, t): Add a train that departs from station s at time t. bisect.insort(self.schedules[s], t) def next_train(self, s, t): Report the earliest train departing from station s at or after time t. Return -1 if no such train exists. index = bisect.bisect_left(self.schedules[s], t) if index < len(self.schedules[s]): return self.schedules[s][index] return -1 def process_queries(n, q, queries): Process a list of queries regarding train schedules and return the results. Args: n: Number of stations. q: Number of queries. queries: A list of queries where each query is a tuple (com, s, t). Returns: A list of results for each next_train query. Example: >>> process_queries(3, 5, [(0, 0, 100), (0, 1, 200), (0, 2, 300), (1, 0, 50), (1, 1, 250)]) [100, -1] >>> process_queries(2, 4, [(0, 1, 100), (0, 1, 200), (1, 1, 50), (1, 1, 150)]) [100, 200] schedule = TrainSchedule(n) result = [] for query in queries: com, s, t = query if com == 0: schedule.add_train(s, t) elif com == 1: result.append(schedule.next_train(s, t)) return result","solution":"import bisect class TrainSchedule: def __init__(self, num_stations): self.schedules = [[] for _ in range(num_stations)] def add_train(self, s, t): bisect.insort(self.schedules[s], t) def next_train(self, s, t): index = bisect.bisect_left(self.schedules[s], t) if index < len(self.schedules[s]): return self.schedules[s][index] return -1 def process_queries(n, q, queries): schedule = TrainSchedule(n) result = [] for query in queries: com, s, t = query if com == 0: schedule.add_train(s, t) elif com == 1: result.append(schedule.next_train(s, t)) return result"},{"question":"def min_moves_to_k_distinct(s: str, k: int) -> int: Determine the minimum number of moves required to make the string s contain k distinct characters. >>> min_moves_to_k_distinct(\\"abc\\", 2) 1 >>> min_moves_to_k_distinct(\\"aaa\\", 1) 0 >>> min_moves_to_k_distinct(\\"abcd\\", 4) 0 >>> min_moves_to_k_distinct(\\"abc\\", 4) -1 >>> min_moves_to_k_distinct(\\"aabbcc\\", 3) 0 >>> min_moves_to_k_distinct(\\"aabbcc\\", 1) 2 def process_test_cases(test_cases: list) -> list: Process multiple test cases for the min_moves_to_k_distinct function. Args: test_cases (list): A list of tuples where each tuple contains a string s and an integer k. Returns: list: A list of integers where each integer represents the minimum number of moves required for that test case. >>> process_test_cases([(\\"abc\\", 2), (\\"aaa\\", 1), (\\"abcd\\", 4)]) [1, 0, 0]","solution":"def min_moves_to_k_distinct(s, k): from collections import Counter # Initial frequency count of characters freq = Counter(s) distinct_chars = len(freq) # If \`k\` is greater than the length of the string, it's impossible if k > len(s): return -1 # If the number of distinct characters is already \`k\` if distinct_chars == k: return 0 # If we have more distinct characters than \`k\`, we need to remove some # If we have fewer distinct characters than \`k\`, we need to add some moves = 0 # We need to reduce or increase the number of distinct characters to \`k\` if distinct_chars > k: # We need to reduce chars_to_remove = distinct_chars - k moves += chars_to_remove else: # We need to increase chars_to_add = k - distinct_chars moves += chars_to_add return moves def process_test_cases(test_cases): results = [] for s, k in test_cases: results.append(min_moves_to_k_distinct(s, k)) return results"},{"question":"class Grid: def __init__(self, n, m): self.n = n self.m = m self.grid = [[0] * m for _ in range(n)] def update(self, x1, y1, x2, y2, val): Increase the value of each element in a specified sub-section of the grid by a given value. for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): self.grid[i][j] += val def query(self, x1, y1, x2, y2): Calculate the sum of the elements in a specified sub-section of the grid. total = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): total += self.grid[i][j] return total def process_operations(n, m, operations): Process the given update and query operations on the grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. operations (List[str]): List of operations to be performed on the grid. Returns: List[int]: Results of the query operations. >>> process_operations(4, 5, [\\"U 1 1 3 3 2\\", \\"Q 1 1 2 2\\", \\"U 2 2 4 4 3\\", \\"Q 2 2 3 3\\", \\"Q 1 1 4 5\\"]) [8, 20, 45] >>> process_operations(1, 1, [\\"U 1 1 1 1 5\\", \\"Q 1 1 1 1\\"]) [5] >>> process_operations(2, 2, [\\"U 1 1 2 2 1\\", \\"U 1 1 2 2 2\\", \\"Q 1 1 2 2\\"]) [12] >>> process_operations(3, 3, [\\"U 1 1 3 3 3\\", \\"U 1 1 3 3 2\\", \\"Q 1 1 3 3\\"]) [45] >>> process_operations(3, 3, [\\"Q 1 1 3 3\\"]) [0] grid = Grid(n, m) results = [] for operation in operations: parts = operation.split() cmd = parts[0] x1, y1, x2, y2 = map(int, parts[1:5]) if cmd == 'U': val = int(parts[5]) grid.update(x1, y1, x2, y2, val) elif cmd == 'Q': results.append(grid.query(x1, y1, x2, y2)) return results","solution":"class Grid: def __init__(self, n, m): self.n = n self.m = m self.grid = [[0] * m for _ in range(n)] def update(self, x1, y1, x2, y2, val): for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): self.grid[i][j] += val def query(self, x1, y1, x2, y2): total = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): total += self.grid[i][j] return total def process_operations(n, m, operations): grid = Grid(n, m) results = [] for operation in operations: parts = operation.split() cmd = parts[0] x1, y1, x2, y2 = map(int, parts[1:5]) if cmd == 'U': val = int(parts[5]) grid.update(x1, y1, x2, y2, val) elif cmd == 'Q': results.append(grid.query(x1, y1, x2, y2)) return results"},{"question":"def calculate_bonus_stars(N: int, stars: List[int]) -> int: Calculate the total bonus stars participants would receive if they purchased all items in the array. >>> calculate_bonus_stars(6, [3, 3, 3, 1, 1, 2]) 11 >>> calculate_bonus_stars(5, [1, 1, 1, 1, 1]) 5","solution":"def calculate_bonus_stars(N, stars): total_bonus = 0 i = 0 while i < N: j = i while j < N and stars[j] == stars[i]: j += 1 length = j - i if length > 1: total_bonus += length * stars[i] i = j return total_bonus # Sample Input N = 6 stars = [3, 3, 3, 1, 1, 2] print(calculate_bonus_stars(N, stars)) # Output: 11"},{"question":"def is_beautiful_permutation(n: int, permutation: List[int]) -> str: Determines if the given permutation from 1 to n is beautiful. A permutation is beautiful if there are no two consecutive integers in decreasing order. >>> is_beautiful_permutation(5, [1, 2, 3, 4, 5]) == \\"YES\\" >>> is_beautiful_permutation(4, [2, 1, 4, 3]) == \\"NO\\" >>> is_beautiful_permutation(3, [1, 2, 3]) == \\"YES\\" >>> is_beautiful_permutation(2, [2, 1]) == \\"NO\\" >>> is_beautiful_permutation(6, [1, 3, 5, 2, 4, 6]) == \\"NO\\" >>> is_beautiful_permutation(1, [1]) == \\"YES\\" >>> is_beautiful_permutation(4, [1, 2, 3, 4]) == \\"YES\\" >>> is_beautiful_permutation(4, [4, 3, 2, 1]) == \\"NO\\" >>> is_beautiful_permutation(5, [5, 1, 2, 3, 4]) == \\"NO\\" >>> is_beautiful_permutation(8, [1, 2, 3, 4, 5, 6, 7, 8]) == \\"YES\\" >>> is_beautiful_permutation(6, [1, 6, 2, 5, 3, 4]) == \\"NO\\"","solution":"def is_beautiful_permutation(n, permutation): Determines if the given permutation from 1 to n is beautiful. A permutation is beautiful if there are no two consecutive integers in decreasing order. Parameters: n (int): The length of the permutation. permutation (list): The permutation of integers from 1 to n. Returns: str: \\"YES\\" if the permutation is beautiful, otherwise \\"NO\\". for i in range(1, n): if permutation[i] < permutation[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"def check_difference_pair_exists(n: int, k: int, arr: list) -> str: Determines if there exists a pair of indices (i, j) such that i != j and A[i] - A[j] = k. Parameters: n (int): The length of the array. k (int): The integer to check for the difference. arr (list of int): The elements of the array. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". >>> check_difference_pair_exists(5, 2, [1, 3, 5, 7, 9]) 'Yes' >>> check_difference_pair_exists(4, 10, [1, 2, 3, 4]) 'No' >>> check_difference_pair_exists(5, -4, [4, 8, 12, 16, 20]) 'Yes' >>> check_difference_pair_exists(5, 0, [1, 1, 1, 1, 1]) 'Yes' >>> check_difference_pair_exists(100000, 3, list(range(1, 100001))) 'Yes' >>> check_difference_pair_exists(6, 1000000000, [1, 5, 9, 14, 20, 25]) 'No' >>> check_difference_pair_exists(5, 999999999, [1, 1000000000, 2, 3, 8]) 'Yes'","solution":"def check_difference_pair_exists(n, k, arr): Determines if there exists a pair of indices (i, j) such that i != j and A[i] - A[j] = k. Parameters: n (int): The length of the array. k (int): The integer to check for the difference. arr (list of int): The elements of the array. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". value_set = set() for num in arr: if (num + k) in value_set or (num - k) in value_set: return \\"Yes\\" value_set.add(num) return \\"No\\""},{"question":"def is_strong_password(password: str) -> bool: Check if the given password is strong according to the specified criteria: - The password must be at least 8 characters long. - The password must contain at least one lowercase letter. - The password must contain at least one uppercase letter. - The password must contain at least one digit. - The password must contain at least one special character from \`!@#%^&*()-+\`. >>> is_strong_password(\\"Aa1!Aa1!\\") True >>> is_strong_password(\\"password\\") False from solution import is_strong_password def test_password_criteria_length(): assert is_strong_password(\\"Aa1!\\") == False assert is_strong_password(\\"Aa1!aa1!\\") == True def test_password_criteria_lowercase(): assert is_strong_password(\\"A1!AAAAAA\\") == False assert is_strong_password(\\"aA1!AAAA\\") == True def test_password_criteria_uppercase(): assert is_strong_password(\\"a1!aaaaaa\\") == False assert is_strong_password(\\"Aa1!aaaa\\") == True def test_password_criteria_digit(): assert is_strong_password(\\"Aa!aaaaa\\") == False assert is_strong_password(\\"Aa1!aaaa\\") == True def test_password_criteria_special_character(): assert is_strong_password(\\"Aa1AAAAA\\") == False assert is_strong_password(\\"Aa1!AAAA\\") == True def test_password_all_criteria_met(): assert is_strong_password(\\"Aa1!Aa1!\\") == True def test_password_missing_some_criteria(): assert is_strong_password(\\"password\\") == False assert is_strong_password(\\"Password1\\") == False assert is_strong_password(\\"Password!\\") == False assert is_strong_password(\\"password1!\\") == False","solution":"def is_strong_password(password: str) -> bool: Check if the password is strong based on given criteria. if len(password) < 8: return False has_lower = any(c.islower() for c in password) has_upper = any(c.isupper() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in '!@#%^&*()-+' for c in password) return has_lower and has_upper and has_digit and has_special"},{"question":"def mostFrequentSubstring(s: str, k: int) -> str: Returns the most frequent substring of length k in s. In case of a tie, returns the lexicographically smallest substring. >>> mostFrequentSubstring(\\"abcabcabc\\", 3) == \\"abc\\" >>> mostFrequentSubstring(\\"ababcbabab\\", 2) == \\"ab\\" >>> mostFrequentSubstring(\\"aaaaa\\", 1) == \\"a\\" >>> mostFrequentSubstring(\\"abcde\\", 5) == \\"abcde\\" >>> mostFrequentSubstring(\\"aabbaa\\", 2) == \\"aa\\" >>> mostFrequentSubstring(\\"a\\" * 100000, 1) == \\"a\\" >>> mostFrequentSubstring(\\"xyxyxyx\\", 2) == \\"xy\\"","solution":"def mostFrequentSubstring(s: str, k: int) -> str: Returns the most frequent substring of length k in s. In case of a tie, returns the lexicographically smallest substring. from collections import defaultdict # Dictionary to store frequency of each substring freq = defaultdict(int) # Iterate over all possible substrings of length k and count their frequency for i in range(len(s) - k + 1): substring = s[i:i + k] freq[substring] += 1 # Find the most frequent substring max_freq = max(freq.values()) candidates = [substring for substring, count in freq.items() if count == max_freq] # Return the lexicographically smallest substring among the candidates return min(candidates)"},{"question":"def count_paths(n: int, m: int, grid: List[str]) -> int: Calculate the number of distinct paths Alice can take from the start to the destination, avoiding the impassable cells. Args: n (int): number of rows in the park grid. m (int): number of columns in the park grid. grid (List[str]): the park grid where '0' denotes a passable cell and '1' denotes an impassable cell. Returns: int: the number of distinct paths from the top-left corner to the bottom-right corner of the park. Examples: >>> count_paths(3, 3, [\\"000\\", \\"010\\", \\"000\\"]) 2 >>> count_paths(4, 4, [\\"0000\\", \\"0100\\", \\"0010\\", \\"0000\\"]) 4 pass","solution":"def count_paths(n, m, grid): if grid[0][0] == '1' or grid[n-1][m-1] == '1': return 0 # If start or end is not passable, return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '1': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Reading input and preparing grid def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [data[i + 2] for i in range(n)] # Print result print(count_paths(n, m, grid)) if __name__ == \\"__main__\\": main()"},{"question":"def minimum_bicycle_lane_length(n: int, m: int, paths: List[Tuple[int, int, int]]) -> int: Determines the minimum required total length of paths to connect all huts with the shortest possible cumulative path length. Parameters: n (int): Number of huts. m (int): Number of paths. paths (list of tuples): List containing (u, v, w) tuples where u and v are huts and w is the path length. Returns: int: The minimum total length of the paths required. >>> minimum_bicycle_lane_length(4, 5, [(1, 2, 10), (1, 3, 6), (1, 4, 5), (2, 3, 4), (3, 4, 3)]) == 12 >>> minimum_bicycle_lane_length(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) == 3 >>> minimum_bicycle_lane_length(2, 1, [(1, 2, 5)]) == 5 >>> minimum_bicycle_lane_length(4, 4, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 3, 1)]) == 5 pass","solution":"def minimum_bicycle_lane_length(n, m, paths): Determines the minimum required total length of paths to connect all huts with the shortest possible cumulative path length (MST). Parameters: n (int): Number of huts. m (int): Number of paths. paths (list of tuples): List containing (u, v, w) tuples where u and v are huts and w is the path length. Returns: int: The minimum total length of the paths required. from heapq import heappop, heappush # Prim's algorithm initialization adj_list = [[] for _ in range(n + 1)] for u, v, w in paths: adj_list[u].append((w, v)) adj_list[v].append((w, u)) total_length = 0 visited = [False] * (n + 1) min_heap = [(0, 1)] # (cost, node) while min_heap: cost, node = heappop(min_heap) if visited[node]: continue total_length += cost visited[node] = True for edge_cost, neighbor in adj_list[node]: if not visited[neighbor]: heappush(min_heap, (edge_cost, neighbor)) return total_length"},{"question":"def min_operations_to_equalize(nums): Returns the minimum number of operations to make all elements of the list equal. >>> min_operations_to_equalize([1, 2, 3]) 2 >>> min_operations_to_equalize([10]) 0 >>> min_operations_to_equalize([5, 5, 5, 5]) 0 >>> min_operations_to_equalize([1, 10, 2, 9]) 16 >>> min_operations_to_equalize([1, 1000000000]) 999999999 >>> min_operations_to_equalize([-5, -4, -3, -2, -1]) 6 >>> min_operations_to_equalize([-10, 0, 10, 20]) 40","solution":"def min_operations_to_equalize(nums): Returns the minimum number of operations to make all elements of the list equal. if not nums: return 0 # sort the list to find the median nums.sort() # finding the median median = nums[len(nums) // 2] # calculating the total operations required to make all elements equal to the median operations = sum(abs(num - median) for num in nums) return operations"},{"question":"from typing import List def num_islands(grid: List[List[str]]) -> int: Find the number of islands in a given 2D grid map where '1' represents land and '0' represents water. >>> num_islands([ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ]) 1 >>> num_islands([ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ]) 3 >>> num_islands([[\\"1\\"]]) 1 >>> num_islands([[\\"0\\"]]) 0 >>> num_islands([ [\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"0\\",\\"1\\",\\"0\\",\\"1\\"], [\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"0\\",\\"1\\",\\"0\\",\\"1\\"] ]) 8 >>> num_islands([]) 0","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid: return 0 m, n = len(grid), len(grid[0]) num_islands = 0 def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0': return grid[x][y] = '0' # mark the visited land as '0' dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) for i in range(m): for j in range(n): if grid[i][j] == '1': num_islands += 1 dfs(i, j) return num_islands"},{"question":"def sum_of_absolute_differences(n, a, q, queries): For each query, find the sum of absolute differences between each consecutive element in the subarray. Parameters: n (int): The length of the array a. a (list of int): The array of integers. q (int): Number of queries. queries (list of tuples): Each tuple contains two integers (l, r). Returns: list of int: The result of each query as a list. pass # Example Usage n = 5 a = [1, 3, 6, 7, 9] q = 3 queries = [(1, 3), (2, 5), (1, 5)] result = sum_of_absolute_differences(n, a, q, queries) print(result) # Output should be [5, 6, 12]","solution":"def sum_of_absolute_differences(n, a, q, queries): For each query, find the sum of absolute differences between each consecutive element in the subarray. Parameters: n (int): The length of the array a. a (list of int): The array of integers. q (int): Number of queries. queries (list of tuples): Each tuple contains two integers (l, r). Returns: list of int: The result of each query as a list. results = [] for l, r in queries: sum_diff = 0 for i in range(l-1, r-1): sum_diff += abs(a[i+1] - a[i]) results.append(sum_diff) return results"},{"question":"from typing import List def transform_to_palindrome(test_cases: List[str]) -> List[str]: Determines if it is possible to rearrange the given string into a palindrome. For possible cases, output \\"YES\\" followed by the rearranged palindrome. For impossible cases, output \\"NO\\". >>> transform_to_palindrome([\\"aabb\\"]) [\\"YES\\", \\"abba\\"] >>> transform_to_palindrome([\\"racecar\\"]) [\\"YES\\", \\"racecar\\"] >>> transform_to_palindrome([\\"abcd\\"]) [\\"NO\\"]","solution":"from collections import Counter def can_form_palindrome(s): Checks if the string can form a palindrome. count = Counter(s) odd_count = sum(1 for c in count.values() if c % 2 != 0) # A string can be rearranged to a palindrome if at most one character has an odd count return odd_count <= 1 def rearrange_to_palindrome(s): Rearranges the string into a palindrome if possible. count = Counter(s) odd_char = [char for char in count if count[char] % 2 != 0] # Palindrome rearrangement half = [] middle = [] for char, cnt in count.items(): half.extend(char * (cnt // 2)) if cnt % 2 != 0: middle.append(char) first_half = ''.join(half) second_half = ''.join(reversed(half)) palindrome = first_half + ''.join(middle) + second_half return palindrome def transform_to_palindrome(test_cases): results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") results.append(rearrange_to_palindrome(s)) else: results.append(\\"NO\\") return results"},{"question":"def max_assignable_tasks(n, m, developers, tasks): Returns the maximum number of tasks that can be assigned to developers such that each task is assigned to a developer whose skill level is greater than or equal to the skill level required for the task. :param n: Number of developers :param m: Number of tasks :param developers: List of skill levels of the developers :param tasks: List of skill level requirements of the tasks :return: Maximum number of assignable tasks >>> max_assignable_tasks(4, 5, [3, 1, 4, 2], [2, 1, 3, 2, 5]) 4 >>> max_assignable_tasks(3, 3, [5, 3, 7], [2, 5, 4]) 3 >>> max_assignable_tasks(3, 5, [1, 1, 1], [1, 1, 1, 1, 1]) 3 >>> max_assignable_tasks(5, 5, [2, 3, 4, 5, 6], [1, 2, 3, 4, 5]) 5 >>> max_assignable_tasks(1, 1, [5], [5]) 1 >>> max_assignable_tasks(1, 1, [4], [5]) 0 >>> max_assignable_tasks(5, 0, [1, 2, 3, 4, 5], []) 0 >>> max_assignable_tasks(0, 5, [], [1, 2, 3, 4, 5]) 0","solution":"def max_assignable_tasks(n, m, developers, tasks): Returns the maximum number of tasks that can be assigned to developers such that each task is assigned to a developer whose skill level is greater than or equal to the skill level required for the task. :param n: Number of developers :param m: Number of tasks :param developers: List of skill levels of the developers :param tasks: List of skill level requirements of the tasks :return: Maximum number of assignable tasks developers.sort() tasks.sort() i = j = count = 0 while i < n and j < m: if developers[i] >= tasks[j]: count += 1 j += 1 i += 1 return count"},{"question":"def construct_full_binary_tree(n: int, b: List[int]) -> Tuple[str, int, List[Tuple[int, int, int]]]: Constructs a full binary tree from the given sequence of values if possible. Returns a tuple (status, depth, tree) where: - status is \\"YES\\" if a full binary tree can be constructed, otherwise \\"NO\\" - depth is the depth of the resulting tree if construction is possible - tree is a list of tuples (node_value, left_child_index, right_child_index) >>> construct_full_binary_tree(3, [2, 3, 1]) (\\"YES\\", 1, [(2, 1, 2), (3, -1, -1), (1, -1, -1)]) >>> construct_full_binary_tree(7, [4, 2, 6, 5, 1, 3, 7]) (\\"YES\\", 2, [(4, 1, 2), (2, 3, 4), (6, 5, 6), (5, -1, -1), (1, -1, -1), (3, -1, -1), (7, -1, -1)]) >>> construct_full_binary_tree(4, [1, 2, 3, 4]) (\\"NO\\", 0, [])","solution":"def construct_full_binary_tree(n, b): Constructs a full binary tree from the given sequence of values if possible. Returns a tuple (status, depth, tree) where: - status is \\"YES\\" if a full binary tree can be constructed, otherwise \\"NO\\" - depth is the depth of the resulting tree if construction is possible - tree is a list of tuples (node_value, left_child_index, right_child_index) if n % 2 == 0: return \\"NO\\", 0, [] if n == 1: return \\"YES\\", 0, [(b[0], -1, -1)] def build_tree(index): if index >= n or index < 0: return -1, -1, -1 left = 2 * index + 1 right = 2 * index + 2 left_index, _, _ = build_tree(left) if left < n else (-1, -1, -1) right_index, _, _ = build_tree(right) if right < n else (-1, -1, -1) return index, left_index, right_index depth = 0 remaining_nodes = n while remaining_nodes > 1: remaining_nodes = (remaining_nodes - 1) // 2 depth += 1 tree = [] for i in range(n): _, left, right = build_tree(i) tree.append((b[i], left, right)) return \\"YES\\", depth, tree"},{"question":"def shortest_path_warehouse(T, test_cases): Calculate the shortest path for the helicopter to deliver goods from a starting warehouse to a destination warehouse in a grid. The helicopter can move up, down, left, or right, but it cannot move diagonally. Each movement to an adjacent warehouse takes exactly 1 unit of time. Some warehouse cells may be blocked, meaning that the helicopter cannot pass through these warehouses. :param T: An integer, the number of test cases (1 ≤ T ≤ 10). :param test_cases: A list of test cases, each containing: - Two integers N and M (1 ≤ N, M ≤ 1000), representing the number of rows and columns in the grid, respectively. - N lines, each containing a string of M characters, where each character represents the type of warehouse cell: - '.' indicates an open warehouse that the helicopter can pass through. - '#' indicates a blocked warehouse that the helicopter cannot pass through. - Two pairs of integers (sx, sy) and (dx, dy), representing the starting and destination warehouse locations. Both pairs are 0-based indices (0 ≤ sx, sy, dx, dy < N). :return: A list of integers, each representing the minimum time required for the helicopter to reach the destination warehouse for the corresponding test case, or -1 if it is impossible to reach the destination. >>> T = 2 >>> test_cases = [ >>> (5, 5, [\\".....\\", \\"..#..\\", \\"..#..\\", \\".....\\", \\".....\\"], (0, 0), (4, 4)), >>> (4, 4, [\\".#..\\", \\"....\\", \\"#...\\", \\"...#\\"], (0, 0), (3, 3)) >>> ] >>> shortest_path_warehouse(T, test_cases) == [8, -1]","solution":"from collections import deque def shortest_path_warehouse(T, test_cases): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right results = [] for case in test_cases: N, M, grid, (sx, sy), (dx, dy) = case if grid[sx][sy] == '#' or grid[dx][dy] == '#': results.append(-1) continue visited = [[False for _ in range(M)] for _ in range(N)] queue = deque([(sx, sy, 0)]) # (current_x, current_y, distance) visited[sx][sy] = True found = False while queue: x, y, dist = queue.popleft() if (x, y) == (dx, dy): results.append(dist) found = True break for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) if not found: results.append(-1) return results"},{"question":"def are_points_collinear(points): Determines if all given points in a 2D plane are collinear. :param points: A list of tuples where each tuple represents a point (x, y) :return: \\"YES\\" if all points are collinear, otherwise \\"NO\\" from solution import are_points_collinear def test_collinear_points(): points = [(1, 2), (2, 3), (3, 4), (4, 5)] assert are_points_collinear(points) == \\"YES\\" def test_non_collinear_points(): points = [(1, 1), (2, 2), (3, 1)] assert are_points_collinear(points) == \\"NO\\" def test_two_points(): points = [(10, 15), (20, 30)] assert are_points_collinear(points) == \\"YES\\" def test_same_points(): points = [(5, 5), (5, 5), (5, 5)] assert are_points_collinear(points) == \\"YES\\" def test_vertical_line(): points = [(1, 2), (1, 3), (1, 5)] assert are_points_collinear(points) == \\"YES\\" def test_horizontal_line(): points = [(2, 3), (5, 3), (10, 3)] assert are_points_collinear(points) == \\"YES\\"","solution":"def are_points_collinear(points): Determines if all given points in a 2D plane are collinear. :param points: A list of tuples where each tuple represents a point (x, y) :return: \\"YES\\" if all points are collinear, otherwise \\"NO\\" if len(points) <= 2: return \\"YES\\" (x0, y0), (x1, y1) = points[:2] dx = x1 - x0 dy = y1 - y0 for x, y in points[2:]: if (y - y0) * dx != (x - x0) * dy: return \\"NO\\" return \\"YES\\""},{"question":"def hasRepeatedSubsequence(s: str) -> str: Determines if the input string contains a repeated subsequence. >>> hasRepeatedSubsequence(\\"AABEBCDD\\") == \\"Yes\\" >>> hasRepeatedSubsequence(\\"XYYXY\\") == \\"Yes\\" >>> hasRepeatedSubsequence(\\"ABCDEFG\\") == \\"No\\" pass","solution":"def hasRepeatedSubsequence(s: str) -> str: Determines if the input string contains a repeated subsequence. Parameters: s (str): The input string containing only uppercase English letters. Returns: str: \\"Yes\\" if there is a repeated subsequence, otherwise \\"No\\". n = len(s) if n <= 2: return \\"No\\" from collections import Counter counts = Counter(s) # If any character appears more than twice, it means there is a repeated subsequence if any(count > 2 for count in counts.values()): return \\"Yes\\" # Create a set to store already seen characters seen = set() for ch in s: if ch in seen: return \\"Yes\\" seen.add(ch) return \\"No\\""},{"question":"def sortByLength(arr, N): Sorts an array of strings based on the length of each string. If two strings have the same length, their relative order remains the same as in the input array. Parameters: arr (list): A list containing N strings. N (int): The number of strings in the array. Returns: list: The sorted list of strings. >>> sortByLength([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"pear\\"], 4) [\\"kiwi\\", \\"pear\\", \\"apple\\", \\"banana\\"] >>> sortByLength([\\"abc\\", \\"de\\", \\"fghi\\", \\"jk\\", \\"lmnop\\"], 5) [\\"de\\", \\"jk\\", \\"abc\\", \\"fghi\\", \\"lmnop\\"]","solution":"def sortByLength(arr, N): Sorts an array of strings based on the length of each string. If two strings have the same length, their relative order remains the same as in the input array. Parameters: arr (list): A list containing N strings. N (int): The number of strings in the array. Returns: list: The sorted list of strings. return sorted(arr, key=len)"},{"question":"def max_coins(N: int, M: int, coins: List[int], tunnels: List[Tuple[int, int]]) -> int: Determine the maximum number of coins the hunter can collect. Args: N (int): Number of caves. M (int): Number of tunnels. coins (List[int]): List of coins in each cave. tunnels (List[Tuple[int, int]]): List of tuples representing the tunnels between caves. Returns: int: Maximum number of coins that can be collected. Example: >>> max_coins(4, 4, [5, 3, 4, 7], [(1, 2), (2, 3), (3, 4), (4, 1)]) 14 >>> max_coins(5, 5, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) 15","solution":"from collections import defaultdict, deque def max_coins(N, M, coins, tunnels): # Create adjacency list for the graph representation of the caves graph = defaultdict(list) for a, b in tunnels: graph[a-1].append(b-1) graph[b-1].append(a-1) # A visited array to keep track of visited caves visited = [False] * N max_collected = 0 # Helper function to perform BFS and calculate total coins in connected component def bfs(start): queue = deque([start]) visited[start] = True total_coins = 0 while queue: node = queue.popleft() total_coins += coins[node] for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return total_coins # Explore all possible starting points for i in range(N): if not visited[i]: max_collected = max(max_collected, bfs(i)) return max_collected"},{"question":"def first_unique_char(s: str) -> str: Find the first unique character in the string. Args: s (str): Input string containing lowercase English letters. Returns: str: The first unique character or an empty string if no unique character exists. >>> first_unique_char(\\"swiss\\") 'w' >>> first_unique_char(\\"aabbcc\\") '' >>> first_unique_char(\\"abcdef\\") 'a' >>> first_unique_char(\\"abac\\") 'b'","solution":"def first_unique_char(s: str) -> str: Find the first unique character in the string. Args: s (str): Input string containing lowercase English letters. Returns: str: The first unique character or an empty string if no unique character exists. # A dictionary to count the occurrences of each character char_count = {} # Loop over each character to populate the char_count dictionary for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has a count of 1 for char in s: if char_count[char] == 1: return char # If no unique character is found, return an empty string return \\"\\""},{"question":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of parentheses needed to make the given string a valid parentheses sequence. >>> min_add_to_make_valid(\\"()))((\\") 4 >>> min_add_to_make_valid(\\"()\\") 0 >>> min_add_to_make_valid(\\"(((())))\\") 0 >>> min_add_to_make_valid(\\"))(\\") 3","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses needed to make the given string a valid parentheses sequence. left_needed = 0 # count of '(' needed right_needed = 0 # count of ')' needed for char in s: if char == '(': right_needed += 1 else: # char is ')' if right_needed > 0: right_needed -= 1 else: left_needed += 1 return left_needed + right_needed"},{"question":"def calculate_minimum_hp(dungeon: List[List[int]]) -> int: Calculate the knight's minimum initial health required to save the princess. Args: dungeon (List[List[int]]): m x n grid representing the health/damage in each cell. Returns: int: Minimum initial health required for the knight to reach the princess. Examples: >>> calculate_minimum_hp([[-2, -3, 3], [-5, -10, 1], [10, 30, -5]]) 7 >>> calculate_minimum_hp([[0, 0, 0], [1, 1, -1]]) 1","solution":"def calculate_minimum_hp(dungeon): Calculate the knight's minimum initial health required to save the princess. Args: dungeon (List[List[int]]): m x n grid representing the health/damage in each cell. Returns: int: Minimum initial health required for the knight to reach the princess. m, n = len(dungeon), len(dungeon[0]) dp = [[0] * n for _ in range(m)] dp[-1][-1] = max(1, 1 - dungeon[-1][-1]) for i in range(m-2, -1, -1): dp[i][-1] = max(1, dp[i+1][-1] - dungeon[i][-1]) for j in range(n-2, -1, -1): dp[-1][j] = max(1, dp[-1][j+1] - dungeon[-1][j]) for i in range(m-2, -1, -1): for j in range(n-2, -1, -1): min_hp_on_exit = min(dp[i+1][j], dp[i][j+1]) dp[i][j] = max(1, min_hp_on_exit - dungeon[i][j]) return dp[0][0]"},{"question":"def process_queries(queries): Processes the given list of queries and returns the results for \\"Cr\\" type queries. Args: queries (list): A list of query strings. Returns: list: A list containing the results of \\"Cr\\" type queries.","solution":"def process_queries(queries): Processes the given list of queries and returns the results for \\"Cr\\" type queries. Args: queries (list): A list of query strings. Returns: list: A list containing the results of \\"Cr\\" type queries. grid = {} result = [] for query in queries: parts = query.split() if parts[0] == 'Ia': x, y, c = int(parts[1]), int(parts[2]), parts[3] if (x, y) not in grid: grid[(x, y)] = c elif parts[0] == 'Cr': x1, y1, x2, y2 = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) count = 0 for x in range(x1, x2 + 1): for y in range(y1, y2 + 1): if (x, y) in grid: grid[(x, y)] = 'R' count += 1 result.append(count) return result"},{"question":"def process_operations(n: int, s: str, operations: List[Tuple[int, int, int, int]]) -> List[int]: Perform given Q operations on the string S. Type 1: Rotate the substring S[L:R] to the left by K positions. Type 2: Query the number of distinct characters in the substring S[L:R]. Args: n (int): Length of the string S. s (str): The string S of length N. operations (List[Tuple[int, int, int, int]]): List of operations to perform. Returns: List[int]: List of results for Type 2 operations. Examples: >>> process_operations(7, \\"abacaba\\", [(2, 1, 3), (1, 2, 5, 2), (2, 1, 3), (1, 1, 7, 3), (2, 4, 6)]) [2, 2, 2] >>> process_operations(5, \\"abcde\\", [(2, 1, 5)]) [5] >>> process_operations(1, \\"a\\", [(2, 1, 1)]) [1] >>> process_operations(6, \\"abcdef\\", [(1, 2, 5, 2), (2, 1, 6)]) [6] >>> process_operations(6, \\"abcdef\\", [(1, 1, 6, 2), (2, 1, 3), (1, 2, 4, 1), (2, 1, 6)]) [3, 6]","solution":"def rotate_left(s, k): return s[k:] + s[:k] def process_operations(n, s, operations): s = list(s) result = [] for op in operations: if op[0] == 1: L, R, K = op[1], op[2], op[3] L, R = L - 1, R - 1 # convert to 0-indexed K = K % (R - L + 1) s = s[:L] + list(rotate_left(s[L:R+1], K)) + s[R+1:] elif op[0] == 2: L, R = op[1], op[2] L, R = L - 1, R - 1 # convert to 0-indexed substring = s[L:R+1] distinct_chars = len(set(substring)) result.append(distinct_chars) return result"},{"question":"def minimal_operations(k: int, s: str) -> int: Returns the minimal number of operations to ensure no letter appears more than k times consecutively in the string s. >>> minimal_operations(2, 'aaabbbcc') 2 >>> minimal_operations(3, 'aabbaabbaa') 0 >>> minimal_operations(1, 'abcd') 0 >>> minimal_operations(1, 'aaaaa') 4 >>> minimal_operations(2, 'abcabcabc') 0 >>> minimal_operations(2, 'mmmmmm') 2 >>> minimal_operations(2, 'abababab') 0","solution":"def minimal_operations(k, s): Returns the minimal number of operations to ensure no letter appears more than k times consecutively in the string s. n = len(s) count = 0 i = 0 while i < n: j = i # Count consecutive characters while j < n and s[j] == s[i]: j += 1 # Calculate the number of operations needed for the current block if j - i > k: count += (j - i - 1) // k i = j return count"},{"question":"from typing import List, Tuple def maximum_sum_after_deletion(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum sum that can be obtained from the resulting array of length N-1 after deleting exactly one element from the array A for each test case. >>> maximum_sum_after_deletion(3, [(3, [1, 2, 3]), (4, [-1, -2, -3, -4]), (5, [1, -2, 3, -4, 5])]) [5, -6, 7] results = [] for i in range(T): A = test_cases[i][1] total_sum = sum(A) max_sum = total_sum - min(A) results.append(max_sum) return results def process_input(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Process the input data to extract the number of test cases and the list of test cases >>> process_input('3n3n1 2 3n4n-1 -2 -3 -4n5n1 -2 3 -4 5') (3, [(3, [1, 2, 3]), (4, [-1, -2, -3, -4]), (5, [1, -2, 3, -4, 5])]) input_lines = input_data.strip().split() T = int(input_lines[0]) index = 1 cases = [] for _ in range(T): N = int(input_lines[index]) A = list(map(int, input_lines[index + 1: index + 1 + N])) cases.append((N, A)) index += N + 1 return T, cases def output_results(results: List[int]) -> None: Output the results for each test case >>> output_results([5, -6, 7]) 5 -6 7 for result in results: print(result)","solution":"def maximum_sum_after_deletion(T, test_cases): results = [] for i in range(T): A = test_cases[i][1] total_sum = sum(A) max_sum = total_sum - min(A) results.append(max_sum) return results def process_input(input_data): input_lines = input_data.strip().split() T = int(input_lines[0]) index = 1 cases = [] for _ in range(T): N = int(input_lines[index]) A = list(map(int, input_lines[index + 1: index + 1 + N])) cases.append((N, A)) index += N + 1 return T, cases def output_results(results): for result in results: print(result)"},{"question":"def count_buildings_with_sunlight(n: int, heights: List[int]) -> int: Determines the number of buildings that will have sunlight. Args: n : int : the number of buildings in the street heights : list of int : the heights of the buildings from left to right Returns: int : the number of buildings that will have sunlight >>> count_buildings_with_sunlight(5, [3, 1, 4, 2, 5]) == 3 >>> count_buildings_with_sunlight(3, [1, 2, 3]) == 3","solution":"def count_buildings_with_sunlight(n, heights): Determines the number of buildings that will have sunlight. Args: n : int : the number of buildings in the street heights : list of int : the heights of the buildings from left to right Returns: int : the number of buildings that will have sunlight count = 0 max_height = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List def findCombinations(candidates: List[int], target: int) -> List[List[int]]: Given an array of integers and a target integer value, find all unique combinations in the array where the candidate numbers sum up to the target. Each candidate number may be used an unlimited number of times. >>> findCombinations([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> findCombinations([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> findCombinations([7], 7) [[7]] >>> findCombinations([5], 10) [[5, 5]] >>> findCombinations([1, 2, 3], 4) [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2]] >>> findCombinations([5, 10, 12], 3) []","solution":"from typing import List def findCombinations(candidates: List[int], target: int) -> List[List[int]]: def backtrack(remain, combo, start): if remain == 0: result.append(list(combo)) return elif remain < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remain - candidates[i], combo, i) combo.pop() result = [] candidates.sort() backtrack(target, [], 0) return result"},{"question":"class Leaderboard: def __init__(self): self.scores = {} self.sorted_scores = [] def add_score(self, player_id, score): Adds a new player with the given score, or updates the score of an existing player. If a player with the given id already exists, their new score will replace their current score. pass def get_rank(self, player_id): Returns the rank of the player with the given id. The rank is determined as follows: - Scores must be sorted in descending order. - Players with the same score must have the same rank. - The next player(s) will have the rank immediately following the group of players with the same score. pass def process_leaderboard(operations): Processes a list of operations for the leaderboard system. >>> operations = [\\"add_score 1 100\\", \\"add_score 2 200\\", \\"get_rank 1\\", \\"add_score 1 300\\", \\"get_rank 1\\", \\"get_rank 2\\", \\"add_score 2 300\\"] >>> process_leaderboard(operations) [2, 1, 2] leaderboard = Leaderboard() results = [] for op in operations: parts = op.split() if parts[0] == 'add_score': id_ = int(parts[1]) score = int(parts[2]) leaderboard.add_score(id_, score) elif parts[0] == 'get_rank': id_ = int(parts[1]) results.append(leaderboard.get_rank(id_)) return results","solution":"class Leaderboard: def __init__(self): self.scores = {} self.sorted_scores = [] def add_score(self, player_id, score): if player_id in self.scores: # Remove old score from sorted_scores old_score = self.scores[player_id] self.sorted_scores.remove((old_score, player_id)) self.scores[player_id] = score # Insert new score self.sorted_scores.append((score, player_id)) self.sorted_scores.sort(reverse=True, key=lambda x: (x[0], x[1])) def get_rank(self, player_id): player_score = self.scores[player_id] rank = 1 for score, pid in self.sorted_scores: if score == player_score: return rank rank += 1 def process_leaderboard(operations): leaderboard = Leaderboard() results = [] for op in operations: parts = op.split() if parts[0] == 'add_score': id_ = int(parts[1]) score = int(parts[2]) leaderboard.add_score(id_, score) elif parts[0] == 'get_rank': id_ = int(parts[1]) results.append(leaderboard.get_rank(id_)) return results # Example usage: # operations = [ # \\"add_score 1 100\\", # \\"add_score 2 200\\", # \\"get_rank 1\\", # \\"add_score 1 300\\", # \\"get_rank 1\\", # \\"get_rank 2\\", # \\"add_score 2 300\\" # ] # process_leaderboard(operations) will output [2, 1, 2]"},{"question":"def process_operations(n: int, operations: List[str]) -> str: Process a series of book stacking operations and return the ID of the book on top of the stack after all operations are performed. Args: n (int): Number of operations. operations (List of str): List of operations to be processed. Returns: str: ID of the book on top or \\"No books\\" if the stack is empty. Examples: >>> process_operations(5, [\\"ADD 5\\", \\"ADD 10\\", \\"UNDO\\", \\"ADD 7\\", \\"UNDO\\"]) '5' >>> process_operations(6, [\\"ADD 5\\", \\"ADD 10\\", \\"UNDO\\", \\"UNDO\\", \\"UNDO\\", \\"UNDO\\"]) 'No books' >>> process_operations(3, [\\"ADD 1\\", \\"ADD 2\\", \\"UNDO\\"]) '1' stack = [] for operation in operations: if operation.startswith(\\"ADD\\"): _, book_id = operation.split() stack.append(int(book_id)) elif operation == \\"UNDO\\": if stack: stack.pop() if stack: return str(stack[-1]) else: return \\"No books\\"","solution":"def process_operations(n, operations): Process a series of book stacking operations and return the ID of the book on top of the stack after all operations are performed. Args: n (int): Number of operations. operations (list of str): List of operations to be processed. Returns: str: ID of the book on top or \\"No books\\" if the stack is empty. stack = [] for operation in operations: if operation.startswith(\\"ADD\\"): _, book_id = operation.split() stack.append(int(book_id)) elif operation == \\"UNDO\\": if stack: stack.pop() if stack: return str(stack[-1]) else: return \\"No books\\""},{"question":"class TreeNode: def __init__(self, key): self.data = key self.left = None self.right = None class DoubleListNode: def __init__(self, key): self.data = key self.prev = None self.next = None def bToDLL(root): Given a binary tree, convert it into a Doubly Linked List (DLL) in such a way that the order of the DLL is the same as the Inorder traversal of the binary tree. The left and right pointers in nodes are to be used as previous and next pointers respectively in the converted DLL. The head pointer of the Doubly Linked List should point to the left-most node in the binary tree. Args: root (TreeNode): Root of the binary tree Returns: DoubleListNode: Head of the resulting Doubly Linked List Examples: >>> root = TreeNode(10) >>> root.left = TreeNode(12) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(25) >>> root.left.right = TreeNode(30) >>> root.right.left = TreeNode(36) >>> head = bToDLL(root) >>> result = [] >>> current = head >>> while current: >>> result.append(current.data) >>> current = current.next >>> result [25, 12, 30, 10, 36, 15] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> head = bToDLL(root) >>> result = [] >>> current = head >>> while current: >>> result.append(current.data) >>> current = current.next >>> result [1, 2, 3] # Your code here def tree_to_dll_list(tree_root): dll_head = bToDLL(tree_root) result = [] current = dll_head while current: result.append(current.data) current = current.next return result","solution":"class TreeNode: def __init__(self, key): self.data = key self.left = None self.right = None class DoubleListNode: def __init__(self, key): self.data = key self.prev = None self.next = None def bToDLL(root): if not root: return None # Initialize pointers needed for conversion head = None # Head of the DLL prev = None # Previous visited node for linking # Helper function to convert binary tree to DLL def inorder_convert(node): nonlocal head, prev if node: # Recur on the left child inorder_convert(node.left) # Update head of DLL if this is the leftmost node if not prev: head = node else: # Adjust the links node.left = prev prev.right = node # Mark this node as previous before moving to right subtree prev = node # Recur on the right child inorder_convert(node.right) inorder_convert(root) # Convert the nodes to DoubleListNode type current = head dll_head = DoubleListNode(current.data) dll_last = dll_head current = current.right while current: new_node = DoubleListNode(current.data) dll_last.next = new_node new_node.prev = dll_last dll_last = new_node current = current.right return dll_head def tree_to_dll_list(tree_root): dll_head = bToDLL(tree_root) result = [] current = dll_head while current: result.append(current.data) current = current.next return result"},{"question":"def rearrange_string(S: str, K: int) -> str: Determine if it's possible to rearrange the string such that no two adjacent characters are the same and the re-arranged string has at least K distinct characters. If such a permutation of S is possible, return the rearranged string; otherwise, return \\"IMPOSSIBLE\\". >>> rearrange_string(\\"aabbcc\\", 3) \\"abcabc\\" >>> rearrange_string(\\"aaaabbbb\\", 2) \\"abababab\\" >>> rearrange_string(\\"aabb\\", 3) \\"IMPOSSIBLE\\"","solution":"from heapq import heappush, heappop def rearrange_string(S, K): if K > 26: return \\"IMPOSSIBLE\\" # Count frequency of each character in the string frequency = {} for char in S: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Priority Queue (Max-Heap based on the frequency) max_heap = [] for char, freq in frequency.items(): heappush(max_heap, (-freq, char)) result = [] wait_queue = [] # To keep track of previously used characters considering 'K' distinct requirement while max_heap: freq, char = heappop(max_heap) result.append(char) wait_queue.append((char, freq + 1)) # decrement frequency because we've used it once if len(wait_queue) < K: continue # Release and push character from wait_queue back to the heap to be used again release_char, release_freq = wait_queue.pop(0) if release_freq < 0: heappush(max_heap, (release_freq, release_char)) if len(result) != len(S): return \\"IMPOSSIBLE\\" return ''.join(result)"},{"question":"def longest_subarray_with_two_distinct(arr): Write a function that takes an integer array \`arr\` and returns the length of the longest contiguous subarray that contains at most two distinct numbers. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 3]) 4 >>> longest_subarray_with_two_distinct([]) 0 >>> longest_subarray_with_two_distinct([1, 1, 1, 1]) 4 >>> longest_subarray_with_two_distinct([1, 2]) 2","solution":"def longest_subarray_with_two_distinct(arr): if len(arr) == 0: return 0 from collections import defaultdict left = 0 right = 0 max_length = 0 count = defaultdict(int) while right < len(arr): count[arr[right]] += 1 while len(count) > 2: count[arr[left]] -= 1 if count[arr[left]] == 0: del count[arr[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def longest_unique_substring(s: str) -> int: Finds the length of the longest substring without repeating characters. Args: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. Examples: >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"abcdef\\") 6","solution":"def longest_unique_substring(s): Finds the length of the longest substring without repeating characters. Args: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 max_len = 0 start = 0 used_chars = {} for end in range(n): if s[end] in used_chars and used_chars[s[end]] >= start: start = used_chars[s[end]] + 1 used_chars[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def longest_common_prefix(strings): Find the length of the longest common prefix among a list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 2 >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) 0 pass def process_test_cases(test_cases): Process multiple test cases to find the longest common prefix lengths. >>> process_test_cases([ [\\"flower\\", \\"flow\\", \\"flight\\"], [\\"dog\\", \\"racecar\\", \\"car\\", \\"drum\\"] ]) [2, 0] pass","solution":"def longest_common_prefix(strings): if not strings: return 0 # Sort the strings to get the smallest and largest string lexicographically adjacent sorted_strings = sorted(strings) first_str = sorted_strings[0] last_str = sorted_strings[-1] # Compare characters of the first and the last string to find the common prefix i = 0 while i < len(first_str) and i < len(last_str) and first_str[i] == last_str[i]: i += 1 return i def process_test_cases(test_cases): results = [] for strings in test_cases: results.append(longest_common_prefix(strings)) return results"},{"question":"def number_of_paths(n: int) -> int: Returns the number of distinct paths in an n x n grid from the top-left corner to the bottom-right corner where only movements to the right and down are allowed. Args: n (int): the size of the grid (1 ≤ n ≤ 100) Returns: int: the number of distinct paths Example: >>> number_of_paths(3) 6 >>> number_of_paths(2) 2","solution":"def number_of_paths(n): Returns the number of distinct paths in an n x n grid from the top-left corner to the bottom-right corner where only movements to the right and down are allowed. # The number of ways to reach a cell (i, j) is the sum of ways to reach (i-1, j) and (i, j-1) # This is analogous to pascal's triangle, where each cell is the binomial coefficient C(i+j, j) grid = [[0] * n for _ in range(n)] for i in range(n): grid[i][0] = 1 for j in range(n): grid[0][j] = 1 for i in range(1, n): for j in range(1, n): grid[i][j] = grid[i-1][j] + grid[i][j-1] return grid[n-1][n-1]"},{"question":"def MaxTasksCompleted(deadline, duration, N): Returns the maximum number of tasks Alice can complete without missing any deadlines. Parameters: deadline (list): List of deadlines for each task duration (list): List of durations for each task N (int): Number of tasks Returns: int: Maximum number of tasks that can be completed within their deadlines # Example test cases def test_example_1(): assert MaxTasksCompleted([4, 2, 5, 8], [2, 1, 3, 2], 4) == 3 def test_example_2(): assert MaxTasksCompleted([3, 3, 3, 3], [3, 3, 3, 3], 4) == 1 def test_all_tasks_meetable(): assert MaxTasksCompleted([10, 15, 20, 25], [5, 5, 5, 5], 4) == 4 def test_no_tasks_meetable(): assert MaxTasksCompleted([1, 1, 1, 1], [2, 2, 2, 2], 4) == 0 def test_some_tasks_meetable(): assert MaxTasksCompleted([10, 10, 10, 10], [2, 2, 2, 8], 4) == 3 def test_large_input(): deadlines = [1000000000] * 100000 durations = [1] * 100000 assert MaxTasksCompleted(deadlines, durations, 100000) == 100000 def test_single_task(): assert MaxTasksCompleted([5], [5], 1) == 1 assert MaxTasksCompleted([5], [6], 1) == 0","solution":"def MaxTasksCompleted(deadline, duration, N): Returns the maximum number of tasks Alice can complete without missing any deadlines. Parameters: deadline (list): List of deadlines for each task duration (list): List of durations for each task N (int): Number of tasks Returns: int: Maximum number of tasks that can be completed within their deadlines tasks = sorted(zip(deadline, duration), key=lambda x: x[0]) current_day = 0 count = 0 for d, t in tasks: if current_day + t <= d: current_day += t count += 1 return count"},{"question":"def count_rectangles(w: int, h: int) -> int: Returns the number of different ways to divide a w x h garden into smaller rectangular sections with integer dimensions. >>> count_rectangles(2, 3) 18 >>> count_rectangles(1, 1) 1 >>> count_rectangles(4, 2) 30","solution":"def count_rectangles(w, h): Returns the number of different ways to divide a w x h garden into smaller rectangular sections with integer dimensions. count = 0 for width in range(1, w + 1): for height in range(1, h + 1): count += (w - width + 1) * (h - height + 1) return count"},{"question":"from typing import List, Tuple def handle_operations(N: int, K: int, A: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: Joe is a software developer working with sequences of integers. He has a sequence A of N integers and needs to perform K operations. Each operation can be one of the following two types: 1. E X Y : Replace the value at the Xth position in the sequence with Y. 2. S L R : Calculate the sum of even numbers in the subarray from the Lth to the Rth position (inclusive). This function processes a list of operations on the list and returns the results of all sum operations. >>> handle_operations(6, 4, [3, 2, 7, 4, 6, 9], [('S', 2, 5), ('E', 3, 8), ('S', 1, 6), ('S', 4, 6)]) [12, 20, 10] >>> handle_operations(5, 2, [2, 4, 6, 8, 10], [('S', 1, 5), ('S', 2, 4)]) [30, 18] >>> handle_operations(5, 2, [1, 3, 5, 7, 9], [('S', 1, 5), ('S', 3, 5)]) [0, 0] >>> handle_operations(6, 3, [1, 2, 3, 4, 5, 6], [('S', 2, 5), ('E', 5, 8), ('S', 1, 6)]) [6, 20]","solution":"def handle_operations(N, K, A, operations): results = [] for operation in operations: op_type = operation[0] if op_type == 'E': X, Y = operation[1], operation[2] A[X - 1] = Y elif op_type == 'S': L, R = operation[1], operation[2] sum_even = sum(x for x in A[L-1:R] if x % 2 == 0) results.append(sum_even) return results"},{"question":"def fibonacci(n): Write a function that takes a positive integer \`n\` and returns a list of the first \`n\` terms of the Fibonacci sequence. If \`n\` <= 0, an empty list is returned. >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(8) [0, 1, 1, 2, 3, 5, 8, 13] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list containing the first n terms of the Fibonacci sequence. If n <= 0, an empty list is returned. if n <= 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] sequence = [0, 1] for i in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"def can_segment(s: str, dictionary: set) -> bool: Determine if a string can be segmented into a space-separated sequence of one or more dictionary words. >>> can_segment(\\"applepenapple\\", {\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"}) True >>> can_segment(\\"pineapplepenapple\\", {\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"}) True >>> can_segment(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) False","solution":"def can_segment(s: str, dictionary: set) -> bool: Determine if a string can be segmented into a space-separated sequence of one or more dictionary words. Parameters: - s: the input string. - dictionary: a set of strings representing the dictionary. Returns: True if the string can be segmented, False otherwise. n = len(s) if n == 0: return True # dp[i] means s[:i] can be segmented into dictionary words dp = [False] * (n + 1) dp[0] = True # An empty string can be segmented for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in dictionary: dp[i] = True break return dp[n]"},{"question":"def find_towers(heights): Returns a list of towers in the given list of building heights. A \\"tower\\" is a building taller than its adjacent buildings. >>> find_towers([1, 2, 3, 1, 5, 6, 2, 3, 2, 1]) [3, 6, 3] >>> find_towers([5, 1, 5, 1, 5, 1]) [5, 5, 5] >>> find_towers([1, 2, 3, 4, 5]) [5] >>> find_towers([]) [] >>> find_towers([5]) [5] >>> find_towers([3, 1]) [3] >>> find_towers([1, 5]) [5] >>> find_towers([1, 1, 1, 1]) [] >>> find_towers([1, 3, 1]) [3] >>> find_towers([2, 1, 2, 1, 2]) [2, 2, 2]","solution":"def find_towers(heights): Returns a list of towers in the given list of building heights. A \\"tower\\" is a building taller than its adjacent buildings. towers = [] n = len(heights) for i in range(n): if i == 0: # First building if n == 1 or heights[i] > heights[i + 1]: towers.append(heights[i]) elif i == n - 1: # Last building if heights[i] > heights[i - 1]: towers.append(heights[i]) else: # Middle buildings if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: towers.append(heights[i]) return towers"},{"question":"def max_path_sum(grid): Calculate the maximum path sum in a grid from the top-left to the bottom-right corner. The input grid is provided as a list of lists containing non-negative integers. The function should return an integer representing the maximum sum path. Example: >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_path_sum([ ... [5, 4], ... [2, 9] ... ]) 18","solution":"def max_path_sum(grid): R = len(grid) C = len(grid[0]) # Create a 2D DP array dp = [[0] * C for _ in range(R)] # Initialize the first cell with the grid value dp[0][0] = grid[0][0] # Fill the first row for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, R): for j in range(1, C): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum path sum return dp[R-1][C-1]"},{"question":"from typing import List def char_value(c: str) -> int: Return the alphabetical value of the character c. return ord(c) - ord('a') + 1 def max_value_for_alice(S: str) -> int: Calculate the maximum value Alice can obtain from string S. def max_values_for_test_cases(T: int, test_cases: List[str]) -> List[int]: Calculate the maximum values Alice can obtain for a list of test cases. >>> max_values_for_test_cases(2, [\\"abc\\", \\"defg\\"]) [4, 12] >>> max_values_for_test_cases(1, [\\"a\\"]) [1] >>> max_values_for_test_cases(1, [\\"aaa\\"]) [2] >>> max_values_for_test_cases(1, [\\"zyxw\\"]) [50] >>> max_values_for_test_cases(1, [\\"cba\\"]) [4]","solution":"def char_value(c): Return the alphabetical value of the character c. return ord(c) - ord('a') + 1 def max_value_for_alice(S): Calculate the maximum value Alice can obtain. # Convert each character to its corresponding value letter_values = [char_value(c) for c in S] # Sort the values in descending order to maximize the scores letter_values.sort(reverse=True) # Alice picks every second starting from the first alice_value = sum(letter_values[i] for i in range(0, len(letter_values), 2)) return alice_value def max_values_for_test_cases(T, test_cases): results = [] for i in range(T): S = test_cases[i] results.append(max_value_for_alice(S)) return results"},{"question":"from typing import List def max_consecutive_buildings(n: int, heights: List[int]) -> int: Returns the maximum number of consecutive buildings that can be visited starting from the first building. Parameters: n (int): Number of buildings. heights (List[int]): List of heights of the buildings. Returns: int: Maximum number of consecutive buildings that can be visited. >>> max_consecutive_buildings(6, [1, 2, 2, 3, 5, 1]) 5 >>> max_consecutive_buildings(4, [4, 3, 2, 1]) 1 pass # Test cases def test_example_1(): assert max_consecutive_buildings(6, [1, 2, 2, 3, 5, 1]) == 5 def test_example_2(): assert max_consecutive_buildings(4, [4, 3, 2, 1]) == 1 def test_all_same_heights(): assert max_consecutive_buildings(4, [3, 3, 3, 3]) == 4 def test_increasing_heights(): assert max_consecutive_buildings(5, [1, 2, 3, 4, 5]) == 5 def test_decreasing_heights(): assert max_consecutive_buildings(5, [5, 4, 3, 2, 1]) == 1 def test_large_input(): assert max_consecutive_buildings(100000, [i for i in range(1, 100001)]) == 100000 def test_large_decreasing_input(): assert max_consecutive_buildings(100000, [i for i in range(100000, 0, -1)]) == 1","solution":"def max_consecutive_buildings(n, heights): Returns the maximum number of consecutive buildings that can be visited starting from the first building. Parameters: n (int): Number of buildings. heights (List[int]): List of heights of the buildings. Returns: int: Maximum number of consecutive buildings that can be visited. max_count = 1 current_count = 1 for i in range(1, n): if heights[i] >= heights[i - 1]: current_count += 1 max_count = max(max_count, current_count) else: break return max_count"},{"question":"def minimum_signal_time(N: int, positions: List[int]) -> int: Returns the minimum time required for every house to receive signals from every other house in the village. Args: N : int : the number of houses in the village positions : List[int] : the positions of the houses in a row described by N integers Returns: int : the minimum time required for every house to receive signals from every other house in the village Examples: >>> minimum_signal_time(4, [1, 3, 6, 7]) 6 >>> minimum_signal_time(2, [1, 2]) 1 >>> minimum_signal_time(2, [10, 20]) 10","solution":"def minimum_signal_time(N, positions): Returns the minimum time required for every house to receive signals from every other house in the village. max_time = 0 for i in range(N - 1): # Calculate the time it takes to send signals from house i to the last house time = positions[-1] - positions[i] max_time = max(max_time, time) return max_time"},{"question":"from typing import List, Tuple def shortest_path_island(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determine the shortest path from the top-left to the bottom-right corner of the island grid. each test case. If no path exists, return -1. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): List of test cases where each test case is a tuple containing the dimensions of the grid and the grid itself. Returns: List[int]: List of shortest path lengths from top-left to bottom-right for each test case. Example: >>> shortest_path_island(3, [ ... (3, 3, [ ... [1, 0, 0], ... [2, 2, 0], ... [1, 1, 1] ... ]), ... (3, 3, [ ... [0, 0, 0], ... [2, 2, 0], ... [1, 1, 1] ... ]), ... (4, 4, [ ... [1, 0, 2, 2], ... [1, 1, 0, 1], ... [0, 2, 1, 2], ... [0, 1, 0, 2] ... ]) ... ]) == [4, -1, 6] >>> shortest_path_island(1, [ ... (1, 1, [ ... [0] ... ]) ... ]) == [-1] >>> shortest_path_island(1, [ ... (1, 1, [ ... [1] ... ]) ... ]) == [0] >>> shortest_path_island(1, [ ... (3, 3, [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) ... ]) == [-1] >>> shortest_path_island(1, [ ... (3, 3, [ ... [1, 2, 2], ... [1, 0, 2], ... [1, 2, 1] ... ]) ... ]) == [4]","solution":"from collections import deque def shortest_path_island(T, test_cases): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] results = [] for case in test_cases: m, n, grid = case if grid[0][0] == 0: results.append(-1) continue visited = [[False] * n for _ in range(m)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True found = False while queue: r, c, dist = queue.popleft() if r == m - 1 and c == n - 1: results.append(dist) found = True break for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]: if grid[nr][nc] == 1 or grid[nr][nc] == 2: queue.append((nr, nc, dist + 1)) visited[nr][nc] = True elif grid[r][c] == 2: queue.append((nr, nc, dist + 1)) visited[nr][nc] = True if not found: results.append(-1) return results"},{"question":"def countSubstrings(S: str) -> int: Returns the count of substrings that start and end with the same character in the binary string S. >>> countSubstrings(\\"abcab\\") 7 >>> countSubstrings(\\"aaaa\\") 10","solution":"def countSubstrings(S): Returns the count of substrings that start and end with the same character in the binary string S. # Count occurrences of each character count = [0] * 26 # There are 26 lowercase English alphabets for char in S: count[ord(char) - ord('a')] += 1 # Calculate the number of substrings for each character total_substrings = 0 for cnt in count: if cnt > 0: total_substrings += cnt * (cnt + 1) // 2 return total_substrings"},{"question":"def can_form_flexible_palindrome(N: int) -> str: Determines if an integer can be rearranged to form a palindrome. >>> can_form_flexible_palindrome(12321) \\"YES\\" >>> can_form_flexible_palindrome(123) \\"NO\\" >>> can_form_flexible_palindrome(7) \\"YES\\" >>> can_form_flexible_palindrome(11111) \\"YES\\" >>> can_form_flexible_palindrome(1221) \\"YES\\" >>> can_form_flexible_palindrome(12345654321) \\"YES\\" >>> can_form_flexible_palindrome(123456554321) \\"NO\\" >>> can_form_flexible_palindrome(1122334455) \\"YES\\" >>> can_form_flexible_palindrome(1122334445) \\"NO\\"","solution":"def can_form_flexible_palindrome(N): Determines if an integer can be rearranged to form a palindrome. Parameters: N (int): The integer to check Returns: str: \\"YES\\" if the integer can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter digits_str = str(N) digit_counts = Counter(digits_str) odd_count = sum(1 for count in digit_counts.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of all prime factors of n in ascending order. >>> prime_factors(28) [2, 7] >>> prime_factors(100) [2, 5] >>> prime_factors(37) [37] >>> prime_factors(60) [2, 3, 5] >>> prime_factors(1) [] def test_prime_factors_of_28(): assert prime_factors(28) == [2, 7] def test_prime_factors_of_100(): assert prime_factors(100) == [2, 5] def test_prime_factors_of_37(): assert prime_factors(37) == [37] def test_prime_factors_of_60(): assert prime_factors(60) == [2, 3, 5] def test_prime_factors_of_1(): assert prime_factors(1) == [] def test_prime_factors_of_2(): assert prime_factors(2) == [2] def test_prime_factors_of_3(): assert prime_factors(3) == [3] def test_prime_factors_of_7(): assert prime_factors(7) == [7] def test_prime_factors_of_999983(): assert prime_factors(999983) == [999983] def test_prime_factors_of_large_composite(): assert prime_factors(123456) == [2, 3, 643]","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of all prime factors of n in ascending order. if n <= 1: return [] factors = [] # Check for number of 2s that divide n if n % 2 == 0: factors.append(2) while n % 2 == 0: n = n // 2 # n must be odd at this point so a skip of 2 (i = i + 2) can be used for i in range(3, int(n**0.5) + 1, 2): # While i divides n, add i and divide n if n % i == 0: factors.append(i) while n % i == 0: n = n // i # If n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"def photos_tag_intersections(n, photos): Returns the intersections of tags between each pair of photos. Parameters: n (int): Number of photos photos (list of lists): List containing sublists where each sublist contains tags for a specific photo. Returns: list of tuples: Each tuple contains (pair indices, count of shared tags) pass from solution import photos_tag_intersections def test_photos_tag_intersections_basic(): photos = [ [1, 2], [2, 3, 4], [1, 4] ] expected = [(1, 2, 1), (1, 3, 1), (2, 3, 1)] result = photos_tag_intersections(3, photos) assert result == expected def test_photos_tag_intersections_all_disjoint(): photos = [ [1, 2], [3, 4], [5, 6] ] expected = [(1, 2, 0), (1, 3, 0), (2, 3, 0)] result = photos_tag_intersections(3, photos) assert result == expected def test_photos_tag_intersections_all_intersect(): photos = [ [1, 2], [2, 1], [1, 2] ] expected = [(1, 2, 2), (1, 3, 2), (2, 3, 2)] result = photos_tag_intersections(3, photos) assert result == expected def test_photos_tag_intersections_single_photo(): photos = [ [1, 2, 3] ] expected = [] result = photos_tag_intersections(1, photos) assert result == expected def test_photos_tag_intersections_empty_photo_tags(): photos = [ [], [1, 2, 3], [] ] expected = [(1, 2, 0), (1, 3, 0), (2, 3, 0)] result = photos_tag_intersections(3, photos) assert result == expected","solution":"def photos_tag_intersections(n, photos): Returns the intersections of tags between each pair of photos. Parameters: n (int): Number of photos photos (list of lists): List containing sublists where each sublist contains tags for a specific photo. Returns: list of tuples: Each tuple contains (pair indices, count of shared tags) intersections = [] for i in range(n): for j in range(i + 1, n): tags_i = set(photos[i]) tags_j = set(photos[j]) shared_tags = tags_i.intersection(tags_j) intersections.append((i + 1, j + 1, len(shared_tags))) return intersections"},{"question":"def maximize_absolute_differences(n, nums): Rearranges the sequence to maximize the sum of absolute differences between adjacent integers. :param n: integer, the number of integers in the sequence. :param nums: list of integers, the sequence of integers. :return: list of integers, rearranged to maximize the sum of absolute differences. >>> maximize_absolute_differences(4, [1, 2, 3, 4]) in ([1, 4, 2, 3], [4, 1, 3, 2]) >>> maximize_absolute_differences(3, [10, 20, 30]) in ([10, 30, 20], [30, 10, 20])","solution":"def maximize_absolute_differences(n, nums): Rearranges the sequence to maximize the sum of absolute differences between adjacent integers. :param n: integer, the number of integers in the sequence. :param nums: list of integers, the sequence of integers. :return: list of integers, rearranged to maximize the sum of absolute differences. nums.sort() result = [] i, j = 0, n - 1 while i < j: result.append(nums[i]) result.append(nums[j]) i += 1 j -= 1 if i == j: result.append(nums[i]) return result"},{"question":"def arrange_gemstones(n: int, gems: List[Tuple[int, int]]) -> str: Arrange the gemstones according to Emilia's rules. Parameters: n (int): Number of gemstones gems (list of tuples): A list of (value, position) of each gemstone Returns: str: \\"Impossible\\" if the arrangement can't be met, or \\"YES\\" followed by a list of positions in the arranged order. Example: >>> arrange_gemstones(5, [(2, 5), (1, 3), (2, 1), (1, 2), (3, 4)]) 'YESn2 3 1 5 4' >>> arrange_gemstones(4, [(2, 4), (3, 1), (1, 2), (3, 3)]) 'YESn2 4 1 3' >>> arrange_gemstones(3, [(4, 2), (3, 1), (4, 1)]) 'Impossible'","solution":"def arrange_gemstones(n, gems): Arrange the gemstones according to Emilia's rules. Parameters: n (int): Number of gemstones gems (list of tuples): A list of (value, position) of each gemstone Returns: str: \\"Impossible\\" if the arrangement can't be met, or \\"YES\\" followed by a list of positions in the arranged order. # Sort the gemstones by value first, and then by position in case of tie sorted_gems = sorted(gems, key=lambda x: (x[0], x[1])) # Check for any duplicate positions positions_seen = set() for gem in sorted_gems: if gem[1] in positions_seen: return \\"Impossible\\" positions_seen.add(gem[1]) # Extract and return the sorted positions sorted_positions = [gem[1] for gem in sorted_gems] return \\"YESn\\" + \\" \\".join(map(str, sorted_positions)) # Example function call if __name__ == \\"__main__\\": n = 5 gems = [(2, 5), (1, 3), (2, 1), (1, 2), (3, 4)] print(arrange_gemstones(n, gems)) # Should output \\"YESn2 3 1 5 4\\""},{"question":"from typing import List, Tuple def max_product_subarray(arr: List[int]) -> int: Returns the maximum product of a contiguous subarray. >>> max_product_subarray([1, 2, 3, 4, 5]) == 120 >>> max_product_subarray([6, 0, 4, 5, 10, 2]) == 400 >>> max_product_subarray([0, 2, 3, 4, 0, 1, 2, 2]) == 24 # Your code here def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns the results as a list. >>> process_test_cases(3, [(5, [1, 2, 3, 4, 5]), (6, [6, 0, 4, 5, 10, 2]), (8, [0, 2, 3, 4, 0, 1, 2, 2])]) == [120, 400, 24] >>> process_test_cases(2, [(4, [2, 3, -2, 4]), (3, [-2, 0, -1])]) == [6, 0] # Your code here","solution":"def max_product_subarray(arr): Returns the maximum product of a contiguous subarray. if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num == 0: max_product = min_product = 0 else: temp_max = max(num, max_product * num, min_product * num) min_product = min(num, max_product * num, min_product * num) max_product = temp_max result = max(result, max_product) return result def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list. results = [] for i in range(t): n, array = test_cases[i] results.append(max_product_subarray(array)) return results"},{"question":"import heapq from typing import List def min_cost_to_tie_ropes(ropes: List[int]) -> int: Calculate the minimum cost to tie all ropes into a single rope. :param ropes: List of integers representing lengths of ropes. :return: Minimum cost to tie all ropes into a single rope. >>> min_cost_to_tie_ropes([8, 4, 6, 12]) 58 >>> min_cost_to_tie_ropes([1, 2, 5, 10, 35, 89]) 224 >>> min_cost_to_tie_ropes([10]) 0 >>> min_cost_to_tie_ropes([10, 20]) 30 >>> min_cost_to_tie_ropes([1, 2, 3, 4, 5]) 33 >>> min_cost_to_tie_ropes([1000, 2000, 3000, 4000, 5000]) 33000 >>> min_cost_to_tie_ropes([]) 0","solution":"import heapq def min_cost_to_tie_ropes(ropes): Returns the minimum cost to tie all ropes into a single rope. if len(ropes) <= 1: return 0 heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"def find_shortest_paths(test_cases): Given a list of test cases where each test case contains a grid, find the length of the shortest path from the top-left corner to the bottom-right corner without passing through obstacles. Each cell in the grid can either be free space '.' or an obstacle '#'. :param test_cases: List of tuples where each tuple contains: - R (int): the number of rows in the grid - C (int): the number of columns in the grid - grid (List[str]): the grid itself :return: List[int] where each element is the length of the shortest path for the corresponding test case. If no path exists, the element should be -1. >>> find_shortest_paths([(3, 3, ['...', '.#.', '...'])]) [4] >>> find_shortest_paths([(4, 4, ['..#.', '#..#', '.#..', '....'])]) [6] >>> find_shortest_paths([(3, 3, ['...', '#', '...'])]) [-1] >>> find_shortest_paths([(4, 4, ['#...', '....', '....', '....'])]) [-1] >>> find_shortest_paths([(2, 2, ['', ''])]) [-1] >>> find_shortest_paths([(1, 1, ['.'])]) [0] >>> test_case = [ '.....', '..#..', '#...#', '.#...', '.....' ] >>> find_shortest_paths([(5, 5, test_case)]) [8]","solution":"from collections import deque def shortest_path(grid, R, C): if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == R - 1 and col == C - 1: return dist for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < R and 0 <= newCol < C and grid[newRow][newCol] == '.' and (newRow, newCol) not in visited: visited.add((newRow, newCol)) queue.append((newRow, newCol, dist + 1)) return -1 def find_shortest_paths(test_cases): results = [] for R, C, grid in test_cases: results.append(shortest_path(grid, R, C)) return results"},{"question":"def longest_word(text: str) -> str: Returns the longest word from a given string. A word is defined as a sequence of alphabetical characters. >>> longest_word(\\"The quick brown fox.\\") == \\"quick\\" >>> longest_word(\\"A journey of a thousand miles begins with a single step\\") == \\"thousand\\" >>> longest_word(\\"To be, or not to be, that is the question\\") == \\"question\\" >>> longest_word(\\"123 abcde fghi! jklmn opqrst\\") == \\"opqrst\\" >>> longest_word(\\"One two six ten\\") == \\"One\\" >>> longest_word(\\"The BIGGEST decision of all\\") == \\"decision\\" import re def test_longest_word_simple(): assert longest_word(\\"The quick brown fox.\\") == \\"quick\\" def test_longest_word_complex(): assert longest_word(\\"A journey of a thousand miles begins with a single step\\") == \\"thousand\\" def test_longest_word_punctuation(): assert longest_word(\\"To be, or not to be, that is the question\\") == \\"question\\" def test_longest_word_with_numbers(): assert longest_word(\\"123 abcde fghi! jklmn opqrst\\") == \\"opqrst\\" def test_longest_word_all_same_length(): assert longest_word(\\"One two six ten\\") == \\"One\\" def test_longest_word_mixed_case(): assert longest_word(\\"The BIGGEST decision of all\\") == \\"decision\\"","solution":"import re def longest_word(text): Returns the longest word from a given string. A word is a sequence of alphabetical characters. # Using regex to keep only alphabetical characters and spaces cleaned_text = re.sub(r'[^a-zA-Zs]', '', text) words = cleaned_text.split() longest = max(words, key=len) return longest"},{"question":"def min_changes_to_palindrome(n: int, s: str) -> int: Determine the minimum number of character changes needed to make the string a palindrome. :param n: Length of the string (1 ≤ n ≤ 105) :param s: The original string consisting of lowercase English letters :return: Minimum number of character changes needed >>> min_changes_to_palindrome(5, 'abcca') 1 >>> min_changes_to_palindrome(4, 'abcd') 2 >>> min_changes_to_palindrome(6, 'abccba') 0","solution":"def min_changes_to_palindrome(n, s): Returns the minimum number of changes to turn the string s into a palindrome. :param n: Length of the string :param s: The original string :return: Minimum number of character changes needed changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"def validate_isbn_10(S: str) -> str: Validates the given ISBN-10 identifier. Parameters: S (str): The ISBN-10 as a string of length 10. Returns: str: \\"Valid ISBN\\" if the ISBN-10 is valid, otherwise \\"Invalid ISBN\\". >>> validate_isbn_10(\\"0306406152\\") 'Valid ISBN' >>> validate_isbn_10(\\"123456789X\\") 'Valid ISBN' >>> validate_isbn_10(\\"0306406153\\") 'Invalid ISBN' >>> validate_isbn_10(\\"1234567890\\") 'Invalid ISBN'","solution":"def validate_isbn_10(S): Validates the given ISBN-10 identifier. Parameters: S (str): The ISBN-10 as a string of length 10. Returns: str: \\"Valid ISBN\\" if the ISBN-10 is valid, otherwise \\"Invalid ISBN\\". if len(S) != 10: return \\"Invalid ISBN\\" total = 0 for i in range(10): char = S[i] if char == 'X' and i == 9: value = 10 elif char.isdigit(): value = int(char) else: return \\"Invalid ISBN\\" total += (i + 1) * value if total % 11 == 0: return \\"Valid ISBN\\" else: return \\"Invalid ISBN\\""},{"question":"def averageEvenNumbers(nums): Filters out even numbers in a list and returns the average of those even numbers. If there are no even numbers, returns 0. >>> averageEvenNumbers([1, 2, 3, 4, 5]) # 3 >>> averageEvenNumbers([7, 11, 13, 5]) # 0 >>> averageEvenNumbers([2, 4, 6, 8]) # 5 pass # Unit Tests def test_average_even_numbers_mixed(): assert averageEvenNumbers([1, 2, 3, 4, 5]) == 3 def test_average_even_numbers_none(): assert averageEvenNumbers([7, 11, 13, 5]) == 0 def test_average_even_numbers_all_even(): assert averageEvenNumbers([2, 4, 6, 8]) == 5 def test_average_even_numbers_all_odd(): assert averageEvenNumbers([1, 3, 5, 7, 9]) == 0 def test_average_even_numbers_mixed_large(): assert averageEvenNumbers([10, 15, 20, 25, 30, 35]) == 20 def test_average_even_numbers_empty(): assert averageEvenNumbers([]) == 0 def test_average_even_numbers_single_even(): assert averageEvenNumbers([2]) == 2 def test_average_even_numbers_single_odd(): assert averageEvenNumbers([1]) == 0","solution":"def averageEvenNumbers(nums): Filters out even numbers and returns the average of those even numbers. If there are no even numbers, returns 0. even_numbers = list(filter(lambda x: x % 2 == 0, nums)) if not even_numbers: return 0 return sum(even_numbers) / len(even_numbers)"},{"question":"def max_consecutive_bloom_days(T: int, test_cases: List[List[Tuple[int, int]]]) -> List[int]: Determine the maximum number of consecutive days Maya can have at least one flower in bloom. Parameters: ---------- T : int Number of test cases. test_cases : List[List[Tuple[int, int]]] A list of test cases, where each test case is a list of tuples. Each tuple contains two integers, start and end, representing the day the flower starts blooming and the day it stops blooming (both inclusive). Returns: ------- List[int] A list of integers, each representing the maximum number of consecutive days at least one flower is in bloom for each test case. >>> max_consecutive_bloom_days(2, [[(1, 5), (10, 15), (20, 25)], [(50, 100), (30, 60)]]) [6, 71] >>> max_consecutive_bloom_days(1, [[(1, 5), (2, 6), (4, 8)]]) [8]","solution":"def max_consecutive_bloom_days(T, test_cases): This function takes in the number of test cases T and a list of test cases. Each test case is a list of tuples [(start1, end1), (start2, end2), ...]. It returns a list of integers representing the maximum number of consecutive days there is at least one type of flower in bloom for each test case. results = [] for i in range(T): intervals = test_cases[i] days = [0] * 366 # Mark days for each blooming period for start, end in intervals: for day in range(start, end + 1): days[day] = 1 # Find the maximum consecutive 1's max_consecutive = 0 current_consecutive = 0 for day in days: if day == 1: current_consecutive += 1 max_consecutive = max(max_consecutive, current_consecutive) else: current_consecutive = 0 results.append(max_consecutive) return results"},{"question":"def smallest_pumpkin_weight_range(n: int, weights: List[int]) -> int: Finds the smallest possible range of pumpkin weights within any group. >>> smallest_pumpkin_weight_range(1, [7]) 0 >>> smallest_pumpkin_weight_range(2, [7, 3]) 4 >>> smallest_pumpkin_weight_range(5, [7, 6, 2, 10, 3]) 1 >>> smallest_pumpkin_weight_range(8, [15, 12, 13, 11, 16, 19, 20, 14]) 1 >>> smallest_pumpkin_weight_range(5, [5, 5, 5, 5, 5]) 0 >>> smallest_pumpkin_weight_range(4, [1, 3, 5, 9]) 2 >>> smallest_pumpkin_weight_range(4, [9, 5, 3, 1]) 2","solution":"def smallest_pumpkin_weight_range(n, weights): Finds the smallest possible range of pumpkin weights within any group. Parameters: n (int): The number of participants. weights (list): List of integers representing the weights of the pumpkins. Returns: int: The smallest range (difference between maximum and minimum weight) within any group. if n == 1: return 0 weights.sort() min_range = float('inf') for i in range(1, n): current_range = weights[i] - weights[i - 1] if current_range < min_range: min_range = current_range return min_range"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there are any two distinct elements in the array that add up to the target sum. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False","solution":"def has_pair_with_sum(arr, target): Determines if there are any two distinct elements in the array that add up to the target sum. seen = set() for num in arr: needed = target - num if needed in seen: return True seen.add(num) return False"},{"question":"def min_abs_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum possible absolute difference between the sums of the two subarrays for each test case. >>> test_count = 3 >>> test_inputs = [ >>> (5, [1, 3, -2, 4, 6]), >>> (4, [10, -5, 3, 2]), >>> (6, [-2, 2, -3, 3, -4, 4]) >>> ] >>> min_abs_difference(test_count, test_inputs) [0, 0, 0] def process_input_output(t: int, inputs: List[Union[int, List[int]]]) -> List[Tuple[int, List[int]]]: Utility function to format the input and output correctly.","solution":"def min_abs_difference(t, test_cases): results = [] for case in test_cases: n, a = case total_sum = sum(a) min_diff = float('inf') left_sum = 0 for i in range(n-1): left_sum += a[i] right_sum = total_sum - left_sum min_diff = min(min_diff, abs(left_sum - right_sum)) results.append(min_diff) return results # Utility function to format the input and output correctly def process_input_output(t, inputs): test_cases = [] for i in range(t): n = inputs[2*i] a = inputs[2*i + 1] test_cases.append((n, a)) return test_cases"},{"question":"def longestWord(S: str, dict: List[str]) -> str: Given a string S and an array of strings dict[], find the longest string in dict[] that can be formed by deleting some characters of the given string S without reordering the remaining characters. If there are more than one possible results, return the longest string with the smallest lexicographical order. If there is no such string that can be formed, return an empty string. >>> longestWord(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) 'apple' >>> longestWord(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) 'a' >>> longestWord(\\"abpcplea\\", []) '' >>> longestWord(\\"abpcplea\\", [\\"x\\", \\"y\\", \\"z\\"]) '' >>> longestWord(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monk\\"]) 'apple' >>> longestWord(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"applf\\"]) 'apple'","solution":"def longestWord(S, dict): def is_subsequence(x, y): # Check if x is subsequence of y it = iter(y) return all(c in it for c in x) # Sort dictionary primarily by length in descending order and secondarily by lexicographical order dict.sort(key=lambda x: (-len(x), x)) for word in dict: if is_subsequence(word, S): return word return \\"\\""},{"question":"def partition_string(n: int, k: int, s: str) -> (int, List[str]): Partition the string into exactly k substrings such that the largest of these substrings is as small as possible. Args: n (int): The length of the string. k (int): The number of substrings. s (str): The string to be partitioned. Returns: Tuple[int, List[str]]: The length of the largest substring among the k substrings and the k substrings themselves. >>> partition_string(8, 3, \\"abcdefgh\\") (3, [\\"abc\\", \\"def\\", \\"gh\\"]) >>> partition_string(10, 4, \\"abcdefghij\\") (3, [\\"abc\\", \\"def\\", \\"ghi\\", \\"j\\"]) >>> partition_string(7, 2, \\"abcdefg\\") (4, [\\"abcd\\", \\"efg\\"])","solution":"def partition_string(n, k, s): # Calculate minimum maximum length of substrings min_max_length = (n + k - 1) // k parts = [] for i in range(k): start_index = i * min_max_length end_index = min(start_index + min_max_length, n) parts.append(s[start_index:end_index]) # Calculate length of the largest substring among the k substrings max_length = max(len(part) for part in parts) return max_length, parts"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values(root: Optional[TreeNode]) -> List[int]: Find the largest value in each row of the binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[int]: A list of integers representing the largest value in each row of the tree. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largest_values(root) [1, 3, 9] >>> root = TreeNode(10) >>> largest_values(root) [10] >>> largest_values(None) []","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values(root: Optional[TreeNode]) -> List[int]: Find the largest value in each row of the binary tree. if not root: return [] result = [] current_level = [root] while current_level: next_level = [] max_value = float('-inf') for node in current_level: if node.val > max_value: max_value = node.val if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) result.append(max_value) current_level = next_level return result"},{"question":"def locate_books(n: int, m: int, q: int, edges: List[Tuple[int, int, int]], start: int, book_shelves: List[int]) -> List[int]: Given the library structure and starting position, find the shortest path times to locate a series of books. Args: n - The number of shelves. m - The number of direct paths between shelves. q - The number of books to locate. edges - A list of tuples, each containing three integers u, v, and w representing a direct path from shelf u to shelf v with a travel time of w minutes. start - The starting shelf number. book_shelves - A list of integers representing the shelf numbers of the books that need to be located. Returns: A list of integers representing the shortest time from the starting shelf to the shelf of each book. If a shelf is not reachable, return -1 for that book. >>> locate_books(5, 7, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 8), (1, 4, 7), (4, 5, 2), (5, 3, 1), (2, 5, 5)], 1, [3, 5, 4]) [7, 8, 7] >>> locate_books(4, 4, 2, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2)], 1, [4, 3]) [3, 2] >>> locate_books(6, 8, 3, [(1, 2, 2), (2, 3, 4), (3, 4, 8), (4, 5, 16), (5, 6, 32), (6, 1, 64), (1, 3, 6), (3, 5, 128)], 1, [4, 5, 6]) [14, 30, 62]","solution":"import heapq def dijkstra(graph, start, n): # Initialize distances with infinity distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def locate_books(n, m, q, edges, start, book_shelves): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) shortest_paths = dijkstra(graph, start, n) result = [] for book in book_shelves: if shortest_paths[book] == float('inf'): result.append(-1) else: result.append(shortest_paths[book]) return result"},{"question":"def verify_sessions(n, rooms_info, k, attendees_info): Verifies that no room exceeds its maximum occupancy during any session. Args: n (int): Number of conference rooms. rooms_info (list): List of tuples with room details. k (int): Number of attendees. attendees_info (list): List of tuples with attendee schedules. Returns: str: \\"YES\\" if no room exceeds its maximum capacity, otherwise \\"NO\\". Examples: >>> verify_sessions(2, [(2, 10, 0, 60, 120, 60), (1, 5, 60, 60)], 3, [(2, 1, 0, 2, 60), (1, 1, 120), (2, 1, 60, 2, 60)]) \\"YES\\" >>> verify_sessions(1, [(2, 5, 0, 60, 120, 60)], 6, [(1, 1, 0)] * 6) \\"NO\\" >>> verify_sessions(3, [(2, 10, 0, 60, 120, 60), (1, 5, 60, 60), (1, 8, 180, 60)], 5, [(2, 1, 0, 2, 180), (1, 1, 120), (1, 2, 60), (1, 3, 180), (1, 2, 60)]) \\"YES\\" >>> verify_sessions(2, [(1, 3, 0, 120), (1, 4, 0, 120)], 2, [(1, 1, 0), (1, 2, 0)]) \\"YES\\" >>> verify_sessions(5, [(2, 1, 0, 60, 180, 60) for _ in range(5)], 5, [(1, i, 180) for i in range(1, 6)]) \\"YES\\"","solution":"def verify_sessions(n, rooms_info, k, attendees_info): # Initialize a dict to hold the occupant count of each session in each room. sessions_dict = {} for i in range(n): num_sessions = rooms_info[i][0] max_capacity = rooms_info[i][1] sessions = rooms_info[i][2:] room_sessions = [] for j in range(num_sessions): start_time = sessions[j * 2] duration = sessions[j * 2 + 1] end_time = start_time + duration room_sessions.append((start_time, end_time, max_capacity)) sessions_dict[i + 1] = room_sessions # Initialize a dict to track current occupants for sessions in each room. occupants_count = {i + 1: [0] * len(sessions_dict[i + 1]) for i in range(n)} # For each attendee, update the occupant count for the corresponding session. for i in range(k): num_attend_sessions = attendees_info[i][0] sessions = attendees_info[i][1:] for j in range(num_attend_sessions): room_num = sessions[j * 2] start_time = sessions[j * 2 + 1] # Find which session attendee attends in the specific room. for s_index, (start, end, max_cap) in enumerate(sessions_dict[room_num]): if start == start_time: occupants_count[room_num][s_index] += 1 if occupants_count[room_num][s_index] > max_cap: return \\"NO\\" return \\"YES\\" # Example usage n = 2 rooms_info = [(2, 10, 0, 60, 120, 60), (1, 5, 60, 60)] k = 3 attendees_info = [(2, 1, 0, 2, 60), (1, 1, 120), (2, 1, 60, 2, 60)] print(verify_sessions(n, rooms_info, k, attendees_info)) # Output should be \\"YES\\""},{"question":"def process_operations(operations): Process a sequence of banking operations and returns the final balance. Args: operations (list): A list of operations, where each operation is represented by a dictionary with a 'type' (string) and 'amount' (number). Returns: int/float: The final balance after processing all operations.","solution":"def process_operations(operations): Process a sequence of banking operations and returns the final balance. Args: operations (list): A list of operations, where each operation is represented by a dictionary with a 'type' (string) and 'amount' (number). Returns: int/float: The final balance after processing all operations. balance = 0 for operation in operations: if operation['type'] == 'deposit': balance += operation['amount'] elif operation['type'] == 'withdrawal' and operation['amount'] <= balance: balance -= operation['amount'] # Ignore 'balance' and invalid operations return balance"},{"question":"def max_travel_cost_reduction(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Determine the maximum possible reduction in travel cost using the zero-cost roads. Args: N : int : The number of cities M : int : The number of existing roads roads : List of Tuples : Each tuple contains three integers u, v, and l, meaning that there is a road between city u and city v with length l. Returns: int : The maximum possible reduction in travel cost Example: >>> max_travel_cost_reduction(5, 4, [(1, 2, 4), (1, 3, 3), (2, 3, 2), (4, 5, 1)]) 10 >>> max_travel_cost_reduction(3, 0, []) 0 >>> max_travel_cost_reduction(1, 0, []) 0","solution":"def max_travel_cost_reduction(N, M, roads): Returns the maximum possible reduction in travel cost using zero-cost roads. if N == 1 or M == 0: return 0 existing_road_sum = sum(l for _, _, l in roads) return existing_road_sum # Reading input import sys input = sys.stdin.read def main(): data = input().strip().split() N = int(data[0]) M = int(data[1]) roads = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index + 1]) l = int(data[index + 2]) roads.append((u, v, l)) index += 3 print(max_travel_cost_reduction(N, M, roads)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def min_jumps_to_last_platform(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of jumps required to reach the last platform from the first platform. If it is not possible to reach the last platform, return -1. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]): Each test case is a tuple consisting of an integer N and a list of integers P. Returns: List[int]: A list of integers representing the minimum number of jumps for each test case. If not possible, the value should be -1. >>> min_jumps_to_last_platform(3, [(5, [3, 3, 1, 0, 2]), (4, [2, 1, 0, 3]), (3, [1, 1, 1])]) [2, -1, 2] >>> min_jumps_to_last_platform(1, [(1, [5])]) [0] >>> min_jumps_to_last_platform(1, [(3, [1, 0, 2])]) [-1] >>> min_jumps_to_last_platform(1, [(4, [1000000000, 0, 0, 0])]) [1] >>> min_jumps_to_last_platform(1, [(6, [1, 1, 1, 1, 1, 1])]) [5] >>> min_jumps_to_last_platform(1, [(5, [2, 3, 1, 1, 4])]) [2]","solution":"def min_jumps_to_last_platform(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] P = test_cases[t][1] if N == 1: results.append(0) continue jumps = [float('inf')] * N jumps[0] = 0 for i in range(N): if jumps[i] == float('inf'): continue jump_power = P[i] for j in range(1, jump_power + 1): if i + j < N: jumps[i + j] = min(jumps[i + j], jumps[i] + 1) else: break if jumps[N-1] != float('inf'): break results.append(jumps[N-1] if jumps[N-1] != float('inf') else -1) return results"},{"question":"def calculate_total_distance(n, deliveries): Simulate the operations of a shipping company that delivers packages to different locations using a single delivery truck. The truck starts at (0, 0) and processes delivery requests in an optimal manner, minimizing total distance traveled. >>> calculate_total_distance(1, [(1, 3, 4)]) 14 >>> calculate_total_distance(1, [(2, 5, 2)]) 14 >>> calculate_total_distance(4, [(1, 3, 4), (2, 5, 2), (1, -2, -3), (2, 0, 0)]) 38 >>> calculate_total_distance(1, [(2, 0, 0)]) 0 >>> calculate_total_distance(2, [(1, 0, 0), (2, 0, 0)]) 0 >>> calculate_total_distance(2, [(1, 1, 1), (1, 1, 1)]) 8","solution":"def calculate_total_distance(n, deliveries): current_pos = (0, 0) total_distance = 0 def manhattan_distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) for delivery in deliveries: t, x, y = delivery destination = (x, y) if t == 1: # Pickup request # Move to destination total_distance += manhattan_distance(current_pos, destination) # Return to warehouse total_distance += manhattan_distance(destination, (0, 0)) # Update current position to warehouse current_pos = (0, 0) elif t == 2: # Drop-off request # Move to destination total_distance += manhattan_distance(current_pos, destination) # Return to warehouse total_distance += manhattan_distance(destination, (0, 0)) # Update current position to warehouse current_pos = (0, 0) return total_distance"},{"question":"def maximize_absolute_differences(N): Find an arrangement of an array of length N containing integers from 1 to N such that the sum of the absolute differences of all consecutive elements in the array is maximized. >>> maximize_absolute_differences(4) [4, 1, 3, 2] >>> maximize_absolute_differences(5) [5, 1, 4, 2, 3] pass def solve(test_cases): Given a list of integers representing test cases, find an arrangement for each integer that maximizes the sum of absolute differences. >>> solve([4, 5]) [[4, 1, 3, 2], [5, 1, 4, 2, 3]] >>> solve([2, 3, 6]) [[2, 1], [3, 1, 2], [6, 1, 5, 2, 4, 3]] pass","solution":"def maximize_absolute_differences(N): arrangement = [] for i in range(N): if i % 2 == 0: arrangement.append(N - i // 2) else: arrangement.append(1 + i // 2) return arrangement def solve(test_cases): results = [] for N in test_cases: results.append(maximize_absolute_differences(N)) return results # Example Usage: # T = 2 # test_cases = [4, 5] # print(solve(test_cases)) # Output: [[4, 1, 3, 2], [5, 1, 4, 2, 3]]"},{"question":"def largest_lit_square_side(n: int, dark_intersections: List[Tuple[int, int]]) -> int: Determine the side length of the largest possible square area that is fully lit up in Gridland. Parameters: n (int): Number of dark intersections. dark_intersections (List[Tuple[int, int]]): List of coordinates representing dark intersections. Returns: int: Side length of the largest lit area. >>> largest_lit_square_side(2, [(1, 1), (2, 2)]) 1 >>> largest_lit_square_side(4, [(0, 1), (1, 2), (2, 1), (1, 0)]) 1 >>> largest_lit_square_side(0, []) float('inf')","solution":"def largest_lit_square_side(n, dark_intersections): if n == 0: return float('inf') # There are no dark intersections, the entire grid is lit min_x, max_x = float('inf'), float('-inf') min_y, max_y = float('inf'), float('-inf') for x, y in dark_intersections: if x < min_x: min_x = x if x > max_x: max_x = x if y < min_y: min_y = y if y > max_y: max_y = y max_side_length = max(max_x - min_x, max_y - min_y) return max_side_length"},{"question":"def can_make_palindrome_with_one_reversal(n: int, s: str) -> str: Determines if we can make the string 's' a palindrome with exactly one reversal. >>> can_make_palindrome_with_one_reversal(5, \\"adaba\\") \\"YES\\" >>> can_make_palindrome_with_one_reversal(4, \\"abcd\\") \\"NO\\" >>> can_make_palindrome_with_one_reversal(3, \\"abc\\") \\"YES\\"","solution":"def can_make_palindrome_with_one_reversal(n, s): Determines if we can make the string 's' a palindrome with exactly one reversal. Args: n (int): The length of the string 's'. s (str): The string to be checked. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. if n == 1: return \\"YES\\" left, right = 0, n - 1 differences = 0 while left < right: if s[left] != s[right]: differences += 1 left += 1 right -= 1 if differences == 0: # Already a palindrome return \\"YES\\" elif differences == 1: return \\"YES\\" # One mismatch can be resolved by one reversal elif differences == 2 and n % 2 == 1: return \\"YES\\" # Two mismatches, but we have a middle character to help balance else: return \\"NO\\""},{"question":"def can_make_detour_and_be_on_time(D, S, E, T): Determines if Lisa can make a detour for coffee and still arrive on time. Parameters: D (int): Total distance to work in kilometers. S (int): Average speed of the car in km/h. E (int): Extra distance in kilometers for the detour. T (int): Total time until she needs to be at work in minutes. Returns: str: \\"Yes\\" if she can make the detour and still be on time, otherwise \\"No\\". pass # Test Cases def test_can_make_detour_and_be_on_time(): assert can_make_detour_and_be_on_time(10, 30, 5, 60) == \\"Yes\\" assert can_make_detour_and_be_on_time(5, 10, 10, 30) == \\"No\\" assert can_make_detour_and_be_on_time(7, 14, 2, 35) == \\"No\\" def test_no_detour_needed(): assert can_make_detour_and_be_on_time(10, 60, 0, 10) == \\"Yes\\" def test_just_enough_time(): assert can_make_detour_and_be_on_time(30, 30, 0, 60) == \\"Yes\\" def test_not_enough_time_with_detour(): assert can_make_detour_and_be_on_time(50, 25, 25, 60) == \\"No\\" def test_max_values(): assert can_make_detour_and_be_on_time(100, 100, 100, 240) == \\"Yes\\" def test_min_values(): assert can_make_detour_and_be_on_time(1, 1, 1, 60) == \\"No\\"","solution":"def can_make_detour_and_be_on_time(D, S, E, T): Determines if Lisa can make a detour for coffee and still arrive on time. Parameters: D (int): Total distance to work in kilometers. S (int): Average speed of the car in km/h. E (int): Extra distance in kilometers for the detour. T (int): Total time until she needs to be at work in minutes. Returns: str: \\"Yes\\" if she can make the detour and still be on time, otherwise \\"No\\". total_distance = D + E time_needed_hours = total_distance / S time_needed_minutes = time_needed_hours * 60 if time_needed_minutes <= T: return \\"Yes\\" else: return \\"No\\""},{"question":"def has_palindromic_substring(s: str, n: int) -> str: Determines if there exists a substring of s of length n which is a palindrome. >>> has_palindromic_substring(\\"abccba\\", 4) \\"YES\\" >>> has_palindromic_substring(\\"abcdef\\", 2) \\"NO\\" >>> has_palindromic_substring(\\"racecar\\", 3) \\"YES\\"","solution":"def has_palindromic_substring(s, n): Determines if there exists a substring of s of length n which is a palindrome. for i in range(len(s) - n + 1): substring = s[i:i+n] if substring == substring[::-1]: return \\"YES\\" return \\"NO\\" # Example usage: # s, n = \\"abccba\\", 4 # print(has_palindromic_substring(s, n)) # Output should be \\"YES\\""},{"question":"def max_products(W: int, N: int, products: List[Tuple[int, int]]) -> int: Determine the maximum number of products that can be delivered given the vehicle’s weight limit and the list of products with their weights and priority levels. >>> max_products(50, 4, [(10, 10), (20, 9), (30, 8), (40, 10)]) == 2 >>> max_products(100, 6, [(25, 5), (20, 5), (40, 3), (10, 7), (15, 7), (30, 4)]) == 5 >>> max_products(10, 5, [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]) == 5 >>> max_products(10, 5, [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5)]) == 2 >>> max_products(10, 5, [(11, 1), (12, 2), (13, 3), (14, 4), (15, 5)]) == 0 pass","solution":"def max_products(W, N, products): # Sort products first by priority (descending) and then by weight (ascending) products.sort(key=lambda x: (-x[1], x[0])) total_weight = 0 count = 0 for weight, priority in products: if total_weight + weight <= W: total_weight += weight count += 1 return count"},{"question":"import re from typing import List def find_emails(text: str) -> List[str]: Extracts and returns all valid email addresses from the given string. If no email addresses are found, it returns \\"No emails found\\". >>> find_emails(\\"Please contact us at support@company.com or sales@company.io.\\") ['support@company.com', 'sales@company.io'] >>> find_emails(\\"My email is user@example.com and I'll be in touch.\\") ['user@example.com'] >>> find_emails(\\"There are no emails in this text.\\") [\\"No emails found\\"] >>> find_emails(\\"Emails to check: an.email@domain.com, mixedcase@EXAMPLE.COM, under_score@sub.domain.net, hyphen-name@domain.co.uk\\") ['an.email@domain.com', 'mixedcase@EXAMPLE.COM', 'under_score@sub.domain.net', 'hyphen-name@domain.co.uk'] >>> find_emails(\\"Invalid: missing_at_symbol.com, @missinglocalpart.com, missingdomain@.com\\") [\\"No emails found\\"]","solution":"import re def find_emails(text): Extracts and returns all valid email addresses from the given string. If no email addresses are found, it returns \\"No emails found\\". email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}' emails = re.findall(email_pattern, text) if emails: return emails else: return [\\"No emails found\\"]"},{"question":"def is_fibonacci(n: int) -> bool: Determine if a given integer is part of the Fibonacci sequence. Parameters: n (int): The integer to check (0 ≤ n ≤ 10^18). Returns: bool: True if the integer is part of the Fibonacci sequence, False otherwise. >>> is_fibonacci(5) True >>> is_fibonacci(4) False","solution":"def is_fibonacci(n): Determine if a given integer is part of the Fibonacci sequence. Parameters: n (int): The integer to check (0 ≤ n ≤ 10^18). Returns: bool: True if the integer is part of the Fibonacci sequence, False otherwise. if n == 0 or n == 1: return True a, b = 0, 1 while b <= n: if b == n: return True a, b = b, a + b return False"},{"question":"def smallest_repeating_substring_length(T: str) -> int: Given a string T, determine whether it is possible to construct the string by repeating a substring of T. If it is possible, returns the length of the smallest such substring. Otherwise, returns -1. >>> smallest_repeating_substring_length(\\"abab\\") 2 >>> smallest_repeating_substring_length(\\"aba\\") -1 >>> smallest_repeating_substring_length(\\"abcabcabcabc\\") 3","solution":"def smallest_repeating_substring_length(T): Returns the length of the smallest substring that can be repeated to form the string T. If no such substring exists, returns -1. n = len(T) # Iterate from 1 to n/2 (no need to go beyond n/2 because that's the max length of a smaller substring) for i in range(1, n // 2 + 1): # If n is not divisible by i, T can't be a repetition of a substring of length i if n % i != 0: continue # We take the candidate substring of length i substring = T[:i] # Reconstruct T by repeating the candidate substring if substring * (n // i) == T: return i return -1"},{"question":"def maximumEnrollment(P: List[List[int]]) -> int: Given a matrix P where P(i, j) denotes the i-th student is interested in the j-th course, find the maximum number of students who can enroll in a course. Args: P: List[List[int]] - 2D list of interest matrix where P[i][j] is 1 if i-th student is interested in j-th course Returns: int - Maximum number of students who can enroll in a course Examples: >>> maximumEnrollment([[1, 0, 1, 0], [0, 1, 1, 1], [1, 1, 1, 0], [0, 1, 1, 1]]) 4 >>> maximumEnrollment([[1, 0, 1], [0, 0, 1], [1, 1, 0]]) 3 >>> maximumEnrollment([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def maximumEnrollment(P): Returns the maximum number of students who can enroll in a course. :param P: List[List[int]] :return: int def bpm(student, match_r, matched_l, visited): for course in range(len(P[student])): if P[student][course] == 1 and not visited[course]: visited[course] = True if matched_l[course] == -1 or bpm(matched_l[course], match_r, matched_l, visited): matched_l[course] = student match_r[student] = course return True return False N = len(P) match_r = [-1] * N matched_l = [-1] * len(P[0]) result = 0 for i in range(N): visited = [False] * len(P[0]) if bpm(i, match_r, matched_l, visited): result += 1 return result"},{"question":"def merge_strings(n, strings): Merges n strings by sorting them in alphabetical order and then concatenating them. :param n: Integer representing the number of strings. :param strings: List of strings to merge. :return: Single concatenated string sorted in alphabetical order. >>> merge_strings(3, [\\"dog\\", \\"cat\\", \\"frog\\"]) == \\"catdogfrog\\" >>> merge_strings(4, [\\"beta\\", \\"alpha\\", \\"delta\\", \\"gamma\\"]) == \\"alphabetadeltagamma\\" >>> merge_strings(1, [\\"zebra\\"]) == \\"zebra\\" >>> merge_strings(2, [\\"apple\\", \\"banana\\"]) == \\"applebanana\\" >>> merge_strings(3, [\\"repeat\\", \\"repeat\\", \\"repeat\\"]) == \\"repeatrepeatrepeat\\" >>> merge_strings(3, [\\"ant\\", \\"bat\\", \\"cat\\"]) == \\"antbatcat\\" >>> merge_strings(3, [\\"cherry\\", \\"banana\\", \\"apple\\"]) == \\"applebananacherry\\" >>> merge_strings(3, [\\"a\\", \\"abcdefg\\", \\"abc\\"]) == \\"aabcabcdefg\\" pass","solution":"def merge_strings(n, strings): Merges n strings by sorting them in alphabetical order and then concatenating them. :param n: Integer representing the number of strings. :param strings: List of strings to merge. :return: Single concatenated string sorted in alphabetical order. sorted_strings = sorted(strings) return ''.join(sorted_strings)"},{"question":"def is_palindrome(n): Checks if a given integer n is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(12321) True >>> is_palindrome(123) False >>> is_palindrome(9009) True >>> is_palindrome(10) False def largest_palindrome_product(): Returns the largest palindrome made from the product of two 3-digit numbers. >>> largest_palindrome_product() 906609","solution":"def is_palindrome(n): Checks if a given integer n is a palindrome. return str(n) == str(n)[::-1] def largest_palindrome_product(): Returns the largest palindrome made from the product of two 3-digit numbers. max_palindrome = 0 for i in range(999, 99, -1): for j in range(i, 99, -1): product = i * j if is_palindrome(product) and product > max_palindrome: max_palindrome = product return max_palindrome"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string containing a mathematical expression with multiplication and division operations. The input string will not contain any addition or subtraction operations. Non-integer division should be handled by rounding down to the nearest integer (floor division). Examples: >>> evaluate_expression(\\"6*3\\") 18 >>> evaluate_expression(\\"10/2\\") 5 >>> evaluate_expression(\\"6*3/2\\") 9 >>> evaluate_expression(\\"8/3*4\\") 8 >>> evaluate_expression(\\"10/2*5\\") 25","solution":"def evaluate_expression(expression): def multiply(a, b): return a * b def divide(a, b): return a // b # Floor division def eval_operator(op, a, b): if op == '*': return multiply(a, b) elif op == '/': return divide(a, b) else: raise ValueError(f\\"Unknown operator: {op}\\") n = len(expression) stack = [] num = '' i = 0 while i < n: if expression[i].isdigit(): num += expression[i] else: if num: stack.append(int(num)) num = '' stack.append(expression[i]) i += 1 if num: stack.append(int(num)) while len(stack) >= 3: a = stack.pop(0) op = stack.pop(0) b = stack.pop(0) result = eval_operator(op, a, b) stack.insert(0, result) return stack[0]"},{"question":"def count_active_sessions(sessions, queries): Given a list of sessions and queries, returns the number of active sessions at each query timestamp. :param sessions: List of tuples [(S1, E1), (S2, E2), ...] representing sessions :param queries: List of integers [T1, T2, ...] representing query timestamps :return: List of integers representing number of active sessions at each query timestamp # Your code here # Sample test cases sessions = [(1, 5), (2, 6), (4, 8), (10, 12), (9, 9)] queries = [3, 5, 9] print(count_active_sessions(sessions, queries)) # Expected output: [2, 3, 1] sessions = [(1, 2), (3, 4), (5, 6)] queries = [0, 7, 10] print(count_active_sessions(sessions, queries)) # Expected output: [0, 0, 0] sessions = [(1, 10), (2, 9), (3, 8)] queries = [4, 5, 6] print(count_active_sessions(sessions, queries)) # Expected output: [3, 3, 3] sessions = [(2, 5)] queries = [1, 2, 3, 5, 6] print(count_active_sessions(sessions, queries)) # Expected output: [0, 1, 1, 1, 0] sessions = [(1, 3), (4, 6), (7, 9)] queries = [3, 4, 5, 6, 7] print(count_active_sessions(sessions, queries)) # Expected output: [1, 1, 1, 1, 1]","solution":"def count_active_sessions(sessions, queries): Given a list of sessions and queries, returns the number of active sessions at each query timestamp. :param sessions: List of tuples [(S1, E1), (S2, E2), ...] representing sessions :param queries: List of integers [T1, T2, ...] representing query timestamps :return: List of integers representing number of active sessions at each query timestamp results = [] for query in queries: active_sessions = 0 for session in sessions: if session[0] <= query <= session[1]: active_sessions += 1 results.append(active_sessions) return results"},{"question":"def max_profit(stock_prices: List[int]) -> int: Given a list of stock prices for the next few days, returns the maximum profit that can be made by buying and selling the stock once. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([2, 4, 1, 7, 5, 9, 3, 8]) 8","solution":"def max_profit(stock_prices): Given a list of stock prices for the next few days, returns the maximum profit that can be made by buying and selling the stock once. If no profit can be made, returns 0. n = len(stock_prices) if n == 0: return 0 min_price = stock_prices[0] max_profit = 0 for price in stock_prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def min_operations_to_convert(s: str, t: str) -> int: Determines the minimum number of operations needed to convert string s to string t. Parameters: s (str): The original string. t (str): The target string to convert to. Returns: int: The minimum number of operations to convert s to t. >>> min_operations_to_convert(\\"abc\\", \\"cba\\") 2 >>> min_operations_to_convert(\\"abcd\\", \\"efgh\\") 4 >>> min_operations_to_convert(\\"aaaa\\", \\"bbbb\\") 4 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine the minimum number of operations needed to convert each string in the tests to its target string. Parameters: test_cases (List[Tuple[str, str]]): A list of tuples, each containing two strings, the original and the target string. Returns: List[str]: A list of results for each test case formatted as \\"Case #i: result\\". >>> test_cases = [(\\"abc\\", \\"cba\\"), (\\"abcd\\", \\"efgh\\"), (\\"aaaa\\", \\"bbbb\\")] >>> process_test_cases(test_cases) ['Case #1: 2', 'Case #2: 4', 'Case #3: 4'] def test_min_operations_to_convert(): assert min_operations_to_convert(\\"abc\\", \\"cba\\") == 2 assert min_operations_to_convert(\\"abcd\\", \\"efgh\\") == 4 assert min_operations_to_convert(\\"aaaa\\", \\"bbbb\\") == 4 assert min_operations_to_convert(\\"hello\\", \\"hullo\\") == 1 assert min_operations_to_convert(\\"same\\", \\"same\\") == 0 def test_process_test_cases(): test_cases = [ (\\"abc\\", \\"cba\\"), (\\"abcd\\", \\"efgh\\"), (\\"aaaa\\", \\"bbbb\\"), ] expected_results = [ \\"Case #1: 2\\", \\"Case #2: 4\\", \\"Case #3: 4\\", ] assert process_test_cases(test_cases) == expected_results","solution":"def min_operations_to_convert(s, t): Determines the minimum number of operations needed to convert string s to string t. Parameters: s (str): The original string. t (str): The target string to convert to. Returns: int: The minimum number of operations to convert s to t. # Initialize the count of operations to 0 operations = 0 # Calculate the number of character changes needed for char_s, char_t in zip(s, t): if char_s != char_t: operations += 1 return operations def process_test_cases(test_cases): results = [] for i, (s, t) in enumerate(test_cases): min_ops = min_operations_to_convert(s, t) results.append(f\\"Case #{i + 1}: {min_ops}\\") return results"},{"question":"def organizeAisles(aisles): Determine if aisles can be rearranged so that each shelf contains the same type of product, and no product type is found in more than one shelf within an aisle. >>> organizeAisles([[1, 2, 0], [0, 1, 2]]) 'Possible' >>> organizeAisles([[0, 1], [2, 2]]) 'Impossible'","solution":"def organizeAisles(aisles): n = len(aisles) m = len(aisles[0]) for aisle in aisles: unique_products = set(aisle) if len(unique_products) != m: return \\"Impossible\\" return \\"Possible\\""},{"question":"def censor_text(text: str, taboo_words: List[str]) -> str: Replaces all occurrences of taboo words in the text with the corresponding number of asterisks, case insensitive. >>> censor_text(\\"The quick brown fox jumps over the lazy dog.\\", [\\"quick\\", \\"dog\\"]) == \\"The ***** brown fox jumps over the lazy ***.\\" >>> censor_text(\\"She sells sea shells by the sea shore.\\", [\\"sells\\", \\"shore\\"]) == \\"She ***** sea shells by the sea *****.\\" >>> censor_text(\\"\\", [\\"quick\\", \\"dog\\"]) == \\"\\" >>> censor_text(\\"The quick brown fox jumps over the lazy dog.\\", []) == \\"The quick brown fox jumps over the lazy dog.\\" >>> censor_text(\\"The QUICK brown fox jumps over the lazy dog.\\", [\\"quick\\", \\"dog\\"]) == \\"The ***** brown fox jumps over the lazy ***.\\" >>> censor_text(\\"Wow! it's a quick, quick test.\\", [\\"quick\\"]) == \\"Wow! it's a *****, ***** test.\\"","solution":"def censor_text(text, taboo_words): Replaces all occurrences of taboo_words in the text with the corresponding number of asterisks, case insensitive. if not text or not taboo_words: return text # Split text into list of words words = text.split() # Create a set of lower-cased taboo words for case insensitive comparison taboo_set = {word.lower() for word in taboo_words} # Replace each word in the text if it is a taboo word result = [] for word in words: clean_word = word.strip('.,\\"?!') # Clean word of punctuation for taboo check if clean_word.lower() in taboo_set: censored = '*' * len(clean_word) result.append(word.replace(clean_word, censored)) else: result.append(word) return ' '.join(result)"},{"question":"def product_of_negatives(arr): Returns the product of all the negative numbers in the array. If there are no negative numbers, returns 1. >>> product_of_negatives([-1, 2, -3, 4]) 3 >>> product_of_negatives([-1, -2, -3, -4]) 24 >>> product_of_negatives([1, 2, 3, 4]) 1 >>> product_of_negatives([0, 2, 3, 4]) 1 >>> product_of_negatives([0, -1, -3, 6]) 3 >>> product_of_negatives([0, 0, -3, 0]) -3 >>> product_of_negatives([-5]) -5 >>> product_of_negatives([-10, 0, 0]) -10 >>> product_of_negatives([0, 0, 0, 0]) 1 >>> product_of_negatives([]) 1","solution":"def product_of_negatives(arr): Returns the product of all the negative numbers in the array. If there are no negative numbers, returns 1. product = 1 has_negative = False for num in arr: if num < 0: product *= num has_negative = True return product if has_negative else 1"},{"question":"def findSingleNumber(nums): Given an array of integers where every integer occurs twice except for one integer which occurs only once, find the integer that occurs only once. >>> findSingleNumber([2, 3, 5, 4, 5, 3, 4]) 2 >>> findSingleNumber([1, 1, 2, 2, 3, 4, 4]) 3 >>> findSingleNumber([0, 1, 0, 1, 99]) 99 >>> findSingleNumber([7]) 7 >>> findSingleNumber([10, 20, 10]) 20 >>> findSingleNumber([99, 1, 1]) 99 >>> findSingleNumber([]) 0 >>> large_input = list(range(1, 100000)) * 2 + [999999] >>> findSingleNumber(large_input) 999999 # Your code here","solution":"def findSingleNumber(nums): Returns the single number that appears only once in the array. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"def find_smallest_missing_positive(arr): Returns the smallest positive integer missing from the array. >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0, 3]) 4 >>> find_smallest_missing_positive([7, 8, 9, 11, 12, 13]) 1","solution":"def find_smallest_missing_positive(arr): Returns the smallest positive integer missing from the array. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def longest_zigzag(nums: List[int]) -> int: Find the length of the longest zigzag sequence that can be obtained from the given list nums. >>> longest_zigzag([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag([1, 2, 3, 4, 5, 6, 7, 8, 9]) 2 >>> longest_zigzag([10, 20, 10, 20, 10]) 5 >>> longest_zigzag([3, 3, 3, 3, 3]) 1","solution":"from typing import List def longest_zigzag(nums: List[int]) -> int: if not nums: return 0 n = len(nums) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): if nums[i] > nums[i-1]: up[i] = down[i-1] + 1 down[i] = down[i-1] elif nums[i] < nums[i-1]: down[i] = up[i-1] + 1 up[i] = up[i-1] else: down[i] = down[i-1] up[i] = up[i-1] return max(up[-1], down[-1])"},{"question":"class ParkingSpot: def __init__(self, level, spot_number, spot_type): Initialize a parking spot with the given level, spot number, and spot type. self.level = level self.spot_number = spot_number self.spot_type = spot_type self.license_plate = None def is_available(self): Check if the spot is available for parking. return self.license_plate is None def park(self, license_plate): Park a vehicle with the given license plate. if self.is_available(): self.license_plate = license_plate return True return False def unpark(self): Unpark the vehicle from the spot. if not self.is_available(): self.license_plate = None return True return False class ParkingSystem: def __init__(self): Initialize the parking system with levels and respective spots. self.levels = [] self.vehicles = {} def initialize(self, num_levels, spots_per_level): Initialize the parking system with the given number of levels and spots per level. Each level has 6 motorcycle spots, 2 compact spots, and 2 large spots (in that order). # Your implementation here def park_vehicle(self, vehicle_type, license_plate): Park a vehicle with the given vehicle type and license plate. Return the level and spot number where it is parked or 'No available spot' if no spot is available. # Your implementation here def unpark_vehicle(self, license_plate): Unpark the vehicle with the given license plate. Return 'Vehicle unparked' or 'Vehicle not found' if the vehicle is not found. # Your implementation here def check_status(self, license_plate): Check the status of the vehicle with the given license plate. Return the level and spot number where it is parked or 'Vehicle not found'. # Your implementation here def is_spot_suitable(self, spot, vehicle_type): Check if the given spot is suitable for the vehicle type. # Your implementation here # Example test cases import pytest from solution import ParkingSystem def test_initialize(): ps = ParkingSystem() ps.initialize(3, 10) assert len(ps.levels) == 3 assert len(ps.levels[0]) == 10 assert ps.levels[0][0].spot_type == 'motorcycle' assert ps.levels[0][6].spot_type == 'compact' assert ps.levels[0][8].spot_type == 'large' def test_park_vehicle_motorcycle(): ps = ParkingSystem() ps.initialize(3, 10) level, spot_number = ps.park_vehicle('motorcycle', '123') assert level == 0 assert spot_number == 0 assert ps.check_status('123') == (0, 0) def test_park_vehicle_large(): ps = ParkingSystem() ps.initialize(3, 10) ps.park_vehicle('motorcycle', '123') ps.park_vehicle('compact', '234') level, spot_number = ps.park_vehicle('large', '345') assert level == 0 assert spot_number == 8 assert ps.check_status('345') == (0, 8) def test_unpark_vehicle(): ps = ParkingSystem() ps.initialize(3, 10) ps.park_vehicle('motorcycle', '123') assert ps.unpark_vehicle('123') == 'Vehicle unparked' assert ps.check_status('123') == 'Vehicle not found' def test_check_status(): ps = ParkingSystem() ps.initialize(3, 10) ps.park_vehicle('motorcycle', '123') assert ps.check_status('123') == (0, 0) assert ps.check_status('234') == 'Vehicle not found' def test_no_available_spot(): ps = ParkingSystem() ps.initialize(1, 2) ps.park_vehicle('large', '123') assert ps.park_vehicle('large', '456') == 'No available spot'","solution":"class ParkingSpot: def __init__(self, level, spot_number, spot_type): self.level = level self.spot_number = spot_number self.spot_type = spot_type self.license_plate = None def is_available(self): return self.license_plate is None def park(self, license_plate): if self.is_available(): self.license_plate = license_plate return True return False def unpark(self): if not self.is_available(): self.license_plate = None return True return False class ParkingSystem: def __init__(self): self.levels = [] self.vehicles = {} def initialize(self, num_levels, spots_per_level): spot_types = ['motorcycle'] * 6 + ['compact'] * 2 + ['large'] * 2 for l in range(num_levels): level_spots = [] for s in range(spots_per_level): spot_type = spot_types[s % len(spot_types)] level_spots.append(ParkingSpot(l, s, spot_type)) self.levels.append(level_spots) def park_vehicle(self, vehicle_type, license_plate): for level in self.levels: for spot in level: if self.is_spot_suitable(spot, vehicle_type) and spot.park(license_plate): self.vehicles[license_plate] = (spot.level, spot.spot_number) return spot.level, spot.spot_number return 'No available spot' def unpark_vehicle(self, license_plate): if license_plate in self.vehicles: level, spot_number = self.vehicles.pop(license_plate) spot = self.levels[level][spot_number] spot.unpark() return 'Vehicle unparked' return 'Vehicle not found' def check_status(self, license_plate): if license_plate in self.vehicles: return self.vehicles[license_plate] return 'Vehicle not found' def is_spot_suitable(self, spot, vehicle_type): if vehicle_type == 'motorcycle': return True elif vehicle_type == 'compact': return spot.spot_type in ['compact', 'large'] elif vehicle_type == 'large': return spot.spot_type == 'large' return False"},{"question":"def can_rearrange_to_form(s1: str, s2: str) -> bool: Check if s1 can be rearranged to form s2. Args: s1 (str): The source string. s2 (str): The target string. Returns: bool: True if s1 can be rearranged to form s2, otherwise False. >>> can_rearrange_to_form(\\"abc\\", \\"abc\\") True >>> can_rearrange_to_form(\\"abc\\", \\"bca\\") True >>> can_rearrange_to_form(\\"abc\\", \\"abcd\\") False >>> can_rearrange_to_form(\\"abc\\", \\"def\\") False >>> can_rearrange_to_form(\\"aabbcc\\", \\"baccab\\") True >>> can_rearrange_to_form(\\"\\", \\"\\") True","solution":"def can_rearrange_to_form(s1, s2): Checks if s1 can be rearranged to form s2. Args: s1 (str): The source string. s2 (str): The target string. Returns: bool: True if s1 can be rearranged to form s2, otherwise False. # If the lengths are not the same, s1 can't be rearranged to form s2 if len(s1) != len(s2): return False # Sort both strings and compare them return sorted(s1) == sorted(s2)"},{"question":"def minimum_connections(n: int, r: int, distances: List[Tuple[int, int, int]]) -> int: Determine the minimum number of direct connections required to ensure all computers are part of a connected network. Args: n (int): The number of computers. r (int): The connection range for each computer. distances (List[Tuple[int, int, int]]): A list of tuples, each containing three integers: a, b, and d, representing that the distance between computer a and computer b is d. Returns: int: The minimum number of connections required to ensure all computers are connected. If it's impossible to connect all computers, returns -1. Examples: >>> minimum_connections(5, 10, [(1, 2, 5), (1, 3, 12), (2, 3, 7), (2, 4, 3), (3, 4, 6), (3, 5, 15), (4, 5, 4)]) 4 >>> minimum_connections(4, 14, [(1, 2, 13), (2, 3, 8), (3, 4, 20)]) -1 >>> minimum_connections(3, 5, [(1, 2, 4), (2, 3, 3), (1, 3, 2)]) 2","solution":"def minimum_connections(n, r, distances): from heapq import heappop, heappush import sys if n == 1: return 0 # Create adjacency list adj = [[] for _ in range(n + 1)] for a, b, d in distances: if d <= r: adj[a].append((d, b)) adj[b].append((d, a)) # Prim's Algorithm to find MST visited = [False] * (n + 1) min_heap = [(0, 1)] # Start from node 1 total_cost = 0 edges_used = 0 while min_heap: cost, u = heappop(min_heap) if visited[u]: continue visited[u] = True total_cost += cost edges_used += 1 for neighbor_cost, neighbor in adj[u]: if not visited[neighbor]: heappush(min_heap, (neighbor_cost, neighbor)) return edges_used - 1 if all(visited[1:]) else -1 # Example usage: # n, r = 5, 10 # distances = [ # (1, 2, 5), # (1, 3, 12), # (2, 3, 7), # (2, 4, 3), # (3, 4, 6), # (3, 5, 15), # (4, 5, 4) # ] # print(minimum_connections(n, r, distances)) # Output: 4"},{"question":"def max_average_speed(N: int, K: int, speeds: List[int]) -> float: Calculates the maximum average speed of any contiguous subarray of length K. :param N: int - the number of cars :param K: int - the length of the subarray :param speeds: list of int - the speeds of the cars :return: float - the maximum average speed with a precision of 6 decimal places >>> max_average_speed(7, 3, [10, 5, 2, 7, 8, 7, 4]) 7.333333 >>> max_average_speed(1, 1, [10]) 10.000000 >>> max_average_speed(5, 2, [5, 5, 5, 5, 5]) 5.000000 >>> max_average_speed(5, 3, [1, 2, 3, 4, 5]) 4.000000 >>> max_average_speed(5, 2, [5, 4, 3, 2, 1]) 4.500000 >>> max_average_speed(5, 5, [1, 2, 3, 4, 5]) 3.000000 >>> max_average_speed(8, 4, [1, 3, 5, 7, 6, 2, 1, 8]) 5.250000","solution":"def max_average_speed(N, K, speeds): Calculates the maximum average speed of any contiguous subarray of length K. :param N: int - the number of cars :param K: int - the length of the subarray :param speeds: list of int - the speeds of the cars :return: float - the maximum average speed with a precision of 6 decimal places # Initial sum of the first subarray of length K current_sum = sum(speeds[:K]) max_sum = current_sum # Sliding window to compute the sum of the next subarray by removing the first element and adding the next for i in range(K, N): current_sum += speeds[i] - speeds[i - K] if current_sum > max_sum: max_sum = current_sum # The result is the maximum sum divided by K for the average max_avg = max_sum / K return round(max_avg, 6)"},{"question":"def smallest_prime_factor(n: int) -> int: Returns the smallest prime factor of the given number n. If n is a prime number, it returns n itself. >>> smallest_prime_factor(10) 2 >>> smallest_prime_factor(17) 17 >>> smallest_prime_factor(49) 7 pass def solve(t: int, numbers: List[int]) -> List[int]: Given t test cases and a list of numbers, return a list of smallest prime factors for all the numbers. >>> solve(3, [10, 17, 49]) [2, 17, 7] >>> solve(5, [2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] pass","solution":"def smallest_prime_factor(n): Returns the smallest prime factor of the given number n. If n is a prime number, it returns n itself. if n <= 1: raise ValueError(\\"n should be greater than 1\\") if n % 2 == 0: return 2 factor = 3 while factor * factor <= n: if n % factor == 0: return factor factor += 2 return n def solve(t, numbers): Given t test cases and a list of numbers, return a list of smallest prime factors for all the numbers. results = [] for num in numbers: results.append(smallest_prime_factor(num)) return results"},{"question":"def evaluate_rpn_expression(expression: str) -> int: Evaluate a single RPN expression and return the result. >>> evaluate_rpn_expression(\\"3 4 +\\") 7 >>> evaluate_rpn_expression(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_rpn_expression(\\"15 7 1 1 + - / 3 * 2 1 1 + + -\\") 5 pass def evaluate_multiple_rpn(expressions: List[str]) -> List[int]: Evaluate multiple RPN expressions and return the list of results. >>> evaluate_multiple_rpn([\\"3 4 +\\", \\"5 1 2 + 4 * + 3 -\\", \\"15 7 1 1 + - / 3 * 2 1 1 + + -\\"]) [7, 14, 5] >>> evaluate_multiple_rpn([\\"2 3 + 4 *\\", \\"10 6 9 3 + -11 * / * 17 + 5 +\\", \\"4 2 / 3 /\\"]) [20, 22, 0] pass","solution":"def evaluate_rpn_expression(expression): stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # Ensure truncation towards zero else: stack.append(int(token)) return stack[0] def evaluate_multiple_rpn(expressions): results = [] for expr in expressions: results.append(evaluate_rpn_expression(expr)) return results"},{"question":"def can_rearrange_harmonic(n: int, numbers: List[int]) -> str: Check if the list can be rearranged to form a harmonic list, where the absolute difference between any two adjacent elements does not exceed 1. Args: n (int): Length of the list. numbers (list of int): The input list of integers. Returns: str: \\"Yes\\" if the list can be rearranged to form a harmonic list, \\"No\\" otherwise. >>> can_rearrange_harmonic(4, [1, 2, 1, 2]) \\"Yes\\" >>> can_rearrange_harmonic(3, [1, 3, 2]) \\"No\\" >>> can_rearrange_harmonic(1, [100]) \\"Yes\\" >>> can_rearrange_harmonic(5, [7, 7, 7, 7, 7]) \\"Yes\\" >>> can_rearrange_harmonic(4, [1, 2, 2, 1]) \\"Yes\\" >>> can_rearrange_harmonic(5, [1, 2, 3, 5, 6]) \\"No\\"","solution":"def can_rearrange_harmonic(n, numbers): Check if the list can be rearranged to form a harmonic list, where the absolute difference between any two adjacent elements does not exceed 1. Args: n (int): Length of the list. numbers (list of int): The input list of integers. Returns: str: \\"Yes\\" if the list can be rearranged to form a harmonic list, \\"No\\" otherwise. # Check if the absolute difference between the max and min elements # is greater than 1 if max(numbers) - min(numbers) > 1: return \\"No\\" return \\"Yes\\""},{"question":"def find_duplicates(nums): Returns a sorted list of duplicate numbers in the input list nums. Params: nums - a list of integers Returns: A sorted list of integers that are duplicates in the input list. Example: >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1, 1, 2]) [1]","solution":"def find_duplicates(nums): Returns a sorted list of duplicate numbers in the input list nums. Params: nums - a list of integers Returns: A sorted list of integers that are duplicates in the input list. from collections import Counter # Create a counter to count occurrences of each number count = Counter(nums) # Extract elements that appear more than once duplicates = [num for num, freq in count.items() if freq > 1] # Return sorted list of duplicates return sorted(duplicates)"},{"question":"def can_achieve_target(N: int, T: int, power_levels: List[int]) -> str: Determine whether it is possible to achieve the exact power level T using any sequence of combinations. >>> can_achieve_target(5, 9, [2, 3, 7, 8, 10]) 'Yes' >>> can_achieve_target(4, 5, [1, 2, 3, 4]) 'Yes' >>> can_achieve_target(3, 11, [2, 4, 6]) 'No' pass def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) T = int(data[1]) power_levels = list(map(int, data[2:])) print(can_achieve_target(N, T, power_levels))","solution":"def can_achieve_target(N, T, power_levels): dp = [False] * (T + 1) dp[0] = True for power in power_levels: for t in range(T, power - 1, -1): if dp[t - power]: dp[t] = True return \\"Yes\\" if dp[T] else \\"No\\" def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) T = int(data[1]) power_levels = list(map(int, data[2:])) print(can_achieve_target(N, T, power_levels))"},{"question":"def leaf_size_on_day(n: int) -> int: Returns the size of the last leaf produced on the nth day. >>> leaf_size_on_day(1) == 1 >>> leaf_size_on_day(2) == 1 >>> leaf_size_on_day(3) == 2 >>> leaf_size_on_day(4) == 3 >>> leaf_size_on_day(5) == 5 >>> leaf_size_on_day(10) == 55","solution":"def leaf_size_on_day(n): Returns the size of the last leaf produced on the nth day. if n == 1 or n == 2: return 1 # Start with the first two leaves a, b = 1, 1 for i in range(3, n+1): next_leaf = a + b a = b b = next_leaf return b"},{"question":"def max_k_consecutive_sum(n, k, volumes): Finds the maximum sum of k consecutive days' rainfall volumes. Parameters: n (int): The number of days. k (int): The size of the window. volumes (list): A list of rainfall volumes for each day. Returns: int: The maximum possible sum of k consecutive days' rainfall volumes. >>> max_k_consecutive_sum(5, 2, [1, 2, 3, 4, 5]) 9 >>> max_k_consecutive_sum(7, 3, [5, 1, 3, 2, 6, 9, 4]) 19 >>> max_k_consecutive_sum(1, 1, [7]) 7 >>> max_k_consecutive_sum(4, 2, [4, 4, 4, 4]) 8 >>> max_k_consecutive_sum(5, 5, [3, 6, 1, 8, 4]) 22 >>> max_k_consecutive_sum(6, 2, [4, 5, 5, 4, 3, 2]) 10","solution":"def max_k_consecutive_sum(n, k, volumes): Finds the maximum sum of k consecutive days' rainfall volumes. Parameters: n (int): The number of days. k (int): The size of the window. volumes (list): A list of rainfall volumes for each day. Returns: int: The maximum possible sum of k consecutive days' rainfall volumes. current_sum = sum(volumes[:k]) max_sum = current_sum for i in range(k, n): current_sum = current_sum - volumes[i - k] + volumes[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def find_missing_number(nums): Finds the missing number from the range 1 to n in an unsorted list of unique integers. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1]) 2 >>> find_missing_number([2, 3, 4, 5, 6]) 1 >>> find_missing_number([1, 2, 3, 4, 5, 6, 7]) 8 >>> find_missing_number(list(range(1, 10001)) + list(range(10001, 20001)) + list(range(20002, 30001))) 20001","solution":"def find_missing_number(nums): Finds the missing number from the range 1 to n in an unsorted list of unique integers. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"def is_path_within_weight(n, m, W, s, t, edges): Determine if there exists a path from node s to node t in an undirected graph with weighted edges such that the total weight of the path does not exceed W. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. W (int): The maximum total weight of the path. s (int): The start node. t (int): The end node. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, w) indicating an edge between node u and node v with weight w. Returns: str: \\"YES\\" if such a path exists, otherwise \\"NO\\". Examples: >>> is_path_within_weight(4, 4, 10, 1, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 3, 1)]) \\"YES\\" >>> is_path_within_weight(3, 3, 2, 1, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 5)]) \\"NO\\" pass def test_is_path_within_weight_case_1(): n, m, W = 4, 4, 10 s, t = 1, 4 edges = [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 3, 1)] assert is_path_within_weight(n, m, W, s, t, edges) == \\"YES\\" def test_is_path_within_weight_case_2(): n, m, W = 3, 3, 2 s, t = 1, 3 edges = [(1, 2, 2), (2, 3, 2), (1, 3, 5)] assert is_path_within_weight(n, m, W, s, t, edges) == \\"NO\\" def test_is_path_within_weight_case_3(): n, m, W = 2, 0, 1 s, t = 1, 2 edges = [] assert is_path_within_weight(n, m, W, s, t, edges) == \\"NO\\" def test_is_path_within_weight_case_4(): n, m, W = 5, 5, 8 s, t = 1, 5 edges = [(1, 2, 2), (2, 3, 3), (3, 4, 2), (4, 5, 1), (1, 5, 10)] assert is_path_within_weight(n, m, W, s, t, edges) == \\"YES\\" def test_is_path_within_weight_case_no_edges(): n, m, W = 3, 0, 5 s, t = 1, 3 edges = [] assert is_path_within_weight(n, m, W, s, t, edges) == \\"NO\\" def test_is_path_within_weight_case_direct_edge(): n, m, W = 2, 1, 10 s, t = 1, 2 edges = [(1, 2, 5)] assert is_path_within_weight(n, m, W, s, t, edges) == \\"YES\\"","solution":"import heapq def is_path_within_weight(n, m, W, s, t, edges): graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Use Dijkstra's algorithm to find the shortest path from s to t pq = [(0, s)] # (current weight, current node) distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 while pq: current_weight, u = heapq.heappop(pq) if u == t: break for v, weight in graph[u]: distance = current_weight + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return \\"YES\\" if distances[t] <= W else \\"NO\\""},{"question":"def max_pairs(n: int, genres: List[int]) -> int: Determine the maximum number of pairs of books with different genres that can be formed. >>> max_pairs(6, [1, 2, 3, 1, 2, 3]) 3 >>> max_pairs(7, [1, 1, 1, 2, 2, 2, 3]) 3 >>> max_pairs(5, [5, 5, 5, 5, 4]) 1","solution":"def max_pairs(n, genres): from collections import Counter # Create a counter for the genres genre_counts = Counter(genres) pairs = 0 while len(genre_counts) > 1: # Get two most common genres g1, g2 = genre_counts.most_common(2) # Form pairs with them pairs += 1 if g1[1] == 1: del genre_counts[g1[0]] else: genre_counts[g1[0]] -= 1 if g2[1] == 1: del genre_counts[g2[0]] else: genre_counts[g2[0]] -= 1 return pairs"},{"question":"def seat_selection(n: int, m: int): Determine which seats Takahashi will choose based on the given rules. Takahashi starts by picking the 1st row entirely, then he must skip the next row, and then pick the row after that, and so on. When picking a row, if the row index is even, he picks only the even-indexed seats in that row (0-based indexing). If the row index is odd, he picks the odd-indexed seats. Args: n (int): The number of rows. m (int): The number of seats per row. Returns: list: A list of tuples where each tuple contains the row index and the list of seat indices picked in that row. >>> seat_selection(4, 4) [(0, [0, 1, 2, 3]), (2, [0, 2])] >>> seat_selection(3, 5) [(0, [0, 1, 2, 3, 4]), (2, [0, 2, 4])] >>> seat_selection(2, 3) [(0, [0, 1, 2])] >>> seat_selection(5, 2) [(0, [0, 1]), (2, [0]), (4, [0])] >>> seat_selection(1, 4) [(0, [0, 1, 2, 3])] >>> seat_selection(2, 1) [(0, [0])]","solution":"def seat_selection(n, m): result = [] for row in range(0, n, 2): seats = [] if row % 2 == 0: seats = [i for i in range(m)] if row == 0 else [i for i in range(m) if i % 2 == 0] else: seats = [i for i in range(m) if i % 2 != 0] result.append((row, seats)) return result"},{"question":"def find_anagrams(word: str, candidates: List[str]) -> List[str]: Determine which candidate words are anagrams of the given word. >>> find_anagrams(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\", \\"silent\\"]) [\\"enlist\\", \\"inlets\\", \\"silent\\"] >>> find_anagrams(\\"cat\\", [\\"dog\\", \\"bird\\", \\"fish\\"]) ['No anagrams found']","solution":"def find_anagrams(word, candidates): Returns a list of anagrams of the given word from the list of candidate words. # Sort the characters in the word to create a canonical form sorted_word = sorted(word) # Check each candidate to see if it's an anagram anagrams = [candidate for candidate in candidates if sorted(candidate) == sorted_word] if not anagrams: return ['No anagrams found'] return anagrams"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit that can be achieved from a single buy-sell transaction given an array of stock prices. If no profit can be achieved, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1]) 0 >>> max_profit([]) 0","solution":"def max_profit(prices): This function takes a list of stock prices and returns the maximum profit that can be achieved from a single buy-sell transaction. If no profit can be achieved, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the start node of the cycle in the linked list if it exists. :param head: ListNode :return: ListNode or None pass def create_linked_list_with_cycle(values, pos): if not values: return None head = ListNode(values[0]) current = head cycle_node = None if pos == 0: cycle_node = head # Create the linked list for index, value in enumerate(values[1:], 1): current.next = ListNode(value) current = current.next # Keep track of the node where the cycle starts if index == pos: cycle_node = current # Create the cycle if cycle_node: current.next = cycle_node return head def test_detectCycle(): # Example 1: head = [3, 2, 0, -4], pos = 1 head = create_linked_list_with_cycle([3, 2, 0, -4], 1) assert detectCycle(head).val == 2 # Example 2: head = [1, 2], pos = 0 head = create_linked_list_with_cycle([1, 2], 0) assert detectCycle(head).val == 1 # Example 3: head = [1], pos = -1 head = create_linked_list_with_cycle([1], -1) assert detectCycle(head) is None # Additional test cases head = create_linked_list_with_cycle([1, 2, 3, 4, 5], 2) assert detectCycle(head).val == 3 head = create_linked_list_with_cycle([], -1) assert detectCycle(head) is None head = create_linked_list_with_cycle([1], 0) assert detectCycle(head).val == 1 head = create_linked_list_with_cycle([1, 2, 3, 4, 5], -1) assert detectCycle(head) is None","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the start node of the cycle in the linked list if it exists. :param head: ListNode :return: ListNode or None if not head or not head.next: return None slow, fast = head, head # First phase: Determine if there is a cycle using fast and slow pointers. while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break # If no cycle is detected, return None. if not fast or not fast.next: return None # Second phase: Find the entry point to the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def paintGrid(grid: List[List[int]], row: int, col: int, new_color: int) -> List[List[int]]: Paint a specified region of the grid with a new color. A region is defined as a group of connected cells with the same initial color. Cells are considered connected if they are adjacent either horizontally or vertically. Args: grid: The m x n grid (a list of lists containing integers). row: The row index of the starting point. col: The column index of the starting point. new_color: The new color to be used for painting (integer). Returns: The modified grid. Examples: >>> grid = [ ... [1, 1, 1], ... [1, 1, 0], ... [1, 0, 1] ... ] >>> paintGrid(grid, 1, 1, 2) [ [2, 2, 2], [2, 2, 0], [2, 0, 1] ] >>> grid = [ ... [0, 0, 0], ... [0, 1, 1] ... ] >>> paintGrid(grid, 1, 1, 1) [ [0, 0, 0], [0, 1, 1] ] pass # Test cases from typing import List def test_paint_grid_example1(): grid = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] row, col = 1, 1 new_color = 2 expected = [ [2, 2, 2], [2, 2, 0], [2, 0, 1] ] assert paintGrid(grid, row, col, new_color) == expected def test_paint_grid_example2(): grid = [ [0, 0, 0], [0, 1, 1] ] row, col = 1, 1 new_color = 1 expected = [ [0, 0, 0], [0, 1, 1] ] assert paintGrid(grid, row, col, new_color) == expected def test_paint_grid_new_color_same_as_old(): grid = [ [0, 0, 0], [0, 1, 1] ] row, col = 1, 0 new_color = 0 expected = [ [0, 0, 0], [0, 1, 1] ] assert paintGrid(grid, row, col, new_color) == expected def test_paint_grid_entire_grid(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] row, col = 0, 0 new_color = 3 expected = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert paintGrid(grid, row, col, new_color) == expected def test_paint_grid_non_connected_cells(): grid = [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] row, col = 1, 1 new_color = 2 expected = [ [1, 0, 1], [0, 2, 0], [1, 0, 1] ] assert paintGrid(grid, row, col, new_color) == expected","solution":"def paintGrid(grid, row, col, new_color): Paint the region of the grid starting from (row, col) with the new color. old_color = grid[row][col] if old_color == new_color: return grid m, n = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] != old_color: return grid[r][c] = new_color dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) dfs(row, col) return grid"},{"question":"def sum_digits_until_one(numbers): Takes a list of positive integers and returns the sum of each number's digits until the sum is a single digit. >>> sum_digits_until_one([15, 29, 32]) [6, 2, 5] >>> sum_digits_until_one([1, 2, 3, 9]) [1, 2, 3, 9] >>> sum_digits_until_one([129, 456, 789]) [3, 6, 6] >>> sum_digits_until_one([8, 18, 124, 59]) [8, 9, 7, 5] >>> sum_digits_until_one([0, 0, 0]) [0, 0, 0] >>> sum_digits_until_one([9999, 8888, 7777]) [9, 5, 1]","solution":"def sum_digits_until_one(numbers): Returns a list where each element is the sum of the digits of the corresponding input number until the sum is a single digit. def sum_to_single_digit(n): while n >= 10: n = sum(int(digit) for digit in str(n)) return n return [sum_to_single_digit(num) for num in numbers]"},{"question":"from typing import List, Tuple def max_rectangle_area(widths: List[int], heights: List[int]) -> Tuple[int, int, int]: Given a list of possible widths and heights, returns the maximum rectangular area that can be enclosed, and the corresponding width and height. >>> max_rectangle_area([2, 3, 5], [4, 2, 6]) (30, 5, 6) >>> max_rectangle_area([5], [6]) (30, 5, 6) >>> max_rectangle_area([2, 3, 5], [6]) (30, 5, 6) >>> max_rectangle_area([5], [4, 2, 6]) (30, 5, 6) >>> max_rectangle_area([1], [1]) (1, 1, 1) >>> max_rectangle_area([3], [3]) (9, 3, 3)","solution":"from typing import List, Tuple def max_rectangle_area(widths: List[int], heights: List[int]) -> Tuple[int, int, int]: Given a list of possible widths and heights, returns the maximum rectangular area that can be enclosed, and the corresponding width and height. max_area = 0 best_width = 0 best_height = 0 for width in widths: for height in heights: area = width * height if area > max_area: max_area = area best_width = width best_height = height return max_area, best_width, best_height"},{"question":"def max_non_overlapping_events(events): Given a list of events with start and end times, compute the maximum number of non-overlapping events that can be attended. :param events: List of tuples (start, end) where start and end are strings representing the start and end times in \\"HH:MM\\" format :return: Integer representing the maximum number of non-overlapping events that can be attended >>> max_non_overlapping_events([(\\"09:00\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")]) 2 >>> max_non_overlapping_events([(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"10:30\\", \\"11:30\\"), (\\"11:00\\", \\"12:00\\")]) 3 pass def solve_calendar_problem(test_cases): Given a list of test cases, where each test case is a list of events with start and end times, compute the maximum number of non-overlapping events for each test case. :param test_cases: List of lists of tuples (start, end) where start and end are strings representing the start and end times in \\"HH:MM\\" format :return: List of integers representing the maximum number of non-overlapping events for each test case >>> solve_calendar_problem([[(\\"09:00\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")], [(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"10:30\\", \\"11:30\\"), (\\"11:00\\", \\"12:00\\")]]) [2, 3] pass","solution":"def max_non_overlapping_events(events): Given a list of events with start and end times, compute the maximum number of non-overlapping events that can be attended. # Convert event times to tuples of integers representing minutes since 00:00 event_times = [(int(start[:2]) * 60 + int(start[-2:]), int(end[:2]) * 60 + int(end[-2:])) for start, end in events] # Sort events by their end times event_times.sort(key=lambda x: x[1]) # Use a greedy algorithm to select the maximum number of non-overlapping events max_events = 0 last_end_time = 0 for start, end in event_times: if start >= last_end_time: max_events += 1 last_end_time = end return max_events def solve_calendar_problem(test_cases): results = [] for events in test_cases: results.append(max_non_overlapping_events(events)) return results"},{"question":"from typing import List def max_smallest_marble_size(n: int, sizes: List[int]) -> int: Given a list of marble sizes, determines the maximum possible size of the smallest marble after any number of merge operations. Args: n : int : The number of marbles sizes : List[int] : List containing the sizes of each marble Returns: int : The maximum possible size of the smallest marble after merge operations Examples: >>> max_smallest_marble_size(4, [1, 2, 3, 4]) 10 >>> max_smallest_marble_size(5, [10, 20, 30, 40, 50]) 150 pass def test_max_smallest_marble_size(): assert max_smallest_marble_size(4, [1, 2, 3, 4]) == 10 assert max_smallest_marble_size(5, [10, 20, 30, 40, 50]) == 150 assert max_smallest_marble_size(3, [1, 1, 1]) == 3 assert max_smallest_marble_size(1, [100]) == 100 assert max_smallest_marble_size(2, [5, 10]) == 15 assert max_smallest_marble_size(3, [1000000000, 1000000000, 1000000000]) == 3000000000 assert max_smallest_marble_size(6, [1, 2, 3, 4, 5, 6]) == 21 test_max_smallest_marble_size()","solution":"def max_smallest_marble_size(n, sizes): Given a list of marble sizes, determines the maximum possible size of the smallest marble after any number of merge operations. return sum(sizes)"},{"question":"def can_permute_palindrome(s: str) -> bool: Determine if any permutation of the input string can form a palindrome. :param s: input string :type s: str :return: True if any permutation of s can form a palindrome, False otherwise :rtype: bool >>> can_permute_palindrome(\\"civic\\") True >>> can_permute_palindrome(\\"ivicc\\") True >>> can_permute_palindrome(\\"hello\\") False >>> can_permute_palindrome(\\"aab\\") True","solution":"from collections import Counter def can_permute_palindrome(s): Determine if any permutation of the input string can form a palindrome. :param s: input string :type s: str :return: True if any permutation of s can form a palindrome, False otherwise :rtype: bool # Count frequencies of each character char_count = Counter(s) # A string can form a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") 10 >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. start = 0 max_length = 0 char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def zog_number_discovery(n: int, k: int, sequence: List[int]) -> List[int]: Perform k operations on the sequence of n integers where in each operation we replace the maximum element at index i or j with the minimum and vice versa. In effect, after enough operations the sequence will always be sorted in descending order. Args: n : int : the number of elements in the sequence k : int : the number of operations to be performed sequence : list of int : the initial sequence of integers Returns: list of int : the sequence after k operations >>> zog_number_discovery(5, 3, [4, 2, 1, 3, 5]) [5, 4, 3, 2, 1] >>> zog_number_discovery(3, 2, [8, 6, 7]) [8, 7, 6] >>> zog_number_discovery(4, 4, [1, 2, 3, 4]) [4, 3, 2, 1] >>> zog_number_discovery(6, 5, [10, 20, 30, 40, 50, 60]) [60, 50, 40, 30, 20, 10] >>> zog_number_discovery(2, 1, [100, 50]) [100, 50] >>> zog_number_discovery(3, 1000, [3, 1, 2]) [3, 2, 1] >>> zog_number_discovery(2, 100000, [1, 2]) [2, 1] >>> zog_number_discovery(2, 1, [2, 1]) [2, 1]","solution":"def zog_number_discovery(n, k, sequence): Perform k operations on the sequence of n integers where in each operation we replace the maximum element at index i or j with the minimum and vice versa. In effect, after enough operations the sequence will always be sorted in descending order. Args: n : int : the number of elements in the sequence k : int : the number of operations to be performed sequence : list of int : the initial sequence of integers Returns: list of int : the sequence after k operations # After any k operations, the sequence will be sorted in descending order. return sorted(sequence, reverse=True)"},{"question":"from typing import List, Tuple def calculate_engagement_scores(n: int, m: int, start_time: str, end_time: str, logs: List[Tuple[str, str, str, str]]) -> List[Tuple[int, int]]: Determine the engagement score for each post within a given time period. :param n: Number of interaction logs :param m: Number of posts :param start_time: Start time of the period in the format \\"YYYY-MM-DD HH:MM:SS\\" :param end_time: End time of the period in the format \\"YYYY-MM-DD HH:MM:SS\\" :param logs: List of interaction logs where each log is a tuple (timestamp, user_id, post_id, interaction) :return: List of tuples containing post ID and its corresponding engagement score sorted by post ID in ascending order >>> logs = [ ... (\\"2023-01-01 10:00:00\\", \\"1\\", \\"1\\", \\"like\\"), ... (\\"2023-01-01 11:00:00\\", \\"2\\", \\"1\\", \\"share\\"), ... (\\"2023-01-01 12:00:00\\", \\"3\\", \\"2\\", \\"comment\\"), ... (\\"2023-01-01 13:00:00\\", \\"4\\", \\"2\\", \\"like\\"), ... (\\"2023-01-01 14:00:00\\", \\"1\\", \\"1\\", \\"comment\\") ... ] >>> calculate_engagement_scores(5, 3, \\"2023-01-01 00:00:00\\", \\"2023-01-02 00:00:00\\", logs) [(1, 6), (2, 3), (3, 0)] >>> logs = [ ... (\\"2023-01-01 10:00:00\\", \\"1\\", \\"1\\", \\"like\\"), ... (\\"2023-01-01 12:00:00\\", \\"2\\", \\"1\\", \\"comment\\"), ... (\\"2023-01-01 14:00:00\\", \\"3\\", \\"3\\", \\"share\\") ... ] >>> calculate_engagement_scores(3, 4, \\"2023-01-01 00:00:00\\", \\"2023-01-02 00:00:00\\", logs) [(1, 3), (2, 0), (3, 3), (4, 0)]","solution":"from datetime import datetime def calculate_engagement_scores(n, m, start_time, end_time, logs): start_time = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_time = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") engagement_scores = {i: 0 for i in range(1, m + 1)} for log in logs: time_str, user_id, post_id, interaction = log time = datetime.strptime(time_str, \\"%Y-%m-%d %H:%M:%S\\") user_id, post_id = int(user_id), int(post_id) if start_time <= time <= end_time: if interaction == \\"like\\": engagement_scores[post_id] += 1 elif interaction == \\"comment\\": engagement_scores[post_id] += 2 elif interaction == \\"share\\": engagement_scores[post_id] += 3 return sorted(engagement_scores.items(), key=lambda x: x[0]) # Example usage logs = [ (\\"2023-01-01 10:00:00\\", \\"1\\", \\"1\\", \\"like\\"), (\\"2023-01-01 11:00:00\\", \\"2\\", \\"1\\", \\"share\\"), (\\"2023-01-01 12:00:00\\", \\"3\\", \\"2\\", \\"comment\\"), (\\"2023-01-01 13:00:00\\", \\"4\\", \\"2\\", \\"like\\"), (\\"2023-01-01 14:00:00\\", \\"1\\", \\"1\\", \\"comment\\") ] print(calculate_engagement_scores(5, 3, \\"2023-01-01 00:00:00\\", \\"2023-01-02 00:00:00\\", logs))"},{"question":"def closestToZero(arr): Finds and returns the pair of elements in the array such that their sum is closest to zero. If there are multiple pairs, returns any one of them. Args: arr (List[int]): List of integers. Returns: tuple: A tuple of two integers whose sum is closest to zero. Examples: >>> closestToZero([-1, 2, 1, -4, 3]) (-1, 1) or (1, -1) >>> closestToZero([2, 3, 6, 7]) (2, 3) or (3, 2) or (6, 7) or (7, 6) >>> closestToZero([-5, -4, -3, -2, -1]) (-2, -1) or (-1, -2) >>> closestToZero([-10, -5, -3, 1, 4, 8]) (-5, 4) or (4, -5)","solution":"def closestToZero(arr): Finds and returns the pair of elements in the array such that their sum is closest to zero. If there are multiple pairs, returns any one of them. arr.sort() left = 0 right = len(arr) - 1 closest_sum = float('inf') closest_pair = (None, None) while left < right: current_sum = arr[left] + arr[right] if abs(current_sum) < abs(closest_sum): closest_sum = current_sum closest_pair = (arr[left], arr[right]) if current_sum < 0: left += 1 else: right -= 1 return closest_pair"},{"question":"def longest_subarray_with_k_distinct(nums, k): Find the length of the longest contiguous subarray with at most K distinct integers. Args: nums (List[int]): The array of integers. k (int): The maximum number of distinct integers allowed in the subarray. Returns: int: The length of the longest subarray.","solution":"def longest_subarray_with_k_distinct(nums, k): Find the length of the longest contiguous subarray with at most K distinct integers. Args: nums (List[int]): The array of integers. k (int): The maximum number of distinct integers allowed in the subarray. Returns: int: The length of the longest subarray. from collections import defaultdict n = len(nums) if n == 0 or k == 0: return 0 # Dictionary to store the count of elements in the current window count = defaultdict(int) left = 0 max_length = 0 for right in range(n): count[nums[right]] += 1 while len(count) > k: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def largest_concatenated_integer(n, arr): Returns the largest possible concatenated integer from the given list of integers. :param n: int, number of elements in the list :param arr: list of integers :return: str, the largest concatenated integer >>> largest_concatenated_integer(3, [50, 2, 1]) '5021' >>> largest_concatenated_integer(4, [10, 2, 30, 3]) '330210' >>> largest_concatenated_integer(5, [3, 30, 34, 5, 9]) '9534330' >>> largest_concatenated_integer(6, [56, 56, 56, 56, 56, 56]) '565656565656' >>> largest_concatenated_integer(1, [0]) '0' >>> largest_concatenated_integer(3, [0, 0, 0]) '0'","solution":"def largest_concatenated_integer(n, arr): Returns the largest possible concatenated integer from the given list of integers. :param n: int, number of elements in the list :param arr: list of integers :return: str, the largest concatenated integer from functools import cmp_to_key # Custom comparator to order the numbers to form the largest concatenated integer def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all integers to strings str_arr = list(map(str, arr)) # Sort the array with the custom comparator str_arr.sort(key=cmp_to_key(compare)) # Concatenate all strings in the sorted array largest_number = ''.join(str_arr) # Remove redundant leading zeroes if exist (for edge case [\\"0\\", \\"0\\", ...]) return largest_number if largest_number[0] != '0' else '0' # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) print(largest_concatenated_integer(n, arr))"},{"question":"def electric_car_battery_management(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Simulate the energy consumption over multiple trips and determine the maximum number of complete trips the car can make. Each trip requires energy E. After completing a trip, the remaining energy in the battery cells is kept, and the car cannot start a new trip if it does not have enough energy to complete it. Args: - T: Number of test cases - test_cases: List of tuples containing: - E: Energy required per trip - N: Number of battery cells - List of integers representing the energy in each battery cell Returns: - List of integers, each representing the maximum number of complete trips for the corresponding test case Example: >>> electric_car_battery_management(2, [(5, 3, [4, 3, 2]), (10, 5, [5, 6, 7, 8, 9])]) [1, 3]","solution":"def max_complete_trips(E, N, energies): total_energy = sum(energies) return total_energy // E def process_test_cases(T, test_cases): results = [] for case in test_cases: E, N, energies = case results.append(max_complete_trips(E, N, energies)) return results def electric_car_battery_management(T, test_cases): return process_test_cases(T, test_cases)"},{"question":"def count_inversions(arr): Given a sequence of integers, compute the number of inversions in the sequence. An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j]. :param arr: List of integers :return: Integer count of inversions >>> count_inversions([5, 3, 2, 4, 1]) 8 >>> count_inversions([1, 2, 3, 4]) 0 >>> from solution import count_inversions def test_count_inversions_example1(): arr = [5, 3, 2, 4, 1] assert count_inversions(arr) == 8 def test_count_inversions_example2(): arr = [1, 2, 3, 4] assert count_inversions(arr) == 0 def test_count_inversions_single_element(): arr = [10] assert count_inversions(arr) == 0 def test_count_inversions_sorted_descending(): arr = [5, 4, 3, 2, 1] assert count_inversions(arr) == 10 def test_count_inversions_mixed_values(): arr = [1, 3, 5, 2, 4, 6] assert count_inversions(arr) == 3","solution":"def count_inversions(arr): Function to count the number of inversions in the array. An inversion is a pair (i, j) such that i < j and arr[i] > arr[j]. :param arr: List of integers :return: Integer count of inversions def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = arr[:] return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)"},{"question":"def can_reach_station(n: int, tunnel_powers: List[int], queries: List[int]) -> List[str]: Determine if it is possible to journey from the starting station (id 0) to various destination stations. Args: n: int - number of tunnels tunnel_powers: List[int] - power levels of the tunnels queries: List[int] - destination station ids to check Returns: List[str] - \\"YES\\" or \\"NO\\" for each query indicating if the journey is possible. >>> can_reach_station(3, [2, 3, 5], [4, 6, 7]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_reach_station(1, [4], [8, 16, 32, 7]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] from typing import List # Test cases def test_example_case(): n = 3 tunnel_powers = [2, 3, 5] queries = [4, 6, 7] expected_results = [\\"YES\\", \\"YES\\", \\"NO\\"] assert can_reach_station(n, tunnel_powers, queries) == expected_results def test_single_power_level(): n = 1 tunnel_powers = [4] queries = [8, 16, 32, 7] expected_results = [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] assert can_reach_station(n, tunnel_powers, queries) == expected_results def test_multiple_queries(): n = 2 tunnel_powers = [3, 7] queries = [9, 21, 14, 5] expected_results = [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] assert can_reach_station(n, tunnel_powers, queries) == expected_results def test_large_powers(): n = 2 tunnel_powers = [1000000007, 999999937] queries = [1000000007 * 2, 999999937 * 3] expected_results = [\\"YES\\", \\"YES\\"] assert can_reach_station(n, tunnel_powers, queries) == expected_results def test_unreachable_stations(): n = 3 tunnel_powers = [2, 7, 11] queries = [13, 19, 23] expected_results = [\\"NO\\", \\"NO\\", \\"NO\\"] assert can_reach_station(n, tunnel_powers, queries) == expected_results","solution":"def can_reach_station(n, tunnel_powers, queries): reachable = set() for power in tunnel_powers: if power > 0: reachable.add(power) results = [] for y in queries: found = False for power in reachable: if y % power == 0: found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: n = 3 tunnel_powers = [2, 3, 5] queries = [4, 6, 7] results = can_reach_station(n, tunnel_powers, queries) for result in results: print(result)"},{"question":"def checkHammingDistance(n: int, arr: List[int], threshold: int, queries: List[Tuple[int, int]]) -> List[bool]: Check if the Hamming distance between consecutive elements in subarrays remains below a given threshold. Parameters: n (int) : Size of the array. arr (List[int]) : Array of integers. threshold (int) : Maximum acceptable Hamming distance. queries (List[Tuple[int, int]]) : List of queries with start and end indices of the subarray. Returns: List[bool] : True if the subarray meets the criteria, false otherwise. Example: >>> checkHammingDistance(5, [1, 4, 3, 6, 7], 2, [(0, 2), (2, 4)]) [False, True] >>> checkHammingDistance(4, [1, 2, 3, 4], 1, [(0, 0), (1, 1)]) [True, True] >>> checkHammingDistance(3, [7, 7, 7], 0, [(0, 2)]) [True]","solution":"def hamming_distance(a, b): return bin(a ^ b).count('1') def checkHammingDistance(n, arr, threshold, queries): results = [] for L, R in queries: meets_criteria = True for i in range(L, R): if hamming_distance(arr[i], arr[i+1]) > threshold: meets_criteria = False break results.append(meets_criteria) return results"},{"question":"from typing import List def count_distinct_k_char_subsequences(s: str, k: int) -> int: Count the number of distinct non-empty subsequences of \`s\` that contain exactly \`k\` characters. >>> count_distinct_k_char_subsequences(\\"abcde\\", 3) 10 >>> count_distinct_k_char_subsequences(\\"aaaaaa\\", 3) 1 >>> count_distinct_k_char_subsequences(\\"ab\\", 1) 2 >>> count_distinct_k_char_subsequences(\\"ab\\", 3) 0 >>> count_distinct_k_char_subsequences(\\"abcdefghijklmnopqrstuvwxyz\\", 5) 65780 >>> count_distinct_k_char_subsequences(\\"a\\", 1) 1","solution":"from itertools import combinations def count_distinct_k_char_subsequences(s, k): subsequences = set() for combo in combinations(s, k): subsequences.add(''.join(combo)) return len(subsequences)"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Return the length of the shortest path from city s to city t using Dijkstra's algorithm. >>> dijkstra(5, 6, [(1, 2, 2), (1, 3, 1), (2, 3, 4), (2, 4, 7), (3, 5, 3), (4, 5, 1)], 1, 5) 4 >>> dijkstra(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 10)], 1, 3) 7 >>> dijkstra(4, 2, [(1, 2, 3), (3, 4, 4)], 1, 4) -1 >>> dijkstra(1, 0, [], 1, 1) 0 >>> dijkstra(5, 3, [(1, 2, 2), (3, 4, 3), (4, 5, 1)], 1, 5) -1 pass","solution":"import heapq def dijkstra(n, m, edges, s, t): Return the length of the shortest path from city s to city t using Dijkstra's algorithm. # Create adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Distance array dist = [float('inf')] * (n + 1) dist[s] = 0 # Priority queue for Dijkstra's algorithm pq = [(0, s)] while pq: d, u = heapq.heappop(pq) if d > dist[u]: continue for v, w in graph[u]: if dist[u] + w < dist[v]: dist[v] = dist[u] + w heapq.heappush(pq, (dist[v], v)) return dist[t] if dist[t] != float('inf') else -1 # Example usage # n, m = 5, 6 # edges = [(1, 2, 2), (1, 3, 1), (2, 3, 4), (2, 4, 7), (3, 5, 3), (4, 5, 1)] # s, t = 1, 5 # print(dijkstra(n, m, edges, s, t)) # Output: 4"},{"question":"def can_reach_destination(N: int, M: int, grid: List[str]) -> str: Determine whether John can reach his destination. Arguments: N -- number of rows in the grid (integer) M -- number of columns in the grid (integer) grid -- a list of strings representing the grid Returns: \\"YES\\" if John can reach the cell (N, M) from (1, 1); otherwise, \\"NO\\" >>> can_reach_destination(3, 4, [\\"OOOO\\", \\"OXOX\\", \\"OOOO\\"]) \\"YES\\" >>> can_reach_destination(3, 3, [\\"OOO\\", \\"XXO\\", \\"OXX\\"]) \\"NO\\"","solution":"def can_reach_destination(N, M, grid): from collections import deque def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == 'O' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (N-1, M-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def swap_first_last(s: str) -> str: Returns a new string where the first and last characters have been swapped. If the string is of length 1, it returns the string unchanged. >>> swap_first_last('a') 'a' >>> swap_first_last('ab') 'ba' >>> swap_first_last('abc') 'cba' >>> swap_first_last('hello') 'oellh' >>> swap_first_last('a b c') 'c b a' >>> swap_first_last('12345') '52341' >>> swap_first_last('aaaa') 'aaaa' >>> swap_first_last('@bc!') '!bc@'","solution":"def swap_first_last(s): Returns a new string where the first and last characters have been swapped. If the string is of length 1, it returns the string unchanged. if len(s) == 1: return s return s[-1] + s[1:-1] + s[0]"},{"question":"def rotate_matrix(matrix): Rotates a given NxN matrix by 90 degrees in clockwise direction. :param matrix: List[List[int]] - A 2D list representing the NxN matrix. :return: List[List[int]] - The rotated matrix. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise. :param matrix: List[List[int]] - A 2D list representing the NxN matrix. :return: List[List[int]] - The rotated matrix. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def reverse_even_numbers(nums: List[int]) -> List[int]: Return a new list containing only the even numbers from the original list, but in reverse order. >>> reverse_even_numbers([1, 2, 3, 4, 5, 6]) == [6, 4, 2] >>> reverse_even_numbers([10, 31, 42, 53, 64]) == [64, 42, 10] >>> reverse_even_numbers([7, 13, 19, 25]) == []","solution":"def reverse_even_numbers(nums): Returns a new list containing only the even numbers from the original list, but in reverse order. even_numbers = [num for num in nums if num % 2 == 0] return even_numbers[::-1]"},{"question":"def find_min_cost_to_connect_cities(C, R, roads): Find the minimum cost to connect all cities with roads. Uses Kruskal's algorithm to find the Minimum Spanning Tree (MST). :param C: Number of cities :param R: Number of potential roads :param roads: List of tuples, where each tuple contains (u, v, w) indicating a road between city u and city v with cost w. :return: Minimum total cost to connect all cities >>> find_min_cost_to_connect_cities(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 6), (1, 3, 2)]) == 10 >>> find_min_cost_to_connect_cities(3, 3, [(1, 2, 1), (1, 3, 2), (2, 3, 3)]) == 3 >>> find_min_cost_to_connect_cities(1, 0, []) == 0 >>> find_min_cost_to_connect_cities(2, 1, [(1, 2, 100)]) == 100 >>> find_min_cost_to_connect_cities(4, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1), (1, 3, 10)]) == 3","solution":"def find_min_cost_to_connect_cities(C, R, roads): Finds the minimum cost to connect all cities with roads. Uses Kruskal's algorithm to find the Minimum Spanning Tree (MST). :param C: Number of cities :param R: Number of potential roads :param roads: List of tuples, where each tuple contains (u, v, w) indicating a road between city u and city v with cost w. :return: Minimum total cost to connect all cities # A function to find the root of a city def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # A function to union two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 roads.sort(key=lambda x: x[2]) # Sort roads based on cost parent = list(range(C)) rank = [0] * C mst_cost = 0 edges_used = 0 for u, v, w in roads: u, v = u - 1, v - 1 # Decrement to use zero-based index root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: # If u and v are not in the same set union(parent, rank, root_u, root_v) mst_cost += w edges_used += 1 if edges_used == C - 1: # MST will have exactly C-1 edges break return mst_cost"},{"question":"def max_non_overlapping_races(races): Returns the maximum number of non-overlapping races. :param races: List of tuples (start, end) of each race. :return: Maximum number of non-overlapping races. >>> max_non_overlapping_races([(1, 2), (2, 3), (3, 4)]) 2 >>> max_non_overlapping_races([(1, 2)]) 1 >>> max_non_overlapping_races([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_races([(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_races([(1, 3), (2, 4), (3, 5), (4, 6)]) 2","solution":"def max_non_overlapping_races(races): Returns the maximum number of non-overlapping races. :param races: List of tuples (start, end) of each race. :return: Maximum number of non-overlapping races. # Sort the races by their end day races.sort(key=lambda x: x[1]) # Initialize the end time of the last selected race to 0 last_end_time = 0 count = 0 for start, end in races: if start > last_end_time: count += 1 last_end_time = end return count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() M = int(data[0]) races = [] for i in range(M): start = int(data[2*i+1]) end = int(data[2*i+2]) races.append((start, end)) print(max_non_overlapping_races(races))"},{"question":"def max_distinct_items(prices, budget): Given a list of integers representing the prices of items in a store and a specific budget, find the maximum number of distinct items you can buy without exceeding the budget. -----Input----- - The input consists of two lines. - The first line contains an integer B, the budget. - The second line contains a list of space-separated positive integers representing the prices of items. -----Output----- - Output a single integer, which is the maximum number of distinct items that can be bought without exceeding the budget. >>> max_distinct_items([1, 12, 5, 111, 200, 1000, 10], 50) 4 >>> max_distinct_items([5, 5, 5, 5], 20) 4 >>> max_distinct_items([100, 200, 300], 50) 0","solution":"def max_distinct_items(prices, budget): # Sort the prices in ascending order prices.sort() # Initialize variables to keep track of total spent and the count of items total_spent = 0 count = 0 # Loop through the sorted prices for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count"},{"question":"def max_sum_submatrix(matrix, n, k): Returns the maximum sum of elements of a k x k sub-matrix in an n x n matrix. >>> n, k = 4, 2 >>> matrix = [ ... [1, 5, 3, 2], ... [8, 2, 4, 1], ... [5, 9, 6, 3], ... [2, 6, 7, 8] ... ] >>> max_sum_submatrix(matrix, n, k) 28 >>> n, k = 1, 1 >>> matrix = [ ... [100] ... ] >>> max_sum_submatrix(matrix, n, k) 100 >>> n, k = 2, 2 >>> matrix = [ ... [-100, -100], ... [-100, -100] ... ] >>> max_sum_submatrix(matrix, n, k) -400 >>> n, k = 3, 1 >>> matrix = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> max_sum_submatrix(matrix, n, k) 0 >>> n, k = 3, 2 >>> matrix = [ ... [10000, 10000, 10000], ... [10000, 10000, 10000], ... [10000, 10000, 10000] ... ] >>> max_sum_submatrix(matrix, n, k) 40000 >>> n, k = 3, 2 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_sum_submatrix(matrix, n, k) 28 pass","solution":"def max_sum_submatrix(matrix, n, k): Returns the maximum sum of elements of a k x k sub-matrix in an n x n matrix. # Initialize the maximum sum variable max_sum = float('-inf') # Compute prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): for j in range(n): prefix_sum[i+1][j+1] = matrix[i][j] + prefix_sum[i][j+1] + prefix_sum[i+1][j] - prefix_sum[i][j] # Iterate through possible k x k sub-matrices for i in range(k, n + 1): for j in range(k, n + 1): current_sum = prefix_sum[i][j] - prefix_sum[i-k][j] - prefix_sum[i][j-k] + prefix_sum[i-k][j-k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def word_exists(grid, word): Check if the word exists in the 2D grid following specific rules. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Args: grid: A 2D list of characters. word: A string representing the target word. Returns: True if the word exists in the grid, and False otherwise. Examples: >>> grid = [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ] >>> word = \\"ABCCED\\" >>> word_exists(grid, word) True >>> grid = [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ] >>> word = \\"SEE\\" >>> word_exists(grid, word) True >>> grid = [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ] >>> word = \\"ABCB\\" >>> word_exists(grid, word) False","solution":"def word_exists(grid, word): if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) def backtrack(r, c, index): if index == len(word): return True if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != word[index]: return False # mark the cell as visited temp, grid[r][c] = grid[r][c], '#' found = ( backtrack(r + 1, c, index + 1) or backtrack(r - 1, c, index + 1) or backtrack(r, c + 1, index + 1) or backtrack(r, c - 1, index + 1) ) grid[r][c] = temp # unmark the cell return found for row in range(rows): for col in range(cols): if backtrack(row, col, 0): return True return False"},{"question":"def decode_message(n: int, encoded_message: List[int]) -> str: Decodes an encoded message from a list of integers representing positions in the alphabet. Parameters: n (int): The length of the encoded message list. encoded_message (list of int): A list of integers representing positions in the alphabet. Returns: str: The decoded message as a string of uppercase English letters. >>> decode_message(5, [8, 5, 12, 12, 15]) 'HELLO' >>> decode_message(3, [3, 1, 20]) 'CAT' >>> decode_message(4, [19, 5, 1, 12]) 'SEAL'","solution":"def decode_message(n, encoded_message): Decodes an encoded message from a list of integers representing positions in the alphabet. Parameters: n (int): The length of the encoded message list. encoded_message (list of int): A list of integers representing positions in the alphabet. Returns: str: The decoded message as a string of uppercase English letters. decoded_message = ''.join(chr(num + 64) for num in encoded_message) return decoded_message"},{"question":"class Enemy: An Enemy class for the terminal game. Initializes with default attributes or customized ones if provided. Attributes: name (str): Name of the enemy. Default is 'Enemy'. health (float): Health points of the enemy. Default is 50.0. damage (float): Damage points of the enemy. Default is 10.0. experience (int): Experience points of the enemy. Default is 0. def __init__(self, name='Enemy', health=50.0, damage=10.0, experience=0): pass # Test cases def test_default_enemy(): enemy = Enemy() assert enemy.name == 'Enemy' assert enemy.health == 50.0 assert enemy.damage == 10.0 assert enemy.experience == 0 def test_custom_name_enemy(): enemy = Enemy(name='Goblin') assert enemy.name == 'Goblin' assert enemy.health == 50.0 assert enemy.damage == 10.0 assert enemy.experience == 0 def test_custom_all_attributes_enemy(): enemy = Enemy(name='Orc', health=70.0, damage=15.0, experience=5) assert enemy.name == 'Orc' assert enemy.health == 70.0 assert enemy.damage == 15.0 assert enemy.experience == 5 def test_partial_custom_attributes_enemy(): enemy = Enemy(name='Dragon', health=100.0) assert enemy.name == 'Dragon' assert enemy.health == 100.0 assert enemy.damage == 10.0 assert enemy.experience == 0","solution":"class Enemy: def __init__(self, name='Enemy', health=50.0, damage=10.0, experience=0): self.name = name self.health = health self.damage = damage self.experience = experience"},{"question":"def analyzeStockPrices(prices, startTime, endTime): Returns the minimum, maximum, and average stock prices within the given time window. :param prices: List of tuples [(timestamp, price),...] :param startTime: Integer start time of the window :param endTime: Integer end time of the window :return: Tuple (minPrice, maxPrice, avgPrice) Examples: >>> analyzeStockPrices([(1, 100), (2, 110), (3, 105), (4, 115)], 2, 4) (105, 115, 110.0) >>> analyzeStockPrices([(1, 150)], 3, 5) (None, None, None)","solution":"def analyzeStockPrices(prices, startTime, endTime): Returns the minimum, maximum, and average stock prices within the given time window. :param prices: List of tuples [(timestamp, price),...] :param startTime: Integer start time of the window :param endTime: Integer end time of the window :return: Tuple (minPrice, maxPrice, avgPrice) filtered_prices = [price for (timestamp, price) in prices if startTime <= timestamp <= endTime] if not filtered_prices: return (None, None, None) minPrice = min(filtered_prices) maxPrice = max(filtered_prices) avgPrice = sum(filtered_prices) / len(filtered_prices) return (minPrice, maxPrice, avgPrice)"},{"question":"def min_typing_time(s: str) -> int: Write a function to determine the minimum time required to type out a given string using a special keyboard. The keyboard contains all lowercase English letters and is arranged in a single row in the following order: \\"abcdefghijklmnopqrstuvwxyz\\". The time taken to move from one key to another is equal to the absolute difference in their positions. You start with your finger on the first character of the keyboard. Args: s (str): The string to be typed out. Returns: int: The total time needed to type out the string. Examples: >>> min_typing_time(\\"cba\\") 4 >>> min_typing_time(\\"zebra\\") 82","solution":"def min_typing_time(s: str) -> int: This function calculates the minimum time required to type out a given string on a keyboard arranged as \\"abcdefghijklmnopqrstuvwxyz\\". if not s: return 0 # Dictionary to store positions of letters in the keyboard. position = {chr(i + 97): i + 1 for i in range(26)} total_time = 0 current_position = 1 # starting at 'a' position, which is 1 for char in s: new_position = position[char] # Calculate the absolute difference between current and new position total_time += abs(new_position - current_position) current_position = new_position return total_time"},{"question":"def findIndices(a: List[int], target: int) -> List[int]: Finds two distinct indices in the array \`a\` where the sum of the elements at those indices equals \`target\`. Args: a (list of int): The integer array. target (int): The target sum. Returns: list of int: A list containing the pair of indices that sum up to the target, or [-1, -1] if no such indices exist. >>> findIndices([2, 7, 11, 15], 9) == [0, 1] >>> findIndices([1, 2, 3], 6) == [-1, -1]","solution":"def findIndices(a, target): Finds two distinct indices in array \`a\` where the sum of the elements at those indices equals \`target\`. Parameters: a (list of int): The integer array. target (int): The target sum. Returns: list of int: A list containing the pair of indices that sum up to the target, or [-1, -1] if no such indices exist. index_map = {} for i, num in enumerate(a): complement = target - num if complement in index_map: return [index_map[complement], i] index_map[num] = i return [-1, -1]"},{"question":"def min_sum_of_squares(N: int) -> int: The function to compute the number of partitions of N that achieve the minimum sum of squares. >>> min_sum_of_squares(5): 1 >>> min_sum_of_squares(6): 1 >>> min_sum_of_squares(7): 1 def number_of_partitions(Q: int, cases: List[int]) -> List[int]: For each case, return the number of partitions that achieve the minimum sum of squares. >>> number_of_partitions(3, [5, 6, 7]): [1, 1, 1] from typing import List def test_case_1(): assert number_of_partitions(1, [5]) == [1] def test_case_2(): assert number_of_partitions(3, [5, 6, 7]) == [1, 1, 1] def test_case_3(): cases = [i for i in range(1, 11)] assert number_of_partitions(10, cases) == [1] * 10 def test_maximum_limit(): cases = [i for i in range(1, 1001)] assert number_of_partitions(1000, cases) == [1] * 1000 def test_minimum_limit(): cases = [1] assert number_of_partitions(1, cases) == [1]","solution":"def min_sum_of_squares(N): The function to compute the number of partitions of N that achieve the minimum sum of squares. We can derive from observation that the minimal sum of squares can be achieved by using all 1's. Thus, the number of such partitions is always 1. return 1 def number_of_partitions(Q, cases): For each case, return the number of partitions that achieve the minimum sum of squares. return [min_sum_of_squares(N) for N in cases] # Example usage: # Q = 3 # cases = [5, 6, 7] # result = number_of_partitions(Q, cases) # print(result) # Output: [1, 1, 1]"},{"question":"import heapq from typing import List def k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]: Find the k pairs (u,v) which consists of one element from nums1 and one element from nums2 with the smallest sums. :param nums1: List[int] :param nums2: List[int] :param k: int :return: List[List[int]] >>> k_smallest_pairs([1, 7, 11], [2, 4, 6], 3) [[1, 2], [1, 4], [1, 6]] >>> k_smallest_pairs([1, 1, 2], [1, 2, 3], 2) [[1, 1], [1, 1]] >>> k_smallest_pairs([1, 2], [3], 3) [[1, 3], [2, 3]]","solution":"import heapq def k_smallest_pairs(nums1, nums2, k): Find the k pairs (u,v) which consists of one element from nums1 and one element from nums2 with the smallest sums. :param nums1: List[int] :param nums2: List[int] :param k: int :return: List[List[int]] if not nums1 or not nums2 or k <= 0: return [] min_heap = [] for i in range(min(len(nums1), k)): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) result = [] while min_heap and len(result) < k: current_sum, i, j = heapq.heappop(min_heap) result.append([nums1[i], nums2[j]]) if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1)) return result"},{"question":"from typing import List def is_super_balanced(s: str) -> str: Determines if a string is \\"super balanced\\". A string is \\"super balanced\\" if all characters occur the same number of times, or if there is one character that occurs one more time than all other characters. >>> is_super_balanced(\\"aabbcc\\") 'YES' >>> is_super_balanced(\\"aabbccc\\") 'YES' >>> is_super_balanced(\\"aabbcccc\\") 'NO' # Implementation here def check_super_balanced_strings(test_cases: List[str]) -> List[str]: Checks a list of strings to determine if each string is \\"super balanced\\". >>> check_super_balanced_strings([\\"aabbcc\\", \\"aabbccc\\", \\"aabbcccc\\", \\"abcabcabc\\", \\"aaa\\"]) ['YES', 'YES', 'NO', 'YES', 'YES'] results = [] for s in test_cases: results.append(is_super_balanced(s)) return results","solution":"from collections import Counter def is_super_balanced(s): Determines if a string is \\"super balanced\\". freq = Counter(s) values = list(freq.values()) freq_set = set(values) if len(freq_set) == 1: return \\"YES\\" if len(freq_set) == 2: max_val = max(freq_set) min_val = min(freq_set) if values.count(max_val) == 1 and max_val - min_val == 1: return \\"YES\\" return \\"NO\\" def check_super_balanced_strings(test_cases): results = [] for s in test_cases: results.append(is_super_balanced(s)) return results"},{"question":"def calculate_total_registration_fees(a: int, b: int, c: int) -> int: Calculate the total registration fees collected from the participants. Parameters: a (int): Number of participants in the 5km race b (int): Number of participants in the 10km race c (int): Number of participants in the 21km race Returns: int: Total registration fees collected >>> calculate_total_registration_fees(10, 5, 2) 260 >>> calculate_total_registration_fees(0, 0, 0) 0 >>> calculate_total_registration_fees(3, 4, 5) 290 from solution import calculate_total_registration_fees def test_calculate_total_registration_fees_sample1(): assert calculate_total_registration_fees(10, 5, 2) == 100 + 100 + 60 def test_calculate_total_registration_fees_sample2(): assert calculate_total_registration_fees(0, 0, 0) == 0 def test_calculate_total_registration_fees_sample3(): assert calculate_total_registration_fees(3, 4, 5) == 30 + 80 + 150 def test_calculate_total_registration_fees_large_numbers(): assert calculate_total_registration_fees(1000, 1000, 1000) == 1000 * 10 + 1000 * 20 + 1000 * 30 def test_calculate_total_registration_fees_edge_case_single_participants(): assert calculate_total_registration_fees(1, 1, 1) == 10 + 20 + 30 def test_calculate_total_registration_fees_mixed_participants(): assert calculate_total_registration_fees(7, 0, 5) == 7 * 10 + 5 * 30","solution":"def calculate_total_registration_fees(a, b, c): Calculate the total registration fees collected from the participants. Parameters: a (int): Number of participants in the 5km race b (int): Number of participants in the 10km race c (int): Number of participants in the 21km race Returns: int: Total registration fees collected fee_5km = 10 fee_10km = 20 fee_21km = 30 total_fees = (a * fee_5km) + (b * fee_10km) + (c * fee_21km) return total_fees"},{"question":"from typing import List, Tuple def find_two_closest_to_zero(arr: List[int]) -> Tuple[int, int]: Finds two numbers in the array such that their sum is closest to zero. >>> find_two_closest_to_zero([-1, 2, 3, -4, 5]) (-1, 2) >>> find_two_closest_to_zero([-10, 15, 27, -4, 30, 6]) (-4, 6) >>> find_two_closest_to_zero([1, -1, 2]) (1, -1)","solution":"def find_two_closest_to_zero(arr): Finds two numbers in the array such that their sum is closest to zero. arr.sort() left, right = 0, len(arr) - 1 closest_sum = float('inf') closest_pair = (arr[left], arr[right]) while left < right: current_sum = arr[left] + arr[right] if abs(current_sum) < abs(closest_sum): closest_sum = current_sum closest_pair = (arr[left], arr[right]) if current_sum < 0: left += 1 else: right -= 1 return closest_pair"},{"question":"from typing import List def find_largest_divisor(n: int, arr: List[int]) -> int: Given an array with \`n\` unique integers, find an integer \`k\` such that all elements in the array can be divided by \`k\` without a remainder. \`k\` should be the largest possible divisor. Args: n (int): the number of integers arr (List[int]): list of integers Returns: int: the largest integer k that divides all the numbers in the array without a remainder. Example: >>> find_largest_divisor(3, [6, 9, 15]) 3 >>> find_largest_divisor(4, [12, 15, 21, 27]) 3","solution":"import math from functools import reduce def find_gcd(x, y): Returns the greatest common divisor (GCD) of x and y using the Euclidean algorithm. while y: x, y = y, x % y return x def largest_divisor(arr): Finds the largest integer k such that all elements in the array can be divided by k without a remainder. return reduce(find_gcd, arr) def find_largest_divisor(n, arr): Wrapper function to find the largest divisor given n and array of integers arr. if n == 1: return arr[0] return largest_divisor(arr)"},{"question":"def handle_booking_requests(n: int, requests: List[Tuple[int, int]]) -> List[str]: This function takes the number of booking requests and a list of booking requests. Each request is a tuple (start, end). It returns a list of strings \\"Yes\\" or \\"No\\" based on whether the booking request is granted or denied. >>> handle_booking_requests(3, [(1, 3), (2, 4), (5, 6)]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> handle_booking_requests(4, [(1, 2), (2, 3), (3, 4), (1, 5)]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"]","solution":"def handle_booking_requests(n, requests): This function takes the number of booking requests and a list of booking requests. Each request is a tuple (start, end). It returns a list of strings \\"Yes\\" or \\"No\\" based on whether the booking request is granted or denied. bookings = [] results = [] for start, end in requests: conflict = False for s, e in bookings: if not (end <= s or start >= e): conflict = True break if conflict: results.append(\\"No\\") else: results.append(\\"Yes\\") bookings.append((start, end)) return results def read_input_and_process(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) requests = [(int(data[i]), int(data[i+1])) for i in range(1, 2*n, 2)] results = handle_booking_requests(n, requests) for result in results: print(result)"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(2) [] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n < 2: return [] # Initialize a boolean array indicating the primality of each number from 0 to n-1. is_prime = [True] * n is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers for i in range(2, int(n ** 0.5) + 1): if is_prime[i]: for j in range(i * i, n, i): is_prime[j] = False # Collecting all prime numbers primes = [i for i in range(n) if is_prime[i]] return primes"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray within the given integer array arr. Parameters: arr (List[int]): An array of integers. Returns: int: The maximum sum of a contiguous subarray. >>> max_subarray_sum([1, 2, 3, 4, -10]) 10 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 def process_input(input_data): Processes the input data into test cases and returns the results as a list. Parameters: input_data (str): The raw input data containing multiple test cases. Returns: List[int]: A list of results for each test case. >>> process_input(\\"3n5n1 2 3 4 -10n4n-1 -2 -3 -4n6n5 4 -1 7 8n\\") [10, -1, 23] def solve(input_data): Given the input data, processes it and returns the results as a formatted string. Parameters: input_data (str): The raw input data containing multiple test cases. Returns: str: The results for each test case, formatted as specified in the problem description. >>> solve(\\"3n5n1 2 3 4 -10n4n-1 -2 -3 -4n6n5 4 -1 7 8n\\") \\"10n-1n23\\"","solution":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray within the given integer array arr. max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def process_input(input_data): input_lines = input_data.strip().split('n') index = 0 T = int(input_lines[index]) index += 1 results = [] for _ in range(T): n = int(input_lines[index]) index += 1 arr = list(map(int, input_lines[index].split())) index += 1 result = max_subarray_sum(arr) results.append(result) return results def solve(input_data): results = process_input(input_data) return \\"n\\".join(map(str, results))"},{"question":"def longest_palindromic_substrings(s: str) -> List[str]: Finds all unique substrings that are palindromes and have the maximum length. Args: s: A string consisting of lowercase Latin letters. Returns: A list of unique longest palindromic substrings in lexicographical order. >>> longest_palindromic_substrings(\\"babad\\") [\\"aba\\", \\"bab\\"] >>> longest_palindromic_substrings(\\"cbbd\\") [\\"bb\\"] >>> longest_palindromic_substrings(\\"a\\") [\\"a\\"] >>> longest_palindromic_substrings(\\"banana\\") [\\"anana\\"] pass","solution":"def longest_palindromic_substrings(s): Finds all unique substrings that are palindromes and have the maximum length. Args: s: A string consisting of lowercase Latin letters. Returns: A list of unique longest palindromic substrings in lexicographical order. n = len(s) max_length = 0 palindromes = set() for i in range(n): for j in range(i, n): substr = s[i:j+1] if substr == substr[::-1]: if len(substr) > max_length: max_length = len(substr) palindromes = {substr} elif len(substr) == max_length: palindromes.add(substr) return sorted(palindromes)"},{"question":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. The allowed operations are: 1. Insert a character. 2. Delete a character. 3. Replace a character. Args: s1 (str): The initial string. s2 (str): The target string. Returns: int: The minimum number of operations required to transform s1 into s2. Examples: >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"abc\\", \\"abc\\") 0","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Need to insert j characters elif j == 0: dp[i][j] = i # Need to delete i characters elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def is_magic_number(n: int) -> str: Check if the number is a magic number. A \\"Magic Number\\" is defined as an integer that satisfies the following conditions: 1. The sum of its digits is a prime number. 2. The number contains at least one digit '7'. Args: n (int): The input integer to be checked. Returns: str: \\"MAGIC!\\" if the number is a Magic Number, otherwise \\"NOT MAGIC!\\". Examples: >>> is_magic_number(37) == \\"NOT MAGIC!\\" >>> is_magic_number(233) == \\"NOT MAGIC!\\" >>> is_magic_number(719) == \\"MAGIC!\\" # Implementation here # Unit Tests def test_magic_with_prime_sum_and_seven(): assert is_magic_number(719) == \\"MAGIC!\\" def test_not_magic_due_to_non_prime_sum(): assert is_magic_number(37) == \\"NOT MAGIC!\\" def test_not_magic_without_seven(): assert is_magic_number(233) == \\"NOT MAGIC!\\" def test_magic_prime_sum_contains_seven(): assert is_magic_number(47) == \\"MAGIC!\\" def test_magic_only_contains_seven(): assert is_magic_number(7) == \\"MAGIC!\\" def test_not_magic_no_prime_sum_does_not_contain_seven(): assert is_magic_number(8) == \\"NOT MAGIC!\\"","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def is_magic_number(n): digits = [int(d) for d in str(n)] digit_sum = sum(digits) contains_seven = 7 in digits if is_prime(digit_sum) and contains_seven: return \\"MAGIC!\\" else: return \\"NOT MAGIC!\\""},{"question":"from typing import List class DynamicArray: A class that supports updating elements in an array and querying the sum of a range of elements. def __init__(self, arr: List[int]) -> None: Initializes the data structure with the given array of integers. pass def update(self, index: int, value: int) -> None: Updates the element at position \`index\` in the array to \`value\`. pass def sum_range(self, left: int, right: int) -> int: Returns the sum of the elements within the range [left, right] (inclusive). pass def test_initial_sum_range(): arr = [1, 3, 5] da = DynamicArray(arr) assert da.sum_range(0, 2) == 9 assert da.sum_range(1, 2) == 8 assert da.sum_range(0, 1) == 4 def test_update_and_sum_range(): arr = [1, 3, 5] da = DynamicArray(arr) da.update(1, 2) assert da.sum_range(0, 2) == 8 assert da.sum_range(1, 2) == 7 assert da.sum_range(0, 1) == 3 def test_update_at_edges(): arr = [1, 3, 5] da = DynamicArray(arr) da.update(0, 10) assert da.sum_range(0, 2) == 18 # 10 + 3 + 5 da.update(2, -5) assert da.sum_range(0, 2) == 8 # 10 + 3 - 5 def test_sequential_updates(): arr = [1, 3, 5, 7, 9] da = DynamicArray(arr) da.update(1, 0) da.update(3, 6) da.update(4, 8) assert da.sum_range(0, 4) == 20 # 1 + 0 + 5 + 6 + 8 def test_large_array_operations(): arr = [i for i in range(10000)] da = DynamicArray(arr) assert da.sum_range(0, 9999) == sum(range(10000)) da.update(9999, 10000) assert da.sum_range(0, 9999) == sum(range(9999)) + 10000 import pytest if __name__ == '__main__': pytest.main()","solution":"from typing import List class DynamicArray: def __init__(self, arr: List[int]) -> None: Initializes the data structure with the given array of integers. self.arr = arr[:] self.prefix_sum = self._compute_prefix_sum() def _compute_prefix_sum(self) -> List[int]: Computes the prefix sum array for the current array. prefix_sum = [0] * (len(self.arr) + 1) for i in range(1, len(prefix_sum)): prefix_sum[i] = prefix_sum[i-1] + self.arr[i-1] return prefix_sum def update(self, index: int, value: int) -> None: Updates the element at position \`index\` in the array to \`value\`. # Update the array diff = value - self.arr[index] self.arr[index] = value # Update the prefix sum array from index+1 onwards for i in range(index + 1, len(self.prefix_sum)): self.prefix_sum[i] += diff def sum_range(self, left: int, right: int) -> int: Returns the sum of the elements within the range [left, right] (inclusive). return self.prefix_sum[right + 1] - self.prefix_sum[left]"},{"question":"def min_operations_to_make_subsequence(s1: str, s2: str) -> int: Determine the minimum number of operations required to make s1 a subsequence of s2. >>> min_operations_to_make_subsequence(\\"abc\\", \\"bahbgdc\\") 0 >>> min_operations_to_make_subsequence(\\"axc\\", \\"bahbgdc\\") 2 >>> min_operations_to_make_subsequence(\\"xyz\\", \\"abcdef\\") 3 >>> min_operations_to_make_subsequence(\\"\\", \\"bahbgdc\\") 0 >>> min_operations_to_make_subsequence(\\"abc\\", \\"\\") 3 >>> min_operations_to_make_subsequence(\\"abcdef\\", \\"abcdef\\") 0 >>> min_operations_to_make_subsequence(\\"a\\", \\"bbbbbaaaa\\") 0 >>> min_operations_to_make_subsequence(\\"z\\", \\"bbbbbaaaa\\") 1","solution":"def min_operations_to_make_subsequence(s1, s2): Determine the minimum number of operations required to make s1 a subsequence of s2. :param s1: String :param s2: String :return: Integer # Length of the input strings len_s1 = len(s1) len_s2 = len(s2) # Pointers for s1 and s2 i, j = 0, 0 # Iterate over s2 and try to match characters with s1 while i < len_s1 and j < len_s2: if s1[i] == s2[j]: # If characters match, move s1 pointer i += 1 # Always move s2 pointer j += 1 # If we have traversed all of s1, it's a subsequence if i == len_s1: return 0 else: # Number of unmatched characters in s1 return len_s1 - i"},{"question":"def format_math_expression(s: str) -> str: Formats the input mathematical string \`s\` so that each operator (\`+\`,\`-\`,\`*\`,\`/\`) is surrounded by exactly one space on both sides, with no leading or trailing spaces and no consecutive spaces. >>> format_math_expression(\\"3+ 5*2-4 /8\\") \\"3 + 5 * 2 - 4 / 8\\" >>> format_math_expression(\\"12*3 + 7- 5/ 4\\") \\"12 * 3 + 7 - 5 / 4\\" >>> format_math_expression(\\" 5/3*2+ 8 -7\\") \\"5 / 3 * 2 + 8 - 7\\" >>> format_math_expression(\\"3+5\\") \\"3 + 5\\" >>> format_math_expression(\\"123 * 456+789 / 10- 11\\") \\"123 * 456 + 789 / 10 - 11\\" >>> format_math_expression(\\"2+3*5-8/4\\") \\"2 + 3 * 5 - 8 / 4\\"","solution":"def format_math_expression(s): Formats the input mathematical string \`s\` so that each operator (\`+\`,\`-\`,\`*\`,\`/\`) is surrounded by exactly one space on both sides, with no leading or trailing spaces and no consecutive spaces. # Create a list of characters from the string because string is immutable and we # may need to insert spaces result = [] i = 0 while i < len(s): if s[i] in \\"+-*/\\": # Ensure there's exactly one space before the operator if result and result[-1] != ' ': result.append(' ') # Add the operator result.append(s[i]) # Ensure there's exactly one space after the operator if i + 1 < len(s) and s[i + 1] != ' ': result.append(' ') i += 1 else: # Add the current character if it's not an operator result.append(s[i]) i += 1 # Skip added spaces for multi-digit numbers/spaces right next to operators while i < len(s) and s[i] == ' ': i += 1 # Join the list back into a string and return it formatted_string = ''.join(result).strip() return formatted_string"},{"question":"class MysticalForest: def __init__(self, n, energies): Initialize the MysticalForest with the number of trees and their initial energies. Parameters: n (int): Number of trees. energies (List[int]): Initial energies of the trees. Example: >>> forest = MysticalForest(5, [2, 3, 4, 5, 6]) self.n = n self.energies = energies def update(self, i): Cast the transformation spell on tree i. Parameters: i (int): The tree index (1-based) to cast the spell on. Example: >>> forest = MysticalForest(5, [2, 3, 4, 5, 6]) >>> forest.update(3) >>> forest.energies [2, 2, 5, 4, 6] i -= 1 # 0-based index for internal list handling if 0 <= i < self.n: self._transform(i) if 0 <= i - 1 < self.n: self._transform(i - 1) if 0 <= i + 1 < self.n: self._transform(i + 1) def _transform(self, index): if self.energies[index] % 2 == 0: self.energies[index] += 1 else: self.energies[index] -= 1 def query(self, l, r): Calculate the sum of magical energies of trees from l to r inclusive. Parameters: l (int): The starting tree index (1-based). r (int): The ending tree index (1-based). Returns: int: Sum of energies from tree l to tree r inclusive. Example: >>> forest = MysticalForest(5, [2, 3, 4, 5, 6]) >>> forest.update(3) >>> forest.query(1, 5) 19 return sum(self.energies[l - 1: r]) def process_queries(n, initial_energies, queries): Process a list of queries on the mystical forest. Parameters: n (int): Number of trees. initial_energies (List[int]): Initial energies of the trees. queries (List[str]): List of queries to process. Returns: List[int]: Results of 'query' type queries. Example: >>> queries = [\\"update 3\\", \\"query 1 5\\", \\"update 1\\", \\"query 1 3\\", \\"query 2 4\\"] >>> process_queries(5, [2, 3, 4, 5, 6], queries) [19, 11, 12] mystical_forest = MysticalForest(n, initial_energies) results = [] for query in queries: command, *params = query.split() if command == \\"update\\": i = int(params[0]) mystical_forest.update(i) elif command == \\"query\\": l, r = map(int, params) results.append(mystical_forest.query(l, r)) return results","solution":"class MysticalForest: def __init__(self, n, energies): self.n = n self.energies = energies def update(self, i): i -= 1 # 0-based index for internal list handling if 0 <= i < self.n: self._transform(i) if 0 <= i - 1 < self.n: self._transform(i - 1) if 0 <= i + 1 < self.n: self._transform(i + 1) def _transform(self, index): if self.energies[index] % 2 == 0: self.energies[index] += 1 else: self.energies[index] -= 1 def query(self, l, r): return sum(self.energies[l - 1: r]) def process_queries(n, initial_energies, queries): mystical_forest = MysticalForest(n, initial_energies) results = [] for query in queries: command, *params = query.split() if command == \\"update\\": i = int(params[0]) mystical_forest.update(i) elif command == \\"query\\": l, r = map(int, params) results.append(mystical_forest.query(l, r)) return results"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},C={class:"card-container"},D={key:0,class:"empty-state"},z=["disabled"],P={key:0},I={key:1};function F(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",D,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",I,"Loading...")):(s(),n("span",P,"See more"))],8,z)):l("",!0)])}const M=m(E,[["render",F],["__scopeId","data-v-99466085"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/65.md","filePath":"guide/65.md"}'),Y={name:"guide/65.md"},G=Object.assign(Y,{setup(i){return(e,u)=>(s(),n("div",null,[w(M)]))}});export{B as __pageData,G as default};
