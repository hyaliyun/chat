import{_,o as r,c as s,a as t,m as c,t as u,C as h,M as g,U as b,f as d,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},A={class:"review-title"},L={class:"review-content"};function R(i,e,l,f,n,a){return r(),s("div",q,[t("div",T,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(u(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(u(l.poem.solution),1)])])])}const N=_(k,[["render",R],["__scopeId","data-v-1c81a16d"]]),E=JSON.parse(`[{"question":"def remove_duplicates(head): Remove duplicates from a sorted linked list. Args: head (ListNode): Head of the sorted linked list. Returns: ListNode: Head of the modified linked list with duplicates removed. current = head # Iterate through the list while current and current.next: if current.val == current.next.val: # Skip the next node because it's a duplicate current.next = current.next.next else: # Move to the next node current = current.next return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Remove duplicates from a sorted linked list. Args: head (ListNode): Head of the sorted linked list. Returns: ListNode: Head of the modified linked list with duplicates removed. current = head # Iterate through the list while current and current.next: if current.val == current.next.val: # Skip the next node because it's a duplicate current.next = current.next.next else: # Move to the next node current = current.next return head"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def detect_and_remove_cycle(head: ListNode) -> ListNode: Detects a cycle in a linked list and removes the node causing the cycle. Returns the head node of the modified list. Example: >>> head = ListNode(3) >>> head.next = ListNode(2) >>> head.next.next = ListNode(0) >>> head.next.next.next = ListNode(-4) >>> head.next.next.next.next = head.next >>> detect_and_remove_cycle(head) # Output: head -> 3 -> 2 -> 0 -> -4 >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = head >>> detect_and_remove_cycle(head) # Output: head -> 1 -> 2 >>> head = ListNode(1) >>> detect_and_remove_cycle(head) # Output: head -> 1","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detect_and_remove_cycle(head: ListNode) -> ListNode: if not head or not head.next: return head slow, fast = head, head cycle_detected = False # Detect cycle using Floyd's Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if not cycle_detected: return head # Find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # To remove the cycle, find the node just before the start of the cycle # and set its next to None iterator = slow while iterator.next != slow: iterator = iterator.next iterator.next = None return head"},{"question":"def sort_by_frequency(arr: list[int]) -> list[int]: Sort elements by frequency in descending order. Parameters ---------- arr: list of integers. A list containing integers. Returns ------- list of integers: A list of integers sorted based on the frequency of occurrence in descending order. If two elements have the same frequency, the one that appears first in the array should come first. pass # Test cases def test_empty_array(): assert sort_by_frequency([]) == [] def test_single_element_array(): assert sort_by_frequency([42]) == [42] def test_multiple_elements_with_same_frequency(): assert sort_by_frequency([4, 5, 6, 5, 4, 3]) == [4, 4, 5, 5, 6, 3] def test_frequency_and_order(): assert sort_by_frequency([1, 2, 3, 4, 4, 5, 5, 5]) == [5, 5, 5, 4, 4, 1, 2, 3] def test_negative_numbers(): assert sort_by_frequency([-1, -2, -1, -2, 3]) == [-1, -1, -2, -2, 3] def test_single_high_frequency_element(): assert sort_by_frequency([1, 1, 1, 1, 2, 3, 4]) == [1, 1, 1, 1, 2, 3, 4] def test_mixed_sign_numbers(): assert sort_by_frequency([1, -1, 1, -1, 2, 2, 2, 3, -1, -1]) == [-1, -1, -1, -1, 2, 2, 2, 1, 1, 3]","solution":"def sort_by_frequency(arr): Sort elements by frequency in descending order. Parameters ---------- arr: list of integers. A list containing integers. Returns ------- list of integers: A list of integers sorted based on the frequency of occurrence in descending order. If two elements have the same frequency, the one that appears first in the array should come first. from collections import Counter if not arr: return [] # Count frequency of each element freq = Counter(arr) # Sort based on frequency and first appearance in the array sorted_arr = sorted(arr, key=lambda x: (-freq[x], arr.index(x))) return sorted_arr"},{"question":"def is_point_in_circle(cx: int, cy: int, radius: int, px: int, py: int) -> bool: Check if the circle with center at (cx, cy) and radius \`radius\` contains the point (px, py). >>> is_point_in_circle(0, 0, 5, 3, 4) True >>> is_point_in_circle(0, 0, 5, 6, 8) False >>> is_point_in_circle(0, 0, 5, 5, 0) True >>> is_point_in_circle(10, 10, 5, 10, 10) True","solution":"def is_point_in_circle(cx: int, cy: int, radius: int, px: int, py: int) -> bool: Check if the circle with center at (cx, cy) and radius \`radius\` contains the point (px, py). # Calculate the squared distance between the center and the point dist_squared = (px - cx)**2 + (py - cy)**2 # Compare it to the squared radius to avoid floating-point arithmetic return dist_squared <= radius**2"},{"question":"from typing import List def are_anagrams(str1: str, str2: str) -> bool: Verifies whether two strings are anagrams of each other. Ignores case differences, spaces, and punctuation, considering only alphabetic characters. Ensures linear time complexity O(n) for efficiency. >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"conversation\\", \\"voices rant on\\") True >>> are_anagrams(\\"hello\\", \\"bye\\") False >>> are_anagrams(\\"The eyes\\", \\"They see\\") True >>> are_anagrams(\\"a!b@c#1\\", \\"c1@b!a\\") True","solution":"import re from collections import Counter def are_anagrams(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams, ignoring case, spaces, and punctuation. def preprocess(s: str) -> str: # Remove all non-alphabet characters and convert to lower case return ''.join(re.findall(r'[a-z]+', s.lower())) str1_processed = preprocess(str1) str2_processed = preprocess(str2) return Counter(str1_processed) == Counter(str2_processed)"},{"question":"from typing import List def transpose_and_sum(matrix: List[List[int]]) -> List[int]: Transposes the given mxn matrix and returns a list containing the sums of each row of the transposed matrix. >>> transpose_and_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [12, 15, 18] >>> transpose_and_sum([ ... [1, 2], ... [3, 4], ... [5, 6], ... [7, 8] ... ]) [16, 20]","solution":"from typing import List def transpose_and_sum(matrix: List[List[int]]) -> List[int]: Transposes the given mxn matrix and returns a list containing the sums of each row of the transposed matrix. if not matrix or not matrix[0]: return [] # Transpose the matrix transposed = list(zip(*matrix)) # Calculate the sum of each row in the transposed matrix result = [sum(row) for row in transposed] return result"},{"question":"def most_frequent_product(history: list[str]) -> str: Determine the most frequent product in the given browsing history. >>> most_frequent_product(['apple', 'banana', 'apple', 'apple', 'banana', 'carrot']) 'apple' >>> most_frequent_product(['watch', 'phone', 'laptop', 'tablet', 'phone', 'watch', 'watch']) 'watch' >>> most_frequent_product(['book', 'pen', 'pencil', 'book', 'pencil', 'book', 'pen']) 'book' >>> most_frequent_product(['shoes']) 'shoes'","solution":"def most_frequent_product(history): from collections import Counter # Count the frequency of each product product_counts = Counter(history) # Find the most common product most_common_product, _ = product_counts.most_common(1)[0] return most_common_product"},{"question":"from typing import List def min_cost_to_buy_items(prices: List[int], offers: List[List[int]], needs: List[int]) -> int: Determine the minimum total cost required to buy all the items on the list, making optimal use of the discount offers. Args: prices (List[int]): A list of integers where each integer prices[i] represents the price of the i-th item. offers (List[List[int]]): A list of lists where each sub-list represents a special offer. Each sub-list contains integers where the first n integers represent the quantity of each item in the offer, and the last integer represents the price of the bundled offer. needs (List[int]): A list of integers where each integer needs[i] represents the required quantity of the i-th item. Returns: int: The minimum total cost required to buy all the items. Example: >>> prices = [2, 5, 3] >>> offers = [[1, 1, 0, 5], [2, 2, 1, 12]] >>> needs = [3, 2, 1] >>> min_cost_to_buy_items(prices, offers, needs) 14","solution":"from typing import List def min_cost_to_buy_items(prices: List[int], offers: List[List[int]], needs: List[int]) -> int: def total_price(needs): return sum(needs[i] * prices[i] for i in range(len(needs))) def dfs(needs): cost = total_price(needs) for offer in offers: temp_needs = [needs[i] - offer[i] for i in range(len(needs))] if all(x >= 0 for x in temp_needs): cost = min(cost, offer[-1] + dfs(temp_needs)) return cost return dfs(needs)"},{"question":"from typing import List, Tuple def unique_elements_count(numbers: List[int]) -> List[Tuple[int, int]]: Identifies unique elements in a list of integers and returns their counts in the order they first appear. >>> unique_elements_count([4, 5, 6, 4, 5, 6, 7]) == [(4, 2), (5, 2), (6, 2), (7, 1)] >>> unique_elements_count([1, 1, 2, 2, 3, 3, 4, 4, 5]) == [(1, 2), (2, 2), (3, 2), (4, 2), (5, 1)] >>> unique_elements_count([]) == []","solution":"from typing import List, Tuple def unique_elements_count(numbers: List[int]) -> List[Tuple[int, int]]: element_count = {} order_of_first_appearance = [] for num in numbers: if num not in element_count: order_of_first_appearance.append(num) element_count[num] = element_count.get(num, 0) + 1 return [(num, element_count[num]) for num in order_of_first_appearance]"},{"question":"def find_and_replace_username(emails: list, old_username: str, new_username: str) -> list: Find and replace the username part of email addresses in a list with a new username while keeping the domain part unchanged. >>> find_and_replace_username([\\"alice@example.com\\", \\"bob@domain.com\\"], \\"alice\\", \\"charlie\\") ['charlie@example.com', 'bob@domain.com'] >>> find_and_replace_username([\\"john.doe@gmail.com\\", \\"jane.doe@outlook.com\\"], \\"john.doe\\", \\"john.smith\\") ['john.smith@gmail.com', 'jane.doe@outlook.com'] >>> find_and_replace_username([\\"foo@bar.com\\"], \\"foo\\", \\"baz\\") ['baz@bar.com'] >>> find_and_replace_username([\\"admin@company.com\\", \\"user@service.com\\"], \\"admin\\", \\"sysadmin\\") ['sysadmin@company.com', 'user@service.com']","solution":"def find_and_replace_username(emails: list, old_username: str, new_username: str) -> list: updated_emails = [] for email in emails: username, domain = email.split('@') if username == old_username: updated_emails.append(new_username + '@' + domain) else: updated_emails.append(email) return updated_emails"},{"question":"def edit_distance(str1: str, str2: str) -> int: Calculate the edit distance (Levenshtein distance) between two strings. The edit distance is the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform one string into the other. Args: str1 (str): First string. str2 (str): Second string. Returns: int: The edit distance between the two strings. Examples: >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> edit_distance(\\"\\", \\"abc\\") 3 >>> edit_distance(\\"abc\\", \\"abc\\") 0 pass def test_edit_distance_identical_strings(): assert edit_distance(\\"abc\\", \\"abc\\") == 0 def test_edit_distance_empty_and_non_empty_string(): assert edit_distance(\\"\\", \\"abc\\") == 3 assert edit_distance(\\"abc\\", \\"\\") == 3 def test_edit_distance_single_character(): assert edit_distance(\\"a\\", \\"a\\") == 0 assert edit_distance(\\"a\\", \\"b\\") == 1 assert edit_distance(\\"a\\", \\"\\") == 1 assert edit_distance(\\"\\", \\"a\\") == 1 def test_edit_distance_varied_length_strings(): assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance(\\"gumbo\\", \\"gambol\\") == 2 def test_edit_distance_different_strings(): assert edit_distance(\\"intention\\", \\"execution\\") == 5 assert edit_distance(\\"horse\\", \\"ros\\") == 3 assert edit_distance(\\"abcd\\", \\"efgh\\") == 4 def test_edit_distance_special_characters(): assert edit_distance(\\"abc\\", \\"abc#\\") == 1 assert edit_distance(\\" \\", \\" \\") == 1 def test_edit_distance_case_sensitivity(): assert edit_distance(\\"Case\\", \\"case\\") == 1 assert edit_distance(\\"CASE\\", \\"case\\") == 4","solution":"def edit_distance(str1: str, str2: str) -> int: n = len(str1) m = len(str2) # Create a 2D array to store the distance dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize the distances for converting empty string to a string for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[n][m]"},{"question":"import os from typing import List def hash_file(filepath: str) -> str: Generate MD5 hash for the content of the file. import hashlib hash_md5 = hashlib.md5() with open(filepath, \\"rb\\") as f: for chunk in iter(lambda: f.read(4096), b\\"\\"): hash_md5.update(chunk) return hash_md5.hexdigest() def find_duplicates(directory: str) -> List[List[str]]: Find duplicates in a specified directory based on file content. Args: directory: The path to the directory to be scanned for duplicates. Returns: A list of lists, where each sublist contains paths to files that are duplicates of each other. # Your implementation here pass def remove_duplicates(directory: str, retain: str) -> int: Remove duplicate files in a directory based on specified retain criterion. Args: directory: The path to the directory to be scanned for duplicates. retain: The criterion for retaining one of the duplicate files. Can be \\"largest\\", \\"smallest\\", \\"first\\", \\"last\\". Returns: The number of duplicate files removed. # Your implementation here pass # Example usage if __name__ == \\"__main__\\": directory = \\"/example-directory/\\" print(find_duplicates(directory)) print(remove_duplicates(directory, \\"first\\")) # Unit Tests import pytest import tempfile def create_test_file(path, content): with open(path, 'w') as f: f.write(content) @pytest.fixture def setup_filesystem(): with tempfile.TemporaryDirectory() as tmpdir: # Create files create_test_file(os.path.join(tmpdir, 'file1.txt'), 'content1') create_test_file(os.path.join(tmpdir, 'file2.txt'), 'content1') # duplicate of file1.txt create_test_file(os.path.join(tmpdir, 'file3.txt'), 'content2') subdir = os.path.join(tmpdir, 'subdir') os.makedirs(subdir) create_test_file(os.path.join(subdir, 'file4.txt'), 'content1') # duplicate of file1.txt create_test_file(os.path.join(subdir, 'file5.txt'), 'content3') yield tmpdir def test_find_duplicates(setup_filesystem): duplicates = find_duplicates(setup_filesystem) expected_duplicates = [ sorted([os.path.join(setup_filesystem, 'file1.txt'), os.path.join(setup_filesystem, 'file2.txt'), os.path.join(setup_filesystem, 'subdir/file4.txt')]) ] assert sorted([sorted(d) for d in duplicates]) == expected_duplicates def test_remove_duplicates_first(setup_filesystem): count = remove_duplicates(setup_filesystem, 'first') assert count == 2 assert find_duplicates(setup_filesystem) == [] def test_remove_duplicates_largest(setup_filesystem): count = remove_duplicates(setup_filesystem, 'largest') assert count == 2 assert find_duplicates(setup_filesystem) == [] def test_remove_duplicates_smallest(setup_filesystem): count = remove_duplicates(setup_filesystem, 'smallest') assert count == 2 assert find_duplicates(setup_filesystem) == [] def test_remove_duplicates_last(setup_filesystem): count = remove_duplicates(setup_filesystem, 'last') assert count == 2 assert find_duplicates(setup_filesystem) == []","solution":"import os import hashlib def hash_file(filepath): Generate MD5 hash for the content of the file. hash_md5 = hashlib.md5() with open(filepath, \\"rb\\") as f: for chunk in iter(lambda: f.read(4096), b\\"\\"): hash_md5.update(chunk) return hash_md5.hexdigest() def find_duplicates(directory): Find duplicates in a specified directory. file_hashes = {} for root, _, files in os.walk(directory): for file in files: filepath = os.path.join(root, file) file_hash = hash_file(filepath) if file_hash in file_hashes: file_hashes[file_hash].append(filepath) else: file_hashes[file_hash] = [filepath] duplicates = [paths for paths in file_hashes.values() if len(paths) > 1] return duplicates def remove_duplicates(directory, retain): Remove duplicates in a specified directory based on the retain criterion. duplicates = find_duplicates(directory) def get_file_size(filename): return os.path.getsize(filename) count = 0 for paths in duplicates: if retain == \\"largest\\": paths.sort(key=get_file_size, reverse=True) elif retain == \\"smallest\\": paths.sort(key=get_file_size) elif retain == \\"first\\": paths.sort() elif retain == \\"last\\": paths.sort(reverse=True) for filepath in paths[1:]: os.remove(filepath) count += 1 return count"},{"question":"def organize_library_inventory(books: list[dict[str, str | int]]) -> dict[str, list[str]]: Organizes the library inventory by authors and sorts their books in descending order of publication years. >>> organize_library_inventory([ ... {\\"title\\": \\"Book A1\\", \\"author\\": \\"Author A\\", \\"year\\": 2001}, ... {\\"title\\": \\"Book B1\\", \\"author\\": \\"Author B\\", \\"year\\": 1999}, ... {\\"title\\": \\"Book A2\\", \\"author\\": \\"Author A\\", \\"year\\": 2003}, ... {\\"title\\": \\"Book C1\\", \\"author\\": \\"Author C\\", \\"year\\": 2000}, ... ]) == { ... \\"Author A\\": [\\"Book A2\\", \\"Book A1\\"], ... \\"Author B\\": [\\"Book B1\\"], ... \\"Author C\\": [\\"Book C1\\"], ... } >>> organize_library_inventory([ ... {\\"title\\": \\"Book A1\\", \\"author\\": \\"Author A\\", \\"year\\": 2001} ... ]) == { ... \\"Author A\\": [\\"Book A1\\"] ... }","solution":"from collections import defaultdict def organize_library_inventory(books): Organizes the library inventory by authors and sorts their books in descending order of publication years. :param books: List of dictionaries with keys \\"title\\", \\"author\\", and \\"year\\" :return: Dictionary with authors as keys and lists of book titles as values authors_books = defaultdict(list) for book in books: author = book['author'] authors_books[author].append(book) sorted_authors_books = {} for author, books in authors_books.items(): sorted_books = sorted(books, key=lambda x: x['year'], reverse=True) sorted_titles = [book['title'] for book in sorted_books] sorted_authors_books[author] = sorted_titles return sorted_authors_books"},{"question":"def minesweeper_board(board: list[list[str]]) -> list[list[str]]: Generate the Minesweeper board with numbers indicating the count of mines surrounding each cell. Parameters: board (list[list[str]]): A 2D list representing the Minesweeper board where 'M' represents a mine and 'E' represents an empty cell. Returns: list[list[str]]: A Minesweeper board where each empty cell 'E' is replaced by a number indicating the count of mines in adjacent cells (including diagonals). Raises: ValueError: If the board is not valid (e.g., contains invalid characters or is not a proper 2D list) Examples: >>> input_board = [ ... ['E', 'E', 'E', 'E', 'E'], ... ['E', 'E', 'M', 'E', 'E'], ... ['E', 'E', 'E', 'E', 'E'], ... ['E', 'E', 'E', 'E', 'E']] >>> minesweeper_board(input_board) [['0', '1', '1', '1', '0'], ['0', '1', 'M', '1', '0'], ['0', '1', '1', '1', '0'], ['0', '0', '0', '0', '0']] >>> input_board = [ ... ['E', 'M', 'E'], ... ['E', 'E', 'E'], ... ['M', 'E', 'M']] >>> minesweeper_board(input_board) [['1', 'M', '1'], ['2', '3', '2'], ['M', '2', 'M']] pass","solution":"def minesweeper_board(board): if not board or not all(isinstance(row, list) for row in board): raise ValueError(\\"The board must be a 2D list.\\") rows = len(board) cols = len(board[0]) for row in board: if len(row) != cols or not all(cell in {'M', 'E'} for cell in row): raise ValueError(\\"The board must contain only 'M' and 'E' characters and be a uniform matrix.\\") # Directions to check for adjacent cells (including diagonals) directions = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] result_board = [['0' for _ in range(cols)] for _ in range(rows)] for r in range(rows): for c in range(cols): if board[r][c] == 'M': result_board[r][c] = 'M' else: mine_count = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] == 'M': mine_count += 1 result_board[r][c] = str(mine_count) return result_board"},{"question":"from typing import List def max_gold_coins(grid: List[List[int]]) -> int: Determine the maximum number of gold coins that can be collected if you start from the top-left cell and can only move right or down. >>> max_gold_coins([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_gold_coins([[1, 2, 5], [3, 2, 1]]) 9 >>> max_gold_coins([[0]]) 0 >>> max_gold_coins([]) Traceback (most recent call last): ... ValueError: Empty grid was passed to the function","solution":"from typing import List def max_gold_coins(grid: List[List[int]]) -> int: if not grid or not grid[0]: raise ValueError(\\"Empty grid was passed to the function\\") # Get the dimensions of the grid rows = len(grid) cols = len(grid[0]) # Create a DP table to store the maximum gold collected up to each cell dp = [[0] * cols for _ in range(rows)] # Initialize the first cell with its own value dp[0][0] = grid[0][0] # Fill the first row for col in range(1, cols): dp[0][col] = dp[0][col-1] + grid[0][col] # Fill the first column for row in range(1, rows): dp[row][0] = dp[row-1][0] + grid[row][0] # Fill the rest of the dp table for row in range(1, rows): for col in range(1, cols): dp[row][col] = max(dp[row-1][col], dp[row][col-1]) + grid[row][col] # The bottom-right cell will contain the max gold that can be collected return dp[rows-1][cols-1]"},{"question":"class BankAccountSystem: Bank Account Management System. This system allows users to create accounts, deposit money, withdraw money, check their balance, and transfer money between accounts. Example Usage: bank = BankAccountSystem() bank.create_account(1001, 500) bank.create_account(1002, 1000) bank.deposit(1001, 300) print(bank.check_balance(1001)) # Output: 800 bank.withdraw(1002, 200) print(bank.check_balance(1002)) # Output: 800 bank.transfer(1001, 1002, 100) print(bank.check_balance(1001)) # Output: 700 print(bank.check_balance(1002)) # Output: 900 def __init__(self): self.accounts = {} def create_account(self, account_number: int, initial_balance: int = 0): Create a new bank account with a unique account number and an initial balance. pass def deposit(self, account_number: int, amount: int): Deposit a specified amount of money into a bank account. pass def withdraw(self, account_number: int, amount: int): Withdraw a specified amount of money from a bank account. pass def check_balance(self, account_number: int) -> int: Check the current balance of a bank account. pass def transfer(self, from_account: int, to_account: int, amount: int): Transfer a specified amount of money from one bank account to another. pass # Unit Tests import pytest def test_create_account(): bank = BankAccountSystem() bank.create_account(1001, 500) assert bank.check_balance(1001) == 500 with pytest.raises(ValueError, match=\\"Account number already exists.\\"): bank.create_account(1001, 300) with pytest.raises(ValueError, match=\\"Initial balance cannot be negative.\\"): bank.create_account(1002, -100) def test_deposit(): bank = BankAccountSystem() bank.create_account(1001, 0) bank.deposit(1001, 300) assert bank.check_balance(1001) == 300 with pytest.raises(ValueError, match=\\"Account number does not exist.\\"): bank.deposit(1002, 100) with pytest.raises(ValueError, match=\\"Deposit amount cannot be negative.\\"): bank.deposit(1001, -50) def test_withdraw(): bank = BankAccountSystem() bank.create_account(1001, 500) bank.withdraw(1001, 200) assert bank.check_balance(1001) == 300 with pytest.raises(ValueError, match=\\"Account number does not exist.\\"): bank.withdraw(1002, 100) with pytest.raises(ValueError, match=\\"Withdrawal amount cannot be negative.\\"): bank.withdraw(1001, -50) with pytest.raises(ValueError, match=\\"Insufficient funds.\\"): bank.withdraw(1001, 500) def test_check_balance(): bank = BankAccountSystem() bank.create_account(1001, 700) assert bank.check_balance(1001) == 700 with pytest.raises(ValueError, match=\\"Account number does not exist.\\"): bank.check_balance(1002) def test_transfer(): bank = BankAccountSystem() bank.create_account(1001, 500) bank.create_account(1002, 1000) bank.transfer(1001, 1002, 200) assert bank.check_balance(1001) == 300 assert bank.check_balance(1002) == 1200 with pytest.raises(ValueError, match=\\"From account does not exist.\\"): bank.transfer(1003, 1002, 100) with pytest.raises(ValueError, match=\\"To account does not exist.\\"): bank.transfer(1001, 1003, 100) with pytest.raises(ValueError, match=\\"Transfer amount cannot be negative.\\"): bank.transfer(1001, 1002, -50) with pytest.raises(ValueError, match=\\"Insufficient funds in from account.\\"): bank.transfer(1001, 1002, 500)","solution":"class BankAccountSystem: def __init__(self): self.accounts = {} def create_account(self, account_number: int, initial_balance: int = 0): if account_number in self.accounts: raise ValueError(\\"Account number already exists.\\") if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative.\\") self.accounts[account_number] = initial_balance def deposit(self, account_number: int, amount: int): if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") if amount < 0: raise ValueError(\\"Deposit amount cannot be negative.\\") self.accounts[account_number] += amount def withdraw(self, account_number: int, amount: int): if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") if amount < 0: raise ValueError(\\"Withdrawal amount cannot be negative.\\") if self.accounts[account_number] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[account_number] -= amount def check_balance(self, account_number: int) -> int: if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") return self.accounts[account_number] def transfer(self, from_account: int, to_account: int, amount: int): if from_account not in self.accounts: raise ValueError(\\"From account does not exist.\\") if to_account not in self.accounts: raise ValueError(\\"To account does not exist.\\") if amount < 0: raise ValueError(\\"Transfer amount cannot be negative.\\") if self.accounts[from_account] < amount: raise ValueError(\\"Insufficient funds in from account.\\") self.accounts[from_account] -= amount self.accounts[to_account] += amount"},{"question":"def reverse_words(sentence: str) -> str: Reverse the order of words in a given sentence. >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"the quick brown fox\\") 'fox brown quick the' >>> reverse_words(\\"a b c d e\\") 'e d c b a' >>> reverse_words(\\"one\\") 'one' >>> reverse_words(\\"\\") '' >>> reverse_words(\\" hello world \\") 'world hello' pass","solution":"def reverse_words(sentence: str) -> str: Reverse the order of words in a given sentence. # Split the sentence into words words = sentence.strip().split() # Reverse the list of words words_reversed = words[::-1] # Join the reversed list of words into a string return ' '.join(words_reversed)"},{"question":"def is_custom_prime(number: int, divisors: list = None) -> bool: Checks if the given number is prime based on a customizable list of divisors. If no list is provided, it checks against all numbers up to the square root of the given number. Parameters: number (int): The number to be checked. divisors (list, optional): List of integer divisors to check against. Returns: bool: True if the number is prime under the given conditions, False otherwise. pass # Unit Test def test_is_custom_prime_traditional(): assert is_custom_prime(13) == True assert is_custom_prime(4) == False assert is_custom_prime(2) == True assert is_custom_prime(9) == False def test_is_custom_prime_with_custom_divisors(): assert is_custom_prime(15, [2, 3, 5]) == False assert is_custom_prime(11, [2, 3, 5]) == True assert is_custom_prime(17, [2, 3, 5, 7]) == True assert is_custom_prime(17, [2, 3, 17]) == False def test_is_custom_prime_edge_cases(): assert is_custom_prime(1) == False assert is_custom_prime(0) == False assert is_custom_prime(-5) == False # No negative number is prime assert is_custom_prime(17, []) == True assert is_custom_prime(17, None) == True assert is_custom_prime(9, [3, 5, 7]) == False def test_is_custom_prime_special_cases(): assert is_custom_prime(2, [2]) == False assert is_custom_prime(2, [3, 5, 7]) == True # Test running code if __name__ == \\"__main__\\": test_is_custom_prime_traditional() test_is_custom_prime_with_custom_divisors() test_is_custom_prime_edge_cases() test_is_custom_prime_special_cases() print(\\"All tests passed.\\")","solution":"def is_custom_prime(number: int, divisors: list = None) -> bool: Checks if the given number is prime based on a customizable list of divisors. If no list is provided, it checks against all numbers up to the square root of the given number. Parameters: number (int): The number to be checked. divisors (list, optional): List of integer divisors to check against. Returns: bool: True if the number is prime under the given conditions, False otherwise. if number <= 1: return False if divisors is None: if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number ** 0.5) + 1, 2): if number % i == 0: return False return True else: for divisor in divisors: if number % divisor == 0: return False return True"},{"question":"import math def factorial_digit_sum(n: int) -> int: Returns the sum of the digits of the factorial of n. :param n: Non-negative integer :return: Sum of digits of factorial of n :raises ValueError: If n is negative :raises TypeError: If n is not an integer >>> factorial_digit_sum(5) 3 >>> factorial_digit_sum(10) 27 def is_sum_of_factorial_digits(m: int) -> bool: Checks if m is equal to the sum of the digits of the factorial of some integer. :param m: Non-negative integer :return: True if m is equal to the sum of the digits of some factorial, otherwise False :raises ValueError: If m is negative :raises TypeError: If m is not an integer >>> is_sum_of_factorial_digits(27) True >>> is_sum_of_factorial_digits(100) False","solution":"import math def factorial_digit_sum(n: int) -> int: Returns the sum of the digits of the factorial of n. :param n: Non-negative integer :return: Sum of digits of factorial of n :raises ValueError: If n is negative :raises TypeError: If n is not an integer if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") factorial_result = math.factorial(n) digit_sum = sum(int(digit) for digit in str(factorial_result)) return digit_sum def is_sum_of_factorial_digits(m: int) -> bool: Checks if m is equal to the sum of the digits of the factorial of some integer. :param m: Non-negative integer :return: True if m is equal to the sum of the digits of some factorial, otherwise False :raises ValueError: If m is negative :raises TypeError: If m is not an integer if not isinstance(m, int): raise TypeError(\\"Input must be an integer.\\") if m < 0: raise ValueError(\\"Input must be a non-negative integer.\\") current_n = 0 while True: current_sum = factorial_digit_sum(current_n) if current_sum == m: return True elif current_sum > m: return False current_n += 1"},{"question":"from typing import List, Tuple def shortest_path(num_islands: int, bridges: List[Tuple[int, int, int]], start: int, end: int) -> int: Calculate the shortest path between two islands. >>> shortest_path(5, [(1, 2, 2), (1, 3, 4), (3, 4, 1), (2, 4, 7)], 1, 4) 5 >>> shortest_path(3, [(1, 2, 1), (2, 3, 2)], 1, 3) 3 >>> shortest_path(4, [(1, 2, 5), (2, 3, 10)], 1, 4) -1","solution":"import heapq from typing import List, Tuple def shortest_path(num_islands: int, bridges: List[Tuple[int, int, int]], start: int, end: int) -> int: # Create adjacency list for the graph graph = {i: [] for i in range(1, num_islands + 1)} for a, b, c in bridges: graph[a].append((b, c)) graph[b].append((a, c)) # Dijkstra's algorithm initialization distance = {i: float('inf') for i in range(1, num_islands + 1)} distance[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reached the end node, return the shortest distance if current_node == end: return current_distance # If we found a shorter path to the current node, process it if current_distance <= distance[current_node]: for neighbor, weight in graph[current_node]: distance_through_current = current_distance + weight # Only consider this new path if it's better if distance_through_current < distance[neighbor]: distance[neighbor] = distance_through_current heapq.heappush(priority_queue, (distance_through_current, neighbor)) # If the end node is unreachable return -1 if distance[end] == float('inf') else distance[end]"},{"question":"import numpy as np def calculate_determinant(matrix: np.ndarray) -> float: Returns the determinant of the given square matrix. Parameters: matrix (np.ndarray): A square matrix. Returns: float: The determinant of the matrix. >>> B = np.array([[1, 2], [3, 4]]) >>> np.isclose(calculate_determinant(B), -2.0000000000000004) True >>> C = np.array([[2, 0], [0, 2]]) >>> np.isclose(calculate_determinant(C), 4.0) True >>> D = np.array([[0, 0], [0, 0]]) >>> np.isclose(calculate_determinant(D), 0.0) True >>> E = np.array([[1]]) >>> np.isclose(calculate_determinant(E), 1.0) True pass def is_eigenvalue(matrix: np.ndarray, value: float) -> bool: Checks if the given value is an eigenvalue of the square matrix. Parameters: matrix (np.ndarray): A square matrix. value (float): A potential eigenvalue. Returns: bool: True if the value is an eigenvalue of the matrix, False otherwise. >>> B = np.array([[1, 2], [3, 4]]) >>> is_eigenvalue(B, -0.3722813232690143) True >>> is_eigenvalue(B, 5.372281323269014) True >>> is_eigenvalue(B, 0) False >>> C = np.array([[3, 2], [2, 3]]) >>> is_eigenvalue(C, 5) True >>> is_eigenvalue(C, 1) True >>> is_eigenvalue(C, -1) False pass","solution":"import numpy as np def calculate_determinant(matrix: np.ndarray) -> float: Returns the determinant of the given square matrix. Parameters: matrix (np.ndarray): A square matrix. Returns: float: The determinant of the matrix. if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The input must be a square matrix.\\") return np.linalg.det(matrix) def is_eigenvalue(matrix: np.ndarray, value: float) -> bool: Checks if the given value is an eigenvalue of the square matrix. Parameters: matrix (np.ndarray): A square matrix. value (float): A potential eigenvalue. Returns: bool: True if the value is an eigenvalue of the matrix, False otherwise. if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The input must be a square matrix.\\") eigenvalues = np.linalg.eigvals(matrix) return np.isclose(eigenvalues, value).any()"},{"question":"def normalize_path(path: str) -> str: Normalize the given Unix-like file path. >>> normalize_path(\\"/home/./user/../documents//file.txt\\") '/home/documents/file.txt' >>> normalize_path(\\"user/../user2/./documents/file.txt\\") 'user2/documents/file.txt' >>> normalize_path(\\"/var//log/././../tmp/\\") '/var/tmp' >>> normalize_path(\\"images/cat/../../videos/dog\\") 'videos/dog'","solution":"def normalize_path(path: str) -> str: Normalize the given Unix-like file path. if not path: return \\"\\" parts = path.split(\\"/\\") stack = [] for part in parts: if part == \\"..\\": if stack and stack[-1] != \\"\\": stack.pop() elif part == \\".\\" or part == \\"\\": continue else: stack.append(part) normalized_path = \\"/\\" + \\"/\\".join(stack) if path.startswith(\\"/\\") else \\"/\\".join(stack) return \\"/\\" if normalized_path == \\"\\" else normalized_path"},{"question":"def count_unique_words(text: str) -> int: Returns the number of unique words in the given text. Words are considered case-insensitive and punctuations are ignored. >>> count_unique_words(\\"Hello, world!! HELLO... World??\\") 2 >>> count_unique_words(\\"\\") 0 >>> count_unique_words(\\"A a A a B b B b\\") 2 >>> count_unique_words(\\"Cat, cat. Dog.. dog?? Elephant!\\") 3 >>> count_unique_words(\\"123 456 789\\") 0 >>> count_unique_words(\\"a \\" * 1000000 + \\"b\\") 2","solution":"import re def count_unique_words(text: str) -> int: Returns the number of unique words in the given text. Words are considered case-insensitive and punctuations are ignored. # Normalize case to lowercase text = text.lower() # Remove punctuation and split into words words = re.findall(r'b[a-z]+b', text) # Use a set to track unique words unique_words = set(words) return len(unique_words)"},{"question":"def sum_main_diagonal_iterative(matrix: list[list[int]]) -> int: Calculate the sum of the main diagonal elements iteratively. >>> sum_main_diagonal_iterative([[1, 2], [3, 4]]) 5 >>> sum_main_diagonal_iterative([[5, 0, 0], [0, 5, 0], [0, 0, 5]]) 15 >>> sum_main_diagonal_iterative([[7]]) 7 >>> sum_main_diagonal_iterative([[1, 2, 3], [4, 5], [6, 7, 8]]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty and square >>> sum_main_diagonal_iterative([]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty and square def sum_main_diagonal_recursive(matrix: list[list[int]], i: int = 0) -> int: Calculate the sum of the main diagonal elements recursively. >>> sum_main_diagonal_recursive([[1, 2], [3, 4]]) 5 >>> sum_main_diagonal_recursive([[5, 0, 0], [0, 5, 0], [0, 0, 5]]) 15 >>> sum_main_diagonal_recursive([[7]]) 7 >>> sum_main_diagonal_recursive([[1, 2, 3], [4, 5], [6, 7, 8]]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty and square >>> sum_main_diagonal_recursive([]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty and square","solution":"def sum_main_diagonal_iterative(matrix): if not matrix or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Matrix must be non-empty and square\\") size = len(matrix) diagonal_sum = 0 for i in range(size): diagonal_sum += matrix[i][i] return diagonal_sum def sum_main_diagonal_recursive(matrix, i=0): if not matrix or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Matrix must be non-empty and square\\") if i == len(matrix): return 0 return matrix[i][i] + sum_main_diagonal_recursive(matrix, i + 1)"},{"question":"class CustomStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] self.max_stack = [] def push(self, x: int) -> None: Push element x onto stack. pass def pop(self) -> int: Removes the element on the top of the stack and returns that element. pass def peek(self) -> int: Get the top element. pass def get_min(self) -> int: Retrieve the minimum element in the stack. pass def get_max(self) -> int: Retrieve the maximum element in the stack. pass # Unit Test def test_custom_stack_operations(): stack = CustomStack() # Initial state tests try: stack.pop() assert False, \\"Expected IndexError for pop on empty stack\\" except IndexError: pass try: stack.peek() assert False, \\"Expected IndexError for peek on empty stack\\" except IndexError: pass try: stack.get_min() assert False, \\"Expected IndexError for get_min on empty stack\\" except IndexError: pass try: stack.get_max() assert False, \\"Expected IndexError for get_max on empty stack\\" except IndexError: pass # Push elements and test min/max/peek stack.push(3) assert stack.peek() == 3 assert stack.get_min() == 3 assert stack.get_max() == 3 stack.push(5) assert stack.peek() == 5 assert stack.get_min() == 3 assert stack.get_max() == 5 stack.push(2) stack.push(1) assert stack.peek() == 1 assert stack.get_min() == 1 assert stack.get_max() == 5 assert stack.pop() == 1 assert stack.peek() == 2 assert stack.get_min() == 2 assert stack.get_max() == 5 assert stack.pop() == 2 assert stack.peek() == 5 assert stack.get_min() == 3 assert stack.get_max() == 5 assert stack.pop() == 5 assert stack.peek() == 3 assert stack.get_min() == 3 assert stack.get_max() == 3 assert stack.pop() == 3 # Stack empty again try: stack.peek() assert False, \\"Expected IndexError for peek on empty stack\\" except IndexError: pass try: stack.get_min() assert False, \\"Expected IndexError for get_min on empty stack\\" except IndexError: pass try: stack.get_max() assert False, \\"Expected IndexError for get_max on empty stack\\" except IndexError: pass","solution":"class CustomStack: def __init__(self): self.stack = [] self.min_stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) # Maintain the min_stack if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) # Maintain the max_stack if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() if top == self.max_stack[-1]: self.max_stack.pop() return top def peek(self) -> int: if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"min from empty stack\\") return self.min_stack[-1] def get_max(self) -> int: if not self.max_stack: raise IndexError(\\"max from empty stack\\") return self.max_stack[-1]"},{"question":"from typing import List def get_top_selling_books(book_list: List[str], top_n: int) -> List[str]: Process a list of book information strings, extracts the details, and returns a list of the top N bestselling books sorted by their sales numbers in descending order. >>> get_top_selling_books([ ... \\"The Great Gatsby by F. Scott Fitzgerald - Sales: 5000000\\", ... \\"Pride and Prejudice by Jane Austen - Sales: 2000000\\", ... \\"To Kill a Mockingbird by Harper Lee - Sales: 3000000\\", ... \\"1984 by George Orwell - Sales: 2500000\\", ... \\"The Catcher in the Rye by J.D. Salinger - Sales: 2750000\\" ... ], 3) [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"] >>> get_top_selling_books([ ... \\"Moby Dick by Herman Melville - Sales: 1500000\\", ... \\"War and Peace by Leo Tolstoy - Sales: 1000000\\", ... \\"The Odyssey by Homer - Sales: 1250000\\" ... ], 2) [\\"Moby Dick\\", \\"The Odyssey\\"] >>> get_top_selling_books([ ... \\"Don Quixote by Miguel de Cervantes - Sales: 5000000\\", ... \\"Ulysses by James Joyce - Sales: 5000000\\", ... \\"One Hundred Years of Solitude by Gabriel Garcia Marquez - Sales: 4700000\\" ... ], 2) [\\"Don Quixote\\", \\"Ulysses\\"]","solution":"from typing import List def get_top_selling_books(book_list: List[str], top_n: int) -> List[str]: if not isinstance(book_list, list): raise ValueError(\\"The book_list must be a list.\\") book_details = [] for book in book_list: if not isinstance(book, str): raise ValueError(\\"Each element in book_list must be a string.\\") parts = book.split(' - Sales: ') if len(parts) != 2 or not parts[1].isdigit(): raise ValueError(\\"Each book detail string must be properly formatted as 'Title by Author - Sales: X'.\\") title_and_author = parts[0] sales = int(parts[1]) book_details.append((sales, title_and_author.split(' by ')[0])) book_details.sort(reverse=True, key=lambda x: x[0]) return [title for _, title in book_details[:top_n]]"},{"question":"import heapq def shortest_path_length(graph: list[list[float]], start_node: int, end_node: int) -> float: Finds the shortest path length between start_node and end_node using Dijkstra's algorithm. Parameters: graph (list[list[float]]): A 2D list representing the weighted adjacency matrix of the graph. start_node (int): The starting node index. end_node (int): The ending node index. Returns: float: The shortest path length from start_node to end_node. If no path exists, return float('inf'). Example: >>> graph = [ ... [0, 3, float('inf'), 7], ... [8, 0, 2, float('inf')], ... [5, float('inf'), 0, 1], ... [2, float('inf'), float('inf'), 0] ... ] >>> shortest_path_length(graph, 0, 2) 5.0 >>> shortest_path_length(graph, 0, 3) 6.0","solution":"import heapq def shortest_path_length(graph, start_node, end_node): Finds the shortest path length between start_node and end_node using Dijkstra's algorithm. Parameters: graph (list[list[float]]): A 2D list representing the weighted adjacency matrix of the graph. start_node (int): The starting node index. end_node (int): The ending node index. Returns: float: The shortest path length from start_node to end_node. If no path exists, return float('inf'). n = len(graph) distances = [float('inf')] * n distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in enumerate(graph[current_node]): if weight != float('inf'): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end_node]"},{"question":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculates the great-circle distance between two points on Earth's surface given their latitude and longitude in decimal degrees. Parameters: lat1 (float): Latitude of the first point. lon1 (float): Longitude of the first point. lat2 (float): Latitude of the second point. lon2 (float): Longitude of the second point. Returns: float: Great-circle distance in kilometers. Examples: >>> great_circle_distance(51.5074, -0.1278, 40.7128, -74.0060) 5570 >>> great_circle_distance(34.0522, -118.2437, 35.6895, 139.6917) 8815 >>> great_circle_distance(48.8566, 2.3522, -33.8688, 151.2093) 16960 >>> great_circle_distance(0, 0, -10, 10) 1569 >>> great_circle_distance(90, 0, 0, 0) 10007 # Convert decimal degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) distance = 6371 * c # Earth's radius in kilometers return distance","solution":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculates the great-circle distance between two points on Earth in kilometers. Parameters: lat1 (float): Latitude of the first point. lon1 (float): Longitude of the first point. lat2 (float): Latitude of the second point. lon2 (float): Longitude of the second point. Returns: float: Great-circle distance in kilometers. # Earth's radius in kilometers R = 6371 # Convert decimal degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) distance = R * c # Distance in kilometers return distance"},{"question":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using dynamic programming. Args: n : int : The position in the Fibonacci sequence. Returns: int : The n-th Fibonacci number. Raises: TypeError : If n is not an integer. ValueError : If n is a negative integer. >>> fibonacci(10) 55 >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(20) 6765 >>> fibonacci(\\"ten\\") Traceback (most recent call last): ... TypeError: Undefined for non-integers >>> fibonacci(-3) Traceback (most recent call last): ... ValueError: Undefined for negative numbers","solution":"def fibonacci(n): Returns the n-th Fibonacci number. Args: n : int : The position in the Fibonacci sequence. Returns: int : The n-th Fibonacci number. Raises: TypeError : If n is not an integer. ValueError : If n is a negative integer. if not isinstance(n, int): raise TypeError(\\"Undefined for non-integers\\") if n < 0: raise ValueError(\\"Undefined for negative numbers\\") if n == 0: return 0 if n == 1: return 1 fib = [0, 1] for i in range(2, n + 1): fib.append(fib[-1] + fib[-2]) return fib[n]"},{"question":"def calculate_expression(s: str) -> int: Evaluates a numeric expression containing digits and the operators + and -. >>> calculate_expression(\\"3+5-2+8\\") 14 >>> calculate_expression(\\"10 + 22 - 5\\") 27 >>> calculate_expression(\\"10-2-3\\") 5 >>> calculate_expression(\\"0 - 1 + 1\\") 0 >>> calculate_expression(\\"54\\") 54","solution":"def calculate_expression(s: str) -> int: Evaluates a numeric expression containing digits and the operators + and -. s = s.replace(' ', '') # remove all spaces total = 0 num = 0 sign = 1 # 1 means positive, -1 means negative for char in s: if char.isdigit(): num = num * 10 + int(char) # to handle multi-digit numbers else: total += sign * num num = 0 sign = 1 if char == '+' else -1 total += sign * num # adding the last number return total"},{"question":"def caesar_cipher(text: str, key: int, direction: str) -> str: Encrypts or decrypts text using the Caesar cipher technique. Arguments: text (str): The input text to be processed. key (int): The shift key. direction (str): The shift direction, either \\"left\\" or \\"right\\". Returns: str: The resulting text after applying the Caesar cipher. >>> caesar_cipher(\\"Hello, World!\\", 3, \\"right\\") \\"Khoor, Zruog!\\" >>> caesar_cipher(\\"Khoor, Zruog!\\", 3, \\"left\\") \\"Hello, World!\\" >>> caesar_cipher(\\"abcXYZ\\", 1, \\"right\\") \\"bcdYZA\\" >>> caesar_cipher(\\"bcdYZA\\", 1, \\"left\\") \\"abcXYZ\\"","solution":"def caesar_cipher(text: str, key: int, direction: str) -> str: Encrypts or decrypts text using the Caesar cipher technique. Arguments: text (str): The input text to be processed. key (int): The shift key. direction (str): The shift direction, either \\"left\\" or \\"right\\". Returns: str: The resulting text after applying the Caesar cipher. result = [] if direction == \\"left\\": key = -key for char in text: if char.isalpha(): shift = key % 26 if char.islower(): result.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a'))) elif char.isupper(): result.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A'))) else: result.append(char) return ''.join(result)"},{"question":"class MatrixTraversal: def dfs(self, matrix: list[list[int]], x: int, y: int, visited: set[tuple[int, int]]) -> int: Perform a DFS traversal starting from a given cell and marks all connected \`1\`s as visited. If the starting cell is not a \`1\`, return without marking any cells. Args: matrix: 2D list of integers x: Row index to start the DFS y: Column index to start the DFS visited: Set of visited cells (tuple of row, column) Returns: int: The size of the connected component starting from the given cell pass def largest_component(self, matrix: list[list[int]]) -> int: Find the largest connected component (i.e., the largest island of \`1\`s). Args: matrix: 2D list of integers Returns: int: The size of the largest connected component of \`1\`s Examples: >>> matrix = [ ... [1, 1, 0, 1], ... [0, 1, 1, 0], ... [1, 0, 0, 1], ... [0, 1, 1, 1] ... ] >>> traversal = MatrixTraversal() >>> traversal.largest_component(matrix) 5 pass # Unit tests def test_single_cell_island(): matrix = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] traversal = MatrixTraversal() assert traversal.largest_component(matrix) == 1 def test_multiple_islands(): matrix = [ [1, 0, 0], [0, 1, 1], [0, 0, 1] ] traversal = MatrixTraversal() assert traversal.largest_component(matrix) == 3 def test_no_islands(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] traversal = MatrixTraversal() assert traversal.largest_component(matrix) == 0 def test_entire_matrix_island(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] traversal = MatrixTraversal() assert traversal.largest_component(matrix) == 9 def test_non_square_matrix(): matrix = [ [1, 0], [1, 1] ] traversal = MatrixTraversal() assert traversal.largest_component(matrix) == 3 def test_islands_with_multiple_components(): matrix = [ [1, 1, 0, 0, 0], [0, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1] ] traversal = MatrixTraversal() assert traversal.largest_component(matrix) == 3 def test_islands_with_diagonal_connections(): matrix = [ [1, 0, 0, 1], [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1] ] traversal = MatrixTraversal() assert traversal.largest_component(matrix) == 3","solution":"class MatrixTraversal: def dfs(self, matrix: list[list[int]], x: int, y: int, visited: set[tuple[int, int]]) -> int: if (x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or matrix[x][y] == 0 or (x, y) in visited): return 0 # Mark the cell as visited visited.add((x, y)) # Count the current cell size = 1 # Visit all 4 adjacent cells size += self.dfs(matrix, x + 1, y, visited) size += self.dfs(matrix, x - 1, y, visited) size += self.dfs(matrix, x, y + 1, visited) size += self.dfs(matrix, x, y - 1, visited) return size def largest_component(self, matrix: list[list[int]]) -> int: visited = set() max_size = 0 for x in range(len(matrix)): for y in range(len(matrix[0])): if matrix[x][y] == 1 and (x, y) not in visited: component_size = self.dfs(matrix, x, y, visited) max_size = max(max_size, component_size) return max_size # Example of how to use: matrix = [ [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 1, 1] ] traversal = MatrixTraversal() print(traversal.largest_component(matrix)) # Output: 5"},{"question":"def square_evens(arr: List[int]) -> List[int]: Squares the even numbers in the given list. :param arr: Input list of integers. :return: List of integers where every even number is squared. return [x**2 if x % 2 == 0 else x for x in arr]","solution":"from typing import List def square_evens(arr: List[int]) -> List[int]: Squares the even numbers in the given list. :param arr: Input list of integers. :return: List of integers where every even number is squared. return [x**2 if x % 2 == 0 else x for x in arr]"},{"question":"def classify_tshirt_size(chest: float, length: float) -> str: Classify the size of a t-shirt based on its chest and length measurements. T-Shirt Size Classification: - 'XS': Chest 78 - 82 cm, Length 58 - 62 cm - 'S': Chest 83 - 87 cm, Length 63 - 67 cm - 'M': Chest 88 - 92 cm, Length 68 - 72 cm - 'L': Chest 93 - 97 cm, Length 73 - 77 cm - 'XL': Chest 98 - 102 cm, Length 78 - 82 cm - 'XXL': Chest 103 - 107 cm, Length 83 - 87 cm Args: chest (float): The chest measurement of the t-shirt in centimeters (cm). length (float): The length measurement of the t-shirt in centimeters (cm). Returns: str: The size of the t-shirt. If the measurements do not fall within any of the given size ranges, return \\"Size not available\\". Raises: ValueError: If the chest or length measurement is not positive. >>> classify_tshirt_size(79, 60) 'XS' >>> classify_tshirt_size(84, 65) 'S' >>> classify_tshirt_size(89, 70) 'M' >>> classify_tshirt_size(95, 75) 'L' >>> classify_tshirt_size(100, 80) 'XL' >>> classify_tshirt_size(105, 85) 'XXL' >>> classify_tshirt_size(110, 90) 'Size not available' >>> classify_tshirt_size(77, 60) 'Size not available' >>> classify_tshirt_size(84, -5) Traceback (most recent call last): ... ValueError: Length measurement must be positive","solution":"def classify_tshirt_size(chest: float, length: float) -> str: if chest <= 0: raise ValueError(\\"Chest measurement must be positive\\") if length <= 0: raise ValueError(\\"Length measurement must be positive\\") size_chart = [ (\\"XS\\", 78, 82, 58, 62), (\\"S\\", 83, 87, 63, 67), (\\"M\\", 88, 92, 68, 72), (\\"L\\", 93, 97, 73, 77), (\\"XL\\", 98, 102, 78, 82), (\\"XXL\\", 103, 107, 83, 87), ] for size, chest_min, chest_max, length_min, length_max in size_chart: if chest_min <= chest <= chest_max and length_min <= length <= length_max: return size return \\"Size not available\\""},{"question":"from typing import List def find_pattern_indices(text: str, pattern: str) -> List[int]: Returns a list of all starting indices where the pattern is found in the text. Parameters: text (str): The text string to search within. pattern (str): The pattern string to search for. Returns: List[int]: A list of starting indices (0-based) where the pattern occurs in the text. Examples: >>> find_pattern_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_pattern_indices(\\"banana\\", \\"ana\\") [1, 3] >>> find_pattern_indices(\\"hello world\\", \\"world\\") [6] >>> find_pattern_indices(\\"aaaaaa\\", \\"aaa\\") [0, 1, 2, 3]","solution":"from typing import List def compute_prefix_function(pattern: str) -> List[int]: Preprocesses the pattern string and returns the prefix table used in the KMP algorithm. m = len(pattern) prefix_table = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j else: prefix_table[i] = 0 return prefix_table def find_pattern_indices(text: str, pattern: str) -> List[int]: Returns a list of all starting indices where the pattern is found in the text. n = len(text) m = len(pattern) if m == 0: # If the pattern is empty, we return an empty list. return [] prefix_table = compute_prefix_function(pattern) indices = [] j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = prefix_table[j - 1] if text[i] == pattern[j]: j += 1 if j == m: indices.append(i - m + 1) j = prefix_table[j - 1] return indices"},{"question":"def unique_sum(lst: list[int]) -> int: Calculates the sum of the unique elements in an input list. Elements are considered unique if they appear exactly once in the list. >>> unique_sum([2, 3, 2, 4, 5]) 12 >>> unique_sum([1, 2, 2, 1, 3, 4]) 7 >>> unique_sum([5, 5, 5, 5, 5]) 0 >>> unique_sum([]) 0","solution":"def unique_sum(lst: list[int]) -> int: from collections import Counter if not lst: return 0 element_count = Counter(lst) unique_elements_sum = sum(element for element, count in element_count.items() if count == 1) return unique_elements_sum"},{"question":"def evaluate_expression(expression: str) -> int: Parse and evaluate mathematical expressions containing addition and multiplication operators. >>> evaluate_expression(\\"1 + 1\\") 2 >>> evaluate_expression(\\"2 * 3\\") 6 >>> evaluate_expression(\\"2 + 3 * 4\\") 20 >>> evaluate_expression(\\"7 * 2 + 3 + 4\\") 21 >>> evaluate_expression(\\"1 + 2 + 3 + 4\\") 10 >>> evaluate_expression(\\"1 * 2 * 3 * 4\\") 24 >>> evaluate_expression(\\"3 + 5 * 2\\") 16","solution":"def evaluate_expression(expression: str) -> int: tokens = expression.split() result = int(tokens[0]) i = 1 while i < len(tokens): operator = tokens[i] operand = int(tokens[i+1]) if operator == '+': result += operand elif operator == '*': result *= operand i += 2 return result"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Parameters: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Parameters: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed linked list. previous = None current = head while current is not None: next_node = current.next # save the next node current.next = previous # reverse the link previous = current # move previous one step forward current = next_node # move current one step forward return previous"},{"question":"# Programming Assessment Question **Context**: You are developing an application that processes sequences of numbers. Part of your task is to identify the contiguous subarray within a one-dimensional list of numbers which has the largest sum. **Task**: Implement a function \`max_subarray_sum()\` that finds the maximum sum of any contiguous subarray within the given list of integers. Function Signature: def max_subarray_sum(nums: list[int]) -> int: pass Input: * \`nums\`: List of integers. Output: * Integer, representing the maximum sum of any contiguous subarray. Constraints: * The input list \`nums\` will contain at most 1,000,000 integers. * Each integer in the list will be between \`-10^7\` and \`10^7\`. Requirements: * Use an efficient algorithm to determine the maximum sum of the subarray. * Ensure the solution runs in linear time, O(n). Example: def test_max_subarray_sum_normal_case(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 # [4, -1, 2, 1] def test_max_subarray_sum_single_element(): assert max_subarray_sum([1]) == 1 def test_max_subarray_sum_all_negative(): assert max_subarray_sum([-1, -2, -3, -4]) == -1 # Single element subarray with largest value def test_max_subarray_sum_empty(): assert max_subarray_sum([]) == 0 # Edge case, empty array, sum is 0 def test_max_subarray_sum_mixed_numbers(): assert max_subarray_sum([3, -2, 5, -1]) == 6 # [3, -2, 5] def test_max_subarray_sum_all_positive(): assert max_subarray_sum([1, 2, 3, 4]) == 10 # Sum of entire array def test_max_subarray_sum_large_input(): large_input = [1] * 1000000 # 1,000,000 elements all being 1 assert max_subarray_sum(large_input) == 1000000 # Sum of entire array","solution":"def max_subarray_sum(nums: list[int]) -> int: Finds the maximum sum of any contiguous subarray within the given list of integers. Parameters: nums (list[int]): List of integers. Returns: int: The maximum sum of any contiguous subarray. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def is_rotation(s: str, goal: str) -> bool: Returns True if the string s can become the string goal after some number of left shifts, otherwise False. >>> is_rotation(\\"abcde\\", \\"cdeab\\") True >>> is_rotation(\\"abcde\\", \\"abced\\") False >>> is_rotation(\\"aaaaa\\", \\"aaaaa\\") True","solution":"def is_rotation(s: str, goal: str) -> bool: Returns True if the string s can become the string goal after some number of left shifts, otherwise False. # Concatenate s with itself to cover all rotation cases concatenated_s = s + s # Check if goal is a substring of the concatenated result return len(s) == len(goal) and goal in concatenated_s"},{"question":"[Completion Task in Python] def advance_sequence(buffer: list[int], start_idx: int, steps: int) -> int: Advances the start index in the buffer by a given number of steps, wrapping around if necessary. Parameters: buffer (list of int): The circular buffer represented as a list of integers. start_idx (int): The start index. steps (int): The number of steps to advance. Returns: int: The new index after advancing. buffer_length = len(buffer) return (start_idx + steps) % buffer_length def get_subsequence(buffer: list[int], start_idx: int, length: int) -> list[int]: Extracts a subsequence from the buffer starting from a given index and having a specified length, wrapping around if necessary. Parameters: buffer (list of int): The circular buffer represented as a list of integers. start_idx (int): The start index. length (int): The desired length of the subsequence. Returns: list of int: The extracted subsequence. buffer_length = len(buffer) subsequence = [] for i in range(length): subsequence.append(buffer[(start_idx + i) % buffer_length]) return subsequence","solution":"def advance_sequence(buffer, start_idx, steps): Advances the start index in the buffer by a given number of steps, wrapping around if necessary. Parameters: buffer (list of int): The circular buffer represented as a list of integers. start_idx (int): The start index. steps (int): The number of steps to advance. Returns: int: The new index after advancing. buffer_length = len(buffer) return (start_idx + steps) % buffer_length def get_subsequence(buffer, start_idx, length): Extracts a subsequence from the buffer starting from a given index and having a specified length, wrapping around if necessary. Parameters: buffer (list of int): The circular buffer represented as a list of integers. start_idx (int): The start index. length (int): The desired length of the subsequence. Returns: list of int: The extracted subsequence. buffer_length = len(buffer) subsequence = [] for i in range(length): subsequence.append(buffer[(start_idx + i) % buffer_length]) return subsequence"},{"question":"from typing import Any def get_order_details(db_conn: Any, order_id: int) -> dict: Fetches order details from the database for the given order_id. Parameters: db_conn (Any): A database connection object. order_id (int): The ID of the order to fetch details for. Returns: dict: A dictionary containing order details. import pytest from unittest.mock import MagicMock def test_get_order_details(monkeypatch): # Setup mock cursor and connection mock_cursor = MagicMock() mock_cursor.fetchone.return_value = { \\"order_id\\": 1234, \\"customer_name\\": \\"John Doe\\", \\"items\\": [\\"item1\\", \\"item2\\"], \\"total_price\\": 99.99 } mock_db_conn = MagicMock() mock_db_conn.cursor.return_value = mock_cursor # Run the test result = get_order_details(mock_db_conn, 1234) assert result[\\"order_id\\"] == 1234 assert result[\\"customer_name\\"] == \\"John Doe\\" assert result[\\"items\\"] == [\\"item1\\", \\"item2\\"] assert result[\\"total_price\\"] == 99.99 def test_get_order_details_no_order(monkeypatch): # Setup mock cursor and connection mock_cursor = MagicMock() mock_cursor.fetchone.return_value = None mock_db_conn = MagicMock() mock_db_conn.cursor.return_value = mock_cursor # Run the test result = get_order_details(mock_db_conn, 9999) assert result == {} def test_get_order_details_empty_order(monkeypatch): # Setup mock cursor and connection mock_cursor = MagicMock() mock_cursor.fetchone.return_value = { \\"order_id\\": 1234, \\"customer_name\\": \\"\\", \\"items\\": [], \\"total_price\\": 0.00 } mock_db_conn = MagicMock() mock_db_conn.cursor.return_value = mock_cursor # Run the test result = get_order_details(mock_db_conn, 1234) assert result[\\"order_id\\"] == 1234 assert result[\\"customer_name\\"] == \\"\\" assert result[\\"items\\"] == [] assert result[\\"total_price\\"] == 0.00","solution":"from typing import Any def get_order_details(db_conn: Any, order_id: int) -> dict: Fetches order details from the database for the given order_id. Parameters: db_conn (Any): A database connection object. order_id (int): The ID of the order to fetch details for. Returns: dict: A dictionary containing order details. cursor = db_conn.cursor() cursor.execute(\\"SELECT * FROM orders WHERE order_id = ?\\", (order_id,)) row = cursor.fetchone() if row is None: return {} return { \\"order_id\\": row[\\"order_id\\"], \\"customer_name\\": row[\\"customer_name\\"], \\"items\\": row[\\"items\\"], \\"total_price\\": row[\\"total_price\\"] }"},{"question":"def grade_distribution(scores: list) -> dict: Returns the grade distribution based on a list of scores. Parameters: scores (list): A list of integer scores. Returns: dict: A dictionary with grades as keys and counts as values. >>> grade_distribution([95, 85, 76, 65, 54]) {'A': 1, 'B': 1, 'C': 1, 'D': 1, 'F': 1} >>> grade_distribution([99, 89, 79, 69, 59]) {'A': 1, 'B': 1, 'C': 1, 'D': 1, 'F': 1} >>> grade_distribution([100, 90, 80, 70, 60, 55]) {'A': 2, 'B': 1, 'C': 1, 'D': 1, 'F': 1} >>> grade_distribution([92, 85, 75]) {'A': 1, 'B': 1, 'C': 1, 'D': 0, 'F': 0} >>> grade_distribution([]) {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'F': 0} >>> grade_distribution([10, 20, 30, 40, 50]) {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'F': 5}","solution":"def grade_distribution(scores): Returns the grade distribution based on a list of scores. Parameters: scores (list): A list of integer scores. Returns: dict: A dictionary with grades as keys and counts as values. # Initializing the grade distribution dictionary distribution = { 'A': 0, 'B': 0, 'C': 0, 'D': 0, 'F': 0 } # Categorizing each score into their respective grade for score in scores: if 90 <= score <= 100: distribution['A'] += 1 elif 80 <= score <= 89: distribution['B'] += 1 elif 70 <= score <= 79: distribution['C'] += 1 elif 60 <= score <= 69: distribution['D'] += 1 elif score < 60: distribution['F'] += 1 return distribution"},{"question":"def perim_triangle(side1: float, side2: float, side3: float) -> float: Calculate the perimeter of a triangle given the lengths of its three sides. The function should raise a ValueError if any of the sides are negative. >>> perim_triangle(3, 4, 5) -> 12 >>> perim_triangle(0, 0, 0) -> 0 def perim_rectangle(length: float, width: float) -> float: Calculate the perimeter of a rectangle given its length and width. The function should raise a ValueError if length or width is negative. >>> perim_rectangle(3, 4) -> 14 >>> perim_rectangle(0, 0) -> 0 def perim_square(side_length: float) -> float: Calculate the perimeter of a square given the length of one side. The function should raise a ValueError if the side length is negative. >>> perim_square(4) -> 16 >>> perim_square(0) -> 0 def perim_pentagon(side_length: float) -> float: Calculate the perimeter of a regular pentagon given the length of one side. The function should raise a ValueError if the side length is negative. >>> perim_pentagon(5) -> 25 >>> perim_pentagon(0) -> 0 def perim_hexagon(side_length: float) -> float: Calculate the perimeter of a regular hexagon given the length of one side. The function should raise a ValueError if the side length is negative. >>> perim_hexagon(6) -> 36 >>> perim_hexagon(0) -> 0 def perim_heptagon(side_length: float) -> float: Calculate the perimeter of a regular heptagon given the length of one side. The function should raise a ValueError if the side length is negative. >>> perim_heptagon(7) -> 49 >>> perim_heptagon(0) -> 0 def perim_octagon(side_length: float) -> float: Calculate the perimeter of a regular octagon given the length of one side. The function should raise a ValueError if the side length is negative. >>> perim_octagon(8) -> 64 >>> perim_octagon(0) -> 0 def perim_nonagon(side_length: float) -> float: Calculate the perimeter of a regular nonagon given the length of one side. The function should raise a ValueError if the side length is negative. >>> perim_nonagon(9) -> 81 >>> perim_nonagon(0) -> 0 def perim_decagon(side_length: float) -> float: Calculate the perimeter of a regular decagon given the length of one side. The function should raise a ValueError if the side length is negative. >>> perim_decagon(10) -> 100 >>> perim_decagon(0) -> 0 # Function usage example perim_triangle(3, 4, 5) perim_rectangle(3, 4) perim_square(4) perim_pentagon(5) perim_hexagon(6) perim_heptagon(7) perim_octagon(8) perim_nonagon(9) perim_decagon(10) import pytest def test_perim_triangle(): assert perim_triangle(3, 4, 5) == 12 assert perim_triangle(0, 0, 0) == 0 with pytest.raises(ValueError): perim_triangle(-1, 2, 3) def test_perim_rectangle(): assert perim_rectangle(3, 4) == 14 assert perim_rectangle(0, 0) == 0 with pytest.raises(ValueError): perim_rectangle(-1, 2) def test_perim_square(): assert perim_square(4) == 16 assert perim_square(0) == 0 with pytest.raises(ValueError): perim_square(-4) def test_perim_pentagon(): assert perim_pentagon(5) == 25 assert perim_pentagon(0) == 0 with pytest.raises(ValueError): perim_pentagon(-5) def test_perim_hexagon(): assert perim_hexagon(6) == 36 assert perim_hexagon(0) == 0 with pytest.raises(ValueError): perim_hexagon(-6) def test_perim_heptagon(): assert perim_heptagon(7) == 49 assert perim_heptagon(0) == 0 with pytest.raises(ValueError): perim_heptagon(-7) def test_perim_octagon(): assert perim_octagon(8) == 64 assert perim_octagon(0) == 0 with pytest.raises(ValueError): perim_octagon(-8) def test_perim_nonagon(): assert perim_nonagon(9) == 81 assert perim_nonagon(0) == 0 with pytest.raises(ValueError): perim_nonagon(-9) def test_perim_decagon(): assert perim_decagon(10) == 100 assert perim_decagon(0) == 0 with pytest.raises(ValueError): perim_decagon(-10)","solution":"def perim_triangle(side1: float, side2: float, side3: float) -> float: if side1 < 0 or side2 < 0 or side3 < 0: raise ValueError(\\"perim_triangle() only accepts non-negative values\\") return side1 + side2 + side3 def perim_rectangle(length: float, width: float) -> float: if length < 0 or width < 0: raise ValueError(\\"perim_rectangle() only accepts non-negative values\\") return 2 * (length + width) def perim_square(side_length: float) -> float: if side_length < 0: raise ValueError(\\"perim_square() only accepts non-negative values\\") return 4 * side_length def perim_pentagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"perim_pentagon() only accepts non-negative values\\") return 5 * side_length def perim_hexagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"perim_hexagon() only accepts non-negative values\\") return 6 * side_length def perim_heptagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"perim_heptagon() only accepts non-negative values\\") return 7 * side_length def perim_octagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"perim_octagon() only accepts non-negative values\\") return 8 * side_length def perim_nonagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"perim_nonagon() only accepts non-negative values\\") return 9 * side_length def perim_decagon(side_length: float) -> float: if side_length < 0: raise ValueError(\\"perim_decagon() only accepts non-negative values\\") return 10 * side_length"},{"question":"import re from collections import defaultdict def parse_log_file(file_path: str) -> dict: Processes a web server log file and returns a summary report. Args: file_path (str): The path to the log file to be processed. Returns: dict: A dictionary with the summary report: - total_requests: The total number of requests. - methods: Counts of request methods (GET, POST, etc.). - status_codes: Counts of response status codes (200, 404, etc.). pass # Test Cases def test_parse_log_file_empty(): with open('test_log_empty.log', 'w') as f: f.write('') # Create an empty log file for testing result = parse_log_file('test_log_empty.log') assert result == { 'total_requests': 0, 'methods': {}, 'status_codes': {} } def test_parse_log_file_single_entry(): with open('test_log_single_entry.log', 'w') as f: f.write('192.168.1.1 - - [12/Oct/2023:14:12:25 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024n') result = parse_log_file('test_log_single_entry.log') assert result == { 'total_requests': 1, 'methods': {'GET': 1}, 'status_codes': {'200': 1} } def test_parse_log_file_multiple_entries(): with open('test_log_multiple_entries.log', 'w') as f: f.write('192.168.1.1 - - [12/Oct/2023:14:12:25 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024n') f.write('192.168.1.2 - - [12/Oct/2023:14:15:43 +0000] \\"POST /submit-form HTTP/1.1\\" 404 512n') f.write('192.168.1.3 - - [12/Oct/2023:14:20:12 +0000] \\"GET /about.html HTTP/1.1\\" 200 2048n') result = parse_log_file('test_log_multiple_entries.log') assert result == { 'total_requests': 3, 'methods': {'GET': 2, 'POST': 1}, 'status_codes': {'200': 2, '404': 1} } def test_parse_log_file_malformed_entries(): with open('test_log_malformed_entries.log', 'w') as f: f.write('192.168.1.1 - - [12/Oct/2023:14:12:25 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024n') f.write('MALFORMED LOG ENTRYn') f.write('192.168.1.2 - - [12/Oct/2023:14:15:43 +0000] \\"POST /submit-form HTTP/1.1\\" 404 512n') result = parse_log_file('test_log_malformed_entries.log') assert result == { 'total_requests': 2, 'methods': {'GET': 1, 'POST': 1}, 'status_codes': {'200': 1, '404': 1} }","solution":"import re from collections import defaultdict def parse_log_file(file_path: str) -> dict: Processes a web server log file and returns a summary report. Args: file_path (str): The path to the log file to be processed. Returns: dict: A dictionary with the summary report: - total_requests: The total number of requests. - methods: Counts of request methods (GET, POST, etc.). - status_codes: Counts of response status codes (200, 404, etc.). total_requests = 0 methods = defaultdict(int) status_codes = defaultdict(int) log_line_pattern = re.compile(r'S+ - - [S+ +d+] \\"(?P<method>S+) S+ S+\\" (?P<status>d+) d+') with open(file_path, 'r') as file: for line in file: match = log_line_pattern.match(line) if match: total_requests += 1 method = match.group('method') status = match.group('status') methods[method] += 1 status_codes[status] += 1 return { 'total_requests': total_requests, 'methods': dict(methods), 'status_codes': dict(status_codes) }"},{"question":"def sum_squared_diffs(list1: List[int], list2: List[int]) -> int: Returns the sum of squared differences between corresponding elements of two lists. >>> sum_squared_diffs([1, 2, 3], [4, 5, 6]) 27 >>> sum_squared_diffs([0, -1, 2], [-1, 0, 2]) 2 >>> sum_squared_diffs([], []) 0","solution":"def sum_squared_diffs(list1, list2): Returns the sum of squared differences between corresponding elements of two lists. return sum((x - y) ** 2 for x, y in zip(list1, list2))"},{"question":"def evaluate_polynomial(coefficients: list[float], x: float) -> float: Evaluate the polynomial with given coefficients at point x. Parameters: coefficients (list of float): Coefficients of the polynomial, ordered from the constant term to the highest degree term. x (float): The point at which to evaluate the polynomial Returns: float: The value of the polynomial evaluated at the given point x Example: >>> evaluate_polynomial([2, 0, 3, 5], 2.0) 54.0 >>> evaluate_polynomial([1], 5.0) 1.0 pass def differentiate_polynomial(coefficients: list[float]) -> list[float]: Differentiate the polynomial with given coefficients. Parameters: coefficients (list of float): Coefficients of the polynomial, ordered from the constant term to the highest degree term. Returns: list of float: Coefficients of the differentiated polynomial, ordered from the constant term to the highest degree term Example: >>> differentiate_polynomial([2, 0, 3, 5]) [0, 6, 15] >>> differentiate_polynomial([1]) [0.0] pass def test_evaluate_polynomial(): assert evaluate_polynomial([2, 0, 3, 5], 2.0) == 54.0 assert evaluate_polynomial([1], 5.0) == 1.0 assert evaluate_polynomial([0, 1], 3.0) == 3.0 assert evaluate_polynomial([], 2.0) == 0.0 # Should handle empty list gracefully assert evaluate_polynomial([0], 10.0) == 0.0 def test_differentiate_polynomial(): assert differentiate_polynomial([2, 0, 3, 5]) == [0, 6, 15] assert differentiate_polynomial([1]) == [0.0] assert differentiate_polynomial([0, 1]) == [1] assert differentiate_polynomial([0]) == [0.0] assert differentiate_polynomial([]) == [0.0] # Should handle empty list gracefully def test_evaluate_polynomial_large_x(): assert evaluate_polynomial([1, -1, 1], 10) == 91.0 # 1 - 10 + 100 = 91 def test_differentiate_polynomial_high_order(): assert differentiate_polynomial([3, 2, 1, 0, 5]) == [2, 2, 0, 20] # Corresponds to 2*x + 2*x^2 + 20*x^4 test_evaluate_polynomial() test_differentiate_polynomial() test_evaluate_polynomial_large_x() test_differentiate_polynomial_high_order()","solution":"def evaluate_polynomial(coefficients, x): Evaluate the polynomial with given coefficients at point x. Parameters: coefficients (list of float): Coefficients of the polynomial, ordered from the constant term to the highest degree term. x (float): The point at which to evaluate the polynomial Returns: float: The value of the polynomial evaluated at the given point x result = 0.0 for coeff in reversed(coefficients): result = result * x + coeff return result def differentiate_polynomial(coefficients): Differentiate the polynomial with given coefficients. Parameters: coefficients (list of float): Coefficients of the polynomial, ordered from the constant term to the highest degree term. Returns: list of float: Coefficients of the differentiated polynomial, ordered from the constant term to the highest degree term n = len(coefficients) if n <= 1: return [0.0] # The derivative of a constant is 0 differentiated_coefficients = [coefficients[i] * i for i in range(1, n)] return differentiated_coefficients"},{"question":"from typing import List def group_students(students: List[str], group_size: int) -> List[List[str]]: Divides students into groups of given size. :param students: List of student names. :param group_size: Maximum number of students per group. :return: List of groups where each group is a list of student names. >>> group_students(['Alice', 'Bob', 'Charlie', 'David', 'Eve'], 2) [['Alice', 'Bob'], ['Charlie', 'David'], ['Eve']] >>> group_students(['Alice', 'Bob', 'Charlie', 'David', 'Eve'], 3) [['Alice', 'Bob', 'Charlie'], ['David', 'Eve']]","solution":"def group_students(students, group_size): Divides students into groups of given size. :param students: List of student names. :param group_size: Maximum number of students per group. :return: List of groups where each group is a list of student names. return [students[i:i + group_size] for i in range(0, len(students), group_size)]"},{"question":"def merge_and_sort(list1: list[int], list2: list[int]) -> list[int]: Merge two sorted lists into a single sorted list without using any built-in sorting methods. Args: list1 (list of int): A sorted list of integers. list2 (list of int): Another sorted list of integers. Returns: list of int: A single list containing all elements from both input lists, sorted in ascending order. Example: >>> merge_and_sort([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_sort([0, 10, 20], [-5, 5, 25]) [-5, 0, 5, 10, 20, 25] >>> merge_and_sort([], [2, 3, 4]) [2, 3, 4] >>> merge_and_sort([1, 2, 3], []) [1, 2, 3] result = [] i, j = 0, 0 # Merge the lists while i < len(list1) and j < len(list2): if list1[i] < list2[j]: result.append(list1[i]) i += 1 else: result.append(list2[j]) j += 1 # Add any remaining elements from list1 while i < len(list1): result.append(list1[i]) i += 1 # Add any remaining elements from list2 while j < len(list2): result.append(list2[j]) j += 1 return result # Test your implementation if __name__ == \\"__main__\\": assert merge_and_sort([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_and_sort([0, 10, 20], [-5, 5, 25]) == [-5, 0, 5, 10, 20, 25] assert merge_and_sort([], [2, 3, 4]) == [2, 3, 4] assert merge_and_sort([1, 2, 3], []) == [1, 2, 3]","solution":"def merge_and_sort(list1, list2): result = [] i, j = 0, 0 # Merge process while i < len(list1) and j < len(list2): if list1[i] < list2[j]: result.append(list1[i]) i += 1 else: result.append(list2[j]) j += 1 # Collect remaining elements from list1 while i < len(list1): result.append(list1[i]) i += 1 # Collect remaining elements from list2 while j < len(list2): result.append(list2[j]) j += 1 return result"},{"question":"from typing import List def find_substrings(s: str, pattern: str) -> List[int]: Returns a list of starting indices where the \`pattern\` is found within the string \`s\`. >>> find_substrings(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_substrings(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] >>> find_substrings(\\"hello world\\", \\"o\\") [4, 7] >>> find_substrings(\\"mississippi\\", \\"issi\\") [1, 4] >>> find_substrings(\\"abc\\", \\"\\") [] >>> find_substrings(\\"\\", \\"abc\\") [] >>> find_substrings(\\"aaa\\", \\"aaaa\\") []","solution":"def find_substrings(s: str, pattern: str) -> list: Returns a list of starting indices where the \`pattern\` is found within the string \`s\`. # Base case: if pattern is empty, return an empty list if not pattern: return [] # Lengths of the input string and pattern n, m = len(s), len(pattern) # Base case: if pattern is longer than s, no match can exist if m > n: return [] # KMP algorithm implementation def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) indices = [] i = j = 0 while i < n: if pattern[j] == s[i]: i += 1 j += 1 if j == m: indices.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != s[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"def highest_frequency_char(s: str) -> str: Find the character with the highest frequency in a string. In case of a tie, return the lexicographically smallest character. >>> highest_frequency_char(\\"aabbbccdd\\") == 'b' >>> highest_frequency_char(\\"aabbcc\\") == 'a' >>> highest_frequency_char(\\"abcd\\") == 'a' >>> highest_frequency_char(\\"\\") == '' >>> highest_frequency_char(\\"zzzzabc\\") == 'z' >>> highest_frequency_char(\\"abccc\\") == 'c' >>> highest_frequency_char(\\"a\\" * 100000) == 'a' # large input test >>> highest_frequency_char(\\"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\\") == 'a' # all characters same frequency >>> highest_frequency_char(\\"aaabbbbcc\\") == 'b' >>> highest_frequency_char(\\"abacabadabacabaeabacabadabacaba\\") == 'a' >>> highest_frequency_char(\\"a\\") == 'a' >>> highest_frequency_char(\\"aa\\") == 'a' >>> highest_frequency_char(\\"ab\\") == 'a' >>> highest_frequency_char(\\"bbaaa\\") == 'a' pass","solution":"def highest_frequency_char(s: str) -> str: if not s: return '' frequency = [0] * 26 # for a-z for char in s: frequency[ord(char) - ord('a')] += 1 max_freq = 0 result_char = None for i in range(26): if frequency[i] > max_freq or (frequency[i] == max_freq and result_char is not None and chr(i + ord('a')) < result_char): max_freq = frequency[i] result_char = chr(i + ord('a')) return result_char"},{"question":"class SequenceManager: def __init__(self, sequence: list[int]) -> None: Initializes the SequenceManager with a sequence of integers. pass def is_non_decreasing(self) -> bool: Checks if the sequence is non-decreasing. >>> SequenceManager([1, 2, 2, 3, 4]).is_non_decreasing() True >>> SequenceManager([5, 4, 3, 2, 1]).is_non_decreasing() False >>> SequenceManager([1, 1, 1, 1]).is_non_decreasing() True pass def is_non_increasing(self) -> bool: Checks if the sequence is non-increasing. >>> SequenceManager([5, 4, 3, 3, 2, 1]).is_non_increasing() True >>> SequenceManager([1, 2, 3, 4, 5]).is_non_increasing() False >>> SequenceManager([3, 3, 3, 3]).is_non_increasing() True pass def custom_sort(self, ascending: bool = True) -> list[int]: Sorts the sequence in either ascending or descending order. >>> SequenceManager([3, 1, 2, 4, 5]).custom_sort(ascending=True) [1, 2, 3, 4, 5] >>> SequenceManager([3, 1, 2, 4, 5]).custom_sort(ascending=False) [5, 4, 3, 2, 1] >>> SequenceManager([4, 4, 2, 2, 3, 3, 1, 1, 5, 5]).custom_sort(ascending=True) [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] >>> SequenceManager([4, 4, 2, 2, 3, 3, 1, 1, 5, 5]).custom_sort(ascending=False) [5, 5, 4, 4, 3, 3, 2, 2, 1, 1] pass","solution":"class SequenceManager: def __init__(self, sequence: list[int]) -> None: self.sequence = sequence def is_non_decreasing(self) -> bool: for i in range(1, len(self.sequence)): if self.sequence[i] < self.sequence[i - 1]: return False return True def is_non_increasing(self) -> bool: for i in range(1, len(self.sequence)): if self.sequence[i] > self.sequence[i - 1]: return False return True def custom_sort(self, ascending: bool = True) -> list[int]: return sorted(self.sequence, reverse=not ascending)"},{"question":"def balanced_parentheses_sequences(n: int) -> int: Returns the total number of distinct balanced parentheses sequences of length 2n. >>> balanced_parentheses_sequences(1) # () 1 >>> balanced_parentheses_sequences(2) # (()), ()() 2 >>> balanced_parentheses_sequences(3) # ((())), (()()), (())(), ()(()), ()()() 5 >>> balanced_parentheses_sequences(4) 14 >>> balanced_parentheses_sequences(5) 42 >>> balanced_parentheses_sequences(20) 6564120420","solution":"def balanced_parentheses_sequences(n: int) -> int: Returns the total number of distinct balanced parentheses sequences of length 2n. This is equivalent to finding the nth Catalan number. # Use dynamic programming to compute the Catalan number C = [0] * (n + 1) C[0] = 1 for i in range(1, n + 1): C[i] = 0 for j in range(i): C[i] += C[j] * C[i - 1 - j] return C[n]"},{"question":"from typing import List, Optional class Post: def __init__(self, content: str, timestamp: int): Initialize a post with content and timestamp. >>> post = Post(content=\\"Hello, world!\\", timestamp=1) >>> post.content 'Hello, world!' >>> post.timestamp 1 self.content = content self.timestamp = timestamp class User: def __init__(self, user_id: int): Initialize a user with an id, and empty lists for posts and friends. >>> user = User(user_id=1) >>> user.id 1 >>> user.posts [] >>> user.friends [] self.id = user_id self.posts: List[Post] = [] self.friends: List['User'] = [] def get_most_recent_post(user: User) -> Optional[Post]: Return the most recent post among all the friends of the given user. >>> post1 = Post(content=\\"Hello, world!\\", timestamp=1) >>> post2 = Post(content=\\"Good morning\\", timestamp=2) >>> user_a = User(id=1) >>> user_b = User(id=2) >>> user_a.friends.append(user_b) >>> user_b.posts.append(post2) >>> result = get_most_recent_post(user_a) >>> result.content 'Good morning' >>> result.timestamp 2 pass","solution":"from typing import List, Optional class Post: def __init__(self, content: str, timestamp: int): self.content = content self.timestamp = timestamp class User: def __init__(self, user_id: int): self.id = user_id self.posts: List[Post] = [] self.friends: List['User'] = [] def get_most_recent_post(user: User) -> Optional[Post]: most_recent_post = None def dfs(current_user: User): nonlocal most_recent_post for post in current_user.posts: if most_recent_post is None or post.timestamp > most_recent_post.timestamp: most_recent_post = post for friend in current_user.friends: dfs(friend) for friend in user.friends: dfs(friend) return most_recent_post"},{"question":"import random import string def generate_password(length: int, include_uppercase: bool, include_lowercase: bool, include_digits: bool, include_special: bool) -> str: Generate a secure, random password based on user-defined criteria. Parameters: length (int): The total length of the password. include_uppercase (bool): Whether to include uppercase letters. include_lowercase (bool): Whether to include lowercase letters. include_digits (bool): Whether to include digits. include_special (bool): Whether to include special characters. Returns: str: The generated password. Raises: ValueError: If length is less than the number of selected character types. Examples: >>> generate_password(length=12, include_uppercase=True, include_lowercase=True, include_digits=True, include_special=True) 'Fw8&e9RzTQk' >>> generate_password(length=8, include_uppercase=False, include_lowercase=True, include_digits=True, include_special=False) 'd9h5f3b0'","solution":"import random import string def generate_password(length: int, include_uppercase: bool, include_lowercase: bool, include_digits: bool, include_special: bool) -> str: if length < (include_uppercase + include_lowercase + include_digits + include_special): raise ValueError(\\"Password length is too short for the selected character types\\") character_sets = [] if include_uppercase: character_sets.append(string.ascii_uppercase) if include_lowercase: character_sets.append(string.ascii_lowercase) if include_digits: character_sets.append(string.digits) if include_special: character_sets.append('!@#%^&*()-_=+[]{}|;:,.<>?') if not character_sets: return '' # Ensure each type is represented password_chars = [random.choice(characters) for characters in character_sets] # Fill the remaining length with random choices from available characters all_characters = ''.join(character_sets) password_chars += [random.choice(all_characters) for _ in range(length - len(password_chars))] # Shuffle the list to ensure randomness random.shuffle(password_chars) return ''.join(password_chars)"},{"question":"from typing import List def unique_words(sentences: List[str]) -> List[str]: Identifies unique words from a list of sentences and returns them sorted in alphabetical order. The function normalizes words by converting them to lowercase and removing punctuation. >>> unique_words([\\"Hello world!\\", \\"This is a Test.\\", \\"Is this a test?\\"]) ['a', 'hello', 'is', 'test', 'this', 'world'] >>> unique_words([\\"Python is great!\\", \\"It's great to learn Python.\\", \\"hello hello, great world!\\"]) ['great', 'hello', 'is', 'its', 'learn', 'python', 'to', 'world'] >>> unique_words([]) [] >>> unique_words([\\"Unique words in this sentence.\\"]) ['in', 'sentence', 'this', 'unique', 'words'] >>> unique_words([\\"Apple apple APPLE apple\\"]) ['apple'] pass","solution":"from typing import List import re def unique_words(sentences: List[str]) -> List[str]: Identifies unique words from a list of sentences and returns them sorted in alphabetical order. The function normalizes words by converting them to lowercase and removing punctuation. # Combine all sentences into a single string combined_text = \\" \\".join(sentences) # Convert the text to lowercase combined_text = combined_text.lower() # Remove punctuation using regex combined_text = re.sub(r'[^ws]', '', combined_text) # Split the text into words words = combined_text.split() # Identify unique words unique_words = sorted(set(words)) return unique_words"},{"question":"from typing import List def merge_sort(arr: List[int]) -> List[int]: This function implements the Merge Sort algorithm to sort a list of integers. Arguments: arr -- list of integers to be sorted Returns: sorted list of integers Example: >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] pass def test_merge_sort_with_positive_numbers(): assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] def test_merge_sort_with_mixed_numbers(): assert merge_sort([5, 1, 4, 2, -8]) == [-8, 1, 2, 4, 5] def test_merge_sort_with_duplicates(): assert merge_sort([2, 1, 2, 1, 3]) == [1, 1, 2, 2, 3] def test_merge_sort_with_empty_list(): assert merge_sort([]) == [] def test_merge_sort_with_single_element(): assert merge_sort([1]) == [1] def test_merge_sort_with_sorted_list(): assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_merge_sort_with_reversed_list(): assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_merge_sort_with_large_numbers(): assert merge_sort([100000, 99999, 100001]) == [99999, 100000, 100001] def test_merge_sort_edge_case_large_list(): assert merge_sort([i for i in range(1000, 0, -1)]) == [i for i in range(1, 1001)]","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: This function implements the Merge Sort algorithm to sort a list of integers. if len(arr) <= 1: return arr # Divide the array into two halves middle = len(arr) // 2 left_half = merge_sort(arr[:middle]) right_half = merge_sort(arr[middle:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: This helper function merges two sorted lists into a single sorted list. sorted_list = [] i = j = 0 # Loop through both lists and append the smaller elements to the sorted list while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append any remaining elements in the left list while i < len(left): sorted_list.append(left[i]) i += 1 # Append any remaining elements in the right list while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"from typing import List, Tuple def count_late_submissions(assignments: List[Tuple[str, str]]) -> int: Write a function count_late_submissions(assignments: List[Tuple[str, str]]) -> int that takes a list of tuples where each tuple contains two strings representing the submission date and the due date of an assignment in the format \\"YYYY-MM-DD\\", and returns the number of late submissions. An assignment is considered late if the submission date is after the due date. >>> count_late_submissions([(\\"2023-05-01\\", \\"2023-04-30\\"), (\\"2023-06-15\\", \\"2023-06-15\\"), (\\"2023-09-10\\", \\"2023-09-01\\")]) 2 >>> count_late_submissions([(\\"2023-04-30\\", \\"2023-04-30\\"), (\\"2023-06-15\\", \\"2023-06-15\\"), (\\"2023-09-01\\", \\"2023-09-01\\")]) 0","solution":"from typing import List, Tuple from datetime import datetime def count_late_submissions(assignments: List[Tuple[str, str]]) -> int: count = 0 date_format = \\"%Y-%m-%d\\" for submission_date, due_date in assignments: submission_date_dt = datetime.strptime(submission_date, date_format) due_date_dt = datetime.strptime(due_date, date_format) if submission_date_dt > due_date_dt: count += 1 return count"},{"question":"from typing import List def longest_sentence(sentences: List[str]) -> str: Returns the longest sentence from the list of sentences. If there are multiple sentences with the same length, it returns the first one. >>> longest_sentence([\\"Hello world\\", \\"A quick brown fox jumps over the lazy dog\\", \\"Goodbye\\"]) 'A quick brown fox jumps over the lazy dog' >>> longest_sentence([\\"abc\\", \\"def\\", \\"ghi\\"]) 'abc'","solution":"from typing import List def longest_sentence(sentences: List[str]) -> str: Returns the longest sentence from the list of sentences. If there are multiple sentences with the same length, it returns the first one. if not sentences: return \\"\\" longest = sentences[0] for sentence in sentences[1:]: if len(sentence) > len(longest): longest = sentence return longest"},{"question":"def rectangle_intersection(rect1: dict, rect2: dict) -> int: Calculate the area of intersection between two rectangles. :param dict rect1: A dictionary containing the coordinates of the first rectangle :param dict rect2: A dictionary containing the coordinates of the second rectangle :return: The area of the intersection of the two rectangles :rtype: int Examples: >>> rect1 = {'x1': 1, 'y1': 1, 'x2': 3, 'y2': 3} >>> rect2 = {'x1': 2, 'y1': 2, 'x2': 4, 'y2': 4} >>> rectangle_intersection(rect1, rect2) 1 >>> rect1 = {'x1': 1, 'y1': 1, 'x2': 3, 'y2': 3} >>> rect2 = {'x1': 3, 'y1': 3, 'x2': 4, 'y2': 4} >>> rectangle_intersection(rect1, rect2) 0","solution":"def rectangle_intersection(rect1, rect2): Calculate the area of intersection between two rectangles. :param dict rect1: A dictionary containing the coordinates of the first rectangle :param dict rect2: A dictionary containing the coordinates of the second rectangle :return: The area of the intersection of the two rectangles :rtype: int # Validate the rectangles if not (rect1['x1'] < rect1['x2'] and rect1['y1'] < rect1['y2'] and rect2['x1'] < rect2['x2'] and rect2['y1'] < rect2['y2']): raise ValueError(\\"Invalid rectangle coordinates\\") # Calculate the intersection coordinates left = max(rect1['x1'], rect2['x1']) right = min(rect1['x2'], rect2['x2']) bottom = max(rect1['y1'], rect2['y1']) top = min(rect1['y2'], rect2['y2']) # Calculate the dimensions of the intersection rectangle width = right - left height = top - bottom # If the rectangles do not intersect or just touch at the edges if width <= 0 or height <= 0: return 0 return width * height"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. Parameters: s1 (str): First input string. s2 (str): Second input string. Returns: bool: True if both strings are anagrams, False otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. Parameters: s1 (str): First input string. s2 (str): Second input string. Returns: bool: True if both strings are anagrams, False otherwise. if len(s1) != len(s2): return False # Frequency dictionary to count occurrences of each character char_count = {} for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] == 0: del char_count[char] else: return False return len(char_count) == 0"},{"question":"from typing import List def find_minimum_spanning_tree(weights: List[List[int]]) -> int: Computes the total weight of the minimum spanning tree (MST) of a weighted, undirected graph using Prim's algorithm. >>> find_minimum_spanning_tree([ ... [0, 2, float('inf'), 6, float('inf')], ... [2, 0, 3, 8, 5], ... [float('inf'), 3, 0, float('inf'), 7], ... [6, 8, float('inf'), 0, 9], ... [float('inf'), 5, 7, 9, 0] ... ]) 16 >>> find_minimum_spanning_tree([ ... [0, 1, 4], ... [1, 0, 2], ... [4, 2, 0] ... ]) 3 pass import heapq import pytest def test_find_minimum_spanning_tree_case1(): weights = [ [0, 2, float('inf'), 6, float('inf')], [2, 0, 3, 8, 5], [float('inf'), 3, 0, float('inf'), 7], [6, 8, float('inf'), 0, 9], [float('inf'), 5, 7, 9, 0] ] assert find_minimum_spanning_tree(weights) == 16 def test_find_minimum_spanning_tree_case2(): weights = [ [0, 1, 4], [1, 0, 2], [4, 2, 0] ] assert find_minimum_spanning_tree(weights) == 3 def test_find_minimum_spanning_tree_single_node(): weights = [ [0] ] assert find_minimum_spanning_tree(weights) == 0 def test_find_minimum_spanning_tree_no_direct_connections(): weights = [ [0, 2, float('inf')], [2, 0, 4], [float('inf'), 4, 0] ] assert find_minimum_spanning_tree(weights) == 6 def test_find_minimum_spanning_tree_large_values(): weights = [ [0, 1000, 1000], [1000, 0, 100], [1000, 100, 0] ] assert find_minimum_spanning_tree(weights) == 1100 if __name__ == '__main__': pytest.main()","solution":"from typing import List import heapq def find_minimum_spanning_tree(weights: List[List[int]]) -> int: n = len(weights) visited = [False] * n min_heap = [(0, 0)] # (cost, vertex) total_weight = 0 while min_heap: weight, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_weight += weight for v in range(n): if not visited[v] and weights[u][v] != float('inf'): heapq.heappush(min_heap, (weights[u][v], v)) return total_weight"},{"question":"def is_palindrome_permutation(s: str) -> bool: Checks if any permutation of the input string can form a palindrome. >>> is_palindrome_permutation(\\"taco cat\\") True >>> is_palindrome_permutation(\\"racecar\\") True >>> is_palindrome_permutation(\\"palindrome\\") False >>> is_palindrome_permutation(\\"aabbccddeeff\\") True >>> is_palindrome_permutation(\\"aabbcc\\") True","solution":"def is_palindrome_permutation(s: str) -> bool: Checks if any permutation of the input string can form a palindrome. from collections import Counter # Remove spaces and lowercase all characters for uniformity cleaned_str = s.replace(\\" \\", \\"\\").lower() char_count = Counter(cleaned_str) # Count the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using dynamic programming. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(30) 832040 >>> fibonacci(50) 12586269025 >>> fibonacci(20) 6765 >>> fibonacci(25) 75025 >>> fibonacci(70) 190392490709135 pass","solution":"def fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 # Initialize the base cases prev1, prev2 = 0, 1 # Compute subsequent Fibonacci numbers for _ in range(2, n + 1): curr = prev1 + prev2 prev1, prev2 = prev2, curr return prev2"},{"question":"class SimpleCalculator: def __init__(self): pass def evaluate(self, expression: str) -> float: Parse and evaluate the given arithmetic expression string. >>> calculator = SimpleCalculator() >>> calculator.evaluate(\\"3+2*2\\") # Should return 7 >>> calculator.evaluate(\\" 3/2 \\") # Should return 1.5 >>> calculator.evaluate(\\"(2+3)*(4-2)\\") # Should return 10 >>> try: ... calculator.evaluate(\\"3/0\\") ... except ZeroDivisionError: ... print(\\"Cannot divide by zero.\\") >>> try: ... calculator.evaluate(\\"3 +\\") ... except ValueError: ... print(\\"Invalid Expression.\\") import pytest calculator = SimpleCalculator() def test_addition(): assert calculator.evaluate(\\"3+2\\") == 5 def test_subtraction(): assert calculator.evaluate(\\"5-3\\") == 2 def test_multiplication(): assert calculator.evaluate(\\"3*2\\") == 6 def test_division(): assert calculator.evaluate(\\"6/2\\") == 3 def test_combined_operations(): assert calculator.evaluate(\\"3+2*2\\") == 7 def test_expression_with_parentheses(): assert calculator.evaluate(\\"(2+3)*(4-2)\\") == 10 def test_float_division(): assert calculator.evaluate(\\"3/2\\") == 1.5 def test_complex_expression(): assert calculator.evaluate(\\"3 + 5 * 2 / (7 - 3)\\") == 5.5 def test_invalid_expression(): with pytest.raises(ValueError): calculator.evaluate(\\"3 +\\") def test_division_by_zero(): with pytest.raises(ZeroDivisionError): calculator.evaluate(\\"3/0\\")","solution":"class SimpleCalculator: def __init__(self): pass def evaluate(self, expression: str) -> float: def parse_expression(expression): tokens = [] number = '' for char in expression: if char.isdigit() or char == '.': number += char else: if number: tokens.append(float(number)) number = '' if char in \\"+-*/()\\": tokens.append(char) if number: tokens.append(float(number)) return tokens def shunting_yard(tokens): precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output = [] operators = [] for token in tokens: if isinstance(token, float): output.append(token) elif token in precedence: while (operators and operators[-1] in precedence and precedence[token] <= precedence[operators[-1]]): output.append(operators.pop()) operators.append(token) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() while operators: output.append(operators.pop()) return output def evaluate_rpn(rpn): stack = [] for token in rpn: if isinstance(token, float): stack.append(token) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': if b == 0: raise ZeroDivisionError(\\"Division by zero.\\") stack.append(a / b) return stack[0] try: tokens = parse_expression(expression) rpn = shunting_yard(tokens) return evaluate_rpn(rpn) except (IndexError, ValueError): raise ValueError(\\"Invalid Expression\\") calculator = SimpleCalculator()"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two given strings are anagrams. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"\\", \\"\\") True","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, False otherwise. from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"from typing import List def generate_parentheses(n: int) -> List[str]: Generates all combinations of n pairs of balanced parentheses. :param n: int - number of pairs of parentheses :return: list of strings - all combinations of balanced parentheses >>> generate_parentheses(1) ['()'] >>> generate_parentheses(2) ['(())', '()()'] >>> generate_parentheses(3) ['((()))', '(()())', '(())()', '()(())', '()()()'] >>> generate_parentheses(4) ['(((())))', '((()()))', '((())())', '((()))()', '(()(()))', '(()()())', '(()())()', '(())(())', '(())()()', '()((()))', '()(()())', '()(())()', '()()(())', '()()()()']","solution":"def generate_parentheses(n): Generates all combinations of n pairs of balanced parentheses. :param n: int - number of pairs of parentheses :return: list of strings - all combinations of balanced parentheses result = [] def backtrack(s, left, right): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \\"(\\", left + 1, right) if right < left: backtrack(s + \\")\\", left, right + 1) backtrack(\\"\\", 0, 0) return sorted(result)"},{"question":"class BinarySearchTree: Represents a binary search tree (BST) supporting basic operations such as inserting and deleting nodes, searching for values, and finding the minimum and maximum values in the tree. Example: >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(20) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(15) >>> bst.delete(20) >>> assert bst.search(10) == True >>> assert bst.search(20) == False >>> assert bst.find_min() == 3 >>> assert bst.find_max() == 15 >>> bst.delete(10) >>> assert bst.find_min() == 3 >>> assert bst.find_max() == 15 def __init__(self): Initializes an empty binary search tree. pass def insert(self, value: int) -> None: Inserts a value into the BST. If the value already exists, it does not insert it again. pass def delete(self, value: int) -> None: Deletes a value from the BST. If the value does not exist, it raises a ValueError. pass def search(self, value: int) -> bool: Searches for a value in the BST. Returns True if the value is found, False otherwise. pass def find_min(self) -> int: Finds and returns the minimum value in the BST. Raises a ValueError if the tree is empty. pass def find_max(self) -> int: Finds and returns the maximum value in the BST. Raises a ValueError if the tree is empty. pass","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) elif key > node.val: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) # If key == node.val, do nothing (BSTs do not contain duplicate values) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: raise ValueError(\\"Value not found in the tree\\") # Step 1: Find the node to be deleted if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: # Node with only one child or no child if node.left is None: return node.right elif node.right is None: return node.left # Node with two children: Get the inorder successor (smallest in the right subtree) temp_val = self._find_min(node.right) node.val = temp_val # Delete the inorder successor node.right = self._delete(node.right, temp_val) return node def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None: return False if node.val == key: return True elif key < node.val: return self._search(node.left, key) else: return self._search(node.right, key) def find_min(self): if self.root is None: raise ValueError(\\"Tree is empty\\") return self._find_min(self.root) def _find_min(self, node): current = node while current.left is not None: current = current.left return current.val def find_max(self): if self.root is None: raise ValueError(\\"Tree is empty\\") return self._find_max(self.root) def _find_max(self, node): current = node while current.right is not None: current = current.right return current.val"},{"question":"from typing import List import heapq def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: Merges k sorted linked lists into one sorted linked list. Args: lists (list of list of int): A list containing k sorted lists. Returns: list of int: A merged sorted list. Example: >>> merge_k_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6, 8]]) [1, 1, 2, 3, 4, 4, 5, 6, 8] >>> merge_k_sorted_lists([[], [], []]) []","solution":"import heapq def merge_k_sorted_lists(lists): Merges k sorted linked lists into one sorted linked list. Args: lists (list of list of int): A list containing k sorted lists. Returns: list of int: A merged sorted list. min_heap = [] merged_list = [] # Insert the first element of each list into the heap for i in range(len(lists)): if lists[i]: heapq.heappush(min_heap, (lists[i][0], i, 0)) # Extract the minimum element and add the next element from the same list to the heap while min_heap: val, list_idx, element_idx = heapq.heappop(min_heap) merged_list.append(val) if element_idx + 1 < len(lists[list_idx]): next_element = lists[list_idx][element_idx + 1] heapq.heappush(min_heap, (next_element, list_idx, element_idx + 1)) return merged_list"},{"question":"def consecutive_character_count(s: str) -> list: Returns a list where each element represents a count of its consecutive occurrences in the given string. >>> consecutive_character_count(\\"aaabbc\\") [3, 2, 1] >>> consecutive_character_count(\\"abcd\\") [1, 1, 1, 1] >>> consecutive_character_count(\\"a\\") [1]","solution":"def consecutive_character_count(s: str) -> list: Returns a list where each element represents a count of its consecutive occurrences in the given string. if not s: return [] result = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: result.append(count) current_char = char count = 1 result.append(count) return result"},{"question":"def calculate_frequency(string: str) -> dict: Calculates the frequency of each character in the given string. :param string: str, the input string. :return: dict, a dictionary where keys are characters and values are their frequencies. pass def most_frequent_characters(frequency_dict: dict) -> list: Returns a list of the most frequent characters from the frequency dictionary. :param frequency_dict: dict, a dictionary with character frequencies. :return: list, a list of characters with the highest frequency, sorted alphabetically. pass # Unit Tests from solution import calculate_frequency, most_frequent_characters def test_calculate_frequency_basic(): assert calculate_frequency(\\"aA bB\\") == {'a': 2, 'b': 2} def test_calculate_frequency_empty_string(): assert calculate_frequency(\\"\\") == {} def test_calculate_frequency_mixed_case(): assert calculate_frequency(\\"AbcDabC\\") == {'a': 2, 'b': 2, 'c': 2, 'd': 1} def test_calculate_frequency_with_spaces(): assert calculate_frequency(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} def test_most_frequent_characters_basic(): freq_dict = {'a': 2, 'b': 2} assert most_frequent_characters(freq_dict) == ['a', 'b'] def test_most_frequent_characters_single_most_frequent(): freq_dict = {'a': 3, 'b': 1} assert most_frequent_characters(freq_dict) == ['a'] def test_most_frequent_characters_empty_dict(): assert most_frequent_characters({}) == [] def test_most_frequent_characters_complex(): freq_dict = {'a': 2, 'b': 2, 'c': 1, 'd': 2} assert most_frequent_characters(freq_dict) == ['a', 'b', 'd'] def test_most_frequent_characters_with_mixed_case_counts(): freq_dict = calculate_frequency(\\"AbcDabC\\") assert most_frequent_characters(freq_dict) == ['a', 'b', 'c']","solution":"def calculate_frequency(string: str) -> dict: Calculates the frequency of each character in the given string. :param string: str, the input string. :return: dict, a dictionary where keys are characters and values are their frequencies. frequency = {} for char in string.lower(): if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency def most_frequent_characters(frequency_dict: dict) -> list: Returns a list of the most frequent characters from the frequency dictionary. :param frequency_dict: dict, a dictionary with character frequencies. :return: list, a list of characters with the highest frequency, sorted alphabetically. if not frequency_dict: return [] # Find the maximum frequency max_freq = max(frequency_dict.values()) # Gather all characters with the maximum frequency most_frequent_chars = [char for char, freq in frequency_dict.items() if freq == max_freq] # Return the sorted list of most frequent characters return sorted(most_frequent_chars)"},{"question":"def kmp_search(text: str, pattern: str) -> List[int]: Perform string pattern matching using the Knuth-Morris-Pratt (KMP) algorithm. Parameters: text (str): The text in which we want to find the pattern. pattern (str): The pattern that we want to find within the text. Returns: List[int]: A list of starting indices where the pattern is found within the text. If the pattern is not found, it returns an empty list. Example usage: >>> kmp_search('ababcabcabababd', 'ababd') [10] >>> kmp_search('abababab', 'abab') [0, 2, 4] >>> kmp_search('hello world', 'pattern') [] >>> kmp_search('', 'pattern') [] >>> kmp_search('hello world', '') [] >>> kmp_search('', '') [] >>> kmp_search('short', 'a very long pattern') [] >>> kmp_search('aaaaa', 'a') [0, 1, 2, 3, 4] >>> kmp_search('aaaaa', 'b') []","solution":"def kmp_search(text, pattern): def build_prefix_table(pattern): m = len(pattern) prefix_table = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j return prefix_table def search(text, pattern): n = len(text) m = len(pattern) prefix_table = build_prefix_table(pattern) indices = [] j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = prefix_table[j - 1] if text[i] == pattern[j]: j += 1 if j == m: indices.append(i - m + 1) j = prefix_table[j - 1] return indices if not text or not pattern: return [] return search(text, pattern)"},{"question":"def spiral_matrix_sum(matrix: list) -> int: Takes a 2D list (matrix) and returns the sum of its elements when traversed in a spiral order. >>> spiral_matrix_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> spiral_matrix_sum([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) 136 >>> spiral_matrix_sum([ ... [7] ... ]) 7 >>> spiral_matrix_sum([ ... [1, 2], ... [3, 4], ... [5, 6], ... [7, 8] ... ]) 36","solution":"def spiral_matrix_sum(matrix): Takes a 2D list (matrix) and returns the sum of its elements when traversed in a spiral order. if not matrix: return 0 top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 result = 0 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result += matrix[top][i] top += 1 # Traverse downwards for i in range(top, bottom + 1): result += matrix[i][right] right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result += matrix[bottom][i] bottom -= 1 if left <= right: # Traverse upwards for i in range(bottom, top - 1, -1): result += matrix[i][left] left += 1 return result"},{"question":"from typing import List def max_height_difference(grid: List[List[int]]) -> int: Returns the maximum height difference between any two cells in the grid. >>> max_height_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 8 >>> max_height_difference([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == 8 >>> max_height_difference([[0]]) == 0 >>> max_height_difference([[100, -100], [-100, 100]]) == 200","solution":"def max_height_difference(grid): Returns the maximum height difference between any two cells in the grid. min_height = float('inf') max_height = float('-inf') for row in grid: for height in row: if height < min_height: min_height = height if height > max_height: max_height = height return max_height - min_height"},{"question":"from typing import List def three_sum(nums: List[int], target: int) -> bool: Returns True if there are three integers in nums that sum up to target, False otherwise. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: bool: True if a triplet sum equals target, False otherwise. Examples: >>> three_sum([1, 2, 3, 4, 5], 9) == True >>> three_sum([1, 2, 3, 4], 11) == False >>> three_sum([], 7) == False # Example usage: print(three_sum([1, 2, 3, 4, 5], 9)) # Output: True print(three_sum([1, 2, 3, 4], 11)) # Output: False","solution":"from typing import List def three_sum(nums: List[int], target: int) -> bool: Returns True if there are three integers in nums that sum up to target, False otherwise. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: bool: True if a triplet sum equals target, False otherwise. nums.sort() n = len(nums) for i in range(n): left = i + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"import random def generate_username(full_name: str) -> str: Generates a username from the user's full name. Parameters: full_name (str): The user's full name. Returns: str: The generated username or None if input is invalid. >>> generate_username(\\"Alice Smith\\") # Example Output: 'asmith453' >>> generate_username(\\"John Jacob Jingleheimer Schmidt\\") # Example Output: 'jschmidt211' >>> generate_username(\\"\\") # Example Output: None >>> generate_username(\\"JustFirst\\") # Example Output: None from generate_username import generate_username def test_generate_username_normal_case(): username = generate_username(\\"Alice Smith\\") assert username.startswith(\\"asmith\\") and username[6:].isdigit() and 100 <= int(username[6:]) <= 999 def test_generate_username_multiple_parts(): username = generate_username(\\"John Jacob Jingleheimer Schmidt\\") assert username.startswith(\\"jschmidt\\") and username[8:].isdigit() and 100 <= int(username[8:]) <= 999 def test_generate_username_empty_string(): assert generate_username(\\"\\") is None def test_generate_username_single_name(): assert generate_username(\\"JustFirst\\") is None def test_generate_username_extra_spaces(): username = generate_username(\\" Alice Smith \\") assert username.startswith(\\"asmith\\") and username[6:].isdigit() and 100 <= int(username[6:]) <= 999 def test_generate_username_no_valid_parts(): assert generate_username(\\" \\") is None # Random number generation makes it difficult to test exact outputs, but we can check the structure and constraints. def test_generate_username_random_number(): for _ in range(100): # A number of trials to ensure randomness is within range for each case username = generate_username(\\"Alice Smith\\") assert username.startswith(\\"asmith\\") and username[6:].isdigit() random_number = int(username[6:]) assert 100 <= random_number <= 999","solution":"import random def generate_username(full_name: str) -> str: Generates a username from the user's full name. Parameters: full_name (str): The user's full name. Returns: str: The generated username or None if input is invalid. if not full_name.strip(): return None name_parts = full_name.strip().split() if len(name_parts) < 2: return None first_name = name_parts[0].lower() last_name = name_parts[-1].lower() random_number = random.randint(100, 999) username = f\\"{first_name[0]}{last_name}{random_number}\\" return username"},{"question":"from typing import List, Tuple def top_n_frequent_words(text: str, n: int) -> List[Tuple[str, int]]: Returns the top N most frequently occurring words from the given string of text. >>> top_n_frequent_words(\\"the quick brown fox jumps over the lazy dog the quick\\", 3) [('the', 3), ('quick', 2), ('brown', 1)] >>> top_n_frequent_words(\\"to be or not to be\\", 2) [('be', 2), ('to', 2)] pass from solution import top_n_frequent_words def test_single_word(): assert top_n_frequent_words(\\"hello\\", 1) == [(\\"hello\\", 1)] def test_same_frequency_alphabetical_order(): assert top_n_frequent_words(\\"a b c d\\", 3) == [(\\"a\\", 1), (\\"b\\", 1), (\\"c\\", 1)] def test_example_case_1(): assert top_n_frequent_words(\\"the quick brown fox jumps over the lazy dog the quick\\", 3) == [(\\"the\\", 3), (\\"quick\\", 2), (\\"brown\\", 1)] def test_example_case_2(): assert top_n_frequent_words(\\"to be or not to be\\", 2) == [(\\"be\\", 2), (\\"to\\", 2)] def test_large_input(): text = \\"a \\" * 1000 + \\"b \\" * 500 + \\"c \\" * 200 + \\"d \\" * 100 + \\"e \\" * 50 assert top_n_frequent_words(text.strip(), 3) == [(\\"a\\", 1000), (\\"b\\", 500), (\\"c\\", 200)] def test_top_n_greater_than_unique_words(): assert top_n_frequent_words(\\"test case with unique words only\\", 10) == [(\\"case\\", 1), (\\"only\\", 1), (\\"test\\", 1), (\\"unique\\", 1), (\\"with\\", 1), (\\"words\\", 1)] def test_word_with_multiple_spaces(): assert top_n_frequent_words(\\"the quick brown fox\\", 3) == [(\\"brown\\", 1), (\\"fox\\", 1), (\\"quick\\", 1)]","solution":"from typing import List, Tuple from collections import Counter def top_n_frequent_words(text: str, n: int) -> List[Tuple[str, int]]: # Split the input text into words words = text.split() # Count the frequency of each word word_counts = Counter(words) # Sort the word counts first by frequency (descending) then alphabetically sorted_word_counts = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Return top n elements from sorted_word_counts list return sorted_word_counts[:n]"},{"question":"class Node: def __init__(self, data, next_node=None): self.data = data self.next_node = next_node class LinkedList: def __init__(self): self.head = None def insert_tail(self, data): new_node = Node(data) if not self.head: self.head = new_node return temp = self.head while temp.next_node: temp = temp.next_node temp.next_node = new_node def detect_and_remove_cycle(linked_list): Detect and remove a cycle in a singly linked list. >>> ll = LinkedList() >>> ll.insert_tail(1) >>> ll.insert_tail(2) >>> ll.insert_tail(3) >>> ll.insert_tail(4) >>> ll.head.next_node.next_node.next_node.next_node = ll.head.next_node # Creating a cycle >>> detect_and_remove_cycle(ll).data 2 >>> detect_and_remove_cycle(ll) >>> result = [] >>> temp = ll.head while temp: result.append(temp.data) temp = temp.next_node >>> result [1, 2, 3, 4]","solution":"class Node: def __init__(self, data, next_node=None): self.data = data self.next_node = next_node class LinkedList: def __init__(self): self.head = None def insert_tail(self, data): new_node = Node(data) if not self.head: self.head = new_node return temp = self.head while temp.next_node: temp = temp.next_node temp.next_node = new_node def detect_and_remove_cycle(linked_list): slow = linked_list.head fast = linked_list.head # Detecting cycle using Floyd’s Cycle-Finding Algorithm while fast is not None and fast.next_node is not None: slow = slow.next_node fast = fast.next_node.next_node if slow == fast: break else: # No cycle detected return None # Finding the start of the cycle slow = linked_list.head while slow != fast: slow = slow.next_node fast = fast.next_node # 'slow' and 'fast' now point to the start of the cycle # Removing the cycle cycle_start_node = slow prev = None temp = slow while True: prev = temp temp = temp.next_node if temp == cycle_start_node: break prev.next_node = None return cycle_start_node"},{"question":"import math class Quadrilateral: def __init__(self, side1: float, side2: float, side3: float, side4: float, angle: float) -> None: self.side1 = side1 self.side2 = side2 self.side3 = side3 self.side4 = side4 self.angle = angle class Parallelogram(Quadrilateral): def __init__(self, side1: float, side2: float, side3: float, side4: float, angle: float) -> None: Initialize the parallelogram with four sides and the angle between two adjacent sides. Raises a ValueError if the sides do not form a valid parallelogram. super().__init__(side1, side2, side3, side4, angle) if not (side1 == side3 and side2 == side4): raise ValueError(\\"Opposite sides of a parallelogram must be equal.\\") if not (0 < angle < 180): raise ValueError(\\"Angle must be between 0 and 180 degrees and not equal to 0 or 180.\\") def area(self) -> float: Return the area of the parallelogram using the formula: Area = a * b * sin(angle) where a and b are two adjacent sides and angle is the angle between them in degrees. def perimeter(self) -> float: Return the perimeter of the parallelogram. def heights(self) -> tuple[float, float]: Return the heights corresponding to each base, calculated as: Height1 = Area / base1 Height2 = Area / base2","solution":"import math class Quadrilateral: def __init__(self, side1, side2, side3, side4, angle): self.side1 = side1 self.side2 = side2 self.side3 = side3 self.side4 = side4 self.angle = angle class Parallelogram(Quadrilateral): def __init__(self, side1, side2, side3, side4, angle): super().__init__(side1, side2, side3, side4, angle) if not (side1 == side3 and side2 == side4): raise ValueError(\\"Opposite sides of a parallelogram must be equal.\\") if not (0 < angle < 180): raise ValueError(\\"Angle must be between 0 and 180 degrees and not equal to 0 or 180.\\") def area(self): radians = math.radians(self.angle) return self.side1 * self.side2 * math.sin(radians) def perimeter(self): return 2 * (self.side1 + self.side2) def heights(self): area = self.area() height1 = area / self.side1 height2 = area / self.side2 return (height1, height2)"},{"question":"def longest_increasing_subsequence(arr: list) -> int: Find the length of the longest subsequence that can be derived from the list such that the subsequence is strictly increasing. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([5, 5, 5, 5]) 1 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(arr: list) -> int: if not arr: return 0 # Create an array to store the longest increasing subsequence length at each index lis = [1] * len(arr) # Iterate over each element of the array for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest increasing subsequence is the maximum value in the lis array return max(lis)"},{"question":"def translate(sentence: str, dictionary: dict) -> str: Translates a sentence from English to a fictional language using the provided dictionary. Parameters: sentence (str): The sentence in English to be translated. dictionary (dict): A dictionary where keys are words in English and values are the corresponding words in the fictional language. Returns: str: The translated sentence in the fictional language. Examples: >>> translate(\\"hello world\\", {\\"hello\\": \\"bono\\", \\"world\\": \\"mundo\\"}) \\"bono mundo\\" >>> translate(\\"hello world this is a test\\", {\\"hello\\": \\"bono\\", \\"world\\": \\"mundo\\", \\"this\\": \\"esto\\", \\"is\\": \\"es\\", \\"a\\": \\"un\\", \\"test\\": \\"prueba\\"}) \\"bono mundo esto es un prueba\\" pass","solution":"def translate(sentence: str, dictionary: dict) -> str: Translates a sentence from English to a fictional language using the provided dictionary. Parameters: sentence (str): The sentence in English to be translated. dictionary (dict): A dictionary where keys are words in English and values are the corresponding words in the fictional language. Returns: str: The translated sentence in the fictional language. words = sentence.split() translated_words = [dictionary[word] for word in words] return ' '.join(translated_words)"},{"question":"def min_operations_to_one(n: int) -> int: Given a positive integer n, return the minimum number of operations required to reduce the number to 1. >>> min_operations_to_one(10) 4 >>> min_operations_to_one(15) 6 >>> min_operations_to_one(1) 0 >>> min_operations_to_one(0) Traceback (most recent call last): ... Exception: Input number should be a positive integer greater than or equal to 1 from solution import min_operations_to_one def test_min_operations_to_one_basic(): assert min_operations_to_one(10) == 4 # (10->5->4->2->1) => 4 operations def test_min_operations_to_one_medium(): assert min_operations_to_one(15) == 6 # (15->14->7->6->3->2->1) => 6 operations def test_min_operations_to_one_edge(): assert min_operations_to_one(1) == 0 # Already 1, no operations needed def test_min_operations_to_one_minimum_input(): assert min_operations_to_one(2) == 1 # (2->1) => 1 operation def test_min_operations_divides(): assert min_operations_to_one(16) == 4 # (16->8->4->2->1) => 4 operations def test_min_operations_invalid_input(): try: min_operations_to_one(0) except ValueError as e: assert str(e) == \\"Input number should be a positive integer greater than or equal to 1\\" else: assert False, \\"Exception was not raised for invalid input\\" try: min_operations_to_one(-5) except ValueError as e: assert str(e) == \\"Input number should be a positive integer greater than or equal to 1\\" else: assert False, \\"Exception was not raised for invalid input\\"","solution":"def min_operations_to_one(n: int) -> int: Given a positive integer n, return the minimum number of operations required to reduce the number to 1. if n < 1: raise ValueError(\\"Input number should be a positive integer greater than or equal to 1\\") operations = [0] * (n + 1) for i in range(2, n + 1): # Subtract 1 operation op1 = operations[i - 1] + 1 # Divide by 2 operation, if the number is even if i % 2 == 0: op2 = operations[i // 2] + 1 else: op2 = float('inf') # Compute minimum operations for the current number operations[i] = min(op1, op2) return operations[n]"},{"question":"def find_missing_number(nums: list) -> int: Given a list of consecutive integers with exactly one missing number, this function finds the missing number. >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([1, 3, 4, 5]) 2 >>> find_missing_number([2, 3]) 1 >>> find_missing_number([]) 1","solution":"def find_missing_number(nums): Given a list of consecutive integers with exactly one missing number, this function finds the missing number. :param nums: List of integers :return: The missing integer n = len(nums) + 1 total_sum = (n * (n + 1)) // 2 current_sum = sum(nums) return total_sum - current_sum"},{"question":"from typing import List, Optional def max_value_difference(arr: List[int]) -> Optional[int]: This function finds the maximum absolute difference between any two elements in an unsorted array of integers. >>> max_value_difference([1, 2, 3, 4, 5]) 4 >>> max_value_difference([-10, -5, 0, 5, 10]) 20 >>> max_value_difference([1, -1, 2, -2, 3, -3]) 6 >>> max_value_difference([100]) None","solution":"from typing import List, Optional def max_value_difference(arr: List[int]) -> Optional[int]: if len(arr) < 2: return None min_val = min(arr) max_val = max(arr) return abs(max_val - min_val)"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a non-negative integer. >>> factorial(5) == 120 >>> factorial(0) == 1 >>> factorial(-1) == ValueError(\\"Input must be a non-negative integer.\\") def is_prime(number: int) -> bool: Determine if a given number is a prime number. >>> is_prime(11) == True >>> is_prime(4) == False >>> is_prime(1) == False >>> is_prime(-1) == False def gcd(a: int, b: int) -> int: Find the greatest common divisor of two integers using the Euclidean algorithm. >>> gcd(54, 24) == 6 >>> gcd(48, 180) == 12 >>> gcd(0, 5) == 5 >>> gcd(-5, 10) == ValueError(\\"Inputs must be non-negative integers.\\")","solution":"def factorial(n: int) -> int: Calculate the factorial of a non-negative integer n. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") result = 1 for i in range(1, n + 1): result *= i return result def is_prime(number: int) -> bool: Determine if a given number is a prime number. if number < 2: return False for i in range(2, int(number ** 0.5) + 1): if number % i == 0: return False return True def gcd(a: int, b: int) -> int: Find the greatest common divisor of two integers using the Euclidean algorithm. if a < 0 or b < 0: raise ValueError(\\"Inputs must be non-negative integers.\\") while b: a, b = b, a % b return a"},{"question":"from typing import List def max_subarray_sum_divide_and_conquer(nums: List[int]) -> int: Find the maximum sum of a contiguous subarray using the \\"Divide and Conquer\\" approach. Args: nums (List[int]): A list of integers. Returns: int: The maximum sum of a contiguous subarray. Examples: >>> max_subarray_sum_divide_and_conquer([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum_divide_and_conquer([1, 2, 3, 4, -10]) 10 >>> max_subarray_sum_divide_and_conquer([-1, -2, -3, -4]) -1","solution":"from typing import List def max_subarray_sum_divide_and_conquer(nums: List[int]) -> int: def find_max_crossing_subarray(nums, left, mid, right): left_sum = float('-inf') sum = 0 for i in range(mid, left - 1, -1): sum += nums[i] if sum > left_sum: left_sum = sum right_sum = float('-inf') sum = 0 for i in range(mid + 1, right + 1): sum += nums[i] if sum > right_sum: right_sum = sum return left_sum + right_sum def find_maximum_subarray(nums, left, right): if left == right: return nums[left] mid = (left + right) // 2 left_max = find_maximum_subarray(nums, left, mid) right_max = find_maximum_subarray(nums, mid + 1, right) cross_max = find_max_crossing_subarray(nums, left, mid, right) return max(left_max, right_max, cross_max) return find_maximum_subarray(nums, 0, len(nums) - 1)"},{"question":"from typing import List, Tuple def is_path(n: int, edges: List[Tuple[int, int]], src: int, dest: int) -> bool: Determine if there is a path from a given source vertex to a destination vertex in a directed graph using DFS. Args: n (int): Number of vertices. edges (List[Tuple[int, int]]): List of directed edges in the graph. src (int): Source vertex. dest (int): Destination vertex. Returns: bool: True if there is a path from src to dest, False otherwise. Example: >>> is_path(5, [(0, 1), (1, 2), (2, 3), (3, 4)], 0, 4) True >>> is_path(5, [(0, 1), (1, 2), (2, 3), (4, 3)], 0, 4) False pass","solution":"from typing import List, Tuple def is_path(n: int, edges: List[Tuple[int, int]], src: int, dest: int) -> bool: # Create adjacency list for the graph graph = [[] for _ in range(n)] for u, v in edges: graph[u].append(v) # Depth First Search to determine if there is a path from src to dest visited = [False] * n def dfs(vertex): if vertex == dest: return True visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if dfs(neighbor): return True return False return dfs(src)"},{"question":"def highlight_keywords(sentence: str, keywords: list) -> str: Highlight keywords in a sentence by enclosing them with square brackets. :param sentence: A string representing the sentence to process :param keywords: A list of strings representing the keywords to highlight :return: A string with keywords highlighted >>> highlight_keywords(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\"]) 'The [quick] brown fox jumps over the lazy dog' >>> highlight_keywords(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"fox\\"]) 'The [quick] brown [fox] jumps over the lazy dog' >>> highlight_keywords(\\"The quick brown fox jumps over the lazy dog\\", [\\"Quick\\", \\"FOX\\"]) 'The [quick] brown [fox] jumps over the lazy dog' >>> highlight_keywords(\\"The quick brown fox jumps over the lazy dog\\", [\\"cat\\", \\"mouse\\"]) 'The quick brown fox jumps over the lazy dog'","solution":"def highlight_keywords(sentence: str, keywords: list) -> str: Highlight keywords in a sentence by enclosing them with square brackets. :param sentence: A string representing the sentence to process :param keywords: A list of strings representing the keywords to highlight :return: A string with keywords highlighted words = sentence.split() lower_keywords = [keyword.lower() for keyword in keywords] highlighted_sentence = [] for word in words: if word.lower() in lower_keywords: highlighted_sentence.append(f'[{word}]') else: highlighted_sentence.append(word) return ' '.join(highlighted_sentence)"},{"question":"def text_to_morse(text: str) -> str: Converts text to Morse code. >>> text_to_morse(\\"HELLO WORLD\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" >>> text_to_morse(\\"SOS\\") \\"... --- ...\\" >>> text_to_morse(\\"HELLO WORLD 123\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -.. .---- ..--- ...--\\" pass def morse_to_text(morse: str) -> str: Converts Morse code to text. >>> morse_to_text(\\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\") \\"HELLO WORLD\\" >>> morse_to_text(\\"... --- ...\\") \\"SOS\\" >>> morse_to_text(\\".... . .-.. .-.. --- .-- --- .-. .-.. -.. .---- ..--- ...--\\") \\"HELLO WORLD 123\\" pass","solution":"# Morse Code Dictionary MORSE_CODE_DICT = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', ' ': ' ' } # Reverse Morse Code Dictionary for decoding REVERSE_MORSE_CODE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()} def text_to_morse(text: str) -> str: Converts text to Morse code. text = text.upper() morse_code = ' '.join(MORSE_CODE_DICT[char] for char in text) return morse_code def morse_to_text(morse: str) -> str: Converts Morse code to text. words = morse.split(' ') decoded_message = [] for word in words: decoded_message.append(''.join(REVERSE_MORSE_CODE_DICT[char] for char in word.split())) return ' '.join(decoded_message)"},{"question":"from typing import List def subset_sum_zero_exists(nums: List[int]) -> str: Determines if there exists a subset in the list that sums to zero. >>> subset_sum_zero_exists([5, -3, 1, 2, -1, 6]) == \\"YES\\" >>> subset_sum_zero_exists([3, 1, 2, 3]) == \\"NO\\"","solution":"def subset_sum_zero_exists(n, nums): Determines if there exists a subset in the list 'nums' that sums to zero. Parameters: - n (int): The number of integers in the list. - nums (List[int]): The list of integers. Returns: - str: \\"YES\\" if there exists a subset that sums to zero, otherwise \\"NO\\". # A set to store the cumulative sums cumulative_sums = set() # Initial sum current_sum = 0 for num in nums: current_sum += num # Subset with sum zero if we see the current_sum again # (current_sum - some_previous_sum = 0 => current_sum = some_previous_sum) if current_sum == 0 or current_sum in cumulative_sums: return \\"YES\\" cumulative_sums.add(current_sum) return \\"NO\\""},{"question":"from typing import List def majority_element(arr: List[int]) -> int: Returns the majority element from the array if one exists, otherwise returns -1. >>> majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> majority_element([1, 2, 3, 4, 5]) -1 >>> majority_element([3, 3, 3, 3, 1, 2, 3]) 3","solution":"from typing import List def majority_element(arr: List[int]) -> int: Returns the majority element from the array if one exists, otherwise returns -1. candidate = None count = 0 # Step 1: Find a candidate for majority element using Boyer-Moore Voting Algorithm for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # Step 2: Verify that the candidate is indeed the majority element if arr.count(candidate) > len(arr) // 2: return candidate else: return -1"},{"question":"def quantity_differences(quantities: List[int]) -> List[int]: Returns a list of differences between the maximum quantity and each quantity in the original list. max_quantity = max(quantities) return [max_quantity - quantity for quantity in quantities]","solution":"from typing import List def quantity_differences(quantities: List[int]) -> List[int]: Returns a list of differences between the maximum quantity and each quantity in the original list. max_quantity = max(quantities) return [max_quantity - quantity for quantity in quantities]"},{"question":"[Completion Task in Python] ''' Define a function named sum_of_digits_power that takes an integer input number and returns the sum of its digits, each raised to consecutive powers starting from 2. If the number is negative, the function should raise a ValueError with the message \\"Number must be non-negative\\". Function signature: **def sum_of_digits_power(number: int) -> int:** Example *Inputs*: print(sum_of_digits_power(1234)) # Expected output: 1^2 + 2^3 + 3^4 + 4^5 = 1 + 8 + 81 + 1024 = 1114 print(sum_of_digits_power(56)) # Expected output: 5^2 + 6^3 = 25 + 216 = 241 *Outputs*: 1114 241 ''' # Complete the Python function \`sum_of_digits_power\` below. def sum_of_digits_power(number: int) -> int: Calculates the sum of the digits of a number, each raised to consecutive powers starting from 2. Args: number (int): A non-negative integer. Returns: int: Sum of the digits each raised to consecutive powers starting from 2. Raises: ValueError: If the \`number\` is negative. if number < 0: raise ValueError(\\"Number must be non-negative\\") total_sum = 0 for power, digit in enumerate(str(number), start=2): total_sum += int(digit) ** power return total_sum def test_sum_of_digits_power(): # Valid cases assert sum_of_digits_power(1234) == 1114 assert sum_of_digits_power(56) == 241 assert sum_of_digits_power(0) == 0 assert sum_of_digits_power(9) == 81 assert sum_of_digits_power(2345) == 1149 # Edge case assert sum_of_digits_power(1) == 1 assert sum_of_digits_power(10) == 1 # Invalid cases try: sum_of_digits_power(-1) except ValueError as e: assert str(e) == \\"Number must be non-negative\\" try: sum_of_digits_power(-123) except ValueError as e: assert str(e) == \\"Number must be non-negative\\"","solution":"def sum_of_digits_power(number): Calculates the sum of the digits of a number, each raised to consecutive powers starting from 2. Args: number (int): A non-negative integer. Returns: int: Sum of the digits each raised to consecutive powers starting from 2. Raises: ValueError: If the \`number\` is negative. if number < 0: raise ValueError(\\"Number must be non-negative\\") total_sum = 0 for power, digit in enumerate(str(number), start=2): total_sum += int(digit) ** power return total_sum"},{"question":"def sort_string_characters(s: str) -> str: Sort the characters in the input string such that all alphabetical characters come first, followed by digits. Both groups are sorted in ascending order. Parameters: s (str): The input string containing alphabetical characters and digits. Returns: str: A string with sorted characters where alphabetical characters come first, followed by digits in ascending order. >>> sort_string_characters(\\"d3c2b1a4\\") == \\"abcd1234\\" >>> sort_string_characters(\\"A1B2C3\\") == \\"ABC123\\" >>> sort_string_characters(\\"z9y8x7\\") == \\"xyz789\\" >>> sort_string_characters(\\"dcba\\") == \\"abcd\\" >>> sort_string_characters(\\"4321\\") == \\"1234\\" >>> sort_string_characters(\\"a1A2\\") == \\"Aa12\\" >>> sort_string_characters(\\"\\") == \\"\\" >>> sort_string_characters(\\"a\\" * 1000 + \\"1\\" * 1000) == \\"a\\" * 1000 + \\"1\\" * 1000","solution":"def sort_string_characters(s: str) -> str: Sort the characters in the input string such that all alphabetical characters come first, followed by digits. Both groups are sorted in ascending order. Parameters: s (str): The input string containing alphabetical characters and digits. Returns: str: A string with sorted characters where alphabetical characters come first, followed by digits in ascending order. alphabets = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: alphabets.append(char) sorted_alphabets = ''.join(sorted(alphabets)) sorted_digits = ''.join(sorted(digits)) return sorted_alphabets + sorted_digits"},{"question":"from collections import deque, defaultdict class Graph: def __init__(self, N: int, edges: List[Tuple[int, int]]): Initialize the graph with N nodes and a list of edges. Args: N (int): Number of nodes in the graph. edges (List[Tuple[int, int]]): List of edges where each edge is represented as a tuple (u, v). def dfs(self, start: int) -> List[int]: Perform a depth-first search (DFS) starting from a given node. Args: start (int): The starting node for DFS. Returns: List[int]: List of nodes in the order they are visited. def bfs(self, start: int) -> List[int]: Perform a breadth-first search (BFS) starting from a given node. Args: start (int): The starting node for BFS. Returns: List[int]: List of nodes in the order they are visited. def shortest_path(self, start: int, end: int) -> int: Calculate the length of the shortest path between two nodes using BFS. Args: start (int): The starting node. end (int): The ending node. Returns: int: Length of the shortest path between the start and end nodes. If no path exists, return -1. # Example usage and testing edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)] graph = Graph(5, edges) # DFS traversal dfs_result = graph.dfs(0) print(dfs_result) # Output example: [0, 1, 2, 4, 3] # BFS traversal bfs_result = graph.bfs(0) print(bfs_result) # Output example: [0, 1, 2, 3, 4] # Shortest path calculation shortest_path_result = graph.shortest_path(0, 4) print(shortest_path_result) # Output example: 2 shortest_path_result = graph.shortest_path(0, 3) print(shortest_path_result) # Output example: 2 shortest_path_result = graph.shortest_path(3, 0) print(shortest_path_result) # Output example: 2 shortest_path_result = graph.shortest_path(0, 6) print(shortest_path_result) # Output example: -1 (assuming nonexistent paths return -1)","solution":"from collections import deque, defaultdict class Graph: def __init__(self, N, edges): self.N = N self.adj_list = defaultdict(list) for u, v in edges: self.adj_list[u].append(v) self.adj_list[v].append(u) def dfs(self, start): visited = set() result = [] self._dfs_util(start, visited, result) return result def _dfs_util(self, node, visited, result): if node in visited: return visited.add(node) result.append(node) for neighbor in self.adj_list[node]: self._dfs_util(neighbor, visited, result) def bfs(self, start): visited = set() result = [] queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) result.append(node) for neighbor in self.adj_list[node]: queue.append(neighbor) return result def shortest_path(self, start, end): if start == end: return 0 visited = set() queue = deque([(start, 0)]) while queue: node, distance = queue.popleft() if node == end: return distance if node not in visited: visited.add(node) for neighbor in self.adj_list[node]: queue.append((neighbor, distance + 1)) return -1 # if no path is found"},{"question":"def unique_paths(m: int, n: int) -> int: Given a grid of size \`m x n\`, where you can only move to the right or down from a given cell, find the number of unique paths to get from the top-left corner \`(0, 0)\` to the bottom-right corner \`(m-1, n-1)\`. >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 7) 28 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths in a m x n grid. # Create a 2D array initialized to 1s for the base cases (first row and first column) dp = [[1] * n for _ in range(m)] # Fill in the dp array using the recurrence relation for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the answer return dp[m-1][n-1]"},{"question":"import pytest def first_non_repeated_character(s: str) -> str: Implement the function first_non_repeated_character that retrieves the first character in a string that does not repeat later. If all characters repeat or if the string is empty, it returns an empty string. It should handle both lowercase and uppercase letters as distinct and raise a ValueError for any invalid characters. Args: s (str): Input string containing only letters. Returns: str: The first non-repeated character or an empty string if none exists. Raises: ValueError: If input string contains non-letter characters. Examples: >>> first_non_repeated_character(\\"swiss\\") 'w' >>> first_non_repeated_character(\\"character\\") 'c' >>> first_non_repeated_character(\\"aabbcc\\") '' >>> first_non_repeated_character(\\"\\") '' >>> first_non_repeated_character(\\"Engineering\\") 'E' pass def test_first_non_repeated_character_basic(): assert first_non_repeated_character(\\"swiss\\") == \\"w\\" def test_first_non_repeated_character_mixed_case(): assert first_non_repeated_character(\\"Engineering\\") == \\"E\\" def test_first_non_repeated_character_repeated_characters(): assert first_non_repeated_character(\\"aabbcc\\") == \\"\\" def test_first_non_repeated_character_single_character(): assert first_non_repeated_character(\\"a\\") == \\"a\\" def test_first_non_repeated_character_empty_string(): assert first_non_repeated_character(\\"\\") == \\"\\" def test_first_non_repeated_character_with_invalid_characters(): with pytest.raises(ValueError, match=r'Invalid character in input string'): first_non_repeated_character(\\"abc123\\") def test_first_non_repeated_character_all_repeated(): assert first_non_repeated_character(\\"aabbccddeeff\\") == \\"\\" def test_first_non_repeated_character_middle_non_repeated(): assert first_non_repeated_character(\\"aabbccddeeafg\\") == \\"f\\" def test_first_non_repeated_character_first_non_repeated(): assert first_non_repeated_character(\\"abcdabcdem\\") == \\"e\\"","solution":"def first_non_repeated_character(s: str) -> str: if not s: return '' # Check for invalid characters if not s.isalpha(): raise ValueError(\\"Invalid character in input string. Only letters are allowed.\\") char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find and return the first non-repeated character for char in s: if char_count[char] == 1: return char return '' # Sample run to verify code # print(first_non_repeated_character(\\"swiss\\")) # should return \\"w\\" # print(first_non_repeated_character(\\"aabbcc\\")) # should return \\"\\""},{"question":"def is_match(s: str, p: str) -> bool: Checks if the given pattern matches the entire string. :param s: A string to be matched. :param p: A pattern string which may contain the special characters '?' and '*'. :return: True if the pattern matches the entire string; otherwise, False. Example: >>> is_match(\\"adceb\\", \\"*a*b\\") True >>> is_match(\\"acdcb\\", \\"a*c?b\\") False >>> is_match(\\"aa\\", \\"a\\") False >>> is_match(\\"aa\\", \\"*\\") True >>> is_match(\\"cb\\", \\"?a\\") False >>> is_match(\\"abcd\\", \\"a*d\\") True","solution":"def is_match(s: str, p: str) -> bool: Checks if the given pattern matches the entire string. :param s: A string to be matched. :param p: A pattern string which may contain the special characters '?' and '*'. :return: True if the pattern matches the entire string; otherwise, False. m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '*': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif p[j - 1] == '?' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"from typing import List def max_subsequence_diff(arr: List[int]) -> int: Given an array of positive integers, finds a subsequence where the difference between the maximum and minimum elements in the subsequence is maximized. Returns the maximum difference found. >>> max_subsequence_diff([1, 2, 3, 4]) 3 >>> max_subsequence_diff([10, 20, 30, 40]) 30 >>> max_subsequence_diff([100, 200, 300, 400, 500]) 400","solution":"from typing import List def max_subsequence_diff(arr: List[int]) -> int: Returns the maximum difference between the maximum and minimum elements of any subsequence in the input list. if not arr: return 0 max_elem = max(arr) min_elem = min(arr) return max_elem - min_elem"},{"question":"from collections import Counter def word_frequency_analysis(sentence: str) -> dict: Analyze the given sentence and determine the frequency of each word. Args: sentence (str): A sentence where words are separated by spaces. Returns: dict: A dictionary where keys are words and values are their frequencies, including a key 'most_frequent_word' which corresponds to the most frequent word. Examples: >>> word_frequency_analysis(\\"the quick brown fox jumps over the lazy dog\\") {'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1, 'most_frequent_word': 'the'} >>> word_frequency_analysis(\\"hello world hello\\") {'hello': 2, 'world': 1, 'most_frequent_word': 'hello'} >>> word_frequency_analysis(\\"apple apple apple banana banana\\") {'apple': 3, 'banana': 2, 'most_frequent_word': 'apple'} def test_word_frequency_analysis_simple(): assert word_frequency_analysis(\\"the quick brown fox jumps over the lazy dog\\") == { 'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1, 'most_frequent_word': 'the' } def test_word_frequency_analysis_tie(): assert word_frequency_analysis(\\"hello world hello\\") == { 'hello': 2, 'world': 1, 'most_frequent_word': 'hello' } def test_word_frequency_analysis_all_same_word(): assert word_frequency_analysis(\\"apple apple apple banana banana\\") == { 'apple': 3, 'banana': 2, 'most_frequent_word': 'apple' } def test_word_frequency_analysis_single_word(): assert word_frequency_analysis(\\"hello\\") == { 'hello': 1, 'most_frequent_word': 'hello' } def test_word_frequency_analysis_identify_word_with_same_count(): assert word_frequency_analysis(\\"a b c a b c a\\") == { 'a': 3, 'b': 2, 'c': 2, 'most_frequent_word': 'a' } def test_word_frequency_analysis_long_sentence(): sentence = \\"example sentence to test long sentence to test the function's handling of various lengths test test long\\" result = word_frequency_analysis(sentence) expected_result = { 'example': 1, 'sentence': 2, 'to': 2, 'test': 4, 'long': 2, 'the': 1, 'function's': 1, 'handling': 1, 'of': 1, 'various': 1, 'lengths': 1, 'most_frequent_word': 'test' } assert result == expected_result def test_word_frequency_analysis_no_duplicate_words(): assert word_frequency_analysis(\\"each word appears only once\\") == { 'each': 1, 'word': 1, 'appears': 1, 'only': 1, 'once': 1, 'most_frequent_word': 'each' }","solution":"from collections import Counter def word_frequency_analysis(sentence: str) -> dict: words = sentence.split() word_counts = Counter(words) # Identify the most frequently occurring word most_frequent_word = '' highest_frequency = 0 for word in words: if word_counts[word] > highest_frequency: most_frequent_word = word highest_frequency = word_counts[word] # Convert the Counter object to a dictionary and add most_frequent_word key result = dict(word_counts) result['most_frequent_word'] = most_frequent_word return result"},{"question":"def transpose_matrix(matrix): Returns the transpose of a given 2D matrix. Parameters: matrix (list of list of int): A 2D list representing the matrix to transpose. Returns: list of list of int: A 2D list representing the transposed matrix. Examples: >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4]]) [[1, 3], [2, 4]] >>> transpose_matrix([[1], [2], [3]]) [[1, 2, 3]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([]) []","solution":"def transpose_matrix(matrix): Returns the transpose of a given 2D matrix. Parameters: matrix (list of list of int): A 2D list representing the matrix to transpose. Returns: list of list of int: A 2D list representing the transposed matrix. if not matrix: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"class TrieNode: pass class Trie: def __init__(self): Initialize your data structure here. pass def insert(self, phrase: str) -> None: Inserts a phrase into the trie. >>> trie = Trie() >>> trie.insert(\\"hello world\\") pass def count_occurrences(self, phrase: str) -> int: Returns the number of times a given phrase appears in the Trie. >>> trie = Trie() >>> trie.insert(\\"hello world\\") >>> trie.count_occurrences(\\"hello world\\") 1 pass def most_frequent_phrases(self, n: int) -> list: Returns the top N most frequent phrases in the Trie. >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.insert(\\"hello world\\") >>> trie.most_frequent_phrases(1) [\\"hello\\"] pass","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_phrase = False self.count = 0 class Trie: def __init__(self): self.root = TrieNode() self.phrase_count = {} def insert(self, phrase): node = self.root for char in phrase: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_phrase = True node.count += 1 if phrase in self.phrase_count: self.phrase_count[phrase] += 1 else: self.phrase_count[phrase] = 1 def count_occurrences(self, phrase): node = self.root for char in phrase: if char not in node.children: return 0 node = node.children[char] if node.is_end_of_phrase: return node.count return 0 def most_frequent_phrases(self, n): return sorted(self.phrase_count.keys(), key=lambda x: (-self.phrase_count[x], x))[:n]"},{"question":"def rename_file(filenames: list, new_filename: str) -> str: Appends a numeric suffix to the new_filename if it exists in filenames. >>> rename_file([\\"file.txt\\", \\"file_1.txt\\"], \\"file.txt\\") 'file_2.txt' >>> rename_file([\\"document.doc\\", \\"document_1.doc\\"], \\"document.doc\\") 'document_2.doc' >>> rename_file([\\"image.png\\", \\"image_2.png\\"], \\"image.png\\") 'image_1.png' >>> rename_file([], \\"new_file.txt\\") 'new_file.txt' >>> rename_file([\\"data.csv\\"], \\"data.csv\\") 'data_1.csv'","solution":"def rename_file(filenames, new_filename): Appends a numeric suffix to the new_filename if it exists in filenames. if new_filename not in filenames: return new_filename base, ext = new_filename.rsplit('.', 1) counter = 1 unique_filename = f\\"{base}_{counter}.{ext}\\" while unique_filename in filenames: counter += 1 unique_filename = f\\"{base}_{counter}.{ext}\\" return unique_filename"},{"question":"def generate_fibonacci_sequence(n: int) -> list: Generates the first n numbers of the Fibonacci sequence. Args: n (int): The number of terms to generate. Returns: list: A list containing the first n numbers of the Fibonacci sequence. >>> generate_fibonacci_sequence(1) [0] >>> generate_fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> generate_fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def generate_fibonacci_sequence(n: int) -> list: Generates the first n numbers of the Fibonacci sequence. Args: n (int): The number of terms to generate. Returns: list: A list containing the first n numbers of the Fibonacci sequence. if n == 1: return [0] fibonacci_sequence = [0, 1] for i in range(2, n): next_value = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_value) return fibonacci_sequence"},{"question":"def kth_smallest(arr: List[int], k: int) -> int: Find the kth smallest element in an unsorted list using the Quickselect algorithm. >>> kth_smallest([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest([7, 10, 4, 3, 20, 15], 4) 10 >>> kth_smallest([1, 2, 3, 4, 5], 5) 5 >>> kth_smallest([5, 4, 3, 2, 1], 1) 1 >>> kth_smallest([7, 2, 1, 0, 5, 4, 3, 8, 9, 6], 5) 4 >>> kth_smallest([42], 1) 42 >>> kth_smallest([1, 2, 3, 4, 5], 2) 2 >>> kth_smallest([3, 1, 2, 2, 4], 2) 2 >>> kth_smallest([3, 3, 3, 3, 3], 3) 3 >>> kth_smallest([1, 3, 5, 2, 4, 6], 6) 6 pass","solution":"def kth_smallest(arr, k): Find the kth smallest element in an unsorted list using the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): # If the list contains only one element, return that element if left == right: return arr[left] # Select a random pivot_index between left and right pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] # Go left elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) # Go right else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"import requests from datetime import datetime, timedelta def top_voted_questions(tag: str, time_period: str) -> list | None: Fetches and returns the list of the top voted questions from Stack Overflow for a given tag within a specified time period. Parameters: tag (str): A string representing the tag to filter the questions by. time_period (str): A string representing the time period to filter the questions by. It can be either \\"day\\", \\"week\\", or \\"month\\". Returns: list | None: A list of dictionaries, where each dictionary contains: { \\"question_title\\": \\"Question Title\\", \\"question_score\\": Score, \\"question_link\\": \\"https://stackoverflow.com/questions/{question_id}\\" } If the input is invalid or an error occurs during fetching or parsing, the function should return \`None\`. >>> top_voted_questions(\\"python\\", \\"week\\") [{'question_title': 'What is the difference between semicolons and newlines in Python?', 'question_score': 543, 'question_link': 'https://stackoverflow.com/questions/12345678'}, {'question_title': 'How do I use the map function in Python?', 'question_score': 389, 'question_link': 'https://stackoverflow.com/questions/23456789'}, ...] Unit Test: from solution import top_voted_questions def test_invalid_tag(): assert top_voted_questions(\\"\\", \\"day\\") is None assert top_voted_questions(\\"\\", \\"week\\") is None assert top_voted_questions(\\"\\", \\"month\\") is None def test_invalid_time_period(): assert top_voted_questions(\\"python\\", \\"\\") is None assert top_voted_questions(\\"python\\", \\"year\\") is None def test_valid_inputs(): result = top_voted_questions(\\"python\\", \\"week\\") assert isinstance(result, list) if result: question = result[0] assert \\"question_title\\" in question assert \\"question_score\\" in question assert \\"question_link\\" in question def test_network_error(monkeypatch): class MockResponse: @staticmethod def raise_for_status(): raise requests.HTTPError(\\"HTTP Error\\") def mock_get(*args, **kwargs): return MockResponse() monkeypatch.setattr(requests, \\"get\\", mock_get) assert top_voted_questions(\\"python\\", \\"week\\") is None def test_valid_response(monkeypatch): class MockResponse: @staticmethod def json(): return { \\"items\\": [ { \\"title\\": \\"Example Question\\", \\"score\\": 100, \\"question_id\\": 12345 } ] } @staticmethod def raise_for_status(): pass def mock_get(*args, **kwargs): return MockResponse() monkeypatch.setattr(requests, \\"get\\", mock_get) result = top_voted_questions(\\"python\\", \\"week\\") assert isinstance(result, list) if result: question = result[0] assert question[\\"question_title\\"] == \\"Example Question\\" assert question[\\"question_score\\"] == 100 assert question[\\"question_link\\"] == \\"https://stackoverflow.com/questions/12345\\" pass","solution":"import requests from datetime import datetime, timedelta def top_voted_questions(tag: str, time_period: str) -> list | None: if not tag or time_period not in {\\"day\\", \\"week\\", \\"month\\"}: return None end_date = int(datetime.now().timestamp()) if time_period == \\"day\\": start_date = int((datetime.now() - timedelta(days=1)).timestamp()) elif time_period == \\"week\\": start_date = int((datetime.now() - timedelta(days=7)).timestamp()) elif time_period == \\"month\\": start_date = int((datetime.now() - timedelta(days=30)).timestamp()) url = f\\"https://api.stackexchange.com/2.3/questions?order=desc&sort=votes&tagged={tag}&site=stackoverflow&fromdate={start_date}&todate={end_date}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() questions = [] for item in data.get(\\"items\\", []): question = { \\"question_title\\": item[\\"title\\"], \\"question_score\\": item[\\"score\\"], \\"question_link\\": f'https://stackoverflow.com/questions/{item[\\"question_id\\"]}' } questions.append(question) return questions except (requests.RequestException, KeyError, ValueError): return None"},{"question":"def rotate_90_clockwise(mat: List[List[int]]) -> List[List[int]]: Rotate the given matrix 90 degrees clockwise. >>> rotate_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def can_rotate_to_match(mat1: List[List[int]], mat2: List[List[int]]) -> bool: Determine if mat1 can be rotated 90 degrees clockwise multiple times to become equal to mat2. >>> can_rotate_to_match([[1, 2], [3, 4]], [[3, 1], [4, 2]]) True >>> can_rotate_to_match([[1, 2], [3, 4]], [[2, 4], [1, 3]]) False >>> can_rotate_to_match([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]]) True >>> can_rotate_to_match([[1]], [[1]]) True >>> can_rotate_to_match([[1, 3], [2, 4]], [[1, 2], [3, 4]]) False","solution":"def rotate_90_clockwise(mat): Rotate the given matrix 90 degrees clockwise. n = len(mat) return [[mat[n - j - 1][i] for j in range(n)] for i in range(n)] def can_rotate_to_match(mat1, mat2): Returns whether mat1 can be rotated to match mat2. if len(mat1) != len(mat2) or len(mat1[0]) != len(mat2[0]): return False rotated_mat = mat1 for _ in range(4): if rotated_mat == mat2: return True rotated_mat = rotate_90_clockwise(rotated_mat) return False"},{"question":"def merge_csv_files(input_files: List[str], output_file: str) -> None: Merges multiple CSV files into a single CSV file. Parameters: - input_files (list of str): List of filenames for the input CSV files. - output_file (str): Filename for the output CSV file where the merged data will be saved. pass # Example usage: input_files = ['file1.csv', 'file2.csv'] output_file = 'merged.csv' merge_csv_files(input_files, output_file) # The content of merged.csv should be: # name,age # Alice,30 # Bob,25 # Carol,27 # David,22","solution":"def merge_csv_files(input_files, output_file): Merges multiple CSV files into a single CSV file. Parameters: - input_files (list of str): List of filenames for the input CSV files. - output_file (str): Filename for the output CSV file where the merged data will be saved. if not input_files: return # Open the output file in write mode with open(output_file, 'w') as outfile: header_written = False for file in input_files: with open(file, 'r') as infile: # Read the lines from the input file lines = infile.readlines() # Write the header if not already written # (header is the first line of the first file) if not header_written: outfile.write(lines[0]) header_written = True # Write the rest of the lines (excluding header) outfile.writelines(lines[1:])"},{"question":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: Calculate the minimum path sum from the top-left to the bottom-right of the matrix. >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 >>> min_path_sum([]) 0 >>> min_path_sum([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 0","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Create a DP table with the same dimensions as the input matrix dp = [[0]*n for _ in range(m)] # Initialize the DP table with the cost of the first cell dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner contains the minimum path sum return dp[m-1][n-1]"},{"question":"import pandas as pd from typing import Dict def summarize_transactions(file_path: str) -> Dict[str, float]: Summarizes the transaction data by reading the CSV file and calculating the sum of each column. :param file_path: Path to the CSV file containing transaction records. :return: A dictionary where keys are the column names and values are the sum of the values in each column. Example: >>> summarize_transactions(\\"path_to_transactions.csv\\") {\\"column1\\": 123456.78, \\"column2\\": 98765.43, ...} def test_summarize_transactions(): import pandas as pd import os def create_test_csv(file_path, data): df = pd.DataFrame(data) df.to_csv(file_path, index=False) # Create a temporary CSV file test_file_path = 'test_transactions.csv' test_data = { 'column1': [10.5, 20.75, 30.25], 'column2': [5.5, 15.25, 25.75], 'column3': [100.0, 200.0, 300.0] } create_test_csv(test_file_path, test_data) # Expected result expected_result = { 'column1': 61.5, 'column2': 46.5, 'column3': 600.0 } # Run the function result = summarize_transactions(test_file_path) # Check the result assert result == expected_result # Clean up the test file os.remove(test_file_path) def test_summarize_transactions_empty(): import pandas as pd import os def create_test_csv(file_path, data): df = pd.DataFrame(data) df.to_csv(file_path, index=False) # Create an empty temporary CSV file test_file_path = 'test_transactions_empty.csv' test_data = {'column1': [], 'column2': [], 'column3': []} create_test_csv(test_file_path, test_data) # Expected result expected_result = { 'column1': 0.0, 'column2': 0.0, 'column3': 0.0 } # Run the function result = summarize_transactions(test_file_path) # Check the result assert result == expected_result # Clean up the test file os.remove(test_file_path)","solution":"import pandas as pd from typing import Dict def summarize_transactions(file_path: str) -> Dict[str, float]: Summarizes the transaction data by reading the CSV file and calculating the sum of each column. :param file_path: Path to the CSV file containing transaction records. :return: A dictionary where keys are the column names and values are the sum of the values in each column. df = pd.read_csv(file_path) summary = df.sum().to_dict() return {column: round(total, 2) for column, total in summary.items()}"},{"question":"import random def sgd_optimizer(initial_param: float, learning_rate: float, num_iterations: int, random_seed: int = None) -> float: Simulates a simple stochastic gradient descent (SGD) optimization process for minimizing a quadratic cost function J(theta) = (theta - 5)^2. Parameters: initial_param (float): The starting value of the parameter to be optimized. learning_rate (float): The step size used in each iteration to update the parameter. num_iterations (int): The number of iterations to perform the optimization. random_seed (int, optional): An optional parameter to set the seed for reproducibility. Returns: float: The optimized parameter value after performing SGD. >>> 4.9 < sgd_optimizer(0.0, 0.1, 100, 42) < 5.1 True >>> 4.9 < sgd_optimizer(-10.0, 0.01, 1000) < 5.1 True","solution":"import random def sgd_optimizer(initial_param: float, learning_rate: float, num_iterations: int, random_seed: int = None) -> float: if random_seed is not None: random.seed(random_seed) theta = initial_param for _ in range(num_iterations): gradient = 2 * (theta - 5) theta = theta - learning_rate * gradient return theta"},{"question":"def has_cycle(graph: dict) -> bool: Determines if a cycle exists in the directed graph represented by the adjacency list. :param graph: Dictionary representing the adjacency list of the graph :return: True if a cycle exists, False otherwise >>> graph1 = { ... \\"A\\": [\\"B\\"], ... \\"B\\": [\\"C\\"], ... \\"C\\": [\\"A\\"] ... } >>> has_cycle(graph1) True >>> graph2 = { ... \\"A\\": [\\"B\\"], ... \\"B\\": [\\"C\\"], ... \\"C\\": [] ... } >>> has_cycle(graph2) False >>> graph3 = { ... \\"A\\": [\\"B\\", \\"C\\"], ... \\"B\\": [], ... \\"C\\": [\\"D\\"], ... \\"D\\": [\\"A\\"] ... } >>> has_cycle(graph3) True >>> graph4 = { ... \\"A\\": [\\"B\\"], ... \\"B\\": [\\"C\\"], ... \\"C\\": [\\"D\\"], ... \\"D\\": [] ... } >>> has_cycle(graph4) False","solution":"def has_cycle(graph): Determines if a cycle exists in the directed graph represented by the adjacency list. :param graph: Dictionary representing the adjacency list of the graph :return: True if a cycle exists, False otherwise def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False visited = {node: False for node in graph} rec_stack = {node: False for node in graph} for node in graph: if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"from typing import List def top_k_average(scores: List[int], K: int) -> float: Returns the average of the top K scores in the given list. If there are fewer than K scores, return the average of all the scores present. Args: scores (List[int]): List of integer scores. K (int): The number of top scores to consider for the average. Returns: float: The average of the top K scores. Examples: >>> abs(top_k_average([5, 3, 8, 6, 2], 3) - 6.3333) < 0.0001 True >>> top_k_average([1, 2, 3], 5) == 2.0 True >>> top_k_average([4, 4, 4, 4], 2) == 4.0 True >>> top_k_average([10], 1) == 10.0 True >>> top_k_average([], 3) == 0.0 True","solution":"from typing import List def top_k_average(scores: List[int], K: int) -> float: Returns the average of the top K scores in the given list. If there are fewer than K scores, return the average of all the scores present. Args: scores (List[int]): List of integer scores. K (int): The number of top scores to consider for the average. Returns: float: The average of the top K scores. if not scores: return 0.0 if K > len(scores): K = len(scores) # Sorting the scores in descending order sorted_scores = sorted(scores, reverse=True) # Taking the top K scores top_k_scores = sorted_scores[:K] # Calculating the average of the top K scores average = sum(top_k_scores) / K return average"},{"question":"def find_unique_element(arr: List[int]) -> int: Finds the unique element in an array where every other element appears exactly twice. Args: arr (List[int]): List of integers where each element appears exactly twice except for one. Returns: int: The unique element. >>> find_unique_element([1, 2, 4, 2, 1]) 4 >>> find_unique_element([7, 3, 5, 4, 5, 3, 7]) 4 >>> find_unique_element([9, 9, 1, 2, 2, 1, 8]) 8 >>> find_unique_element([10]) 10","solution":"def find_unique_element(arr): Finds the unique element in an array where every other element appears exactly twice. Args: arr (List[int]): List of integers where each element appears exactly twice except for one. Returns: int: The unique element. unique_elem = 0 for num in arr: unique_elem ^= num return unique_elem"},{"question":"def are_disjoint_sets(set1: list[int], set2: list[int]) -> bool: Function to determine if two sets of integers are disjoint. Parameters: set1 (list[int]): The first set of integers. set2 (list[int]): The second set of integers. Returns: bool: True if the sets are disjoint, False otherwise. Examples: >>> are_disjoint_sets([1, 2, 3, 4], [5, 6, 7, 8]) True >>> are_disjoint_sets([1, 2, 3], [3, 4, 5]) False >>> are_disjoint_sets([], []) True >>> are_disjoint_sets([1, 1, 1, 1], [2, 2, 2, 2]) True from solution import are_disjoint_sets def test_both_sets_empty(): assert are_disjoint_sets([], []) == True def test_one_set_empty(): assert are_disjoint_sets([1, 2, 3], []) == True assert are_disjoint_sets([], [4, 5, 6]) == True def test_disjoint_sets(): assert are_disjoint_sets([1, 2, 3, 4], [5, 6, 7, 8]) == True assert are_disjoint_sets([-10**9, 0, 10**9], [-1, 1, 2, 3]) == True def test_non_disjoint_sets(): assert are_disjoint_sets([1, 2, 3], [3, 4, 5]) == False assert are_disjoint_sets([-10**9, 0, 10**9], [10**9]) == False def test_sets_with_duplicates(): assert are_disjoint_sets([1, 1, 1, 1], [2, 2, 2, 2]) == True assert are_disjoint_sets([1, 1, 1, 1], [1, 2, 2, 2]) == False","solution":"def are_disjoint_sets(set1: list[int], set2: list[int]) -> bool: Function to determine if two sets of integers are disjoint. Parameters: set1 (list[int]): The first set of integers. set2 (list[int]): The second set of integers. Returns: bool: True if the sets are disjoint, False otherwise. # Convert both lists to sets set1_as_set = set(set1) set2_as_set = set(set2) # Check if the intersection of both sets is empty return set1_as_set.isdisjoint(set2_as_set)"},{"question":"def optimized_longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between s1 and s2. >>> optimized_longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> optimized_longest_common_subsequence(\\"\\", \\"GXTXAYB\\") 0 >>> optimized_longest_common_subsequence(\\"AGGTAB\\", \\"\\") 0 >>> optimized_longest_common_subsequence(\\"ABCDE\\", \\"ACE\\") 3 >>> optimized_longest_common_subsequence(\\"ABCDEF\\", \\"AF\\") 2 >>> optimized_longest_common_subsequence(\\"ABC\\", \\"DEF\\") 0 >>> optimized_longest_common_subsequence(\\"A\\", \\"A\\") 1 >>> optimized_longest_common_subsequence(\\"A\\", \\"B\\") 0 >>> optimized_longest_common_subsequence(\\"ABCD\\", \\"ABCD\\") 4 >>> optimized_longest_common_subsequence(\\"A\\" * 1000, \\"A\\" * 1000) 1000 >>> optimized_longest_common_subsequence(\\"A\\" * 1000, \\"B\\" * 1000) 0 >>> optimized_longest_common_subsequence(\\"ABC\\" * 333, \\"ABC\\" * 333) 999","solution":"def optimized_longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between s1 and s2. Uses a space-optimized dynamic programming approach that only keeps the current and previous row of the DP table. n = len(s1) m = len(s2) if n == 0 or m == 0: return 0 # We only need two rows, current and previous previous = [0] * (m + 1) current = [0] * (m + 1) for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: current[j] = previous[j - 1] + 1 else: current[j] = max(previous[j], current[j - 1]) # Move to the next row previous, current = current, previous return previous[m]"},{"question":"def compress_string(input_string: str) -> str: Compresses a given string by replacing repeated consecutive characters with their corresponding character followed by their count. If the compressed string is not shorter than the original string, return the original string. Parameters: input_string (str): The string that needs to be compressed. Returns: str: The compressed string or the original string if compression doesn't make it shorter. Examples: >>> compress_string(\\"aaabbcccc\\") 'a3b2c4' >>> compress_string(\\"abcd\\") 'abcd'","solution":"def compress_string(input_string: str) -> str: Compresses the string by replacing consecutive repeated characters with the character followed by the number of repetitions. If the compressed string is not shorter than the original string, returns the original string. Parameters: input_string (str): The string to be compressed. Returns: str: The compressed string or the original string if compression doesn't make it shorter. if not input_string: return input_string compressed = [] count = 1 n = len(input_string) for i in range(1, n): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 # Append the last set of characters compressed.append(input_string[-1] + str(count)) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < n else input_string"},{"question":"def reverse_words(s: str) -> str: Reverse the order of words in a string while preserving spaces. Parameters ---------- s: str A string which may contain leading, trailing, or multiple spaces between words. Returns ------- str A new string with the words reversed. >>> reverse_words(\\"The quick brown fox\\") 'fox brown quick The' >>> reverse_words(\\" hello world \\") 'world hello' >>> reverse_words(\\"a good example\\") 'example good a' >>> reverse_words(\\" no spaces\\") 'spaces no' >>> reverse_words(\\"single\\") 'single' # Tests def test_reverse_words(): assert reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" assert reverse_words(\\" hello world \\") == \\"world hello\\" assert reverse_words(\\"a good example\\") == \\"example good a\\" assert reverse_words(\\" no spaces\\") == \\"spaces no\\" assert reverse_words(\\"single\\") == \\"single\\" def test_reverse_words_leading_trailing_spaces(): assert reverse_words(\\" leading space\\") == \\"space leading\\" assert reverse_words(\\"trailing space \\") == \\"space trailing\\" assert reverse_words(\\" leading and trailing spaces \\") == \\"spaces trailing and leading\\" def test_reverse_words_only_spaces(): assert reverse_words(\\" \\") == \\"\\" assert reverse_words(\\" a \\") == \\"a\\" assert reverse_words(\\"a \\") == \\"a\\" assert reverse_words(\\" a\\") == \\"a\\" def test_reverse_words_special_characters(): assert reverse_words(\\"!@# %^ &*()\\") == \\"&*() %^ !@#\\" assert reverse_words(\\"1 2 3 4 5\\") == \\"5 4 3 2 1\\" def test_reverse_words_mixed(): assert reverse_words(\\" 123 abc !@#xyz\\") == \\"!@#xyz abc 123\\" assert reverse_words(\\" spaced words out \\") == \\"out words spaced\\"","solution":"def reverse_words(s: str) -> str: Reverse the order of words in a string while preserving spaces. Parameters ---------- s: str A string which may contain leading, trailing, or multiple spaces between words. Returns ------- str A new string with the words reversed. # Split the string into words treating spaces as delimiters words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed words with a single space in between return ' '.join(reversed_words)"},{"question":"from typing import List def minimize_adjacent_sum(nums: List[int]) -> List[int]: Determine if it is possible to rearrange the elements of nums such that the sum of the absolute differences between all adjacent elements is minimized. If possible, return the rearranged array. If multiple rearrangements provide the same sum, return the lexicographically smallest one. If it is not possible to rearrange the elements (for example, if the array has less than two elements), return an empty array. >>> minimize_adjacent_sum([4, 2, 1, 3]) [1, 2, 3, 4] >>> minimize_adjacent_sum([10, 1, 5, 2]) [1, 2, 5, 10] >>> minimize_adjacent_sum([7]) []","solution":"from typing import List def minimize_adjacent_sum(nums: List[int]) -> List[int]: if len(nums) < 2: return [] return sorted(nums)"},{"question":"import heapq class RunningMedian: def __init__(self): self.lower_half = [] # Max heap (invert values to use min heap) self.upper_half = [] # Min heap def add_number(self, num: int) -> None: Add a number to the continuously growing list of integers. Parameters: num (int): The integer to be added to the list. pass def get_median(self) -> float: Get the median of the current list of numbers. Returns: float: The median of the numbers in the list. pass","solution":"import heapq class RunningMedian: def __init__(self): self.lower_half = [] # Max heap (invert values to use min heap) self.upper_half = [] # Min heap def add_number(self, num: int) -> None: # Add to max heap (lower half) heapq.heappush(self.lower_half, -num) # Balance heaps: make sure every element in lower_half is <= elements in upper_half if self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0]): val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) # Balance sizes: the size of lower_half can only exceed upper_half by at most 1 if len(self.lower_half) > len(self.upper_half) + 1: val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) if len(self.upper_half) > len(self.lower_half): val = heapq.heappop(self.upper_half) heapq.heappush(self.lower_half, -val) def get_median(self) -> float: if len(self.lower_half) == len(self.upper_half): return (-self.lower_half[0] + self.upper_half[0]) / 2.0 else: return float(-self.lower_half[0])"},{"question":"from typing import List, Tuple def find_pair(arr: List[int], target: int) -> Tuple[int, int]: Finds and returns a tuple (a, b) such that a and b are two distinct elements from the list and their sum is equal to target. If no such pair exists, returns an empty tuple. >>> find_pair([2, 7, 11, 15], 9) (2, 7) >>> find_pair([1, 2, 3, 4, 5], 10) () >>> find_pair([1, 2, 3, 4, 5, 6], 7) (1, 6) # or other valid pairs >>> find_pair([5, 20, 3, 50, 2, 80, 1], 6) (5, 1) >>> find_pair([-3, 4, 1, 90], -2) (-3, 1) >>> find_pair([1, 2], 3) (1, 2)","solution":"from typing import List, Tuple def find_pair(arr: List[int], target: int) -> Tuple[int, int]: Finds and returns a tuple (a, b) such that a and b are two distinct elements from the list and their sum is equal to target. If no such pair exists, returns an empty tuple. seen = {} for num in arr: complement = target - num if complement in seen: return (complement, num) seen[num] = True return ()"},{"question":"import re def normalize_string(s: str) -> str: Normalize the string by converting to lowercase and removing non-alphanumeric characters. return re.sub(r'[^A-Za-z0-9]', '', s.lower()) def is_palindrome(s: str) -> bool: Check if a given string is a palindrome using simple comparison. normalized = normalize_string(s) return normalized == normalized[::-1] def is_palindrome_recursion(s: str) -> bool: Check if a given string is a palindrome using recursion. normalized = normalize_string(s) def helper(sub_s: str, left: int, right: int) -> bool: if left >= right: return True if sub_s[left] != sub_s[right]: return False return helper(sub_s, left + 1, right - 1) return helper(normalized, 0, len(normalized) - 1) def is_palindrome_two_pointer(s: str) -> bool: Check if a given string is a palindrome using a two-pointer technique. normalized = normalize_string(s) left, right = 0, len(normalized) - 1 while left < right: if normalized[left] != normalized[right]: return False left += 1 right -= 1 return True # Example test cases assert is_palindrome(\\"A man, a plan, a canal, Panama\\") == True assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"hello\\") == False assert is_palindrome(\\"\\") == True assert is_palindrome(\\"a\\") == True assert is_palindrome(\\"Able , was I saw eLba\\") == True assert is_palindrome_recursion(\\"A man, a plan, a canal, Panama\\") == True assert is_palindrome_recursion(\\"racecar\\") == True assert is_palindrome_recursion(\\"hello\\") == False assert is_palindrome_recursion(\\"\\") == True assert is_palindrome_recursion(\\"a\\") == True assert is_palindrome_recursion(\\"Able , was I saw eLba\\") == True assert is_palindrome_two_pointer(\\"A man, a plan, a canal, Panama\\") == True assert is_palindrome_two_pointer(\\"racecar\\") == True assert is_palindrome_two_pointer(\\"hello\\") == False assert is_palindrome_two_pointer(\\"\\") == True assert is_palindrome_two_pointer(\\"a\\") == True assert is_palindrome_two_pointer(\\"Able , was I saw eLba\\") == True","solution":"import re def normalize_string(s: str) -> str: Normalize the string by converting to lowercase and removing non-alphanumeric characters. return re.sub(r'[^A-Za-z0-9]', '', s.lower()) def is_palindrome(s: str) -> bool: Check if a given string is a palindrome using simple comparison. normalized = normalize_string(s) return normalized == normalized[::-1] def is_palindrome_recursion(s: str) -> bool: Check if a given string is a palindrome using recursion. normalized = normalize_string(s) def helper(sub_s: str, left: int, right: int) -> bool: if left >= right: return True if sub_s[left] != sub_s[right]: return False return helper(sub_s, left + 1, right - 1) return helper(normalized, 0, len(normalized) - 1) def is_palindrome_two_pointer(s: str) -> bool: Check if a given string is a palindrome using a two-pointer technique. normalized = normalize_string(s) left, right = 0, len(normalized) - 1 while left < right: if normalized[left] != normalized[right]: return False left += 1 right -= 1 return True"},{"question":"import requests def fetch_and_save_weather_data(city_name: str, api_key: str, filename: str) -> None: Fetches current weather data for the given city and saves it to a file. Parameters: city_name (str): Name of the city. api_key (str): API key for authenticating with the weather service. filename (str): Name of the file to save the weather details. Raises: ValueError: If \`api_key\` is blank or invalid. IOError: If there is an error while writing to the file. # Your code here # Mocking requests.get to simulate API calls @patch(\\"requests.get\\") def test_fetch_and_save_weather_data_success(mock_get): mock_get.return_value.status_code = 200 mock_get.return_value.json.return_value = { \\"cod\\": 200, \\"weather\\": [{\\"description\\": \\"clear sky\\"}], \\"main\\": {\\"temp\\": 282.55} } with patch(\\"builtins.open\\", mock_open()) as mocked_file: fetch_and_save_weather_data(\\"New York\\", \\"fake_api_key\\", \\"weather.txt\\") mocked_file.assert_called_once_with(\\"weather.txt\\", \\"w\\") mocked_file().write.assert_called_once_with(str({ \\"cod\\": 200, \\"weather\\": [{\\"description\\": \\"clear sky\\"}], \\"main\\": {\\"temp\\": 282.55} })) @patch(\\"requests.get\\") def test_fetch_and_save_weather_data_api_key_blank(mock_get): with pytest.raises(ValueError): fetch_and_save_weather_data(\\"New York\\", \\"\\", \\"weather.txt\\") @patch(\\"requests.get\\") def test_fetch_and_save_weather_data_network_error(mock_get): mock_get.side_effect = requests.exceptions.ConnectionError with pytest.raises(IOError): fetch_and_save_weather_data(\\"New York\\", \\"fake_api_key\\", \\"weather.txt\\") @patch(\\"requests.get\\") def test_fetch_and_save_weather_data_invalid_city(mock_get): mock_get.return_value.status_code = 404 mock_get.return_value.json.return_value = {\\"cod\\": \\"404\\", \\"message\\": \\"city not found\\"} with pytest.raises(IOError): fetch_and_save_weather_data(\\"InvalidCity\\", \\"fake_api_key\\", \\"weather.txt\\") @patch(\\"requests.get\\") def test_fetch_and_save_weather_data_file_write_error(mock_get): mock_get.return_value.status_code = 200 mock_get.return_value.json.return_value = { \\"cod\\": 200, \\"weather\\": [{\\"description\\": \\"clear sky\\"}], \\"main\\": {\\"temp\\": 282.55} } with patch(\\"builtins.open\\", mock_open()) as mocked_file: mocked_file.side_effect = IOError(\\"File write error\\") with pytest.raises(IOError): fetch_and_save_weather_data(\\"New York\\", \\"fake_api_key\\", \\"weather.txt\\")","solution":"import requests import os def fetch_and_save_weather_data(city_name: str, api_key: str, filename: str) -> None: Fetches current weather data for the given city and saves it to a file. Parameters: city_name (str): Name of the city. api_key (str): API key for authenticating with the weather service. filename (str): Name of the file to save the weather details. Raises: ValueError: If \`api_key\` is blank or invalid. IOError: If there is an error while writing to the file. if not api_key: raise ValueError(\\"API key is required\\") url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={api_key}\\" try: response = requests.get(url) response.raise_for_status() # Raise HTTPError for bad responses except requests.exceptions.RequestException as e: raise IOError(f\\"Network error: {e}\\") try: weather_data = response.json() if weather_data.get(\\"cod\\") != 200: raise IOError(f\\"Error retrieving weather data: {weather_data.get('message', 'Unknown error')}\\") with open(filename, \\"w\\") as file: file.write(str(weather_data)) except Exception as e: raise IOError(f\\"File operation failed: {e}\\")"},{"question":"from typing import List class PrimeFactorizer: A class to perform various operations involving prime numbers. Methods: is_prime(number: int) -> bool next_prime(number: int) -> int prime_factors(number: int) -> List[int] factors(number: int) -> List[int] Examples: >>> factorizer = PrimeFactorizer() >>> factorizer.is_prime(7) True >>> factorizer.next_prime(7) 11 >>> factorizer.prime_factors(28) [2, 2, 7] >>> factorizer.factors(28) [1, 2, 4, 7, 14, 28] @staticmethod def is_prime(number: int) -> bool: Checks if a given number is prime. Args: number (int): The number to check. Returns: bool: True if the number is prime, False otherwise. ... @staticmethod def next_prime(number: int) -> int: Finds and returns the smallest prime number larger than the given number. Args: number (int): The number to find the next prime after. Returns: int: The next prime number greater than the given number. ... @staticmethod def prime_factors(number: int) -> List[int]: Returns a list of prime factors of the given number. Args: number (int): The number to factorize. Returns: List[int]: A list of prime factors. ... @staticmethod def factors(number: int) -> List[int]: Returns a list of all factors of the given number. Args: number (int): The number to find factors of. Returns: List[int]: A list of all factors. ...","solution":"from typing import List class PrimeFactorizer: @staticmethod def is_prime(number: int) -> bool: if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True @staticmethod def next_prime(number: int) -> int: if number <= 1: return 2 prime = number found = False while not found: prime += 1 if PrimeFactorizer.is_prime(prime): found = True return prime @staticmethod def prime_factors(number: int) -> List[int]: n = number factors = [] while n % 2 == 0: factors.append(2) n //= 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n //= i if n > 2: factors.append(n) return factors @staticmethod def factors(number: int) -> List[int]: result = set() for i in range(1, int(number**0.5) + 1): if number % i == 0: result.add(i) result.add(number // i) return sorted(result)"},{"question":"def has_palindromic_substring(s: str) -> bool: Checks if a given string contains any palindromic substrings of length greater than or equal to 3. >>> has_palindromic_substring(\\"\\") False >>> has_palindromic_substring(\\"abc\\") False >>> has_palindromic_substring(\\"aba\\") True >>> has_palindromic_substring(\\"abba\\") True >>> has_palindromic_substring(\\"abcdedcba\\") True >>> has_palindromic_substring(\\"abcdefghij\\") False","solution":"def has_palindromic_substring(s: str) -> bool: Returns True if the input string contains any palindromic substrings of length greater than or equal to 3. Returns False otherwise. if not isinstance(s, str): raise TypeError(\\"The input should be a string\\") def is_palindrome(sub): return sub == sub[::-1] n = len(s) for length in range(3, n+1): for i in range(n - length + 1): if is_palindrome(s[i:i+length]): return True return False"},{"question":"def is_valid_expression(expression: str) -> bool: Determines whether the given string \`expression\` is a valid expression or not. >>> is_valid_expression(\\"a(b)c\\") True >>> is_valid_expression(\\"((123))\\") True >>> is_valid_expression(\\"a(b)c)\\") False >>> is_valid_expression(\\"(((1)\\") False pass","solution":"def is_valid_expression(expression: str) -> bool: Determines whether the given string \`expression\` is a valid expression or not. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"from typing import List def word_breaks(s: str, word_dict: List[str]) -> List[str]: Finds all possible word breaks for a given string s using a provided dictionary of words. >>> word_breaks(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cats and dog\\", \\"cat sand dog\\"] >>> word_breaks(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] >>> word_breaks(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) []","solution":"from typing import List def word_breaks(s: str, word_dict: List[str]) -> List[str]: Finds all possible word breaks for a given string s using a provided dictionary of words. def backtrack(start): if start == len(s): return [[]] if start in memo: return memo[start] results = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_dict_set: for rest in backtrack(end): results.append([word] + rest) memo[start] = results return results word_dict_set = set(word_dict) memo = {} results = backtrack(0) return [' '.join(words) for words in results]"},{"question":"def minimum_swaps_to_sort(arr: list[int]) -> int: Return the minimum number of swaps required to sort the array in ascending order. >>> minimum_swaps_to_sort([4, 3, 1, 2]) 3 >>> minimum_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> minimum_swaps_to_sort([1]) 0 >>> minimum_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_swaps_to_sort([5, 4, 3, 2, 1]) 2 >>> minimum_swaps_to_sort(list(range(1, 101))[::-1]) 50 >>> minimum_swaps_to_sort([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 1]) 10","solution":"def minimum_swaps_to_sort(arr: list[int]) -> int: n = len(arr) arr_pos = [(val, idx) for idx, val in enumerate(arr)] arr_pos.sort(key=lambda it: it[0]) visited = {k: False for k in range(n)} swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: swaps += cycle_size - 1 return swaps"},{"question":"''' def sort_strings(strings: list[str]) -> list[str]: Sort a list of strings based on their length. If two strings have the same length, they should be sorted lexicographically. return sorted(strings, key=lambda x: (len(x), x)) '''","solution":"def sort_strings(strings: list[str]) -> list[str]: Sort a list of strings based on their length. If two strings have the same length, they should be sorted lexicographically. return sorted(strings, key=lambda x: (len(x), x)) # Example usage # strings = [\\"banana\\", \\"apple\\", \\"pear\\", \\"kiwi\\", \\"fig\\"] # print(sort_strings(strings)) # Output: [\\"fig\\", \\"kiwi\\", \\"pear\\", \\"apple\\", \\"banana\\"] # strings = [\\"bbb\\", \\"aaa\\", \\"ccc\\", \\"aaaa\\", \\"kk\\"] # print(sort_strings(strings)) # Output: [\\"kk\\", \\"aaa\\", \\"bbb\\", \\"ccc\\", \\"aaaa\\"]"},{"question":"import threading from concurrent.futures import ThreadPoolExecutor, as_completed import requests from typing import List, Dict def fetch_url(url: str) -> (str, int): try: response = requests.get(url, timeout=5) return url, response.status_code except requests.RequestException: return url, None def multithreaded_web_crawler(urls: List[str], num_threads: int) -> Dict[str, int]: Crawl a list of URLs concurrently using multiple threads. Args: urls (List[str]): A list of URLs to be crawled. num_threads (int): The number of threads to use for crawling. Returns: Dict[str, int]: A dictionary with URLs as keys and their HTTP statuses as values. >>> urls = [\\"http://httpbin.org/status/200\\", \\"http://httpbin.org/status/404\\"] >>> result = multithreaded_web_crawler(urls, 2) >>> result[\\"http://httpbin.org/status/200\\"] == 200 >>> result[\\"http://httpbin.org/status/404\\"] == 404","solution":"import threading from concurrent.futures import ThreadPoolExecutor, as_completed import requests def fetch_url(url): try: response = requests.get(url, timeout=5) return url, response.status_code except requests.RequestException as e: return url, None def multithreaded_web_crawler(urls, num_threads): results = {} visited_urls = set() lock = threading.Lock() def worker(url): nonlocal lock, results, visited_urls if url not in visited_urls: with lock: visited_urls.add(url) result = fetch_url(url) with lock: results[url] = result[1] with ThreadPoolExecutor(max_workers=num_threads) as executor: future_to_url = {executor.submit(worker, url): url for url in urls} for future in as_completed(future_to_url): future.result() return results"},{"question":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> None: Transpose a given square matrix in place. :param matrix: A list of lists representing a square matrix (n x n) of integers. :return: None. The matrix is modified in place. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> transpose_matrix(matrix) >>> matrix [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> None: Transpose a given square matrix in place. :param matrix: A list of lists representing a square matrix (n x n) of integers. :return: None. The matrix is modified in place. n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"def group_anagrams(words): Group a list of strings into sets of anagrams. >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"rat\\", \\"tar\\", \\"art\\"]) [['listen', 'silent', 'enlist'], ['google', 'gogole'], ['rat', 'tar', 'art']] >>> group_anagrams([]) [] >>> group_anagrams([\\"apple\\"]) [['apple']] >>> group_anagrams([\\"cat\\", \\"dog\\", \\"bird\\"]) [['cat'], ['dog'], ['bird']] >>> group_anagrams([\\"test\\", \\"test\\"]) [['test', 'test']] pass","solution":"def group_anagrams(words): from collections import defaultdict # Using a dictionary to map sorted word to list of anagrams anagram_map = defaultdict(list) for word in words: # Sort the word and use it as a key sorted_word = ''.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"from collections import deque def shortest_path(graph, start_node, target_node): Finds the shortest path in an unweighted graph from start_node to target_node using BFS. :param graph: A dictionary where keys are node identifiers and values are lists of adjacent nodes. :param start_node: The identifier of the starting node. :param target_node: The identifier of the target node. :return: A list of nodes representing the shortest path from start_node to target_node. def test_shortest_path_basic_case(): graph = { 1: [2, 3], 2: [4], 3: [4], 4: [5], 5: [] } start_node = 1 target_node = 5 result = shortest_path(graph, start_node, target_node) assert result in [[1, 2, 4, 5], [1, 3, 4, 5]] def test_shortest_path_direct_connection(): graph = { 1: [2], 2: [], } start_node = 1 target_node = 2 expected_path = [1, 2] assert shortest_path(graph, start_node, target_node) == expected_path def test_shortest_path_no_path(): graph = { 1: [2], 2: [3], 3: [] } start_node = 1 target_node = 4 # Node 4 is not reachable from node 1 expected_path = [] assert shortest_path(graph, start_node, target_node) == expected_path def test_shortest_path_same_start_target(): graph = { 1: [2], 2: [3], 3: [] } start_node = 1 target_node = 1 # Start and target node are the same expected_path = [1] assert shortest_path(graph, start_node, target_node) == expected_path def test_shortest_path_another_case(): graph = { 'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': ['E'], 'E': [] } start_node = 'A' target_node = 'E' result = shortest_path(graph, start_node, target_node) assert result in [['A', 'B', 'D', 'E'], ['A', 'C', 'D', 'E']]","solution":"from collections import deque def shortest_path(graph, start_node, target_node): Finds the shortest path in an unweighted graph from start_node to target_node using BFS. :param graph: A dictionary where keys are node identifiers and values are lists of adjacent nodes. :param start_node: The identifier of the starting node. :param target_node: The identifier of the target node. :return: A list of nodes representing the shortest path from start_node to target_node. if start_node == target_node: return [start_node] visited = set() queue = deque([(start_node, [start_node])]) while queue: current_node, path = queue.popleft() if current_node not in visited: visited.add(current_node) for neighbor in graph[current_node]: if neighbor == target_node: return path + [target_node] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return []"},{"question":"from typing import List, Tuple def generate_itinerary(flights: List[Tuple[str, str]]) -> List[str]: Generates the complete flight itinerary from a list of flight segments. >>> generate_itinerary([(\\"JFK\\", \\"ATL\\"), (\\"ATL\\", \\"SFO\\"), (\\"SFO\\", \\"LAX\\")]) ['JFK', 'ATL', 'SFO', 'LAX'] >>> generate_itinerary([(\\"LAX\\", \\"JFK\\"), (\\"SFO\\", \\"LAX\\"), (\\"ATL\\", \\"SFO\\")]) ['ATL', 'SFO', 'LAX', 'JFK'] # TODO: Implement this function pass def test_generate_itinerary_example_1(): assert generate_itinerary([(\\"JFK\\", \\"ATL\\"), (\\"ATL\\", \\"SFO\\"), (\\"SFO\\", \\"LAX\\")]) == ['JFK', 'ATL', 'SFO', 'LAX'] def test_generate_itinerary_example_2(): assert generate_itinerary([(\\"LAX\\", \\"JFK\\"), (\\"SFO\\", \\"LAX\\"), (\\"ATL\\", \\"SFO\\")]) == ['ATL', 'SFO', 'LAX', 'JFK'] def test_generate_itinerary_single_segment(): assert generate_itinerary([(\\"JFK\\", \\"LAX\\")]) == [\\"JFK\\", \\"LAX\\"] def test_generate_itinerary_disordered_segments(): assert generate_itinerary([(\\"SFO\\", \\"LAX\\"), (\\"JFK\\", \\"ATL\\"), (\\"ATL\\", \\"SFO\\")]) == ['JFK', 'ATL', 'SFO', 'LAX'] def test_generate_itinerary_circular_route(): assert generate_itinerary([(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"A\\")]) == ['A', 'B', 'C', 'A'] def test_generate_itinerary_large_input(): input_flights = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\"), (\\"E\\", \\"F\\"), (\\"F\\", \\"G\\"), (\\"G\\", \\"H\\"), (\\"H\\", \\"I\\"), (\\"I\\", \\"J\\"), (\\"J\\", \\"K\\")] expected_output = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\", \\"G\\", \\"H\\", \\"I\\", \\"J\\", \\"K\\"] assert generate_itinerary(input_flights) == expected_output","solution":"from typing import List, Tuple, Dict def generate_itinerary(flights: List[Tuple[str, str]]) -> List[str]: # Create a graph to represent the flights as an adjacency list graph = {} in_degree = {} out_degree = {} for departure, arrival in flights: if departure not in graph: graph[departure] = [] graph[departure].append(arrival) if departure not in out_degree: out_degree[departure] = 0 if arrival not in in_degree: in_degree[arrival] = 0 out_degree[departure] += 1 in_degree[arrival] += 1 if arrival not in out_degree: out_degree[arrival] = 0 if departure not in in_degree: in_degree[departure] = 0 # Find the starting point: the node with out_degree and no in_degree start = None for location in out_degree: if out_degree[location] == in_degree.get(location, 0) + 1: start = location break elif start is None: start = location if start is None: return [] # Hierholzer's algorithm to find Eulerian Path/Circuit def visit(airport: str, result: List[str]): while graph.get(airport): next_airport = graph[airport].pop() visit(next_airport, result) result.append(airport) result = [] visit(start, result) return list(reversed(result))"},{"question":"def trap_rainwater(heights: list[int]) -> int: Calculate how much water it can trap after raining. Args: heights (list[int]): A list of integers where each integer represents the height of a vertical line drawn to the x-axis at that position. Returns: int: An integer representing the total units of water trapped. Examples: >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([4,2,0,3,2,5]) 9 pass def test_no_heights(): assert trap_rainwater([]) == 0 def test_single_height(): assert trap_rainwater([1]) == 0 def test_two_heights(): assert trap_rainwater([1, 2]) == 0 def test_example_case_1(): assert trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_example_case_2(): assert trap_rainwater([4,2,0,3,2,5]) == 9 def test_flat_surface(): assert trap_rainwater([1, 1, 1, 1, 1]) == 0 def test_valleys(): assert trap_rainwater([3, 0, 2, 0, 4]) == 7 def test_increasing_heights(): assert trap_rainwater([1, 2, 3, 4, 5]) == 0 def test_decreasing_heights(): assert trap_rainwater([5, 4, 3, 2, 1]) == 0 def test_peak_and_valley(): assert trap_rainwater([0, 1, 0, 2, 0, 3]) == 3","solution":"def trap_rainwater(heights: list[int]) -> int: Calculate how much water can be trapped after raining given the heights of vertical lines. Args: heights: A list of integers representing the height of vertical lines drawn to the x-axis at that position. Returns: An integer representing the total units of water trapped. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"def longest_multiple_subsequence(lst: list[int]) -> int: Given a list of integers, find the length of the longest subsequence such that each element in this subsequence is a multiple of the previous element in the subsequence. >>> longest_multiple_subsequence([1, 2, 4, 8, 16, 3, 9, 27]) 5 >>> longest_multiple_subsequence([3, 6, 4, 12, 24]) 4 >>> longest_multiple_subsequence([4, 8, 5, 10]) 2 >>> longest_multiple_subsequence([10]) 1 >>> longest_multiple_subsequence([2, 5, 7, 11]) 1 >>> longest_multiple_subsequence([1, 2, 4, 8, 16, 32, 64, 128]) 8 >>> longest_multiple_subsequence([1000000000, 500000000, 250000000, 125000000]) 4 >>> longest_multiple_subsequence([5, 11, 17, 23]) 1 >>> longest_multiple_subsequence([1, 3, 9, 27, 6, 18, 54]) 5 # Implementation here","solution":"def longest_multiple_subsequence(lst): n = len(lst) if n == 1: return 1 lst.sort() dp = [1] * n # dp[i] will store the length of the longest subsequence ending with lst[i] for i in range(1, n): for j in range(i): if lst[i] % lst[j] == 0: # If lst[i] is a multiple of lst[j] dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def longest_unique_substring(s: str) -> int: Finds the longest substring with all unique characters. Parameters: s (str): The input string to search within. Returns: int: The length of the longest substring with all unique characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0","solution":"def longest_unique_substring(s: str) -> int: Finds the longest substring with all unique characters. Parameters: s (str): The input string to search within. Returns: int: The length of the longest substring with all unique characters. # Edge case for empty string if not s: return 0 # Dictionary to store the last seen index of each character last_seen = {} longest = 0 start = 0 for end in range(len(s)): if s[end] in last_seen and last_seen[s[end]] >= start: start = last_seen[s[end]] + 1 last_seen[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"from typing import List def is_anagram_substring(s: str, pattern: str) -> bool: Determine if any substring of a given input string is an anagram of a specified pattern string. >>> is_anagram_substring(\\"cbaebabacd\\", \\"abc\\") True >>> is_anagram_substring(\\"af\\", \\"be\\") False >>> is_anagram_substring(\\"\\", \\"a\\") False >>> is_anagram_substring(\\"a\\", \\"a\\") True","solution":"def is_anagram_substring(s: str, pattern: str) -> bool: from collections import Counter # Length of the pattern pattern_len = len(pattern) if pattern_len > len(s): return False # Counter for the pattern string pattern_count = Counter(pattern) # Counter for the first window in string \`s\` window_count = Counter(s[:pattern_len]) if window_count == pattern_count: return True # Sliding window for i in range(pattern_len, len(s)): start_char = s[i - pattern_len] end_char = s[i] window_count[end_char] += 1 if window_count[start_char] == 1: del window_count[start_char] else: window_count[start_char] -= 1 if window_count == pattern_count: return True return False"},{"question":"def is_fibonacci_number(number: int) -> bool: Determine if a given number is part of the Fibonacci sequence. Raises a ValueError for incorrect input types. >>> is_fibonacci_number(0) True >>> is_fibonacci_number(1) True >>> is_fibonacci_number(13) True >>> is_fibonacci_number(20) False >>> is_fibonacci_number(144) True >>> is_fibonacci_number(\\"ten\\") Traceback (most recent call last): ... ValueError: The input must be a non-negative integer.","solution":"def is_fibonacci_number(number): Returns True if the number is part of the Fibonacci sequence, False otherwise. if not isinstance(number, int) or number < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if number in (0, 1): return True a, b = 0, 1 while b < number: a, b = b, a + b return b == number"},{"question":"import random import string class DiscountCodeGenerator: A class to generate and validate discount codes for promotional campaigns. Example: >>> generator = DiscountCodeGenerator() >>> new_code = generator.generate_code(8) >>> print(f\\"Generated Code: {new_code}\\") >>> is_valid = generator.validate_code(new_code) >>> print(f\\"Is the code valid? {is_valid}\\") >>> was_redeemed = generator.redeem_code(new_code) >>> print(f\\"Was the code redeemed? {was_redeemed}\\") >>> was_redeemed_again = generator.redeem_code(new_code) >>> print(f\\"Was the code redeemed again? {was_redeemed_again}\\") >>> another_code = generator.generate_code(8) >>> print(f\\"Generated Another Code: {another_code}\\") >>> is_valid = generator.validate_code(another_code) >>> print(f\\"Is the another code valid? {is_valid}\\") def __init__(self): Initializes a new DiscountCodeGenerator instance. self.generated_codes = set() self.redeemed_codes = set() def generate_code(self, length: int) -> str: Generates a unique discount code with the specified length. Args: length (int): Length of the discount code to be generated. Returns: str: The generated unique discount code. def validate_code(self, code: str) -> bool: Validates if the given code is unique and has not been redeemed. Args: code (str): The discount code to validate. Returns: bool: True if the code is unique and not redeemed, otherwise False. def redeem_code(self, code: str) -> bool: Marks the given discount code as redeemed if it is valid. Args: code (str): The discount code to mark as redeemed. Returns: bool: True if the code was successfully redeemed, otherwise False. def test_generate_code_length(): generator = DiscountCodeGenerator() code = generator.generate_code(8) assert len(code) == 8 def test_generate_code_uniqueness(): generator = DiscountCodeGenerator() code1 = generator.generate_code(8) code2 = generator.generate_code(8) assert code1 != code2 def test_validate_code(): generator = DiscountCodeGenerator() code = generator.generate_code(8) assert generator.validate_code(code) == True assert generator.validate_code(\\"INVALIDCODE\\") == False def test_redeem_code(): generator = DiscountCodeGenerator() code = generator.generate_code(8) assert generator.redeem_code(code) == True assert generator.redeem_code(code) == False def test_reject_invalid_code_redeem(): generator = DiscountCodeGenerator() assert generator.redeem_code(\\"INVALIDCODE\\") == False def test_code_redeemed_only_once(): generator = DiscountCodeGenerator() code = generator.generate_code(8) assert generator.redeem_code(code) == True assert generator.validate_code(code) == False def test_code_length_less_than_six_raises_error(): generator = DiscountCodeGenerator() try: generator.generate_code(5) except ValueError as ve: assert str(ve) == \\"Code length must be at least 6 characters long.\\" else: assert False, \\"Expected ValueError was not raised\\"","solution":"import random import string class DiscountCodeGenerator: def __init__(self): Initializes a new DiscountCodeGenerator instance. self.generated_codes = set() self.redeemed_codes = set() def generate_code(self, length: int) -> str: Generates a unique discount code with the specified length. Args: length (int): Length of the discount code to be generated. Returns: str: The generated unique discount code. if length < 6: raise ValueError(\\"Code length must be at least 6 characters long.\\") characters = string.ascii_uppercase + string.digits while True: code = ''.join(random.choices(characters, k=length)) if code not in self.generated_codes: self.generated_codes.add(code) return code def validate_code(self, code: str) -> bool: Validates if the given code is unique and has not been redeemed. Args: code (str): The discount code to validate. Returns: bool: True if the code is unique and not redeemed, otherwise False. return code in self.generated_codes and code not in self.redeemed_codes def redeem_code(self, code: str) -> bool: Marks the given discount code as redeemed if it is valid. Args: code (str): The discount code to mark as redeemed. Returns: bool: True if the code was successfully redeemed, otherwise False. if self.validate_code(code): self.redeemed_codes.add(code) return True return False"},{"question":"from typing import List, Tuple, Dict def calculate_total_sales(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]: Aggregate the total cost for each product sold from a list of transactions. Each transaction is represented as a tuple (id, product_name, cost). Args: transactions (List[Tuple[str, str, float]]): List of transactions. Returns: Dict[str, float]: Dictionary with product names as keys and the total cost for each product as values. >>> transactions = [ ... (\\"T1\\", \\"ProductA\\", 9.99), ... (\\"T2\\", \\"ProductB\\", 5.49), ... (\\"T3\\", \\"ProductA\\", 12.99), ... (\\"T4\\", \\"ProductC\\", 7.99), ... (\\"T5\\", \\"ProductB\\", 3.49) ... ] >>> calculate_total_sales(transactions) {'ProductA': 22.98, 'ProductB': 8.98, 'ProductC': 7.99} pass","solution":"from typing import List, Tuple, Dict def calculate_total_sales(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]: product_sales = {} for transaction_id, product_name, cost in transactions: if product_name in product_sales: product_sales[product_name] += cost else: product_sales[product_name] = cost return product_sales"},{"question":"def evaluate_rpn(expression: List[str]) -> float: Evaluates the given RPN expression and returns the result as a float. >>> evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9.0 >>> evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6.6 >>> evaluate_rpn([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) 2.0 >>> evaluate_rpn([\\"-2\\", \\"1\\", \\"+\\"]) -1.0 >>> evaluate_rpn([\\"3\\", \\"-4\\", \\"*\\"]) -12.0 >>> evaluate_rpn([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14.0 >>> evaluate_rpn([\\"42\\"]) 42.0 >>> evaluate_rpn([\\"10\\", \\"2\\", \\"/\\"]) 5.0 >>> evaluate_rpn([\\"7\\", \\"3\\", \\"/\\"]) 2.3333333333333335","solution":"def evaluate_rpn(expression): Evaluates the given RPN expression and returns the result as a float. Args: expression (List[str]): A list of strings where each string is either an integer or an operator. Returns: float: The result of the RPN expression. stack = [] operators = {\\"+\\", \\"-\\", \\"*\\", \\"/\\"} for token in expression: if token in operators: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(a / b) else: stack.append(int(token)) return float(stack.pop())"},{"question":"def is_power_of_3(n: int) -> bool: Determines if a given positive integer is a power of 3. >>> is_power_of_3(27) True >>> is_power_of_3(13) False >>> is_power_of_3(243) True","solution":"def is_power_of_3(n: int) -> bool: Determines if a given positive integer is a power of 3. Parameters: n (int): A positive integer. Returns: bool: True if n is a power of 3, False otherwise. if n <= 0: return False # The largest power of 3 within the range of 10^18 is 3**38 (1162261467 ** 3) max_power_of_3 = 3**38 return max_power_of_3 % n == 0 and n != 0"},{"question":"from typing import List class TrendingItems: def __init__(self, k: int): Initializes the object with the number of top trending items to track. pass def add_interaction(self, item_id: int): Records an interaction with the specified item. pass def get_top_trending(self) -> List[int]: Returns a list of the top \`k\` trending items sorted by their frequency in descending order. In case of a tie in frequency, items with the smaller IDs come first. pass # Example usage: ti = TrendingItems(3) ti.add_interaction(10) ti.add_interaction(20) ti.add_interaction(10) ti.add_interaction(30) ti.add_interaction(10) ti.add_interaction(20) # The top 3 trending items are [10, 20, 30] print(ti.get_top_trending()) # Output should be [10, 20, 30] ti.add_interaction(40) ti.add_interaction(40) ti.add_interaction(40) # The top 3 trending items are now [40, 10, 20] print(ti.get_top_trending()) # Output should be [40, 10, 20] # Unit Tests def test_basic_functionality(): ti = TrendingItems(3) ti.add_interaction(10) ti.add_interaction(20) ti.add_interaction(10) ti.add_interaction(30) ti.add_interaction(10) ti.add_interaction(20) assert ti.get_top_trending() == [10, 20, 30] def test_more_interactions(): ti = TrendingItems(3) ti.add_interaction(10) ti.add_interaction(10) ti.add_interaction(10) ti.add_interaction(20) ti.add_interaction(20) ti.add_interaction(30) ti.add_interaction(40) ti.add_interaction(40) ti.add_interaction(40) assert ti.get_top_trending() == [10, 40, 20] def test_tiebreaker_by_id(): ti = TrendingItems(2) ti.add_interaction(10) ti.add_interaction(20) ti.add_interaction(30) ti.add_interaction(20) ti.add_interaction(10) # Both 10 and 20 have the same count, should sort by IDs assert ti.get_top_trending() == [10, 20] def test_single_trending_item(): ti = TrendingItems(1) ti.add_interaction(5) ti.add_interaction(5) ti.add_interaction(6) assert ti.get_top_trending() == [5] def test_all_interactions_same_item(): ti = TrendingItems(3) ti.add_interaction(1) ti.add_interaction(1) ti.add_interaction(1) assert ti.get_top_trending() == [1] def test_more_items_than_trending(): ti = TrendingItems(2) items = [1, 2, 3, 4, 5] for item in items: ti.add_interaction(item) ti.add_interaction(item) # Any two items can be acceptable since they all have the same frequency result = ti.get_top_trending() assert len(result) == 2 expected_items = set(items) assert set(result).issubset(expected_items)","solution":"from typing import List from collections import defaultdict, Counter class TrendingItems: def __init__(self, k: int): self.k = k self.item_count = Counter() def add_interaction(self, item_id: int): self.item_count[item_id] += 1 def get_top_trending(self) -> List[int]: # Sorting first by frequency (in descending order), then by item_id (in ascending order for ties) sorted_items = sorted(self.item_count.items(), key=lambda x: (-x[1], x[0])) return [item for item, _ in sorted_items[:self.k]]"},{"question":"def unique_words_count(sentences: list[str]) -> int: Calculate the number of unique words across all sentences. >>> unique_words_count([\\"This is a sample sentence\\", \\"Another sample sentence is here\\", \\"Sample text is different\\"]) 10 pass def word_frequencies(sentences: list[str]) -> dict: Compute the frequency of each word in the list of sentences. >>> word_frequencies([\\"This is a sample sentence\\", \\"Another sample sentence is here\\", \\"Sample text is different\\"]) {'This': 1, 'is': 3, 'a': 1, 'sample': 2, 'sentence': 2, 'Another': 1, 'here': 1, 'Sample': 1, 'text': 1, 'different': 1} pass def sentence_lengths(sentences: list[str]) -> list[int]: Calculate the length of each sentence in terms of the number of words. >>> sentence_lengths([\\"This is a sample sentence\\", \\"Another sample sentence is here\\", \\"Sample text is different\\"]) [5, 5, 4] pass def average_sentence_length(sentence_lengths: list[int]) -> float: Compute the average length of the sentences. >>> average_sentence_length([5, 5, 4]) 4.666666666666667 pass def unique_words_in_sentence(sentence: str) -> set: Identify the unique words in each sentence. >>> unique_words_in_sentence(\\"This is a sample sentence\\") {'This', 'is', 'a', 'sample', 'sentence'} pass","solution":"def unique_words_count(sentences): Calculate the number of unique words across all sentences. words_set = set() for sentence in sentences: words = sentence.split() for word in words: words_set.add(word) return len(words_set) def word_frequencies(sentences): Compute the frequency of each word in the list of sentences. frequency_dict = {} for sentence in sentences: words = sentence.split() for word in words: if word in frequency_dict: frequency_dict[word] += 1 else: frequency_dict[word] = 1 return frequency_dict def sentence_lengths(sentences): Calculate the length of each sentence in terms of the number of words. lengths = [] for sentence in sentences: length = len(sentence.split()) lengths.append(length) return lengths def average_sentence_length(sentence_lengths): Compute the average length of the sentences. return sum(sentence_lengths) / len(sentence_lengths) def unique_words_in_sentence(sentence): Identify the unique words in each sentence. return set(sentence.split())"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Checks if one string is a permutation of another string. The function returns True if str2 is a permutation of str1, else returns False. Raises ValueError if either input string is empty. >>> is_permutation(\\"nick\\", \\"kcin\\") True >>> is_permutation(\\"brad\\", \\"dbra\\") True >>> is_permutation(\\"apple\\", \\"applf\\") False >>> is_permutation(\\"foo\\", \\"bar\\") False >>> is_permutation(\\"\\", \\"abc\\") Traceback (most recent call last): ... ValueError: Empty string(s) were passed to the function >>> is_permutation(\\"hello\\", \\"\\") Traceback (most recent call last): ... ValueError: Empty string(s) were passed to the function","solution":"def is_permutation(str1: str, str2: str) -> bool: Returns True if str2 is a permutation of str1, else returns False. Raises ValueError if either input string is empty. if not str1 or not str2: raise ValueError(\\"Empty string(s) were passed to the function\\") # Count the characters in both strings from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"def sequence_sum(sequence: str) -> int: Calculate the sum of integers in the string sequence. >>> sequence_sum(\\"1,2,3,-4,5\\") 7 >>> sequence_sum(\\"\\") 0 >>> sequence_sum(\\"42\\") 42 >>> sequence_sum(\\"-1,-2,-3\\") -6 >>> sequence_sum(\\"1,-2,3\\") 2 >>> sequence_sum(\\"1,2,three\\") Traceback (most recent call last): ... ValueError: Invalid input: sequence must contain only integers separated by commas pass def sequence_product(sequence: str) -> int: Calculate the product of integers in the string sequence. >>> sequence_product(\\"1,2,3,-4,5\\") -120 >>> sequence_product(\\"\\") 1 >>> sequence_product(\\"42\\") 42 >>> sequence_product(\\"-1,-2,-3\\") -6 >>> sequence_product(\\"1,-2,3\\") -6 >>> sequence_product(\\"1,2,three\\") Traceback (most recent call last): ... ValueError: Invalid input: sequence must contain only integers separated by commas pass def test_sequence_sum_basic(): assert sequence_sum(\\"1,2,3,-4,5\\") == 7 def test_sequence_sum_empty(): assert sequence_sum(\\"\\") == 0 def test_sequence_sum_single(): assert sequence_sum(\\"42\\") == 42 def test_sequence_sum_negative(): assert sequence_sum(\\"-1,-2,-3\\") == -6 def test_sequence_sum_mixed(): assert sequence_sum(\\"1,-2,3\\") == 2 def test_sequence_sum_invalid(): try: sequence_sum(\\"1,2,three\\") except ValueError as e: assert str(e) == \\"Invalid input: sequence must contain only integers separated by commas\\" def test_sequence_product_basic(): assert sequence_product(\\"1,2,3,-4,5\\") == -120 def test_sequence_product_empty(): assert sequence_product(\\"\\") == 1 def test_sequence_product_single(): assert sequence_product(\\"42\\") == 42 def test_sequence_product_negative(): assert sequence_product(\\"-1,-2,-3\\") == -6 def test_sequence_product_mixed(): assert sequence_product(\\"1,-2,3\\") == -6 def test_sequence_product_invalid(): try: sequence_product(\\"1,2,three\\") except ValueError as e: assert str(e) == \\"Invalid input: sequence must contain only integers separated by commas\\"","solution":"def sequence_sum(sequence: str) -> int: Calculate the sum of integers in the string sequence. if not sequence: return 0 try: numbers = [int(x) for x in sequence.split(',')] except ValueError: raise ValueError(\\"Invalid input: sequence must contain only integers separated by commas\\") total_sum = 0 for num in numbers: total_sum += num return total_sum def sequence_product(sequence: str) -> int: Calculate the product of integers in the string sequence. if not sequence: return 1 try: numbers = [int(x) for x in sequence.split(',')] except ValueError: raise ValueError(\\"Invalid input: sequence must contain only integers separated by commas\\") total_product = 1 for num in numbers: total_product *= num return total_product"},{"question":"# Completion Task You are tasked with creating a function to evaluate the total resistance of resistors connected in different configurations: series and parallel. The function should compute the total resistance based on the given list of resistances and the specified configuration. def total_resistance(resistances, configuration): Calculate the total resistance of resistors in series or parallel configuration. Args: resistances (list of float): The list of individual resistances. configuration (str): The type of configuration ('series' or 'parallel') Returns: float: The total resistance in the specified configuration. if configuration == 'series': return sum(resistances) elif configuration == 'parallel': reciprocal_sum = sum(1.0/r for r in resistances) return 1.0 / reciprocal_sum else: raise ValueError(\\"Configuration must be either 'series' or 'parallel'\\") def test_total_resistance_series(): assert total_resistance([100, 200, 300], 'series') == 600.0 assert total_resistance([50, 50], 'series') == 100.0 assert total_resistance([1, 1, 1], 'series') == 3.0 def test_total_resistance_parallel(): import pytest assert abs(total_resistance([100, 200, 300], 'parallel') - 54.54545454545455) < 1e-9 assert abs(total_resistance([50, 50], 'parallel') - 25.0) < 1e-9 assert abs(total_resistance([1, 1, 1], 'parallel') - 0.3333333333333333) < 1e-9 with pytest.raises(ZeroDivisionError): total_resistance([0, 1], 'parallel') def test_invalid_configuration(): import pytest with pytest.raises(ValueError): total_resistance([100, 200, 300], 'invalid')","solution":"def total_resistance(resistances, configuration): Calculate the total resistance of resistors in series or parallel configuration. Args: resistances (list of float): The list of individual resistances. configuration (str): The type of configuration ('series' or 'parallel') Returns: float: The total resistance in the specified configuration. if configuration == 'series': return sum(resistances) elif configuration == 'parallel': reciprocal_sum = sum(1.0/r for r in resistances) return 1.0 / reciprocal_sum else: raise ValueError(\\"Configuration must be either 'series' or 'parallel'\\")"},{"question":"def lexical_sort(words, order='asc'): Sorts a list of strings based on their lexicographical order. Case-insensitive and supports ascending and descending sorting order. Args: - words: List of strings to be sorted. - order: 'asc' for ascending order or 'desc' for descending order. Default is 'asc'. Returns: - A list of strings sorted based on the specified order. >>> lexical_sort([\\"apple\\", \\"Banana\\", \\"grape\\", \\"Apricot\\"], 'asc') [\\"apple\\", \\"Apricot\\", \\"Banana\\", \\"grape\\"] >>> lexical_sort([\\"zebra\\", \\"apple\\", \\"Orange\\", \\"banana\\", \\"Lemon\\"], 'desc') [\\"zebra\\", \\"Orange\\", \\"Lemon\\", \\"banana\\", \\"apple\\"] >>> lexical_sort([\\"carrot\\", \\"Angel\\", \\"zebra\\", \\"Dome\\"]) [\\"Angel\\", \\"carrot\\", \\"Dome\\", \\"zebra\\"] >>> lexical_sort([\\"Cherry\\", \\"apple\\", \\"berry\\"], 'asc') [\\"apple\\", \\"berry\\", \\"Cherry\\"] >>> lexical_sort([\\"Cherry\\", \\"apple\\", \\"berry\\"], 'desc') [\\"Cherry\\", \\"berry\\", \\"apple\\"] # Your code here pass","solution":"def lexical_sort(words, order='asc'): Sorts a list of strings based on their lexicographical order. Case-insensitive and supports ascending and descending sorting order. Args: - words: List of strings to be sorted. - order: 'asc' for ascending order or 'desc' for descending order. Default is 'asc'. Returns: - A list of strings sorted based on the specified order. words_sorted = sorted(words, key=lambda word: word.lower()) if order == 'desc': return words_sorted[::-1] return words_sorted"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix 90 degrees clockwise in-place. Args: matrix (list[list[int]]): A 2D list representing an n x n matrix where 1 <= n <= 1000. Returns: None: The function modifies the input matrix in-place to achieve the rotation. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ]","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. n = len(matrix) # transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # reverse the rows of the transposed matrix for i in range(n): matrix[i].reverse()"},{"question":"def valid_utf8(data: list[int]) -> bool: Determine if a given list of integers represents a valid UTF-8 encoding. :param list[int] data: A list of integers representing bytes of the encoding. :return bool: True if valid UTF-8 encoding, False otherwise. Example: >>> valid_utf8([197, 130, 1]) True >>> valid_utf8([235, 140, 4]) False >>> valid_utf8([240, 162, 138, 147]) True >>> valid_utf8([145]) False >>> valid_utf8([]) True # Your implementation goes here","solution":"def valid_utf8(data: list[int]) -> bool: Determine if a given list of integers represents a valid UTF-8 encoding. :param list[int] data: A list of integers representing bytes of the encoding. :return bool: True if valid UTF-8 encoding, False otherwise. n = len(data) i = 0 while i < n: first_byte = data[i] if first_byte & 0b10000000 == 0: # 1-byte character i += 1 continue elif first_byte & 0b11100000 == 0b11000000: # 2-byte character num_bytes = 2 elif first_byte & 0b11110000 == 0b11100000: # 3-byte character num_bytes = 3 elif first_byte & 0b11111000 == 0b11110000: # 4-byte character num_bytes = 4 else: return False if i + num_bytes > n: return False for j in range(1, num_bytes): if data[i + j] & 0b11000000 != 0b10000000: return False i += num_bytes return True"},{"question":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between two strings. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0","solution":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between two strings. m = len(text1) n = len(text2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up. for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def second_largest(nums: List[int]) -> int: Given a list of integers, find the second largest unique number in the list. Raises ValueError if there are fewer than two unique numbers. >>> second_largest([10, 20, 4, 20, 30]) 20 >>> second_largest([4, 4, 4, 4, 4]) # Raises ValueError >>> second_largest([5, 1, 5]) 1 >>> second_largest([0, 0, 1, 2, 3, 3]) 2 >>> second_largest([7, 8]) 7 pass","solution":"from typing import List def second_largest(nums: List[int]) -> int: unique_nums = list(set(nums)) if len(unique_nums) < 2: raise ValueError(\\"There are fewer than two unique numbers in the list.\\") unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"def parse_command(command: str) -> dict: Parses a command string and returns a structured dictionary with keys action, direction, and item as applicable. Examples: >>> parse_command(\\"Go North\\") {\\"action\\": \\"go\\", \\"direction\\": \\"north\\"} >>> parse_command(\\"take sword\\") {\\"action\\": \\"take\\", \\"item\\": \\"sword\\"} >>> parse_command(\\"drop shield\\") {\\"action\\": \\"drop\\", \\"item\\": \\"shield\\"} >>> parse_command(\\"save game\\") {\\"action\\": \\"save\\"} >>> parse_command(\\"load game\\") {\\"action\\": \\"load\\"} >>> parse_command(\\"go west\\") {\\"action\\": \\"go\\", \\"direction\\": \\"west\\"} >>> parse_command(\\"run east\\") {} >>> parse_command(\\"go upwards\\") {} >>> parse_command(\\"take the sword\\") {} >>> parse_command(\\"drop my shield\\") {} >>> parse_command(\\"\\") {} >>> parse_command(\\"gO NoRTh\\") {\\"action\\": \\"go\\", \\"direction\\": \\"north\\"} >>> parse_command(\\"TAKE SWord\\") {\\"action\\": \\"take\\", \\"item\\": \\"sword\\"} >>> parse_command(\\" go north \\") {\\"action\\": \\"go\\", \\"direction\\": \\"north\\"} >>> parse_command(\\" tsave gamet\\") {\\"action\\": \\"save\\"}","solution":"def parse_command(command: str) -> dict: Parses a command string and returns a structured dictionary with keys action, direction, and item as applicable. command = command.lower().strip() words = command.split() if len(words) == 0: return {} action = words[0] valid_actions = [\\"go\\", \\"take\\", \\"drop\\", \\"save\\", \\"load\\"] directions = [\\"north\\", \\"south\\", \\"east\\", \\"west\\"] if action not in valid_actions: return {} result = {\\"action\\": action} if action == \\"go\\": if len(words) == 2 and words[1] in directions: result[\\"direction\\"] = words[1] else: return {} elif action == \\"take\\" or action == \\"drop\\": if len(words) == 2: result[\\"item\\"] = words[1] else: return {} return result"},{"question":"def num_unique_bst(n: int) -> int: Returns the number of unique BSTs that can be constructed with \`n\` unique nodes. This is computed using the nth Catalan number. Args: n (int): The number of unique nodes (1 ≤ n ≤ 19). Returns: int: An integer representing the number of unique BSTs that can be constructed with \`n\` unique nodes. Examples: >>> num_unique_bst(3) 5 >>> num_unique_bst(5) 42","solution":"def num_unique_bst(n: int) -> int: Returns the number of unique BSTs that can be constructed with \`n\` unique nodes. This is computed using the nth Catalan number. if n == 0 or n == 1: return 1 # Initialize a list to store results of subproblems catalan = [0] * (n + 1) # Base cases catalan[0] = 1 catalan[1] = 1 # Fill the table according to the recursive Catalan Number equation for i in range(2, n + 1): catalan[i] = sum(catalan[j] * catalan[i - 1 - j] for j in range(i)) return catalan[n]"},{"question":"class FileSystem: def __init__(self): Initialize the file system with a root directory. def mkdir(self, path: str) -> None: Create a new directory at the specified path. Args: path (str): The absolute path where the new directory should be created. def touch(self, path: str, content: str) -> None: Create a new file with the provided content at the specified path. Args: path (str): The absolute path of the new file to be created. content (str): The content to be written to the new file. def cat(self, path: str) -> str: Retrieve the content of the file at the specified path. Args: path (str): The absolute path of the file whose content is to be retrieved. Returns: str: The content of the specified file. # Example usage fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.touch(\\"/a/b/c/file.txt\\", \\"Hello World\\") print(fs.cat(\\"/a/b/c/file.txt\\")) # Expected output: \\"Hello World\\"","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: dirs = path.strip(\\"/\\").split(\\"/\\") current_dir = self.root for d in dirs: if d not in current_dir: current_dir[d] = {} current_dir = current_dir[d] def touch(self, path: str, content: str) -> None: dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() current_dir = self.root for d in dirs: current_dir = current_dir[d] current_dir[file_name] = content def cat(self, path: str) -> str: dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() current_dir = self.root for d in dirs: current_dir = current_dir[d] return current_dir[file_name]"},{"question":"def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose a given matrix (2D list). A function to transpose a given matrix. Args: matrix (List[List[int]]): A 2D list where each sublist represents a row in the matrix. Returns: List[List[int]]: A 2D list representing the transposed matrix. >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1, 2, 3]]) [[1], [2], [3]] >>> transpose_matrix([[1], [2], [3]]) [[1, 2, 3]] >>> transpose_matrix([]) [] >>> transpose_matrix([[]]) [] # Your code here","solution":"def transpose_matrix(matrix): Transposes the given matrix. Args: matrix (list of list of int): The 2D list to be transposed. Returns: list of list of int: The transposed matrix. if not matrix or not matrix[0]: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"import math def custom_triangle(n: int) -> list: Generate n rows of the custom triangle sequence. Each element is determined by the product of the two elements directly above it divided by their GCD. Args: n (int): Number of rows in the sequence (n >= 1) Returns: List[List[int]]: A list of lists representing the rows of the custom triangle sequence. # Your implementation here def gcd(a, b): while b: a, b = b, a % b return a # Test cases if __name__ == \\"__main__\\": # Base case assert custom_triangle(1) == [[1]] # Two levels triangle assert custom_triangle(2) == [[1], [1, 1]] # Three levels triangle assert custom_triangle(3) == [[1], [1, 1], [1, 1, 1]] # Four levels triangle assert custom_triangle(4) == [[1], [1, 1], [1, 1, 1], [1, 1, 1, 1]] # Five levels triangle assert custom_triangle(5) == [[1], [1, 1], [1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1, 1]] # Invalid inputs assert custom_triangle(0) == [] assert custom_triangle(-1) == [] assert custom_triangle(-5) == []","solution":"import math def custom_triangle(n: int) -> list: Generate n rows of the custom triangle sequence. Each element is determined by the product of the two elements directly above it divided by their GCD. Args: n (int): Number of rows in the sequence (n >= 1) Returns: List[List[int]]: A list of lists representing the rows of the custom triangle sequence. if n < 1: return [] def gcd(a, b): while b: a, b = b, a % b return a triangle = [[1]] for i in range(1, n): prev_row = triangle[-1] new_row = [1] * (i + 1) for j in range(1, i): product = prev_row[j-1] * prev_row[j] new_row[j] = product // gcd(prev_row[j-1], prev_row[j]) triangle.append(new_row) return triangle"},{"question":"def mixed_sort(input_list: list) -> list: Sorts a mixed list of integers and strings with integers first in ascending order, followed by strings in lexicographical order. Args: input_list (list): A list containing both integers and strings. Returns: list: A new list with integers sorted in ascending order followed by strings in lexicographical order. Raises: TypeError: If the input_list contains elements that are neither integers nor strings. >>> mixed_sort([3, \\"apple\\", 1, \\"banana\\", 2, \\"cherry\\"]) [1, 2, 3, \\"apple\\", \\"banana\\", \\"cherry\\"] >>> mixed_sort([3, 1, 2]) [1, 2, 3] >>> mixed_sort([\\"banana\\", \\"apple\\", \\"cherry\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> mixed_sort([3, \\"apple\\", 1, 1, \\"banana\\", \\"apple\\", 3]) [1, 1, 3, 3, \\"apple\\", \\"apple\\", \\"banana\\"] >>> mixed_sort([]) [] >>> mixed_sort([1]) [1] >>> mixed_sort([\\"apple\\"]) [\\"apple\\"] >>> mixed_sort([1, \\"apple\\"]) [1, \\"apple\\"]","solution":"def mixed_sort(input_list: list) -> list: Sorts a mixed list of integers and strings with integers first in ascending order, followed by strings in lexicographical order. Args: input_list (list): A list containing both integers and strings. Returns: list: A new list with integers sorted in ascending order followed by strings in lexicographical order. Raises: TypeError: If the input_list contains elements that are neither integers nor strings. integers = [] strings = [] for item in input_list: if isinstance(item, int): integers.append(item) elif isinstance(item, str): strings.append(item) else: raise TypeError(\\"The input_list contains elements that are neither integers nor strings.\\") integers.sort() strings.sort() return integers + strings"},{"question":"def reverse_even_sublists(numbers: list) -> list: Given a list of integers, reverse the contiguous sublists of even numbers in place. Parameters: numbers (list): A list of integers. Returns: list: A new list with even number sublists reversed, and odd numbers unchanged. >>> reverse_even_sublists([1, 2, 8, 4, 3, 6, 6, 7, 9, 2, 2, 12, 1]) [1, 4, 8, 2, 3, 6, 6, 7, 9, 12, 2, 2, 1] >>> reverse_even_sublists([10, 12, 14, 17, 18, 20, 3]) [14, 12, 10, 17, 20, 18, 3] >>> reverse_even_sublists([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> reverse_even_sublists([2, 4, 6, 8]) [8, 6, 4, 2] >>> reverse_even_sublists([1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> reverse_even_sublists([2, 4, 6, 1, 2, 4, 6, 8]) [6, 4, 2, 1, 8, 6, 4, 2] >>> reverse_even_sublists([1]) [1] >>> reverse_even_sublists([2]) [2]","solution":"def reverse_even_sublists(numbers: list) -> list: Given a list of integers, reverse the contiguous sublists of even numbers in place. Parameters: numbers (list): A list of integers. Returns: list: A new list with even number sublists reversed, and odd numbers unchanged. result = [] i = 0 n = len(numbers) while i < n: if numbers[i] % 2 == 0: even_start = i while i < n and numbers[i] % 2 == 0: i += 1 even_sublist = numbers[even_start:i][::-1] result.extend(even_sublist) else: result.append(numbers[i]) i += 1 return result"},{"question":"def sort_numbers_in_string(input_string: str) -> list: Extracts all the numbers from a given string and returns them as a sorted list of integers. Args: input_string (str): A string containing words and numbers separated by spaces. Returns: list: A sorted list of integers extracted from the string. >>> sort_numbers_in_string(\\"42 apples 12 oranges 7 bananas 42 watermelons 0 grapes\\") [0, 7, 12, 42, 42] >>> sort_numbers_in_string(\\"1000 apples 500 grapes 1 orange\\") [1, 500, 1000] from typing import List import re def test_sort_numbers_in_string_single_number(): assert sort_numbers_in_string(\\"42 apples\\") == [42] def test_sort_numbers_in_string_multiple_integer(): assert sort_numbers_in_string(\\"42 apples 12 oranges 7 bananas 42 watermelons 0 grapes\\") == [0, 7, 12, 42, 42] def test_sort_numbers_in_string_repeated_numbers(): assert sort_numbers_in_string(\\"5 apples 5 oranges 5 bananas\\") == [5, 5, 5] def test_sort_numbers_in_string_large_numbers(): assert sort_numbers_in_string(\\"1000 apples 500 grapes 1 orange\\") == [1, 500, 1000] def test_sort_numbers_in_string_different_order(): assert sort_numbers_in_string(\\"banana 4 apple 3 orange 5 pear 1 grape 2\\") == [1, 2, 3, 4, 5] def test_sort_numbers_in_string_no_words(): assert sort_numbers_in_string(\\"4 2 5 1 3\\") == [1, 2, 3, 4, 5] def test_sort_numbers_in_string_spaces(): assert sort_numbers_in_string(\\" 4 2 5 1 3 \\") == [1, 2, 3, 4, 5] def test_sort_numbers_in_string_single_word_multiple_numbers(): assert sort_numbers_in_string(\\"apple 5 10 grapes 20\\") == [5, 10, 20]","solution":"def sort_numbers_in_string(input_string: str) -> list: Extracts all the numbers from a given string and returns them as a sorted list of integers. Args: input_string (str): A string containing words and numbers separated by spaces. Returns: list: A sorted list of integers extracted from the string. # Split the input string by spaces to get all the words and numbers elements = input_string.split() # Extract numbers from the elements, filtering out non-digits and converting to integers numbers = [int(element) for element in elements if element.isdigit()] # Sort the numbers in ascending order sorted_numbers = sorted(numbers) return sorted_numbers"},{"question":"def unique_elements_sum(data: list) -> int: Given a list of integers, this function returns the sum of all unique elements. Unique elements are those that appear exactly once in the list. Args: data (list): A list of integers. Returns: int: The sum of all unique elements in the list. Examples: >>> unique_elements_sum([1, 2, 2, 3, 4, 4, 5]) 9 >>> unique_elements_sum([10, 10, 20, 30, 40, 50, 50]) 90 >>> unique_elements_sum([5, 5, 5]) 0 # Sample test cases def test_unique_elements_sum_example1(): data = [1, 2, 2, 3, 4, 4, 5] assert unique_elements_sum(data) == 9 # (1 + 3 + 5) def test_unique_elements_sum_example2(): data = [10, 10, 20, 30, 40, 50, 50] assert unique_elements_sum(data) == 90 # (20 + 30 + 40) def test_unique_elements_sum_example3(): data = [5, 5, 5] assert unique_elements_sum(data) == 0 # No unique elements def test_unique_elements_sum_with_all_unique(): data = [1, 2, 3, 4, 5] assert unique_elements_sum(data) == 15 # (1 + 2 + 3 + 4 + 5) def test_unique_elements_sum_with_negative_numbers(): data = [-1, -2, -2, -3, -3, 1] assert unique_elements_sum(data) == 0 # (-1 appears 2 times, -2 and -3 too) def test_unique_elements_sum_with_mixed_signs(): data = [1, -1, 2, -2, 3, -3, 3, -3] assert unique_elements_sum(data) == 0 # all numbers appear twice def test_unique_elements_sum_with_single_element(): data = [42] assert unique_elements_sum(data) == 42 # Only one element def test_unique_elements_sum_with_empty_list(): data = [] assert unique_elements_sum(data) == 0 # No elements","solution":"def unique_elements_sum(data): Returns the sum of unique elements in the list. Unique elements are those that appear exactly once. from collections import Counter counts = Counter(data) # Filter and sum up the unique elements unique_sum = sum(key for key, count in counts.items() if count == 1) return unique_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root: TreeNode) -> int: Given a binary tree, find the sum of all left leaves in the tree. >>> root = TreeNode(1) >>> sum_of_left_leaves(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> sum_of_left_leaves(root) 2 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> sum_of_left_leaves(root) 0 >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> sum_of_left_leaves(root) 24 >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(4, TreeNode(6)), TreeNode(5)) >>> root.right = TreeNode(3, None, TreeNode(7, TreeNode(9), TreeNode(8))) >>> sum_of_left_leaves(root) 15","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): def is_leaf(node): return node and not node.left and not node.right def dfs(node, is_left): if not node: return 0 if is_leaf(node) and is_left: return node.val return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False)"},{"question":"import heapq from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into one sorted list. Parameters: lists (List[List[int]]): A list of k sorted lists of integers. Returns: List[int]: A single sorted list containing all the elements from the k input lists. Examples: >>> merge_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_sorted_lists([[], [], []]) [] >>> merge_sorted_lists([[1], [2], [3]]) [1, 2, 3] pass def test_merge_sorted_lists_basic(): assert merge_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) == [1, 1, 2, 3, 4, 4, 5, 6] def test_merge_sorted_lists_empty_lists(): assert merge_sorted_lists([[], [], []]) == [] def test_merge_sorted_lists_single_element_lists(): assert merge_sorted_lists([[1], [2], [3]]) == [1, 2, 3] def test_merge_sorted_lists_different_lengths(): assert merge_sorted_lists([[1, 2, 3], [4, 5], [6, 7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_merge_sorted_lists_duplicates(): assert merge_sorted_lists([[2, 4, 6], [1, 3, 5, 7], [2, 4, 6, 8]]) == [1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8] def test_merge_sorted_lists_empty_inner_list(): assert merge_sorted_lists([[1, 3, 5], [], [2, 4, 6]]) == [1, 2, 3, 4, 5, 6] def test_merge_sorted_lists_large_input(): # Extensive test for large input list1 = list(range(0, 10000, 2)) # Even numbers from 0 to 9998 list2 = list(range(1, 10000, 2)) # Odd numbers from 1 to 9999 expected = list(range(10000)) # All numbers from 0 to 9999 assert merge_sorted_lists([list1, list2]) == expected","solution":"import heapq from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into one sorted list. Parameters: lists (List[List[int]]): A list of k sorted lists of integers. Returns: List[int]: A single sorted list containing all the elements from the k input lists. merged_list = [] heap = [] # Populate heap with the first element from each list along with the list index and element index for list_index, sorted_list in enumerate(lists): if sorted_list: heapq.heappush(heap, (sorted_list[0], list_index, 0)) # Extract the smallest element from the heap and add the next element from the same list to the heap while heap: value, list_index, element_index = heapq.heappop(heap) merged_list.append(value) # If there is another element in the same list, add it to the heap if element_index + 1 < len(lists[list_index]): next_value = lists[list_index][element_index + 1] heapq.heappush(heap, (next_value, list_index, element_index + 1)) return merged_list"},{"question":"from typing import List def min_subarray_len(nums: List[int], s: int) -> int: Given an array of n integers and an integer s, find the length of the smallest subarray with a sum greater than or equal to s. If there is no such subarray, return -1. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 4) 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1], 15) -1 >>> min_subarray_len([12, 28, 83, 4, 25, 26, 10, 45, 23, 12], 213) 7","solution":"from typing import List def min_subarray_len(nums: List[int], s: int) -> int: n = len(nums) if n == 0: return -1 min_len = float('inf') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= s: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float('inf') else -1"},{"question":"# Function Signature def format_file_name(file_name: str) -> str: Formats the file name such that each word starts with an uppercase letter followed by lowercase letters, and words are separated by underscores. pass","solution":"def format_file_name(file_name: str) -> str: Formats the file name such that each word starts with an uppercase letter followed by lowercase letters, and words are separated by underscores. # Trim leading and trailing spaces file_name = file_name.strip() # Split the file name by spaces words = file_name.split() # Capitalize each word and join them with underscores formatted_name = '_'.join(word.capitalize() for word in words) return formatted_name"},{"question":"def find_peak_element(nums: list[int]) -> int: Finds an index of a peak element in the list. A peak element is an element that is greater than its neighbors. >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) in [1, 5] >>> find_peak_element([10, 20, 15, 2, 23, 90, 67]) in [1, 5] >>> find_peak_element([2, 2, 2, 2, 2]) in range(0, 5) >>> find_peak_element([5, 4, 3, 2, 1]) 0 >>> find_peak_element([1, 2, 3, 4, 5]) 4 >>> find_peak_element(list(range(10**6))) == 10**6 - 1 >>> find_peak_element(list(range(10**6, 0, -1))) == 0","solution":"def find_peak_element(nums: list[int]) -> int: Finds an index of a peak element in the list. A peak element is an element that is greater than its neighbors. Arguments: nums -- a list of integers Returns: An index of any peak element. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def find_all_subsets(nums): Generate all possible subsets (the power set) of the given list of unique integers. The subsets are sorted first by their lengths and then lexicographically within the same length. >>> find_all_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> find_all_subsets([1]) [[], [1]] >>> find_all_subsets([9, 0, 6]) [[], [0], [6], [9], [0, 6], [0, 9], [6, 9], [0, 6, 9]]","solution":"def find_all_subsets(nums): Generate all possible subsets (the power set) of the given list of unique integers. The subsets are sorted first by their lengths and then lexicographically within the same length. def backtrack(start, path): result.append(sorted(path)) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() result = [] backtrack(0, []) result.sort(key=lambda x: (len(x), x)) return result"},{"question":"def product_except_self(nums: list) -> list: Returns a list where each element at index i is the product of all the numbers in the original list except the one at i. Exceptions: - Raises TypeError if input is not a list of integers. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900]","solution":"def product_except_self(nums: list) -> list: Returns a list where each element at index i is the product of all the numbers in the original list except the one at i. Exceptions: - Raises TypeError if input is not a list of integers. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900] if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise TypeError(\\"Input must be a list of integers\\") length = len(nums) res = [1] * length left_product = 1 for i in range(length): res[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): res[i] *= right_product right_product *= nums[i] return res"},{"question":"import re from typing import List, Dict def clean_and_validate_emails(emails: List[str]) -> Dict[str, List[str]]: Validates and cleans a list of email addresses. Args: emails (List[str]): A list of email addresses as strings. Returns: dict: A dictionary with keys 'valid_emails' and 'invalid_emails' containing cleaned valid and invalid emails respectively. >>> clean_and_validate_emails([\\"Valid.Email@Example.com \\", \\"invalid-email@example...com\\", \\"another.Valid+Email@example.co.uk\\", \\"invalid.email@domain\\", \\" valid.email@domain.COM\\"]) {'valid_emails': ['valid.email@example.com', 'another.valid+email@example.co.uk', 'valid.email@domain.com'], 'invalid_emails': ['invalid-email@example...com', 'invalid.email@domain']} >>> clean_and_validate_emails([\\"invalid@domain\\", \\"invalid-email.com\\", \\"@invalid.com\\", \\"invalid@com\\", \\"invalid@domain.\\"]) {'valid_emails': [], 'invalid_emails': ['invalid@domain', 'invalid-email.com', '@invalid.com', 'invalid@com', 'invalid@domain.']} >>> clean_and_validate_emails([\\"test.email+alex@leetcode.com\\", \\"email@lc.com\\", \\"simple@example.com\\", \\"alice-bob123@sub.example.co.uk\\"]) {'valid_emails': ['test.email+alex@leetcode.com', 'email@lc.com', 'simple@example.com', 'alice-bob123@sub.example.co.uk'], 'invalid_emails': []} >>> clean_and_validate_emails([\\" whitespace@around.com \\", \\"t this.is@example.com n\\", \\" trailing.space@domain.com n\\"]) {'valid_emails': ['whitespace@around.com', 'this.is@example.com', 'trailing.space@domain.com'], 'invalid_emails': []} >>> clean_and_validate_emails([]) {'valid_emails': [], 'invalid_emails': []} pass","solution":"import re from typing import List, Dict def clean_and_validate_emails(emails: List[str]) -> Dict[str, List[str]]: Validates and cleans a list of email addresses. Args: emails (List[str]): A list of email addresses as strings. Returns: dict: A dictionary with keys 'valid_emails' and 'invalid_emails' containing cleaned valid and invalid emails respectively. # Email validation regex pattern pattern = re.compile(r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+') valid_emails = [] invalid_emails = [] for email in emails: cleaned_email = email.strip().lower() if pattern.match(cleaned_email) and '..' not in cleaned_email: valid_emails.append(cleaned_email) else: invalid_emails.append(email.strip()) # retain original format for invalid emails return { \\"valid_emails\\": valid_emails, \\"invalid_emails\\": invalid_emails }"},{"question":"def calculate_directory_size(directory: dict) -> int: Calculate the total size of files within a directory structure, taking into account nested subdirectories. >>> example_directory = { ... 'file1.txt': 100, ... 'file2.txt': 200, ... 'subdir1': { ... 'file3.txt': 300, ... 'file4.txt': 400, ... 'subdir2': { ... 'file5.txt': 500, ... 'file6.txt': 600, ... } ... }, ... 'subdir3': { ... 'file7.txt': 700 ... } ... } >>> calculate_directory_size(example_directory) 2800 >>> calculate_directory_size({}) 0 >>> calculate_directory_size({'file1.txt': 100}) 100 >>> calculate_directory_size({'subdir1': {'file1.txt': 100}}) 100 >>> nested_subdirs = { ... 'dir1': { ... 'file1.txt': 50, ... 'subdir1': {'file2.txt': 100}, ... 'subdir2': {'subdir3': {'file3.txt': 150}} ... }, ... 'file4.txt': 200 ... } >>> calculate_directory_size(nested_subdirs) 500 >>> large_directory = { ... 'hugefile.txt': 1_000_000, ... 'dir1': {'bigfile.txt': 500_000}, ... 'dir2': {'subdir1': {'giganticfile.txt': 2_000_000}} ... } >>> calculate_directory_size(large_directory) 3_500_000","solution":"def calculate_directory_size(directory: dict) -> int: total_size = 0 def traverse_directory(sub_directory): nonlocal total_size for key, value in sub_directory.items(): if isinstance(value, dict): traverse_directory(value) else: total_size += value traverse_directory(directory) return total_size"},{"question":"def find_palindromes(filepath: str) -> list[str]: Reads a file and returns a list of palindromes found in the file. Words are case-insensitive palindromes. >>> find_palindromes('words.txt') ['Racecar', 'Level', 'Rotator'] # Your code here import tempfile import os def test_find_palindromes_with_mixed_case(): words = [\\"Racecar\\", \\"Level\\", \\"Algorithm\\", \\"Rotator\\", \\"Palindrome\\"] expected_palindromes = [\\"Racecar\\", \\"Level\\", \\"Rotator\\"] with tempfile.NamedTemporaryFile(delete=False) as tf: file_name = tf.name tf.write(\\"n\\".join(words).encode('utf-8')) try: result = find_palindromes(file_name) assert result == expected_palindromes finally: os.remove(file_name) def test_find_palindromes_with_no_palindromes(): words = [\\"Algorithm\\", \\"Data\\", \\"Science\\"] expected_palindromes = [] with tempfile.NamedTemporaryFile(delete=False) as tf: file_name = tf.name tf.write(\\"n\\".join(words).encode('utf-8')) try: result = find_palindromes(file_name) assert result == expected_palindromes finally: os.remove(file_name) def test_find_palindromes_with_all_palindromes(): words = [\\"Racecar\\", \\"Madam\\", \\"Civic\\", \\"Radar\\", \\"Rotator\\"] expected_palindromes = words with tempfile.NamedTemporaryFile(delete=False) as tf: file_name = tf.name tf.write(\\"n\\".join(words).encode('utf-8')) try: result = find_palindromes(file_name) assert result == expected_palindromes finally: os.remove(file_name) def test_find_palindromes_with_empty_file(): words = [] expected_palindromes = [] with tempfile.NamedTemporaryFile(delete=False) as tf: file_name = tf.name tf.write(\\"n\\".join(words).encode('utf-8')) try: result = find_palindromes(file_name) assert result == expected_palindromes finally: os.remove(file_name) def test_find_palindromes_with_single_character_words(): words = [\\"a\\", \\"b\\", \\"C\\", \\"D\\"] expected_palindromes = [\\"a\\", \\"b\\", \\"C\\", \\"D\\"] with tempfile.NamedTemporaryFile(delete=False) as tf: file_name = tf.name tf.write(\\"n\\".join(words).encode('utf-8')) try: result = find_palindromes(file_name) assert result == expected_palindromes finally: os.remove(file_name)","solution":"def find_palindromes(filepath: str) -> list[str]: Reads a file and returns a list of palindromes found in the file. Words are case-insensitive palindromes. Parameters: filepath (str): The path to the text file containing words. Returns: list[str]: A list of palindromic words. palindromes = [] with open(filepath, 'r') as file: for line in file: word = line.strip() if word.lower() == word[::-1].lower(): palindromes.append(word) return palindromes"},{"question":"from typing import List def intersection(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of integers that appear in both input lists. >>> intersection([1, 2, 3, 4], [3, 4, 5, 6]) [3, 4] >>> intersection([], [3, 4, 5, 6]) [] >>> intersection([1, 2, 3, 4], []) [] >>> intersection([1, 2, 2, 3], [2, 2, 3, 3]) [2, 3] def union(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of all unique integers that appear in either input list. >>> union([1, 2, 3, 4], [3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> union([], [3, 4, 5, 6]) [3, 4, 5, 6] >>> union([1, 2, 3, 4], []) [1, 2, 3, 4] >>> union([1, 2, 2, 3], [3, 3, 4, 4]) [1, 2, 3, 4] def main(): Accepts two lists of integers from the user, calculates their intersection and union, and prints the results.","solution":"from typing import List def intersection(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of integers that appear in both input lists. intersect = list(set(list1) & set(list2)) return sorted(intersect) def union(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of all unique integers that appear in either input list. union_set = list(set(list1) | set(list2)) return sorted(union_set) def main(): list1 = list(map(int, input(\\"Enter the first list of integers separated by spaces: \\").split())) list2 = list(map(int, input(\\"Enter the second list of integers separated by spaces: \\").split())) print(\\"Intersection:\\", intersection(list1, list2)) print(\\"Union:\\", union(list1, list2))"},{"question":"Write a function \`suggest_friends\` that accepts an undirected graph represented as an adjacency list and a user identifier, and returns a list of suggested friends based on mutual friends count. The function should suggest users who are not already friends with the given user and have the highest number of mutual friends with them. def suggest_friends(graph, user_id): ''' Suggest friends for the given user based on mutual friends count. Args: graph (dict): An undirected graph represented as an adjacency list. user_id (int): The user identifier for whom the friend suggestions will be made. Returns: list: A list of suggested friends, sorted in ascending order. ''' user_friends = set(graph[user_id]) mutual_friends_count = {} for friend in user_friends: for mutual_friend in graph[friend]: if mutual_friend != user_id and mutual_friend not in user_friends: if mutual_friend not in mutual_friends_count: mutual_friends_count[mutual_friend] = 0 mutual_friends_count[mutual_friend] += 1 if not mutual_friends_count: return [] max_mutual_friends = max(mutual_friends_count.values()) suggested_friends = [user for user, count in mutual_friends_count.items() if count == max_mutual_friends] return sorted(suggested_friends)","solution":"def suggest_friends(graph, user_id): Suggest friends for the given user based on mutual friends count. Args: graph (dict): An undirected graph represented as an adjacency list. user_id (int): The user identifier for whom the friend suggestions will be made. Returns: list: A list of suggested friends, sorted in ascending order. user_friends = set(graph[user_id]) mutual_friends_count = {} for friend in user_friends: for mutual_friend in graph[friend]: if mutual_friend != user_id and mutual_friend not in user_friends: if mutual_friend not in mutual_friends_count: mutual_friends_count[mutual_friend] = 0 mutual_friends_count[mutual_friend] += 1 if not mutual_friends_count: return [] max_mutual_friends = max(mutual_friends_count.values()) suggested_friends = [user for user, count in mutual_friends_count.items() if count == max_mutual_friends] return sorted(suggested_friends)"},{"question":"from typing import List def custom_sort(nums: List[int]) -> List[int]: Custom sort function that places all negative numbers before positive numbers, while preserving the original relative order within negative and positive groups. >>> custom_sort([3, -1, -4, 2, -6, 5, 0]) [-1, -4, -6, 3, 2, 5, 0] >>> custom_sort([-3, -2, -1]) [-3, -2, -1] >>> custom_sort([1, 2, 3]) [1, 2, 3] >>> custom_sort([0, -1, -3, 2]) [-1, -3, 0, 2] >>> custom_sort([0, -1, 2, -1, 2, -2]) [-1, -1, -2, 0, 2, 2] >>> custom_sort([]) [] >>> custom_sort([0]) [0] >>> custom_sort([-1]) [-1] >>> custom_sort([1]) [1] pass","solution":"from typing import List def custom_sort(nums: List[int]) -> List[int]: Custom sort function that places all negative numbers before positive numbers, while preserving the original relative order within negative and positive groups. :param nums: List of integers to be sorted. :return: A list of integers sorted as described. negative_numbers = [number for number in nums if number < 0] non_negative_numbers = [number for number in nums if number >= 0] return negative_numbers + non_negative_numbers"},{"question":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> None: Transposes the given n x n square matrix in place. :param matrix: A 2D list representing the square matrix to be transposed. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> transpose_matrix(matrix) >>> matrix == [ ... [1, 4, 7], ... [2, 5, 8], ... [3, 6, 9] ... ] True >>> matrix = [ ... [1] ... ] >>> transpose_matrix(matrix) >>> matrix == [ ... [1] ... ] True >>> matrix = [ ... [3, 4], ... [1, 8] ... ] >>> transpose_matrix(matrix) >>> matrix == [ ... [3, 1], ... [4, 8] ... ] True pass","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> None: Transposes the given n x n square matrix in place. :param matrix: A 2D list representing the square matrix to be transposed. n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"def remove_duplicates_and_count(s: str) -> dict: Removes duplicate characters from a string and returns a dictionary containing the count of each unique character. Parameters: s (str): The input string. Returns: dict: A dictionary with unique characters as keys and their counts as values. Examples: >>> remove_duplicates_and_count(\\"abracadabra\\") {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} >>> remove_duplicates_and_count(\\"hello world!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1, '!': 1} >>> remove_duplicates_and_count(\\"112233\\") {'1': 2, '2': 2, '3': 2} >>> remove_duplicates_and_count(\\"aA!@#%^&*()\\") {'a': 1, 'A': 1, '!': 1, '@': 1, '#': 1, '': 1, '%': 1, '^': 1, '&': 1, '*': 1, '(': 1, ')': 1}","solution":"def remove_duplicates_and_count(s: str) -> dict: Removes duplicate characters from a string and returns a dictionary containing the count of each unique character. Parameters: s (str): The input string. Returns: dict: A dictionary with unique characters as keys and their counts as values. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"from datetime import datetime def update_order_status(orders: list, current_date: str) -> list: Updates the status of orders based on the given current date. Args: orders (list): A list of dictionaries where each dictionary contains: - \`order_id\` (str): The unique identifier for the order. - \`estimated_delivery_date\` (str): The estimated delivery date in 'YYYY-MM-DD' format. - \`status\` (str): The current status of the order ('Processing', 'Shipped', 'Out for Delivery', 'Delivered'). current_date (str): The current date in 'YYYY-MM-DD' format. Returns: list: The updated list of orders with their statuses changed appropriately. Examples: >>> orders = [ ... {\\"order_id\\": \\"1001\\", \\"estimated_delivery_date\\": \\"2023-11-05\\", \\"status\\": \\"Processing\\"}, ... {\\"order_id\\": \\"1002\\", \\"estimated_delivery_date\\": \\"2023-10-14\\", \\"status\\": \\"Processing\\"}, ... {\\"order_id\\": \\"1003\\", \\"estimated_delivery_date\\": \\"2023-10-11\\", \\"status\\": \\"Processing\\"}, ... ] >>> current_date = \\"2023-10-14\\" >>> update_order_status(orders, current_date) [ {\\"order_id\\": \\"1001\\", \\"estimated_delivery_date\\": \\"2023-11-05\\", \\"status\\": \\"Shipped\\"}, {\\"order_id\\": \\"1002\\", \\"estimated_delivery_date\\": \\"2023-10-14\\", \\"status\\": \\"Out for Delivery\\"}, {\\"order_id\\": \\"1003\\", \\"estimated_delivery_date\\": \\"2023-10-11\\", \\"status\\": \\"Delivered\\"}, ]","solution":"from datetime import datetime def update_order_status(orders, current_date): Updates the status of orders based on the given current date. Args: orders (list): A list of dictionaries where each dictionary contains order_id, estimated_delivery_date, and status. current_date (str): The current date in 'YYYY-MM-DD' format. Returns: list: The updated list of orders with their statuses changed appropriately. current_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") for order in orders: estimated_delivery_date = datetime.strptime(order[\\"estimated_delivery_date\\"], \\"%Y-%m-%d\\") if current_date < estimated_delivery_date: order[\\"status\\"] = \\"Shipped\\" elif current_date == estimated_delivery_date: order[\\"status\\"] = \\"Out for Delivery\\" else: order[\\"status\\"] = \\"Delivered\\" return orders"},{"question":"def find_missing(sequence: List[int]) -> int: Find the missing number in a Fibonacci-like sequence. >>> find_missing([1, 1, 2, 3, 5, 8, 13, 21]) == 0 >>> find_missing([1, 1, 2, 3, 5, 13, 21, 34]) == 8 >>> find_missing([2, 3, 5, 8, 13, 21, 34, 55, 144]) == 89 >>> find_missing([1, 4, 5, 9, 14]) == 0","solution":"from typing import List def find_missing(sequence: List[int]) -> int: Finds the missing number in a Fibonacci-like sequence. n = len(sequence) for i in range(2, n): # If the sequence is correct up to i-1 elements, find if the current element fits the pattern if sequence[i] != sequence[i-1] + sequence[i-2]: # Found a discrepancy; now determine which number is missing # Case 1: The missing number is between (i-2) and (i-1) if i-2 > 0 and sequence[i] == sequence[i-2] + sequence[i-1] + sequence[i-3]: return sequence[i-2] + sequence[i-1] # Case 2: The missing number is at position i (sequence[i] should be sequence[i-1] + sequence[i-2]) else: return sequence[i-1] + sequence[i-2] # If no missing number is found, return 0 (which means sequence is actually correct) return 0"},{"question":"def calculate_stock_out_frequency(items: list[str], sales_data: list[list[dict[str, bool]]]) -> dict[str, float]: Calculates the stock-out frequency of items. :param items: List of item names. :param sales_data: List of lists, where each inner list contains sales records for a single day. Each sales record is a dictionary with \\"item\\" (string) and \\"sold_out\\" (boolean) fields. :return: A dictionary where keys are item names, and values are floats representing the percentage of days the item was sold out, rounded to 2 decimal places. Example: >>> items = [\\"item1\\", \\"item2\\", \\"item3\\"] >>> sales_data = [ ... [{\\"item\\": \\"item1\\", \\"sold_out\\": True}, {\\"item\\": \\"item2\\", \\"sold_out\\": False}], ... [{\\"item\\": \\"item1\\", \\"sold_out\\": False}, {\\"item\\": \\"item2\\", \\"sold_out\\": True}], ... [{\\"item\\": \\"item1\\", \\"sold_out\\": True}, {\\"item\\": \\"item2\\", \\"sold_out\\": True}], ... [{\\"item\\": \\"item3\\", \\"sold_out\\": False}, {\\"item\\": \\"item1\\", \\"sold_out\\": True}], ... ] >>> calculate_stock_out_frequency(items, sales_data) {'item1': 75.00, 'item2': 50.00, 'item3': 0.00}","solution":"def calculate_stock_out_frequency(items, sales_data): Calculates the stock-out frequency of items. :param items: List of item names. :param sales_data: List of lists, where each inner list contains sales records for a single day. Each sales record is a dictionary with \\"item\\" (string) and \\"sold_out\\" (boolean) fields. :return: A dictionary where keys are item names, and values are floats representing the percentage of days the item was sold out, rounded to 2 decimal places. # Initialize a dictionary to keep track of the count of sold-out days for each item sold_out_count = {item: 0 for item in items} total_days = len(sales_data) # Total number of days in the sales data for daily_sales in sales_data: for record in daily_sales: if record[\\"item\\"] in sold_out_count and record[\\"sold_out\\"]: sold_out_count[record[\\"item\\"]] += 1 # Calculating the percentage of sold-out days for each item sold_out_frequency = {item: round((sold_out_count[item] / total_days) * 100, 2) if total_days > 0 else 0.00 for item in items} return sold_out_frequency"},{"question":"from typing import List def non_repeating_element(nums: List[int]) -> int: Returns the first non-repeating element in the list. If all elements are repeating, returns -1. >>> non_repeating_element([4, 5, 1, 2, 0, 4]) == 5 >>> non_repeating_element([1, 2, 2, 1, 3, 3]) == -1 >>> non_repeating_element([7]) == 7 >>> non_repeating_element([3, 3, 5, 5, 1]) == 1 >>> non_repeating_element([]) == -1 >>> non_repeating_element([10, 20, 30, 20, 10, 40]) == 30 >>> non_repeating_element([-1, -1, -2, -3, -2]) == -3","solution":"from typing import List from collections import Counter def non_repeating_element(nums: List[int]) -> int: Returns the first non-repeating element in the list. If all elements are repeating, returns -1. count = Counter(nums) for num in nums: if count[num] == 1: return num return -1"},{"question":"def search_books(titles: list[str], query: str) -> list[str]: Function to search for book titles containing the query string, ignoring case. Parameters: titles (list of str): The list of book titles. query (str): The search query to match within the book titles. Returns: list of str: A list of book titles that contain the search query, case-insensitively. >>> search_books([\\"The Great Gatsby\\", \\"Catching Fire\\", \\"To Kill a Mockingbird\\", \\"Great Expectations\\"], \\"great\\") [\\"The Great Gatsby\\", \\"Great Expectations\\"] >>> search_books([\\"The Great Gatsby\\", \\"Catching Fire\\", \\"To Kill a Mockingbird\\", \\"Great Expectations\\"], \\"FIRE\\") [\\"Catching Fire\\"] >>> search_books([\\"Pride and Prejudice\\", \\"War and Peace\\", \\"1984\\", \\"Brave New World\\"], \\"and\\") [\\"Pride and Prejudice\\", \\"War and Peace\\"]","solution":"def search_books(titles: list[str], query: str) -> list[str]: Function to search for book titles containing the query string, ignoring case. Parameters: titles (list of str): The list of book titles. query (str): The search query to match within the book titles. Returns: list of str: A list of book titles that contain the search query, case-insensitively. lower_query = query.lower() result = [title for title in titles if lower_query in title.lower()] return result"},{"question":"class StringAnalyzer: def __init__(self, string: str): self.string = string def longest_palindromic_substring(self) -> str: Calculate the longest palindromic substring within the given string and return the result as a new string. >>> s_analyzer = StringAnalyzer(\\"babad\\") >>> s_analyzer.longest_palindromic_substring() 'bab' # or 'aba' >>> s_analyzer = StringAnalyzer(\\"cbbd\\") >>> s_analyzer.longest_palindromic_substring() 'bb'","solution":"class StringAnalyzer: def __init__(self, string: str): self.string = string def longest_palindromic_substring(self) -> str: def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not self.string: return \\"\\" longest_palindrome = \\"\\" for i in range(len(self.string)): # Odd length palindromes (single character center) odd_palindrome = expand_around_center(self.string, i, i) if len(odd_palindrome) > len(longest_palindrome): longest_palindrome = odd_palindrome # Even length palindromes (two character center) even_palindrome = expand_around_center(self.string, i, i + 1) if len(even_palindrome) > len(longest_palindrome): longest_palindrome = even_palindrome return longest_palindrome"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[Optional[TreeNode]]: Generate all unique BSTs that store values 1...n. >>> results = generate_trees(1) >>> len(results) 1 >>> results[0].val 1 >>> results = generate_trees(2) >>> len(results) 2 >>> any(tree.val == 1 and tree.right.val == 2 for tree in results) True >>> any(tree.val == 2 and tree.left.val == 1 for tree in results) True >>> results = generate_trees(3) >>> len(results) 5 >>> any(tree.val == 1 and tree.right.val == 2 and tree.right.right.val == 3 for tree in results) True >>> any(tree.val == 3 and tree.left.val == 2 and tree.left.left.val == 1 for tree in results) True pass","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[Optional[TreeNode]]: if n == 0: return [] def generate_trees_helper(start: int, end: int) -> List[Optional[TreeNode]]: if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_trees_helper(start, i - 1) right_trees = generate_trees_helper(i + 1, end) for l in left_trees: for r in right_trees: curr_tree = TreeNode(i) curr_tree.left = l curr_tree.right = r all_trees.append(curr_tree) return all_trees return generate_trees_helper(1, n)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Rearranges the given string into the lexicographically smallest string by performing exactly one swap of two different characters. >>> lexicographically_smallest_string(\\"dcba\\") \\"acbd\\" >>> lexicographically_smallest_string(\\"abba\\") \\"aabb\\" pass # Example usage: result = lexicographically_smallest_string(\\"dcba\\") print(result) # Output: \\"acbd\\"","solution":"def lexicographically_smallest_string(s: str) -> str: Rearranges the given string into the lexicographically smallest string by performing exactly one swap of two different characters. n = len(s) s_list = list(s) # Trying to find the smallest character for any given position for i in range(n): min_char = min(s_list[i+1:], default=s_list[i]) if min_char < s_list[i]: min_pos = s_list[i+1:].index(min_char) + (i + 1) s_list[i], s_list[min_pos] = s_list[min_pos], s_list[i] break return ''.join(s_list)"},{"question":"from typing import List def most_frequent_urls(urls: List[str]) -> List[str]: Takes a list of URLs and returns a list of the most frequent URLs in descending order of frequency. If there are ties, URLs should be returned in the order they first appeared in the input list. >>> most_frequent_urls([]) [] >>> most_frequent_urls([\\"a.com\\", \\"b.com\\", \\"a.com\\", \\"c.com\\", \\"b.com\\", \\"a.com\\"]) [\\"a.com\\", \\"b.com\\", \\"c.com\\"] >>> most_frequent_urls([\\"a.com\\", \\"b.com\\", \\"c.com\\", \\"b.com\\", \\"a.com\\", \\"c.com\\"]) [\\"a.com\\", \\"b.com\\", \\"c.com\\"] >>> most_frequent_urls([\\"x.com\\"]) [\\"x.com\\"]","solution":"from typing import List from collections import Counter, OrderedDict def most_frequent_urls(urls: List[str]) -> List[str]: if not urls: return [] counter = Counter(urls) ordered_counter = OrderedDict(sorted(counter.items(), key=lambda x: (-x[1], urls.index(x[0])))) return list(ordered_counter.keys())"},{"question":"from typing import List def missing_number(sequence: List[int]) -> int: Returns the missing number in the arithmetic sequence. >>> missing_number([5, 10, 15, 25, 30]) == 20 >>> missing_number([-2, 0, 2, 6]) == 4","solution":"def missing_number(sequence): Returns the missing number in the arithmetic sequence. n = len(sequence) # Calculate the common difference (using the first two elements) difference = (sequence[-1] - sequence[0]) // n # Expected value calculation for i in range(1, n): expected_value = sequence[0] + i * difference if sequence[i] != expected_value: return expected_value # Example usage print(missing_number([5, 10, 15, 25, 30])) # Output should be 20 print(missing_number([-2, 0, 2, 6])) # Output should be 4"},{"question":"def optimized_reverse_and_sort(arr: list) -> list: Returns the sorted version of the reversed input list. >>> optimized_reverse_and_sort([3, 1, 4, 1, 5, 9, 2, 6]) [1, 1, 2, 3, 4, 5, 6, 9] >>> optimized_reverse_and_sort([5, -1, -10, 8, 0]) [-10, -1, 0, 5, 8] >>> optimized_reverse_and_sort([]) [] >>> optimized_reverse_and_sort([10]) [10] >>> optimized_reverse_and_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> optimized_reverse_and_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> optimized_reverse_and_sort([7, 7, 7, 7, 7]) [7, 7, 7, 7, 7] >>> arr = list(range(-1000, 1000)) >>> optimized_reverse_and_sort(arr) == sorted(arr) True >>> optimized_reverse_and_sort([3, 1, 1, 2, 7, 6, 5, 4, 9, 8]) [1, 1, 2, 3, 4, 5, 6, 7, 8, 9] pass","solution":"def optimized_reverse_and_sort(arr: list) -> list: Returns the sorted version of the reversed input list. # Sorting the array, which inherently handles the order return sorted(arr)"},{"question":"def find_missing_number(nums: list[int]) -> int: Finds the smallest missing positive integer in an unsorted list of integers. Args: nums: List[int] - A list of integers. Returns: int - The smallest missing positive integer. >>> find_missing_number([1, 2, 0]) 3 >>> find_missing_number([3, 4, -1, 1]) 2 >>> find_missing_number([7, 8, 9, 11, 12]) 1 >>> find_missing_number([1, 2, 3, 4, 5, 6]) 7 >>> find_missing_number([-5, -10, -1]) 1","solution":"def find_missing_number(nums: list[int]) -> int: Finds the smallest missing positive integer in an unsorted list of integers. Args: nums: List[int] - A list of integers. Returns: int - The smallest missing positive integer. n = len(nums) # Place each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: correct_pos = nums[i] - 1 nums[i], nums[correct_pos] = nums[correct_pos], nums[i] # Find the first missing positive integer for i in range(n): if nums[i] != i + 1: return i + 1 # if all positions are correct, the missing integer is n + 1 return n + 1"},{"question":"def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: Convert a temperature from one scale to another. >>> convert_temperature(100, 'Celsius', 'Fahrenheit') 212.0 >>> convert_temperature(0, 'Celsius', 'Kelvin') 273.15 >>> convert_temperature(32, 'Fahrenheit', 'Celsius') 0.0 >>> convert_temperature(0, 'Kelvin', 'Celsius') -273.15","solution":"def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: if from_scale == 'Kelvin' and value < 0: raise ValueError(\\"Temperature in Kelvin cannot be less than 0\\") if from_scale == \\"Celsius\\": if to_scale == \\"Fahrenheit\\": return value * 9/5 + 32 elif to_scale == \\"Kelvin\\": return value + 273.15 elif from_scale == \\"Fahrenheit\\": if to_scale == \\"Celsius\\": return (value - 32) * 5/9 elif to_scale == \\"Kelvin\\": return (value - 32) * 5/9 + 273.15 elif from_scale == \\"Kelvin\\": if to_scale == \\"Celsius\\": return value - 273.15 elif to_scale == \\"Fahrenheit\\": return (value - 273.15) * 9/5 + 32 return value # If from_scale equals to_scale"},{"question":"def find_longest_word(s: str, dictionary: List[str]) -> str: Find the longest word in \`dictionary\` that can be formed by deleting some characters of the string \`s\` without reordering the remaining characters. >>> find_longest_word(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) \\"apple\\" >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"a\\"","solution":"from typing import List def find_longest_word(s: str, dictionary: List[str]) -> str: def is_subsequence(x): it = iter(s) return all(c in it for c in x) dictionary.sort(key = lambda x: (-len(x), x)) for word in dictionary: if is_subsequence(word): return word return \\"\\""},{"question":"def sum_of_primes(m: int, n: int) -> int: Compute the sum of all prime numbers between two given integers m and n, inclusive. >>> sum_of_primes(1, 10) 17 >>> sum_of_primes(10, 20) 60 >>> sum_of_primes(5, 5) 5 >>> sum_of_primes(20, 30) 52 >>> sum_of_primes(1, 100) 1060","solution":"import math def sum_of_primes(m: int, n: int) -> int: Returns the sum of all prime numbers between m and n inclusive. if n < 2: return 0 if m < 2: m = 2 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(math.sqrt(n)) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False return sum(i for i in range(m, n + 1) if sieve[i])"},{"question":"def longest_unique_substring_length() -> int: Reads the content from 'input.txt' and returns the length of the longest substring without repeating characters. >>> longest_unique_substring_length() 3 >>> longest_unique_substring_length() 1","solution":"def longest_unique_substring_length() -> int: Reads the content from 'input.txt' and returns the length of the longest substring without repeating characters. with open('input.txt', 'r') as file: s = file.readline().strip() char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def closest_pair(numbers: list) -> tuple: Finds the two distinct elements in the list with the smallest absolute difference. >>> closest_pair([4, 9, 1, 17, 8, 3, 5]) (3, 4) >>> closest_pair([-5, 1, 10, 2, -4]) (-5, -4)","solution":"def closest_pair(numbers: list) -> tuple: Finds the two distinct elements in the list with the smallest absolute difference. # Sort the list to make it easier to find closest pairs numbers.sort() # Initialize the smallest difference to a large number smallest_diff = float('inf') closest_pair = (0, 0) # Iterate through sorted list and check consecutive pairs for i in range(len(numbers) - 1): diff = abs(numbers[i] - numbers[i + 1]) if diff < smallest_diff: smallest_diff = diff closest_pair = (numbers[i], numbers[i + 1]) return closest_pair"},{"question":"from typing import List, Tuple def summarize_list(numbers: List[int]) -> Tuple[int, int, int, int]: Summarizes the list of integers by calculating the sum, product, maximum, and minimum. Parameters: numbers (List[int]): List of integers. Returns: Tuple[int, int, int, int]: Tuple containing the sum, product, maximum, and minimum of the input list. Examples: >>> summarize_list([3, 5, 7, 2, 8]) (25, 1680, 8, 2) >>> summarize_list([-1, 2, -3, 4, -5]) (-3, 120, 4, -5)","solution":"from typing import List, Tuple def summarize_list(numbers: List[int]) -> Tuple[int, int, int, int]: Summarizes the list of integers by calculating the sum, product, maximum, and minimum. Parameters: numbers (List[int]): List of integers. Returns: Tuple[int, int, int, int]: Tuple containing the sum, product, maximum, and minimum of the input list. total_sum = sum(numbers) total_product = 1 for num in numbers: total_product *= num max_val = max(numbers) min_val = min(numbers) return total_sum, total_product, max_val, min_val"},{"question":"def convert_kelvin_to_fahrenheit(kelvin: float) -> float: Converts a temperature from Kelvin to Fahrenheit. Parameters: kelvin (float): A temperature in Kelvin. Must be in the range 0 <= kelvin <= 10000. Returns: float: The temperature converted to Fahrenheit. Raises: ValueError: If the kelvin value is outside the range 0 <= kelvin <= 10000. Examples: >>> convert_kelvin_to_fahrenheit(0) -459.67 >>> convert_kelvin_to_fahrenheit(273.15) 32.0 >>> convert_kelvin_to_fahrenheit(300) 80.33 >>> convert_kelvin_to_fahrenheit(10000) 17640.33","solution":"def convert_kelvin_to_fahrenheit(kelvin: float) -> float: Converts a temperature from Kelvin to Fahrenheit. Parameters: kelvin (float): A temperature in Kelvin. Must be in the range 0 <= kelvin <= 10000. Returns: float: The temperature converted to Fahrenheit. Raises: ValueError: If the kelvin value is outside the range 0 <= kelvin <= 10000. if kelvin < 0 or kelvin > 10000: raise ValueError(\\"Kelvin value must be in the range 0 <= kelvin <= 10000\\") fahrenheit = (kelvin - 273.15) * 9/5 + 32 return fahrenheit"},{"question":"import numpy as np def euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: Computes the Euclidean distance between two points. Parameters: - point1: np.ndarray - point2: np.ndarray Returns: - float: Euclidean distance. pass def k_nearest_neighbors(x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, k: int) -> np.ndarray: Classifies test samples based on the 'k' nearest training samples using the Euclidean distance metric. Parameters: - x_train: np.ndarray - 2D array of training data - y_train: np.ndarray - 1D array of training labels - x_test: np.ndarray - 2D array of test data - k: int - number of neighbors to consider Returns: - np.ndarray: 1D array of predicted labels for test data pass # Example Usage x_train = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [6.0, 7.0]]) y_train = np.array([0, 0, 1, 1]) x_test = np.array([[1.5, 2.5], [5.0, 6.0]]) k = 3 y_pred = k_nearest_neighbors(x_train, y_train, x_test, k) print(\\"Predicted Labels:\\", y_pred)","solution":"import numpy as np from collections import Counter def euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: Computes the Euclidean distance between two points. Parameters: - point1: np.ndarray - point2: np.ndarray Returns: - float: Euclidean distance. return np.sqrt(np.sum((point1 - point2) ** 2)) def k_nearest_neighbors(x_train: np.ndarray, y_train: np.ndarray, x_test: np.ndarray, k: int) -> np.ndarray: Classifies test samples based on the 'k' nearest training samples using the Euclidean distance metric. Parameters: - x_train: np.ndarray - 2D array of training data - y_train: np.ndarray - 1D array of training labels - x_test: np.ndarray - 2D array of test data - k: int - number of neighbors to consider Returns: - np.ndarray: 1D array of predicted labels for test data y_pred = [] for test_point in x_test: distances = [euclidean_distance(test_point, train_point) for train_point in x_train] sorted_indices = np.argsort(distances) top_k_indices = sorted_indices[:k] top_k_labels = y_train[top_k_indices] label_counts = Counter(top_k_labels) most_common_label = sorted(label_counts.items(), key=lambda item: (-item[1], item[0]))[0][0] y_pred.append(most_common_label) return np.array(y_pred)"},{"question":"from typing import List def find_subset_sum(nums: List[int], target: int) -> bool: Determine if there is a subset of the given list such that the subset's sum is equal to the target sum. >>> find_subset_sum([1, 2, 3], 4) True >>> find_subset_sum([1, 2, 3], 5) True >>> find_subset_sum([1, 2, 3], 7) False >>> find_subset_sum([1, 2, 3, 4, 5], 10) True >>> find_subset_sum([1, 2, 3, 4, 5], 11) True >>> find_subset_sum([2, 4, 8], 5) False","solution":"from typing import List, Tuple, Dict def find_subset_sum(nums: List[int], target: int) -> bool: memo: Dict[Tuple[int, int], bool] = {} def dfs(index: int, current_sum: int) -> bool: if current_sum == target: return True if current_sum > target or index == len(nums): return False if (index, current_sum) in memo: return memo[(index, current_sum)] # Include the current number include = dfs(index + 1, current_sum + nums[index]) # Exclude the current number exclude = dfs(index + 1, current_sum) memo[(index, current_sum)] = include or exclude return memo[(index, current_sum)] return dfs(0, 0)"},{"question":"from typing import List, Dict, Optional import datetime class BlogPost: def __init__(self): self.posts = {} self.current_id = 0 def create_post(self, title: str, content: str, tags: Optional[List[str]] = None) -> int: Create a new blog post and return its unique identifier. # Implementation goes here. def edit_post(self, post_id: int, title: Optional[str] = None, content: Optional[str] = None, tags: Optional[List[str]] = None) -> bool: Edit an existing blog post identified by post_id. Return True if successful, else False. # Implementation goes here. def delete_post(self, post_id: int) -> bool: Delete a blog post identified by post_id. Return True if successful, else False. # Implementation goes here. def get_posts(self, tag: Optional[str] = None) -> List[Dict]: Retrieve all blog posts or filter by specific tag if provided. # Implementation goes here. # Example Usage: # Initialize the BlogPost class blog = BlogPost() # Create a new post post_id = blog.create_post(\\"My First Post\\", \\"This is the content of my first post.\\", [\\"intro\\", \\"first\\"]) # Edit the post blog.edit_post(post_id, content=\\"Updated content of my first post.\\") # Retrieve all posts all_posts = blog.get_posts() # Delete the post blog.delete_post(post_id) # Retrieve posts with a specific tag filtered_posts = blog.get_posts(tag=\\"intro\\")","solution":"from typing import List, Dict, Optional import datetime class BlogPost: def __init__(self): self.posts = {} self.current_id = 1 def create_post(self, title: str, content: str, tags: Optional[List[str]] = None) -> int: if not title or not content: raise ValueError(\\"Title and content cannot be empty.\\") post = { \\"id\\": self.current_id, \\"title\\": title, \\"content\\": content, \\"tags\\": tags if tags else [], \\"timestamp\\": datetime.datetime.now() } self.posts[self.current_id] = post self.current_id += 1 return post[\\"id\\"] def edit_post(self, post_id: int, title: Optional[str] = None, content: Optional[str] = None, tags: Optional[List[str]] = None) -> bool: if post_id not in self.posts: return False if title is not None: self.posts[post_id][\\"title\\"] = title if content is not None: self.posts[post_id][\\"content\\"] = content if tags is not None: self.posts[post_id][\\"tags\\"] = tags self.posts[post_id][\\"timestamp\\"] = datetime.datetime.now() return True def delete_post(self, post_id: int) -> bool: if post_id not in self.posts: return False del self.posts[post_id] return True def get_posts(self, tag: Optional[str] = None) -> List[Dict]: if tag: return [post for post in self.posts.values() if tag in post[\\"tags\\"]] return list(self.posts.values())"},{"question":"from collections import defaultdict class WordFrequencyCounter: A class that processes a given list of strings and provides frequency analysis of words. Methods: __init__(self, str_list): Initialize the WordFrequencyCounter with a list of strings. calculate_frequencies(self): Calculate the frequency of each word across all strings. word_frequency(self, word): Return the frequency of the given word. If the word does not exist, return 0. most_frequent_word(self): Return the word with the highest frequency. unique_word_count(self): Return the total number of unique words present. >>> str_list = [\\"apple orange banana\\", \\"apple apple orange\\", \\"banana orange apple\\"] >>> wf = WordFrequencyCounter(str_list) >>> wf.calculate_frequencies() >>> wf.word_frequency(\\"apple\\") == 4 True >>> wf.word_frequency(\\"banana\\") == 2 True >>> wf.word_frequency(\\"orange\\") == 3 True >>> wf.word_frequency(\\"grape\\") == 0 True >>> wf.most_frequent_word() in [\\"apple\\"] True >>> wf.unique_word_count() == 3 True def __init__(self, str_list): pass def calculate_frequencies(self): pass def word_frequency(self, word): pass def most_frequent_word(self): pass def unique_word_count(self): pass","solution":"from collections import defaultdict class WordFrequencyCounter: def __init__(self, str_list): Initialize the WordFrequencyCounter with a list of strings. self.str_list = str_list self.word_freq = defaultdict(int) def calculate_frequencies(self): Calculate the frequency of each word across all strings. for string in self.str_list: words = string.split() for word in words: self.word_freq[word] += 1 def word_frequency(self, word): Return the frequency of the given word. If the word does not exist, return 0. return self.word_freq.get(word, 0) def most_frequent_word(self): Return the word with the highest frequency. If there are multiple words with the same highest frequency, return any one of them. if not self.word_freq: return None return max(self.word_freq, key=self.word_freq.get) def unique_word_count(self): Return the total number of unique words present. return len(self.word_freq)"},{"question":"def top_k_frequent_products(transactions: list[int], k: int) -> list[int]: Returns the k most frequently occurring product IDs in the transactions. :param transactions: list of product IDs from transactions :param k: number of top-most frequent product IDs to return :return: a list of k most frequent product IDs >>> top_k_frequent_products([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2) [4, 3] >>> top_k_frequent_products([5, 5, 5, 2, 2, 8, 8, 8, 8, 7, 7, 1, 1, 1, 1], 3) [1, 8, 5]","solution":"from collections import defaultdict import heapq def top_k_frequent_products(transactions: list[int], k: int) -> list[int]: Returns the k most frequently occurring product IDs in the transactions. :param transactions: list of product IDs from transactions :param k: number of top-most frequent product IDs to return :return: a list of k most frequent product IDs # Step 1: Count frequency of each product ID freq_map = defaultdict(int) for product_id in transactions: freq_map[product_id] += 1 # Step 2: Use a heap to find the top k frequent product IDs heap = [] for product_id, frequency in freq_map.items(): heapq.heappush(heap, (-frequency, product_id)) # invert frequency for max-heap simulation # Step 3: Extract the top k elements from the heap top_k = [] for _ in range(k): top_k.append(heapq.heappop(heap)[1]) return top_k"},{"question":"def merge_shelves(shelves: List[List[int]]) -> List[int]: Merges a list of shelves into a single, sorted list of unique book IDs. Parameters: shelves (List[List[int]]): A list of shelves, each shelf is a list of book IDs. Returns: List[int]: A sorted list of unique book IDs. pass # Unit tests def test_merge_shelves_multiple_shelves(): shelves = [ [103, 203, 403], [123, 203, 403, 503], [1, 3, 103, 123, 1003] ] assert merge_shelves(shelves) == [1, 3, 103, 123, 203, 403, 503, 1003] def test_merge_shelves_empty_shelves(): shelves = [] assert merge_shelves(shelves) == [] def test_merge_shelves_with_repeated_books(): shelves = [ [1, 2, 3], [3, 2, 1], [1, 1, 1] ] assert merge_shelves(shelves) == [1, 2, 3] def test_merge_shelves_with_empty_shelves(): shelves = [ [], [], [1, 2, 3] ] assert merge_shelves(shelves) == [1, 2, 3] def test_merge_shelves_with_large_range_books(): shelves = [ [5000, 1, 10000], [9999, 0, 5000] ] assert merge_shelves(shelves) == [0, 1, 5000, 9999, 10000]","solution":"def merge_shelves(shelves): Merges a list of book shelves into a single sorted list of unique book IDs. Parameters: shelves (List[List[int]]): A list of shelves, each shelf is a list of book IDs. Returns: List[int]: A sorted list of unique book IDs. # Use a set to collect unique book IDs unique_books = set() # Iterate over each shelf and add book IDs to the set for shelf in shelves: for book_id in shelf: unique_books.add(book_id) # Convert the set to a sorted list and return return sorted(unique_books)"},{"question":"[Completion Task in Python] import os def enhanced_logger(log_message: str, log_dir: str = \\".\\", max_size: int = 1024) -> None: Manages the logging process and splits log files when they exceed a specified size limit. :param log_message: The message to be logged. :param log_dir: The directory where log files are stored. :param max_size: The maximum size (in bytes) for a log file before it is split. >>> import os >>> os.mkdir('test_logs') >>> enhanced_logger(\\"Test log message\\", log_dir=\\"test_logs\\", max_size=1024) >>> log_files = os.listdir('test_logs') >>> len(log_files) 1 >>> \\"log_1.txt\\" in log_files True pass","solution":"import os def enhanced_logger(log_message: str, log_dir: str = \\".\\", max_size: int = 1024) -> None: Writes a log message to the latest log file and splits the log files when they exceed the specified size limit. :param log_message: The message to be logged. :param log_dir: The directory where log files are stored. :param max_size: The maximum size (in bytes) for a log file before it is split. if not os.path.exists(log_dir): raise FileNotFoundError(f\\"The directory {log_dir} does not exist.\\") if not os.access(log_dir, os.W_OK): raise PermissionError(f\\"Insufficient permissions to write to the directory {log_dir}.\\") base_filename = \\"log_\\" extension = \\".txt\\" # Function to get the next log file number def get_next_log_number(directory, base_name, ext): existing_files = [name for name in os.listdir(directory) if name.startswith(base_name) and name.endswith(ext)] if not existing_files: return 1 else: numbers = [int(name[len(base_name):-len(ext)]) for name in existing_files] return max(numbers) + 1 current_log_number = get_next_log_number(log_dir, base_filename, extension) - 1 current_log_file = os.path.join(log_dir, f\\"{base_filename}{current_log_number}{extension}\\") # Check if the current log file exists and its size if not os.path.exists(current_log_file) or os.path.getsize(current_log_file) >= max_size: current_log_number += 1 current_log_file = os.path.join(log_dir, f\\"{base_filename}{current_log_number}{extension}\\") with open(current_log_file, \\"a\\") as log_file: log_file.write(log_message + \\"n\\")"},{"question":"def calculate_total_weight(weights: list) -> float: Computes the total weight of valid items in the list. Parameters: weights (list): List of item weights including integers, floats, and strings. Returns: float: Total weight of valid entries. Valid weights are positive numbers between 0.01 and 100.00 kilograms inclusive. Invalid weights include negative values, non-numeric strings, and values out of specified range. Example Usage: >>> calculate_total_weight([10, 20.5, \\"30\\", \\"40.2\\"]) 100.7 >>> calculate_total_weight([10, -5, \\"abc\\", 20, \\"15.5\\"]) 45.5 >>> calculate_total_weight([\\"10.0\\", \\"20.1\\", -5, 30, \\"40.00\\"]) 100.1 >>> calculate_total_weight([0, \\"0.5\\", 100, \\"abc\\", 50]) 150.5 >>> calculate_total_weight([\\"abc\\", -45, \\"70.1\\", \\"30\\"]) 100.1","solution":"def calculate_total_weight(weights): Computes the total weight of valid items in the list. Parameters: weights (list): List of item weights including integers, floats, and strings. Returns: float: Total weight of valid entries. total_weight = 0.0 for weight in weights: valid_weight = None try: # Convert string representations to floats if isinstance(weight, str): weight = float(weight) # Check if the weight is within the valid range if isinstance(weight, (int, float)) and 0.01 <= weight <= 100.00: valid_weight = weight else: raise ValueError except ValueError: print(f\\"Invalid weight: {weight}\\") if valid_weight is not None: total_weight += valid_weight return total_weight"},{"question":"def english_to_morse(text: str) -> str: Translate English text into Morse code. >>> english_to_morse(\\"SOS\\") == \\"... --- ...\\" >>> english_to_morse(\\"Hello World\\") == \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" >>> english_to_morse(\\"Python Programming\\") == \\".--. -.-- - .... --- -. / .--. .-. --- --. .-. .- -- -- .. -. --.\\"","solution":"def english_to_morse(text: str) -> str: morse_code_dict = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', 'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..' } words = text.split() translated_words = [] for word in words: translated_letters = [morse_code_dict.get(letter, '') for letter in word if letter in morse_code_dict] translated_word = ' '.join(translated_letters) if translated_word: translated_words.append(translated_word) return ' / '.join(translated_words)"},{"question":"def is_prime(number: int) -> bool: Check if a number is a prime number. >>> is_prime(5) True >>> is_prime(4) False pass def compute_factorial(number: int) -> int: Compute the factorial of a number. >>> compute_factorial(5) 120 >>> compute_factorial(0) 1 pass def analyze_number(number: int) -> tuple: Analyze the given number to determine if it is prime and to compute its factorial if it is less than or equal to 10. >>> analyze_number(5) (True, 120) >>> analyze_number(10) (False, 3628800) >>> analyze_number(12) (False, None) >>> analyze_number(7) (True, 5040) pass","solution":"import math def is_prime(number): Check if a number is a prime number. if number < 2: return False for i in range(2, int(math.sqrt(number)) + 1): if number % i == 0: return False return True def compute_factorial(number): Compute the factorial of a number. if number == 0: return 1 factorial = 1 for i in range(1, number + 1): factorial *= i return factorial def analyze_number(number): Analyze the given number to determine if it is prime and to compute its factorial if it is less than or equal to 10. if not isinstance(number, int) or number < 0: raise ValueError(\\"Number must be a non-negative integer.\\") prime_status = is_prime(number) factorial_result = compute_factorial(number) if number <= 10 else None return (prime_status, factorial_result)"},{"question":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral to an integer. Returns -1 if the input is invalid. >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"MMMCMXCIX\\") 3999 >>> roman_to_integer(\\"IIII\\") -1 >>> roman_to_integer(\\"VX\\") -1 >>> roman_to_integer(\\"MMXVIII\\") 2018","solution":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral to an integer. Returns -1 if the input is invalid. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } valid_pairs = { 'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900 } # Check for valid Roman numeral if not roman or any(c not in roman_to_int for c in roman): return -1 # Substitution list for invalid patterns invalid_patterns = [\\"IIII\\", \\"VV\\", \\"XXXX\\", \\"LL\\", \\"CCCC\\", \\"DD\\", \\"MMMM\\", \\"VX\\", \\"IL\\", \\"IC\\", \\"ID\\", \\"IM\\", \\"XD\\", \\"XM\\"] for pattern in invalid_patterns: if pattern in roman: return -1 i = 0 value = 0 length = len(roman) while i < length: # Check for a valid pair if i + 1 < length and roman[i:i+2] in valid_pairs: value += valid_pairs[roman[i:i+2]] i += 2 else: value += roman_to_int.get(roman[i], 0) i += 1 return value"},{"question":"import numpy as np def exponential_moving_average(data: np.ndarray, alpha: float) -> np.ndarray: Computes the Exponential Moving Average (EMA) of a given data array. Parameters: data (ndarray): A 1-dimensional array of numeric values. alpha (float): The smoothing factor, a value between 0 (exclusive) and 1 (inclusive). Returns: ema (ndarray): A 1-dimensional array of the same length as the input, containing the EMA of the input data. Examples: >>> data = np.array([1, 2, 3, 4, 5]) >>> alpha = 0.5 >>> exponential_moving_average(data, alpha) array([1. , 1.5, 2.25, 3.125, 4.0625]) >>> data = np.array([0]) >>> alpha = 0.5 >>> exponential_moving_average(data, alpha) array([0.])","solution":"import numpy as np def exponential_moving_average(data: np.ndarray, alpha: float) -> np.ndarray: Computes the Exponential Moving Average (EMA) of a given data array. Parameters: data (ndarray): A 1-dimensional array of numeric values. alpha (float): The smoothing factor, a value between 0 (exclusive) and 1 (inclusive). Returns: ema (ndarray): A 1-dimensional array of the same length as the input, containing the EMA of the input data. if not (0 < alpha <= 1): raise ValueError(\\"Alpha must be between 0 (exclusive) and 1 (inclusive).\\") ema = np.zeros(len(data)) ema[0] = data[0] # Set the first EMA value to the first data point for i in range(1, len(data)): ema[i] = alpha * data[i] + (1 - alpha) * ema[i - 1] return ema"},{"question":"def binary_search(sorted_list, target): :param sorted_list: sorted list of integers :param target: integer to find :return: index of target integer if found, -1 otherwise pass def test_binary_search(): assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 4) == 3 assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == -1 assert binary_search([], 1) == -1 assert binary_search([1, 2, 3, 4, 5], 1) == 0 assert binary_search([1, 2, 3, 4, 5], 5) == 4 assert binary_search([3], 3) == 0 assert binary_search([3], 4) == -1 large_list = list(range(100000)) assert binary_search(large_list, 67890) == 67890 assert binary_search(large_list, -1) == -1 assert binary_search(large_list, 100000) == -1 if __name__ == \\"__main__\\": test_binary_search()","solution":"def binary_search(sorted_list, target): :param sorted_list: sorted list of integers :param target: integer to find :return: index of target integer if found, -1 otherwise left, right = 0, len(sorted_list) - 1 while left <= right: mid = (left + right) // 2 if sorted_list[mid] == target: return mid elif sorted_list[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from typing import List, Tuple def min_rooms_needed(intervals: List[Tuple[int, int]]) -> int: Evaluate the maximum number of rooms used at any point during the reservation period. >>> min_rooms_needed([(1, 3), (2, 5), (4, 6)]) 2 >>> min_rooms_needed([(1, 2), (2, 3), (3, 4)]) 1","solution":"from typing import List, Tuple def min_rooms_needed(intervals: List[Tuple[int, int]]) -> int: times = [] for interval in intervals: times.append((interval[0], 'start')) times.append((interval[1], 'end')) times.sort() max_rooms = 0 current_rooms = 0 for time, ttype in times: if ttype == 'start': current_rooms += 1 max_rooms = max(max_rooms, current_rooms) else: current_rooms -= 1 return max_rooms"},{"question":"# Create a function that computes the shortest distance between two nodes in an undirected, weighted graph using Dijkstra's algorithm. import heapq from typing import List, Tuple def find_shortest_path(edges: List[Tuple[int, int, float]], start_node: int, end_node: int) -> float: if start_node == end_node: return 0.0 # Build the graph as an adjacency list graph = {} for node1, node2, weight in edges: if node1 not in graph: graph[node1] = [] if node2 not in graph: graph[node2] = [] graph[node1].append((weight, node2)) graph[node2].append((weight, node1)) # Dijkstra's algorithm priority_queue = [(0, start_node)] shortest_paths = {start_node: 0} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end_node: return current_distance for weight, neighbor in graph.get(current_node, []): distance = current_distance + weight if neighbor not in shortest_paths or distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return float('inf') # Test cases to validate the solution edges = [ (0, 1, 4.0), (0, 2, 1.0), (2, 1, 2.0), (1, 3, 1.0), (2, 3, 5.0) ] start_node = 0 end_node = 3 result = find_shortest_path(edges, start_node, end_node) print(result) # Output: 4.0","solution":"import heapq from typing import List, Tuple def find_shortest_path(edges: List[Tuple[int, int, float]], start_node: int, end_node: int) -> float: if start_node == end_node: return 0.0 # Build the graph as an adjacency list graph = {} for node1, node2, weight in edges: if node1 not in graph: graph[node1] = [] if node2 not in graph: graph[node2] = [] graph[node1].append((weight, node2)) graph[node2].append((weight, node1)) # Dijkstra's algorithm priority_queue = [(0, start_node)] shortest_paths = {start_node: 0} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end_node: return current_distance for weight, neighbor in graph.get(current_node, []): distance = current_distance + weight if neighbor not in shortest_paths or distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return float('inf')"},{"question":"def custom_sort(arr: list) -> list: Sort a list containing integers, floats, and strings by: 1. Integers in ascending order. 2. Floats in ascending order. 3. Strings alphabetically (case-insensitively). >>> custom_sort([42, \\"apple\\", 3.14, \\"Banana\\", 20, \\"cherry\\", 2.718, \\"APPLE\\"]) [20, 42, 2.718, 3.14, 'apple', 'APPLE', 'Banana', 'cherry'] >>> custom_sort([3, 1, 2]) [1, 2, 3] >>> custom_sort([3.1, 1.1, 2.1]) [1.1, 2.1, 3.1] >>> custom_sort([\\"banana\\", \\"Apple\\", \\"cherry\\"]) [\\"Apple\\", \\"banana\\", \\"cherry\\"] >>> custom_sort([]) [] >>> custom_sort([42]) [42] >>> custom_sort([3.14]) [3.14] >>> custom_sort([\\"apple\\"]) [\\"apple\\"] >>> custom_sort([\\"banana\\", \\"Apple\\", \\"cherry\\", \\"APPLE\\"]) [\\"Apple\\", \\"APPLE\\", \\"banana\\", \\"cherry\\"]","solution":"def custom_sort(arr: list) -> list: Sort a list containing integers, floats, and strings by: 1. Integers in ascending order. 2. Floats in ascending order. 3. Strings alphabetically (case-insensitively). # Separate the list into three different lists for each type: integers, floats, and strings int_part = [x for x in arr if isinstance(x, int)] float_part = [x for x in arr if isinstance(x, float)] str_part = [x for x in arr if isinstance(x, str)] # Sort each part individually int_part.sort() float_part.sort() str_part.sort(key=lambda s: s.lower()) # Concatenate the sorted lists in the required order return int_part + float_part + str_part"},{"question":"def transform_string(text: str) -> str: Returns a new string where no character appears consecutively more than once. Parameters: text (str): a non-empty string containing only uppercase English letters (A-Z) Returns: str: a transformed string with consecutive duplicates removed. Examples: >>> transform_string(\\"AAABBCCCCDDDE\\") 'ABCDE' >>> transform_string(\\"A\\") 'A' >>> transform_string(\\"AAA\\") 'A'","solution":"def transform_string(text: str) -> str: Returns a new string where no character appears consecutively more than once. Parameters: text (str): a non-empty string containing only uppercase English letters (A-Z) Returns: str: a transformed string with consecutive duplicates removed. if not text: return \\"\\" result = [text[0]] for char in text[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"import random import string def generate_unique_ids(n: int) -> list: Generate a list of n unique identifiers, each being 8 randomly chosen alphanumeric characters. >>> generate_unique_ids(5) ['a1B2c3D4', 'e5F6g7H8', 'i9J0k1L2', 'm3N4o5P6', 'q7R8s9T0'] >>> generate_unique_ids(1) ['x1Y2z3A4'] >>> generate_unique_ids('two') Traceback (most recent call last): ... ValueError: n must be an integer between 1 and 1000 inclusive >>> generate_unique_ids(0) Traceback (most recent call last): ... ValueError: n must be an integer between 1 and 1000 inclusive","solution":"import random import string def generate_unique_ids(n: int) -> list: if not isinstance(n, int) or not (1 <= n <= 1000): raise ValueError(\\"n must be an integer between 1 and 1000 inclusive\\") unique_ids = set() while len(unique_ids) < n: new_id = ''.join(random.choices(string.ascii_letters + string.digits, k=8)) unique_ids.add(new_id) return list(unique_ids)"},{"question":"def find_substrings(main_sentence: str, words: list[str]) -> list[str]: Identify which words from the list appear as exact substrings in the main sentence, case-insensitively. >>> find_substrings(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"dog\\", \\"cat\\", \\"Fox\\"]) [\\"quick\\", \\"dog\\", \\"Fox\\"] >>> find_substrings(\\"The quick brown fox jumps over the lazy dog\\", []) [] >>> find_substrings(\\"The quick brown fox jumps over the lazy dog\\", [\\"elephant\\", \\"giraffe\\"]) [] pass def substring_occurrence_count(main_sentence: str, words: list[str]) -> dict[str, int]: Count the number of times words from the provided list appear as exact substrings in the main sentence, case-insensitively. >>> substring_occurrence_count(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"dog\\", \\"cat\\", \\"Fox\\"]) {\\"quick\\": 1, \\"dog\\": 1, \\"Fox\\": 1} >>> substring_occurrence_count(\\"The quick brown fox jumps over the lazy dog\\", [\\"elephant\\", \\"giraffe\\"]) {} >>> substring_occurrence_count(\\"Repeat repeat repeat\\", [\\"repeat\\"]) {\\"repeat\\": 3} pass def substring_presence_score(main_sentence: str, words: list[str]) -> float: Calculate the percentage of words from the list that appear as exact substrings in the main sentence, case-insensitively. >>> substring_presence_score(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"dog\\", \\"cat\\", \\"Fox\\"]) 75.0 >>> substring_presence_score(\\"The quick brown fox jumps over the lazy dog\\", [\\"elephant\\", \\"giraffe\\"]) 0.0 >>> substring_presence_score(\\"The quick brown fox jumps over the lazy dog\\", []) 0.0 pass","solution":"def find_substrings(main_sentence: str, words: list[str]) -> list[str]: Identify which words from the list appear as exact substrings in the main sentence, case-insensitively. main_sentence_lower = main_sentence.lower() return [word for word in words if word.lower() in main_sentence_lower] def substring_occurrence_count(main_sentence: str, words: list[str]) -> dict[str, int]: Count the number of times words from the provided list appear as exact substrings in the main sentence, case-insensitively. main_sentence_lower = main_sentence.lower() count_dict = {} for word in words: word_lower = word.lower() count = main_sentence_lower.count(word_lower) if count > 0: count_dict[word] = count return count_dict def substring_presence_score(main_sentence: str, words: list[str]) -> float: Calculate the percentage of words from the list that appear as exact substrings in the main sentence, case-insensitively. found_words = find_substrings(main_sentence, words) return (len(found_words) / len(words)) * 100 if words else 0.0"},{"question":"import numpy as np def decision_tree_classifier(X: np.ndarray, y: np.ndarray, max_depth: int = 5) -> dict: Trains a decision tree model and returns a dictionary representing the tree structure. The function should: 1. Calculate the entropy of a dataset. 2. Compute the information gain of a potential split. 3. Implement a function to split the dataset based on a given feature and threshold. 4. Recursively build the decision tree using the best splits until the max depth is reached or no further split improves the information gain. 5. The resulting tree should be represented in a nested dictionary format. Args: X (np.ndarray): A numpy array of shape (m, n) where 'm' is the number of samples and 'n' is the number of features. y (np.ndarray): A numpy array of shape (m,) with binary labels (0 or 1). max_depth (int): Maximum depth of the decision tree (default is 5). Returns: dict: A nested dictionary representing the trained decision tree. Example: >>> X = np.array([[1, 0], [0, 1], [1, 1], [0, 0], [0, 1]]) >>> y = np.array([1, 0, 1, 0, 0]) >>> tree = decision_tree_classifier(X, y, max_depth=3) >>> print(tree) {'feature': 0, 'threshold': 0.5, 'left': {'feature': 1, 'threshold': 0.5, 'left': {'class': 0}, 'right': {'class': 1}}, 'right': {'class': 1}}","solution":"import numpy as np def entropy(y): unique, counts = np.unique(y, return_counts=True) probabilities = counts / len(y) return -np.sum(probabilities * np.log2(probabilities)) def information_gain(y, y_left, y_right): weight_left = len(y_left) / len(y) weight_right = len(y_right) / len(y) return entropy(y) - (weight_left * entropy(y_left) + weight_right * entropy(y_right)) def split_dataset(X, y, feature, threshold): left_indices = X[:, feature] <= threshold right_indices = X[:, feature] > threshold return X[left_indices], y[left_indices], X[right_indices], y[right_indices] def best_split(X, y): best_feature = None best_threshold = None best_info_gain = -1 for feature in range(X.shape[1]): thresholds = np.unique(X[:, feature]) for threshold in thresholds: X_left, y_left, X_right, y_right = split_dataset(X, y, feature, threshold) if len(y_left) > 0 and len(y_right) > 0: gain = information_gain(y, y_left, y_right) if gain > best_info_gain: best_info_gain = gain best_feature = feature best_threshold = threshold return best_feature, best_threshold def build_tree(X, y, depth, max_depth): if len(np.unique(y)) == 1: return {'class': int(y[0])} if depth >= max_depth or len(y) == 0: return {'class': int(np.round(np.mean(y)))} feature, threshold = best_split(X, y) if feature is None: return {'class': int(np.round(np.mean(y)))} X_left, y_left, X_right, y_right = split_dataset(X, y, feature, threshold) left_subtree = build_tree(X_left, y_left, depth + 1, max_depth) right_subtree = build_tree(X_right, y_right, depth + 1, max_depth) return { 'feature': feature, 'threshold': threshold, 'left': left_subtree, 'right': right_subtree } def decision_tree_classifier(X: np.ndarray, y: np.ndarray, max_depth: int = 5) -> dict: tree = build_tree(X, y, depth=0, max_depth=max_depth) return tree"},{"question":"from typing import List def find_nth_smallest(matrix: List[List[int]], n: int) -> int: Finds the Nth smallest element in a sorted matrix. >>> matrix = [ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ] >>> find_nth_smallest(matrix, 8) 13 >>> matrix = [ ... [1, 2], ... [1, 3] ... ] >>> find_nth_smallest(matrix, 2) 1 pass","solution":"import heapq from typing import List def find_nth_smallest(matrix: List[List[int]], n: int) -> int: Finds the Nth smallest element in a sorted matrix. m = len(matrix) # Min-heap to store elements along with their coordinates in the matrix min_heap = [(matrix[r][0], r, 0) for r in range(m)] heapq.heapify(min_heap) # Extract the nth smallest element from the heap count = 0 while count < n: element, r, c = heapq.heappop(min_heap) count += 1 if c + 1 < m: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return element"},{"question":"import string def word_frequency(text: str) -> dict: Count the frequency of each word in a given string, treating words case-insensitively and ignoring punctuation. If the input is invalid, return a meaningful error message. >>> word_frequency(\\"Hello, world! Hello...\\") {'hello': 2, 'world': 1} >>> word_frequency(\\"Test, test, Test.\\") {'test': 3} >>> word_frequency(\\"\\") 'Invalid input: text must be a non-empty string' >>> word_frequency(12345) 'Invalid input: text must be a non-empty string' def test_word_frequency_common_case(): assert word_frequency(\\"Hello, world! Hello...\\") == {'hello': 2, 'world': 1} def test_word_frequency_case_insensitivity(): assert word_frequency(\\"Test, test, Test.\\") == {'test': 3} def test_word_frequency_empty_string(): assert word_frequency(\\"\\") == 'Invalid input: text must be a non-empty string' def test_word_frequency_non_string(): assert word_frequency(12345) == 'Invalid input: text must be a non-empty string' def test_word_frequency_multiple_punctuation(): assert word_frequency(\\"This is a test. This, indeed, is a test!\\") == {'this': 2, 'is': 2, 'a': 2, 'test': 2, 'indeed': 1} def test_word_frequency_with_numbers_and_words(): assert word_frequency(\\"One, two, three, 3, 2, 1.\\") == {'one': 1, 'two': 1, 'three': 1, '3': 1, '2': 1, '1': 1}","solution":"import string def word_frequency(text: str) -> dict: Count the frequency of each word in a given string, treating words case-insensitively and ignoring punctuation. If the input is invalid, return a meaningful error message. >>> word_frequency(\\"Hello, world! Hello...\\") {'hello': 2, 'world': 1} >>> word_frequency(\\"Test, test, Test.\\") {'test': 3} >>> word_frequency(\\"\\") 'Invalid input: text must be a non-empty string' >>> word_frequency(12345) 'Invalid input: text must be a non-empty string' if not isinstance(text, str) or not text.strip(): return 'Invalid input: text must be a non-empty string' # Remove punctuation translator = str.maketrans('', '', string.punctuation) text = text.translate(translator) # Convert to lower case and split into words words = text.lower().split() word_count = {} for word in words: word_count[word] = word_count.get(word, 0) + 1 return word_count"},{"question":"def is_permutation_in_string(s1: str, s2: str) -> bool: Determines whether any permutation of s1 is a substring of s2. >>> is_permutation_in_string(\\"ab\\", \\"eidbaooo\\") True >>> is_permutation_in_string(\\"ab\\", \\"eidboaoo\\") False","solution":"from collections import Counter def is_permutation_in_string(s1: str, s2: str) -> bool: Determines whether any permutation of s1 is a substring of s2. len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_counter = Counter(s1) window_counter = Counter(s2[:len_s1]) if s1_counter == window_counter: return True for i in range(len_s1, len_s2): start_char = s2[i - len_s1] end_char = s2[i] window_counter[end_char] += 1 window_counter[start_char] -= 1 if window_counter[start_char] == 0: del window_counter[start_char] if window_counter == s1_counter: return True return False"},{"question":"def reverse_words_in_groups(sentence: str, k: int) -> str: Given a string \`sentence\` and an integer \`k\`, reverse the words in the sentence using groups of \`k\`. Parameters: sentence (str): A non-empty string containing lowercase English letters and spaces. k (int): A positive integer representing the group size. Returns: str: Returns the modified sentence after reversing words in groups of \`k\`. Examples: >>> reverse_words_in_groups(\\"the quick brown fox jumps over the lazy dog\\", 3) 'brown quick the over jumps fox dog lazy the' >>> reverse_words_in_groups(\\"hello there world\\", 2) 'there hello world' >>> reverse_words_in_groups(\\"a b c d e f g\\", 4) 'd c b a g f e'","solution":"def reverse_words_in_groups(sentence: str, k: int) -> str: words = sentence.split() result = [] for i in range(0, len(words), k): group = words[i:i+k] reversed_group = group[::-1] result.extend(reversed_group) return ' '.join(result)"},{"question":"def find_longest_common_path(paths: list[str]) -> str: Finds the longest common path shared by all the file paths in the list. Args: paths (list of str): List of strings representing file paths. Returns: str: Longest common path shared by all the file paths. If there is no common path, return an empty string. >>> find_longest_common_path([ ... \\"home/user/docs\\", ... \\"home/user/music\\", ... \\"home/user/docs/reports\\" ... ]) \\"home/user\\" >>> find_longest_common_path([ ... \\"var/log/nginx\\", ... \\"var/log/apache\\", ... \\"var/log/syslog\\", ... \\"var/cache/apt\\" ... ]) \\"var\\" >>> find_longest_common_path([ ... \\"root/admin/settings\\", ... \\"root/admin/users\\", ... \\"home/user/files\\" ... ]) \\"\\"","solution":"def find_longest_common_path(paths): Finds the longest common path shared by all the file paths in the list. Args: paths (list of str): List of strings representing file paths. Returns: str: Longest common path shared by all the file paths. If there is no common path, return an empty string. if not paths: return \\"\\" # Split all paths by '/' split_paths = [path.split('/') for path in paths] # Find the minimum length of all split paths min_len = min(len(path) for path in split_paths) longest_common_path_parts = [] for i in range(min_len): # Take the i-th part of each split path current_parts = [path[i] for path in split_paths] # If all parts are the same, add it to the common path parts if all(part == current_parts[0] for part in current_parts): longest_common_path_parts.append(current_parts[0]) else: break # Join the common path parts with '/' return '/'.join(longest_common_path_parts)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_all_paths(self) -> list[list[int]]: Find all paths from the root to leaf nodes. Returns: list[list[int]]: A list containing all paths from the root to leaf nodes. pass # Example usage root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(root.find_all_paths()) # Output should be [[1, 2, 4], [1, 2, 5], [1, 3]] # Unit Tests def test_empty_tree(): root = None assert (root.find_all_paths() if root else []) == [] def test_single_node_tree(): root = TreeNode(1) assert root.find_all_paths() == [[1]] def test_two_levels_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert root.find_all_paths() == [[1, 2], [1, 3]] def test_three_levels_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert root.find_all_paths() == [[1, 2, 4], [1, 2, 5], [1, 3]] def test_only_left_subtree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert root.find_all_paths() == [[1, 2, 3, 4]] def test_only_right_subtree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert root.find_all_paths() == [[1, 2, 3, 4]]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_all_paths(self) -> list: Find all paths from the root to leaf nodes. Returns: list[list[int]]: A list containing all paths from the root to leaf nodes. def dfs(node, path, paths): if node is None: return path.append(node.value) if not node.left and not node.right: paths.append(list(path)) else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() paths = [] dfs(self, [], paths) return paths"},{"question":"def flatten_dictionary(input_dict: dict, delimiter: str = '.') -> dict: Flattens a nested dictionary into a single-level dictionary. >>> flatten_dictionary({'a': 1, 'b': {'x': 2, 'y': {'z': 3}}}) {'a': 1, 'b.x': 2, 'b.y.z': 3} >>> flatten_dictionary({'a': 1, 'b': {'x': 2, 'y': {'z': 3}}}, '-') {'a': 1, 'b-x': 2, 'b-y-z': 3}","solution":"def flatten_dictionary(input_dict: dict, delimiter: str = '.') -> dict: Flattens a nested dictionary into a single-level dictionary. Arguments: input_dict -- The dictionary to be flattened. delimiter -- The string to be used as a separator for keys. Returns: A flattened dictionary. def _flatten(current_dict, parent_key=''): items = [] for k, v in current_dict.items(): new_key = f\\"{parent_key}{delimiter}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(_flatten(v, new_key).items()) else: items.append((new_key, v)) return dict(items) return _flatten(input_dict)"},{"question":"def count_unique_rotations(strings: list) -> int: Returns the number of unique strings after considering all rotations of each string. Parameters: strings (list): A list of strings. Returns: int: The number of unique strings after considering rotations. Example: >>> count_unique_rotations([\\"abc\\", \\"bca\\", \\"cab\\", \\"aaa\\", \\"aab\\"]) 3 from solution import count_unique_rotations def test_no_rotations_needed(): assert count_unique_rotations([\\"abc\\", \\"def\\", \\"ghi\\"]) == 3 def test_all_identical_strings(): assert count_unique_rotations([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) == 1 def test_all_rotations(): assert count_unique_rotations([\\"abc\\", \\"bca\\", \\"cab\\"]) == 1 def test_mixed_cases(): assert count_unique_rotations([\\"abc\\", \\"bca\\", \\"aaa\\", \\"aab\\"]) == 3 def test_various_lengths(): assert count_unique_rotations([\\"abc\\", \\"cba\\", \\"d\\"]) == 3 def test_single_string(): assert count_unique_rotations([\\"a\\"]) == 1 def test_duplicate_strings(): assert count_unique_rotations([\\"aaa\\", \\"aaa\\", \\"aab\\", \\"aab\\"]) == 2 def test_empty_list(): assert count_unique_rotations([]) == 0","solution":"def count_unique_rotations(strings: list) -> int: Returns the number of unique strings after considering all rotations of each string. # Function to get the minimal rotation of a string def get_minimal_rotation(s): n = len(s) doubled_s = s + s min_rotation = min(doubled_s[i:i+n] for i in range(n)) return min_rotation # Use a set to store unique minimal rotations unique_rotations = set() # Process each string to find its minimal rotation for s in strings: minimal_rotation = get_minimal_rotation(s) unique_rotations.add(minimal_rotation) return len(unique_rotations)"},{"question":"def track_notifications(tracker: 'NotificationTracker', notification: str) -> bool: Tracks and sends new notifications only if they have not been sent before. Args: tracker (NotificationTracker): The tracker instance to manage notifications. notification (str): The notification string to be sent. Returns: bool: True if the notification was sent, False if it was a duplicate. >>> tracker = NotificationTracker() >>> track_notifications(tracker, \\"Order Shipped\\") True >>> track_notifications(tracker, \\"Order Delivered\\") True >>> track_notifications(tracker, \\"Order Shipped\\") False >>> track_notifications(tracker, \\"Order Delivered\\") False >>> track_notifications(tracker, \\"Order Cancelled\\") True pass class NotificationTracker: def __init__(self): self.sent_notifications = set() def add_notification(self, notification: str) -> None: self.sent_notifications.add(notification) def has_notification(self, notification: str) -> bool: return notification in self.sent_notifications","solution":"def track_notifications(tracker, notification: str) -> bool: Tracks and sends new notifications only if they have not been sent before. Args: tracker (NotificationTracker): The tracker instance to manage notifications. notification (str): The notification string to be sent. Returns: bool: True if the notification was sent, False if it was a duplicate. if tracker.has_notification(notification): return False else: tracker.add_notification(notification) return True # Example NotificationTracker class implementation class NotificationTracker: def __init__(self): self.sent_notifications = set() def add_notification(self, notification: str) -> None: self.sent_notifications.add(notification) def has_notification(self, notification: str) -> bool: return notification in self.sent_notifications"},{"question":"from typing import Any import heapq class PriorityQueue: Implements a priority queue to handle incoming data streams with varying priorities. Methods: enqueue(item: Any, priority: int): Adds the item to the queue with the given priority. dequeue() -> Any: Removes and returns the item with the highest priority. peek() -> Any: Returns the item with the highest priority without removing it from the queue. is_empty() -> bool: Returns True if the queue is empty, otherwise returns False. def __init__(self): pass def enqueue(self, item: Any, priority: int): pass def dequeue(self) -> Any: pass def peek(self) -> Any: pass def is_empty(self) -> bool: pass import pytest from solution import PriorityQueue def test_enqueue_and_peek(): pq = PriorityQueue() pq.enqueue(\\"task1\\", 2) pq.enqueue(\\"task2\\", 1) pq.enqueue(\\"task3\\", 3) assert pq.peek() == \\"task3\\" def test_enqueue_and_dequeue(): pq = PriorityQueue() pq.enqueue(\\"task1\\", 2) pq.enqueue(\\"task2\\", 1) pq.enqueue(\\"task3\\", 3) assert pq.dequeue() == \\"task3\\" assert pq.dequeue() == \\"task1\\" assert pq.dequeue() == \\"task2\\" def test_is_empty(): pq = PriorityQueue() assert pq.is_empty() == True pq.enqueue(\\"task1\\", 2) assert pq.is_empty() == False pq.dequeue() assert pq.is_empty() == True def test_dequeue_empty(): pq = PriorityQueue() with pytest.raises(IndexError): pq.dequeue() def test_peek_empty(): pq = PriorityQueue() with pytest.raises(IndexError): pq.peek() def test_stable_priority(): pq = PriorityQueue() pq.enqueue(\\"task1\\", 1) pq.enqueue(\\"task2\\", 1) pq.enqueue(\\"task3\\", 1) assert pq.dequeue() == \\"task1\\" assert pq.dequeue() == \\"task2\\" assert pq.dequeue() == \\"task3\\" def test_enqueue_different_types(): pq = PriorityQueue() pq.enqueue(1, 2) pq.enqueue(\\"task\\", 3) pq.enqueue([1, 2, 3], 1) assert pq.dequeue() == \\"task\\" assert pq.dequeue() == 1 assert pq.dequeue() == [1, 2, 3]","solution":"from typing import Any import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def enqueue(self, item: Any, priority: int): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def dequeue(self) -> Any: if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") return heapq.heappop(self._queue)[-1] def peek(self) -> Any: if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self._queue[0][-1] def is_empty(self) -> bool: return len(self._queue) == 0"},{"question":"from typing import List def has_repeated_substring(s: str) -> bool: Checks if a string can be constructed by repeating a substring. >>> has_repeated_substring(\\"abab\\") True >>> has_repeated_substring(\\"abcabcabc\\") True >>> has_repeated_substring(\\"abcd\\") False >>> has_repeated_substring(\\"aaaa\\") True >>> has_repeated_substring(\\"abac\\") False","solution":"def has_repeated_substring(s: str) -> bool: Checks if the string can be constructed by repeating a substring. n = len(s) if n <= 1: return False # Double the string and remove the first and the last character doubled = (s + s)[1:-1] # Check if the original string exists in the modified double string return s in doubled"},{"question":"from typing import Dict, List def find_cycles(graph: Dict[int, List[int]]) -> List[List[int]]: Finds all simple cycles in an undirected graph. :param graph: A dictionary representing the graph, where the keys are node IDs and the values are lists of adjacent node IDs. :return: A list of cycles, where each cycle is represented as a list of node IDs. # To be implemented pass # Example Graph graph1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4], 4: [3] } # Example Cycle in Graph # Cycle 1: [0, 1, 2, 0] # Cycle 2: [0, 2, 1, 0] # Cycle 3: [1, 2, 0, 1] print(find_cycles(graph1)) # Output might include: [[0, 1, 2], [0, 2, 1], [1, 2, 0]] (Order of cycles and nodes may vary) # Example Graph with no cycles graph2 = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } print(find_cycles(graph2)) # Output: [] def test_find_cycles_single_cycle(): graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4], 4: [3] } cycles = find_cycles(graph) cycles_set = [set(cycle) for cycle in cycles] expected_cycle = [{0, 1, 2}] assert all(any(cycle == ec for ec in cycles_set) for cycle in expected_cycle) def test_find_cycles_no_cycles(): graph = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } assert find_cycles(graph) == [] def test_find_cycles_multiple_cycles(): graph = { 0: [1, 2], 1: [0, 2, 3], 2: [0, 1], 3: [1] } cycles = find_cycles(graph) cycles_set = [set(cycle) for cycle in cycles] expected_cycles = [{0, 1, 2}] assert all(any(e == c for c in cycles_set) for e in expected_cycles) def test_find_cycles_with_small_graph(): graph = { 0: [1], 1: [0, 2], 2: [1, 3, 4], 3: [2, 4], 4: [2, 3] } cycles = find_cycles(graph) cycles_set = [set(cycle) for cycle in cycles] expected_cycles = [{2, 3, 4}] assert all(any(e == c for c in cycles_set) for e in expected_cycles)","solution":"from typing import Dict, List def find_cycles(graph: Dict[int, List[int]]) -> List[List[int]]: def dfs(vertex, start, path): if vertex in visited: if vertex == start and len(path) > 2: cycles.append(path[:]) return visited.add(vertex) path.append(vertex) for neighbor in graph[vertex]: dfs(neighbor, start, path) path.pop() visited.remove(vertex) visited = set() cycles = [] for node in graph: dfs(node, node, []) return cycles"},{"question":"def can_form_palindrome(input_string: str) -> bool: Determines if the given string can be rearranged into a palindrome. Args: input_string (str): The input string consisting of lowercase letters. Returns: bool: True if the input string can be rearranged to form a palindrome, otherwise False. Raises: ValueError: If the input_string contains non-lowercase alphabetic characters. Examples: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"AaBbCc\\") Traceback (most recent call last): ... ValueError: Input must contain only lowercase alphabetic characters >>> can_form_palindrome(\\"a1b2\\") Traceback (most recent call last): ... ValueError: Input must contain only lowercase alphabetic characters","solution":"def can_form_palindrome(input_string: str) -> bool: Determines if the given string can be rearranged into a palindrome. Args: input_string (str): The input string consisting of lowercase letters. Returns: bool: True if the input string can be rearranged to form a palindrome, otherwise False. Raises: ValueError: If the input_string contains non-lowercase alphabetic characters. if not all('a' <= c <= 'z' for c in input_string): raise ValueError(\\"Input must contain only lowercase alphabetic characters\\") from collections import Counter # Count the frequency of each character char_count = Counter(input_string) # Check the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # It's possible to form a palindrome if there's at most one character with an odd count return odd_count <= 1"},{"question":"def single_number(nums: List[int]) -> int: Finds the element that appears only once in an array where every other element appears thrice. Args: nums (List[int]): An array of integers where every element appears thrice except for one element which appears exactly once. Returns: int: The element that appears only once in the array. Examples: >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([1, 1, 1, 2, 2, 2, 3]) 3","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the element that appears only once in an array where every other element appears thrice. ones, twos = 0, 0 for num in nums: # First, add num to 'twos' if it's already in 'ones' twos |= ones & num # Then, XOR num with 'ones' ones ^= num # Calculate common bits between 'ones' and 'twos' (these bits should be reset in both ones and twos) common_bit_mask = ~(ones & twos) # Reset the common bits in both 'ones' and 'twos' ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def invert_tree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping its left and right children nodes at every level. >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(9) >>> inverted_root = invert_tree(root) >>> tree_to_list(inverted_root) [4, 7, 2, 9, 6, 3, 1] >>> invert_tree(None) is None True >>> single_node = TreeNode(1) >>> tree_to_list(invert_tree(single_node)) [1] >>> root_two_levels = TreeNode(1) >>> root_two_levels.left = TreeNode(2) >>> root_two_levels.right = TreeNode(3) >>> tree_to_list(invert_tree(root_two_levels)) [1, 3, 2] def tree_to_list(root: TreeNode): Helper function to convert tree to list using level-order traversal if not root: return [] result, queue = [], [root] while queue: current = queue.pop(0) if current: result.append(current.val) queue.append(current.left) queue.append(current.right) else: result.append(None) while result and result[-1] is None: result.pop() return result","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def invert_tree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping its left and right children nodes at every level. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"def unique_substrings(s: str) -> list[str]: Generates all unique substrings from an input string and returns them in lexicographical order. >>> unique_substrings(\\"abca\\") ['a', 'ab', 'abc', 'abca', 'b', 'bc', 'bca', 'c', 'ca'] >>> unique_substrings(\\"banana\\") ['a', 'an', 'ana', 'anan', 'anana', 'b', 'ba', 'ban', 'bana', 'banan', 'banana', 'n', 'na', 'nan', 'nana'] >>> unique_substrings(\\"aaa\\") ['a', 'aa', 'aaa'] >>> unique_substrings(\\"\\") [] >>> unique_substrings(\\"abc\\") ['a', 'ab', 'abc', 'b', 'bc', 'c']","solution":"def unique_substrings(s: str) -> list[str]: Generates all unique substrings from the input string and returns them in lexicographical order. substrings = set() # Generate all substrings and add to set for uniqueness for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) # Convert to list and sort unique_substrings_list = sorted(substrings) return unique_substrings_list"},{"question":"def check_course_availability(courses: Dict[str, Tuple[int, int]]) -> Dict[str, bool]: Returns a dictionary indicating whether each course is still available for registration. Parameters: - courses: Dict[str, Tuple[int, int]], a dictionary where the keys are course names and the values are tuples containing the number of registered participants and the maximum capacity of the course. Returns: - Dict[str, bool]: a dictionary indicating whether each course is available for registration. Examples: >>> check_course_availability({\\"Math101\\": (25, 30), \\"History202\\": (30, 30), \\"Science303\\": (28, 30)}) {'Math101': True, 'History202': False, 'Science303': True} >>> check_course_availability({\\"Yoga\\": (15, 20), \\"Cooking\\": (20, 20), \\"Dance\\": (18, 20)}) {'Yoga': True, 'Cooking': False, 'Dance': True} >>> check_course_availability({\\"Drawing\\": (5, 10), \\"Sculpture\\": (9, 10), \\"Painting\\": (10, 10)}) {'Drawing': True, 'Sculpture': True, 'Painting': False} pass from solution import check_course_availability def test_check_course_availability_case1(): courses = {\\"Math101\\": (25, 30), \\"History202\\": (30, 30), \\"Science303\\": (28, 30)} expected = {\\"Math101\\": True, \\"History202\\": False, \\"Science303\\": True} assert check_course_availability(courses) == expected def test_check_course_availability_case2(): courses = {\\"Yoga\\": (15, 20), \\"Cooking\\": (20, 20), \\"Dance\\": (18, 20)} expected = {\\"Yoga\\": True, \\"Cooking\\": False, \\"Dance\\": True} assert check_course_availability(courses) == expected def test_check_course_availability_case3(): courses = {\\"Drawing\\": (5, 10), \\"Sculpture\\": (9, 10), \\"Painting\\": (10, 10)} expected = {\\"Drawing\\": True, \\"Sculpture\\": True, \\"Painting\\": False} assert check_course_availability(courses) == expected def test_check_course_availability_all_full(): courses = {\\"CourseA\\": (10, 10), \\"CourseB\\": (20, 20), \\"CourseC\\": (30, 30)} expected = {\\"CourseA\\": False, \\"CourseB\\": False, \\"CourseC\\": False} assert check_course_availability(courses) == expected def test_check_course_availability_all_available(): courses = {\\"CourseA\\": (0, 10), \\"CourseB\\": (10, 20), \\"CourseC\\": (20, 30)} expected = {\\"CourseA\\": True, \\"CourseB\\": True, \\"CourseC\\": True} assert check_course_availability(courses) == expected def test_check_course_availability_edge_case(): courses = {\\"EdgeCase1\\": (999, 1000)} expected = {\\"EdgeCase1\\": True} assert check_course_availability(courses) == expected def test_check_course_availability_empty(): courses = {} expected = {} assert check_course_availability(courses) == expected","solution":"def check_course_availability(courses): Returns a dictionary indicating whether each course is still available for registration. Parameters: - courses: Dict[str, Tuple[int, int]], a dictionary where the keys are course names and the values are tuples containing the number of registered participants and the maximum capacity of the course. Returns: - Dict[str, bool]: a dictionary indicating whether each course is available for registration. availability = {} for course, (registered, capacity) in courses.items(): availability[course] = registered < capacity return availability"},{"question":"from typing import List def group_and_sort_elements(arr: List[int]) -> List[List[int]]: Groups elements based on their frequency of occurrence, sorts each group by frequency in decreasing order, and within each group, the elements are sorted in ascending order. Example Usage: >>> group_and_sort_elements([4, 5, 6, 5, 4, 3]) [[4, 5], [3, 6]] >>> group_and_sort_elements([1, 2, 2, 3, 3, 3]) [[3], [2], [1]] >>> group_and_sort_elements([4, 4, 4, 4, 4]) [[4]] >>> group_and_sort_elements([]) [] >>> group_and_sort_elements([1, 2, 3, 4, 5]) [[1, 2, 3, 4, 5]] pass","solution":"from collections import Counter from typing import List def group_and_sort_elements(arr: List[int]) -> List[List[int]]: Groups elements based on their frequency of occurrence, sorts each group by frequency in decreasing order, and within each group, the elements are sorted in ascending order. if not arr: return [] # Calculate the frequency of each element frequency = Counter(arr) # Create a dictionary where the keys are frequencies and the values are lists of elements with that frequency freq_dict = {} for num, freq in frequency.items(): if freq not in freq_dict: freq_dict[freq] = [] freq_dict[freq].append(num) # Sort the elements within each frequency group and then sort the groups by frequency in descending order result = [] for freq in sorted(freq_dict.keys(), reverse=True): result.append(sorted(freq_dict[freq])) return result"},{"question":"from typing import List def find_max_length(nums: List[int]) -> int: Given an integer array \`nums\`, find the maximum length of a subarray that has an equal number of 0's and 1's. >>> find_max_length([0, 1]) 2 >>> find_max_length([0, 1, 0]) 2 >>> find_max_length([0, 1, 0, 1, 0, 1, 1, 0]) 8 >>> find_max_length([1, 1, 1, 1, 0, 0, 0, 0]) 8 >>> find_max_length([1, 0, 1, 0, 1, 1, 0, 0, 1, 0]) 10","solution":"from typing import List def find_max_length(nums: List[int]) -> int: count_map = {0: -1} # Map to store the first occurrence of each count max_length = 0 count = 0 for i, num in enumerate(nums): # Convert 0 to -1 to make the counting easier count += 1 if num == 1 else -1 if count in count_map: # If count has been seen before, update max_length max_length = max(max_length, i - count_map[count]) else: # Store the first occurrence of this count count_map[count] = i return max_length"},{"question":"from typing import List, Tuple def schedule_tasks(n: int, tasks: List[Tuple[int, int, int]]) -> List[int]: Schedules task based on their priority and returns the order of execution. >>> schedule_tasks(5, [(1, 4, 2), (2, 3, 3), (3, 2, 1), (4, 2, 3), (5, 1, 2)]) == [2, 4, 1, 5, 3] >>> schedule_tasks(3, [(1, 5, 1), (2, 3, 2), (3, 7, 1)]) == [2, 1, 3] >>> schedule_tasks(4, [(1, 2, 5), (2, 3, 5), (3, 1, 4), (4, 4, 3)]) == [1, 2, 3, 4]","solution":"from typing import List, Tuple def schedule_tasks(n: int, tasks: List[Tuple[int, int, int]]) -> List[int]: Schedules task based on their priority and returns the order of execution. # Sort tasks first by priority (descending), then by their appearance (order in input) sorted_tasks = sorted(tasks, key=lambda x: (-x[2], tasks.index(x))) # Extract the task IDs in the sorted order task_order = [task[0] for task in sorted_tasks] return task_order"},{"question":"from typing import List def is_zigzag(arr: List[int]) -> bool: Determines whether the given list of integers forms a zigzag pattern. >>> is_zigzag([1, 3, 2, 4, 3]) True >>> is_zigzag([1, 2, 3, 4, 5]) False >>> is_zigzag([5, 1, 2, 3]) False >>> is_zigzag([5]) True >>> is_zigzag([]) True","solution":"from typing import List def is_zigzag(arr: List[int]) -> bool: Determines whether the given list of integers forms a zigzag pattern. n = len(arr) if n < 2: return True for i in range(1, n - 1): if not ((arr[i-1] < arr[i] > arr[i+1]) or (arr[i-1] > arr[i] < arr[i+1])): return False return True"},{"question":"def nand_gate(input_1: int, input_2: int) -> int: This function implements a NAND gate. A NAND gate returns True (1) if at least one of the inputs is False (0). return int(not (input_1 and input_2)) def and_using_nand(input_1: int, input_2: int) -> int: Compute the AND operation using only NAND gates :param input_1: First boolean input (0 or 1) :param input_2: Second boolean input (0 or 1) :return: Result of AND operation (0 or 1) >>> and_using_nand(0, 0) 0 >>> and_using_nand(0, 1) 0 >>> and_using_nand(1, 0) 0 >>> and_using_nand(1, 1) 1","solution":"def nand_gate(input_1: int, input_2: int) -> int: This function implements a NAND gate. A NAND gate returns True (1) if at least one of the inputs is False (0). return int(not (input_1 and input_2)) def and_using_nand(input_1: int, input_2: int) -> int: This function simulates an AND gate using only NAND gates. # First, apply the NAND gate to the inputs nand_result = nand_gate(input_1, input_2) # Then, apply the NAND gate to the result of the first NAND gate with itself and_result = nand_gate(nand_result, nand_result) return and_result"},{"question":"def can_form_palindrome(sequence: str) -> bool: Determines if any permutation of the input string can form a palindrome. The function leverages efficient counting or bit manipulation techniques to provide an optimized solution. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> can_form_palindrome(\\"Was it a car or a cat I saw?\\") True pass from solution import can_form_palindrome def test_can_form_palindrome_simple_cases(): assert can_form_palindrome(\\"civic\\") == True assert can_form_palindrome(\\"ivicc\\") == True assert can_form_palindrome(\\"hello\\") == False assert can_form_palindrome(\\"a\\") == True assert can_form_palindrome(\\"ab\\") == False def test_can_form_palindrome_with_spaces_and_punctuations(): assert can_form_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert can_form_palindrome(\\"Was it a car or a cat I saw?\\") == True assert can_form_palindrome(\\"No 'x' in Nixon\\") == True assert can_form_palindrome(\\"This is not a palindrome.\\") == False def test_can_form_palindrome_edge_cases(): assert can_form_palindrome(\\"\\") == True # Empty string assert can_form_palindrome(\\" \\") == True # Single space assert can_form_palindrome(\\"!!!!!!\\") == True # Only punctuation assert can_form_palindrome(\\"a\\" * 100000) == True # Very long string with same character def test_can_form_palindrome_mixed_case_characters(): assert can_form_palindrome(\\"AaBb\\") == True assert can_form_palindrome(\\"RaceCar\\") == True assert can_form_palindrome(\\"RaCeCaR\\") == True assert can_form_palindrome(\\"aAbBCcD\\") == True","solution":"def can_form_palindrome(sequence: str) -> bool: Determines if any permutation of the input string can form a palindrome. # Using a set to track characters with odd counts char_count = set() # Iterate through each character in the input string for char in sequence: if char.isalnum(): # Ignore non-alphanumeric characters char = char.lower() # Treat upper and lower case letters as same if char in char_count: char_count.remove(char) else: char_count.add(char) # A permutation can form a palindrome if there's at most one character with an odd count. return len(char_count) <= 1"},{"question":"def custom_sort(data: list) -> list: Sorts a list of tuples based on multiple attributes. Arguments: data: A list of tuples, where each tuple contains a string (name), an integer (age), and a float (height). Returns: A list of tuples sorted based on the specified criteria: - by name in ascending order - then by age in descending order - finally by height in ascending order pass def test_custom_sort_normal_case(): data = [(\\"Alice\\", 30, 5.5), (\\"Bob\\", 25, 6.0), (\\"Alice\\", 28, 5.4), (\\"Bob\\", 25, 5.8)] expected = [('Alice', 30, 5.5), ('Alice', 28, 5.4), ('Bob', 25, 5.8), ('Bob', 25, 6.0)] assert custom_sort(data) == expected def test_custom_sort_duplicate_names_ages(): data = [(\\"Alice\\", 30, 5.5), (\\"Alice\\", 30, 5.4), (\\"Alice\\", 28, 5.4), (\\"Alice\\", 30, 5.8)] expected = [('Alice', 30, 5.4), ('Alice', 30, 5.5), ('Alice', 30, 5.8), ('Alice', 28, 5.4)] assert custom_sort(data) == expected def test_custom_sort_single_element(): data = [(\\"Alice\\", 30, 5.5)] expected = [(\\"Alice\\", 30, 5.5)] assert custom_sort(data) == expected def test_custom_sort_empty_list(): data = [] expected = [] assert custom_sort(data) == expected def test_custom_sort_multitype_edge_case(): data = [(\\"Alice\\", 30, 5.9), (\\"Zebra\\", 50, 5.5), (\\"Alice\\", 22, 6.1), (\\"Bob\\", 25, 5.0)] expected = [('Alice', 30, 5.9), ('Alice', 22, 6.1), ('Bob', 25, 5.0), ('Zebra', 50, 5.5)] assert custom_sort(data) == expected","solution":"def custom_sort(data: list) -> list: Sorts a list of tuples based on multiple attributes. Arguments: data: A list of tuples, where each tuple contains a string (name), an integer (age), and a float (height). Returns: A list of tuples sorted based on the specified criteria: - by name in ascending order - then by age in descending order - finally by height in ascending order return sorted(data, key=lambda x: (x[0], -x[1], x[2]))"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. The expression can include integers, +, -, *, / operators, and parentheses. >>> evaluate_expression(\\"2 + 3 * 4\\") 14.0 >>> evaluate_expression(\\"(1 + 2) * (3 + 4) / 2\\") 10.5 >>> evaluate_expression(\\"10 + 2 * 6\\") 22.0 >>> evaluate_expression(\\"100 * 2 + 12\\") 212.0 >>> evaluate_expression(\\"100 * (2 + 12)\\") 1400.0 >>> evaluate_expression(\\"100 * (2 + 12) / 14\\") 100.0","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. The expression can include integers, +, -, *, / operators, and parentheses. # Helper to perform the basic arithmetic operations. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(a / b) # Helper to determine the precedence of operators. def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 # Function to convert infix expression to postfix expression. def infix_to_postfix(expression): ops = [] postfix = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = [] while i < len(expression) and expression[i].isdigit(): num.append(expression[i]) i += 1 postfix.append(int(''.join(num))) i -= 1 # Step back after the number ends elif expression[i] == '(': ops.append(expression[i]) elif expression[i] == ')': while ops and ops[-1] != '(': postfix.append(ops.pop()) ops.pop() # Pop the '(' else: # Operator encountered while (ops and precedence(ops[-1]) >= precedence(expression[i])): postfix.append(ops.pop()) ops.append(expression[i]) i += 1 while ops: postfix.append(ops.pop()) return postfix # Function to evaluate postfix expression. def evaluate_postfix(postfix): operands = [] for token in postfix: if isinstance(token, int): operands.append(token) else: apply_operator(operands, token) return operands[0] # Remove whitespaces for better parsing. expression = expression.replace(' ', '') postfix = infix_to_postfix(expression) return float(evaluate_postfix(postfix))"},{"question":"class Stack: A stack data structure with the following operations: - \`push(value)\`: Adds a value to the top of the stack. - \`pop()\`: Removes and returns the value on the top of the stack. Raises an \`IndexError\` if the stack is empty. - \`is_empty()\`: Returns \`True\` if the stack is empty and \`False\` otherwise. - \`peek()\`: Returns the value on the top of the stack without removing it. Raises an \`IndexError\` if the stack is empty. Example: >>> stack = Stack() >>> stack.is_empty() True >>> stack.push(10) >>> stack.peek() 10 >>> stack.push(20) >>> stack.pop() 20 >>> stack.peek() 10 >>> stack.pop() 10 >>> stack.is_empty() True def __init__(self): self._elements = [] def push(self, value: int): self._elements.append(value) def pop(self) -> int: if not self._elements: raise IndexError(\\"pop from empty stack\\") return self._elements.pop() def is_empty(self) -> bool: return len(self._elements) == 0 def peek(self) -> int: if not self._elements: raise IndexError(\\"peek from empty stack\\") return self._elements[-1]","solution":"class Stack: def __init__(self): self._elements = [] def push(self, value: int): self._elements.append(value) def pop(self) -> int: if not self._elements: raise IndexError(\\"pop from empty stack\\") return self._elements.pop() def is_empty(self) -> bool: return len(self._elements) == 0 def peek(self) -> int: if not self._elements: raise IndexError(\\"peek from empty stack\\") return self._elements[-1]"},{"question":"def sort_numeric_strings(num_strings: List[str]) -> List[str]: Sorts a list of strings containing numerical values as integers. >>> sort_numeric_strings([\\"10\\", \\"1\\", \\"3\\", \\"20\\"]) ['1', '3', '10', '20'] >>> sort_numeric_strings([\\"5\\", \\"7\\", \\"2\\", \\"9\\", \\"0\\"]) ['0', '2', '5', '7', '9'] >>> sort_numeric_strings([\\"100\\", \\"21\\", \\"31\\", \\"4\\", \\"15\\"]) ['4', '15', '21', '31', '100'] >>> sort_numeric_strings([\\"1000\\", \\"5000\\", \\"999\\", \\"10000\\", \\"123\\"]) ['123', '999', '1000', '5000', '10000']","solution":"def sort_numeric_strings(num_strings): Sorts a list of strings containing numerical values as integers. Args: num_strings (List[str]): A list of strings where each string represents a non-negative integer. Returns: List[str]: A list of strings sorted in ascending order based on their integer values. return sorted(num_strings, key=int)"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.key = key class BalancedBST: def __init__(self): self.root = None def insert(self, key): Insert a key into the BST and balance the tree. # Implement your insertion and balancing logic here pass def in_order_traversal(self): Perform in-order traversal and return the sorted list. # Implement your in-order traversal logic here pass # You may add any helper methods if needed # Example usage bst = BalancedBST() elements = [3, 1, 4, 1, 5, 9, 2, 6] for elem in elements: bst.insert(elem) print(bst.in_order_traversal()) # Output should be [1, 1, 2, 3, 4, 5, 6, 9] def test_in_order_traversal(): bst = BalancedBST() elements = [3, 1, 4, 1, 5, 9, 2, 6] for elm in elements: bst.insert(elm) assert bst.in_order_traversal() == sorted(elements) def test_empty_tree(): bst = BalancedBST() assert bst.in_order_traversal() == [] def test_single_element_tree(): bst = BalancedBST() bst.insert(42) assert bst.in_order_traversal() == [42] def test_duplicates(): bst = BalancedBST() elements = [5, 1, 5, 3, 5, 2] for elm in elements: bst.insert(elm) assert bst.in_order_traversal() == sorted(elements) def test_large_input(): import random bst = BalancedBST() elements = random.sample(range(100000), 50000) for elm in elements: bst.insert(elm) assert bst.in_order_traversal() == sorted(elements)","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.key = key class BalancedBST: def __init__(self): self.root = None def insert(self, key): Insert a key into the BST and balance the tree. self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traversal(self): Perform in-order traversal and return the sorted list. res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, node, res): if not node: return self._in_order_traversal(node.left, res) res.append(node.key) self._in_order_traversal(node.right, res)"},{"question":"def nor_gate(input_1: int, input_2: int) -> int: return int(not (input_1 or input_2)) def and_using_nor(input_1: int, input_2: int) -> int: Compute the AND operation using only NOR gates. >>> and_using_nor(0, 0) 0 >>> and_using_nor(0, 1) 0 >>> and_using_nor(1, 0) 0 >>> and_using_nor(1, 1) 1 :param input_1: First boolean input (0 or 1) :param input_2: Second boolean input (0 or 1) :return: Result of AND operation (0 or 1)","solution":"def nor_gate(input_1: int, input_2: int) -> int: return int(not (input_1 or input_2)) def and_using_nor(input_1: int, input_2: int) -> int: Compute the AND operation using only NOR gates :param input_1: First boolean input (0 or 1) :param input_2: Second boolean input (0 or 1) :return: Result of AND operation (0 or 1) # NOR(x, x) = NOT(x) # AND can be constructed with the following series of NOR gates: # A AND B = NOR(NOR(A, A), NOR(B, B)) not_input_1 = nor_gate(input_1, input_1) not_input_2 = nor_gate(input_2, input_2) result = nor_gate(not_input_1, not_input_2) return result"},{"question":"def has_repeated_characters(s: str) -> bool: Returns whether a given string contains any repeated characters. Parameters: s (str): Input string to check for repeated characters. Output: bool: True if any character is repeated, False otherwise. Examples: >>> has_repeated_characters(\\"hello\\") True >>> has_repeated_characters(\\"abcdef\\") False >>> has_repeated_characters(\\"aA\\") False >>> has_repeated_characters(\\"aa\\") True def test_has_repeated_characters(): assert has_repeated_characters(\\"hello\\") == True assert has_repeated_characters(\\"abcdef\\") == False assert has_repeated_characters(\\"aA\\") == False assert has_repeated_characters(\\"aa\\") == True assert has_repeated_characters(\\"1234567890\\") == False assert has_repeated_characters(\\"11234567890\\") == True assert has_repeated_characters(\\"!@#%^&*()_+\\") == False assert has_repeated_characters(\\"!@#%^&*()_+!\\") == True assert has_repeated_characters(\\"a\\") == False assert has_repeated_characters(\\"\\") == False # Edge case with an empty string assert has_repeated_characters(\\"a\\"*100000) == True # Edge case with maximum length string","solution":"def has_repeated_characters(s: str) -> bool: Returns whether a given string contains any repeated characters. Parameters: s (str): Input string to check for repeated characters. Output: bool: True if any character is repeated, False otherwise. char_set = set() for char in s: if char in char_set: return True char_set.add(char) return False"},{"question":"def is_palindrome(s: str) -> bool: Check if a string is a palindrome. >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"\\") # Should raise ValueError def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in a string. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"\\") # Should raise ValueError def test_is_palindrome(): assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"hello\\") == False assert is_palindrome(\\"a\\") == True try: is_palindrome(\\"\\") except ValueError as e: assert str(e) == \\"Input must be a non-empty string\\" try: is_palindrome(123) except ValueError as e: assert str(e) == \\"Input must be a non-empty string\\" def test_longest_palindromic_substring(): assert longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" assert longest_palindromic_substring(\\"a\\") == \\"a\\" try: longest_palindromic_substring(\\"\\") except ValueError as e: assert str(e) == \\"Input must be a non-empty string\\" try: longest_palindromic_substring(123) except ValueError as e: assert str(e) == \\"Input must be a non-empty string\\" def run_tests(): test_is_palindrome() test_longest_palindromic_substring() if __name__ == \\"__main__\\": run_tests()","solution":"def is_palindrome(s: str) -> bool: if not isinstance(s, str) or s == \\"\\": raise ValueError(\\"Input must be a non-empty string\\") return s == s[::-1] def longest_palindromic_substring(s: str) -> str: if not isinstance(s, str) or s == \\"\\": raise ValueError(\\"Input must be a non-empty string\\") n = len(s) if n == 1: return s start = 0 max_length = 1 table = [[0] * n for _ in range(n)] for i in range(n): table[i][i] = True for i in range(n - 1): if s[i] == s[i + 1]: table[i][i + 1] = True start = i max_length = 2 for k in range(3, n + 1): for i in range(n - k + 1): j = i + k - 1 if table[i + 1][j - 1] and s[i] == s[j]: table[i][j] = True if k > max_length: start = i max_length = k return s[start:start + max_length]"},{"question":"from typing import List, Tuple def distinct_users_in_timeframe(logs: List[Tuple[str, int, str]], start: str, end: str) -> int: Returns the number of distinct users who engaged with the system between the given start and end timestamps (inclusive). >>> logs = [ ... (\\"2023-01-01 10:00:00\\", 1, \\"login\\"), ... (\\"2023-01-01 10:05:00\\", 2, \\"view\\"), ... (\\"2023-01-01 10:10:00\\", 1, \\"click\\"), ... (\\"2023-01-01 10:20:00\\", 3, \\"login\\"), ... (\\"2023-01-01 10:30:00\\", 2, \\"logout\\"), ... (\\"2023-01-01 10:35:00\\", 4, \\"view\\"), ... (\\"2023-01-01 10:45:00\\", 1, \\"logout\\"), ... ] >>> distinct_users_in_timeframe(logs, \\"2023-01-01 10:00:00\\", \\"2023-01-01 10:30:00\\") 3 >>> distinct_users_in_timeframe(logs, \\"2023-01-01 10:20:00\\", \\"2023-01-01 10:40:00\\") 2 >>> distinct_users_in_timeframe(logs, \\"2023-01-01 10:35:00\\", \\"2023-01-01 10:45:00\\") 2 >>> distinct_users_in_timeframe(logs, \\"2023-01-01 09:00:00\\", \\"2023-01-01 09:59:59\\") 0 >>> distinct_users_in_timeframe(logs, \\"2023-01-01 10:00:00\\", \\"2023-01-01 10:45:00\\") 4","solution":"from typing import List, Tuple def distinct_users_in_timeframe(logs: List[Tuple[str, int, str]], start: str, end: str) -> int: Returns the number of distinct users who engaged with the system between the given start and end timestamps (inclusive). user_set = set() for timestamp, user_id, action in logs: if start <= timestamp <= end: user_set.add(user_id) return len(user_set)"},{"question":"from typing import List class TimeMap: A class to support setting and retrieving key-value pairs with timestamp-based querying. >>> time_map = TimeMap() >>> time_map.set(\\"foo\\", \\"bar\\", 1) >>> time_map.get(\\"foo\\", 1) 'bar' >>> time_map.get(\\"foo\\", 3) 'bar' >>> time_map.set(\\"foo\\", \\"bar2\\", 4) >>> time_map.get(\\"foo\\", 4) 'bar2' >>> time_map.get(\\"foo\\", 5) 'bar2' def __init__(self): Initialize the data structure. pass def set(self, key: str, value: str, timestamp: int) -> None: Stores the value with the key and the given timestamp. pass def get(self, key: str, timestamp: int) -> str: Retrieves the value associated with the key at or before the given timestamp. pass","solution":"from collections import defaultdict import bisect class TimeMap: def __init__(self): Initialize the data structure. self.store = defaultdict(list) def set(self, key, value, timestamp): Stores the value with the key and the given timestamp. self.store[key].append((timestamp, value)) def get(self, key, timestamp): Retrieves the value associated with the key at or before the given timestamp. if key not in self.store: return \\"\\" values = self.store[key] # Use binary search to find the appropriate timestamp index = bisect.bisect_right(values, (timestamp, chr(127))) if index == 0: return \\"\\" return values[index - 1][1]"},{"question":"def is_palindrome(number: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(12321) == True >>> is_palindrome(123321) == True >>> is_palindrome(123421) == False pass def largest_palindromic_product() -> int: Find the largest palindromic number that is a product of two 3-digit numbers. The function should compute within the hard-coded range of 3-digit numbers (100 to 999). Returns: The largest palindromic number that is a product of two 3-digit numbers as an integer. >>> largest_palindromic_product() == 906609 pass","solution":"def is_palindrome(number): Check if a number is a palindrome. return str(number) == str(number)[::-1] def largest_palindromic_product(): Finds the largest palindromic number that is a product of two 3-digit numbers. max_palindrome = 0 # Iterate over all pairs of 3-digit numbers for i in range(999, 99, -1): for j in range(i, 99, -1): product = i * j if is_palindrome(product) and product > max_palindrome: max_palindrome = product return max_palindrome"},{"question":"def subset_sum(item_values: list, target_value: int) -> bool: Determines if there exists a subset of the given list of item values that add up to the target value. Args: item_values (list): A list of integers representing the values of items. target_value (int): The target value to achieve with a subset of items. Returns: bool: True if a subset with the exact sum exists, False otherwise. Example Usage: >>> subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> subset_sum([3, 34, 4, 12, 5, 2], 30) False pass def test_subset_sum_exists(): item_values = [3, 34, 4, 12, 5, 2] target_value = 9 assert subset_sum(item_values, target_value) == True def test_subset_sum_not_exists(): item_values = [3, 34, 4, 12, 5, 2] target_value = 30 assert subset_sum(item_values, target_value) == False def test_subset_sum_empty_list(): item_values = [] target_value = 0 assert subset_sum(item_values, target_value) == True def test_subset_sum_single_item(): item_values = [5] target_value = 5 assert subset_sum(item_values, target_value) == True def test_subset_sum_no_combination(): item_values = [1, 2, 3] target_value = 7 assert subset_sum(item_values, target_value) == False def test_subset_sum_multiple_combinations(): item_values = [1, 2, 3, 4, 5] target_value = 10 assert subset_sum(item_values, target_value) == True","solution":"def subset_sum(item_values, target_value): n = len(item_values) dp = [[False] * (target_value + 1) for _ in range(n + 1)] # There is always a subset with sum 0, i.e., the empty subset for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target_value + 1): if item_values[i-1] > j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-item_values[i-1]] return dp[n][target_value]"},{"question":"def rotate_in_place(matrix: list[list[int]]) -> None: Rotates the NxN matrix 90 degrees clockwise in place. pass def extract_new_matrix(matrix: list[list[int]]) -> list[list[int]]: Creates a new NxN matrix representing the original matrix rotated 90 degrees clockwise. pass def rotate(matrix: list[list[int]], use_helper: bool) -> list[list[int]]: Rotates the matrix by calling one of the above two functions based on the use_helper flag. pass # Example Usage: if __name__ == \\"__main__\\": matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Testing rotation with helper function rotated_matrix = rotate(matrix, use_helper=True) print(rotated_matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Testing in-place rotation rotate(matrix, use_helper=False) print(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ]","solution":"def rotate_in_place(matrix: list[list[int]]) -> None: Rotates the NxN matrix 90 degrees clockwise in place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp def extract_new_matrix(matrix: list[list[int]]) -> list[list[int]]: Creates a new NxN matrix representing the original matrix rotated 90 degrees clockwise. n = len(matrix) new_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n - i - 1] = matrix[i][j] return new_matrix def rotate(matrix: list[list[int]], use_helper: bool) -> list[list[int]]: Rotates the matrix by calling one of the above two functions based on the use_helper flag. if use_helper: return extract_new_matrix(matrix) else: rotate_in_place(matrix) return matrix"},{"question":"def summarize_transactions(transactions: list[tuple[str, float]]) -> dict: Summarize daily and monthly totals from a list of transactions. >>> transactions = [ ... ('2023-01-01', 100.0), ... ('2023-01-01', 200.0), ... ('2023-01-02', 300.0), ... ('2023-02-01', 400.0), ... ('2023-02-01', 100.0) ... ] >>> summarize_transactions(transactions) { 'daily_totals': { '2023-01-01': 300.0, '2023-01-02': 300.0, '2023-02-01': 500.0, }, 'monthly_totals': { '2023-01': 600.0, '2023-02': 500.0 } } from collections import defaultdict def test_single_day_single_transaction(): transactions = [ ('2023-01-01', 100.0) ] result = summarize_transactions(transactions) assert result == { 'daily_totals': {'2023-01-01': 100.0}, 'monthly_totals': {'2023-01': 100.0} } def test_single_day_multiple_transactions(): transactions = [ ('2023-01-01', 100.0), ('2023-01-01', 200.0) ] result = summarize_transactions(transactions) assert result == { 'daily_totals': {'2023-01-01': 300.0}, 'monthly_totals': {'2023-01': 300.0} } def test_multiple_days(): transactions = [ ('2023-01-01', 100.0), ('2023-01-02', 200.0) ] result = summarize_transactions(transactions) assert result == { 'daily_totals': { '2023-01-01': 100.0, '2023-01-02': 200.0 }, 'monthly_totals': {'2023-01': 300.0} } def test_multiple_months(): transactions = [ ('2023-01-01', 100.0), ('2023-02-01', 200.0) ] result = summarize_transactions(transactions) assert result == { 'daily_totals': { '2023-01-01': 100.0, '2023-02-01': 200.0 }, 'monthly_totals': { '2023-01': 100.0, '2023-02': 200.0 } } def test_complex_case(): transactions = [ ('2023-01-01', 100.0), ('2023-01-01', 200.0), ('2023-01-02', 300.0), ('2023-02-01', 400.0), ('2023-02-01', 100.0) ] result = summarize_transactions(transactions) assert result == { 'daily_totals': { '2023-01-01': 300.0, '2023-01-02': 300.0, '2023-02-01': 500.0, }, 'monthly_totals': { '2023-01': 600.0, '2023-02': 500.0 } }","solution":"from collections import defaultdict def summarize_transactions(transactions): daily_totals = defaultdict(float) monthly_totals = defaultdict(float) for date, amount in transactions: daily_totals[date] += amount year_month = date[:7] monthly_totals[year_month] += amount return { 'daily_totals': dict(daily_totals), 'monthly_totals': dict(monthly_totals) }"},{"question":"def find_out_of_place_word(words: List[str]) -> int: Returns the index of the word that is out of place in an otherwise alphabetical order list. Parameters: words (List[str]): A list of words sorted in alphabetical order except for one word. Returns: int: An index of the out-of-place word or -1 if the list is sorted correctly. n = len(words) for i in range(1, n): if words[i] < words[i - 1]: # If we find that words[i] is out of order, the located index is likely the problem. # However, we must confirm if it is the current word or the previous word if i == 1 or words[i] >= words[i - 2]: return i - 1 else: return i return -1","solution":"from typing import List def find_out_of_place_word(words: List[str]) -> int: Returns the index of the word that is out of place in an otherwise alphabetical order list. Parameters: words (List[str]): A list of words sorted in alphabetical order except for one word. Returns: int: An index of the out-of-place word or -1 if the list is sorted correctly. n = len(words) for i in range(1, n): if words[i] < words[i - 1]: # If we find that words[i] is out of order, the located index is likely the problem. # However, we must confirm if it is the current word or the previous word if i == 1 or words[i] >= words[i - 2]: return i - 1 else: return i return -1"},{"question":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotate a list of integers to the right by k steps. Parameters: nums (list of int): The list of integers to be rotated. k (int): The number of steps to rotate the list to the right. Returns: list of int: The rotated list. Examples: >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_list([1, 2, 3], 4) [3, 1, 2] >>> rotate_list([1], 5) [1]","solution":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list to the right by k steps. Parameters: nums (list of int): The list of integers to be rotated. k (int): The number of steps to rotate the list to the right. Returns: list of int: The rotated list. if not nums: return nums n = len(nums) k = k % n # Normalize k if it's larger than the list size if k == 0: return nums return nums[-k:] + nums[:-k]"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if any permutation of the input string can form a palindrome. A string can form a palindrome if and only if at most one character has an odd frequency. >>> can_form_palindrome(\\"civic\\") == True >>> can_form_palindrome(\\"ivicc\\") == True >>> can_form_palindrome(\\"hello\\") == False >>> can_form_palindrome(\\"aabbccd\\") == True","solution":"def can_form_palindrome(s: str) -> bool: Checks if any permutation of the input string can form a palindrome. A string can form a palindrome if and only if at most one character has an odd frequency. from collections import Counter # Count the frequency of each character in the input string char_count = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # It can be converted to a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def unique_words_count(documents: list) -> int: Returns the number of unique words across all documents, case-insensitively and ignoring punctuation. >>> documents = [ ... \\"Hello, world! This is a test.\\", ... \\"Test the function with different sets of documents!\\", ... \\"Hello again, testing punctuation removal.\\" ... ] >>> unique_words_count(documents) 17 >>> documents = [ ... \\"Count, unique; words, in? multiple.document's:with punctuation\\", ... \\"Unique words' counting MUST ignore casing and punctuation.\\" ... ] >>> unique_words_count(documents) 14","solution":"import re def unique_words_count(documents: list) -> int: Returns the number of unique words across all documents, case-insensitively and ignoring punctuation. unique_words = set() word_pattern = re.compile(r'bw+b') for document in documents: words = word_pattern.findall(document.lower()) unique_words.update(words) return len(unique_words)"},{"question":"def predict_next_item(sequences: list[list[int]], window_size: int) -> list[tuple[list[int], int]]: Predicts the next item in a user's interaction sequence using a frequency-based method within a fixed window size. >>> predict_next_item([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]], 3) [([1, 2, 3], 1), ([2, 3, 1], 2), ([3, 1, 2], 3), ([1, 2, 3], 1), ([4, 5, 6], 4), ([5, 6, 4], 5), ([6, 4, 5], 6), ([4, 5, 6], 4)] >>> predict_next_item([[1], [2]], 1) [([1], 1), ([2], 2)] >>> predict_next_item([[1, 2], [3, 4, 5]], 4) [] >>> predict_next_item([[1, 1, 2, 2, 1, 1]], 3) [([1, 1, 2], 1), ([1, 2, 2], 2), ([2, 2, 1], 2), ([2, 1, 1], 1)] >>> predict_next_item([], 3) [] >>> predict_next_item([[1, 2, 3], []], 2) [([1, 2], 1), ([2, 3], 2)]","solution":"from collections import Counter from typing import List, Tuple def predict_next_item(sequences: List[List[int]], window_size: int) -> List[Tuple[List[int], int]]: result = [] for sequence in sequences: if len(sequence) < window_size: continue # skip sequences shorter than the window size for i in range(len(sequence) - window_size + 1): window = sequence[i:i + window_size] most_common_item = Counter(window).most_common(1)[0][0] result.append((window, most_common_item)) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root: Optional[TreeNode]) -> List[int]: Given the root of a binary tree, return the path with the maximum sum of node values from the root to a leaf node. If there are multiple paths with the same maximum sum, return any of them. >>> root = TreeNode( ... val=10, ... left=TreeNode( ... val=5, ... left=TreeNode(val=3), ... right=TreeNode(val=8) ... ), ... right=TreeNode( ... val=15, ... right=TreeNode(val=20) ... ) ... ) >>> max_sum_path(root) [10, 15, 20] >>> root = TreeNode( ... val=1, ... left=TreeNode(val=2), ... right=TreeNode(val=3) ... ) >>> max_sum_path(root) [1, 3] or [1, 2] pass # Unit tests def test_basic_tree(): root = TreeNode( val=10, left=TreeNode( val=5, left=TreeNode(val=3), right=TreeNode(val=8) ), right=TreeNode( val=15, right=TreeNode(val=20) ) ) assert max_sum_path(root) == [10, 15, 20] def test_single_node_tree(): root = TreeNode(val=5) assert max_sum_path(root) == [5] def test_distributed_tree(): root = TreeNode( val=1, left=TreeNode(val=2), right=TreeNode(val=3) ) result = max_sum_path(root) assert result in [[1, 2], [1, 3]] def test_empty_tree(): root = None assert max_sum_path(root) == [] def test_tree_with_equal_paths(): root = TreeNode( val=1, left=TreeNode( val=4, left=TreeNode(val=5), right=TreeNode(val=1) ), right=TreeNode( val=10, left=TreeNode(val=1) ) ) assert max_sum_path(root) == [1, 10, 1]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root: Optional[TreeNode]) -> List[int]: if not root: return [] def dfs(node): if not node: return (0, []) if not node.left and not node.right: return (node.val, [node.val]) left_sum, left_path = dfs(node.left) right_sum, right_path = dfs(node.right) if left_sum > right_sum: return (node.val + left_sum, [node.val] + left_path) else: return (node.val + right_sum, [node.val] + right_path) _, max_path = dfs(root) return max_path"},{"question":"def simple_calculator(expression: str) -> float: Evaluates a basic arithmetic expression given as a string. Supported operators are: +, -, *, and /. Parameters: expression (str): A string containing the arithmetic expression. Returns: float: The result of the arithmetic operation. str: A warning message if the operation is invalid (e.g., division by zero). Examples: >>> simple_calculator(\\"3 + 5\\") 8.0 >>> simple_calculator(\\"10 / 2\\") 5.0 >>> simple_calculator(\\"8 * 3\\") 24.0 >>> simple_calculator(\\"9 - 4\\") 5.0 >>> simple_calculator(\\"7 / 0\\") 'Division by zero is undefined'","solution":"def simple_calculator(expression): Evaluates a basic arithmetic expression given as a string. Supported operators are: +, -, *, and /. Parameters: expression (str): A string containing the arithmetic expression. Returns: float: The result of the arithmetic operation. str: A warning message if the operation is invalid (e.g., division by zero). # Remove all whitespace from the expression expression = expression.replace(\\" \\", \\"\\") # Determine the operator and split the expression into operands if '+' in expression: operands = expression.split('+') operator = '+' elif '-' in expression: operands = expression.split('-') operator = '-' elif '*' in expression: operands = expression.split('*') operator = '*' elif '/' in expression: operands = expression.split('/') operator = '/' else: return \\"Invalid expression\\" operand1, operand2 = map(float, operands) # Perform the arithmetic operation if operator == '+': return operand1 + operand2 elif operator == '-': return operand1 - operand2 elif operator == '*': return operand1 * operand2 elif operator == '/': if operand2 == 0: return \\"Division by zero is undefined\\" return operand1 / operand2"},{"question":"def simple_index(dataset: List[List[any]], column: int) -> Dict[any, List[int]]: Create an index for a column in a dataset. Parameters: dataset (List[List[Any]]): the dataset as a list of lists. column (int): the index of the column to be indexed. Returns: Dict[Any, List[int]]: a dictionary with keys as unique column values and values as lists of row indices. Examples: >>> dataset = [ ... [1, \\"Alice\\", 3.4], ... [2, \\"Bob\\", 3.8], ... [3, \\"Alice\\", 2.4], ... [4, \\"Dana\\", 3.9] ... ] >>> simple_index(dataset, 1) {'Alice': [0, 2], 'Bob': [1], 'Dana': [3]} >>> simple_index(dataset, 2) {3.4: [0], 3.8: [1], 2.4: [2], 3.9: [3]} >>> simple_index(dataset, 0) {1: [0], 2: [1], 3: [2], 4: [3]}","solution":"from typing import List, Dict, Any def simple_index(dataset: List[List[Any]], column: int) -> Dict[Any, List[int]]: Create an index for a column in a dataset. Parameters: dataset (List[List[Any]]): the dataset as a list of lists. column (int): the index of the column to be indexed. Returns: Dict[Any, List[int]]: a dictionary with keys as unique column values and values as lists of row indices. index = {} for row_idx, row in enumerate(dataset): value = row[column] if value not in index: index[value] = [] index[value].append(row_idx) return index"},{"question":"def secant_method( func: Callable[[float], float], x0: float, x1: float, tol: float, max_iter: int ) -> float: Implement the Secant Method for solving nonlinear equations and find the root of the function \`f(x) = 0\`. Parameters: func (Callable[[float], float]): The function for which the root is to be found. x0 (float): Initial guess. x1 (float): Second guess. tol (float): Tolerance for convergence. max_iter (int): Maximum number of iterations. Returns: float: The approximated root of the function \`func\`. >>> def func(x): return x**3 - x - 2 >>> secant_method(func, 1.0, 2.0, 1e-6, 100) 1.52138... >>> def func(x): return math.cos(x) - x >>> secant_method(func, 0.5, 1.0, 1e-6, 100) 0.73908...","solution":"def secant_method(func, x0, x1, tol, max_iter): Finds the root of the function \`func\` using the Secant Method. Parameters: func (Callable[[float], float]): The function for which the root is to be found. x0 (float): Initial guess. x1 (float): Second guess. tol (float): Tolerance for convergence. max_iter (int): Maximum number of iterations. Returns: float: The approximated root of the function \`func\`. for _ in range(max_iter): # Calculate the function values at x0 and x1 f_x0 = func(x0) f_x1 = func(x1) # Prevent division by zero if f_x1 == f_x0: raise ValueError(\\"Function values at x0 and x1 are equal, leading to division by zero.\\") # Calculate the next x value using the secant method formula x2 = x1 - f_x1 * (x1 - x0) / (f_x1 - f_x0) # Check for convergence if abs(x2 - x1) < tol: return x2 # Update variables for next iteration x0, x1 = x1, x2 # Returning last approximation if maximum iterations are reached return x1"},{"question":"def manage_cart(actions: list[dict]) -> float: Simulates an online shopping cart. This function allows users to add items, remove items, and calculate the total cost of the items in the cart. Each item in the cart has a name, price, and quantity. >>> actions = [ ... {\\"action\\": \\"add\\", \\"item\\": \\"apple\\", \\"price\\": 1.0, \\"quantity\\": 3}, ... {\\"action\\": \\"add\\", \\"item\\": \\"banana\\", \\"price\\": 0.5, \\"quantity\\": 5}, ... {\\"action\\": \\"remove\\", \\"item\\": \\"apple\\", \\"quantity\\": 1}, ... {\\"action\\": \\"total\\"} ... ] >>> manage_cart(actions) 6.5 >>> actions = [ ... {\\"action\\": \\"add\\", \\"item\\": \\"apple\\", \\"price\\": 1.0, \\"quantity\\": 3}, ... {\\"action\\": \\"remove\\", \\"item\\": \\"apple\\", \\"quantity\\": 5}, ... {\\"action\\": \\"total\\"} ... ] >>> manage_cart(actions) 0.0 >>> actions = [ ... {\\"action\\": \\"add\\", \\"item\\": \\"apple\\", \\"price\\": 1.0, \\"quantity\\": 3}, ... {\\"action\\": \\"invalid_action\\"}, ... {\\"action\\": \\"total\\"} ... ] >>> manage_cart(actions) 3.0","solution":"def manage_cart(actions): cart = {} for action in actions: act = action.get('action') item = action.get('item') price = action.get('price') quantity = action.get('quantity') if act == \\"add\\": if item and price is not None and quantity is not None: if item in cart: cart[item]['quantity'] += quantity else: cart[item] = {'price': price, 'quantity': quantity} elif act == \\"remove\\": if item and quantity is not None: if item in cart: if cart[item]['quantity'] > quantity: cart[item]['quantity'] -= quantity else: del cart[item] elif act == \\"total\\": total_cost = sum(info['price'] * info['quantity'] for info in cart.values()) return total_cost # If there's no \\"total\\" action in the end total_cost = sum(info['price'] * info['quantity'] for info in cart.values()) return total_cost"},{"question":"def count_ways(n: int) -> int: Computes the number of ways to climb a staircase with n steps, where you can climb 1, 2, or 3 steps at a time. >>> count_ways(3) 4 >>> count_ways(4) 7 >>> count_ways(10) 274","solution":"def count_ways(n: int) -> int: Computes the number of ways to climb a staircase with n steps, where you can climb 1, 2, or 3 steps at a time. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 ways = [0] * (n + 1) ways[0] = 1 ways[1] = 1 ways[2] = 2 ways[3] = 4 for i in range(4, n + 1): ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3] return ways[n]"},{"question":"from typing import List, Dict, Any def get_books_by_author(author_name: str, books: List[Dict[str, Any]]) -> List[str]: Retrieve books by the specified author, sorted by publication year in ascending order. Args: author_name (str): The name of the author. books (List[Dict[str, Any]]): A list of dictionaries representing books. Each dictionary contains: - 'title' (str): Title of the book, - 'author' (str): Name of the author, - 'publication_year' (int): Year the book was published, - 'available' (bool): Availability status of the book. Returns: List[str]: A list of titles of books by the specified author, sorted by the publication year. pass # Example usage books = [ {'title': 'Book A', 'author': 'Author X', 'publication_year': 2000, 'available': True}, {'title': 'Book B', 'author': 'Author Y', 'publication_year': 1999, 'available': False}, {'title': 'Book C', 'author': 'Author X', 'publication_year': 2003, 'available': True}, {'title': 'Book D', 'author': 'Author Z', 'publication_year': 2001, 'available': True} ] print(get_books_by_author('Author X', books)) # Expected Output: ['Book A', 'Book C']","solution":"from typing import List, Dict, Any def get_books_by_author(author_name: str, books: List[Dict[str, Any]]) -> List[str]: Retrieve books by the specified author, sorted by publication year in ascending order. Args: author_name (str): The name of the author. books (List[Dict[str, Any]]): A list of dictionaries representing books. Each dictionary contains: - 'title' (str): Title of the book, - 'author' (str): Name of the author, - 'publication_year' (int): Year the book was published, - 'available' (bool): Availability status of the book. Returns: List[str]: A list of titles of books by the specified author, sorted by the publication year. # Filter books by the specified author filtered_books = [book for book in books if book['author'] == author_name] # Sort the filtered books by publication year in ascending order sorted_books = sorted(filtered_books, key=lambda x: x['publication_year']) # Extract and return the titles of the sorted books return [book['title'] for book in sorted_books]"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. This function must run in O(n) time complexity and achieve the result with O(1) space complexity (excluding the space for the output array). Args: nums: List of integers Returns: List of integers where each value at index i is the product of all numbers in the input array except for the number at index i. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) answer = [1] * n left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"from typing import List def length_of_lis(prices: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list of prices. Args: prices (List[int]): A list of integers representing stock prices Returns: int: The length of the longest increasing subsequence Examples: >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_lis([4, 10, 4, 3, 8, 9]) 3 >>> length_of_lis([1]) 1 pass","solution":"from typing import List import bisect def length_of_lis(prices: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list of prices. if not prices: return 0 # dp will store the increasing subsequences formed dp = [] for price in prices: # Find the index where the price fits in the dp array idx = bisect.bisect_left(dp, price) # If the price is larger than any element in dp, it extends the largest subsequence if idx == len(dp): dp.append(price) else: dp[idx] = price return len(dp)"},{"question":"from typing import List def merge_and_sort_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two lists, sorts the resulting list in ascending order, and removes duplicates. Parameters: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: List[int]: A sorted list of unique integers. Examples: >>> merge_and_sort_lists([5, 3, 1], [6, 2, 3, 1]) [1, 2, 3, 5, 6] >>> merge_and_sort_lists([], [4, 2, 2, 3, 9]) [2, 3, 4, 9] from solution import merge_and_sort_lists def test_merge_and_sort_lists_example(): assert merge_and_sort_lists([5, 3, 1], [6, 2, 3, 1]) == [1, 2, 3, 5, 6] def test_merge_and_sort_lists_empty_lists(): assert merge_and_sort_lists([], []) == [] def test_merge_and_sort_lists_list1_empty(): assert merge_and_sort_lists([], [4, 2, 2, 3, 9]) == [2, 3, 4, 9] def test_merge_and_sort_lists_list2_empty(): assert merge_and_sort_lists([7, 8, 8, 5], []) == [5, 7, 8] def test_merge_and_sort_lists_no_duplicates(): assert merge_and_sort_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_merge_and_sort_lists_only_duplicates(): assert merge_and_sort_lists([1, 2, 3], [3, 2, 1]) == [1, 2, 3] def test_merge_and_sort_lists_large_numbers(): assert merge_and_sort_lists([10**9, -10**9], [0, 10**9]) == [-10**9, 0, 10**9]","solution":"def merge_and_sort_lists(list1, list2): Merges two lists, sorts the resulting list in ascending order, and removes duplicates. Parameters: list1 (list of int): The first list of integers. list2 (list of int): The second list of integers. Returns: list of int: A sorted list of unique integers. merged_set = set(list1) | set(list2) sorted_list = sorted(merged_set) return sorted_list"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts the word into the Trie. >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.insert(\\"helium\\") def search(self, word: str) -> bool: Returns True if the word is in the Trie, False otherwise. >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.search(\\"hello\\") True >>> trie.search(\\"hellium\\") False def delete(self, word: str) -> None: Deletes the word from the Trie if it exists. >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.delete(\\"hello\\") >>> trie.search(\\"hello\\") False","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def delete(self, word: str) -> None: def _delete(node, word, depth): if depth == len(word): if node.is_end_of_word: node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char in node.children: should_delete_child = _delete(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 and not node.is_end_of_word return False _delete(self.root, word, 0)"},{"question":"def extract_domain_counts(emails: list[str]) -> dict[str, int]: Count the occurrences of each domain in a list of email addresses. Args: emails (list[str]): List of email addresses in the format [username@domain]. Returns: dict[str, int]: Dictionary with domains as keys and their counts as values. Example: >>> extract_domain_counts([\\"alice@example.com\\", \\"bob@example.com\\", \\"charles@test.org\\"]) {'example.com': 2, 'test.org': 1} >>> extract_domain_counts([\\"john@domain.com\\", \\"jane@domain.com\\", \\"doe@another.com\\"]) {'domain.com': 2, 'another.com': 1}","solution":"def extract_domain_counts(emails: list[str]) -> dict[str, int]: Count the occurrences of each domain in a list of email addresses. Args: emails (list[str]): List of email addresses in the format [username@domain]. Returns: dict[str, int]: Dictionary with domains as keys and their counts as values. domain_count = {} for email in emails: domain = email.split('@')[1] if domain in domain_count: domain_count[domain] += 1 else: domain_count[domain] = 1 return domain_count"},{"question":"def compress(text: str) -> str: Compresses a string using run-length encoding (RLE) technique. >>> compress(\\"aaaabbbcca\\") \\"4a3b2ca\\" >>> compress(\\"aabbcc\\") \\"2a2b2c\\" >>> compress(\\"abcd\\") \\"abcd\\" >>> compress(\\"\\") \\"\\" def decompress(text: str) -> str: Decompresses a run-length encoded (RLE) string. >>> decompress(\\"4a3b2ca\\") \\"aaaabbbcca\\" >>> decompress(\\"2a2b2c\\") \\"aabbcc\\" >>> decompress(\\"abcd\\") \\"abcd\\" >>> decompress(\\"\\") \\"\\"","solution":"def compress(text: str) -> str: if not text: return \\"\\" compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(f\\"{count if count > 1 else ''}{text[i - 1]}\\") count = 1 compressed.append(f\\"{count if count > 1 else ''}{text[-1]}\\") return ''.join(compressed) def decompress(text: str) -> str: if not text: return \\"\\" decompressed = [] i = 0 while i < len(text): if text[i].isdigit(): num = 0 while i < len(text) and text[i].isdigit(): num = num * 10 + int(text[i]) i += 1 if i < len(text): decompressed.append(text[i] * num) else: decompressed.append(text[i]) i += 1 return ''.join(decompressed)"},{"question":"def longest_vowel_substring(s: str) -> str: Returns the longest contiguous substring that contains only vowels from the input string \`s\`. >>> longest_vowel_substring(\\"elephant\\") \\"e\\" >>> longest_vowel_substring(\\"beautiful\\") \\"eau\\" >>> longest_vowel_substring(\\"sky\\") \\"\\"","solution":"def longest_vowel_substring(s: str) -> str: Returns the longest contiguous substring that contains only vowels from the input string \`s\`. vowels = set('aeiou') max_len = 0 max_substr = \\"\\" current_start = 0 current_len = 0 for i, char in enumerate(s): if char in vowels: current_len += 1 if current_len > max_len: max_len = current_len max_substr = s[current_start:i+1] else: current_len = 0 current_start = i + 1 return max_substr"},{"question":"from typing import List, Dict class Hotel: def __init__(self): self.rooms = {} def add_room(self, room_id: str, capacity: int) -> None: Add a room to the hotel with a specific capacity. Args: room_id (str): A unique identifier for the room. capacity (int): The maximum number of guests that can be accommodated in the room. def book_rooms(self, bookings: List[int]) -> Dict[int, List[str]]: Process a list of bookings, automatically assigning rooms based on their availability, and return a summary with room assignments. Args: bookings (List[int]): A list of integers, each representing the number of guests for a booking. Returns: Dict[int, List[str]]: A dictionary where each key represents the booking index, and the value is a list of room identifiers assigned to that booking. def available_rooms(self, guests: int) -> List[str]: Check and return a list of available rooms that can accommodate the given number of guests. Args: guests (int): The number of guests requiring accommodation. Returns: List[str]: A list of room identifiers that can accommodate the given number of guests.","solution":"from typing import List, Dict class Hotel: def __init__(self): self.rooms = {} self.available_rooms_list = [] def add_room(self, room_id: str, capacity: int) -> None: self.rooms[room_id] = { \\"capacity\\": capacity, \\"available\\": True } self.available_rooms_list.append((capacity, room_id)) self.available_rooms_list.sort() def available_rooms(self, guests: int) -> List[str]: suitable_rooms = [] for capacity, room_id in self.available_rooms_list: if capacity >= guests and self.rooms[room_id][\\"available\\"]: suitable_rooms.append(room_id) return suitable_rooms def book_rooms(self, bookings: List[int]) -> Dict[int, List[str]]: booking_result = {} for booking_id, guests in enumerate(bookings): suitable_rooms = self.available_rooms(guests) if suitable_rooms: room_id = suitable_rooms[0] self.rooms[room_id][\\"available\\"] = False booking_result[booking_id] = [room_id] self.available_rooms_list.remove((self.rooms[room_id][\\"capacity\\"], room_id)) else: booking_result[booking_id] = [] return booking_result"},{"question":"def simplify_unix_path(path: str) -> str: Simplify a Unix/Linux style path to its canonical form. >>> simplify_unix_path(\\"/home//foo/\\") == \\"/home/foo\\" >>> simplify_unix_path(\\"/a/./b/../../c/\\") == \\"/c\\" >>> simplify_unix_path(\\"/../\\") == \\"/\\" >>> simplify_unix_path(\\"/home//foo/./bar\\") == \\"/home/foo/bar\\" >>> simplify_unix_path(\\"/a//b////c/d//././/..\\") == \\"/a/b/c\\" >>> simplify_unix_path(\\"/a/.../b/./c/../d/\\") == \\"/a/.../b/d\\" >>> simplify_unix_path(\\"/\\") == \\"/\\"","solution":"def simplify_unix_path(path: str) -> str: components = path.split(\\"/\\") stack = [] for part in components: if part == \\"..\\": if stack: stack.pop() elif part and part != \\".\\": stack.append(part) simplified_path = \\"/\\" + \\"/\\".join(stack) return simplified_path"},{"question":"def kth_largest_unique_element(arr: list, k: int) -> int: Find the k-th largest unique element in the array. If there are fewer than k unique elements, return -1. >>> kth_largest_unique_element([3, 1, 2, 1, 4, 3, 5], 2) 4 >>> kth_largest_unique_element([7, 7, 7], 1) 7 >>> kth_largest_unique_element([3, 1, 2, 2, 1, 3], 4) -1 pass","solution":"def kth_largest_unique_element(arr, k): Find the k-th largest unique element in the array. If there are fewer than k unique elements, return -1. unique_elements = list(set(arr)) unique_elements.sort(reverse=True) if len(unique_elements) < k: return -1 return unique_elements[k-1]"},{"question":"def average_temperature(temperatures: list) -> float: Returns the average temperature from the list of temperatures, excluding readings outside the range of -50 to 50 degrees. Args: temperatures (list): List of integer temperatures. Returns: float: The average temperature of the valid readings, or 0.0 if all readings are invalid. Examples: >>> average_temperature([23, 45, -60, 12, 54, 30, -10]) 20.0 >>> average_temperature([-60, 54, 70, -100, 90]) 0.0 >>> average_temperature([10, 20, 30, -10, -20, 0]) 5.0 >>> average_temperature([]) 0.0 >>> average_temperature([25]) 25.0 >>> average_temperature([100]) 0.0","solution":"def average_temperature(temperatures: list) -> float: Returns the average temperature from the list of temperatures, excluding readings outside the range of -50 to 50 degrees. Args: temperatures (list): List of integer temperatures. Returns: float: The average temperature of the valid readings. # Filter temperatures to remove invalid readings valid_temperatures = [temp for temp in temperatures if -50 <= temp <= 50] # If no valid temperatures, return 0 if not valid_temperatures: return 0.0 # Calculate the average of valid temperatures return sum(valid_temperatures) / len(valid_temperatures)"},{"question":"from typing import Optional class TreeNode: def __init__(self, data: int): self.data = data self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None def is_min_heap(root: Optional[TreeNode]) -> bool: Determines if the given binary tree is a Min Heap. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> is_min_heap(root) True >>> root = TreeNode(3) >>> root.left = TreeNode(2) >>> root.right = TreeNode(1) >>> is_min_heap(root) False","solution":"from typing import Optional class TreeNode: def __init__(self, data: int): self.data = data self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None def is_min_heap(root: Optional[TreeNode]) -> bool: # Helper function to check min-heap property def check_min_heap(node: Optional[TreeNode]) -> bool: # Base case: if the node is None, it satisfies min-heap property by default if not node: return True # Check if the current node is less than or equal to its left child if node.left and node.data > node.left.data: return False # Check if the current node is less than or equal to its right child if node.right and node.data > node.right.data: return False # Recur for left and right children return check_min_heap(node.left) and check_min_heap(node.right) return check_min_heap(root)"},{"question":"# Find Missing Element in Range You are asked to write a function that finds the missing element in an array that contains all the elements from a certain range except one. Specifically, given an array of unique integers that represent a sequence from a start value to an end value, return the missing integer. def find_missing_element(arr: list, start: int, end: int) -> int: Finds the missing element in an array containing unique integers within a specified range. Args: arr: List of unique integers representing a sequence with one missing element. start: The starting integer of the range. end: The ending integer of the range. Returns: The missing integer from the array. Example: >>> find_missing_element([1, 2, 4, 5], 1, 5) 3 >>> find_missing_element([10, 11, 13], 10, 13) 12 total_sum = sum(range(start, end + 1)) array_sum = sum(arr) return total_sum - array_sum","solution":"def find_missing_element(arr: list, start: int, end: int) -> int: Finds the missing element in an array containing unique integers within a specified range. Args: arr: List of unique integers representing a sequence with one missing element. start: The starting integer of the range. end: The ending integer of the range. Returns: The missing integer from the array. Example: >>> find_missing_element([1, 2, 4, 5], 1, 5) 3 >>> find_missing_element([10, 11, 13], 10, 13) 12 total_sum = sum(range(start, end + 1)) array_sum = sum(arr) return total_sum - array_sum"},{"question":"def max_count_after_operations(m: int, n: int, ops: List[List[int]]) -> int: Given dimensions of the grid (m, n) and a list of operations (ops), find the number of maximum integers in the matrix after performing all the operations. >>> max_count_after_operations(3, 3, [[2, 2], [3, 3]]) 4 >>> max_count_after_operations(3, 3, [[2, 2], [3, 3], [3, 3]]) 4 >>> max_count_after_operations(3, 3, []) 9","solution":"def max_count_after_operations(m: int, n: int, ops: list) -> int: if not ops: return m * n min_r = m min_c = n for op in ops: min_r = min(min_r, op[0]) min_c = min(min_c, op[1]) return min_r * min_c"},{"question":"from typing import List def square_even_numbers(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the squares of all the even numbers from the original list. Args: nums (List[int]): A list of integers Returns: List[int]: A list of squared even integers Examples: >>> square_even_numbers([1, 2, 3, 4, 5]) [4, 16] >>> square_even_numbers([7, 8, 10, 13]) [64, 100] >>> square_even_numbers([]) [] >>> square_even_numbers([-2, -4, -6]) [4, 16, 36] >>> square_even_numbers([1, 3, 5, 7]) []","solution":"from typing import List def square_even_numbers(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the squares of all the even numbers from the original list. Args: nums (List[int]): A list of integers Returns: List[int]: A list of squared even integers return [num ** 2 for num in nums if num % 2 == 0]"},{"question":"import heapq from typing import List, Tuple, Dict def dijkstra(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: Find the shortest path from the source vertex to all other vertices in the graph using Dijkstra's Algorithm. Parameters: graph: Adjacency list representing the directed graph where keys are vertices, and values are lists of tuples representing adjacent vertices and the weight of the edges (vertex, weight). source: The source vertex from which to calculate the shortest paths. Returns: A dictionary where keys are vertices and values are the shortest distance from the source vertex to that vertex. >>> graph1 = {0: [(1, 2), (2, 4)], 1: [(3, 1)], 2: [(3, 5)], 3: [(4, 3)], 4: [], 5: [(3, 2)]} >>> source1 = 0 >>> dijkstra(graph1, source1) == {0: 0, 1: 2, 2: 4, 3: 3, 4: 6, 5: float('inf')} True >>> graph2 = {0: [(1, 1)], 1: [(2, 2)], 2: [(0, 3)]} >>> source2 = 1 >>> dijkstra(graph2, source2) == {0: 5, 1: 0, 2: 2} True","solution":"import heapq from typing import List, Tuple, Dict def dijkstra(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: Find the shortest path from the source vertex to all other vertices in the graph using Dijkstra's Algorithm. Parameters: graph: Adjacency list representing the directed graph where keys are vertices, and values are lists of tuples representing adjacent vertices and the weight of the edges (vertex, weight). source: The source vertex from which to calculate the shortest paths. Returns: A dictionary where keys are vertices and values are the shortest distance from the source vertex to that vertex. pq = [(0, source)] # Priority queue of (distance, vertex) distances = {source: 0} visited = set() while pq: current_distance, current_vertex = heapq.heappop(pq) if current_vertex in visited: continue visited.add(current_vertex) for neighbor, weight in graph.get(current_vertex, []): distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # Ensure all vertices are included in the result, even if they are not reachable for vertex in graph.keys(): if vertex not in distances: distances[vertex] = float('inf') return distances"},{"question":"def top_k_frequent(nums: list, k: int) -> list: Returns the k most frequent elements in the list nums. If there is a tie in frequency, the smaller element is preferred. Arguments: nums: A list of integers. k: An integer representing the number of top frequent elements to return. Returns: A list of k integers representing the most frequent elements, sorted by their frequency and then by their value if frequency is the same. Example: >>> nums = [1, 1, 1, 2, 2, 3] >>> k = 2 >>> top_k_frequent(nums, k) [1, 2] >>> nums = [4, 4, 4, 5, 6, 6, 7, 7, 7] >>> k = 3 >>> top_k_frequent(nums, k) [4, 7, 6] pass","solution":"from collections import Counter import heapq def top_k_frequent(nums: list, k: int) -> list: Returns the k most frequent elements in the list nums. If there is a tie in frequency, the smaller element is preferred. Arguments: nums: A list of integers. k: An integer representing the number of top frequent elements to return. Returns: A list of k integers representing the most frequent elements, sorted by their frequency and then by their value if frequency is the same. # Count the frequency of each element in nums frequency_counter = Counter(nums) # Use a heap to get the k most frequent elements # The heap uses negative frequency to get the largest frequencies heap = [(-freq, num) for num, freq in frequency_counter.items()] heapq.heapify(heap) # Extract the k elements with the highest frequency (and smallest number in case of ties) top_k_elements = [heapq.heappop(heap)[1] for _ in range(k)] return top_k_elements"},{"question":"def resolve_dependencies(modules: list[str], dependencies: dict[str, list[str]]) -> list[str]: Determine a valid order in which the modules can be installed or executed based on their dependencies. If no valid order exists due to circular dependencies, return an empty list. Args: modules : list[str] A list of strings where each string is a module name. dependencies : dict[str, list[str]] A dictionary where each key is a module name and the corresponding value is a list of modules that it depends on. Returns: list[str] A list of strings representing the valid installation order of the modules, or an empty list if no valid order exists due to circular dependencies. >>> modules = ['A', 'B', 'C', 'D'] >>> dependencies = {'A': ['B'], 'B': ['C'], 'C': [], 'D': ['C']} >>> resolve_dependencies(modules, dependencies) ['C', 'B', 'A', 'D'] >>> modules = ['A', 'B', 'C', 'D'] >>> dependencies = {'A': ['B'], 'B': ['C'], 'C': ['A'], 'D': ['C']} >>> resolve_dependencies(modules, dependencies) [] # your code here","solution":"def resolve_dependencies(modules, dependencies): Given a list of modules and a dictionary mapping each module to its dependencies, returns a valid installation order of the modules using topological sorting, or an empty list if a circular dependency exists. from collections import defaultdict, deque # Create a graph and in-degree count graph = defaultdict(list) in_degree = {module: 0 for module in modules} # Build the graph and in-degree for module, deps in dependencies.items(): for dep in deps: graph[dep].append(module) in_degree[module] += 1 # Initialize the queue with modules having no dependencies (in-degree 0) queue = deque([module for module in modules if in_degree[module] == 0]) order = [] # Perform topological sorting while queue: module = queue.popleft() order.append(module) # Decrease in-degree of neighboring nodes for neighbor in graph[module]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if topological sort is possible (i.e., no circular dependency) if len(order) == len(modules): return order else: return [] # Example usage: modules = ['A', 'B', 'C', 'D'] dependencies = { 'A': ['B'], 'B': ['C'], 'C': [], 'D': ['C'] } print(resolve_dependencies(modules, dependencies)) # Prints a valid order e.g., ['C', 'B', 'A', 'D']"},{"question":"def plan_drone_path(grid, start, end): Plan the shortest path for a drone in a 2D grid avoiding obstacles. >>> grid = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> end = (2, 2) >>> plan_drone_path(grid, start, end) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] >>> grid2 = [ ... [0, 1], ... [1, 0] ... ] >>> start2 = (0, 0) >>> end2 = (1, 1) >>> plan_drone_path(grid2, start2, end2) []","solution":"from collections import deque def plan_drone_path(grid, start, end): if start == end: return [start] rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([start]) came_from = {start: None} while queue: current = queue.popleft() if current == end: path = [] while current: path.append(current) current = came_from[current] return path[::-1] for direction in directions: next_cell = (current[0] + direction[0], current[1] + direction[1]) if 0 <= next_cell[0] < rows and 0 <= next_cell[1] < cols and next_cell not in came_from and grid[next_cell[0]][next_cell[1]] == 0: queue.append(next_cell) came_from[next_cell] = current return []"},{"question":"def longest_even_odd_subarray(arr: list) -> tuple: Finds the longest subarray with equal number of even and odd integers. Args: arr (list of int): The input array of integers. Returns: tuple: (length of the subarray, start index, end index) if such a subarray is found, otherwise (0, -1, -1). >>> longest_even_odd_subarray([1, 2, 3, 6, 5, 4, 6, 5]) (8, 0, 7) >>> longest_even_odd_subarray([1, 1, 1, 1]) (0, -1, -1) >>> longest_even_odd_subarray([2, 2, 2, 2]) (0, -1, -1) >>> longest_even_odd_subarray([1, 2, 1, 2, 1, 2]) (6, 0, 5) >>> longest_even_odd_subarray([1, 2]) (2, 0, 1)","solution":"def longest_even_odd_subarray(arr: list) -> tuple: Finds the longest subarray with equal number of even and odd integers. Args: arr (list of int): The input array of integers. Returns: tuple: (length of the subarray, start index, end index) if such a subarray is found, otherwise (0, -1, -1). n = len(arr) max_length = 0 start_index = -1 end_index = -1 prefix_sum = {0: -1} current_balance = 0 for i in range(n): if arr[i] % 2 == 0: current_balance += 1 else: current_balance -= 1 if current_balance in prefix_sum: length = i - prefix_sum[current_balance] if length > max_length: max_length = length start_index = prefix_sum[current_balance] + 1 end_index = i else: prefix_sum[current_balance] = i return (max_length, start_index, end_index)"},{"question":"def find_triplets(nums: list) -> list: Finds all unique triplets in the list which sum to zero. >>> find_triplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([0, 0, 0]) [[0, 0, 0]] >>> find_triplets([1, 2, -2, -1]) [] >>> find_triplets([]) [] >>> find_triplets([1, 2, 3, 4, 5]) [] >>> find_triplets([0, -1, 2, -3, 1]) [[-3, 1, 2], [-1, 0, 1]] >>> find_triplets(list(range(-500, 500))) # Arbitrary large input for performance testing >>> find_triplets([-2, 0, 1, 1, 2, -1,-1, -2]) [[-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1]]","solution":"def find_triplets(nums): Finds all unique triplets in the list which sum to zero. nums.sort() results = [] length = len(nums) for i in range(length - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip same element to avoid duplicate triplets left, right = i + 1, length - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: results.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return results"},{"question":"class TrieNode: def __init__(self): Initialize a Trie node with children and a boolean to track the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the root of the Trie. self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the Trie. :param word: String to be inserted. pass def search(self, word: str) -> bool: Search for a word in the Trie. :param word: String to be searched. :return: True if word exists in the Trie, otherwise False. pass def starts_with(self, prefix: str) -> list[str]: Find all words in the Trie that start with the given prefix. :param prefix: The prefix string. :return: List of all words in the Trie that start with the prefix. pass # Example usage trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"helium\\") print(trie.search(\\"hello\\")) # Output: True print(trie.search(\\"helix\\")) # Output: False print(trie.starts_with(\\"he\\")) # Output: [\\"hello\\", \\"helium\\"] print(trie.starts_with(\\"hex\\")) # Output: []","solution":"class TrieNode: def __init__(self): Initialize a Trie node with children and a boolean to track the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the root of the Trie. self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the Trie. :param word: String to be inserted. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Search for a word in the Trie. :param word: String to be searched. :return: True if word exists in the Trie, otherwise False. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> list[str]: Find all words in the Trie that start with the given prefix. :param prefix: The prefix string. :return: List of all words in the Trie that start with the prefix. def dfs(node, prefix): results = [] if node.is_end_of_word: results.append(prefix) for char, next_node in node.children.items(): results.extend(dfs(next_node, prefix + char)) return results node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return dfs(node, prefix)"},{"question":"Implement the function \`collatz_steps\` that computes the number of steps required to reach 1 in the Collatz sequence for a given positive integer. def collatz_steps(n: int) -> int: Computes the number of steps required to reach 1 in the Collatz sequence for a given number n. Parameters: n (int): A positive integer to start the Collatz sequence. Returns: int: The number of steps to reach 1. Raises: ValueError: If the input is not a positive integer. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer\\") steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps def test_collatz_steps(): # test with a few known values assert collatz_steps(1) == 0 assert collatz_steps(12) == 9 assert collatz_steps(19) == 20 # test with arbitrarily large number assert collatz_steps(1000000) == 152 # test for minimum positive value assert collatz_steps(2) == 1 # test when n = 27, which is known to have a long sequence assert collatz_steps(27) == 111 # test invalid inputs import pytest with pytest.raises(ValueError, match=\\"Input must be a positive integer\\"): collatz_steps(-5) with pytest.raises(ValueError, match=\\"Input must be a positive integer\\"): collatz_steps(0) with pytest.raises(ValueError, match=\\"Input must be a positive integer\\"): collatz_steps(\\"a\\") with pytest.raises(ValueError, match=\\"Input must be a positive integer\\"): collatz_steps(2.3) if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def collatz_steps(n: int) -> int: Computes the number of steps required to reach 1 in the Collatz sequence for a given number n. Parameters: n (int): A positive integer to start the Collatz sequence. Returns: int: The number of steps to reach 1. Raises: ValueError: If the input is not a positive integer. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer\\") steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps"},{"question":"from typing import List, Union def diagonal_product(matrix: List[List[Union[int, float]]]) -> Union[int, float]: Calculate the product of the diagonal elements of a square matrix. :param matrix: A 2D list representation of the square matrix. :return: The product of the diagonal elements, or 0 for invalid input cases. Example usage: >>> diagonal_product([[2, 3], [4, 5]]) 10 >>> diagonal_product([[1, 0, 0], [0, 2, 0], [0, 0, 3]]) 6 >>> diagonal_product([[1.5, 0], [0, 3.5]]) 5.25 >>> diagonal_product([[1, 2], [3, 4], [5, 6]]) 0 >>> diagonal_product([[1, 0], [0, 0]]) 0 >>> diagonal_product([]) 0","solution":"from typing import List, Union def diagonal_product(matrix: List[List[Union[int, float]]]) -> Union[int, float]: Calculate the product of the diagonal elements of a square matrix. :param matrix: A 2D list representation of the square matrix. :return: The product of the diagonal elements, or 0 for invalid input cases. # Check if matrix is empty if not matrix: return 0 # Check if matrix is square size = len(matrix) if any(len(row) != size for row in matrix): return 0 # Calculate the product of diagonal elements product = 1 for i in range(size): # Check for diagonal element being zero if matrix[i][i] == 0: return 0 product *= matrix[i][i] return product"},{"question":"def reverse_string(s: str) -> str: Reverses the input string. Parameters: s (str): A string to be reversed. Returns: str: The reversed string. def test_reverse_simple_string(): assert reverse_string(\\"hello\\") == \\"olleh\\" def test_reverse_with_spaces(): assert reverse_string(\\"hello world\\") == \\"dlrow olleh\\" def test_reverse_empty_string(): assert reverse_string(\\"\\") == \\"\\" def test_reverse_single_character(): assert reverse_string(\\"a\\") == \\"a\\" def test_reverse_palindrome(): assert reverse_string(\\"madam\\") == \\"madam\\" def test_reverse_with_symbols(): assert reverse_string(\\"!@@!\\") == \\"!@@!\\" def test_reverse_long_string(): input_data = \\"a\\" * 100000 expected_output = \\"a\\" * 100000 assert reverse_string(input_data) == expected_output def test_reverse_mixed_characters(): assert reverse_string(\\"123 abc!@\\") == \\"@!cba 321\\"","solution":"def reverse_string(s: str) -> str: Reverses the input string. Parameters: s (str): A string to be reversed. Returns: str: The reversed string. return s[::-1]"},{"question":"from typing import List class MatrixPathFinder: def __init__(self): Initialize the MatrixPathFinder. pass def longest_increasing_path(self, matrix: List[List[int]]) -> int: Calculates the length of the longest increasing path in the given matrix. Args: matrix (List[List[int]]): A 2D list of integers. Returns: int: The length of the longest increasing path. Example: >>> mpf = MatrixPathFinder() >>> matrix = [ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ] >>> mpf.longest_increasing_path(matrix) 4 >>> matrix = [ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ] >>> mpf.longest_increasing_path(matrix) 4 pass # Unit tests def test_longest_increasing_path(): mpf = MatrixPathFinder() matrix1 = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] assert mpf.longest_increasing_path(matrix1) == 4 matrix2 = [ [3, 4, 5], [3, 2, 6], [2, 2, 1] ] assert mpf.longest_increasing_path(matrix2) == 4 matrix3 = [[1]] assert mpf.longest_increasing_path(matrix3) == 1 matrix4 = [ [7, 8, 9], [9, 7, 6], [7, 2, 3] ] assert mpf.longest_increasing_path(matrix4) == 6 matrix5 = [ [1, 2], [2, 3] ] assert mpf.longest_increasing_path(matrix5) == 3 def test_empty_matrix(): mpf = MatrixPathFinder() assert mpf.longest_increasing_path([]) == 0 assert mpf.longest_increasing_path([[]]) == 0 def test_large_matrix(): mpf = MatrixPathFinder() large_matrix = [[1] * 200 for _ in range(200)] assert mpf.longest_increasing_path(large_matrix) == 1","solution":"from typing import List class MatrixPathFinder: def __init__(self): pass def longest_increasing_path(self, matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) memo = [[0] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x: int, y: int) -> int: if memo[x][y] != 0: return memo[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) memo[x][y] = max_length return max_length return max(dfs(x, y) for x in range(m) for y in range(n))"},{"question":"def sort_primes(lst: list) -> list: Returns a new list with prime numbers at the beginning in their original relative order, followed by non-prime numbers in their original relative order. >>> sort_primes([3, 6, 2, 7, 8, 1]) [3, 2, 7, 6, 8, 1] >>> sort_primes([10, 11, 13, 14, 15]) [11, 13, 10, 14, 15] >>> sort_primes([]) []","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sort_primes(lst): Returns a new list with prime numbers at the beginning in their original relative order, followed by non-prime numbers in their original relative order. primes = [] non_primes = [] for num in lst: if is_prime(num): primes.append(num) else: non_primes.append(num) return primes + non_primes"},{"question":"def most_frequent_characters(s: str) -> str: Determine the most frequent character(s) in a given string. If there is a tie, return all of the most frequent characters in alphabetical order as a single concatenated string. >>> most_frequent_characters(\\"aabbbcccc\\") 'c' >>> most_frequent_characters(\\"abcabcabc\\") 'abc' >>> most_frequent_characters(\\"a\\") 'a' >>> most_frequent_characters(\\"abcd\\") 'abcd' >>> most_frequent_characters(\\"aabbccddeeff\\") 'abcdef' >>> most_frequent_characters(\\"aabbccddeee\\") 'e' >>> most_frequent_characters(\\"x\\" * 50000 + \\"y\\" * 50000) 'xy'","solution":"def most_frequent_characters(s: str) -> str: from collections import Counter # Count the frequency of each character frequency = Counter(s) # Find the maximum frequency max_freq = max(frequency.values()) # Collect characters with the maximum frequency most_frequent = [char for char, freq in frequency.items() if freq == max_freq] # Return the characters sorted and concatenated return ''.join(sorted(most_frequent))"},{"question":"from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], start_node: int) -> List[float]: Implements Dijkstra's algorithm to find the shortest paths from start_node to all other nodes in a graph. :param graph: A list of lists where each sublist represents the adjacency list of the corresponding node. Each element in the sublist is a tuple of the form (neighbor, weight), where \`neighbor\` is the adjacent node and \`weight\` is the edge weight between the nodes. :param start_node: An integer representing the starting node from which shortest paths are calculated. :return: A list of floats where the value at index \`i\` represents the shortest distance from the \`start_node\` to node \`i\`. If a node is not reachable from \`start_node\`, the distance should be represented as float('inf'). Example: >>> graph = [ [(1, 4), (2, 1)], # neighbors of node 0 [(3, 1)], # neighbors of node 1 [(1, 2), (3, 5)], # neighbors of node 2 [] # node 3 has no neighbors ] >>> start_node = 0 >>> dijkstra(graph, start_node) [0, 3, 1, 4]","solution":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], start_node: int) -> List[float]: Implements Dijkstra's algorithm to find the shortest paths from start_node to all other nodes in a graph. # Number of nodes in the graph n = len(graph) # Distance array, initialized to infinity for all nodes except the start_node distances = [float('inf')] * n distances[start_node] = 0 # Priority Queue (Min-Heap) min_heap = [(0, start_node)] while min_heap: current_distance, current_node = heapq.heappop(min_heap) # If we find a larger distance in the heap than the current known distance, skip processing if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"from typing import List def replace_integer_elements(nums: List[int]) -> List[int]: Replace each element in the list with the product of all other elements without using division. Args: nums: List[int] - list of integers Returns: List[int] - new list after replacement Example Usage: >>> replace_integer_elements([1, 2, 3, 4]) [24, 12, 8, 6] >>> replace_integer_elements([-1, -2, -3, -4]) [-24, -12, -8, -6]","solution":"from typing import List def replace_integer_elements(nums: List[int]) -> List[int]: Replace each element in the list with the product of all other elements. Args: nums: List[int] - list of integers Returns: List[int] - new list after replacement n = len(nums) if n == 2: return [nums[1], nums[0]] left_products = [1] * n right_products = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] result = [] for i in range(n): result.append(left_products[i] * right_products[i]) return result"},{"question":"def consistent_hash(key: str, num_nodes: int) -> int: Computes the hash of a given key and maps it to one of the nodes in the system. Returns the index of the node to which the key should be mapped. >>> consistent_hash('my_key', 5) # The result might vary due to the nature of hash function >>> consistent_hash('another_key', 5) # The result might vary due to the nature of hash function Example test cases: assert consistent_hash('my_key', 1) == 0 assert consistent_hash('sufficient_hashing', 100) >= 0 assert consistent_hash('sufficient_hashing', 100) < 100","solution":"def consistent_hash(key: str, num_nodes: int) -> int: Computes the hash of a given key and maps it to one of the nodes in the system. Returns the index of the node to which the key should be mapped. hash_value = hash(key) return hash_value % num_nodes"},{"question":"class MinHeap: Implement a priority queue using a Min Binary Heap. The MinHeap class should support the following operations: - \`insert(val)\`: Add a new element to the heap. - \`extract_min()\`: Remove and return the minimum element from the heap. - \`get_min()\`: Return the minimum element without removing it. - \`is_empty()\`: Return \`True\` if the heap is empty, \`False\` otherwise. Example usage: >>> heap = MinHeap() >>> heap.is_empty() True >>> heap.insert(3) >>> heap.insert(1) >>> heap.insert(2) >>> heap.is_empty() False >>> heap.get_min() 1 >>> heap.extract_min() 1 >>> heap.get_min() 2 >>> heap.insert(0) >>> heap.get_min() 0 >>> heap.extract_min() 0 >>> heap.extract_min() 2 >>> heap.extract_min() 3 >>> heap.is_empty() True def __init__(self): pass def insert(self, val: int) -> None: pass def extract_min(self) -> int: pass def get_min(self) -> int: pass def is_empty(self) -> bool: pass","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: self.heap.append(val) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: if self.is_empty(): raise IndexError(\\"extract_min() called on empty heap\\") self._swap(0, len(self.heap) - 1) min_val = self.heap.pop() self._heapify_down(0) return min_val def get_min(self) -> int: if self.is_empty(): raise IndexError(\\"get_min() called on empty heap\\") return self.heap[0] def is_empty(self) -> bool: return len(self.heap) == 0 def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self._swap(index, parent_index) self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self._swap(index, smallest) self._heapify_down(smallest) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"def int_to_roman(num: int) -> str: Convert a given positive integer into its equivalent Roman numeral representation. Handles numbers from 1 to 3999. if num < 1 or num > 3999: raise ValueError(\\"int_to_roman() requires a positive integer between 1 and 3999\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): while num >= val[i]: num -= val[i] roman_numeral += syb[i] return roman_numeral","solution":"def int_to_roman(num): Convert a given positive integer into its equivalent Roman numeral representation. Handles numbers from 1 to 3999. if num < 1 or num > 3999: raise ValueError(\\"int_to_roman() requires a positive integer between 1 and 3999\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): while num >= val[i]: num -= val[i] roman_numeral += syb[i] return roman_numeral"},{"question":"def find_and_replace(text: str, target: str, replacement: str) -> tuple: Finds all occurrences of a target substring in a text and replaces them with a specified replacement substring. Additionally, returns the number of replacements made. >>> find_and_replace(\\"Hello world, hello!\\", \\"hello\\", \\"hi\\") ('Hello world, hi!', 1) >>> find_and_replace(\\"ababab\\", \\"aba\\", \\"ab\\") ('abab', 2) >>> find_and_replace(\\"aaaaa\\", \\"aa\\", \\"a\\") ('aaa', 2) >>> find_and_replace(\\"\\", \\"a\\", \\"b\\") ('', 0)","solution":"def find_and_replace(text, target, replacement): Finds all occurrences of the target in text and replaces them with the replacement. Returns a tuple of (modified text, count of replacements). if target == \\"\\": # If target is empty, return the original text and zero replacements return text, 0 result = [] i = 0 replacements = 0 while i < len(text): if text[i:i+len(target)] == target: result.append(replacement) replacements += 1 i += len(target) else: result.append(text[i]) i += 1 modified_text = \\"\\".join(result) return modified_text, replacements"},{"question":"def find_zero_sum_subarray(arr: List[int]) -> bool: Determines whether there exists at least one subarray with sum zero. >>> find_zero_sum_subarray([4, 2, -3, 1, 6]) == True >>> find_zero_sum_subarray([4, 2, 0, 1, 6]) == True >>> find_zero_sum_subarray([-3, 2, 3, 1, 6]) == False","solution":"from typing import List def find_zero_sum_subarray(arr: List[int]) -> bool: Determines whether there exists at least one subarray with sum zero. sum_set = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in sum_set: return True sum_set.add(current_sum) return False"},{"question":"def reorder_products(inventory: dict, threshold: int) -> list: Determine which products need to be reordered based on their quantities and the threshold value. Args: inventory (dict): A dictionary where each key is a product name (string), and each value is the quantity of that product (int), each quantity must be non-negative. threshold (int): The threshold quantity below which the product needs to be reordered, must be a non-negative integer. Returns: list: A list of product names (strings) that need to be reordered. Raises: Exception: If any quantity in the inventory dictionary is negative. Exception: If threshold is negative. Exception: If inventory is empty. Examples: >>> reorder_products({\\"apples\\": 10, \\"bananas\\": 5, \\"oranges\\": 2}, 6) ['bananas', 'oranges'] >>> reorder_products({\\"apples\\": 10, \\"bananas\\": 12, \\"oranges\\": 15}, 10) [] >>> reorder_products({\\"apples\\": 10, \\"bananas\\": -1, \\"oranges\\": 2}, 6) Exception: Quantities must be non-negative >>> reorder_products({\\"apples\\": 10, \\"bananas\\": 5, \\"oranges\\": 2}, -5) Exception: Threshold must be a non-negative integer >>> reorder_products({}, 6) Exception: Inventory cannot be empty # your implementation here","solution":"def reorder_products(inventory: dict, threshold: int) -> list: # Check for invalid inputs if any(quantity < 0 for quantity in inventory.values()): raise Exception(\\"Quantities must be non-negative\\") if threshold < 0: raise Exception(\\"Threshold must be a non-negative integer\\") if not inventory: raise Exception(\\"Inventory cannot be empty\\") # Determine which products need to be reordered reorder_list = [product for product, quantity in inventory.items() if quantity < threshold] return reorder_list"},{"question":"from collections import deque from typing import Dict, List def find_shortest_path(graph: Dict[int, List[int]], start: int, goal: int) -> List[int]: Determines the shortest path between two nodes in an unweighted, undirected graph. The function returns the path as a list of nodes. :param graph: Dictionary representing the adjacency list of the graph. :param start: Starting node. :param goal: Goal node. :return: List of nodes in the shortest path from start to goal. pass # Test cases def test_find_shortest_path_simple(): graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] } assert find_shortest_path(graph, 0, 4) in ([0, 1, 3, 4], [0, 2, 3, 4]) def test_find_shortest_path_start_equals_goal(): graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] } assert find_shortest_path(graph, 3, 3) == [3] def test_find_shortest_path_chain_graph(): graph = { 1: [2], 2: [1, 3], 3: [2, 4], 4: [3] } assert find_shortest_path(graph, 1, 4) == [1, 2, 3, 4] def test_find_shortest_path_large_graph(): graph = { i: [i + 1] for i in range(100000) } graph[99999] = [] assert find_shortest_path(graph, 0, 99999) == list(range(100000))","solution":"from collections import deque from typing import Dict, List def find_shortest_path(graph: Dict[int, List[int]], start: int, goal: int) -> List[int]: Determines the shortest path between two nodes in an unweighted, undirected graph. The function returns the path as a list of nodes. :param graph: Dictionary representing the adjacency list of the graph. :param start: Starting node. :param goal: Goal node. :return: List of nodes in the shortest path from start to goal. if start == goal: return [start] queue = deque([start]) came_from = {start: None} while queue: current = queue.popleft() if current == goal: break for neighbor in graph[current]: if neighbor not in came_from: queue.append(neighbor) came_from[neighbor] = current path = [] cur_node = goal while cur_node is not None: path.append(cur_node) cur_node = came_from[cur_node] path.reverse() return path"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_height(root: TreeNode) -> int: Calculate the height of a binary tree. Parameters: root (TreeNode): A TreeNode representing the root of the binary tree. Returns: int: The height of the given binary tree. Examples: >>> root1 = TreeNode(1) >>> root1.left = TreeNode(2) >>> root1.right = TreeNode(3) >>> root1.left.left = TreeNode(4) >>> root1.left.right = TreeNode(5) >>> calculate_height(root1) 2 >>> root2 = TreeNode(1) >>> root2.left = TreeNode(2) >>> root2.left.left = TreeNode(3) >>> root2.left.left.left = TreeNode(4) >>> calculate_height(root2) 3 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_height(root: TreeNode) -> int: if root is None: return -1 left_height = calculate_height(root.left) right_height = calculate_height(root.right) return max(left_height, right_height) + 1"},{"question":"import numpy as np import matplotlib.pyplot as plt import requests import csv from typing import Tuple def collect_dataset() -> np.matrix: Downloads and processes the customer behavior dataset. pass def initialize_centroids(data: np.matrix, k: int) -> np.matrix: Randomly initializes k centroids from the dataset. pass def assign_clusters(data: np.matrix, centroids: np.matrix) -> np.array: Assigns each data point to the nearest centroid. pass def update_centroids(data: np.matrix, assignments: np.array, k: int) -> np.matrix: Updates centroids by calculating the mean of all data points assigned to each centroid. pass def run_kmeans(data: np.matrix, k: int, max_iterations: int = 100) -> Tuple[np.matrix, np.array]: Runs the K-Means clustering algorithm. pass def visualize_clusters(data: np.matrix, centroids: np.matrix, assignments: np.array) -> None: Visualizes the clustered data points and centroids. pass def main(): Main execution function to load data, run K-Means, and visualize clusters. pass if __name__ == \\"__main__\\": main()","solution":"import numpy as np import matplotlib.pyplot as plt import requests import csv from typing import Tuple def collect_dataset() -> np.matrix: Downloads and processes the customer behavior dataset. url = 'https://example.com/customer_behavior.csv' # Example URL; replace with actual URL response = requests.get(url) response.raise_for_status() data = list(csv.reader(response.text.strip().split('n'))) data_matrix = np.array(data[1:], dtype=float) # Exclude header and convert to float matrix return data_matrix def initialize_centroids(data: np.matrix, k: int) -> np.matrix: Randomly initializes k centroids from the dataset. indices = np.random.choice(data.shape[0], k, replace=False) return np.array(data[indices]) def assign_clusters(data: np.matrix, centroids: np.matrix) -> np.array: Assigns each data point to the nearest centroid. distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(data: np.matrix, assignments: np.array, k: int) -> np.matrix: Updates centroids by calculating the mean of all data points assigned to each centroid. new_centroids = np.array([data[assignments == ki].mean(axis=0) for ki in range(k)]) return new_centroids def run_kmeans(data: np.matrix, k: int, max_iterations: int = 100) -> Tuple[np.matrix, np.array]: Runs the K-Means clustering algorithm. centroids = initialize_centroids(data, k) for _ in range(max_iterations): assignments = assign_clusters(data, centroids) new_centroids = update_centroids(data, assignments, k) if np.allclose(centroids, new_centroids): break centroids = new_centroids return centroids, assignments def visualize_clusters(data: np.matrix, centroids: np.matrix, assignments: np.array) -> None: Visualizes the clustered data points and centroids. plt.scatter(data[:, 1], data[:, 2], c=assignments, cmap='viridis') plt.scatter(centroids[:, 1], centroids[:, 2], s=300, c='red', marker='x') plt.xlabel('Spending') plt.ylabel('Visits') plt.title('Customer Segmentation using K-Means') plt.show() def main(): Main execution function to load data, run K-Means, and visualize clusters. data = collect_dataset() k = 3 centroids, assignments = run_kmeans(data, k) visualize_clusters(data, centroids, assignments) if __name__ == \\"__main__\\": main()"},{"question":"DEFAULT_SPEEDS = { \\"walking\\": 5, \\"biking\\": 15, \\"driving\\": 60, \\"flying\\": 800 } def estimate_travel_time(distance: float, mode: str, custom_speed: float = None) -> float: Calculate the estimated travel time between two points based on given average speed and distance. distance (float): The distance between the two points in kilometers. mode (str): The mode of transportation. Supported modes include 'walking', 'biking', 'driving', and 'flying'. custom_speed (float, optional): The user's custom speed value in kilometers per hour. If not provided, the function will use the default speed for the specified mode. Returns: float: The estimated travel time in hours, rounded to 2 decimal places. Raises: ValueError: If an unsupported mode is provided or if distance or custom speed is negative. Example Usage: >>> estimate_travel_time(30, \\"walking\\") 6.00 >>> estimate_travel_time(30, \\"driving\\") 0.50 >>> estimate_travel_time(400, \\"flying\\", 900) 0.44 >>> estimate_travel_time(50, \\"biking\\", 20) 2.50 >>> estimate_travel_time(50, \\"skating\\") Traceback (most recent call last): ... ValueError: Unsupported 'mode' value: 'skating'. Supported modes are: walking, biking, driving, flying >>> estimate_travel_time(-50, \\"walking\\") Traceback (most recent call last): ... ValueError: Distance must be a non-negative value >>> estimate_travel_time(50, \\"walking\\", -5) Traceback (most recent call last): ... ValueError: Custom speed must be a non-negative value","solution":"DEFAULT_SPEEDS = { \\"walking\\": 5, \\"biking\\": 15, \\"driving\\": 60, \\"flying\\": 800 } def estimate_travel_time(distance: float, mode: str, custom_speed: float = None) -> float: if distance < 0: raise ValueError(\\"Distance must be a non-negative value\\") mode = mode.lower() if mode not in DEFAULT_SPEEDS: raise ValueError(f\\"Unsupported 'mode' value: '{mode}'. Supported modes are: walking, biking, driving, flying\\") speed = custom_speed if custom_speed is not None else DEFAULT_SPEEDS[mode] if speed < 0: raise ValueError(\\"Custom speed must be a non-negative value\\") travel_time = distance / speed return round(travel_time, 2)"},{"question":"def count_k_sum_combinations(nums: list, k: int, S: int) -> int: Given an array of integers \`nums\`, an integer \`k\` and an integer \`S\`, returns the number of unique k-sum combinations from the array that add up to \`S\`. Args: nums (list): List of integers. k (int): Number of elements in the subset. S (int): Target sum of the subset. Returns: int: The number of unique k-sum combinations that sum up to \`S\`. Raises: ValueError: If \`k\` is larger than the size of the array or if inputs are invalid. pass # Example usage and test cases if __name__ == \\"__main__\\": print(count_k_sum_combinations([1, 2, 3, 4, 5], 3, 6)) # Output expected: 1 print(count_k_sum_combinations([1, 2, 2, 3, 3], 3, 7)) # Output expected: 2","solution":"from itertools import combinations def count_k_sum_combinations(nums: list, k: int, S: int) -> int: Given an array of integers \`nums\`, an integer \`k\` and an integer \`S\`, returns the number of unique k-sum combinations from the array that add up to \`S\`. Args: nums (list): List of integers. k (int): Number of elements in the subset. S (int): Target sum of the subset. Returns: int: The number of unique k-sum combinations that sum up to \`S\`. if k > len(nums): raise ValueError(\\"k can't be larger than the size of the array\\") # Generate all possible combinations of size k all_combinations = combinations(nums, k) # Use a set to ensure the combinations are unique unique_combinations = set() # Check each combination if it sums to the target S for combo in all_combinations: if sum(combo) == S: unique_combinations.add(tuple(sorted(combo))) return len(unique_combinations)"},{"question":"import numpy as np def normalize_dataset(dataset: np.ndarray) -> np.ndarray: Normalizes the dataset such that each feature has a mean of 0 and a standard deviation of 1. Parameters: dataset (np.ndarray): 2D array of shape (n_samples, n_features). Returns: np.ndarray: Normalized dataset with the same shape as input. pass # Your implementation here # Example usage: dataset = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]) normalized_dataset = normalize_dataset(dataset) print(normalized_dataset) # Unit tests def test_normalize_simple_dataset(): dataset = np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]) normalized = normalize_dataset(dataset) np.testing.assert_almost_equal(np.mean(normalized, axis=0), np.zeros(2)) np.testing.assert_almost_equal(np.std(normalized, axis=0), np.ones(2)) def test_normalize_single_sample(): dataset = np.array([[1.0, 2.0, 3.0]]) normalized = normalize_dataset(dataset) np.testing.assert_almost_equal(normalized, np.zeros((1, 3))) def test_normalize_identical_features(): dataset = np.array([[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]) normalized = normalize_dataset(dataset) np.testing.assert_almost_equal(normalized, np.zeros((3, 2))) def test_normalize_zero_variance_feature(): dataset = np.array([[1.0, 2.0], [1.0, 5.0], [1.0, 8.0]]) normalized = normalize_dataset(dataset) np.testing.assert_almost_equal(normalized[:, 0], np.zeros(3)) np.testing.assert_almost_equal(np.std(normalized[:, 1]), 1.0) def test_normalize_large_dataset(): dataset = np.random.rand(100000, 1000) normalized = normalize_dataset(dataset) np.testing.assert_almost_equal(np.mean(normalized, axis=0), np.zeros(1000)) np.testing.assert_almost_equal(np.std(normalized, axis=0), np.ones(1000)) # Run tests test_normalize_simple_dataset() test_normalize_single_sample() test_normalize_identical_features() test_normalize_zero_variance_feature() test_normalize_large_dataset()","solution":"import numpy as np def normalize_dataset(dataset: np.ndarray) -> np.ndarray: Normalizes the dataset such that each feature has a mean of 0 and a standard deviation of 1. Parameters: dataset (np.ndarray): 2D array of shape (n_samples, n_features). Returns: np.ndarray: Normalized dataset with the same shape as input. mean = np.mean(dataset, axis=0) std = np.std(dataset, axis=0) std[std == 0] = 1 # Prevent division by zero if a feature has zero standard deviation normalized_data = (dataset - mean) / std return normalized_data # Example usage: dataset = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]) normalized_dataset = normalize_dataset(dataset) print(normalized_dataset)"},{"question":"def merge_sort(arr: list) -> list: Sorts a list of integers using the Merge Sort algorithm. Args: arr: A list of integers to be sorted. Returns: A new list containing the sorted integers. Raises: TypeError: If the input is not a list of integers. if not isinstance(arr, list): raise TypeError(\\"Input should be a list of integers.\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"All elements in the list should be integers.\\") def test_merge_sort_empty_list(): assert merge_sort([]) == [] def test_merge_sort_single_element(): assert merge_sort([1]) == [1] def test_merge_sort_sorted_list(): assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_merge_sort_reverse_sorted_list(): assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_merge_sort_unsorted_list(): assert merge_sort([4, 1, 3, 9, 7]) == [1, 3, 4, 7, 9] assert merge_sort([10, 2, 8, 6, 7]) == [2, 6, 7, 8, 10] assert merge_sort([5, 5, 5, 2, 1]) == [1, 2, 5, 5, 5] def test_merge_sort_with_duplicates(): assert merge_sort([4, 1, 3, 3, 9, 7, 1]) == [1, 1, 3, 3, 4, 7, 9] def test_merge_sort_raises_type_error_if_not_list(): try: merge_sort(\\"not a list\\") except TypeError as e: assert str(e) == \\"Input should be a list of integers.\\" else: assert False, \\"Expected TypeError but none was raised.\\" def test_merge_sort_raises_type_error_if_not_integers(): try: merge_sort([1, 2, 3, \\"four\\"]) except TypeError as e: assert str(e) == \\"All elements in the list should be integers.\\" else: assert False, \\"Expected TypeError but none was raised.\\" if __name__ == \\"__main__\\": test_merge_sort_empty_list() test_merge_sort_single_element() test_merge_sort_sorted_list() test_merge_sort_reverse_sorted_list() test_merge_sort_unsorted_list() test_merge_sort_with_duplicates() test_merge_sort_raises_type_error_if_not_list() test_merge_sort_raises_type_error_if_not_integers()","solution":"def merge_sort(arr): Sorts a list of integers using the Merge Sort algorithm. Args: arr: A list of integers to be sorted. Returns: A new list containing the sorted integers. Raises: TypeError: If the input is not a list of integers. if not isinstance(arr, list): raise TypeError(\\"Input should be a list of integers.\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"All elements in the list should be integers.\\") if len(arr) <= 1: return arr def merge(left, right): sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid_point = len(arr) // 2 left_half = merge_sort(arr[:mid_point]) right_half = merge_sort(arr[mid_point:]) return merge(left_half, right_half)"},{"question":"def min_path_sum(grid): Computes the minimum sum of a path from the top-left to the bottom-right of the provided grid. You can only move either down or right at any point in time. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 12","solution":"def min_path_sum(grid): Computes the minimum sum of a path from the top-left to the bottom-right of the provided grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the DP table with the same dimensions as grid. dp = [[0] * n for _ in range(m)] # Initialize the starting point. dp[0][0] = grid[0][0] # Fill the first row. for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column. for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the remainder of the grid. for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the minimum path sum. return dp[m-1][n-1]"},{"question":"from typing import List def spell_check(word: str, dictionary: List[str]) -> str: Finds and returns the dictionary word with the smallest edit distance to the input word. Args: word (str): A string representing the misspelled word. dictionary (List[str]): A list of strings representing the dictionary of valid words. Returns: str: A string representing the closest correct spelling from the dictionary based on the smallest edit distance. Examples: >>> spell_check(\\"speling\\", [\\"spelling\\", \\"spelt\\", \\"spell\\"]) == \\"spelling\\" >>> spell_check(\\"a\\", [\\"a\\", \\"b\\", \\"c\\"]) == \\"a\\" >>> spell_check(\\"\\", [\\"a\\", \\"\\"]) == \\"\\" >>> spell_check(\\"word\\", [\\"\\"]) == \\"\\" >>> spell_check(\\"abcd\\", [\\"abdc\\", \\"acbd\\", \\"adbc\\"]) in [\\"abdc\\", \\"acbd\\", \\"adbc\\"] >>> spell_check(\\"SpeLLinG\\", [\\"spelling\\", \\"spellt\\", \\"spell\\"]) == \\"spelling\\" >>> spell_check(\\"abcde\\", [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\", \\"abcdef\\"]) == \\"abcde\\" >>> spell_check(\\"ac\\", [\\"ab\\", \\"bc\\", \\"cd\\"]) in [\\"ab\\", \\"bc\\"] >>> spell_check(\\"word\\", [\\"word\\", \\"ward\\", \\"sword\\"]) == \\"word\\" pass","solution":"from typing import List def edit_distance(word1: str, word2: str) -> int: m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return dp[m][n] def spell_check(word: str, dictionary: List[str]) -> str: closest_word = dictionary[0] min_distance = edit_distance(word, closest_word) for dict_word in dictionary[1:]: current_distance = edit_distance(word, dict_word) if current_distance < min_distance: closest_word = dict_word min_distance = current_distance return closest_word"},{"question":"from typing import List def check_board(board: List[List[str]]) -> str: Evaluates the current state of the tic-tac-toe board. Parameters: board (List[List[str]]): A 3x3 matrix representing the tic-tac-toe board. Returns: str: 'X' if X wins, 'O' if O wins, 'Draw' if it's a draw, 'Ongoing' if the game is still ongoing. >>> board1 = [ ... ['X', 'O', 'X'], ... ['O', 'X', 'O'], ... ['O', 'X', 'X'] ... ] >>> check_board(board1) 'X' >>> board2 = [ ... ['X', 'O', ''], ... ['O', 'O', 'X'], ... ['X', 'X', 'O'] ... ] >>> check_board(board2) 'Ongoing'","solution":"from typing import List def check_board(board: List[List[str]]) -> str: Evaluates the current state of the tic-tac-toe board. Parameters: board (List[List[str]]): A 3x3 matrix representing the tic-tac-toe board. Returns: str: 'X' if X wins, 'O' if O wins, 'Draw' if it's a draw, 'Ongoing' if the game is still ongoing. def check_winner(player): # Check rows and columns for i in range(3): if all(board[i][j] == player for j in range(3)) or all(board[j][i] == player for j in range(3)): return True # Check diagonals if (board[0][0] == player and board[1][1] == player and board[2][2] == player) or (board[0][2] == player and board[1][1] == player and board[2][0] == player): return True return False if check_winner('X'): return 'X' if check_winner('O'): return 'O' if all(all(cell != '' for cell in row) for row in board): return 'Draw' return 'Ongoing'"},{"question":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: Calculate the sum of the matrix's two diagonals. Args: matrix (List[List[int]]): A square 2D list of integers. Returns: int: The sum of the two diagonals (primary and secondary), counting the center only once if it's shared. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> diagonal_sum(matrix) 25 >>> matrix = [ ... [1, 2], ... [4, 5] ... ] >>> diagonal_sum(matrix) 12 >>> matrix = [ ... [1] ... ] >>> diagonal_sum(matrix) 1","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Primary diagonal if i != n - i - 1: total_sum += matrix[i][n - i - 1] # Secondary diagonal return total_sum"},{"question":"class LRUCache: Implement a Simple Cache System with Least Recently Used (LRU) policy. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) >>> cache.get(2) -1 >>> cache.get(3) 3 >>> cache.put(4, 4) >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 >>> cache.current_size() 2 def __init__(self, capacity: int): self.cache = {} self.order = [] self.capacity = capacity def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass def current_size(self) -> int: pass","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.order = [] self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.order.remove(key) self.order.append(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: oldest = self.order.pop(0) del self.cache[oldest] self.cache[key] = value self.order.append(key) def current_size(self) -> int: return len(self.cache)"},{"question":"from typing import List, Optional class SimpleCache: def __init__(self, capacity: int): Initialize the cache with given capacity. pass def put(self, key: int, value: int) -> None: Stores the key-value pair in the cache. If the cache exceeds its capacity, evicts the least recently used item. If the key already exists, updates the value and marks it as most recently used. Args: key: The key to be inserted. value: The value to be associated with the key. pass def get(self, key: int) -> int: Returns the value associated with the key. Marks the key as most recently used. Args: key: The key whose value needs to be retrieved. Returns: The value associated with the key if found, else -1. pass def __str__(self) -> str: Returns the current state of the cache as a formatted string of key-value pairs, ordered from most to least recently used. Returns: A string representation of the cache. pass","solution":"from collections import OrderedDict class SimpleCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value def get(self, key: int) -> int: if key in self.cache: value = self.cache.pop(key) self.cache[key] = value return value return -1 def __str__(self) -> str: return str(list(self.cache.items()))"},{"question":"def generate_report(data): Generates a report with basic statistics of the list \`data\`. Parameters: data (list): A list of integers. Returns: str: A formatted string with basic statistics or \\"Invalid input\\". >>> generate_report([1, 2, 3, 4, 5]) 'Minimum: 1nMaximum: 5nSum: 15nAverage: 3.00nMedian: 3.00' >>> generate_report([10]) 'Minimum: 10nMaximum: 10nSum: 10nAverage: 10.00nMedian: 10.00' >>> generate_report([-1, -2, 0, 1, 2]) 'Minimum: -2nMaximum: 2nSum: 0nAverage: 0.00nMedian: 0.00'","solution":"def generate_report(data): Generates a report with basic statistics of the list \`data\`. Parameters: data (list): A list of integers. Returns: str: A formatted string with basic statistics or \\"Invalid input\\". if not isinstance(data, list) or len(data) == 0 or not all(isinstance(i, int) for i in data): return \\"Invalid input\\" data_sorted = sorted(data) n = len(data) minimum = data_sorted[0] maximum = data_sorted[-1] total_sum = sum(data) average = total_sum / n if n % 2 == 0: median = (data_sorted[n//2 - 1] + data_sorted[n//2]) / 2 else: median = data_sorted[n//2] report = ( f\\"Minimum: {minimum}n\\" f\\"Maximum: {maximum}n\\" f\\"Sum: {total_sum}n\\" f\\"Average: {average:.2f}n\\" f\\"Median: {median:.2f}\\" ) return report"},{"question":"import numpy as np class TemperatureAnalysis: A class for analyzing temperature data collected from various sensors. Parameters: temperatures (array-like): An array of temperature readings. Methods: set_temperature_data: Update the temperature data. mean_temperature: Compute the mean temperature. median_temperature: Compute the median temperature. temperature_anomalies: Compute the temperature anomalies. Examples: >>> temperatures = np.array([25.3, 26.7, 24.1, 23.4, 28.9, 27.1, 30.2], dtype='float32') >>> ta = TemperatureAnalysis(temperatures=temperatures) >>> ta.mean_temperature() 26.52857 >>> ta.median_temperature() 26.7 >>> ta.temperature_anomalies() array([-1.22857, 0.17143, -2.42857, -3.12857, 2.37143, 0.57143, 3.67143]) >>> new_temperatures = np.array([22.1, 21.7, 23.9, 24.3, 26.2], dtype='float32') >>> ta.set_temperature_data(new_temperatures) >>> ta.mean_temperature() 23.64 >>> ta.median_temperature() 23.9 >>> ta.temperature_anomalies() array([-1.54, -1.94, 0.26, 0.66, 2.56]) def __init__(self, temperatures): self.temperatures = np.array(temperatures, dtype='float32') def set_temperature_data(self, temperatures): self.temperatures = np.array(temperatures, dtype='float32') def mean_temperature(self): if len(self.temperatures) == 0: return float('nan') return np.mean(self.temperatures) def median_temperature(self): if len(self.temperatures) == 0: return float('nan') return np.median(self.temperatures) def temperature_anomalies(self): if len(self.temperatures) == 0: return np.array([]) mean = self.mean_temperature() return self.temperatures - mean","solution":"import numpy as np class TemperatureAnalysis: def __init__(self, temperatures): self.temperatures = np.array(temperatures, dtype='float32') def set_temperature_data(self, temperatures): self.temperatures = np.array(temperatures, dtype='float32') def mean_temperature(self): if len(self.temperatures) == 0: return float('nan') return np.mean(self.temperatures) def median_temperature(self): if len(self.temperatures) == 0: return float('nan') return np.median(self.temperatures) def temperature_anomalies(self): if len(self.temperatures) == 0: return np.array([]) mean = self.mean_temperature() return self.temperatures - mean"},{"question":"def longest_common_substring_length(A: str, B: str) -> int: Returns the length of the longest common substring between two given strings. :param A: str - First input string :param B: str - Second input string :return: int - The length of the longest common substring >>> longest_common_substring_length(\\"abcde\\", \\"abfce\\") 2 >>> longest_common_substring_length(\\"geeksforgeeks\\", \\"geeksquiz\\") 5","solution":"def longest_common_substring_length(A: str, B: str) -> int: Returns the length of the longest common substring between two given strings. :param A: str - First input string :param B: str - Second input string :return: int - The length of the longest common substring n = len(A) m = len(B) # Create a 2D array to store lengths of longest common suffixes of substrings # LCSubstr[i][j] contains the length of longest common suffix of A[0...i-1] and B[0...j-1] LCSubstr = [[0] * (m + 1) for i in range(n + 1)] # To store the length of the longest common substring longest_length = 0 # Building the LCSubstr matrix in bottom-up fashion for i in range(1, n + 1): for j in range(1, m + 1): if A[i - 1] == B[j - 1]: LCSubstr[i][j] = LCSubstr[i - 1][j - 1] + 1 longest_length = max(longest_length, LCSubstr[i][j]) else: LCSubstr[i][j] = 0 return longest_length"},{"question":"[Completion Task in Python] Scenario You are developing a word-processing application and need to implement a feature to find and replace a specified word in a given text with another word. This involves creating a function that efficiently processes the text to handle multiple occurrences of the target word and replaces them correctly. Additionally, the function should be capable of handling both case-sensitive and case-insensitive replacements. Requirements 1. **Implementation of a Word Replace Function** - Write a function \`replace_word\` that takes a text string and replaces all occurrences of a target word with a specified replacement word. - Your function should also take a boolean parameter that indicates whether the replacement should be case-sensitive or not. Input - \`text\` (str): The input text in which words need to be replaced. - \`target\` (str): The word to be replaced. - \`replacement\` (str): The word to replace the target word with. - \`case_sensitive\` (bool): A flag to indicate if the replacement should be case-sensitive. Output - str: The modified text with all occurrences of the target word replaced by the replacement word. Constraints - The length of \`text\` will not exceed 5000 characters. - The length of both \`target\` and \`replacement\` will not exceed 100 characters. - The input text may contain punctuation and special characters. Function Signature def replace_word(text: str, target: str, replacement: str, case_sensitive: bool) -> str: pass Sample Input and Output >>> replace_word(\\"Hello World! Hello everyone.\\", \\"Hello\\", \\"Hi\\", True) \\"Hi World! Hi everyone.\\" >>> replace_word(\\"Hello World! Hello everyone.\\", \\"hello\\", \\"Hi\\", False) \\"Hi World! Hi everyone.\\" >>> replace_word(\\"The quick brown fox jumps over the lazy dog. The quick brown fox is quick.\\", \\"quick\\", \\"fast\\", True) \\"The fast brown fox jumps over the lazy dog. The fast brown fox is fast.\\" >>> replace_word(\\"The quick brown fox jumps over the lazy dog. The quick brown fox is quick.\\", \\"FOX\\", \\"wolf\\", False) \\"The quick brown wolf jumps over the lazy dog. The quick brown wolf is quick.\\" Instructions 1. **Replacement Behavior**: Ensure that all occurrences of the target word are replaced correctly. 2. **Case Sensitivity**: Handle both case-sensitive and case-insensitive replacements based on the input flag.","solution":"def replace_word(text: str, target: str, replacement: str, case_sensitive: bool) -> str: Replaces all occurrences of the target word in the input text with the replacement word. Args: - text (str): The input text where replacements should be made. - target (str): The word to be replaced. - replacement (str): The word to replace the target word with. - case_sensitive (bool): Flag to determine if replacement should be case-sensitive. Returns: - str: The modified text with words replaced. if case_sensitive: return text.replace(target, replacement) # Case-insensitive replacement import re text = re.sub(re.escape(target), replacement, text, flags=re.IGNORECASE) return text"},{"question":"from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: Implements Dijkstra's algorithm to find the shortest path from vertex s to all other vertices. Args: n (int): The number of vertices in the graph. edges (List[Tuple[int, int, int]]): The list of edges in the graph, each edge is represented as a tuple (u, v, w). s (int): The starting vertex. Returns: List[int]: The list of shortest distances from the starting vertex to each other vertex. If a vertex is unreachable, its distance should be set to infinity \`float('inf')\`. Examples: >>> dijkstra(5, [(0, 1, 10), (0, 4, 5), (1, 2, 1), (4, 1, 3), (4, 2, 9), (4, 3, 2), (3, 2, 6), (2, 3, 4)], 0) [0, 8, 9, 7, 5] >>> dijkstra(3, [(0, 1, 1), (1, 2, 2), (0, 2, 4)], 0) [0, 1, 3] >>> dijkstra(4, [(0, 1, 1), (1, 2, 2)], 0) [0, 1, 3, float('inf')] >>> dijkstra(1, [], 0) [0] >>> dijkstra(4, [(0, 1, 1), (0, 1, 1), (0, 2, 5), (1, 3, 2)], 0) [0, 1, 5, 3]","solution":"from typing import List, Tuple import heapq def dijkstra(n: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: Implements Dijkstra's algorithm to find the shortest path from vertex s to all other vertices. # Create adjacency list graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) # Distance array, initialize all distances as infinity dist = [float('inf')] * n dist[s] = 0 # Min-heap priority queue to get the vertex with the smallest distance heap = [(0, s)] # (distance, vertex) while heap: current_dist, u = heapq.heappop(heap) # If the popped vertex has a distance greater than the already found smallest distance, # it means we have processed this vertex before with a smaller distance if current_dist > dist[u]: continue # Process each neighbor of current vertex for v, weight in graph[u]: distance = current_dist + weight # If found a shorter path to vertex v, update its distance and push into the heap if distance < dist[v]: dist[v] = distance heapq.heappush(heap, (distance, v)) return dist"},{"question":"def currency_exchange(amount: float, source_currency: str, target_currency: str, exchange_rates: dict) -> float: Converts an amount from source currency to target currency using given exchange rates. Parameters: amount (float): The amount of money in the source currency. source_currency (str): The source currency code. target_currency (str): The target currency code. exchange_rates (dict): A dictionary containing exchange rates. Returns: float: The equivalent amount in the target currency, rounded to two decimal places. >>> currency_exchange(100.0, \\"USD\\", \\"EUR\\", {\\"USD\\": 1.0, \\"EUR\\": 0.85}) 85.00 >>> currency_exchange(50.0, \\"GBP\\", \\"JPY\\", {\\"GBP\\": 1.4, \\"JPY\\": 110.0}) 3928.57","solution":"def currency_exchange(amount: float, source_currency: str, target_currency: str, exchange_rates: dict) -> float: Converts an amount from source currency to target currency using given exchange rates. Parameters: amount (float): The amount of money in the source currency. source_currency (str): The source currency code. target_currency (str): The target currency code. exchange_rates (dict): A dictionary containing exchange rates. Returns: float: The equivalent amount in the target currency, rounded to two decimal places. # Validate inputs if amount < 0: raise ValueError(\\"Amount must be greater than or equal to 0.\\") if source_currency not in exchange_rates or target_currency not in exchange_rates: raise ValueError(\\"Invalid currency code or exchange rate not available.\\") # Convert source amount to base currency using source exchange rate base_currency_amount = amount / exchange_rates[source_currency] # Convert base currency amount to target currency using target exchange rate target_amount = base_currency_amount * exchange_rates[target_currency] # Return the target amount rounded to two decimal places return round(target_amount, 2)"},{"question":"class BST: def find_kth_smallest(self, k: int) -> int: Find the kth smallest element in the binary search tree. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(2) >>> bst.insert(4) >>> bst.insert(6) >>> bst.insert(8) >>> bst.find_kth_smallest(3) 4 >>> bst.find_kth_smallest(1) 2 >>> bst.find_kth_smallest(6) 7","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert(node.right, value) def find_kth_smallest(self, k): def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.value] + in_order_traversal(node.right) in_order = in_order_traversal(self.root) return in_order[k-1]"},{"question":"from typing import List class TaskScheduler: def __init__(self, tasks: List[str], n: int): Initialize the TaskScheduler with a list of tasks and the cooling period \`n\`. pass def leastInterval(self) -> int: Calculate the minimum number of time intervals required to execute all the given tasks with the cooling period constraint. >>> TaskScheduler(['A', 'A', 'A', 'B', 'B', 'B'], 2).leastInterval() 8 >>> TaskScheduler(['A', 'A', 'A', 'B', 'B', 'B'], 0) 6 >>> TaskScheduler(['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'D', 'D'], 2).leastInterval() 10 >>> TaskScheduler(['A'], 2).leastInterval() 1 >>> TaskScheduler(['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C', 'D', 'D', 'E'], 2).leastInterval() 12 pass","solution":"from collections import Counter from typing import List class TaskScheduler: def __init__(self, tasks: List[str], n: int): self.tasks = tasks self.n = n def leastInterval(self) -> int: task_counts = Counter(self.tasks) max_count = max(task_counts.values()) max_count_tasks = list(task_counts.values()).count(max_count) part_count = max_count - 1 part_length = self.n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(self.tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(self.tasks) + idles"},{"question":"def max_tips(orders: list, tips: list, serve_time: list) -> int: Calculate the maximum tips the restaurant can earn based on the constraints. :param orders: List of strings representing unique order IDs. :param tips: List of integers representing the tip amounts. :param serve_time: List of tuples of two integers representing serve times. :return: Maximum tips that can be earned. >>> max_tips([\\"A\\", \\"B\\", \\"C\\"], [100, 200, 150], [(1, 4), (2, 6), (5, 8)]) 300 >>> max_tips([\\"D\\", \\"E\\", \\"F\\"], [500, 100, 250], [(3, 5), (0, 2), (1, 7)]) 500 import pytest def test_single_order(): orders = [\\"A\\"] tips = [100] serve_time = [(1, 4)] assert max_tips(orders, tips, serve_time) == 100 def test_non_overlapping_orders(): orders = [\\"A\\", \\"B\\"] tips = [100, 200] serve_time = [(1, 3), (4, 6)] assert max_tips(orders, tips, serve_time) == 300 def test_overlapping_orders_choose_higher_tip(): orders = [\\"A\\", \\"B\\"] tips = [100, 200] serve_time = [(1, 5), (2, 6)] assert max_tips(orders, tips, serve_time) == 200 def test_overlapping_orders_choose_non_overlapping(): orders = [\\"A\\", \\"B\\", \\"C\\"] tips = [100, 200, 150] serve_time = [(1, 3), (2, 5), (4, 7)] assert max_tips(orders, tips, serve_time) == 250 def test_large_number_of_orders(): orders = [f\\"Order_{i}\\" for i in range(1000)] tips = [i for i in range(1000)] serve_time = [(i, i+1) for i in range(1000)] assert max_tips(orders, tips, serve_time) == 499500 def test_empty_lists(): orders = [] tips = [] serve_time = [] assert max_tips(orders, tips, serve_time) == 0 def test_orders_with_zero_tips(): orders = [\\"A\\", \\"B\\"] tips = [0, 0] serve_time = [(1, 4), (2, 5)] assert max_tips(orders, tips, serve_time) == 0","solution":"def max_tips(orders, tips, serve_time): This function calculates the maximum tips the restaurant can earn based on the constraints of overlapping serve times. :param orders: List of strings representing unique order IDs. :param tips: List of integers representing the tip amounts. :param serve_time: List of tuples of two integers representing serve times. :return: Maximum tips that can be earned. if not orders or not tips or not serve_time: return 0 # Combining the orders' information combined = list(zip(orders, tips, serve_time)) # Sorting orders based on end time for optimal scheduling combined.sort(key=lambda x: x[2][1]) # Initialize dp array where dp[i] represents the maximum tips # we can get from first i orders considering the constraints dp = [0] * len(combined) dp[0] = combined[0][1] for i in range(1, len(combined)): current_tip = combined[i][1] non_conflicting_tip = 0 for j in range(i-1, -1, -1): if combined[j][2][1] <= combined[i][2][0]: non_conflicting_tip = dp[j] break dp[i] = max(dp[i-1], current_tip + non_conflicting_tip) return dp[-1]"},{"question":"class Graph: def __init__(self): self.graph = {} def add_edge(self, v1, v2): if v1 not in self.graph: self.graph[v1] = [] if v2 not in self.graph: self.graph[v2] = [] self.graph[v1].append(v2) self.graph[v2].append(v1) def dfs(self, start: int): Performs a DFS beginning from the start vertex and returns a list of vertices in the order they are visited. >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(3, 4) >>> set(g.dfs(0)) {0, 1, 2} >>> set(g.dfs(3)) {3, 4} def has_path(self, start: int, end: int) -> bool: Checks if there is a path between the start and end vertices using DFS. >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(3, 4) >>> g.has_path(0, 2) True >>> g.has_path(0, 4) False def connected_components(self) -> list[list[int]]: Identifies and returns a list of all connected components in the graph. Each connected component is represented as a list of vertices. >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(3, 4) >>> components = g.connected_components() >>> for component in components: ... component.sort() ... components.sort() ... expected_components = [[0, 1, 2], [3, 4]] ... components == expected_components True","solution":"class Graph: def __init__(self): self.graph = {} def add_edge(self, v1, v2): if v1 not in self.graph: self.graph[v1] = [] if v2 not in self.graph: self.graph[v2] = [] self.graph[v1].append(v2) self.graph[v2].append(v1) def dfs(self, start: int): visited = set() result = [] def dfs_visit(vertex): visited.add(vertex) result.append(vertex) for neighbor in self.graph.get(vertex, []): if neighbor not in visited: dfs_visit(neighbor) dfs_visit(start) return result def has_path(self, start: int, end: int) -> bool: visited = set() def dfs_check(vertex): if vertex == end: return True visited.add(vertex) for neighbor in self.graph.get(vertex, []): if neighbor not in visited: if dfs_check(neighbor): return True return False return dfs_check(start) def connected_components(self) -> list[list[int]]: visited = set() components = [] def dfs_collect(start): component = [] stack = [start] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) component.append(vertex) for neighbor in self.graph.get(vertex, []): if neighbor not in visited: stack.append(neighbor) return component for vertex in self.graph: if vertex not in visited: component = dfs_collect(vertex) components.append(component) return components"},{"question":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class BST: def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: return BSTNode(value) if value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return node def find(self, value): return self._find(self.root, value) def _find(self, node, value): if not node: return False if value == node.value: return True elif value < node.value: return self._find(node.left, value) else: return self._find(node.right, value) def balance(self): self.root = self._balance_tree() def _balance_tree(self): Balances the BST to make it height-balanced, following the AVL tree properties. Re-balancing should be optimized to ensure minimal tree rotations. pass def _get_height(self, node): if not node: return 0 return node.height # Example Usage: bst = BST() bst.insert(10) bst.insert(20) bst.insert(30) bst.insert(40) bst.insert(50) bst.insert(25) bst.balance() assert bst.find(25) == True assert bst.find(60) == False # Unit Tests def test_insert_and_find(): bst = BST() bst.insert(10) bst.insert(20) bst.insert(30) assert bst.find(10) == True assert bst.find(20) == True assert bst.find(30) == True assert bst.find(40) == False def test_balance(): bst = BST() bst.insert(10) bst.insert(20) bst.insert(30) bst.insert(40) bst.insert(50) bst.insert(25) bst.balance() assert bst.find(10) == True assert bst.find(20) == True assert bst.find(30) == True assert bst.find(40) == True assert bst.find(50) == True assert bst.find(25) == True assert bst.find(60) == False def test_balanced_structure(): bst = BST() bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) bst.balance() assert bst.root.value == 50 assert bst.root.left.value == 30 assert bst.root.right.value == 70","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class BST: def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: return BSTNode(value) if value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return node def find(self, value): return self._find(self.root, value) def _find(self, node, value): if not node: return False if value == node.value: return True elif value < node.value: return self._find(node.left, value) else: return self._find(node.right, value) def balance(self): self.root = self._balance_tree() def _balance_tree(self): nodes = [] self._in_order_traversal(self.root, nodes) return self._sorted_array_to_bst(nodes, 0, len(nodes) - 1) def _in_order_traversal(self, node, nodes): if not node: return self._in_order_traversal(node.left, nodes) nodes.append(node.value) self._in_order_traversal(node.right, nodes) def _sorted_array_to_bst(self, arr, start, end): if start > end: return None mid = (start + end) // 2 node = BSTNode(arr[mid]) node.left = self._sorted_array_to_bst(arr, start, mid - 1) node.right = self._sorted_array_to_bst(arr, mid + 1, end) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return node def _get_height(self, node): if not node: return 0 return node.height"},{"question":"import os from collections import defaultdict def file_type_counter(path: str) -> dict: Counts the number of different file types in the given directory and its subdirectories. Args: path (str): The directory path to analyze. Returns: dict: A dictionary with file extensions as keys and their respective counts as values. ... def test_file_type_counter(tmp_path): # Your test case code here ... def test_empty_directory(tmp_path): # Your test case code here ... def test_ignore_directories_without_read_permissions(tmp_path): # Your test case code here ...","solution":"import os from collections import defaultdict def file_type_counter(path): Counts the number of different file types in the given directory and its subdirectories. Args: path (str): The directory path to analyze. Returns: dict: A dictionary with file extensions as keys and their respective counts as values. file_counts = defaultdict(int) for root, _, files in os.walk(path): for file in files: ext = os.path.splitext(file)[1] file_counts[ext] += 1 return dict(file_counts)"},{"question":"from typing import List def find_missing_element(array1: List[int], array2: List[int]) -> int: Finds the missing element from array2 which is a shuffled version of array1 with one element missing. :param array1: List[int] - The original array :param array2: List[int] - The array with one element missing :return: int - The missing element # Implementation here. # Unit tests: def test_find_missing_element_basic(): assert find_missing_element([4, 12, 9, 5], [12, 4, 9]) == 5 assert find_missing_element([1, 2, 3, 4, 5, 6], [2, 3, 1, 5, 6]) == 4 def test_find_missing_element_single_element(): assert find_missing_element([1], []) == 1 def test_find_missing_element_large_numbers(): assert find_missing_element([1000000, 2000000, 3000000, 4000000], [1000000, 3000000, 4000000]) == 2000000 def test_find_missing_element_large_arrays(): large_array1 = list(range(1, 1000001)) large_array2 = list(range(1, 500001)) + list(range(500002, 1000001)) assert find_missing_element(large_array1, large_array2) == 500001 def test_find_missing_element_negative_numbers(): assert find_missing_element([-1, -2, -3, -4, -5, -6], [-2, -3, -1, -5, -6]) == -4","solution":"from typing import List def find_missing_element(array1: List[int], array2: List[int]) -> int: Finds the missing element from array2 which is a shuffled version of array1 with one element missing. :param array1: List[int] - The original array :param array2: List[int] - The array with one element missing :return: int - The missing element # Calculate the sum of elements in both arrays sum_array1 = sum(array1) sum_array2 = sum(array2) # The difference will be the missing element return sum_array1 - sum_array2"},{"question":"def optimized_heap_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the heap sort algorithm. >>> optimized_heap_sort([4, 10, 3, 5, 1]) [1, 3, 4, 5, 10] >>> optimized_heap_sort([0, -10, 20, -20, 10]) [-20, -10, 0, 10, 20] >>> optimized_heap_sort([5]) [5] >>> optimized_heap_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> optimized_heap_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> optimized_heap_sort([7, 7, 7, 7, 7]) [7, 7, 7, 7, 7] >>> optimized_heap_sort([]) [] >>> optimized_heap_sort([-2, -1, 0, 1, 2, -1, -2, 2]) [-2, -2, -1, -1, 0, 1, 2, 2] pass","solution":"def optimized_heap_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the heap sort algorithm. def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) if n == 0: return [] copied_arr = arr[:] # Copy the original array to not modify it # Build a maxheap for i in range(n//2 - 1, -1, -1): heapify(copied_arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): copied_arr[i], copied_arr[0] = copied_arr[0], copied_arr[i] # swap heapify(copied_arr, i, 0) return copied_arr"},{"question":"from typing import List, Tuple, Dict class Vertex: def __init__(self, id: int): self.id = id self.neighbors = [] def dijkstra(graph: List[Vertex], source: Vertex) -> Dict[int, int]: Implement Dijkstra's algorithm to find the shortest path from a given source vertex to all other vertices. Args: graph (List[Vertex]): A list of Vertex objects representing the graph. source (Vertex): The starting vertex for Dijkstra's algorithm. Returns: Dict[int, int]: A dictionary where the keys are vertex IDs and the values are the shortest path distances from the source vertex. >>> vertices = [Vertex(i) for i in range(3)] >>> vertices[0].neighbors = [(1, 1), (2, 4)] >>> vertices[1].neighbors = [(2, 2)] >>> vertices[2].neighbors = [] >>> dijkstra(vertices, vertices[0]) {0: 0, 1: 1, 2: 3} >>> vertices = [Vertex(i) for i in range(1)] >>> vertices[0].neighbors = [] >>> dijkstra(vertices, vertices[0]) {0: 0}","solution":"from typing import List, Tuple, Dict import heapq import sys class Vertex: def __init__(self, id: int): self.id = id self.neighbors = [] def dijkstra(graph: List[Vertex], source: Vertex) -> Dict[int, int]: dist = {vertex.id: sys.maxsize for vertex in graph} dist[source.id] = 0 priority_queue = [(0, source.id)] heapq.heapify(priority_queue) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for neighbor_id, weight in graph[u].neighbors: distance_through_u = current_dist + weight if distance_through_u < dist[neighbor_id]: dist[neighbor_id] = distance_through_u heapq.heappush(priority_queue, (distance_through_u, neighbor_id)) return dist"},{"question":"def most_frequent_word(paragraph: str, banned_words: list[str]) -> str: Implement a function that returns the most frequent word in the paragraph that is not in the banned words. The word returned should be in lowercase. >>> most_frequent_word(\\"This is a test. This test is only a test.\\", [\\"is\\", \\"a\\"]) \\"test\\" >>> most_frequent_word(\\"Bob hit a ball, the hit BALL flew far after it was hit.\\", [\\"hit\\"]) \\"ball\\" >>> most_frequent_word(\\"It is sunny out there. It's really sunny and warm.\\", [\\"is\\", \\"it\\", \\"and\\", \\"sunny\\"]) \\"out\\" >>> most_frequent_word(\\"The quick brown fox jumps over the lazy dog. The quick brown fox is quick.\\", [\\"the\\", \\"fox\\", \\"is\\"]) \\"quick\\"","solution":"import re from collections import Counter def most_frequent_word(paragraph: str, banned_words: list[str]) -> str: # Normalize the paragraph: replace punctuations by spaces and convert to lowercase normalized_paragraph = re.sub(r'[^ws]', ' ', paragraph).lower() # Split the paragraph into words words = normalized_paragraph.split() # Create a set of banned words for fast lookup banned_set = set(banned_words) # Filter out the banned words and count the frequency of the remaining words word_counts = Counter(word for word in words if word not in banned_set) # Find the word with the highest frequency most_common_word = word_counts.most_common(1)[0][0] return most_common_word"},{"question":"def check_permission(permission_str: str, user_type: str, required_permission: str) -> bool: Verifies whether a file has the specified set of permissions for a given user. Args: permission_str (str): A string representing the file permissions (e.g., '-rwxr-xr--'). user_type (str): A string indicating the user type (\`'owner'\`, \`'group'\`, \`'others'\`). required_permission (str): A string representing the permissions to check (e.g., 'rwx'). Returns: bool: True if the specified user has all of the required permissions, otherwise False. Raises: ValueError: If the permission string length is invalid, if the user type is invalid, or if the required permission contains invalid characters. >>> check_permission('-rwxr-xr--', 'owner', 'rwx') True >>> check_permission('-rwxr-xr--', 'group', 'rwx') False >>> check_permission('-rwxr-xr--', 'group', 'rx') True >>> check_permission('-rw-r--r--', 'others', 'r') True >>> check_permission('-rw-r--r--', 'others', 'x') False >>> check_permission('-rw-r--r--', 'admin', 'r') Traceback (most recent call last): ... ValueError: Invalid user type ...","solution":"def check_permission(permission_str: str, user_type: str, required_permission: str) -> bool: if len(permission_str) != 10: raise ValueError(\\"Invalid permission string length\\") user_index_map = { 'owner': 1, 'group': 4, 'others': 7 } if user_type not in user_index_map: raise ValueError(\\"Invalid user type\\") if any(x not in \\"rwx\\" for x in required_permission): raise ValueError(\\"Invalid required permission characters\\") start_idx = user_index_map[user_type] permission_slice = permission_str[start_idx:start_idx+3] return all(permission in permission_slice for permission in required_permission)"},{"question":"import numpy as np def find_max_length(nums: np.ndarray) -> int: Find the length of the longest contiguous subarray with an equal number of 0s and 1s. >>> find_max_length(np.array([0, 1, 0])) 2 >>> find_max_length(np.array([0, 1, 0, 1, 1, 0, 0])) 6 >>> find_max_length(np.array([0, 0, 0, 0])) 0 >>> find_max_length(np.array([1, 1, 1, 1])) 0 >>> find_max_length(np.array([0, 1, 1, 0, 0, 1, 1])) 6 >>> find_max_length(np.array([0])) 0 >>> find_max_length(np.array([1])) 0 >>> find_max_length(np.array([0, 1])) 2 >>> find_max_length(np.array([1, 0])) 2 >>> find_max_length(np.array([0, 0])) 0 >>> find_max_length(np.array([1, 1])) 0 pass","solution":"import numpy as np def find_max_length(nums: np.ndarray) -> int: max_length = 0 cumulative_sum = 0 sum_to_index = {0: -1} # Initialize with 0 sum at index -1 to handle full array case for i in range(len(nums)): if nums[i] == 0: cumulative_sum -= 1 else: cumulative_sum += 1 if cumulative_sum in sum_to_index: length = i - sum_to_index[cumulative_sum] max_length = max(max_length, length) else: sum_to_index[cumulative_sum] = i return max_length"},{"question":"from typing import List def update_inventory(books: List[str], requests: List[str]) -> List[str]: Updates the list of books by removing those that have been requested and are available in the inventory. :param books: List of strings representing the titles of books currently available in the library. :param requests: List of strings representing the titles of books being issued. :return: List of strings representing the titles of books that remain available in the library. >>> update_inventory( ... [\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\"], ... [\\"1984\\", \\"Pride and Prejudice\\", \\"Moby Dick\\"] ... ) [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] >>> update_inventory( ... [\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\"], ... [\\"Moby Dick\\", \\"War and Peace\\"] ... ) [\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\"]","solution":"from typing import List def update_inventory(books: List[str], requests: List[str]) -> List[str]: Updates the list of books by removing those that have been requested and are available in the inventory. :param books: List of strings representing the titles of books currently available in the library. :param requests: List of strings representing the titles of books being issued. :return: List of strings representing the titles of books that remain available in the library. # Convert the list of requests into a set for O(1) membership checks requested_set = set(requests) # Filter out books that are requested updated_books = [book for book in books if book not in requested_set] return updated_books"},{"question":"def length_of_lis(n: int, arr: List[int]) -> int: Find the length of the longest increasing subsequence. >>> length_of_lis(8, [10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis(1, [10]) 1 >>> length_of_lis(0, []) 0 >>> length_of_lis(5, [1, 2, 3, 4, 5]) 5 >>> length_of_lis(5, [5, 4, 3, 2, 1]) 1 >>> length_of_lis(7, [1, 3, 2, 4, 3, 5, 4]) 4 >>> length_of_lis(7, [1, 2, 2, 2, 3, 4, 4]) 4 >>> length_of_lis(10, [1, 11, 2, 10, 3, 9, 4, 8, 5, 7, 6]) 6","solution":"from typing import List def length_of_lis(n: int, arr: List[int]) -> int: if n == 0: return 0 # Initialize a list to store the length of the longest increasing subsequence ending at each position lis = [1] * n # Build the lis array for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest increasing subsequence will be the maximum value in the lis array return max(lis)"},{"question":"from typing import List def flood_fill(grid: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: Perform a flood fill on a 2D grid starting from a given cell. Args: grid (List[List[int]]): The 2D grid of integers representing colors. sr (int): The starting row index. sc (int): The starting column index. new_color (int): The new color to apply. Returns: List[List[int]]: The grid after performing the flood fill. Example: >>> grid = [ ... [1, 1, 1], ... [1, 1, 0], ... [1, 0, 1] ... ] >>> flood_fill(grid, 1, 1, 2) [ [2, 2, 2], [2, 2, 0], [2, 0, 1] ] pass import pytest def test_flood_fill_basic(): grid = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] expected = [ [2, 2, 2], [2, 2, 0], [2, 0, 1] ] assert flood_fill(grid, 1, 1, 2) == expected def test_flood_fill_already_same_color(): grid = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] expected = grid.copy() assert flood_fill(grid, 0, 0, 1) == expected def test_flood_fill_different_color(): grid = [ [0, 0, 0], [0, 1, 1] ] expected = [ [2, 2, 2], [2, 1, 1] ] assert flood_fill(grid, 0, 0, 2) == expected def test_flood_fill_single_element(): grid = [ [0] ] expected = [ [2] ] assert flood_fill(grid, 0, 0, 2) == expected def test_flood_fill_no_change_needed(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = grid.copy() assert flood_fill(grid, 1, 1, 5) == expected","solution":"from typing import List def flood_fill(grid: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: original_color = grid[sr][sc] if original_color == new_color: return grid def fill(r, c): if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]): return if grid[r][c] != original_color: return grid[r][c] = new_color # Move in all four possible directions fill(r + 1, c) fill(r - 1, c) fill(r, c + 1) fill(r, c - 1) fill(sr, sc) return grid"},{"question":"def max_subarray_with_indices(nums: list[int]) -> tuple[int, int, int]: Finds a contiguous subarray with the largest sum and returns the sum along with the start and end indices. >>> max_subarray_with_indices([-2,1,-3,4,-1,2,1,-5,4]) (6, 3, 6) >>> max_subarray_with_indices([1,2,3,4,-10,5,6,7,8]) (26, 0, 8)","solution":"def max_subarray_with_indices(nums): Finds the subarray with the maximum sum and returns the sum along with the start and end indices. :param nums: List of integers :return: A tuple containing (max_sum, start_index, end_index) if not nums: raise ValueError(\\"The array should not be empty\\") max_sum = nums[0] current_sum = nums[0] start_index = 0 end_index = 0 temp_start = 0 for i in range(1, len(nums)): if nums[i] > current_sum + nums[i]: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start_index = temp_start end_index = i return max_sum, start_index, end_index"},{"question":"from typing import List, Tuple def count_user_groups(friendships: List[Tuple[int, int]], n: int) -> int: Determine the number of distinct user groups (connected components) in the given graph. Args: friendships (List[Tuple[int, int]]): A list of tuples representing friendships. n (int): The total number of users. Returns: int: The number of distinct user groups. Example: >>> count_user_groups([(0, 1), (1, 2), (3, 4)], 5) 3","solution":"from typing import List, Tuple def count_user_groups(friendships: List[Tuple[int, int]], n: int) -> int: def dfs(node: int): for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True dfs(neighbor) adj_list = [[] for _ in range(n)] visited = [False] * n for u, v in friendships: adj_list[u].append(v) adj_list[v].append(u) num_groups = 0 for user in range(n): if not visited[user]: num_groups += 1 visited[user] = True dfs(user) return num_groups"},{"question":"def prime_factors(n: int) -> list[int]: Returns the list of prime factors of the given integer n. Raises ValueError if the input is not a positive integer greater than 1. >>> prime_factors(56) [2, 2, 2, 7] >>> prime_factors(37) [37] >>> prime_factors(100) [2, 2, 5, 5] >>> prime_factors(84) [2, 2, 3, 7] >>> prime_factors(1) Traceback (most recent call last): ... ValueError: Expected int greater than 1 >>> prime_factors(-10) Traceback (most recent call last): ... ValueError: Expected a positive int greater than 1 # Your code here","solution":"def prime_factors(n: int) -> list[int]: Returns the list of prime factors of the given integer n. Raises ValueError if the input is not a positive integer greater than 1. if n <= 1: raise ValueError(\\"Expected int greater than 1\\") factors = [] # Start dividing by the smallest prime number, 2 divisor = 2 while n > 1: while n % divisor == 0: factors.append(divisor) n //= divisor divisor += 1 return factors"},{"question":"def scalable_matrix_multiply(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: Computes the product of two matrices, optimized for large matrices. Args: - matrix1 (list[list[int]]): First matrix of size m x n. - matrix2 (list[list[int]]): Second matrix of size n x p. Returns: - result (list[list[int]]): The product of matrix1 and matrix2, of size m x p. Example: >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... ] >>> matrix2 = [ ... [7, 8], ... [9, 10], ... [11, 12], ... ] >>> scalable_matrix_multiply(matrix1, matrix2) [[58, 64], [139, 154]] Unit Test: from solution import scalable_matrix_multiply def test_small_matrices(): matrix1 = [ [1, 2], [3, 4], ] matrix2 = [ [2, 0], [1, 2], ] expected = [ [4, 4], [10, 8], ] assert scalable_matrix_multiply(matrix1, matrix2) == expected def test_rectangular_matrices(): matrix1 = [ [1, 2, 3], [4, 5, 6], ] matrix2 = [ [7, 8], [9, 10], [11, 12], ] expected = [ [58, 64], [139, 154], ] assert scalable_matrix_multiply(matrix1, matrix2) == expected def test_large_square_matrices(): size = 1000 matrix1 = [[1] * size for _ in range(size)] matrix2 = [[1] * size for _ in range(size)] expected = [[1000] * size for _ in range(size)] assert scalable_matrix_multiply(matrix1, matrix2) == expected def test_identity_matrix(): matrix1 = [ [1, 0, 0], [0, 1, 0], [0, 0, 1], ] matrix2 = [ [5, 6, 7], [8, 9, 10], [11, 12, 13], ] expected = matrix2 # multiplying by identity matrix returns the other matrix assert scalable_matrix_multiply(matrix1, matrix2) == expected","solution":"import numpy as np def scalable_matrix_multiply(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: Multiplies two matrices using numpy for efficient computation. Args: - matrix1 (list[list[int]]): First matrix of size m x n. - matrix2 (list[list[int]]): Second matrix of size n x p. Returns: - result (list[list[int]]): The product of matrix1 and matrix2, of size m x p. # Convert lists to numpy arrays for efficient computation np_matrix1 = np.array(matrix1) np_matrix2 = np.array(matrix2) # Perform matrix multiplication using numpy np_result = np.dot(np_matrix1, np_matrix2) # Convert numpy array result back to regular list before returning return np_result.tolist()"},{"question":"def find_unique_element(nums: list[int]) -> int: Returns the integer that appears exactly once in the list. All other integers in the list appear exactly twice. >>> find_unique_element([2, 3, 2, 4, 4, 3, 5]) == 5 >>> find_unique_element([-1, -1, 2, 2, 3]) == 3 >>> find_unique_element([1, 3, 4, 4, 3, 5, 5]) == 1 >>> find_unique_element([1000, -1000, 1000]) == -1000 >>> find_unique_element([7]) == 7 # Implement this function pass","solution":"def find_unique_element(nums: list[int]) -> int: Returns the integer that appears exactly once in the list. All other integers in the list appear exactly twice. unique_number = 0 # XOR all numbers, pairs of similar numbers will cancel out each other for num in nums: unique_number ^= num return unique_number"},{"question":"def longest_common_suffix(strings: List[str]) -> str: Find the longest common suffix among a list of strings. >>> longest_common_suffix([\\"processing\\", \\"sing\\", \\"wing\\"]) \\"ing\\" >>> longest_common_suffix([\\"apple\\", \\"banana\\", \\"grape\\"]) \\"\\"","solution":"from typing import List def longest_common_suffix(strings: List[str]) -> str: if not strings: return \\"\\" # Reverse all strings to find the longest common prefix instead reversed_strings = [s[::-1] for s in strings] # Find the longest common prefix of the reversed strings def longest_common_prefix(strings: List[str]) -> str: if not strings: return \\"\\" # Take the first string as the initial prefix prefix = strings[0] for s in strings[1:]: # Gradually reduce the prefix length until it fits the current string while not s.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix common_prefix_reversed = longest_common_prefix(reversed_strings) # Reverse the result to get the common suffix return common_prefix_reversed[::-1]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_path(root: TreeNode, target: int) -> list[int]: Find the path from the root of the binary tree to a node whose value matches the target. Each node in the binary tree has a unique integer value. :param root: The root node of the binary tree. :param target: An integer value representing the target node's value. :return: The path from the root to the target node as a list of integers. If the target value does not exist in the tree, return an empty list. >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> find_path(root, 6) [5, 7, 6] >>> find_path(root, 4) []","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_path(root: TreeNode, target: int) -> list[int]: def helper(node, path): if not node: return False path.append(node.val) if node.val == target: return True if (helper(node.left, path) or helper(node.right, path)): return True path.pop() return False result = [] if root: helper(root, result) return result"},{"question":"def sequence_sum(n: int) -> int: Computes the nth term of the specified sequence and returns the sum of all terms in the sequence up to and including the nth term. >>> sequence_sum(0) 1 >>> sequence_sum(1) 2 >>> sequence_sum(2) 4 >>> sequence_sum(3) 8 >>> sequence_sum(4) 16 pass def test_sequence_sum_0(): assert sequence_sum(0) == 1 def test_sequence_sum_1(): assert sequence_sum(1) == 2 def test_sequence_sum_2(): assert sequence_sum(2) == 4 def test_sequence_sum_3(): assert sequence_sum(3) == 8 def test_sequence_sum_4(): assert sequence_sum(4) == 16 def test_sequence_sum_5(): assert sequence_sum(5) == 32 def test_sequence_sum_10(): assert sequence_sum(10) == 1024 def test_sequence_sum_15(): assert sequence_sum(15) == 32768 def test_sequence_sum_30(): assert sequence_sum(30) == 1073741824","solution":"def sequence_sum(n: int) -> int: Computes the nth term of the specified sequence and returns the sum of all terms in the sequence up to and including the nth term. if n == 0: return 1 if n == 1: return 2 # Sequence cache to store already computed terms sequence = [1, 1] for i in range(2, n + 1): next_term = sum(sequence) sequence.append(next_term) return sum(sequence)"},{"question":"def calculate_bell_number(n: int) -> int: Computes the Bell number B(n) for a given integer n using Bell's triangle. Args: n (int): The order of the Bell number Returns: int: The Bell number B(n) Examples: >>> calculate_bell_number(0) == 1 >>> calculate_bell_number(1) == 1 >>> calculate_bell_number(2) == 2 >>> calculate_bell_number(3) == 5 >>> calculate_bell_number(4) == 15 def test_calculate_bell_number_base_cases(): assert calculate_bell_number(0) == 1 assert calculate_bell_number(1) == 1 def test_calculate_bell_number_small_values(): assert calculate_bell_number(2) == 2 assert calculate_bell_number(3) == 5 assert calculate_bell_number(4) == 15 assert calculate_bell_number(5) == 52 def test_calculate_bell_number_larger_values(): assert calculate_bell_number(6) == 203 assert calculate_bell_number(7) == 877 assert calculate_bell_number(8) == 4140 assert calculate_bell_number(9) == 21147 assert calculate_bell_number(10) == 115975 def test_calculate_bell_number_higher(): assert calculate_bell_number(15) == 1382958545 assert calculate_bell_number(20) == 51724158235372","solution":"def calculate_bell_number(n: int) -> int: Returns the Bell number B(n). Bell numbers are calculated using Bell's triangle (Aitken's array). bell = [[0 for _ in range(n+1)] for _ in range(n+1)] bell[0][0] = 1 for i in range(1, n+1): # Start of each row in Bell triangle bell[i][0] = bell[i-1][i-1] for j in range(1, i+1): bell[i][j] = bell[i-1][j-1] + bell[i][j-1] return bell[n][0]"},{"question":"from datetime import datetime from dateutil.relativedelta import relativedelta def calculate_ages(people: list[str], reference_date: str) -> list[str]: Calculate each person's exact age in years, months, and days as of a given reference date. >>> calculate_ages([\\"Alice Smith, 1985-10-30\\", \\"Bob Johnson, 1992-04-20\\"], \\"2023-09-11\\") [\\"Alice Smith: 37 years, 10 months, 12 days\\", \\"Bob Johnson: 31 years, 4 months, 22 days\\"] >>> calculate_ages([\\"John Doe, 2000-01-01\\"], \\"2023-09-11\\") [\\"John Doe: 23 years, 8 months, 10 days\\"] >>> calculate_ages([\\"Jane Doe, 1995-12-31\\"], \\"2023-01-01\\") [\\"Jane Doe: 27 years, 0 months, 1 days\\"] >>> calculate_ages([\\"Chris P, 1988-02-29\\"], \\"2024-02-29\\") [\\"Chris P: 36 years, 0 months, 0 days\\"] >>> calculate_ages([\\"Alex Q, 2010-06-15\\"], \\"2021-06-14\\") [\\"Alex Q: 10 years, 11 months, 30 days\\"] pass","solution":"from datetime import datetime from dateutil.relativedelta import relativedelta def calculate_ages(people, reference_date): reference_date = datetime.strptime(reference_date, \\"%Y-%m-%d\\") ages = [] for person in people: name, birthdate = person.split(', ') birthdate = datetime.strptime(birthdate, \\"%Y-%m-%d\\") age_delta = relativedelta(reference_date, birthdate) age_str = f\\"{name}: {age_delta.years} years, {age_delta.months} months, {age_delta.days} days\\" ages.append(age_str) return ages"},{"question":"def permute(nums): Returns all unique permutations of the list of distinct numbers. return [list(p) for p in permutations(nums)] # Example usage input_list = [1, 2, 3] output = permute(input_list) print(output) # Expected Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]","solution":"from itertools import permutations def permute(nums): Returns all unique permutations of the list of distinct numbers. return [list(p) for p in permutations(nums)] # Example usage input_list = [1, 2, 3] output = permute(input_list) print(output) # Expected Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"},{"question":"from typing import List, Tuple def count_frequency(nums: List[int]) -> List[Tuple[int, int]]: Count the frequency of each number in a list and return a list of tuples sorted by the frequency of numbers in descending order. If two numbers have the same frequency, they should be sorted in ascending order by the number value. >>> count_frequency([1, 1, 2, 2, 2, 3]) [(2, 3), (1, 2), (3, 1)] >>> count_frequency([4, 4, 1, 2, 2, 3, 3, 3, 3]) [(3, 4), (2, 2), (4, 2), (1, 1)] >>> count_frequency([]) [] >>> count_frequency([1, 2, 3, 4, 5]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]","solution":"from typing import List, Tuple from collections import Counter def count_frequency(nums: List[int]) -> List[Tuple[int, int]]: Count the frequency of each number in the list and return a list of tuples sorted by frequency in descending order, and by number in ascending order for ties. # Count the frequency using Counter frequency_counter = Counter(nums) # Create a list of tuples (number, frequency) frequency_list = [(num, freq) for num, freq in frequency_counter.items()] # Sort the list by frequency in descending order, and by number in ascending order for ties frequency_list.sort(key=lambda x: (-x[1], x[0])) return frequency_list"},{"question":"import numpy as np class MultiTaskLogisticRegression: def __init__(self, num_tasks: int, num_features: int, lr: float = 0.01, epochs: int = 1000): Initialize the multi-task logistic regression model. :param num_tasks: Integer, number of classification tasks. :param num_features: Integer, number of features in the input data. :param lr: Float, learning rate for the optimization. :param epochs: Integer, number of epochs for the training process. def _sigmoid(self, z: np.ndarray) -> np.ndarray: Apply the sigmoid function. def _loss(self, y_true: np.ndarray, y_pred: np.ndarray) -> float: Calculate the loss using cross-entropy. def _train_task(self, X: np.ndarray, y: np.ndarray, W: np.ndarray, b: float) -> (np.ndarray, float): Train a single task and update weights and bias. def fit(self, X_list: [np.ndarray], y_list: [np.ndarray]): Train the multi-task logistic regression model. :param X_list: List of numpy arrays. Each array is of shape (m, n) with m samples and n features. :param y_list: List of numpy arrays. Each array is of shape (m,) with the class labels for each task. def predict(self, X: np.ndarray) -> [np.ndarray]: Predict the class labels for the given input data. :param X: Numpy array of shape (m, n) with the input data. :return: List of numpy arrays. Each array is of shape (m,) with the predicted class labels for each task. # Example usage: # Assuming X_list and y_list are pre-defined data for multiple tasks num_tasks = len(X_list) num_features = X_list[0].shape[1] model = MultiTaskLogisticRegression(num_tasks, num_features, lr=0.01, epochs=1000) model.fit(X_list, y_list) predictions = model.predict(X_list[0]) accuracy = np.mean(predictions[0] == y_list[0]) print(f\\"Accuracy for task 1: {accuracy * 100:.2f}%\\")","solution":"import numpy as np class MultiTaskLogisticRegression: def __init__(self, num_tasks: int, num_features: int, lr: float = 0.01, epochs: int = 1000): Initialize the multi-task logistic regression model. :param num_tasks: Integer, number of classification tasks. :param num_features: Integer, number of features in the input data. :param lr: Float, learning rate for the optimization. :param epochs: Integer, number of epochs for the training process. self.num_tasks = num_tasks self.num_features = num_features self.lr = lr self.epochs = epochs # Initialize weights and biases for each task self.W = [np.zeros(num_features) for _ in range(num_tasks)] self.b = [0.0 for _ in range(num_tasks)] def _sigmoid(self, z: np.ndarray) -> np.ndarray: Apply the sigmoid function. return 1 / (1 + np.exp(-z)) def _loss(self, y_true: np.ndarray, y_pred: np.ndarray) -> float: Calculate the loss using cross-entropy. m = y_true.shape[0] return -1/m * np.sum(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred)) def _train_task(self, X: np.ndarray, y: np.ndarray, W: np.ndarray, b: float) -> (np.ndarray, float): Train a single task and update weights and bias. m = X.shape[0] for _ in range(self.epochs): z = np.dot(X, W) + b a = self._sigmoid(z) dz = a - y dW = 1/m * np.dot(X.T, dz) db = 1/m * np.sum(dz) W -= self.lr * dW b -= self.lr * db return W, b def fit(self, X_list: [np.ndarray], y_list: [np.ndarray]): Train the multi-task logistic regression model. :param X_list: List of numpy arrays. Each array is of shape (m, n) with m samples and n features. :param y_list: List of numpy arrays. Each array is of shape (m,) with the class labels for each task. for task in range(self.num_tasks): self.W[task], self.b[task] = self._train_task(X_list[task], y_list[task], self.W[task], self.b[task]) def predict(self, X: np.ndarray) -> [np.ndarray]: Predict the class labels for the given input data. :param X: Numpy array of shape (m, n) with the input data. :return: List of numpy arrays. Each array is of shape (m,) with the predicted class labels for each task. predictions = [] for task in range(self.num_tasks): z = np.dot(X, self.W[task]) + self.b[task] a = self._sigmoid(z) predictions.append((a >= 0.5).astype(int)) return predictions"},{"question":"def reverse_string_iterative(s: str) -> str: Reverses a string using an iterative approach. >>> reverse_string_iterative(\\"hello\\") \\"olleh\\" >>> reverse_string_iterative(\\"Python\\") \\"nohtyP\\" >>> reverse_string_iterative(\\"A\\") \\"A\\" >>> reverse_string_iterative(\\"\\") \\"\\" >>> reverse_string_iterative(\\"12345\\") \\"54321\\" def reverse_string_recursive(s: str) -> str: Reverses a string using a recursive approach. >>> reverse_string_recursive(\\"hello\\") \\"olleh\\" >>> reverse_string_recursive(\\"Python\\") \\"nohtyP\\" >>> reverse_string_recursive(\\"A\\") \\"A\\" >>> reverse_string_recursive(\\"\\") \\"\\" >>> reverse_string_recursive(\\"12345\\") \\"54321\\"","solution":"def reverse_string_iterative(s: str) -> str: Reverses a string using an iterative approach. return s[::-1] def reverse_string_recursive(s: str) -> str: Reverses a string using a recursive approach. if len(s) <= 1: return s return s[-1] + reverse_string_recursive(s[:-1])"},{"question":"def temperature_differences(temperatures: list) -> list: Calculate the temperature difference between each successive day. >>> temperature_differences([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, -4, -2, 3, 4, -3] >>> temperature_differences([59, 57, 60, 64, 65]) [-2, 3, 4, 1] >>> temperature_differences([30, 30, 30]) [0, 0]","solution":"def temperature_differences(temperatures: list) -> list: Returns a list of integers where each integer represents the difference in temperature from one day to the next. return [temperatures[i+1] - temperatures[i] for i in range(len(temperatures) - 1)]"},{"question":"import requests from datetime import datetime, timedelta class StockTracker: A class to track real-time stock prices and their highest and lowest prices in the last 24 hours. Methods ------- __init__(self, tickers: list[str]) -> None Initializes the tracker with a list of company tickers. update_price(self) -> None Fetches the latest price for each ticker and updates the highest and lowest prices for the last 24 hours. get_current_price(self, ticker: str) -> float Returns the current price of the specified ticker. get_highest_price(self, ticker: str) -> float Returns the highest price of the specified ticker in the last 24 hours. get_lowest_price(self, ticker: str) -> float Returns the lowest price of the specified ticker in the last 24 hours. Example usage: >>> tracker = StockTracker([\\"AAPL\\", \\"GOOGL\\", \\"AMZN\\"]) >>> tracker.update_price() >>> print(tracker.get_current_price(\\"AAPL\\")) >>> print(tracker.get_highest_price(\\"GOOGL\\")) >>> print(tracker.get_lowest_price(\\"AMZN\\")) def __init__(self, tickers: list[str]) -> None: Initializes the tracker with a list of company tickers. pass def update_price(self) -> None: Fetches the latest price for each ticker and updates the highest and lowest prices for the last 24 hours. pass def get_current_price(self, ticker: str) -> float: Returns the current price of the specified ticker. pass def get_highest_price(self, ticker: str) -> float: Returns the highest price of the specified ticker in the last 24 hours. pass def get_lowest_price(self, ticker: str) -> float: Returns the lowest price of the specified ticker in the last 24 hours. pass","solution":"import requests from datetime import datetime, timedelta class StockTracker: def __init__(self, tickers): self.tickers = tickers self.stock_data = {} for ticker in tickers: self.stock_data[ticker] = { \\"current_price\\": None, \\"high_24h\\": float('-inf'), \\"low_24h\\": float('inf'), \\"history\\": [] } def update_price(self): for ticker in self.tickers: try: response = requests.get(f\\"https://api.finance.com/stock?ticker={ticker}\\") response.raise_for_status() data = response.json() current_price = data['price'] timestamp = datetime.utcnow() self.stock_data[ticker]['current_price'] = current_price self.stock_data[ticker]['history'].append((timestamp, current_price)) # Clean up history to only keep entries from the past 24 hours cutoff = timestamp - timedelta(hours=24) self.stock_data[ticker]['history'] = [(time, price) for (time, price) in self.stock_data[ticker]['history'] if time > cutoff] # Update high and low prices over the last 24 hours prices_last_24h = [price for time, price in self.stock_data[ticker]['history']] if prices_last_24h: self.stock_data[ticker]['high_24h'] = max(prices_last_24h) self.stock_data[ticker]['low_24h'] = min(prices_last_24h) except requests.RequestException as e: print(f\\"Error fetching data for {ticker}: {e}\\") def get_current_price(self, ticker): return self.stock_data[ticker]['current_price'] if ticker in self.stock_data else None def get_highest_price(self, ticker): return self.stock_data[ticker]['high_24h'] if ticker in self.stock_data else None def get_lowest_price(self, ticker): return self.stock_data[ticker]['low_24h'] if ticker in self.stock_data else None"},{"question":"from typing import List, Tuple, Dict def update_inventory(products: List[Tuple[str, int]]) -> Dict[str, int]: Update the product inventory based on the list of products and their quantities. Args: products (List[Tuple[str, int]]): A list of tuples where each tuple contains a product name and its quantity. Returns: dict: A dictionary with product names as keys and their corresponding total quantities as values. Examples: >>> update_inventory([(\\"apple\\", 10), (\\"banana\\", 5), (\\"apple\\", 3), (\\"orange\\", 7)]) {'apple': 13, 'banana': 5, 'orange': 7} >>> update_inventory([(\\"notebook\\", 2), (\\"pen\\", 15), (\\"notebook\\", 3)]) {'notebook': 5, 'pen': 15} >>> update_inventory([]) {}","solution":"def update_inventory(products): Update the product inventory based on the list of products and their quantities. Args: products (List[Tuple[str, int]]): A list of tuples where each tuple contains a product name and its quantity. Returns: dict: A dictionary with product names as keys and their corresponding total quantities as values. inventory = {} for product, quantity in products: if product in inventory: inventory[product] += quantity else: inventory[product] = quantity return inventory"},{"question":"from typing import List def max_subset_sum(weights: List[int], max_capacity: int) -> int: Determines the maximum sum of weights that is less than or equal to max_capacity. Args: weights (List[int]): A list of unique integers representing the weights of items. max_capacity (int): An integer representing the maximum capacity of the knapsack. Returns: int: The maximum sum of weights that is less than or equal to max_capacity. Examples: >>> max_subset_sum([1, 3, 4, 5, 9], 10) 10 >>> max_subset_sum([], 10) 0 >>> max_subset_sum([5], 10) 5 >>> max_subset_sum([15], 10) 0","solution":"from itertools import combinations from typing import List def max_subset_sum(weights: List[int], max_capacity: int) -> int: Determines the maximum sum of weights that is less than or equal to max_capacity. max_sum = 0 n = len(weights) # Generate all subsets and calculate their sums for r in range(n + 1): for subset in combinations(weights, r): current_sum = sum(subset) if current_sum <= max_capacity: max_sum = max(max_sum, current_sum) return max_sum # Example usage weights = [1, 3, 4, 5, 9] max_capacity = 10 print(max_subset_sum(weights, max_capacity)) # Output should be 10"},{"question":"def fibonacci_filter(numbers: List[int]) -> List[int]: Returns a list of numbers that are part of the Fibonacci sequence up to the maximum value in the input list. >>> fibonacci_filter([10, 15, 8, 34, 2]) [8, 34, 2] >>> fibonacci_filter([4, 6, 7, 22]) [] >>> fibonacci_filter([0, 1, 1, 2, 3, 5]) [0, 1, 1, 2, 3, 5]","solution":"def fibonacci_filter(numbers): Returns a list of numbers that are part of the Fibonacci sequence up to the maximum value in the input list. if not numbers: return [] max_num = max(numbers) fibs = set() a, b = 0, 1 fibs.add(a) while a <= max_num: fibs.add(a) a, b = b, a + b return [num for num in numbers if num in fibs]"},{"question":"import numpy as np def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False for i in range(2, int(np.sqrt(n)) + 1): if n % i == 0: return False return True def prime_index(n: int) -> int: Find number of primes less than or equal to n. count = 0 for i in range(2, n + 1): if is_prime(i): count += 1 return count def replace_primes_with_indices(matrix: np.ndarray) -> np.ndarray: Replace all prime numbers in a 2D numpy matrix with their prime indices. Parameters: matrix (np.ndarray): 2D numpy array of integers. Returns: np.ndarray: 2D numpy array with prime numbers replaced by their prime indices. >>> replace_primes_with_indices(np.array([[2, 3, 4], [5, 6, 7], [8, 9, 10]])) array([[1, 2, 4], [3, 6, 4], [8, 9, 10]]) >>> replace_primes_with_indices(np.array([[4, 6, 8], [10, 12, 14]])) array([[4, 6, 8], [10, 12, 14]]) import numpy as np from solution import replace_primes_with_indices def test_replace_primes_with_indices(): matrix = np.array([ [2, 3, 4], [5, 6, 7], [8, 9, 10] ]) expected_output = np.array([ [1, 2, 4], [3, 6, 4], [8, 9, 10] ]) assert np.array_equal(replace_primes_with_indices(matrix), expected_output) def test_no_primes(): matrix = np.array([ [4, 6, 8], [10, 12, 14] ]) expected_output = np.array([ [4, 6, 8], [10, 12, 14] ]) assert np.array_equal(replace_primes_with_indices(matrix), expected_output) def test_all_primes(): matrix = np.array([ [2, 3, 5], [7, 11, 13], [17, 19, 23] ]) expected_output = np.array([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) assert np.array_equal(replace_primes_with_indices(matrix), expected_output) def test_mixed_values(): matrix = np.array([ [29, 15, 22], [17, 24, 25], [9, 31, 9] ]) expected_output = np.array([ [10, 15, 22], [7, 24, 25], [9, 11, 9] ]) assert np.array_equal(replace_primes_with_indices(matrix), expected_output) def test_large_matrix(): matrix = np.random.randint(1, 100, size=(10, 10)) output = replace_primes_with_indices(matrix) assert output.shape == matrix.shape","solution":"import numpy as np def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False for i in range(2, int(np.sqrt(n)) + 1): if n % i == 0: return False return True def prime_index(n: int) -> int: Find number of primes less than or equal to n. count = 0 for i in range(2, n + 1): if is_prime(i): count += 1 return count def replace_primes_with_indices(matrix: np.ndarray) -> np.ndarray: Replace all prime numbers in a 2D numpy matrix with their prime indices. result = matrix.copy() for i in range(matrix.shape[0]): for j in range(matrix.shape[1]): if is_prime(matrix[i, j]): result[i, j] = prime_index(matrix[i, j]) return result"},{"question":"[Completion Task in Python] def find_top_athlete(scores: dict[int, list[float]]) -> int: top_athlete = None highest_avg_score = float('-inf') for athlete, score_list in scores.items(): avg_score = sum(score_list) / len(score_list) if avg_score > highest_avg_score or (avg_score == highest_avg_score and athlete < top_athlete): top_athlete = athlete highest_avg_score = avg_score return top_athlete","solution":"def find_top_athlete(scores: dict[int, list[float]]) -> int: top_athlete = None highest_avg_score = float('-inf') for athlete, score_list in scores.items(): avg_score = sum(score_list) / len(score_list) if avg_score > highest_avg_score or (avg_score == highest_avg_score and athlete < top_athlete): top_athlete = athlete highest_avg_score = avg_score return top_athlete"},{"question":"import csv def average_grade(math: int, science: int, english: int) -> float: Calculate the average of the given grades for math, science, and English. >>> average_grade(90, 95, 85) 90.0 >>> average_grade(70, 80, 90) 80.0 >>> average_grade(100, 95, 100) 98.33 >>> average_grade(0, 0, 0) 0.0 def process_student_data(filename: str = \\"students.csv\\") -> dict: Process the student data in the given CSV file and return a dictionary with average grades. >>> process_student_data(\\"students.csv\\") {\\"Alice\\": 87.67, \\"Bob\\": 81.33, \\"Charlie\\": 90.67}","solution":"import csv def average_grade(math: int, science: int, english: int) -> float: Calculate the average of the given grades for math, science, and English. return round((math + science + english) / 3, 2) def process_student_data(filename: str = \\"students.csv\\") -> dict: Process the student data in the given CSV file and return a dictionary with average grades. student_averages = {} with open(filename, mode='r') as file: csv_reader = csv.reader(file) for row in csv_reader: name, math, science, english = row[0], int(row[1]), int(row[2]), int(row[3]) student_averages[name] = average_grade(math, science, english) return student_averages"},{"question":"def has_required_permissions(user_permissions: dict[str, list[str]], resource: str, required_permissions: list[str]) -> bool: Check if the user has all required permissions for a resource. :param user_permissions: Dictionary with keys as resource names and values as lists of permissions. :param resource: The resource for which permissions are being checked. :param required_permissions: List of permissions required to access the resource. :return: True if the user has all required permissions; otherwise, False. >>> has_required_permissions({\\"file1\\": [\\"read\\", \\"write\\"], \\"file2\\": [\\"read\\"]}, \\"file1\\", [\\"read\\", \\"write\\"]) True >>> has_required_permissions({\\"file1\\": [\\"read\\", \\"write\\"], \\"file2\\": [\\"read\\"]}, \\"file2\\", [\\"write\\"]) False >>> has_required_permissions({\\"file1\\": [\\"read\\"], \\"file2\\": [\\"read\\", \\"write\\", \\"execute\\"]}, \\"file2\\", [\\"read\\", \\"execute\\"]) True >>> has_required_permissions({\\"file1\\": [\\"read\\"], \\"file2\\": [\\"read\\"]}, \\"file3\\", [\\"read\\"]) False","solution":"def has_required_permissions(user_permissions: dict[str, list[str]], resource: str, required_permissions: list[str]) -> bool: Check if the user has all required permissions for a resource. :param user_permissions: Dictionary with keys as resource names and values as lists of permissions. :param resource: The resource for which permissions are being checked. :param required_permissions: List of permissions required to access the resource. :return: True if the user has all required permissions; otherwise, False. if resource not in user_permissions: return False user_permissions_for_resource = user_permissions[resource] return all(permission in user_permissions_for_resource for permission in required_permissions)"},{"question":"from typing import List def knapsack(values: List[int], weights: List[int], capacity: int) -> int: Determines the maximum value that can be obtained by selecting items based on their weights and values, without exceeding the given capacity. :param values: List of integers representing the values of the items. :param weights: List of integers representing the weights of the items. :param capacity: Integer representing the maximum capacity of the knapsack. :return: The maximum value that can be obtained within the given capacity. >>> knapsack([60, 100, 120], [10, 20, 30], 50) 220 >>> knapsack([10, 20, 30], [1, 1, 1], 2) 50 >>> knapsack([100, 200, 300], [1, 3, 4], 4) 300 >>> knapsack([5, 6, 3, 9], [2, 2, 1, 3], 4) 12 def test_knapsack_example_1(): assert knapsack([60, 100, 120], [10, 20, 30], 50) == 220 def test_knapsack_example_2(): assert knapsack([10, 20, 30], [1, 1, 1], 2) == 50 def test_knapsack_example_3(): assert knapsack([100, 200, 300], [1, 3, 4], 4) == 300 def test_knapsack_example_4(): assert knapsack([5, 6, 3, 9], [2, 2, 1, 3], 4) == 12 def test_knapsack_no_capacity(): assert knapsack([15, 25, 35], [1, 2, 3], 0) == 0 def test_knapsack_no_items(): assert knapsack([], [], 10) == 0 def test_knapsack_single_item_fits(): assert knapsack([50], [10], 10) == 50 def test_knapsack_single_item_does_not_fit(): assert knapsack([50], [10], 5) == 0 def test_knapsack_multiple_items_some_fit(): assert knapsack([10, 40, 30, 50], [5, 4, 6, 3], 10) == 90","solution":"from typing import List def knapsack(values: List[int], weights: List[int], capacity: int) -> int: Determines the maximum value that can be obtained by selecting items based on their weights and values, without exceeding the given capacity. :param values: List of integers representing the values of the items. :param weights: List of integers representing the weights of the items. :param capacity: Integer representing the maximum capacity of the knapsack. :return: The maximum value that can be obtained within the given capacity. n = len(values) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(capacity + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i - 1] <= w: dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"from typing import List, Dict class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): pass def search(self, word): pass def find_words_in_trie(words: List[str], queries: List[str]) -> Dict[str, bool]: Construct a Trie from given words and determine if query words are found in the Trie. >>> find_words_in_trie([\\"cat\\", \\"dog\\", \\"rat\\", \\"bat\\", \\"cow\\"], [\\"cat\\", \\"batman\\", \\"cow\\", \\"tiger\\"]) {\\"cat\\": True, \\"batman\\": False, \\"cow\\": True, \\"tiger\\": False} pass","solution":"from typing import List, Dict class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def find_words_in_trie(words: List[str], queries: List[str]) -> Dict[str, bool]: trie = Trie() for word in words: trie.insert(word) result = {} for query in queries: result[query] = trie.search(query) return result"},{"question":"def find_duplicate(nums: list[int]) -> int: Returns the first duplicate value in the list. If no duplicates, returns -1. >>> find_duplicate([1, 3, 4, 2, 5, 3, 7]) 3 >>> find_duplicate([5, 6, 4, 7, 9, 2, 1]) -1 >>> find_duplicate([1, 2, 1, 3, 4, 5]) 1 >>> find_duplicate([7, 9, 4, 7, 2, 4, 8]) 7 >>> find_duplicate([8, 1, 8, 2, 3, 8]) 8 from typing import List def test_find_duplicate_no_duplicates(): assert find_duplicate([5, 6, 4, 7, 9, 2, 1]) == -1 def test_find_duplicate_single_element(): assert find_duplicate([7]) == -1 def test_find_duplicate_first_element_duplicate(): assert find_duplicate([1, 2, 1, 3, 4, 5]) == 1 def test_find_duplicate_last_element_duplicate(): assert find_duplicate([7, 9, 4, 7, 2, 4, 8]) == 7 def test_find_duplicate_multiple_duplicates(): assert find_duplicate([8, 1, 8, 2, 3, 8]) == 8 def test_find_duplicate_with_large_list(): assert find_duplicate(list(range(100000)) + [50000]) == 50000 def test_find_duplicate_all_elements_same(): assert find_duplicate([1, 1, 1, 1]) == 1","solution":"def find_duplicate(nums: list[int]) -> int: Returns the first duplicate value in the list. If no duplicates, returns -1. seen = set() for num in nums: if num in seen: return num seen.add(num) return -1"},{"question":"class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. def get(self, key: int) -> int: Get the value of the key if it exists in the cache, otherwise return -1. def put(self, key: int, value: int) -> None: Update the value of the key if it exists, or insert the key if it does not exist. When the cache reaches its capacity, evict the least recently used item. # Unit tests def test_cache_capacity_one(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 cache.put(2, 2) assert cache.get(1) == -1 # evicted assert cache.get(2) == 2 def test_cache_eviction(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # LRU key is now 2 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # key 2 evicted cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # key 1 evicted assert cache.get(3) == 3 # key 3 remains assert cache.get(4) == 4 # key 4 remains def test_update_key_value(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) assert cache.get(1) == 10 # updated value cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # key 2 evicted assert cache.get(1) == 10 # key 1 remains with updated value assert cache.get(3) == 3 # key 3 remains def test_repeated_key_access(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # key 2 evicted cache.put(1, 10) # update key 1 to new value assert cache.get(1) == 10 # key 1 remains with new value cache.put(4, 4) # evicts key 3 assert cache.get(3) == -1 # key 3 evicted assert cache.get(4) == 4 # key 4 remains","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) # Dummy head self.tail = Node(0, 0) # Dummy tail self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node): prev, nxt = node.prev, node.next prev.next = nxt nxt.prev = prev def _add(self, node: Node): last = self.tail.prev last.next = node self.tail.prev = node node.prev = last node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"def least_interval(tasks: list, n: int) -> int: Determine the minimum time required to complete all given tasks with cooling periods. Args: tasks (list): A list of characters representing tasks. n (int): The cooling period between the same tasks. Returns: int: The minimum intervals required to execute all the tasks with the given cooling period. Examples: >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B'], 2) 8 >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B'], 0) 6 >>> least_interval(['A', 'B', 'C', 'A', 'B', 'C'], 1) 6 >>> least_interval([], 2) 0","solution":"def least_interval(tasks: list, n: int) -> int: from collections import Counter if not tasks: return 0 task_counts = list(Counter(tasks).values()) max_count = max(task_counts) max_count_tasks = task_counts.count(max_count) part_count = max_count - 1 part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"def can_reach_target(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> bool: Determines if there is a path from the start cell to the target cell in a grid filled with obstacles. Parameters: - grid (list[list[int]]): The 2D grid represented as a list of lists of integers, where 0 represents a free cell and 1 represents an obstacle. - start (tuple[int, int]): The starting cell as a tuple (row, col). - target (tuple[int, int]): The target cell as a tuple (row, col). Returns: - bool: True if there is a path from the start cell to the target cell, False otherwise. pass def test_can_reach_target_simple_path(): grid = [ [0, 0, 0, 1], [0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0] ] start = (0, 0) target = (3, 3) assert can_reach_target(grid, start, target) == True def test_can_reach_target_no_path(): grid = [ [0, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 0, 0] ] start = (0, 0) target = (3, 3) assert can_reach_target(grid, start, target) == False def test_can_reach_target_edge_case(): grid = [ [0, 0, 0], [0, 1, 1], [0, 0, 0] ] start = (0, 2) target = (2, 2) assert can_reach_target(grid, start, target) == True def test_can_reach_target_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] start = (0, 0) target = (2, 2) assert can_reach_target(grid, start, target) == True def test_can_reach_target_start_is_target(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] start = (1, 1) target = (1, 1) assert can_reach_target(grid, start, target) == True def test_can_reach_target_surrounded_start(): grid = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] start = (1, 1) target = (2, 2) assert can_reach_target(grid, start, target) == False def test_can_reach_target_surrounded_target(): grid = [ [0, 0, 0], [0, 1, 1], [0, 1, 0] ] start = (0, 0) target = (2, 2) assert can_reach_target(grid, start, target) == False","solution":"def can_reach_target(grid, start, target): Determines if there is a path from the start cell to the target cell in a grid filled with obstacles. Parameters: - grid (list[list[int]]): The 2D grid represented as a list of lists of integers, where 0 represents a free cell and 1 represents an obstacle. - start (tuple[int, int]): The starting cell as a tuple (row, col). - target (tuple[int, int]): The target cell as a tuple (row, col). Returns: - bool: True if there is a path from the start cell to the target cell, False otherwise. rows, cols = len(grid), len(grid[0]) queue = [start] # Use a BFS queue visited = set() visited.add(start) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right while queue: current = queue.pop(0) if current == target: return True for direction in directions: new_row, new_col = current[0] + direction[0], current[1] + direction[1] if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: queue.append((new_row, new_col)) visited.add((new_row, new_col)) return False"},{"question":"def summarize_error_messages(log_file_path: str) -> dict: Reads a log file and summarizes the occurrences of each unique error message. Args: log_file_path (str): The path to the log file. Returns: dict: A dictionary where the keys are error messages and the values are the counts of their occurrences. Example: >>> summarize_error_messages('path/to/logfile.log') {'This is the first error': 3, 'This is the second error': 2, 'This is the third error': 1} import os def test_summarize_error_messages(): # Create a temporary log file for testing log_file_path = 'test_log_file.log' with open(log_file_path, 'w') as file: file.write(\\"2023-10-01 08:00:00 [ERROR] This is the first errorn\\") file.write(\\"2023-10-01 08:05:00 [ERROR] This is the second errorn\\") file.write(\\"2023-10-01 08:10:00 [INFO] This is just an infon\\") file.write(\\"2023-10-01 08:15:00 [ERROR] This is the first errorn\\") file.write(\\"2023-10-01 08:20:00 [ERROR] This is the third errorn\\") file.write(\\"2023-10-01 08:25:00 [ERROR] This is the first errorn\\") file.write(\\"2023-10-01 08:30:00 [ERROR] This is the second errorn\\") expected_output = { \\"This is the first error\\": 3, \\"This is the second error\\": 2, \\"This is the third error\\": 1, } actual_output = summarize_error_messages(log_file_path) assert actual_output == expected_output # Clean up the temporary file os.remove(log_file_path) def test_summarize_error_messages_no_errors(): # Create a temporary log file for testing log_file_path = 'test_log_file_no_errors.log' with open(log_file_path, 'w') as file: file.write(\\"2023-10-01 08:00:00 [INFO] This is just an infon\\") file.write(\\"2023-10-01 08:10:00 [WARNING] This is a warningn\\") expected_output = {} actual_output = summarize_error_messages(log_file_path) assert actual_output == expected_output # Clean up the temporary file os.remove(log_file_path) def test_summarize_error_messages_nonexistent_file(): non_existent_file_path = 'non_existent_log_file.log' expected_output = {} actual_output = summarize_error_messages(non_existent_file_path) assert actual_output == expected_output","solution":"def summarize_error_messages(log_file_path: str) -> dict: Reads a log file and summarizes the occurrences of each unique error message. Args: log_file_path (str): The path to the log file. Returns: dict: A dictionary where the keys are error messages and the values are the counts of their occurrences. error_counts = {} try: with open(log_file_path, 'r') as file: for line in file: if \\"[ERROR]\\" in line: # Extract error message by splitting the line error_message = line.split(\\"[ERROR]\\")[1].strip() if error_message in error_counts: error_counts[error_message] += 1 else: error_counts[error_message] = 1 except IOError: print(f\\"Error: Unable to read file {log_file_path}\\") return error_counts"},{"question":"def cleanup_logs(directory_path: str, days_threshold: int, report_file: str) -> None: Scans the specified directory, deletes files older than a given threshold, and logs the actions taken to a report file. :param directory_path: The path to the directory containing the log files. :param days_threshold: The number of days to use as the threshold for deleting files. :param report_file: The path to the file where the report should be written. >>> cleanup_logs(\\"/var/logs\\", 30, \\"/var/reports/cleanup_report.txt\\")","solution":"import os import datetime def cleanup_logs(directory_path: str, days_threshold: int, report_file: str) -> None: Scans the specified directory, deletes files older than a given threshold, and logs the actions taken to a report file. :param directory_path: The path to the directory containing the log files. :param days_threshold: The number of days to use as the threshold for deleting files. :param report_file: The path to the file where the report should be written. try: current_time = datetime.datetime.now() threshold_time = current_time - datetime.timedelta(days=days_threshold) with open(report_file, 'w') as report: for filename in os.listdir(directory_path): file_path = os.path.join(directory_path, filename) if filename.endswith('.log') and os.path.isfile(file_path): # Get the last modified time of the file file_mod_time = datetime.datetime.fromtimestamp(os.path.getmtime(file_path)) if file_mod_time < threshold_time: os.remove(file_path) report.write(f\\"{filename}: deletedn\\") else: report.write(f\\"{filename}: skippedn\\") except Exception as e: with open(report_file, 'a') as report: report.write(f\\"Error: {str(e)}n\\")"},{"question":"def merge_intervals(intervals: list[tuple[int, int]]) -> list[tuple[int, int]]: Merges overlapping intervals. Args: intervals (list[tuple[int, int]]): A list of intervals as tuples (start, end) Returns: list[tuple[int, int]]: A list of merged intervals. Examples: >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 10), (2, 6), (8, 10), (15, 18)]) [(1, 10), (15, 18)] >>> merge_intervals([(1, 2), (2, 3), (3, 4)]) [(1, 4)]","solution":"def merge_intervals(intervals): Merges overlapping intervals. Args: intervals (list[tuple[int, int]]): A list of intervals as tuples (start, end) Returns: list[tuple[int, int]]: A list of merged intervals. if not intervals: return [] # Sort intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: # There is overlap, so merge the current interval merged[-1] = (last_merged[0], max(last_merged[1], current[1])) else: # No overlap, so add the current interval to the merged list merged.append(current) return merged"},{"question":"def average_color(colors: list[tuple[int, int, int]]) -> tuple[int, int, int]: Returns the average color of a list of RGB tuples. Each tuple contains three integers in the range of 0 to 255. >>> average_color([(255, 0, 0), (0, 255, 0), (0, 0, 255)]) (85, 85, 85) >>> average_color([(255, 255, 255), (255, 255, 255), (0, 0, 0)]) (170, 170, 170) >>> average_color([(128, 64, 32), (32, 64, 128)]) (80, 64, 80)","solution":"def average_color(colors): Returns the average color of a list of RGB tuples. Each tuple contains three integers in the range of 0 to 255. num_colors = len(colors) total_red = sum(color[0] for color in colors) total_green = sum(color[1] for color in colors) total_blue = sum(color[2] for color in colors) avg_red = round(total_red / num_colors) avg_green = round(total_green / num_colors) avg_blue = round(total_blue / num_colors) return (avg_red, avg_green, avg_blue)"},{"question":"import heapq class MedianPriceTracker: A class to track product prices and efficiently find the median price. >>> tracker = MedianPriceTracker() >>> tracker.add_price(10) >>> tracker.add_price(20) >>> print(tracker.find_median()) # Output: 15.0 >>> tracker.add_price(30) >>> print(tracker.find_median()) # Output: 20.0 def __init__(self): self.min_heap = [] # min heap to store the larger half of the prices self.max_heap = [] # max heap to store the smaller half of the prices def add_price(self, price: int) -> None: # Add a new product price to the tracker pass def find_median(self) -> float: # Return the median of the current set of product prices pass # Unit Tests def test_add_price_and_find_median(): tracker = MedianPriceTracker() tracker.add_price(10) assert tracker.find_median() == 10.0 tracker.add_price(20) assert tracker.find_median() == 15.0 tracker.add_price(30) assert tracker.find_median() == 20.0 def test_even_number_of_elements(): tracker = MedianPriceTracker() tracker.add_price(5) tracker.add_price(10) tracker.add_price(15) tracker.add_price(20) assert tracker.find_median() == 12.5 def test_large_number_of_elements(): tracker = MedianPriceTracker() prices = [i for i in range(1, 1001)] # Adding 1000 elements for price in prices: tracker.add_price(price) assert tracker.find_median() == 500.5 def test_single_element(): tracker = MedianPriceTracker() tracker.add_price(7) assert tracker.find_median() == 7.0 def test_negative_and_positive_prices(): tracker = MedianPriceTracker() tracker.add_price(5) tracker.add_price(15) tracker.add_price(-5) tracker.add_price(-15) assert tracker.find_median() == 0.0","solution":"import heapq class MedianPriceTracker: def __init__(self): self.min_heap = [] # min heap to store the larger half of the prices self.max_heap = [] # max heap to store the smaller half of the prices def add_price(self, price: int) -> None: heapq.heappush(self.max_heap, -price) # Ensuring the first max_heap element is always less than or equal to the first min_heap element if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Rebalance heaps if the sizes differ by more than one if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"def frequency_of_characters(text: str) -> dict[str, int]: Calculate the frequency of each character in the input string. Parameters: - text: str, the input string Returns: - dict[str, int]: a dictionary where the keys are characters and the values are their respective counts Raises: - ValueError: if the input is not a string >>> frequency_of_characters(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> frequency_of_characters(\\"test case\\") {'t': 2, 'e': 2, 's': 2, ' ': 1, 'c': 1, 'a': 1} >>> frequency_of_characters(1234) Traceback (most recent call last): ValueError: Input must be a string","solution":"def frequency_of_characters(text): Returns a dictionary with the frequency of each character in the input string. Parameters: - text: str, the input string Returns: - dict[str, int]: a dictionary where keys are characters and values are their counts Raises: - ValueError: if the input is not a string if not isinstance(text, str): raise ValueError(\\"Input must be a string\\") frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def shortest_path(grid: list, start: tuple, end: tuple) -> int: Find the shortest path from the start to the destination in a maze represented by a 2D grid. Parameters: grid (list): A 2D list of integers, where 0 represents an empty cell and 1 represents a block. start (tuple): A tuple of two integers representing the starting cell's coordinates (row, column). end (tuple): A tuple of two integers representing the destination cell's coordinates (row, column). Returns: int: The length of the shortest path from \`start\` to \`end\`. If no path is found, return -1. Examples: >>> shortest_path([[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]], (0, 0), (4, 4)) 8 >>> shortest_path([[0, 1], [1, 0]], (0, 0), (1, 1)) -1 pass def test_shortest_path_simple_case(): grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) assert shortest_path(grid, start, end) == 8 def test_shortest_path_no_path(): grid = [ [0, 1], [1, 0] ] start = (0, 0) end = (1, 1) assert shortest_path(grid, start, end) == -1 def test_shortest_path_start_is_end(): grid = [ [0, 0], [0, 0] ] start = (0, 0) end = (0, 0) assert shortest_path(grid, start, end) == 0 def test_shortest_path_multiple_paths(): grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) end = (2, 2) assert shortest_path(grid, start, end) == 4 def test_shortest_path_large_grid(): grid = [ [0] * 500 for _ in range(500) ] start = (0, 0) end = (499, 499) assert shortest_path(grid, start, end) == 998 def test_shortest_path_start_adjacent_to_end(): grid = [ [0, 0], [0, 0] ] start = (0, 0) end = (0, 1) assert shortest_path(grid, start, end) == 1","solution":"from collections import deque def shortest_path(grid, start, end): # Check if the start and end points are the same if start == end: return 0 # Directions array for moving in 4 possible directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Get the dimensions of the grid rows, cols = len(grid), len(grid[0]) # BFS initialization queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: current_row, current_col, dist = queue.popleft() # Explore all possible 4 directions for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: if (new_row, new_col) == end: return dist + 1 queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def rotate_matrix(matrix: list) -> None: Rotates an n x n matrix in place by 90 degrees clockwise. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"def rotate_matrix(matrix: list) -> None: Rotates an n x n matrix in place by 90 degrees clockwise. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List, Tuple def top_urls_by_unique_users(logs: List[Tuple[str, str]]) -> List[str]: Determines the URLs visited by the highest number of unique users. :param logs: List of tuples where each tuple contains a URL visited and a user ID. :return: List of URLs ordered by the number of unique users in descending order. >>> top_urls_by_unique_users([(\\"url1\\", \\"user1\\"), (\\"url1\\", \\"user2\\"), (\\"url2\\", \\"user1\\")]) ['url1', 'url2'] >>> top_urls_by_unique_users([(\\"url2\\", \\"user1\\"), (\\"url3\\", \\"user2\\"), (\\"url3\\", \\"user3\\"), (\\"url2\\", \\"user1\\"), (\\"url1\\", \\"user2\\")]) ['url3', 'url1', 'url2'] >>> top_urls_by_unique_users([(\\"url1\\", \\"user1\\")]) ['url1']","solution":"from collections import defaultdict from typing import List, Tuple def top_urls_by_unique_users(logs: List[Tuple[str, str]]) -> List[str]: Returns the URLs visited by the highest number of unique users, ordered by the number of unique users in descending order. :param logs: List of tuples containing URL and user ID. :return: List of URLs ordered by unique user count in descending order. url_users = defaultdict(set) for url, user in logs: url_users[url].add(user) sorted_urls = sorted(url_users.items(), key=lambda item: (-len(item[1]), item[0])) return [url for url, users in sorted_urls]"},{"question":"import random import time from typing import Callable, Dict, List def bubble_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def evaluate_sorting_algorithms(algorithms: Dict[str, Callable[[List[int]], List[int]]], n: int) -> Dict[str, float]: Evaluate the correctness and performance of different sorting algorithms. Generate \`n\` random integers, sort them using provided sorting functions, and measure the time taken for the sorting process. >>> algorithms = { ... \\"Bubble Sort\\": bubble_sort, ... \\"Quick Sort\\": quick_sort ... } >>> results = evaluate_sorting_algorithms(algorithms, 10000) >>> \\"Bubble Sort\\" in results True >>> \\"Quick Sort\\" == type(results[\\"Quick Sort\\"]) <class 'float'> pass def test_evaluate_sorting_algorithms(): from solution import evaluate_sorting_algorithms, bubble_sort, quick_sort algorithms = { \\"Bubble Sort\\": bubble_sort, \\"Quick Sort\\": quick_sort } results = evaluate_sorting_algorithms(algorithms, 100) assert len(results) == len(algorithms) for key in results: assert key in algorithms for value in results.values(): assert isinstance(value, float) assert value >= 0 def test_sorting_algorithms_correctness(): from solution import bubble_sort, quick_sort lst = [random.randint(-100, 100) for _ in range(100)] sorted_lst = sorted(lst) assert bubble_sort(lst[:]) == sorted_lst assert quick_sort(lst[:]) == sorted_lst","solution":"import random import time def evaluate_sorting_algorithms(algorithms, n): results = {} random_lst = random.sample(range(-10**6, 10**6), n) for name, sort_func in algorithms.items(): lst_copy = random_lst[:] start_time = time.time() sort_func(lst_copy) # Assuming the function sorts in place end_time = time.time() results[name] = end_time - start_time return results def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def quick_sort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 self.sum = key class AVLTree: def __init__(self): self.root = None def insert(self, root, key): if not root: return Node(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) root.sum = root.key + self.get_sum(root.left) + self.get_sum(root.right) balance = self.get_balance(root) # Left Left Case if balance > 1 and key < root.left.key: return self.right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return self.left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.sum = z.key + self.get_sum(z.left) + self.get_sum(z.right) y.sum = y.key + self.get_sum(y.left) + self.get_sum(y.right) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.sum = z.key + self.get_sum(z.left) + self.get_sum(z.right) y.sum = y.key + self.get_sum(y.left) + self.get_sum(y.right) return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def get_sum(self, root): if not root: return 0 return root.sum def range_sum(self, l, r): Range Sum Query: Calculate the sum of all values within the specified range [l, r]. >>> tree = AVLTree() >>> insert_values(tree, [10, 20, 30, 40, 50, 25]) >>> tree.range_sum(10, 30) 85 >>> tree.range_sum(15, 45) 115","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 self.sum = key class AVLTree: def __init__(self): self.root = None def insert(self, root, key): if not root: return Node(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) root.sum = root.key + self.get_sum(root.left) + self.get_sum(root.right) balance = self.get_balance(root) # Left Left Case if balance > 1 and key < root.left.key: return self.right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return self.left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.sum = z.key + self.get_sum(z.left) + self.get_sum(z.right) y.sum = y.key + self.get_sum(y.left) + self.get_sum(y.right) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.sum = z.key + self.get_sum(z.left) + self.get_sum(z.right) y.sum = y.key + self.get_sum(y.left) + self.get_sum(y.right) return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def get_sum(self, root): if not root: return 0 return root.sum def range_sum(self, l, r): return self._range_sum(self.root, l, r) def _range_sum(self, node, l, r): if not node: return 0 if node.key < l: return self._range_sum(node.right, l, r) elif node.key > r: return self._range_sum(node.left, l, r) return (node.key + self._range_sum(node.left, l, r) + self._range_sum(node.right, l, r)) # Helper method to insert values into the AVL tree def insert_values(tree, values): for value in values: tree.root = tree.insert(tree.root, value) tree = AVLTree() insert_values(tree, [10, 20, 30, 40, 50, 25]) print(tree.range_sum(10, 30)) # should print 85 print(tree.range_sum(15, 45)) # should print 115"},{"question":"class Trie: Trie Implementation with Specific Rules Tries, also known as prefix trees, are a type of ordered tree data structure commonly used to store associative arrays where the keys are usually strings. A trie allows for efficient insertion, deletion, and lookup operations. Your task is to implement a basic trie with the following operations: 1. insert: Adds a word to the trie. 2. search: Checks if a word is present in the trie. 3. startsWith: Checks if there is any word in the trie that starts with a given prefix. Additionally, you need to implement a function longest_common_prefix() which returns the longest common prefix string amongst all words stored in the trie. Example: operations = [ (\\"insert\\", \\"flower\\"), (\\"insert\\", \\"flow\\"), (\\"insert\\", \\"flight\\"), (\\"search\\", \\"flow\\"), # Output: True (\\"search\\", \\"flame\\"), # Output: False (\\"startsWith\\", \\"fl\\"), # Output: True (\\"startsWith\\", \\"fle\\"), # Output: False (\\"longest_common_prefix\\",) # Output: \\"fl\\" ] trie = Trie() for op in operations: if op[0] == \\"insert\\": trie.insert(op[1]) elif op[0] == \\"search\\": print(trie.search(op[1])) elif op[0] == \\"startsWith\\": print(trie.startsWith(op[1])) elif op[0] == \\"longest_common_prefix\\": print(trie.longest_common_prefix()) def __init__(self): Initialize the Trie # Your implementation here def insert(self, word: str) -> None: Insert a word into the trie # Your implementation here def search(self, word: str) -> bool: Search for a word in the trie # Your implementation here def startsWith(self, prefix: str) -> bool: Check if there is any word in the trie that starts with the given prefix # Your implementation here def longest_common_prefix(self) -> str: Find and return the longest common prefix among all words in the trie # Your implementation here","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the Trie self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the trie node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Search for a word in the trie node = self._find_node(word) return node is not None and node.is_end_of_word def startsWith(self, prefix: str) -> bool: Check if there is any word in the trie that starts with the given prefix return self._find_node(prefix) is not None def _find_node(self, word: str) -> TrieNode: Helper function to traverse the trie and find the node of the last character of the word node = self.root for char in word: if char not in node.children: return None node = node.children[char] return node def longest_common_prefix(self) -> str: Find and return the longest common prefix among all words in the trie node = self.root prefix = [] while node and not node.is_end_of_word and len(node.children) == 1: char = next(iter(node.children)) prefix.append(char) node = node.children[char] return ''.join(prefix)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_nodes_in_range(root: TreeNode, L: int, R: int) -> int: Count the number of nodes within the specified range in the binary tree. The function takes the root of a binary tree and two integers L and R, and returns the number of nodes with values within the range [L, R] inclusively. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(8) >>> root.right.right = TreeNode(18) >>> count_nodes_in_range(root, 5, 15) 4 >>> count_nodes_in_range(TreeNode(20), 5, 15) 0 pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_nodes_in_range(root: TreeNode, L: int, R: int) -> int: if root is None: return 0 count = 0 if L <= root.value <= R: count = 1 count += count_nodes_in_range(root.left, L, R) count += count_nodes_in_range(root.right, L, R) return count"},{"question":"from typing import List def longest_harmonious_subsequence(nums: List[int]) -> int: Finds the length of the longest harmonious subsequence within a given list of integers. A harmonious subsequence is defined as a subsequence where the difference between the maximum and minimum elements is exactly 1. >>> longest_harmonious_subsequence([1, 3, 2, 2, 5, 2, 3, 7]) 5 >>> longest_harmonious_subsequence([1, 1, 1, 1]) 0","solution":"from typing import List from collections import Counter def longest_harmonious_subsequence(nums: List[int]) -> int: Finds the length of the longest harmonious subsequence in a list of integers. num_counts = Counter(nums) max_length = 0 for num in num_counts: if num + 1 in num_counts: max_length = max(max_length, num_counts[num] + num_counts[num + 1]) return max_length"},{"question":"class NetworkPath: def __init__(self): Initialize the NetworkPath instance with no initial nodes or connections. pass def add_node(self, node: str) -> None: Adds a new node to the network. Nodes should be unique and represented by strings. >>> network = NetworkPath() >>> network.add_node(\\"A\\") >>> network.validate_network(\\"A\\") pass def connect_nodes(self, node1: str, node2: str, latency: float) -> None: Connects two existing nodes in the network with a given latency. Validates that both nodes exist in the network. >>> network = NetworkPath() >>> network.add_node(\\"A\\") >>> network.add_node(\\"B\\") >>> network.connect_nodes(\\"A\\", \\"B\\", 10.5) pass def calculate_latency(self, path: list) -> float: Calculates the total latency for a given path, which is provided as a list of nodes. Validates that all nodes in the path are connected. >>> network = NetworkPath() >>> network.add_node(\\"A\\") >>> network.add_node(\\"B\\") >>> network.add_node(\\"C\\") >>> network.connect_nodes(\\"A\\", \\"B\\", 10.5) >>> network.connect_nodes(\\"B\\", \\"C\\", 5.2) >>> network.calculate_latency([\\"A\\", \\"B\\", \\"C\\"]) 15.7 pass def validate_network(self, *nodes: str) -> None: Validates that all specified nodes exist in the network and throws a ValueError if a node does not exist. >>> network = NetworkPath() >>> network.add_node(\\"A\\") >>> network.validate_network(\\"A\\") >>> network.validate_network(\\"B\\") Traceback (most recent call last): ValueError: Node B does not exist. pass import pytest def test_add_and_validate_nodes(): network = NetworkPath() network.add_node(\\"A\\") assert \\"A\\" in network.nodes with pytest.raises(ValueError): network.add_node(\\"A\\") with pytest.raises(ValueError): network.validate_network(\\"B\\") def test_connect_and_validate_nodes(): network = NetworkPath() network.add_node(\\"A\\") network.add_node(\\"B\\") network.connect_nodes(\\"A\\", \\"B\\", 10.5) assert network.connections[\\"A\\"][\\"B\\"] == 10.5 assert network.connections[\\"B\\"][\\"A\\"] == 10.5 with pytest.raises(ValueError): network.connect_nodes(\\"A\\", \\"C\\", 5.0) def test_calculate_latency(): network = NetworkPath() network.add_node(\\"A\\") network.add_node(\\"B\\") network.add_node(\\"C\\") network.connect_nodes(\\"A\\", \\"B\\", 10.5) network.connect_nodes(\\"B\\", \\"C\\", 5.2) assert network.calculate_latency([\\"A\\", \\"B\\", \\"C\\"]) == 15.7 def test_calculate_latency_with_invalid_path(): network = NetworkPath() network.add_node(\\"A\\") network.add_node(\\"B\\") network.add_node(\\"C\\") network.connect_nodes(\\"A\\", \\"B\\", 10.5) network.connect_nodes(\\"B\\", \\"C\\", 5.2) with pytest.raises(ValueError): network.calculate_latency([\\"A\\", \\"C\\"]) with pytest.raises(ValueError): network.calculate_latency([\\"A\\", \\"B\\", \\"D\\"]) def test_invalid_latencies(): network = NetworkPath() network.add_node(\\"A\\") network.add_node(\\"B\\") with pytest.raises(ValueError): network.connect_nodes(\\"A\\", \\"B\\", -5.0) with pytest.raises(ValueError): network.connect_nodes(\\"A\\", \\"B\\", 0.0)","solution":"class NetworkPath: def __init__(self): self.nodes = set() self.connections = {} def add_node(self, node: str) -> None: if node in self.nodes: raise ValueError(f\\"Node {node} already exists.\\") self.nodes.add(node) self.connections[node] = {} def connect_nodes(self, node1: str, node2: str, latency: float) -> None: self.validate_network(node1, node2) if latency <= 0: raise ValueError(\\"Latency must be a positive number.\\") self.connections[node1][node2] = latency self.connections[node2][node1] = latency def calculate_latency(self, path: list) -> float: total_latency = 0.0 for i in range(len(path) - 1): node1 = path[i] node2 = path[i + 1] self.validate_network(node1, node2) if node2 not in self.connections[node1]: raise ValueError(f\\"No direct connection between {node1} and {node2}.\\") total_latency += self.connections[node1][node2] return total_latency def validate_network(self, *nodes: str) -> None: for node in nodes: if node not in self.nodes: raise ValueError(f\\"Node {node} does not exist.\\")"},{"question":"from typing import List def remove_duplicates(arr: List[int]) -> int: Remove duplicates from a sorted array. >>> arr = [1, 1, 2] >>> remove_duplicates(arr) 2 >>> arr[:2] [1, 2] >>> arr = [0,0,1,1,1,2,2,3,3,4] >>> remove_duplicates(arr) 5 >>> arr[:5] [0, 1, 2, 3, 4] >>> arr = [] >>> remove_duplicates(arr) 0 >>> arr [] >>> arr = [1] >>> remove_duplicates(arr) 1 >>> arr [1] >>> arr = [2, 2, 2, 2, 2] >>> remove_duplicates(arr) 1 >>> arr[:1] [2] >>> arr = [1, 2, 3, 4, 5] >>> remove_duplicates(arr) 5 >>> arr [1, 2, 3, 4, 5] >>> arr = [1, 1, 1, 2, 2, 3, 4, 4, 5] >>> remove_duplicates(arr) 5 >>> arr[:5] [1, 2, 3, 4, 5]","solution":"from typing import List def remove_duplicates(arr: List[int]) -> int: if not arr: return 0 write_index = 1 for read_index in range(1, len(arr)): if arr[read_index] != arr[write_index - 1]: arr[write_index] = arr[read_index] write_index += 1 return write_index"},{"question":"from typing import List def most_frequent_word(log: str) -> str: Identify the most frequently occurring word in given log data while ignoring case and punctuation. In case of a tie, return the lexicographically smallest word. >>> most_frequent_word(\\"Hello world! Hello everyone.\\") 'hello' >>> most_frequent_word(\\"This is a test. This test is only a test.\\") 'test' >>> most_frequent_word(\\"Data analysis is fun. Data is insightful.\\") 'data' >>> most_frequent_word(\\"Python, PYTHON, python; PYTHON!\\") 'python' >>> most_frequent_word(\\"apple a day keeps the doctor away.\\") 'a' >>> most_frequent_word(\\"@@@@@@ !!!!!\\") ''","solution":"import re from collections import Counter def most_frequent_word(log: str) -> str: Returns the most frequently occurring word in the input log string, ignoring case and punctuation. In case of a tie, returns the lexicographically smallest word. # Remove punctuation using regex and convert to lowercase words = re.findall(r'bw+b', log.lower()) if not words: return '' # Count the frequency of each word counter = Counter(words) # Find the most frequently occurring word most_common_word, highest_count = min(counter.items(), key=lambda item: (-item[1], item[0])) return most_common_word"},{"question":"def encode_string(input_string: str) -> str: Encodes a string based on the rule that each group of consecutive identical characters should be replaced by the character followed by the count of its consecutive appearances, and if a character appears only once consecutively, the count is not added. >>> encode_string(\\"aaabbcaaa\\") \\"a3b2ca3\\" >>> encode_string(\\"AABCC\\") \\"A2BC2\\" >>> encode_string(\\"xyz\\") \\"xyz\\" >>> encode_string(\\"kkkkkk\\") \\"k6\\" >>> encode_string(\\"PPQQq\\") \\"P2Q2q\\" from solution import encode_string def test_encode_string_simple_case(): assert encode_string(\\"aaabbcaaa\\") == \\"a3b2ca3\\" def test_encode_string_upper_case(): assert encode_string(\\"AABCC\\") == \\"A2BC2\\" def test_encode_string_no_consecutive_chars(): assert encode_string(\\"xyz\\") == \\"xyz\\" def test_encode_string_all_same_chars(): assert encode_string(\\"kkkkkk\\") == \\"k6\\" def test_encode_string_mixed_case(): assert encode_string(\\"PPQQq\\") == \\"P2Q2q\\" def test_encode_string_single_char(): assert encode_string(\\"a\\") == \\"a\\" def test_encode_string_two_same_chars(): assert encode_string(\\"aa\\") == \\"a2\\" def test_encode_string_edge_case_empty_string(): assert encode_string(\\"\\") == \\"\\"","solution":"def encode_string(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: if count > 1: encoded_string.append(f\\"{input_string[i - 1]}{count}\\") else: encoded_string.append(input_string[i - 1]) count = 1 if count > 1: encoded_string.append(f\\"{input_string[-1]}{count}\\") else: encoded_string.append(input_string[-1]) return \\"\\".join(encoded_string)"},{"question":"def symmetric_difference(set1: Set[int], set2: Set[int]) -> Set[int]: Compute the symmetric difference of two sets. Parameters: set1 (Set[int]): First set of integers. set2 (Set[int]): Second set of integers. Returns: Set[int]: Symmetric difference of set1 and set2. >>> symmetric_difference({1, 2, 3}, {3, 4, 5}) {1, 2, 4, 5} >>> symmetric_difference({1, 2, 3}, {1, 2, 3}) set() >>> symmetric_difference({1, 2, 3, 4}, {3, 4, 5, 6}) {1, 2, 5, 6} >>> symmetric_difference(set(), {1, 2, 3}) {1, 2, 3} >>> symmetric_difference({1, 2, 3}, set()) {1, 2, 3} >>> symmetric_difference(set(), set()) set()","solution":"def symmetric_difference(set1, set2): Compute the symmetric difference of two sets. Parameters: set1 (Set[int]): First set of integers. set2 (Set[int]): Second set of integers. Returns: Set[int]: Symmetric difference of set1 and set2. return (set1 - set2) | (set2 - set1)"},{"question":"def find_first_unique_character(s: str) -> str: Find the first unique character in a given string. >>> find_first_unique_character(\\"abcdabc\\") 'd' >>> find_first_unique_character(\\"aabbcc\\") '' >>> find_first_unique_character(\\"a\\") 'a' >>> find_first_unique_character(\\"\\") ''","solution":"def find_first_unique_character(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"Invalid input\\") # Dictionary to count character occurrences char_count = {} # Counting each character in the string for char in s: char_count[char] = char_count.get(char, 0) + 1 # Finding the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no unique character found, return empty string return \\"\\""},{"question":"# Question: Implement a Custom HashMap with Collision Handling using Separate Chaining Design and implement a simplified version of a HashMap (also known as a hash table) from scratch. Your implementation should handle hash collisions using the separate chaining technique, where each bucket in the hash table is a linked list. Requirements: 1. **Class**: \`CustomHashMap\` with the following methods: - \`__init__(self, size: int)\`: Initializes the hash table with a specified number of buckets. - \`put(self, key: int, value: int)\`: Inserts a key-value pair into the hash table. If the key already exists, update the value. - \`get(self, key: int) -> int\`: Retrieves the value associated with the key. Returns \`None\` if the key is not found. - \`remove(self, key: int)\`: Removes the key-value pair from the hash table if it exists. 2. **Constraints**: - The hash function should be a simple modulus operation (\`key % size\`). - Handle key collisions using the separate chaining technique with linked lists. - Handle scenarios where the hash table might be empty or have a small number of buckets effectively. 3. **Performance**: - Aim to ensure average-case time complexity remains efficient for \`put\`, \`get\`, and \`remove\` operations. - Avoid using additional data structures beyond linked lists for collision handling. class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.next = None class CustomHashMap: def __init__(self, size: int): Initialize the hash table with a given number of buckets. :param size: The number of buckets in the hash table. self.size = size self.buckets = [None] * size def put(self, key: int, value: int): Insert a key-value pair into the hash table. :param key: The key to insert. :param value: The value to associate with the key. index = key % self.size if self.buckets[index] is None: self.buckets[index] = Node(key, value) else: current = self.buckets[index] while True: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) def get(self, key: int) -> int: Retrieve the value associated with the key. :param key: The key to search for. :return: The value associated with the key, or None if the key is not found. index = key % self.size current = self.buckets[index] while current is not None: if current.key == key: return current.value current = current.next return None def remove(self, key: int): Remove the key-value pair from the hash table. :param key: The key to remove. index = key % self.size current = self.buckets[index] if current is None: return if current.key == key: self.buckets[index] = current.next return prev = None while current is not None: if current.key == key: prev.next = current.next return prev = current current = current.next","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.next = None class CustomHashMap: def __init__(self, size: int): Initialize the hash table with a given number of buckets. :param size: The number of buckets in the hash table. self.size = size self.buckets = [None] * size def put(self, key: int, value: int): Insert a key-value pair into the hash table. :param key: The key to insert. :param value: The value to associate with the key. index = key % self.size if self.buckets[index] is None: self.buckets[index] = Node(key, value) else: current = self.buckets[index] while True: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) def get(self, key: int) -> int: Retrieve the value associated with the key. :param key: The key to search for. :return: The value associated with the key, or None if the key is not found. index = key % self.size current = self.buckets[index] while current is not None: if current.key == key: return current.value current = current.next return None def remove(self, key: int): Remove the key-value pair from the hash table. :param key: The key to remove. index = key % self.size current = self.buckets[index] if current is None: return if current.key == key: self.buckets[index] = current.next return prev = None while current is not None: if current.key == key: prev.next = current.next return prev = current current = current.next"},{"question":"def recursive_fibonacci(n: int) -> int: Recursively calculates the n-th Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence (0-indexed). Must be a non-negative integer. Returns: int: The n-th Fibonacci number. pass # Test cases def test_recursive_fibonacci_base_cases(): assert recursive_fibonacci(0) == 0 assert recursive_fibonacci(1) == 1 def test_recursive_fibonacci_small_numbers(): assert recursive_fibonacci(2) == 1 assert recursive_fibonacci(3) == 2 assert recursive_fibonacci(4) == 3 assert recursive_fibonacci(5) == 5 def test_recursive_fibonacci_larger_numbers(): assert recursive_fibonacci(10) == 55 assert recursive_fibonacci(15) == 610 assert recursive_fibonacci(20) == 6765 def test_recursive_fibonacci_negative_input(): with pytest.raises(ValueError): recursive_fibonacci(-1) def test_recursive_fibonacci_edge_cases(): assert recursive_fibonacci(30) == 832040","solution":"def recursive_fibonacci(n): Recursively calculates the n-th Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence (0-indexed). Must be a non-negative integer. Returns: int: The n-th Fibonacci number. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2)"},{"question":"def remove_duplicate_events(events: list[int]) -> list[int]: Removes duplicate events from the list while preserving the order of the first occurrence of each event. Args: events (list[int]): A list of integers representing captured events. Returns: list[int]: A list of integers with duplicates removed, preserving the first occurrence of each event. Examples: >>> remove_duplicate_events([1, 2, 3, 2, 1, 5, 6, 2, 8, 5]) [1, 2, 3, 5, 6, 8] >>> remove_duplicate_events([1, 1, 1, 1, 1, 1]) [1] >>> remove_duplicate_events([4, 5, 6, 7, 8, 9]) [4, 5, 6, 7, 8, 9] >>> remove_duplicate_events([]) [] >>> remove_duplicate_events([10, 20, 30, 20, 10, 40, 50, 10]) [10, 20, 30, 40, 50]","solution":"def remove_duplicate_events(events: list[int]) -> list[int]: Removes duplicate events from the list while preserving the order of the first occurrence of each event. Args: events (list[int]): A list of integers representing captured events. Returns: list[int]: A list of integers with duplicates removed, preserving the first occurrence of each event. seen = set() unique_events = [] for event in events: if event not in seen: seen.add(event) unique_events.append(event) return unique_events"},{"question":"def double_pendulum_motion(theta1: float, theta2: float, length1: float, length2: float, mass1: float, mass2: float, g: float = 9.81, t0: float = 0.0, tf: float, dt: float) -> (list, list): Simulate the motion of a double pendulum and return the time series data for the angles. Args: theta1: initial angle of the first pendulum (in radians). theta2: initial angle of the second pendulum (in radians). length1: length of the rod of the first pendulum. length2: length of the rod of the second pendulum. mass1: mass of the first pendulum. mass2: mass of the second pendulum. g: acceleration due to gravity (default 9.81). t0: start time of the simulation (default 0 seconds). tf: end time of the simulation. dt: time step for numerical integration. Returns: A tuple containing two lists: - The angles theta1 over time. - The angles theta2 over time. Example: >>> theta1_series, theta2_series = double_pendulum_motion(0.1, 0.2, 1.0, 1.0, 1.0, 1.0, tf=10, dt=0.01) >>> len(theta1_series) 1001 >>> len(theta2_series) 1001 >>> round(theta1_series[-1], 4) -0.2114 >>> round(theta2_series[-1], 4) -1.3785 pass from solution import double_pendulum_motion def test_double_pendulum_basic(): theta1_series, theta2_series = double_pendulum_motion(0.1, 0.2, 1.0, 1.0, 1.0, 1.0, tf=10, dt=0.01) assert len(theta1_series) == len(theta2_series) assert len(theta1_series) == 1001 assert round(theta1_series[0], 1) == 0.1 assert round(theta2_series[0], 1) == 0.2 def test_double_pendulum_gravity(): theta1_series, theta2_series = double_pendulum_motion(0.1, 0.2, 1.0, 1.0, 1.0, 1.0, g=0, tf=10, dt=0.01) assert len(theta1_series) == len(theta2_series) assert len(theta1_series) == 1001 assert round(theta1_series[0], 1) == 0.1 assert round(theta2_series[0], 1) == 0.2 def test_double_pendulum_length(): theta1_series, theta2_series = double_pendulum_motion(0.1, 0.2, 2.0, 2.0, 1.0, 1.0, tf=10, dt=0.01) assert len(theta1_series) == len(theta2_series) assert len(theta1_series) == 1001 def test_double_pendulum_mass(): theta1_series, theta2_series = double_pendulum_motion(0.1, 0.2, 1.0, 1.0, 2.0, 2.0, tf=10, dt=0.01) assert len(theta1_series) == len(theta2_series) assert len(theta1_series) == 1001 def test_double_pendulum_timesteps(): theta1_series, theta2_series = double_pendulum_motion(0.1, 0.2, 1.0, 1.0, 1.0, 1.0, tf=5, dt=0.1) assert len(theta1_series) == len(theta2_series) assert len(theta1_series) == 51","solution":"import numpy as np def double_pendulum_motion(theta1, theta2, length1, length2, mass1, mass2, g=9.81, t0=0.0, tf=10.0, dt=0.01): Simulate the motion of a double pendulum and return the time series data for the angles. Args: theta1: initial angle of the first pendulum (in radians). theta2: initial angle of the second pendulum (in radians). length1: length of the rod of the first pendulum. length2: length of the rod of the second pendulum. mass1: mass of the first pendulum. mass2: mass of the second pendulum. g: acceleration due to gravity (default 9.81). t0: start time of the simulation (default 0 seconds). tf: end time of the simulation. dt: time step for numerical integration. Returns: A tuple containing two lists: - The angles theta1 over time. - The angles theta2 over time. def derivatives(state, t): theta1, z1, theta2, z2 = state delta = theta2 - theta1 den1 = (mass1 + mass2) * length1 - mass2 * length1 * np.cos(delta) * np.cos(delta) den2 = (length2 / length1) * den1 dz1dt = ((mass2 * length1 * z1 * z1 * np.sin(delta) * np.cos(delta) + mass2 * g * np.sin(theta2) * np.cos(delta) + mass2 * length2 * z2 * z2 * np.sin(delta) - (mass1 + mass2) * g * np.sin(theta1)) / den1) dz2dt = ((-mass2 * length2 * z2 * z2 * np.sin(delta) * np.cos(delta) + (mass1 + mass2) * g * np.sin(theta1) * np.cos(delta) - (mass1 + mass2) * length1 * z1 * z1 * np.sin(delta) - (mass2 + (mass1 + mass2) * g * np.sin(theta2))) / den2) return np.array([z1, dz1dt, z2, dz2dt]) def rk4_step(state, t, dt): k1 = dt * derivatives(state, t) k2 = dt * derivatives(state + 0.5 * k1, t + 0.5 * dt) k3 = dt * derivatives(state + 0.5 * k2, t + 0.5 * dt) k4 = dt * derivatives(state + k3, t + dt) return state + (k1 + 2 * k2 + 2 * k3 + k4) / 6 t_values = np.arange(t0, tf + dt, dt) theta1_values = [] theta2_values = [] state = np.array([theta1, 0, theta2, 0]) for t in t_values: theta1_values.append(state[0]) theta2_values.append(state[2]) state = rk4_step(state, t, dt) return theta1_values, theta2_values"},{"question":"def pascal_triangle_row_sum(n: int) -> int: Computes the sum of the numbers in the nth row of Pascal's Triangle. The sum of the elements in the nth row is 2^n. >>> pascal_triangle_row_sum(0) # Output: 1 >>> pascal_triangle_row_sum(4) # Output: 16 >>> pascal_triangle_row_sum(10) # Output: 1024 >>> pascal_triangle_row_sum(20) # Output: 1048576","solution":"def pascal_triangle_row_sum(n: int) -> int: Computes the sum of the numbers in the nth row of Pascal's Triangle. The sum of the elements in the nth row is 2^n. return 2 ** n"},{"question":"class Record: def __init__(self, attributes: dict): Initialize a record with attributes, which are stored in a dictionary. self.attributes = attributes class Database: def __init__(self): Initialize with an empty dictionary to hold records. self.records = {} def create(self, unique_id: str, record: Record): Add a new record with a unique ID. If the ID already exists, do nothing. # Implement the method def read(self, unique_id: str) -> Record: Fetch and return the record associated with the provided ID. Return None if not found. # Implement the method def update(self, unique_id: str, record: Record): Modify an existing record identified by a unique ID. If the ID does not exist, do nothing. # Implement the method def delete(self, unique_id: str): Remove a record associated with the provided ID. # Implement the method # Example usage: if __name__ == \\"__main__\\": # Define a Record record1 = Record({'name': 'Alice', 'age': '30', 'city': 'New York'}) record2 = Record({'name': 'Bob', 'age': '25', 'city': 'Los Angeles'}) # Initialize the Database db = Database() # Test Create Operation db.create('001', record1) db.create('002', record2) # Test Read Operation print(db.read('001').attributes) # Output: {'name': 'Alice', 'age': '30', 'city': 'New York'} print(db.read('003')) # Output: None # Test Update Operation db.update('001', Record({'name': 'Alice', 'age': '31', 'city': 'Boston'})) print(db.read('001').attributes) # Output: {'name': 'Alice', 'age': '31', 'city': 'Boston'} # Test Delete Operation db.delete('002') print(db.read('002')) # Output: None","solution":"class Record: def __init__(self, attributes): Initialize a record with attributes, which are stored in a dictionary. self.attributes = attributes class Database: def __init__(self): Initialize with an empty dictionary to hold records. self.records = {} def create(self, unique_id, record): Add a new record with a unique ID. If the ID already exists, do nothing. if unique_id not in self.records: self.records[unique_id] = record def read(self, unique_id): Fetch and return the record associated with the provided ID. Return None if not found. return self.records.get(unique_id, None) def update(self, unique_id, record): Modify an existing record identified by a unique ID. If the ID does not exist, do nothing. if unique_id in self.records: self.records[unique_id] = record def delete(self, unique_id): Remove a record associated with the provided ID. if unique_id in self.records: del self.records[unique_id]"},{"question":"def character_frequency_in_conditions(conditions: list[str]) -> dict[str, int]: Determines the frequency of each character in the given list of conditions, ignoring spaces and comparison operators. Parameters: - conditions (list[str]): A list of strings where each string is a condition. Returns: - dict[str, int]: A dictionary where the keys are characters and the values are their frequencies across all conditions in the list. >>> character_frequency_in_conditions([\\"a < b\\", \\"c <= a\\", \\"a == d\\"]) {'a': 3, 'b': 1, 'c': 1, 'd': 1} >>> character_frequency_in_conditions([\\"x != y\\", \\"y > x\\"]) {'x': 2, 'y': 2} >>> character_frequency_in_conditions([\\"p == q\\", \\"q >= r\\", \\"r <= s\\", \\"p != p\\"]) {'p': 3, 'q': 2, 'r': 2, 's': 1}","solution":"def character_frequency_in_conditions(conditions: list[str]) -> dict[str, int]: Determines the frequency of each character in the given list of conditions, ignoring spaces and comparison operators. Parameters: - conditions (list[str]): A list of strings where each string is a condition. Returns: - dict[str, int]: A dictionary where the keys are characters and the values are their frequencies across all conditions in the list. ignore_chars = set(' <=>!') # characters to ignore frequency = {} for condition in conditions: for char in condition: if char not in ignore_chars: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def encode_message(message: str, shift: int) -> str: Encode a message using the Caesar Cipher technique. >>> encode_message(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\" >>> encode_message(\\"abcXYZ\\", -3) \\"xyzUVW\\" >>> encode_message(\\"123! abc! XYZ?@\\", 2) \\"123! cde! ZAB?@\\" >>> encode_message(\\"Hello\\", 52) \\"Hello\\" pass def decode_message(encoded_message: str, shift: int) -> str: Decode a message encoded using the Caesar Cipher technique. >>> decode_message(\\"Mjqqt, Btwqi!\\", 5) \\"Hello, World!\\" >>> decode_message(\\"xyzUVW\\", -3) \\"abcXYZ\\" >>> decode_message(\\"123! cde! ZAB?@\\", 2) \\"123! abc! XYZ?@\\" >>> decode_message(\\"Hello\\", 52) \\"Hello\\" pass","solution":"def encode_message(message: str, shift: int) -> str: def shift_char(c, shift): if c.isalpha(): base = ord('A') if c.isupper() else ord('a') return chr((ord(c) - base + shift) % 26 + base) return c return ''.join(shift_char(c, shift) for c in message) def decode_message(encoded_message: str, shift: int) -> str: return encode_message(encoded_message, -shift)"},{"question":"def k_combinations(nums: list, k: int) -> list: Generates all k-combinations of the given list of numbers. Parameters: nums (list): The list of distinct integers. k (int): The number of elements in each combination. Returns: list: A list of lists where each inner list is a k-combination of the given numbers. >>> k_combinations([1, 2, 3], 2) [[1, 2], [1, 3], [2, 3]] >>> k_combinations([1, 2, 3, 4], 1) [[1], [2], [3], [4]] >>> k_combinations([1, 2, 3], 3) [[1, 2, 3]] >>> k_combinations([1, 2, 3], 0) [[]] >>> k_combinations([], 0) [[]]","solution":"from itertools import combinations def k_combinations(nums: list, k: int) -> list: Generates all k-combinations of the given list of numbers. Parameters: nums (list): The list of distinct integers. k (int): The number of elements in each combination. Returns: list: A list of lists where each inner list is a k-combination of the given numbers. return [list(comb) for comb in combinations(nums, k)]"},{"question":"class SudokuValidator: def __init__(self, grid): self.grid = grid def is_valid(self): Check if the given 9x9 Sudoku grid is a valid solution. >>> sudoku_grid = [ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ] >>> validator = SudokuValidator(sudoku_grid) >>> validator.is_valid() True pass","solution":"class SudokuValidator: def __init__(self, grid): self.grid = grid def is_valid(self): return self._check_rows() and self._check_cols() and self._check_subgrids() def _check_rows(self): for row in self.grid: if not self._is_part_valid(row): return False return True def _check_cols(self): for col in range(9): if not self._is_part_valid([self.grid[row][col] for row in range(9)]): return False return True def _check_subgrids(self): for row in range(0, 9, 3): for col in range(0, 9, 3): if not self._is_part_valid([ self.grid[i][j] for i in range(row, row + 3) for j in range(col, col + 3) ]): return False return True def _is_part_valid(self, part): return sorted(part) == list(range(1, 10))"},{"question":"from typing import List, Tuple def array_operations(arr: List[int], operations: List[Tuple[str, int, int, int]]) -> List[int]: Perform a series of operations on an array and return the final state of the array. >>> array_operations([1, 2, 3, 4, 5], [(\\"update\\", 1, 1, 10), (\\"increment\\", 0, 2, 3), (\\"reverse\\", 1, 3, 0)]) [4, 4, 6, 13, 5] >>> array_operations([], []) [] >>> array_operations([1, 2, 3, 4, 5], [(\\"increment\\", 0, 4, 1), (\\"reverse\\", 0, 4, 0), (\\"update\\", 0, 0, 7)]) [7, 5, 4, 3, 2]","solution":"from typing import List, Tuple def array_operations(arr: List[int], operations: List[Tuple[str, int, int, int]]) -> List[int]: def update(arr: List[int], index: int, value: int): arr[index] = value def increment(arr: List[int], start: int, end: int, value: int): for i in range(start, end + 1): arr[i] += value def reverse(arr: List[int], start: int, end: int): arr[start:end + 1] = arr[start:end + 1][::-1] for op_type, start, end, value in operations: if op_type == \\"update\\": update(arr, start, value) elif op_type == \\"increment\\": increment(arr, start, end, value) elif op_type == \\"reverse\\": reverse(arr, start, end) return arr"},{"question":"def format_name(full_name: str) -> str: Takes a full name string and returns it with properly capitalized names. >>> format_name(\\"joHN doE\\") \\"John Doe\\" >>> format_name(\\"alICE jOnes\\") \\"Alice Jones\\" >>> format_name(\\"marY ANN hopkINS\\") \\"Mary Ann Hopkins\\"","solution":"def format_name(full_name: str) -> str: Takes a full name string and returns it with properly capitalized names. Parameters: - full_name (str): The full name as a string. Returns: - str: The properly capitalized full name. # Split the full name into parts name_parts = full_name.split() # Capitalize each part formatted_parts = [part.capitalize() for part in name_parts] # Join the parts back into a single string formatted_name = \\" \\".join(formatted_parts) return formatted_name"},{"question":"def word_frequencies(text: str) -> dict: Count word frequencies in the given text. :param text: The input text string to analyze. :return: Dictionary of word frequencies. Example Usage: >>> word_frequencies(\\"Hello, world! Hello...\\") {'hello': 2, 'world': 1} >>> word_frequencies(\\"There are 2 apples and 10 bananas.\\") {'there': 1, 'are': 1, '2': 1, 'apples': 1, 'and': 1, '10': 1, 'bananas': 1}","solution":"def word_frequencies(text: str) -> dict: Count word frequencies in the given text. :param text: The input text string to analyze. :return: Dictionary of word frequencies. # Implementation of the function import re from collections import defaultdict # Convert text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r'[,.!?;:]', '', text) # Split the text into words words = text.split() # Initialize a defaultdict to store word frequencies freq_dict = defaultdict(int) # Count each word's frequency for word in words: if word: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"def calculate_trapped_water(heights: List[int]) -> int: Calculate the total amount of water that can be trapped after raining. Args: heights (List[int]): A list of non-negative integers representing the height of each point. Returns: int: Total amount of trapped water. Examples: >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9 >>> calculate_trapped_water([2, 0, 2]) 2 >>> calculate_trapped_water([0, 0, 0]) 0 >>> calculate_trapped_water([5]) 0","solution":"from typing import List def calculate_trapped_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def unique_paths(m: int, n: int) -> int: Determines the number of unique paths in an m x n grid from the top-left corner to the bottom-right corner. >>> unique_paths(3, 7) == 28 >>> unique_paths(3, 2) == 3 >>> unique_paths(7, 3) == 28 >>> unique_paths(3, 3) == 6","solution":"def unique_paths(m: int, n: int) -> int: Determines the number of unique paths in an m x n grid from the top-left corner to the bottom-right corner. :param m: Number of rows in the grid :param n: Number of columns in the grid :return: Number of unique paths # Create a 2D list with all elements initialized to 1 dp = [[1] * n for _ in range(m)] # Populate the table using dynamic programming for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"def min_runes_to_insert(spell: str) -> int: Implement function \`min_runes_to_insert(spell: str) -> int\` which takes a string \`spell\` and returns the minimum number of runes to insert to ensure no two consecutive runes are the same. Args: spell (str): The initial sequence of runes. Returns: int: The minimum number of runes to insert for a potent spell. Raises: ValueError: If the input is not a string. Examples: >>> min_runes_to_insert(\\"aabb\\") 2 >>> min_runes_to_insert(\\"aaaa\\") 3 >>> min_runes_to_insert(\\"abc\\") 0 >>> min_runes_to_insert(\\"\\") 0","solution":"def min_runes_to_insert(spell: str) -> int: Returns the minimum number of runes to insert for a potent spell. Args: spell (str): The initial sequence of runes. Returns: int: The minimum number of runes to insert for a potent spell. Raises: ValueError: If the input is not a string or contains invalid characters. if not isinstance(spell, str): raise ValueError(\\"Input must be a string\\") n = len(spell) if n == 0: return 0 insertions = 0 for i in range(1, n): if spell[i] == spell[i - 1]: insertions += 1 return insertions"},{"question":"def kmp_search(text: str, pattern: str) -> list[int]: Search for all occurrences of a given pattern string within a large text string. >>> kmp_search(\\"ababcabcabababd\\", \\"ababd\\") [10] >>> kmp_search(\\"aaaaaa\\", \\"aa\\") [0, 1, 2, 3, 4] >>> kmp_search(\\"hello world\\", \\"world\\") [6] >>> kmp_search(\\"abcdabcdabcd\\", \\"abcd\\") [0, 4, 8] >>> kmp_search(\\"\\", \\"pattern\\") [] >>> kmp_search(\\"text\\", \\"\\") []","solution":"def kmp_search(text: str, pattern: str) -> list[int]: Returns a list of starting indices where the pattern is found in the text using the Knuth-Morris-Pratt (KMP) algorithm. if not text or not pattern: return [] def compute_lps(pattern: str) -> list[int]: Computes the longest prefix-suffix (LPS) array. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"def is_prime(number: int) -> bool: Determines if the given number is a prime number. Parameters: number (int): The number to check. Returns: bool: True if the number is prime, False otherwise. Example Usage: >>> is_prime(2) True >>> is_prime(15) False >>> is_prime(17) True >>> is_prime(1) False >>> is_prime(-5) False","solution":"def is_prime(number): Determines if the given number is a prime number. Parameters: number (int): The number to check. Returns: bool: True if the number is prime, False otherwise. if number <= 1: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True"},{"question":"def find_closest_match(player_skills: List[int], target_skill: int) -> int: Finds the player with the closest skill level to the target player's skill level. Args: player_skills (List[int]): List of skill levels of other players. target_skill (int): Skill level of the target player. Returns: int: Skill level of the player closest to the target skill level. Examples: >>> find_closest_match([1500, 1700, 1600, 1800, 2000], 1650) 1600 >>> find_closest_match([1500], 1600) 1500 >>> find_closest_match([1500, 1700, 1600, 1800, 2000], 1750) 1700 >>> find_closest_match([1500, 1550, 1650, 1700], 1600) 1550 # Implement the function to find the closest match","solution":"def find_closest_match(player_skills, target_skill): Finds the player with the closest skill level to the target player's skill level. Args: player_skills (List[int]): List of skill levels of other players. target_skill (int): Skill level of the target player. Returns: int: Skill level of the player closest to the target skill level. closest_skill = player_skills[0] min_diff = abs(player_skills[0] - target_skill) for skill in player_skills[1:]: diff = abs(skill - target_skill) if diff < min_diff or (diff == min_diff and skill < closest_skill): closest_skill = skill min_diff = diff return closest_skill"},{"question":"def balance_parentheses(expression: str) -> str: Balances the parentheses in the given expression by adding the minimum number of necessary parentheses. Parameters: expression (str): A string consisting of characters which may include parentheses. Returns: str: A new string where parentheses are balanced by adding the minimum number of necessary parentheses. >>> balance_parentheses(\\"a + (b * c) - (d / e\\") \\"a + (b * c) - (d / e)\\" >>> balance_parentheses(\\"((a+b)\\") \\"((a+b))\\"","solution":"def balance_parentheses(expression: str) -> str: Balances the parentheses in the given expression by adding the minimum number of necessary parentheses. # To keep track of the open parentheses open_parentheses_count = 0 # List to build the corrected expression balanced_expression = [] # Iterate through each character in the input expression for char in expression: if char == '(': open_parentheses_count += 1 elif char == ')': if open_parentheses_count > 0: open_parentheses_count -= 1 else: # An extra closing parenthesis is encountered balanced_expression.append('(') balanced_expression.append(char) # Add the necessary number of closing parentheses at the end balanced_expression.extend(')' * open_parentheses_count) return ''.join(balanced_expression)"},{"question":"def diagonal_sum(mat: List[List[int]]) -> int: Calculate the sum of the matrix diagonals. This includes the primary diagonal (top-left to bottom-right) and the secondary diagonal (top-right to bottom-left). Note that if an element is on both diagonals, it should be counted only once. >>> diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 25 >>> diagonal_sum([ ... [5, -3, 9], ... [2, 10, 7], ... [8, 6, 12] ... ]) 40 >>> diagonal_sum([ ... [1] ... ]) 1 pass","solution":"from typing import List def diagonal_sum(mat: List[List[int]]) -> int: n = len(mat) total_sum = 0 for i in range(n): total_sum += mat[i][i] # Primary diagonal total_sum += mat[i][n - i - 1] # Secondary diagonal # If n is odd, subtract the middle element as it is added twice if n % 2 == 1: total_sum -= mat[n//2][n//2] return total_sum"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: Reverse the nodes of the linked list k at a time and return the modified list. >>> def list_to_array(head): ... array = [] ... while head: ... array.append(head.value) ... head = head.next ... return array >>> ln5 = ListNode(5) >>> ln4 = ListNode(4, ln5) >>> ln3 = ListNode(3, ln4) >>> ln2 = ListNode(2, ln3) >>> ln1 = ListNode(1, ln2) >>> head = reverse_k_group(ln1, 2) >>> list_to_array(head) [2, 1, 4, 3, 5] >>> ln5 = ListNode(5) >>> ln4 = ListNode(4, ln5) >>> ln3 = ListNode(3, ln4) >>> ln2 = ListNode(2, ln3) >>> ln1 = ListNode(1, ln2) >>> head = reverse_k_group(ln1, 3) >>> list_to_array(head) [3, 2, 1, 4, 5] >>> ln3 = ListNode(3) >>> ln2 = ListNode(2, ln3) >>> ln1 = ListNode(1, ln2) >>> head = reverse_k_group(ln1, 4) >>> list_to_array(head) [1, 2, 3] >>> ln4 = ListNode(4) >>> ln3 = ListNode(3, ln4) >>> ln2 = ListNode(2, ln3) >>> ln1 = ListNode(1, ln2) >>> head = reverse_k_group(ln1, 1) >>> list_to_array(head) [1, 2, 3, 4] >>> head = reverse_k_group(None, 2) >>> list_to_array(head) [] >>> ln1 = ListNode(1) >>> head = reverse_k_group(ln1, 2) >>> list_to_array(head) [1]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head cur, nex, pre = head, None, dummy count = 0 while cur: count += 1 cur = cur.next while count >= k: cur = pre.next nex = cur.next for _ in range(1, k): cur.next = nex.next nex.next = pre.next pre.next = nex nex = cur.next pre = cur count -= k return dummy.next"},{"question":"def find_closest_pair(coordinates): Find the closest pair of coordinates among a given set of coordinates. >>> find_closest_pair([(34.0522, -118.2437), (40.7128, -74.0060), (37.7749, -122.4194), (34.0522, -118.2436)]) ((34.0522, -118.2437), (34.0522, -118.2436)) >>> find_closest_pair([(19.4326, -99.1332), (51.5074, -0.1278), (48.8566, 2.3522), (40.4168, -3.7038)]) ((51.5074, -0.1278), (48.8566, 2.3522))","solution":"import math def euclidean_distance(coord1, coord2): return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2) def find_closest_pair(coordinates): if len(coordinates) < 2: raise ValueError(\\"At least two coordinates are required\\") min_distance = float('inf') closest_pair = None for i in range(len(coordinates)): for j in range(i + 1, len(coordinates)): distance = euclidean_distance(coordinates[i], coordinates[j]) if distance < min_distance: min_distance = distance closest_pair = (coordinates[i], coordinates[j]) return closest_pair"},{"question":"def decodeString(s: str) -> str: Decode the given encoded string according to the rule k[encoded_string] where encoded_string inside the square brackets is being repeated exactly k times. Args: s (str): The encoded string. Returns: str: The decoded string. Examples: >>> decodeString(\\"3[a]2[bc]\\") \\"aaabcbc\\" >>> decodeString(\\"3[a2[c]]\\") \\"accaccacc\\" >>> decodeString(\\"2[abc]3[cd]ef\\") \\"abcabccdcdcdef\\" >>> decodeString(\\"10[a]\\") \\"aaaaaaaaaa\\" >>> decodeString(\\"2[3[xy]]\\") \\"xyxyxyxyxyxy\\"","solution":"def decodeString(s: str) -> str: stack = [] current_string = '' current_num = 0 for ch in s: if ch.isdigit(): current_num = current_num * 10 + int(ch) elif ch == '[': stack.append((current_string, current_num)) current_string = '' current_num = 0 elif ch == ']': prev_string, num = stack.pop() current_string = prev_string + num * current_string else: current_string += ch return current_string"},{"question":"def generate_histogram(arr: list) -> dict: Generates a histogram-like count of elements in an array. Parameters: arr (list): A list of integers which may include repetitions. Returns: dict: A dictionary with integers as keys and their respective counts as values. >>> generate_histogram([1, 2, 2, 3, 3, 3, 4]) == {1: 1, 2: 2, 3: 3, 4: 1} >>> generate_histogram([5, 5, 5, 5]) == {5: 4} >>> generate_histogram([]) == {} >>> generate_histogram([-1, -2, -2, -1, -1]) == {-1: 3, -2: 2} >>> generate_histogram([1, -1, 1, -1, 0]) == {1: 2, -1: 2, 0: 1} >>> arr = list(range(1000)) + list(range(500, 1500)) >>> expected_result = {i: 1 for i in range(500)} >>> for i in range(500, 1000): ... expected_result[i] = 2 >>> for i in range(1000, 1500): ... expected_result[i] = 1 >>> generate_histogram(arr) == expected_result","solution":"def generate_histogram(arr: list) -> dict: Generates a histogram-like count of elements in an array. Parameters: arr (list): A list of integers which may include repetitions. Returns: dict: A dictionary with integers as keys and their respective counts as values. histogram = {} for num in arr: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int], allow_repeats: bool) -> int: Determine the length of the longest increasing subsequence within a list of integers, with additional constraints on whether subsequences can include repeated elements or not. If allow_repeats is True, repeated elements can be included in the subsequence. Parameters: arr (List[int]): An array of n integers where 1 ≤ n ≤ 10^4. allow_repeats (bool): A boolean flag that determines if repeated elements are allowed in the subsequence. Returns: int: The length of the longest increasing subsequence. Examples: >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18], False) 4 >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18], True) 4 >>> longest_increasing_subsequence([10, 10, 10, 10], False) 1 >>> longest_increasing_subsequence([10, 10, 10, 10], True) 4 >>> longest_increasing_subsequence([3, 10, 2, 1, 20], False) 3 >>> longest_increasing_subsequence([3, 10, 2, 1, 20], True) 3 >>> longest_increasing_subsequence([], True) 0","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int], allow_repeats: bool) -> int: Returns the length of the longest increasing subsequence. If allow_repeats is True, repeated elements can be included in the subsequence. if not arr: return 0 if allow_repeats: dp = [] for num in arr: if not dp or num >= dp[-1]: dp.append(num) else: # Find the first number larger than num and replace it idx = bisect.bisect_right(dp, num) dp[idx] = num return len(dp) else: dp = [] for num in arr: idx = bisect.bisect_left(dp, num) if idx == len(dp): dp.append(num) else: dp[idx] = num return len(dp)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target_sum: int) -> bool: Determines if the binary tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. >>> tree = TreeNode(5) >>> tree.left = TreeNode(4) >>> tree.right = TreeNode(8) >>> tree.left.left = TreeNode(11) >>> tree.left.left.left = TreeNode(7) >>> tree.left.left.right = TreeNode(2) >>> tree.right.left = TreeNode(13) >>> tree.right.right = TreeNode(4) >>> tree.right.right.right = TreeNode(1) >>> has_path_sum(tree, 22) True >>> has_path_sum(tree, 26) True >>> has_path_sum(tree, 18) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): if not root: return False target_sum -= root.val if not root.left and not root.right: # if it's a leaf node return target_sum == 0 return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum)"},{"question":"def common_divisors_count(a: int, b: int) -> int: Returns the count of common divisors of two given positive integers a and b. >>> common_divisors_count(12, 18) == 4 >>> common_divisors_count(100, 75) == 3 >>> common_divisors_count(36, 60) == 6 >>> common_divisors_count(7, 14) == 2 >>> common_divisors_count(13, 17) == 1 # Coprime numbers have only 1 common divisor which is 1 >>> common_divisors_count(12, 12) == 6 # All divisors of 12: 1, 2, 3, 4, 6, 12 >>> common_divisors_count(10**9, 10**9) == 100 >>> common_divisors_count(1, 23456789) == 1 # Any number with 1 has only one common divisor which is 1","solution":"def common_divisors_count(a: int, b: int) -> int: Returns the count of common divisors of two given positive integers a and b. # Calculate the gcd of a and b def gcd(x, y): while y: x, y = y, x % y return x g = gcd(a, b) # Count the divisors of gcd(a, b) count = 0 for i in range(1, int(g ** 0.5) + 1): if g % i == 0: count += 1 if i != g // i: count += 1 return count"},{"question":"Implement a function named \`reverse_vowels\` which takes a string as input and returns a new string with the vowels reversed. - Input: A string \`s\` consisting of printable ASCII characters. - Output: A new string where the vowels are reversed in order, and all other characters remain in their original positions. - Constraints: * You must handle both uppercase and lowercase vowels. * You should consider edge cases such as an empty string, a string with no vowels, and a string with all vowels. - Performance: The implementation should have a linear time complexity of O(n), where n is the length of the string. Example: 1. Input: \\"hello\\" Output: \\"holle\\" 2. Input: \\"leetcode\\" Output: \\"leotcede\\" 3. Input: \\"aA\\" Output: \\"Aa\\" 4. Input: \\"bcdfgh\\" Output: \\"bcdfgh\\" def reverse_vowels(s: str) -> str: Returns a new string where the vowels in the input string are reversed. vowels = set('aeiouAEIOU') s_list = list(s) i, j = 0, len(s) - 1 while i < j: if s_list[i] not in vowels: i += 1 elif s_list[j] not in vowels: j -= 1 else: s_list[i], s_list[j] = s_list[j], s_list[i] i += 1 j -= 1 return ''.join(s_list) def test_reverse_vowels_simple_case(): assert reverse_vowels(\\"hello\\") == \\"holle\\" assert reverse_vowels(\\"leetcode\\") == \\"leotcede\\" def test_reverse_vowels_all_vowels(): assert reverse_vowels(\\"aeiou\\") == \\"uoiea\\" assert reverse_vowels(\\"aA\\") == \\"Aa\\" def test_reverse_vowels_no_vowels(): assert reverse_vowels(\\"bcdfgh\\") == \\"bcdfgh\\" assert reverse_vowels(\\"xyz\\") == \\"xyz\\" def test_reverse_vowels_mixed_case(): assert reverse_vowels(\\"AEIOUaeiou\\") == \\"uoieaUOIEA\\" assert reverse_vowels(\\"HeLlo\\") == \\"HoLle\\" def test_reverse_vowels_empty_string(): assert reverse_vowels(\\"\\") == \\"\\" def test_reverse_vowels_single_character(): assert reverse_vowels(\\"a\\") == \\"a\\" assert reverse_vowels(\\"b\\") == \\"b\\" def test_reverse_vowels_performance(): large_string = \\"a\\" * 1000000 + \\"b\\" * 1000000 + \\"e\\" * 1000000 reversed_string = \\"e\\" * 1000000 + \\"b\\" * 1000000 + \\"a\\" * 1000000 assert reverse_vowels(large_string) == reversed_string","solution":"def reverse_vowels(s: str) -> str: Returns a new string where the vowels in the input string are reversed. vowels = set('aeiouAEIOU') s_list = list(s) i, j = 0, len(s) - 1 while i < j: if s_list[i] not in vowels: i += 1 elif s_list[j] not in vowels: j -= 1 else: s_list[i], s_list[j] = s_list[j], s_list[i] i += 1 j -= 1 return ''.join(s_list)"},{"question":"from collections import defaultdict from typing import List, Tuple def detect_cycle_dfs(V: int, edges: List[Tuple[int, int]]) -> bool: Detect if there's a cycle in an undirected graph using Depth-First Search (DFS). Parameters: V (int): The number of vertices in the graph. edges (List[Tuple[int, int]]): A list of tuples representing the edges in the graph. Returns: bool: True if there is a cycle, else False. >>> detect_cycle_dfs(5, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)]) True >>> detect_cycle_dfs(4, [(0, 1), (1, 2), (2, 3)]) False >>> detect_cycle_dfs(4, []) False pass # your implementation here def test_no_edges(): assert detect_cycle_dfs(4, []) == False def test_single_cycle(): assert detect_cycle_dfs(3, [(0, 1), (1, 2), (2, 0)]) == True def test_tree_no_cycle(): assert detect_cycle_dfs(5, [(0, 1), (1, 2), (1, 3), (3, 4)]) == False def test_disconnected_graph_with_cycle(): assert detect_cycle_dfs(6, [(0, 1), (1, 2), (2, 0), (3, 4)]) == True def test_disconnected_graph_no_cycle(): assert detect_cycle_dfs(6, [(0, 1), (1, 2), (3, 4)]) == False def test_large_graph_no_cycle(): edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)] assert detect_cycle_dfs(10, edges) == False def test_large_graph_with_cycle(): edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 0)] assert detect_cycle_dfs(10, edges) == True","solution":"def detect_cycle_dfs(V, edges): from collections import defaultdict def dfs(v, visited, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, visited, v): return True elif neighbor != parent: return True return False # Build the graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * V for vertex in range(V): if not visited[vertex]: if dfs(vertex, visited, -1): return True return False"},{"question":"def remove_duplicates(s: str) -> str: Returns a new string with all duplicate characters removed from the input string s. The function maintains the order of characters as they first appear in the input string. Parameters: s (str): A string of lowercase and uppercase English letters. Returns: str: A new string with duplicates removed. Raises: TypeError: If s is not a string. Examples: >>> remove_duplicates(\\"banana\\") 'ban' >>> remove_duplicates(\\"hello\\") 'helo' >>> remove_duplicates(\\"abcdabcd\\") 'abcd' >>> remove_duplicates(\\"aAaAaA\\") 'aA' >>> remove_duplicates(\\"\\") ''","solution":"def remove_duplicates(s: str) -> str: Returns a new string with all duplicate characters removed from the input string s. The function maintains the order of characters as they first appear in the input string. Parameters: s (str): A string of lowercase and uppercase English letters. Returns: str: A new string with duplicates removed. Raises: TypeError: If s is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def find_first_occurrence(arr, target): Find the index of the first occurrence of target in a sorted list. :param arr: Sorted list of integers :param target: Integer value to search for :return: Index of the first occurrence of target, or -1 if not found >>> find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) 1 >>> find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 3) 4 >>> find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 5) 6 >>> find_first_occurrence([1, 2, 3, 4, 5, 6, 7], 8) -1 >>> find_first_occurrence([], 2) -1 >>> find_first_occurrence([1, 3, 5, 7, 9], 2) -1 >>> find_first_occurrence([2, 2, 2], 2) 0 >>> find_first_occurrence([1, 2, 3, 4, 5, 5, 5], 5) 4 pass","solution":"def find_first_occurrence(arr, target): Find the index of the first occurrence of target in a sorted list. :param arr: Sorted list of integers :param target: Integer value to search for :return: Index of the first occurrence of target, or -1 if not found left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: result = mid right = mid - 1 # Move left to find the first occurrence elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"def is_strong_password(password: str) -> bool: Evaluates the strength of a password based on given criteria. A password is considered strong if it satisfies all the following conditions: 1. It has at least 8 characters. 2. It contains at least one uppercase letter. 3. It contains at least one lowercase letter. 4. It contains at least one digit. 5. It contains at least one special character from the set: !@#%^&*()-+ :param password: str - The password to evaluate. :return: bool - True if the password is strong, False otherwise. >>> is_strong_password(\\"Aa1@strong\\") True >>> is_strong_password(\\"weak\\") False >>> is_strong_password(\\"Aa1@\\") False >>> is_strong_password(\\"Aa1abcdefg@\\") True","solution":"def is_strong_password(password: str) -> bool: Evaluates the strength of a password based on given criteria. A password is considered strong if it satisfies all the following conditions: 1. It has at least 8 characters. 2. It contains at least one uppercase letter. 3. It contains at least one lowercase letter. 4. It contains at least one digit. 5. It contains at least one special character from the set: !@#%^&*()-+ :param password: str - The password to evaluate. :return: bool - True if the password is strong, False otherwise. if len(password) < 8: return False has_upper = any(char.isupper() for char in password) has_lower = any(char.islower() for char in password) has_digit = any(char.isdigit() for char in password) has_special = any(char in \\"!@#%^&*()-+\\" for char in password) return has_upper and has_lower and has_digit and has_special"},{"question":"import numpy as np def min_max_normalize(data: np.ndarray) -> np.ndarray: Apply Min-Max normalization to the data. >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> min_max_normalize(data) array([[0. , 0. ], [0.5, 0.5], [1. , 1. ]]) def z_score_standardize(data: np.ndarray) -> np.ndarray: Apply Z-score standardization to the data. >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> z_score_standardize(data).mean(axis=0) array([0., 0.]) >>> z_score_standardize(data).std(axis=0) array([1., 1.]) class PCA: def __init__(self, n_components: int): self.n_components = n_components self.mean = None self.components = None def fit(self, data: np.ndarray): Fit the data using PCA, finding the principal components. >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> pca = PCA(n_components=1) >>> pca.fit(data) def transform(self, data: np.ndarray) -> np.ndarray: Transform the data to the principal component space. >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> pca = PCA(n_components=1) >>> pca.fit(data) >>> transformed = pca.transform(data) >>> transformed.shape (3, 1) def preprocess_data(data: np.ndarray, n_components: int, normalization: str) -> np.ndarray: Integrate normalization and PCA to preprocess the data. >>> data = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]) >>> preprocess_data(data, n_components=1, normalization='min_max').shape (4, 1) >>> preprocess_data(data, n_components=1, normalization='z_score').shape (4, 1) >>> try: ... preprocess_data(data, n_components=1, normalization='invalid') ... except ValueError as e: ... str(e) == \\"Normalization method must be 'min_max' or 'z_score'.\\"","solution":"import numpy as np def min_max_normalize(data: np.ndarray) -> np.ndarray: Apply Min-Max normalization to the data. min_val = np.min(data, axis=0) max_val = np.max(data, axis=0) return (data - min_val) / (max_val - min_val) def z_score_standardize(data: np.ndarray) -> np.ndarray: Apply Z-score standardization to the data. mean = np.mean(data, axis=0) std_dev = np.std(data, axis=0) return (data - mean) / std_dev class PCA: def __init__(self, n_components: int): self.n_components = n_components self.mean = None self.components = None def fit(self, data: np.ndarray): Fit the data using PCA, finding the principal components. self.mean = np.mean(data, axis=0) data_centered = data - self.mean covariance_matrix = np.cov(data_centered, rowvar=False) eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix) sorted_indices = np.argsort(eigenvalues)[::-1] self.components = eigenvectors[:, sorted_indices[:self.n_components]] def transform(self, data: np.ndarray) -> np.ndarray: Transform the data to the principal component space. data_centered = data - self.mean return np.dot(data_centered, self.components) def preprocess_data(data: np.ndarray, n_components: int, normalization: str) -> np.ndarray: Integrate normalization and PCA to preprocess the data. if normalization == 'min_max': normalized_data = min_max_normalize(data) elif normalization == 'z_score': normalized_data = z_score_standardize(data) else: raise ValueError(\\"Normalization method must be 'min_max' or 'z_score'.\\") pca = PCA(n_components) pca.fit(normalized_data) return pca.transform(normalized_data)"},{"question":"import re def generate_log_report(file_path: str) -> dict: Reads a log file, parses its content to extract key information, and returns a dictionary summarizing the data. Parameters: file_path (str): The path to the log file. Returns: dict: A dictionary containing the summary of the log with the following structure: - total_requests: Total number of log entries. - requests_by_status: A dictionary where keys are status codes and values are the number of requests with that status. - ip_addresses: A list of unique IP addresses that made requests. Example: >>> generate_log_report(\\"path/to/logfile.log\\") { \\"total_requests\\": 3, \\"requests_by_status\\": { \\"200\\": 2, \\"404\\": 1 }, \\"ip_addresses\\": [\\"192.168.1.1\\", \\"192.168.1.2\\"] } import pytest from solution import generate_log_report def test_generate_log_report_with_valid_file(tmp_path): log_content = 192.168.1.1 - - [01/Jan/2022:10:00:00] \\"GET /index.html HTTP/1.1\\" 200 1024 192.168.1.2 - - [01/Jan/2022:10:01:00] \\"POST /submit HTTP/1.1\\" 404 512 192.168.1.1 - - [01/Jan/2022:10:02:00] \\"GET /about.html HTTP/1.1\\" 200 2048 log_file = tmp_path / \\"test_log.log\\" log_file.write_text(log_content) expected_report = { \\"total_requests\\": 3, \\"requests_by_status\\": { \\"200\\": 2, \\"404\\": 1 }, \\"ip_addresses\\": [\\"192.168.1.1\\", \\"192.168.1.2\\"] } assert generate_log_report(log_file) == expected_report def test_generate_log_report_with_no_log_entries(tmp_path): log_file = tmp_path / \\"empty_log.log\\" log_file.write_text(\\"\\") expected_report = { \\"total_requests\\": 0, \\"requests_by_status\\": {}, \\"ip_addresses\\": [] } assert generate_log_report(log_file) == expected_report def test_generate_log_report_with_file_not_found(): with pytest.raises(FileNotFoundError): generate_log_report(\\"non_existent_file.log\\")","solution":"import re def generate_log_report(file_path: str) -> dict: report = { \\"total_requests\\": 0, \\"requests_by_status\\": {}, \\"ip_addresses\\": set() } log_entry_pattern = re.compile( r'(?P<ip>[d.]+)s+-s+-s+[.+?]s+\\".+?\\"s+(?P<status>d+)s+d+' ) try: with open(file_path, 'r') as file: for line in file: report[\\"total_requests\\"] += 1 match = log_entry_pattern.match(line) if match: ip = match.group('ip') status = match.group('status') report[\\"ip_addresses\\"].add(ip) if status in report[\\"requests_by_status\\"]: report[\\"requests_by_status\\"][status] += 1 else: report[\\"requests_by_status\\"][status] = 1 except FileNotFoundError: raise FileNotFoundError(f\\"The file at path {file_path} was not found.\\") report[\\"ip_addresses\\"] = list(report[\\"ip_addresses\\"]) return report"},{"question":"class MinStack: def __init__(self) -> None: Initialize your data structure here. pass def push(self, val: int) -> None: Push element val onto stack. pass def pop(self) -> None: Removes the element on the top of the stack. pass def top(self) -> int: Get the top element. pass def getMin(self) -> int: Retrieve the minimum element in the stack. pass # Example Usage: # minStack = MinStack() # minStack.push(-2) # minStack.push(0) # minStack.push(-3) # print(minStack.getMin()) # Output: -3 # minStack.pop() # print(minStack.top()) # Output: 0 # print(minStack.getMin()) # Output: -2","solution":"class MinStack: def __init__(self) -> None: Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Push element val onto stack, and update the min stack. self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Removes the element on the top of the stack, and update the min stack. if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] raise IndexError(\\"top from empty stack\\") def getMin(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1] raise IndexError(\\"getMin from empty stack\\")"},{"question":"class LogManagement: def __init__(self, logs): Initializes the LogManagement instance with a list of logs. :param logs: List of integers representing log timestamps. self.logs = logs def find_kth_recent(self, k): Returns the k-th most recent log timestamp. :param k: 1-based index indicating the k-th most recent log to find. :return: Integer timestamp of the k-th most recent log or None if k is out of bounds. >>> logs = LogManagement([1587888888, 1587887890, 1587888999, 1587890000]) >>> logs.find_kth_recent(1) 1587890000 >>> logs.find_kth_recent(3) 1587887890 >>> logs.find_kth_recent(5) None from solution import LogManagement def test_find_kth_recent(): logs = LogManagement([1587888888, 1587887890, 1587888999, 1587890000]) assert logs.find_kth_recent(1) == 1587890000 # Most recent assert logs.find_kth_recent(2) == 1587888999 # 2nd most recent assert logs.find_kth_recent(3) == 1587887890 # 3rd most recent assert logs.find_kth_recent(4) == 1587888888 # 4th most recent assert logs.find_kth_recent(5) == None # Out of bounds def test_find_kth_recent_empty_logs(): logs = LogManagement([]) assert logs.find_kth_recent(1) == None def test_find_kth_recent_invalid_k(): logs = LogManagement([1587888888, 1587887890]) assert logs.find_kth_recent(0) == None assert logs.find_kth_recent(-1) == None def test_find_kth_recent_single_log(): logs = LogManagement([1587888888]) assert logs.find_kth_recent(1) == 1587888888 assert logs.find_kth_recent(2) == None","solution":"class LogManagement: def __init__(self, logs): Initializes the LogManagement instance with a list of logs. :param logs: List of integers representing log timestamps. self.logs = logs def find_kth_recent(self, k): Returns the k-th most recent log timestamp. :param k: 1-based index indicating the k-th most recent log to find. :return: Integer timestamp of the k-th most recent log or None if k is out of bounds. if k <= 0 or k > len(self.logs): return None return self.logs[-k]"},{"question":"def find_missing_number(arr: List[int]) -> int: Returns the missing number from the array containing distinct numbers from the 0, 1, 2, ..., n set. Parameters: arr (List[int]): The list containing n distinct numbers from the set. Returns: int: The missing number from the array. Raises: ValueError: If the input array does not meet the requirements. TypeError: If the input is not a list. Examples: >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9,6,4,2,3,5,7,0,1]) 8","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Returns the missing number from the array containing distinct numbers from the 0, 1, 2, ..., n set. Parameters: arr (List[int]): The list containing n distinct numbers from the set. Returns: int: The missing number from the array. n = len(arr) expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"def calculate_median(distances: list[int]) -> float: Calculates the median of a list of integers representing travel distances. Args: distances: A list of integers representing travel distances. Returns: float: The median value. >>> calculate_median([300, 600, 700, 200, 100]) 300.0 >>> calculate_median([200, 300, 600, 700]) 450.0 >>> calculate_median([100, 200, 300]) 200.0 >>> calculate_median([900]) 900.0 >>> calculate_median([50, 100, 150, 200, 250, 300, 350]) 200.0","solution":"def calculate_median(distances): Calculates the median of a list of integers representing travel distances. Args: distances: A list of integers representing travel distances. Returns: float: The median value. sorted_distances = sorted(distances) n = len(sorted_distances) mid = n // 2 if n % 2 == 1: # Odd number of elements, return the middle one return float(sorted_distances[mid]) else: # Even number of elements, return the average of the two middle ones return (sorted_distances[mid - 1] + sorted_distances[mid]) / 2"},{"question":"from typing import List def sort_and_deduplicate(strings: List[str]) -> List[str]: Removes duplicates from the input list and returns a sorted list. Parameters: strings (List[str]): A list of strings that may contain duplicates. Returns: List[str]: A sorted list of strings with duplicates removed. Example usage: >>> sort_and_deduplicate([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\"]) ['apple', 'banana', 'orange'] >>> sort_and_deduplicate([\\"zebra\\", \\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"kiwi\\"]) ['apple', 'banana', 'kiwi', 'zebra']","solution":"from typing import List def sort_and_deduplicate(strings: List[str]) -> List[str]: Removes duplicates from the input list and returns a sorted list. Parameters: strings (List[str]): A list of strings that may contain duplicates. Returns: List[str]: A sorted list of strings with duplicates removed. return sorted(set(strings))"},{"question":"class CircularBuffer: def __init__(self, size: int): Initializes a circular buffer with the given size. pass def add(self, value: int) -> None: Adds a new element to the buffer. If the buffer is full, it should resize to accommodate the new element. pass def remove(self) -> int: Removes and returns the oldest element from the buffer. If the buffer is empty, it should return -1 or raise an appropriate exception. pass def resize(self, new_size: int) -> None: Resizes the buffer to the new size, preserving the current data. pass def get_buffer(self) -> list[int]: Returns the current state of the buffer as a list of integers. pass def test_circular_buffer_operations(): buffer = CircularBuffer(3) buffer.add(1) buffer.add(2) print(buffer.get_buffer()) # Output: [1, 2] buffer.add(3) print(buffer.get_buffer()) # Output: [1, 2, 3] buffer.add(4) # Buffer is full, should resize print(buffer.get_buffer()) # Output: [1, 2, 3, 4] removed = buffer.remove() print(removed) # Output: 1 print(buffer.get_buffer()) # Output: [2, 3, 4] buffer.resize(6) print(buffer.get_buffer()) # Output: [2, 3, 4] buffer.add(5) buffer.add(6) buffer.add(7) print(buffer.get_buffer()) # Output: [2, 3, 4, 5, 6, 7]","solution":"class CircularBuffer: def __init__(self, size: int): self.size = size self.buffer = [None] * size self.read_pointer = 0 self.write_pointer = 0 self.count = 0 def add(self, value: int) -> None: if self.count == self.size: self.resize(self.size * 2) self.buffer[self.write_pointer] = value self.write_pointer = (self.write_pointer + 1) % self.size self.count += 1 def remove(self) -> int: if self.count == 0: raise IndexError(\\"remove from empty buffer\\") value = self.buffer[self.read_pointer] self.buffer[self.read_pointer] = None self.read_pointer = (self.read_pointer + 1) % self.size self.count -= 1 return value def resize(self, new_size: int) -> None: new_buffer = [None] * new_size for i in range(self.count): new_buffer[i] = self.buffer[(self.read_pointer + i) % self.size] self.buffer = new_buffer self.size = new_size self.read_pointer = 0 self.write_pointer = self.count def get_buffer(self) -> list: return [self.buffer[(self.read_pointer + i) % self.size] for i in range(self.count)]"},{"question":"from typing import List, Tuple def split_rgb(image: List[List[Tuple[int, int, int]]]) -> Tuple[List[List[int]], List[List[int]], List[List[int]]]: Splits an RGB image into its respective red, green, and blue channels. :param image: The input RGB image as a 2D list, with each element being a tuple (R, G, B) :return: Three 2D lists representing the red, green, and blue channels respectively. >>> image = [ ... [(255, 0, 0), (0, 255, 0), (0, 0, 255)], ... [(123, 123, 123), (76, 89, 90), (12, 34, 56)] ... ] >>> r_channel, g_channel, b_channel = split_rgb(image) >>> r_channel [ [255, 0, 0], [123, 76, 12] ] >>> g_channel [ [0, 255, 0], [123, 89, 34] ] >>> b_channel [ [0, 0, 255], [123, 90, 56] ]","solution":"from typing import List, Tuple def split_rgb(image: List[List[Tuple[int, int, int]]]) -> Tuple[List[List[int]], List[List[int]], List[List[int]]]: Splits an RGB image into its respective red, green, and blue channels. :param image: The input RGB image as a 2D list, with each element being a tuple (R, G, B) :return: Three 2D lists representing the red, green, and blue channels respectively m = len(image) n = len(image[0]) r_channel = [[0] * n for _ in range(m)] g_channel = [[0] * n for _ in range(m)] b_channel = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): r, g, b = image[i][j] r_channel[i][j] = r g_channel[i][j] = g b_channel[i][j] = b return r_channel, g_channel, b_channel"},{"question":"from typing import List class Parentheses: def __init__(self, brackets: List[str]): Initialize with a list of brackets. >>> Parentheses(['(', ')', '(', '(', ')', ')']).longest_valid_substring() # 6 >>> Parentheses(['(', ')', '(', ')']).is_valid(['(', ')', '(']) # False def longest_valid_substring(self) -> int: Compute the length of the longest valid parentheses substring. >>> Parentheses(['(', ')', ')', '(', ')']).longest_valid_substring() # 2 >>> Parentheses(['(', '(', '(', '(', '(', '(', '(', ')', ')', ')', ')', ')', ')']).longest_valid_substring() # 12 @staticmethod def is_valid(exp: List[str]) -> bool: Check if a given expression is valid. >>> Parentheses.is_valid(['(', ')', '(', ')']) # True >>> Parentheses.is_valid(['(', ')', '(', ')', ')']) # False","solution":"from typing import List class Parentheses: def __init__(self, brackets: List[str]): self.brackets = brackets def longest_valid_substring(self) -> int: max_length = 0 stack = [-1] for i, char in enumerate(self.brackets): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length @staticmethod def is_valid(exp: List[str]) -> bool: balance = 0 for char in exp: if char == '(': balance += 1 else: balance -= 1 if balance < 0: return False return balance == 0"},{"question":"def shift_left(arr: list, shifts: int) -> list: Shifts the elements of \`arr\` to the left by \`shifts\` positions. Parameters: arr (list): The list of integers to be shifted. shifts (int): The number of positions to shift the list. Returns: list: The list after being shifted to the left. Examples: >>> shift_left([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> shift_left([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> shift_left([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5]","solution":"def shift_left(arr: list, shifts: int) -> list: Shifts the elements of \`arr\` to the left by \`shifts\` positions. Parameters: arr (list): The list of integers to be shifted. shifts (int): The number of positions to shift the list. Returns: list: The list after being shifted to the left. n = len(arr) if n == 0: return arr shifts = shifts % n # Simplify shifts if greater than the length of the list return arr[shifts:] + arr[:shifts]"},{"question":"def fibonacci_recursive(n: int) -> int: Calculate the n-th term in the Fibonacci sequence using recursion. >>> fibonacci_recursive(0) 0 >>> fibonacci_recursive(7) 13 # Implementation here def fibonacci_iterative(n: int) -> int: Calculate the n-th term in the Fibonacci sequence using an iterative approach. >>> fibonacci_iterative(0) 0 >>> fibonacci_iterative(7) 13 >>> fibonacci_iterative(30) 832040 # Implementation here","solution":"def fibonacci_recursive(n): Calculate the n-th term in the Fibonacci sequence using recursion. if n <= 1: return n else: return fibonacci_recursive(n-1) + fibonacci_recursive(n-2) def fibonacci_iterative(n): Calculate the n-th term in the Fibonacci sequence using an iterative approach. if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def character_frequency(string: str) -> dict: Returns the frequency of each character in the string. >>> character_frequency(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> character_frequency(\\"a b c\\") {'a': 1, ' ': 2, 'b': 1, 'c': 1} >>> character_frequency(\\"\\") {} >>> character_frequency(\\"!!!@\\") {'!': 3, '@': 1, '#': 2} >>> character_frequency(\\"aA\\") {'a': 1, 'A': 1} pass def reconstruct_string(char_freq: dict) -> str: Reconstructs a string based on the given character frequency dictionary. >>> reconstruct_string({'h': 1, 'e': 1, 'l': 2, 'o': 1}) \\"hello\\" >>> reconstruct_string({'a': 1, ' ': 2, 'b': 1, 'c': 1}) \\"a bc\\" >>> reconstruct_string({}) \\"\\" >>> reconstruct_string({'!': 3, '@': 1, '#': 2}) \\"!!!@\\" >>> reconstruct_string({'a': 1, 'A': 1}) \\"aA\\" if not isinstance(char_freq, dict): raise ValueError(\\"Input must be a dictionary.\\") reconstructed = [] for char, freq in char_freq.items(): if not isinstance(freq, int) or freq < 0: raise ValueError(\\"Frequencies must be non-negative integers.\\") reconstructed.append(char * freq) return ''.join(reconstructed) pass","solution":"def character_frequency(string: str) -> dict: Returns the frequency of each character in the string. frequency = {} for char in string: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency def reconstruct_string(char_freq: dict) -> str: Reconstructs a string based on the given character frequency dictionary. if not isinstance(char_freq, dict): raise ValueError(\\"Input must be a dictionary.\\") reconstructed = [] for char, freq in char_freq.items(): if not isinstance(freq, int) or freq < 0: raise ValueError(\\"Frequencies must be non-negative integers.\\") reconstructed.append(char * freq) return ''.join(reconstructed)"},{"question":"def sum_of_distinct_powers(n: int) -> List[int]: Returns a list of integers such that each integer in the list represents a power of 2 (i.e., a number of the form 2^i) and their sum equals \`n\`. The numbers in the list should be in ascending order. Parameters ---------- n : int The target sum (1 ≤ n ≤ 10^9). Returns ------- List[int] A list of integers representing powers of 2 that sum up to \`n\`, sorted in ascending order. Examples -------- >>> sum_of_distinct_powers(13) [1, 4, 8] >>> sum_of_distinct_powers(23) [1, 2, 4, 16] >>> sum_of_distinct_powers(31) [1, 2, 4, 8, 16]","solution":"from typing import List def sum_of_distinct_powers(n: int) -> List[int]: Returns a list of distinct powers of 2 that sum up to n. powers = [] power = 1 while n > 0: if n & 1: powers.append(power) power <<= 1 n >>= 1 return powers"},{"question":"def longest_consecutive_sequence(array: list[int]) -> int: Determines the longest sequence of consecutive integers in an unsorted array. Parameters: array (list[int]): The array of integers. Returns: int: The length of the longest sequence of consecutive integers. Examples: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, -1, 1, 2, -2, -3, 3, 4, -4]) 9 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([5, 5, 5, 5]) 1 >>> longest_consecutive_sequence([-1, -2, -3, -4, -5]) 5 >>> longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2, 19]) 4 pass","solution":"def longest_consecutive_sequence(array): Returns the length of the longest sequence of consecutive integers. if not array: return 0 num_set = set(array) max_length = 0 for num in array: if num - 1 not in num_set: # Only check for the beginning of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def preprocess_and_query(prices: List[int], queries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Preprocesses the prices list for efficient range minimum and maximum queries. :param prices: List of stock prices. :param queries: List of tuples representing the range queries. :return: List of tuples containing the minimum and maximum prices for each query. >>> preprocess_and_query([100, 180, 260, 310, 40, 535, 695], [(0, 2)]) [(100, 260)] >>> preprocess_and_query([100, 180, 260, 310, 40, 535, 695], [(0, 2), (1, 5), (3, 6)]) [(100, 260), (40, 535), (40, 695)] >>> preprocess_and_query([10, 9, 8, 7, 6, 5, 4], [(0, 3), (2, 6), (0, 6)]) [(7, 10), (4, 8), (4, 10)]","solution":"from typing import List, Tuple def preprocess_and_query(prices: List[int], queries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Preprocesses the prices list for efficient range minimum and maximum queries. :param prices: List of stock prices. :param queries: List of tuples representing the range queries. :return: List of tuples containing the minimum and maximum prices for each query. n = len(prices) if n == 0: return [(None, None)] * len(queries) LOG = n.bit_length() min_table = [[0] * LOG for _ in range(n)] max_table = [[0] * LOG for _ in range(n)] for i in range(n): min_table[i][0] = prices[i] max_table[i][0] = prices[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: min_table[i][j] = min(min_table[i][j - 1], min_table[i + (1 << (j - 1))][j - 1]) max_table[i][j] = max(max_table[i][j - 1], max_table[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 def query(l, r): j = (r - l + 1).bit_length() - 1 min_val = min(min_table[l][j], min_table[r - (1 << j) + 1][j]) max_val = max(max_table[l][j], max_table[r - (1 << j) + 1][j]) return min_val, max_val result = [] for l, r in queries: result.append(query(l, r)) return result"},{"question":"# Subsequence Finder Complete the function \`is_subsequence\` which determines if the second string is a subsequence of the first string. def is_subsequence(s: str, t: str) -> bool: Determines if t is a subsequence of s. Args: s (str): The source string. t (str): The target subsequence string. Returns: bool: True if t is a subsequence of s, False otherwise. it = iter(s) return all(char in it for char in t) You can test your implementation using the following test cases: from solution import is_subsequence def test_subsequence_present(): assert is_subsequence('abcde', 'ace') == True assert is_subsequence('ahbgdc', 'abc') == True def test_subsequence_not_present(): assert is_subsequence('abcde', 'aec') == False assert is_subsequence('axc', 'ahbgdc') == False def test_empty_subsequence(): assert is_subsequence('abcde', '') == True assert is_subsequence('', '') == True def test_empty_source(): assert is_subsequence('', 'a') == False def test_subsequence_same_as_source(): assert is_subsequence('abc', 'abc') == True def test_large_input(): s = 'a' * 1000 t = 'a' * 1000 assert is_subsequence(s, t) == True t = 'a' * 999 + 'b' assert is_subsequence(s, t) == False","solution":"def is_subsequence(s: str, t: str) -> bool: Determines if t is a subsequence of s. Args: s (str): The source string. t (str): The target subsequence string. Returns: bool: True if t is a subsequence of s, False otherwise. it = iter(s) return all(char in it for char in t)"},{"question":"from typing import List def is_valid_tictactoe_state(board: List[str]) -> bool: Determine whether a given tic-tac-toe board configuration is a valid state. >>> is_valid_tictactoe_state([\\"XOX\\", \\" X \\", \\" O \\"]) True >>> is_valid_tictactoe_state([\\"XXX\\", \\"OOO\\", \\" \\"]) False","solution":"from typing import List def is_valid_tictactoe_state(board: List[str]) -> bool: Determines if a given tic-tac-toe board configuration is a valid state. def check_winner(player: str) -> bool: # Check rows, columns and diagonals for a win return any([ all(cell == player for cell in row) for row in board ]) or any([ all(board[row][col] == player for row in range(3)) for col in range(3) ]) or all([ board[i][i] == player for i in range(3) ]) or all([ board[i][2 - i] == player for i in range(3) ]) # Count X's and O's x_count = sum(row.count('X') for row in board) o_count = sum(row.count('O') for row in board) if o_count > x_count: return False if x_count > o_count + 1: return False x_wins = check_winner('X') o_wins = check_winner('O') if x_wins and o_wins: return False if x_wins and x_count != o_count + 1: return False if o_wins and x_count != o_count: return False return True"},{"question":"from typing import List, Union def find_second_largest(nums: List[int]) -> Union[int, None]: Returns the second largest unique integer in the list. If there is no such element, returns None. >>> find_second_largest([4, 2, 1, 3, 3, 1, 4]) 3 >>> find_second_largest([10, 20, 20, 10]) 10 >>> find_second_largest([1]) None >>> find_second_largest([-5, 0, -3, -4]) -3 >>> find_second_largest([]) None","solution":"from typing import List, Union def find_second_largest(nums: List[int]) -> Union[int, None]: Returns the second largest unique integer in the list. If there is no such element, returns None. if len(nums) < 2: return None unique_nums = set(nums) if len(unique_nums) < 2: return None unique_nums = list(unique_nums) unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"def filter_and_sort_odds(num_str): Parses a string containing space-separated integers, filters out the even numbers, and returns the remaining odd numbers in ascending order. :param num_str: str : A string containing space-separated integers. :return: list of int : The odd integers in ascending order. >>> filter_and_sort_odds(\\"10 15 20 25 30\\") [15, 25] >>> filter_and_sort_odds(\\" 1 2 3 4 5 \\") [1, 3, 5] >>> filter_and_sort_odds(\\"2 4 6 8 10\\") [] >>> filter_and_sort_odds(\\"\\") [] >>> filter_and_sort_odds(\\"abc def ghi\\") [] >>> filter_and_sort_odds(\\"99 -101 303 202\\") [-101, 99, 303]","solution":"def filter_and_sort_odds(num_str): Parses a string containing space-separated integers, filters out the even numbers, and returns the remaining odd numbers in ascending order. :param num_str: str : A string containing space-separated integers. :return: list of int : The odd integers in ascending order. # Split the string into potential integer substrings potential_integers = num_str.strip().split() # Filter and keep only the odd integers odd_numbers = [] for item in potential_integers: try: num = int(item) if num % 2 != 0: odd_numbers.append(num) except ValueError: continue # Return the sorted list of odd numbers return sorted(odd_numbers)"},{"question":"def trap_water(heights: list[int]) -> int: Calculate how much water would be trapped between buildings after it rains. >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([1, 1, 1, 1, 1]) 0 >>> trap_water([0, 0, 0, 0]) 0 >>> trap_water([5, 4, 1, 2]) 1","solution":"def trap_water(heights): if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"def shortest_path(maze, start, target): Determines the shortest path from the starting position to the target position in a maze using the Breadth-First Search (BFS) algorithm. >>> maze = [ ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [1, 0, 0, 0] ... ] >>> start = (0, 0) >>> target = (3, 3) >>> shortest_path(maze, start, target) 6 >>> maze = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(maze, start, target) -1 >>> maze = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(maze, start, target) -1 >>> maze = [ ... [0, 0, 1], ... [0, 0, 0], ... [1, 0, 0] ... ] >>> start = (1, 1) >>> target = (1, 1) >>> shortest_path(maze, start, target) 0","solution":"def shortest_path(maze, start, target): from collections import deque rows, cols = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if maze[start[0]][start[1]] == 1 or maze[target[0]][target[1]] == 1: return -1 if start == target: return 0 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: row, col, distance = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and maze[new_row][new_col] == 0: if (new_row, new_col) == target: return distance + 1 queue.append((new_row, new_col, distance + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def longest_palindrome(s: str) -> str: Find the longest palindromic substring in a given string. >>> longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindrome(\\"cbbd\\") == \\"bb\\" True pass def count_palindromic_substrings(s: str) -> int: Count all unique palindromic substrings within the given string. >>> count_palindromic_substrings(\\"aaa\\") == 6 # \\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aaa\\" True >>> count_palindromic_substrings(\\"abc\\") == 3 # \\"a\\", \\"b\\", \\"c\\" True pass def replace_palindromic_substring(s: str, old: str, new: str) -> str: Replace all occurrences of a given palindromic substring with another substring. >>> replace_palindromic_substring(\\"ababab\\", \\"aba\\", \\"xyz\\") == \\"xyzbab\\" True >>> replace_palindromic_substring(\\"abcde\\", \\"cdc\\", \\"xyz\\") == \\"abcde\\" # \\"cdc\\" is not found in \\"abcde\\", so no replacement True pass","solution":"def longest_palindrome(s: str) -> str: if len(s) == 0: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes substr1 = expand_around_center(s, i, i) if len(substr1) > len(longest): longest = substr1 # Even length palindromes substr2 = expand_around_center(s, i, i + 1) if len(substr2) > len(longest): longest = substr2 return longest def count_palindromic_substrings(s: str) -> int: def expand_around_center(s, left, right): count = 0 while left >= 0 and right < len(s) and s[left] == s[right]: count += 1 left -= 1 right += 1 return count count = 0 for i in range(len(s)): # Odd length palindromes count += expand_around_center(s, i, i) # Even length palindromes count += expand_around_center(s, i, i + 1) return count def replace_palindromic_substring(s: str, old: str, new: str) -> str: return s.replace(old, new)"},{"question":"def transpose_and_sum(matrix): Transpose the given matrix and calculate the sum of all its elements. Parameters: matrix : list of lists A 2D list (matrix) where each inner list represents a row of the matrix. Returns: float : The sum of all elements in the transposed matrix. Raises: ValueError : If the input is not a list of lists or is not rectangular. pass def test_transpose_and_sum_basic(): assert transpose_and_sum([[1, 2], [3, 4]]) == 10 def test_transpose_and_sum_with_floats(): assert transpose_and_sum([[0.5, -0.5], [-1, 1]]) == 0.0 def test_transpose_and_sum_rectangular(): assert transpose_and_sum([[1, 2, 3], [4, 5, 6]]) == 21 def test_transpose_and_sum_single_element(): assert transpose_and_sum([[1]]) == 1 def test_transpose_and_sum_large_matrix(): assert transpose_and_sum([[1]*100]*100) == 10000 def test_invalid_input_not_a_list_of_lists(): try: transpose_and_sum([1, 2, 3]) except ValueError as e: assert str(e) == \\"Input must be a list of lists.\\" def test_invalid_input_not_rectangular(): try: transpose_and_sum([[1, 2], [3]]) except ValueError as e: assert str(e) == \\"All rows in the matrix must have the same length.\\"","solution":"def transpose_and_sum(matrix): Transpose the given matrix and calculate the sum of all its elements. Parameters: matrix : list of lists A 2D list (matrix) where each inner list represents a row of the matrix. Returns: float : The sum of all elements in the transposed matrix. Raises: ValueError : If the input is not a list of lists or is not rectangular. if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists.\\") row_length = len(matrix[0]) if not all(len(row) == row_length for row in matrix): raise ValueError(\\"All rows in the matrix must have the same length.\\") transposed_matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(row_length)] return sum(sum(row) for row in transposed_matrix)"},{"question":"def find_kth_perfect_number(k: int) -> int: Implement a Python function \`find_kth_perfect_number\` that takes an integer \`k\` and returns the k-th perfect number. A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding itself. Requirements: 1. The function should handle edge cases such as non-positive \`k\`. 2. The function should return -1 for invalid inputs. Examples: >>> find_kth_perfect_number(1) == 6 >>> find_kth_perfect_number(2) == 28 >>> find_kth_perfect_number(3) == 496 >>> find_kth_perfect_number(4) == 8128 >>> find_kth_perfect_number(0) == -1 >>> find_kth_perfect_number(-1) == -1 pass","solution":"def find_divisors(n): Returns a list of proper divisors of n (excluding the number itself). divisors = [] for i in range(1, n // 2 + 1): if n % i == 0: divisors.append(i) return divisors def is_perfect_number(n): Checks if the number n is a perfect number. return sum(find_divisors(n)) == n def find_kth_perfect_number(k): Finds the k-th perfect number. if k <= 0: return -1 perfect_numbers = [] num = 2 # Start checking from the smallest number greater than 1 while len(perfect_numbers) < k: if is_perfect_number(num): perfect_numbers.append(num) num += 1 return perfect_numbers[k-1]"},{"question":"def intersection(set_a: set, set_b: set) -> set: Returns the intersection of two sets. :param set_a: set of integers :param set_b: set of integers :return: A set containing elements that are present in both set_a and set_b >>> intersection({1, 2, 3}, {2, 3, 4}) {2, 3} >>> intersection({1, 2, 3}, {4, 5, 6}) set() >>> intersection({1, 2, 3, 4}, set()) set() >>> intersection({2, 4, 6}, {2, 4, 8, 10}) {2, 4} >>> intersection(3, {2, 3, 4}) Traceback (most recent call last): ... AssertionError: The input value of [set_a=3] is not a set","solution":"def intersection(set_a: set, set_b: set) -> set: Returns the intersection of two sets. :param set_a: set of integers :param set_b: set of integers :return: A set containing elements that are present in both set_a and set_b >>> intersection({1, 2, 3}, {2, 3, 4}) {2, 3} >>> intersection({1, 2, 3}, {4, 5, 6}) set() >>> intersection({1, 2, 3, 4}, set()) set() >>> intersection({2, 4, 6}, {2, 4, 8, 10}) {2, 4} >>> intersection(3, {2, 3, 4}) Traceback (most recent call last): ... AssertionError: The input value of [set_a=3] is not a set assert isinstance(set_a, set), f\\"The input value of [set_a={set_a}] is not a set\\" assert isinstance(set_b, set), f\\"The input value of [set_b={set_b}] is not a set\\" return set_a & set_b"},{"question":"def frog_jump_ways(n: int) -> int: Calculate the number of distinct ways the frog can reach the top of a staircase with n steps. :param n: Number of steps in the staircase :return: Number of distinct ways to reach the top >>> frog_jump_ways(1) 1 >>> frog_jump_ways(2) 2 >>> frog_jump_ways(3) 3 >>> frog_jump_ways(4) 5 >>> frog_jump_ways(5) 8","solution":"def frog_jump_ways(n: int) -> int: Calculate the number of distinct ways the frog can reach the top of a staircase with n steps. :param n: Number of steps in the staircase :return: Number of distinct ways to reach the top if n == 1: return 1 if n == 2: return 2 # Create a list to store the number of ways to reach each step dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"def are_cyclic_permutations(str1: str, str2: str) -> bool: Determines if one string is a cyclic permutation of another. Parameters: - str1 (str): The first string to check. - str2 (str): The second string to check. Returns: - bool: True if str1 and str2 are cyclic permutations of each other, otherwise False. Example: >>> are_cyclic_permutations(\\"abcd\\", \\"dabc\\") True >>> are_cyclic_permutations(\\"abc\\", \\"acb\\") False >>> are_cyclic_permutations(\\"abc\\", \\"\\") False >>> are_cyclic_permutations(\\"\\", \\"abc\\") False >>> are_cyclic_permutations(\\"abc\\", \\"abcd\\") False","solution":"def are_cyclic_permutations(str1: str, str2: str) -> bool: Determines if one string is a cyclic permutation of another. Parameters: - str1: The first string. - str2: The second string. Returns: - True if str1 and str2 are cyclic permutations of each other, otherwise False. # Check if lengths are different if len(str1) != len(str2): return False # Check for empty strings if not str1 or not str2: return False # Concatenate str1 with itself and check if str2 is a substring double_str1 = str1 + str1 return str2 in double_str1"},{"question":"def temperature_conversion(value: float, from_type: str, to_type: str) -> float: Converts temperature from one unit to another. Parameters: value (float): the numeric value to convert. from_type (str): the unit of the input value. to_type (str): the unit of the desired output value. Returns: float: converted value. Raises: ValueError: if from_type or to_type is invalid. Examples: >>> temperature_conversion(0, 'C', 'F') 32.0 >>> temperature_conversion(273.15, 'K', 'C') 0.0 >>> temperature_conversion(32, 'F', 'K') 273.15 >>> temperature_conversion(100, 'C', 'invalid_unit') Traceback (most recent call last): ... ValueError: Invalid 'to_type' value: 'invalid_unit'. Conversion units are: C, F, K.","solution":"def temperature_conversion(value, from_type, to_type): Converts temperature from one unit to another. Parameters: value (float): the numeric value to convert. from_type (str): the unit of the input value. to_type (str): the unit of the desired output value. Returns: float: converted value. Raises: ValueError: if from_type or to_type is invalid. from_type = from_type.upper() to_type = to_type.upper() if from_type not in ['C', 'F', 'K']: raise ValueError(f\\"Invalid 'from_type' value: '{from_type}'. Conversion units are: C, F, K.\\") if to_type not in ['C', 'F', 'K']: raise ValueError(f\\"Invalid 'to_type' value: '{to_type}'. Conversion units are: C, F, K.\\") if from_type == to_type: return float(value) # Convert from source to Celsius if from_type == 'F': celsius = (value - 32) * 5.0/9.0 elif from_type == 'K': celsius = value - 273.15 else: celsius = value # Convert from Celsius to destination if to_type == 'F': return celsius * 9.0/5.0 + 32 elif to_type == 'K': return celsius + 273.15 else: return celsius"},{"question":"import pandas as pd def perform_sentiment_analysis(file_path: str) -> pd.DataFrame: Performs sentiment analysis on product reviews. Args: - file_path (str): Path to the CSV file containing product reviews. Returns: - pd.DataFrame: DataFrame with 'review_id' and predicted sentiments. pass # Unit Tests import pytest import pandas as pd from io import StringIO def sample_reviews(): data = review_id,review_text,sentiment 1,\\"I love this product, it is amazing!\\",positive 2,\\"This is the worst thing I have ever bought.\\",negative 3,\\"It is okay, nothing special.\\",neutral 4,\\"Absolutely fantastic! Will buy again.\\",positive 5,\\"Terrible! Do not recommend.\\",negative return StringIO(data) def test_perform_sentiment_analysis(): df = pd.read_csv(sample_reviews()) df.to_csv('test_reviews.csv', index=False) result_df = perform_sentiment_analysis('test_reviews.csv') assert 'review_id' in result_df.columns assert 'predicted_sentiment' in result_df.columns assert len(result_df) == 5 assert all(result_df['predicted_sentiment'].isin(['positive', 'negative', 'neutral'])) def test_perform_sentiment_analysis_accuracy(): df = pd.read_csv(sample_reviews()) df.to_csv('test_reviews.csv', index=False) result_df = perform_sentiment_analysis('test_reviews.csv') known_sentiments = df['sentiment'] predicted_sentiments = result_df['predicted_sentiment'] accuracy = (known_sentiments == predicted_sentiments).mean() assert accuracy > 0.6 # Just an example threshold for testing purposes","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.pipeline import make_pipeline from sklearn.metrics import accuracy_score def perform_sentiment_analysis(file_path: str) -> pd.DataFrame: # Load the data df = pd.read_csv(file_path) # Assuming the dataset also has a 'sentiment' column for training purposes # Pre-processing and vectorization X = df['review_text'] y = df['sentiment'] # pretend we already have labelled sentiments for training # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Create a pipeline with tf-idf vectorizer and logistic regression classifier pipeline = make_pipeline(TfidfVectorizer(), LogisticRegression(max_iter=1000)) # Train the model pipeline.fit(X_train, y_train) # Predict sentiment on the test set y_pred = pipeline.predict(X_test) # Measure accuracy accuracy = accuracy_score(y_test, y_pred) print(f'Accuracy: {accuracy}') # Now we predict on the whole dataset to get the sentiment predictions df['predicted_sentiment'] = pipeline.predict(df['review_text']) # Return the dataframe with review_id and predicted sentiment return df[['review_id', 'predicted_sentiment']]"},{"question":"Write a function \`generate_primes\` that takes two parameters: \`start\` and \`end\`, both non-negative integers, representing the beginning and end of a range (inclusive). The function returns a list of all prime numbers within the given range, sorted in ascending order. # Input * \`start\` (int): A non-negative integer representing the beginning of the range (inclusive). * \`end\` (int): A non-negative integer representing the end of the range (inclusive). # Output * \`result\` (List[int]): A list of all prime numbers within the given range, sorted in ascending order. # Example print(generate_primes(10, 50)) # Output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] print(generate_primes(0, 10)) # Output: [2, 3, 5, 7]","solution":"from typing import List def generate_primes(start: int, end: int) -> List[int]: Generates all prime numbers within a specified range [start, end]. Parameters: start (int): The beginning of the range (inclusive). end (int): The end of the range (inclusive). Returns: List[int]: A list of all prime numbers within the given range. def sieve_of_eratosthenes(n: int) -> List[int]: Helper function to compute prime numbers up to n using Sieve of Eratosthenes. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [] for p in range(2, n + 1): if is_prime[p] == True: prime_numbers.append(p) return prime_numbers if start > end: return [] if end < 2: return [] primes_up_to_end = sieve_of_eratosthenes(end) primes_in_range = [num for num in primes_up_to_end if num >= start] return primes_in_range"},{"question":"import heapq from collections import defaultdict def network_delay_time(times: list, n: int, k: int) -> int: Calculate the time it takes for a signal to propagate from node k to all other nodes. >>> network_delay_time([(2, 1, 1), (2, 3, 1), (3, 4, 1)], 4, 2) == 2 >>> network_delay_time([(1, 2, 1)], 2, 1) == 1 >>> network_delay_time([(1, 2, 1)], 2, 2) == -1 >>> network_delay_time([(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 1)], 4, 1) == 4","solution":"import heapq from collections import defaultdict def network_delay_time(times: list, n: int, k: int) -> int: Calculate the time it takes for a signal to propagate from node k to all other nodes. graph = defaultdict(list) # Build the graph for u, v, w in times: graph[u].append((v, w)) # Min-heap to store (time, node) for Dijkstra's algorithm min_heap = [(0, k)] shortest_times = {} while min_heap: t, node = heapq.heappop(min_heap) if node in shortest_times: continue shortest_times[node] = t for neighbor, w in graph[node]: if neighbor not in shortest_times: heapq.heappush(min_heap, (t + w, neighbor)) if len(shortest_times) == n: return max(shortest_times.values()) return -1"},{"question":"from typing import List def is_rotation(arr1: List[int], arr2: List[int]) -> bool: Checks if arr2 is a rotation of arr1. >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) True >>> is_rotation([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) False pass # Test cases def test_positive_case_1(): assert is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) == True def test_positive_case_2(): assert is_rotation([1, 2, 3, 4, 5], [4, 5, 1, 2, 3]) == True def test_negative_case_1(): assert is_rotation([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == False def test_negative_case_2(): assert is_rotation([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) == False def test_single_element_case(): assert is_rotation([1], [1]) == True def test_single_element_mismatch(): assert is_rotation([1], [2]) == False def test_same_array(): assert is_rotation([1, 2, 3], [1, 2, 3]) == True def test_different_lengths(): assert is_rotation([1, 2, 3], [1, 2, 3, 4]) == False","solution":"def is_rotation(arr1, arr2): Checks if arr2 is a rotation of arr1. if len(arr1) != len(arr2): return False doubled_arr1 = arr1 + arr1 for i in range(len(arr1)): if doubled_arr1[i:i + len(arr2)] == arr2: return True return False"},{"question":"def find_unique_element(arr: list[int]) -> int: Find the element that appears only once in the array. Every other element in the array appears exactly twice. Args: arr (list[int]): The input array of integers. Returns: int: The unique element. Examples: >>> find_unique_element([4, 1, 2, 1, 2]) 4 >>> find_unique_element([2, 2, 1]) 1 >>> find_unique_element([1, 2, 3, 4, 3, 2, 1]) 4 pass from solution import find_unique_element def test_find_unique_element_single_element(): assert find_unique_element([42]) == 42 def test_find_unique_element_example1(): assert find_unique_element([4, 1, 2, 1, 2]) == 4 def test_find_unique_element_example2(): assert find_unique_element([2, 2, 1]) == 1 def test_find_unique_element_example3(): assert find_unique_element([1, 2, 3, 4, 3, 2, 1]) == 4 def test_find_unique_element_mixed_positive_negative(): assert find_unique_element([-1, 2, -1, 2, 3]) == 3 def test_find_unique_element_all_negative(): assert find_unique_element([-1, -2, -1, -2, -3]) == -3","solution":"def find_unique_element(arr: list[int]) -> int: Returns the element that appears exactly once in the array. Every other element appears exactly twice. Uses XOR to find the unique element in linear time with constant space. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"from typing import List def longest_consecutive_days(dates: List[str], user_id: str) -> int: Determine the longest sequence of consecutive days a user has been active on the platform. Args: dates (List[str]): A list of dates in \\"YYYY-MM-DD\\" format. user_id (str): A string serving as a user's unique identifier. Returns: int: The length of the longest consecutive sequence of days the user was active. Examples: >>> longest_consecutive_days([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-04\\", \\"2023-01-05\\", \\"2023-01-06\\"], \\"user_123\\") 3 >>> longest_consecutive_days([\\"2023-03-01\\", \\"2023-03-02\\", \\"2023-03-04\\", \\"2023-03-05\\", \\"2023-03-06\\", \\"2023-03-08\\"], \\"user_456\\") 3 >>> longest_consecutive_days([], \\"user_789\\") 0","solution":"from typing import List from datetime import datetime, timedelta def longest_consecutive_days(dates: List[str], user_id: str) -> int: if not dates: return 0 # Convert string dates to datetime objects date_objects = sorted(datetime.strptime(date, \\"%Y-%m-%d\\") for date in dates) max_streak = 0 current_streak = 1 for i in range(1, len(date_objects)): if date_objects[i] - date_objects[i-1] == timedelta(days=1): current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 1 max_streak = max(max_streak, current_streak) return max_streak"},{"question":"def find_longest_subsequence(numbers: list) -> int: Returns the length of the longest contiguous subsequence of \`numbers\` that contains at most three distinct integers. Raises a ValueError if the input is not a list of integers. >>> find_longest_subsequence([1, 2, 1, 3, 4, 3, 5]) 4 >>> find_longest_subsequence([1, 2, 1, 2, 1, 2]) 6 >>> find_longest_subsequence([4, 5, 6, 7, 8, 9]) 3 >>> find_longest_subsequence([1]) 1 >>> find_longest_subsequence([]) 0 >>> find_longest_subsequence([10, 'test', 20]) Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> find_longest_subsequence(123) Traceback (most recent call last): ... ValueError: Input must be a list of integers","solution":"def find_longest_subsequence(numbers: list) -> int: if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers\\") for num in numbers: if not isinstance(num, int): raise ValueError(\\"Input must be a list of integers\\") n = len(numbers) if n == 0: return 0 max_length = 0 start = 0 counts = {} for end in range(n): if numbers[end] in counts: counts[numbers[end]] += 1 else: counts[numbers[end]] = 1 while len(counts) > 3: counts[numbers[start]] -= 1 if counts[numbers[start]] == 0: del counts[numbers[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from top-left to bottom-right in an m x n grid. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(1, 1) 1","solution":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from top-left to bottom-right in an m x n grid. # Create a 2D array filled with 1s, which will hold the number of ways to reach each cell. dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from cell (1, 1) because the first row and first column # can only be reached by one path, either from the left or from above. for i in range(1, m): for j in range(1, n): # Each cell can be reached either from the cell above it or from the cell to the left of it. dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will contain the number of unique paths to reach it. return dp[-1][-1]"},{"question":"def normalize_list(values: list) -> list: Normalize a list of integers or floats to the range [0, 1]. >>> normalize_list([1, 2, 3, 4, 5]) [0.0, 0.25, 0.5, 0.75, 1.0] >>> normalize_list([5, 4, 3, 2, 1]) [1.0, 0.75, 0.5, 0.25, 0.0] >>> normalize_list([3, 1, 4, 1, 5, 9]) [0.25, 0.0, 0.375, 0.0, 0.5, 1.0] >>> normalize_list([-5, -3, -1, -4]) [0.0, 0.5, 1.0, 0.25] >>> normalize_list([2, 2, 2, 2]) [0.0, 0.0, 0.0, 0.0] >>> normalize_list([10]) [0.0] >>> normalize_list([1.0, 2.5, 3.5, 4.0]) [0.0, 0.5, 0.8333333333333334, 1.0] pass","solution":"def normalize_list(values): Normalizes a list of integers or floats to the range [0, 1]. Args: values (list): A list of integers or floats. Returns: list: A list of floats where each value is scaled to the range [0, 1]. min_val = min(values) max_val = max(values) if min_val == max_val: # If all values are the same, return a list of zeros return [0.0] * len(values) return [(x - min_val) / (max_val - min_val) for x in values]"},{"question":"def compress_string(input_string: str) -> str: Compress a string using the counts of repeated characters. If the compressed string is not shorter than the original, return the original string. >>> compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") == \\"abcdef\\" >>> compress_string(\\"\\") == \\"\\" >>> compress_string(\\"a\\") == \\"a\\" >>> compress_string(\\"aaaaaa\\") == \\"a6\\" >>> compress_string(\\"AaAaAa\\") == \\"AaAaAa\\" >>> compress_string(\\"abcd\\") == \\"abcd\\" >>> compress_string(\\"a\\"*1000) == \\"a1000\\" >>> compress_string(\\"a\\"*500 + \\"b\\"*500) == \\"a500b500\\"","solution":"def compress_string(input_string: str) -> str: if not input_string: return input_string compressed_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed_string.append(input_string[i - 1] + str(count)) count = 1 compressed_string.append(input_string[-1] + str(count)) compressed_result = ''.join(compressed_string) return compressed_result if len(compressed_result) < len(input_string) else input_string"},{"question":"def transpose_matrix(matrix: list[list[int]]) -> None: Transpose the given square matrix in place. Args: matrix (list of list of int): The square matrix to be transposed. Returns: None Example: >>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> transpose_matrix(matrix) >>> matrix [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> matrix = [[1, 0], [0, 1]] >>> transpose_matrix(matrix) >>> matrix [[1, 0], [0, 1]]","solution":"def transpose_matrix(matrix: list[list[int]]) -> None: Transpose the given square matrix in place. Args: matrix (list of list of int): The square matrix to be transposed. Returns: None n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"def distinct_powers_in_range(x: int, y: int) -> int: Return the number of distinct integers of the form a^b where 2 <= a <= x and 2 <= b <= y. >>> distinct_powers_in_range(5, 5) 15 >>> distinct_powers_in_range(10, 10) 69","solution":"def distinct_powers_in_range(x: int, y: int) -> int: Returns the number of distinct integers of the form a^b where 2 <= a <= x and 2 <= b <= y. unique_powers = set() for a in range(2, x + 1): for b in range(2, y + 1): unique_powers.add(a ** b) return len(unique_powers)"},{"question":"from typing import List, Dict def filter_books(library: List[Dict[str, str]], criteria: Dict[str, str]) -> List[Dict[str, str]]: Filters the library books based on the provided criteria. Parameters: - library: List of dictionaries where each dictionary represents a book with attributes 'title', 'author', 'genre', and 'year'. - criteria: Dictionary of attributes to filter the books. The keys are attribute names and the values are the corresponding values to match. Returns: - List of dictionaries representing the books that match all the specified criteria. >>> library = [ ... {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": \\"1949\\"}, ... {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Fiction\\", \\"year\\": \\"1960\\"}, ... {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Fiction\\", \\"year\\": \\"1925\\"}, ... {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"genre\\": \\"Dystopian\\", \\"year\\": \\"1932\\"} ... ] >>> criteria = {\\"genre\\": \\"Fiction\\", \\"author\\": \\"Harper Lee\\"} >>> filter_books(library, criteria) [{'title': 'To Kill a Mockingbird', 'author': 'Harper Lee', 'genre': 'Fiction', 'year': '1960'}] >>> criteria = {\\"genre\\": \\"Dystopian\\"} >>> filter_books(library, criteria) [{'title': '1984', 'author': 'George Orwell', 'genre': 'Dystopian', 'year': '1949'}, {'title': 'Brave New World', 'author': 'Aldous Huxley', 'genre': 'Dystopian', 'year': '1932'}] >>> criteria = {} >>> filter_books(library, criteria) [{'title': '1984', 'author': 'George Orwell', 'genre': 'Dystopian', 'year': '1949'}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee', 'genre': 'Fiction', 'year': '1960'}, {'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald', 'genre': 'Fiction', 'year': '1925'}, {'title': 'Brave New World', 'author': 'Aldous Huxley', 'genre': 'Dystopian', 'year': '1932'}]","solution":"from typing import List, Dict def filter_books(library: List[Dict[str, str]], criteria: Dict[str, str]) -> List[Dict[str, str]]: Filters the library books based on the provided criteria. Parameters: - library: List of dictionaries where each dictionary represents a book with attributes 'title', 'author', 'genre', and 'year'. - criteria: Dictionary of attributes to filter the books. The keys are attribute names and the values are the corresponding values to match. Returns: - List of dictionaries representing the books that match all the specified criteria. return [book for book in library if all(book.get(key) == value for key, value in criteria.items())]"},{"question":"def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: Convert a temperature from one scale to another. Parameters: - value (float): The temperature value to be converted. - from_scale (str): The scale from which the temperature is to be converted. (Must be one of \\"C\\", \\"F\\", \\"K\\"). - to_scale (str): The scale to which the temperature is to be converted. (Must be one of \\"C\\", \\"F\\", \\"K\\"). Returns: - float: The converted temperature value. >>> convert_temperature(100, 'C', 'F') 212.0 >>> abs(convert_temperature(0, 'C', 'K') - 273.15) < 1e-9 True >>> abs(convert_temperature(32, 'F', 'C')) < 1e-9 True >>> abs(convert_temperature(212, 'F', 'K') - 373.15) < 1e-9 True >>> abs(convert_temperature(273.15, 'K', 'C')) < 1e-9 True >>> abs(convert_temperature(373.15, 'K', 'F') - 212.0) < 1e-9 True >>> try: convert_temperature(100, 'X', 'C') ... except ValueError as e: str(e) == \\"Invalid temperature scale: 'X'\\" >>> try: convert_temperature(100, 'C', 'Z') ... except ValueError as e: str(e) == \\"Invalid temperature scale: 'Z'\\" >>> try: convert_temperature(-1, 'K', 'C') ... except ValueError as e: str(e) == \\"Temperature in Kelvin cannot be less than 0.\\" >>> try: convert_temperature(-274, 'C', 'K') ... except ValueError as e: str(e) == \\"Temperature in Kelvin cannot be less than 0.\\" >>> convert_temperature(100, 'C', 'C') 100 >>> convert_temperature(32, 'F', 'F') 32 >>> convert_temperature(273.15, 'K', 'K') 273.15","solution":"def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: if from_scale not in [\\"C\\", \\"F\\", \\"K\\"]: raise ValueError(f\\"Invalid temperature scale: '{from_scale}'\\") if to_scale not in [\\"C\\", \\"F\\", \\"K\\"]: raise ValueError(f\\"Invalid temperature scale: '{to_scale}'\\") if from_scale == \\"C\\": if value < -273.15: raise ValueError(\\"Temperature in Kelvin cannot be less than 0.\\") if to_scale == \\"F\\": return value * 9 / 5 + 32 elif to_scale == \\"K\\": return value + 273.15 elif from_scale == \\"F\\": if to_scale == \\"C\\": return (value - 32) * 5 / 9 elif to_scale == \\"K\\": return (value - 32) * 5 / 9 + 273.15 elif from_scale == \\"K\\": if value < 0: raise ValueError(\\"Temperature in Kelvin cannot be less than 0.\\") if to_scale == \\"C\\": return value - 273.15 elif to_scale == \\"F\\": return (value - 273.15) * 9 / 5 + 32 # If from_scale and to_scale are the same, return the original value return value"},{"question":"def find_missing_element(nums: List[int]) -> int: Finds the missing element in a list of consecutive integers starting from 1 to n. >>> find_missing_element([1, 2, 4, 5, 6]) 3 >>> find_missing_element([3, 4, 2, 1]) 5 >>> find_missing_element([2, 3, 1]) 4","solution":"def find_missing_element(nums): Finds the missing element in a list of consecutive integers starting from 1 to n. Args: nums (List[int]): List of integers from 1 to n with one missing. Returns: int: The missing integer. n = len(nums) + 1 total_sum = n * (n + 1) // 2 array_sum = sum(nums) return total_sum - array_sum"},{"question":"class VersionedDictionary: def __init__(self) -> None: Initialize the versioned dictionary. pass def set_key(self, key: str, value: any) -> None: Set a value for a key, creating a new version entry for that key. >>> vd = VersionedDictionary() >>> vd.set_key('a', 1) >>> vd.set_key('a', 2) >>> vd.get_key('a') 2 pass def get_key(self, key: str) -> any: Get the current value of a key. >>> vd = VersionedDictionary() >>> vd.get_key('a') None pass def get_key_by_version(self, key: str, version: int) -> any: Retrieve the value of a key at a specific version. >>> vd = VersionedDictionary() >>> vd.set_key('a', 1) >>> vd.get_key_by_version('a', 0) 1 pass def delete_key(self, key: str) -> None: Delete a key and all its versions. >>> vd = VersionedDictionary() >>> vd.set_key('a', 1) >>> vd.delete_key('a') >>> vd.get_key('a') None pass def revert_key(self, key: str, version: int) -> None: Revert a key to a specific version in its history. >>> vd = VersionedDictionary() >>> vd.set_key('a', 1) >>> vd.set_key('a', 2) >>> vd.revert_key('a', 0) >>> vd.get_key('a') 1 pass","solution":"class VersionedDictionary: def __init__(self) -> None: self.store = {} def set_key(self, key: str, value: any) -> None: if key not in self.store: self.store[key] = [] self.store[key].append(value) def get_key(self, key: str) -> any: if key not in self.store or not self.store[key]: return None return self.store[key][-1] def get_key_by_version(self, key: str, version: int) -> any: if key not in self.store or version >= len(self.store[key]): return None return self.store[key][version] def delete_key(self, key: str) -> None: if key in self.store: del self.store[key] def revert_key(self, key: str, version: int) -> None: if key in self.store and version < len(self.store[key]): self.store[key] = self.store[key][:version + 1]"},{"question":"def generate_permutations(strings: list[str]) -> list[list[str]]: Generates all possible permutations of a given list of strings. Parameters: strings (list[str]): A list of strings to generate permutations for. Returns: list[list[str]]: A list containing all possible permutations. Constraints: - The length of the strings list will be between 0 and 6. Examples: >>> generate_permutations([\\"a\\", \\"b\\"]) [['a', 'b'], ['b', 'a']] >>> generate_permutations([\\"cat\\", \\"dog\\", \\"bird\\"]) [['cat', 'dog', 'bird'], ['cat', 'bird', 'dog'], ['dog', 'cat', 'bird'], ['dog', 'bird', 'cat'], ['bird', 'cat', 'dog'], ['bird', 'dog', 'cat']] >>> generate_permutations([]) [[]] >>> generate_permutations([\\"apple\\"]) [['apple']]","solution":"def generate_permutations(strings): Generates all possible permutations of a given list of strings. Parameters: strings (list[str]): A list of strings to generate permutations for. Returns: list[list[str]]: A list containing all possible permutations. # Base case: If the list is empty, return an empty list if len(strings) == 0: return [[]] # Recursive case: Generate permutations result = [] for i, s in enumerate(strings): remaining_elements = strings[:i] + strings[i+1:] for p in generate_permutations(remaining_elements): result.append([s] + p) return result"},{"question":"from collections import Counter class Histogram: The Histogram class represents a histogram tracking the frequency of integer values. Methods: add(value: int): Add a value to the histogram. remove(value: int): Remove a value from the histogram. Raises ValueError if not present. get_frequency(value: int) -> int: Get the frequency of a value. mode() -> list[int]: Return the value(s) with the highest frequency. Raises ValueError if histogram is empty. median() -> float: Return the median value. Raises ValueError if histogram is empty. mean() -> float: Return the mean of values. Raises ValueError if histogram is empty. clear(): Clear the histogram. def __init__(self): pass def add(self, value: int): pass def remove(self, value: int): pass def get_frequency(self, value: int) -> int: pass def mode(self) -> list[int]: pass def median(self) -> float: pass def mean(self) -> float: pass def clear(self): pass # Example usage if __name__ == \\"__main__\\": hist = Histogram() hist.add(1) hist.add(2) hist.add(2) hist.add(3) print(hist.get_frequency(2)) # Output: 2 print(hist.mode()) # Output: [2] print(hist.median()) # Output: 2.0 print(hist.mean()) # Output: 2.0 hist.remove(2) print(hist.get_frequency(2)) # Output: 1 hist.clear() try: hist.median() # Should raise ValueError as the histogram is now empty except ValueError: print(\\"Histogram is empty\\")","solution":"from collections import Counter class Histogram: def __init__(self): self.counter = Counter() self.values = [] def add(self, value): self.counter[value] += 1 self.values.append(value) self.values.sort() def remove(self, value): if self.counter[value] == 0: raise ValueError(\\"Value not found in histogram\\") self.counter[value] -= 1 if self.counter[value] == 0: del self.counter[value] self.values.remove(value) def get_frequency(self, value): return self.counter[value] def mode(self): if not self.values: raise ValueError(\\"Histogram is empty\\") max_freq = max(self.counter.values()) return [key for key, freq in self.counter.items() if freq == max_freq] def median(self): if not self.values: raise ValueError(\\"Histogram is empty\\") n = len(self.values) mid = n // 2 if n % 2 == 1: return float(self.values[mid]) else: return (self.values[mid - 1] + self.values[mid]) / 2.0 def mean(self): if not self.values: raise ValueError(\\"Histogram is empty\\") return sum(self.values) / len(self.values) def clear(self): self.counter.clear() self.values.clear()"},{"question":"def sort_dict_by_values(input_dict: dict[str, int]) -> list[str]: Sorts a dictionary by its values in ascending order and returns a list of keys arranged according to this order. :param input_dict: A dictionary with string keys and integer values. :return: A list of keys sorted by their corresponding values. >>> sort_dict_by_values({'apple': 5, 'banana': 2, 'cherry': 8, 'date': 3}) ['banana', 'date', 'apple', 'cherry'] >>> sort_dict_by_values({'kiwi': 3, 'mango': 1, 'pear': 2}) ['mango', 'pear', 'kiwi'] >>> sort_dict_by_values({'x': 10, 'y': 1, 'z': 5}) ['y', 'z', 'x']","solution":"def sort_dict_by_values(input_dict): Sorts a dictionary by its values in ascending order and returns a list of keys arranged according to this order. :param input_dict: A dictionary with string keys and integer values. :return: A list of keys sorted by their corresponding values. if not isinstance(input_dict, dict): raise ValueError(\\"Input must be a dictionary.\\") for key, value in input_dict.items(): if not isinstance(key, str) or not isinstance(value, int): raise ValueError(\\"Dictionary must have string keys and integer values.\\") # Sort the dictionary by its values sorted_items = sorted(input_dict.items(), key=lambda item: item[1]) # Extract the keys from the sorted items sorted_keys = [key for key, _ in sorted_items] return sorted_keys"},{"question":"def search_matrix(matrix: list[list[int]], target: int) -> tuple: Searches for a target value in a row-wise and column-wise sorted matrix. If found, returns a tuple of its coordinates (row, col). If not found, returns (-1, -1). >>> search_matrix( ... [ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16], ... [10, 13, 14, 17] ... ], ... 5 ... ) (1, 1) >>> search_matrix( ... [ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16], ... [10, 13, 14, 17] ... ], ... 15 ... ) (-1, -1) >>> search_matrix([], 3) (-1, -1) # Your code here","solution":"def search_matrix(matrix: list[list[int]], target: int) -> tuple: Searches for a target value in a row-wise and column-wise sorted matrix. if not matrix or not matrix[0]: return -1, -1 rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return row, col elif matrix[row][col] < target: row += 1 else: col -= 1 return -1, -1"},{"question":"import matplotlib.pyplot as plt from typing import List, Tuple def generate_line_chart(data: List[Tuple[str, float]], title: str, x_label: str, y_label: str, line_color: str = 'blue', line_thickness: int = 2) -> None: Creates a line chart with the given data and customization options. Args: data (List[Tuple[str, float]]): A list of tuples where each tuple contains a timestamp (str) and a data value (float). title (str): The title of the chart. x_label (str): The label for the x-axis. y_label (str): The label for the y-axis. line_color (str, optional): The color of the line. Defaults to 'blue'. line_thickness (int, optional): The thickness of the line. Defaults to 2. Returns: None: The function displays the line chart.","solution":"import matplotlib.pyplot as plt from typing import List, Tuple def generate_line_chart(data: List[Tuple[str, float]], title: str, x_label: str, y_label: str, line_color: str = 'blue', line_thickness: int = 2) -> None: Creates a line chart with the given data and customization options. Args: data (List[Tuple[str, float]]): A list of tuples where each tuple contains a timestamp (str) and a data value (float). title (str): The title of the chart. x_label (str): The label for the x-axis. y_label (str): The label for the y-axis. line_color (str, optional): The color of the line. Defaults to 'blue'. line_thickness (int, optional): The thickness of the line. Defaults to 2. Returns: None: The function displays the line chart. if len(data) < 2: raise ValueError(\\"Data list must contain at least two data points.\\") dates, values = zip(*data) plt.figure(figsize=(10, 6)) plt.plot(dates, values, color=line_color, linewidth=line_thickness) plt.title(title) plt.xlabel(x_label) plt.ylabel(y_label) plt.grid(True) plt.show()"},{"question":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers in the list nums. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([0, 0, 1, -1, -2, 2, 3, -3]) 7 def test_empty_list(): assert longest_consecutive_subsequence([]) == 0 def test_single_element(): assert longest_consecutive_subsequence([100]) == 1 def test_general_case(): assert longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 def test_with_duplicates(): assert longest_consecutive_subsequence([1, 2, 2, 3, 4]) == 4 def test_negative_and_positive(): assert longest_consecutive_subsequence([0, 0, 1, -1, -2, 2, 3, -3]) == 7 def test_long_streak(): assert longest_consecutive_subsequence([10, 4, 200, 1, 3, 2, 5, 6, 7, 8, 9]) == 10 def test_no_consecutive(): assert longest_consecutive_subsequence([10, 20, 30, 40]) == 1","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest subsequence of consecutive integers in the list nums. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # starting point of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List, Tuple def detect_pattern_activity(logs: List[Tuple[int, str]], time_window: int) -> List[str]: Detects user activity patterns within the given time window. Args: logs (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer timestamp and a string representing an operation and user ID in the format \\"operation:user_id\\". time_window (int): The time window (in seconds) within which to detect the pattern sequence. Returns: List[str]: A list of user IDs who have performed the sequence of operations within the specified time window. # Example Test Cases example_logs = [ (1, \\"login:user1\\"), (2, \\"view_item:user1\\"), (3, \\"add_to_cart:user1\\"), (4, \\"checkout:user1\\"), (5, \\"login:user2\\"), (6, \\"view_item:user2\\"), (8, \\"add_to_cart:user2\\"), (10, \\"checkout:user2\\"), (11, \\"login:user3\\"), (15, \\"view_item:user3\\"), (20, \\"add_to_cart:user3\\"), (30, \\"checkout:user3\\") ] print(detect_pattern_activity(example_logs, 5)) # Expected Output: ['user1', 'user2'] print(detect_pattern_activity(example_logs, 10)) # Expected Output: ['user1', 'user2', 'user3']","solution":"def detect_pattern_activity(logs, time_window): Detects user activity patterns within the given time window. Args: logs (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer timestamp and a string representing an operation and user ID in the format \\"operation:user_id\\". time_window (int): The time window (in seconds) within which to detect the pattern sequence. Returns: List[str]: A list of user IDs who have performed the sequence of operations within the specified time window. pattern = [\\"login\\", \\"view_item\\", \\"add_to_cart\\", \\"checkout\\"] user_operations = {} result = set() for timestamp, op_string in logs: op, user_id = op_string.split(\\":\\") if user_id not in user_operations: user_operations[user_id] = [] user_operations[user_id].append((timestamp, op)) # Check for the pattern in the user operations if len(user_operations[user_id]) >= 4: last_operations = user_operations[user_id][-4:] if [op for ts, op in last_operations] == pattern: if last_operations[-1][0] - last_operations[0][0] <= time_window: result.add(user_id) return list(result)"},{"question":"from typing import List def unique_paths(forest: List[List[int]]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of the grid. The grid contains clear pathways (0) and trees (1). You can only move down or right. >>> unique_paths([ ... [0, 0, 1], ... [0, 0, 0], ... [1, 0, 0] ... ]) == 2 >>> unique_paths([ ... [0, 1], ... [0, 0] ... ]) == 1 >>> unique_paths([ ... [1, 0], ... [0, 0] ... ]) == 0 >>> unique_paths([ ... [0, 0], ... [0, 1] ... ]) == 0 >>> unique_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths([ ... [0, 1], ... [1, 0] ... ]) == 0 >>> unique_paths([ ... [0, 0, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [1, 0, 1, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == 17","solution":"from typing import List def unique_paths(forest: List[List[int]]) -> int: n = len(forest) m = len(forest[0]) if forest[0][0] == 1 or forest[n-1][m-1] == 1: return 0 # Initialize a 2D dp array with 0's dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if forest[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Example usage: forest = [ [0, 0, 1], [0, 0, 0], [1, 0, 0] ] print(unique_paths(forest)) # Expected output: 2"},{"question":"def parse_config_file(file_path: str) -> dict: Parses a configuration file and extracts key-value pairs. Each line in the file represents a key-value pair separated by an equal sign \`=\`. - Keys and values might have leading or trailing whitespaces. - Lines starting with a hash \`#\` are comments and should be ignored. - Lines that do not contain an equal sign or are empty should be skipped. Args: file_path (str): A string representing the path to the configuration file. Returns: dict: A dictionary containing the key-value pairs extracted from the configuration file with processed keys and values. Example: >>> parse_config_file(\\"config.txt\\") { \\"username\\": \\"admin\\", \\"password\\": \\"1234\\", \\"host\\": \\"example.com\\", \\"port\\": \\"8080\\" } pass import tempfile import os def test_parse_config_file(): config_content = # Sample configuration file username = admin password = 1234 host= example.com port= 8080 expected_result = { \\"username\\": \\"admin\\", \\"password\\": \\"1234\\", \\"host\\": \\"example.com\\", \\"port\\": \\"8080\\" } with tempfile.NamedTemporaryFile(delete=False) as temp_config_file: temp_config_file.write(config_content.encode('utf-8')) temp_config_file.flush() result = parse_config_file(temp_config_file.name) assert result == expected_result os.remove(temp_config_file.name) def test_parse_config_file_with_comments_and_invalid_lines(): config_content = # This is a comment username = admin # Another comment password = secret_password invalid_line host = localhost expected_result = { \\"username\\": \\"admin\\", \\"password\\": \\"secret_password\\", \\"host\\": \\"localhost\\" } with tempfile.NamedTemporaryFile(delete=False) as temp_config_file: temp_config_file.write(config_content.encode('utf-8')) temp_config_file.flush() result = parse_config_file(temp_config_file.name) assert result == expected_result os.remove(temp_config_file.name) def test_parse_config_file_with_whitespaces(): config_content = username = admin password = 12345 thost = example.com t portt t=t 8080 expected_result = { \\"username\\": \\"admin\\", \\"password\\": \\"12345\\", \\"host\\": \\"example.com\\", \\"port\\": \\"8080\\" } with tempfile.NamedTemporaryFile(delete=False) as temp_config_file: temp_config_file.write(config_content.encode('utf-8')) temp_config_file.flush() result = parse_config_file(temp_config_file.name) assert result == expected_result os.remove(temp_config_file.name) def test_parse_config_file_empty_file(): config_content = \\"\\" expected_result = {} with tempfile.NamedTemporaryFile(delete=False) as temp_config_file: temp_config_file.write(config_content.encode('utf-8')) temp_config_file.flush() result = parse_config_file(temp_config_file.name) assert result == expected_result os.remove(temp_config_file.name)","solution":"def parse_config_file(file_path: str) -> dict: config = {} with open(file_path, 'r') as file: for line in file: line = line.strip() if not line or line.startswith('#'): continue if '=' not in line: continue key, value = line.split('=', 1) key = key.strip().lower() value = value.strip() config[key] = value return config"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Find the number of unique paths in a grid with obstacles from the top-left corner to the bottom-right corner. >>> grid1 = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> unique_paths_with_obstacles(grid1) 2 >>> grid2 = [ ... [0, 1], ... [0, 0] ... ] >>> unique_paths_with_obstacles(grid2) 1","solution":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) # Create a 2D DP array initialized to 0 dp = [[0] * n for _ in range(m)] # Initialize the start point dp[0][0] = 1 # Fill the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # No path through obstacles else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome, ignoring non-alphanumeric characters and case differences. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\" \\") True from solution import is_palindrome def test_empty_string(): assert is_palindrome(\\"\\") == True def test_single_character(): assert is_palindrome(\\"a\\") == True assert is_palindrome(\\"Z\\") == True def test_valid_palindromes(): assert is_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome(\\"No 'x' in Nixon\\") == True assert is_palindrome(\\"racecar\\") == True def test_invalid_palindromes(): assert is_palindrome(\\"race a car\\") == False assert is_palindrome(\\"hello world\\") == False def test_non_alphanumeric_characters(): assert is_palindrome(\\"#%\\") == True assert is_palindrome(\\"#d%cb &a b C D%#\\") == True def test_case_insensitivity(): assert is_palindrome(\\"Able was I ere I saw Elba\\") == True def test_long_input(): long_palindrome = \\"A\\" * 10**5 + \\"a\\" * 10**5 assert is_palindrome(long_palindrome) == True long_non_palindrome = \\"A\\" * 10**5 + \\"b\\" * 10**5 assert is_palindrome(long_non_palindrome) == False","solution":"import re def is_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome, ignoring non-alphanumeric characters and case differences. # Remove all non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"class IntervalManager: A class to manage intervals efficiently and compute the total covered length by the union of intervals. Methods: add_interval(start: int, end: int) -> None: Adds a new interval [start, end) and merges overlapping intervals if necessary. get_total_covered_length() -> int: Returns the total length covered by the union of all intervals stored. def __init__(self): # Initialize the data structure def add_interval(self, start: int, end: int) -> None: # Add code to insert an interval and merge if necessary def get_total_covered_length(self) -> int: # Calculate and return the total length covered by the union of intervals # Example usage im = IntervalManager() im.add_interval(1, 5) im.add_interval(6, 10) im.add_interval(3, 7) length = im.get_total_covered_length() print(length) # Expected output: 9","solution":"class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: new_interval = (start, end) self.intervals.append(new_interval) self._merge_intervals() def get_total_covered_length(self) -> int: merged_intervals = self._merge_intervals() total_length = 0 for interval in merged_intervals: total_length += interval[1] - interval[0] return total_length def _merge_intervals(self): if not self.intervals: return [] # Sort intervals by start time self.intervals.sort() merged_intervals = [self.intervals[0]] for current in self.intervals[1:]: last = merged_intervals[-1] if current[0] <= last[1]: # Overlapping intervals, merge them merged_intervals[-1] = (last[0], max(last[1], current[1])) else: # No overlap, add the interval to the list merged_intervals.append(current) self.intervals = merged_intervals return merged_intervals"},{"question":"import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.datasets import make_blobs from sklearn.metrics import silhouette_score from sklearn.preprocessing import StandardScaler def load_dataset(samples: int = 300, centers: int = 3, cluster_std: float = 0.60) -> np.ndarray: data, _ = make_blobs(n_samples=samples, centers=centers, cluster_std=cluster_std, random_state=42) return data def preprocess_data(data: np.ndarray) -> np.ndarray: scaler = StandardScaler() return scaler.fit_transform(data) def kmeans_clustering(data: np.ndarray) -> tuple: data = preprocess_data(data) sse = [] for k in range(1, 11): kmeans = KMeans(n_clusters=k, random_state=42) kmeans.fit(data) sse.append(kmeans.inertia_) plt.figure() plt.plot(range(1, 11), sse, marker='o') plt.title('Elbow Method') plt.xlabel('Number of clusters (k)') plt.ylabel('Sum of squared errors (SSE)') plt.show() optimal_k = 3 kmeans = KMeans(n_clusters=optimal_k, random_state=42) labels = kmeans.fit_predict(data) silhouette_avg = silhouette_score(data, labels) print(f'Silhouette Score for k={optimal_k}: {silhouette_avg:.2f}') plt.figure() plt.scatter(data[:, 0], data[:, 1], c=labels, s=50, cmap='viridis') centers = kmeans.cluster_centers_ plt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.75) plt.title('K-Means Clustering') plt.xlabel('Feature 1') plt.ylabel('Feature 2') plt.show() return silhouette_avg, optimal_k","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.datasets import make_blobs from sklearn.metrics import silhouette_score from sklearn.preprocessing import StandardScaler def load_dataset(samples: int = 300, centers: int = 3, cluster_std: float = 0.60) -> np.ndarray: Generate a synthetic dataset with the given parameters. data, _ = make_blobs(n_samples=samples, centers=centers, cluster_std=cluster_std, random_state=42) return data def preprocess_data(data: np.ndarray) -> np.ndarray: Normalize the provided dataset. scaler = StandardScaler() return scaler.fit_transform(data) def kmeans_clustering(data: np.ndarray) -> tuple: Apply K-Means clustering to the dataset and evaluate using silhouette score. Returns: tuple: silhouette score, optimal number of clusters # Preprocess the dataset data = preprocess_data(data) # Determine the optimal number of clusters using the Elbow method sse = [] for k in range(1, 11): kmeans = KMeans(n_clusters=k, random_state=42) kmeans.fit(data) sse.append(kmeans.inertia_) plt.figure() plt.plot(range(1, 11), sse, marker='o') plt.title('Elbow Method') plt.xlabel('Number of clusters (k)') plt.ylabel('Sum of squared errors (SSE)') plt.show() # Choose the optimal k based on the Elbow curve optimal_k = 3 # Apply K-Means with the optimal number of clusters kmeans = KMeans(n_clusters=optimal_k, random_state=42) labels = kmeans.fit_predict(data) # Evaluate the clustering performance using silhouette score silhouette_avg = silhouette_score(data, labels) print(f'Silhouette Score for k={optimal_k}: {silhouette_avg:.2f}') # Visualize the clusters plt.figure() plt.scatter(data[:, 0], data[:, 1], c=labels, s=50, cmap='viridis') centers = kmeans.cluster_centers_ plt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.75) plt.title('K-Means Clustering') plt.xlabel('Feature 1') plt.ylabel('Feature 2') plt.show() return silhouette_avg, optimal_k def main() -> None: # Load synthetic dataset data = load_dataset() # Perform K-Means clustering and evaluation kmeans_clustering(data) if __name__ == \\"__main__\\": main()"},{"question":"def wildcard_matcher(pattern: str, text: str) -> bool: Checks whether the given \`text\` string matches the \`pattern\` string which may include '*' for any sequence of characters and '?' for any single character. >>> wildcard_matcher(\\"a*b\\", \\"abab\\") # True >>> wildcard_matcher(\\"a?b\\", \\"acb\\") # True >>> wildcard_matcher(\\"a?b\\", \\"ab\\") # False >>> wildcard_matcher(\\"*a\\", \\"aa\\") # True >>> wildcard_matcher(\\"?\\", \\"a\\") # True >>> wildcard_matcher(\\"?\\", \\"\\") # False # Implement the function here","solution":"def wildcard_matcher(pattern, text): Returns whether the text matches the pattern, with the pattern containing wildcards '*' and '?'. memo = {} def dp(i, j): if (i, j) in memo: return memo[(i, j)] if j == len(pattern): result = i == len(text) else: if j < len(pattern) and pattern[j] == '*': result = (i < len(text) and dp(i + 1, j)) or dp(i, j + 1) else: match = i < len(text) and (pattern[j] == text[i] or pattern[j] == '?') result = match and dp(i + 1, j + 1) memo[(i, j)] = result return result return dp(0, 0)"},{"question":"import re from typing import List def generate_suggestions(dictionary: List[str], word: str) -> List[str]: Returns a list of words that are the closest match to the given misspelled word from the dictionary. pass def correct_text(segment: str, dictionary: List[str]) -> str: Corrects the text segment by replacing each misspelled word with the closest match from the dictionary. pass # Example usage: dictionary = [\\"hello\\", \\"world\\", \\"welcome\\", \\"to\\", \\"the\\", \\"autocorrect\\", \\"system\\"] text = \\"Helo, wrld! Welcome to the auotcorrect systm.\\" suggestions = generate_suggestions(dictionary, \\"Helo\\") print(suggestions) # Example Output: [\\"hello\\"] corrected_text = correct_text(text, dictionary) print(corrected_text) # Example Output: \\"Hello, world! Welcome to the autocorrect system.\\" def test_generate_suggestions(): dictionary = [\\"hello\\", \\"world\\", \\"welcome\\", \\"to\\", \\"the\\", \\"autocorrect\\", \\"system\\"] assert generate_suggestions(dictionary, \\"helo\\") == [\\"hello\\"] assert generate_suggestions(dictionary, \\"wrld\\") == [\\"world\\"] assert generate_suggestions(dictionary, \\"systm\\") == [\\"system\\"] assert generate_suggestions(dictionary, \\"welcome\\") == [\\"welcome\\"] assert generate_suggestions(dictionary, \\"xyz\\") == [] def test_correct_text(): dictionary = [\\"hello\\", \\"world\\", \\"welcome\\", \\"to\\", \\"the\\", \\"autocorrect\\", \\"system\\"] text = \\"Helo, wrld! Welcome to the auotcorrect systm.\\" assert correct_text(text, dictionary) == \\"Hello, world! Welcome to the autocorrect system.\\" def test_correct_text_with_proper_nouns(): dictionary = [\\"hello\\", \\"john\\", \\"doe\\"] text = \\"Hello John, how is Do today?\\" assert correct_text(text, dictionary) == \\"Hello John, how is Doe today?\\" def test_correct_text_with_punctuation(): dictionary = [\\"i\\", \\"love\\", \\"programming\\", \\"python\\", \\"and\\", \\"debugging\\"] text = \\"I love progrmming; Python and deuglbugging!\\" assert correct_text(text, dictionary) == \\"I love programming; Python and debugging!\\"","solution":"import re from difflib import get_close_matches def generate_suggestions(dictionary: list[str], word: str) -> list[str]: Returns a list of words that are the closest match to the given misspelled word from the dictionary. # Using difflib.get_close_matches to find the closest matches closest_matches = get_close_matches(word.lower(), dictionary, n=5, cutoff=0.6) return closest_matches def correct_text(segment: str, dictionary: list[str]) -> str: Corrects the text segment by replacing each misspelled word with the closest match from the dictionary. def replace_match(match): word = match.group() match_lc = word.lower() if match_lc in dictionary: return word suggestions = generate_suggestions(dictionary, match_lc) if suggestions: # Preserving the original casing suggestion = suggestions[0] if word[0].isupper(): suggestion = suggestion.capitalize() return suggestion return word # Regular expression to match words word_pattern = re.compile(r'bw+b') # Correcting the text corrected_text = re.sub(word_pattern, replace_match, segment) return corrected_text"},{"question":"def count_even_odd(numbers: list[int]) -> dict[str, int]: Analyzes a list of integers and returns the count of even and odd integers. Parameters: numbers (list of int): A list containing integers. Returns: dict: A dictionary with keys 'even' and 'odd' representing the count of even and odd numbers respectively. Raises: TypeError: If the input is not a list. ValueError: If any element in the list is not an integer. Examples: >>> count_even_odd([1, 2, 3, 4, 5]) {'even': 2, 'odd': 3} >>> count_even_odd([0, -2, -4, 5, 9]) {'even': 3, 'odd': 2} >>> count_even_odd([]) {'even': 0, 'odd': 0} >>> count_even_odd([2, 4, 6, 8]) {'even': 4, 'odd': 0} >>> count_even_odd([-1, -3, -5]) {'even': 0, 'odd': 3} >>> count_even_odd(\\"not a list\\") Traceback (most recent call last): ... TypeError: Input must be a list of integers >>> count_even_odd([1, 2, 'a', 4]) Traceback (most recent call last): ... ValueError: All elements in the list must be integers","solution":"def count_even_odd(numbers: list[int]) -> dict[str, int]: Returns the count of even and odd integers in a given list. Parameters: numbers (list of int): A list containing integers. Returns: dict: A dictionary with keys 'even' and 'odd' representing the count of even and odd numbers respectively. Raises: TypeError: If the input is not a list. ValueError: If any element in the list is not an integer. if not isinstance(numbers, list): raise TypeError(\\"Input must be a list of integers\\") even_count = 0 odd_count = 0 for num in numbers: if not isinstance(num, int): raise ValueError(\\"All elements in the list must be integers\\") if num % 2 == 0: even_count += 1 else: odd_count += 1 return {'even': even_count, 'odd': odd_count}"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Conduct a level order traversal (breadth-first traversal) of the given binary tree. Args: root (Optional[TreeNode]): The root of the binary tree. Returns: List[List[int]]: A list of lists, where each internal list contains the values of nodes at a specific level from left to right. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> level_order_traversal(root) [[1], [2, 3]] >>> root = None >>> level_order_traversal(root) [] pass","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root: TreeNode) -> list[list[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_values = [] for _ in range(level_size): node = queue.popleft() level_values.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_values) return result"},{"question":"def custom_fibonacci(n: int, start1: int, start2: int, offset: int) -> list[int]: Generate a Fibonacci-like sequence with arbitrary starting terms and offset. >>> custom_fibonacci(5, 1, 1, 0) [1, 1, 2, 3, 5] >>> custom_fibonacci(5, 2, 3, 1) [2, 3, 6, 10, 17] >>> custom_fibonacci(0, 1, 1, 2) [] >>> custom_fibonacci(3, 5, 8, -1) [5, 8, 12] >>> custom_fibonacci(6, -1, -1, 2) [-1, -1, 0, 1, 3, 6] pass def test_custom_fibonacci_basic(): assert custom_fibonacci(5, 1, 1, 0) == [1, 1, 2, 3, 5] assert custom_fibonacci(5, 2, 3, 1) == [2, 3, 6, 10, 17] assert custom_fibonacci(3, 5, 8, -1) == [5, 8, 12] def test_custom_fibonacci_zero_or_negative_n(): assert custom_fibonacci(0, 1, 1, 2) == [] assert custom_fibonacci(-1, 1, 1, 2) == [] def test_custom_fibonacci_single_term(): assert custom_fibonacci(1, 5, 10, 2) == [5] def test_custom_fibonacci_two_terms(): assert custom_fibonacci(2, 5, 10, 2) == [5, 10] def test_custom_fibonacci_with_negative_terms(): assert custom_fibonacci(6, -1, -1, 2) == [-1, -1, 0, 1, 3, 6] assert custom_fibonacci(5, -5, -8, 3) == [-5, -8, -10, -15, -22] def test_custom_fibonacci_with_zero_offset(): assert custom_fibonacci(5, 2, 3, 0) == [2, 3, 5, 8, 13]","solution":"def custom_fibonacci(n: int, start1: int, start2: int, offset: int) -> list[int]: if n <= 0: return [] if n == 1: return [start1] if n == 2: return [start1, start2] result = [start1, start2] for _ in range(2, n): next_term = result[-1] + result[-2] + offset result.append(next_term) return result"},{"question":"from typing import List def secure_prime_factors(input_num: int) -> List[int]: Compute the prime factors of a given positive integer. Args: input_num (int): A positive integer to be factorized. Returns: List[int]: A list of prime factors sorted in ascending order. Raises: ValueError: If the input is not a positive integer. Examples: >>> secure_prime_factors(18) [2, 3, 3] >>> secure_prime_factors(29) [29] >>> secure_prime_factors(56) [2, 2, 2, 7] >>> secure_prime_factors(100) [2, 2, 5, 5] import pytest def test_prime_factors_of_18(): assert secure_prime_factors(18) == [2, 3, 3] def test_prime_factors_of_29(): assert secure_prime_factors(29) == [29] def test_prime_factors_of_56(): assert secure_prime_factors(56) == [2, 2, 2, 7] def test_prime_factors_of_100(): assert secure_prime_factors(100) == [2, 2, 5, 5] def test_prime_factors_of_1(): assert secure_prime_factors(1) == [] def test_large_prime_factor(): assert secure_prime_factors(1000000007) == [1000000007] # 1000000007 is a prime number def test_non_integer_input(): with pytest.raises(ValueError, match=\\"Input must be a positive integer\\"): secure_prime_factors(3.5) def test_zero_input(): with pytest.raises(ValueError, match=\\"Input must be a positive integer\\"): secure_prime_factors(0) def test_negative_input(): with pytest.raises(ValueError, match=\\"Input must be a positive integer\\"): secure_prime_factors(-10)","solution":"from typing import List import math def secure_prime_factors(input_num: int) -> List[int]: if not isinstance(input_num, int) or input_num <= 0: raise ValueError(\\"Input must be a positive integer\\") if input_num == 1: return [] prime_factors = [] # Check for number of 2s that divide input_num while input_num % 2 == 0: prime_factors.append(2) input_num //= 2 # n must be odd at this point, so a skip of 2 (i.e., 3, 5, 7, ...) is used for i in range(3, int(math.sqrt(input_num)) + 1, 2): while input_num % i == 0: prime_factors.append(i) input_num //= i # If n is a prime number greater than 2, it will remain as is if input_num > 2: prime_factors.append(input_num) return prime_factors"},{"question":"def convert_base(num: str, from_base: int, to_base: int) -> str: Convert a number between different bases. >>> convert_base(\\"1010\\", 2, 10) == \\"10\\" >>> convert_base(\\"10\\", 10, 2) == \\"1010\\" >>> convert_base(\\"1A\\", 16, 2) == \\"11010\\" >>> convert_base(\\"11010\\", 2, 16) == \\"1A\\" >>> convert_base(\\"255\\", 10, 16) == \\"FF\\" >>> convert_base(\\"FF\\", 16, 10) == \\"255\\" >>> convert_base(\\"ZZZZ\\", 36, 10) == str(int(\\"ZZZZ\\", 36)) >>> convert_base(\\"12345\\", 10, 10) == \\"12345\\" >>> convert_base(\\"A\\", 16, 2) == \\"1010\\" >>> convert_base(\\"5\\", 10, 8) == \\"5\\" >>> convert_base(\\"0\\", 2, 10) == \\"0\\" >>> convert_base(\\"0\\", 10, 2) == \\"0\\" pass","solution":"def convert_base(num: str, from_base: int, to_base: int) -> str: # Step 1. Convert number from from_base to base 10. base_10_num = int(num, from_base) # Step 2. Convert the base 10 number to the target base (to_base). if base_10_num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" while base_10_num > 0: remainder = base_10_num % to_base result = digits[remainder] + result base_10_num //= to_base return result"},{"question":"def reconstruct_itinerary(tickets: List[Tuple[str, str]]) -> List[str]: Reconstruct the itinerary from given list of tickets to form the lexicographically smallest itinerary. >>> reconstruct_itinerary([(\\"MUC\\", \\"LHR\\"), (\\"JFK\\", \\"MUC\\"), (\\"SFO\\", \\"SJC\\"), (\\"LHR\\", \\"SFO\\")]) ['JFK', 'MUC', 'LHR', 'SFO', 'SJC'] >>> reconstruct_itinerary([(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")]) ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO'] from solution import reconstruct_itinerary def test_reconstruct_itinerary_case1(): tickets = [(\\"MUC\\", \\"LHR\\"), (\\"JFK\\", \\"MUC\\"), (\\"SFO\\", \\"SJC\\"), (\\"LHR\\", \\"SFO\\")] assert reconstruct_itinerary(tickets) == [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] def test_reconstruct_itinerary_case2(): tickets = [(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")] assert reconstruct_itinerary(tickets) == [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"] def test_reconstruct_itinerary_single_flight(): tickets = [(\\"JFK\\", \\"SFO\\")] assert reconstruct_itinerary(tickets) == [\\"JFK\\", \\"SFO\\"] def test_reconstruct_itinerary_multiple_destinations(): tickets = [(\\"JFK\\", \\"A\\"), (\\"JFK\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"C\\", \\"JFK\\"), (\\"B\\", \\"D\\")] assert reconstruct_itinerary(tickets) == [\\"JFK\\", \\"A\\", \\"C\\", \\"JFK\\", \\"B\\", \\"D\\"] def test_reconstruct_itinerary_complex_case(): tickets = [(\\"JFK\\", \\"A\\"), (\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"A\\"), (\\"A\\", \\"D\\"), (\\"D\\", \\"A\\"), (\\"A\\", \\"E\\"), (\\"E\\", \\"F\\"), (\\"F\\", \\"JFK\\")] assert reconstruct_itinerary(tickets) == [\\"JFK\\", \\"A\\", \\"B\\", \\"C\\", \\"A\\", \\"D\\", \\"A\\", \\"E\\", \\"F\\", \\"JFK\\"] def test_reconstruct_itinerary_all_return(): tickets = [(\\"JFK\\", \\"A\\"), (\\"A\\", \\"JFK\\"), (\\"JFK\\", \\"B\\"), (\\"B\\", \\"JFK\\"), (\\"JFK\\", \\"C\\"), (\\"C\\", \\"JFK\\")] assert reconstruct_itinerary(tickets) == [\\"JFK\\", \\"A\\", \\"JFK\\", \\"B\\", \\"JFK\\", \\"C\\", \\"JFK\\"]","solution":"def reconstruct_itinerary(tickets): Reconstructs the itinerary from given list of tickets to form the lexicographically smallest itinerary. from collections import defaultdict, deque # Build the graph flights = defaultdict(list) for start, end in sorted(tickets): flights[start].append(end) # Store the final path itinerary = [] def visit(airport): while flights[airport]: next_flight = flights[airport].pop(0) visit(next_flight) itinerary.append(airport) visit('JFK') return itinerary[::-1]"},{"question":"def partition_array(arr: List[int], k: int) -> int: Partitions an array into \`k\` or fewer non-empty continuous subarrays to minimize the maximum subarray sum. Args: - arr (List[int]): A list of integers representing the array to be partitioned. - k (int): The maximum number of partitions allowed. Returns: - int: The minimized maximum sum among the \`k\` or fewer subarrays. Examples: >>> partition_array([7, 2, 5, 10, 8], 2) 18 >>> partition_array([1, 1, 1, 1, 1, 100], 2) 100 pass def visualize_partitions(arr: List[int], k: int) -> List[List[int]]: Partitions an array into \`k\` or fewer non-empty continuous subarrays and returns the partitions. Args: - arr (List[int]): A list of integers representing the array to be partitioned. - k (int): The maximum number of partitions allowed. Returns: - List[List[int]]: A list of lists where each inner list is a partitioned subarray. Examples: >>> visualize_partitions([7, 2, 5, 10, 8], 2) [[7, 2, 5], [10, 8]] >>> visualize_partitions([1, 1, 1, 1, 1, 100], 2) [[1, 1, 1, 1, 1], [100]] pass","solution":"def partition_array(arr, k): Partitions an array into \`k\` or fewer non-empty continuous subarrays to minimize the maximum subarray sum. Args: - arr (List[int]): A list of integers representing the array to be partitioned. - k (int): The maximum number of partitions allowed. Returns: - int: The minimized maximum sum among the \`k\` or fewer subarrays. def canPartition(max_sum): current_sum = 0 partition_count = 1 for num in arr: if current_sum + num > max_sum: partition_count += 1 current_sum = num if partition_count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canPartition(mid): right = mid else: left = mid + 1 return left def visualize_partitions(arr, k): Partitions an array into \`k\` or fewer non-empty continuous subarrays and returns the partitions. Args: - arr (List[int]): A list of integers representing the array to be partitioned. - k (int): The maximum number of partitions allowed. Returns: - List[List[int]]: A list of lists where each inner list is a partitioned subarray. def canPartitionWithResult(max_sum): current_sum = 0 current_partition = [] partitions = [] for num in arr: if current_sum + num > max_sum: partitions.append(current_partition) current_partition = [num] current_sum = num else: current_partition.append(num) current_sum += num partitions.append(current_partition) return partitions min_max_sum = partition_array(arr, k) return canPartitionWithResult(min_max_sum)"},{"question":"import heapq class PriorityScheduler: A scheduler for tasks with different priorities. The \`PriorityScheduler\` class maintains tasks and executes them based on priority. Higher priority tasks run before lower priority ones, and tasks with the same priority run in the order they were added. Methods: add_task(task_name: str, priority: int) -> None: Adds a task given its name and priority. get_task() -> str: Returns the name of the next task to be executed based on the priority. If no tasks are available, returns an empty string. Example: >>> scheduler = PriorityScheduler() >>> scheduler.add_task(\\"Task1\\", 1) >>> scheduler.add_task(\\"Task2\\", 2) >>> scheduler.add_task(\\"Task3\\", 1) >>> assert scheduler.get_task() == \\"Task2\\" # Has higher priority >>> assert scheduler.get_task() == \\"Task1\\" # Added first among tasks with same priority >>> assert scheduler.get_task() == \\"Task3\\" # Added later among tasks with same priority >>> assert scheduler.get_task() == \\"\\" # No more tasks available >>> scheduler.add_task(\\"Task4\\", 3) >>> scheduler.add_task(\\"Task5\\", 0) >>> assert scheduler.get_task() == \\"Task4\\" # Highest priority >>> assert scheduler.get_task() == \\"Task5\\" # Lowest priority, last task >>> assert scheduler.get_task() == \\"\\" # No more tasks available def __init__(self): # Initialize your data structures here. pass def add_task(self, task_name: str, priority: int) -> None: Adds a task with a given name and priority. pass def get_task(self) -> str: Returns the name of the next task to be executed based on priority. pass","solution":"import heapq class PriorityScheduler: def __init__(self): self.pq = [] self.counter = 0 def add_task(self, task_name: str, priority: int) -> None: heapq.heappush(self.pq, (-priority, self.counter, task_name)) self.counter += 1 def get_task(self) -> str: if self.pq: return heapq.heappop(self.pq)[2] return \\"\\""},{"question":"def is_palindrome(x: int) -> bool: Determine if an integer is a palindrome without converting the integer to a string. >>> is_palindrome(121) True >>> is_palindrome(-121) False >>> is_palindrome(10) False >>> is_palindrome(12321) True pass def test_positive_palindrome_numbers(): assert is_palindrome(121) == True assert is_palindrome(12321) == True assert is_palindrome(1) == True assert is_palindrome(1221) == True def test_negative_numbers(): assert is_palindrome(-121) == False assert is_palindrome(-12321) == False assert is_palindrome(-1) == False assert is_palindrome(-1221) == False def test_non_palindrome_numbers(): assert is_palindrome(10) == False assert is_palindrome(123) == False assert is_palindrome(123456) == False assert is_palindrome(42) == False def test_edge_cases(): assert is_palindrome(0) == True assert is_palindrome(11) == True assert is_palindrome(1001) == True assert is_palindrome(1000021) == False","solution":"def is_palindrome(x: int) -> bool: if x < 0: return False reversed_number = 0 original_number = x while x > 0: reversed_number = reversed_number * 10 + x % 10 x //= 10 return original_number == reversed_number"},{"question":"def largest_connected_group(grid: list[list[str]]) -> int: Finds the size of the largest connected group of identical characters in the grid. Two cells are considered part of the same connected group if they share a border (vertical or horizontal). Example: >>> largest_connected_group([ ... ['a', 'a', 'b'], ... ['a', 'a', 'b'], ... ['b', 'b', 'b'] ... ]) 5 >>> largest_connected_group([ ... ['a', 'b', 'c'], ... ['b', 'b', 'd'], ... ['c', 'd', 'd'] ... ]) 3","solution":"def largest_connected_group(grid): Returns the size of the largest connected group of identical characters in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(x, y, char): # Use stack for DFS stack = [(x, y)] count = 0 while stack: cx, cy = stack.pop() if visited[cx][cy]: continue visited[cx][cy] = True count += 1 # Check all four directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == char: stack.append((nx, ny)) return count largest_group = 0 for r in range(rows): for c in range(cols): if not visited[r][c]: current_group_size = dfs(r, c, grid[r][c]) largest_group = max(largest_group, current_group_size) return largest_group"},{"question":"from typing import List def longest_upward_trend(prices: List[int]) -> int: Determine the length of the longest upward trend in the list of prices. >>> longest_upward_trend([100, 102, 101, 103, 105, 107]) 4 >>> longest_upward_trend([101, 100, 99, 98, 97]) 1 >>> longest_upward_trend([100, 101, 102, 103, 104]) 5 >>> longest_upward_trend([50, 50, 50, 50, 50]) 1 >>> longest_upward_trend([]) 0 pass","solution":"from typing import List def longest_upward_trend(prices: List[int]) -> int: if not prices: return 0 longest_streak = 0 current_streak = 1 for i in range(1, len(prices)): if prices[i] > prices[i-1]: current_streak += 1 else: if current_streak > longest_streak: longest_streak = current_streak current_streak = 1 return max(longest_streak, current_streak)"},{"question":"from typing import List, Tuple def can_reach_target(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: Determines if Pac-Man can reach the target cell from the start cell in a given grid. Parameters: - grid (list[list[int]]): A 2D list representing the grid where 0 is an open path and 1 is a wall. - start (tuple[int, int]): The starting cell (row, column) where Pac-Man is initially located. - target (tuple[int, int]): The target cell (row, column) Pac-Man needs to reach. Returns: - bool: True if Pac-Man can reach the target cell, False otherwise. Example: >>> grid = [ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 1], ... [0, 1, 0, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> can_reach_target(grid, start, target) True >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> start = (0, 0) >>> target = (1, 1) >>> can_reach_target(grid, start, target) False","solution":"from collections import deque def can_reach_target(grid, start, target): Determines if Pac-Man can reach the target cell from the start cell in a given grid. Parameters: - grid (list[list[int]]): A 2D list representing the grid where 0 is an open path and 1 is a wall. - start (tuple[int, int]): The starting cell (row, column) where Pac-Man is initially located. - target (tuple[int, int]): The target cell (row, column) Pac-Man needs to reach. Returns: - bool: True if Pac-Man can reach the target cell, False otherwise. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([start]) visited = set([start]) while queue: r, c = queue.popleft() if (r, c) == target: return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append((nr, nc)) visited.add((nr, nc)) return False"},{"question":"def cipher(text: str, shift: int, encrypt: bool) -> str: Encrypt or decrypt a given message using a simple substitution cipher. - If 'encrypt' is True, shift each letter in 'text' by the given 'shift' value to get the encrypted message. - If 'encrypt' is False, shift each letter in 'text' by the negative of the given 'shift' value to get the decrypted message. Non-alphabetic characters should remain unchanged. Examples: >>> cipher(\\"Hello World!\\", 3, True) 'Khoor Zruog!' >>> cipher(\\"Khoor Zruog!\\", 3, False) 'Hello World!' >>> cipher(\\"abc xyz\\", 1, True) 'bcd yza' >>> cipher(\\"bcd yza\\", 1, False) 'abc xyz' >>> cipher(\\"abc xyz\\", -1, True) 'zab wxy'","solution":"def cipher(text: str, shift: int, encrypt: bool) -> str: result = [] # Adjust the shift for decryption if necessary if not encrypt: shift = -shift for char in text: if char.isalpha(): start = ord('A') if char.isupper() else ord('a') result.append(chr((ord(char) - start + shift) % 26 + start)) else: result.append(char) return ''.join(result)"},{"question":"def double_numbers(arr: list) -> list: Doubles every number in the given array. >>> double_numbers([1, 2, 3, 4]) [2, 4, 6, 8] >>> double_numbers([-1, -2, -3, -4]) [-2, -4, -6, -8] >>> double_numbers([0, 1000000000, -999999999]) [0, 2000000000, -1999999998]","solution":"def double_numbers(arr: list) -> list: Returns a new list with each integer in the input list doubled. return [x * 2 for x in arr]"},{"question":"def compress_string(s: str) -> str: Compresses the given string using run-length encoding. If the compressed string is not shorter than the original string, returns the original string. Args: s: The string to compress. Returns: The compressed string or the original string if compression does not reduce the size. Example: >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"aaaaaaaaaa\\") 'a10' >>> compress_string(\\"\\") '' >>> compress_string(\\"aabbbca\\") 'a2b3c1a1' # Your code goes here","solution":"def compress_string(s: str) -> str: Compresses the given string using run-length encoding. If the compressed string is not shorter than the original string, returns the original string. Args: s: The string to compress. Returns: The compressed string or the original string if compression does not reduce the size. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def reverse_words_in_string(s: str) -> str: Reverses each word in the input string while keeping the words in the same order. Args: s (str): The string to be processed. Returns: str: The processed string with each word reversed and original order preserved. >>> reverse_words_in_string(\\"hello world\\") 'olleh dlrow' >>> reverse_words_in_string(\\"The quick brown fox\\") 'ehT kciuq nworb xof' >>> reverse_words_in_string(\\" example \\") ' elpmaxe ' >>> reverse_words_in_string(\\" \\") ' ' >>> reverse_words_in_string(\\"\\") '' >>> reverse_words_in_string(\\"a b c d\\") 'a b c d' >>> reverse_words_in_string(\\"hello, world!\\") ',olleh !dlrow'","solution":"def reverse_words_in_string(s: str) -> str: Reverses each word in the input string while keeping the words in the same order. Args: s (str): The string to be processed. Returns: str: The processed string with each word reversed and original order preserved. # Split the string by whitespace words = s.split(' ') # Reverse each word reversed_words = [word[::-1] for word in words] # Join them back with a single space return ' '.join(reversed_words)"},{"question":"class DequeEmptyException(Exception): pass class Deque: def __init__(self, max_capacity: int = None) -> None: Initialize the Deque with an optional maximum capacity. def add_front(self, value: int) -> None: Adds a new element at the front of the Deque. If the Deque is at max capacity, it should overwrite the oldest element on the front end. def add_back(self, value: int) -> None: Adds a new element at the back of the Deque. If the Deque is at max capacity, it should overwrite the oldest element on the back end. def remove_front(self) -> int: Removes and returns the element from the front of the Deque. If the Deque is empty, it should raise an appropriate exception. def remove_back(self) -> int: Removes and returns the element from the back of the Deque. If the Deque is empty, it should raise an appropriate exception. import pytest from solution import Deque, DequeEmptyException def test_add_and_remove_front(): deque = Deque() deque.add_front(1) deque.add_front(2) assert deque.remove_front() == 2 assert deque.remove_front() == 1 def test_add_and_remove_back(): deque = Deque() deque.add_back(1) deque.add_back(2) assert deque.remove_back() == 2 assert deque.remove_back() == 1 def test_empty_deque(): deque = Deque() with pytest.raises(DequeEmptyException): deque.remove_front() with pytest.raises(DequeEmptyException): deque.remove_back() def test_bounded_deque_add_back(): deque = Deque(max_capacity=3) deque.add_back(1) deque.add_back(2) deque.add_back(3) deque.add_back(4) assert deque.remove_front() == 2 assert deque.remove_front() == 3 assert deque.remove_front() == 4 def test_bounded_deque_add_front(): deque = Deque(max_capacity=3) deque.add_front(1) deque.add_front(2) deque.add_front(3) deque.add_front(4) assert deque.remove_back() == 2 assert deque.remove_back() == 3 assert deque.remove_back() == 4","solution":"class DequeEmptyException(Exception): pass class Deque: def __init__(self, max_capacity: int = None) -> None: self.deque = [] self.max_capacity = max_capacity def add_front(self, value: int) -> None: if self.max_capacity and len(self.deque) >= self.max_capacity: self.deque.pop() self.deque.insert(0, value) def add_back(self, value: int) -> None: if self.max_capacity and len(self.deque) >= self.max_capacity: self.deque.pop(0) self.deque.append(value) def remove_front(self) -> int: if not self.deque: raise DequeEmptyException(\\"Deque is empty\\") return self.deque.pop(0) def remove_back(self) -> int: if not self.deque: raise DequeEmptyException(\\"Deque is empty\\") return self.deque.pop()"},{"question":"def diagonal_sum(matrix: list) -> dict: Returns the sum of the primary and secondary diagonals of a square matrix. Args: matrix (list): A list of lists of integers representing the square matrix. Returns: dict: A dictionary containing the sums of the primary and secondary diagonals. Raises: ValueError: If the input matrix is not a square matrix or contains non-integer elements.","solution":"def diagonal_sum(matrix: list) -> dict: Returns the sum of the primary and secondary diagonals of a square matrix. Args: matrix (list): A list of lists of integers representing the square matrix. Returns: dict: A dictionary containing the sums of the primary and secondary diagonals. Raises: ValueError: If the input matrix is not a square matrix or contains non-integer elements. if not all(isinstance(row, list) and all(isinstance(el, int) for el in row) for row in matrix): raise ValueError(\\"All elements of the matrix must be integers\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"Input must be a square matrix\\") primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n-1-i] return { \\"primary_diagonal_sum\\": primary_diagonal_sum, \\"secondary_diagonal_sum\\": secondary_diagonal_sum }"},{"question":"def process_files(file_list: list[str], operation: dict[str, str]) -> dict[str, list[str]]: Processes the file list based on their extensions and the given operations. Parameters: - file_list (list of str): List of file names. - operation (dict of str: str): A dictionary mapping file extensions to operations. Returns: - dict of str: list of str: Dictionary mapping each extension to a list of files. Example: >>> file_list = [\\"data.csv\\", \\"image.png\\", \\"document.pdf\\", \\"archive.zip\\", \\"script.py\\"] >>> operation = { >>> \\"csv\\": \\"Load to Database\\", >>> \\"png\\": \\"Compress Image\\", >>> \\"pdf\\": \\"Extract Text\\", >>> \\"zip\\": \\"Unzip Archive\\", >>> \\"py\\": \\"Execute Script\\" >>> } >>> process_files(file_list, operation) {'csv': ['data.csv'], 'png': ['image.png'], 'pdf': ['document.pdf'], 'zip': ['archive.zip'], 'py': ['script.py']}","solution":"def process_files(file_list, operation): Processes the file list based on their extensions and the given operations. Parameters: - file_list (list of str): List of file names. - operation (dict of str: str): A dictionary mapping file extensions to operations. Returns: - dict of str: list of str: Dictionary mapping each extension to a list of files. result = {} for file in file_list: # Split the file name to get the extension file_name, ext = file.rsplit('.', 1) # Get the operation for the current extension if ext in operation: op = operation[ext] print(f\\"{op}: {file}\\") # Append the file to the list of this extension if ext not in result: result[ext] = [] result[ext].append(file) return result"},{"question":"def has_cycle(graph: dict) -> bool: Determines if the undirected graph contains any cycles. :param graph: A dictionary representing the adjacency list of the graph. :return: True if the graph contains a cycle, False otherwise. >>> has_cycle({0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2]}) True >>> has_cycle({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}) False >>> has_cycle({}) False","solution":"def has_cycle(graph: dict) -> bool: Determines if the undirected graph contains any cycles. :param graph: A dictionary representing the adjacency list of the graph. :return: True if the graph contains a cycle, False otherwise. def dfs(node, parent, visited): visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, node, visited): return True elif neighbor != parent: return True return False visited = set() # Check all components of the graph for node in graph: if node not in visited: if dfs(node, -1, visited): return True return False"},{"question":"def digit_frequency(number_list: list) -> dict: Calculate the frequency of each digit in the given list of integers. :param number_list: List of integers to be analyzed. :return: Dictionary with digit frequencies. >>> digit_frequency([123, 456, 789, 101]) {'0': 2, '1': 3, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1} # Your implementation goes here. pass def test_all_digits_present(): assert digit_frequency([1234567890]) == { '0': 1, '1': 1, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1 } def test_multiple_occurrences(): assert digit_frequency([111, 2222, 333]) == { '0': 0, '1': 3, '2': 4, '3': 3, '4': 0, '5': 0, '6': 0, '7': 0, '8': 0, '9': 0 } def test_mixed_sign_numbers(): assert digit_frequency([123, -321, 456, -654, 789]) == { '0': 0, '1': 2, '2': 2, '3': 2, '4': 2, '5': 2, '6': 2, '7': 1, '8': 1, '9': 1 } def test_with_zero(): assert digit_frequency([0, 12345, 67890]) == { '0': 2, '1': 1, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1 } def test_large_numbers(): assert digit_frequency([100000001]) == { '0': 7, '1': 2, '2': 0, '3': 0, '4': 0, '5': 0, '6': 0, '7': 0, '8': 0, '9': 0 }","solution":"def digit_frequency(number_list: list) -> dict: Calculate the frequency of each digit in the given list of integers. :param number_list: List of integers to be analyzed. :return: Dictionary with digit frequencies. frequencies = {str(digit): 0 for digit in range(10)} for number in number_list: for digit in str(abs(number)): frequencies[digit] += 1 return frequencies"},{"question":"# Problem Statement: You need to design a function \`count_subsequences_sum(arr: List[int], target: int) -> int\` that counts the number of contiguous subsequences within the array \`arr\` that sum up to \`target\`. # Input: * A list of integers \`arr\` where \`2 <= len(arr) <= 10^4\` and \`-10^5 <= arr[i] <= 10^5\` for each element in \`arr\`. * An integer \`target\` where \`-10^9 <= target <= 10^9\`. # Output: * An integer representing the number of contiguous subsequences that sum up to \`target\`. # Constraints: * The function should handle the input efficiently within the given constraints. * Focus on optimizing for time complexity using appropriate data structures and algorithms. # Examples: count_subsequences_sum([1, 2, 3, 4], 3) -> 2 # (subsequences: [1, 2], [3]) count_subsequences_sum([1, -1, 1, 1, -1], 0) -> 4 # (subsequences: [1, -1], [-1, 1], [1, -1], [1, -1, 1]) count_subsequences_sum([1, 1, 1, 1], 2) -> 3 # (subsequences: [1, 1], [1, 1], [1, 1]) count_subsequences_sum([5, 6, -5, 5, 3, 5, 3], 8) -> 4 # (subsequences: [5, 3], [6, -5, 5, 3, 5, 3]) # Directions: 1. Follow the provided function signature exactly. 2. Ensure the solution correctly handles large ranges of values and potential edge cases. 3. Consider utilizing efficient data structures, such as hashes or sliding windows, to achieve an optimal solution.","solution":"from typing import List def count_subsequences_sum(arr: List[int], target: int) -> int: prefix_sum_count = {0: 1} current_sum = 0 count = 0 for num in arr: current_sum += num if (current_sum - target) in prefix_sum_count: count += prefix_sum_count[current_sum - target] if current_sum in prefix_sum_count: prefix_sum_count[current_sum] += 1 else: prefix_sum_count[current_sum] = 1 return count"},{"question":"def generate_fibonacci_sequence(n: int) -> list[int]: Generates the first n Fibonacci numbers. Parameters: n (int): The number of Fibonacci numbers to generate. Must be a non-negative integer. Returns: list[int]: A list containing the first n Fibonacci numbers. Raises: ValueError: If the input n is a negative integer. Examples: >>> generate_fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci_sequence(1) [0] >>> generate_fibonacci_sequence(0) [] >>> generate_fibonacci_sequence(-5) Traceback (most recent call last): ... ValueError: The number of elements should be a non-negative integer","solution":"def generate_fibonacci_sequence(n: int) -> list[int]: Generates the first n Fibonacci numbers. Parameters: n (int): The number of Fibonacci numbers to generate. Must be a non-negative integer. Returns: list[int]: A list containing the first n Fibonacci numbers. Raises: ValueError: If the input n is a negative integer. if n < 0: raise ValueError(\\"The number of elements should be a non-negative integer\\") # Base cases if n == 0: return [] elif n == 1: return [0] # Start the sequence with the first two Fibonacci numbers fib_sequence = [0, 1] # Generate the rest of the sequence for _ in range(2, n): next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"def is_palindromic_prime(n: int) -> bool: Verifies whether a given positive integer \`n\` is a palindromic prime. >>> is_palindromic_prime(101) True >>> is_palindromic_prime(131) True >>> is_palindromic_prime(10) False pass def find_palindromic_primes(limit: int) -> List[int]: Finds all palindromic primes up to a specified limit. >>> find_palindromic_primes(200) [2, 3, 5, 7, 11, 101, 131, 151, 181, 191] pass","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindromic_prime(n): if not isinstance(n, int) or n < 2: raise ValueError(\\"Input must be an integer greater than or equal to 2.\\") return str(n) == str(n)[::-1] and is_prime(n) def find_palindromic_primes(limit): if not isinstance(limit, int) or limit < 2: raise ValueError(\\"Limit must be an integer greater than or equal to 2.\\") palindromic_primes = [] for num in range(2, limit + 1): if is_palindromic_prime(num): palindromic_primes.append(num) return palindromic_primes"},{"question":"def is_permutation_in_string(s1: str, s2: str) -> bool: Determines if any permutation of s2 is a substring of s1. >>> is_permutation_in_string(\\"oidbcaf\\", \\"abc\\") True >>> is_permutation_in_string(\\"oidbcafoo\\", \\"bafo\\") True >>> is_permutation_in_string(\\"oidbcafiaeb\\", \\"abf\\") False >>> is_permutation_in_string(\\"a\\", \\"ab\\") False >>> is_permutation_in_string(\\"abc\\", \\"abc\\") True >>> is_permutation_in_string(\\"abcde\\", \\"edcba\\") True","solution":"def is_permutation_in_string(s1: str, s2: str) -> bool: from collections import Counter len_s1, len_s2 = len(s1), len(s2) # Edge case where permutation of a longer string cannot fit in a shorter string if len_s2 > len_s1: return False s2_counter = Counter(s2) window_counter = Counter(s1[:len_s2]) if window_counter == s2_counter: return True for i in range(len_s2, len_s1): window_counter[s1[i]] += 1 window_counter[s1[i - len_s2]] -= 1 if window_counter[s1[i - len_s2]] == 0: del window_counter[s1[i - len_s2]] if window_counter == s2_counter: return True return False"},{"question":"def sum_nested_parentheses(expression: str) -> int: Process a string containing a mathematical expression with nested parentheses and sum all the integer values within all parentheses. >>> sum_nested_parentheses(\\"(12)(34)\\") 46 >>> sum_nested_parentheses(\\"(12(34)56)\\") 102 >>> sum_nested_parentheses(\\"abc(11(de3f456)78)xyz\\") 548 >>> sum_nested_parentheses(\\"(1(2(3(4)5(6)7(8)9)10)11)\\") 66 >>> sum_nested_parentheses(\\"no_numbers_here\\") 0 >>> sum_nested_parentheses(\\"(12(34)\\") Traceback (most recent call last): ... ValueError: Unmatched or misordered parentheses","solution":"def sum_nested_parentheses(expression: str) -> int: stack = [] current_number = '' total_sum = 0 for char in expression: if char == '(': if current_number: stack[-1] += int(current_number) current_number = '' stack.append(0) elif char == ')': if not stack: raise ValueError(\\"Unmatched or misordered parentheses\\") if current_number: stack[-1] += int(current_number) current_number = '' num_to_add = stack.pop() if stack: stack[-1] += num_to_add else: total_sum += num_to_add elif char.isdigit(): current_number += char else: if current_number: if stack: stack[-1] += int(current_number) current_number = '' if stack: raise ValueError(\\"Unmatched or misordered parentheses\\") return total_sum"},{"question":"from typing import List def can_partition_k_subsets(nums: List[int], k: int) -> bool: Determine if you can partition the array into exactly k subsets with equal sums. >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition_k_subsets([1, 2, 3, 4], 3) False >>> can_partition_k_subsets([1, 1, 1, 1], 2) True >>> can_partition_k_subsets([2, 2, 2, 2, 3, 4], 2) False >>> can_partition_k_subsets([2, 2, 2, 2, 2, 2], 3) True >>> can_partition_k_subsets([1], 1) True >>> can_partition_k_subsets([1, 1, 1], 2) False >>> can_partition_k_subsets([2, 4, 5, 7], 3) False >>> can_partition_k_subsets([4, 4, 4, 4, 4, 4], 3) True if k == 1: return True if sum(nums) % k != 0: return False target = sum(nums) // k nums.sort(reverse=True) subsets = [0] * k def backtrack(index): if index == len(nums): return all(x == target for x in subsets) for i in range(k): if subsets[i] + nums[index] <= target: subsets[i] += nums[index] if backtrack(index + 1): return True subsets[i] -= nums[index] if subsets[i] == 0: break return False return backtrack(0)","solution":"from typing import List def can_partition_k_subsets(nums: List[int], k: int) -> bool: if k == 1: return True if sum(nums) % k != 0: return False target = sum(nums) // k nums.sort(reverse=True) subsets = [0] * k def backtrack(index): if index == len(nums): return all(x == target for x in subsets) for i in range(k): if subsets[i] + nums[index] <= target: subsets[i] += nums[index] if backtrack(index + 1): return True subsets[i] -= nums[index] if subsets[i] == 0: break return False return backtrack(0)"},{"question":"from typing import List, Tuple def perform_operations(arr: List[int], operations: List[Tuple[str, int]]) -> List[int]: Perform a series of operations on an array, including rotations and queries. A rotation shifts all elements of the array to the right by one position, and a query returns the element at a specified index. Parameters: arr (List[int]): The initial array. operations (List[Tuple[str, int]]): A list of operations, where each operation is either a rotation (\\"rotate\\") or a query (\\"query\\") with an index. Returns: List[int]: A list of query results. Example: >>> perform_operations([1, 2, 3, 4, 5], [(\\"rotate\\", 0), (\\"rotate\\", 0), (\\"query\\", 0), (\\"query\\", 1)]) [4, 5] >>> perform_operations([3, 8, 9, 7, 6], [(\\"rotate\\", 0), (\\"query\\", 1), (\\"rotate\\", 0), (\\"query\\", 3)]) [9, 8]","solution":"from typing import List, Tuple def perform_operations(arr: List[int], operations: List[Tuple[str, int]]) -> List[int]: n = len(arr) effective_rotations = 0 results = [] for op, idx in operations: if op == \\"rotate\\": effective_rotations = (effective_rotations + 1) % n elif op == \\"query\\": adjusted_index = (idx - effective_rotations) % n results.append(arr[adjusted_index]) return results"},{"question":"def find_first_last_position(numbers, target): Returns the indices of the first and last occurrence of a given element in a sorted list of integers. If the element is not found, returns [-1, -1]. >>> find_first_last_position([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> find_first_last_position([5, 7, 7, 8, 8, 10], 6) [-1, -1] >>> find_first_last_position([1, 2, 3, 4, 4, 4, 5], 4) [3, 5] >>> find_first_last_position([], 0) [-1, -1]","solution":"def find_first_last_position(numbers, target): Returns the indices of the first and last occurrence of a given element in a sorted list of integers. If the element is not found, returns [-1, -1]. def find_first(numbers, target): left, right = 0, len(numbers) - 1 first_position = -1 while left <= right: mid = left + (right - left) // 2 if numbers[mid] == target: first_position = mid right = mid - 1 # Search in the left half elif numbers[mid] < target: left = mid + 1 else: right = mid - 1 return first_position def find_last(numbers, target): left, right = 0, len(numbers) - 1 last_position = -1 while left <= right: mid = left + (right - left) // 2 if numbers[mid] == target: last_position = mid left = mid + 1 # Search in the right half elif numbers[mid] < target: left = mid + 1 else: right = mid - 1 return last_position first_position = find_first(numbers, target) last_position = find_last(numbers, target) if first_position == -1: return [-1, -1] return [first_position, last_position]"},{"question":"from typing import List def trap_rain_water(elevations: List[int]) -> int: Compute the amount of water that can be trapped between the elevations after rainfall. The amount of water trapped at a given index is determined by the height of the tallest bar to the left and the tallest bar to the right. The water level at that index is the minimum of these two heights minus the elevation at that index. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([]) 0 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9","solution":"from typing import List def trap_rain_water(elevations: List[int]) -> int: if not elevations or len(elevations) < 3: return 0 n = len(elevations) left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevations[i]) right_max[n - 1] = elevations[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevations[i]) water_trapped = 0 for i in range(1, n - 1): water_trapped += max(0, min(left_max[i], right_max[i]) - elevations[i]) return water_trapped"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Check if str1 and str2 are anagrams, ignoring non-alphabetic characters. Args: str1 (str): the first string. str2 (str): the second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. Examples: >>> is_anagram(\\"Astronomer\\", \\"Moon starer!\\") True >>> is_anagram(\\"The Morse Code\\", \\"Here come dots!\\") True >>> is_anagram(\\"Hello, World!\\", \\"Dell, How rol!\\") True >>> is_anagram(\\"Example\\", \\"Sample\\") False >>> is_anagram(\\"Anagram\\", \\"Nag a ram!\\") True","solution":"def is_anagram(str1: str, str2: str) -> bool: Check if str1 and str2 are anagrams, ignoring non-alphabetic characters. Args: str1 (str): the first string. str2 (str): the second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. import re from collections import Counter def clean_string(s): return re.sub('[^a-zA-Z]', '', s).lower() clean_str1 = clean_string(str1) clean_str2 = clean_string(str2) return Counter(clean_str1) == Counter(clean_str2)"},{"question":"def next_permutation(lst: List[int]) -> None: Modifies the list lst in-place to produce the next lexicographical permutation. If no such permutation exists, it rearranges to the lowest possible order. >>> lst = [1, 2, 3] >>> next_permutation(lst) >>> lst [1, 3, 2] >>> lst = [3, 2, 1] >>> next_permutation(lst) >>> lst [1, 2, 3] >>> lst = [1, 1, 5] >>> next_permutation(lst) >>> lst [1, 5, 1]","solution":"def next_permutation(lst): Modifies the list lst in-place to produce the next lexicographical permutation. If no such permutation exists, it rearranges to the lowest possible order. n = len(lst) if n <= 1: return # Step 1: Find the largest index k such that lst[k] < lst[k + 1]. If no such index exists, # the permutation is the last permutation. k = n - 2 while k >= 0 and lst[k] >= lst[k + 1]: k -= 1 if k == -1: # lst is sorted in descending order, rearrange to the lowest possible order lst.reverse() return # Step 2: Find the largest index l greater than k such that lst[k] < lst[l] l = n - 1 while l > k and lst[l] <= lst[k]: l -= 1 # Step 3: Swap the value of lst[k] with that of lst[l] lst[k], lst[l] = lst[l], lst[k] # Step 4: Reverse the sequence from lst[k + 1] to the end lst[k + 1:] = reversed(lst[k + 1:])"},{"question":"def sort_sales_data(sales_data): Sort the sales data by total sales in descending order and by year in ascending order when sales are equal. Args: sales_data (list): A list of dictionaries containing 'year' and 'total_sales'. Returns: list: Sorted list of dictionaries. Examples: >>> sales_data = [ ... {\\"year\\": 2020, \\"total_sales\\": 1500.75}, ... {\\"year\\": 2019, \\"total_sales\\": 1600.60}, ... {\\"year\\": 2021, \\"total_sales\\": 1500.75}, ... {\\"year\\": 2018, \\"total_sales\\": 1400.50}, ... ] >>> sort_sales_data(sales_data) [ {\\"year\\": 2019, \\"total_sales\\": 1600.60}, {\\"year\\": 2020, \\"total_sales\\": 1500.75}, {\\"year\\": 2021, \\"total_sales\\": 1500.75}, {\\"year\\": 2018, \\"total_sales\\": 1400.50}, ] >>> sales_data = [ ... {\\"year\\": 2015, \\"total_sales\\": 3000.00}, ... {\\"year\\": 2016, \\"total_sales\\": 3000.00}, ... {\\"year\\": 2014, \\"total_sales\\": 4000.00}, ... ] >>> sort_sales_data(sales_data) [ {\\"year\\": 2014, \\"total_sales\\": 4000.00}, {\\"year\\": 2015, \\"total_sales\\": 3000.00}, {\\"year\\": 2016, \\"total_sales\\": 3000.00}, ]","solution":"def sort_sales_data(sales_data): Sorts the sales data by total sales in descending order. If two entries have the same total sales, they are sorted by year in ascending order. Parameters: sales_data (list): A list of dictionaries containing 'year' and 'total_sales'. Returns: list: Sorted list of dictionaries. # Sorting primarily by total sales (descending) and secondarily by year (ascending) return sorted(sales_data, key=lambda x: (-x['total_sales'], x['year']))"},{"question":"def rotate_elements(input_list: list[int], count: int) -> list[int]: Rotates elements in a list to the right by the specified count. Arguments: input_list -- a list of integers to be rotated. count -- an integer specifying the number of places to rotate. Returns: A list of integers with elements rotated to the right by the given count. >>> rotate_elements([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_elements([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_elements([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_elements([1, 2, 3], 5) [2, 3, 1] >>> rotate_elements([], 3) [] >>> rotate_elements([1, 2, 'a', 4], 2) Traceback (most recent call last): ... ValueError: All elements in input_list must be integers >>> rotate_elements([1], 2) [1]","solution":"def rotate_elements(input_list: list[int], count: int) -> list[int]: Rotates elements in a list to the right by the specified count. Arguments: input_list -- a list of integers to be rotated. count -- an integer specifying the number of places to rotate. Returns: A list of integers with elements rotated to the right by the given count. if not all(isinstance(element, int) for element in input_list): raise ValueError(\\"All elements in input_list must be integers\\") if len(input_list) == 0: return [] count = count % len(input_list) # Ensure count is within list length return input_list[-count:] + input_list[:-count]"},{"question":"def enhanced_merge_sort(collection: list) -> list: Enhanced merge sort that uses insertion sort for subarrays of size <= 10, and performs in-place merging to save memory usage. >>> enhanced_merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> enhanced_merge_sort([]) [] >>> enhanced_merge_sort([-5, -1, 0, 3, 2]) [-5, -1, 0, 2, 3] >>> enhanced_merge_sort([7, 2, 9, 4, 3, 8, 1, 6, 5, 0]) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # Implementation here from solution import enhanced_merge_sort def test_enhanced_merge_sort_example_cases(): assert enhanced_merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert enhanced_merge_sort([]) == [] assert enhanced_merge_sort([-5, -1, 0, 3, 2]) == [-5, -1, 0, 2, 3] assert enhanced_merge_sort([7, 2, 9, 4, 3, 8, 1, 6, 5, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] def test_enhanced_merge_sort_small_array(): assert enhanced_merge_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def test_enhanced_merge_sort_single_element(): assert enhanced_merge_sort([1]) == [1] def test_enhanced_merge_sort_duplicates(): assert enhanced_merge_sort([5, 4, 3, 3, 2, 1, 0, 0, -1, -1]) == [-1, -1, 0, 0, 1, 2, 3, 3, 4, 5] def test_enhanced_merge_sort_large_array(): import random large_array = random.sample(range(10**6), 10**6) sorted_large_array = sorted(large_array) assert enhanced_merge_sort(large_array) == sorted_large_array","solution":"def enhanced_merge_sort(collection: list) -> list: Enhanced merge sort that uses insertion sort for subarrays of size <= 10. def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr, left, middle, right): left_half_size = middle - left + 1 right_half_size = right - middle left_half = arr[left:left + left_half_size] right_half = arr[middle + 1:middle + 1 + right_half_size] i, j, k = 0, 0, left while i < left_half_size and j < right_half_size: if left_half[i] <= right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < left_half_size: arr[k] = left_half[i] i += 1 k += 1 while j < right_half_size: arr[k] = right_half[j] j += 1 k += 1 def merge_sort(arr, left, right): if left < right: if right - left <= 10: insertion_sort(arr, left, right) else: middle = (left + right) // 2 merge_sort(arr, left, middle) merge_sort(arr, middle + 1, right) merge(arr, left, middle, right) if collection: merge_sort(collection, 0, len(collection) - 1) return collection"},{"question":"def balanced_string_splits(s: str) -> int: Count the minimum number of splits required to divide a given string into balanced parts. >>> balanced_string_splits(\\"RLRRLLRLRL\\") 4 >>> balanced_string_splits(\\"RLLLLRRRLR\\") 3 >>> balanced_string_splits(\\"LLLL\\") 0","solution":"def balanced_string_splits(s: str) -> int: balanced_splits = 0 count = 0 for char in s: if char == 'L': count += 1 elif char == 'R': count -= 1 if count == 0: balanced_splits += 1 return balanced_splits"},{"question":"def circular_array_rotation(array: list[int], rotations: int) -> list[int]: Perform a circular rotation to the right on the array. >>> circular_array_rotation([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> circular_array_rotation([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] >>> circular_array_rotation([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] >>> circular_array_rotation([1], 3) == [1] >>> circular_array_rotation([], 4) == []","solution":"def circular_array_rotation(array: list[int], rotations: int) -> list[int]: Rotates the given array to the right by the specified number of rotations. if not array: # If the array is empty, no rotation is needed return array n = len(array) rotations = rotations % n # This reduces the number of rotations needed return array[-rotations:] + array[:-rotations]"},{"question":"import numpy as np def k_means_segmentation(img: np.ndarray, k: int, max_iters: int = 100) -> np.ndarray: Segment the image using K-means clustering. :param img: input image as a numpy array with shape (H, W, 3). :param k: the number of clusters to segment the image into. :param max_iters: the maximum number of iterations for the K-means algorithm. :return: segmented image with the same shape as the input image. >>> img = np.array([[[0, 0, 0], [255, 255, 255]], [[255, 255, 255], [0, 0, 0]]], dtype=np.uint8) >>> k_means_segmentation(img, 2).shape (2, 2, 3)","solution":"import numpy as np def k_means_segmentation(img: np.ndarray, k: int, max_iters: int = 100) -> np.ndarray: Segment the image using K-means clustering. :param img: input image as a numpy array with shape (H, W, 3). :param k: the number of clusters to segment the image into. :param max_iters: the maximum number of iterations for the K-means algorithm. :return: segmented image with the same shape as the input image. # Reshape the image to a 2D array of pixels pixels = img.reshape(-1, 3) num_pixels = pixels.shape[0] # Randomly initialize the centroids by selecting random k pixels from the image np.random.seed(42) centroids = pixels[np.random.choice(num_pixels, k, replace=False)] for _ in range(max_iters): # Compute the distance between each pixel and the centroids distances = np.linalg.norm(pixels[:, np.newaxis] - centroids, axis=2) # Assign each pixel to the closest centroid labels = np.argmin(distances, axis=1) # Calculate the new centroids new_centroids = np.array([pixels[labels == i].mean(axis=0) for i in range(k)]) # Check for convergence (if centroids do not change) if np.all(centroids == new_centroids): break centroids = new_centroids # Replace each pixel's color with the centroid color of the cluster it belongs to segmented_pixels = centroids[labels].reshape(img.shape) return segmented_pixels.astype(np.uint8)"},{"question":"def is_valid_extension(filename: str, allowed_extensions: List[str]) -> bool: Returns True if the file extension of the input filename is found in the allowed_extensions list, and False otherwise. >>> is_valid_extension(\\"example.txt\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) True >>> is_valid_extension(\\"example.pdf\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) True >>> is_valid_extension(\\"example\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) False >>> is_valid_extension(\\"example.\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) False >>> is_valid_extension(\\"example.TXT\\", [\\"txt\\", \\"pdf\\", \\"doc\\"]) True >>> is_valid_extension(\\"example.jpeg\\", [\\"jpg\\", \\"jpeg\\", \\"png\\"]) True >>> is_valid_extension(\\"example.docx\\", [\\"doc\\", \\"pdf\\"]) False","solution":"from typing import List def is_valid_extension(filename: str, allowed_extensions: List[str]) -> bool: # Strip the extension from the filename if '.' not in filename or filename.endswith('.'): return False # Get the extension and make it case insensitive extension = filename.rsplit('.', 1)[-1].lower() # Convert allowed extensions to a set for O(1) look-up time and case insensitive allowed_extensions_set = {ext.lower() for ext in allowed_extensions} # Check if the extension is in the allowed extensions return extension in allowed_extensions_set"},{"question":"from typing import Optional, Tuple class BorrowTracker: A class to track the borrow counts of books and retrieve the most frequently borrowed book. Methods: record_borrow(book_id: int) -> None: Increments the borrow count of the book with the specified \`book_id\`. get_most_frequent_book() -> Optional[Tuple[int, int]]: Returns a tuple \`(book_id, count)\` of the book with the highest borrow count if present, else \`None\`. remove_most_frequent_book() -> Optional[Tuple[int, int]]: Removes and returns the tuple \`(book_id, count)\` of the book with the highest borrow count if present, else \`None\`. update_borrow_count(book_id: int, new_count: int) -> None: Updates the borrow count of the book with \`book_id\` to \`new_count\`. Example: >>> tracker = BorrowTracker() >>> tracker.record_borrow(101) >>> tracker.record_borrow(102) >>> tracker.record_borrow(101) >>> tracker.record_borrow(103) >>> tracker.record_borrow(101) >>> tracker.get_most_frequent_book() (101, 3) >>> tracker.update_borrow_count(101, 1) >>> tracker.get_most_frequent_book() (103, 1) >>> tracker.remove_most_frequent_book() (103, 1) >>> tracker.get_most_frequent_book() (101, 1) def record_borrow(self, book_id: int) -> None: pass # Implementation here def get_most_frequent_book(self) -> Optional[Tuple[int, int]]: pass # Implementation here def remove_most_frequent_book(self) -> Optional[Tuple[int, int]]: pass # Implementation here def update_borrow_count(self, book_id: int, new_count: int) -> None: pass # Implementation here","solution":"import heapq from collections import defaultdict class BorrowTracker: def __init__(self): self.borrow_counts = defaultdict(int) self.max_heap = [] self.book_positions = {} self.entry_finder = {} self.REMOVED = '<removed-book>' self.counter = 0 def record_borrow(self, book_id: int) -> None: if book_id in self.entry_finder: self.remove_book(book_id) self.borrow_counts[book_id] += 1 self._add_book(book_id, self.borrow_counts[book_id]) def _add_book(self, book_id: int, count: int): entry = [-count, self.counter, book_id] self.entry_finder[book_id] = entry heapq.heappush(self.max_heap, entry) self.counter += 1 def remove_book(self, book_id: int): entry = self.entry_finder.pop(book_id) entry[-1] = self.REMOVED def get_most_frequent_book(self) -> tuple | None: while self.max_heap and self.max_heap[0][-1] == self.REMOVED: heapq.heappop(self.max_heap) if not self.max_heap: return None count, _, book_id = self.max_heap[0] return (book_id, -count) def remove_most_frequent_book(self) -> tuple | None: while self.max_heap and self.max_heap[0][-1] == self.REMOVED: heapq.heappop(self.max_heap) if not self.max_heap: return None count, _, book_id = heapq.heappop(self.max_heap) self.entry_finder.pop(book_id, None) return (book_id, -count) def update_borrow_count(self, book_id: int, new_count: int) -> None: if book_id in self.entry_finder: self.remove_book(book_id) self.borrow_counts[book_id] = new_count self._add_book(book_id, new_count)"},{"question":"from typing import List, Tuple def track_and_report_bp(patient_name: str, bp_readings: List[Tuple[str, int, int]]) -> None: Tracks and reports a patient's blood pressure measurements over a period of time. Args: patient_name (str): The name of the patient. bp_readings (List[Tuple[str, int, int]]): A list of tuples containing: - date (string in the format 'YYYY-MM-DD') - Systolic blood pressure (integer) - Diastolic blood pressure (integer) Returns: None >>> track_and_report_bp(\\"John Doe\\", [(\\"2023-01-01\\", 120, 80), (\\"2023-02-01\\", 125, 82)]) Patient: John Doe Date: 2023-01-01 - Systolic: 120, Diastolic: 80 Date: 2023-02-01 - Systolic: 125, Diastolic: 82 >>> track_and_report_bp(\\"Jane Doe\\", []) Patient: Jane Doe No blood pressure readings available. # Implementation here","solution":"from typing import List, Tuple from datetime import datetime def track_and_report_bp(patient_name: str, bp_readings: List[Tuple[str, int, int]]) -> None: Tracks and reports a patient's blood pressure measurements. Args: - patient_name (str): The name of the patient. - bp_readings (List[Tuple[str, int, int]]): A list of tuples containing date (YYYY-MM-DD), systolic, and diastolic BP. Returns: - None print(f\\"Patient: {patient_name}\\") if not bp_readings: print(\\"No blood pressure readings available.\\") return for reading in bp_readings: date_str, systolic, diastolic = reading try: datetime.strptime(date_str, '%Y-%m-%d') print(f\\"Date: {date_str} - Systolic: {systolic}, Diastolic: {diastolic}\\") except ValueError: print(f\\"Invalid date format for reading: {reading}. Skipping this reading.\\")"},{"question":"def is_rotated_substring(s1: str, s2: str) -> bool: Determines if s2 is a substring of any rotation of s1. >>> is_rotated_substring(\\"waterbottle\\", \\"erbottlewat\\") == True >>> is_rotated_substring(\\"hello\\", \\"ole\\") == False >>> is_rotated_substring(\\"abcde\\", \\"cdeab\\") == True pass","solution":"def is_rotated_substring(s1: str, s2: str) -> bool: Determines if s2 is a substring of any rotation of s1. if len(s1) < len(s2): return False # Concatenating s1 with itself covers all possible rotations s1s1 = s1 + s1 return s2 in s1s1"},{"question":"def two_sum(nums: list, target: int) -> bool: Determines if there are two distinct elements in nums that sum to target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: bool: True if there are two distinct elements that sum to target, False otherwise. Test cases: >>> two_sum([2, 7, 11, 15], 9) True >>> two_sum([1, 2, 3, 4], 8) False >>> two_sum([3, 3], 6) True >>> two_sum([-1, -2, -3, -4, -5], -8) True >>> two_sum([0, 4, 3, 0], 0) True >>> two_sum([1, 2, 3, 1000000000], 1000000002) True >>> two_sum([], 1) False >>> two_sum([1], 1) False >>> two_sum([5, 5, 5, 5, 5], 10) True","solution":"def two_sum(nums, target): Determines if there are two distinct elements in nums that sum to target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: bool: True if there are two distinct elements that sum to target, False otherwise. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"class EventManager: EventManager class to manage a set of events. - add_event(identifier: str, start_time: int, end_time: int): Adds a new event with the given identifier, start time, and end time. - get_next_event(current_time: int) -> str: Returns the identifier of the next event to occur after the given current time. - is_time_slot_free(start_time: int, end_time: int) -> bool: Checks if the given time slot (from start_time to end_time) is free of any events. Examples: >>> manager = EventManager() >>> manager.add_event(\\"Meeting\\", 540, 600) >>> manager.add_event(\\"Workshop\\", 630, 720) >>> manager.add_event(\\"Lunch\\", 720, 780) >>> manager.get_next_event(500) 'Meeting' >>> manager.is_time_slot_free(600, 630) True >>> manager.is_time_slot_free(590, 620) False def __init__(self): pass def add_event(self, identifier: str, start_time: int, end_time: int): pass def get_next_event(self, current_time: int) -> str: pass def is_time_slot_free(self, start_time: int, end_time: int) -> bool: pass","solution":"class EventManager: def __init__(self): self.events = [] def add_event(self, identifier: str, start_time: int, end_time: int): self.events.append((start_time, end_time, identifier)) self.events.sort(key=lambda x: (x[0], x[1])) def get_next_event(self, current_time: int) -> str: for start, end, identifier in self.events: if start > current_time: return identifier return \\"No upcoming events\\" def is_time_slot_free(self, start_time: int, end_time: int) -> bool: for event_start, event_end, _ in self.events: if start_time < event_end and end_time > event_start: return False return True"},{"question":"def count_distinct_substrings(text: str, k: int) -> int: Calculate the number of distinct substrings of length k in a given text string. Parameters: text (str): The input text string. k (int): The length of substrings to consider. Returns: int: The number of distinct substrings of length k. Examples: >>> count_distinct_substrings(\\"ababc\\", 2) 3 >>> count_distinct_substrings(\\"abcdef\\", 1) 6 >>> count_distinct_substrings(\\"aaaaa\\", 2) 1 >>> count_distinct_substrings(\\"abababab\\", 3) 2 >>> count_distinct_substrings(\\"\\", 1) 0 >>> count_distinct_substrings(\\"a\\", 2) 0 >>> count_distinct_substrings(\\"a!@#\\", 2) 3 >>> count_distinct_substrings(\\"AaAa\\", 1) 2 >>> count_distinct_substrings(\\"12345\\", 2) 4 >>> count_distinct_substrings(\\"abababab\\", 2) 2 >>> count_distinct_substrings(\\"abcde\\", 5) 1","solution":"def count_distinct_substrings(text: str, k: int) -> int: This function counts the number of distinct substrings of length k in a given text string. Parameters: text (str): The input text string. k (int): The length of substrings to consider. Returns: int: The number of distinct substrings of length k. substrings = set() for i in range(len(text) - k + 1): substrings.add(text[i:i + k]) return len(substrings)"},{"question":"import heapq def shortest_path(edges: list[tuple[int, int, float]], start: int, end: int) -> float: Computes the shortest path from start to end in a weighted graph. Parameters: edges (list[tuple[int, int, float]]): List of edges represented as (u, v, w) tuples. start (int): Starting node. end (int): Destination node. Returns: float: The total weight of the shortest path from start to end, rounded to two decimal places. If no path exists, returns float('inf'). Examples: >>> shortest_path([(0, 1, 4.0), (0, 2, 2.0), (1, 2, 5.0), (1, 3, 10.0), (2, 4, 3.0), (4, 3, 4.0)], 0, 3) 9.0 >>> shortest_path([(0, 1, 2.5), (1, 2, 3.5), (2, 3, 1.0), (3, 4, 2.0)], 0, 4) 9.0 >>> shortest_path([(0, 1, 4.0), (1, 2, 1.0)], 0, 3) inf","solution":"import heapq def shortest_path(edges, start, end): Computes the shortest path from start to end in a weighted graph. Parameters: edges (list[tuple[int, int, float]]): List of edges represented as (u, v, w) tuples. start (int): Starting node. end (int): Destination node. Returns: float: The total weight of the shortest path from start to end, rounded to two decimal places. If no path exists, returns float('inf'). # Build graph as adjacency list graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Priority queue to store (cost, node) and initialize it with start node pq = [(0, start)] # Dictionary to store the shortest path to each node shortest_paths = {start: 0} while pq: current_cost, current_node = heapq.heappop(pq) if current_node == end: return round(current_cost, 2) if current_node in graph: for neighbor, weight in graph[current_node]: distance = current_cost + weight if neighbor not in shortest_paths or distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return float('inf')"},{"question":"def max_subarray_with_constraints(arr: list[int], k: int) -> int: Returns the maximum sum of any subarray whose length is exactly k. :param arr: List[int] - A list representing the daily changes in product prices :param k: int - The length of the subarray :return: int - The maximum sum of any subarray of length k within the input list >>> max_subarray_with_constraints([1, -2, 3, 4, -1, 2, 1, -5, 4], 3) 6 >>> max_subarray_with_constraints([-1, -2, -3, -4, -5], 2) -3 >>> max_subarray_with_constraints([5, 4, 3, 2, 1], 1) 5 >>> max_subarray_with_constraints([2, 1, -1, 3, 5, -2, 1, 4], 4) 8 from solution import max_subarray_with_constraints def test_example_1(): arr = [1, -2, 3, 4, -1, 2, 1, -5, 4] k = 3 assert max_subarray_with_constraints(arr, k) == 6 def test_example_2(): arr = [-1, -2, -3, -4, -5] k = 2 assert max_subarray_with_constraints(arr, k) == -3 def test_example_3(): arr = [5, 4, 3, 2, 1] k = 1 assert max_subarray_with_constraints(arr, k) == 5 def test_example_4(): arr = [2, 1, -1, 3, 5, -2, 1, 4] k = 4 assert max_subarray_with_constraints(arr, k) == 8 def test_all_negative_elements(): arr = [-4, -3, -2, -1, -5] k = 3 assert max_subarray_with_constraints(arr, k) == -6 def test_all_positive_elements(): arr = [1, 2, 3, 4, 5, 6] k = 2 assert max_subarray_with_constraints(arr, k) == 11 def test_mixed_elements(): arr = [4, -1, -2, 1, 5, -3, 2] k = 3 assert max_subarray_with_constraints(arr, k) == 4 def test_subarray_is_full_array(): arr = [1, 2, 3, 4, 5] k = 5 assert max_subarray_with_constraints(arr, k) == 15","solution":"def max_subarray_with_constraints(arr, k): Returns the maximum sum of any subarray whose length is exactly k. # Initial sum of the first of the first 'k' elements current_sum = sum(arr[:k]) max_sum = current_sum # use sliding window to find the maximum sum subarray of size k for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List def longest_increasing_subsequence(play_counts: List[int]) -> int: Find the length of the longest increasing subsequence in a given list of play counts. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7]) 7 >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10, 22, 33, 21, 50, 41, 60, 80, 70, 25, 30]) 6","solution":"from typing import List def longest_increasing_subsequence(play_counts: List[int]) -> int: if not play_counts: return 0 n = len(play_counts) lis = [1] * n # Initialize LIS values for all indexes # Compute optimized LIS values in a bottom up manner for i in range(1, n): for j in range(0, i): if play_counts[i] > play_counts[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Pick the maximum of all LIS values return max(lis)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Check if a binary tree is height-balanced. >>> root1 = TreeNode(3) >>> root1.left = TreeNode(9) >>> root1.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> is_balanced(root1) True >>> root2 = TreeNode(1) >>> root2.left = TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(4)), TreeNode(3)) >>> root2.right = TreeNode(2) >>> is_balanced(root2) False >>> is_balanced(None) True","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_balance_and_height(node): if not node: return (True, 0) left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) if not left_balanced or not right_balanced: return (False, 0) if abs(left_height - right_height) > 1: return (False, 0) return (True, 1 + max(left_height, right_height)) balanced, _ = check_balance_and_height(root) return balanced"},{"question":"def find_course_order(num_courses: int, prerequisites: List[Tuple[int, int]]) -> List[int]: Determine the order of courses based on prerequisites. If a cycle is detected, return an empty list. in_degree = {i: 0 for i in range(num_courses)} graph = defaultdict(list) for course, prereq in prerequisites: in_degree[course] += 1 graph[prereq].append(course) queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == num_courses: return order else: return []","solution":"from typing import List, Tuple from collections import deque, defaultdict def find_course_order(num_courses: int, prerequisites: List[Tuple[int, int]]) -> List[int]: Determine the order of courses based on prerequisites. If a cycle is detected, return an empty list. in_degree = {i: 0 for i in range(num_courses)} graph = defaultdict(list) for course, prereq in prerequisites: in_degree[course] += 1 graph[prereq].append(course) queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == num_courses: return order else: return []"},{"question":"def calculate(expression: str) -> float: Evaluate a mathematical expression passed as a string. The expression can contain integers, floating-point numbers, and operators \`+\`, \`-\`, \`*\`, \`/\`, and parentheses \`()\`. The function should handle spaces within the string and provide meaningful error messages for invalid expressions. >>> calculate(\\"3 + 5 * 2 / (7 - 3)\\") 5.5 >>> calculate(\\"(2.5 + 1.5) * 2\\") 8.0 >>> calculate(\\"2 + 3 * 4\\") 14.0 >>> calculate(\\"(2 + (3 * 4)) - 5\\") 9.0 pass if __name__ == \\"__main__\\": import pytest def test_simple_addition(): assert calculate(\\"2 + 3\\") == 5.0 def test_simple_subtraction(): assert calculate(\\"5 - 2\\") == 3.0 def test_simple_multiplication(): assert calculate(\\"3 * 4\\") == 12.0 def test_simple_division(): assert calculate(\\"10 / 2\\") == 5.0 def test_division_by_zero(): with pytest.raises(ValueError, match=\\"Division by zero.\\"): calculate(\\"10 / 0\\") def test_operator_precedence(): assert calculate(\\"2 + 3 * 4\\") == 14.0 def test_parentheses_precedence(): assert calculate(\\"(2 + 3) * 4\\") == 20.0 def test_complex_expression(): assert calculate(\\"3 + 5 * 2 / (7 - 3)\\") == 5.5 def test_nested_parentheses(): assert calculate(\\"(2 + (3 * 4)) - 5\\") == 9.0 def test_invalid_expression(): with pytest.raises(ValueError, match=\\"Malformed expression.\\"): calculate(\\"2 +\\") def test_invalid_characters(): with pytest.raises(ValueError, match=\\"Invalid character found: a\\"): calculate(\\"2 + a\\") def test_empty_expression(): with pytest.raises(ValueError, match=\\"Empty expression.\\"): calculate(\\"\\") def test_spaces_in_expression(): assert calculate(\\" 2 + 3 * 4 \\") == 14.0 assert calculate(\\" ( 2 + 3 ) * 4 \\") == 20.0 def test_floating_point_numbers(): assert calculate(\\"2.5 + 3.5\\") == 6.0 assert calculate(\\"2.5 * 3.4\\") == 8.5 assert calculate(\\"7.0 / 2.0\\") == 3.5 pytest.main()","solution":"def calculate(expression: str) -> float: def get_precedence(op): precedences = {'+': 1, '-': 1, '*': 2, '/': 2} return precedences[op] if op in precedences else 0 def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': if right == 0: raise ValueError(\\"Division by zero.\\") values.append(left / right) def greater_precedence(op1, op2): return get_precedence(op1) > get_precedence(op2) def evaluate(expression): tokens = expression.replace('(', ' ( ').replace(')', ' ) ').split() values = [] operators = [] for token in tokens: if token.isnumeric() or (('.' in token) and token.replace('.', '', 1).isdigit()): values.append(float(token)) elif token in ['+', '-', '*', '/']: while (operators and operators[-1] != '(' and greater_precedence(operators[-1], token)): apply_operator(operators, values) operators.append(token) elif token == '(': operators.append(token) elif token == ')': while operators[-1] != '(': apply_operator(operators, values) operators.pop() # Remove the '(' from the stack else: raise ValueError(f\\"Invalid character found: {token}\\") while operators: apply_operator(operators, values) return values[0] if not expression: raise ValueError(\\"Empty expression.\\") try: return evaluate(expression) except IndexError: raise ValueError(\\"Malformed expression.\\") except ValueError as e: raise ValueError(str(e))"},{"question":"def apply_discounts(products: list, discounts: list) -> list: Calculates final prices for products after applying the appropriate discounts. :param products: List of tuples, each containing ('category', 'price'). :param discounts: List of tuples, each containing ('category', 'min_price', 'max_price', 'discount_percentage'). :return: List of final prices for each product in the order they appeared in the input list. >>> apply_discounts([ ('electronics', 299.99), ('books', 19.99), ('clothing', 49.99), ('electronics', 1099.00) ], [ ('electronics', 100.00, 999.99, 10), ('electronics', 1000.00, 1500.00, 15), ('books', 0.00, 50.00, 5), ('clothing', 0.00, 100.00, 20) ]) [269.99, 18.99, 39.99, 934.15] >>> apply_discounts([ ('toys', 15.99), ('furniture', 299.99) ], [ ('electronics', 100.00, 999.99, 10), ('books', 0.00, 50.00, 5), ('clothing', 0.00, 100.00, 20) ]) [15.99, 299.99] >>> apply_discounts([ ('electronics', 100.00), ('electronics', 1500.00) ], [ ('electronics', 50.00, 200.00, 5), ('electronics', 1000.00, 1600.00, 10), ('electronics', 1500.00, 2000.00, 20) ]) [95.00, 1350.00] >>> apply_discounts([ ('electronics', 100.00), ('books', 50.00) ], [ ('electronics', 100.00, 100.00, 5), ('books', 50.00, 50.00, 10) ]) [95.00, 45.00] >>> apply_discounts([('electronics', i) for i in range(1, 10001)], [('electronics', 1, 10000, 50)]) [round((i - (i * 0.5)), 2) for i in range(1, 10001)]","solution":"def apply_discounts(products, discounts): final_prices = [] for category, price in products: discount_applied = False for disc_category, min_price, max_price, discount_percentage in discounts: if category == disc_category and min_price <= price <= max_price: discount_amount = (discount_percentage / 100) * price final_price = price - discount_amount final_prices.append(round(final_price, 2)) discount_applied = True break if not discount_applied: final_prices.append(price) return final_prices"},{"question":"def parse_url_params(url: str, params: List[str]) -> Dict[str, Any]: Parses a given URL and extracts the values of specified query parameters. Args: url (str): The URL containing query parameters. params (List[str]): A list of parameter names to extract from the URL. Returns: Dict[str, Any]: A dictionary with the specified parameters and their corresponding values. >>> parse_url_params(\\"https://example.com/search?query=python&sort=desc&limit=20\\", [\\"query\\", \\"limit\\"]) {\\"query\\": \\"python\\", \\"limit\\": \\"20\\"} >>> parse_url_params(\\"https://example.com/search?category=books&query=python&sort=desc\\", [\\"category\\", \\"query\\", \\"page\\"]) {\\"category\\": \\"books\\", \\"query\\": \\"python\\"}","solution":"from typing import List, Dict, Any import urllib.parse def parse_url_params(url: str, params: List[str]) -> Dict[str, Any]: Parses a given URL and extracts the values of specified query parameters. Args: url (str): The URL containing query parameters. params (List[str]): A list of parameter names to extract from the URL. Returns: Dict[str, Any]: A dictionary with the specified parameters and their corresponding values. query = urllib.parse.urlparse(url).query query_dict = dict(urllib.parse.parse_qsl(query)) return {param: query_dict[param] for param in params if param in query_dict}"},{"question":"def finite_difference_derivative(function, x: float, h: float = 1e-5) -> float: Approximates the derivative of 'function' at the point 'x' using the central difference method with a step size of 'h'. Parameters: - function: A callable that takes a float and returns a float (the function whose derivative is to be approximated) - x: The point at which to approximate the derivative - h: The step size for the finite difference method (default is 1e-5) Returns: - A float representing the approximate derivative of 'function' at 'x' >>> finite_difference_derivative(lambda x: x ** 2, 2) 4.0 >>> finite_difference_derivative(lambda x: 3 * x + 1, 5) 3.0 >>> finite_difference_derivative(lambda x: math.sin(x), math.pi / 2) 0.0 >>> finite_difference_derivative(lambda x: math.exp(x), 1) 2.71828 # approximately e >>> finite_difference_derivative(lambda x: x ** 3, 2) 12.0 return (function(x + h) - function(x - h)) / (2 * h)","solution":"def finite_difference_derivative(function, x: float, h: float = 1e-5) -> float: Approximates the derivative of 'function' at the point 'x' using the central difference method with a step size of 'h'. Parameters: - function: A callable that takes a float and returns a float (the function whose derivative is to be approximated) - x: The point at which to approximate the derivative - h: The step size for the finite difference method (default is 1e-5) Returns: - A float representing the approximate derivative of 'function' at 'x' return (function(x + h) - function(x - h)) / (2 * h)"},{"question":"class ProjectManager: A class to manage projects and their tasks. Methods: - add_project(project_name: str) -> None: Adds a new project with the given name. - remove_project(project_name: str) -> None: Removes the project with the given name. - add_task(project_name: str, task: str) -> None: Adds a task to the specified project. - remove_task(project_name: str, task: str) -> None: Removes a task from the specified project. - get_tasks(project_name: str) -> list: Returns a list of tasks for the specified project. - get_projects() -> list: Returns a list of all project names. def __init__(self): pass def add_project(self, project_name: str) -> None: pass def remove_project(self, project_name: str) -> None: pass def add_task(self, project_name: str, task: str) -> None: pass def remove_task(self, project_name: str, task: str) -> None: pass def get_tasks(self, project_name: str) -> list: pass def get_projects(self) -> list: pass import pytest def test_add_project(): manager = ProjectManager() manager.add_project(\\"Project A\\") assert manager.get_projects() == [\\"Project A\\"] def test_remove_project(): manager = ProjectManager() manager.add_project(\\"Project A\\") manager.remove_project(\\"Project A\\") assert manager.get_projects() == [] def test_add_task(): manager = ProjectManager() manager.add_project(\\"Project A\\") manager.add_task(\\"Project A\\", \\"Task 1\\") assert manager.get_tasks(\\"Project A\\") == [\\"Task 1\\"] def test_remove_task(): manager = ProjectManager() manager.add_project(\\"Project A\\") manager.add_task(\\"Project A\\", \\"Task 1\\") manager.remove_task(\\"Project A\\", \\"Task 1\\") assert manager.get_tasks(\\"Project A\\") == [] def test_get_tasks(): manager = ProjectManager() manager.add_project(\\"Project A\\") manager.add_task(\\"Project A\\", \\"Task 1\\") manager.add_task(\\"Project A\\", \\"Task 2\\") assert manager.get_tasks(\\"Project A\\") == [\\"Task 1\\", \\"Task 2\\"] def test_get_projects(): manager = ProjectManager() manager.add_project(\\"Project A\\") manager.add_project(\\"Project B\\") assert sorted(manager.get_projects()) == [\\"Project A\\", \\"Project B\\"] def test_add_task_to_non_existent_project(): manager = ProjectManager() manager.add_task(\\"Project A\\", \\"Task 1\\") assert manager.get_tasks(\\"Project A\\") == [] def test_remove_non_existent_task(): manager = ProjectManager() manager.add_project(\\"Project A\\") manager.remove_task(\\"Project A\\", \\"Task 1\\") assert manager.get_tasks(\\"Project A\\") == [] def test_remove_non_existent_project(): manager = ProjectManager() manager.remove_project(\\"Project A\\") assert manager.get_projects() == [] if __name__ == \\"__main__\\": pytest.main()","solution":"class ProjectManager: def __init__(self): self.projects = {} def add_project(self, project_name: str) -> None: if project_name not in self.projects: self.projects[project_name] = [] def remove_project(self, project_name: str) -> None: if project_name in self.projects: del self.projects[project_name] def add_task(self, project_name: str, task: str) -> None: if project_name in self.projects: self.projects[project_name].append(task) def remove_task(self, project_name: str, task: str) -> None: if project_name in self.projects and task in self.projects[project_name]: self.projects[project_name].remove(task) def get_tasks(self, project_name: str) -> list[str]: if project_name in self.projects: return self.projects[project_name] return [] def get_projects(self) -> list[str]: return list(self.projects.keys())"},{"question":"import numpy as np def normalize_rows(matrix: np.ndarray) -> np.ndarray: Normalizes each row of the given 2D array so that the values range between 0 and 1. Parameters: matrix (np.ndarray): The input 2D array to be normalized. Returns: np.ndarray: The row-wise normalized 2D array. Example: >>> input_matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> normalize_rows(input_matrix) array([[0. , 0.5, 1. ], [0. , 0.5, 1. ], [0. , 0.5, 1. ]]) >>> input_matrix = np.array([[10, -10, 0], [10, 10, 10], [-5, 5, 0]]) >>> normalize_rows(input_matrix) array([[1. , 0. , 0.5], [0. , 0. , 0. ], [0. , 1. , 0.5]])","solution":"import numpy as np def normalize_rows(matrix: np.ndarray) -> np.ndarray: Normalizes each row of the given 2D array so that the values range between 0 and 1. Parameters: matrix (np.ndarray): The input 2D array to be normalized. Returns: np.ndarray: The row-wise normalized 2D array. # Calculate the min and max of each row row_min = matrix.min(axis=1, keepdims=True) row_max = matrix.max(axis=1, keepdims=True) # Avoid division by zero in the case where all elements in the row are the same row_range = row_max - row_min row_range[row_range == 0] = 1 # Normalize the matrix normalized_matrix = (matrix - row_min) / row_range return normalized_matrix"},{"question":"import heapq def shortest_path(graph: dict, start: str, target: str) -> list: Finds the shortest path from start to target in a weighted, undirected graph using Dijkstra's algorithm. >>> graph = { >>> 'A': {'B': 1, 'C': 4}, >>> 'B': {'A': 1, 'C': 2, 'D': 5}, >>> 'C': {'A': 4, 'B': 2, 'D': 1}, >>> 'D': {'B': 5, 'C': 1} >>> } >>> shortest_path(graph, 'A', 'D') ['A', 'B', 'C', 'D'] >>> shortest_path(graph, 'A', 'C') ['A', 'B', 'C'] >>> shortest_path(graph, 'B', 'D') ['B', 'C', 'D'] >>> shortest_path(graph, 'C', 'A') ['C', 'B', 'A']","solution":"import heapq def shortest_path(graph, start, target): Finds the shortest path from start to target in a weighted, undirected graph using Dijkstra's algorithm. if not graph: raise ValueError(\\"Graph is empty\\") if start not in graph or target not in graph: raise ValueError(\\"Start or target node is not in the graph\\") # Priority queue to hold nodes to be processed, initialized with the start node pq = [(0, start)] # (distance, node) distances = {node: float('inf') for node in graph} distances[start] = 0 # To reconstruct the path previous_nodes = {node: None for node in graph} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == target: break # We have reached the target node for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) # Reconstruct the shortest path path = [] current = target while current is not None: path.append(current) current = previous_nodes[current] if path[-1] != start: return [] # If no valid path is found path.reverse() return path"},{"question":"class File: Class representing a file in the virtual filesystem. >>> file = File(\\"example.txt\\", \\"This is an example content.\\") >>> file.get_name() 'example.txt' >>> file.get_content() 'This is an example content.' def __init__(self, name: str, content: str) -> None: pass def get_name(self) -> str: pass def get_content(self) -> str: pass class Directory: Class representing a directory in the virtual filesystem. >>> directory = Directory(\\"sample_directory\\") >>> file1 = File(\\"file1.txt\\", \\"Content of file 1\\") >>> file2 = File(\\"file2.txt\\", \\"Content of file 2\\") >>> directory.add_file(file1) >>> directory.add_file(file2) >>> directory.list_files() ['file1.txt', 'file2.txt'] >>> retrieved_file = directory.get_file(\\"file1.txt\\") >>> retrieved_file.get_content() 'Content of file 1' >>> non_existent_file = directory.get_file(\\"non_existent.txt\\") >>> non_existent_file is None True def __init__(self, name: str) -> None: pass def add_file(self, file: File) -> None: pass def get_file(self, name: str) -> File: pass def list_files(self) -> List[str]: pass","solution":"from typing import List class File: def __init__(self, name: str, content: str) -> None: self.name = name self.content = content def get_name(self) -> str: return self.name def get_content(self) -> str: return self.content class Directory: def __init__(self, name: str) -> None: self.name = name self.files = {} def add_file(self, file: File) -> None: self.files[file.get_name()] = file def get_file(self, name: str) -> File: return self.files.get(name, None) def list_files(self) -> List[str]: return list(self.files.keys())"},{"question":"from typing import List def even_index_elements(lst: List[int]) -> List[int]: Extracts all elements from a list that are located at even indices. Parameters: lst (List[int]): A list of integers. Returns: List[int]: A new list containing all elements from the original list that are at even indices. Examples: >>> even_index_elements([10, 20, 30, 40, 50]) [10, 30, 50] >>> even_index_elements([5, 15, 25, 35, 45, 55, 65]) [5, 25, 45, 65] >>> even_index_elements([1, 2, 3, 4, 5, 6]) [1, 3, 5] >>> even_index_elements([9, 8, 7, 6, 5, 4, 3, 2]) [9, 7, 5, 3] >>> even_index_elements([]) [] pass","solution":"from typing import List def even_index_elements(lst: List[int]) -> List[int]: Returns a list of elements that are at even indices from the original list. Parameters: lst (List[int]): A list of integers. Returns: List[int]: A list of integers at even indices. return [lst[i] for i in range(0, len(lst), 2)]"},{"question":"def max_sliding_window(nums: list[int], k: int) -> list[int]: Finds the maximum value in each sliding window of size k across an array. @param nums: a list of integers. @param k: the size of the sliding window. @return: a list of the maximum values from each sliding window. If the window size k is invalid, raise a ValueError: - If nums is empty, raise a ValueError with the message \\"Input list must not be empty\\". - If k is not a positive integer, raise a ValueError with the message \\"Window size must be a positive integer\\". - If k is greater than the length of nums, raise a ValueError with the message \\"Window size must not exceed the length of the input list\\". >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([9, 11], 2) [11] >>> max_sliding_window([4, 3, 2, 1], 1) [4, 3, 2, 1] >>> max_sliding_window([1, 2, 3, 4, 5], 2) [2, 3, 4, 5]","solution":"from collections import deque def max_sliding_window(nums: list[int], k: int) -> list[int]: Finds the maximum value in each sliding window of size k across an array. @param nums: a list of integers. @param k: the size of the sliding window. @return: a list of the maximum values from each sliding window. If the window size k is invalid, raise a ValueError. if not nums: raise ValueError(\\"Input list must not be empty\\") if k <= 0: raise ValueError(\\"Window size must be a positive integer\\") if k > len(nums): raise ValueError(\\"Window size must not exceed the length of the input list\\") deq = deque() max_values = [] for i, num in enumerate(nums): while deq and deq[0] <= i - k: deq.popleft() while deq and nums[deq[-1]] < num: deq.pop() deq.append(i) if i >= k - 1: max_values.append(nums[deq[0]]) return max_values"},{"question":"import re class PalindromeChecker: def __init__(self): self.strings = [] def is_palindrome(self, word: str) -> bool: Determine if the given string is a palindrome (i.e., it reads the same backward as forward). Args: word (str): A string to be checked if it is a palindrome. Returns: bool: True if word is a palindrome, otherwise False. Constraints: - The method should be case insensitive ('A' should be treated the same as 'a'). - Only alphanumeric characters should be considered (ignore spaces, punctuation, etc.). - The length of the input string will not exceed 1000 characters. Examples: >>> checker = PalindromeChecker() >>> checker.is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> checker.is_palindrome(\\"racecar\\") == True >>> checker.is_palindrome(\\"hello\\") == False >>> checker.is_palindrome(\\"No 'x' in Nixon\\") == True","solution":"import re class PalindromeChecker: def __init__(self): self.strings = [] def is_palindrome(self, word: str) -> bool: Returns True if the given word is a palindrome, ignoring case and non-alphanumeric characters. # Normalize the word by removing non-alphanumeric characters and converting to lowercase cleaned_word = re.sub(r'[^a-zA-Z0-9]', '', word).lower() return cleaned_word == cleaned_word[::-1]"},{"question":"from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges a list of sorted integer lists into a single sorted list. >>> merge_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) == [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_sorted_lists([[1, 3, 5], [2, 4, 6], [0]]) == [0, 1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([[], [3, 4, 5], [1, 2, 6]]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([[], [], []]) == [] >>> merge_sorted_lists([[10, 20, 30]]) == [10, 20, 30] def test_merge_sorted_lists(): assert merge_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) == [1, 1, 2, 3, 4, 4, 5, 6] assert merge_sorted_lists([[1, 3, 5], [2, 4, 6], [0]]) == [0, 1, 2, 3, 4, 5, 6] assert merge_sorted_lists([[], [3, 4, 5], [1, 2, 6]]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([[], [], []]) == [] assert merge_sorted_lists([[10, 20, 30]]) == [10, 20, 30] assert merge_sorted_lists([[], [1]]) == [1] assert merge_sorted_lists([[5, 7], [1, 2, 3], [4, 6]]) == [1, 2, 3, 4, 5, 6, 7] def test_edge_cases(): assert merge_sorted_lists([[1000000], [-1000000]]) == [-1000000, 1000000] assert merge_sorted_lists([]) == [] assert merge_sorted_lists([[], [-1, 0, 1]]) == [-1, 0, 1] assert merge_sorted_lists([[1, 2, 3], [], [-2, -1, 0]]) == [-2, -1, 0, 1, 2, 3] def test_large_input(): big_list = [list(range(1000)) for _ in range(10)] merged = list(range(1000)) * 10 merged.sort() assert merge_sorted_lists(big_list) == merged","solution":"import heapq from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges a list of sorted integer lists into a single sorted list. min_heap = [] for i, sorted_list in enumerate(lists): if sorted_list: heapq.heappush(min_heap, (sorted_list[0], i, 0)) result = [] while min_heap: val, list_idx, elem_idx = heapq.heappop(min_heap) result.append(val) if elem_idx + 1 < len(lists[list_idx]): heapq.heappush(min_heap, (lists[list_idx][elem_idx + 1], list_idx, elem_idx + 1)) return result"},{"question":"def balance_tasks(tasks: list[int], num_workers: int) -> int: Simulate the allocation of tasks among a group of workers, such that the total load is balanced as evenly as possible. Args: tasks (list[int]): A list of positive integers, where each integer represents the time required to complete a task. num_workers (int): An integer representing the number of workers available to complete the tasks. Returns: int: The minimum possible maximum load any worker will have. Examples: >>> balance_tasks([10, 20, 30, 40, 50], 2) 90 >>> balance_tasks([1, 1, 1, 10, 10, 10, 1, 1, 1], 3) 13 pass from solution import balance_tasks def test_single_task(): assert balance_tasks([5], 1) == 5 def test_single_worker(): assert balance_tasks([10, 20, 30, 40, 50], 1) == 150 def test_equal_distribution(): assert balance_tasks([10, 20, 30, 40, 50], 2) == 90 def test_more_workers_than_tasks(): assert balance_tasks([10, 20, 30, 40, 50], 10) == 50 def test_varied_tasks_fewer_workers(): assert balance_tasks([1, 1, 1, 10, 10, 10, 1, 1, 1], 3) == 13 def test_balanced_distribution(): assert balance_tasks([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == 17 def test_larger_tasks(): assert balance_tasks([9, 8, 7, 6, 5, 4, 3, 2, 1], 3) == 17","solution":"def balance_tasks(tasks: list[int], num_workers: int) -> int: def canBalance(maxLoad): current_worker_load = 0 workers_needed = 1 for task in tasks: if current_worker_load + task <= maxLoad: current_worker_load += task else: workers_needed += 1 current_worker_load = task if workers_needed > num_workers: return False return True left, right = max(tasks), sum(tasks) min_possible_max_load = right while left <= right: mid = (left + right) // 2 if canBalance(mid): min_possible_max_load = mid right = mid - 1 else: left = mid + 1 return min_possible_max_load"},{"question":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: Implements the Sieve of Eratosthenes algorithm and returns a list of primes up to and including n. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> sieve_of_eratosthenes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> sieve_of_eratosthenes(13) [2, 3, 5, 7, 11, 13] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(15) [2, 3, 5, 7, 11, 13]","solution":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: Implements the Sieve of Eratosthenes algorithm and returns a list of primes up to and including n. if n < 2: return [] primes = [True] * (n + 1) p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return [p for p in range(2, n + 1) if primes[p]]"},{"question":"def is_valid_time(time_str: str) -> bool: Checks whether a given time string is in a valid \\"HH:MM\\" format. Args: time_str (str): The time string to validate. Returns: bool: True if the time string is valid, False otherwise. >>> is_valid_time(\\"18:45\\") True >>> is_valid_time(\\"25:00\\") False # Your code here def minutes_since_midnight(time: str) -> int: Converts a valid \\"HH:MM\\" time string to the number of minutes since midnight. Args: time (str): A valid time string. Returns: int: The total minutes since midnight. >>> minutes_since_midnight(\\"02:30\\") 150 >>> minutes_since_midnight(\\"12:00\\") 720 # Your code here def duration_between(start: str, end: str) -> str: Calculates the duration between two given times in a 24-hour format. Args: start (str): The starting time in \\"HH:MM\\" format. end (str): The ending time in \\"HH:MM\\" format. Returns: str: The duration in \\"HH hours and MM minutes\\" format. >>> duration_between(\\"23:30\\", \\"01:15\\") '1 hours and 45 minutes' >>> duration_between(\\"09:00\\", \\"18:00\\") '9 hours and 0 minutes' >>> duration_between(\\"06:15\\", \\"06:15\\") '24 hours and 0 minutes' # Your code here","solution":"def is_valid_time(time_str: str) -> bool: Checks whether a given time string is in a valid \\"HH:MM\\" format. Args: time_str (str): The time string to validate. Returns: bool: True if the time string is valid, False otherwise. if len(time_str) != 5 or time_str[2] != ':': return False hh, mm = time_str.split(':') if not (hh.isdigit() and mm.isdigit()): return False hours = int(hh) minutes = int(mm) return 0 <= hours < 24 and 0 <= minutes < 60 def minutes_since_midnight(time: str) -> int: Converts a valid \\"HH:MM\\" time string to the number of minutes since midnight. Args: time (str): A valid time string. Returns: int: The total minutes since midnight. hh, mm = map(int, time.split(':')) return hh * 60 + mm def duration_between(start: str, end: str) -> str: Calculates the duration between two given times in a 24-hour format. Args: start (str): The starting time in \\"HH:MM\\" format. end (str): The ending time in \\"HH:MM\\" format. Returns: str: The duration in \\"HH hours and MM minutes\\" format. start_minutes = minutes_since_midnight(start) end_minutes = minutes_since_midnight(end) if end_minutes <= start_minutes: end_minutes += 24 * 60 total_minutes = end_minutes - start_minutes hours = total_minutes // 60 minutes = total_minutes % 60 return f\\"{hours} hours and {minutes} minutes\\""},{"question":"import base64 def generate_auth_tokens(credentials: dict) -> dict: Generates basic authorization tokens for given user credentials. Args: credentials (dict): A dictionary where keys are user IDs and values are passwords. Returns: dict: A dictionary with user IDs as keys and basic authorization tokens as values. Example: >>> credentials = { ... \\"user1\\": \\"pass1\\", ... \\"admin\\": \\"adminPass\\", ... \\"guest\\": \\"guest123\\" ... } >>> generate_auth_tokens(credentials) { \\"user1\\": \\"Basic dXNlcjE6cGFzczE=\\", \\"admin\\": \\"Basic YWRtaW46YWRtaW5QYXNz\\", \\"guest\\": \\"Basic Z3Vlc3Q6Z3Vlc3QxMjM=\\" }","solution":"import base64 def generate_auth_tokens(credentials): Generates basic authorization tokens for given user credentials. Args: credentials (dict): A dictionary with user IDs as keys and passwords as values. Returns: dict: A dictionary with user IDs as keys and basic authorization tokens as values. auth_tokens = {} for user_id, password in credentials.items(): token = f\\"{user_id}:{password}\\" encoded_token = base64.b64encode(token.encode()).decode() auth_tokens[user_id] = f\\"Basic {encoded_token}\\" return auth_tokens"},{"question":"def fibonacci(n: int) -> int: Compute the nth Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(50) == 12586269025","solution":"def fibonacci(n: int) -> int: Computes the nth Fibonacci number using an iterative approach. if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def find_missing_number(arr: list) -> int: Find the missing integer in an array of integers ranging from 0 to n. >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> find_missing_number([0]) 1 >>> find_missing_number([]) 0","solution":"def find_missing_number(arr): Returns the missing number from the list arr which contains integers from 0 to n. n = len(arr) expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"def partition_list(nums: list, a: int, b: int) -> list: Partitions the list into three parts: values less than \`a\`, values between \`a\` and \`b\` (inclusive), and values greater than \`b\`. >>> partition_list([3, 1, 2, 4, 5], 2, 4) [1, 3, 2, 4, 5] >>> partition_list([10, 5, 6, 3, 2, 8], 4, 7) [3, 2, 5, 6, 10, 8] >>> partition_list([], 1, 2) [] >>> partition_list([1, 1, 1, 1], 1, 1) [1, 1, 1, 1] >>> partition_list([1, 2, 3], 4, 5) [1, 2, 3] >>> partition_list([6, 7, 8], 4, 5) [6, 7, 8] >>> partition_list([4, 5], 4, 5) [4, 5] >>> partition_list([5, 1, 8, 4, 6, 3, 2], 4, 6) [1, 3, 2, 5, 4, 6, 8] >>> partition_list([-5, -1, 0, 3, -2], -1, 2) [-5, -2, -1, 0, 3] >>> large_list = list(range(1, 1000001)) >>> partition_list(large_list, 500000, 500000) == list(range(1, 500000)) + [500000] + list(range(500001, 1000001)) True","solution":"def partition_list(nums: list, a: int, b: int) -> list: Partitions the list into three parts: values less than \`a\`, values between \`a\` and \`b\` (inclusive), and values greater than \`b\`. less_than_a = [] between_a_and_b = [] greater_than_b = [] for num in nums: if num < a: less_than_a.append(num) elif a <= num <= b: between_a_and_b.append(num) else: greater_than_b.append(num) return less_than_a + between_a_and_b + greater_than_b"},{"question":"[Completion Task in Python] # Completion Task Implement the function \`transpose_matrix(matrix: List[List[int]]) -> List[List[int]]\` with the following behavior: 1. **\`transpose_matrix(matrix: List[List[int]]) -> List[List[int]]\`** - **Description**: Transposes the given matrix. - **Input**: \`matrix\` (List[List[int]]) – A two-dimensional list of integers. - **Output**: A new two-dimensional list containing the transposed matrix. Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transpose_matrix(matrix)) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] matrix = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix)) # Output: # [ # [1, 4], # [2, 5], # [3, 6] # ] def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given matrix. :param matrix: List[List[int]] - A two-dimensional list of integers. :return: A new two-dimensional list containing the transposed matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given matrix. :param matrix: List[List[int]] - A two-dimensional list of integers. :return: A new two-dimensional list containing the transposed matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"def calculate_wave_property(velocity: float, frequency: float, wavelength: float) -> tuple[str, float]: Calculates the missing wave property (velocity, frequency, or wavelength) based on the provided two properties. Parameters: velocity (float): Wave velocity (m/s). Set to 0 if unknown. frequency (float): Wave frequency (Hz). Set to 0 if unknown. wavelength (float): Wave wavelength (m). Set to 0 if unknown. Returns: tuple: Tuple containing the name of the calculated property ('velocity', 'frequency', or 'wavelength') and its value. Raises: ValueError: If not exactly two values are provided or if any of the values are negative. Examples: >>> calculate_wave_property(0, 50, 2) ('velocity', 100.0) >>> calculate_wave_property(340, 0, 2) ('frequency', 170.0) >>> calculate_wave_property(300, 60, 0) ('wavelength', 5.0)","solution":"def calculate_wave_property(velocity: float, frequency: float, wavelength: float) -> tuple[str, float]: Calculates the missing wave property (velocity, frequency, or wavelength) based on the provided two properties. Parameters: velocity (float): Wave velocity (m/s). Set to 0 if unknown. frequency (float): Wave frequency (Hz). Set to 0 if unknown. wavelength (float): Wave wavelength (m). Set to 0 if unknown. Returns: tuple: Tuple containing the name of the calculated property ('velocity', 'frequency', or 'wavelength') and its value. Raises: ValueError: If not exactly two values are provided or if any of the values are negative. if [velocity, frequency, wavelength].count(0) != 1: raise ValueError(\\"Exactly two of the properties must be provided.\\") if velocity < 0 or frequency < 0 or wavelength < 0: raise ValueError(\\"Negative values are not allowed.\\") if velocity == 0: return \\"velocity\\", frequency * wavelength if frequency == 0: return \\"frequency\\", velocity / wavelength if wavelength == 0: return \\"wavelength\\", velocity / frequency"},{"question":"from typing import List, Tuple, Dict class HuffmanCoding: def __init__(self): Initialize your data structure here pass def build_tree(self, char_freq: List[Tuple[str, int]]) -> None: Build the Huffman Tree from the given character frequencies. pass def generate_codes(self) -> Dict[str, str]: Generate Huffman codes for each character based on the Huffman Tree. Returns: dict: A dictionary with characters as keys and their corresponding Huffman codes as values. pass def encode(self, data: str) -> str: Encode the given data using the generated Huffman codes. Args: data (str): The string data to encode. Returns: str: The encoded string. pass def decode(self, encoded_data: str) -> str: Decode the given encoded string using the Huffman Tree. Args: encoded_data (str): The encoded string. Returns: str: The original decoded string. pass # Example Usage huffman = HuffmanCoding() char_freq = [('a', 5), ('b', 9), ('c', 12), ('d', 13), ('e', 16), ('f', 45)] huffman.build_tree(char_freq) codes = huffman.generate_codes() print(codes) # Should output the Huffman codes for each character data = \\"abcde\\" encoded_data = huffman.encode(data) print(encoded_data) # Should output the encoded string decoded_data = huffman.decode(encoded_data) print(decoded_data) # Should output the original string 'abcde' import pytest def test_huffman_coding(): huffman = HuffmanCoding() char_freq = [('a', 5), ('b', 9), ('c', 12), ('d', 13), ('e', 16), ('f', 45)] huffman.build_tree(char_freq) codes = huffman.generate_codes() # Testing if all characters have codes assert all(char in codes for char, _ in char_freq) assert len(codes) == len(char_freq) test_data = \\"abcdef\\" encoded_data = huffman.encode(test_data) decoded_data = huffman.decode(encoded_data) assert test_data == decoded_data def test_huffman_encode(): huffman = HuffmanCoding() char_freq = [('a', 5), ('b', 1), ('c', 6)] huffman.build_tree(char_freq) huffman.generate_codes() data = \\"abc\\" assert huffman.encode(data) == ''.join([huffman.codes[char] for char in data]) def test_huffman_decode(): huffman = HuffmanCoding() char_freq = [('a', 5), ('b', 1), ('c', 6)] huffman.build_tree(char_freq) huffman.generate_codes() encoded_data = \\"\\".join(huffman.codes[char] for char in \\"abc\\") assert huffman.decode(encoded_data) == \\"abc\\" if __name__ == \\"__main__\\": pytest.main()","solution":"from typing import List, Tuple, Dict import heapq class HuffmanCoding: class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def __init__(self): self.root = None self.codes = {} self.reverse_codes = {} def build_tree(self, char_freq: List[Tuple[str, int]]) -> None: heap = [self.Node(char, freq) for char, freq in char_freq] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = self.Node(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) self.root = heap[0] self._generate_codes_helper(self.root, '') def _generate_codes_helper(self, node, current_code): if node is None: return if node.char is not None: self.codes[node.char] = current_code self.reverse_codes[current_code] = node.char self._generate_codes_helper(node.left, current_code + '0') self._generate_codes_helper(node.right, current_code + '1') def generate_codes(self) -> Dict[str, str]: return self.codes def encode(self, data: str) -> str: encoded_data = ''.join([self.codes[char] for char in data]) return encoded_data def decode(self, encoded_data: str) -> str: current_code = '' decoded_data = '' for bit in encoded_data: current_code += bit if current_code in self.reverse_codes: decoded_data += self.reverse_codes[current_code] current_code = '' return decoded_data"},{"question":"def matrix_chain_order(dimensions: List[int]) -> int: Returns the minimum number of multiplications needed to multiply a chain of matrices. Parameters: dimensions (List[int]): A list of integers representing the dimensions of the matrices. Returns: int: The minimum number of scalar multiplications needed to multiply the chain of matrices. >>> matrix_chain_order([1, 2, 3, 4]) 18 >>> matrix_chain_order([10, 20, 30]) 6000 >>> matrix_chain_order([40, 20, 30, 10, 30]) 26000 >>> matrix_chain_order([10, 20]) 0","solution":"def matrix_chain_order(dimensions): Returns the minimum number of multiplications needed to multiply the chain of matrices. Parameters: dimensions (List[int]): A list of integers representing the dimensions of the matrices. Returns: int: The minimum number of scalar multiplications needed to multiply the chain of matrices. # Number of matrices n = len(dimensions) - 1 # m[i][j] will hold the minimum number of scalar multiplications needed # to compute the matrix A[i]A[i+1]...A[j] = A[i..j] m = [[0 for _ in range(n)] for _ in range(n)] # L is chain length for L in range(2, n + 1): for i in range(n - L + 1): j = i + L - 1 m[i][j] = float('inf') for k in range(i, j): # q = cost/scalar multiplications q = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1] if q < m[i][j]: m[i][j] = q return m[0][n-1]"},{"question":"from typing import List def sum_of_elements(numbers: List[int]) -> int: Computes the sum of all integers in a given list. >>> sum_of_elements([1, 2, 3, 4]) 10 >>> sum_of_elements([-1, -2, -3, -4]) -10 >>> sum_of_elements([1, -1, 2, -2]) 0 >>> sum_of_elements([100]) 100 >>> sum_of_elements([]) 0","solution":"from typing import List def sum_of_elements(numbers: List[int]) -> int: Returns the sum of all integers in the provided list. return sum(numbers)"},{"question":"class CustomMinHeap: def __init__(self): Initializes an empty Min-Heap. # Implementation here def insert(self, value: int) -> None: Inserts a value into the Min-Heap. :param value: The value to be inserted. # Implementation here def extract_min(self) -> int: Extracts and returns the minimum value from the Min-Heap. :return: The minimum value. # Implementation here def increase_value(self, index: int, new_value: int) -> None: Increases the value of the element at the specified index to new_value and readjusts the heap. :param index: The index of the element to be increased. :param new_value: The new value to be assigned. # Implementation here def test_insert_and_extract_min(): heap = CustomMinHeap() heap.insert(3) heap.insert(1) heap.insert(6) heap.insert(5) heap.insert(2) heap.insert(4) assert heap.extract_min() == 1 assert heap.extract_min() == 2 assert heap.extract_min() == 3 assert heap.extract_min() == 4 assert heap.extract_min() == 5 assert heap.extract_min() == 6 assert heap.extract_min() is None def test_increase_value(): heap = CustomMinHeap() heap.insert(3) heap.insert(1) heap.insert(6) heap.insert(5) heap.insert(2) heap.insert(4) assert heap.extract_min() == 1 heap.increase_value(0, 7) assert heap.extract_min() == 3 assert heap.extract_min() == 4 assert heap.extract_min() == 5 assert heap.extract_min() == 6 assert heap.extract_min() == 7 def test_invalid_increase_value(): heap = CustomMinHeap() heap.insert(5) heap.insert(10) heap.increase_value(1, 5) assert heap.extract_min() == 5 assert heap.extract_min() == 10 def test_empty_heap(): heap = CustomMinHeap() assert heap.extract_min() is None","solution":"class CustomMinHeap: def __init__(self): Initializes an empty Min-Heap. self.heap = [] def insert(self, value: int) -> None: Inserts a value into the Min-Heap. :param value: The value to be inserted. self.heap.append(value) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: Extracts and returns the minimum value from the Min-Heap. :return: The minimum value. if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() min_value = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_value def increase_value(self, index: int, new_value: int) -> None: Increases the value of the element at the specified index to new_value and readjusts the heap. :param index: The index of the element to be increased. :param new_value: The new value to be assigned. if 0 <= index < len(self.heap) and self.heap[index] < new_value: self.heap[index] = new_value self._heapify_down(index) def _heapify_up(self, index: int): parent_index = (index - 1) // 2 while index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] index = parent_index parent_index = (index - 1) // 2 def _heapify_down(self, index: int): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"def remove_duplicate_characters(input_text: str) -> str: Remove consecutive duplicate characters in a given string. Parameters: - input_text (str): A string possibly containing sequences of consecutive duplicate characters. Returns: - str: A new string with consecutive duplicates reduced to a single character. Examples: >>> remove_duplicate_characters(\\"heeelllooo wooorrld\\") \\"helo world\\" >>> remove_duplicate_characters(\\"Thiiiss iiiis aaannn exaaamplee\\") \\"This is an example\\" >>> remove_duplicate_characters(\\"abc\\") \\"abc\\"","solution":"def remove_duplicate_characters(input_text: str) -> str: Remove consecutive duplicate characters in a given string. Parameters: - input_text (str): A string possibly containing sequences of consecutive duplicate characters. Returns: - str: A new string with consecutive duplicates reduced to a single character. if not input_text: return \\"\\" # Initialize result with the first character result = [input_text[0]] # Iterate over the string starting from the second character for i in range(1, len(input_text)): if input_text[i] != input_text[i - 1]: result.append(input_text[i]) return ''.join(result)"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring with all unique characters. If there are multiple substrings with the same length, returns the first one. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> longest_unique_substring(\\"aab\\") \\"ab\\" >>> longest_unique_substring(\\"dvdf\\") \\"vdf\\" >>> longest_unique_substring(\\"abcde\\") \\"abcde\\" >>> longest_unique_substring(\\"a\\") \\"a\\" >>> longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyz\\") \\"abcdefghijklmnopqrstuvwxyz\\" >>> longest_unique_substring(\\"abccba\\") \\"abc\\" >>> longest_unique_substring(\\"\\") \\"\\" >>> longest_unique_substring(\\"tmmzuxt\\") \\"mzuxt\\"","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring with all unique characters. If there are multiple substrings with the same length, returns the first one. n = len(s) if n == 0: return \\"\\" char_index_map = {} start = 0 max_len = 0 longest_substr_start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 > max_len: max_len = end - start + 1 longest_substr_start = start return s[longest_substr_start:longest_substr_start + max_len]"},{"question":"from typing import List def arrange_alternating(arr: List[int]) -> List[int]: Rearrange the array such that it forms an alternating sequence of positive and negative numbers. >>> arrange_alternating([1, 2, -3, -4, -2, 6]) [1, -3, 2, -4, 6, -2] >>> arrange_alternating([-1, -2, 3, 4, 5, -6]) [3, -1, 4, -2, 5, -6] >>> arrange_alternating([1, -1, 2, -2, 3, -3]) [1, -1, 2, -2, 3, -3] >>> arrange_alternating([4, -1, -2, -3, 7, 9]) [4, -1, 7, -2, 9, -3] import pytest def test_example_1(): assert arrange_alternating([1, 2, -3, -4, -2, 6]) == [1, -3, 2, -4, 6, -2] def test_example_2(): assert arrange_alternating([-1, -2, 3, 4, 5, -6]) == [3, -1, 4, -2, 5, -6] def test_example_3(): assert arrange_alternating([1, -1, 2, -2, 3, -3]) == [1, -1, 2, -2, 3, -3] def test_example_4(): assert arrange_alternating([4, -1, -2, -3, 7, 9]) == [4, -1, 7, -2, 9, -3] def test_all_positive(): assert arrange_alternating([1, 2, 3, 4]) == [1, 2, 3, 4] def test_all_negative(): assert arrange_alternating([-1, -2, -3, -4]) == [-1, -2, -3, -4] def test_equal_positives_negatives(): assert arrange_alternating([1, -1, 2, -2, 3, -3, 4, -4]) == [1, -1, 2, -2, 3, -3, 4, -4] def test_more_positives(): assert arrange_alternating([1, 2, 3, 4, 5, -1, -2, -3]) == [1, -1, 2, -2, 3, -3, 4, 5] def test_more_negatives(): assert arrange_alternating([1, 2, 3, -1, -2, -3, -4, -5]) == [1, -1, 2, -2, 3, -3, -4, -5]","solution":"from typing import List def arrange_alternating(arr: List[int]) -> List[int]: positive = [num for num in arr if num > 0] negative = [num for num in arr if num < 0] result = [] i, j = 0, 0 while i < len(positive) and j < len(negative): if len(result) == 0 or result[-1] < 0: result.append(positive[i]) i += 1 else: result.append(negative[j]) j += 1 # If positives remain while i < len(positive): result.append(positive[i]) i += 1 # If negatives remain while j < len(negative): result.append(negative[j]) j += 1 return result"},{"question":"from typing import Dict, List, Tuple, Any def dijkstra(graph: Dict[Any, List[Tuple[Any, int]]], source: Any) -> Dict[Any, int]: Implements Dijkstra's algorithm to find the shortest path from the source vertex to all other vertices in a weighted directed graph. :param graph: Dict representing the adjacency list of the graph :param source: The starting vertex for calculating the shortest paths :return: Dict with the shortest distance from source to each vertex >>> graph = { ... 'A': [('B', 1), ('C', 4)], ... 'B': [('C', 2), ('D', 5)], ... 'C': [('D', 1)], ... 'D': [] ... } >>> dijkstra(graph, 'A') {'A': 0, 'B': 1, 'C': 3, 'D': 4} >>> graph = { ... 'A': [] ... } >>> dijkstra(graph, 'A') {'A': 0} >>> graph = { ... 'A': [('B', 1)], ... 'B': [] ... } >>> dijkstra(graph, 'A') {'A': 0, 'B': 1} >>> graph = { ... 1: [(2, 6), (3, 1)], ... 2: [(1, 6), (3, 2), (4, 2)], ... 3: [(1, 1), (2, 2), (4, 1)], ... 4: [(2, 2), (3, 1)], ... } >>> dijkstra(graph, 1) {1: 0, 2: 3, 3: 1, 4: 2} >>> graph = { ... 'A': [('B', 1)], ... 'B': [], ... 'C': [('D', 1)], ... 'D': [] ... } >>> dijkstra(graph, 'A') {'A': 0, 'B': 1, 'C': float('infinity'), 'D': float('infinity')}","solution":"import heapq def dijkstra(graph, source): Implements Dijkstra's algorithm to find the shortest path from the source vertex to all other vertices in a weighted directed graph. :param graph: Dict representing the adjacency list of the graph :param source: The starting vertex for calculating the shortest paths :return: Dict with the shortest distance from source to each vertex # Initial distances are infinity distances = {vertex: float('infinity') for vertex in graph} distances[source] = 0 # The distance to the source is 0 priority_queue = [(0, source)] # Priority queue to hold vertices to explore while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Nodes can get added to the priority queue multiple times, we only process the first time we remove it if current_distance > distances[current_vertex]: continue # Examine and update the distances to each neighbor of the current vertex for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it's shorter if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"def min_palindromic_substrings(s: str) -> int: Finds and returns the minimum number of palindromic substrings required to cover the entire given string. Parameters: - s (str): The input string consisting of lowercase alphabets. Returns: - int: The minimum number of palindromic substrings. Examples: >>> min_palindromic_substrings(\\"aab\\") 2 >>> min_palindromic_substrings(\\"racecar\\") 1 >>> min_palindromic_substrings(\\"noonmadam\\") 2 pass # Unit tests from solution import min_palindromic_substrings def test_min_palindromic_substrings(): assert min_palindromic_substrings(\\"aab\\") == 2 assert min_palindromic_substrings(\\"racecar\\") == 1 assert min_palindromic_substrings(\\"noonmadam\\") == 2 assert min_palindromic_substrings(\\"abc\\") == 3 assert min_palindromic_substrings(\\"abacdc\\") == 2 def test_single_character(): assert min_palindromic_substrings(\\"a\\") == 1 def test_all_unique_characters(): assert min_palindromic_substrings(\\"abcdefg\\") == 7 def test_small_palindrome(): assert min_palindromic_substrings(\\"abba\\") == 1 def test_mixed_palindrome(): assert min_palindromic_substrings(\\"madamimadam\\") == 1","solution":"def min_palindromic_substrings(s: str) -> int: Finds and returns the minimum number of palindromic substrings required to cover the entire given string. Parameters: - s (str): The input string consisting of lowercase alphabets. Returns: - int: The minimum number of palindromic substrings. n = len(s) dp = [[False] * n for _ in range(n)] # Length 1 substrings are palindrome for i in range(n): dp[i][i] = True # Length 2 substrings are palindrome if characters are same for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True # Fill the dp table for substrings longer than 2 for length in range(3, n+1): for i in range(n-length+1): j = i+length-1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True # Minimum cuts dp array cuts = [0] * n for i in range(n): if dp[0][i]: cuts[i] = 0 else: cuts[i] = float('inf') for j in range(i): if dp[j+1][i]: cuts[i] = min(cuts[i], cuts[j]+1) return cuts[-1] + 1"},{"question":"def max_nesting_depth(s: str) -> int: Calculate the maximum nesting depth of parentheses in the string. Args: s (str): The input string containing round brackets. Returns: int: The maximum depth of nested parentheses. Examples: >>> max_nesting_depth(\\"(a(b(c)d)e)\\") 3 >>> max_nesting_depth(\\"((())\\") 3 >>> max_nesting_depth(\\"a(b)c\\") 1 >>> max_nesting_depth(\\")\\") 0 >>> max_nesting_depth(\\"\\") 0 pass def test_max_nesting_depth_example_cases(): assert max_nesting_depth(\\"(a(b(c)d)e)\\") == 3 assert max_nesting_depth(\\"((())\\") == 3 assert max_nesting_depth(\\"a(b)c\\") == 1 assert max_nesting_depth(\\")\\") == 0 assert max_nesting_depth(\\"\\") == 0 def test_max_nesting_depth_no_parentheses(): assert max_nesting_depth(\\"abcdefgh\\") == 0 def test_max_nesting_depth_single_level(): assert max_nesting_depth(\\"(a)\\") == 1 assert max_nesting_depth(\\"a(b)c(d)e(f)g\\") == 1 def test_max_nesting_depth_multiple_levels(): assert max_nesting_depth(\\"(((a)))\\") == 3 assert max_nesting_depth(\\"(a(b(c(d)e)f)g)\\") == 4 assert max_nesting_depth(\\"a(b(c(d(e)f)g(h(i)j)k)l)m\\") == 4 def test_max_nesting_depth_unbalanced(): assert max_nesting_depth(\\"(()\\") == 2 assert max_nesting_depth(\\")(\\") == 1 assert max_nesting_depth(\\"())\\") == 1 assert max_nesting_depth(\\"((a)b\\") == 2 def test_max_nesting_depth_large_input(): long_string = \\"(\\" * 5000 + \\")\\" * 5000 assert max_nesting_depth(long_string) == 5000 nested_string = \\"\\".join([\\"(\\" * i + \\")\\" * i for i in range(1, 101)]) assert max_nesting_depth(nested_string) == 100","solution":"def max_nesting_depth(s: str) -> int: Calculate the maximum nesting depth of parentheses in the string. Args: s (str): The input string containing round brackets. Returns: int: The maximum depth of nested parentheses. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': if current_depth > 0: # Only decrease if previously increased current_depth -= 1 return max_depth"},{"question":"def sort_by_nested_key(records: list, key_path: str) -> list: Sort a list of dictionaries by a nested key specified in key_path. Args: records (list): A list of dictionaries to be sorted. key_path (str): A string representing the path to the nested key, using dots (.) as separators. Returns: list: A sorted list of dictionaries based on the nested key. >>> records = [{\\"id\\": 1, \\"info\\": {\\"age\\": 30, \\"name\\": \\"Alice\\"}}, {\\"id\\": 2, \\"info\\": {\\"age\\": 25, \\"name\\": \\"Bob\\"}}, {\\"id\\": 3, \\"info\\": {\\"age\\": 35, \\"name\\": \\"Charlie\\"}}] >>> sort_by_nested_key(records, \\"info.age\\") [{\\"id\\": 2, \\"info\\": {\\"age\\": 25, \\"name\\": \\"Bob\\"}}, {\\"id\\": 1, \\"info\\": {\\"age\\": 30, \\"name\\": \\"Alice\\"}}, {\\"id\\": 3, \\"info\\": {\\"age\\": 35, \\"name\\": \\"Charlie\\"}}] >>> sort_by_nested_key(records, \\"info.name\\") [{\\"id\\": 1, \\"info\\": {\\"age\\": 30, \\"name\\": \\"Alice\\"}}, {\\"id\\": 2, \\"info\\": {\\"age\\": 25, \\"name\\": \\"Bob\\"}}, {\\"id\\": 3, \\"info\\": {\\"age\\": 35, \\"name\\": \\"Charlie\\"}}]","solution":"def sort_by_nested_key(records, key_path): Sorts a list of dictionaries by a nested key specified in key_path. Args: records (list): A list of dictionaries to be sorted. key_path (str): A string representing the path to the nested key, using dots (.) as separators. Returns: list: A sorted list of dictionaries based on the nested key. def get_nested_value(d, key_path): keys = key_path.split('.') for key in keys: d = d[key] return d return sorted(records, key=lambda x: get_nested_value(x, key_path))"},{"question":"def find_pattern_in_string(s: str, p: str) -> bool: Determines if the pattern p matches any substring of s, considering wildcards '?' and '*'. >>> find_pattern_in_string(\\"abefcdgiescdfimde\\", \\"ab*cd?i*de\\") True >>> find_pattern_in_string(\\"mississippi\\", \\"mis*is*ip*\\") True >>> find_pattern_in_string(\\"abc\\", \\"a*dc\\") False >>> find_pattern_in_string(\\"abcdef\\", \\"a?c*f\\") True >>> find_pattern_in_string(\\"hello\\", \\"h*l?o\\") True >>> find_pattern_in_string(\\"hello\\", \\"h*el*?o\\") True","solution":"def find_pattern_in_string(s: str, p: str) -> bool: Determines if the pattern p matches any substring of s, considering wildcards '?' and '*'. def match(text, pattern): dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)] dp[0][0] = True for j in range(1, len(pattern) + 1): if pattern[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, len(text) + 1): for j in range(1, len(pattern) + 1): if pattern[j - 1] == '*': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif pattern[j - 1] == '?' or pattern[j - 1] == text[i - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[len(text)][len(pattern)] for i in range(len(s)): if match(s[i:], p): return True return False"},{"question":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, target: int) -> Tuple[int, List[int]]: Uses Dijkstra's algorithm to find the shortest path from start to target in a weighted graph. :param graph: A dictionary where the keys are vertex identifiers and the values are lists of tuples. Each tuple represents a neighboring vertex and the weight of the edge to that neighbor. :param start: The starting vertex identifier. :param target: The target vertex identifier. :return: A tuple where the first element is the length of the shortest path, and the second element is the list of vertices in the shortest path from start to target. >>> graph = { ... 0: [(1, 4), (2, 1)], ... 1: [(3, 1)], ... 2: [(1, 2), (3, 5)], ... 3: [] ... } >>> dijkstra(graph, 0, 3) == (4, [0, 2, 1, 3])","solution":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, target: int) -> Tuple[int, List[int]]: Uses Dijkstra's algorithm to find the shortest path from start to target in a weighted graph. :param graph: A dictionary where the keys are vertex identifiers and the values are lists of tuples. Each tuple represents a neighboring vertex and the weight of the edge to that neighbor. :param start: The starting vertex identifier. :param target: The target vertex identifier. :return: A tuple where the first element is the length of the shortest path, and the second element is the list of vertices in the shortest path from start to target. # Priority queue: stores (distance, vertex) tuples pq = [(0, start)] # Dictionary to store the shortest distance to each vertex distances = {vertex: float('infinity') for vertex in graph} distances[start] = 0 # Dictionary to store the path to reconstruct the shortest path parent = {vertex: None for vertex in graph} while pq: current_distance, current_vertex = heapq.heappop(pq) # If we reached the target, we can reconstruct the path if current_vertex == target: path = [] while current_vertex is not None: path.append(current_vertex) current_vertex = parent[current_vertex] path.reverse() return current_distance, path # Skip if a better path to current_vertex was already found if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance parent[neighbor] = current_vertex heapq.heappush(pq, (distance, neighbor)) # If the target was not reached, return infinity distance and empty path return float('infinity'), []"},{"question":"from typing import List def count_islands(grid: List[List[int]]) -> int: Count the number of distinct islands in a 2D grid made up of '0's and '1's. An island is defined as a group of '1's (land) connected vertically or horizontally. >>> count_islands([[1, 0, 1, 0], [1, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0]]) 4 >>> count_islands([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 1 >>> count_islands([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 0 >>> count_islands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1]]) 5 Args: grid (List[List[int]]): A 2D grid made up of '0's (water) and '1's (land). Returns: int: The number of distinct islands found in the grid.","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: if not isinstance(grid, list) or any(not isinstance(row, list) for row in grid): raise TypeError(\\"Input grid must be a list of lists.\\") if len(grid) == 0 or len(grid) > 50 or len(grid[0]) == 0 or len(grid[0]) > 50: raise ValueError(\\"Grid dimensions are out of bound. Allowed dimensions are 1x1 to 50x50.\\") row_len = len(grid[0]) for row in grid: if len(row) != row_len: raise ValueError(\\"All rows in the grid must have the same length.\\") if any(cell != 0 and cell != 1 for cell in row): raise ValueError(\\"Grid can only contain 0's and 1's.\\") def dfs(r, c): if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0: return grid[r][c] = 0 dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) count = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: count += 1 dfs(r, c) return count"},{"question":"class FlightReservationSystem: def __init__(self): Initializes the flight reservation system. pass def add_flight(self, flight_number: str, num_seats: int) -> None: Adds a new flight with the given number of seats. Args: flight_number (str): The unique identifier for the flight. num_seats (int): The number of seats available on the flight. pass def reserve_seat(self, flight_number: str, seat_number: int) -> bool: Reserves a seat on the flight if it is available. Args: flight_number (str): The unique identifier for the flight. seat_number (int): The seat number to be reserved. Returns: bool: True if the reservation is successful, False otherwise. >>> frs = FlightReservationSystem() >>> frs.add_flight(\\"AA123\\", 100) >>> frs.reserve_seat(\\"AA123\\", 1) True >>> frs.reserve_seat(\\"AA123\\", 101) False pass def is_seat_available(self, flight_number: str, seat_number: int) -> bool: Returns if the seat is available on the flight. Args: flight_number (str): The unique identifier for the flight. seat_number (int): The seat number to be checked. Returns: bool: True if the seat is available, False otherwise. >>> frs = FlightReservationSystem() >>> frs.add_flight(\\"AA123\\", 100) >>> frs.is_seat_available(\\"AA123\\", 1) True >>> frs.reserve_seat(\\"AA123\\", 1) >>> frs.is_seat_available(\\"AA123\\", 1) False pass","solution":"class FlightReservationSystem: def __init__(self): self.flights = {} def add_flight(self, flight_number: str, num_seats: int) -> None: self.flights[flight_number] = [False] * num_seats def reserve_seat(self, flight_number: str, seat_number: int) -> bool: if flight_number not in self.flights: return False if seat_number < 1 or seat_number > len(self.flights[flight_number]): return False if self.flights[flight_number][seat_number-1] == True: return False self.flights[flight_number][seat_number-1] = True return True def is_seat_available(self, flight_number: str, seat_number: int) -> bool: if flight_number not in self.flights: return False if seat_number < 1 or seat_number > len(self.flights[flight_number]): return False return not self.flights[flight_number][seat_number-1]"},{"question":"import numpy as np def strassen_matrix_multiply(A: np.ndarray, B: np.ndarray) -> np.ndarray: Multiplies two square matrices using Strassen's algorithm. Parameters: A (ndarray): The first square matrix. B (ndarray): The second square matrix. Returns: C (ndarray): The resulting matrix product. Example: >>> import numpy as np >>> A = np.array([[1, 2], [3, 4]]) >>> B = np.array([[5, 6], [7, 8]]) >>> strassen_matrix_multiply(A, B) array([[19, 22], [43, 50]])","solution":"import numpy as np def strassen_matrix_multiply(A: np.ndarray, B: np.ndarray) -> np.ndarray: Multiplies two square matrices using Strassen's algorithm. Parameters: A (ndarray): The first square matrix. B (ndarray): The second square matrix. Returns: C (ndarray): The resulting matrix product. if A.shape[0] == 1: return A * B else: mid = A.shape[0] // 2 A11 = A[:mid, :mid] A12 = A[:mid, mid:] A21 = A[mid:, :mid] A22 = A[mid:, mid:] B11 = B[:mid, :mid] B12 = B[:mid, mid:] B21 = B[mid:, :mid] B22 = B[mid:, mid:] M1 = strassen_matrix_multiply(A11 + A22, B11 + B22) M2 = strassen_matrix_multiply(A21 + A22, B11) M3 = strassen_matrix_multiply(A11, B12 - B22) M4 = strassen_matrix_multiply(A22, B21 - B11) M5 = strassen_matrix_multiply(A11 + A12, B22) M6 = strassen_matrix_multiply(A21 - A11, B11 + B12) M7 = strassen_matrix_multiply(A12 - A22, B21 + B22) C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 + M3 - M2 + M6 C = np.zeros((A.shape[0], A.shape[1])) C[:mid, :mid] = C11 C[:mid, mid:] = C12 C[mid:, :mid] = C21 C[mid:, mid:] = C22 return C"},{"question":"from collections import deque class SlidingWindowAverage: A class to calculate the average of elements within a sliding window of a specified size. def __init__(self, size: int): Initializes the sliding window with the specified size. def add(self, value: float): Adds a new value to the sliding window. def average(self) -> float: Returns the average of the current values in the sliding window. # Example Usage # swa = SlidingWindowAverage(3) # swa.add(1.0) # window = [1.0] # print(swa.average()) # returns 1.0 # swa.add(2.0) # window = [1.0, 2.0] # print(swa.average()) # returns 1.5 # swa.add(3.0) # window = [1.0, 2.0, 3.0] # print(swa.average()) # returns 2.0 # swa.add(4.0) # window = [2.0, 3.0, 4.0] # print(swa.average()) # returns 3.0","solution":"from collections import deque class SlidingWindowAverage: def __init__(self, size: int): Initializes the sliding window with the specified size. self.size = size self.window = deque() self.sum = 0.0 def add(self, value: float): Adds a new value to the sliding window. self.window.append(value) self.sum += value if len(self.window) > self.size: self.sum -= self.window.popleft() def average(self) -> float: Returns the average of the current values in the sliding window. if not self.window: return 0.0 return self.sum / len(self.window)"},{"question":"def min_coins(coin_denominations: list, amount: int) -> int: Determine the minimum number of coins needed to make a certain amount of change. Args: - coin_denominations (list): A list of positive integers representing coin denominations. - amount (int): The target amount of change. Returns: - int: The minimum number of coins needed to make the amount, or -1 if it's not possible. Examples: >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1, 2, 5, 10], 27) 4 >>> min_coins([1, 2, 5], 0) 0 >>> min_coins([7], 14) 2 >>> min_coins([3, 5], 7) -1 >>> min_coins([1, 2, 5], 100) 20 >>> min_coins([3], 3) 1","solution":"def min_coins(coin_denominations, amount): # Initialize the dp array with infinity dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: 0 coins are needed to make the amount of 0 # Iterate over each denomination for coin in coin_denominations: for x in range(coin, amount + 1): if dp[x - coin] != float('inf'): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, it means we cannot make the amount with the given denominations return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"class BookSearch: A class to search books by title, author, and ISBN. Methods ------- add_book(title: str, author: str, isbn: str) -> None: Adds a new book with the given title, author, and ISBN to the search system. search_by_title(title_substring: str) -> List[str]: Finds and returns a list of book titles that contain the given title substring. The search should be case-insensitive. search_by_author(author_substring: str) -> List[str]: Finds and returns a list of book titles whose authors contain the given author substring. The search should be case-insensitive. search_by_isbn(isbn: str) -> str: Finds and returns the title of the book with the exact ISBN match. If no book is found, returns an empty string. def __init__(self): pass def add_book(self, title: str, author: str, isbn: str) -> None: pass def search_by_title(self, title_substring: str) -> List[str]: pass def search_by_author(self, author_substring: str) -> List[str]: pass def search_by_isbn(self, isbn: str) -> str: pass def test_add_book_and_search_by_title(): bs = BookSearch() bs.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"9780141182636\\") bs.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"9780061120084\\") bs.add_book(\\"1984\\", \\"George Orwell\\", \\"9780451524935\\") assert bs.search_by_title(\\"great\\") == [\\"The Great Gatsby\\"] assert bs.search_by_title(\\"1984\\") == [\\"1984\\"] assert bs.search_by_title(\\"NotExist\\") == [] def test_search_by_author(): bs = BookSearch() bs.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"9780141182636\\") bs.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"9780061120084\\") bs.add_book(\\"1984\\", \\"George Orwell\\", \\"9780451524935\\") assert bs.search_by_author(\\"Lee\\") == [\\"To Kill a Mockingbird\\"] assert bs.search_by_author(\\"Orwell\\") == [\\"1984\\"] assert bs.search_by_author(\\"Fitzgerald\\") == [\\"The Great Gatsby\\"] assert bs.search_by_author(\\"NotExist\\") == [] def test_search_by_isbn(): bs = BookSearch() bs.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"9780141182636\\") bs.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"9780061120084\\") bs.add_book(\\"1984\\", \\"George Orwell\\", \\"9780451524935\\") assert bs.search_by_isbn(\\"9780141182636\\") == \\"The Great Gatsby\\" assert bs.search_by_isbn(\\"9780451524935\\") == \\"1984\\" assert bs.search_by_isbn(\\"0000000000000\\") == \\"\\"","solution":"class BookSearch: def __init__(self): self.books = {} def add_book(self, title: str, author: str, isbn: str) -> None: self.books[isbn] = {'title': title, 'author': author} def search_by_title(self, title_substring: str) -> list: title_substring = title_substring.lower() return [book['title'] for book in self.books.values() if title_substring in book['title'].lower()] def search_by_author(self, author_substring: str) -> list: author_substring = author_substring.lower() return [book['title'] for book in self.books.values() if author_substring in book['author'].lower()] def search_by_isbn(self, isbn: str) -> str: return self.books[isbn]['title'] if isbn in self.books else \\"\\""},{"question":"from typing import List, Dict def merge_dicts(dict_list: List[Dict[str, str]]) -> Dict[str, List[str]]: Merge a list of dictionaries into a single dictionary, where definitions for the same word are stored in a list of unique values. >>> dict_list = [ >>> {\\"apple\\": \\"a fruit\\", \\"table\\": \\"a piece of furniture\\"}, >>> {\\"apple\\": \\"a tech company\\", \\"table\\": \\"data arrangement\\", \\"python\\": \\"a programming language\\"}, >>> {\\"table\\": \\"a piece of furniture\\", \\"python\\": \\"a type of snake\\"} >>> ] >>> merge_dicts(dict_list) {'apple': ['a fruit', 'a tech company'], 'table': ['a piece of furniture', 'data arrangement'], 'python': ['a programming language', 'a type of snake']}","solution":"from typing import List, Dict def merge_dicts(dict_list: List[Dict[str, str]]) -> Dict[str, List[str]]: result = {} for dictionary in dict_list: for word, definition in dictionary.items(): if word not in result: result[word] = [definition] else: if definition not in result[word]: result[word].append(definition) return result"},{"question":"def fibonacci_memo(n: int) -> int: Calculates the n-th Fibonacci number using memoization. >>> fibonacci_memo(10) 55 >>> fibonacci_memo(50) 12586269025 # Your code here def fibonacci_matrix(n: int) -> int: Calculates the n-th Fibonacci number using matrix exponentiation. >>> fibonacci_matrix(10) 55 >>> fibonacci_matrix(100) 354224848179261915075 # Your code here # Unit Tests def test_fibonacci_memo(): assert fibonacci_memo(0) == 0 assert fibonacci_memo(1) == 1 assert fibonacci_memo(2) == 1 assert fibonacci_memo(3) == 2 assert fibonacci_memo(10) == 55 assert fibonacci_memo(30) == 832040 assert fibonacci_memo(50) == 12586269025 def test_fibonacci_matrix(): assert fibonacci_matrix(0) == 0 assert fibonacci_matrix(1) == 1 assert fibonacci_matrix(2) == 1 assert fibonacci_matrix(3) == 2 assert fibonacci_matrix(10) == 55 assert fibonacci_matrix(30) == 832040 assert fibonacci_matrix(50) == 12586269025 assert fibonacci_matrix(100) == 354224848179261915075","solution":"def fibonacci_memo(n: int) -> int: Calculates the n-th Fibonacci number using memoization. memo = {0: 0, 1: 1} def fib(n): if n not in memo: memo[n] = fib(n - 1) + fib(n - 2) return memo[n] return fib(n) def fibonacci_matrix(n: int) -> int: Calculates the n-th Fibonacci number using matrix exponentiation. if n == 0: return 0 if n == 1: return 1 def multiply_matrices(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_exponentiation(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_exponentiation(F, n - 1) return result_matrix[0][0]"},{"question":"# Sum of Unique Items in Array Given a list of integers, find and return the sum of all the unique elements in the list. def sum_of_unique_elements(arr): Computes the sum of the unique elements in an array of integers. An element is considered unique if it appears exactly once in the array. Parameters: arr (list): A list of integers. Returns: int: The sum of unique elements. element_count = {} # Count occurrences of each element for elem in arr: if elem in element_count: element_count[elem] += 1 else: element_count[elem] = 1 # Sum only the elements that appear exactly once unique_sum = sum(elem for elem, count in element_count.items() if count == 1) return unique_sum def test_sum_of_unique_elements(): assert sum_of_unique_elements([1, 2, 3, 2]) == 4 assert sum_of_unique_elements([1, 1, 1, 1, 2, 2, 2, 2]) == 0 assert sum_of_unique_elements([5, -1, -1, 2, 3, -3]) == 7 assert sum_of_unique_elements([7]) == 7 assert sum_of_unique_elements([1, 3, 2, 3, 4, 4]) == 3 assert sum_of_unique_elements([-1, -1, 2, 2, 3, 4, 5, -2, -2]) == 12 assert sum_of_unique_elements([]) == 0 assert sum_of_unique_elements([-10000, 10000, 1, -1]) == 0 assert sum_of_unique_elements([10000, 10000, -9999, -9999, 9999, 9999]) == 0 if __name__ == \\"__main__\\": test_sum_of_unique_elements()","solution":"def sum_of_unique_elements(arr): Computes the sum of the unique elements in an array of integers. An element is considered unique if it appears exactly once in the array. Parameters: arr (list): A list of integers. Returns: int: The sum of unique elements. element_count = {} # Count occurrences of each element for elem in arr: if elem in element_count: element_count[elem] += 1 else: element_count[elem] = 1 # Sum only the elements that appear exactly once unique_sum = sum(elem for elem, count in element_count.items() if count == 1) return unique_sum"},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Perform a level-order traversal on a binary tree and return a list of lists containing the values of nodes at each level. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> level_order_traversal(root) == [[1], [2, 3], [4, 5]] from collections import deque if not root: return [] # Implementation goes here def test_empty_tree(): assert level_order_traversal(None) == [] def test_single_node_tree(): root = TreeNode(1) assert level_order_traversal(root) == [[1]] def test_two_level_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert level_order_traversal(root) == [[1], [2, 3]] def test_three_level_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert level_order_traversal(root) == [[1], [2, 3], [4, 5, 6, 7]] def test_imbalanced_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) assert level_order_traversal(root) == [[1], [2], [3]] def test_complex_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.right.left = TreeNode(8) root.right = TreeNode(3) root.right.right = TreeNode(7) root.right.right.left = TreeNode(6) assert level_order_traversal(root) == [[1], [2, 3], [4, 5, 7], [8, 6]]","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): from collections import deque if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number efficiently. >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(10) 55 >>> nth_fibonacci(20) 6765 def test_fibonacci_cases(): # Testing the first few Fibonacci numbers assert nth_fibonacci(0) == 0 assert nth_fibonacci(1) == 1 assert nth_fibonacci(2) == 1 assert nth_fibonacci(3) == 2 assert nth_fibonacci(4) == 3 assert nth_fibonacci(5) == 5 # Testing larger Fibonacci numbers within given range assert nth_fibonacci(10) == 55 assert nth_fibonacci(20) == 6765 assert nth_fibonacci(30) == 832040 def test_fibonacci_edge_cases(): # Testing edge cases assert nth_fibonacci(0) == 0 assert nth_fibonacci(1) == 1","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number efficiently using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"import re from collections import defaultdict def count_unique_words(s: str) -> dict: Count unique words in a given string, ignoring case and punctuation. >>> count_unique_words(\\"Hello, world! Hello!!\\") {'hello': 2, 'world': 1} >>> count_unique_words(\\"Testing, testing, 123. TESTING!\\") {'testing': 3, '123': 1} >>> count_unique_words(\\"Unique words are counted. Unique, UNIQUE!\\") {'unique': 3, 'words': 1, 'are': 1, 'counted': 1} >>> count_unique_words(\\"No words here?! 123 456.\\") {'no': 1, 'words': 1, 'here': 1, '123': 1, '456': 1} >>> count_unique_words(\\"\\") {}","solution":"import re from collections import defaultdict def count_unique_words(s: str) -> dict: Count unique words in a given string, ignoring case and punctuation. # Convert to lowercase and use regex to find alphanumeric word sequences s = s.lower() words = re.findall(r'bw+b', s) word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"def evaluate_postfix(postfix: str) -> int: Evaluates a postfix arithmetic expression and returns the result as an integer. Parameters: postfix (str): A string representing the postfix arithmetic expression. Returns: int: The result of the expression. Raises: ValueError: If the expression is malformed or contains invalid operations. Example: >>> evaluate_postfix(\\"3 4 +\\") 7 >>> evaluate_postfix(\\"10 2 /\\") 5 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_postfix(\\"4 0 /\\") Traceback (most recent call last): ... ValueError: division by zero >>> evaluate_postfix(\\"4 +\\") Traceback (most recent call last): ... ValueError: invalid expression","solution":"def evaluate_postfix(postfix: str) -> int: Evaluates a postfix arithmetic expression and returns the result as an integer. Parameters: postfix (str): A string representing the postfix arithmetic expression. Returns: int: The result of the expression. Raises: ValueError: If the expression is malformed or contains invalid operations. if not postfix: raise ValueError(\\"invalid expression\\") postfix = postfix.strip() stack = [] operators = set(['+', '-', '*', '/', '^']) tokens = postfix.split() for token in tokens: if token.isdigit(): stack.append(int(token)) elif token in operators: if len(stack) < 2: raise ValueError(\\"invalid expression\\") b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': if b == 0: raise ValueError(\\"division by zero\\") stack.append(a // b) elif token == '^': stack.append(a ** b) else: raise ValueError(f\\"invalid token: {token}\\") if len(stack) != 1: raise ValueError(\\"invalid expression\\") return stack[0]"},{"question":"def recommend_books(reading_history: List[str], available_books: List[Tuple[str, float]], n: int) -> List[str]: Generate the top N book recommendations based on the similarity scores of available books. :param reading_history: List of book titles the customer has read and rated highly :param available_books: List of tuples where each tuple contains a book title and its similarity score :param n: Number of top recommendations required :return: List of recommended book titles sorted by similarity scores in descending order >>> reading_history = [\\"BookA\\", \\"BookB\\", \\"BookC\\"] >>> available_books = [(\\"BookD\\", 0.9), (\\"BookE\\", 0.8), (\\"BookF\\", 0.85), (\\"BookG\\", 0.7)] >>> n = 3 >>> recommend_books(reading_history, available_books, n) [\\"BookD\\", \\"BookF\\", \\"BookE\\"] >>> reading_history = [\\"BookA\\"] >>> available_books = [(\\"BookD\\", 0.9), (\\"BookE\\", 0.8)] >>> n = 5 >>> recommend_books(reading_history, available_books, n) [\\"BookD\\", \\"BookE\\"] >>> reading_history = [\\"BookA\\"] >>> available_books = [] >>> n = 3 >>> recommend_books(reading_history, available_books, n) [] >>> reading_history = [\\"BookA\\", \\"BookB\\", \\"BookC\\"] >>> available_books = [(\\"BookX\\", 0.95), (\\"BookY\\", 0.99), (\\"BookZ\\", 0.98), (\\"BookW\\", 0.97)] >>> n = 2 >>> recommend_books(reading_history, available_books, n) [\\"BookY\\", \\"BookZ\\"]","solution":"from typing import List, Tuple def recommend_books(reading_history: List[str], available_books: List[Tuple[str, float]], n: int) -> List[str]: Generate the top N book recommendations based on the similarity scores of available books. :param reading_history: List of book titles the customer has read and rated highly :param available_books: List of tuples where each tuple contains a book title and its similarity score :param n: Number of top recommendations required :return: List of recommended book titles sorted by similarity scores in descending order # Sort the available_books based on the similarity score in descending order sorted_books = sorted(available_books, key=lambda x: x[1], reverse=True) # Get the top N book titles based on their sorted order top_n_books = [book[0] for book in sorted_books[:n]] return top_n_books"},{"question":"def validate_and_count(expression: str) -> tuple[bool, int]: Validate whether a given string has balanced parentheses and count the number of balanced pairs. Args: expression (str): A string containing only the characters '(', ')' and possibly other characters. Returns: tuple: A tuple where the first element is a boolean indicating if the parentheses are balanced and the second element is an integer representing the number of balanced pairs. Examples: >>> validate_and_count('') (True, 0) >>> validate_and_count('abc') (True, 0) >>> validate_and_count('((((') (False, 0) >>> validate_and_count('))))') (False, 0) >>> validate_and_count('()()') (True, 2) >>> validate_and_count('()())') (False, 2) >>> validate_and_count('(()') (False, 1) >>> validate_and_count('(())') (True, 2) >>> validate_and_count('()(())') (True, 3) >>> validate_and_count('()(()))') (False, 3) >>> validate_and_count(\\"()\\" * 500000) (True, 500000) >>> validate_and_count(\\"(\\" * 500001 + \\")\\" * 500000) (False, 500000)","solution":"def validate_and_count(expression: str) -> tuple[bool, int]: stack = [] balanced_pairs = 0 for char in expression: if char == '(': stack.append(char) elif char == ')': if stack: stack.pop() balanced_pairs += 1 else: return (False, balanced_pairs) return (len(stack) == 0, balanced_pairs)"},{"question":"def subset_sum(nums: list[int], target: int) -> bool: Determines whether a non-empty subset of the given set of integers sums up to the target value. :param nums: List of non-negative integers. :param target: Target sum. :return: True if such a subset exists, otherwise False. n = len(nums) dp = [False] * (target + 1) dp[0] = True # A sum of 0 can always be achieved by choosing an empty subset for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]","solution":"def subset_sum(nums, target): Determines whether a non-empty subset of the given set of integers sums up to the target value. :param nums: List of non-negative integers. :param target: Target sum. :return: True if such a subset exists, otherwise False. n = len(nums) dp = [False] * (target + 1) dp[0] = True # A sum of 0 can always be achieved by choosing an empty subset for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"# Function Implementation: def fibonacci(n: int) -> int: if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr # Examples: # Example 1: >>> fibonacci(0) 0 # Example 2: >>> fibonacci(1) 1 # Example 3: >>> fibonacci(10) 55 # Example 4: >>> fibonacci(20) 6765 # Example 5: >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer","solution":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using a space-optimized Dynamic Programming approach. :param n: The index (n) of the Fibonacci sequence to compute. :return: The nth Fibonacci number. :raises ValueError: If the input number is negative. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"def generate_email(subject: str, recipient_name: str, sender_name: str, body: str) -> str: Generates a professional email template based on input parameters. Parameters: subject (str): Subject of the email. recipient_name (str): Name of the email recipient. sender_name (str): Name of the person sending the email. body (str): Main content of the email body. Returns: str: Formatted email string. >>> generate_email( ... \\"Project Update\\", ... \\"John Doe\\", ... \\"Jane Doe\\", ... \\"I wanted to give you a quick update on the project...\\" ... ) 'Subject: Project UpdatennDear John Doe,nnI wanted to give you a quick update on the project...nnSincerely,nJane Doe' >>> generate_email( ... \\"Meeting Reminder\\", ... \\"Dr. Smith\\", ... \\"Andrea\\", ... \\"This is a reminder for our meeting scheduled at 10 AM tomorrow. Please confirm your availability.\\" ... ) 'Subject: Meeting RemindernnDear Dr. Smith,nnThis is a reminder for our meeting scheduled at 10 AM tomorrow. Please confirm your availability.nnSincerely,nAndrea' >>> generate_email( ... \\"Hello!\\", ... \\"Mark\\", ... \\"Lucy\\", ... \\"Just wanted to say hi and see how you're doing. Hope all is well!\\" ... ) 'Subject: Hello!nnDear Mark,nnJust wanted to say hi and see how you're doing. Hope all is well!nnSincerely,nLucy' >>> generate_email( ... \\"Job Application\\", ... \\"Hiring Manager\\", ... \\"Alice\\", ... \\"I am writing to apply for the software engineering position at your esteemed company. Attached are my resume and cover letter. Looking forward to hearing from you.\\" ... ) 'Subject: Job ApplicationnnDear Hiring Manager,nnI am writing to apply for the software engineering position at your esteemed company. Attached are my resume and cover letter. Looking forward to hearing from you.nnSincerely,nAlice'","solution":"def generate_email(subject: str, recipient_name: str, sender_name: str, body: str) -> str: Generates a professional email template based on input parameters. Parameters: subject (str): Subject of the email. recipient_name (str): Name of the email recipient. sender_name (str): Name of the person sending the email. body (str): Main content of the email body. Returns: str: Formatted email string. return f Subject: {subject} Dear {recipient_name}, {body} Sincerely, {sender_name} .strip()"},{"question":"def longest_monotonic_increasing_subsequence(prices: list[int]) -> int: Determine the length of the longest monotonically increasing subsequence in a list of integers representing potential price changelogs. Args: prices (list[int]): A list of integers representing prices. Returns: int: The length of the longest monotonically increasing subsequence. Examples: >>> longest_monotonic_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_monotonic_increasing_subsequence([-1, 3, 4, 5, 2, 2, 2, 2, 6]) 5 >>> longest_monotonic_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_monotonic_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 >>> longest_monotonic_increasing_subsequence([-2, -1, -3, -4, -1, 4, 2, 3]) 4","solution":"import bisect def longest_monotonic_increasing_subsequence(prices: list[int]) -> int: Returns the length of the longest monotonically increasing subsequence in the list of integers. if not prices: return 0 sub = [] for price in prices: pos = bisect.bisect_left(sub, price) if pos == len(sub): sub.append(price) else: sub[pos] = price return len(sub)"},{"question":"def optimal_meeting_point(positions: list[int]) -> int: Determine the optimal meeting point in a 1D grid that minimizes the total travel distance for all attendees. Parameters: positions (list of int): A list of integers representing the positions of attendees. Returns: int: The optimal meeting point that minimizes travel distances. pass def test_all_same_position(): assert optimal_meeting_point([5, 5, 5, 5]) == 5 def test_small_list_odd_length(): assert optimal_meeting_point([1, 2, 3]) == 2 def test_small_list_even_length(): assert optimal_meeting_point([1, 2]) == 1 def test_list_with_large_range(): assert optimal_meeting_point([1, 1000, 2000]) == 1000 def test_list_even_number_elements(): assert optimal_meeting_point([10, 15, 17, 20]) == 15 def test_list_with_same_elements(): assert optimal_meeting_point([2, 2, 2, 2]) == 2 def test_large_numbers(): assert optimal_meeting_point([1000000, 2000000, 3000000]) == 2000000 def test_unsorted_list(): assert optimal_meeting_point([6, 1, 2]) == 2 def test_single_element(): assert optimal_meeting_point([999]) == 999","solution":"def optimal_meeting_point(positions: list[int]) -> int: Determine the optimal meeting point in a 1D grid that minimizes the total travel distance for all attendees. Parameters: positions (list of int): A list of integers representing the positions of attendees. Returns: int: The optimal meeting point that minimizes travel distances. # Sort the positions list sorted_positions = sorted(positions) # The optimal meeting point is the median position n = len(sorted_positions) if n % 2 == 1: # If the list length is odd, return the middle element return sorted_positions[n // 2] else: # If the list length is even, return the lower middle element return sorted_positions[n // 2 - 1]"},{"question":"class Graph: def __init__(self): Initialize an empty dictionary to hold adjacency list self.graph = {} def add_edge(self, u: int, v: int) -> None: Add an edge from vertex u to vertex v if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def find_all_paths(self, start_vertex: int, end_vertex: int) -> list[list[int]]: Find all possible paths between two nodes in a directed graph. >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 3) >>> g.find_all_paths(2, 3) [[2, 3]]","solution":"class Graph: def __init__(self): # Initialize an empty dictionary to hold adjacency list self.graph = {} def add_edge(self, u, v): # Add the edge from u to v in the adjacency list if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def find_all_paths(self, start_vertex, end_vertex): def dfs(current_vertex, end_vertex, path): path.append(current_vertex) if current_vertex == end_vertex: paths.append(path[:]) else: for neighbor in self.graph.get(current_vertex, []): if neighbor not in path: dfs(neighbor, end_vertex, path) path.pop() paths = [] dfs(start_vertex, end_vertex, []) return paths"},{"question":"# running_median **Function Signature:** def running_median(numbers: list) -> list: Given a list of integers, computes the running median as integers are added. :param numbers: List of integers. :return: List of floating-point numbers representing the running medians. >>> running_median([2, 1, 5, 7, 2, 0, 5]) [2.0, 1.5, 2.0, 3.5, 2.0, 2.0, 2.0] >>> running_median([10, 20, 30]) [10.0, 15.0, 20.0] lower_half = [] # Max-heap to store the smaller half of numbers upper_half = [] # Min-heap to store the larger half of numbers medians = [] for number in numbers: if not lower_half or number <= -lower_half[0]: heapq.heappush(lower_half, -number) else: heapq.heappush(upper_half, number) # Balance the heaps if len(lower_half) > len(upper_half) + 1: heapq.heappush(upper_half, -heapq.heappop(lower_half)) elif len(upper_half) > len(lower_half): heapq.heappush(lower_half, -heapq.heappop(upper_half)) # Calculate the median if len(lower_half) == len(upper_half): median = (-lower_half[0] + upper_half[0]) / 2.0 else: median = float(-lower_half[0]) medians.append(median) return medians","solution":"import heapq def running_median(numbers: list) -> list: Given a list of integers, computes the running median as integers are added. :param numbers: List of integers. :return: List of floating-point numbers representing the running medians. >>> running_median([2, 1, 5, 7, 2, 0, 5]) [2.0, 1.5, 2.0, 3.5, 2.0, 2.0, 2.0] >>> running_median([10, 20, 30]) [10.0, 15.0, 20.0] lower_half = [] # Max-heap to store the smaller half of numbers upper_half = [] # Min-heap to store the larger half of numbers medians = [] for number in numbers: if not lower_half or number <= -lower_half[0]: heapq.heappush(lower_half, -number) else: heapq.heappush(upper_half, number) # Balance the heaps if len(lower_half) > len(upper_half) + 1: heapq.heappush(upper_half, -heapq.heappop(lower_half)) elif len(upper_half) > len(lower_half): heapq.heappush(lower_half, -heapq.heappop(upper_half)) # Calculate the median if len(lower_half) == len(upper_half): median = (-lower_half[0] + upper_half[0]) / 2.0 else: median = float(-lower_half[0]) medians.append(median) return medians"},{"question":"Create a class called \`EventCalendar\` that includes methods for managing events. Below are the Python functions you need to implement in the class: from typing import List class EventCalendar: def __init__(self): Initialize an empty event calendar. pass def add_event(self, title: str, start_time: int, duration: int): Add a new event with the given title, start time, and duration. pass def remove_event(self, title: str): Remove the event with the specified title. pass def get_event_at(self, time: int) -> str: Return the title of the event happening at the given time. If no event is happening at that time, return \\"No event\\". pass def get_events_in_range(self, start_time: int, end_time: int) -> List[str]: Retrieve a list of titles of all events that overlap with the specified time range [start_time, end_time). pass","solution":"from typing import List class EventCalendar: def __init__(self): self.events = {} def add_event(self, title: str, start_time: int, duration: int): if title in self.events: raise ValueError(\\"Event with the same title already exists.\\") self.events[title] = (start_time, start_time + duration) def remove_event(self, title: str): if title in self.events: del self.events[title] def get_event_at(self, time: int) -> str: for title, (start, end) in self.events.items(): if start <= time < end: return title return \\"No event\\" def get_events_in_range(self, start_time: int, end_time: int) -> List[str]: result = [] for title, (start, end) in self.events.items(): if start < end_time and end > start_time: result.append(title) return result"},{"question":"# Task: Reverse Linked List Implement the following method within the \`LinkedList\` class: def reverse(self) -> 'LinkedList': Reverse the linked list in place and return the LinkedList instance with its elements reversed. prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev return self Verify the correctness of your implementation using these unit tests: from solution import LinkedList def test_reverse_empty_list(): ll = LinkedList() ll.reverse() assert str(ll) == '[]' def test_reverse_single_element_list(): ll = LinkedList() ll.append(1) ll.reverse() assert str(ll) == '[1]' def test_reverse_two_element_list(): ll = LinkedList() ll.append(1) ll.append(2) ll.reverse() assert str(ll) == '[2, 1]' def test_reverse_multiple_element_list(): ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) ll.reverse() assert str(ll) == '[4, 3, 2, 1]' def test_reverse_already_reversed_list(): ll = LinkedList() ll.append(4) ll.append(3) ll.append(2) ll.append(1) ll.reverse() assert str(ll) == '[1, 2, 3, 4]'","solution":"class Node: def __init__(self, value: int, next: 'Node' = None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev return self def __str__(self) -> str: result = [] current = self.head while current: result.append(current.value) current = current.next return str(result)"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Determine the length of the longest palindromic substring in a given string. A palindrome is a word, number, phrase, or other sequences of characters which reads the same backward as forward (ignoring spaces, punctuation, and capitalization). Args: s (str): Input string consisting of printable ASCII characters. Returns: int: Length of the longest palindromic substring. If there is no palindromic substring, return \`0\`. Examples: >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"abcde\\") 1 >>> longest_palindromic_substring_length(\\"\\") 0 >>> longest_palindromic_substring_length(\\"abacdfgdcaba\\") 3 >>> longest_palindromic_substring_length(\\"aaaa\\") 4 # Your code here","solution":"def longest_palindromic_substring_length(s: str) -> int: n = len(s) if n == 0: return 0 # Create a table to store results of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromic max_length = 1 for i in range(n): dp[i][i] = True start = 0 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True start = i max_length = length return max_length"},{"question":"import os import shutil from filecmp import cmp def sync_directories(source_dir: str, dest_dir: str) -> None: Synchronize files and directories from source_dir to dest_dir. Args: - source_dir (str): Path to the source directory. - dest_dir (str): Path to the destination directory. Returns: - None >>> sync_directories('path/to/source', 'path/to/dest') # Ensure the destination directory exists if not os.path.exists(dest_dir): os.makedirs(dest_dir) # Track files and directories in the source directory source_items = set(os.listdir(source_dir)) dest_items = set(os.listdir(dest_dir)) # Handle items to be copied or replaced for item in source_items: source_path = os.path.join(source_dir, item) dest_path = os.path.join(dest_dir, item) if os.path.isdir(source_path): # If it's a directory sync_directories(source_path, dest_path) else: # If it's a file if not os.path.exists(dest_path) or not cmp(source_path, dest_path, shallow=False): shutil.copy2(source_path, dest_path) # Handle items to be removed for item in dest_items - source_items: dest_path = os.path.join(dest_dir, item) if os.path.isdir(dest_path): shutil.rmtree(dest_path) else: os.remove(dest_path)","solution":"import os import shutil from filecmp import cmp def sync_directories(source_dir, dest_dir): Synchronize files and directories from source_dir to dest_dir. Args: - source_dir (str): Path to the source directory. - dest_dir (str): Path to the destination directory. Returns: - None # Ensure the destination directory exists if not os.path.exists(dest_dir): os.makedirs(dest_dir) # Track files and directories in the source directory source_items = set(os.listdir(source_dir)) dest_items = set(os.listdir(dest_dir)) # Handle items to be copied or replaced for item in source_items: source_path = os.path.join(source_dir, item) dest_path = os.path.join(dest_dir, item) if os.path.isdir(source_path): # If it's a directory sync_directories(source_path, dest_path) else: # If it's a file if not os.path.exists(dest_path) or not cmp(source_path, dest_path, shallow=False): shutil.copy2(source_path, dest_path) # Handle items to be removed for item in dest_items - source_items: dest_path = os.path.join(dest_dir, item) if os.path.isdir(dest_path): shutil.rmtree(dest_path) else: os.remove(dest_path)"},{"question":"import time from typing import Dict def factorial_recursive(n: int) -> int: Computes the factorial of n recursively. >>> factorial_recursive(0) 1 >>> factorial_recursive(5) 120 pass def factorial_iterative(n: int) -> int: Computes the factorial of n iteratively. >>> factorial_iterative(0) 1 >>> factorial_iterative(5) 120 pass def compare_execution_time(n: int) -> Dict[str, float]: Compares the execution time of the recursive and iterative factorial functions for a given n. >>> compare_execution_time(5) { 'recursive_time': 0.000057, 'iterative_time': 0.000032 } pass","solution":"import time def factorial_recursive(n: int) -> int: Computes the factorial of n recursively. if n == 0: return 1 return n * factorial_recursive(n - 1) def factorial_iterative(n: int) -> int: Computes the factorial of n iteratively. result = 1 for i in range(1, n + 1): result *= i return result def compare_execution_time(n: int) -> dict: Compares the execution time of the recursive and iterative factorial functions for a given n. start_time = time.time() factorial_recursive(n) recursive_time = time.time() - start_time start_time = time.time() factorial_iterative(n) iterative_time = time.time() - start_time return { \\"recursive_time\\": recursive_time, \\"iterative_time\\": iterative_time }"},{"question":"def number_of_paths(m: int, n: int) -> int: Calculate the number of ways to traverse a \`m x n\` grid when starting from the top-left corner and only being able to move either down or right until reaching the bottom-right corner. >>> number_of_paths(3, 3) 6 >>> number_of_paths(1, 5) 1 >>> number_of_paths(0, 4) 0 >>> number_of_paths(4, 0) 0 >>> number_of_paths(4, 4) 20","solution":"def number_of_paths(m: int, n: int) -> int: # If either m or n is less than or equal to 0, the grid is not valid. if m <= 0 or n <= 0: return 0 # Initialize a 2D array with all elements set to 1. dp = [[1] * n for _ in range(m)] # Fill the 2D array with the number of ways to reach each cell. for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will contain the number of ways to reach it. return dp[m-1][n-1]"},{"question":"Create a class \`MemoryAllocator\` that manages memory allocation and deallocation requests. The system uses a single contiguous block of memory that can be divided into smaller blocks using the buddy system. Class Methods: * \`__init__(self, max_size: int)\`: Initializes the memory allocator with the given maximum memory size. * \`allocate(self, request_size: int) -> int\`: Allocate the smallest available block that fits the request size and return the starting index of the allocated block. Return \`-1\` if no suitable block is available. * \`deallocate(self, start_index: int, size: int) -> bool\`: Deallocate the block starting at the given index and of the given size. Return \`True\` if the block was successfully deallocated, otherwise \`False\`. class MemoryAllocator: def __init__(self, max_size: int): # Your implementation here pass def allocate(self, request_size: int) -> int: # Your implementation here pass def deallocate(self, start_index: int, size: int) -> bool: # Your implementation here pass # Example usage: allocator = MemoryAllocator(16) print(allocator.allocate(4)) # Expected: 0 or another valid index print(allocator.allocate(8)) # Expected: 4 or another valid index print(allocator.deallocate(0, 4)) # Expected: True print(allocator.allocate(2)) # Expected: 0 or another valid index print(allocator.allocate(1)) # Expected: 2 or another valid index print(allocator.deallocate(4, 8)) # Expected: True print(allocator.allocate(16)) # Expected: 0 (if the entire memory is free) Ensure that your methods handle different scenarios, such as fragmentation and combining free blocks during deallocation.","solution":"class MemoryAllocator: def __init__(self, max_size: int): self.max_size = max_size self.memory = [0] * max_size # 0 means free, 1 means allocated self.allocations = {} def allocate(self, request_size: int) -> int: if request_size > self.max_size: return -1 for i in range(self.max_size - request_size + 1): if all(self.memory[i + j] == 0 for j in range(request_size)): for j in range(request_size): self.memory[i + j] = 1 self.allocations[i] = request_size return i return -1 def deallocate(self, start_index: int, size: int) -> bool: if start_index in self.allocations and self.allocations[start_index] == size: for i in range(start_index, start_index + size): self.memory[i] = 0 del self.allocations[start_index] return True return False"},{"question":"def advanced_binary_search(arr: list, target: int) -> int: Performs a binary search on a sorted list and returns the index of the first occurrence of the target value. If the target is not found, returns -1. :param arr: List of sorted integers :param target: Integer value to search for :return: Index of the first occurrence of target or -1 if target is not found >>> advanced_binary_search([1, 2, 3, 4, 4, 5], 4) 3 >>> advanced_binary_search([1, 2, 3, 4, 5], 6) -1 >>> advanced_binary_search([], 1) -1 >>> advanced_binary_search([5], 5) 0 >>> advanced_binary_search([3], 5) -1 >>> advanced_binary_search([1, 2, 2, 2, 3], 2) 1 >>> advanced_binary_search(list(range(100000)), 50000) 50000 >>> advanced_binary_search(list(range(100000)), 99999) 99999 pass","solution":"def advanced_binary_search(arr: list, target: int) -> int: Performs a binary search on a sorted list and returns the index of the first occurrence of the target value. If the target is not found, returns -1. :param arr: List of sorted integers :param target: Integer value to search for :return: Index of the first occurrence of target or -1 if target is not found left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: result = mid right = mid - 1 # Continue searching on the left half elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Transposes the given matrix. This function takes a matrix (a list of lists) and returns a new matrix that is the transpose of the original. The transpose of a matrix is obtained by swapping the rows and columns. Args: matrix: List[List[int]] - A 2D list where each sublist represents a row of the matrix. Returns: List[List[int]] - The transposed matrix. # Unit Tests def test_transpose_square_matrix(): assert transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] def test_transpose_rectangular_matrix(): assert transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] def test_transpose_single_element(): assert transpose([[1]]) == [[1]] def test_transpose_different_dimensions(): assert transpose([[3, 5, 7], [1, 4, 9]]) == [[3, 1], [5, 4], [7, 9]] def test_transpose_one_row_matrix(): assert transpose([[1, 2, 3, 4]]) == [[1], [2], [3], [4]] def test_transpose_one_column_matrix(): assert transpose([[1], [2], [3], [4]]) == [[1, 2, 3, 4]] def test_transpose_large_matrix(): matrix = [[i + j for i in range(1000)] for j in range(1000)] transposed = [[j + i for j in range(1000)] for i in range(1000)] assert transpose(matrix) == transposed","solution":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Transposes the given matrix. This function takes a matrix (a list of lists) and returns a new matrix that is the transpose of the original. The transpose of a matrix is obtained by swapping the rows and columns. Args: matrix: List[List[int]] - A 2D list where each sublist represents a row of the matrix. Returns: List[List[int]] - The transposed matrix. # Number of rows in the original matrix rows = len(matrix) # Number of columns in the original matrix cols = len(matrix[0]) # Initialize the transposed matrix with empty lists transposed_matrix = [[0] * rows for _ in range(cols)] # Iterate over the rows and columns to swap indices for i in range(rows): for j in range(cols): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix"},{"question":"Create a function \`analyze_words\` that takes a passage of text as input and returns a dictionary containing the count of each unique word in the passage. The function should ignore case and punctuation, and account for edge cases such as empty strings or strings with no words. Function Signature def analyze_words( passage: str ) -> dict[str, int]: # Input * \`passage\`: A string variable containing a block of text. # Output * Returns a dictionary where the keys are unique words (in lowercase) and the values are the counts of those words in the input passage. # Constraints * The input text (\`passage\`) will contain only standard printable ASCII characters, punctuation marks, and whitespace. * Words are separated by spaces or punctuated, and punctuation should not be counted as part of the word. # Requirements Your solution should: * Convert all words to lowercase. * Remove punctuation marks from the word boundaries. * Handle empty strings and return an empty dictionary. * Be efficient in terms of time and space complexity. # Examples >>> analyze_words(\\"Hello, world! Hello.\\") {'hello': 2, 'world': 1} >>> analyze_words(\\"A journey of a thousand miles begins with a single step.\\") {'a': 3, 'journey': 1, 'of': 1, 'thousand': 1, 'miles': 1, 'begins': 1, 'with': 1, 'single': 1, 'step': 1} >>> analyze_words(\\"\\") {} >>> analyze_words(\\"To be, or not to be; that is the question.\\") {'to': 2, 'be': 2, 'or': 1, 'not': 1, 'that': 1, 'is': 1, 'the': 1, 'question': 1} # Notes * Ensure that common punctuation marks (e.g., periods, commas, semicolons) are properly handled and not included in the word counts. * Consider edge cases such as passages with special characters or continuous punctuation. * Provide clear and meaningful error messages where necessary. Unit Test: from solution import analyze_words def test_basic_input(): assert analyze_words(\\"Hello, world! Hello.\\") == {'hello': 2, 'world': 1} def test_longer_passage(): passage = \\"A journey of a thousand miles begins with a single step.\\" expected_output = {'a': 3, 'journey': 1, 'of': 1, 'thousand': 1, 'miles': 1, 'begins': 1, 'with': 1, 'single': 1, 'step': 1} assert analyze_words(passage) == expected_output def test_empty_string(): assert analyze_words(\\"\\") == {} def test_varied_punctuation(): passage = \\"To be, or not to be; that is the question.\\" expected_output = {'to': 2, 'be': 2, 'or': 1, 'not': 1, 'that': 1, 'is': 1, 'the': 1, 'question': 1} assert analyze_words(passage) == expected_output def test_short_words_and_symbols(): passage = \\"Wow! What an analysis: this code/function works like a charm.\\" expected_output = {'wow': 1, 'what': 1, 'an': 1, 'analysis': 1, 'this': 1, 'code': 1, 'function': 1, 'works': 1, 'like': 1, 'a': 1, 'charm': 1} assert analyze_words(passage) == expected_output Solution: import re from collections import defaultdict def analyze_words(passage: str) -> dict[str, int]: Analyzes the given text passage and returns the count of each unique word in the passage. The function is case-insensitive and ignores punctuation. :param passage: A string variable containing a block of text. :return: A dictionary where keys are unique words (in lowercase) and values are their counts. # Normalize the passage: convert to lowercase and remove punctuation using regex passage = passage.lower() words = re.findall(r'bw+b', passage) # Creating a dictionary to store word counts word_count = defaultdict(int) # Count the frequency of each word for word in words: word_count[word] += 1 return dict(word_count)","solution":"import re from collections import defaultdict def analyze_words(passage: str) -> dict[str, int]: Analyzes the given text passage and returns the count of each unique word in the passage. The function is case-insensitive and ignores punctuation. :param passage: A string variable containing a block of text. :return: A dictionary where keys are unique words (in lowercase) and values are their counts. # Normalize the passage: convert to lowercase and remove punctuation using regex passage = passage.lower() words = re.findall(r'bw+b', passage) # Creating a dictionary to store word counts word_count = defaultdict(int) # Count the frequency of each word for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"Linked List Reversal and Rotation Implementation class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): Inserts a new node with the given data at the end of the linked list. def display(self): Prints the elements of the linked list. def reverse(self): Reverses the linked list. def rotate(self, k): Rotates the linked list to the right by k nodes. if __name__ == \\"__main__\\": Example demonstrating the functionality. # Create a linked list and insert some nodes ll = LinkedList() for i in range(1, 6): ll.insert(i) print(\\"Original Linked List:\\") ll.display() # Reverse the linked list ll.reverse() print(\\"Reversed Linked List:\\") ll.display() # Rotate the linked list by 2 nodes ll.rotate(2) print(\\"Rotated Linked List by 2 nodes:\\") ll.display()","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, data): Inserts a new node with the given data at the end of the linked list. new_node = Node(data) if not self.head: self.head = new_node return last_node = self.head while last_node.next: last_node = last_node.next last_node.next = new_node def display(self): Prints the elements of the linked list. current = self.head elements = [] while current: elements.append(str(current.data)) current = current.next print(\\" -> \\".join(elements) + \\" -> None\\") def reverse(self): Reverses the linked list. prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def rotate(self, k): Rotates the linked list to the right by k nodes. if not self.head or k == 0: return # Compute length of the list length = 1 current = self.head while current.next: length += 1 current = current.next # Make the linked list circular current.next = self.head # Find the point of rotation rotate_point = length - k % length # Traverse to the point of rotation current = self.head for _ in range(rotate_point - 1): current = current.next # Break the circle and set new head self.head = current.next current.next = None"},{"question":"def zigzag_traversal(matrix: List[List[int]]) -> List[int]: Traverse the given matrix in zigzag order and return the result as a list. pass","solution":"from typing import List def zigzag_traversal(matrix: List[List[int]]) -> List[int]: Traverse the given matrix in zigzag order and return the result as a list. if not matrix: return [] result = [] rows = len(matrix) cols = len(matrix[0]) for row in range(rows): if row % 2 == 0: # Left to right for col in range(cols): result.append(matrix[row][col]) else: # Right to left for col in range(cols - 1, -1, -1): result.append(matrix[row][col]) return result"},{"question":"def approximately_equal(a: float, b: float, tol: float) -> bool: Checks if two floating-point numbers \`a\` and \`b\` are approximately equal within a given tolerance \`tol\`. Parameters: a (float): The first floating-point number. b (float): The second floating-point number. tol (float): The tolerance within which the numbers are considered approximately equal. Returns: bool: True if the absolute difference between \`a\` and \`b\` is less than or equal to \`tol\`, otherwise False. >>> approximately_equal(1.00001, 1.00002, 0.0001) True >>> approximately_equal(1.00001, 1.0002, 0.0001) False >>> approximately_equal(-1.00001, -1.00002, 0.0001) True >>> approximately_equal(1000000.1, 1000000.2, 0.01) False","solution":"def approximately_equal(a: float, b: float, tol: float) -> bool: Checks if two floating-point numbers \`a\` and \`b\` are approximately equal within a given tolerance \`tol\`. Parameters: a (float): The first floating-point number. b (float): The second floating-point number. tol (float): The tolerance within which the numbers are considered approximately equal. Returns: bool: True if the absolute difference between \`a\` and \`b\` is less than or equal to \`tol\`, otherwise False. return abs(a - b) <= tol"},{"question":"def shuffle_deck(deck: list[int]) -> list[int]: Shuffles the deck such that no card remains in its original position. Returns an empty list if it's not possible. >>> shuffle_deck([1, 2, 3, 4]) in [[2, 1, 4, 3], [3, 4, 1, 2], [4, 3, 2, 1]] >>> shuffle_deck([1, 2, 3]) in [[2, 3, 1], [3, 1, 2], [2, 3, 1]] >>> shuffle_deck([1, 1]) == [] >>> shuffle_deck([1]) == [] >>> shuffle_deck([]) == []","solution":"import random def shuffle_deck(deck): Shuffles the deck such that no card remains in its original position. Returns an empty list if it's not possible. n = len(deck) # Handle edge case for empty deck or single card deck if n <= 1: return [] # Create a shuffled deck shuffled_deck = deck[:] random.shuffle(shuffled_deck) # Check if we have a valid shuffle such that no card remains in its original position for _ in range(100): # Try shuffling multiple times to find a valid derangement random.shuffle(shuffled_deck) if all(original != shuffled for original, shuffled in zip(deck, shuffled_deck)): return shuffled_deck return []"},{"question":"def is_transpose_symmetric(matrix: list[list[int]]) -> bool: Return True if the given square matrix is symmetric with respect to its transpose, and False otherwise. >>> is_transpose_symmetric([[1, 2, 3], [2, 4, 5], [3, 5, 6]]) True >>> is_transpose_symmetric([[1, 2], [3, 4]]) False >>> is_transpose_symmetric([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) True >>> is_transpose_symmetric([[1, 2, 3], [2, 'a', 5], [3, 5, 6]]) Traceback (most recent call last): ... TypeError: matrix must be a list of lists of integers >>> is_transpose_symmetric([[1, 2], [3, 4, 5]]) Traceback (most recent call last): ... ValueError: matrix is not a square matrix","solution":"def is_transpose_symmetric(matrix: list[list[int]]) -> bool: Return True if the given square matrix is symmetric with respect to its transpose, and False otherwise. if not isinstance(matrix, list): raise TypeError('matrix must be a list of lists of integers') n = len(matrix) for row in matrix: if not isinstance(row, list): raise TypeError('matrix must be a list of lists of integers') if len(row) != n: raise ValueError('matrix is not a square matrix') for element in row: if not isinstance(element, int): raise TypeError('matrix must be a list of lists of integers') for i in range(n): for j in range(n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"class Fibonacci: def __init__(self, n: int): Initialize the iterator with the number of elements n. Args: n (int): The number of elements in the Fibonacci sequence to generate. (1 <= n <= 1000) pass def __iter__(self): Returns the iterator object itself. Returns: self: The iterator object itself. pass def __next__(self): Returns the next Fibonacci number in the sequence. Returns: int: The next Fibonacci number in the sequence. Raises: StopIteration: When the number of elements n is reached. pass def test_fibonacci_n_1(): fib = Fibonacci(1) assert list(fib) == [0] def test_fibonacci_n_2(): fib = Fibonacci(2) assert list(fib) == [0, 1] def test_fibonacci_n_5(): fib = Fibonacci(5) assert list(fib) == [0, 1, 1, 2, 3] def test_fibonacci_n_10(): fib = Fibonacci(10) assert list(fib) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_fibonacci_n_20(): fib = Fibonacci(20) expected_result = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181] assert list(fib) == expected_result","solution":"class Fibonacci: def __init__(self, n: int): self.n = n self.current_index = 0 self.a = 0 self.b = 1 def __iter__(self): return self def __next__(self): if self.current_index >= self.n: raise StopIteration if self.current_index == 0: self.current_index += 1 return self.a if self.current_index == 1: self.current_index += 1 return self.b next_value = self.a + self.b self.a = self.b self.b = next_value self.current_index += 1 return next_value"},{"question":"class Library: Library management system for handling book operations efficiently. Methods: - add_book(title: str): Adds a book to the library with the given title. - borrow_book(title: str) -> str: Allows a user to borrow a book if it is available. - return_book(title: str) -> str: Allows a user to return a borrowed book. - is_book_available(title: str) -> bool: Checks if a book is available for borrowing. Example usage: >>> library = Library() >>> library.add_book(\\"Python Programming\\") >>> library.add_book(\\"Data Structures\\") >>> print(library.borrow_book(\\"Python Programming\\")) # Output: \\"Book 'Python Programming' borrowed successfully.\\" >>> print(library.borrow_book(\\"Python Programming\\")) # Output: \\"Book 'Python Programming' is currently borrowed.\\" >>> print(library.is_book_available(\\"Python Programming\\")) # Output: False >>> print(library.return_book(\\"Python Programming\\")) # Output: \\"Book 'Python Programming' returned successfully.\\" >>> print(library.is_book_available(\\"Python Programming\\")) # Output: True >>> print(library.borrow_book(\\"Data Structures\\")) # Output: \\"Book 'Data Structures' borrowed successfully.\\" def __init__(self): # Initialization code here pass def add_book(self, title: str): # Implementation here pass def borrow_book(self, title: str) -> str: # Implementation here pass def return_book(self, title: str) -> str: # Implementation here pass def is_book_available(self, title: str) -> bool: # Implementation here pass","solution":"class Library: def __init__(self): self.books = {} # Dictionary to store books and their status def add_book(self, title: str): if title not in self.books: self.books[title] = True # True means the book is available else: return \\"Book already exists in the library.\\" def borrow_book(self, title: str) -> str: if title not in self.books: return f\\"Book '{title}' does not exist in the library.\\" elif self.books[title]: self.books[title] = False # Mark the book as borrowed return f\\"Book '{title}' borrowed successfully.\\" else: return f\\"Book '{title}' is currently borrowed.\\" def return_book(self, title: str) -> str: if title not in self.books: return f\\"Book '{title}' does not exist in the library.\\" elif not self.books[title]: self.books[title] = True # Mark the book as available return f\\"Book '{title}' returned successfully.\\" else: return f\\"Book '{title}' was not borrowed.\\" def is_book_available(self, title: str) -> bool: return self.books.get(title, False)"},{"question":"def climb_stairs(n: int) -> int: Calculate the number of distinct ways to climb a staircase of n steps, where at each step, you can either climb 1, 2, or 3 steps. >>> climb_stairs(1) 1 >>> climb_stairs(2) 2 >>> climb_stairs(3) 4 >>> climb_stairs(4) 7 >>> climb_stairs(5) 13 >>> climb_stairs(10) 274 >>> climb_stairs(20) 121415 >>> climb_stairs(30) 53798080 >>> climb_stairs(50) 10562230626642 >>> climb_stairs(100) 180396380815100901214157639","solution":"def climb_stairs(n: int) -> int: Calculate the number of distinct ways to climb a staircase of n steps, where at each step, you can either climb 1, 2, or 3 steps. if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 # Create a dp array to store the number of ways to reach each step dp = [0] * (n + 1) # Base cases dp[1] = 1 dp[2] = 2 dp[3] = 4 # Fill the dp array for steps from 4 to n for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"import heapq class MedianFinder: A data structure to continuously find the median of a stream of integers. Methods: __init__(self): Initializes the MedianFinder object. addNum(self, num: int): Adds a number to the data structure. findMedian(self) -> float: Returns the median of all numbers added so far. def __init__(self): Initializes the MedianFinder object. self.min_heap = [] # min-heap for the right half self.max_heap = [] # max-heap for the left half (simulated as a min-heap with negative values) def addNum(self, num: int) -> None: Adds a number to the data structure. pass def findMedian(self) -> float: Returns the median of all numbers added so far. pass if __name__ == \\"__main__\\": import pytest def test_medianfinder_single_element(): finder = MedianFinder() finder.addNum(1) assert finder.findMedian() == 1.0 def test_medianfinder_two_elements(): finder = MedianFinder() finder.addNum(1) finder.addNum(2) assert finder.findMedian() == 1.5 def test_medianfinder_odd_number_of_elements(): finder = MedianFinder() finder.addNum(1) finder.addNum(2) finder.addNum(3) assert finder.findMedian() == 2.0 def test_medianfinder_even_number_of_elements(): finder = MedianFinder() finder.addNum(1) finder.addNum(2) finder.addNum(3) finder.addNum(4) assert finder.findMedian() == 2.5 def test_medianfinder_with_negative_numbers(): finder = MedianFinder() finder.addNum(-5) finder.addNum(-10) finder.addNum(-1) assert finder.findMedian() == -5.0 def test_medianfinder_mixed_numbers(): finder = MedianFinder() finder.addNum(-10) finder.addNum(0) finder.addNum(10) assert finder.findMedian() == 0.0 def test_medianfinder_repeated_elements(): finder = MedianFinder() finder.addNum(2) finder.addNum(2) finder.addNum(2) assert finder.findMedian() == 2.0 # Running all tests pytest.main([__file__])","solution":"import heapq class MedianFinder: def __init__(self): self.min_heap = [] # min-heap for the right half self.max_heap = [] # max-heap for the left half (simulated as a min-heap with negative values) def addNum(self, num: int) -> None: if not self.max_heap or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) elif len(self.min_heap) > len(self.max_heap): return float(self.min_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merge two sorted arrays into a single sorted array. Args: arr1: A list of integers sorted in non-decreasing order. arr2: A list of integers sorted in non-decreasing order. Returns: A list of integers representing the merged sorted array. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0], [1, 2, 3]) [0, 1, 2, 3] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([-5, -3, -1], [-4, -2, 0]) [-5, -4, -3, -2, -1, 0] # Your implementation here","solution":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: i, j = 0, 0 merged = [] while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Given a list of coin denominations and a target amount, find the minimum number of coins required to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. :param coins: List of integers representing the coin denominations. :param amount: An integer representing the target amount. :return: An integer representing the minimum number of coins needed to make up the given amount. Example: >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1], 0) 0 pass def test_min_coins_basic(): assert min_coins([1, 2, 5], 11) == 3 def test_min_coins_cannot_make_amount(): assert min_coins([2], 3) == -1 def test_min_coins_zero_amount(): assert min_coins([1], 0) == 0 def test_min_coins_single_coin(): assert min_coins([1, 7, 10], 14) == 2 def test_min_coins_large_amount(): assert min_coins([1, 2, 5, 10], 100) == 10 def test_min_coins_no_coins(): assert min_coins([], 5) == -1 def test_min_coins_large_coin_values(): assert min_coins([100, 200, 500], 300) == 2 def test_min_coins_edge_case_same_coin_value(): assert min_coins([1], 10000) == 10000","solution":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Given a list of coin denominations and a target amount, find the minimum number of coins required to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. :param coins: List of integers representing the coin denominations. :param amount: An integer representing the target amount. :return: An integer representing the minimum number of coins needed to make up the given amount. # Create a list to store the minimum number of coins needed for each amount up to the target amount dp = [amount + 1] * (amount + 1) dp[0] = 0 # Base case: no coins are needed to make up amount 0 # For each coin, update the dp array for coin in coins: for i in range(coin, amount + 1): dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[amount] still has the initial value, it means we cannot form the amount with the given coins return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"def evaluate_postfix(expression: List[str]) -> float: Evaluates the given postfix (Reverse Polish Notation) expression. Args: expression (List[str]): A list of strings representing both numbers and operators in postfix notation. Returns: float: The result of the evaluated expression. Raises: ValueError: If the expression is empty or contains invalid characters. ZeroDivisionError: If a division by zero is attempted. Example Usage: >>> evaluate_postfix([\\"2\\", \\"3\\", \\"+\\", \\"4\\", \\"*\\"]) 20.0 >>> evaluate_postfix([\\"10\\", \\"2\\", \\"/\\", \\"3\\", \\"-\\"]) 2.0 >>> evaluate_postfix([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14.0 >>> evaluate_postfix([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) 2.0 >>> evaluate_postfix([]) Traceback (most recent call last): ... ValueError: Expression cannot be empty >>> evaluate_postfix([\\"2\\", \\"3\\", \\"a\\", \\"+\\"]) Traceback (most recent call last): ... ValueError: Invalid character in expression","solution":"def evaluate_postfix(expression): Evaluates the given postfix (Reverse Polish Notation) expression. Args: expression (List[str]): A list of strings representing both numbers and operators in postfix notation. Returns: float: The result of the evaluated expression. Raises: ValueError: If the expression is empty or contains invalid characters. ZeroDivisionError: If a division by zero is attempted. if not expression: raise ValueError(\\"Expression cannot be empty\\") stack = [] for token in expression: if token in {'+', '-', '*', '/'}: if len(stack) < 2: raise ValueError(\\"Insufficient values in expression\\") right = stack.pop() left = stack.pop() if token == '+': stack.append(left + right) elif token == '-': stack.append(left - right) elif token == '*': stack.append(left * right) elif token == '/': if right == 0: raise ZeroDivisionError(\\"Division by zero\\") stack.append(left / right) else: try: stack.append(float(token)) except ValueError: raise ValueError(\\"Invalid character in expression\\") if len(stack) != 1: raise ValueError(\\"The expression did not result in a single value\\") return stack.pop()"},{"question":"from typing import List def find_strongest_product_subarray(arr: List[int]) -> int: This function finds the maximum product of any contiguous subarray within the given array \`arr\`. :param arr: List[int] : A list of integers representing the array. :return: int : The highest product of any contiguous subarray. >>> find_strongest_product_subarray([2, 3, -2, 4]) == 6 >>> find_strongest_product_subarray([-2, 0, -1]) == 0 >>> find_strongest_product_subarray([-2, -3, 0, -2, -40]) == 80 >>> find_strongest_product_subarray([6, -3, -10, 0, 2]) == 180 pass # Unit tests def test_single_element(): assert find_strongest_product_subarray([2]) == 2 assert find_strongest_product_subarray([-2]) == -2 def test_all_positive(): assert find_strongest_product_subarray([2, 3, 4]) == 24 def test_all_negative(): assert find_strongest_product_subarray([-2, -3, -4]) == 12 def test_mixed_positive_negative(): assert find_strongest_product_subarray([2, 3, -2, 4]) == 6 assert find_strongest_product_subarray([-2, 0, -1]) == 0 assert find_strongest_product_subarray([-2, -3, 0, -2, -40]) == 80 assert find_strongest_product_subarray([6, -3, -10, 0, 2]) == 180 def test_with_zeros(): assert find_strongest_product_subarray([0, 2, 3, 0, -2, 4]) == 6 assert find_strongest_product_subarray([-2, 0, -1, 0, 2, 3]) == 6 def test_large_product(): assert find_strongest_product_subarray([1, -2, -3, 0, 7, -8, -2]) == 112","solution":"from typing import List def find_strongest_product_subarray(arr: List[int]) -> int: This function finds the maximum product of any contiguous subarray within the given array \`arr\`. :param arr: List[int] : A list of integers representing the array. :return: int : The highest product of any contiguous subarray. if not arr: return 0 max_product = arr[0] min_product = arr[0] result = arr[0] for i in range(1, len(arr)): if arr[i] < 0: max_product, min_product = min_product, max_product max_product = max(arr[i], max_product * arr[i]) min_product = min(arr[i], min_product * arr[i]) result = max(result, max_product) return result"},{"question":"def decode_phone_number(phone_number: str) -> str: Decode a phone number written with letters to its digit-only form. Non-alphanumeric characters should remain in the same position. Parameters: - phone_number (str): A phone number string that may contain letters, digits, and non-alphanumeric characters. Returns: - str: The decoded phone number with letters replaced by corresponding digits and non-alphanumeric characters in their original positions. Examples: >>> decode_phone_number(\\"1-800-FLOWERS\\") '1-800-3569377' >>> decode_phone_number(\\"(555) - GET-FOOD\\") '(555) - 438-3663' >>> decode_phone_number(\\"1-800-DO-MATH\\") '1-800-36-6284' >>> decode_phone_number(\\"CALL-NOW\\") '2255-669' >>> decode_phone_number(\\"PYTHON-123\\") '798466-123' pass def test_decode_phone_number(): assert decode_phone_number(\\"1-800-FLOWERS\\") == '1-800-3569377' assert decode_phone_number(\\"(555) - GET-FOOD\\") == '(555) - 438-3663' assert decode_phone_number(\\"1-800-DO-MATH\\") == '1-800-36-6284' assert decode_phone_number(\\"CALL-NOW\\") == '2255-669' assert decode_phone_number(\\"PYTHON-123\\") == '798466-123' assert decode_phone_number(\\"HELLO-WORLD\\") == '43556-96753' assert decode_phone_number(\\"GOOD-888\\") == '4663-888' assert decode_phone_number(\\"BRAVE2023\\") == '272832023' assert decode_phone_number(\\"IN2THE-WILD\\") == '462843-9453' def test_decode_phone_number_with_no_alphanumeric(): assert decode_phone_number(\\"\\") == '' assert decode_phone_number(\\"12345\\") == '12345' assert decode_phone_number(\\"-----\\") == '-----' assert decode_phone_number(\\"!!!#\\") == '!!!#'","solution":"def decode_phone_number(phone_number: str) -> str: Decode a phone number written with letters to its digit-only form. Non-alphanumeric characters should remain in the same position. # Mapping of letters to their corresponding digits letter_to_digit = { 'A': '2', 'B': '2', 'C': '2', 'D': '3', 'E': '3', 'F': '3', 'G': '4', 'H': '4', 'I': '4', 'J': '5', 'K': '5', 'L': '5', 'M': '6', 'N': '6', 'O': '6', 'P': '7', 'Q': '7', 'R': '7', 'S': '7', 'T': '8', 'U': '8', 'V': '8', 'W': '9', 'X': '9', 'Y': '9', 'Z': '9' } decoded_number = [] for char in phone_number: if char.isalpha(): decoded_number.append(letter_to_digit[char.upper()]) else: decoded_number.append(char) return ''.join(decoded_number)"},{"question":"def validate_multiplication(a: float, b: float, product: float) -> bool: Verifies if the product of the first two numbers (a and b) is approximately equal to the third number (product) within a tolerance of 1e-6. >>> validate_multiplication(10.0, 20.0, 200.0) == True >>> validate_multiplication(3.6, 0.25, 0.9) == True >>> validate_multiplication(1.234, 2.345, 2.8947) == False >>> validate_multiplication(0.1, 0.2, 0.02) == True >>> validate_multiplication(-1.5, 2.0, -3.0) == True >>> validate_multiplication(10.0, 10.0, 99.999999) == True >>> validate_multiplication(10.0, 10.0, 100.000001) == True >>> validate_multiplication(10.0, 10.0, 100.00001) == False","solution":"def validate_multiplication(a: float, b: float, product: float) -> bool: Verifies if the product of the first two numbers (a and b) is approximately equal to the third number (product) within a tolerance of 1e-6. epsilon = 1e-6 return abs((a * b) - product) <= epsilon"},{"question":"def shortest_path(graph: dict, start_node: str, end_node: str) -> list: Computes the shortest path between start_node and end_node in a graph. >>> shortest_path({\\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"A\\": 1, \\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"A\\": 4, \\"B\\": 2, \\"D\\": 1}, \\"D\\": {\\"B\\": 5, \\"C\\": 1}}, \\"A\\", \\"D\\") [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] >>> shortest_path({\\"A\\": {\\"B\\": 1}, \\"B\\": {\\"A\\": 1}, \\"C\\": {\\"D\\": 1}, \\"D\\": {\\"C\\": 1}}, \\"A\\", \\"D\\") [] >>> shortest_path({\\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"A\\": 1, \\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"A\\": 4, \\"B\\": 2, \\"D\\": 1}, \\"D\\": {\\"B\\": 5, \\"C\\": 1}}, \\"A\\", \\"A\\") [\\"A\\"] >>> shortest_path({\\"A\\": {}}, \\"A\\", \\"A\\") [\\"A\\"] >>> shortest_path({\\"A\\": {\\"B\\": 1}, \\"B\\": {\\"A\\": 1}, \\"C\\": {\\"D\\": 1}, \\"D\\": {\\"C\\": 1}}, \\"A\\", \\"C\\") [] >>> shortest_path({\\"A\\": {\\"B\\": 5, \\"C\\": 10}, \\"B\\": {\\"A\\": 5, \\"D\\": 2}, \\"C\\": {\\"A\\": 10, \\"D\\": 1}, \\"D\\": {\\"B\\": 2, \\"C\\": 1, \\"E\\": 1}, \\"E\\": {\\"D\\": 1, \\"F\\": 1}, \\"F\\": {\\"E\\": 1}}, \\"A\\", \\"F\\") [\\"A\\", \\"B\\", \\"D\\", \\"E\\", \\"F\\"]","solution":"import heapq def shortest_path(graph: dict, start_node: str, end_node: str) -> list: Computes the shortest path between start_node and end_node in a graph using Dijkstra's algorithm. :param graph: Dictionary representing the graph where keys are nodes and values are dictionaries of adjacent nodes with distances. :param start_node: The starting node. :param end_node: The target node. :return: List of nodes representing the shortest path from start_node to end_node. Return empty list if no path exists. if start_node not in graph or end_node not in graph: raise ValueError(\\"Start or end node not found in the graph.\\") # Priority queue to store (distance, node, path) pq = [(0, start_node, [start_node])] visited = set() while pq: (cost, current, path) = heapq.heappop(pq) if current in visited: continue if current == end_node: return path visited.add(current) for neighbor, weight in graph[current].items(): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path + [neighbor])) return []"},{"question":"def concatenate_elimination(list1: List[str], list2: List[str]) -> str: Concatenate the elements of two lists into a single string, excluding common characters. Arguments: list1 -- List containing the first set of single-character strings. list2 -- List containing the second set of single-character strings. Returns: A string that is the result of concatenating the two lists after eliminating any character that is present in both lists. Example: >>> concatenate_elimination(['a', 'b', 'c'], ['b', 'd', 'e']) 'acde' >>> concatenate_elimination(['m', 'n'], ['n', 'o']) 'mo' pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"from typing import List def concatenate_elimination(list1: List[str], list2: List[str]) -> str: Concatenate the elements of two lists into a single string, excluding common characters. Args: list1: List containing the first set of single-character strings. list2: List containing the second set of single-character strings. Returns: A string that is the result of concatenating the two lists after eliminating any character that is present in both lists. Examples: >>> concatenate_elimination(['a', 'b', 'c'], ['b', 'd', 'e']) 'acde' >>> concatenate_elimination(['m', 'n'], ['n', 'o']) 'mo' # Create a set of common characters common_chars = set(list1).intersection(set(list2)) # Filter out common characters from list1 and list2 filtered_list1 = [char for char in list1 if char not in common_chars] filtered_list2 = [char for char in list2 if char not in common_chars] # Concatenate the filtered lists and return as a string return ''.join(filtered_list1 + filtered_list2)"},{"question":"def longest_consecutive_sequence(arr: Sequence[int]) -> int: Determine the length of the longest consecutive elements sequence in the array. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([1, 2, 0, 1]) 3 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([5]) 1 >>> longest_consecutive_sequence([4, 5, 6, 7, 8, 9]) 6 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence([3, 4, 2, 1]) 4 >>> longest_consecutive_sequence([100000, 99999, 99998, -1000000000, -999999999]) 3 pass","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest consecutive elements sequence in the array. if not arr: return 0 nums_set = set(arr) longest_length = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"def depth_first_search(graph: dict, start_vertex: int) -> list: Perform a Depth-First Search (DFS) on the graph starting from the given vertex. Parameters: graph (dict): A dictionary representation of an undirected graph where the keys are vertex identifiers and the values are lists of adjacent vertices. start_vertex (int): The starting vertex for the DFS traversal. Returns: list: A list of vertices in the order they were visited during the DFS traversal. Example: >>> graph = { ... 0: [1, 2], ... 1: [0, 3, 4], ... 2: [0], ... 3: [1], ... 4: [1] ... } >>> depth_first_search(graph, 0) [0, 1, 3, 4, 2] >>> depth_first_search(graph, 1) [1, 0, 2, 3, 4]","solution":"def depth_first_search(graph, start_vertex): Perform a Depth-First Search (DFS) on the graph starting from the given vertex. Parameters: graph (dict): A dictionary representation of an undirected graph where the keys are vertex identifiers and the values are lists of adjacent vertices. start_vertex (int): The starting vertex for the DFS traversal. Returns: list: A list of vertices in the order they were visited during the DFS traversal. visited = set() stack = [start_vertex] dfs_order = [] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) dfs_order.append(vertex) # Add adjacent vertices to the stack in reverse order for neighbor in reversed(graph[vertex]): stack.append(neighbor) return dfs_order"},{"question":"from typing import List, Dict def create_shift_schedule(employees: List[str], total_shifts: int) -> Dict[str, int]: Create a shift schedule for employees ensuring as even a distribution as possible. Args: employees (List[str]): List of employee names. total_shifts (int): Total number of shifts to be distributed. Returns: Dict[str, int]: Dictionary with employee names as keys and the number of shifts as values. Examples: >>> create_shift_schedule([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], 7) {\\"Alice\\": 3, \\"Bob\\": 2, \\"Charlie\\": 2} >>> create_shift_schedule([\\"Dave\\", \\"Eva\\"], 5) {\\"Dave\\": 3, \\"Eva\\": 2} >>> create_shift_schedule([], 5) {} >>> create_shift_schedule([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], 0) {\\"Alice\\": 0, \\"Bob\\": 0, \\"Charlie\\": 0}","solution":"from typing import List, Dict def create_shift_schedule(employees: List[str], total_shifts: int) -> Dict[str, int]: Create a shift schedule for employees ensuring as even a distribution as possible. Args: employees (List[str]): List of employee names. total_shifts (int): Total number of shifts to be distributed. Returns: Dict[str, int]: Dictionary with employee names as keys and the number of shifts as values. if not employees: return {} # Use the absolute value of total_shifts if negative total_shifts = abs(total_shifts) num_employees = len(employees) base_shifts = total_shifts // num_employees extra_shifts = total_shifts % num_employees schedule = {} for i, employee in enumerate(employees): shifts = base_shifts + (1 if i < extra_shifts else 0) schedule[employee] = shifts return schedule"},{"question":"def is_keith_number(num: int) -> bool: Determines if a given number is a Keith number. >>> is_keith_number(197) True >>> is_keith_number(19) True >>> is_keith_number(20) False >>> is_keith_number(999) False >>> is_keith_number(14) Traceback (most recent call last): ... ValueError: num must be greater than or equal to 10","solution":"def is_keith_number(num): Determines if a given number is a Keith number. if num < 10: raise ValueError(\\"num must be greater than or equal to 10\\") # Convert the number to its individual digits digits = [int(digit) for digit in str(num)] # Use the length of the digits length = len(digits) # Initialize the sequence with the digits sequence = digits[:] # Generate the sequence until the number is reached or surpassed while True: next_term = sum(sequence[-length:]) if next_term == num: return True if next_term > num: return False sequence.append(next_term)"},{"question":"def sum_and_product(nums: list[int]) -> tuple[int, int]: Returns the sum and product of the elements in the list. If the list is empty, returns (0, 1). Args: nums (list[int]): A list of integers. The list can be empty. Returns: tuple[int, int]: A tuple containing the sum and the product of the list elements. Examples: >>> sum_and_product([1, 2, 3, 4]) (10, 24) >>> sum_and_product([5, -1, 2]) (6, -10) >>> sum_and_product([10]) (10, 10) >>> sum_and_product([]) (0, 1) >>> sum_and_product([0, 1, 2, 3]) (6, 0) >>> sum_and_product([-1, -1, -1, -1]) (-4, 1)","solution":"def sum_and_product(nums: list[int]) -> tuple[int, int]: Returns the sum and product of the elements in the list. If the list is empty, returns (0, 1). if not nums: return (0, 1) total_sum = 0 total_product = 1 for num in nums: total_sum += num total_product *= num return (total_sum, total_product)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode | None) -> TreeNode | None: Invert a binary tree, swapping every left node with its corresponding right node. >>> root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) >>> inverted_root = invert_tree(root) >>> inverted_root.left.val == 7 True >>> inverted_root.right.val == 2 True >>> inverted_root.left.left.val == 9 True >>> inverted_root.left.right.val == 6 True >>> inverted_root.right.left.val == 3 True >>> inverted_root.right.right.val == 1 True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode | None) -> TreeNode | None: if not root: return None # Invert the subtree root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, value): # Initialize with a list for the value to store duplicates self.values = [value] self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a value into the BST, allowing duplicates. def delete(self, value: int) -> None: Delete a value from the BST, handling duplicates correctly. def range_query(self, low: int, high: int) -> List[int]: Retrieve all values within the specified range [low, high], inclusive. >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(20) >>> bst.insert(10) # duplicate >>> bst.insert(15) >>> bst.insert(25) >>> sorted(bst.range_query(10, 20)) [10, 10, 15, 20]","solution":"class TreeNode: def __init__(self, value): # Initialize with a list for the value to store duplicates self.values = [value] self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.values[0]: if node.left: self._insert(node.left, value) else: node.left = TreeNode(value) elif value > node.values[0]: if node.right: self._insert(node.right, value) else: node.right = TreeNode(value) else: node.values.append(value) def delete(self, value: int) -> None: self.root = self._delete(self.root, value) def _delete(self, node, value): if not node: return node if value < node.values[0]: node.left = self._delete(node.left, value) elif value > node.values[0]: node.right = self._delete(node.right, value) else: # value found if len(node.values) > 1: node.values.pop() elif not node.left: return node.right elif not node.right: return node.left else: min_larger_node = self._get_min(node.right) node.values = min_larger_node.values node.right = self._delete(node.right, min_larger_node.values[0]) return node def _get_min(self, node): current = node while current.left: current = current.left return current def range_query(self, low: int, high: int) -> list: result = [] self._range_query(self.root, low, high, result) return result def _range_query(self, node, low, high, result): if not node: return if low <= node.values[0] <= high: result.extend(node.values) if low < node.values[0]: self._range_query(node.left, low, high, result) if node.values[0] < high: self._range_query(node.right, low, high, result)"},{"question":"def gen_passwd() -> str: Function to generate a random 8-character password that meets the specified criteria. Returns: A string representing the generated password. pass # Regex patterns to match required characters in the password lowercase_pattern = re.compile(r'[a-z]') uppercase_pattern = re.compile(r'[A-Z]') digit_pattern = re.compile(r'd') special_char_pattern = re.compile(r'[!@#%^&*()]') def test_password_length(): password = gen_passwd() assert len(password) == 8, f\\"Password length is not 8: {password}\\" def test_password_contains_lowercase(): password = gen_passwd() assert lowercase_pattern.search(password), f\\"Password does not contain a lowercase letter: {password}\\" def test_password_contains_uppercase(): password = gen_passwd() assert uppercase_pattern.search(password), f\\"Password does not contain an uppercase letter: {password}\\" def test_password_contains_digit(): password = gen_passwd() assert digit_pattern.search(password), f\\"Password does not contain a digit: {password}\\" def test_password_contains_special_character(): password = gen_passwd() assert special_char_pattern.search(password), f\\"Password does not contain a special character: {password}\\" def test_randomness(): passwords = {gen_passwd() for _ in range(100)} assert len(passwords) == 100, \\"Generated passwords are not random enough\\"","solution":"import random import string def gen_passwd() -> str: Function to generate a random 8-character password that meets the specified criteria. Returns: A string representing the generated password. all_chars = string.ascii_lowercase + string.ascii_uppercase + string.digits + \\"!@#%^&*()\\" password = [] # Ensure at least one of each required type password.append(random.choice(string.ascii_lowercase)) password.append(random.choice(string.ascii_uppercase)) password.append(random.choice(string.digits)) password.append(random.choice(\\"!@#%^&*()\\")) # Fill the rest of the password length (8-4=4 more characters) for _ in range(4): password.append(random.choice(all_chars)) # Shuffle the list to ensure randomness random.shuffle(password) return ''.join(password)"},{"question":"def find_pattern_square_number() -> int: Finds the unique positive integer n whose square has the digits '123456787654321' in the middle. Example: >>> find_pattern_square_number() 12345678 # Example of possible output (not the actual answer) pass if __name__ == \\"__main__\\": result = find_pattern_square_number() print(result) # Should print the unique positive integer n such that n^2 has the specified middle pattern","solution":"def find_pattern_square_number(): Finds the unique positive integer n whose square has the digits '123456787654321' in the middle. pattern = '123456787654321' pattern_length = len(pattern) # Start searching for n from a reasonable lower bound lower_bound = 10**7 upper_bound = 10**8 # We need to account for numbers whose squares can have the pattern in the middle. for n in range(lower_bound, upper_bound): square_str = str(n * n) if pattern in square_str: center_start = (len(square_str) - pattern_length) // 2 if square_str[center_start:center_start + pattern_length] == pattern: return n return None"},{"question":"from typing import List def kmp_search(text: str, pattern: str) -> List[int]: Knuth-Morris-Pratt (KMP) pattern matching algorithm to search for a pattern in a provided text. Args: text (str): The text in which to search for the pattern. pattern (str): The pattern to search for in the text. Returns: List[int]: A list of starting indices where the pattern is found in the text. >>> kmp_search(\\"ababcabcabababd\\", \\"ababd\\") == [10] >>> kmp_search(\\"ababcabcabababdababd\\", \\"ababd\\") == [10, 15] >>> kmp_search(\\"abcdefgh\\", \\"xyz\\") == [] >>> kmp_search(\\"aaaaa\\", \\"aaa\\") == [0, 1, 2] >>> kmp_search(\\"abc\\", \\"abcd\\") == [] >>> kmp_search(\\"abcde\\", \\"\\") == [] >>> kmp_search(\\"\\", \\"\\") == [] >>> kmp_search(\\"\\", \\"a\\") == []","solution":"from typing import List def kmp_search(text: str, pattern: str) -> List[int]: Knuth-Morris-Pratt (KMP) pattern matching algorithm to search for a pattern in a provided text. Args: text (str): The text in which to search for the pattern. pattern (str): The pattern to search for in the text. Returns: List[int]: A list of starting indices where the pattern is found in the text. def compute_lps_array(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array for given pattern. Args: pattern (str): The pattern for which to compute the LPS array. Returns: List[int]: LPS array. length = len(pattern) lps = [0] * length j = 0 # length of the previous longest prefix suffix i = 1 while i < length: if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j-1] else: lps[i] = 0 i += 1 return lps n = len(text) m = len(pattern) if m == 0: return [] lps = compute_lps_array(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"def search_range(nums: List[int], target: int) -> List[int]: def find_start(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] >= target: high = mid - 1 else: low = mid + 1 return low start = find_start(nums, target) if start >= len(nums) or nums[start] != target: return [-1, -1] end = find_start(nums, target + 1) - 1 return [start, end] def test_search_range(): assert search_range([5, 7, 7, 8, 8, 10], 8) == [3, 4] assert search_range([5, 7, 7, 8, 8, 10], 6) == [-1, -1] assert search_range([], 0) == [-1, -1] assert search_range([1], 1) == [0, 0] assert search_range([2, 2, 2, 2], 2) == [0, 3] assert search_range([1, 3, 4, 5, 5, 5, 6, 7], 5) == [3, 5] assert search_range([1, 1, 2, 2, 3, 3], 2) == [2, 3] assert search_range([1, 2, 2, 2, 3, 4, 5], 3) == [4, 4] assert search_range([2, 2, 2, 3, 3, 3, 4, 4], 5) == [-1, -1]","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_start(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] >= target: high = mid - 1 else: low = mid + 1 return low start = find_start(nums, target) if start >= len(nums) or nums[start] != target: return [-1, -1] end = find_start(nums, target + 1) - 1 return [start, end]"},{"question":"from collections import OrderedDict class LRUCache: LRUCache class that simulates a cache with Least Recently Used (LRU) policy. Methods: - __init__(self, capacity: int): Initializes the cache with a given capacity. - get(self, key: int) -> int: Returns the value if the key is in the cache, otherwise returns -1. - put(self, key: int, value: int) -> None: Inserts or updates the key-value pair. Evicts the least recently used item if necessary. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) # Evicts key 2 >>> cache.get(2) -1 >>> cache.put(4, 4) # Evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"def add_large_numbers(arr_a: list[int], arr_b: list[int]) -> list[int]: Adds two large numbers represented as arrays of digits. >>> add_large_numbers([9, 9, 9], [1]) [1, 0, 0, 0] >>> add_large_numbers([2, 7, 4], [5, 6, 8]) [8, 4, 2] >>> add_large_numbers([0], [0]) [0]","solution":"def add_large_numbers(arr_a, arr_b): Adds two large numbers represented as arrays of digits. Args: arr_a: A list of integers representing the digits of the first large number. arr_b: A list of integers representing the digits of the second large number. Returns: A list of integers representing the digits of the sum of the two large numbers. # Reverse the lists to make the addition process easier (least significant to most significant) arr_a = arr_a[::-1] arr_b = arr_b[::-1] # Initialize the variables max_length = max(len(arr_a), len(arr_b)) result = [] carry = 0 # Iterate over each digit and perform the addition for i in range(max_length): digit_a = arr_a[i] if i < len(arr_a) else 0 digit_b = arr_b[i] if i < len(arr_b) else 0 total = digit_a + digit_b + carry carry = total // 10 result.append(total % 10) # If there's any carry left, append it to the result if carry > 0: result.append(carry) # Reverse the result to represent the number from most significant to least significant digit result.reverse() return result"},{"question":"from typing import List def generate_fibonacci_like_sequence(a: int, b: int, n: int) -> List[int]: Generate a Fibonacci-like sequence of length n starting with a and b. >>> generate_fibonacci_like_sequence(3, 5, 10) [3, 5, 8, 13, 21, 34, 55, 89, 144, 233] >>> generate_fibonacci_like_sequence(0, 1, 10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci_like_sequence(1, 1, 10) [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> generate_fibonacci_like_sequence(0, 1, 1) [0] >>> generate_fibonacci_like_sequence(0, 1, 2) [0, 1] >>> generate_fibonacci_like_sequence(5, 5, 1) [5] >>> generate_fibonacci_like_sequence(5, 5, 2) [5, 5] >>> generate_fibonacci_like_sequence(10**9, 10**9, 5) [10**9, 10**9, 2 * 10**9, 3 * 10**9, 5 * 10**9] >>> generate_fibonacci_like_sequence(2, 3, 6) [2, 3, 5, 8, 13, 21] >>> generate_fibonacci_like_sequence(1, 4, 7) [1, 4, 5, 9, 14, 23, 37]","solution":"from typing import List def generate_fibonacci_like_sequence(a: int, b: int, n: int) -> List[int]: Generates a Fibonacci-like sequence of length n starting with a and b. if n == 1: return [a] if n == 2: return [a, b] sequence = [a, b] for _ in range(2, n): next_number = sequence[-1] + sequence[-2] sequence.append(next_number) return sequence"},{"question":"from typing import List def optimal_storage(items_weights: List[int], capacity: int) -> int: Determine the maximum combined weight of items that can be stored without exceeding the capacity. :param items_weights: List[int] - A list of weights of items. :param capacity: int - The maximum capacity of the warehouse storage unit. :return: int - The maximum combined weight of items that can be stored. >>> optimal_storage([1, 3, 4, 5], 7) 7 >>> optimal_storage([2, 2, 4, 6], 9) 8 >>> optimal_storage([5, 5, 5, 5], 10) 10 >>> optimal_storage([1, 2, 3, 8, 7, 4], 15) 15","solution":"from typing import List def optimal_storage(items_weights: List[int], capacity: int) -> int: Determine the maximum combined weight of items that can be stored without exceeding the capacity. :param items_weights: List[int] - A list of weights of items. :param capacity: int - The maximum capacity of the warehouse storage unit. :return: int - The maximum combined weight of items that can be stored. # Initialize a list to store the maximum weight for each capacity from 0 to capacity dp = [0] * (capacity + 1) # Iterate through each item weight for weight in items_weights: # Traverse the capacities backwards from the given capacity to the weight of the current item for cap in range(capacity, weight - 1, -1): # Update the dp array with the maximum value by including the current item dp[cap] = max(dp[cap], dp[cap - weight] + weight) return dp[capacity]"},{"question":"from itertools import permutations import math def shortest_route(points: list[tuple[int, int]]) -> float: Determine the shortest possible route to deliver packages to a list of delivery points. Args: - points: a list of tuples representing the coordinates (x, y) of delivery points on a 2D plane. Returns: - a float representing the total distance of the shortest route, visiting all points exactly once and returning to the start. Example: >>> shortest_route([(0, 0), (1, 1), (2, 2)]) 6.828 def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_distance(route): distance = 0.0 for i in range(len(route) - 1): distance += euclidean_distance(route[i], route[i + 1]) distance += euclidean_distance(route[-1], route[0]) return distance if len(points) == 1: return 0.0 min_distance = float('inf') for perm in permutations(points[1:]): candidate_route = [points[0]] + list(perm) route_distance = total_distance(candidate_route) if route_distance < min_distance: min_distance = route_distance return round(min_distance, 3) if __name__ == '__main__': import math # Test cases assert shortest_route([(0, 0)]) == 0.0 assert shortest_route([(0, 0), (1, 1)]) == round(2 * math.sqrt(2), 3) assert shortest_route([(0, 0), (1, 1), (2, 2)]) == round(2 * math.sqrt(2) + math.sqrt(8), 3) points = [(0, 0), (0, 1), (1, 1), (1, 0)] expected_min_distance = round(4.0, 3) assert shortest_route(points) == expected_min_distance points = [(0, 0), (0, 2), (2, 2), (2, 0)] expected_min_distance = round(8.0, 3) assert shortest_route(points) == expected_min_distance","solution":"import math from itertools import permutations def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_distance(route): distance = 0.0 for i in range(len(route) - 1): distance += euclidean_distance(route[i], route[i + 1]) # Adding the return trip to the starting point distance += euclidean_distance(route[-1], route[0]) return distance def shortest_route(points): if len(points) == 1: return 0.0 min_distance = float('inf') for perm in permutations(points[1:]): candidate_route = [points[0]] + list(perm) route_distance = total_distance(candidate_route) if route_distance < min_distance: min_distance = route_distance return round(min_distance, 3)"},{"question":"from typing import List def subset_sum(arr: List[int], target: int) -> bool: Determine if a subset with the target sum exists. Parameters: - arr (List[int]): A list of non-negative integers representing the set. - target (int): The target sum we want to achieve using the subset of \`arr\`. Returns: - bool: True if a subset with the target sum exists, otherwise False. >>> subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> subset_sum([1, 2, 3, 7], 6) True >>> subset_sum([9, 2, 6, 8], 5) False def test_subset_sum_example_cases(): assert subset_sum([3, 34, 4, 12, 5, 2], 9) == True assert subset_sum([1, 2, 3, 7], 6) == True assert subset_sum([9, 2, 6, 8], 5) == False def test_subset_sum_single_element(): assert subset_sum([7], 7) == True assert subset_sum([7], 10) == False def test_subset_sum_multiple_same_elements(): assert subset_sum([5, 5, 5], 10) == True assert subset_sum([5, 5, 5], 15) == True assert subset_sum([5, 5, 5], 20) == False def test_subset_sum_zero_target(): assert subset_sum([1, 2, 3], 0) == True def test_subset_sum_empty_array(): assert subset_sum([], 0) == True assert subset_sum([], 10) == False def test_subset_sum_large_input(): arr = [1] * 1000 assert subset_sum(arr, 500) == True if __name__ == \\"__main__\\": test_subset_sum_example_cases() test_subset_sum_single_element() test_subset_sum_multiple_same_elements() test_subset_sum_zero_target() test_subset_sum_empty_array() test_subset_sum_large_input() print(\\"All tests passed.\\")","solution":"from typing import List def subset_sum(arr: List[int], target: int) -> bool: Determine if a subset with the target sum exists. Parameters: - arr (List[int]): A list of non-negative integers representing the set. - target (int): The target sum we want to achieve using the subset of arr. Returns: - bool: True if a subset with the target sum exists, otherwise False. n = len(arr) # Initialize a DP table with False values dp = [[False] * (target + 1) for _ in range(n + 1)] # Base case: A sum of 0 can always be made with an empty subset for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, target + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] return dp[n][target]"},{"question":"import requests from typing import List class JSONApiClient: def __init__(self, base_url: str): Initialize the client with a base URL for the API. Args: base_url (str): The base URL of the JSON API. self.base_url = base_url def fetch_data(self, endpoint: str) -> dict: Fetch data from a given endpoint and return the parsed JSON response. Args: endpoint (str): The specific API endpoint to fetch data from. Returns: dict: Parsed JSON response from the API. >>> client = JSONApiClient(\\"https://api.example.com\\") >>> client.fetch_data(\\"endpoint\\") {'id': 1, 'name': 'Item 1', 'category': 'A'} pass def get_item_by_id(self, endpoint: str, item_id: int) -> dict: Fetch data from a given endpoint and return the item with the specified ID. Args: endpoint (str): The specific API endpoint to fetch data from. item_id (int): The ID of the item. Returns: dict: The item with the specified ID. >>> client = JSONApiClient(\\"https://api.example.com\\") >>> client.get_item_by_id(\\"endpoint\\", 1) {'id': 1, 'name': 'Item 1', 'category': 'A'} pass def get_items_by_category(self, endpoint: str, category: str) -> List[dict]: Fetch data from a given endpoint and return a list of items that belong to a specified category. Args: endpoint (str): The specific API endpoint to fetch data from. category (str): The name of the category to filter items by. Returns: list[dict]: List of items belonging to the specified category. >>> client = JSONApiClient(\\"https://api.example.com\\") >>> client.get_items_by_category(\\"endpoint\\", \\"A\\") [ {'id': 1, 'name': 'Item 1', 'category': 'A'}, {'id': 3, 'name': 'Item 3', 'category': 'A'} ] pass # Example usage if __name__ == \\"__main__\\": client = JSONApiClient(\\"https://api.example.com\\") products = client.fetch_data('products') product = client.get_item_by_id('products', 123) category_items = client.get_items_by_category('products', 'electronics') import pytest from unittest.mock import patch # Sample data to be used in mocked responses sample_data = [ {\\"id\\": 1, \\"name\\": \\"Item 1\\", \\"category\\": \\"A\\"}, {\\"id\\": 2, \\"name\\": \\"Item 2\\", \\"category\\": \\"B\\"}, {\\"id\\": 3, \\"name\\": \\"Item 3\\", \\"category\\": \\"A\\"}, {\\"id\\": 4, \\"name\\": \\"Item 4\\", \\"category\\": \\"C\\"} ] @patch('solution.requests.get') def test_fetch_data(mock_get): mock_get.return_value.json.return_value = sample_data mock_get.return_value.status_code = 200 client = JSONApiClient(\\"https://api.example.com\\") data = client.fetch_data('endpoint') assert data == sample_data @patch('solution.requests.get') def test_get_item_by_id(mock_get): mock_get.return_value.json.return_value = sample_data mock_get.return_value.status_code = 200 client = JSONApiClient(\\"https://api.example.com\\") item = client.get_item_by_id('endpoint', 2) assert item == {\\"id\\": 2, \\"name\\": \\"Item 2\\", \\"category\\": \\"B\\"} with pytest.raises(ValueError): client.get_item_by_id('endpoint', 99) @patch('solution.requests.get') def test_get_items_by_category(mock_get): mock_get.return_value.json.return_value = sample_data mock_get.return_value.status_code = 200 client = JSONApiClient(\\"https://api.example.com\\") items = client.get_items_by_category('endpoint', 'A') assert items == [ {\\"id\\": 1, \\"name\\": \\"Item 1\\", \\"category\\": \\"A\\"}, {\\"id\\": 3, \\"name\\": \\"Item 3\\", \\"category\\": \\"A\\"} ] items = client.get_items_by_category('endpoint', 'B') assert items == [{\\"id\\": 2, \\"name\\": \\"Item 2\\", \\"category\\": \\"B\\"}] items = client.get_items_by_category('endpoint', 'Z') assert items == []","solution":"import requests from typing import List class JSONApiClient: def __init__(self, base_url: str): self.base_url = base_url def fetch_data(self, endpoint: str) -> dict: url = f\\"{self.base_url}/{endpoint}\\" response = requests.get(url) response.raise_for_status() return response.json() def get_item_by_id(self, endpoint: str, item_id: int) -> dict: data = self.fetch_data(endpoint) for item in data: if item['id'] == item_id: return item raise ValueError(f\\"Item with ID {item_id} not found\\") def get_items_by_category(self, endpoint: str, category: str) -> List[dict]: data = self.fetch_data(endpoint) return [item for item in data if item.get('category') == category]"},{"question":"def allocate_classrooms(classes: List[Tuple[int, int]]) -> int: Determine the minimum number of classrooms required to schedule all the given classes without conflicts in time. Args: classes (List[Tuple[int, int]]): A list of tuples representing the start and end times of classes. Returns: int: The minimum number of classrooms required. >>> allocate_classrooms([(30, 75), (0, 50), (60, 150)]) 2 >>> allocate_classrooms([(0, 10), (15, 25)]) 1 >>> allocate_classrooms([(0, 30), (5, 10), (15, 20)]) 2 >>> allocate_classrooms([(1, 4), (2, 6), (8, 9), (8, 9)]) 2 pass # Example Usage classes = [(30, 75), (0, 50), (60, 150)] print(allocate_classrooms(classes)) # Expected output: 2","solution":"import heapq def allocate_classrooms(classes): if not classes: return 0 # Sort classes by start time classes.sort(key=lambda x: x[0]) # Initialize a heap heap = [] # Add the end time of the first class heapq.heappush(heap, classes[0][1]) # Iterate through the rest of the classes for i in range(1, len(classes)): # If the current class starts after or when the earliest ending class finishes, # remove the end time from the heap if classes[i][0] >= heap[0]: heapq.heappop(heap) # Add the current class's end time to the heap heapq.heappush(heap, classes[i][1]) # The size of the heap is the minimum number of classrooms required return len(heap)"},{"question":"import pandas as pd def process_large_csv(file_path: str, chunk_size: int): Optimized CSV processing in chunks with vectorized operations. Parameters: file_path (str): The path to the large CSV file. chunk_size (int): Number of rows to read per chunk. Outputs: The function should print the calculated metric.","solution":"import pandas as pd def process_large_csv(file_path: str, chunk_size: int): Optimized CSV processing in chunks with vectorized operations. Parameters: file_path (str): The path to the large CSV file. chunk_size (int): Number of rows to read per chunk. Outputs: The function should print the calculated metric. aggregate_metric = 0 total_rows = 0 for chunk in pd.read_csv(file_path, chunksize=chunk_size): # Example of vectorized operation: calculate the sum of a column chunk_sum = chunk['column_name'].sum() # Replace 'column_name' with the actual column name aggregate_metric += chunk_sum total_rows += len(chunk) # Can perform other vectorized operations on the chunk here if total_rows > 0: calculated_metric = aggregate_metric / total_rows else: calculated_metric = 0 print(f\\"Calculated Metric: {calculated_metric}\\")"},{"question":"def most_frequent_char(s: str) -> str: Finds and returns the most frequently occurring character in the string s. If there are multiple characters with the same maximum frequency, returns the character that appears first in the string. >>> most_frequent_char(\\"abracadabra\\") == 'a' >>> most_frequent_char(\\"hello world\\") == 'l' >>> most_frequent_char(\\"aabbbccdde\\") == 'b' >>> most_frequent_char(\\"xyzzyx\\") == 'x' pass from solution import most_frequent_char def test_single_character(): assert most_frequent_char(\\"a\\") == \\"a\\" def test_simple_cases(): assert most_frequent_char(\\"abracadabra\\") == \\"a\\" assert most_frequent_char(\\"hello\\") == \\"l\\" assert most_frequent_char(\\"aabbbccdde\\") == \\"b\\" def test_tie_cases(): assert most_frequent_char(\\"xyxy\\") == \\"x\\" assert most_frequent_char(\\"aabb\\") == \\"a\\" assert most_frequent_char(\\"little\\") == \\"l\\" def test_all_unique(): assert most_frequent_char(\\"abcdefg\\") == \\"a\\" def test_large_input(): assert most_frequent_char(\\"a\\" * 100000 + \\"b\\" * 99999) == \\"a\\" def test_case_sensitivity(): assert most_frequent_char(\\"aaBBccddd\\") == \\"d\\" assert most_frequent_char(\\"AaaBBB\\") == \\"B\\" def test_unicode_characters(): assert most_frequent_char(\\"こんにちはこんにちは\\") == \\"こ\\"","solution":"def most_frequent_char(s: str) -> str: Finds and returns the most frequently occurring character in the string s. If there are multiple characters with the same maximum frequency, returns the character that appears first in the string. from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Find the character(s) with the maximum frequency max_freq = max(count.values()) # Return the first character in the string that has the maximum frequency for char in s: if count[char] == max_freq: return char"},{"question":"def strip_comments(source_code: str) -> str: Removes both single-line (//) and multi-line (/*...*/) comments from the given source code string, while preserving string literals. >>> source_code = ''' ... int main() { ... // Single-line comment ... printf(\\"Hello, World!\\"); /* Multi-line ... comment */ ... return 0; ... } ... ''' >>> strip_comments(source_code) 'nint main() {n n printf(\\"Hello, World!\\"); n return 0;n}n' >>> source_code = ''' ... const char* str = \\"/* Not a comment */\\"; ... // End line comment ... ''' >>> strip_comments(source_code) 'nconst char* str = \\"/* Not a comment */\\";nn' >>> source_code = 'printf(\\"String with // inside\\");' >>> strip_comments(source_code) 'printf(\\"String with // inside\\");'","solution":"def strip_comments(source_code: str) -> str: Removes both single-line (//) and multi-line (/*...*/) comments from the given source code string, while preserving string literals. import re # Regular expression to match comments, while ignoring string literals # This regex uses negative lookbehind to avoid removal inside string literals pattern = r'((?<!)\\".*?(?<!)\\"|/*.*?*/|//.*?)' def replacer(match): # If the match is a comment, return an empty string to remove it # Otherwise, return the match itself (string literal) return match.group(1) if match.group(1).startswith('\\"') else \\"\\" # Use regex sub with the defined pattern and replacer function cleaned_code = re.sub(pattern, replacer, source_code, flags=re.DOTALL | re.MULTILINE) return cleaned_code"},{"question":"class OrderQueue: Simulate a queue system for orders in a restaurant. def __init__(self): Initialize the order queue. self.queue = [] def add_order(self, order: str) -> None: Add a new order (string) to the queue. def process_order(self) -> str: Remove the order that is next in line and return it. If the queue is empty, return \`None\`. def peek_next_order(self) -> str: Return the next order to be processed without removing it from the queue. If the queue is empty, return \`None\`. def is_empty(self) -> bool: Return \`True\` if the queue is empty, otherwise \`False\`. def main(): Simulates adding several orders to the OrderQueue, processing and printing each order until the queue is empty. order_queue = OrderQueue() orders = [\\"Cheeseburger\\", \\"Fries\\", \\"Cola\\"] for order in orders: order_queue.add_order(order) print(f'Added order: {order}') print(f'Next order to process: {order_queue.peek_next_order()}') while not order_queue.is_empty(): print(f'Processed order: {order_queue.process_order()}') print(f'Queue empty: {order_queue.is_empty()}') if __name__ == \\"__main__\\": main()","solution":"class OrderQueue: def __init__(self): self.queue = [] def add_order(self, order: str) -> None: self.queue.append(order) def process_order(self) -> str: if self.is_empty(): return None return self.queue.pop(0) def peek_next_order(self) -> str: if self.is_empty(): return None return self.queue[0] def is_empty(self) -> bool: return len(self.queue) == 0 def main(): order_queue = OrderQueue() orders = [\\"Cheeseburger\\", \\"Fries\\", \\"Cola\\"] for order in orders: order_queue.add_order(order) print(f'Added order: {order}') print(f'Next order to process: {order_queue.peek_next_order()}') while not order_queue.is_empty(): print(f'Processed order: {order_queue.process_order()}') print(f'Queue empty: {order_queue.is_empty()}') if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def custom_radix_sort(arr: List[int]) -> List[int]: Sort an array of integers using the Radix Sort algorithm. >>> custom_radix_sort([-15, 3, 0, -23, 5, 7, -1]) [-23, -15, -1, 0, 3, 5, 7] >>> custom_radix_sort([3, 1, 4, 2]) [1, 2, 3, 4] >>> custom_radix_sort([-3, -1, -4, -2]) [-4, -3, -2, -1] >>> custom_radix_sort([]) [] >>> custom_radix_sort([100000, -99999, 50000, -100000, 99999]) [-100000, -99999, 50000, 99999, 100000] >>> custom_radix_sort([3, 1, 2, 2, 1, 3]) [1, 1, 2, 2, 3, 3]","solution":"from typing import List from math import log10 def counting_sort_for_radix(arr, exp, base): n = len(arr) output = [0] * n count = [0] * base for i in range(n): index = abs(arr[i]) // exp count[index % base] += 1 for i in range(1, base): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % base] - 1] = arr[i] count[index % base] -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr, base=10): if len(arr) == 0: return arr max_num = max(abs(num) for num in arr) exp = 1 while max_num // exp > 0: counting_sort_for_radix(arr, exp, base) exp *= base def custom_radix_sort(arr: List[int]) -> List[int]: if not arr: return [] # Separate positive and negative numbers neg = [-num for num in arr if num < 0] pos = [num for num in arr if num >= 0] # Sort positive and negative numbers separately radix_sort(neg) radix_sort(pos) # Combine them: negatives are reversed and negated, followed by positives neg = [-num for num in reversed(neg)] return neg + pos"},{"question":"def infix_to_postfix(expression: str) -> str: Converts the given infix expression to its equivalent postfix expression. Args: expression (str): A string representing the infix expression. The expression will contain single-letter operands (A-Z), binary operators (+, -, *, /), and parentheses for grouping. Returns: str: A string representing the postfix expression corresponding to the given infix expression. Examples: >>> infix_to_postfix(\\"A+B*C\\") 'ABC*+' >>> infix_to_postfix(\\"(A+B)*C\\") 'AB+C*' >>> infix_to_postfix(\\"A*(B+C*D)+E\\") 'ABCD*+*E+'","solution":"def infix_to_postfix(expression: str) -> str: Converts the given infix expression to its equivalent postfix expression. precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 0} stack = [] postfix = [] for char in expression: if char.isalpha(): # Operand postfix.append(char) elif char == '(': # Left parenthesis stack.append(char) elif char == ')': # Right parenthesis while stack and stack[-1] != '(': postfix.append(stack.pop()) stack.pop() # Pop the left parenthesis else: # Operator while stack and precedence[stack[-1]] >= precedence[char]: postfix.append(stack.pop()) stack.append(char) while stack: postfix.append(stack.pop()) return ''.join(postfix)"},{"question":"from typing import Union, Optional class ExpressionNode: def __init__(self, value: Union[int, str], left: Optional['ExpressionNode'] = None, right: Optional['ExpressionNode'] = None): Initializes the node with a value, left child, and right child. def __str__(self) -> str: Returns a string representation of the node and its children. class ExpressionTree: def __init__(self, expression: str): Initializes the expression tree with an infix expression. def _build_tree(self) -> ExpressionNode: Parses the expression and builds an expression tree. This function should handle operator precedence and parentheses correctly. def _tokenize(self, expression: str): Tokenizes the given expression string into a list of tokens. def _evaluate_node(self, node: ExpressionNode) -> int: Recursively evaluates the expression tree starting from the given node. def evaluate(self) -> int: Evaluates the entire expression tree and returns the result. def __str__(self) -> str: Returns a string representation of the expression tree. # Example usage: # Initialization exp_tree = ExpressionTree(\\"(3 + 2) * (7 - 4) / 3\\") # Expression Tree String Representation print(exp_tree) # Should print a suitable string representation of the tree # Evaluate the Expression result = exp_tree.evaluate() print(result) # Should print 5 # Unit Tests def test_simple_addition(): exp_tree = ExpressionTree(\\"2 + 3\\") assert exp_tree.evaluate() == 5 def test_simple_subtraction(): exp_tree = ExpressionTree(\\"5 - 2\\") assert exp_tree.evaluate() == 3 def test_multiplication(): exp_tree = ExpressionTree(\\"3 * 4\\") assert exp_tree.evaluate() == 12 def test_division(): exp_tree = ExpressionTree(\\"10 / 2\\") assert exp_tree.evaluate() == 5 def test_operator_precedence(): exp_tree = ExpressionTree(\\"2 + 3 * 4\\") assert exp_tree.evaluate() == 14 def test_parentheses(): exp_tree = ExpressionTree(\\"(2 + 3) * 4\\") assert exp_tree.evaluate() == 20 def test_complex_expression(): exp_tree = ExpressionTree(\\"(3 + 2) * (7 - 4) / 3\\") assert exp_tree.evaluate() == 5 def test_expression_string_representation(): exp_tree = ExpressionTree(\\"3 + 2\\") assert str(exp_tree) == \\"(3 + 2)\\"","solution":"from typing import Union, Optional class ExpressionNode: def __init__(self, value: Union[int, str], left: Optional['ExpressionNode'] = None, right: Optional['ExpressionNode'] = None): self.value = value self.left = left self.right = right def __str__(self) -> str: if self.left is None and self.right is None: return str(self.value) return f\\"({str(self.left)} {self.value} {str(self.right)})\\" class ExpressionTree: def __init__(self, expression: str): self.expression = expression self.root = self._build_tree() def _build_tree(self) -> ExpressionNode: tokens = self._tokenize(self.expression) output = [] operators = [] def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operator(operators, output): right = output.pop() left = output.pop() op = operators.pop() output.append(ExpressionNode(op, left, right)) i = 0 while i < len(tokens): if tokens[i].isdigit(): output.append(ExpressionNode(int(tokens[i]))) elif tokens[i] == '(': operators.append(tokens[i]) elif tokens[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, output) operators.pop() # remove the '(' else: # it is an operator while (operators and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operators, output) operators.append(tokens[i]) i += 1 while operators: apply_operator(operators, output) return output[0] def _tokenize(self, expression: str): tokens = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = '' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 tokens.append(num) elif expression[i] in '+-*/()': tokens.append(expression[i]) i += 1 else: i += 1 # skip spaces return tokens def _evaluate_node(self, node: ExpressionNode) -> int: if isinstance(node.value, int): return node.value left_val = self._evaluate_node(node.left) right_val = self._evaluate_node(node.right) if node.value == '+': return left_val + right_val elif node.value == '-': return left_val - right_val elif node.value == '*': return left_val * right_val elif node.value == '/': return left_val // right_val # integer division def evaluate(self) -> int: return self._evaluate_node(self.root) def __str__(self) -> str: return str(self.root)"},{"question":"def sieve_of_eratosthenes(n: int) -> list: Calculate all prime numbers up to a given number \`n\` using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def sieve_of_eratosthenes(n: int) -> list: if n < 2: return [] # Initialize a list of boolean values, where index \`i\` will be True if \`i\` is a prime number. is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers. p = 2 while (p * p <= n): # If is_prime[p] is still True, then it is a prime. if is_prime[p]: # Updating all multiples of p to not prime for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 # Collecting all prime numbers from the is_prime array primes = [p for p in range(n + 1) if is_prime[p]] return primes"},{"question":"def dijkstra(graph: dict[str, dict[str, int]], start: str, end: str) -> list[str]: Find the shortest path between start and end nodes using Dijkstra's algorithm. Args: graph (dict[str, dict[str, int]]): A dictionary representing the graph where keys are node names and values are dictionaries of neighboring nodes and edge weights. start (str): The starting node for the path. end (str): The target node for the path. Returns: list[str]: A list of nodes representing the shortest path from start to end. Examples: >>> graph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'C': 2, 'D': 5}, 'C': {'A': 4, 'B': 2, 'D': 1}, 'D': {'B': 5, 'C': 1}} >>> dijkstra(graph, 'A', 'D') ['A', 'B', 'C', 'D'] >>> dijkstra(graph, 'A', 'A') ['A'] >>> dijkstra(graph, 'A', 'E') []","solution":"import heapq def dijkstra(graph, start, end): Find the shortest path between start and end nodes using Dijkstra's algorithm. Args: graph (dict): A dictionary representing the graph where keys are node names and values are dictionaries of neighboring nodes and edge weights. start (str): The starting node for the path. end (str): The target node for the path. Returns: list: A list of nodes representing the shortest path from start to end. # Priority queue to store (cost, node, path) priority_queue = [(0, start, [])] visited = set() while priority_queue: (cost, current_node, path) = heapq.heappop(priority_queue) if current_node in visited: continue path = path + [current_node] visited.add(current_node) # Goal state if current_node == end: return path for neighbor, weight in graph.get(current_node, {}).items(): if neighbor not in visited: heapq.heappush(priority_queue, (cost + weight, neighbor, path)) return []"},{"question":"from typing import List def number_of_divisors(x: int) -> int: Helper function to return the number of divisors of x. pass def game_of_sequences(a1: int, n: int) -> List[int]: Generates a sequence of numbers based on the rule provided. :param a1: The initial element of the sequence. :param n: The length of the sequence. :return: A list representing the sequence. pass # Test cases def test_number_of_divisors(): assert number_of_divisors(1) == 1 assert number_of_divisors(2) == 2 assert number_of_divisors(3) == 2 assert number_of_divisors(4) == 3 assert number_of_divisors(6) == 4 assert number_of_divisors(12) == 6 assert number_of_divisors(28) == 6 def test_game_of_sequences_basic(): assert game_of_sequences(6, 5) == [6, 4, 3, 2, 2] assert game_of_sequences(7, 4) == [7, 2, 2, 2] def test_game_of_sequences_single_element(): assert game_of_sequences(1, 1) == [1] assert game_of_sequences(5, 1) == [5] def test_game_of_sequences_longer(): assert game_of_sequences(12, 6) == [12, 6, 4, 3, 2, 2] assert game_of_sequences(28, 5) == [28, 6, 4, 3, 2] def test_game_of_sequences_edge_cases(): assert game_of_sequences(1000, 10) == [1000, 16, 5, 2, 2, 2, 2, 2, 2, 2] assert game_of_sequences(999, 3) == [999, 8, 4]","solution":"from typing import List def number_of_divisors(x: int) -> int: Helper function to return the number of divisors of x. count = 0 for i in range(1, int(x**0.5) + 1): if x % i == 0: count += 1 if i != x // i: # To account for both divisors when i is not the square root of x count += 1 return count def game_of_sequences(a1: int, n: int) -> List[int]: Generates a sequence of numbers based on the rule provided. :param a1: The initial element of the sequence. :param n: The length of the sequence. :return: A list representing the sequence. sequence = [a1] current_value = a1 for _ in range(n - 1): next_value = number_of_divisors(current_value) sequence.append(next_value) current_value = next_value return sequence"},{"question":"def calculate_total(cart: list, location: str) -> float: Calculates the total price of all items in the cart, including tax. - cart: A list of dictionaries, where each dictionary represents an item in the cart and has two keys: \\"unit_price\\" and \\"quantity\\". - location: A string that indicates the location for the sales tax. The function returns the total price as a float, rounded to 2 decimal places. >>> cart = [ {\\"unit_price\\": 19.99, \\"quantity\\": 2}, {\\"unit_price\\": 5.49, \\"quantity\\": 3}, {\\"unit_price\\": 7.99, \\"quantity\\": 1} ] >>> calculate_total(cart, 'NY') 66.25 >>> cart = [] >>> calculate_total(cart, \\"NY\\") 0.0 >>> cart = [ {\\"unit_price\\": 19.99, \\"quantity\\": 0}, {\\"unit_price\\": 5.49, \\"quantity\\": 0} ] >>> calculate_total(cart, \\"CA\\") 0.0 >>> cart = [ {\\"unit_price\\": 19.99, \\"quantity\\": 2}, {\\"unit_price\\": -5.49, \\"quantity\\": 3}, {\\"unit_price\\": 7.99, \\"quantity\\": 0}, {\\"unit_price\\": 10.00, \\"quantity\\": 1} ] >>> calculate_total(cart, \\"NY\\") 66.25 >>> cart = [ {\\"unit_price\\": 100.0, \\"quantity\\": 1}, {\\"unit_price\\": 50.0, \\"quantity\\": 2} ] >>> calculate_total(cart, \\"Other\\") 210.0 >>> cart = [ {\\"unit_price\\": 10.0, \\"quantity\\": 10} ] >>> calculate_total(cart, \\"CA\\") 107.25 >>> cart = [{\\"unit_price\\": 50.0, \\"quantity\\": 1}] >>> calculate_total(cart, \\"NY\\") 54.44 >>> calculate_total(cart, \\"CA\\") 53.62 >>> calculate_total(cart, \\"TX\\") 52.5","solution":"def calculate_total(cart: list, location: str) -> float: Calculates the total price of items in a shopping cart, including tax based on location. # Define the sales tax rates tax_rates = { 'NY': 0.08875, 'CA': 0.0725, 'default': 0.05 } # Determine the applicable tax rate based on location sales_tax_rate = tax_rates.get(location, tax_rates['default']) # Initialize total price total_price = 0.0 for item in cart: # Extract unit price and quantity, ignoring invalid entries unit_price = item.get(\\"unit_price\\", -1) quantity = item.get(\\"quantity\\", -1) if unit_price < 0 or quantity <= 0: continue # Calculate the subtotal price for the current item subtotal = unit_price * quantity total_price += subtotal # Apply sales tax to the total price total_with_tax = total_price * (1 + sales_tax_rate) # Return the total price rounded to 2 decimal places return round(total_with_tax, 2)"},{"question":"def reverse_excluding_evens(lst: list) -> list: Reverse a list excluding elements at even indices. :param lst: A list of elements. :return: A new list with odd-indexed elements reversed and even-indexed elements in original order. >>> reverse_excluding_evens([1, 2, 3, 4, 5]) [1, 4, 3, 2, 5] >>> reverse_excluding_evens([1, 2, 3, 4, 5, 6]) [1, 6, 3, 4, 5, 2] >>> reverse_excluding_evens(['a', 'b', 'c', 'd']) ['a', 'd', 'c', 'b'] >>> reverse_excluding_evens([]) [] >>> reverse_excluding_evens([1, 'a', 2, 'b']) [1, 'b', 2, 'a'] def test_example_cases(): assert reverse_excluding_evens([1, 2, 3, 4, 5]) == [1, 4, 3, 2, 5] assert reverse_excluding_evens([1, 2, 3, 4, 5, 6]) == [1, 6, 3, 4, 5, 2] assert reverse_excluding_evens(['a', 'b', 'c', 'd']) == ['a', 'd', 'c', 'b'] def test_empty_list(): assert reverse_excluding_evens([]) == [] def test_single_element_list(): assert reverse_excluding_evens([42]) == [42] def test_mixed_data_types(): assert reverse_excluding_evens([1, 'a', 2, 'b']) == [1, 'b', 2, 'a'] assert reverse_excluding_evens([True, 'yes', 42, 3.14]) == [True, 3.14, 42, 'yes'] def test_all_elements_same_type(): assert reverse_excluding_evens([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 8, 3, 6, 5, 4, 7, 2, 9] assert reverse_excluding_evens(['a', 'b', 'c', 'd', 'e', 'f', 'g']) == ['a', 'f', 'c', 'd', 'e', 'b', 'g'] def test_long_list(): input_list = list(range(1000)) expected_output = list(range(1000)) odd_part = list(range(1, 1000, 2))[::-1] expected_output[1::2] = odd_part # Replace odd indices with reversed odd part assert reverse_excluding_evens(input_list) == expected_output","solution":"def reverse_excluding_evens(lst): Reverse a list excluding elements at even indices. :param lst: A list of elements. :return: A new list with odd-indexed elements reversed and even-indexed elements in original order. if not lst: return [] odd_indices = [i for i in range(len(lst)) if i % 2 != 0] reversed_odd_values = [lst[i] for i in odd_indices][::-1] result = lst.copy() for i, idx in enumerate(odd_indices): result[idx] = reversed_odd_values[i] return result"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lowest_common_ancestor(root: TreeNode, p: int, q: int) -> int: Given the root of a binary tree and two distinct node values, find the lowest common ancestor (LCA) of the nodes with those values. Args: root (TreeNode): The root node of the binary tree. p (int): The value of the first node. q (int): The value of the second node. Returns: int: The value of the lowest common ancestor node. >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> find_lowest_common_ancestor(root, 5, 1) 3 >>> find_lowest_common_ancestor(root, 5, 4) 5 >>> find_lowest_common_ancestor(root, 6, 4) 5","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lowest_common_ancestor(root: TreeNode, p: int, q: int) -> int: def helper(node): if not node: return None if node.val == p or node.val == q: return node left = helper(node.left) right = helper(node.right) if left and right: return node return left if left else right lca = helper(root) return lca.val"},{"question":"def insert_url(trie: dict, url: str) -> None: Insert a given URL into the trie. Args: trie (dict): The root node of the trie. url (str): The URL to be inserted. pass def find_urls(trie: dict, prefix: str) -> List[str]: Find all URLs in the trie that start with the given prefix. Args: trie (dict): The root node of the trie. prefix (str): The prefix to search for. Returns: List[str]: A list of URLs that start with the given prefix. pass # Unit Tests def test_insert_and_find_urls(): trie = {} insert_url(trie, \\"www.google.com\\") insert_url(trie, \\"www.golang.org\\") insert_url(trie, \\"www.github.com\\") insert_url(trie, \\"www.geeksforgeeks.org\\") assert find_urls(trie, \\"www.go\\") == ['www.google.com', 'www.golang.org'] assert find_urls(trie, \\"www.gi\\") == ['www.github.com'] assert find_urls(trie, \\"www.g\\") == ['www.google.com', 'www.golang.org', 'www.github.com', 'www.geeksforgeeks.org'] assert find_urls(trie, \\"www.geek\\") == ['www.geeksforgeeks.org'] assert find_urls(trie, \\"\\") == ['www.google.com', 'www.golang.org', 'www.github.com', 'www.geeksforgeeks.org'] assert find_urls(trie, \\"www.y\\") == [] def test_insert_duplicate_urls(): trie = {} insert_url(trie, \\"www.example.com\\") insert_url(trie, \\"www.example.com\\") assert find_urls(trie, \\"www.example\\") == [\\"www.example.com\\"] def test_no_matching_prefix(): trie = {} insert_url(trie, \\"www.example.com\\") insert_url(trie, \\"www.example.org\\") assert find_urls(trie, \\"www.notexample\\") == [] def test_empty_trie(): trie = {} assert find_urls(trie, \\"any\\") == []","solution":"def insert_url(trie, url): Insert a given URL into the trie. Args: trie (dict): The root node of the trie. url (str): The URL to be inserted. node = trie for char in url: if char not in node: node[char] = {} node = node[char] node['*'] = url # '*' signifies the end of the URL def find_urls(trie, prefix): Find all URLs in the trie that start with the given prefix. Args: trie (dict): The root node of the trie. prefix (str): The prefix to search for. Returns: List[str]: A list of URLs that start with the given prefix. def dfs(node, path, results): if '*' in node: results.append(node['*']) for char in node: if char != '*': dfs(node[char], path + char, results) results = [] node = trie for char in prefix: if char in node: node = node[char] else: return results dfs(node, prefix, results) return results"},{"question":"def is_anagram(s: str, t: str) -> bool: Determine if t is an anagram of s. :param s: First string :param t: Second string :return: True if t is an anagram of s, False otherwise Examples: >>> is_anagram(\\"anagram\\", \\"nagaram\\") True >>> is_anagram(\\"rat\\", \\"car\\") False","solution":"def is_anagram(s: str, t: str) -> bool: Determine if t is an anagram of s. :param s: First string :param t: Second string :return: True if t is an anagram of s, False otherwise if len(s) != len(t): return False # Utilize a counter to count occurrences of each character from collections import Counter # Compare character counts of both strings return Counter(s) == Counter(t)"},{"question":"def sum_of_digits(n: int) -> int: Compute the sum of the digits in a given positive integer. >>> sum_of_digits(12345) 15 >>> sum_of_digits(9876) 30 >>> sum_of_digits(111111) 6 pass # Unit Tests def test_single_digit(): assert sum_of_digits(5) == 5 assert sum_of_digits(9) == 9 def test_multiple_digits(): assert sum_of_digits(12345) == 15 assert sum_of_digits(9876) == 30 assert sum_of_digits(111111) == 6 def test_large_number(): assert sum_of_digits(123456789123456789) == 90 assert sum_of_digits(999999999999999999) == 162 def test_minimum_input(): assert sum_of_digits(1) == 1 assert sum_of_digits(10) == 1","solution":"def sum_of_digits(n): Returns the sum of the digits of a given number n. Parameters: n (int): The positive integer whose sum of digits is to be computed. Returns: int: The sum of the digits of n. return sum(int(digit) for digit in str(n))"},{"question":"def find_optimal_route(locations: list[tuple[int, int]]) -> list[tuple[int, int]]: Find the optimal route for a delivery driver to visit all given locations exactly once while minimizing the total distance traveled. The driver starts at the origin (0, 0). Args: locations (list): A list of tuples, where each tuple contains two integers representing the x and y coordinates of a delivery location. Returns: list: A list of tuples representing the optimal order of locations to visit. >>> find_optimal_route([(1, 2), (4, 6), (3, 1), (6, 5)]) [(1, 2), (3, 1), (4, 6), (6, 5)] >>> find_optimal_route([(2, 3), (-1, -5), (7, 8), (3, 3)]) [(2, 3), (3, 3), (7, 8), (-1, -5)]","solution":"def find_optimal_route(locations): Returns the approximate optimal route for the given locations using a heuristic approach like the nearest neighbor. import math def distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) if not locations: return [] # Start from the origin current_location = (0, 0) unvisited_locations = set(locations) route = [] while unvisited_locations: next_location = min(unvisited_locations, key=lambda loc: distance(current_location, loc)) route.append(next_location) unvisited_locations.remove(next_location) current_location = next_location return route"},{"question":"# Function Signature def is_valid_identifier(input_str: str) -> bool: Validate if the input string is a valid identifier. Args: input_str (str): The string to be validated as an identifier. Returns: bool: True if the input_str is a valid identifier, False otherwise. if not isinstance(input_str, str): raise ValueError(f\\"Expected string as input, found {type(input_str)}\\") if len(input_str) == 0: return False if not (input_str[0].isalpha() or input_str[0] == '_'): return False for char in input_str[1:]: if not (char.isalnum() or char == '_'): return False return True # Example example_input = \\"variable1\\" example_output = is_valid_identifier(example_input) assert example_output == True, f\\"Expected True, but got {example_output}\\" example_input = \\"1variable\\" example_output = is_valid_identifier(example_input) assert example_output == False, f\\"Expected False, but got {example_output}\\" # Unit Tests def test_valid_identifiers(): assert is_valid_identifier(\\"variable1\\") == True assert is_valid_identifier(\\"_variable\\") == True assert is_valid_identifier(\\"variable_name\\") == True assert is_valid_identifier(\\"a\\") == True assert is_valid_identifier(\\"_\\") == True def test_invalid_identifiers(): assert is_valid_identifier(\\"1variable\\") == False assert is_valid_identifier(\\"variable-name\\") == False assert is_valid_identifier(\\"\\") == False assert is_valid_identifier(\\" \\") == False assert is_valid_identifier(\\"var!able\\") == False def test_value_error_for_non_string_input(): import pytest with pytest.raises(ValueError, match=\\"Expected string as input, found <class 'int'>\\"): is_valid_identifier(123) with pytest.raises(ValueError, match=\\"Expected string as input, found <class 'list'>\\"): is_valid_identifier([\\"variable\\"]) with pytest.raises(ValueError, match=\\"Expected string as input, found <class 'NoneType'>\\"): is_valid_identifier(None)","solution":"def is_valid_identifier(input_str: str) -> bool: if not isinstance(input_str, str): raise ValueError(f\\"Expected string as input, found {type(input_str)}\\") if len(input_str) == 0: return False if not (input_str[0].isalpha() or input_str[0] == '_'): return False for char in input_str[1:]: if not (char.isalnum() or char == '_'): return False return True"},{"question":"# TaskQueue Implementation class InvalidTaskError(Exception): Raised when an invalid task is enqueued pass class EmptyQueueError(Exception): Raised when an operation is attempted on an empty queue pass class TaskQueue: def __init__(self): self.queue = [] def enqueue(self, task: str) -> None: if not task: raise InvalidTaskError(\\"Task cannot be empty\\") self.queue.append(task) def dequeue(self) -> str: if self.is_empty(): raise EmptyQueueError(\\"No tasks in the queue\\") return self.queue.pop(0) def peek(self) -> str: if self.is_empty(): raise EmptyQueueError(\\"No tasks in the queue\\") return self.queue[0] def is_empty(self) -> bool: return len(self.queue) == 0 def size() -> int: return len(self.queue)","solution":"class InvalidTaskError(Exception): Raised when an invalid task is enqueued pass class EmptyQueueError(Exception): Raised when an operation is attempted on an empty queue pass class TaskQueue: def __init__(self): self.queue = [] def enqueue(self, task: str) -> None: if not task: raise InvalidTaskError(\\"Task cannot be empty\\") self.queue.append(task) def dequeue(self) -> str: if self.is_empty(): raise EmptyQueueError(\\"No tasks in the queue\\") return self.queue.pop(0) def peek(self) -> str: if self.is_empty(): raise EmptyQueueError(\\"No tasks in the queue\\") return self.queue[0] def is_empty(self) -> bool: return len(self.queue) == 0 def size(self) -> int: return len(self.queue)"},{"question":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate a N x N matrix representation of an image by 90 degrees in a clockwise direction. Validate that it is a square matrix, raising a ValueError if not. >>> rotate_matrix_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1]]) [[1]] >>> rotate_matrix_90_clockwise([[1, 2], [3]]) Traceback (most recent call last): ... ValueError: Input must be an N x N matrix","solution":"def rotate_matrix_90_clockwise(matrix): if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be an N x N matrix\\") n = len(matrix) # Generate new matrix of same size filled with zeros rotated_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"def can_rearrange_to_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_rearrange_to_palindrome(\\"civic\\") True >>> can_rearrange_to_palindrome(\\"ivicc\\") True >>> can_rearrange_to_palindrome(\\"hello\\") False # Your code here def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string. Args: s (str): The input string. Returns: str: The longest palindromic substring. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" # Your code here","solution":"def can_rearrange_to_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character char_count = Counter(s) # Count the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # We can form a palindrome if there is at most one character with an odd frequency return odd_count <= 1 def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string. if not s: return \\"\\" n = len(s) start = 0 max_length = 1 # Dynamic Programming table dp = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for palindrome of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for palindrome of length greater than 2 for length in range(3, n + 1): # length of the palindrome for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True start = i max_length = length return s[start:start + max_length]"},{"question":"from typing import Dict def word_histogram(text: str) -> Dict[str, int]: Generates a word frequency histogram from the input text. Arguments: text: str - The input text to analyze. Returns: Dict[str, int] - A dictionary where the keys are the words from the text, and the values are the frequencies of those words. Example usage: >>> word_histogram(\\"Hello, world! Hello.\\") {'hello': 2, 'world': 1} >>> word_histogram(\\"This is a test. This test is simple.\\") {'this': 2, 'is': 2, 'a': 1, 'test': 2, 'simple': 1} >>> word_histogram(\\"Numbers 123, 123, and 456!\\") {'numbers': 1, '123': 2, 'and': 1, '456': 1} >>> word_histogram(\\"\\") {}","solution":"import re from collections import defaultdict from typing import Dict def word_histogram(text: str) -> Dict[str, int]: Generates a word frequency histogram from the input text. # Convert the text to lowercase text = text.lower() # Use regular expressions to find all words words = re.findall(r'bw+b', text) # Use a defaultdict to count the word frequencies histogram = defaultdict(int) for word in words: histogram[word] += 1 return dict(histogram)"},{"question":"def vending_machine(money: float, snack_id: int) -> tuple[str, float]: Implements a vending machine that provides snacks based on the amount of money inserted. Returns the snack and change or an error message. - money: A float representing the amount of money inserted by the user. - snack_id: An integer representing the ID of the snack the user wishes to purchase. The snack inventory is as follows: { 1: {\\"name\\": \\"Chips\\", \\"price\\": 2.50, \\"quantity\\": 10}, 2: {\\"name\\": \\"Soda\\", \\"price\\": 1.75, \\"quantity\\": 15}, 3: {\\"name\\": \\"Candy Bar\\", \\"price\\": 1.25, \\"quantity\\": 5}, 4: {\\"name\\": \\"Cookies\\", \\"price\\": 3.00, \\"quantity\\": 0}, 5: {\\"name\\": \\"Juice\\", \\"price\\": 2.00, \\"quantity\\": 7}, } Returns a tuple (str, float): - \`str\`: name of the snack if the purchase is successful, or an error message. - \`float\`: change returned to the user, or 0.0 if the transaction is not successful. Example usage: >>> vending_machine(5.00, 1) ('Chips', 2.50) >>> vending_machine(1.00, 2) ('Insufficient funds', 0.0) >>> vending_machine(2.50, 4) ('Out of stock', 0.0) >>> vending_machine(1.50, 3) ('Candy Bar', 0.25) >>> vending_machine(2.00, 5) ('Juice', 0.0)","solution":"def vending_machine(money: float, snack_id: int) -> tuple[str, float]: # Inventory of snacks inventory = { 1: {\\"name\\": \\"Chips\\", \\"price\\": 2.50, \\"quantity\\": 10}, 2: {\\"name\\": \\"Soda\\", \\"price\\": 1.75, \\"quantity\\": 15}, 3: {\\"name\\": \\"Candy Bar\\", \\"price\\": 1.25, \\"quantity\\": 5}, 4: {\\"name\\": \\"Cookies\\", \\"price\\": 3.00, \\"quantity\\": 0}, 5: {\\"name\\": \\"Juice\\", \\"price\\": 2.00, \\"quantity\\": 7}, } if not isinstance(money, (int, float)) or not isinstance(snack_id, int): return (\\"Invalid input\\", 0.0) if money < 0 or snack_id not in inventory: return (\\"Invalid input\\", 0.0) snack = inventory[snack_id] if snack[\\"quantity\\"] == 0: return (\\"Out of stock\\", 0.0) if money < snack[\\"price\\"]: return (\\"Insufficient funds\\", 0.0) change = round(money - snack[\\"price\\"], 2) return (snack[\\"name\\"], change)"},{"question":"class TrieNode: def __init__(self): Initializes a TrieNode with child nodes set to an empty dictionary and a boolean flag indicating if it's the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initializes the Trie with the root node. self.root = TrieNode() def insert(self, word): Inserts a word into the Trie. word : string : The word to be inserted. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") pass def search(self, word): Searches for a word in the Trie. word : string : The word to search for. Returns True if the word exists in the Trie, otherwise False. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False pass def startsWith(self, prefix): Checks if there is any word in the Trie that starts with the given prefix. prefix : string : The prefix to search for. Returns True if there is a word in the Trie that starts with the prefix, otherwise False. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.startsWith(\\"app\\") True >>> trie.startsWith(\\"appl\\") True >>> trie.startsWith(\\"apl\\") False pass from solution import Trie def test_insert_and_search_word(): trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True assert trie.search(\\"app\\") == False def test_search_non_inserted_word(): trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"banana\\") == False def test_starts_with_prefix(): trie = Trie() trie.insert(\\"apple\\") assert trie.startsWith(\\"app\\") == True assert trie.startsWith(\\"appl\\") == True assert trie.startsWith(\\"apl\\") == False def test_insert_and_search_multiple_words(): trie = Trie() words = [\\"apple\\", \\"app\\", \\"apt\\", \\"bat\\"] for word in words: trie.insert(word) for word in words: assert trie.search(word) == True assert trie.search(\\"cat\\") == False def test_edge_cases_empty_string(): trie = Trie() assert trie.search(\\"\\") == False assert trie.startsWith(\\"\\") == True trie.insert(\\"\\") assert trie.search(\\"\\") == True","solution":"class TrieNode: def __init__(self): Initializes a TrieNode with child nodes set to an empty dictionary and a boolean flag indicating if it's the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initializes the Trie with the root node. self.root = TrieNode() def insert(self, word): Inserts a word into the Trie. word : string : The word to be inserted. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Searches for a word in the Trie. word : string : The word to search for. Returns True if the word exists in the Trie, otherwise False. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix): Checks if there is any word in the Trie that starts with the given prefix. prefix : string : The prefix to search for. Returns True if there is a word in the Trie that starts with the prefix, otherwise False. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.startsWith(\\"app\\") True >>> trie.startsWith(\\"appl\\") True >>> trie.startsWith(\\"apl\\") False node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"def find_unique_element(arr: list[int]) -> int: Finds the unique element in a list where every other element appears exactly twice. >>> find_unique_element([4, 1, 2, 1, 2]) 4 >>> find_unique_element([2, 2, 3, 3, 7, 5, 5]) 7 >>> find_unique_element([7]) 7 >>> find_unique_element([-1, -2, -2, -1, -3]) -3 >>> find_unique_element([100000, 200000, 200000, 100000, 99999]) 99999 >>> find_unique_element([-100000, -100000, 100000]) 100000 >>> find_unique_element([0, -1, -1, 0, 1, 1, 2]) 2 >>> find_unique_element([1, 2, 2, 3, 3]) 1","solution":"def find_unique_element(arr: list[int]) -> int: Finds the unique element in a list where every other element appears exactly twice. Uses the XOR property which cancels out identical numbers. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def simplify_path(path: str) -> str: Simplifies the given Unix-style file path into its canonical form. >>> simplify_path(\\"/home/\\") '/home' >>> simplify_path(\\"/../\\") '/' >>> simplify_path(\\"/home//foo/\\") '/home/foo' >>> simplify_path(\\"/a/./b/../../c/\\") '/c'","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style file path into its canonical form. Parameters: path (str): A string representing a Unix-style file path. Returns: str: The simplified canonical path. # Split the path by '/' and initialize a stack parts = path.split('/') stack = [] # Iterate over each part for part in parts: if part == '' or part == '.': # Skip any empty part or current directory symbols continue elif part == '..': # Move up a directory (if stack is not empty) if stack: stack.pop() else: # Any valid directory name, push on to the stack stack.append(part) # Join the stack to form the canonical path, starting with a '/' return '/' + '/'.join(stack)"},{"question":"from typing import List, Dict, Any class BookStore: def __init__(self): Initialize an empty inventory. self.inventory = {} def add_book(self, title: str, author: str, genre: str, copies: int) -> None: Add a new book to the inventory or update the existing book's copies. Args: title (str): The title of the book. author (str): The author of the book. genre (str): The genre of the book. copies (int): The number of copies available. pass def update_copies(self, title: str, author: str, copies: int) -> None: Update the number of copies of a specific book or add the book if it doesn't exist. Args: title (str): The title of the book. author (str): The author of the book. copies (int): The number of copies to set. pass def get_books_by_genre(self, genre: str) -> List[Dict[str, Any]]: Retrieve all books for a specific genre. Args: genre (str): The genre of the books to retrieve. Returns: List[Dict[str, Any]]: List of books within the specified genre. pass","solution":"from typing import List, Dict, Any class BookStore: def __init__(self): # Initialize an empty inventory self.inventory = {} def add_book(self, title: str, author: str, genre: str, copies: int) -> None: # Implement the logic to add a new book or update the copies if the book already exists book_id = (title, author) if book_id in self.inventory: self.inventory[book_id]['copies'] += copies else: self.inventory[book_id] = { \\"title\\": title, \\"author\\": author, \\"genre\\": genre, \\"copies\\": copies } def update_copies(self, title: str, author: str, copies: int) -> None: # Implement the logic to update the number of copies of an existing book or add the book if it doesn't exist book_id = (title, author) if book_id in self.inventory: self.inventory[book_id]['copies'] = copies else: self.inventory[book_id] = { \\"title\\": title, \\"author\\": author, \\"genre\\": \\"\\", # Genre is unknown if adding through update_copies \\"copies\\": copies } def get_books_by_genre(self, genre: str) -> List[Dict[str, Any]]: # Implement the logic to retrieve books by genre return [ {key: value for key, value in book.items() if key != 'genre'} for book in self.inventory.values() if book['genre'] == genre ]"},{"question":"def sum_of_squares(n: int) -> int: Calculates the sum of squares of the first n natural numbers. If n is negative, raises a ValueError with the message: \\"The input must be a non-negative integer\\". Parameters: n (int): The number of natural numbers to sum. Must be a non-negative integer. Returns: int: The sum of squares of the first n natural numbers. Examples: >>> sum_of_squares(5) 55 >>> sum_of_squares(0) 0 >>> sum_of_squares(1) 1 >>> sum_of_squares(10) 385 >>> sum_of_squares(-3) ValueError: The input must be a non-negative integer >>> sum_of_squares(12) 650","solution":"def sum_of_squares(n: int) -> int: Calculates the sum of squares of the first n natural numbers. Parameters: n (int): The number of natural numbers to sum. Must be a non-negative integer. Returns: int: The sum of squares of the first n natural numbers. if n < 0: raise ValueError(\\"The input must be a non-negative integer\\") return sum(i**2 for i in range(1, n + 1))"},{"question":"from typing import List, Any def normalize_list(items: List[Any]) -> List[str]: Converts all items in the given list to their string representation. Parameters: items (List[Any]): A list containing items of various data types. Returns: List[str]: A list where each item has been converted to its string representation. Examples: >>> normalize_list([1, 'two', 3.0, True, None]) ['1', 'two', '3.0', 'True', 'None'] >>> normalize_list([]) [] >>> normalize_list([123, 456.789, 'example']) ['123', '456.789', 'example']","solution":"def normalize_list(items): Converts all items in the given list to their string representation. Parameters: items (list): A list containing items of various data types. Returns: list: A list where each item has been converted to its string representation. return [str(item) for item in items]"},{"question":"from typing import List, Dict, Union def aggregate_http_logs(logs: List[str]) -> Dict[str, Dict[str, Union[float, int]]]: Aggregates metrics from the HTTP logs. Parameters: logs (List[str]): List of HTTP log entries in \\"METHOD ENDPOINT RESPONSE_TIME\\" format. Returns: Dict[str, Dict[str, Union[float, int]]]: Aggregated metrics for each endpoint. Example: >>> aggregate_http_logs([\\"GET /api/users 100\\", \\"POST /api/users 200\\", \\"GET /api/users 150\\", \\"GET /home 100\\"]) {'/api/users': {'requests': 3, 'avg_response_time': 150.0}, '/home': {'requests': 1, 'avg_response_time': 100.0}} >>> aggregate_http_logs([\\"POST /login 300\\", \\"POST /login 400\\", \\"GET /login 200\\"]) {'/login': {'requests': 3, 'avg_response_time': 300.0}} >>> aggregate_http_logs([\\"GET /data 500\\"]) {'/data': {'requests': 1, 'avg_response_time': 500.0}}","solution":"from typing import List, Dict, Union def aggregate_http_logs(logs: List[str]) -> Dict[str, Dict[str, Union[float, int]]]: Aggregates metrics from the HTTP logs. Parameters: logs (List[str]): List of HTTP log entries in \\"METHOD ENDPOINT RESPONSE_TIME\\" format. Returns: Dict[str, Dict[str, Union[float, int]]]: Aggregated metrics for each endpoint. metrics = {} for log in logs: parts = log.split() method, endpoint, response_time = parts[0].upper(), parts[1], int(parts[2]) if endpoint not in metrics: metrics[endpoint] = {'requests': 0, 'total_response_time': 0} metrics[endpoint]['requests'] += 1 metrics[endpoint]['total_response_time'] += response_time for endpoint in metrics: total_requests = metrics[endpoint]['requests'] total_response_time = metrics[endpoint]['total_response_time'] avg_response_time = total_response_time / total_requests metrics[endpoint]['avg_response_time'] = avg_response_time del metrics[endpoint]['total_response_time'] return metrics"},{"question":"def recursive_factorial(n: int) -> int: Computes the factorial of a given positive integer using a recursive approach. Parameters: n (int): A non-negative integer to compute the factorial of. Returns: int: Factorial of the given number. Raises: ValueError: If n is a negative integer. pass def test_recursive_factorial_base_case(): assert recursive_factorial(0) == 1 assert recursive_factorial(1) == 1 def test_recursive_factorial_positive_numbers(): assert recursive_factorial(5) == 120 assert recursive_factorial(7) == 5040 assert recursive_factorial(10) == 3628800 def test_recursive_factorial_large_number(): assert recursive_factorial(15) == 1307674368000 def test_recursive_factorial_exceptions(): try: recursive_factorial(-1) except ValueError as e: assert str(e) == \\"Input must be a non-negative integer.\\" else: assert False, \\"Expected ValueError for negative input\\" def test_recursive_factorial_edge_cases(): assert recursive_factorial(2) == 2 assert recursive_factorial(3) == 6 assert recursive_factorial(4) == 24","solution":"def recursive_factorial(n: int) -> int: Computes the factorial of a given positive integer using a recursive approach. Parameters: n (int): A non-negative integer to compute the factorial of. Returns: int: Factorial of the given number. Raises: ValueError: If n is a negative integer. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 1 return n * recursive_factorial(n - 1)"},{"question":"# Task Implement a function called \`min_swaps_to_sort\` that calculates the minimum number of swaps needed to sort the given array in ascending order. def min_swaps_to_sort(arr: List[int]) -> int: This function calculates the minimum number of swaps needed to sort an array in ascending order. Args: - arr (List[int]): A list of integers that needs to be sorted. Returns: - int: The minimum number of swaps required to sort the array in ascending order. Example: >>> min_swaps_to_sort([4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> min_swaps_to_sort([1, 3, 5, 2, 4, 6, 7]) 3 n = len(arr) # Create an array of tuples where each tuple is (value, index) arrpos = [(value, i) for i, value in enumerate(arr)] # Sort the array by the values arrpos.sort(key=lambda it: it[0]) # Initialize visited array visited = [False] * n # Initialize result swaps = 0 for i in range(n): # If the element is already visited or already at the correct position if visited[i] or arrpos[i][1] == i: continue # Initialize a cycle length cycle_size = 0 x = i while not visited[x]: # Mark the current element as visited visited[x] = True # Move to the next index x = arrpos[x][1] cycle_size += 1 # Add the number of swaps needed for this cycle if cycle_size > 1: swaps += (cycle_size - 1) return swaps","solution":"from typing import List def min_swaps_to_sort(arr: List[int]) -> int: n = len(arr) # Create an array of tuples where each tuple is (value, index) arrpos = [(value, i) for i, value in enumerate(arr)] # Sort the array by the values arrpos.sort(key=lambda it: it[0]) # Initialize visited array visited = [False] * n # Initialize result swaps = 0 for i in range(n): # If the element is already visited or already at the correct position if visited[i] or arrpos[i][1] == i: continue # Initialize a cycle length cycle_size = 0 x = i while not visited[x]: # Mark the current element as visited visited[x] = True # Move to the next index x = arrpos[x][1] cycle_size += 1 # Add the number of swaps needed for this cycle if cycle_size > 1: swaps += (cycle_size - 1) return swaps"},{"question":"class BalancedBST: def __init__(self) -> None: Initialize the root of the Balanced Binary Search Tree (BST). pass def insert(self, value: int) -> None: Insert a new integer value into the BST and balance the tree. Args: value (int): The integer value to be inserted into the BST. pass def search(self, value: int) -> bool: Search for an integer value in the BST. Args: value (int): The integer value to search in the BST. Returns: bool: True if the value is found, False otherwise. pass # Example usage: bst = BalancedBST() # Insert values bst.insert(10) bst.insert(20) bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(30) # Search values print(bst.search(20)) # Expected output: True print(bst.search(15)) # Expected output: False","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class BalancedBST: def __init__(self) -> None: self.root = None def insert(self, value: int) -> None: if not self.root: self.root = Node(value) else: self.root = self._insert(self.root, value) def search(self, value: int) -> bool: return self._search(self.root, value) is not None def _insert(self, root, key): if not root: return Node(key) if key < root.key: root.left = self._insert(root.left, key) elif key > root.key: root.right = self._insert(root.right, key) else: # Duplicate keys are not allowed return root root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) # Get balance factor balance = self._get_balance(root) # Left Left if balance > 1 and key < root.left.key: return self._right_rotate(root) # Right Right if balance < -1 and key > root.right.key: return self._left_rotate(root) # Left Right if balance > 1 and key > root.left.key: root.left = self._left_rotate(root.left) return self._right_rotate(root) # Right Left if balance < -1 and key < root.right.key: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def _search(self, root, key): if root is None or root.key == key: return root if key < root.key: return self._search(root.left, key) return self._search(root.right, key) def _left_rotate(self, z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) # Return the new root return y def _right_rotate(self, z): y = z.left T3 = y.right # Perform rotation y.right = z z.left = T3 # Update heights z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) # Return the new root return y def _get_height(self, root): if not root: return 0 return root.height def _get_balance(self, root): if not root: return 0 return self._get_height(root.left) - self._get_height(root.right)"},{"question":"import random def estimate_probability_of_seven(num_rolls: int) -> float: Estimates the probability of rolling a sum of 7 with two six-sided dice. Args: num_rolls (int): The number of times to roll the dice. Returns: float: The estimated probability of getting a sum of 7. Example: >>> estimate_probability_of_seven(10000) # Expected output: A float value representing probability","solution":"import random def estimate_probability_of_seven(num_rolls: int) -> float: Estimates the probability of rolling a sum of 7 with two six-sided dice. Args: num_rolls (int): The number of times to roll the dice. Returns: float: The estimated probability of getting a sum of 7. count_of_sevens = 0 for _ in range(num_rolls): roll1 = random.randint(1, 6) roll2 = random.randint(1, 6) if roll1 + roll2 == 7: count_of_sevens += 1 return count_of_sevens / num_rolls"},{"question":"def recursive_sum(n: int) -> int: Calculate the sum of all positive integers up to and including n using recursion. Input Parameter: n (int): The upper limit integer up to which the sum is to be calculated. Returns: int: The sum of all integers from 1 to n. Raises: ValueError: If n is not a natural number (i.e., not a positive integer). ... # Example Tests: # >>> recursive_sum(1) # 1 # # >>> recursive_sum(3) # 6 # 1 + 2 + 3 # # >>> recursive_sum(5) # 15 # 1 + 2 + 3 + 4 + 5 # # >>> recursive_sum(10) # 55 # 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 # # >>> recursive_sum(0) # Traceback (most recent call last): # ... # ValueError: Input must be a natural number (positive integer) # # >>> recursive_sum(-5) # Traceback (most recent call last): # ... # ValueError: Input must be a natural number (positive integer) # # >>> recursive_sum(3.5) # Traceback (most recent call last): # ... # ValueError: Input must be a natural number (positive integer)","solution":"def recursive_sum(n: int) -> int: Calculate the sum of all positive integers up to and including n using recursion. Input Parameter: n (int): The upper limit integer up to which the sum is to be calculated. Returns: int: The sum of all integers from 1 to n. Raises: ValueError: If n is not a natural number (i.e., not a positive integer). if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a natural number (positive integer)\\") if n == 1: return 1 return n + recursive_sum(n - 1)"},{"question":"from typing import List, Tuple, Dict import heapq def dijkstra( graph: Dict[int, List[Tuple[int, int]]], start: int, ) -> Dict[int, int]: Implement Dijkstra's algorithm to find the shortest path in a weighted graph using a priority queue for efficient distance updates. Parameters: graph (dict[int, list[tuple[int, int]]]): A dictionary representing the adjacency list of the graph. The key is a node, and the value is a list of tuples (neighbour, weight), representing the connected node and the edge weight. start (int): The starting node for the algorithm. Returns: dict[int, int] -- A dictionary where the key is a node and the value is the shortest distance from the start node to that node. >>> graph = { ... 0: [(1, 4), (2, 1)], ... 1: [(3, 1)], ... 2: [(1, 2), (3, 5)], ... 3: [] ... } >>> start = 0 >>> dijkstra(graph, start) {0: 0, 1: 3, 2: 1, 3: 4} pass","solution":"import heapq def dijkstra(graph, start): Implements Dijkstra's algorithm to find shortest paths from start to all other nodes. Parameters: graph: dict[int, list[tuple[int, int]]] -- The adjacency list representing the graph. start: int -- The starting node for the algorithm. Returns: dict[int, int] -- A dictionary with the shortest distance to each node. distances = {node: float('inf') for node in graph} distances[start] = 0 priority_queue = [(0, start)] heapq.heapify(priority_queue) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"import numpy as np def rotate_image_90_clockwise(image: np.ndarray) -> np.ndarray: Rotates the given 2D numpy array image by 90 degrees clockwise. Parameters: image (np.ndarray): A 2D numpy array representing the image to rotate. Returns: np.ndarray: A 2D numpy array representing the rotated image. >>> image = np.array([[1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) >>> rotate_image_90_clockwise(image) array([[7, 4, 1], [8, 5, 2], [9, 6, 3]]) >>> image = np.array([[1, 2, 3, 4], ... [5, 6, 7, 8]]) >>> rotate_image_90_clockwise(image) array([[5, 1], [6, 2], [7, 3], [8, 4]])","solution":"import numpy as np def rotate_image_90_clockwise(image): Rotates the given 2D numpy array image by 90 degrees clockwise. Parameters: image (np.ndarray): A 2D numpy array representing the image to rotate. Returns: np.ndarray: A 2D numpy array representing the rotated image. m, n = image.shape rotated_image = np.zeros((n, m), dtype=image.dtype) for i in range(m): for j in range(n): rotated_image[j, m - 1 - i] = image[i, j] return rotated_image"},{"question":"from sklearn.linear_model import LinearRegression def linear_regression_predict(train_data: list[list[float]], train_target: list[float], test_data: list[list[float]]) -> list[float]: Predicts temperature using linear regression based on training data. Parameters: train_data: A list of lists containing the training features. train_target: A list of training target values. test_data: A list of lists containing the test features. Returns: A list of predicted temperatures for the test data. Example: >>> train_data = [ ... [120, 65, 5.7], ... [200, 70, 4.5], ... [300, 75, 6.1], ... [150, 68, 5.0], ... [250, 72, 5.5] ... ] >>> train_target = [22.5, 25.0, 30.0, 23.0, 27.5] >>> test_data = [ ... [170, 67, 5.2], ... [220, 73, 4.8] ... ] >>> linear_regression_predict(train_data, train_target, test_data) [23.7, 26.2] # Example output, actual implementation needed.","solution":"from sklearn.linear_model import LinearRegression def linear_regression_predict(train_data: list[list[float]], train_target: list[float], test_data: list[list[float]]) -> list[float]: Predicts temperature using linear regression based on training data. Parameters: train_data: A list of lists containing the training features. train_target: A list of training target values. test_data: A list of lists containing the test features. Returns: A list of predicted temperatures for the test data. # Create the linear regression model model = LinearRegression() # Fit the model on the training data model.fit(train_data, train_target) # Predict using the model on the test data predictions = model.predict(test_data) return predictions.tolist()"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_paths(root: Optional[TreeNode], target_sum: int) -> List[List[int]]: Finds all paths in a binary tree that sum to a given value. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> find_paths(root, 22) [[5, 4, 11, 2], [5, 8, 4, 5]] >>> find_paths(None, 22) [] >>> root = TreeNode(2) >>> root.left = TreeNode(3) >>> root.right = TreeNode(5) >>> find_paths(root, 10) [] >>> root = TreeNode(1) >>> root.left = TreeNode(-2) >>> root.right = TreeNode(-3) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> root.right.left = TreeNode(-2) >>> root.left.left.left = TreeNode(-1) >>> find_paths(root, -1) [[1, -2, 1, -1]] >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> find_paths(root, 26) [[5, 8, 13]]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_paths(root: Optional[TreeNode], target_sum: int) -> List[List[int]]: def helper(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target_sum: paths.append(list(current_path)) else: helper(node.left, current_path, current_sum) helper(node.right, current_path, current_sum) current_path.pop() paths = [] helper(root, [], 0) return paths"},{"question":"from typing import List def sum_of_unique_elements(lst: List[int]) -> int: Calculate the sum of all unique elements in a list. >>> sum_of_unique_elements([1, 2, 3, 2, 4]) 8 >>> sum_of_unique_elements([0, 0, 0]) 0 >>> sum_of_unique_elements([-1, 1, 2, -1, 3, 4]) 10 >>> sum_of_unique_elements([5]) 5 >>> sum_of_unique_elements([10, 10, 10]) 0 pass def test_sum_of_unique_elements(): assert sum_of_unique_elements([1, 2, 3, 2, 4]) == 8 assert sum_of_unique_elements([0, 0, 0]) == 0 assert sum_of_unique_elements([-1, 1, 2, -1, 3, 4]) == 10 assert sum_of_unique_elements([5]) == 5 assert sum_of_unique_elements([10, 10, 10]) == 0 assert sum_of_unique_elements([]) == 0 assert sum_of_unique_elements([1,1,2,2,3,3,4,4,5,5]) == 0 assert sum_of_unique_elements([10,20,30,40,50]) == 150 import pytest pytest.main(args=['-v'])","solution":"from collections import Counter def sum_of_unique_elements(lst): Returns the sum of unique elements in the list, where unique means the element appears exactly once. # Create a Counter dictionary to count the occurrences of each element count = Counter(lst) # Extract elements that appear exactly once and sum them up unique_sum = sum(k for k, v in count.items() if v == 1) return unique_sum"},{"question":"from typing import List def normalize_time_series(data: List[float], lower_bound: float, upper_bound: float) -> List[float]: Normalize the data points so that they fall within the specified range. >>> normalize_time_series([10.0, 20.0, 30.0, 40.0, 50.0], 0.0, 1.0) [0.0, 0.25, 0.5, 0.75, 1.0] >>> normalize_time_series([-10.0, 0.0, 10.0], -1.0, 1.0) [-1.0, 0.0, 1.0] >>> normalize_time_series([1e-5, 1e5], 0.0, 1.0) [0.0, 1.0] >>> normalize_time_series([5.0, 5.0, 5.0], 0.0, 1.0) [0.5, 0.5, 0.5] >>> normalize_time_series([1.0, 2.0, 3.0], -1.0, 0.0) [-1.0, -0.5, 0.0] >>> normalize_time_series([4.5], 2.0, 3.0) [2.5] pass","solution":"from typing import List def normalize_time_series(data: List[float], lower_bound: float, upper_bound: float) -> List[float]: min_val = min(data) max_val = max(data) range_val = max_val - min_val norm_range = upper_bound - lower_bound if range_val == 0: # If all values in data are the same, return a list with the mid-point return [lower_bound + norm_range / 2] * len(data) normalized_data = [ lower_bound + ((x - min_val) / range_val) * norm_range for x in data ] return normalized_data"},{"question":"from typing import Any import threading from collections import OrderedDict import time class LRUCache: def __init__(self, capacity: int, expiration: int): Initialize the cache with a specified capacity (maximum number of items) and expiration time (in seconds). pass def get(self, key: str) -> Any: Retrieve the value associated with the key if present in the cache and not expired. Update the key's usage timestamp. Return None if the key is not found or expired. >>> cache = LRUCache(2, 3) >>> cache.set(\\"a\\", 1) >>> cache.get(\\"a\\") 1 >>> cache.get(\\"b\\") None pass def set(self, key: str, value: Any): Insert or update the key-value pair in the cache. If the cache is at capacity, evict the least recently used item before adding the new key-value pair. >>> cache = LRUCache(2, 3) >>> cache.set(\\"a\\", 1) >>> cache.set(\\"b\\", 2) >>> cache.set(\\"c\\", 3) >>> cache.get(\\"a\\") None >>> cache.get(\\"b\\") 2 >>> cache.get(\\"c\\") 3 pass def delete(self, key: str): Remove the key-value pair from the cache if it exists. >>> cache = LRUCache(2, 3) >>> cache.set(\\"a\\", 1) >>> cache.delete(\\"a\\") >>> cache.get(\\"a\\") None pass def _evict_expired(self): Internal method to remove expired entries from the cache. pass # Unit Tests import threading import time def test_cache_initialization(): cache = LRUCache(2, 3) assert cache.capacity == 2 assert cache.expiration == 3 def test_cache_set_get(): cache = LRUCache(2, 3) cache.set(\\"a\\", 1) assert cache.get(\\"a\\") == 1 def test_cache_evict_lru(): cache = LRUCache(2, 3) cache.set(\\"a\\", 1) cache.set(\\"b\\", 2) cache.set(\\"c\\", 3) assert cache.get(\\"a\\") == None assert cache.get(\\"b\\") == 2 assert cache.get(\\"c\\") == 3 def test_cache_expiration(): cache = LRUCache(2, 1) cache.set(\\"a\\", 1) time.sleep(2) assert cache.get(\\"a\\") == None def test_cache_update_existing(): cache = LRUCache(2, 3) cache.set(\\"a\\", 1) cache.set(\\"a\\", 2) assert cache.get(\\"a\\") == 2 def test_cache_delete(): cache = LRUCache(2, 3) cache.set(\\"a\\", 1) cache.delete(\\"a\\") assert cache.get(\\"a\\") == None def test_cache_concurrency(): cache = LRUCache(2, 3) def worker(i): cache.set(f\\"key{i}\\", i) time.sleep(0.1) return cache.get(f\\"key{i}\\") threads = [] for i in range(5): t = threading.Thread(target=worker, args=(i,)) t.start() threads.append(t) for t in threads: t.join() # Check that only the last two inserted keys are present assert cache.get(\\"key3\\") == 3 assert cache.get(\\"key4\\") == 4 assert cache.get(\\"key0\\") == None assert cache.get(\\"key1\\") == None assert cache.get(\\"key2\\") == None","solution":"import threading from collections import OrderedDict import time class LRUCache: def __init__(self, capacity: int, expiration: int): self.capacity = capacity self.expiration = expiration self.cache = OrderedDict() self.lock = threading.Lock() def _is_expired(self, entry): return time.time() - entry[1] > self.expiration def _evict_expired(self): keys_to_delete = [] for key, entry in self.cache.items(): if self._is_expired(entry): keys_to_delete.append(key) for key in keys_to_delete: del self.cache[key] def get(self, key: str): with self.lock: self._evict_expired() if key not in self.cache: return None value, timestamp = self.cache.pop(key) self.cache[key] = (value, time.time()) # update timestamp return value def set(self, key: str, value: any): with self.lock: self._evict_expired() if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # pop the first item (LRU) self.cache[key] = (value, time.time()) def delete(self, key: str): with self.lock: if key in self.cache: del self.cache[key]"},{"question":"from typing import List def merge_alternating_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two lists by alternating elements from each list. >>> merge_alternating_lists([1, 2, 3], [4, 5, 6]) [1, 4, 2, 5, 3, 6] >>> merge_alternating_lists([1], [4, 5, 6]) [1, 4, 5, 6] >>> merge_alternating_lists([1, 2, 3], []) [1, 2, 3] >>> merge_alternating_lists([], [4, 5, 6]) [4, 5, 6] >>> merge_alternating_lists([], []) [] pass def test_merge_alternating_lists(): # Basic tests assert merge_alternating_lists([1, 2, 3], [4, 5, 6]) == [1, 4, 2, 5, 3, 6] assert merge_alternating_lists([1], [4, 5, 6]) == [1, 4, 5, 6] assert merge_alternating_lists([1, 2, 3], []) == [1, 2, 3] assert merge_alternating_lists([], [4, 5, 6]) == [4, 5, 6] assert merge_alternating_lists([], []) == [] # Edge cases assert merge_alternating_lists([1, 3, 5], [2, 4, 6, 8, 10]) == [1, 2, 3, 4, 5, 6, 8, 10] assert merge_alternating_lists([1, 2, 3, 4, 5], [6]) == [1, 6, 2, 3, 4, 5] # Test with non-integer lists should raise a TypeError try: merge_alternating_lists(123, [1, 2, 3]) except TypeError as e: assert str(e) == \\"Both arguments must be lists\\" try: merge_alternating_lists([1, 2, 3], \\"123\\") except TypeError as e: assert str(e) == \\"Both arguments must be lists\\" try: merge_alternating_lists([1, 2, '3'], [4, 5, 6]) except TypeError as e: assert str(e) == \\"All elements in the lists must be integers\\" try: merge_alternating_lists([1, 2, 3], [4, '5', 6]) except TypeError as e: assert str(e) == \\"All elements in the lists must be integers\\"","solution":"from typing import List def merge_alternating_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two lists by alternating elements from each list. if not isinstance(list1, list) or not isinstance(list2, list): raise TypeError(\\"Both arguments must be lists\\") if not all(isinstance(i, int) for i in list1) or not all(isinstance(i, int) for i in list2): raise TypeError(\\"All elements in the lists must be integers\\") merged_list = [] i = 0 while i < len(list1) or i < len(list2): if i < len(list1): merged_list.append(list1[i]) if i < len(list2): merged_list.append(list2[i]) i += 1 return merged_list"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.count = 1 class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: Inserts the value into the binary search tree (BST), maintaining BST properties. Duplicate values are handled by increasing a counter associated with the node. Args: value (int): The integer value to insert into the BST. pass def height(self) -> int: Returns the height of the binary search tree. Returns: int: The height of the BST. pass def is_balanced(self) -> bool: Returns whether the binary search tree is balanced. A binary tree is balanced if the height of the two subtrees of any node never differ by more than one. Returns: bool: True if the BST is balanced, False otherwise. pass def find(self, value: int) -> int: Returns the count of the specified value in the binary search tree (BST). Args: value (int): The integer value to search for in the BST. Returns: int: The count of the specified value in the BST. pass # Unit Tests def test_insert_and_find(): bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(5) bst.insert(2) bst.insert(20) assert bst.find(10) == 1 assert bst.find(5) == 2 assert bst.find(2) == 1 assert bst.find(15) == 1 assert bst.find(20) == 1 assert bst.find(100) == 0 def test_height(): bst = BinarySearchTree() assert bst.height() == -1 # Height of an empty tree bst.insert(10) assert bst.height() == 0 bst.insert(5) bst.insert(15) assert bst.height() == 1 bst.insert(5) bst.insert(2) bst.insert(20) assert bst.height() == 2 def test_is_balanced(): bst = BinarySearchTree() assert bst.is_balanced() == True # An empty tree is balanced bst.insert(10) assert bst.is_balanced() == True # A single node tree is balanced bst.insert(5) bst.insert(15) assert bst.is_balanced() == True bst.insert(5) assert bst.is_balanced() == True bst.insert(2) bst.insert(20) assert bst.is_balanced() == True bst.insert(25) assert bst.is_balanced() == False # Now tree becomes unbalanced","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.count = 1 # Start counter at 1 for the new node class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, current_node, value): if value < current_node.value: if current_node.left: self._insert_recursive(current_node.left, value) else: current_node.left = TreeNode(value) elif value > current_node.value: if current_node.right: self._insert_recursive(current_node.right, value) else: current_node.right = TreeNode(value) else: current_node.count += 1 def height(self) -> int: def _height(node): if not node: return -1 left_height = _height(node.left) right_height = _height(node.right) return max(left_height, right_height) + 1 return _height(self.root) def is_balanced(self) -> bool: def _check_balance(node): if not node: return (True, 0) left_balanced, left_height = _check_balance(node.left) right_balanced, right_height = _check_balance(node.right) balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) height = max(left_height, right_height) + 1 return (balanced, height) balanced, _ = _check_balance(self.root) return balanced def find(self, value: int) -> int: def _find_recursive(node, value): if not node: return 0 if value < node.value: return _find_recursive(node.left, value) elif value > node.value: return _find_recursive(node.right, value) else: return node.count return _find_recursive(self.root, value)"},{"question":"import pandas as pd from typing import List def aggregate_transactions(file_paths: List[str]) -> dict: Process multiple CSV files containing transaction records for an e-commerce platform and aggregate the data to generate summary statistics. This function reads the transactions from multiple CSV files, computes the total revenue, the average transaction amount, and returns these summary statistics. Parameters: file_paths (List[str]): A list of paths to CSV files containing transaction data. Each CSV file has the columns: \\"transaction_id\\", \\"user_id\\", \\"transaction_amount\\", and \\"transaction_date\\". Returns: dict: A dictionary containing \\"total_revenue\\" (float) and \\"average_transaction_amount\\" (float), which are rounded to two decimal places. Example: >>> file_paths = [\\"transactions_jan.csv\\", \\"transactions_feb.csv\\"] >>> aggregate_transactions(file_paths) {'total_revenue': 15000.50, 'average_transaction_amount': 125.43} # Implement your code here","solution":"import pandas as pd from typing import List def aggregate_transactions(file_paths: List[str]) -> dict: total_revenue = 0.0 total_transactions = 0 for file_path in file_paths: try: df = pd.read_csv(file_path) total_revenue += df['transaction_amount'].sum() total_transactions += len(df) except (FileNotFoundError, pd.errors.EmptyDataError): continue average_transaction_amount = (total_revenue / total_transactions) if total_transactions > 0 else 0.0 return { \\"total_revenue\\": round(total_revenue, 2), \\"average_transaction_amount\\": round(average_transaction_amount, 2) }"},{"question":"def elevator_simulation(requests: list[tuple[int, int]]) -> list[int]: Simulates the elevator movements based on the given list of requests. :param requests: List of tuples where each tuple contains two integers: the start floor and the end floor of the request. :return: List of integers representing the floors the elevator stops at in order. >>> elevator_simulation([(0, 5)]) == [0, 5] >>> elevator_simulation([(0, 5), (1, 3), (3, 2)]) == [0, 5, 1, 3, 2] >>> elevator_simulation([(2, 6), (6, 0), (3, 8)]) == [0, 2, 6, 0, 3, 8] >>> elevator_simulation([]) == [0] >>> elevator_simulation([(5, 5)]) == [0, 5] >>> elevator_simulation([(0, 999), (999, 0)]) == [0, 999, 0] >>> elevator_simulation([(1, 4), (4, 2), (2, 8), (8, 3)]) == [0, 1, 4, 2, 8, 3]","solution":"def elevator_simulation(requests): Simulates the elevator movements based on the given list of requests. :param requests: List of tuples where each tuple contains two integers: the start floor and the end floor of the request. :return: List of integers representing the floors the elevator stops at in order. current_floor = 0 stops = [current_floor] for start_floor, end_floor in requests: if start_floor != current_floor: stops.append(start_floor) current_floor = start_floor if end_floor != current_floor: stops.append(end_floor) current_floor = end_floor return stops"},{"question":"def longest_two_char_substring(s: str) -> str: Find the longest substring of a given string that contains exactly two distinct characters. >>> longest_two_char_substring(\\"abcbbbbcccbdddadacb\\") \\"bcbbbbcccb\\" >>> longest_two_char_substring(\\"eceba\\") \\"ece\\" >>> longest_two_char_substring(\\"a\\") \\"\\" >>> longest_two_char_substring(\\"aa\\") \\"aa\\" >>> longest_two_char_substring(\\"abcde\\") \\"ab\\" def test_longest_two_char_substring(): # Example tests assert longest_two_char_substring(\\"abcbbbbcccbdddadacb\\") == \\"bcbbbbcccb\\" assert longest_two_char_substring(\\"eceba\\") == \\"ece\\" assert longest_two_char_substring(\\"a\\") == \\"\\" assert longest_two_char_substring(\\"aa\\") == \\"aa\\" assert longest_two_char_substring(\\"abcde\\") == \\"ab\\" # Additional tests assert longest_two_char_substring(\\"\\") == \\"\\" assert longest_two_char_substring(\\"b\\") == \\"\\" assert longest_two_char_substring(\\"bbaa\\") == \\"bbaa\\" assert longest_two_char_substring(\\"abcdefghik\\") == \\"ab\\" assert longest_two_char_substring(\\"abac\\") == \\"aba\\" assert longest_two_char_substring(\\"aabacbebebe\\") == \\"bebebe\\"","solution":"def longest_two_char_substring(s: str) -> str: if len(s) < 2: return \\"\\" start = 0 max_length = 0 max_substr = \\"\\" char_count = {} for end, char in enumerate(s): char_count[char] = char_count.get(char, 0) + 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substr = s[start:end + 1] return max_substr"},{"question":"def count_unique_elements(elements: list) -> int: Returns the count of unique elements in a list, ignoring case sensitivity for strings. Args: elements (list): A list that may contain elements of various types, including strings, numbers, and other hashable types. Returns: int: The count of unique elements, case-insensitive for strings. Raises: TypeError: If any element in the list is not hashable. Examples: >>> count_unique_elements([\\"Hello\\", \\"world\\", \\"hello\\", \\"WORLD\\"]) 2 >>> count_unique_elements([1, 2, 3, 2, 1, 4]) 4 >>> count_unique_elements([\\"Sunny\\", \\"sunny\\", \\"SUNNY\\"]) 1 >>> count_unique_elements([\\"apple\\", \\"banana\\", \\"cherry\\", \\"Apple\\", \\"CHERRY\\"]) 3 >>> count_unique_elements([\\"a\\", \\"A\\", 1, 2, \\"b\\", \\"B\\"]) 4 pass import pytest def test_unique_strings_case_insensitive(): assert count_unique_elements([\\"Hello\\", \\"world\\", \\"hello\\", \\"WORLD\\"]) == 2 def test_unique_numbers(): assert count_unique_elements([1, 2, 3, 2, 1, 4]) == 4 def test_all_case_variations_of_a_string(): assert count_unique_elements([\\"Sunny\\", \\"sunny\\", \\"SUNNY\\"]) == 1 def test_mixed_case_and_unique_strings(): assert count_unique_elements([\\"apple\\", \\"banana\\", \\"cherry\\", \\"Apple\\", \\"CHERRY\\"]) == 3 def test_mixed_case_strings_and_numbers(): assert count_unique_elements([\\"a\\", \\"A\\", 1, 2, \\"b\\", \\"B\\"]) == 4 def test_empty_list(): assert count_unique_elements([]) == 0 def test_list_with_non_hashable_elements(): with pytest.raises(TypeError, match=\\"unhashable type: 'list'\\"): count_unique_elements([\\"a\\", [1, 2, 3], \\"b\\"]) def test_mixed_types_empty_dict(): with pytest.raises(TypeError, match=\\"unhashable type: 'dict'\\"): count_unique_elements([\\"a\\", {\\"key\\": \\"value\\"}, \\"b\\"]) def test_hashable_non_string_elements(): assert count_unique_elements([(1, 2), (2, 1), \\"tuple\\"]) == 3 def test_bool_vs_int(): assert count_unique_elements([True, False, 1, 0]) == 2","solution":"def count_unique_elements(elements: list) -> int: Returns the count of unique elements in a list, ignoring case sensitivity for strings. unique_elements = set() for element in elements: if isinstance(element, str): element = element.lower() try: unique_elements.add(element) except TypeError: raise TypeError(f\\"unhashable type: '{type(element).__name__}'\\") return len(unique_elements)"},{"question":"def inplace_merge(sorted_list1, sorted_list2): Merge sorted_list2 into sorted_list1 in place. >>> sorted_list1 = [1, 3, 5, 7] >>> sorted_list2 = [2, 4, 6, 8] >>> inplace_merge(sorted_list1, sorted_list2) >>> print(sorted_list1) # [1, 2, 3, 4, 5, 6, 7, 8] >>> sorted_list1 = [10, 20, 30] >>> sorted_list2 = [15, 25, 35] >>> inplace_merge(sorted_list1, sorted_list2) >>> print(sorted_list1) # [10, 15, 20, 25, 30, 35] >>> sorted_list1 = [3, 4, 9] >>> sorted_list2 = [1, 7, 8] >>> inplace_merge(sorted_list1, sorted_list2) >>> print(sorted_list1) # [1, 3, 4, 7, 8, 9] >>> sorted_list1 = [] >>> sorted_list2 = [1, 2, 3] >>> inplace_merge(sorted_list1, sorted_list2) >>> print(sorted_list1) # [1, 2, 3]","solution":"def inplace_merge(sorted_list1, sorted_list2): Merge sorted_list2 into sorted_list1 in place. i, j, k = len(sorted_list1) - 1, len(sorted_list2) - 1, len(sorted_list1) + len(sorted_list2) - 1 sorted_list1.extend([0] * len(sorted_list2)) while j >= 0: if i >= 0 and sorted_list1[i] > sorted_list2[j]: sorted_list1[k] = sorted_list1[i] i -= 1 else: sorted_list1[k] = sorted_list2[j] j -= 1 k -= 1"},{"question":"import hashlib def md5_checksum(file_path: str) -> str: Compute the MD5 checksum for the given file. :param file_path: str - Path to the input file. :return: str - Corresponding MD5 checksum in hexadecimal format.","solution":"import hashlib def md5_checksum(file_path: str) -> str: Compute the MD5 checksum for the given file. :param file_path: str - Path to the input file. :return: str - Corresponding MD5 checksum in hexadecimal format. hash_md5 = hashlib.md5() with open(file_path, \\"rb\\") as f: for chunk in iter(lambda: f.read(4096), b\\"\\"): hash_md5.update(chunk) return hash_md5.hexdigest()"},{"question":"import re from typing import List, Dict, Any The function \`extract_phone_numbers\` processes a list of contact dictionaries and returns a list of formatted phone numbers in the standard E.164 format. def extract_phone_numbers(contacts: List[Dict[str, Any]]) -> List[str]: def format_phone_number(phone: str) -> str: # Remove spaces, dashes, and parentheses cleaned_phone = re.sub(r\\"[()s-]\\", \\"\\", phone) # Check if phone number is prefixed with \\"+\\" if not cleaned_phone.startswith(\\"+\\"): cleaned_phone = f\\"+1{cleaned_phone}\\" # Assuming default country code as +1 if not present # Validate the phone number format if re.match(r\\"^+d{10,15}\\", cleaned_phone): return cleaned_phone else: return None formatted_phone_numbers = [] for contact in contacts: phone = contact.get(\\"phone\\", \\"\\") formatted_phone = format_phone_number(phone) if formatted_phone: formatted_phone_numbers.append(formatted_phone) return formatted_phone_numbers","solution":"import re from typing import List, Dict, Any def extract_phone_numbers(contacts: List[Dict[str, Any]]) -> List[str]: def format_phone_number(phone: str) -> str: # Remove spaces, dashes, and parentheses cleaned_phone = re.sub(r\\"[()s-]\\", \\"\\", phone) # Check if phone number is prefixed with \\"+\\" if not cleaned_phone.startswith(\\"+\\"): cleaned_phone = f\\"+1{cleaned_phone}\\" # Assuming default country code as +1 if not present # Validate the phone number format if re.match(r\\"^+d{10,15}\\", cleaned_phone): return cleaned_phone else: return None formatted_phone_numbers = [] for contact in contacts: phone = contact.get(\\"phone\\", \\"\\") formatted_phone = format_phone_number(phone) if formatted_phone: formatted_phone_numbers.append(formatted_phone) return formatted_phone_numbers"},{"question":"def rearrange_string(s: str) -> str: Rearranges the input string such that all letters appear before any digits while maintaining their original order. >>> rearrange_string(\\"a1b2c3\\") abc123 >>> rearrange_string(\\"x9y8\\") xy98 >>> rearrange_string(\\"1a2b3\\") ab123 def combine_rearranged_strings(strings_list: List[str]) -> str: Concatenates each rearranged string (where all letters appear before digits) from the input strings list. >>> combine_rearranged_strings([\\"a1b2c3\\", \\"x9y8\\", \\"1a2b3\\"]) abc123xy98ab123 >>> combine_rearranged_strings([\\"a1\\"]) a1 >>> combine_rearranged_strings([\\"a1\\", \\"b2\\", \\"c3\\"]) a1b2c3 >>> combine_rearranged_strings([\\"123a\\", \\"456b\\", \\"789c\\"]) a123b456c789 >>> combine_rearranged_strings([\\"\\"]) '' >>> combine_rearranged_strings([]) ''","solution":"def rearrange_string(s): Rearranges the input string such that all letters appear before any digits while maintaining their original order. :param s: Input string containing a mix of alphanumeric characters :return: Rearranged string with letters first followed by digits letters = ''.join([char for char in s if char.isalpha()]) digits = ''.join([char for char in s if char.isdigit()]) return letters + digits def combine_rearranged_strings(strings_list): Concatenates each rearranged string (where all letters appear before digits) from the input strings list. :param strings_list: List of strings containing a mix of alphanumeric characters :return: A single string resulting from concatenating each rearranged string rearranged_strings = [rearrange_string(s) for s in strings_list] return ''.join(rearranged_strings)"},{"question":"def trap_rain_water(heights: list) -> int: Calculate the total amount of rainwater trapped between the bars. Parameters: heights (list of int): A list of non-negative integers representing the heights of bars. Returns: int: The total amount of trapped rainwater. >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rain_water([4,2,0,3,2,5]) 9 >>> trap_rain_water([0]) 0 >>> trap_rain_water([2,0,2]) 2 >>> trap_rain_water([]) 0 >>> trap_rain_water([3, 3, 3, 3]) 0 >>> trap_rain_water([9, 7, 5, 3, 1]) 0 >>> trap_rain_water([1, 3, 5, 7, 9]) 0 pass","solution":"def trap_rain_water(heights: list) -> int: Calculate the total amount of rainwater trapped between the bars. Parameters: heights (list of int): A list of non-negative integers representing the heights of bars. Returns: int: The total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"class SinglyLinkedList: def __init__(self): self.head = None def insert_tail(self, data): Inserts a new node with the given data at the end of the list. pass def detect_and_remove_loop(self): Detect and remove loop in the list if any, using Floyd’s Cycle-Finding Algorithm. Returns True if a loop was detected and removed, otherwise returns False. pass def traverse(self): Returns a list containing all elements in the linked list. pass def test_detect_and_remove_loop_no_loop(): sll = SinglyLinkedList() sll.insert_tail(1) sll.insert_tail(2) sll.insert_tail(3) assert sll.detect_and_remove_loop() == False assert sll.traverse() == [1, 2, 3] def test_detect_and_remove_loop_with_loop(): sll = SinglyLinkedList() sll.insert_tail(1) sll.insert_tail(2) sll.insert_tail(3) sll.insert_tail(4) sll.insert_tail(5) # Creating a cycle: 5 -> 2 sll.head.next.next.next.next.next = sll.head.next assert sll.detect_and_remove_loop() == True assert sll.detect_and_remove_loop() == False assert sll.traverse() == [1, 2, 3, 4, 5] def test_detect_and_remove_loop_single_node_with_loop(): sll = SinglyLinkedList() sll.insert_tail(1) # Creating a cycle: 1 -> 1 sll.head.next = sll.head assert sll.detect_and_remove_loop() == True assert sll.detect_and_remove_loop() == False assert sll.traverse() == [1] def test_detect_and_remove_loop_two_nodes_with_loop(): sll = SinglyLinkedList() sll.insert_tail(1) sll.insert_tail(2) # Creating a cycle: 2 -> 1 sll.head.next.next = sll.head assert sll.detect_and_remove_loop() == True assert sll.detect_and_remove_loop() == False assert sll.traverse() == [1, 2] def test_detect_and_remove_loop_empty_list(): sll = SinglyLinkedList() assert sll.detect_and_remove_loop() == False assert sll.traverse() == []","solution":"class Node: def __init__(self, data): self.data = data self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert_tail(self, data): new_node = Node(data) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def detect_and_remove_loop(self): slow = self.head fast = self.head # Detect Loop using Floyd’s Cycle-Finding Algorithm while slow and fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: self._remove_loop(slow) return True return False def _remove_loop(self, loop_node): ptr1 = self.head while True: ptr2 = loop_node while ptr2.next != loop_node and ptr2.next != ptr1: ptr2 = ptr2.next if ptr2.next == ptr1: break ptr1 = ptr1.next # Breaking the loop ptr2.next = None def traverse(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result"},{"question":"def minimize_makespan(tasks: List[int], servers: int) -> int: Allocate tasks to servers to minimize the maximum execution time for the most loaded server. >>> minimize_makespan([10, 7, 8, 12, 6, 8], 3) 18 >>> minimize_makespan([10, 20, 30], 2) 30 pass # Test cases def test_example_1(): tasks = [10, 7, 8, 12, 6, 8] servers = 3 assert minimize_makespan(tasks, servers) == 18 def test_example_2(): tasks = [10, 20, 30] servers = 2 assert minimize_makespan(tasks, servers) == 30 def test_all_tasks_same_time(): tasks = [5, 5, 5, 5] servers = 2 assert minimize_makespan(tasks, servers) == 10 def test_more_servers_than_tasks(): tasks = [10, 20, 30] servers = 5 assert minimize_makespan(tasks, servers) == 30 def test_single_task_single_server(): tasks = [50] servers = 1 assert minimize_makespan(tasks, servers) == 50 def test_single_task_multiple_servers(): tasks = [50] servers = 3 assert minimize_makespan(tasks, servers) == 50 def test_high_execution_times(): tasks = [10**6, 10**6, 10**6] servers = 2 assert minimize_makespan(tasks, servers) == 2 * 10**6 def test_many_tasks(): tasks = [i for i in range(1, 101)] servers = 10 assert minimize_makespan(tasks, servers) == 505 # Sum of 10 to 19","solution":"def minimize_makespan(tasks, servers): def can_distribute_with_max_load(max_load): # Array to keep track of load on each server server_loads = [0] * servers for task in sorted(tasks, reverse=True): # Find the server with the least load that can take the current task if server_loads[0] + task > max_load: return False # Add the task to this server server_loads[0] += task # Re-sort the server loads to maintain the min-heap property server_loads.sort() return True # Binary search for the minimum possible max_load low, high = max(tasks), sum(tasks) while low < high: mid = (low + high) // 2 if can_distribute_with_max_load(mid): high = mid else: low = mid + 1 return low"},{"question":"def unique_paths(m: int, n: int) -> int: Computes the number of unique paths for a robot to reach the bottom-right corner of an m x n grid starting from the top-left corner, moving only down or right. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 # Your code here","solution":"def unique_paths(m, n): if m == 0 or n == 0: return 0 # Create a 2D list to store the number of paths to reach each cell dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] # Example usage: # print(unique_paths(3, 2)) # Output: 3 # print(unique_paths(7, 3)) # Output: 28"},{"question":"def is_unique_chars(input_str: str) -> bool: Check if the string has all unique characters. :param input_str: string to be checked :return: boolean indicating if all characters are unique >>> is_unique_chars(\\"abcdef\\") True >>> is_unique_chars(\\"aabcdef\\") False >>> is_unique_chars(\\"\\") True pass def are_permutations(str1: str, str2: str) -> bool: Check if one string is a permutation of the other. :param str1: first string for comparison :param str2: second string for comparison :return: boolean indicating if the strings are permutations of each other >>> are_permutations(\\"abc\\", \\"cba\\") True >>> are_permutations(\\"abc\\", \\"cbad\\") False >>> are_permutations(\\"\\", \\"\\") True pass","solution":"def is_unique_chars(input_str: str) -> bool: Check if the string has all unique characters. :param input_str: string to be checked :return: boolean indicating if all characters are unique seen_chars = set() for char in input_str: if char in seen_chars: return False seen_chars.add(char) return True def are_permutations(str1: str, str2: str) -> bool: Check if one string is a permutation of the other. :param str1: first string for comparison :param str2: second string for comparison :return: boolean indicating if the strings are permutations of each other if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"def repeat_strings(strings: list[str], n: int) -> list[str]: Repeats each string in the input list 'n' times. Args: strings (list of str): A list of strings to be repeated. n (int): A non-negative integer indicating how many times to repeat each string. Returns: list of str: A list of strings where each string is repeated 'n' times. Examples: >>> repeat_strings(['a', 'bc', 'def'], 3) ['aaa', 'bcbcbc', 'defdefdef'] >>> repeat_strings(['hello', 'world'], 1) ['hello', 'world'] >>> repeat_strings(['python', 'rocks'], 0) [] >>> repeat_strings([], 5) [] >>> repeat_strings(['test'], 4) ['testtesttesttest']","solution":"def repeat_strings(strings: list[str], n: int) -> list[str]: Repeats each string in the input list 'n' times. Args: strings (list of str): A list of strings to be repeated. n (int): A non-negative integer indicating how many times to repeat each string. Returns: list of str: A list of strings where each string is repeated 'n' times. if not strings or n == 0: return [] return [s * n for s in strings]"},{"question":"def validate_isbn13(isbn: str) -> bool: Validates if the given ISBN-13 code is correct. Parameters: isbn (str): The ISBN-13 code as a string. Returns: bool: True if the ISBN-13 is valid, False otherwise. Raises: ValueError: If the input is not exactly 13 digits. pass # Example usage and results assert validate_isbn13(\\"9780316066525\\") == True # Valid ISBN-13 assert validate_isbn13(\\"9780316066524\\") == False # Invalid ISBN-13 try: validate_isbn13(\\"978031606652\\") # This should raise a ValueError except ValueError as ve: assert str(ve) == \\"ISBN must be exactly 13 digits\\" assert validate_isbn13(\\"9783161484100\\") == True # Another valid ISBN-13 assert validate_isbn13(\\"9783161484101\\") == False # Incorrect checksum","solution":"def validate_isbn13(isbn: str) -> bool: Validates if the given ISBN-13 code is correct. Parameters: isbn (str): The ISBN-13 code as a string. Returns: bool: True if the ISBN-13 is valid, False otherwise. Raises: ValueError: If the input is not exactly 13 digits. if len(isbn) != 13 or not isbn.isdigit(): raise ValueError(\\"ISBN must be exactly 13 digits\\") total = 0 for i in range(12): digit = int(isbn[i]) if i % 2 == 0: total += digit * 1 else: total += digit * 3 checksum = total % 10 if checksum != 0: checksum = 10 - checksum return checksum == int(isbn[12]) # Example usage assert validate_isbn13(\\"9780316066525\\") == True assert validate_isbn13(\\"9780316066524\\") == False try: validate_isbn13(\\"978031606652\\") # This should raise a ValueError except ValueError as ve: assert str(ve) == \\"ISBN must be exactly 13 digits\\""},{"question":"class FenwickTree: Class to represent a Fenwick Tree (Binary Indexed Tree) for efficient stock management. Methods ------- build(a: list[int]) -> None: Builds the Fenwick Tree from a list of initial stock levels. update(idx: int, delta: int) -> None: Updates the stock level at a specific index. query(idx: int) -> int: Returns the cumulative stock level from the start up to a given index. range_query(left: int, right: int) -> int: Returns the cumulative stock level within a specific range. def __init__(self, size: int): Initializes the Fenwick Tree with a given size. Args: size (int): Size of the Fenwick Tree. self.size = size self.tree = [0] * (size + 1) def build(self, a: list[int]) -> None: Builds the Fenwick Tree from a list of initial stock levels. Args: a (list[int]): The list of initial stock levels for the items in the warehouse. def update(self, idx: int, delta: int) -> None: Updates the stock level at a specific index. Args: idx (int): Index of the item in the array (1-based index). delta (int): Value to update the stock level by (can be positive or negative). def query(self, idx: int) -> int: Returns the cumulative stock level from the start up to a given index. Args: idx (int): Index of the item up to which the cumulative stock level is to be calculated (1-based index). Returns: int: The cumulative stock level from the beginning of the array up to index \`idx\`. def range_query(self, left: int, right: int) -> int: Returns the cumulative stock level within a specific range. Args: left (int): Left boundary of the range (1-based index). right (int): Right boundary of the range (1-based index). Returns: int: The cumulative stock level within the range \`[left, right]\`. from solution import FenwickTree def test_build_and_query(): A = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) assert fenwick_tree.query(5) == 10 + 20 + 30 + 40 + 50 def test_update_and_query(): A = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) fenwick_tree.update(3, 10) # A = [10, 20, 40, 40, 50, 60, 70, 80, 90, 100] assert fenwick_tree.query(5) == 10 + 20 + 40 + 40 + 50 def test_range_query(): A = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) assert fenwick_tree.range_query(3, 6) == 30 + 40 + 50 + 60 def test_update_and_range_query(): A = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) fenwick_tree.update(3, 10) # A = [10, 20, 40, 40, 50, 60, 70, 80, 90, 100] assert fenwick_tree.range_query(3, 6) == 40 + 40 + 50 + 60 fenwick_tree.update(6, -20) # A = [10, 20, 40, 40, 50, 40, 70, 80, 90, 100] assert fenwick_tree.range_query(4, 6) == 40 + 50 + 40","solution":"class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def build(self, a: list[int]) -> None: for idx, val in enumerate(a, 1): self.update(idx, val) def update(self, idx: int, delta: int) -> None: while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def query(self, idx: int) -> int: sum = 0 while idx > 0: sum += self.tree[idx] idx -= idx & -idx return sum def range_query(self, left: int, right: int) -> int: return self.query(right) - self.query(left - 1)"},{"question":"def bst_to_sorted_list(root: 'TreeNode') -> list: Convert a Binary Search Tree (BST) to a sorted list using in-order traversal. >>> root1 = TreeNode(4) >>> root1.left = TreeNode(2, TreeNode(1), TreeNode(3)) >>> root1.right = TreeNode(6, TreeNode(5), TreeNode(7)) >>> bst_to_sorted_list(root1) [1, 2, 3, 4, 5, 6, 7] >>> root2 = TreeNode(3, TreeNode(1, right=TreeNode(2)), TreeNode(4)) >>> bst_to_sorted_list(root2) [1, 2, 3, 4] import pytest class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def test_empty_bst(): assert bst_to_sorted_list(None) == [] def test_single_node_bst(): root = TreeNode(1) assert bst_to_sorted_list(root) == [1] def test_complete_bst(): root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(6, TreeNode(5), TreeNode(7)) assert bst_to_sorted_list(root) == [1, 2, 3, 4, 5, 6, 7] def test_left_skewed_bst(): root = TreeNode(4, TreeNode(3, TreeNode(2, TreeNode(1)))) assert bst_to_sorted_list(root) == [1, 2, 3, 4] def test_right_skewed_bst(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) assert bst_to_sorted_list(root) == [1, 2, 3, 4] @pytest.mark.parametrize(\\"input_tree, expected_output\\", [ (TreeNode(5, TreeNode(3), TreeNode(7)), [3, 5, 7]), (TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))), [1, 2, 3, 4]), (TreeNode(1), [1]), (None, []), ]) def test_various_bsts(input_tree, expected_output): assert bst_to_sorted_list(input_tree) == expected_output","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_sorted_list(root: TreeNode) -> list: Convert BST to a sorted list using in-order traversal. :param root: TreeNode - The root node of the binary search tree. :return: list - List of elements in the BST sorted in ascending order. def in_order_traversal(node, elements): if node: in_order_traversal(node.left, elements) elements.append(node.val) in_order_traversal(node.right, elements) sorted_elements = [] in_order_traversal(root, sorted_elements) return sorted_elements"},{"question":"from typing import List, Dict, Any def analyze_temperatures(data: List[Dict[str, Any]]) -> Dict[str, float]: Analyzes a list of temperature data and returns a dictionary with statistical information. :param data: A list of dictionaries, each containing 'date' and 'temperature' keys. :return: A dictionary with keys 'mean', 'median', 'min', 'max' representing respective statistical values of the temperatures. >>> analyze_temperatures([{\\"date\\": \\"2023-03-01\\", \\"temperature\\": 15.0}, {\\"date\\": \\"2023-03-02\\", \\"temperature\\": 18.5}, {\\"date\\": \\"2023-03-03\\", \\"temperature\\": 12.3}, {\\"date\\": \\"2023-03-04\\", \\"temperature\\": 20.1}]) {\\"mean\\": 16.475, \\"median\\": 16.75, \\"min\\": 12.3, \\"max\\": 20.1} >>> analyze_temperatures([{\\"date\\": \\"2023-03-01\\", \\"temperature\\": 15.0}]) {\\"mean\\": 15.0, \\"median\\": 15.0, \\"min\\": 15.0, \\"max\\": 15.0}","solution":"from typing import List, Dict, Any import statistics def analyze_temperatures(data: List[Dict[str, Any]]) -> Dict[str, float]: temperatures = [entry['temperature'] for entry in data] mean_temp = statistics.mean(temperatures) median_temp = statistics.median(temperatures) min_temp = min(temperatures) max_temp = max(temperatures) return { \\"mean\\": mean_temp, \\"median\\": median_temp, \\"min\\": min_temp, \\"max\\": max_temp }"},{"question":"from typing import List class FileSystem: def __init__(self): Initialize the FileSystem. pass def mkdir(self, path: str) -> None: Creates a directory at the specified path. >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.ls(\\"/\\") == [\\"a\\"] pass def add_content_to_file(self, file_path: str, content: str) -> None: Appends content to the file at the specified path, creating the file if it does not exist. >>> fs = FileSystem() >>> fs.add_content_to_file(\\"/a/b/c/file.txt\\", \\"hello\\") >>> fs.read_content_from_file(\\"/a/b/c/file.txt\\") == \\"hello\\" pass def read_content_from_file(self, file_path: str) -> str: Reads the content from the file at the specified path. >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.add_content_to_file(\\"/a/b/c/file.txt\\", \\"text\\") >>> fs.read_content_from_file(\\"/a/b/c/file.txt\\") == \\"text\\" pass def ls(self, path: str) -> List[str]: Lists the contents of the directory at the specified path, sorted in lexicographical order. >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.add_content_to_file(\\"/a/file.txt\\", \\"hello\\") >>> fs.ls(\\"/\\") == [\\"a\\"] >>> fs.ls(\\"/a\\") == [\\"b\\", \\"file.txt\\"] pass","solution":"class FileSystem: def __init__(self): self.fs = {\\"\\": {}} def mkdir(self, path: str) -> None: dirs = path.split('/') cur = self.fs[\\"\\"] for d in filter(bool, dirs): if d not in cur: cur[d] = {} cur = cur[d] def add_content_to_file(self, file_path: str, content: str) -> None: *dirs, file_name = file_path.split('/') cur = self.fs[\\"\\"] for d in filter(bool, dirs): if d not in cur: cur[d] = {} cur = cur[d] if file_name not in cur: cur[file_name] = \\"\\" cur[file_name] += content def read_content_from_file(self, file_path: str) -> str: *dirs, file_name = file_path.split('/') cur = self.fs[\\"\\"] for d in filter(bool, dirs): cur = cur[d] return cur[file_name] def ls(self, path: str) -> list: if path == \\"/\\": return sorted(self.fs[\\"\\"].keys()) parts = path.split('/') cur = self.fs[\\"\\"] for part in filter(bool, parts): cur = cur[part] if isinstance(cur, str): return [parts[-1]] return sorted(cur.keys())"},{"question":"def sort_books(inventory: list[tuple[int, str]]) -> list[tuple[int, str]]: Sorts a list of book inventory records in ascending order based on book titles using the bubble sort algorithm. :param inventory: A list of tuples, each containing an integer representing qty and a string with the book title. :return: The sorted list based on book titles.","solution":"def sort_books(inventory: list[tuple[int, str]]) -> list[tuple[int, str]]: Sorts a list of book inventory records in ascending order based on book titles using the bubble sort algorithm. :param inventory: A list of tuples, each containing an integer representing qty and a string with the book title. :return: The sorted list based on book titles. n = len(inventory) for i in range(n): for j in range(0, n-i-1): if inventory[j][1] > inventory[j+1][1]: inventory[j], inventory[j+1] = inventory[j+1], inventory[j] return inventory"},{"question":"Your task is to convert the function run_length_encode to find the longest common prefix among a list of strings. # Function Signature def longest_common_prefix(strs: List[str]) -> str: # Input * \`strs\` (List[str]): A list of strings. # Output * Returns the longest common prefix string among the input strings. If there is no common prefix, return an empty string. # Constraints * The input list can contain between 0 and 200 strings. * Each string in the list can have a length of up to 200 characters. # Requirements * The function should handle edge cases like an empty list and single-character strings. * Optimize the function to run efficiently with respect to the input list size and string lengths. # Example longest_prefix = longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) print(longest_prefix) # Output: \\"fl\\" longest_prefix = longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) print(longest_prefix) # Output: \\"\\" # Testing * Test with different types of input lists, including empty lists, single-character strings, and mixed cases. * Ensure the function handles edge cases like an empty list and single-character strings. * Validate the function's performance with a maximum of 200 strings and each string having up to 200 characters. Unit Test: from solution import longest_common_prefix def test_longest_common_prefix_empty_list(): assert longest_common_prefix([]) == \\"\\" def test_longest_common_prefix_no_common(): assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_longest_common_prefix_single_string(): assert longest_common_prefix([\\"flower\\"]) == \\"flower\\" def test_longest_common_prefix_common_prefix(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_longest_common_prefix_no_repeat(): assert longest_common_prefix([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"\\" def test_longest_common_prefix_mixed_cases(): assert longest_common_prefix([\\"apple\\", \\"appETite\\", \\"Applaud\\"]) == \\"app\\" def test_longest_common_prefix_edge_cases(): assert longest_common_prefix([\\"a\\", \\"a\\"]) == \\"a\\" assert longest_common_prefix([\\"aa\\", \\"a\\"]) == \\"a\\" Solution: def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" min_length = min(len(s) for s in strs) if min_length == 0: return \\"\\" for i in range(min_length): current_char = strs[0][i] for string in strs: if string[i] != current_char: return strs[0][:i] return strs[0][:min_length]","solution":"def run_length_encode(data: str) -> str: if not isinstance(data, str): raise ValueError(\\"Input must be a string\\") if not data: return \\"\\" encoded = [] current_char = data[0] count = 1 for char in data[1:]: if char == current_char: count += 1 else: if count > 1: encoded.append(f\\"{current_char}{count}\\") else: encoded.append(current_char) current_char = char count = 1 if count > 1: encoded.append(f\\"{current_char}{count}\\") else: encoded.append(current_char) return \\"\\".join(encoded)"},{"question":"def most_frequent_item(transactions: list) -> list: Determine the most frequently purchased item(s) in a list of transactions. If multiple items have the same highest frequency, return all of them in a list sorted in alphabetical order. >>> most_frequent_item(['apple', 'banana', 'apple', 'orange', 'banana', 'banana']) ['banana'] >>> most_frequent_item(['apple', 'banana', 'apple', 'orange', 'banana', 'orange']) ['apple', 'banana', 'orange'] >>> most_frequent_item([]) [] >>> most_frequent_item(['grape', 'grape', 'berry']) ['grape']","solution":"def most_frequent_item(transactions: list) -> list: from collections import Counter if not transactions: return [] frequency_count = Counter(transactions) most_common_count = max(frequency_count.values()) most_frequent_items = [item for item, count in frequency_count.items() if count == most_common_count] return sorted(most_frequent_items)"},{"question":"def find_element_after_rotations(arr: list[int], rotations: int, position: int) -> int: Finds the element at a specified position after a series of right circular rotations. :param arr: The original array. :param rotations: The number of right circular rotations to perform. :param position: The index position (0-based) to find the element after rotations. :return: The element at the specified position after rotations. >>> find_element_after_rotations([1, 2, 3, 4, 5], 2, 1) 5 >>> find_element_after_rotations([1, 2, 3, 4, 5], 7, 0) 4 >>> find_element_after_rotations([1, 2, 3, 4, 5], 0, 3) 4 >>> find_element_after_rotations([1], 100, 0) 1 >>> find_element_after_rotations([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, 4) 2","solution":"def find_element_after_rotations(arr: list[int], rotations: int, position: int) -> int: Finds the element at a specified position after a series of right circular rotations. :param arr: The original array. :param rotations: The number of right circular rotations to perform. :param position: The index position (0-based) to find the element after rotations. :return: The element at the specified position after rotations. n = len(arr) effective_rotations = rotations % n # To handle large numbers of rotations efficiently new_position = (position - effective_rotations) % n return arr[new_position]"},{"question":"from PIL import Image import os def resize_images_in_directory(directory_path: str, target_width: int) -> int: Resizes a batch of images to a specified width while maintaining their aspect ratios. Saves the resized images in a new directory named 'resized_images' within the given directory. Args: directory_path (str): Path to the directory containing images to be resized. target_width (int): The target width to resize images to. Returns: int: Number of images successfully resized and saved. Example: >>> resize_images_in_directory(\\"/path/to/images\\", 800) 5 # Unit Tests import os from PIL import Image import shutil import pytest from solution import resize_images_in_directory def setup_test_directory(): os.makedirs(\\"test_images\\", exist_ok=True) img1 = Image.new(\\"RGB\\", (1000, 500), color=\\"red\\") img1.save(\\"test_images/test1.jpg\\") img2 = Image.new(\\"RGB\\", (500, 1000), color=\\"blue\\") img2.save(\\"test_images/test2.png\\") def cleanup_test_directory(): shutil.rmtree(\\"test_images\\") @pytest.fixture(scope=\\"module\\") def setup_and_teardown(): setup_test_directory() yield cleanup_test_directory() def test_resize_images_in_directory(setup_and_teardown): resized_count = resize_images_in_directory(\\"test_images\\", 800) assert resized_count == 2 resized_image_1 = Image.open(\\"test_images/resized_images/test1.jpg\\") resized_image_2 = Image.open(\\"test_images/resized_images/test2.png\\") assert resized_image_1.size[0] == 800 assert resized_image_1.size[1] == int(800 * (500 / 1000)) assert resized_image_2.size[0] == 800 assert resized_image_2.size[1] == int(800 * (1000 / 500))","solution":"from PIL import Image import os def resize_images_in_directory(directory_path: str, target_width: int) -> int: if not os.path.isdir(directory_path): print(\\"Invalid directory path\\") return 0 resized_images_dir = os.path.join(directory_path, 'resized_images') if not os.path.exists(resized_images_dir): os.makedirs(resized_images_dir) count = 0 for filename in os.listdir(directory_path): file_path = os.path.join(directory_path, filename) if os.path.isfile(file_path): try: with Image.open(file_path) as img: aspect_ratio = img.height / img.width target_height = int(target_width * aspect_ratio) resized_img = img.resize((target_width, target_height), Image.LANCZOS) resized_img.save(os.path.join(resized_images_dir, filename)) count += 1 except Exception as e: print(f\\"Error processing file {filename}: {e}\\") return count"},{"question":"def calculate_rental_cost(car_type: str, days: int) -> float: Computes the total rental cost based on the type of car and the number of rental days. Parameters: car_type (str): The type of car, which may be one of \\"economy\\", \\"compact\\", \\"standard\\", \\"luxury\\". days (int): The number of days the car is rented. Returns: float: The total rental cost. Raises: ValueError: If car_type is unknown or days is negative. >>> calculate_rental_cost(\\"economy\\", 1) 30.0 >>> calculate_rental_cost(\\"compact\\", 5) 200.0 >>> calculate_rental_cost(\\"standard\\", 3) 150.0 >>> calculate_rental_cost(\\"luxury\\", 4) 400.0 >>> calculate_rental_cost(\\"unknown_car_type\\", 2) Traceback (most recent call last): ValueError: Unknown car type >>> calculate_rental_cost(\\"economy\\", -1) Traceback (most recent call last): ValueError: Days cannot be negative >>> calculate_rental_cost(\\"economy\\", 0) 0.0 >>> calculate_rental_cost(\\"luxury\\", 0) 0.0","solution":"def calculate_rental_cost(car_type: str, days: int) -> float: Computes the total rental cost based on the type of car and the number of rental days. Parameters: car_type (str): The type of car, which may be one of \\"economy\\", \\"compact\\", \\"standard\\", \\"luxury\\". days (int): The number of days the car is rented. Returns: float: The total rental cost. Raises: ValueError: If car_type is unknown or days is negative. # Dictionary mapping car types to their daily rates rates = { \\"economy\\": 30, \\"compact\\": 40, \\"standard\\": 50, \\"luxury\\": 100 } # Validate input if car_type not in rates: raise ValueError(\\"Unknown car type\\") if days < 0: raise ValueError(\\"Days cannot be negative\\") # Compute and return the total rental cost total_cost = rates[car_type] * days return total_cost"},{"question":"Implement a class \`MinStack\` that supports the following operations: - \`push(int val)\`: Pushes the integer \`val\` onto the stack. - \`pop()\`: Removes the element on the top of the stack. - \`top()\`: Gets the top element of the stack. - \`get_min()\`: Retrieves the minimum element in the stack. Class Signature class MinStack: def __init__(self): pass def push(self, val: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def get_min(self) -> int: pass Methods 1. __init__(): Initializes the stack object. 2. push(int val): Adds a new element \`val\` to the stack. 3. pop(): Removes the top element from the stack. 4. top(): Returns the top element. 5. get_min(): Returns the minimum element in the stack. Constraints or Considerations * All operations must have O(1) time complexity. * You are allowed to use additional data structures to achieve the desired performance. * The stack can store multiple identical elements. Examples min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Output: -3 min_stack.pop() print(min_stack.top()) # Output: 0 print(min_stack.get_min()) # Output: -2 Additional Notes - Ensure robust handling of edge cases, such as performing operations on an empty stack. - Aim for elegant and readable code with appropriate comments and documentation. - Consider the implications of space complexity and strive for an optimal solution.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string \`s\`. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"abcd\\") == \\"a\\" >>> longest_palindromic_substring(\\"abacdc\\") in [\\"aba\\", \\"cdc\\"] >>> longest_palindromic_substring(\\"racecarworld\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"worldracecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"aracecara\\") == \\"aracecara\\"","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string \`s\`. n = len(s) if n <= 1: return s start, max_length = 0, 1 for i in range(1, n): # Check for even length palindrome low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd length palindrome low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def min_steps_to_destination(forest: list[list[str]], start: tuple[int, int], dest: tuple[int, int]) -> int: Given a forest represented as a grid of 'T' (trees) and 'O' (open ground), find the minimum number of steps needed to reach the destination from the start point. If the destination cannot be reached, return -1 using BFS. Args: - forest (list[list[str]]): The grid-like forest. - start (tuple(int, int)): Starting position in the grid. - dest (tuple(int, int)): Destination position in the grid. Returns: - int: Minimum number of steps to reach the destination, or -1 if unreachable. >>> forest = [ ... [\\"O\\", \\"O\\", \\"T\\", \\"O\\"], ... [\\"T\\", \\"O\\", \\"T\\", \\"O\\"], ... [\\"O\\", \\"O\\", \\"O\\", \\"T\\"], ... [\\"T\\", \\"T\\", \\"O\\", \\"O\\"] ... ] >>> start = (0, 0) >>> dest = (3, 3) >>> min_steps_to_destination(forest, start, dest) 6 >>> forest = [ ... [\\"O\\", \\"T\\"], ... [\\"T\\", \\"O\\"] ... ] >>> start = (0, 0) >>> dest = (1, 1) >>> min_steps_to_destination(forest, start, dest) -1","solution":"from collections import deque def min_steps_to_destination(forest, start, dest): Given a forest represented as a grid of 'T' (trees) and 'O' (open ground), it finds the minimum number of steps needed to reach the destination from the start point using BFS. rows, cols = len(forest), len(forest[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if start == dest: return 0 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and forest[nx][ny] == 'O': if (nx, ny) == dest: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def detect_cycle(graph: dict[str, list[str]]) -> bool: Returns True if there is a cycle in the graph, False otherwise. :param graph: A dictionary representing the adjacency list of the graph. :return: A boolean indicating whether there is a cycle in the graph. >>> detect_cycle({ \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"E\\"], \\"E\\": [] }) True >>> detect_cycle({ \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] }) False","solution":"def detect_cycle(graph: dict[str, list[str]]) -> bool: Returns True if there is a cycle in the graph, False otherwise. :param graph: A dictionary representing the adjacency list of the graph. :return: A boolean indicating whether there is a cycle in the graph. visited = set() rec_stack = set() def dfs(node): if node in rec_stack: # Cycle detected return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"from typing import List, Tuple, Callable import threading import queue def priority_task_scheduler( tasks: List[Tuple[int, Callable]], num_threads: int ) -> None: Manage and execute tasks using multiple threads with priority scheduling. Args: tasks (List[Tuple[int, Callable]]): A list of tasks with priorities. num_threads (int): Number of threads to use for executing tasks. Example: >>> import time >>> def task_a(): >>> print(\\"Executing Task A\\") >>> time.sleep(1) >>> def task_b(): >>> print(\\"Executing Task B\\") >>> time.sleep(1) >>> def task_c(): >>> print(\\"Executing Task C\\") >>> time.sleep(1) >>> tasks = [ >>> (1, task_a), >>> (3, task_c), >>> (2, task_b) >>> ] >>> priority_task_scheduler(tasks, 2) pass def add_task(scheduler_queue, task, priority): Add a new task to the scheduler's queue with a given priority. Args: scheduler_queue: The priority queue managing the tasks. task (Callable): The task function to execute. priority (int): The priority of the task. Example: >>> scheduler_queue = queue.PriorityQueue() >>> def task_x(): >>> print(\\"Executing Task X\\") >>> add_task(scheduler_queue, task_x, 4) pass","solution":"from typing import List, Tuple, Callable import threading import queue def priority_task_scheduler( tasks: List[Tuple[int, Callable]], num_threads: int ) -> None: task_queue = queue.PriorityQueue() for priority, task in tasks: task_queue.put((-priority, task)) def worker(): while not task_queue.empty(): priority, task = task_queue.get() task() task_queue.task_done() threads = [] for _ in range(num_threads): thread = threading.Thread(target=worker) thread.start() threads.append(thread) for thread in threads: thread.join() def add_task(scheduler_queue, task, priority): scheduler_queue.put((-priority, task))"},{"question":"def calculate_average_grades(students_grades: dict) -> None: This function receives a dictionary with student names as keys and lists of their grades as values. It calculates the average grade for each student and prints the result. >>> students_grades = { ... \\"Alice\\": [85, 90, 78], ... \\"Bob\\": [92, 88, 91, 92], ... \\"Charlie\\": [] ... } >>> calculate_average_grades(students_grades) Alice: 84.33 Bob: 90.75 Charlie: No grades available","solution":"def calculate_average_grades(students_grades: dict) -> None: This function receives a dictionary with student names as keys and lists of their grades as values. It calculates the average grade for each student and prints the result. for student, grades in students_grades.items(): if grades: average = sum(grades) / len(grades) print(f\\"{student}: {average:.2f}\\") else: print(f\\"{student}: No grades available\\")"},{"question":"import math def quadratic_roots(a: float, b: float, c: float) -> tuple[float, float]: Calculate the roots of a quadratic equation of the form ax^2 + bx + c = 0. Parameters: a (float): Coefficient of x^2 (cannot be zero). b (float): Coefficient of x. c (float): Constant term. Returns: tuple[float, float]: A tuple containing two float values representing the roots of the quadratic equation in increasing order. Raises: ValueError: If 'a' is zero or if the roots are complex (discriminant is negative). Examples: >>> quadratic_roots(1, -3, 2) (1.0, 2.0) >>> quadratic_roots(1, 2, 1) (-1.0, -1.0) >>> quadratic_roots(2, 5, 3) (-1.5, -1.0) >>> quadratic_roots(0, 2, -4) Traceback (most recent call last): ... ValueError: Coefficient 'a' cannot be zero >>> quadratic_roots(4, 2, 5) Traceback (most recent call last): ... ValueError: Complex roots are not supported","solution":"import math def quadratic_roots(a: float, b: float, c: float) -> tuple[float, float]: if a == 0: raise ValueError(\\"Coefficient 'a' cannot be zero\\") discriminant = b**2 - 4*a*c if discriminant < 0: raise ValueError(\\"Complex roots are not supported\\") root1 = (-b + math.sqrt(discriminant)) / (2*a) root2 = (-b - math.sqrt(discriminant)) / (2*a) return (min(root1, root2), max(root1, root2))"},{"question":"def merge_sort_routes(routes: list[tuple[str, float]]) -> list[tuple[str, float]]: Sort a list of routes based on distance using the merge sort algorithm. :param routes: List of tuples, where each tuple contains a route name and a distance. :return: List of tuples sorted by the distance in ascending order. >>> merge_sort_routes([(\\"Route A\\", 120.5), (\\"Route B\\", 85.2), (\\"Route C\\", 67.9), (\\"Route D\\", 101.0)]) [(\\"Route C\\", 67.9), (\\"Route B\\", 85.2), (\\"Route D\\", 101.0), (\\"Route A\\", 120.5)] >>> merge_sort_routes([(\\"Route X\\", 45.0)]) [(\\"Route X\\", 45.0)] >>> merge_sort_routes([]) [] >>> merge_sort_routes([(\\"Route 1\\", 250.3), (\\"Route 2\\", 250.3), (\\"Route 3\\", 150.0)]) [(\\"Route 3\\", 150.0), (\\"Route 1\\", 250.3), (\\"Route 2\\", 250.3)] # Your code here def merge(left, right): Merge two halves of the list, sorting by distance. :param left: Left half of the list. :param right: Right half of the list. :return: Merged and sorted list. # Your code here","solution":"def merge_sort_routes(routes): Sort a list of routes based on distance using the merge sort algorithm. :param routes: List of tuples, where each tuple contains a route name and a distance. :return: List of tuples sorted by the distance in ascending order. if len(routes) <= 1: return routes mid = len(routes) // 2 left_half = merge_sort_routes(routes[:mid]) right_half = merge_sort_routes(routes[mid:]) return merge(left_half, right_half) def merge(left, right): Merge two halves of the list, sorting by distance. :param left: Left half of the list. :param right: Right half of the list. :return: Merged and sorted list. sorted_list = [] i = 0 j = 0 while i < len(left) and j < len(right): if left[i][1] <= right[j][1]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Function Signature def search_range(sorted_list: list[int], low: int, high: int) -> list[int]: pass # Example Example 1: sorted_list = [1, 2, 3, 4, 5, 6, 7, 8, 9] low = 3 high = 7 search_range(sorted_list, low, high) **Output**: \`[3, 4, 5, 6, 7]\` Example 2: sorted_list = [10, 20, 30, 40, 50] low = 15 high = 35 search_range(sorted_list, low, high) **Output**: \`[20, 30]\` Example 3: sorted_list = [1, 2, 3, 4, 5] low = 6 high = 9 search_range(sorted_list, low, high) **Output**: \`[]\` # Additional Requirements - Your implementation should be efficient with a time complexity of O(log n). # Hints - Think about how you can use binary search to find the lower and upper bounds for the range and then slice the list accordingly.","solution":"def search_range(sorted_list: list[int], low: int, high: int) -> list[int]: def binary_search_left(array, target): left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < target: left = mid + 1 else: right = mid return left def binary_search_right(array, target): left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] <= target: left = mid + 1 else: right = mid return left left_index = binary_search_left(sorted_list, low) right_index = binary_search_right(sorted_list, high) return sorted_list[left_index:right_index]"},{"question":"def word_frequency(text: str) -> dict: Computes the frequency of each word in the given text string. Words are treated case-insensitively and punctuation is ignored. >>> word_frequency(\\"Hello, world! Hello, Programming.\\") {'hello': 2, 'world': 1, 'programming': 1} >>> word_frequency(\\"Python is great. Isn't Python great?\\") {'python': 2, 'is': 1, 'great': 2, 'isnt': 1} >>> word_frequency(\\"\\") {}","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Computes the frequency of each word in the given text string. Words are treated case-insensitively and punctuation is ignored. if not text: return {} # Convert text to lowercase and remove punctuation using regular expression text = text.lower() text = re.sub(r\\"[^ws]\\", \\"\\", text) # Split the text into words words = text.split() # Use defaultdict to count word frequencies frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"import csv def read_user_data(file_path): Reads a CSV file and returns a list of dictionaries representing user data. Parameters: file_path (str): The path to the CSV file. Returns: list: A list of dictionaries containing the user data or an empty list in case of an error. user_data = [] try: with open(file_path, mode='r', encoding='utf-8') as csvfile: reader = csv.DictReader(csvfile) for row in reader: user_data.append(row) except FileNotFoundError: print(f\\"File not found: {file_path}\\") except IOError: print(f\\"Error reading file: {file_path}\\") return user_data if __name__ == \\"__main__\\": import os import tempfile def test_read_user_data_valid_file(): with tempfile.TemporaryDirectory() as tmpdir: file_path = os.path.join(tmpdir, 'user_data.csv') with open(file_path, 'w', encoding='utf-8') as f: f.write(\\"name,emailnJohn Doe,john.doe@example.comnJane Smith,jane.smith@example.comn\\") expected_result = [ {\\"name\\": \\"John Doe\\", \\"email\\": \\"john.doe@example.com\\"}, {\\"name\\": \\"Jane Smith\\", \\"email\\": \\"jane.smith@example.com\\"} ] assert read_user_data(file_path) == expected_result def test_read_user_data_missing_file(): assert read_user_data('non_existent_file.csv') == [] def test_read_user_data_empty_file(): with tempfile.TemporaryDirectory() as tmpdir: file_path = os.path.join(tmpdir, 'empty.csv') open(file_path, 'w', encoding='utf-8').close() assert read_user_data(file_path) == [] def test_read_user_data_incorrect_format(): with tempfile.TemporaryDirectory() as tmpdir: file_path = os.path.join(tmpdir, 'incorrect_data.csv') with open(file_path, 'w', encoding='utf-8') as f: f.write(\\"name-emailnJohn Doe john.doe@example.comnJane Smith jane.smith@example.comn\\") try: read_user_data(file_path) assert True except: assert False def test_read_user_data_io_error(monkeypatch): def mock_open(*args, **kwargs): raise IOError(\\"Mocked IO Error\\") monkeypatch.setattr(\\"builtins.open\\", mock_open) assert read_user_data(\\"any_path.csv\\") == [] test_read_user_data_valid_file() test_read_user_data_missing_file() test_read_user_data_empty_file() test_read_user_data_incorrect_format() test_read_user_data_io_error(lambda x: None)","solution":"import csv def read_user_data(file_path): Reads a CSV file and returns a list of dictionaries representing user data. Parameters: file_path (str): The path to the CSV file. Returns: list: A list of dictionaries containing the user data. user_data = [] try: with open(file_path, mode='r', encoding='utf-8') as csvfile: reader = csv.DictReader(csvfile) for row in reader: user_data.append(row) except FileNotFoundError: print(f\\"File not found: {file_path}\\") except IOError: print(f\\"Error reading file: {file_path}\\") except Exception as e: print(f\\"An error occurred: {str(e)}\\") return user_data"},{"question":"def count_unique_substrings(s: str) -> int: Counts the number of unique substrings in a given string. >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"aaa\\") 3","solution":"def count_unique_substrings(s: str) -> int: Counts the number of unique substrings in a given string. :param s: The input string containing only lowercase English letters. :return: The total number of unique substrings. substrings = set() for i in range(len(s)): for j in range(i, len(s)): substrings.add(s[i:j+1]) return len(substrings)"},{"question":"def is_permutation(s1: str, s2: str) -> bool: Determines if one string is a permutation of the other. :param s1: First string :param s2: Second string :return: True if s1 is a permutation of s2, False otherwise >>> is_permutation(\\"listen\\", \\"silent\\") True >>> is_permutation(\\"hello\\", \\"bello\\") False >>> is_permutation(\\"A gentleman\\", \\"Elegant man\\") False >>> is_permutation(\\"123456\\", \\"654321\\") True >>> is_permutation(\\"\\", \\"\\") True >>> is_permutation(\\"abc\\", \\"def\\") False","solution":"def is_permutation(s1: str, s2: str) -> bool: Determines if one string is a permutation of the other. :param s1: First string :param s2: Second string :return: True if s1 is a permutation of s2, False otherwise if len(s1) != len(s2): return False count = {} for char in s1: if char in count: count[char] += 1 else: count[char] = 1 for char in s2: if char in count: count[char] -= 1 else: return False return all(value == 0 for value in count.values())"},{"question":"from threading import Lock, Condition class BoundedBlockingQueue: def __init__(self, capacity: int): Initialize the bounded blocking queue with a given capacity. Args: capacity (int): The maximum number of elements the queue can hold. self.capacity = capacity self.queue = [] self.lock = Lock() self.not_full = Condition(self.lock) self.not_empty = Condition(self.lock) def enqueue(self, element: int) -> None: Enqueue an element to the queue. If the queue is full, block until space is available. Args: element (int): The element to add to the queue. pass def dequeue(self) -> int: Dequeue an element from the queue. If the queue is empty, block until an element is available. Returns: int: The element removed from the front of the queue. pass def size(self) -> int: Get the current number of elements in the queue. Returns: int: The size of the queue. pass","solution":"from threading import Lock, Condition class BoundedBlockingQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [] self.lock = Lock() self.not_full = Condition(self.lock) self.not_empty = Condition(self.lock) def enqueue(self, element: int) -> None: with self.not_full: while len(self.queue) >= self.capacity: self.not_full.wait() self.queue.append(element) self.not_empty.notify() def dequeue(self) -> int: with self.not_empty: while not self.queue: self.not_empty.wait() element = self.queue.pop(0) self.not_full.notify() return element def size(self) -> int: with self.lock: return len(self.queue)"},{"question":"import heapq class CustomPriorityQueue: Custom priority queue implementation using a min-heap. This class manages tasks with specific priorities, allowing for dynamic insertion and removal of tasks based on their priority. Methods: insert(task: str, priority: int) -> None: Inserts a task with a given priority into the queue. extract_min() -> str: Removes and returns the task with the lowest priority. peek_min() -> str: Returns the task with the lowest priority without removing it. Example: >>> pq = CustomPriorityQueue() >>> pq.insert(\\"task1\\", 3) >>> pq.insert(\\"task2\\", 1) >>> pq.insert(\\"task3\\", 2) >>> pq.peek_min() 'task2' >>> pq.extract_min() 'task2' >>> pq.peek_min() 'task3' def test_insert_and_peek_min(): pq = CustomPriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 1) pq.insert(\\"task3\\", 2) assert pq.peek_min() == \\"task2\\" def test_extract_min(): pq = CustomPriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 1) pq.insert(\\"task3\\", 2) assert pq.extract_min() == \\"task2\\" assert pq.peek_min() == \\"task3\\" def test_peek_min_after_multiple_extractions(): pq = CustomPriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 1) pq.insert(\\"task3\\", 2) pq.extract_min() assert pq.extract_min() == \\"task3\\" assert pq.peek_min() == \\"task1\\" def test_multiple_tasks_same_priority(): pq = CustomPriorityQueue() pq.insert(\\"task1\\", 2) pq.insert(\\"task2\\", 2) pq.insert(\\"task3\\", 2) pq.insert(\\"task4\\", 1) assert pq.extract_min() == \\"task4\\" assert pq.extract_min() in [\\"task1\\", \\"task2\\", \\"task3\\"] def test_extract_all_elements(): pq = CustomPriorityQueue() pq.insert(\\"task1\\", 2) pq.insert(\\"task2\\", 1) pq.insert(\\"task3\\", 3) pq.insert(\\"task4\\", 1) assert pq.extract_min() in [\\"task2\\", \\"task4\\"] assert pq.extract_min() in [\\"task2\\", \\"task4\\"] assert pq.extract_min() == \\"task1\\" assert pq.extract_min() == \\"task3\\"","solution":"import heapq class CustomPriorityQueue: def __init__(self): self.heap = [] def insert(self, task: str, priority: int) -> None: heapq.heappush(self.heap, (priority, task)) def extract_min(self) -> str: return heapq.heappop(self.heap)[1] def peek_min(self) -> str: return self.heap[0][1]"},{"question":"def replace_placeholders(template: str, values: dict) -> str: Replaces placeholders in the format {tag} within the template string with corresponding values from the dictionary. Parameters: - template (str): The template string containing placeholder tags. - values (dict): A dictionary where keys are tags and values are the replacement strings. Returns: - str: The string with all placeholder tags replaced by their corresponding values. Example: >>> replace_placeholders(\\"Hello, {name}!\\", {\\"name\\": \\"Alice\\"}) 'Hello, Alice!' >>> replace_placeholders(\\"Your order {order_id} is confirmed.\\", {\\"order_id\\": \\"12345\\"}) 'Your order 12345 is confirmed.' >>> replace_placeholders(\\"Welcome {user}, your score is {score}.\\", {\\"user\\": \\"Bob\\", \\"score\\": \\"95\\"}) 'Welcome Bob, your score is 95.' >>> replace_placeholders(\\"{greeting}, {name}!\\", {\\"greeting\\": \\"Hi\\"}) 'Hi, {name}!' pass # Sample Test Cases print(replace_placeholders(\\"Hello, {name}!\\", {\\"name\\": \\"Alice\\"})) # Expected output: \\"Hello, Alice!\\" print(replace_placeholders(\\"Your order {order_id} is confirmed.\\", {\\"order_id\\": \\"12345\\"})) # Expected output: \\"Your order 12345 is confirmed.\\" print(replace_placeholders(\\"Welcome {user}, your score is {score}.\\", {\\"user\\": \\"Bob\\", \\"score\\": \\"95\\"})) # Expected output: \\"Welcome Bob, your score is 95.\\" print(replace_placeholders(\\"{greeting}, {name}!\\", {\\"greeting\\": \\"Hi\\"})) # Expected output: \\"Hi, {name}!\\"","solution":"def replace_placeholders(template: str, values: dict) -> str: Replaces placeholders in the format {tag} within the template string with corresponding values from the dictionary. Parameters: - template (str): The template string containing placeholder tags. - values (dict): A dictionary where keys are tags and values are the replacement strings. Returns: - str: The string with all placeholder tags replaced by their corresponding values. for tag, replacement in values.items(): template = template.replace(f'{{{tag}}}', replacement) return template"},{"question":"class RLECompressor: @staticmethod def compress_rle(text: str) -> str: Compress a text string using run-length encoding. Consecutive elements with the same value are replaced with a single element and a count. Args: text (str): A non-empty string to compress. Returns: str: The compressed string. Raises: ValueError: If the input is not a non-empty string. Examples: >>> RLECompressor.compress_rle(\\"AAAABBBCCDAA\\") '4A3B2C1D2A' >>> RLECompressor.compress_rle(\\"A\\") '1A' >>> RLECompressor.compress_rle(\\"ABC\\") '1A1B1C' >>> RLECompressor.compress_rle(\\"aaAA\\") '2a2A' pass @staticmethod def decompress_rle(encoded_text: str) -> str: Decompress a run-length encoded string back to its original form. Args: encoded_text (str): A non-empty string representing the run-length encoded text. Returns: str: The original, decompressed string. Raises: ValueError: If the input is not a non-empty string or the encoding format is invalid. Examples: >>> RLECompressor.decompress_rle(\\"4A3B2C1D2A\\") 'AAAABBBCCDAA' >>> RLECompressor.decompress_rle(\\"1A\\") 'A' >>> RLECompressor.decompress_rle(\\"1A1B1C\\") 'ABC' >>> RLECompressor.decompress_rle(\\"2a2A\\") 'aaAA' pass def test_compress_rle_basic(): assert RLECompressor.compress_rle(\\"AAAABBBCCDAA\\") == \\"4A3B2C1D2A\\" def test_compress_rle_single_char(): assert RLECompressor.compress_rle(\\"A\\") == \\"1A\\" def test_compress_rle_no_repetition(): assert RLECompressor.compress_rle(\\"ABC\\") == \\"1A1B1C\\" def test_compress_rle_mixed_case(): assert RLECompressor.compress_rle(\\"aaAA\\") == \\"2a2A\\" def test_decompress_rle_basic(): assert RLECompressor.decompress_rle(\\"4A3B2C1D2A\\") == \\"AAAABBBCCDAA\\" def test_decompress_rle_single_char(): assert RLECompressor.decompress_rle(\\"1A\\") == \\"A\\" def test_decompress_rle_no_repetition(): assert RLECompressor.decompress_rle(\\"1A1B1C\\") == \\"ABC\\" def test_decompress_rle_mixed_case(): assert RLECompressor.decompress_rle(\\"2a2A\\") == \\"aaAA\\" def test_compress_invalid_input(): try: RLECompressor.compress_rle(123) except ValueError as e: assert str(e) == \\"Invalid input. Non-empty string expected.\\" def test_decompress_invalid_input(): try: RLECompressor.decompress_rle(123) except ValueError as e: assert str(e) == \\"Invalid input. Non-empty string expected.\\" def test_decompress_invalid_format(): try: RLECompressor.decompress_rle(\\"A4\\") except ValueError as e: assert str(e) == \\"Invalid encoding format.\\" try: RLECompressor.decompress_rle(\\"4A2\\") except ValueError as e: assert str(e) == \\"Invalid encoding format.\\"","solution":"class RLECompressor: @staticmethod def compress_rle(text: str) -> str: if not text or not isinstance(text, str): raise ValueError(\\"Invalid input. Non-empty string expected.\\") compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(f\\"{count}{text[i - 1]}\\") count = 1 compressed.append(f\\"{count}{text[-1]}\\") # Add the last group return ''.join(compressed) @staticmethod def decompress_rle(encoded_text: str) -> str: if not encoded_text or not isinstance(encoded_text, str): raise ValueError(\\"Invalid input. Non-empty string expected.\\") decompressed = [] count = '' for char in encoded_text: if char.isdigit(): count += char else: if count == '': raise ValueError(\\"Invalid encoding format.\\") decompressed.append(char * int(count)) count = '' if count != '': raise ValueError(\\"Invalid encoding format.\\") return ''.join(decompressed)"},{"question":"def find_missing_number(nums: list[int]) -> int: Find the missing number in the given list of integers. The list contains \`n\` distinct integers from the range 0 to \`n\`, with exactly one number missing. >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> find_missing_number([0]) 1 # Your code here from solution import find_missing_number def test_missing_number_at_end(): assert find_missing_number([3, 0, 1]) == 2 def test_missing_number_at_start(): assert find_missing_number([0, 1]) == 2 def test_missing_number_in_middle(): assert find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8 def test_single_element(): assert find_missing_number([0]) == 1 assert find_missing_number([1]) == 0 def test_large_input(): n = 10**5 nums = list(range(n)) nums.remove(54321) assert find_missing_number(nums) == 54321","solution":"def find_missing_number(nums: list[int]) -> int: n = len(nums) total_sum = n * (n + 1) // 2 nums_sum = sum(nums) return total_sum - nums_sum"},{"question":"class FIFOCache: A fixed-size FIFO (First-In-First-Out) cache. >>> cache = FIFOCache(2) >>> cache.insert(\\"a\\", \\"apple\\") >>> cache.insert(\\"b\\", \\"banana\\") >>> cache.retrieve(\\"a\\") 'apple' >>> cache.retrieve(\\"b\\") 'banana' >>> cache.insert(\\"c\\", \\"cherry\\") >>> cache.retrieve(\\"a\\") 'Key not found' >>> cache.retrieve(\\"b\\") 'banana' >>> cache.retrieve(\\"c\\") 'cherry' >>> cache.insert(\\"d\\", \\"date\\") >>> cache.retrieve(\\"b\\") 'Key not found' >>> cache.retrieve(\\"c\\") 'cherry' >>> cache.retrieve(\\"d\\") 'date' def __init__(self, capacity: int): Initialize the FIFO Cache with a fixed capacity. pass def insert(self, key: str, value: str) -> None: Add a key-value pair to the cache. If the cache is full, evict the earliest added item. pass def retrieve(self, key: str) -> str: Retrieve the value associated with the key, or return \\"Key not found\\" if the key does not exist. pass","solution":"class FIFOCache: def __init__(self, capacity): Initialize the FIFO Cache with a fixed capacity if capacity <= 0: raise ValueError(\\"Capacity must be greater than zero.\\") self.capacity = capacity self.cache = {} self.order = [] def insert(self, key, value): Add a key-value pair to the cache. If the cache is full, evict the earliest added item. if key in self.cache: # If the key is already in the cache, update the value but maintain position self.cache[key] = value else: if len(self.cache) == self.capacity: # Evict the first item added oldest_key = self.order.pop(0) del self.cache[oldest_key] # Add the new item self.cache[key] = value self.order.append(key) def retrieve(self, key): Retrieve the value associated with the key, or return \\"Key not found\\" if the key does not exist. return self.cache.get(key, \\"Key not found\\")"},{"question":"from typing import List, Tuple class RangedSet: def __init__(self, ranges: List[Tuple[int, int]]): self.ranges = ranges def find_intersection(range_a: RangedSet, range_b: RangedSet) -> List[Tuple[int, int]]: Finds the intersection of two ranged sets. Args: range_a (RangedSet): The first ranged set. range_b (RangedSet): The second ranged set. Returns: List[Tuple[int, int]]: A list of tuples representing the intersecting ranges. >>> range_a = RangedSet([(1, 5), (10, 15)]) >>> range_b = RangedSet([(3, 7), (12, 18)]) >>> find_intersection(range_a, range_b) [(3, 5), (12, 15)] >>> range_a = RangedSet([(1, 3), (8, 10)]) >>> range_b = RangedSet([(4, 7), (11, 14)]) >>> find_intersection(range_a, range_b) [] >>> range_a = RangedSet([(-5, -3), (0, 2)]) >>> range_b = RangedSet([(-10, -6), (1, 3)]) >>> find_intersection(range_a, range_b) [(-5, -6), (1, 2)]","solution":"from typing import List, Tuple class RangedSet: def __init__(self, ranges: List[Tuple[int, int]]): self.ranges = ranges def find_intersection(range_a: RangedSet, range_b: RangedSet) -> List[Tuple[int, int]]: a_ranges = range_a.ranges b_ranges = range_b.ranges i, j = 0, 0 intersections = [] while i < len(a_ranges) and j < len(b_ranges): a_start, a_end = a_ranges[i] b_start, b_end = b_ranges[j] # Find the intersection start = max(a_start, b_start) end = min(a_end, b_end) if start <= end: intersections.append((start, end)) # Move to the next interval if a_end < b_end: i += 1 else: j += 1 return intersections"},{"question":"def maximize_packages(packages: List[Tuple[int, int]], capacity: int, max_distance: int) -> int: Determines the maximum number of packages that can be loaded onto a drone without exceeding its total payload capacity and ensuring that all delivery distances are within the allowed maximum distance. Args: packages (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers - the first integer is the weight of the package, and the second integer is the distance to the delivery location. capacity (int): The maximum payload capacity of the drone. max_distance (int): The maximum operational distance of the drone. Returns: int: The maximum number of packages that can be loaded onto the drone. Examples: >>> maximize_packages([(10, 5), (15, 7), (20, 3)], 30, 10) 2 >>> maximize_packages([(10, 12), (20, 15)], 50, 10) 0 >>> maximize_packages([(5, 2), (25, 8), (10, 6)], 40, 10) 3","solution":"from typing import List, Tuple def maximize_packages(packages: List[Tuple[int, int]], capacity: int, max_distance: int) -> int: # Filter out packages that exceed the maximum distance valid_packages = [pkg for pkg in packages if pkg[1] <= max_distance] # Sort valid packages by weight valid_packages.sort() total_weight = 0 package_count = 0 for weight, distance in valid_packages: if total_weight + weight <= capacity: total_weight += weight package_count += 1 else: break return package_count"},{"question":"from typing import List, Dict def sort_employees(employees: List[Dict[str, str]]) -> List[Dict[str, str]]: Sort a list of employees first by department and then by name. >>> employees = [ ... {\\"department\\": \\"Engineering\\", \\"name\\": \\"Alice\\"}, ... {\\"department\\": \\"HR\\", \\"name\\": \\"Bob\\"}, ... {\\"department\\": \\"Engineering\\", \\"name\\": \\"Charlie\\"}, ... {\\"department\\": \\"HR\\", \\"name\\": \\"alice\\"}, ... ] >>> sort_employees(employees) [{'department': 'Engineering', 'name': 'Alice'}, {'department': 'Engineering', 'name': 'Charlie'}, {'department': 'HR', 'name': 'alice'}, {'department': 'HR', 'name': 'Bob'}]","solution":"from typing import List, Dict def sort_employees(employees: List[Dict[str, str]]) -> List[Dict[str, str]]: Sort a list of employees first by department and then by name. return sorted(employees, key=lambda x: (x['department'].lower(), x['name'].lower()))"},{"question":"import re from collections import Counter LOG_PATTERN = re.compile( r'(?P<date>d{4}-d{2}-d{2}) (?P<time>d{2}:d{2}:d{2}) [(?P<level>INFO|WARNING|ERROR)] (?P<message>.+)' ) def process_log_file(log_file_path): Process a log file to count entries by log level and identify the peak hour. :param log_file_path: Path to the log file :return: Dictionary containing the counts of log levels and the peak hour >>> process_log_file('example.log') {'INFO': 3, 'WARNING': 1, 'ERROR': 2, 'peak_hour': 11} pass def filter_log_by_date(log_file_path, date_str): Generate a summary of log entries for a specified date. :param log_file_path: Path to the log file :param date_str: Date string in the format YYYY-MM-DD :return: Summary string containing the count of log entries by level for the specified date and the peak hour >>> filter_log_by_date('example.log', '2023-05-14') 'Date: 2023-05-14, INFO: 2, WARNING: 1, ERROR: 1, Peak Hour: 11' pass","solution":"import re from collections import defaultdict, Counter from datetime import datetime LOG_PATTERN = re.compile( r'(?P<date>d{4}-d{2}-d{2}) (?P<time>d{2}:d{2}:d{2}) [(?P<level>INFO|WARNING|ERROR)] (?P<message>.+)' ) def process_log_file(log_file_path): level_counts = Counter() hourly_counts = Counter() with open(log_file_path, 'r') as file: for line in file: match = LOG_PATTERN.match(line) if match: log_level = match.group('level') log_hour = int(match.group('time').split(\\":\\")[0]) level_counts[log_level] += 1 hourly_counts[log_hour] += 1 peak_hour = hourly_counts.most_common(1)[0][0] if hourly_counts else None result = { 'INFO': level_counts['INFO'], 'WARNING': level_counts['WARNING'], 'ERROR': level_counts['ERROR'], 'peak_hour': peak_hour } return result def filter_log_by_date(log_file_path, date_str): level_counts = Counter() hourly_counts = Counter() with open(log_file_path, 'r') as file: for line in file: match = LOG_PATTERN.match(line) if match: log_date = match.group('date') if log_date == date_str: log_level = match.group('level') log_hour = int(match.group('time').split(\\":\\")[0]) level_counts[log_level] += 1 hourly_counts[log_hour] += 1 peak_hour = hourly_counts.most_common(1)[0][0] if hourly_counts else None summary = (f\\"Date: {date_str}, INFO: {level_counts['INFO']}, \\" f\\"WARNING: {level_counts['WARNING']}, ERROR: {level_counts['ERROR']}, \\" f\\"Peak Hour: {peak_hour}\\") return summary"},{"question":"from typing import List def convert_to_utc(timestamps: List[str]) -> List[str]: Converts a list of timestamps in different time zones to UTC. Args: timestamps (List[str]): A list of timestamp strings in ISO 8601 format. Returns: List[str]: A list of timestamp strings converted to UTC, formatted as ISO 8601 strings. >>> convert_to_utc([ ... \\"2023-10-07T13:45:00-04:00\\", ... \\"2023-10-07T17:30:00+02:00\\", ... \\"2023-10-07T14:00:00Z\\", ... \\"2023-10-07T07:30:00-07:00\\" ... ]) [ \\"2023-10-07T17:45:00Z\\", \\"2023-10-07T15:30:00Z\\", \\"2023-10-07T14:00:00Z\\", \\"2023-10-07T14:30:00Z\\" ] >>> convert_to_utc([]) []","solution":"from dateutil import parser from datetime import datetime, timezone from typing import List def convert_to_utc(timestamps: List[str]) -> List[str]: Converts a list of timestamps in different time zones to UTC. Args: timestamps (List[str]): A list of timestamp strings in ISO 8601 format. Returns: List[str]: A list of timestamp strings converted to UTC, formatted as ISO 8601 strings. utc_timestamps = [] for ts in timestamps: dt = parser.isoparse(ts) # Parse the timestamp using dateutil utc_dt = dt.astimezone(timezone.utc) # Convert to UTC utc_timestamps.append(utc_dt.isoformat().replace(\\"+00:00\\", \\"Z\\")) # Convert back to ISO 8601 string return utc_timestamps"},{"question":"def count_k_complete_subarrays(arr: list[int], k: int) -> int: Calculate the number of subarrays that contain exactly k distinct integers. >>> count_k_complete_subarrays([1, 2, 1, 2, 3], 2) == 7 >>> count_k_complete_subarrays([1, 2, 1, 3, 4], 3) == 3 >>> count_k_complete_subarrays([1], 1) == 1 >>> count_k_complete_subarrays([1, 2, 3], 5) == 0 >>> count_k_complete_subarrays([1, 1, 1, 1], 1) == 10 >>> count_k_complete_subarrays([1, 2, 3, 4, 5], 5) == 1 >>> count_k_complete_subarrays([1, 2, 1, 3, 4, 2, 3], 3) == 6","solution":"def count_k_complete_subarrays(arr, k): from collections import defaultdict def at_most_k_distinct(arr, k): count = defaultdict(int) i = 0 total_k_complete = 0 for j in range(len(arr)): if count[arr[j]] == 0: k -= 1 count[arr[j]] += 1 while k < 0: count[arr[i]] -= 1 if count[arr[i]] == 0: k += 1 i += 1 total_k_complete += j - i + 1 return total_k_complete return at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k-1)"},{"question":"class SalesAnalyzer: def __init__(self, sales_data): self.sales_data = sales_data def detect_trending_products(self, product_id, n): Identify products showing a consistent increase in sales over the past n days. Args: product_id (str): ID of the product to analyze n (int): Number of past days to analyze sales trend Returns: bool: True if the product's sales trend is increasing over the last n days, otherwise False. pass def detect_underperforming_products(self, sales_threshold, m): Find products with sales below a specified threshold over the past m days. Args: sales_threshold (int): Minimum sales to consider a product performing well m (int): Number of past days to analyze Returns: List[str]: A list of product IDs that are underperforming. pass import pytest def test_detect_trending_products_single_true(): sales_data = { 'P001': [10, 12, 15, 20, 25, 30, 35] } analyzer = SalesAnalyzer(sales_data) assert analyzer.detect_trending_products('P001', 5) == True def test_detect_trending_products_single_false(): sales_data = { 'P002': [8, 7, 6, 5, 4, 4, 3] } analyzer = SalesAnalyzer(sales_data) assert analyzer.detect_trending_products('P002', 5) == False def test_detect_trending_products_not_enough_data(): sales_data = { 'P003': [15, 18] } analyzer = SalesAnalyzer(sales_data) assert analyzer.detect_trending_products('P003', 5) == False def test_detect_underperforming_products_single(): sales_data = { 'P001': [10, 5, 6, 20, 25, 20, 19], 'P002': [8, 7, 4, 3, 4, 4, 3], 'P003': [20, 21, 25, 24, 5, 5, 5] } analyzer = SalesAnalyzer(sales_data) assert analyzer.detect_underperforming_products(5, 3) == ['P002'] def test_detect_underperforming_products_multiple(): sales_data = { 'P001': [1, 2, 3, 2, 1], 'P002': [0, 0, 0, 0, 0], 'P003': [10, 20, 30, 40, 50] } analyzer = SalesAnalyzer(sales_data) assert analyzer.detect_underperforming_products(5, 5) == ['P001', 'P002'] def test_detect_underperforming_products_no_underperformers(): sales_data = { 'P001': [10, 15, 20, 25, 30, 35, 40], 'P002': [6, 7, 8, 9, 10, 11, 12] } analyzer = SalesAnalyzer(sales_data) assert analyzer.detect_underperforming_products(5, 7) == []","solution":"class SalesAnalyzer: def __init__(self, sales_data): self.sales_data = sales_data def detect_trending_products(self, product_id, n): sales = self.sales_data.get(product_id) if sales is None or len(sales) < n: return False for i in range(-n, -1): if sales[i] >= sales[i + 1]: return False return True def detect_underperforming_products(self, sales_threshold, m): underperforming_products = [] for product_id, sales in self.sales_data.items(): if len(sales) < m: continue if all(sale < sales_threshold for sale in sales[-m:]): underperforming_products.append(product_id) return underperforming_products"},{"question":"def find_error_spikes(log_directory: pathlib.Path, threshold: int) -> list[tuple[datetime, int]]: Scans a series of log files and identifies periods of unusually high error occurrences. Args: log_directory (pathlib.Path): Path object pointing to the directory containing log files. threshold (int): Minimum number of errors to identify a spike. Returns: list[tuple[datetime, int]]: List of tuples, where each tuple contains the start time of an interval and the corresponding error count. Given a log directory structure and files: Example: directory_structure: logs/ ├── log1.txt ├── log2.txt log1.txt content: [2023-01-01 10:00:03] ERROR Something went wrong [2023-01-01 10:02:34] ERROR Another error occurred [2023-01-01 10:12:45] ERROR Critical failure log2.txt content: [2023-01-01 10:05:12] ERROR Something went wrong again [2023-01-01 10:08:22] ERROR Unexpected condition [2023-01-01 10:15:30] ERROR Exception occurred >>> find_error_spikes(Path(\\"logs\\"), 3) [(datetime(2023, 1, 1, 10, 0), 3)] import tempfile from pathlib import Path from datetime import datetime from solution import find_error_spikes def create_log_file(directory, filename, content): file_path = directory / filename with file_path.open(\\"w\\") as f: f.write(content) return file_path def test_find_error_spikes_single_file(): with tempfile.TemporaryDirectory() as tmpdirname: log_dir = Path(tmpdirname) log_content = [2023-01-01 10:00:03] ERROR Something went wrong [2023-01-01 10:02:34] ERROR Another error occurred [2023-01-01 10:12:45] ERROR Critical failure [2023-01-01 10:05:12] ERROR Something went wrong again [2023-01-01 10:08:22] ERROR Unexpected condition [2023-01-01 10:15:30] ERROR Exception occurred create_log_file(log_dir, \\"log.txt\\", log_content) expected = [(datetime(2023, 1, 1, 10, 0), 4)] # 4 errors in the 10:00 to 10:10 interval assert find_error_spikes(log_dir, 3) == expected def test_find_error_spikes_multiple_files(): with tempfile.TemporaryDirectory() as tmpdirname: log_dir = Path(tmpdirname) log1_content = [2023-01-01 10:00:03] ERROR Error 1 [2023-01-01 10:02:34] ERROR Error 2 [2023-01-01 10:12:45] ERROR Error 3 log2_content = [2023-01-01 10:05:12] ERROR Error 4 [2023-01-01 10:08:22] ERROR Error 5 [2023-01-01 10:15:30] ERROR Error 6 create_log_file(log_dir, \\"log1.txt\\", log1_content) create_log_file(log_dir, \\"log2.txt\\", log2_content) expected = [(datetime(2023, 1, 1, 10, 0), 4)] # 4 errors in the 10:00 to 10:10 interval assert find_error_spikes(log_dir, 3) == expected def test_no_error_spikes(): with tempfile.TemporaryDirectory() as tmpdirname: log_dir = Path(tmpdirname) log_content = [2023-01-01 10:00:03] INFO Everything is fine [2023-01-01 10:02:34] INFO Running smooth [2023-01-01 10:12:45] INFO All good create_log_file(log_dir, \\"log.txt\\", log_content) assert find_error_spikes(log_dir, 3) == [] def test_error_spikes_no_files(): with tempfile.TemporaryDirectory() as tmpdirname: log_dir = Path(tmpdirname) assert find_error_spikes(log_dir, 3) == []","solution":"import pathlib from datetime import datetime, timedelta from collections import defaultdict import re def find_error_spikes(log_directory: pathlib.Path, threshold: int) -> list[tuple[datetime, int]]: error_counts = defaultdict(int) interval_format = \\"%Y-%m-%d %H:%M\\" log_files = log_directory.glob(\\"*.txt\\") error_pattern = re.compile(r\\"[(?P<timestamp>.+?)] ERROR\\") for log_file in log_files: with log_file.open() as file: for line in file: match = error_pattern.search(line) if match: timestamp_str = match.group(\\"timestamp\\") log_time = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") interval = log_time - timedelta(minutes=log_time.minute % 10, seconds=log_time.second) interval_str = interval.strftime(interval_format) error_counts[interval_str] += 1 return [(datetime.strptime(interval, interval_format), count) for interval, count in error_counts.items() if count >= threshold]"},{"question":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the missing number in a list of integers ranging from 0 to n. >>> find_missing_number([3, 0, 1]) == 2 >>> find_missing_number([0, 1]) == 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8 >>> find_missing_number([0]) == 1","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the missing number in a list of integers ranging from 0 to n. n = len(arr) + 1 expected_sum = n * (n - 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. >>> min_cost_path([ ... [1, 3, 5], ... [2, 1, 2], ... [4, 3, 1] ... ]) 7 >>> min_cost_path([ ... [1] ... ]) 1 >>> min_cost_path([ ... [1, 2], ... [1, 1] ... ]) 3 pass def test_min_cost_path_3x3(): grid = [ [1, 3, 5], [2, 1, 2], [4, 3, 1] ] assert min_cost_path(grid) == 7 def test_min_cost_path_1x1(): grid = [ [1] ] assert min_cost_path(grid) == 1 def test_min_cost_path_2x2(): grid = [ [1, 2], [1, 1] ] assert min_cost_path(grid) == 3 def test_min_cost_path_single_row(): grid = [ [1, 2, 3] ] assert min_cost_path(grid) == 6 def test_min_cost_path_single_column(): grid = [ [1], [2], [3] ] assert min_cost_path(grid) == 6 def test_empty_grid(): grid = [] try: min_cost_path(grid) assert False, \\"Expected ValueError\\" except ValueError: assert True def test_grid_with_zero_column(): grid = [[]] try: min_cost_path(grid) assert False, \\"Expected ValueError\\" except ValueError: assert True","solution":"def min_cost_path(grid): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. if not grid or not grid[0]: raise ValueError(\\"The grid must have at least one cell.\\") # Retrieve the dimensions of the grid rows = len(grid) cols = len(grid[0]) # Create a 2D dp array with the same dimensions as the grid dp = [[0 for _ in range(cols)] for _ in range(rows)] # Initialize the starting point dp[0][0] = grid[0][0] # Initialize the first row (only horizontal moves) for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column (only vertical moves) for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]) # The last cell contains the minimum cost to reach the bottom-right corner return dp[rows - 1][cols - 1]"},{"question":"def adjust_brightness(image: list[list[tuple[int, int, int]]], factor: float) -> list[list[tuple[int, int, int]]]: Adjust the brightness of a 2D list representing an image. Each pixel is represented by a tuple (red, green, blue), where 0 <= red, green, blue <= 255. The factor is a float where a value greater than 1 increases brightness, and a value less than 1 decreases brightness. >>> adjust_brightness([[(100, 100, 100), (50, 50, 50)], [(200, 200, 200), (25, 25, 25)]], 1.2) [[(120, 120, 120), (60, 60, 60)], [(240, 240, 240), (30, 30, 30)]] >>> adjust_brightness([[(255, 255, 255), (0, 0, 0)], [(128, 128, 128), (64, 64, 64)]], 0.5) [[(127, 127, 127), (0, 0, 0)], [(64, 64, 64), (32, 32, 32)]] >>> adjust_brightness([[(255, 128, 64)]], 2.0) [[(255, 255, 128)]] >>> adjust_brightness([], 1.5) [] >>> adjust_brightness([[(10, 20, 30), (40, 50, 60)]], 0.0) [[(0, 0, 0), (0, 0, 0)]]","solution":"def clamp(value, min_value, max_value): return max(min_value, min(value, max_value)) def adjust_brightness(image, factor): if not image: return [] adjusted_image = [] for row in image: adjusted_row = [] for (red, green, blue) in row: adjusted_red = clamp(int(red * factor), 0, 255) adjusted_green = clamp(int(green * factor), 0, 255) adjusted_blue = clamp(int(blue * factor), 0, 255) adjusted_row.append((adjusted_red, adjusted_green, adjusted_blue)) adjusted_image.append(adjusted_row) return adjusted_image"},{"question":"def deepest_directory_depth(directory_structure: dict) -> int: Returns the depth of the deepest directory in a nested dictionary structure. >>> directory_structure = { \\"root\\": [ \\"file1.txt\\", { \\"subdir1\\": [ \\"file2.txt\\", { \\"subdir2\\": [ \\"file3.txt\\", \\"file4.txt\\", { \\"subdir3\\": [ \\"file5.txt\\" ] } ] } ] } ] } >>> deepest_directory_depth(directory_structure) 4 >>> directory_structure = { \\"root\\": [\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\"] } >>> deepest_directory_depth(directory_structure) 1 >>> directory_structure = { \\"root\\": [ \\"file1.txt\\", { \\"subdir1\\": [\\"file2.txt\\"] } ] } >>> deepest_directory_depth(directory_structure) 2","solution":"def deepest_directory_depth(directory_structure: dict, current_depth=1) -> int: Returns the depth of the deepest directory in a nested dictionary structure. max_depth = current_depth for item in directory_structure.values(): if isinstance(item, list): for sub_item in item: if isinstance(sub_item, dict): for sub_dir in sub_item: max_depth = max(max_depth, deepest_directory_depth(sub_item, current_depth + 1)) return max_depth"},{"question":"import heapq class UniqueMinHeap: A custom data structure that acts like a min-heap but only contains unique elements. def __init__(self): Initializes an empty UniqueMinHeap. self.heap = [] self.set = set() def insert(self, value: int): Inserts a unique integer into the heap. If the integer already exists in the heap, it should not be added again. Args: value (int): The value to be inserted. pass def extract_min(self) -> int: Removes and returns the smallest integer from the heap. If the heap is empty, raise an appropriate exception. Returns: int: The smallest integer in the heap. pass def get_min(self) -> int: Returns the smallest integer in the heap without removing it. If the heap is empty, raise an appropriate exception. Returns: int: The smallest integer in the heap. pass","solution":"import heapq class UniqueMinHeap: def __init__(self): self.heap = [] self.set = set() def insert(self, value: int): if value not in self.set: heapq.heappush(self.heap, value) self.set.add(value) def extract_min(self) -> int: if not self.heap: raise IndexError(\\"extract_min(): empty heap\\") min_val = heapq.heappop(self.heap) self.set.remove(min_val) return min_val def get_min(self) -> int: if not self.heap: raise IndexError(\\"get_min(): empty heap\\") return self.heap[0]"},{"question":"def justify_text(words: List[str], maxWidth: int) -> List[str]: Implement Text Justification algorithm to format a list of words into fully justified text lines. Each line should contain exactly maxWidth characters. >>> justify_text([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16) [\\"This is an\\", \\"example of text\\", \\"justification. \\"] >>> justify_text([\\"What\\", \\"must\\", \\"be\\", \\"acknowledgment\\", \\"shall\\", \\"be\\"], 16) [\\"What must be\\", \\"acknowledgment \\", \\"shall be \\"] >>> justify_text([\\"Science\\", \\"is\\", \\"what\\", \\"we\\", \\"understand\\", \\"well\\", \\"enough\\", \\"to\\", \\"explain\\", \\"to\\", \\"a\\", \\"computer.\\", \\"Art\\", \\"is\\", \\"everything\\", \\"else\\", \\"we\\", \\"do\\"], 20) [\\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\"] >>> justify_text([\\"Hello\\"], 10) [\\"Hello \\"] >>> justify_text([\\"Hello\\", \\"world\\"], 11) [\\"Hello world\\"]","solution":"def justify_text(words, maxWidth): def justify_line(line, maxWidth): num_spaces = maxWidth - sum(len(word) for word in line) if len(line) == 1: return line[0] + ' ' * num_spaces gaps = len(line) - 1 space_between_words, extra_spaces = divvy(num_spaces, gaps) justified_line = '' for i in range(gaps): justified_line += line[i] + ' ' * (space_between_words + (1 if i < extra_spaces else 0)) justified_line += line[-1] return justified_line def divvy(total, divisors): return divmod(total, divisors) lines = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > maxWidth: lines.append(justify_line(current_line, maxWidth)) current_line = [] current_length = 0 current_line.append(word) current_length += len(word) final_line = ' '.join(current_line) final_line_padded = final_line + ' ' * (maxWidth - len(final_line)) lines.append(final_line_padded) return lines"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence (0 ≤ n ≤ 30). Returns: int: The nth Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040 pass","solution":"def fibonacci(n): Returns the nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence (0 ≤ n ≤ 30). Returns: int: The nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"class Node: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None def height_of_tree(root: Node) -> int: Calculate the height of the binary tree rooted at \`root\`. Args: root (Node): The root node of the binary tree. Returns: int: The height of the tree. Examples: >>> root = Node(1) >>> height_of_tree(root) 0 >>> root.left = Node(2) >>> root.right = Node(3) >>> height_of_tree(root) 1 >>> root.left.left = Node(4) >>> root.right.right = Node(5) >>> height_of_tree(root) 2 >>> root.left.left.left = Node(6) >>> height_of_tree(root) 3 >>> height_of_tree(None) -1","solution":"class Node: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None def height_of_tree(root: Node) -> int: Calculate the height of the binary tree rooted at \`root\`. Args: root (Node): The root node of the binary tree. Returns: int: The height of the tree. if not root: return -1 left_height = height_of_tree(root.left) right_height = height_of_tree(root.right) return max(left_height, right_height) + 1"},{"question":"def validate_knight_moves(moves: list) -> bool: Validate a sequence of knight moves on a chessboard. >>> validate_knight_moves([(1, 1), (3, 2), (1, 3), (2, 1)]) True >>> validate_knight_moves([(1, 1), (3, 3)]) False >>> validate_knight_moves([(4, 5), (2, 3), (1, 2), (9, 4)]) False >>> validate_knight_moves([(1, 1)]) True >>> validate_knight_moves([(1, 1), (3, 2), (5, 3), (7, 4), (8, 6)]) True >>> validate_knight_moves([(1, 1), (3, 2), (4, 4), (5, 5)]) False def is_valid_move(start, end): x1, y1 = start x2, y2 = end return (abs(x1 - x2), abs(y1 - y2)) in [(2, 1), (1, 2)] for i in range(len(moves) - 1): if not is_valid_move(moves[i], moves[i + 1]): return False return True","solution":"def validate_knight_moves(moves: list) -> bool: def is_valid_move(start, end): x1, y1 = start x2, y2 = end # A knight move in chess is valid if it moves in an L shape: # 2 squares in one direction, and then 1 square in a perpendicular direction return (abs(x1 - x2), abs(y1 - y2)) in [(2, 1), (1, 2)] for i in range(len(moves) - 1): if not is_valid_move(moves[i], moves[i + 1]): return False return True"},{"question":"def merge_cells(grid: list[list[int]]) -> list[list[int]]: Returns a new 2D grid with merged cells where each group of connected cells with the same integer value is replaced by a single cell with that integer value. >>> merge_cells([[1, 2, 2], [3, 2, 2], [3, 3, 4]]) [[1, 2, 0], [3, 0, 0], [0, 0, 4]] >>> merge_cells([[5, 5], [5, 5]]) [[5, 0], [0, 0]]","solution":"def merge_cells(grid): def dfs(x, y, value): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == value: grid[i][j] = 0 cells.add((i, j)) neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] stack.extend(neighbors) for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] != 0: value = grid[i][j] cells = set() dfs(i, j, value) min_i = min(cell[0] for cell in cells) min_j = min(cell[1] for cell in cells) grid[min_i][min_j] = value return grid"},{"question":"from typing import List, Tuple def custom_sort(tuples: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Sort a list of tuples by the specified custom order. Args: tuples (List[Tuple[int, int, int]]): A list of tuples to be sorted. Returns: List[Tuple[int, int, int]]: The sorted list of tuples. Example: >>> custom_sort([(1, 2, 3), (1, 1, 3), (2, 2, 2), (1, 2, 2)]) [(1, 2, 2), (1, 2, 3), (1, 1, 3), (2, 2, 2)] >>> custom_sort([(0, 2, 3), (0, 2, 1), (1, 1, 1), (0, 1, 1)]) [(0, 2, 1), (0, 2, 3), (0, 1, 1), (1, 1, 1)] from solution import custom_sort def test_custom_sort_example1(): assert custom_sort([(1, 2, 3), (1, 1, 3), (2, 2, 2), (1, 2, 2)]) == [(1, 2, 2), (1, 2, 3), (1, 1, 3), (2, 2, 2)] def test_custom_sort_example2(): assert custom_sort([(0, 2, 3), (0, 2, 1), (1, 1, 1), (0, 1, 1)]) == [(0, 2, 1), (0, 2, 3), (0, 1, 1), (1, 1, 1)] def test_custom_sort_empty(): assert custom_sort([]) == [] def test_custom_sort_single_element(): assert custom_sort([(0, 0, 0)]) == [(0, 0, 0)] def test_custom_sort_same_a_b_different_c(): assert custom_sort([(1, 2, 5), (1, 2, 3), (1, 2, 4)]) == [(1, 2, 3), (1, 2, 4), (1, 2, 5)] def test_custom_sort_same_a_different_b(): assert custom_sort([(1, 3, 2), (1, 2, 3), (1, 3, 1)]) == [(1, 3, 1), (1, 3, 2), (1, 2, 3)] def test_custom_sort_all_elements_different(): assert custom_sort([(3, 2, 1), (1, 2, 3), (2, 1, 3), (1, 1, 3)]) == [(1, 2, 3), (1, 1, 3), (2, 1, 3), (3, 2, 1)]","solution":"from typing import List, Tuple def custom_sort(tuples: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Sort a list of tuples by the specified custom order. Args: tuples (List[Tuple[int, int, int]]): A list of tuples to be sorted. Returns: List[Tuple[int, int, int]]: The sorted list of tuples. return sorted(tuples, key=lambda x: (x[0], -x[1], x[2]))"},{"question":"def follows_pattern(pattern: str, s: str) -> bool: Determines if the given string s follows the specified pattern. Args: pattern (str): The pattern string where each character represents a particular word. s (str): The string composed of words separated by spaces. Returns: bool: True if the pattern matches the given string s, otherwise False. Example: >>> follows_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> follows_pattern(\\"abba\\", \\"dog cat cat fish\\") False >>> follows_pattern(\\"aaaa\\", \\"dog dog dog dog\\") True >>> follows_pattern(\\"aaaa\\", \\"dog dog dog cat\\") False pass from solution import follows_pattern def test_follows_pattern(): assert follows_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert follows_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert follows_pattern(\\"aaaa\\", \\"dog dog dog dog\\") == True assert follows_pattern(\\"aaaa\\", \\"dog dog dog cat\\") == False assert follows_pattern(\\"aabb\\", \\"dog dog cat cat\\") == True assert follows_pattern(\\"aabb\\", \\"dog cat cat dog\\") == False assert follows_pattern(\\"ab\\", \\"dog cat\\") == True assert follows_pattern(\\"ab\\", \\"dog dog\\") == False assert follows_pattern(\\"abc\\", \\"dog cat fish\\") == True assert follows_pattern(\\"abc\\", \\"dog cat cat\\") == False def test_different_lengths(): assert follows_pattern(\\"ab\\", \\"dog\\") == False assert follows_pattern(\\"a\\", \\"dog cat\\") == False def test_single_character_pattern(): assert follows_pattern(\\"a\\", \\"dog\\") == True assert follows_pattern(\\"b\\", \\"cat\\") == True assert follows_pattern(\\"a\\", \\"dog cat\\") == False assert follows_pattern(\\"aa\\", \\"dog dog\\") == True assert follows_pattern(\\"aa\\", \\"dog cat\\") == False assert follows_pattern(\\"ab\\", \\"dog dog\\") == False","solution":"def follows_pattern(pattern: str, s: str) -> bool: Determines if the given string s follows the specified pattern. Args: pattern (str): The pattern string where each character represents a particular word. s (str): The string composed of words separated by spaces. Returns: bool: True if the pattern matches the given string s, otherwise False. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def depth_of_query(root: Optional[TreeNode], node: int) -> int: Returns the depth of the given node in the binary tree. If the node does not exist, return -1. def test_node_exists_at_root(): root = TreeNode(3) assert depth_of_query(root, 3) == 0 def test_node_exists_at_depth_1(): root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) assert depth_of_query(root, 9) == 1 assert depth_of_query(root, 20) == 1 def test_node_exists_at_deeper_levels(): root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert depth_of_query(root, 15) == 2 assert depth_of_query(root, 7) == 2 def test_node_does_not_exist(): root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) assert depth_of_query(root, 10) == -1 def test_empty_tree(): assert depth_of_query(None, 3) == -1","solution":"from typing import Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def depth_of_query(root: Optional[TreeNode], node: int) -> int: Returns the depth of the given node in the binary tree. If the node does not exist, return -1. if not root: return -1 def dfs(current, depth): if not current: return -1 if current.value == node: return depth left_depth = dfs(current.left, depth + 1) if left_depth != -1: return left_depth return dfs(current.right, depth + 1) return dfs(root, 0)"},{"question":"def shortest_path_to_user(connections: list[tuple[int, int]], start: int, end: int) -> list[int]: Determine the shortest path between two users in a social media network. Args: connections (list of tuple of int): A list of tuples representing directed connections. start (int): The starting user id. end (int): The target user id. Returns: list of int: The shortest path from start to end user ids. If no path exists, return an empty list. Examples: >>> shortest_path_to_user([(0, 1), (1, 2), (2, 3), (4, 2), (4, 5), (5, 6)], 0, 3) [0, 1, 2, 3] >>> shortest_path_to_user([(0, 1), (1, 2), (2, 3)], 0, 4) [] from typing import List, Tuple def test_shortest_path_basic(): connections = [(0, 1), (1, 2), (2, 3)] start = 0 end = 3 assert shortest_path_to_user(connections, start, end) == [0, 1, 2, 3] def test_shortest_path_no_path(): connections = [(0, 1), (1, 2), (2, 3)] start = 0 end = 4 assert shortest_path_to_user(connections, start, end) == [] def test_shortest_path_direct_connection(): connections = [(0, 1), (1, 2), (2, 3), (3, 4)] start = 2 end = 3 assert shortest_path_to_user(connections, start, end) == [2, 3] def test_shortest_path_multiple_paths(): connections = [(0, 1), (1, 2), (2, 3), (0, 3)] start = 0 end = 3 assert shortest_path_to_user(connections, start, end) == [0, 3] def test_shortest_path_disconnected_graph(): connections = [(0, 1), (2, 3), (3, 4)] start = 0 end = 3 assert shortest_path_to_user(connections, start, end) == [] def test_shortest_path_single_node(): connections = [] start = 0 end = 0 assert shortest_path_to_user(connections, start, end) == [0] def test_shortest_path_loop(): connections = [(0, 1), (1, 2), (2, 0), (2, 3)] start = 0 end = 3 assert shortest_path_to_user(connections, start, end) == [0, 1, 2, 3]","solution":"from collections import deque, defaultdict def shortest_path_to_user(connections, start, end): def bfs(): queue = deque([(start, [start])]) visited = set() while queue: current, path = queue.popleft() if current == end: return path if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] # Build the adjacency list for the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) # Perform BFS to find the shortest path return bfs()"},{"question":"def sum_of_divisors(n: int) -> int: Calculate the sum of all divisors of n. >>> sum_of_divisors(6) 12 >>> sum_of_divisors(28) 56 def test_sum_of_divisors(): assert sum_of_divisors(6) == 12 assert sum_of_divisors(28) == 56 assert sum_of_divisors(1) == 1 assert sum_of_divisors(12) == 28 assert sum_of_divisors(17) == 18 assert sum_of_divisors(100) == 217 assert sum_of_divisors(36) == 91 assert sum_of_divisors(45) == 78 assert sum_of_divisors(1024) == 2047 assert sum_of_divisors(9973) == 9974","solution":"def sum_of_divisors(n): Returns the sum of all divisors of n. # Initialize the sum of divisors to 0 total = 0 # Loop through all integers from 1 to n for i in range(1, n + 1): if n % i == 0: total += i return total"},{"question":"from typing import List def max_trapped_water(heights: List[int]) -> int: Calculate the maximum amount of water that could be trapped between buildings after it rains. >>> max_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> max_trapped_water([3, 0, 2, 0, 4]) 7 >>> max_trapped_water([1, 1, 1, 1, 1]) 0 >>> max_trapped_water([0, 0, 0, 0, 0]) 0 >>> max_trapped_water([]) 0 >>> max_trapped_water([0, 1]) 0 >>> max_trapped_water([4, 2, 0, 3, 2, 5]) 9","solution":"from typing import List def max_trapped_water(heights: List[int]) -> int: if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"def is_valid_expression(expression: str) -> bool: Validate if the given expression containing multiple types of brackets is valid using a stack data structure. >>> is_valid_expression(\\"{[()()]}\\") True >>> is_valid_expression(\\"{[(])}\\") False >>> is_valid_expression(\\"([{}])[]\\") True import pytest from solution import is_valid_expression def test_balanced_expression(): assert is_valid_expression(\\"{[()()]}\\") == True def test_unbalanced_expression(): assert is_valid_expression(\\"{[(])}\\") == False def test_empty_string(): assert is_valid_expression(\\"\\") == True def test_single_type_balanced_brackets(): assert is_valid_expression(\\"()()()\\") == True def test_single_type_unbalanced_brackets(): assert is_valid_expression(\\"(()\\") == False def test_mixed_balanced_brackets(): assert is_valid_expression(\\"([{}])[]\\") == True def test_mixed_unbalanced_brackets(): assert is_valid_expression(\\"[({])}\\") == False def test_only_opening_brackets(): assert is_valid_expression(\\"(({{[[\\") == False def test_only_closing_brackets(): assert is_valid_expression(\\"]]}}))\\") == False # Running pytest to verify all test cases if __name__ == \\"__main__\\": pytest.main()","solution":"def is_valid_expression(expression: str) -> bool: stack = [] bracket_pairs = { ')': '(', '}': '{', ']': '[' } for char in expression: if char in bracket_pairs.values(): stack.append(char) elif char in bracket_pairs.keys(): if stack and stack[-1] == bracket_pairs[char]: stack.pop() else: return False return not stack"},{"question":"def priority_sort(packages: list[tuple[int, int, int]]) -> list[int]: Sorts packages based on priority in descending order. If two packages have the same priority, they are sorted based on arrival time in ascending order. Parameters: packages (list of (int, int, int)): A list of tuples where each tuple contains three integers representing the package ID, priority, and arrival time respectively. Returns: list of int: Sorted list of package IDs based on the sorting criteria. Example: >>> packages = [(1, 3, 10), (2, 2, 5), (3, 3, 4), (4, 1, 7)] >>> priority_sort(packages) [3, 1, 2, 4]","solution":"def priority_sort(packages): Sorts packages based on priority in descending order. If two packages have the same priority, they are sorted based on arrival time in ascending order. Parameters: packages (list of (int, int, int)): A list of tuples where each tuple contains three integers representing the package ID, priority, and arrival time respectively. Returns: list of int: Sorted list of package IDs based on the sorting criteria. if not packages: raise ValueError(\\"The list of packages should not be empty\\") if not all(isinstance(p, tuple) and len(p) == 3 and all(isinstance(x, int) for x in p) for p in packages): raise ValueError(\\"Each element must be a tuple of exactly three integers\\") packages.sort(key=lambda x: (-x[1], x[2])) return [p[0] for p in packages]"},{"question":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_leaves(root: Optional[TreeNode]) -> int: Calculate the sum of all the leaf nodes in a binary tree. >>> node1 = TreeNode(1) >>> node2 = TreeNode(2) >>> node3 = TreeNode(3) >>> node4 = TreeNode(4) >>> node5 = TreeNode(5) >>> node1.left = node2 >>> node1.right = node3 >>> node2.left = node4 >>> node2.right = node5 >>> sum_of_leaves(node1) 12 >>> node3a = TreeNode(3) >>> node9 = TreeNode(9) >>> node20 = TreeNode(20) >>> node15 = TreeNode(15) >>> node7 = TreeNode(7) >>> node3a.left = node9 >>> node3a.right = node20 >>> node20.left = node15 >>> node20.right = node7 >>> sum_of_leaves(node3a) 31 >>> node1 = TreeNode(1) >>> sum_of_leaves(node1) 1 >>> sum_of_leaves(None) 0","solution":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_leaves(root: Optional[TreeNode]) -> int: if root is None: return 0 if root.left is None and root.right is None: return root.val return sum_of_leaves(root.left) + sum_of_leaves(root.right)"},{"question":"def fibonacci_recursive(n: int) -> int: Returns the n-th Fibonacci number using a recursive approach. >>> fibonacci_recursive(0) 0 >>> fibonacci_recursive(1) 1 >>> fibonacci_recursive(2) 1 >>> fibonacci_recursive(5) 5 >>> fibonacci_recursive(10) 55 pass def fibonacci_iterative(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. >>> fibonacci_iterative(0) 0 >>> fibonacci_iterative(1) 1 >>> fibonacci_iterative(2) 1 >>> fibonacci_iterative(5) 5 >>> fibonacci_iterative(10) 55 # Error Handling >>> fibonacci_iterative(-1) Traceback (most recent call last): ... ValueError: Parameter n must be a non-negative integer. >>> fibonacci_iterative(\\"abcd\\") Traceback (most recent call last): ... TypeError: Parameter n must be int or castable to int. pass","solution":"def fibonacci_recursive(n: int) -> int: Returns the n-th Fibonacci number using a recursive approach. if n < 0: raise ValueError(\\"Parameter n must be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 else: return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2) def fibonacci_iterative(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. if not isinstance(n, int): if isinstance(n, float) and n.is_integer(): n = int(n) else: raise TypeError(\\"Parameter n must be an int or castable to int.\\") if n < 0: raise ValueError(\\"Parameter n must be a non-negative integer.\\") a, b = 0, 1 for _ in range(n): a, b = b, a + b return a"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing integers, parentheses, and the operators +, -, *, and /. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5 >>> evaluate_expression(\\"(2+6*3+5-(3*14/7+2)*5)+3\\") -12","solution":"def evaluate_expression(expression: str) -> int: def helper(tokens): stack = [] num = 0 sign = '+' while len(tokens) > 0: char = tokens.pop(0) if char.isnumeric(): num = num * 10 + int(char) if char == '(': num = helper(tokens) if (not char.isnumeric() and char != ' ') or len(tokens) == 0: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) num = 0 sign = char if char == ')': break return sum(stack) return helper(list(expression))"},{"question":"def custom_sort(nums: list) -> list: Sort a list of integers primarily by their absolute values in ascending order. If two integers have the same absolute value, they retain their original relative order. >>> custom_sort([10, -4, 3, -10, 2]) [2, 3, -4, 10, -10] >>> custom_sort([-1, 3, -3, 4, 0, -1]) [0, -1, -1, 3, -3, 4] pass # Unit Tests def test_custom_sort_with_mixed_sign_numbers(): assert custom_sort([10, -4, 3, -10, 2]) == [2, 3, -4, 10, -10] def test_custom_sort_with_duplicates_and_zeros(): assert custom_sort([-1, 3, -3, 4, 0, -1]) == [0, -1, -1, 3, -3, 4] def test_custom_sort_with_all_negative_numbers(): assert custom_sort([-5, -10, -8, -7]) == [-5, -7, -8, -10] def test_custom_sort_with_all_positive_numbers(): assert custom_sort([5, 1, 9, 8, 2]) == [1, 2, 5, 8, 9] def test_custom_sort_with_single_element(): assert custom_sort([42]) == [42] def test_custom_sort_with_all_zeros(): assert custom_sort([0, 0, 0]) == [0, 0, 0]","solution":"def custom_sort(nums: list) -> list: Sort a list of integers primarily by their absolute values in ascending order. If two integers have the same absolute value, they retain their original relative order. return sorted(nums, key=lambda x: (abs(x), nums.index(x)))"},{"question":"def prime_factors(n: int) -> dict: Calculate the prime factors of a given integer. Returns a dictionary where the keys are the prime factors and the values are the respective powers of those factors. >>> prime_factors(60) {2: 2, 3: 1, 5: 1} >>> prime_factors(130) {2: 1, 5: 1, 13: 1} >>> prime_factors(37) {37: 1} >>> prime_factors(1) {}","solution":"def prime_factors(n: int) -> dict: if n < 2: return {} factors = {} # Check for number of 2s that divide n while n % 2 == 0: if 2 in factors: factors[2] += 1 else: factors[2] = 1 n = n // 2 # n must be odd at this point so we can skip 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: if i in factors: factors[i] += 1 else: factors[i] = 1 n = n // i # This condition is to check if n is a prime number # greater than 2 at the end if n > 2: factors[n] = 1 return factors"},{"question":"def pythagorean_triplet_product(k: int) -> int: Returns the product of the Pythagorean triplet (a, b, c) where a + b + c = k. If no such triplet exists, the function returns -1. Parameters: k (int): The sum of the triplet to be found. Returns: int: The product a * b * c of the triplet, or -1 if no such triplet exists. for a in range(1, k // 3): for b in range(a + 1, k // 2): c = k - a - b if a * a + b * b == c * c: return a * b * c return -1 from solution import pythagorean_triplet_product def test_pythagorean_triplet_product_12(): assert pythagorean_triplet_product(12) == 60 def test_pythagorean_triplet_product_30(): assert pythagorean_triplet_product(30) == 780 def test_pythagorean_triplet_product_1000(): assert pythagorean_triplet_product(1000) == 31875000 def test_pythagorean_triplet_product_no_triplet(): assert pythagorean_triplet_product(43) == -1 def test_pythagorean_triplet_product_smallest_sum(): assert pythagorean_triplet_product(10) == -1 def test_pythagorean_triplet_product_large_no_triplet(): assert pythagorean_triplet_product(2999) == -1","solution":"def pythagorean_triplet_product(k: int) -> int: Returns the product of the Pythagorean triplet (a, b, c) where a + b + c = k. If no such triplet exists, the function returns -1. Parameters: k (int): The sum of the triplet to be found. Returns: int: The product a * b * c of the triplet, or -1 if no such triplet exists. for a in range(1, k // 3): for b in range(a + 1, k // 2): c = k - a - b if a * a + b * b == c * c: return a * b * c return -1"},{"question":"from typing import List def find_sequence(target: int, length: int) -> List[int]: Create a sequence of natural numbers such that the sequence meets specific criteria and the sum of its elements achieves a target value. >>> find_sequence(15, 5) [3, 3, 3, 3, 3] >>> find_sequence(10, 2) [5, 5] >>> find_sequence(7, 3) [1, 2, 4] >>> find_sequence(0, 1) [0] or [] >>> find_sequence(2, 3) [] >>> find_sequence(100, 1) [100]","solution":"from typing import List def find_sequence(target: int, length: int) -> List[int]: if target < length: return [] base_value = target // length remainder = target % length sequence = [base_value + 1] * remainder + [base_value] * (length - remainder) return sequence"},{"question":"from typing import List, Tuple, Dict def calculate_final_balances(transactions: List[Tuple[str, str, int]]) -> Dict[str, int]: Calculates the final balance for each account after processing all transactions. Args: transactions (List[Tuple[str, str, int]]): A list of tuples representing the transactions. Returns: Dict[str, int]: A dictionary where each key is an account identifier, and the corresponding value is the final balance. Example: >>> calculate_final_balances([ (\\"acc1\\", \\"deposit\\", 500), (\\"acc2\\", \\"deposit\\", 300), (\\"acc1\\", \\"withdrawal\\", 200), (\\"acc3\\", \\"deposit\\", 700), (\\"acc2\\", \\"withdrawal\\", 100), (\\"acc3\\", \\"withdrawal\\", 200) ]) {\\"acc1\\": 300, \\"acc2\\": 200, \\"acc3\\": 500} pass def test_single_transaction(): assert calculate_final_balances([(\\"acc1\\", \\"deposit\\", 100)]) == {\\"acc1\\": 100} def test_multiple_deposits(): assert calculate_final_balances([ (\\"acc1\\", \\"deposit\\", 100), (\\"acc1\\", \\"deposit\\", 200) ]) == {\\"acc1\\": 300} def test_deposit_and_withdrawal(): assert calculate_final_balances([ (\\"acc1\\", \\"deposit\\", 300), (\\"acc1\\", \\"withdrawal\\", 100) ]) == {\\"acc1\\": 200} def test_multiple_accounts(): assert calculate_final_balances([ (\\"acc1\\", \\"deposit\\", 300), (\\"acc2\\", \\"deposit\\", 200), (\\"acc1\\", \\"withdrawal\\", 100), (\\"acc2\\", \\"withdrawal\\", 50) ]) == {\\"acc1\\": 200, \\"acc2\\": 150} def test_empty_transactions_list(): assert calculate_final_balances([]) == {} def test_large_number_of_transactions(): transactions = [(\\"acc1\\", \\"deposit\\", 1) for _ in range(1000)] + [(\\"acc1\\", \\"withdrawal\\", 1) for _ in range(500)] assert calculate_final_balances(transactions) == {\\"acc1\\": 500}","solution":"from typing import List, Tuple, Dict def calculate_final_balances(transactions: List[Tuple[str, str, int]]) -> Dict[str, int]: balances = {} for account_id, transaction_type, amount in transactions: if account_id not in balances: balances[account_id] = 0 if transaction_type == \\"deposit\\": balances[account_id] += amount elif transaction_type == \\"withdrawal\\": balances[account_id] -= amount return balances"},{"question":"def is_fibonacci_sum(number: int) -> bool: Determine whether a given number can be represented as a sum of any contiguous subsequence of Fibonacci numbers. >>> is_fibonacci_sum(10) True # (2 + 3 + 5) >>> is_fibonacci_sum(7) True # (2 + 3 + 2) >>> is_fibonacci_sum(17) False >>> is_fibonacci_sum(13) True # (13 is a Fibonacci number itself) >>> is_fibonacci_sum(0) False","solution":"def is_fibonacci_sum(number: int) -> bool: if not isinstance(number, int) or number < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if number == 0: return False # Generate fibonacci numbers until the largest one less than or equal to \`number\` fibs = [1, 1] while True: next_fib = fibs[-1] + fibs[-2] if next_fib > number: break fibs.append(next_fib) # Use sliding window technique to find a contiguous subsequence for start in range(len(fibs)): current_sum = 0 for end in range(start, len(fibs)): current_sum += fibs[end] if current_sum == number: return True if current_sum > number: break return False"},{"question":"from typing import List def count_exceedances(temperature_readings: List[int], threshold: int, duration: int) -> int: Counts the number of times the temperature exceeds the threshold for at least the given number of consecutive minutes. :param temperature_readings: List of temperature readings. :param threshold: The temperature threshold. :param duration: Number of consecutive minutes to consider. :return: The number of exceedances. >>> count_exceedances([70, 72, 68, 65, 74, 75, 76, 70, 69, 71], 72, 3) 1 >>> count_exceedances([60, 61, 59, 60, 58], 70, 2) 0 >>> count_exceedances([80, 81, 82, 83, 84], 75, 2) 4","solution":"from typing import List def count_exceedances(temperature_readings: List[int], threshold: int, duration: int) -> int: Counts the number of times the temperature exceeds the threshold for at least the given number of consecutive minutes. :param temperature_readings: List of temperature readings. :param threshold: The temperature threshold. :param duration: Number of consecutive minutes to consider. :return: The number of exceedances. if len(temperature_readings) < duration: return 0 exceedances_count = 0 consecutive_count = 0 for i in range(len(temperature_readings)): if temperature_readings[i] > threshold: consecutive_count += 1 if consecutive_count >= duration: exceedances_count += 1 else: consecutive_count = 0 return exceedances_count"},{"question":"from typing import List def transpose_and_sum(matrix: List[List[int]]) -> int: Transposes a given 2D matrix and then calculates the sum of all elements in the transposed matrix. Parameters: matrix (List[List[int]]): A 2D list of integers, representing the matrix to be transposed. Returns: int: The sum of all elements in the transposed matrix. Raises: ValueError: If the input matrix is not rectangular (i.e., all rows are not of the same length). >>> transpose_and_sum([[1, 2], [3, 4], [5, 6]]) 21 >>> transpose_and_sum([[1, 2, 3], [4, 5, 6]]) 21 >>> transpose_and_sum([[7]]) 7 >>> transpose_and_sum([[]]) Traceback (most recent call last): ... ValueError: matrix cannot be empty or contain empty rows >>> transpose_and_sum([[1, 2, 3], [4, 5]]) Traceback (most recent call last): ... ValueError: all rows must be of the same length import pytest def test_transpose_and_sum_regular_case(): assert transpose_and_sum([[1, 2], [3, 4], [5, 6]]) == 21 assert transpose_and_sum([[1, 2, 3], [4, 5, 6]]) == 21 def test_transpose_and_sum_single_element(): assert transpose_and_sum([[7]]) == 7 def test_transpose_and_sum_empty_rows(): with pytest.raises(ValueError, match=\\"matrix cannot be empty or contain empty rows\\"): transpose_and_sum([[]]) def test_transpose_and_sum_non_rectangular(): with pytest.raises(ValueError, match=\\"all rows must be of the same length\\"): transpose_and_sum([[1, 2, 3], [4, 5]]) def test_transpose_and_sum_edge_cases(): assert transpose_and_sum([[1]]) == 1 assert transpose_and_sum([[1, 2], [3, 4]]) == 10","solution":"from typing import List def transpose_and_sum(matrix: List[List[int]]) -> int: This function transposes a given 2D matrix and then calculates the sum of all elements in the transposed matrix. Parameters: matrix (List[List[int]]): A 2D list of integers, representing the matrix to be transposed. Returns: int: The sum of all elements in the transposed matrix. Raises: ValueError: If the input matrix is not rectangular (i.e., all rows are not of the same length). # Check for empty matrix or empty rows if not matrix or not all(matrix): raise ValueError(\\"matrix cannot be empty or contain empty rows\\") row_length = len(matrix[0]) # Validate that all rows are of the same length if not all(len(row) == row_length for row in matrix): raise ValueError(\\"all rows must be of the same length\\") # Perform the transpose operation using a list comprehension transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(row_length)] # Calculate the sum of all elements in the transposed matrix return sum(sum(row) for row in transposed)"},{"question":"from typing import List class RangeMinQuery: def __init__(self, nums: List[int]): Initialize the Range Min Query with nums. def update(self, index: int, value: int): Update the element at index to value. def min_query(self, left: int, right: int) -> int: Return the minimum value in the range [left, right], inclusive. >>> rmq = RangeMinQuery([1, 3, 2, 7, 9, 11]) >>> rmq.min_query(1, 4) 2 >>> rmq.update(3, 0) >>> rmq.min_query(1, 4) 0","solution":"class RangeMinQuery: def __init__(self, nums): Initialize the Range Min Query with nums. self.n = len(nums) self.tree = [0] * (2 * self.n) self.build(nums) def build(self, nums): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = nums[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): # Set value at position p p = index + self.n self.tree[p] = value # Move upward and update parents while p > 1: p //= 2 self.tree[p] = min(self.tree[2 * p], self.tree[2 * p + 1]) def min_query(self, left, right): # get minimum value in range [left, right) res = float('inf') l, r = left + self.n, right + 1 + self.n while l < r: # If l is a right node, bring the value and move to parent's right node if l % 2: res = min(res, self.tree[l]) l += 1 # If r is a right node, bring the value of the left node and move to parent if r % 2: r -= 1 res = min(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"from collections import deque from typing import List def reverse_k_elements(queue: List[int], k: int) -> List[int]: Reverses the first k elements of the queue represented by a list. Args: queue (List[int]): The list representing the queue. k (int): The number of elements to reverse from the front of the queue. Returns: List[int]: The list with the first k elements reversed. >>> reverse_k_elements([1, 2, 3, 4, 5], 3) [3, 2, 1, 4, 5] >>> reverse_k_elements([10, 20, 30, 40, 50], 2) [20, 10, 30, 40, 50] >>> reverse_k_elements([5, 6, 7, 8, 9, 10], 6) [10, 9, 8, 7, 6, 5] >>> reverse_k_elements([100], 1) [100] >>> reverse_k_elements([1, 2], 1) [1, 2]","solution":"from collections import deque from typing import List def reverse_k_elements(queue: List[int], k: int) -> List[int]: Reverses the first k elements of the queue represented by a list. Args: queue (List[int]): The list representing the queue. k (int): The number of elements to reverse from the front of the queue. Returns: List[int]: The list with the first k elements reversed. if k <= 0 or k > len(queue): raise ValueError(\\"k must be between 1 and the length of the queue inclusive\\") # Utilize deque for efficient operations dq = deque(queue[:k]) dq.reverse() # Return the concatenated list with the reversed part and the remaining part return list(dq) + queue[k:]"},{"question":"def manage_inventory(transactions: list[tuple[str, int]]) -> dict: Returns the final inventory of books. >>> manage_inventory([(\\"Harry Potter\\", 10), (\\"The Hobbit\\", 5), (\\"Harry Potter\\", -3), (\\"The Hobbit\\", 2), (\\"The Alchemist\\", 7), (\\"Harry Potter\\", -2), (\\"The Alchemist\\", -1)]) {'Harry Potter': 5, 'The Hobbit': 7, 'The Alchemist': 6} >>> manage_inventory([(\\"Inferno\\", 8), (\\"To Kill a Mockingbird\\", 3), (\\"Inferno\\", -2), (\\"To Kill a Mockingbird\\", -1), (\\"1984\\", 6), (\\"Inferno\\", -6), (\\"1984\\", 2), (\\"Inferno\\", 5)]) {'Inferno': 5, 'To Kill a Mockingbird': 2, '1984': 8}","solution":"def manage_inventory(transactions: list[tuple[str, int]]) -> dict: Returns the final inventory of books. inventory = {} for book, change in transactions: if book in inventory: inventory[book] += change else: inventory[book] = change return inventory"},{"question":"def is_perfect_square(number: int) -> bool: Return True if this number is a perfect square or False otherwise. >>> is_perfect_square(1) True >>> is_perfect_square(2) False >>> is_perfect_square(4) True >>> is_perfect_square(10) False >>> is_perfect_square(16) True >>> is_perfect_square(25) True >>> is_perfect_square(-4) Traceback (most recent call last): ... ValueError: number must be positive >>> is_perfect_square(2.5) Traceback (most recent call last): ... TypeError: number must be an integer","solution":"def is_perfect_square(number: int) -> bool: Return True if this number is a perfect square or False otherwise. if not isinstance(number, int): raise TypeError(\\"number must be an integer\\") if number <= 0: raise ValueError(\\"number must be positive\\") left, right = 1, number while left <= right: mid = (left + right) // 2 mid_squared = mid * mid if mid_squared == number: return True elif mid_squared < number: left = mid + 1 else: right = mid - 1 return False"},{"question":"import numpy as np class Individual: def __init__(self, x, y): self.x = x self.y = y self.fitness = None class Population: def __init__(self, size): self.individuals = [Individual(np.random.uniform(-10, 10), np.random.uniform(-10, 10)) for _ in range(size)] class GeneticAlgorithm: def __init__(self, population_size=50, generations=100, crossover_rate=0.7, mutation_rate=0.01): self.population = Population(population_size) self.generations = generations self.crossover_rate = crossover_rate self.mutation_rate = mutation_rate def fitness_function(self, individual): Calculate the fitness of an individual. :param individual: Individual, the individual whose fitness is to be calculated. :return: float, the fitness score. x, y = individual.x, individual.y return np.sin(x) * np.cos(y) + np.cos(x) * np.sin(y) def selection(self): Select individuals from the population based on their fitness. :return: List of Individuals selected. pass def crossover(self, parent1, parent2): Perform crossover between two parents to produce an offspring. :param parent1: Individual, the first parent. :param parent2: Individual, the second parent. :return: Individual, the offspring. pass def mutate(self, individual): Perform mutation on an individual. :param individual: Individual, the individual to be mutated. pass def generate_new_population(self): Generate a new population using selection, crossover, and mutation. pass def run(self): Run the genetic algorithm for the specified number of generations. for _ in range(self.generations): self.generate_new_population() best_individual = max(self.population.individuals, key=self.fitness_function) return best_individual def test_genetic_algorithm(): Test function for Genetic Algorithm. ga = GeneticAlgorithm() best_individual = ga.run() print(f\\"Best Individual: x = {best_individual.x}, y = {best_individual.y}, fitness = {best_individual.fitness}\\") # Uncomment to test # test_genetic_algorithm()","solution":"import numpy as np class Individual: def __init__(self, x, y): self.x = x self.y = y self.fitness = None class Population: def __init__(self, size): self.individuals = [Individual(np.random.uniform(-10, 10), np.random.uniform(-10, 10)) for _ in range(size)] class GeneticAlgorithm: def __init__(self, population_size=50, generations=100, crossover_rate=0.7, mutation_rate=0.01): self.population = Population(population_size) self.generations = generations self.crossover_rate = crossover_rate self.mutation_rate = mutation_rate def fitness_function(self, individual): Calculate the fitness of an individual. :param individual: Individual, the individual whose fitness is to be calculated. :return: float, the fitness score. x, y = individual.x, individual.y return np.sin(x) * np.cos(y) + np.cos(x) * np.sin(y) def selection(self): Select individuals from the population based on their fitness. :return: List of Individuals selected. sorted_individuals = sorted(self.population.individuals, key=self.fitness_function, reverse=True) return sorted_individuals[:len(sorted_individuals)//2] def crossover(self, parent1, parent2): Perform crossover between two parents to produce an offspring. :param parent1: Individual, the first parent. :param parent2: Individual, the second parent. :return: Individual, the offspring. if np.random.rand() > self.crossover_rate: return parent1 alpha = np.random.rand() x = alpha * parent1.x + (1 - alpha) * parent2.x y = alpha * parent1.y + (1 - alpha) * parent2.y return Individual(x, y) def mutate(self, individual): Perform mutation on an individual. :param individual: Individual, the individual to be mutated. if np.random.rand() < self.mutation_rate: individual.x += np.random.normal() individual.y += np.random.normal() def generate_new_population(self): Generate a new population using selection, crossover, and mutation. new_population = [] selected_individuals = self.selection() while len(new_population) < len(self.population.individuals): parent1, parent2 = np.random.choice(selected_individuals, 2) offspring = self.crossover(parent1, parent2) self.mutate(offspring) new_population.append(offspring) self.population.individuals = new_population def run(self): Run the genetic algorithm for the specified number of generations. for _ in range(self.generations): self.generate_new_population() best_individual = max(self.population.individuals, key=self.fitness_function) best_individual.fitness = self.fitness_function(best_individual) return best_individual def test_genetic_algorithm(): Test function for Genetic Algorithm. ga = GeneticAlgorithm() best_individual = ga.run() print(f\\"Best Individual: x = {best_individual.x}, y = {best_individual.y}, fitness = {best_individual.fitness}\\") # Uncomment to test # test_genetic_algorithm()"},{"question":"from typing import List def combination_sum(nums: List[int], target: int) -> List[List[int]]: Given an integer array \`nums\` sorted in non-decreasing order, return a list of unique combinations that sum up to a target value \`target\`. Each number in \`nums\` may be used as many times as needed. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([2], 1) [] def test_combination_sum(): # Basic test cases assert combination_sum([2, 3, 6, 7], 7) == [[2, 2, 3], [7]] assert combination_sum([2, 3, 5], 8) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]] assert combination_sum([2], 1) == [] # Edge cases assert combination_sum([1], 1) == [[1]] assert combination_sum([1], 2) == [[1, 1]] # More complex case assert combination_sum([2, 3, 5, 7], 10) == [[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 3, 5], [3, 7], [5, 5]] # Larger numbers assert combination_sum([5, 10, 12], 15) == [[5, 5, 5], [5, 10]] # No combination assert combination_sum([3, 4, 5], 2) == [] test_combination_sum()","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> List[List[int]]: result = [] def backtrack(remaining, path, start): if remaining == 0: result.append(list(path)) return elif remaining < 0: return for i in range(start, len(nums)): path.append(nums[i]) backtrack(remaining - nums[i], path, i) path.pop() backtrack(target, [], 0) return result"},{"question":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float, radius: float) -> float: Function to calculate the Great Circle Distance between two points on a sphere given their latitude and longitude. Parameters: - lat1, lon1: Latitude and Longitude of the first point. - lat2, lon2: Latitude and Longitude of the second point. - radius: Radius of the sphere. Returns: - Great Circle Distance as a float. Raises: - ValueError if latitude or longitude are out of the specified range or if radius is non-positive. Example usage: >>> great_circle_distance(36.12, -86.67, 33.94, -118.40, 6371) 2887.26 (approx) >>> great_circle_distance(-91, 0, 0, 0, 6371) Raises ValueError with message \\"Latitude must be within the range of -90 to 90.\\" >>> great_circle_distance(0, 0, 0, 0, -1) Raises ValueError with message \\"Radius must be a positive value.\\"","solution":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float, radius: float) -> float: Function to calculate the Great Circle Distance between two points on a sphere given their latitude and longitude. Parameters: - lat1, lon1: Latitude and Longitude of the first point. - lat2, lon2: Latitude and Longitude of the second point. - radius: Radius of the sphere. Returns: - Great Circle Distance as a float. Raises: - ValueError if latitude or longitude are out of the specified range or if radius is non-positive. # Validate latitude and longitude if not (-90 <= lat1 <= 90): raise ValueError(\\"Latitude must be within the range of -90 to 90.\\") if not (-90 <= lat2 <= 90): raise ValueError(\\"Latitude must be within the range of -90 to 90.\\") if not (-180 <= lon1 <= 180): raise ValueError(\\"Longitude must be within the range of -180 to 180.\\") if not (-180 <= lon2 <= 180): raise ValueError(\\"Longitude must be within the range of -180 to 180.\\") # Validate radius if radius <= 0: raise ValueError(\\"Radius must be a positive value.\\") # Convert degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Distance in the same units as radius distance = radius * c return distance"},{"question":"class KeyValueStore: def __init__(self): Initialize the in-memory key-value store. # Your implementation here def set(self, key: str, value: any) -> None: Sets the value for a given key in the key-value store. Parameters: key (str): The key for the value. value (Any): The value to be associated with the key. # Your implementation here def get(self, key: str) -> any: Retrieves the value associated with the given key. Parameters: key (str): The key whose value is to be retrieved. Returns: Any: The value associated with the key, or None if the key does not exist. # Your implementation here def update(self, key: str, value: any) -> None: Updates the value for an existing key in the key-value store. Parameters: key (str): The key for which the value is to be updated. value (Any): The new value to be associated with the key. Raises: KeyError: If the key does not exist in the store. # Your implementation here def delete(self, key: str) -> None: Deletes the key-value pair corresponding to the given key from the store. Parameters: key (str): The key to be deleted from the store. Raises: KeyError: If the key does not exist in the store. # Your implementation here","solution":"class KeyValueStore: def __init__(self): self.store = {} def set(self, key: str, value: any) -> None: self.store[key] = value def get(self, key: str) -> any: return self.store.get(key) def update(self, key: str, value: any) -> None: if key in self.store: self.store[key] = value else: raise KeyError(f\\"Key '{key}' not found in the store\\") def delete(self, key: str) -> None: if key in self.store: del self.store[key] else: raise KeyError(f\\"Key '{key}' not found in the store\\")"},{"question":"from typing import List, Optional class Book: def __init__(self, id: int, title: str, author: str, copies: int): self.id = id self.title = title self.author = author self.copies = copies def __repr__(self) -> str: return f\\"Book({self.id}, {self.title}, {self.author}, {self.copies})\\" class Library: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: Adds a new book to the library inventory. >>> library = Library() >>> book = Book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3) >>> library.add_book(book) >>> len(library.books) == 1 pass def find_book_by_title(self, title: str) -> Optional[Book]: Finds and returns a book by its title. If the book is not found, returns None. >>> library = Library() >>> book = Book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3) >>> library.add_book(book) >>> library.find_book_by_title(\\"To Kill a Mockingbird\\") == book >>> library.find_book_by_title(\\"1984\\") == None pass def check_out_book(self, id: int) -> bool: Checks out a book by its identification number. If the book is available (i.e., has at least one copy left), reduces the number of copies by one and returns True. If the book is not available or not found, returns False. >>> library = Library() >>> book = Book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3) >>> library.add_book(book) >>> library.check_out_book(1) == True >>> library.find_book_by_title(\\"To Kill a Mockingbird\\").copies == 2 >>> library.check_out_book(2) == False pass","solution":"from typing import List, Optional class Book: def __init__(self, id: int, title: str, author: str, copies: int): self.id = id self.title = title self.author = author self.copies = copies def __repr__(self) -> str: return f\\"Book({self.id}, {self.title}, {self.author}, {self.copies})\\" class Library: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: self.books.append(book) def find_book_by_title(self, title: str) -> Optional[Book]: for book in self.books: if book.title == title: return book return None def check_out_book(self, id: int) -> bool: for book in self.books: if book.id == id: if book.copies > 0: book.copies -= 1 return True else: return False return False"},{"question":"class TopologicalSort: This class implements topological sorting for a directed acyclic graph (DAG) using Depth-First Search (DFS) method. Attributes: graph (dict): The adjacency list representing the DAG. Methods: dfs(node, visited, stack): Performs a DFS from the given node. topo_sort(): Returns the nodes in topologically sorted order. def __init__(self, graph: dict[str, list[str]]) -> None: ... def dfs(self, node: str, visited: set[str], stack: list[str]) -> None: ... def topo_sort(self) -> list[str]: ... def test_topo_sort_basic(): graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } t = TopologicalSort(graph) result = t.topo_sort() assert result in [[\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], [\\"A\\", \\"C\\", \\"B\\", \\"D\\", \\"E\\"]] def test_topo_sort_single_node(): graph = { \\"A\\": [] } t = TopologicalSort(graph) result = t.topo_sort() assert result == [\\"A\\"] def test_topo_sort_disconnected(): graph = { \\"A\\": [\\"B\\"], \\"C\\": [\\"D\\"], \\"B\\": [\\"E\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } t = TopologicalSort(graph) result = t.topo_sort() assert result in [ [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], [\\"C\\", \\"D\\", \\"A\\", \\"B\\", \\"E\\"] ] def test_topo_sort_large(): graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"D\\", \\"E\\"], \\"D\\": [\\"F\\"], \\"E\\": [\\"F\\"], \\"F\\": [\\"G\\"], \\"G\\": [] } t = TopologicalSort(graph) result = t.topo_sort() assert result == [\\"A\\", \\"C\\", \\"E\\", \\"B\\", \\"D\\", \\"F\\", \\"G\\"] or result == [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\", \\"G\\"]","solution":"class TopologicalSort: def __init__(self, graph: dict[str, list[str]]) -> None: self.graph = graph def dfs(self, node: str, visited: set[str], stack: list[str]) -> None: visited.add(node) for neighbor in self.graph.get(node, []): if neighbor not in visited: self.dfs(neighbor, visited, stack) stack.append(node) def topo_sort(self) -> list[str]: visited = set() stack = [] for node in self.graph: if node not in visited: self.dfs(node, visited, stack) stack.reverse() return stack"},{"question":"import numpy as np import pandas as pd from urllib.request import urlopen def collect_dataset() -> np.matrix: Download and return the dataset as a matrix. >>> data = collect_dataset() >>> data.shape (150, 4) pass def euclidean_distance(point1: np.array, point2: np.array) -> float: Calculate the Euclidean distance between two data points. >>> point1 = np.array([1, 2]) >>> point2 = np.array([4, 6]) >>> np.isclose(euclidean_distance(point1, point2), 5.0) True pass def assign_clusters(data: np.matrix, centroids: np.matrix) -> np.array: Assign each data point to the nearest cluster center. >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> centroids = np.array([[1, 2], [5, 6]]) >>> assign_clusters(data, centroids) array([0, 0, 1]) pass def update_centroids(data: np.matrix, clusters: np.array, k: int) -> np.matrix: Compute the new centroid positions based on the current cluster assignments. >>> data = np.array([[1, 2], [2, 3], [4, 5], [5, 6]]) >>> clusters = np.array([0, 0, 1, 1]) >>> update_centroids(data, clusters, 2) array([[1.5, 2.5], [4.5, 5.5]]) pass def compute_wcss(data: np.matrix, clusters: np.array, centroids: np.matrix) -> float: Calculate the within-cluster sum of squares. >>> data = np.array([[1, 2], [2, 3], [4, 5], [5, 6]]) >>> clusters = np.array([0, 0, 1, 1]) >>> centroids = np.array([[1.5, 2.5], [4.5, 5.5]]) >>> np.isclose(compute_wcss(data, clusters, centroids), 2.0) True pass def run_k_means(data: np.matrix, k: int, max_iters: int) -> Tuple[np.matrix, float]: Integrate all functions to perform the K-Means algorithm. >>> data = collect_dataset() >>> k = 3 >>> max_iters = 100 >>> centroids, wcss = run_k_means(data, k, max_iters) >>> centroids.shape (3, 4) >>> wcss >= 0 True pass","solution":"import numpy as np import pandas as pd from urllib.request import urlopen def collect_dataset(): url = \\"https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv\\" df = pd.read_csv(url) data = df.drop(columns=['species']).values return data def euclidean_distance(point1, point2): return np.sqrt(np.sum((point1 - point2) ** 2)) def assign_clusters(data, centroids): clusters = [] for point in data: distances = [euclidean_distance(point, centroid) for centroid in centroids] clusters.append(np.argmin(distances)) return np.array(clusters) def update_centroids(data, clusters, k): new_centroids = [] for i in range(k): cluster_points = data[clusters == i] if len(cluster_points) > 0: new_centroid = np.mean(cluster_points, axis=0) else: new_centroid = data[np.random.randint(0, data.shape[0])] new_centroids.append(new_centroid) return np.array(new_centroids) def compute_wcss(data, clusters, centroids): wcss = 0 for i, point in enumerate(data): centroid = centroids[clusters[i]] wcss += euclidean_distance(point, centroid) ** 2 return wcss def run_k_means(data, k, max_iters=100): n_samples, n_features = data.shape centroids = data[np.random.choice(n_samples, k, replace=False)] for _ in range(max_iters): clusters = assign_clusters(data, centroids) new_centroids = update_centroids(data, clusters, k) if np.all(centroids == new_centroids): break centroids = new_centroids wcss = compute_wcss(data, clusters, centroids) return centroids, wcss"},{"question":"from typing import List, Tuple def find_path_with_obstacles(grid: List[List[int]]) -> List[Tuple[int, int]]: Find the shortest path from the top-left corner to the bottom-right corner of a 2D grid, avoiding obstacles. >>> find_path_with_obstacles([ ... [0, 0, 0, 1], ... [1, 0, 1, 0], ... [0, 0, 0, 0], ... [1, 1, 0, 0] ... ]) [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3)] >>> find_path_with_obstacles([[0, 1, 1], [1, 1, 1], [1, 1, 0]]) == [] >>> find_path_with_obstacles([]) == [] >>> find_path_with_obstacles([[0]]) == [(0, 0)]","solution":"from typing import List, Tuple from collections import deque def find_path_with_obstacles(grid: List[List[int]]) -> List[Tuple[int, int]]: if not grid or not grid[0]: return [] rows, cols = len(grid), len(grid[0]) start, end = (0, 0), (rows - 1, cols - 1) if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return [] # Direction vectors for moving in 4 directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue for BFS: stores (current_position, path_taken) queue = deque([(start, [start])]) visited = set([start]) while queue: (curr_x, curr_y), path = queue.popleft() if (curr_x, curr_y) == end: return path for dx, dy in directions: next_x, next_y = curr_x + dx, curr_y + dy if 0 <= next_x < rows and 0 <= next_y < cols and grid[next_x][next_y] == 0: next_position = (next_x, next_y) if next_position not in visited: visited.add(next_position) queue.append((next_position, path + [next_position])) return []"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in-place. >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix1) >>> matrix1 [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix2 = [ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix2) >>> matrix2 [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] pass","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def flatten_list(nested_list): Flattens a nested list of integers, maintaining the order of elements. Args: nested_list (list): The input list containing nested lists of integers. Returns: list: A flattened list of integers. Raises: TypeError: If any elements in the nested lists are not integers. Examples: >>> flatten_list([1, [2, 3], [[4, 5], 6], 7]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_list([1, [2, [3, [4, [5]]]]]) [1, 2, 3, 4, 5] >>> flatten_list([3, [2, [1, 0], -1], [-2]]) [3, 2, 1, 0, -1, -2] >>> flatten_list([4, [5, 6, [7, 8]], [9]]) [4, 5, 6, 7, 8, 9] >>> flatten_list([[1, 2, [3, 4]], 5]) [1, 2, 3, 4, 5]","solution":"def flatten_list(nested_list): Flattens a nested list of integers, maintaining the order of elements. Args: nested_list (list): The input list containing nested lists of integers. Returns: list: A flattened list of integers. Raises: TypeError: If any elements in the nested lists are not integers. def flatten_helper(lst): for item in lst: if isinstance(item, list): yield from flatten_helper(item) elif isinstance(item, int): yield item else: raise TypeError(\\"All elements must be integers within the nested lists\\") return list(flatten_helper(nested_list))"},{"question":"def longest_common_subarray( list_a: list[int], list_b: list[int] ) -> list[int]: Finds the longest common contiguous subarray between two given lists of integers. If there are multiple subarrays with the same maximum length, return any one of them. :param list_a: A non-empty list of integers. :param list_b: A non-empty list of integers. :return: A list of integers representing the longest common subarray or an empty list if no common subarray exists. Examples: >>> longest_common_subarray([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) [3, 4, 5] >>> longest_common_subarray([1, 2, 3, 4, 5, 6], [4, 5, 6, 7, 8, 9]) [4, 5, 6] >>> longest_common_subarray([1, 2, 3, 4, 2, 3, 4, 5], [2, 3, 4, 5, 6, 7]) [2, 3, 4, 5] >>> longest_common_subarray([1, 2, 3], [4, 5, 6]) [] pass","solution":"def longest_common_subarray(list_a, list_b): Finds the longest common contiguous subarray between two given lists of integers. n, m = len(list_a), len(list_b) max_length = 0 end_idx = 0 # Create a (n+1)x(m+1) DP table filled with 0s dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if list_a[i - 1] == list_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 # Track the maximum length and ending index if dp[i][j] > max_length: max_length = dp[i][j] end_idx = i # Extract the longest common subarray if max_length == 0: return [] else: return list_a[end_idx - max_length:end_idx]"},{"question":"def flatten_array(nested_list: list) -> list[int]: Flattens a nested list into a single list of integers. >>> flatten_array([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_array([1, [2, 3], [[4, 5], 6], 7]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_array([[1, 2], [3, [4, [5, 6]]], 7]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_array([[[[1, 2, 3]]], 4, [5, [6, 7]]]) [1, 2, 3, 4, 5, 6, 7]","solution":"def flatten_array(nested_list: list) -> list[int]: Flattens a nested list into a single list of integers. flattened = [] def flatten(lst): for item in lst: if isinstance(item, list): flatten(item) else: flattened.append(item) flatten(nested_list) return flattened"},{"question":"from typing import List def longest_stable_period(sales: List[int], d: int) -> int: Find the length of the longest stable period in sales array where the difference between the maximum and minimum values in any subarray is less than or equal to d. Parameters: sales (List[int]): List of monthly sales figures. d (int): Maximum allowed difference in sales to be considered stable. Returns: int: Length of the longest stable period. Examples: >>> longest_stable_period([10, 12, 14, 18, 19, 20, 10, 8], 2) 3 >>> longest_stable_period([5, 5, 5, 5, 5], 0) 5 >>> longest_stable_period([7, 10, 5, 7, 6, 8, 9], 3) 4","solution":"from typing import List from collections import deque def longest_stable_period(sales: List[int], d: int) -> int: Find the length of the longest stable period in sales array where the difference between the maximum and minimum values in any subarray is less than or equal to d. n = len(sales) if n == 0: return 0 min_deque = deque() max_deque = deque() left = 0 max_length = 0 for right in range(n): while min_deque and sales[right] < sales[min_deque[-1]]: min_deque.pop() while max_deque and sales[right] > sales[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while sales[max_deque[0]] - sales[min_deque[0]] > d: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Dict class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, genre: str) -> None: Add a book to the library collection. :param title: A string representing the title of the book. :param author: A string representing the author of the book. :param genre: A string representing the genre of the book. pass def search_books(self, **criteria) -> List[Dict]: Search for books in the library collection. :param criteria: Keyword arguments that can include 'title', 'author', and/or 'genre'. :return: A list of dictionaries where each dictionary represents a book that matches the search criteria. Examples: >>> library = Library() >>> library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Fiction\\") >>> library.add_book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\") >>> library.search_books(title=\\"1984\\") [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\"}] >>> library.search_books(genre=\\"Fiction\\") [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Fiction\\"}] >>> library.search_books() [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\"} ] pass","solution":"from typing import List, Dict class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, genre: str) -> None: book = {\\"title\\": title, \\"author\\": author, \\"genre\\": genre} self.books.append(book) def search_books(self, **criteria) -> List[Dict]: results = self.books for key, value in criteria.items(): results = [book for book in results if book.get(key) == value] return results"},{"question":"from typing import List, Dict def longest_words(sentences: List[str]) -> Dict[int, str]: Identify the longest word from each sentence and return a dictionary where the key is the index of the sentence and the value is the longest word in that sentence. >>> longest_words([\\"I love programming\\"]) {0: \\"programming\\"} >>> longest_words([ \\"I love programming\\", \\"Python is great\\", \\"Find the longest word in each sentence\\" ]) {0: \\"programming\\", 1: \\"Python\\", 2: \\"sentence\\"} >>> longest_words([\\"cat bat rat\\"]) {0: \\"cat\\"} >>> longest_words([\\"hello\\", \\"world\\", \\"python\\"]) {0: \\"hello\\", 1: \\"world\\", 2: \\"python\\"} >>> longest_words([]) {} >>> longest_words([ \\"short sentence\\", \\"a much longer sentence indeed\\", \\"tiny\\", \\"a b c d e f\\" ]) {0: \\"sentence\\", 1: \\"sentence\\", 2: \\"tiny\\", 3: \\"a\\"} >>> sentences = [\\"a \\" * 1000 + \\"longestword\\"] * 10000 >>> expected_output = {i: \\"longestword\\" for i in range(10000)} >>> longest_words(sentences) == expected_output True","solution":"from typing import List, Dict def longest_words(sentences: List[str]) -> Dict[int, str]: Function to identify the longest word from each sentence and return a dictionary where the key is the index of the sentence and the value is the longest word in that sentence. Parameters: sentences (List[str]): A list of sentences. Returns: Dict[int, str]: A dictionary mapping sentence index to its longest word. result = {} for i, sentence in enumerate(sentences): words = sentence.split() longest_word = max(words, key=len, default=\\"\\") result[i] = longest_word return result"},{"question":"import numpy as np class SimpleConvolutionalNeuralNetwork: def __init__(self, num_filters: int, filter_size: int, pool_size: int): Initialize the CNN with the specified number of filters, filter size for the convolutional layer, and pool size for the max-pooling layer. Parameters: - num_filters: int, number of convolutional filters. - filter_size: int, size of the convolutional filters. - pool_size: int, size of the pooling window. self.num_filters = num_filters self.filter_size = filter_size self.pool_size = pool_size self.filters = [np.random.randn(filter_size, filter_size) for _ in range(num_filters)] def convolve(self, image: np.ndarray, filter: np.ndarray) -> np.ndarray: Perform convolution on the input image using the given filter. Parameters: - image: np.ndarray, input image represented as a 2D array. - filter: np.ndarray, 2D array of size (filter_size, filter_size). Returns: - np.ndarray, convolved feature map. pass def max_pool(self, feature_map: np.ndarray, pool_size: int) -> np.ndarray: Perform max-pooling on the feature map using the given pool size. Parameters: - feature_map: np.ndarray, feature map obtained after convolution. - pool_size: int, size of the max-pooling window. Returns: - np.ndarray, pooled feature map. pass def forward(self, image: np.ndarray) -> np.ndarray: Perform a forward pass of the CNN on the input image, applying convolution followed by max-pooling. Parameters: - image: np.ndarray, input image represented as a 2D array. Returns: - np.ndarray, the feature maps after applying convolution and max-pooling. pass if __name__ == \\"__main__\\": # Sample image (3x3) for demonstration purposes sample_image = np.array([[1, 2, 1], [2, 1, 0], [1, 0, 2]]) # Initialize the CNN model cnn = SimpleConvolutionalNeuralNetwork(num_filters=1, filter_size=2, pool_size=2) # Perform forward pass on the sample image output = cnn.forward(sample_image) print(\\"Output feature map after forward pass:n\\", output)","solution":"import numpy as np class SimpleConvolutionalNeuralNetwork: def __init__(self, num_filters: int, filter_size: int, pool_size: int): self.num_filters = num_filters self.filter_size = filter_size self.pool_size = pool_size # Randomly initialize filters self.filters = [np.random.randn(filter_size, filter_size) for _ in range(num_filters)] def convolve(self, image: np.ndarray, filter: np.ndarray) -> np.ndarray: image_height, image_width = image.shape filter_height, filter_width = filter.shape output_height = image_height - filter_height + 1 output_width = image_width - filter_width + 1 output = np.zeros((output_height, output_width)) for i in range(output_height): for j in range(output_width): region = image[i:i + filter_height, j:j + filter_width] output[i, j] = np.sum(region * filter) return output def max_pool(self, feature_map: np.ndarray, pool_size: int) -> np.ndarray: fm_height, fm_width = feature_map.shape output_height = fm_height // pool_size output_width = fm_width // pool_size output = np.zeros((output_height, output_width)) for i in range(output_height): for j in range(output_width): region = feature_map[i * pool_size:(i + 1) * pool_size, j * pool_size:(j + 1) * pool_size] output[i, j] = np.max(region) return output def forward(self, image: np.ndarray) -> np.ndarray: features = [] for filter in self.filters: convolved = self.convolve(image, filter) pooled = self.max_pool(convolved, self.pool_size) features.append(pooled) return np.array(features) if __name__ == \\"__main__\\": # Sample image (3x3) for demonstration purposes sample_image = np.array([[1, 2, 1], [2, 1, 0], [1, 0, 2]]) # Initialize the CNN model cnn = SimpleConvolutionalNeuralNetwork(num_filters=1, filter_size=2, pool_size=2) # Perform forward pass on the sample image output = cnn.forward(sample_image) print(\\"Output feature map after forward pass:n\\", output)"},{"question":"def is_fibonacci_like(arr: list[int]) -> bool: Check if an array is a Fibonacci-like sequence. Args: arr (list[int]): The input array of integers. Returns: bool: True if the sequence is Fibonacci-like, False otherwise. >>> is_fibonacci_like([1, 1, 2, 3, 5, 8]) True >>> is_fibonacci_like([2, 4, 6, 10, 16]) False >>> is_fibonacci_like([0, 1, 1, 2, 3, 5, 8]) True # Unit Test def test_is_fibonacci_like_true(): assert is_fibonacci_like([1, 1, 2, 3, 5, 8]) == True assert is_fibonacci_like([0, 1, 1, 2, 3, 5, 8, 13]) == True def test_is_fibonacci_like_false(): assert is_fibonacci_like([2, 4, 6, 10, 15]) == False assert is_fibonacci_like([1, 2, 4]) == False def test_is_fibonacci_like_edge_cases(): assert is_fibonacci_like([]) == False assert is_fibonacci_like([1]) == False assert is_fibonacci_like([1, 2]) == False assert is_fibonacci_like([1, 1, 2]) == True assert is_fibonacci_like([2, 3, 5, 8, 13, 21]) == True","solution":"def is_fibonacci_like(arr: list[int]) -> bool: Check if an array is a Fibonacci-like sequence. Args: arr (list[int]): The input array of integers. Returns: bool: True if the sequence is Fibonacci-like, False otherwise. if len(arr) < 3: return False for i in range(2, len(arr)): if arr[i] != arr[i-1] + arr[i-2]: return False return True"},{"question":"class IntervalManager: Data structure to manage intervals and query overlapping intervals with a given time point. def __init__(self): Initializes the data structure. pass def add_interval(self, start: int, end: int) -> None: Adds a new interval with start and end times (inclusive). Args: start (int): The start time of the interval. end (int): The end time of the interval (inclusive). pass def count_overlapping_intervals(self, time: int) -> int: Returns the number of intervals that overlap with the given time. Args: time (int): The time point to query overlapping intervals. Returns: int: The number of overlapping intervals. Examples: >>> manager = IntervalManager() >>> manager.add_interval(1, 5) >>> manager.add_interval(3, 7) >>> manager.add_interval(4, 6) >>> manager.add_interval(8, 10) >>> manager.count_overlapping_intervals(4) 3 >>> manager.count_overlapping_intervals(6) 2 >>> manager.count_overlapping_intervals(8) 1 >>> manager.count_overlapping_intervals(2) 1 pass # Unit tests def test_add_intervals_and_count_overlaps(): manager = IntervalManager() manager.add_interval(1, 5) manager.add_interval(3, 7) manager.add_interval(4, 6) manager.add_interval(8, 10) assert manager.count_overlapping_intervals(4) == 3 assert manager.count_overlapping_intervals(6) == 2 assert manager.count_overlapping_intervals(8) == 1 assert manager.count_overlapping_intervals(2) == 1 assert manager.count_overlapping_intervals(12) == 0 def test_no_intervals(): manager = IntervalManager() assert manager.count_overlapping_intervals(5) == 0 def test_single_interval(): manager = IntervalManager() manager.add_interval(0, 5) assert manager.count_overlapping_intervals(3) == 1 assert manager.count_overlapping_intervals(0) == 1 assert manager.count_overlapping_intervals(5) == 1 assert manager.count_overlapping_intervals(-1) == 0 assert manager.count_overlapping_intervals(6) == 0 def test_large_intervals(): manager = IntervalManager() manager.add_interval(-10**6, 10**6) assert manager.count_overlapping_intervals(0) == 1 assert manager.count_overlapping_intervals(-10**6) == 1 assert manager.count_overlapping_intervals(10**6) == 1","solution":"class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: self.intervals.append((start, end)) def count_overlapping_intervals(self, time: int) -> int: count = 0 for start, end in self.intervals: if start <= time <= end: count += 1 return count"},{"question":"class Inventory: Simulate a basic inventory management system for a store. Allow adding products, updating stock quantities, and querying product availability. def __init__(self): Initializes an empty inventory. pass def add_product(self, product_name: str, quantity: int) -> None: Adds a new product to the inventory with the given initial quantity. >>> inventory = Inventory() >>> inventory.add_product(\\"apple\\", 10) >>> inventory.check_availability(\\"apple\\") 10 >>> inventory.add_product(\\"apple\\", 5) Output: ValueError: Product already exists in inventory >>> inventory.add_product(\\"banana\\", -5) Output: ValueError: Quantity cannot be negative pass def update_stock(self, product_name: str, quantity: int) -> None: Updates the stock quantity of an existing product. >>> inventory = Inventory() >>> inventory.add_product(\\"apple\\", 10) >>> inventory.update_stock(\\"apple\\", 5) >>> inventory.check_availability(\\"apple\\") 5 >>> inventory.update_stock(\\"orange\\", 10) Output: ValueError: Product does not exist in inventory >>> inventory.update_stock(\\"apple\\", -5) Output: ValueError: Quantity cannot be negative pass def check_availability(self, product_name: str) -> int: Returns the current stock quantity of the specified product. >>> inventory = Inventory() >>> inventory.add_product(\\"apple\\", 10) >>> inventory.add_product(\\"banana\\", 20) >>> inventory.check_availability(\\"apple\\") 10 >>> inventory.check_availability(\\"orange\\") 0 pass","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_name: str, quantity: int) -> None: if product_name in self.products: raise ValueError(\\"Product already exists in inventory\\") if quantity < 0: raise ValueError(\\"Quantity cannot be negative\\") self.products[product_name] = quantity def update_stock(self, product_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity cannot be negative\\") if product_name not in self.products: raise ValueError(\\"Product does not exist in inventory\\") self.products[product_name] = quantity def check_availability(self, product_name: str) -> int: return self.products.get(product_name, 0)"},{"question":"[Completion Task in Python] Implement the following functions: 1. fit_knn_model(): This function fits the KNN model with the provided training features, labels, and number of neighbors to consider. def fit_knn_model(features: list[list[float]], labels: list[int], k: int) -> dict: return {'features': features, 'labels': labels, 'k': k} 2. euclidean_distance(): This utility function calculates the Euclidean distance between two points. import math def euclidean_distance(point1: list[float], point2: list[float]) -> float: return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) 3. predict_instances(): This function predicts the class labels for unknown instances using the fitted KNN model. from collections import Counter def predict_instances(unknown_features: list[list[float]], model: dict) -> list[int]: training_features = model['features'] training_labels = model['labels'] k = model['k'] predictions = [] for uf in unknown_features: distances = [(euclidean_distance(uf, tf), label) for tf, label in zip(training_features, training_labels)] sorted_distances = sorted(distances)[:k] k_nearest_labels = [label for _, label in sorted_distances] most_common_label = Counter(k_nearest_labels).most_common(1)[0][0] predictions.append(most_common_label) return predictions 4. calculate_accuracy(): This utility function calculates the accuracy of predictions by comparing predicted labels with actual labels. def calculate_accuracy(actual_labels: list[int], predicted_labels: list[int]) -> float: correct_predictions = sum(a == p for a, p in zip(actual_labels, predicted_labels)) return (correct_predictions / len(actual_labels)) * 100","solution":"import math from collections import Counter def fit_knn_model(features, labels, k): Fits the KNN model with the provided training features and labels. Parameters: features (list[list[float]]): 2D list of feature values for training instances. labels (list[int]): List of labels corresponding to the training instances. k (int): Number of neighbors to consider. Returns: dict: A dictionary containing the training features, labels, and k. return {'features': features, 'labels': labels, 'k': k} def euclidean_distance(point1, point2): Calculates the Euclidean distance between two points. Parameters: point1 (list[float]): First point. point2 (list[float]): Second point. Returns: float: The Euclidean distance between the two points. return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def predict_instances(unknown_features, model): Predicts the class labels for unknown instances using the KNN model. Parameters: unknown_features (list[list[float]]): 2D list of feature values for unknown instances. model (dict): Fitted KNN model containing training features, labels, and k. Returns: list[int]: List of predicted class labels for the unknown instances. training_features = model['features'] training_labels = model['labels'] k = model['k'] predictions = [] for uf in unknown_features: distances = [(euclidean_distance(uf, tf), label) for tf, label in zip(training_features, training_labels)] sorted_distances = sorted(distances)[:k] k_nearest_labels = [label for _, label in sorted_distances] most_common_label = Counter(k_nearest_labels).most_common(1)[0][0] predictions.append(most_common_label) return predictions def calculate_accuracy(actual_labels, predicted_labels): Calculates the accuracy of predictions compared to actual labels. Parameters: actual_labels (list[int]): List of actual class labels. predicted_labels (list[int]): List of predicted class labels. Returns: float: Accuracy percentage of the predictions. correct_predictions = sum(a == p for a, p in zip(actual_labels, predicted_labels)) return (correct_predictions / len(actual_labels)) * 100"},{"question":"import requests class WeatherDataFetcher: BASE_URL = \\"https://api.weatherapi.com/v1\\" API_KEY = \\"your_api_key_here\\" # Replace with your actual API key def fetch_current_temperature(self, city: str) -> float: Fetch the current temperature for a given city. Args: city (str): The city to fetch the temperature for. Returns: float: The current temperature in Celsius. pass def fetch_weekly_forecast(self, city: str) -> dict: Fetch the daily weather forecast for the next seven days for a specified city. Args: city (str): The city to fetch the weather forecast for. Returns: dict: A dictionary with dates as keys and temperatures as values. pass def fetch_extreme_temperatures(self, city: str) -> tuple: Fetch the highest and lowest temperatures recorded in the past 24 hours for a given city. Args: city (str): The city to fetch the extreme temperatures for. Returns: tuple: A tuple containing the highest and lowest temperatures. pass","solution":"import requests from requests.exceptions import RequestException from datetime import datetime, timedelta class WeatherDataFetcher: BASE_URL = \\"https://api.weatherapi.com/v1\\" API_KEY = \\"your_api_key_here\\" # Replace with your actual API key def fetch_current_temperature(self, city: str) -> float: try: response = requests.get(f\\"{self.BASE_URL}/current.json\\", params={\\"key\\": self.API_KEY, \\"q\\": city}) response.raise_for_status() data = response.json() return data['current']['temp_c'] except RequestException: print(f\\"Failed to fetch current temperature for {city}\\") return None def fetch_weekly_forecast(self, city: str) -> dict: try: response = requests.get(f\\"{self.BASE_URL}/forecast.json\\", params={\\"key\\": self.API_KEY, \\"q\\": city, \\"days\\": 7}) response.raise_for_status() data = response.json() forecast = data['forecast']['forecastday'] result = {} for day in forecast: date = day['date'] temp = day['day']['avgtemp_c'] result[date] = temp return result except RequestException: print(f\\"Failed to fetch weekly forecast for {city}\\") return None def fetch_extreme_temperatures(self, city: str) -> tuple: try: # Get current datetime and 24 hours ago datetime now = datetime.utcnow() last_24_hours = now - timedelta(hours=24) response = requests.get(f\\"{self.BASE_URL}/history.json\\", params={\\"key\\": self.API_KEY, \\"q\\": city, \\"dt\\": last_24_hours.strftime('%Y-%m-%d')}) response.raise_for_status() data = response.json() temps = [hourly['temp_c'] for hourly in data['forecast']['forecastday'][0]['hour']] return (max(temps), min(temps)) except RequestException: print(f\\"Failed to fetch extreme temperatures for {city}\\") return None"},{"question":"def validate_ip_address(ip: str) -> bool: Validate if the given string is a valid IPv4 address. :param ip: A string representing the IP address to be validated. :return: True if the IP address is valid; otherwise, False. # Add your code here # Example test cases print(validate_ip_address(\\"192.168.0.1\\")) # True print(validate_ip_address(\\"255.255.255.255\\")) # True print(validate_ip_address(\\"256.100.100.100\\")) # False print(validate_ip_address(\\"192.168.01.1\\")) # False print(validate_ip_address(\\"192.168.0\\")) # False print(validate_ip_address(\\"192.168.0.1.1\\")) # False print(validate_ip_address(\\"abc.def.ghi.jkl\\")) # False","solution":"def validate_ip_address(ip: str) -> bool: Validate if the given string is a valid IPv4 address. :param ip: A string representing the IP address to be validated. :return: True if the IP address is valid; otherwise, False. # Split the IP address by periods parts = ip.split('.') # There should be exactly 4 parts if len(parts) != 4: return False for part in parts: # Part should be a number if not part.isdigit(): return False # Convert part to integer num = int(part) # Validate range if num < 0 or num > 255: return False # Validate no leading zeros, e.g., \\"01\\" if str(num) != part: return False return True"},{"question":"import numpy as np class ImageAnalyzer: def __init__(self, image): self.image = image def average_intensity(self): Calculate the average intensity for each color channel in an image. :return: A dictionary with the average intensity of 'red', 'green', and 'blue' channels. pass def test_average_intensity_basic(): image = np.array([[[125, 200, 75], [100, 150, 200]], [[200, 100, 150], [50, 50, 50]]], dtype=np.uint8) analyzer = ImageAnalyzer(image) result = analyzer.average_intensity() expected = {'red': 118.75, 'green': 125.0, 'blue': 118.75} assert result == expected def test_average_intensity_single_color(): image = np.ones((4, 4, 3), dtype=np.uint8) * 255 analyzer = ImageAnalyzer(image) result = analyzer.average_intensity() expected = {'red': 255.0, 'green': 255.0, 'blue': 255.0} assert result == expected def test_average_intensity_zero_intensity(): image = np.zeros((4, 4, 3), dtype=np.uint8) analyzer = ImageAnalyzer(image) result = analyzer.average_intensity() expected = {'red': 0.0, 'green': 0.0, 'blue': 0.0} assert result == expected def test_average_intensity_random_values(): np.random.seed(0) image = np.random.randint(0, 256, (10, 10, 3), dtype=np.uint8) analyzer = ImageAnalyzer(image) result = analyzer.average_intensity() expected = {'red': np.mean(image[:, :, 0]), 'green': np.mean(image[:, :, 1]), 'blue': np.mean(image[:, :, 2])} assert result == expected","solution":"import numpy as np class ImageAnalyzer: def __init__(self, image): self.image = image def average_intensity(self): Calculate the average intensity for each color channel in an image. :return: A dictionary with the average intensity of 'red', 'green', and 'blue' channels. avg_red = np.mean(self.image[:, :, 0]) avg_green = np.mean(self.image[:, :, 1]) avg_blue = np.mean(self.image[:, :, 2]) return {'red': avg_red, 'green': avg_green, 'blue': avg_blue}"},{"question":"def schedule_tasks(tasks: list[tuple[int, int]], slots: list[int]) -> list[list[tuple[int, int]]]: Schedules tasks to time slots to maximize total priority. Parameters: tasks (list of tuple): List where each tuple contains (duration, priority). slots (list of int): List of available time slot durations. Returns: list of list of tuple: A list of lists, where each inner list contains the scheduled tasks for a respective time slot. pass # Example Usage: tasks = [(4, 50), (2, 30), (1, 20), (3, 40), (2, 60)] slots = [5, 3, 2] print(schedule_tasks(tasks, slots)) # Expected Output: [[(2, 60)], [(3, 40)], [(2, 30)]]","solution":"def schedule_tasks(tasks, slots): Schedules tasks to time slots to maximize total priority. Parameters: tasks (list of tuple): List where each tuple contains (duration, priority). slots (list of int): List of available time slot durations. Returns: list of list of tuple: A list of lists, where each inner list contains the scheduled tasks for a respective time slot. # Sort tasks by priority in descending order tasks.sort(key=lambda x: x[1], reverse=True) # Prepare the result list schedule = [[] for _ in slots] # Fill slots with tasks for i in range(len(slots)): for task in tasks: if task[0] <= slots[i]: schedule[i].append(task) tasks.remove(task) break # Move to the next slot after finding a fit return schedule"},{"question":"def is_power_of_three(number: int) -> bool: Determines if a given positive integer is a power of three using bitwise operations. Parameters: number (int): A positive integer Returns: bool: True if the number is a power of three, False otherwise Raises: TypeError: If the input is not an integer. ValueError: If the input is not a positive integer. Examples: >>> is_power_of_three(1) True >>> is_power_of_three(3) True >>> is_power_of_three(9) True >>> is_power_of_three(15) False >>> is_power_of_three(27) True >>> is_power_of_three(0) Traceback (most recent call last): ... ValueError: The input must be a positive integer!! >>> is_power_of_three(-3) Traceback (most recent call last): ... ValueError: The input must be a positive integer!! >>> is_power_of_three(\\"3\\") Traceback (most recent call last): ... TypeError: The input must be an integer! pass","solution":"def is_power_of_three(number): Determines if a given positive integer is a power of three using bitwise operations. Parameters: number (int): A positive integer Returns: bool: True if the number is a power of three, False otherwise Raises: TypeError: If the input is not an integer. ValueError: If the input is not a positive integer. Examples: >>> is_power_of_three(1) True >>> is_power_of_three(3) True >>> is_power_of_three(9) True >>> is_power_of_three(15) False >>> is_power_of_three(27) True >>> is_power_of_three(0) Traceback (most recent call last): ... ValueError: The input must be a positive integer!! >>> is_power_of_three(-3) Traceback (most recent call last): ... ValueError: The input must be a positive integer!! >>> is_power_of_three(\\"3\\") Traceback (most recent call last): ... TypeError: The input must be an integer! if not isinstance(number, int): raise TypeError(\\"The input must be an integer!\\") if number <= 0: raise ValueError(\\"The input must be a positive integer!!\\") # The largest power of three that fits in a 32-bit integer max_power_of_three = 1162261467 # 3^19, since 3^20 is beyond 32-bit int range # number is a power of three if max_power_of_three % number == 0 return max_power_of_three % number == 0"},{"question":"def largest_prime_factor(n: int) -> int: Returns the largest prime factor of a given integer n. >>> largest_prime_factor(13195) 29 >>> largest_prime_factor(600851475143) 6857 >>> largest_prime_factor(37) 37 >>> largest_prime_factor(49) 7 pass # Unit Tests def test_largest_prime_factor_small_numbers(): assert largest_prime_factor(2) == 2 assert largest_prime_factor(3) == 3 assert largest_prime_factor(4) == 2 assert largest_prime_factor(5) == 5 def test_largest_prime_factor_known_cases(): assert largest_prime_factor(13195) == 29 assert largest_prime_factor(600851475143) == 6857 assert largest_prime_factor(37) == 37 assert largest_prime_factor(49) == 7 def test_largest_prime_factor_edge_cases(): assert largest_prime_factor(1) == 1 # Not technically valid as input based on constraints, ignoring for practical edge case assert largest_prime_factor(10**12) == 5 def test_largest_prime_factor_prime_numbers(): assert largest_prime_factor(101) == 101 assert largest_prime_factor(113) == 113 assert largest_prime_factor(997) == 997 def test_largest_prime_factor_composite_numbers(): assert largest_prime_factor(56) == 7 assert largest_prime_factor(72) == 3","solution":"import math def largest_prime_factor(n: int) -> int: Returns the largest prime factor of a given integer n. # Initialize the largest factor as the smallest prime number largest_factor = 1 # Remove the factors of 2 while n % 2 == 0: largest_factor = 2 n = n // 2 # At this point, n must be odd. Start loop from 3 and increment by 2 (odd numbers only) for i in range(3, int(math.sqrt(n)) + 1, 2): while (n % i == 0): largest_factor = i n = n // i # This condition is to check if n is a prime number greater than 2 if n > 2: largest_factor = n return largest_factor"},{"question":"from typing import List def count_unique_with_limit(arr: List[int], k: int) -> int: Returns the count of unique numbers in the list \`arr\` that appear \`k\` times or fewer. - arr: A list of integers. - k: An integer specifying the limit on the number of occurrences. >>> count_unique_with_limit([1, 2, 2, 3, 3, 3, 4], 1) 1 >>> count_unique_with_limit([1, 2, 2, 3, 3, 3, 4, 4], 2) 3 >>> count_unique_with_limit([1, 1, 1, 1, 2, 2, 3, 3, 3], 2) 1 pass # Your implementation here","solution":"from collections import Counter def count_unique_with_limit(arr: list[int], k: int) -> int: Returns the count of unique numbers in the \`arr\` that appear \`k\` times or fewer. if not isinstance(arr, list) or not isinstance(k, int) or k < 0: raise ValueError(\\"Invalid input\\") count = Counter(arr) limited_count_numbers = [num for num, freq in count.items() if 0 < freq <= k] return len(limited_count_numbers)"}]`),F={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},z={class:"card-container"},I={key:0,class:"empty-state"},j=["disabled"],D={key:0},S={key:1};function P(i,e,l,f,n,a){const m=h("PoemCard");return r(),s("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(r(),s("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")}," ✕ ")):d("",!0)]),t("div",z,[(r(!0),s(y,null,v(a.displayedPoems,(o,p)=>(r(),w(m,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),s("div",I,' No results found for "'+u(n.searchQuery)+'". ',1)):d("",!0)]),a.hasMorePoems?(r(),s("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(r(),s("span",S,"Loading...")):(r(),s("span",D,"See more"))],8,j)):d("",!0)])}const B=_(F,[["render",P],["__scopeId","data-v-ca1e2f78"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/28.md","filePath":"library/28.md"}'),V={name:"library/28.md"},G=Object.assign(V,{setup(i){return(e,l)=>(r(),s("div",null,[x(B)]))}});export{O as __pageData,G as default};
