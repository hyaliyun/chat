import{_ as m,o as s,c as n,a as t,m as d,t as c,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function S(i,e,u,_,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(c(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(c(u.poem.solution),1)])])])}const R=m(q,[["render",S],["__scopeId","data-v-3b7ba254"]]),A=JSON.parse(`[{"question":"def evaluate_expression(expression: str) -> int: Evaluate the string expression consisting of digits (0-9), operators (+, -, *, /) and parentheses. Returns the evaluated result as an integer. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"(2+3)*(5-1)\\") 20 >>> evaluate_expression(\\"10/(2+3)\\") 2 import re def test_evaluate_expression_simple(): assert evaluate_expression(\\"3+5\\") == 8 def test_evaluate_expression_order(): assert evaluate_expression(\\"3+5*2\\") == 13 def test_evaluate_expression_parenthesis(): assert evaluate_expression(\\"(2+3)*(5-1)\\") == 20 def test_evaluate_expression_division(): assert evaluate_expression(\\"10/(2+3)\\") == 2 def test_evaluate_expression_complex(): assert evaluate_expression(\\"3 + 4 * 2 / ( 1 - 5 )\\") == 1 def test_evaluate_expression_multiple_parentheses(): assert evaluate_expression(\\"((10 + 2) * 3 - 2) / 8\\") == 4 def test_evaluate_expression_whitespace(): assert evaluate_expression(\\" 10 + 2 \\") == 12","solution":"def evaluate_expression(expression): Evaluate the string expression consisting of digits (0-9), operators (+, -, *, /) and parentheses. Returns the evaluated result as an integer. def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return int(a / b) # Use int() to truncate towards zero return 0 def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue elif tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(expression) def evaluate_expressions(expressions): results = [] for expression in expressions: results.append(evaluate_expression(expression)) return results def main(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) expressions = data[1:T+1] results = evaluate_expressions(expressions) for result in results: print(result)"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string s is a palindrome considering only letters and ignoring case, spaces, and special characters. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"123Abc-!cbA321\\") True >>> is_palindrome(\\"This is not a palindr0me\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"A\\") True pass def check_palindromes(test_cases: List[str]) -> List[str]: Processes multiple test cases to check if each of them is a palindrome, returning a list of \\"palindrome\\" or \\"not a palindrome\\" for each test case. >>> check_palindromes([ ... \\"A man, a plan, a canal, Panama!\\", ... \\"No 'x' in Nixon\\", ... \\"This is not a palindrome\\", ... \\"123Abc-!cbA321\\", ... \\"Aba\\" ... ]) ['palindrome', 'palindrome', 'not a palindrome', 'palindrome', 'palindrome'] pass","solution":"def is_palindrome(s): Checks if the given string s is a palindrome considering only letters and ignoring case, spaces, and special characters. # Filter out non-letter characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalpha()] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1] def check_palindromes(test_cases): Processes multiple test cases to check if each of them is a palindrome. results = [] for s in test_cases: if is_palindrome(s): results.append(\\"palindrome\\") else: results.append(\\"not a palindrome\\") return results"},{"question":"def dispense_cash(amount: int) -> str: Given an amount, this function calculates the number of each denomination (100s, 50s, 20s, 10s, 5s, 1s) needed to dispense the amount while minimizing the number of bills. >>> dispense_cash(376) == \\"100s: 3, 50s: 1, 20s: 1, 10s: 0, 5s: 1, 1s: 1\\" >>> dispense_cash(123) == \\"100s: 1, 50s: 0, 20s: 1, 10s: 0, 5s: 0, 1s: 3\\" >>> dispense_cash(6879) == \\"100s: 68, 50s: 1, 20s: 1, 10s: 0, 5s: 1, 1s: 4\\" pass def process_transactions(input_lines: List[str]) -> List[str]: Processes multiple lines of transaction inputs until encountering '0'. For each transaction, it returns the number of each denomination of bill to be dispensed. >>> input_lines = [\\"376\\", \\"123\\", \\"6879\\", \\"0\\"] >>> process_transactions(input_lines) [\\"100s: 3, 50s: 1, 20s: 1, 10s: 0, 5s: 1, 1s: 1\\", \\"100s: 1, 50s: 0, 20s: 1, 10s: 0, 5s: 0, 1s: 3\\", \\"100s: 68, 50s: 1, 20s: 1, 10s: 0, 5s: 1, 1s: 4\\"] pass","solution":"def dispense_cash(amount): Given an amount, this function calculates the number of each denomination (100s, 50s, 20s, 10s, 5s, 1s) needed to dispense the amount while minimizing the number of bills. denominations = [100, 50, 20, 10, 5, 1] bills = {} for denom in denominations: bills[denom], amount = divmod(amount, denom) return f\\"100s: {bills[100]}, 50s: {bills[50]}, 20s: {bills[20]}, 10s: {bills[10]}, 5s: {bills[5]}, 1s: {bills[1]}\\" def process_transactions(input_lines): Processes multiple lines of transaction inputs until encountering '0'. For each transaction, it returns the number of each denomination of bill to be dispensed. results = [] for line in input_lines: amount = int(line) if amount == 0: break result = dispense_cash(amount) results.append(result) return results"},{"question":"import math from typing import List, Tuple def min_sum_after_gcd_operations(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array a_1, a_2, ..., a_n which consists of n integers. An operation involves selecting any two distinct indices i and j (with i â‰  j) and replacing a_i with the GCD (Greatest Common Divisor) of a_i and a_j. Your task is to determine the minimum possible sum of the array's elements after performing any number of such operations (including zero). Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases. Each test case contains a tuple with the number of elements in the array n and the array a. Returns: List[int]: List of integers representing the minimum possible sum for each test case. Examples: >>> min_sum_after_gcd_operations(3, [(3, [12, 15, 18]), (4, [24, 36, 48, 60]), (2, [7, 11])]) [9, 48, 7] >>> min_sum_after_gcd_operations(1, [(5, [20, 20, 20, 20, 20])]) [100]","solution":"import math def min_sum_after_gcd_operations(t, test_cases): results = [] for case in test_cases: n, arr = case gcd_all = arr[0] for num in arr[1:]: gcd_all = math.gcd(gcd_all, num) results.append(gcd_all * n) return results"},{"question":"def is_palindrome(num: int) -> bool: Checks if a number is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(99) == True >>> is_palindrome(10101) == True >>> is_palindrome(12321) == True >>> is_palindrome(10) == False def largest_palindrome(n: int) -> int: Finds the largest palindrome number less than or equal to n. >>> largest_palindrome(123) == 121 >>> largest_palindrome(99) == 99 >>> largest_palindrome(1000) == 999 >>> largest_palindrome(1) == 1 >>> largest_palindrome(10) == 9 >>> largest_palindrome(101) == 101","solution":"def is_palindrome(num): Checks if a number is a palindrome. s = str(num) return s == s[::-1] def largest_palindrome(n): Finds the largest palindrome number less than or equal to n. for num in range(n, 0, -1): if is_palindrome(num): return num"},{"question":"def total_employee_count(department): Returns the total number of employees in the given department including all sub-departments recursively. >>> dept_structure = { ... \\"__employees\\": 100, ... \\"HR\\": { ... \\"__employees\\": 20, ... \\"Recruitment\\": {\\"__employees\\": 10}, ... \\"Employee Relations\\": {\\"__employees\\": 8} ... }, ... \\"Engineering\\": { ... \\"__employees\\": 50, ... \\"Software\\": { ... \\"__employees\\": 30, ... \\"Backend\\": {\\"__employees\\": 15}, ... \\"Frontend\\": {\\"__employees\\": 10} ... }, ... \\"Hardware\\": {\\"__employees\\": 20} ... } ... } >>> total_employee_count(dept_structure) 263","solution":"def total_employee_count(department): Returns the total number of employees in the given department including all sub-departments recursively. total_count = 0 for key, value in department.items(): if key == \\"__employees\\": total_count += value elif isinstance(value, dict): total_count += total_employee_count(value) return total_count"},{"question":"def get_top_scores(test_cases): Accepts a list of test cases and returns a list of lists containing distinct scores in descending order for each test case. pass def parse_input(input_data): Parses the input string and returns a list of test cases, where each test case is a list of scores. pass def format_output(results): Formats the results into the required output string where each score is printed on a new line. pass # Example usage >>> input_data = \\"2n5n100 200 300 200 100n4n50 50 40 30\\" >>> test_cases = parse_input(input_data) >>> results = get_top_scores(test_cases) >>> output = format_output(results) >>> output \\"300n200n100n50n40n30\\"","solution":"def get_top_scores(test_cases): Accepts a list of test cases and returns a list of lists containing distinct scores in descending order for each test case. results = [] for participants_scores in test_cases: distinct_scores = list(set(participants_scores)) # Extract distinct scores distinct_scores.sort(reverse=True) # Sort in descending order results.append(distinct_scores) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) scores = list(map(int, lines[idx + 1].split())) test_cases.append(scores) idx += 2 return test_cases def format_output(results): output = [] for result in results: for score in result: output.append(str(score)) return 'n'.join(output)"},{"question":"def num_islands(grid: List[List[str]]) -> int: Calculate the number of islands in the given grid. An island is defined as a group of connected lands ('1') horizontally or vertically. Args: grid (List[List[str]]): The grid of land ('1') and water ('0'). Returns: int: The number of islands in the grid. >>> num_islands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) 3 >>> num_islands([ ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) 0 >>> num_islands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) 1 >>> num_islands([ ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"] ... ]) 9 >>> num_islands([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) 1 >>> num_islands([]) 0 >>> num_islands([[\\"1\\"]]) 1 >>> num_islands([[\\"0\\"]]) 0","solution":"def num_islands(grid): Returns the number of islands in the grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # Mark as visited dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count"},{"question":"def can_form_target_sum(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[str]: Determine if it's possible to form a subset (with repetition allowed) whose sum is exactly the target sum. >>> can_form_target_sum(2, [(3, [1, 2, 3], 5), (4, [2, 3, 5, 7], 9)]) ['YES', 'YES'] >>> can_form_target_sum(1, [(1, [5], 10)]) ['YES']","solution":"def can_form_target_sum(T, test_cases): results = [] def can_sum(S, nums): dp = [False] * (S + 1) dp[0] = True for i in range(1, S + 1): for num in nums: if i - num >= 0 and dp[i - num]: dp[i] = True break return dp[S] for i in range(T): N, nums, S = test_cases[i] results.append(\\"YES\\" if can_sum(S, nums) else \\"NO\\") return results"},{"question":"from typing import List, Tuple def maximize_storage(n: int, W: int, baked_goods: List[Tuple[str, int]]) -> Tuple[int, List[str]]: Returns the maximum number of different baked goods that can be stored without exceeding the given weight limit and the list of names of the selected baked goods. Args: n: int - The number of different baked goods W: int - The maximum weight capacity of the storage room baked_goods: List[Tuple[str, int]] - A list of tuples containing the name and weight of each baked good Returns: Tuple[int, List[str]] - A tuple containing the count of selected baked goods and the list of their names >>> maximize_storage(5, 10, [(\\"cake\\", 3), (\\"cookie\\", 2), (\\"bread\\", 4), (\\"muffin\\", 5), (\\"pie\\", 6)]) (3, [\\"cookie\\", \\"cake\\", \\"bread\\"]) >>> maximize_storage(4, 15, [(\\"baguette\\", 10), (\\"bun\\", 3), (\\"croissant\\", 4), (\\"pretzel\\", 5)]) (3, [\\"bun\\", \\"croissant\\", \\"pretzel\\"]) >>> maximize_storage(3, 5, [(\\"donut\\", 10), (\\"eclair\\", 6), (\\"tart\\", 2)]) (1, [\\"tart\\"])","solution":"def maximize_storage(n, W, baked_goods): Returns the maximum number of different baked goods that can be stored without exceeding the given weight limit and the list of names of the selected baked goods. # Sort baked goods based on their weight in ascending order baked_goods.sort(key=lambda x: x[1]) total_weight = 0 selected_baked_goods = [] for name, weight in baked_goods: if total_weight + weight <= W: total_weight += weight selected_baked_goods.append(name) else: break count = len(selected_baked_goods) return count, selected_baked_goods"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. Examples: >>> evaluate_expression(\\"3 + 5\\") 8.0 >>> evaluate_expression(\\"10 + 2 * 6\\") 22.0 >>> evaluate_expression(\\"100 * 2 + 12\\") 212.0 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400.0 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100.0","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a float. :param expression: A string containing the mathematical expression. :return: Result of the expression as a float. return float(eval(expression))"},{"question":"import random def get_computer_choice() -> str: Randomly returns one of 'rock', 'paper' or 'scissors' choice for the computer. return random.choice(['rock', 'paper', 'scissors']) def determine_winner(player_choice: str, computer_choice: str) -> str: Determine the winner of a single round of Rock, Paper, Scissors. - If player_choice wins against computer_choice, return 'win' - If player_choice loses against computer_choice, return 'lose' - If both choices are the same, return 'draw' >>> determine_winner(\\"rock\\", \\"scissors\\") 'win' >>> determine_winner(\\"scissors\\", \\"rock\\") 'lose' >>> determine_winner(\\"scissors\\", \\"scissors\\") 'draw' def play_game(): Simulates the Rock, Paper, Scissors game between the player and the computer. The game continues for multiple rounds until the player enters 'exit' to terminate the game. After each round, prints the result of the round and the current score. Upon termination, prints the final score.","solution":"import random def get_computer_choice(): return random.choice(['rock', 'paper', 'scissors']) def determine_winner(player_choice, computer_choice): if player_choice == computer_choice: return 'draw' elif (player_choice == \\"rock\\" and computer_choice == \\"scissors\\") or (player_choice == \\"scissors\\" and computer_choice == \\"paper\\") or (player_choice == \\"paper\\" and computer_choice == \\"rock\\"): return 'win' else: return 'lose' def play_game(): player_score = 0 computer_score = 0 while True: player_choice = input(\\"Enter rock, paper, scissors or exit: \\").lower() if player_choice == 'exit': print(f\\"Final Score - Player: {player_score} Computer: {computer_score}\\") break if player_choice not in ['rock', 'paper', 'scissors']: print(\\"Invalid input, please enter rock, paper, scissors or exit.\\") continue computer_choice = get_computer_choice() result = determine_winner(player_choice, computer_choice) if result == 'win': player_score += 1 elif result == 'lose': computer_score += 1 print(result) print(f\\"Player: {player_score} Computer: {computer_score}\\")"},{"question":"def process_bookshelf(n: int, q: int, initial_books: List[Tuple[int, int, int]], operations: List[Tuple[int, ...]]) -> List[int]: Organize a bookshelf and perform a series of operations on it. Parameters: n (int): Initial number of books. q (int): Number of operations. initial_books (List[Tuple[int, int, int]]): List of tuples representing the books, each containing (ID, category, pages). operations (List[Tuple[int, ...]]): List of operations to perform on the bookshelf. Returns: List[int]: A list of results for type 3 operations (total number of pages in a category). Example: >>> n = 5 >>> q = 6 >>> initial_books = [(1, 2, 350), (2, 3, 500), (3, 2, 200), (4, 1, 150), (5, 3, 100)] >>> operations = [(3, 2), (1, 6, 2, 300), (3, 2), (2, 1), (3, 2), (3, 3)] >>> process_bookshelf(n, q, initial_books, operations) [550, 850, 500, 600] pass","solution":"class Bookshelf: def __init__(self, n, books): self.books = {} self.category_pages = {} for id_, category, pages in books: self.books[id_] = (category, pages) if category not in self.category_pages: self.category_pages[category] = 0 self.category_pages[category] += pages def add_book(self, id_, category, pages): self.books[id_] = (category, pages) if category not in self.category_pages: self.category_pages[category] = 0 self.category_pages[category] += pages def remove_book(self, id_): if id_ in self.books: category, pages = self.books[id_] self.category_pages[category] -= pages del self.books[id_] def total_pages_in_category(self, category): return self.category_pages.get(category, 0) def process_bookshelf(n, q, initial_books, operations): bookshelf = Bookshelf(n, initial_books) results = [] for operation in operations: if operation[0] == 1: _, id_, category, pages = operation bookshelf.add_book(id_, category, pages) elif operation[0] == 2: _, id_ = operation bookshelf.remove_book(id_) elif operation[0] == 3: _, category = operation results.append(bookshelf.total_pages_in_category(category)) return results"},{"question":"def min_moves_to_convert(grid): Return the minimum number of moves to convert all cells in the grid to 1. >>> min_moves_to_convert(['111', '110', '001']) == 1 >>> min_moves_to_convert(['111', '111', '111']) == 0 >>> min_moves_to_convert(['100', '000', '001']) == 2 >>> min_moves_to_convert(['101', '000', '101']) == 2 >>> min_moves_to_convert(['1']) == 0","solution":"def min_moves_to_convert(grid): Return the minimum number of moves to convert all cells in the grid to 1. H = len(grid) W = len(grid[0]) # To avoid going out of bounds directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization from collections import deque queue = deque([]) visited = [[False] * W for _ in range(H)] # Enqueue all the initial '1' cells and mark them as visited for i in range(H): for j in range(W): if grid[i][j] == '1': queue.append((i, j, 0)) # (row, col, depth) visited[i][j] = True max_depth = 0 # BFS loop while queue: x, y, depth = queue.popleft() max_depth = max(max_depth, depth) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny]: visited[nx][ny] = True if grid[nx][ny] == '0': queue.append((nx, ny, depth + 1)) return max_depth def main(): import sys input = sys.stdin.read data = input().split() H = int(data[0]) W = int(data[1]) grid = [data[i + 2] for i in range(H)] print(min_moves_to_convert(grid)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def max_coins(grid: List[List[int]]) -> int: Returns the maximum number of coins that can be collected from the top-left corner to the bottom-right corner, moving only right or down. >>> grid = [ ... [0, 3, 1, 1], ... [2, 0, 0, 4], ... [1, 5, 3, 1] ... ] >>> max_coins(grid) 12","solution":"from typing import List def max_coins(grid: List[List[int]]) -> int: Returns the maximum number of coins that can be collected from the top-left corner to the bottom-right corner, moving only right or down. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Create a 2D dp array to store the maximum coins collected up to each cell dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def smallest_missing_integer(nums: List[int]) -> int: Find the smallest non-negative integer not present in the given list of integers. >>> smallest_missing_integer([1, 2, 0, 4, 5]) 3 >>> smallest_missing_integer([-1, -2, 0, -4, -5, -6]) 1 >>> smallest_missing_integer([0, 1, 3, 4, 5, 6, 7, 8]) 2 >>> smallest_missing_integer([]) 0 >>> smallest_missing_integer([0]) 1 >>> smallest_missing_integer([0, 1, 2, 3, 4]) 5 pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases and return the smallest non-negative integer not present in the list for each test case. >>> process_test_cases(2, [(5, [1, 2, 0, 4, 5]), (6, [-1, -2, 0, -4, -5, -6])]) [3, 1] >>> process_test_cases(1, [(8, [0, 1, 3, 4, 5, 6, 7, 8])]) [2] >>> process_test_cases(3, [(1, [0]), (0, []), (5, [-3, -2, -1, 0, 1])]) [1, 0, 2] >>> process_test_cases(1, [(7, [2, 3, 4, 5, 6, 7, 1])]) [0] pass","solution":"def smallest_missing_integer(nums): Finds the smallest non-negative integer not present in the given list of integers. nums_set = set(nums) missing_int = 0 while missing_int in nums_set: missing_int += 1 return missing_int def process_test_cases(T, test_cases): Processes multiple test cases and returns the smallest non-negative integer not present in the list for each test case. results = [] for i in range(T): N = test_cases[i][0] nums = test_cases[i][1] results.append(smallest_missing_integer(nums)) return results"},{"question":"def find_supervisors(N: int, supervisors: List[int]) -> List[int]: Given the number of employees N and a list of their supervisors, return a list of indices of employees who receive reports from at least one employee. >>> find_supervisors(7, [0, 1, 1, 3, 3, 4, 5]) [1, 3, 4, 5] >>> find_supervisors(4, [0, 0, 0, 0]) [] >>> find_supervisors(5, [0, 1, 2, 3, 4]) [1, 2, 3, 4] >>> find_supervisors(7, [0, 1, 1, 1, 2, 2, 3]) [1, 2, 3]","solution":"def find_supervisors(N, supervisors): Given the number of employees N and a list of their supervisors, return a list of indices of employees who receive reports from at least one employee. supervisor_set = set() for supervisor in supervisors: if supervisor != 0: supervisor_set.add(supervisor) return sorted(supervisor_set)"},{"question":"from typing import List def maxProfit(P: List[int]) -> int: Returns the maximum profit possible by buying and selling on different days. Parameters: - P: List[int]: List of profit values on different days Returns: - int: Maximum possible profit pass def process_cases(t: int, cases: List[List[int]]) -> List[int]: Process multiple test cases to find the maximum profit for each case. Parameters: - t: int : Number of test cases - cases: List[List[int]] : List of test cases where each test case is a list of integers Returns: - List[int]: List of maximum possible profits for each test case pass # Example usage: t = 2 cases = [ [6, 7, 1, 5, 3, 6, 4], [7, 7, 6, 4, 3, 1, 2, 5] ] results = process_cases(t, cases) for result in results: print(result)","solution":"def maxProfit(P): Returns the maximum profit possible by buying and selling on different days. Parameters: - P: List[int] : List of profit values on different days Returns: - int: Maximum possible profit if not P or len(P) < 2: return 0 min_price = P[0] max_profit = 0 for price in P: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def process_cases(t, cases): results = [] for case in cases: _, *P = case results.append(maxProfit(P)) return results # Example usage: t = 2 cases = [ [6, 7, 1, 5, 3, 6, 4], [7, 7, 6, 4, 3, 1, 2, 5] ] results = process_cases(t, cases) for result in results: print(result)"},{"question":"def find_three_evens_sum(test_cases): Check if each integer in the test cases can be expressed as the sum of exactly three even integers greater than zero. Args: test_cases (List[int]): List of integers to be checked. Returns: List[Union[Tuple[int, int, int], int]]: List of tuples where each tuple contains three even integers that sum up to the corresponding input integer. If it's not possible, returns -1. >>> find_three_evens_sum([12, 18, 8, 15]) [(2, 4, 6), (2, 2, 14), (2, 2, 4), -1] def process_input_and_solve(t, numbers): Process input and solve the problem based on the given number of test cases. Args: t (int): Number of test cases. numbers (List[int]): List of positive integers to check. Returns: List[Union[Tuple[int, int, int], int]]: List of results for each test case.","solution":"def find_three_evens_sum(test_cases): results = [] for n in test_cases: if n >= 6 and n % 2 == 0: results.append((2, 2, n - 4)) # Any even number n >= 6 can be expressed as 2 + 2 + (n-4) else: results.append(-1) return results def process_input_and_solve(t, numbers): results = find_three_evens_sum(numbers) return results"},{"question":"def battle_index(S: str) -> int: Calculate the battle index of the given string, which is the count of distinct substrings. >>> battle_index(\\"abc\\") 6 >>> battle_index(\\"aaa\\") 3 >>> battle_index(\\"a\\") 1 >>> battle_index(\\"ab\\") 3 >>> battle_index(\\"abab\\") 7 >>> battle_index(\\"abba\\") 8 >>> battle_index(\\"aaaa\\") 4","solution":"def battle_index(S): Calculate the battle index of the given string, which is the count of distinct substrings. # A set to store substrings. substrings = set() # Generate all possible substrings and add them to the set. for i in range(len(S)): for j in range(i + 1, len(S) + 1): substrings.add(S[i:j]) # The number of distinct substrings is the size of the set. return len(substrings)"},{"question":"def max_combined_beauty(n: int, flowers: List[Tuple[int, int]]) -> int: Determine the maximum combined beauty value of any \\"visually pleasing\\" pair of flowers in the garden. If there is no such pair, return -1. >>> max_combined_beauty(5, [(1, 2), (2, 4), (3, 1), (4, 3), (5, 5)]) == 9 >>> max_combined_beauty(3, [(2, 3), (2, 1), (2, 4)]) == -1 >>> max_combined_beauty(4, [(1, 1), (2, 2), (3, 3), (4, 4)]) == 7 >>> max_combined_beauty(3, [(3, 3), (2, 2), (1, 1)]) == -1 >>> max_combined_beauty(2, [(1, 2), (2, 3)]) == 5 >>> max_combined_beauty(3, [(1, 100000), (2, 100000), (3, 100000)]) == -1","solution":"def max_combined_beauty(n, flowers): max_beauty = -1 max_beauty_so_far = [0] * n max_val = 0 for i in range(n): max_val = max(max_val, flowers[i][1]) max_beauty_so_far[i] = max_val for j in range(1, n): for i in range(j): if flowers[i][0] < flowers[j][0] and flowers[i][1] < flowers[j][1]: max_beauty = max(max_beauty, flowers[i][1] + flowers[j][1]) return max_beauty"},{"question":"from typing import List def find_min_cost(grid: List[List[int]]) -> int: Write a function that takes a 2D grid representing a cost matrix and returns the minimum cost to reach the bottom-right corner of the grid starting from the top-left corner. You can only move to the right or down at each step. If the input grid is empty, return -1. Example: >>> find_min_cost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> find_min_cost([ ... [1, 2, 3] ... ]) 6 >>> find_min_cost([ ... [1], ... [2], ... [3] ... ]) 6 >>> find_min_cost([]) -1 >>> find_min_cost([ ... [5] ... ]) 5 >>> find_min_cost([ ... [1, 2], ... [1, 1] ... ]) 3","solution":"from typing import List def find_min_cost(grid: List[List[int]]) -> int: Returns the minimum cost to reach the bottom-right corner of the grid starting from the top-left corner. if not grid or not grid[0]: return -1 rows = len(grid) cols = len(grid[0]) # Create a 2D array to store the minimum cost to reach each cell dp = [[0 for _ in range(cols)] for _ in range(rows)] # Initialize the first cell with the starting grid cost dp[0][0] = grid[0][0] # Fill out the first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill out the first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Compute the minimum cost for the rest of the grid for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner will have the minimum cost to reach it return dp[rows - 1][cols - 1]"},{"question":"from typing import List, Tuple def max_distinct_elements(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given an integer array \`arr\` of size \`n\` and an integer \`k\`, find the maximum number of distinct elements in any subarray of size \`k\`. A subarray is a contiguous part of an array. Args: t (int): Number of test cases test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains: - n (int): Size of the array - k (int): Size of the subarray - arr (List[int]): The array of integers Returns: List[int]: List of integers where each integer is the maximum number of distinct elements in any subarray of size \`k\` for the corresponding test case. Examples: >>> t = 2 >>> test_cases = [(6, 3, [1, 2, 1, 3, 4, 3]), (5, 2, [4, 4, 4, 4, 4])] >>> max_distinct_elements(t, test_cases) [3, 1] >>> t = 1 >>> test_cases = [(1, 1, [1])] >>> max_distinct_elements(t, test_cases) [1] >>> t = 1 >>> test_cases = [(6, 3, [1, 2, 3, 4, 5, 6])] >>> max_distinct_elements(t, test_cases) [3] >>> t = 1 >>> test_cases = [(5, 3, [7, 7, 7, 7, 7])] >>> max_distinct_elements(t, test_cases) [1] >>> t = 1 >>> test_cases = [(4, 2, [1, 2, 1, 2])] >>> max_distinct_elements(t, test_cases) [2] >>> t = 1 >>> test_cases = [(5, 3, [1, 2, 1, 1, 2])] >>> max_distinct_elements(t, test_cases) [2]","solution":"from collections import defaultdict def max_distinct_elements(t, test_cases): results = [] for case in test_cases: n, k, arr = case window_counts = defaultdict(int) distinct_count = 0 max_distinct = 0 for i in range(n): if i >= k: if window_counts[arr[i - k]] == 1: distinct_count -= 1 window_counts[arr[i - k]] -= 1 if window_counts[arr[i]] == 0: distinct_count += 1 window_counts[arr[i]] += 1 if i >= k - 1: max_distinct = max(max_distinct, distinct_count) results.append(max_distinct) return results"},{"question":"def maxSubarraySum(arr: List[int]) -> int: Returns the maximum sum of any non-empty subarray of consecutive elements. >>> maxSubarraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxSubarraySum([1, 2, 3, 4, 5]) 15 >>> maxSubarraySum([-9, -8, -7, -6, -5, -4, -3, -2, -1]) -1 >>> maxSubarraySum([3]) 3 >>> maxSubarraySum([-3]) -3 >>> maxSubarraySum([-10000, 10000, -10000, 10000, -10000, 10000]) 10000 >>> maxSubarraySum([0, 0, 0, 0, 0]) 0","solution":"def maxSubarraySum(arr): Returns the maximum sum of any non-empty subarray of consecutive elements. max_current = max_global = arr[0] for number in arr[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global"},{"question":"class QueueUsingStacks: Simulate a queue using two stacks. Methods: enqueue(x): Pushes 'x' into the queue. dequeue(): Pops the front element from the queue and returns it. If the queue is empty, returns -1. front(): Returns the front element of the queue without removing it. If the queue is empty, returns -1. Example: >>> queue = QueueUsingStacks() >>> queue.enqueue(2) >>> queue.enqueue(3) >>> queue.front() 2 >>> queue.dequeue() 2 >>> queue.front() 3 >>> queue.dequeue() 3 >>> queue.front() -1 >>> queue.dequeue() -1 def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: pass def dequeue(self) -> int: pass def front(self) -> int: pass # Unit tests def test_enqueue_dequeue(): queue = QueueUsingStacks() queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 2 assert queue.dequeue() == 3 assert queue.dequeue() == -1 def test_enqueue_front(): queue = QueueUsingStacks() queue.enqueue(2) assert queue.front() == 2 queue.enqueue(3) assert queue.front() == 2 def test_dequeue_empty_queue(): queue = QueueUsingStacks() assert queue.dequeue() == -1 def test_front_empty_queue(): queue = QueueUsingStacks() assert queue.front() == -1 def test_mixed_operations(): queue = QueueUsingStacks() queue.enqueue(5) assert queue.dequeue() == 5 queue.enqueue(10) assert queue.front() == 10 assert queue.dequeue() == 10 assert queue.front() == -1 assert queue.dequeue() == -1","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x): # Always push the new element onto stack1 self.stack1.append(x) def dequeue(self): if not self.stack2: # If stack2 is empty, move all elements from stack1 to stack2 while self.stack1: self.stack2.append(self.stack1.pop()) if self.stack2: return self.stack2.pop() else: return -1 def front(self): if not self.stack2: # If stack2 is empty, move all elements from stack1 to stack2 while self.stack1: self.stack2.append(self.stack1.pop()) if self.stack2: return self.stack2[-1] else: return -1"},{"question":"from typing import List def can_be_palindrome(s: str) -> bool: Check if a string can be transformed into a palindrome by deleting at most one character. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i, j = i + 1, j - 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True def canBePalindromeForTestCases(test_cases: List[str]) -> List[str]: Process multiple test cases and return results. >>> canBePalindromeForTestCases([\\"abca\\"]) [\\"YES\\"] >>> canBePalindromeForTestCases([\\"racecar\\"]) [\\"YES\\"] >>> canBePalindromeForTestCases([\\"abcde\\"]) [\\"NO\\"] >>> canBePalindromeForTestCases([\\"abccba\\"]) [\\"YES\\"] >>> canBePalindromeForTestCases([\\"a\\"]) [\\"YES\\"] >>> canBePalindromeForTestCases([\\"abca\\", \\"racecar\\", \\"abcde\\", \\"abccba\\", \\"a\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def can_be_palindrome(s): Check if a string can be transformed into a palindrome by deleting at most one character. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i, j = i + 1, j - 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True def canBePalindromeForTestCases(test_cases): Process multiple test cases and return results. result = [] for s in test_cases: if can_be_palindrome(s): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def one_edit_away(s: str, t: str) -> bool: Determines if two strings s and t are one edit away from being the same string. An edit is an insertion, deletion, or replacement of a single character. Example 1: >>> one_edit_away(\\"pale\\", \\"ple\\") True Example 2: >>> one_edit_away(\\"pales\\", \\"pale\\") True Example 3: >>> one_edit_away(\\"pale\\", \\"bale\\") True Example 4: >>> one_edit_away(\\"pale\\", \\"bake\\") False","solution":"def one_edit_away(s, t): Determines if two strings s and t are one edit away from being the same string. An edit is an insertion, deletion, or replacement of a single character. len_s, len_t = len(s), len(t) # If the length difference is more than 1, return False if abs(len_s - len_t) > 1: return False # Identify the longer and shorter strings if len_s > len_t: s, t = t, s found_difference = False i, j = 0, 0 while i < len(s) and j < len(t): if s[i] != t[j]: if found_difference: return False found_difference = True if len(s) == len(t): i += 1 # If lengths are the same, move both pointers else: i += 1 j += 1 return True"},{"question":"def first_non_repeated_character(s: str) -> str: Returns the first non-repeated character in the string. If all characters are repeated or the input string is empty, returns an empty string. >>> first_non_repeated_character(\\"abacabad\\") 'c' >>> first_non_repeated_character(\\"abacabaabacaba\\") '' >>> first_non_repeated_character(\\"abcabcabc\\") '' >>> first_non_repeated_character(\\"aabbccddeeffg\\") 'g'","solution":"def first_non_repeated_character(s): Returns the first non-repeated character in the string. If all characters are repeated or the input string is empty, returns an empty string. char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return '' # Return empty string if no non-repeated character found"},{"question":"def canFollowCommands(n: int, m: int, grid: List[List[int]], s: str) -> int: Determine if there exists a starting cell from which the robot can follow the given command sequence while staying within the grid and only on open cells (1s). >>> canFollowCommands(3, 3, [[1, 1, 0], [1, 0, 1], [1, 1, 1]], \\"RRDLLU\\") 0 >>> canFollowCommands(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]], \\"RDL\\") 1","solution":"def canFollowCommands(n, m, grid, s): def isValid(i, j): return 0 <= i < n and 0 <= j < m and grid[i][j] == 1 directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)} for start_i in range(n): for start_j in range(m): if grid[start_i][start_j] == 1: i, j = start_i, start_j valid = True for command in s: di, dj = directions[command] i += di j += dj if not isValid(i, j): valid = False break if valid: return 1 return 0"},{"question":"def max_product_of_two(arr: List[int]) -> int: Function to find the maximum product of two distinct elements in the array. Parameters: arr (list): a list of integers Returns: int: maximum product of two distinct elements in the array >>> max_product_of_two([1, 2, 3, 4, 5]) 20 >>> max_product_of_two([10, 10, 5]) 100 >>> max_product_of_two([1, 0, 2, 9]) 18 from solution import max_product_of_two def test_max_product_of_two(): assert max_product_of_two([1, 2, 3, 4, 5]) == 20 assert max_product_of_two([10, 10, 5]) == 100 assert max_product_of_two([1, 0, 2, 9]) == 18 assert max_product_of_two([3, 7]) == 21 assert max_product_of_two([10, 10]) == 100 assert max_product_of_two([0, 10]) == 0 assert max_product_of_two([10, 20, 30, 40]) == 1200 assert max_product_of_two([5, 5, 5, 5]) == 25 assert max_product_of_two([2, 1, 0, 1000]) == 2000 # Edge cases assert max_product_of_two([1, 1, 1, 1, 1]) == 1 assert max_product_of_two([0, 0, 0, 0, 5]) == 0","solution":"def max_product_of_two(arr): Function to find the maximum product of two distinct elements in the array. Parameters: arr (list): a list of integers Returns: int: maximum product of two distinct elements in the array if len(arr) < 2: return 0 arr.sort(reverse=True) return arr[0] * arr[1]"},{"question":"def solve(grid: List[str], N: int, M: int, sx: int, sy: int, tx: int, ty: int) -> int: Determine the minimum number of moves required to reach the target cell from the starting cell. If it is not possible to reach the target cell, return -1. >>> grid = [ ... '0000', ... '0110', ... '0110', ... '0000', ... ] >>> solve(grid, 4, 4, 0, 0, 3, 3) 6 >>> grid = [ ... '000', ... '010', ... '000', ... ] >>> solve(grid, 3, 3, 0, 0, 2, 2) 4 >>> grid = [ ... '00', ... '00', ... ] >>> solve(grid, 2, 2, 0, 0, 1, 1) 2 >>> grid = [ ... '01', ... '10', ... ] >>> solve(grid, 2, 2, 0, 0, 1, 1) -1 >>> grid = [ ... '1111', ... '0110', ... '0110', ... '0000', ... ] >>> solve(grid, 4, 4, 0, 0, 3, 3) -1 >>> grid = [ ... '0000', ... '0000', ... '0000', ... '0000', ... ] >>> solve(grid, 4, 4, 0, 0, 3, 3) 6 >>> grid = [ ... '1111', ... '1100', ... '1111', ... '0000', ... ] >>> solve(grid, 4, 4, 0, 0, 3, 3) -1","solution":"from collections import deque def min_moves(grid, N, M, sx, sy, tx, ty): # Helper function to check if a cell is within grid bounds and of the same type def is_valid(nx, ny, cell_type): return 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == cell_type and not visited[nx][ny] visited = [[False] * M for _ in range(N)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up queue = deque([(sx, sy, 0)]) # (current_x, current_y, current_moves) visited[sx][sy] = True cell_type = grid[sx][sy] # Type of the starting cell while queue: x, y, moves = queue.popleft() if x == tx and y == ty: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, cell_type): visited[nx][ny] = True queue.append((nx, ny, moves + 1)) return -1 # Function to handle input as specified def solve(grid, N, M, sx, sy, tx, ty): return min_moves(grid, N, M, sx, sy, tx, ty)"},{"question":"def is_prime(n): Returns True if n is a prime number, otherwise False. >>> is_prime(0) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(9) False def prime_indices(nums): Given a list of integers, returns a new list containing only the elements whose indices are prime numbers. >>> prime_indices([10, 15, 20, 25, 30, 35]) [20, 25, 35] >>> prime_indices([5, 6, 7, 8, 9, 10]) [7, 8, 10] >>> prime_indices([1, 2, 3, 4, 5]) [3, 4] >>> prime_indices([]) [] >>> prime_indices([11]) [] >>> prime_indices([2, 3, 5, 7, 11, 13, 17]) [5, 7, 13] >>> prime_indices([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7]","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def prime_indices(nums): Given a list of integers, returns a new list containing only the elements whose indices are prime numbers. return [nums[i] for i in range(len(nums)) if is_prime(i)]"},{"question":"def max_sum_subarray_two_distinct(n, a): Returns the maximum sum of a subarray that contains at most two distinct integers. >>> max_sum_subarray_two_distinct(5, [1, 2, 1, 2, 3]) == 6 >>> max_sum_subarray_two_distinct(8, [1, 2, 3, 4, 3, 2, 1, 2]) == 10 pass # Sample Unit Tests def test_example_1(): assert max_sum_subarray_two_distinct(5, [1, 2, 1, 2, 3]) == 6 def test_example_2(): assert max_sum_subarray_two_distinct(8, [1, 2, 3, 4, 3, 2, 1, 2]) == 10 def test_all_same_elements(): assert max_sum_subarray_two_distinct(4, [5, 5, 5, 5]) == 20 def test_all_distinct_elements(): assert max_sum_subarray_two_distinct(4, [1, 2, 3, 4]) == 7 def test_two_distinct_elements(): assert max_sum_subarray_two_distinct(6, [1, 2, 1, 2, 1, 2]) == 9 def test_empty_array(): assert max_sum_subarray_two_distinct(0, []) == 0 def test_single_element(): assert max_sum_subarray_two_distinct(1, [10]) == 10 def test_two_elements(): assert max_sum_subarray_two_distinct(2, [1, 2]) == 3 def test_large_numbers(): assert max_sum_subarray_two_distinct(3, [1000000000, 1000000000, 1000000000]) == 3000000000","solution":"def max_sum_subarray_two_distinct(n, a): Returns the maximum sum of a subarray that contains at most two distinct integers. if n == 0: return 0 max_sum = 0 current_sum = 0 start = 0 distinct_count = {} for end in range(n): current_sum += a[end] if a[end] in distinct_count: distinct_count[a[end]] += 1 else: distinct_count[a[end]] = 1 while len(distinct_count) > 2: current_sum -= a[start] if distinct_count[a[start]] == 1: del distinct_count[a[start]] else: distinct_count[a[start]] -= 1 start += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def top_k_heroes(n, k, m, scores): Determines the scores of the top k heroes based on their event scores. :param n: Number of events :param k: Number of top heroes to advance :param m: Number of heroes :param scores: List of lists, where each list contains the scores of the hero in n events. :return: List of the scores of the top k heroes in descending order pass def test_top_k_heroes(): assert top_k_heroes(3, 2, 4, [ [10, 20, 30], [50, 60, 70], [30, 40, 50], [60, 20, 10] ]) == [180, 120] assert top_k_heroes(2, 1, 3, [ [20, 30], [15, 25], [30, 40] ]) == [70] assert top_k_heroes(4, 3, 5, [ [10, 10, 10, 10], [20, 20, 20, 20], [30, 30, 30, 30], [40, 40, 40, 40], [50, 50, 50, 50] ]) == [200, 160, 120] assert top_k_heroes(2, 2, 4, [ [5, 10], [10, 5], [0, 0], [10, 10] ]) == [20, 15] assert top_k_heroes(3, 3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [24, 15, 6]","solution":"def top_k_heroes(n, k, m, scores): Determines the scores of the top k heroes based on their event scores. :param n: Number of events :param k: Number of top heroes to advance :param m: Number of heroes :param scores: List of lists, where each list contains the scores of the hero in n events. :return: List of the scores of the top k heroes in descending order total_scores = [(sum(scores[i]), i) for i in range(m)] total_scores.sort(key=lambda x: (-x[0], x[1])) top_heroes_scores = [score for score, idx in total_scores[:k]] return top_heroes_scores"},{"question":"def lowest_common_ancestor(N: int, nodes: List[Tuple[int, int]], p: int, q: int) -> int: Find the lowest common ancestor (LCA) of two given nodes in the binary tree. The LCA of two nodes p and q in a binary tree is the lowest (i.e., deepest) node that is an ancestor of both p and q, where we allow a node to be a descendant of itself. Args: N (int): Number of nodes in the tree. nodes (List[Tuple[int, int]]): List of tuples where each tuple consists of two integers representing the left and right children of the i-th node. p (int): First node. q (int): Second node. Returns: int: The value of the lowest common ancestor. >>> lowest_common_ancestor(5, [(2, 3), (4, 5), (0, 0), (0, 0), (0, 0)], 4, 5) 2 >>> lowest_common_ancestor(3, [(2, 3), (0, 0), (0, 0)], 2, 3) 1","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def build_tree(nodes): node_list = [TreeNode(i) for i in range(len(nodes)+1)] for i, (l, r) in enumerate(nodes): if l != 0: node_list[i+1].left = node_list[l] if r != 0: node_list[i+1].right = node_list[r] return node_list[1] if node_list else None def findLCA(root, p, q): if root is None: return None if root.val == p or root.val == q: return root left_lca = findLCA(root.left, p, q) right_lca = findLCA(root.right, p, q) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca def lowest_common_ancestor(N, nodes, p, q): root = build_tree(nodes) lca_node = findLCA(root, p, q) return lca_node.val if lca_node else -1"},{"question":"def lexicographically_smallest_list(nums): Returns the lexicographically smallest list by reversing subarrays. >>> lexicographically_smallest_list([4, 5, 1, 3, 2]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_list([1]) [1] >>> lexicographically_smallest_list([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_list([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_list([1000, 2000, 0, 999, 1]) [0, 1, 999, 1000, 2000]","solution":"def lexicographically_smallest_list(nums): Returns the lexicographically smallest list by reversing subarrays. return sorted(nums)"},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[str]) -> int: Determines the shortest path from the top-left corner to the bottom-right corner in an n x m grid layout of rooms. Args: n (int): Number of rows. m (int): Number of columns. grid (list of str): List of strings representing the grid. Returns: int: The minimum number of steps needed to reach the bottom-right corner, or -1 if no such path exists. >>> grid = [ ... \\"......\\", ... \\".#..\\", ... \\"...#.#\\", ... \\".#....\\", ... \\"......\\" ... ] >>> shortest_path(5, 6, grid) 9 >>> grid = [ ... \\"#\\", ... \\"#.#\\", ... \\"#\\" ... ] >>> shortest_path(3, 3, grid) -1 import pytest def test_shortest_path_example_1(): grid = [ \\"......\\", \\".#..\\", \\"...#.#\\", \\".#....\\", \\"......\\" ] assert shortest_path(5, 6, grid) == 9 def test_shortest_path_example_2(): grid = [ \\"#\\", \\"#.#\\", \\"#\\" ] assert shortest_path(3, 3, grid) == -1 def test_shortest_path_no_blocks(): grid = [ \\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\" ] assert shortest_path(5, 5, grid) == 8 def test_shortest_path_blocked_start(): grid = [ \\"#....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\" ] assert shortest_path(5, 5, grid) == -1 def test_shortest_path_blocked_end(): grid = [ \\".....\\", \\".....\\", \\".....\\", \\".....\\", \\"....#\\" ] assert shortest_path(5, 5, grid) == -1 def test_shortest_path_single_cell_open(): grid = [\\".\\"] assert shortest_path(1, 1, grid) == 0 def test_shortest_path_single_cell_closed(): grid = [\\"#\\"] assert shortest_path(1, 1, grid) == -1","solution":"from collections import deque def shortest_path(n, m, grid): Determines the shortest path from the top-left corner to the bottom-right corner in an n x m grid layout of rooms. Args: n (int): Number of rows. m (int): Number of columns. grid (list of str): List of strings representing the grid. Returns: int: The minimum number of steps needed to reach the bottom-right corner, or -1 if no such path exists. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1,0), (1,0), (0,-1), (0,1)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited[0][0] = True while queue: x, y, steps = queue.popleft() if x == n-1 and y == m-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"def is_target_sum_in_matrix(n: int, target: int, matrix: List[List[int]]) -> str: Determine if there is a sequence in the matrix that sums up to the target integer. >>> is_target_sum_in_matrix(3, 8, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) == \\"YES\\" >>> is_target_sum_in_matrix(3, 15, [ ... [1, -1, 1], ... [-1, 1, -1], ... [1, -1, 1]]) == \\"NO\\"","solution":"def is_target_sum_in_matrix(n, target, matrix): def dfs(x, y, current_sum): if current_sum == target: return True visited.add((x, y)) # 8 possible directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: if dfs(nx, ny, current_sum + matrix[nx][ny]): return True visited.discard((x, y)) return False for i in range(n): for j in range(n): visited = set() if dfs(i, j, matrix[i][j]): return \\"YES\\" return \\"NO\\""},{"question":"def minPathCost(grid): Given a 2D grid, find a path from top-left corner to bottom-right corner, which minimizes the total cost. You can only move either down or right at any point in time. >>> minPathCost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> minPathCost([ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 12 pass from solution import minPathCost def test_minPathCost_example1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert minPathCost(grid) == 7 def test_minPathCost_example2(): grid = [ [1, 2, 3], [4, 5, 6] ] assert minPathCost(grid) == 12 def test_minPathCost_singleElement(): grid = [ [5] ] assert minPathCost(grid) == 5 def test_minPathCost_singleRow(): grid = [ [1, 2, 3, 4] ] assert minPathCost(grid) == 10 def test_minPathCost_singleColumn(): grid = [ [1], [2], [3], [4] ] assert minPathCost(grid) == 10 def test_minPathCost_allZeros(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert minPathCost(grid) == 0","solution":"def minPathCost(grid): Given a 2D grid, find a path from top-left corner to bottom-right corner, which minimizes the total cost. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize DP table with the same size as grid dp = [[0 for _ in range(n)] for _ in range(m)] # Initialize the first cell with the grid's first cell value dp[0][0] = grid[0][0] # Fill the first row for i in range(1, n): dp[0][i] = dp[0][i - 1] + grid[0][i] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"class MaxStack: A stack that supports push, pop, top, and retrieving the maximum element. Methods: push(x: int): Push element x onto the stack. pop(): Remove the element on the top of the stack. top() -> int: Get the element on the top of the stack. max() -> int: Retrieve the maximum element in the stack. >>> max_stack = MaxStack() >>> max_stack.push(10) >>> max_stack.push(20) >>> max_stack.push(30) >>> max_stack.max() 30 >>> max_stack.top() 30 >>> max_stack.pop() >>> max_stack.max() 20 >>> max_stack.top() 20 >>> max_stack.pop() >>> max_stack.max() 10 def __init__(self): pass def push(self, x: int): pass def pop(self): pass def top(self) -> int: pass def max(self) -> int: pass","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self): if self.stack: popped = self.stack.pop() if popped == self.max_stack[-1]: self.max_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def max(self) -> int: if self.max_stack: return self.max_stack[-1] return None"},{"question":"def min_time_units(n: int, p: List[int]) -> int: Returns the minimum total number of time units required to allow all participants to complete their respective problems. Each participant can solve one problem per time unit, provided no other participant is working on that same problem. Parameters: n (int): Number of participants. p (List[int]): Number of problems each participant wants to solve. Returns: int: Minimum total number of time units required. >>> min_time_units(3, [2, 3, 3]) 3 >>> min_time_units(4, [1, 2, 4, 3]) 4 >>> min_time_units(1, [100]) 100 >>> min_time_units(5, [5, 5, 5, 5, 5]) 5 >>> min_time_units(5, [2, 3, 9, 6, 1]) 9","solution":"def min_time_units(n, p): Returns the minimum total number of time units required to allow all participants to complete their respective problems. Each participant can solve one problem per time unit, provided no other participant is working on that same problem. Parameters: n (int): Number of participants. p (list of int): Number of problems each participant wants to solve. Returns: int: Minimum total number of time units required. return max(p) # The minimum time units required is the maximum number of problems any single participant has."},{"question":"def magic_tree_height(n: int) -> int: Returns the height of the Magic Tree after n time units. >>> magic_tree_height(0) == 1 >>> magic_tree_height(1) == 3 >>> magic_tree_height(4) == 36 def observe_magic_trees(observations: List[int]) -> List[int]: Given a list of observations (time units), return a list of heights of the Magic Tree for each observation. >>> observe_magic_trees([0, 1, 4]) == [1, 3, 36] >>> observe_magic_trees([3, 2, 5]) == [18, 6, 108]","solution":"def magic_tree_height(n): Returns the height of the Magic Tree after n time units. height = 1 # Initially the height is 1 unit for i in range(1, n + 1): if i % 2 == 1: height *= 3 else: height *= 2 return height def observe_magic_trees(observations): Given a list of observations (time units), return a list of heights of the Magic Tree for each observation. return [magic_tree_height(n) for n in observations]"},{"question":"def average_wait_time(wait_times): Returns the average waiting time for buses, excluding negative wait times. If all wait times are negative, returns -1. >>> average_wait_time([3, -1, 5, 7, 0]) == 3 >>> average_wait_time([-2, -3, -9]) == -1 >>> average_wait_time([10, 5, 15, 3, 2]) == 7 >>> average_wait_time([10]) == 10 >>> average_wait_time([-10]) == -1 >>> average_wait_time([-10, 0, 5, -3]) == 2 >>> average_wait_time([100, -100, 50, -50, 25]) == 58","solution":"def average_wait_time(wait_times): Returns the average waiting time for buses, excluding negative wait times. If all wait times are negative, returns -1. positive_wait_times = [time for time in wait_times if time >= 0] if not positive_wait_times: return -1 total_wait_time = sum(positive_wait_times) average_wait_time = total_wait_time // len(positive_wait_times) return average_wait_time"},{"question":"def longest_subsequence_in_substring(S: str, T: str) -> int: Determine the length of the longest subsequence of S which is also a substring of T. >>> longest_subsequence_in_substring(\\"abc\\", \\"abcd\\") 3 >>> longest_subsequence_in_substring(\\"xyz\\", \\"xyzxyz\\") 3 >>> longest_subsequence_in_substring(\\"abc\\", \\"xyxaybyc\\") 1 pass def solve(queries: List[Tuple[str, str]]) -> List[int]: Solve the problem for multiple queries. >>> solve([(\\"abc\\", \\"abcd\\"), (\\"xyz\\", \\"xyzxyz\\"), (\\"abc\\", \\"xyxaybyc\\")]) [3, 3, 1] pass from typing import List, Tuple def test_examples(): queries = [ (\\"abc\\", \\"abcd\\"), (\\"xyz\\", \\"xyzxyz\\"), (\\"abc\\", \\"xyxaybyc\\") ] expected_results = [3, 3, 1] assert solve(queries) == expected_results def test_edge_cases(): # Both strings are the same queries = [ (\\"a\\", \\"a\\"), (\\"ab\\", \\"ab\\"), (\\"abcd\\", \\"abcd\\") ] expected_results = [1, 2, 4] assert solve(queries) == expected_results # S is a single character queries = [ (\\"a\\", \\"bbbbba\\"), (\\"x\\", \\"zxz\\"), (\\"c\\", \\"abcd\\") ] expected_results = [1, 1, 1] assert solve(queries) == expected_results # T does not contain any character of S queries = [ (\\"abc\\", \\"defgh\\"), (\\"xyz\\", \\"abcd\\"), (\\"ghi\\", \\"xyz\\") ] expected_results = [0, 0, 0] assert solve(queries) == expected_results def test_large_input(): import string queries = [ (string.ascii_lowercase, string.ascii_lowercase * 10), (string.ascii_lowercase, \\"a\\" * 5000), ] expected_results = [26, 1] assert solve(queries) == expected_results","solution":"def longest_subsequence_in_substring(S, T): Determine the length of the longest subsequence of S which is also a substring of T. m, n = len(S), len(T) # Initialize the dp matrix. dp = [[0] * (n + 1) for _ in range(m + 1)] max_length = 0 # Fill the dp matrix for i in range(1, m + 1): for j in range(1, n + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) else: dp[i][j] = 0 return max_length def solve(queries): results = [] for S, T in queries: results.append(longest_subsequence_in_substring(S, T)) return results"},{"question":"def max_subgrid_with_threshold(matrix: List[List[int]], threshold: int) -> int: Find the largest size of a sub-grid such that the sum of all its elements is less than or equal to the given threshold. >>> max_subgrid_with_threshold([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 6) # returns 1 >>> max_subgrid_with_threshold([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4) # returns 2 >>> max_subgrid_with_threshold([[10, 20, 30], [5, 25, 35], [15, 5, 10]], 50) # returns 1 >>> max_subgrid_with_threshold([[1]], 1) # returns 1 >>> max_subgrid_with_threshold([[10, 20], [30, 40]], 5) # returns 0 >>> max_subgrid_with_threshold([[1, 2, 3, 4]], 5) # returns 1 >>> max_subgrid_with_threshold([[1], [2], [3], [4]], 3) # returns 1","solution":"def max_subgrid_with_threshold(matrix, threshold): Find the largest size of a sub-grid such that the sum of all its elements is less than or equal to the given threshold. if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) max_size = 0 for r in range(rows): for c in range(cols): current_sum = 0 size = 0 while r + size < rows and c + size < cols: for k in range(size + 1): current_sum += matrix[r + size][c + k] current_sum += matrix[r + k][c + size] current_sum -= matrix[r + size][c + size] # Remove the double counted element if current_sum > threshold: break size += 1 max_size = max(max_size, size) return max_size"},{"question":"def allocate_students(n, m, c, preferences): Allocates students to classes based on their preferences and capacities. Args: n (int): The number of students. m (int): The number of classes. c (int): The maximum capacity of each class. preferences (List[List[int]]): A list where each sublist contains the preferences of a student (starting with the number of preferences followed by class indices). Returns: str: \\"Possible\\" followed by the allocation of students or \\"Impossible\\". >>> n = 6 >>> m = 3 >>> c = 2 >>> preferences = [ ... [3, 1, 2, 3], ... [2, 2, 3], ... [3, 1, 3, 2], ... [1, 3], ... [3, 2, 1, 3], ... [2, 3, 1] ... ] >>> allocate_students(n, m, c, preferences) Possible 1 2 1 3 2 1","solution":"def allocate_students(n, m, c, preferences): # Initialization of class capacities and student allocations capacities = [0] * m allocation = [-1] * n # Allocation process for i, pref in enumerate(preferences): for class_choice in pref[1:]: if capacities[class_choice - 1] < c: capacities[class_choice - 1] += 1 allocation[i] = class_choice break # Check if all students have been allocated if -1 in allocation: return \\"Impossible\\" else: result = [\\"Possible\\"] result.extend(map(str, allocation)) return \\"n\\".join(result)"},{"question":"def min_moves_to_visit_all(N: int, points: List[int]) -> int: Returns the minimum number of moves required to visit all districts at least once starting from any given district in a circular city. Parameters: N (int): The number of districts. points (List[int]): A list containing the number of points of interest in each district. Returns: int: The minimum number of moves required to visit all districts. >>> min_moves_to_visit_all(4, [3, 0, 2, 4]) 3 >>> min_moves_to_visit_all(1, [5]) 0 >>> min_moves_to_visit_all(2, [1, 2]) 1 >>> min_moves_to_visit_all(5, [1, 1, 1, 1, 1]) 4 >>> min_moves_to_visit_all(10, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) 9","solution":"def min_moves_to_visit_all(N, points): Returns the minimum number of moves required to visit all districts at least once starting from any given district in a circular city. return N - 1"},{"question":"def longest_subarray_with_equal_odd_even(n: int, array: List[int]) -> int: Nadia has an array of n positive integers. She's interested in finding the longest contiguous subarray that has an equal number of odd and even elements. Args: n: An integer representing the number of elements in the array. array: A list of integers representing the values of the array elements. Returns: An integer representing the length of the longest contiguous subarray with an equal number of odd and even elements. Examples: >>> longest_subarray_with_equal_odd_even(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_subarray_with_equal_odd_even(5, [2, 4, 6, 1, 3]) 4 >>> longest_subarray_with_equal_odd_even(5, [1, 3, 5, 7, 9]) 0","solution":"def longest_subarray_with_equal_odd_even(n, array): count = 0 max_length = 0 index_map = {0: -1} # To handle case when subarray starts from index 0 for i in range(n): if array[i] % 2 == 0: count += 1 else: count -= 1 if count in index_map: max_length = max(max_length, i - index_map[count]) else: index_map[count] = i return max_length # Example Usage: # n = 6 # array = [1, 2, 3, 4, 5, 6] # print(longest_subarray_with_equal_odd_even(n, array)) # Output: 6"},{"question":"def count_special_subarrays(n, k, arr): Carla wants to count the number of special subarrays of a given array. A subarray is called special if the sum of the subarray is divisible by a given integer k. Given an array of integers and an integer k, find the number of special subarrays. Args: n (int): The number of elements in the array. k (int): The integer by which the subarray sum must be divisible. arr (List[int]): The list of integers representing the array. Returns: int: The number of special subarrays. Examples: >>> count_special_subarrays(5, 5, [5, 1, 2, 3, 4]) 4 >>> count_special_subarrays(4, 3, [3, 6, 9, 12]) 10 from solution import count_special_subarrays def test_example_1(): assert count_special_subarrays(5, 5, [5, 1, 2, 3, 4]) == 4 def test_example_2(): assert count_special_subarrays(4, 3, [3, 6, 9, 12]) == 10 def test_single_element_array(): assert count_special_subarrays(1, 1, [1]) == 1 assert count_special_subarrays(1, 2, [2]) == 1 assert count_special_subarrays(1, 5, [4]) == 0 def test_large_k(): assert count_special_subarrays(5, 1000000000, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) == 15 def test_no_special_subarrays(): assert count_special_subarrays(4, 5, [1, 1, 1, 1]) == 0 def test_all_same_elements(): assert count_special_subarrays(5, 2, [2, 2, 2, 2, 2]) == 15","solution":"def count_special_subarrays(n, k, arr): count_map = {0: 1} # To store frequency of prefix sums mod k prefix_sum = 0 special_subarray_count = 0 for num in arr: prefix_sum += num mod_value = prefix_sum % k if mod_value in count_map: special_subarray_count += count_map[mod_value] count_map[mod_value] += 1 else: count_map[mod_value] = 1 return special_subarray_count"},{"question":"def max_subarray_sum(arr): Implement Kadane's Algorithm to find the maximum subarray sum. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 def process_test_cases(T, test_cases): Process multiple test cases to find the maximum subarray sum for each. >>> T = 2 >>> test_cases = [(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (5, [1, 2, 3, 4, 5])] >>> process_test_cases(T, test_cases) [6, 15] >>> T = 3 >>> test_cases = [(4, [-1, -2, -3, -4]), (3, [1, 1, 1]), (7, [2, -1, 2, 3, 4, -5, 2])] >>> process_test_cases(T, test_cases) [-1, 3, 10]","solution":"def max_subarray_sum(arr): Implement Kadane's Algorithm to find the maximum subarray sum. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_test_cases(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] arr = test_cases[i][1] results.append(max_subarray_sum(arr)) return results"},{"question":"def trap(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped between the buildings after it rains. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([0, 0, 0, 0, 0]) 0 >>> trap([1, 1, 1, 1, 1]) 0 >>> trap([5]) 0 >>> trap([5, 0]) 0 >>> trap([0, 5]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): Calculate the maximum amount of water that can be trapped between the buildings. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotateRight(head, k): Rotate the list to the right by k places and return the head of the modified linked list. If the linked list is empty or has only one node, return the original list. Parameters: head (ListNode): The head of the singly linked list. k (int): The number of places to rotate the list. Returns: ListNode: The head of the modified linked list. def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linkedlist_to_list(head): lst = [] while head: lst.append(head.value) head = head.next return lst # Unit Test def test_rotate_right_example_1(): head = list_to_linkedlist([1, 2, 3, 4, 5]) k = 2 new_head = rotateRight(head, k) assert linkedlist_to_list(new_head) == [4, 5, 1, 2, 3] def test_rotate_right_example_2(): head = list_to_linkedlist([10, 20, 30, 40, 50]) k = 3 new_head = rotateRight(head, k) assert linkedlist_to_list(new_head) == [30, 40, 50, 10, 20] def test_rotate_right_with_k_zero(): head = list_to_linkedlist([1, 2, 3, 4, 5]) k = 0 new_head = rotateRight(head, k) assert linkedlist_to_list(new_head) == [1, 2, 3, 4, 5] def test_rotate_right_with_k_equal_length(): head = list_to_linkedlist([1, 2, 3, 4, 5]) k = 5 new_head = rotateRight(head, k) assert linkedlist_to_list(new_head) == [1, 2, 3, 4, 5] def test_rotate_right_with_empty_list(): head = list_to_linkedlist([]) k = 5 new_head = rotateRight(head, k) assert linkedlist_to_list(new_head) == [] def test_rotate_right_with_single_node(): head = list_to_linkedlist([1]) k = 5 new_head = rotateRight(head, k) assert linkedlist_to_list(new_head) == [1] def test_rotate_right_with_k_larger_than_length(): head = list_to_linkedlist([1, 2, 3, 4, 5]) k = 7 new_head = rotateRight(head, k) assert linkedlist_to_list(new_head) == [4, 5, 1, 2, 3]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Find the length of the linked list length = 1 current = head while current.next: current = current.next length += 1 # Make the linked list circular current.next = head # Compute the effective rotations needed k = k % length if k == 0: current.next = None return head # Find the new tail of the rotated list steps_to_new_tail = length - k new_tail = head for _ in range(steps_to_new_tail - 1): new_tail = new_tail.next # Set the new head and break the circle new_head = new_tail.next new_tail.next = None return new_head def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linkedlist_to_list(head): lst = [] while head: lst.append(head.value) head = head.next return lst"},{"question":"def preprocess_array(arr): Preprocess the array to get the prefix sums. >>> preprocess_array([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] >>> preprocess_array([-1, -2, -3, -4, -5]) [0, -1, -3, -6, -10, -15] >>> preprocess_array([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0, 0] pass def subarray_sum(prefix_sums, L, R): Returns the sum of the subarray from index L to R using the prefix sums. >>> prefix_sums = preprocess_array([1, 2, 3, 4, 5]) >>> subarray_sum(prefix_sums, 1, 3) 6 >>> subarray_sum(prefix_sums, 2, 4) 9 >>> subarray_sum(prefix_sums, 1, 5) 15 >>> prefix_sums = preprocess_array([-1, -2, -3, -4, -5]) >>> subarray_sum(prefix_sums, 1, 3) -6 >>> subarray_sum(prefix_sums, 2, 4) -9 >>> subarray_sum(prefix_sums, 1, 5) -15 pass def process_queries(arr, queries): Process each query and return the results as a list. >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> process_queries(arr, queries) [6, 9, 15] >>> arr = [-1, -2, -3, -4, -5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> process_queries(arr, queries) [-6, -9, -15] >>> arr = [0, 0, 0, 0, 0] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> process_queries(arr, queries) [0, 0, 0] pass","solution":"def preprocess_array(arr): Preprocess the array to get the prefix sums. prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] return prefix_sums def subarray_sum(prefix_sums, L, R): Returns the sum of the subarray from index L to R using the prefix sums. return prefix_sums[R] - prefix_sums[L - 1] def process_queries(arr, queries): Process each query and return the results as a list. prefix_sums = preprocess_array(arr) results = [] for L, R in queries: results.append(subarray_sum(prefix_sums, L, R)) return results"},{"question":"def fastest_delivery(n, m, k, roads, queries): Function to determine the fastest delivery route from s to d for each query. :param n: Number of warehouses :param m: Number of roads :param k: Number of queries :param roads: List of tuples representing the roads (u, v, t) :param queries: List of tuples representing the queries (s, d) :return: List containing the minimum travel time for each query or -1 if no path exists >>> fastest_delivery(5, 6, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 3, 6), (1, 5, 10)], [(1, 5), (2, 4), (1, 3), (3, 5), (5, 1)]) [10, 5, 3, 7, -1] >>> fastest_delivery(3, 2, 2, [(1, 2, 1), (2, 3, 1)], [(1, 3), (3, 1)]) [2, -1]","solution":"import heapq import sys def dijkstra(n, graph, start): Dijkstra's algorithm to find the shortest path from start to all other vertices in a weighted graph. :param n: Number of warehouses (vertices) :param graph: Adjacency list representation of the graph :param start: Starting vertex for Dijkstra :return: List of shortest distances from start to each vertex (1-indexed) dist = [sys.maxsize] * (n + 1) dist[start] = 0 pq = [(0, start)] # (distance, vertex) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: if current_dist + weight < dist[v]: dist[v] = current_dist + weight heapq.heappush(pq, (dist[v], v)) return dist def fastest_delivery(n, m, k, roads, queries): Function to determine the fastest delivery route from s to d for each query. :param n: Number of warehouses :param m: Number of roads :param k: Number of queries :param roads: List of tuples representing the roads (u, v, t) :param queries: List of tuples representing the queries (s, d) :return: List containing the minimum travel time for each query or -1 if no path exists # Build the graph as an adjacency list graph = [[] for _ in range(n + 1)] for u, v, t in roads: graph[u].append((v, t)) results = [] for s, d in queries: dist = dijkstra(n, graph, s) if dist[d] == sys.maxsize: results.append(-1) else: results.append(dist[d]) return results"},{"question":"def distinct_shot_heights(T: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int]]]]) -> List[int]: Calculate the number of distinct shot heights across specified ranges in the array. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], List[Tuple[int, int]]]]): A list of tuples where each tuple contains: - an integer N which is the size of the array, - an integer Q which is the number of ranges, - a list of N integers representing the heights of the targets, - a list of Q tuples (L, R) representing the inclusive range of indices for Alex to shoot. Returns: List[int]: A list of integers where each integer represents the number of distinct height values present in the specified range [L, R] after the reduction by 1 due to Alex's shot. Example: >>> distinct_shot_heights(1, [(5, 3, [4, 3, 5, 2, 1], [(1, 3), (2, 5), (1, 5)])]) [3, 4, 5] >>> distinct_shot_heights(2, [(4, 2, [4, 3, 4, 3], [(1, 2), (3, 4)]), (6, 3, [1, 2, 3, 4, 5, 6], [(1, 6), (2, 5), (3, 3)])]) [2, 2, 6, 4, 1]","solution":"def distinct_shot_heights(T, test_cases): results = [] for i in range(T): N, Q, heights, queries = test_cases[i] for query in queries: L, R = query shot_heights = set(heights[L-1:R]) results.append(len(shot_heights)) return results"},{"question":"def set_intersection(set1, set2): Calculate the intersection of two given sets. The sets will be represented as lists of integers, where each list can contain numbers ranging from -50 to 50. Return the intersection of the sets as a list, sorted in ascending order. If there is no intersection, return an empty list. Args: set1: List of integers representing the first set. set2: List of integers representing the second set. Returns: A sorted list of integers representing the intersection of the two sets. >>> set_intersection([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) [4, 5] >>> set_intersection([10, 20, 30], [-10, 0, 10]) [10] >>> set_intersection([-1, -2, -3], [1, 2, 3]) [] from solution import set_intersection def test_intersection_with_common_elements(): assert set_intersection([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) == [4, 5] def test_intersection_with_single_common_element(): assert set_intersection([10, 20, 30], [-10, 0, 10]) == [10] def test_intersection_with_no_common_elements(): assert set_intersection([-1, -2, -3], [1, 2, 3]) == [] def test_intersection_with_empty_set1(): assert set_intersection([], [1, 2, 3]) == [] def test_intersection_with_empty_set2(): assert set_intersection([1, 2, 3], []) == [] def test_intersection_with_both_empty_sets(): assert set_intersection([], []) == [] def test_intersection_with_identical_sets(): assert set_intersection([1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_intersection_with_repeated_elements(): assert set_intersection([1, 1, 2, 2, 3, 3], [2, 2, 3, 3, 4, 4]) == [2, 3]","solution":"def set_intersection(set1, set2): Returns the intersection of two sets as a sorted list. Args: set1: List of integers representing the first set. set2: List of integers representing the second set. Returns: A sorted list of integers representing the intersection of the two sets. # Convert lists to sets and find the intersection intersection = set(set1) & set(set2) # Convert the intersection set to a sorted list return sorted(intersection)"},{"question":"from typing import List, Tuple def find_scc_and_largest_scc_size(N: int, M: int, edges: List[Tuple[int, int]]) -> Tuple[int, int]: Finds the number of Strongly Connected Components (SCCs) and the size of the largest SCC in a given directed graph. Parameters: N (int): Number of nodes M (int): Number of edges edges (list of tuples): List of directed edges (u, v) Returns: tuple: Number of SCCs, Size of the largest SCC Examples: >>> find_scc_and_largest_scc_size(5, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)]) (2, 3) >>> find_scc_and_largest_scc_size(1, 0, []) (1, 1)","solution":"from collections import defaultdict, deque def find_scc_and_largest_scc_size(N, M, edges): Finds the number of Strongly Connected Components (SCCs) and the size of the largest SCC in a given directed graph. Parameters: N (int): Number of nodes M (int): Number of edges edges (list of tuples): List of directed edges (u, v) Returns: tuple: Number of SCCs, Size of the largest SCC def kosaraju(): def dfs1(v): visited[v] = True for next_node in adj[v]: if not visited[next_node]: dfs1(next_node) stack.append(v) def dfs2(v): visited[v] = True scc_size[0] += 1 for next_node in rev_adj[v]: if not visited[next_node]: dfs2(next_node) adj = defaultdict(list) rev_adj = defaultdict(list) for u, v in edges: adj[u].append(v) rev_adj[v].append(u) visited = [False] * (N + 1) stack = [] for i in range(1, N + 1): if not visited[i]: dfs1(i) visited = [False] * (N + 1) num_scc = 0 largest_scc_size = 0 while stack: node = stack.pop() if not visited[node]: scc_size = [0] dfs2(node) num_scc += 1 largest_scc_size = max(largest_scc_size, scc_size[0]) return num_scc, largest_scc_size return kosaraju() # Example usage: N = 5 M = 5 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)] print(find_scc_and_largest_scc_size(N, M, edges)) # Output: (2, 3)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(nodes): Build binary tree from node list. def is_balanced_tree(root): Check if the binary tree is balanced. def is_balanced(n, node_list): Given the root of a binary tree, determine if it is a balanced binary tree. >>> is_balanced(3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)]) True >>> is_balanced(7, [(1, 2, 3), (2, 4, 5), (3, -1, 6), (4, -1, -1), (5, -1, -1), (6, 7, -1), (7, -1, -1)]) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(nodes): tree_nodes = {} tree_nodes[1] = TreeNode(nodes[1][0]) for i in range(1, len(nodes)): value, left, right = nodes[i] if left != -1: if left not in tree_nodes: tree_nodes[left] = TreeNode(nodes[left][0]) tree_nodes[i].left = tree_nodes[left] if right != -1: if right not in tree_nodes: tree_nodes[right] = TreeNode(nodes[right][0]) tree_nodes[i].right = tree_nodes[right] return tree_nodes[1] def is_balanced_tree(root): def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, balanced = check_balance(root) return balanced def is_balanced(n, node_list): nodes = [None] + node_list # Adjust index to match problem statement. root = build_tree(nodes) return is_balanced_tree(root)"},{"question":"def swap_first_last_char(text): Swaps the first and last characters of the input string. If the string has a length of 1 or is empty, returns the string as it is. >>> swap_first_last_char('hello') 'oellh' >>> swap_first_last_char('a') 'a' >>> swap_first_last_char('') '' >>> swap_first_last_char('ab') 'ba' >>> swap_first_last_char('!@#') '#@!' >>> swap_first_last_char('aaa') 'aaa'","solution":"def swap_first_last_char(text): Swaps the first and last characters of the input string. If the string has a length of 1 or is empty, returns the string as it is. Parameters: text (str): The input string. Returns: str: The string with first and last characters swapped. if len(text) <= 1: return text return text[-1] + text[1:-1] + text[0]"},{"question":"def solve_sudoku(grid): Solve the Sudoku puzzle by filling the empty cells. Modifies the input grid in-place to represent the solution. Returns True if the Sudoku puzzle is solved successfully, else returns False. >>> input_grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] >>> expected_output = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] >>> solve_sudoku(input_grid) True >>> input_grid == expected_output True","solution":"def is_valid(grid, row, col, num): Check whether it will be legal to assign num to the given row, col. # Check if the number is not repeated in the current row and column for i in range(9): if grid[row][i] == num or grid[i][col] == num: return False # Check if the number is not repeated in the 3x3 subgrid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if grid[start_row + i][start_col + j] == num: return False return True def solve_sudoku(grid): Solve the Sudoku puzzle by filling the empty cells. Modifies the input grid in-place to represent the solution. Returns True if the Sudoku puzzle is solved successfully, else returns False. # Find an empty cell empty_cell = None for i in range(9): for j in range(9): if grid[i][j] == 0: empty_cell = (i, j) break if empty_cell: break # If there is no empty cell, puzzle is solved if not empty_cell: return True row, col = empty_cell # Try placing numbers 1 to 9 in the empty cell for num in range(1, 10): if is_valid(grid, row, col, num): grid[row][col] = num if solve_sudoku(grid): return True grid[row][col] = 0 # backtrack return False"},{"question":"def countStrings(N: int) -> int: Given an integer N, find the number of unique binary strings of length N that do not contain consecutive 1s. >>> countStrings(3) == 5 >>> countStrings(4) == 8 >>> countStrings(1) == 2 >>> countStrings(10) == 144 >>> countStrings(10000) > 0 MOD = 10**9 + 7 # edge case for smallest N if N == 1: return 2 # initialize dp arrays dp0 = [0] * (N+1) # ending in 0 dp1 = [0] * (N+1) # ending in 1 # base cases dp0[1] = 1 dp1[1] = 1 # populate the dp arrays for i in range(2, N+1): dp0[i] = (dp0[i-1] + dp1[i-1]) % MOD dp1[i] = dp0[i-1] # return the total number of valid strings of length N return (dp0[N] + dp1[N]) % MOD from solution import countStrings def test_example_1(): assert countStrings(3) == 5 def test_example_2(): assert countStrings(4) == 8 def test_smallest_n(): assert countStrings(1) == 2 def test_medium_n(): assert countStrings(10) == 144 def test_max_n(): assert countStrings(10000) > 0 # we're not checking the exact value for performance but it should not raise any error","solution":"def countStrings(N): MOD = 10**9 + 7 # edge case for smallest N if N == 1: return 2 # initialize dp arrays dp0 = [0] * (N+1) # ending in 0 dp1 = [0] * (N+1) # ending in 1 # base cases dp0[1] = 1 dp1[1] = 1 # populate the dp arrays for i in range(2, N+1): dp0[i] = (dp0[i-1] + dp1[i-1]) % MOD dp1[i] = dp0[i-1] # return the total number of valid strings of length N return (dp0[N] + dp1[N]) % MOD"},{"question":"def is_sas(n: int, sequence: List[int]) -> str: Determines if the given sequence is a Swapping Adjacent Sequence (SAS). Args: n: int - the length of the sequence. sequence: list of int - the sequence of integers. Returns: str - \\"YES\\" if the sequence is a SAS, otherwise \\"NO\\". >>> is_sas(5, [5, 4, 3, 2, 1]) \\"YES\\" >>> is_sas(6, [4, 3, 5, 2, 6, 1]) \\"NO\\"","solution":"def is_sas(n, sequence): Determines if the given sequence is a Swapping Adjacent Sequence (SAS). Args: n: int - the length of the sequence. sequence: list of int - the sequence of integers. Returns: str - \\"YES\\" if the sequence is a SAS, otherwise \\"NO\\". for i in range(1, n): if sequence[i] > sequence[i-1]: return \\"NO\\" return \\"YES\\""},{"question":"def count_valid_sequences(n: int) -> int: Calculate the number of valid sequences of tasks Polycarpus can plan over n days. >>> count_valid_sequences(3) 4 >>> count_valid_sequences(4) 8 >>> count_valid_sequences(1) 3","solution":"def count_valid_sequences(n): if n == 1: return 3 else: return 2 ** (n - 1)"},{"question":"from typing import List, Tuple def max_depth(P: int, M: int, orbits: List[Tuple[int, int]]) -> int: Determine the depth of the most distant moon from the central planet in terms of the number of hops in the graph. >>> max_depth(3, 3, [(1, 2), (2, 3), (1, 4)]) 2 >>> max_depth(1, 0, []) 0 >>> max_depth(1, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> max_depth(2, 4, [(1, 2), (1, 3), (2, 4), (3, 5)]) 2 >>> max_depth(2, 6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (6, 7)]) 3","solution":"def max_depth(P, M, orbits): from collections import defaultdict, deque # Create an adjacency list for representing the graph graph = defaultdict(list) for u, v in orbits: graph[u].append(v) # BFS to find the maximum depth from the central planet (node 1) queue = deque([(1, 0)]) # (node, current_depth) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) for neighbor in graph[node]: queue.append((neighbor, depth + 1)) return max_depth"},{"question":"from datetime import datetime from typing import List def calculate_total_duration(test_cases: List[List[str]]) -> List[int]: Given a list of test cases, where each test case contains a list of timestamps in the format YYYY-MM-DD HH:MM:SS, calculate the total duration in seconds that encompasses all the messages sent during that day. >>> calculate_total_duration([[\\"2023-04-23 10:00:00\\", \\"2023-04-23 10:30:00\\", \\"2023-04-23 11:00:00\\"]]) [3600] >>> calculate_total_duration([[\\"2023-03-15 08:00:00\\", \\"2023-03-15 08:15:00\\", \\"2023-03-15 08:15:00\\", \\"2023-03-15 09:45:00\\", \\"2023-03-15 10:00:00\\"]]) [7200] pass def process_input(input_str: str) -> List[List[str]]: Process the input string and convert it to the required format. >>> process_input(\\"2n3n2023-04-23 10:00:00n2023-04-23 10:30:00n2023-04-23 11:00:00n5n2023-03-15 08:00:00n2023-03-15 08:15:00n2023-03-15 08:15:00n2023-03-15 09:45:00n2023-03-15 10:00:00\\") [[\\"2023-04-23 10:00:00\\", \\"2023-04-23 10:30:00\\", \\"2023-04-23 11:00:00\\"], [\\"2023-03-15 08:00:00\\", \\"2023-03-15 08:15:00\\", \\"2023-03-15 08:15:00\\", \\"2023-03-15 09:45:00\\", \\"2023-03-15 10:00:00\\"]] pass","solution":"from datetime import datetime def calculate_total_duration(test_cases): results = [] for timestamps in test_cases: if not timestamps: results.append(0) continue # Convert timestamps to datetime objects datetime_list = [datetime.strptime(ts, \\"%Y-%m-%d %H:%M:%S\\") for ts in timestamps] # Find the minimum and maximum datetime min_timestamp = min(datetime_list) max_timestamp = max(datetime_list) # Calculate the total duration in seconds total_duration = (max_timestamp - min_timestamp).seconds results.append(total_duration) return results def process_input(input_str): lines = input_str.strip().split(\\"n\\") num_test_cases = int(lines[0]) index = 1 test_cases = [] for _ in range(num_test_cases): num_messages = int(lines[index]) index += 1 timestamps = lines[index:index + num_messages] test_cases.append(timestamps) index += num_messages return test_cases"},{"question":"def smallest_unique_permutation(s: str) -> str: Given a string s, find the lexicographically smallest permutation of s that has all unique characters. If no such permutation exists, return \\"no permutation\\". >>> smallest_unique_permutation(\\"google\\") 'eglo' >>> smallest_unique_permutation(\\"apple\\") 'aelp' >>> smallest_unique_permutation(\\"banana\\") 'abn' >>> smallest_unique_permutation(\\"abcde\\") 'abcde' def solve(test_cases: List[str]) -> List[str]: Given a list of test cases, where each test case is a string s, return a list of results where each result is the lexicographically smallest permutation of s with all unique characters, or \\"no permutation\\" if it is not possible. >>> solve([\\"google\\", \\"apple\\", \\"banana\\", \\"abcde\\"]) ['eglo', 'aelp', 'abn', 'abcde'] >>> solve([\\"hello\\", \\"world\\", \\"python\\", \\"programming\\"]) ['ehlo', 'dlorw', 'hnopty', 'agimnopr']","solution":"def smallest_unique_permutation(s): Finds the lexicographically smallest permutation of the string s that has all unique characters. If no such permutation exists, returns 'no permutation'. unique_chars = sorted(set(s)) return ''.join(unique_chars) def solve(test_cases): results = [] for s in test_cases: unique_permutation = smallest_unique_permutation(s) results.append(unique_permutation) return results"},{"question":"def process_employee_hierarchy(n, employees_info): Given a list of employees in a company where each employee is identified by a unique ID and a list of their subordinates, compute the following information for each employee: * Employee ID * Number of direct subordinates * Total number of subordinates (direct or indirect) * Level in the organizational hierarchy (assuming the CEO is at level 0) * Type of employee (CEO, Manager, or Staff) An employee who has subordinates is a Manager, while an employee at the top of the hierarchy with no superior is the CEO, and employees without any subordinates are Staff. Args: n (int): The number of employees employees_info (List[str]): List of employee information strings in the format \\"id subordinates\\" where 'subordinates' is a comma-separated list of subordinate IDs or empty if no subordinates. Returns: List[str]: List of formatted strings for each employee containing their information. Example: >>> n = 6 >>> employees_info = [\\"0 1,2\\", \\"1 3,4\\", \\"2 5\\", \\"3\\", \\"4\\", \\"5\\"] >>> process_employee_hierarchy(n, employees_info) [ \\"employee 0: direct_subordinates = 2, total_subordinates = 5, level = 0, CEO\\", \\"employee 1: direct_subordinates = 2, total_subordinates = 2, level = 1, Manager\\", \\"employee 2: direct_subordinates = 1, total_subordinates = 1, level = 1, Manager\\", \\"employee 3: direct_subordinates = 0, total_subordinates = 0, level = 2, Staff\\", \\"employee 4: direct_subordinates = 0, total_subordinates = 0, level = 2, Staff\\", \\"employee 5: direct_subordinates = 0, total_subordinates = 0, level = 2, Staff\\" ] from solution import process_employee_hierarchy def test_simple_hierarchy(): n = 3 employees_info = [ \\"0 1,2\\", \\"1\\", \\"2\\" ] result = process_employee_hierarchy(n, employees_info) expected = [ \\"employee 0: direct_subordinates = 2, total_subordinates = 2, level = 0, CEO\\", \\"employee 1: direct_subordinates = 0, total_subordinates = 0, level = 1, Staff\\", \\"employee 2: direct_subordinates = 0, total_subordinates = 0, level = 1, Staff\\" ] assert result == expected def test_multiple_levels(): n = 6 employees_info = [ \\"0 1,2\\", \\"1 3,4\\", \\"2 5\\", \\"3\\", \\"4\\", \\"5\\" ] result = process_employee_hierarchy(n, employees_info) expected = [ \\"employee 0: direct_subordinates = 2, total_subordinates = 5, level = 0, CEO\\", \\"employee 1: direct_subordinates = 2, total_subordinates = 2, level = 1, Manager\\", \\"employee 2: direct_subordinates = 1, total_subordinates = 1, level = 1, Manager\\", \\"employee 3: direct_subordinates = 0, total_subordinates = 0, level = 2, Staff\\", \\"employee 4: direct_subordinates = 0, total_subordinates = 0, level = 2, Staff\\", \\"employee 5: direct_subordinates = 0, total_subordinates = 0, level = 2, Staff\\" ] assert result == expected def test_only_ceo(): n = 1 employees_info = [ \\"0\\" ] result = process_employee_hierarchy(n, employees_info) expected = [ \\"employee 0: direct_subordinates = 0, total_subordinates = 0, level = 0, CEO\\" ] assert result == expected def test_two_level_hierarchy(): n = 4 employees_info = [ \\"0 1,2,3\\", \\"1\\", \\"2\\", \\"3\\" ] result = process_employee_hierarchy(n, employees_info) expected = [ \\"employee 0: direct_subordinates = 3, total_subordinates = 3, level = 0, CEO\\", \\"employee 1: direct_subordinates = 0, total_subordinates = 0, level = 1, Staff\\", \\"employee 2: direct_subordinates = 0, total_subordinates = 0, level = 1, Staff\\", \\"employee 3: direct_subordinates = 0, total_subordinates = 0, level = 1, Staff\\" ] assert result == expected","solution":"from collections import defaultdict, deque def process_employee_hierarchy(n, employees_info): employees = {} levels = {} for info in employees_info: parts = info.split() emp_id = int(parts[0]) subordinates = list(map(int, parts[1].split(','))) if len(parts) > 1 and parts[1] else [] employees[emp_id] = subordinates levels[emp_id] = -1 def count_total_subordinates(emp_id): if not employees[emp_id]: return 0 total = len(employees[emp_id]) for sub_id in employees[emp_id]: total += count_total_subordinates(sub_id) return total # Determine hierarchy levels and the root (CEO) reversed_tree = defaultdict(list) for emp_id, subs in employees.items(): for sub in subs: reversed_tree[sub].append(emp_id) CEO_id = None for emp_id in employees: if emp_id not in reversed_tree: CEO_id = emp_id break levels[CEO_id] = 0 queue = deque([CEO_id]) while queue: current = queue.popleft() current_level = levels[current] for sub in employees[current]: levels[sub] = current_level + 1 queue.append(sub) results = [] for emp_id in range(n): direct_subordinates = len(employees[emp_id]) total_subordinates = count_total_subordinates(emp_id) level = levels[emp_id] if emp_id == CEO_id: emp_type = \\"CEO\\" elif direct_subordinates > 0: emp_type = \\"Manager\\" else: emp_type = \\"Staff\\" results.append(f\\"employee {emp_id}: direct_subordinates = {direct_subordinates}, total_subordinates = {total_subordinates}, level = {level}, {emp_type}\\") return results"},{"question":"def restore_sequence(n: int, m: int, a: List[int], s: int) -> List[int]: Petya has a sequence of n integers, but he accidentally shuffled it. Fortunately, he remembers the sum of the original sequence, and that it contained exactly m unique integers. Restore the original sequence or report that it's impossible. >>> restore_sequence(5, 3, [1, 2, 2, 3, 2], 10) [1, 3, 2, 2, 2] >>> restore_sequence(3, 2, [5, 5, 5], 17) -1 Args: n (int): The length of the sequence. m (int): The number of unique integers in the sequence. a (List[int]): The shuffled sequence. s (int): The sum of the original sequence. Returns: List[int]: The original sequence of n integers or -1 if impossible.","solution":"def restore_sequence(n, m, a, s): from itertools import permutations from collections import Counter def check_sequence(seq): return sum(seq) == s and len(set(seq)) == m # Generate permutations of the given sequence for perm in permutations(a): if check_sequence(perm): return list(perm) return -1 # Example usage: # print(restore_sequence(5, 3, [1, 2, 2, 3, 2], 10)) # Output: [1, 3, 2, 2, 2] # print(restore_sequence(3, 2, [5, 5, 5], 17)) # Output: -1"},{"question":"def max_palindromic_segment_sum(n, thicknesses): Finds the maximum possible sum of thicknesses of any contiguous palindrome segment after optimal rearrangement. Parameters: n (int): number of books on the shelf thicknesses (List[int]): thickness of each book Returns: int: maximum possible sum of a contiguous palindrome segment Example: >>> max_palindromic_segment_sum(5, [1, 4, 1, 4, 1]) 11 >>> max_palindromic_segment_sum(4, [1, 2, 3, 4]) 4","solution":"from collections import Counter def max_palindromic_segment_sum(n, thicknesses): Finds the maximum possible sum of thicknesses of any contiguous palindrome segment after optimal rearrangement. count = Counter(thicknesses) half_sum = 0 max_single = 0 for thickness, freq in count.items(): pairs = (freq // 2) * 2 half_sum += thickness * pairs if freq % 2 != 0: max_single = max(max_single, thickness) return half_sum + max_single"},{"question":"def min_changes_to_avoid_consecutive_blocks(n, blocks): Returns the minimum number of changes required to ensure that no two consecutive blocks share the same color. >>> min_changes_to_avoid_consecutive_blocks(5, \\"RRGBB\\") == 2 >>> min_changes_to_avoid_consecutive_blocks(3, \\"RGB\\") == 0 pass","solution":"def min_changes_to_avoid_consecutive_blocks(n, blocks): Returns the minimum number of changes required to ensure that no two consecutive blocks share the same color. changes = 0 for i in range(1, n): if blocks[i] == blocks[i - 1]: changes += 1 if i + 1 < n: # Find a different color from the neighbors for color in 'RGB': if color != blocks[i - 1] and color != blocks[i + 1]: blocks = blocks[:i] + color + blocks[i + 1:] break else: # Last block must be different from the previous block for color in 'RGB': if color != blocks[i - 1]: blocks = blocks[:i] + color + blocks[i + 1:] break return changes"},{"question":"def maximum_gold(C): Garnet has stumbled across a mysterious forest filled with ancient treasures and mystical challenges. Each treasure chest in the forest contains a certain number of gold coins, and being the adventurous spirit she is, Garnet wants to collect as much gold as she can. However, each chest is guarded by a magical puzzle that either adds to or subtracts from the total number of coins collected so far. Determine the maximum coins Garnet can collect after traversing the entire forest for each scenario. She must collect coins from at least one chest, and she cannot skip any chests. :param C: List[int] - array of integers where each integer represents coins in each chest. :return: int - the maximum coins that can be collected. >>> maximum_gold([1, 2, 3, 4]) 10 >>> maximum_gold([-1, -2, -3, -4]) -1 >>> maximum_gold([3, -2, 5, -1]) 6 >>> maximum_gold([3, -2, -1, 5]) 5 >>> maximum_gold([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> maximum_gold([10]) 10 >>> maximum_gold([-10]) -10 >>> maximum_gold([i for i in range(1, 100001)]) sum(range(1, 100001)) >>> maximum_gold([10] * 50000 + [-1] * 50000) 500000 >>> maximum_gold([-1] * 50000 + [10] * 50000) 500000","solution":"def maximum_gold(C): Returns the maximum coins Garnet can collect from the given array of chests. :param C: List[int] - array of integers where each integer represents coins in each chest. :return: int - the maximum coins that can be collected. max_coins = current_sum = C[0] for coins in C[1:]: current_sum = max(coins, current_sum + coins) max_coins = max(max_coins, current_sum) return max_coins"},{"question":"def smallest_permutation(n: int, m: int, a: List[int], operations: List[Tuple[int, int]]) -> List[int]: Returns the lexicographically smallest permutation of the array that can be achieved by any number of reverse operations. Args: n (int): The length of the array. m (int): The number of operations. a (List[int]): The array elements. operations (List[Tuple[int, int]]): The endpoints of the subarray to reverse in each operation. Returns: List[int]: The lexicographically smallest permutation of the array. pass # Unit Tests def test_case_1(): n = 5 m = 3 a = [5, 3, 2, 4, 1] operations = [(1, 3), (2, 5), (1, 5)] assert smallest_permutation(n, m, a, operations) == [1, 2, 3, 4, 5] def test_case_2(): n = 3 m = 2 a = [3, 2, 1] operations = [(1, 2), (2, 3)] assert smallest_permutation(n, m, a, operations) == [1, 2, 3] def test_case_3(): n = 5 m = 1 a = [4, 2, 3, 5, 1] operations = [(2, 4)] assert smallest_permutation(n, m, a, operations) == [1, 2, 3, 4, 5] def test_case_4(): n = 4 m = 0 a = [1, 4, 3, 2] operations = [] assert smallest_permutation(n, m, a, operations) == [1, 2, 3, 4] def test_case_5(): n = 6 m = 2 a = [6, 5, 4, 3, 2, 1] operations = [(1, 3), (4, 6)] assert smallest_permutation(n, m, a, operations) == [1, 2, 3, 4, 5, 6]","solution":"def smallest_permutation(n, m, a, operations): Returns the lexicographically smallest permutation of the array that can be achieved by any number of reverse operations. # The simplest way to find the lexicographically smallest permutation of the given array # is to simply sort the array, ignoring the operations because any sorting can be # mimicked by appropriate sequence of reverses. return sorted(a)"},{"question":"def can_make_all_equal(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Sophie has an array of n integers. She can perform the following operation any number of times: choose any two integers in the array and replace them with their product. Sophie wants to know if it's possible to make all integers in the array equal by performing the operation no more than k times. Parameters: test_cases (List[Tuple[int, int, List[int]]]): List of tuples where each tuple contains: - an integer n (number of items in array) - an integer k (maximum number of operations allowed) - a list of integers (Sophie's array) Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case >>> can_make_all_equal([(4, 7, [1, 1, 1, 1]), (3, 0, [6, 9, 12]), (4, 10, [2, 3, 5, 7])]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> can_make_all_equal([(2, 2, [4, 2]), (5, 10000, [1, 10**6, 10**6, 2, 3])]) [\\"NO\\", \\"NO\\"] >>> can_make_all_equal([(1000, 10**9, [i + 1 for i in range(1000)])]) [\\"NO\\"]","solution":"def can_make_all_equal(test_cases): results = [] for case in test_cases: n, k, arr = case # If all elements are the same initially. if all(x == arr[0] for x in arr): results.append(\\"YES\\") else: # It's impossible if we are not allowed to perform any operations if k == 0: results.append(\\"NO\\") else: # We can always make all elements product to be zero which is trivially same number with few multiplications results.append(\\"NO\\") return results"},{"question":"def calculate_final_score(scores): Calculate the final score by discarding the highest and lowest scores and averaging the remaining three scores. Args: scores (list): List of five integers representing the scores from five judges. Returns: int: The average of the remaining three scores after discarding the highest and lowest scores. >>> calculate_final_score([15, 99, 50, 76, 88]) 71 >>> calculate_final_score([50, 50, 50, 50, 50]) 50 >>> calculate_final_score([70, 80, 90, 90, 10]) 80 >>> calculate_final_score([0, 0, 100, 100, 50]) 50 >>> calculate_final_score([10, 20, 30, 40, 50]) 30 >>> calculate_final_score([10, 20, 30, 40]) # Raises ValueError ValueError: Exactly 5 scores are required","solution":"def calculate_final_score(scores): Calculate the final score by discarding the highest and lowest scores and averaging the remaining three scores. if len(scores) != 5: raise ValueError(\\"Exactly 5 scores are required\\") sorted_scores = sorted(scores) remaining_scores = sorted_scores[1:4] # discarding the highest and lowest scores final_score = sum(remaining_scores) // len(remaining_scores) return final_score"},{"question":"def remaining_sellers(S: int, M: int, mergers: List[Tuple[int, int]]) -> int: Determine the number of remaining sellers after all the mergers. Parameters: S (int): Number of initial sellers. M (int): Number of mergers. mergers (list of tuple): List of mergers where each merger is represented by a tuple (u, v). Returns: int: Number of remaining sellers. Examples: >>> remaining_sellers(5, 0, []) 5 >>> remaining_sellers(5, 1, [(1, 2)]) 4 >>> remaining_sellers(6, 5, [(1, 2), (3, 2), (4, 2), (5, 2), (6, 2)]) 1 >>> remaining_sellers(5, 3, [(1, 3), (2, 3), (4, 5)]) 2 >>> remaining_sellers(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1","solution":"def remaining_sellers(S, M, mergers): Determine the number of remaining sellers after all the mergers. Parameters: S (int): Number of initial sellers. M (int): Number of mergers. mergers (list of tuple): List of mergers where each merger is represented by a tuple (u, v). Returns: int: Number of remaining sellers. existing_sellers = set(range(1, S + 1)) for u, v in mergers: if u in existing_sellers: existing_sellers.remove(u) return len(existing_sellers)"},{"question":"def longestBitonicSubarray(arr, n): Find the length of the longest subarray which is both strictly increasing and strictly decreasing. The subarray should initially be increasing and then start decreasing without any elements being repeated. :param arr: List[int] - An array of positive integers :param n: int - The size of the array :return: int - The length of the longest bitonic subarray Examples: >>> longestBitonicSubarray([1, 2, 3, 5, 4, 2, 1], 7) 7 >>> longestBitonicSubarray([1, 3, 2, 4, 5], 5) 3 pass","solution":"def longestBitonicSubarray(arr, n): if n == 0: return 0 inc = [0] * n dec = [0] * n inc[0] = 1 for i in range(1, n): if arr[i] > arr[i - 1]: inc[i] = inc[i - 1] + 1 else: inc[i] = 1 dec[n - 1] = 1 for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: dec[i] = dec[i + 1] + 1 else: dec[i] = 1 max_len = 0 for i in range(n): if inc[i] > 1 and dec[i] > 1: max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"def isSubsequence(s: str, pattern: str) -> bool: Determine if the pattern string is a subsequence of the main string s. >>> isSubsequence(\\"codingisfun\\", \\"cisn\\") True >>> isSubsequence(\\"codingisfun\\", \\"ciss\\") False","solution":"def isSubsequence(s, pattern): Determine if the pattern string is a subsequence of the main string s. Args: s (str): The main string. pattern (str): The pattern string. Returns: bool: True if pattern is a subsequence of s, False otherwise. i, j = 0, 0 while i < len(s) and j < len(pattern): if s[i] == pattern[j]: j += 1 i += 1 return j == len(pattern)"},{"question":"def find_missing_number(arr): Write a function that takes a single array of positive integers and returns the missing number from the sequence. The array is supposed to contain all numbers from 1 to n, where n is the length of the array plus one, but one number is missing. Parameters: arr (list): List of positive integers where one number is missing from the sequence Returns: int: The missing number in the sequence >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([1, 3]) 2","solution":"def find_missing_number(arr): Returns the missing number from the sequence. The array is supposed to contain all numbers from 1 to n, where n is the length of the array plus one, but one number is missing. Parameters: arr (list): List of positive integers where one number is missing from the sequence Returns: int: The missing number in the sequence n = len(arr) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"def maximum_product_of_three(nums): Returns the largest product possible from three of the numbers in the array. >>> maximum_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> maximum_product_of_three([-10, -10, 1, 3, 2]) 300 >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-1, -2, -3, -4]) -6 >>> maximum_product_of_three([-4, -3, 1, 2, 3]) 36 >>> maximum_product_of_three([1, -4, 3, -6, 7, 0]) 168","solution":"def maximum_product_of_three(nums): Returns the largest product possible from three of the numbers in the array. import sys max1 = max2 = max3 = -sys.maxsize - 1 min1 = min2 = sys.maxsize for num in nums: if num > max1: max3 = max2 max2 = max1 max1 = num elif num > max2: max3 = max2 max2 = num elif num > max3: max3 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2 * max3, min1 * min2 * max1)"},{"question":"from typing import List, Tuple, Union def min_buses_needed(datasets: List[Tuple[int, int, int]]) -> List[Union[int, str]]: Determines the minimum number of buses needed to transport all students for each dataset. Parameters: datasets (list): List of tuples where each tuple contains number of students, number of bus types, and capacities of each type. Returns: list: List of minimum buses needed or \\"Impossible\\" for each dataset. >>> datasets = [(100, 3, 30, 20, 50), (120, 4, 10, 10, 10, 10), (50, 2, 40, 20)] >>> min_buses_needed(datasets) [2, \\"Impossible\\", 2] >>> datasets = [(90, 1, 100), (110, 1, 100), (100, 1, 100)] >>> min_buses_needed(datasets) [1, \\"Impossible\\", 1] >>> datasets = [(100, 5, 20, 30, 40, 50, 60), (150, 3, 50, 50, 50), (200, 4, 70, 80, 40, 10)] >>> min_buses_needed(datasets) [2, 3, 3] >>> datasets = [(300, 3, 50, 50, 50), (400, 2, 200, 100)] >>> min_buses_needed(datasets) [\\"Impossible\\", \\"Impossible\\"] >>> datasets = [(0, 2, 10, 20), (0, 1, 5)] >>> min_buses_needed(datasets) [0, 0] >>> datasets = [(75, 3, 25, 25, 25), (100, 2, 50, 50)] >>> min_buses_needed(datasets) [3, 2]","solution":"def min_buses_needed(datasets): Determines the minimum number of buses needed to transport all students for each dataset. Parameters: datasets (list): List of tuples where each tuple contains number of students, number of bus types, and capacities of each type. Returns: list: List of minimum buses needed or \\"Impossible\\" for each dataset. results = [] for data in datasets: n = data[0] bus_capacities = sorted(data[2:], reverse=True) total_capacity = sum(bus_capacities) if total_capacity < n: results.append(\\"Impossible\\") continue buses_needed = 0 remaining_students = n for capacity in bus_capacities: if remaining_students <= 0: break trips = (remaining_students + capacity - 1) // capacity # Calculate required trips buses_needed += trips remaining_students -= (trips * capacity) results.append(buses_needed) return results"},{"question":"def check_overlap(existing_beds: List[Tuple[int, int]], new_bed: Tuple[int, int]) -> str: Check if the new flower bed overlaps with any of the existing flower beds. >>> check_overlap([(2, 4), (10, 14)], (5, 9)) \\"No\\" >>> check_overlap([(1, 3), (5, 8), (12, 15)], (3, 6)) \\"Yes\\"","solution":"def check_overlap(existing_beds, new_bed): a_new, b_new = new_bed for a, b in existing_beds: if a < b_new and a_new < b: return \\"Yes\\" return \\"No\\""},{"question":"def calculate_subtree_max_values(n: int, values: List[int], edges: List[Tuple[int, int]]) -> List[int]: Calculate the maximum value for each node's subtree in a tree. Args: - n (int): Number of nodes in the tree. - values (List[int]): Values assigned to each node. - edges (List[Tuple[int, int]]): List of edges defining the tree. Returns: - List[int]: A list of n integers where the i-th integer represents the maximum value in the subtree rooted at the i-th node. Example: >>> calculate_subtree_max_values(5, [1, 3, 2, 5, 4], [(1, 2), (1, 3), (2, 4), (2, 5)]) [5, 5, 2, 5, 4] >>> calculate_subtree_max_values(1, [42], []) [42] # Test cases def test_example_case(): n = 5 values = [1, 3, 2, 5, 4] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] assert calculate_subtree_max_values(n, values, edges) == [5, 5, 2, 5, 4] def test_single_node(): n = 1 values = [42] edges = [] assert calculate_subtree_max_values(n, values, edges) == [42] def test_linear_tree(): n = 4 values = [4, 3, 2, 1] edges = [(1, 2), (2, 3), (3, 4)] assert calculate_subtree_max_values(n, values, edges) == [4, 3, 2, 1] def test_star_shaped_tree(): n = 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (1, 4), (1, 5)] assert calculate_subtree_max_values(n, values, edges) == [5, 2, 3, 4, 5] def test_balanced_tree(): n = 7 values = [4, 5, 6, 7, 8, 9, 10] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] assert calculate_subtree_max_values(n, values, edges) == [10, 8, 10, 7, 8, 9, 10] def test_unbalanced_tree(): n = 5 values = [5, 4, 3, 2, 1] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert calculate_subtree_max_values(n, values, edges) == [5, 4, 3, 2, 1]","solution":"def calculate_subtree_max_values(n, values, edges): from collections import defaultdict, deque # Create adjacency list representation of the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Array to store the maximum values of subtrees subtree_max_values = [0] * (n + 1) # DFS function to calculate subtree maximum def dfs(node, parent): subtree_max = values[node - 1] for neighbor in tree[node]: if neighbor != parent: subtree_max = max(subtree_max, dfs(neighbor, node)) subtree_max_values[node] = subtree_max return subtree_max # Start DFS from root node, assuming 1 as the root dfs(1, -1) # Return the results without the extra zero at index 0 return subtree_max_values[1:] # Example usage n = 5 values = [1, 3, 2, 5, 4] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] print(calculate_subtree_max_values(n, values, edges))"},{"question":"from typing import List def max_number_friend_pairs(ages: List[int]) -> int: In the kingdom of Zombieland, there lives a group of friendly zombies who love to play with numbers. One day, Zombie King Zed devised a new game called \\"Number-Friends\\". In this game, two zombies are considered \\"number-friends\\" if the sum of the digits of their ages is equal. The zombies want to form the maximum number of number-friend pairs, and they need your help to do so. Each zombie has a unique age. Given the list of ages of all zombies in Zombieland, find the maximum number of number-friend pairs that can be formed. >>> max_number_friend_pairs([12, 21, 13, 31, 22]) 2 >>> max_number_friend_pairs([18, 99, 27, 54]) 1 >>> max_number_friend_pairs([10]) 0 >>> max_number_friend_pairs([10, 20, 30, 40, 50]) 0 >>> max_number_friend_pairs([111, 111, 111, 111]) 2","solution":"from collections import Counter def sum_of_digits(n): return sum(int(digit) for digit in str(n)) def max_number_friend_pairs(ages): digit_sum_count = Counter(sum_of_digits(age) for age in ages) return sum(count // 2 for count in digit_sum_count.values())"},{"question":"def max_value_connected_subgraph(n: int, m: int, values: List[int], edges: List[Tuple[int, int]], k: int) -> int: Find the maximum value sum possible for a connected subgraph containing exactly k vertices. A subgraph is connected if there exists a path between every pair of vertices in this subgraph. Args: n : int : The number of vertices m : int : The number of edges values : List[int] : The values of the vertices edges : List[Tuple[int, int]] : The list of edges k : int : The number of vertices in the subgraph Returns: int : The maximum sum of values possible for a connected subgraph containing exactly k vertices. If no such subgraph exists, returns -1. >>> max_value_connected_subgraph(5, 4, [1, 2, 3, 4, 5], [(0, 1), (0, 2), (0, 3), (3, 4)], 3) 10 >>> max_value_connected_subgraph(3, 3, [10, 20, 30], [(0, 1), (1, 2), (0, 2)], 2) 50 >>> max_value_connected_subgraph(4, 2, [5, 2, 8, 6], [(0, 1), (2, 3)], 3) -1 from solution import max_value_connected_subgraph def test_example_case_1(): n = 5 m = 4 values = [1, 2, 3, 4, 5] edges = [(0, 1), (0, 2), (0, 3), (3, 4)] k = 3 assert max_value_connected_subgraph(n, m, values, edges, k) == 10 def test_example_case_2(): n = 3 m = 3 values = [10, 20, 30] edges = [(0, 1), (1, 2), (0, 2)] k = 2 assert max_value_connected_subgraph(n, m, values, edges, k) == 50 def test_example_case_3(): n = 4 m = 2 values = [5, 2, 8, 6] edges = [(0, 1), (2, 3)] k = 3 assert max_value_connected_subgraph(n, m, values, edges, k) == -1 def test_single_component(): n = 4 m = 3 values = [1, 2, 3, 4] edges = [(0, 1), (1, 2), (2, 3)] k = 2 assert max_value_connected_subgraph(n, m, values, edges, k) == 7 def test_all_connected(): n = 3 m = 2 values = [5, 10, 15] edges = [(0, 1), (1, 2)] k = 3 assert max_value_connected_subgraph(n, m, values, edges, k) == 30","solution":"def max_value_connected_subgraph(n, m, values, edges, k): from itertools import combinations import networkx as nx # Create a graph using networkx G = nx.Graph() G.add_edges_from(edges) # Check if the subgraph with k nodes is connected def is_connected_subgraph(sub): subgraph = G.subgraph(sub) return nx.is_connected(subgraph) # Generate all combinations of k nodes all_combinations = combinations(range(n), k) max_sum = -1 for combo in all_combinations: if is_connected_subgraph(combo): subgraph_sum = sum(values[i] for i in combo) if subgraph_sum > max_sum: max_sum = subgraph_sum return max_sum # Example usage n = 5 m = 4 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (1, 4), (4, 5)] k = 3 # Convert edges from 1-based to 0-based edges = [(u - 1, v - 1) for u, v in edges] print(max_value_connected_subgraph(n, m, values, edges, k)) # the output should be 10"},{"question":"from typing import List def shortest_path(grid: List[str], n: int, sx: int, sy: int, dx: int, dy: int) -> int: Alyssa needs a program to find the shortest path from the starting point to the delivery point, avoiding obstacles. >>> shortest_path( [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ], 4, 0, 0, 3, 3 ) 6 >>> shortest_path( [ '..#..', '..#..', '.....', '.', '.....' ], 5, 0, 0, 4, 4 ) 8 >>> shortest_path( [ '', '', '', '' ], 4, 0, 0, 3, 3 ) -1 >>> shortest_path( [ '....', '....', '....', '....' ], 4, 2, 2, 2, 2 ) 0 >>> shortest_path( [ '....', '..', '.#..', '....' ], 4, 0, 0, 3, 3 ) 6 >>> shortest_path( [ '....', '.#..', '....', '...#' ], 4, 0, 0, 3, 3 ) -1","solution":"from collections import deque def shortest_path(grid, n, sx, sy, dx, dy): if grid[sx][sy] == '#' or grid[dx][dy] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False]*n for _ in range(n)] queue = deque([(sx, sy, 0)]) # (x, y, distance) visited[sx][sy] = True while queue: x, y, distance = queue.popleft() if x == dx and y == dy: return distance for dir in directions: nx, ny = x + dir[0], y + dir[1] if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, distance + 1)) return -1"},{"question":"def two_sum(arr: List[int], target: int) -> Tuple[int, int]: Given an array of integers \`arr\` and an integer \`target\`, return the indices of two numbers such that they add up to the \`target\`. You may assume that each input would have exactly one solution, and you may not use the same element twice. The answer must be returned as a tuple of indices. The order of indices in the tuple does not matter. If no solution is found, return an empty tuple. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1) >>> two_sum([1, 2, 3, 4], 8) ()","solution":"def two_sum(arr, target): Returns the indices of two numbers from the array 'arr' that add up to 'target'. The returned indices are in the form of a tuple. :param arr: List of integers. :param target: Integer target sum. :return: A tuple of indices or empty tuple if no solution is found. # Create a dictionary to store the value and its index num_to_index = {} for index, num in enumerate(arr): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return ()"},{"question":"def longest_substring_with_k_distinct_chars(k: int, s: str) -> int: Returns the length of the longest substring that contains at most k distinct characters. >>> longest_substring_with_k_distinct_chars(2, \\"eceba\\") == 3 >>> longest_substring_with_k_distinct_chars(3, \\"aaabbcc\\") == 7 >>> longest_substring_with_k_distinct_chars(1, \\"qwertyyuioop\\") == 2","solution":"def longest_substring_with_k_distinct_chars(k, s): Returns the length of the longest substring that contains at most k distinct characters. n = len(s) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 char_count = {} while right < n: current_char = s[right] char_count[current_char] = char_count.get(current_char, 0) + 1 right += 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def distribute_items(weights): Distributes items into two bags such that the absolute difference between their total weights is minimized. :param weights: List of integers representing weights of items :return: Minimum absolute difference between the total weights of the two bags >>> distribute_items([3, 1, 4, 2, 2]) 0 >>> distribute_items([1, 2, 1, 2, 1]) 1","solution":"def distribute_items(weights): Distributes items into two bags such that the absolute difference between their total weights is minimized. :param weights: List of integers representing weights of items :return: Minimum absolute difference between the total weights of the two bags total_weight = sum(weights) n = len(weights) target = total_weight // 2 # Dynamic programming to find the maximum weight as close to half of total weight (target) dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(target + 1): dp[i][j] = dp[i-1][j] if j >= weights[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-weights[i-1]] for j in range(target, -1, -1): if dp[n][j]: return abs(total_weight - 2 * j)"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Given an array of integers, where some elements appear twice and others appear once, find all integers that appear twice. The algorithm should have a linear runtime complexity and use only constant extra space. Example 1: >>> find_duplicates([4,3,2,7,8,2,3,1]) [2, 3] Example 2: >>> find_duplicates([1,1,2]) [1] Example 3: >>> find_duplicates([1]) [] :param nums: List[int] :return: List[int] # Implement the function here","solution":"def find_duplicates(nums): Given an array of integers, where some elements appear twice and others appear once, this function finds all integers that appear twice. The algorithm has a linear runtime complexity and uses constant extra space. :param nums: List[int] - The input list of integers :return: List[int] - A list of integers that appear twice in the input list duplicates = [] for num in nums: # Use the value as an index and check the sign of the element at that index if nums[abs(num) - 1] < 0: duplicates.append(abs(num)) # Flip the sign of the element at the found index to mark it as visited else: nums[abs(num) - 1] *= -1 return duplicates"},{"question":"def max_pyramid_levels(n: int) -> int: Given an integer n representing the number of marbles, calculates the maximum number of complete levels that can be built in a pyramid. Args: n (int): Number of marbles Returns: int: Maximum number of complete levels >>> max_pyramid_levels(15) 5 >>> max_pyramid_levels(6) 3","solution":"def max_pyramid_levels(n): Returns the maximum number of complete levels that can be built with n marbles. marbles_used = 0 level = 0 while marbles_used + (level + 1) <= n: level += 1 marbles_used += level return level"},{"question":"def can_transform_to_palindrome(s: str) -> str: Determine if it's possible to transform the string s into a palindrome by reversing any of its even-length substrings any number of times. >>> can_transform_to_palindrome(\\"abba\\") \\"YES\\" >>> can_transform_to_palindrome(\\"malayalam\\") \\"YES\\" >>> can_transform_to_palindrome(\\"abcd\\") \\"NO\\"","solution":"def can_transform_to_palindrome(s): Determine if it's possible to transform the string s into a palindrome by reversing any of its even-length substrings any number of times. # Count frequency of each character freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 # Check the number of characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # For a string to become a palindrome, at most one character can have an odd frequency if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def min_containers(n: int, weights: List[int], W: int) -> int: Returns the minimum number of containers required to pack all the items. :param n: int, number of items :param weights: list of int, weights of the items :param W: int, maximum weight capacity of each container :return: int, minimum number of containers required >>> min_containers(5, [2, 3, 5, 7, 1], 10) 2 >>> min_containers(4, [1, 2, 3, 4], 10) 1 >>> min_containers(3, [5, 5, 5], 5) 3 >>> min_containers(3, [100, 200, 300], 500) 2 >>> min_containers(1, [5], 10) 1 >>> min_containers(4, [4, 4, 4, 4], 4) 4","solution":"def min_containers(n, weights, W): Returns the minimum number of containers required to pack all the items. :param n: int, number of items :param weights: list of int, weights of the items :param W: int, maximum weight capacity of each container :return: int, minimum number of containers required # Sort weights in descending order to pack heavier items first weights.sort(reverse=True) containers = 0 while weights: container_capacity = W i = 0 while i < len(weights): if weights[i] <= container_capacity: container_capacity -= weights[i] weights.pop(i) else: i += 1 containers += 1 return containers"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"a\\") 1 >>> longest_unique_substring(\\"au\\") 2 >>> longest_unique_substring(\\"dvdf\\") 3 >>> longest_unique_substring(\\"anviaj\\") 5 >>> longest_unique_substring(\\"abcdefg\\") 7 >>> longest_unique_substring(\\"abcadefghi\\") 9","solution":"def longest_unique_substring(s): Returns the length of the longest substring with all distinct characters. n = len(s) max_len = 0 start = 0 seen_chars = {} for end in range(n): if s[end] in seen_chars and seen_chars[s[end]] >= start: start = seen_chars[s[end]] + 1 seen_chars[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [ [1, 2], [3, 4] ], [ [3, 1], [4, 2] ]","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[last - offset][first] # Move bottom element to left matrix[last - offset][first] = matrix[last][last - offset] # Move right element to bottom matrix[last][last - offset] = matrix[i][last] # Move top element to right matrix[i][last] = top return matrix"},{"question":"def printDiamond(n): Prints a diamond pattern with numbers ascending to n and then descending back to 1. Constraints: 1 â‰¤ n â‰¤ 50 Example: >>> printDiamond(3) 1 123 12345 123 1 >>> printDiamond(4) 1 123 12345 1234567 12345 123 1 pass import pytest def test_print_diamond_n_1(capsys): printDiamond(1) captured = capsys.readouterr() assert captured.out == \\"1n\\" def test_print_diamond_n_2(capsys): printDiamond(2) captured = capsys.readouterr() assert captured.out == \\" 1n123n 1n\\" def test_print_diamond_n_3(capsys): printDiamond(3) captured = capsys.readouterr() assert captured.out == \\" 1n 123n12345n 123n 1n\\" def test_print_diamond_n_4(capsys): printDiamond(4) captured = capsys.readouterr() assert captured.out == \\" 1n 123n 12345n1234567n 12345n 123n 1n\\" def test_invalid_input_too_low(): with pytest.raises(ValueError): printDiamond(0) def test_invalid_input_too_high(): with pytest.raises(ValueError): printDiamond(51) def test_invalid_input_negative(): with pytest.raises(ValueError): printDiamond(-5) if __name__ == '__main__': pytest.main()","solution":"def printDiamond(n): Prints a diamond pattern with numbers ascending to n and then descending back to 1. if n < 1 or n > 50: raise ValueError(\\"n must be between 1 and 50, inclusive.\\") # Top half of the diamond including the middle for i in range(1, n + 1): space = ' ' * (n - i) numbers = ''.join(str(x) for x in range(1, 2 * i)) print(space + numbers) # Bottom half of the diamond for i in range(n - 1, 0, -1): space = ' ' * (n - i) numbers = ''.join(str(x) for x in range(1, 2 * i)) print(space + numbers)"},{"question":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns a tuple of two integers from the list that sum up to the target. If such a pair does not exist, returns an empty tuple. Assumes that each input would have exactly one solution, and the same element cannot be used twice. Examples: >>> two_sum([2, 7, 11, 15], 9) (2, 7) >>> two_sum([3, 2, 4], 6) (2, 4) >>> two_sum([3, 3], 6) (3, 3) pass","solution":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns a tuple of two integers from the list that sum up to the target. If such a pair does not exist, returns an empty tuple. Assumes that each input would have exactly one solution, and the same element cannot be used twice. num_map = {} for num in nums: complement = target - num if complement in num_map: return (complement, num) num_map[num] = True return ()"},{"question":"def is_palindrome(s: str) -> str: Returns \\"YES\\" if the string is a palindrome considering only alphanumeric characters and ignoring case. Otherwise, returns \\"NO\\". >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") \\"YES\\" >>> is_palindrome(\\"race a car\\") \\"NO\\"","solution":"def is_palindrome(s): Returns \\"YES\\" if the string is a palindrome considering only alphanumeric characters and ignoring case. Otherwise, returns \\"NO\\". # Convert the string to lowercase to ignore cases s = s.lower() # Retain only alphanumeric characters alphanumeric_s = ''.join(char for char in s if char.isalnum()) # Check if the string is the same forwards and backwards if alphanumeric_s == alphanumeric_s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def process_queries(sequence, queries): Process a series of queries on a sequence of integers and return the results for type 2 queries. The function supports two types of queries: 1. Appending an integer to the end of the sequence. 2. Computing the product of elements within a specified range (inclusive), modulo 1,000,000,007. Args: sequence (List[int]): Initial sequence of integers. queries (List[Tuple[int, ...]]): A list of queries. Each query is a tuple where the first element is the query type (1 or 2). For type 1, the tuple has the form (1, X). For type 2, the tuple has the form (2, L, R). Returns: List[int]: Results of type 2 queries. Example: >>> process_queries([2, 3, 5, 7, 11], [(2, 1, 3), (1, 13), (2, 1, 6), (2, 4, 6)]) [30, 30030, 1001] from solution import process_queries def test_process_queries(): sequence = [2, 3, 5, 7, 11] queries = [(2, 1, 3), (1, 13), (2, 1, 6), (2, 4, 6)] assert process_queries(sequence, queries) == [30, 30030, 1001] def test_process_queries_single_query(): sequence = [4, 2, 6, 8] queries = [(2, 2, 4)] assert process_queries(sequence, queries) == [96] def test_process_queries_with_append(): sequence = [1, 2, 3] queries = [(2, 1, 2), (1, 5), (2, 1, 4)] assert process_queries(sequence, queries) == [2, 30] def test_process_queries_modulo(): sequence = [10**5] * 10 queries = [(2, 1, 10)] assert process_queries(sequence, queries) == [10**50 % 1000000007] def test_process_queries_with_empty_queries(): sequence = [1, 2, 3, 4, 5] queries = [] assert process_queries(sequence, queries) == [] def test_process_queries_append_only(): sequence = [1] queries = [(1, 2), (1, 3), (1, 4), (1, 5)] assert process_queries(sequence, queries) == []","solution":"def process_queries(sequence, queries): MODULO = 1000000007 results = [] for query in queries: if query[0] == 1: # Append integer X to the sequence sequence.append(query[1]) elif query[0] == 2: # Compute product of sequence elements from L to R (inclusive) L, R = query[1], query[2] product = 1 for i in range(L-1, R): product = (product * sequence[i]) % MODULO results.append(product) return results"},{"question":"from typing import List, Tuple def can_complete_tour(n: int, flights: List[Tuple[str, str]]) -> str: Determine if it's possible to complete a tour that visits all given cities exactly once and returns to the starting city. >>> can_complete_tour(4, [(\\"A\\", \\"B\\"), (\\"C\\", \\"D\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"A\\")]) == \\"YES\\" >>> can_complete_tour(3, [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"A\\")]) == \\"YES\\" >>> can_complete_tour(3, [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"A\\")]) == \\"NO\\" >>> can_complete_tour(4, [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\")]) == \\"NO\\" >>> can_complete_tour(2, [(\\"A\\", \\"B\\"), (\\"C\\", \\"D\\")]) == \\"NO\\" >>> can_complete_tour(1, [(\\"A\\", \\"A\\")]) == \\"YES\\" >>> can_complete_tour(0, []) == \\"NO\\"","solution":"from collections import defaultdict, deque def can_complete_tour(n, flights): # If there are no flights, a tour is not possible if n == 0: return \\"NO\\" # Create a graph from the given flights graph = defaultdict(list) in_degree = defaultdict(int) out_degree = defaultdict(int) cities = set() for flight in flights: src, dest = flight graph[src].append(dest) out_degree[src] += 1 in_degree[dest] += 1 cities.add(src) cities.add(dest) # Check if each city has equal in-degree and out-degree for city in cities: if in_degree[city] != out_degree[city]: return \\"NO\\" # Perform BFS to check connectivity def bfs(start_city): visited = set() queue = deque([start_city]) while queue: city = queue.popleft() if city not in visited: visited.add(city) for neighbor in graph[city]: if neighbor not in visited: queue.append(neighbor) return visited # Pick any starting city start_city = next(iter(cities)) visited_cities = bfs(start_city) if len(visited_cities) == len(cities): return \\"YES\\" else: return \\"NO\\""},{"question":"def sum_of_unique_prime_factors(n): Returns the sum of all unique prime factors of n. >>> sum_of_unique_prime_factors(12) 5 >>> sum_of_unique_prime_factors(30) 10 >>> sum_of_unique_prime_factors(2) 2 >>> sum_of_unique_prime_factors(10) 7 >>> sum_of_unique_prime_factors(1) 0 pass def process_test_cases(test_cases): Processes multiple test cases and returns the results for each case. >>> process_test_cases([12, 30, 10, 2]) [5, 10, 7, 2] pass","solution":"def sum_of_unique_prime_factors(n): Returns the sum of all unique prime factors of n. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True if n <= 1: return 0 prime_factors = set() # Check for number of twos while n % 2 == 0: prime_factors.add(2) n = n // 2 # Check for number of threes while n % 3 == 0: prime_factors.add(3) n = n // 3 # Now check for rest of the numbers i = 5 while i * i <= n: while n % i == 0: prime_factors.add(i) n = n // i while n % (i + 2) == 0: prime_factors.add(i + 2) n = n // (i + 2) i += 6 # If n is a prime number and greater than 2 if n > 2: prime_factors.add(n) return sum(prime_factors) def process_test_cases(test_cases): results = [] for case in test_cases: results.append(sum_of_unique_prime_factors(case)) return results"},{"question":"from typing import List def kth_smallest(arr: List[int], k: int) -> int: Finds the k-th smallest element in the array using the Quickselect algorithm. Args: arr (List[int]): List of integers. k (int): The position of the smallest element to find (1-based index). Returns: int: The k-th smallest element in the array. Examples: >>> kth_smallest([3, 2, 1, 5, 6, 4], 2) 2 >>> kth_smallest([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest([3, 2, 1, 5, 6, 4], 4) 4","solution":"from typing import List import random def kth_smallest(arr: List[int], k: int) -> int: Finds the k-th smallest element in the array using the Quickselect algorithm. def partition(left, right, pivot_index): pivot = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): if left == right: return arr[left] pivot_index = random.randint(left, right) pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"from typing import List, Tuple def preprocess_array_for_min(arr: List[int]) -> Tuple[List[List[int]], List[int]]: Preprocess the given array to allow efficient range minimum queries. pass def range_minimum_query(st: List[List[int]], log: List[int], L: int, R: int) -> int: Answer the range minimum query using the preprocessed array. pass def solve(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Solve the range minimum queries for the given array and queries. pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) arr = list(map(int, data[2:2+N])) queries = [] index = 2+N for _ in range(Q): L = int(data[index]) R = int(data[index+1]) queries.append((L, R)) index += 2 results = solve(arr, queries) for result in results: print(result)","solution":"def preprocess_array_for_min(arr): Preprocess the given array to allow efficient range minimum queries. import sys n = len(arr) log = [0] * (n + 1) for i in range(2, n + 1): log[i] = log[i // 2] + 1 k = log[n] + 1 st = [[0] * k for _ in range(n)] for i in range(n): st[i][0] = arr[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 return st, log def range_minimum_query(st, log, L, R): Answer the range minimum query using the preprocessed array. j = log[R - L + 1] return min(st[L][j], st[R - (1 << j) + 1][j]) def solve(arr, queries): st, log = preprocess_array_for_min(arr) results = [] for (L, R) in queries: results.append(range_minimum_query(st, log, L - 1, R - 1)) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) arr = list(map(int, data[2:2+N])) queries = [] index = 2+N for _ in range(Q): L = int(data[index]) R = int(data[index+1]) queries.append((L, R)) index += 2 results = solve(arr, queries) for result in results: print(result)"},{"question":"def pascalTriangle(N: int) -> List[List[int]]: Function to generate Pascal's Triangle up to N rows. >>> pascalTriangle(1) [[1]] >>> pascalTriangle(2) [[1], [1, 1]] >>> pascalTriangle(3) [[1], [1, 1], [1, 2, 1]] >>> pascalTriangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> pascalTriangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] pass","solution":"def pascalTriangle(N): Function to generate Pascal's Triangle up to N rows. if N <= 0: return [] triangle = [[1]] for i in range(1, N): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"def fizzBuzz(x): Generates a list of numbers from 1 to x with substitutions: - \\"Fizz\\" for multiples of 3. - \\"Buzz\\" for multiples of 5. - \\"FizzBuzz\\" for multiples of both 3 and 5. >>> fizzBuzz(15) [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] >>> fizzBuzz(5) [1, 2, \\"Fizz\\", 4, \\"Buzz\\"]","solution":"def fizzBuzz(x): Generates a list of numbers from 1 to x with substitutions: - \\"Fizz\\" for multiples of 3. - \\"Buzz\\" for multiples of 5. - \\"FizzBuzz\\" for multiples of both 3 and 5. result = [] for i in range(1, x + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"def store_and_retrieve(operations): Simulate a system that supports adding, retrieving, and deleting key-value pairs. >>> store_and_retrieve([\\"ADD 1 10\\", \\"GET 1\\", \\"DELETE 1\\", \\"GET 1\\"]) [\\"10\\", \\"None\\"] >>> store_and_retrieve([\\"ADD 2 20\\", \\"GET 2\\", \\"DELETE 2\\"]) [\\"20\\", \\"None\\"] pass def handle_multiple_datasets(datasets): Handle multiple datasets of operations and provide the results in order. >>> handle_multiple_datasets([[\\"ADD 1 10\\", \\"GET 1\\", \\"DELETE 1\\", \\"GET 1\\"], [\\"ADD 2 20\\", \\"GET 2\\", \\"DELETE 2\\"]]) [\\"10\\", \\"None\\", \\"\\", \\"20\\", \\"None\\", \\"\\"] pass","solution":"def store_and_retrieve(operations): storage = {} result = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": key = int(parts[1]) value = int(parts[2]) storage[key] = value elif command == \\"GET\\": key = int(parts[1]) result.append(str(storage.get(key, \\"None\\"))) elif command == \\"DELETE\\": key = int(parts[1]) if key in storage: del storage[key] return result def handle_multiple_datasets(datasets): results = [] for operations in datasets: results.extend(store_and_retrieve(operations)) results.append(\\"\\") # add an empty line after each dataset's output return results"},{"question":"from typing import List, Tuple def solve_test_cases(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Solve the minimum spanning tree problem for a given set of test cases. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): A list of tuples, where each tuple contains: - an integer n (number of parks), - an integer m (number of paths), - a list of tuples (u, v, w) where (u, v) is a path with length w. Returns: List[int]: A list of integers representing the minimum total length of paths for each test case, or -1 if it is not possible to visit all parks. >>> solve_test_cases(1, [(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 4), (1, 4, 5)])]) [6] >>> solve_test_cases(1, [(4, 2, [(1, 2, 1), (3, 4, 2)])]) [-1] >>> solve_test_cases(1, [(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 2)])]) [5] pass","solution":"class UnionFind: A class to represent a union-find (disjoint set) data structure with path compression and union by rank. def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 return True return False def minimum_spanning_tree(n, edges): uf = UnionFind(n) edges.sort(key=lambda x: x[2]) mst_weight = 0 count = 0 for u, v, w in edges: if uf.union(u - 1, v - 1): mst_weight += w count += 1 if count == n - 1: break if count != n - 1: return -1 return mst_weight def solve_test_cases(t, test_cases): results = [] for n, m, edges in test_cases: result = minimum_spanning_tree(n, edges) results.append(result) return results"},{"question":"def encode_message(k: int, message: str) -> str: Returns the encoded message by shifting each letter in the message k positions. >>> encode_message(3, \\"Hello, World!\\") == \\"Khoor, Zruog!\\" >>> encode_message(5, \\"ABC xyz 123\\") == \\"FGH cde 123\\"","solution":"def encode_message(k, message): Returns the encoded message by shifting each letter in the message k positions. encoded_message = [] for char in message: if char.isupper(): encoded_message.append(chr((ord(char) - ord('A') + k) % 26 + ord('A'))) elif char.islower(): encoded_message.append(chr((ord(char) - ord('a') + k) % 26 + ord('a'))) else: encoded_message.append(char) return ''.join(encoded_message)"},{"question":"MOD = 10**9 + 7 def unique_connections_count(n: int) -> int: Given the number of participants n, find the number of unique sets of connections formed after all participants have attended, modulo 10^9+7. >>> unique_connections_count(3) 3 >>> unique_connections_count(4) 15","solution":"MOD = 10**9 + 7 def unique_connections_count(n): # Use a recursive relation to calculate the result using dynamic programming if n == 1: return 1 dp = [0] * (n + 1) dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i - 1] * (2 * i - 3) % MOD return dp[n]"},{"question":"def count_unique_statements(statements): Returns the number of unique problem statements considering anagrams as identical. >>> count_unique_statements([\\"anagram\\", \\"nagaram\\", \\"manga ra\\"]) 1 >>> count_unique_statements([\\"hello world\\", \\"world hello\\", \\"hello there\\"]) 2","solution":"def count_unique_statements(statements): Returns the number of unique problem statements considering anagrams as identical. def normalize(statement): Normalizes the statement by sorting the characters (excluding spaces) return ''.join(sorted(statement.replace(' ', ''))) unique_statements = set() for statement in statements: normalized = normalize(statement) unique_statements.add(normalized) return len(unique_statements)"},{"question":"def findCommonSubstrings(s1: str, s2: str) -> List[str]: Write a function that takes in two strings and returns the longest common substrings between them. - A substring is defined as a contiguous sequence of characters within a string. - If there are multiple common substrings of the same maximum length, the function should return a list of all these substrings without duplicates. Args: s1 (str): First input string s2 (str): Second input string Returns: List[str]: List of the longest common substrings Examples: >>> findCommonSubstrings(\\"ABABC\\", \\"BABCA\\") [\\"BABC\\"] >>> findCommonSubstrings(\\"ABC\\", \\"XYZ\\") [] >>> findCommonSubstrings(\\"bananas\\", \\"cananas\\") [\\"ananas\\"]","solution":"def findCommonSubstrings(s1, s2): Returns the longest common substrings between s1 and s2. len_s1 = len(s1) len_s2 = len(s2) # Initialize a matrix to store lengths of longest common suffixes of substrings lcs_suffix = [[0] * (len_s2 + 1) for i in range(len_s1 + 1)] # Store length of longest common substring longest_len = 0 # Set to store all longest common substrings common_substrings = set() # Build the lcs_suffix matrix for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i - 1] == s2[j - 1]: lcs_suffix[i][j] = lcs_suffix[i - 1][j - 1] + 1 if lcs_suffix[i][j] > longest_len: longest_len = lcs_suffix[i][j] common_substrings = {s1[i - longest_len:i]} elif lcs_suffix[i][j] == longest_len: common_substrings.add(s1[i - longest_len:i]) return list(common_substrings)"},{"question":"def length_of_longest_substring(inputString: str) -> int: Given a string, find the length of the longest substring without repeating characters. Args: inputString (str): A non-empty string containing only ASCII characters. Returns: int: The length of the longest substring without repeating characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 pass","solution":"def length_of_longest_substring(inputString): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(inputString): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def product_except_self(nums): Given a list of positive integers nums, returns a new list such that each element at index i of the new list is the product of all the numbers in the original list except the one at i. This function achieves this without using division and in O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([5]) [1] >>> product_except_self([3, 8]) [8, 3] >>> product_except_self([1, 1, 1, 1, 1]) [1, 1, 1, 1, 1] >>> input_list = [1, 10**3, 10**3, 10**3] >>> output_list = [10**9, 10**6, 10**6, 10**6] >>> product_except_self(input_list) output_list >>> input_list = [1] * 10**5 >>> output_list = [1] * 10**5 >>> product_except_self(input_list) output_list","solution":"def product_except_self(nums): Given a list of positive integers nums, returns a new list such that each element at index i of the new list is the product of all the numbers in the original list except the one at i. This function achieves this without using division and in O(n) time complexity. n = len(nums) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def recommend_books(user_preferences: dict, book_list: list) -> list: Returns a list of book titles recommended for the user based on their preferences and book ratings. Parameters: - user_preferences: dict, where keys are genres and values are user's rating for that genre (1 to 5). - book_list: list of dicts, where each dict represents a book with 'title', 'genre', and 'rating'. Returns: - list of book titles. Example: >>> user_preferences = {'Science Fiction': 5, 'Fantasy': 4, 'Mystery': 3, 'Romance': 2} >>> book_list = [ ... {'title': 'Dune', 'genre': 'Science Fiction', 'rating': 4.8}, ... {'title': 'The Hobbit', 'genre': 'Fantasy', 'rating': 4.6}, ... {'title': 'The Girl with the Dragon Tattoo', 'genre': 'Mystery', 'rating': 4.1}, ... {'title': 'Pride and Prejudice', 'genre': 'Romance', 'rating': 4.4}, ... {'title': 'Foundation', 'genre': 'Science Fiction', 'rating': 4.3}, ... {'title': 'Twilight', 'genre': 'Romance', 'rating': 3.9} ... ] >>> recommend_books(user_preferences, book_list) ['Dune', 'The Hobbit', 'Foundation', 'The Girl with the Dragon Tattoo'] # Your code here from solution import recommend_books def test_recommend_books(): user_preferences = { 'Science Fiction': 5, 'Fantasy': 4, 'Mystery': 3, 'Romance': 2 } book_list = [ {'title': 'Dune', 'genre': 'Science Fiction', 'rating': 4.8}, {'title': 'The Hobbit', 'genre': 'Fantasy', 'rating': 4.6}, {'title': 'The Girl with the Dragon Tattoo', 'genre': 'Mystery', 'rating': 4.1}, {'title': 'Pride and Prejudice', 'genre': 'Romance', 'rating': 4.4}, {'title': 'Foundation', 'genre': 'Science Fiction', 'rating': 4.3}, {'title': 'Twilight', 'genre': 'Romance', 'rating': 3.9} ] expected_output = ['Dune', 'The Hobbit', 'Foundation', 'The Girl with the Dragon Tattoo'] assert recommend_books(user_preferences, book_list) == expected_output def test_no_recommendations(): user_preferences = { 'Science Fiction': 2, 'Fantasy': 1, 'Mystery': 2, 'Romance': 1 } book_list = [ {'title': 'Dune', 'genre': 'Science Fiction', 'rating': 4.8}, {'title': 'The Hobbit', 'genre': 'Fantasy', 'rating': 4.6}, {'title': 'The Girl with the Dragon Tattoo', 'genre': 'Mystery', 'rating': 4.1}, {'title': 'Pride and Prejudice', 'genre': 'Romance', 'rating': 4.4}, {'title': 'Foundation', 'genre': 'Science Fiction', 'rating': 4.3}, {'title': 'Twilight', 'genre': 'Romance', 'rating': 3.9} ] expected_output = [] assert recommend_books(user_preferences, book_list) == expected_output def test_multiple_recommendations_with_same_rating(): user_preferences = { 'Science Fiction': 5, 'Fantasy': 4, 'Mystery': 3, 'Romance': 2 } book_list = [ {'title': 'Dune', 'genre': 'Science Fiction', 'rating': 4.8}, {'title': 'The Hobbit', 'genre': 'Fantasy', 'rating': 4.6}, {'title': 'The Girl with the Dragon Tattoo', 'genre': 'Mystery', 'rating': 4.1}, {'title': 'Pride and Prejudice', 'genre': 'Romance', 'rating': 4.4}, {'title': 'Foundation', 'genre': 'Science Fiction', 'rating': 4.8}, {'title': 'Twilight', 'genre': 'Romance', 'rating': 3.9} ] expected_output = ['Dune', 'Foundation', 'The Hobbit', 'The Girl with the Dragon Tattoo'] assert recommend_books(user_preferences, book_list) == expected_output def test_preferences_with_no_matching_books(): user_preferences = { 'Horror': 5, 'Non-Fiction': 4, } book_list = [ {'title': 'Dune', 'genre': 'Science Fiction', 'rating': 4.8}, {'title': 'The Hobbit', 'genre': 'Fantasy', 'rating': 4.6}, {'title': 'The Girl with the Dragon Tattoo', 'genre': 'Mystery', 'rating': 4.1}, ] expected_output = [] assert recommend_books(user_preferences, book_list) == expected_output","solution":"def recommend_books(user_preferences, book_list): Returns a list of book titles recommended for the user based on their preferences and book ratings. Parameters: - user_preferences: dict, where keys are genres and values are user's rating for that genre (1 to 5). - book_list: list of dicts, where each dict represents a book with 'title', 'genre', and 'rating'. Returns: - list of book titles. # Filter books based on user preferences and book ratings recommended_books = [book for book in book_list if user_preferences.get(book['genre'], 0) >= 3 and book['rating'] >= 4.0] # Sort the recommended books by rating (descending) and title (alphabetically) if ratings are the same recommended_books.sort(key=lambda x: (-x['rating'], x['title'])) # Return the list of book titles return [book['title'] for book in recommended_books]"},{"question":"def is_balanced(s: str) -> bool: Returns True if the string s is correctly balanced, False otherwise. >>> is_balanced(\\"{[()]}\\") == True >>> is_balanced(\\"{[(])}\\") == False >>> is_balanced(\\"{[}\\") == False >>> is_balanced(\\"\\") == True >>> is_balanced(\\"()()\\") == True >>> is_balanced(\\"[]{}\\") == True >>> is_balanced(\\"({)}\\") == False >>> is_balanced(\\"[[\\") == False >>> is_balanced(\\"{[()]()()}\\") == True >>> is_balanced(\\"{[([)]]}\\") == False >>> is_balanced(\\"{{[[(())]]}}[)\\") == False >>> is_balanced(\\"({)}[\\") == False","solution":"def is_balanced(s): Returns True if the string s is correctly balanced, False otherwise. stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in s: if char in matching_bracket.values(): # If it's an opening bracket stack.append(char) elif char in matching_bracket.keys(): # If it's a closing bracket if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"def sum_of_squares_of_digits(num: int) -> int: Helper function to calculate the sum of squares of the digits of a number. >>> sum_of_squares_of_digits(19) == 82 >>> sum_of_squares_of_digits(82) == 68 >>> sum_of_squares_of_digits(68) == 100 >>> sum_of_squares_of_digits(100) == 1 def is_lucky_number(num: int) -> bool: Helper function to determine if a number is a lucky number. >>> is_lucky_number(1) == True >>> is_lucky_number(7) == True >>> is_lucky_number(10) == True >>> is_lucky_number(19) == True >>> is_lucky_number(2) == False def lucky_number(n: int) -> list[int]: Returns a list of all \\"lucky numbers\\" less than or equal to n. >>> lucky_number(10) == [1, 7, 10] >>> lucky_number(20) == [1, 7, 10, 13, 19] >>> lucky_number(1) == [1] >>> lucky_number(100) == [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97, 100] >>> lucky_number(0) == [] >>> lucky_number(1000) # testing within the constraint 1 <= n <= 1000","solution":"def sum_of_squares_of_digits(num): Helper function to calculate the sum of squares of the digits of a number. return sum(int(digit) ** 2 for digit in str(num)) def is_lucky_number(num): Helper function to determine if a number is a lucky number. seen = set() while num != 1 and num not in seen: seen.add(num) num = sum_of_squares_of_digits(num) return num == 1 def lucky_number(n): Returns a list of all \\"lucky numbers\\" less than or equal to n. return [i for i in range(1, n + 1) if is_lucky_number(i)]"},{"question":"def count_distinct_absolute_values(N: int, A: List[int]) -> int: Returns the number of distinct absolute values in the array A. >>> count_distinct_absolute_values(5, [-1, -1, 0, 1, -2]) 3 >>> count_distinct_absolute_values(3, [-3, -3, 3]) 1","solution":"def count_distinct_absolute_values(N, A): Returns the number of distinct absolute values in the array A. return len(set(abs(x) for x in A))"},{"question":"def total_pages_read(test_cases): Calculate the total number of pages read after completing a certain number of books in each test case. :param test_cases: List of test cases, each containing: - \\"M\\": the number of books, - \\"pages\\": a list of integers where each integer denotes the number of pages in a book, - \\"P\\": the number of books read :return: List of integers where each integer is the total number of pages read for the corresponding test case. >>> test_cases = [ {\\"M\\": 5, \\"pages\\": [100, 200, 300, 400, 500], \\"P\\": 3}, {\\"M\\": 4, \\"pages\\": [500, 600, 700, 800], \\"P\\": 2} ] >>> total_pages_read(test_cases) [600, 1100] >>> test_cases = [ {\\"M\\": 1, \\"pages\\": [1000], \\"P\\": 1} ] >>> total_pages_read(test_cases) [1000] >>> test_cases = [ {\\"M\\": 3, \\"pages\\": [150, 250, 350], \\"P\\": 3} ] >>> total_pages_read(test_cases) [750] >>> test_cases = [ {\\"M\\": 5, \\"pages\\": [100, 200, 300, 400, 500], \\"P\\": 0} ] >>> total_pages_read(test_cases) [0] >>> test_cases = [ {\\"M\\": 1000, \\"pages\\": [i for i in range(1, 1001)], \\"P\\": 1000} ] >>> total_pages_read(test_cases) [500500]","solution":"def total_pages_read(test_cases): results = [] for case in test_cases: M = case[\\"M\\"] pages = case[\\"pages\\"] P = case[\\"P\\"] results.append(sum(pages[:P])) return results"},{"question":"def min_trucks_required(num_cases: int, cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine the minimum number of delivery trucks required to deliver a certain number of parcels based on the weight capacity of the trucks and the weight of the parcels for each test case. >>> min_trucks_required(2, [(4, 10, [2, 3, 5, 8]), (3, 15, [5, 9, 12])]) ['Case #1: 2', 'Case #2: 2'] >>> min_trucks_required(1, [(3, 10, [8, 9, 10])]) ['Case #1: 3'] >>> min_trucks_required(1, [(4, 10, [0, 0, 0, 0])]) ['Case #1: 1']","solution":"def min_trucks_required(num_cases, cases): results = [] for i in range(num_cases): N, C, parcels = cases[i] parcels.sort(reverse=True) trucks = 0 used = [False] * N for j in range(N): if not used[j]: weight = parcels[j] used[j] = True trucks += 1 for k in range(j + 1, N): if not used[k] and weight + parcels[k] <= C: weight += parcels[k] used[k] = True results.append(f\\"Case #{i + 1}: {trucks}\\") return results"},{"question":"def is_possible_to_sort_grid(n: int, m: int, grid: List[str]) -> str: Determine whether it's possible to transform the grid into a grid with non-decreasing rows and columns. >>> is_possible_to_sort_grid(3, 3, ['123', '456', '789']) 'YES' >>> is_possible_to_sort_grid(3, 3, ['132', '465', '798']) 'NO' >>> is_possible_to_sort_grid(1, 5, ['12345']) 'YES'","solution":"def is_possible_to_sort_grid(n, m, grid): # Check each row for row in grid: if sorted(row) != list(row): return \\"NO\\" # Check each column for col in range(m): column = [grid[row][col] for row in range(n)] if sorted(column) != column: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def findSubsets(nums: List[int]) -> List[List[int]]: Given a set of numbers, return all possible subsets of the set. The solutions should not contain duplicate subsets, even if the input set contains duplicates, and the order of subsets does not matter. >>> sorted(findSubsets([1, 2, 2])) sorted([[], [1], [2], [1,2], [2,2], [1,2,2]]) >>> sorted(findSubsets([0])) sorted([[], [0]])","solution":"from itertools import combinations def findSubsets(nums): Returns all possible unique subsets of the given list of numbers. nums.sort() # Sort to manage duplicates result = set() for i in range(len(nums) + 1): for comb in combinations(nums, i): result.add(comb) return [list(subset) for subset in result]"},{"question":"def is_prime(num: int) -> bool: Checks if a number is prime. pass def generate_primes_up_to(n: int) -> List[int]: Generates a list of all prime numbers up to n. pass def max_prime_distance_permutation(n: int) -> List[int]: Generates a permutation of numbers from 1 to n that maximizes the prime distance. >>> max_prime_distance_permutation(1) [1] >>> max_prime_distance_permutation(4) [4, 3, 2, 1] # or any permutation that maximizes the prime distance >>> max_prime_distance_permutation(5) [5, 4, 3, 2, 1] # or any permutation that maximizes the prime distance pass","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def generate_primes_up_to(n): Generates a list of all prime numbers up to n. primes = [] for i in range(2, n + 1): if is_prime(i): primes.append(i) return primes def max_prime_distance_permutation(n): Generates a permutation of numbers from 1 to n that maximizes the prime distance. if n == 1: return [1] primes = generate_primes_up_to(n - 1) permutation = list(range(1, n + 1)) permutation.reverse() # Start with a descending order permutation. return permutation # Example usage: # output = max_prime_distance_permutation(4) # print(output) # Should output a permutation such as: [4, 3, 2, 1]"},{"question":"def check_rotations(test_cases): Check if there are any pairs of strings in the list that are rotations of each other. >>> check_rotations([[\\"abc\\", \\"bca\\", \\"xyz\\"]]) [\\"YES\\"] >>> check_rotations([[\\"dog\\", \\"cat\\", \\"god\\", \\"tac\\"]]) [\\"NO\\"] >>> check_rotations([[\\"abc\\", \\"cab\\", \\"bca\\", \\"def\\", \\"efd\\"]]) [\\"YES\\"] >>> check_rotations([[\\"aaa\\", \\"aaa\\", \\"aaa\\"]]) [\\"YES\\"] >>> check_rotations([[\\"abc\\", \\"def\\", \\"ghi\\"]]) [\\"NO\\"] >>> check_rotations([[\\"abc\\", \\"bca\\", \\"xyz\\"], [\\"dog\\", \\"cat\\", \\"god\\", \\"tac\\"]]) [\\"YES\\", \\"NO\\"]","solution":"def check_rotations(test_cases): def is_rotation(s1, s2): return len(s1) == len(s2) and s2 in (s1 + s1) results = [] for test_case in test_cases: lock_combinations = test_case n = len(lock_combinations) found = False for i in range(n): for j in range(i + 1, n): if is_rotation(lock_combinations[i], lock_combinations[j]): results.append(\\"YES\\") found = True break if found: break if not found: results.append(\\"NO\\") return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 pass # Unit Tests def test_example_1(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 def test_example_2(): assert length_of_longest_substring(\\"bbbbb\\") == 1 def test_example_3(): assert length_of_longest_substring(\\"pwwkew\\") == 3 def test_empty_string(): assert length_of_longest_substring(\\"\\") == 0 def test_single_character(): assert length_of_longest_substring(\\"a\\") == 1 def test_all_unique_characters(): assert length_of_longest_substring(\\"abcdef\\") == 6 def test_longer_string_with_repeats(): assert length_of_longest_substring(\\"aabbccabcdeabcd\\") == 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_set = set() left = 0 result = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) result = max(result, right - left + 1) return result"},{"question":"def alphabet_frequency(text: str) -> dict: Returns a dictionary with alphabets as keys and their frequencies as values. Non-alphabetic characters are ignored and all alphabetic characters are treated case-insensitively. >>> alphabet_frequency(\\"Hello, World!\\") == {'d': 1, 'e': 1, 'h': 1, 'l': 3, 'o': 2, 'r': 1, 'w': 1} >>> alphabet_frequency(\\"Coding is fun! 123\\") == {'c': 1, 'd': 1, 'f': 1, 'g': 1, 'i': 2, 'n': 2, 'o': 1, 's': 1, 'u': 1}","solution":"def alphabet_frequency(text): Returns a dictionary with alphabets as keys and their frequencies as values. Non-alphabetic characters are ignored and all alphabetic characters are treated case-insensitively. from collections import Counter # Filter only alphabetic characters and convert to lowercase filtered_text = [char.lower() for char in text if char.isalpha()] # Count frequencies frequency = Counter(filtered_text) # Sort the dictionary by keys and return return dict(sorted(frequency.items()))"},{"question":"def allocate_participants(m: int, n: int, skill_levels: List[int], difficulty_levels: List[int]) -> int: Given the skill levels of participants and the difficulty levels of questions, determine the maximum number of participants that can be allocated to the questions such that a participant can only be allocated to a question if their skill level is greater than or equal to the question's difficulty level. Args: m : int : number of participants n : int : number of questions skill_levels : List[int] : list of skill levels of participants difficulty_levels : List[int] : list of difficulty levels of questions Returns: int : maximum number of participants that can be allocated to the questions >>> allocate_participants(5, 3, [4, 3, 2, 5, 1], [2, 3, 4]) 3 >>> allocate_participants(4, 5, [1, 2, 3, 4], [1, 1, 2, 2, 3]) 4 pass from typing import List def test_example1(): assert allocate_participants(5, 3, [4, 3, 2, 5, 1], [2, 3, 4]) == 3 def test_example2(): assert allocate_participants(4, 5, [1, 2, 3, 4], [1, 1, 2, 2, 3]) == 4 def test_all_participants_capable(): assert allocate_participants(3, 3, [3, 3, 3], [3, 2, 1]) == 3 def test_no_matches(): assert allocate_participants(3, 3, [1, 1, 1], [2, 2, 2]) == 0 def test_partial_matches(): assert allocate_participants(3, 2, [1, 3, 4], [2, 3]) == 2 def test_more_questions_than_participants(): assert allocate_participants(3, 4, [3, 3, 3], [2, 3, 4, 1]) == 3 def test_more_participants_than_questions(): assert allocate_participants(4, 3, [4, 3, 2, 1], [1, 2, 3]) == 3 def test_equal_skill_and_difficulty_levels(): assert allocate_participants(3, 3, [1, 2, 3], [1, 2, 3]) == 3","solution":"def allocate_participants(m, n, skill_levels, difficulty_levels): skill_levels.sort() difficulty_levels.sort() participant_index = 0 question_index = 0 count = 0 while participant_index < m and question_index < n: if skill_levels[participant_index] >= difficulty_levels[question_index]: count += 1 question_index += 1 participant_index += 1 return count"},{"question":"def reverse_string(S: str) -> str: Write a function that reverses a given string. Args: S (str): A string of 1 to 100 lowercase alphabetical characters. Returns: str: The reversed string. Examples: >>> reverse_string('hello') 'olleh' >>> reverse_string('racecar') 'racecar' >>> reverse_string('a') 'a' >>> reverse_string('abcdefghijklmnopqrstuvwxyz') 'zyxwvutsrqponmlkjihgfedcba' >>> reverse_string('aaaa') 'aaaa'","solution":"def reverse_string(S): Returns the reversed string of the given string S. Args: S (str): A string of 1 to 100 lowercase alphabetical characters. Returns: str: The reversed string. return S[::-1]"},{"question":"def process_employee_data(data: str) -> str: Calculate and return the total salary, employee with the highest salary, and median salary from the given employee data string. >>> process_employee_data(\\"101|Alice|5000, 102|Bob|7000, 103|Charlie|6000, 104|David|8000, 105|Eve|5500\\") 'Total: 31500 Highest: David Median: 6000' >>> process_employee_data(\\"\\") 'Total: 0 Highest: None Median: 0' >>> process_employee_data(\\"101|Alice|5000\\") 'Total: 5000 Highest: Alice Median: 5000' >>> process_employee_data(\\"101|Alice|5000, 102|Bob|7000\\") 'Total: 12000 Highest: Bob Median: 6000' >>> process_employee_data(\\"101|Alice|5000, 102|Bob|5000, 103|Charlie|5000\\") 'Total: 15000 Highest: Alice Median: 5000'","solution":"def process_employee_data(data): if not data.strip(): return \\"Total: 0 Highest: None Median: 0\\" employees = data.split(', ') total_salary = 0 salaries = [] highest_salary = float('-inf') highest_salary_name = None for employee in employees: emp_id, name, salary = employee.split('|') salary = int(salary) total_salary += salary salaries.append(salary) if salary > highest_salary: highest_salary = salary highest_salary_name = name salaries.sort() num_employees = len(salaries) if num_employees % 2 == 1: median_salary = salaries[num_employees // 2] else: median_salary = (salaries[(num_employees // 2) - 1] + salaries[num_employees // 2]) / 2 return f\\"Total: {total_salary} Highest: {highest_salary_name} Median: {int(median_salary)}\\""},{"question":"import random import string def generate_password(N: int) -> str: Generate a random password that is N characters long, containing at least one lowercase letter, one uppercase letter, and one digit. Args: - N: An integer representing the length of the password (3 â‰¤ N â‰¤ 100). Returns: - A string representing the generated password. Examples: >>> len(generate_password(6)) == 6 True >>> len(generate_password(10)) == 10 True >>> any(c.islower() for c in generate_password(8)) True >>> any(c.isupper() for c in generate_password(8)) True >>> any(c.isdigit() for c in generate_password(8)) True if N < 3 or N > 100: raise ValueError(\\"Password length must be between 3 and 100.\\")","solution":"import random import string def generate_password(N: int) -> str: Generate a random password that is N characters long, containing at least one lowercase letter, one uppercase letter, and one digit. if N < 3 or N > 100: raise ValueError(\\"Password length must be between 3 and 100.\\") password_chars = [] # At least one lowercase letter password_chars.append(random.choice(string.ascii_lowercase)) # At least one uppercase letter password_chars.append(random.choice(string.ascii_uppercase)) # At least one digit password_chars.append(random.choice(string.digits)) # Fill the rest of the password with random alphanumeric characters remaining_chars = N - 3 if remaining_chars > 0: password_chars.extend(random.choices(string.ascii_letters + string.digits, k=remaining_chars)) # Shuffle to avoid any predictable patterns random.shuffle(password_chars) return ''.join(password_chars)"},{"question":"def distinct_elements(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, determine the number of distinct elements between the L-th and R-th position in the array (both inclusive). Parameters: arr (List[int]): The array of integers. queries (List[Tuple[int, int]]): A list of tuples, each containing two integers (L, R). Returns: List[int]: A list of integers representing the number of distinct elements for each query. >>> distinct_elements([1, 2, 1, 3, 2], [(1, 3), (2, 4), (1, 5)]) [2, 3, 3] >>> distinct_elements([1, 2, 3, 4, 5], [(1, 5)]) [5] >>> distinct_elements([1, 1, 1, 1, 1], [(1, 5)]) [1]","solution":"def distinct_elements(arr, queries): Returns the number of distinct elements in the subarray defined by each query. Parameters: arr (list): The array of integers. queries (list): A list of tuples, each containing two integers (L, R). Returns: list: A list of integers representing the number of distinct elements for each query. distinct_count = [] for L, R in queries: subarray = arr[L-1:R] distinct_count.append(len(set(subarray))) return distinct_count"},{"question":"def minDistance(str1: str, str2: str) -> int: Given two strings str1 and str2, find the minimum number of steps required to convert str1 into str2. In one step, you can insert a character, delete a character, or replace a character. >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"abc\\", \\"\\") 3 >>> minDistance(\\"\\", \\"\\") 0 >>> minDistance(\\"abc\\", \\"abc\\") 0 >>> minDistance(\\"abcd\\", \\"xyz\\") 4","solution":"def minDistance(str1, str2): # Initialize the matrix dp where dp[i][j] represents the edit distance between # the first i characters of str1 and the first j characters of str2. m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the base case values for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the matrix using the recurrence relation for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # delete dp[i][j - 1], # insert dp[i - 1][j - 1]) # replace return dp[m][n]"},{"question":"from typing import List, Dict, Tuple, Union def calculate_total_feed(animals: List[Dict[str, Union[str, int, List[Tuple[str, int]]]]]) -> Dict[str, int]: Determine the total quantity required for each type of food for all animals in the shelter. Args: animals: A list of dictionaries, where each dictionary represents one animal. Each dictionary contains: - \\"species\\" (str): The species of the animal. - \\"age\\" (int): The age of the animal. - \\"feeding_requirements\\" (List[Tuple[str, int]]): A list of tuples where each tuple consists of the food type (str) and the quantity needed (int). Returns: A dictionary with food types as keys and the total quantities of the respective food types required per day as values. Example: >>> animals = [ ... {\\"species\\": \\"Dog\\", \\"age\\": 5, \\"feeding_requirements\\": [(\\"Dry Food\\", 2), (\\"Water\\", 1)]}, ... {\\"species\\": \\"Cat\\", \\"age\\": 3, \\"feeding_requirements\\": [(\\"Dry Food\\", 1), (\\"Water\\", 1)]}, ... {\\"species\\": \\"Parrot\\", \\"age\\": 2, \\"feeding_requirements\\": [(\\"Seeds\\", 3), (\\"Water\\", 1)]} ... ] >>> calculate_total_feed(animals) {'Dry Food': 3, 'Water': 3, 'Seeds': 3} pass","solution":"from typing import List, Dict, Tuple, Union def calculate_total_feed(animals: List[Dict[str, Union[str, int, List[Tuple[str, int]]]]]) -> Dict[str, int]: total_feed = {} for animal in animals: for food_type, quantity in animal[\\"feeding_requirements\\"]: if food_type in total_feed: total_feed[food_type] += quantity else: total_feed[food_type] = quantity return total_feed"},{"question":"def min_days_to_equalize(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Determine the minimum number of days needed to make all the numbers on the nodes equal. Each day, you can choose a connected subgraph and increase the number written on each node of this subgraph by 1. Parameters: n (int): The number of nodes in the tree. values (List[int]): The initial numbers written on the nodes. edges (List[Tuple[int, int]]): The edges representing connections between nodes. Returns: int: The minimum number of days needed to make all numbers on the nodes equal. Examples: >>> min_days_to_equalize(4, [1, 2, 3, 4], [(1, 2), (1, 3), (1, 4)]) 3 >>> min_days_to_equalize(5, [5, 5, 5, 5, 5], [(2, 1), (3, 1), (4, 1), (5, 1)]) 0 >>> min_days_to_equalize(3, [1, 5, 3], [(1, 2), (2, 3)]) 4","solution":"def min_days_to_equalize(n, values, edges): max_value = max(values) steps_needed = 0 for value in values: steps_needed = max(steps_needed, max_value - value) return steps_needed"},{"question":"def calculate_donation(target: int) -> int: Calculate the amount Arun will donate based on his target donation. Arun can donate only in denominations of 10, 20, 50, or 100 dollars. If the amount he wants to donate cannot be exactly matched using these denominations, he will donate the closest amount that is less than his target donation. -----Input----- A single integer 0 < T <= 5000 - the target amount Arun wants to donate. -----Output----- Output the actual amount Arun will donate. The donated amount must be in multiples of 10, 20, 50, or 100 dollars and must be less than or equal to his target amount. >>> calculate_donation(150) 150 >>> calculate_donation(93) 90 >>> calculate_donation(1) 0","solution":"def calculate_donation(target): Returns the closest possible donation amount that is less than or equal to the target, using denominations of 10, 20, 50, or 100 dollars. possible_donations = sorted([10, 20, 50, 100], reverse=True) closest_donation = 0 for denom in possible_donations: while target >= denom: target -= denom closest_donation += denom return closest_donation"},{"question":"def is_prime(n: int) -> bool: Determines if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(29) True >>> is_prime(1) False pass def concatenated_is_prime(a: int, b: int) -> str: Concatenates two integers a and b, then checks if the resulting number is prime. >>> concatenated_is_prime(7, 13) \\"NO\\" >>> concatenated_is_prime(2, 3) \\"YES\\" >>> concatenated_is_prime(11, 2) \\"NO\\" >>> concatenated_is_prime(3, 7) \\"YES\\" >>> concatenated_is_prime(12, 1) \\"NO\\" pass","solution":"def is_prime(n): Determines if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def concatenated_is_prime(a, b): Concatenates two integers a and b, then checks if the resulting number is prime. concatenated_number = int(str(a) + str(b)) return \\"YES\\" if is_prime(concatenated_number) else \\"NO\\""},{"question":"def maximum_rectangular_area(M: int, N: int, capacities: List[List[int]], W: int) -> int: Determine the maximum rectangular area of terraces that can be completely filled with the available water. >>> maximum_rectangular_area(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 30) 6 >>> maximum_rectangular_area(2, 2, [[4, 5], [6, 7]], 10) 2 >>> maximum_rectangular_area(3, 3, [[10, 20, 30], [40, 50, 60], [70, 80, 90]], 1) 0 >>> maximum_rectangular_area(2, 2, [[0, 0], [0, 0]], 10) 4 >>> maximum_rectangular_area(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9) 9","solution":"def maximum_rectangular_area(M, N, capacities, W): def get_prefix_sum(matrix): prefix_sum = [[0] * (N + 1) for _ in range(M + 1)] for i in range(1, M + 1): for j in range(1, N + 1): prefix_sum[i][j] = capacities[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def get_area_sum(prefix_sum, row1, col1, row2, col2): return prefix_sum[row2+1][col2+1] - prefix_sum[row2+1][col1] - prefix_sum[row1][col2+1] + prefix_sum[row1][col1] prefix_sum = get_prefix_sum(capacities) max_area = 0 for row1 in range(M): for row2 in range(row1, M): for col1 in range(N): for col2 in range(col1, N): area_sum = get_area_sum(prefix_sum, row1, col1, row2, col2) area = (row2 - row1 + 1) * (col2 - col1 + 1) if area_sum <= W: max_area = max(max_area, area) return max_area"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels in the input string s. Args: s: A string containing alphabets (both uppercase and lowercase) and spaces. Returns: The number of vowels in the input string. Examples: >>> count_vowels(\\"Hello World\\") 3 >>> count_vowels(\\"Algorithms are fun\\") 5 Constraints: - The string length should be between 1 and 10^5 inclusive. - The string may contain both uppercase and lowercase letters, as well as spaces. import pytest def test_count_vowels_mixed_case(): assert count_vowels(\\"Hello World\\") == 3 def test_count_vowels_all_lowercase(): assert count_vowels(\\"algorithms are fun\\") == 6 def test_count_vowels_all_uppercase(): assert count_vowels(\\"ALGORITHMS ARE FUN\\") == 6 def test_count_vowels_no_vowels(): assert count_vowels(\\"bcdfghjklmnpqrstvwxyz\\") == 0 def test_count_vowels_empty_string(): assert count_vowels(\\"\\") == 0 def test_count_vowels_only_vowels(): assert count_vowels(\\"aeiouAEIOU\\") == 10","solution":"def count_vowels(s): Returns the number of vowels in the input string s. vowels = set('aeiouAEIOU') count = 0 for char in s: if char in vowels: count += 1 return count"},{"question":"def max_difference_after_swaps(n, k, taste_scores, swaps): Determine the maximum difference in taste scores among any two dishes after k swap operations. >>> max_difference_after_swaps(5, 2, [10, 20, 30, 40, 50], [(1, 5), (2, 4)]) 40 >>> max_difference_after_swaps(4, 3, [1, 3, 5, 7], [(1, 2), (3, 4), (2, 3)]) 6 >>> max_difference_after_swaps(3, 0, [5, 15, 25], []) 20 >>> max_difference_after_swaps(4, 1, [7, 2, 8, 3], [(2, 4)]) 6 >>> max_difference_after_swaps(5, 1, [1000000000, 200000000, 500000000, 800000000, 300000000], [(1, 5)]) 800000000","solution":"def max_difference_after_swaps(n, k, taste_scores, swaps): for x, y in swaps: taste_scores[x-1], taste_scores[y-1] = taste_scores[y-1], taste_scores[x-1] return max(taste_scores) - min(taste_scores)"},{"question":"from typing import List def max_water_container(heights: List[int]) -> int: Calculate the maximum amount of water that can be contained between two vertical lines. >>> max_water_container([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_container([1, 1]) 1 >>> max_water_container([4, 3, 2, 1, 4]) 16 >>> max_water_container([1, 2, 1]) 2 >>> max_water_container([5, 4, 3, 2, 1]) 6 >>> max_water_container([10000] * 100000) 999990000","solution":"from typing import List def max_water_container(heights: List[int]) -> int: This function calculates the maximum amount of water that can be contained between two vertical lines in the input list of heights. max_area = 0 left = 0 right = len(heights) - 1 while left < right: # Calculate the width width = right - left # Calculate the height by taking the minimum of two heights height = min(heights[left], heights[right]) # Calculate the area and update max_area if current area is larger current_area = width * height max_area = max(max_area, current_area) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def findOddOccurrence(arr): Returns the integer that appears an odd number of times in the array. >>> findOddOccurrence([2, 3, 5, 4, 5, 3, 4, 2, 4]) 4 >>> findOddOccurrence([1, 1, 2, 2, 3, 3, 3]) 3 >>> findOddOccurrence([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) 0 >>> findOddOccurrence([2, 2, 2, 1, 1, 1, 3, 3, 3, 1000000]) 1000000 >>> findOddOccurrence([10, 10, 10]) 10","solution":"def findOddOccurrence(arr): Returns the integer that appears an odd number of times in the array. result = 0 for number in arr: result ^= number return result"},{"question":"def find_min_command_centers(n: int, m: int, edges: List[Tuple[int, int]]) -> Union[int, str]: Determine the minimum number of command centers required to maintain communication even if any single link fails or return 'impossible' if it's not achievable. Parameters: n (int): Number of ant hills m (int): Number of possible communication links edges (List[Tuple[int, int]]): List of bidirectional communication links Returns: Union[int, str]: Minimum number of command centers required or 'impossible' >>> find_min_command_centers(4, 4, [(0, 1), (1, 2), (2, 3), (3, 0)]) 4 >>> find_min_command_centers(4, 2, [(0, 1), (2, 3)]) 'impossible'","solution":"def find_min_command_centers(n, m, edges): from sys import setrecursionlimit setrecursionlimit(10000) if m == 0: return \\"impossible\\" # Convert edges to adjacency list adj = [[] for _ in range(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) # Function to check if the graph is strongly connected def is_strongly_connected(): def dfs(node, visited): visited[node] = True for neighbor in adj[node]: if not visited[neighbor]: dfs(neighbor, visited) # Initial DFS from the first node visited = [False] * n dfs(0, visited) if any(not v for v in visited): return False # Transpose the graph transpose = [[] for _ in range(n)] for u in range(n): for v in adj[u]: transpose[v].append(u) # DFS on the transposed graph visited = [False] * n dfs(0, visited) return all(visited) if not is_strongly_connected(): return \\"impossible\\" # If the graph is connected, the result equals the number of nodes. return n"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Returns the largest sum of any contiguous subarray of length exactly k. If k is greater than the length of the array, returns -1. >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 2) 6 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 1) 5 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 6) 14 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 7) -1 >>> max_sum_subarray([], 1) -1 >>> max_sum_subarray([2, -1, 5, -1, 3], 2) 4 >>> max_sum_subarray([-2, -1, -5, -1, -3], 2) -3 >>> max_sum_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) 34 >>> max_sum_subarray([0, 0, 0, 0, 0, 0], 3) 0","solution":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Returns the largest sum of any contiguous subarray of length exactly k. If k is greater than the length of the array, returns -1. n = len(arr) if k > n: return -1 # Calculate the sum of the first 'k' elements max_sum = curr_sum = sum(arr[:k]) # Use sliding window to find the maximum sum subarray of length 'k' for i in range(k, n): curr_sum = curr_sum + arr[i] - arr[i - k] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"def transform_string(S: str) -> str: Transforms the string based on palindrome check: - If S is a palindrome, returns the reversed string. - Otherwise, returns the string in uppercase. >>> transform_string(\\"Radar\\") \\"radaR\\" >>> transform_string(\\"Hello\\") \\"HELLO\\" >>> transform_string(\\"a\\") \\"a\\" >>> transform_string(\\"RaCeCaR\\") \\"RaCeCaR\\"","solution":"def transform_string(S): Transforms the string based on palindrome check: - If S is a palindrome, returns the reversed string. - Otherwise, returns the string in uppercase. S_normalized = S.lower() if S_normalized == S_normalized[::-1]: return S[::-1] else: return S.upper()"},{"question":"def rearrange_string(input_string: str) -> str: Rearranges the input string so that all letters appear in sorted order, followed by all numbers in sorted order. >>> rearrange_string(\\"b2a1c3\\") == \\"abc123\\" >>> rearrange_string(\\"K5L2M1aA1\\") == \\"AKLMa1125\\" >>> rearrange_string(\\"d4a3b2\\") == \\"abd234\\"","solution":"def rearrange_string(input_string: str) -> str: Rearranges the input string so that all letters appear in sorted order, followed by all numbers in sorted order. letters = [] numbers = [] for char in input_string: if char.isdigit(): numbers.append(char) else: letters.append(char) # Sort letters and numbers separately letters_sorted = ''.join(sorted(letters)) numbers_sorted = ''.join(sorted(numbers)) # Return concatenated result return letters_sorted + numbers_sorted"},{"question":"def three_sum(lst: List[int], target: int) -> str: Determines if there are three distinct numbers in the list that sum up to the target. >>> three_sum([10, 20, 30, 40, 50], 60) \\"Yes\\" >>> three_sum([1, 2, 3, 4, 5, 6], 10) \\"Yes\\" >>> three_sum([1, 1, 1, 1, 1], 4) \\"No\\" >>> three_sum([-1, 0, 1, 2, -1, -4], 10) \\"No\\" >>> three_sum([1000000000, -1000000000, 0], 0) \\"Yes\\" >>> three_sum([1000000000, -999999999, 1], 1) \\"No\\" >>> three_sum([-10**9, -10**9, -10**9 + 1, 2*10**9], 0) \\"Yes\\" def process_test_cases(T: int, test_cases: List[tuple]) -> List[str]: Processes multiple test cases to determine if there exists a triplet of numbers in the list that sum to the target. Args: T (int): The number of test cases. test_cases (List[tuple]): A list of tuples, where each tuple contains: (N (int): number of elements in the list, lst (List[int]): the elements of the list, target (int): the target number) Returns: List[str]: A list of results for each test case, either \\"Yes\\" or \\"No\\". >>> test_cases = [(5, [10, 20, 30, 40, 50], 60), (6, [1, 2, 3, 4, 5, 6], 10)] >>> process_test_cases(2, test_cases) [\\"Yes\\", \\"Yes\\"]","solution":"def three_sum(lst, target): Determines if there are three distinct numbers in the list that sum up to the target. Args: lst (list): List of integers. target (int): The target sum. Returns: str: \\"Yes\\" if such a triplet exists, otherwise \\"No\\". lst.sort() n = len(lst) for i in range(n - 2): j, k = i + 1, n - 1 while j < k: curr_sum = lst[i] + lst[j] + lst[k] if curr_sum == target: return \\"Yes\\" elif curr_sum < target: j += 1 else: k -= 1 return \\"No\\" def process_test_cases(T, test_cases): results = [] for i in range(T): N, lst, target = test_cases[i] result = three_sum(lst, target) results.append(result) return results"},{"question":"def check_anomalies(n: int, employees_intervals: List[List[int]]) -> str: A company keeps track of its employeesâ€™ working hours and wants to identify any anomalies in the data. An anomaly is defined as: 1. Overlapping intervals within the same day for a single employee. 2. Intervals that extend outside the 24-hour period. Input - The first integer n is the number of employees. - Each of the next n lists starts with an integer m (the number of intervals for that employee), followed by m pairs of integers [start, end]. Output - Print \\"YES\\" if there is at least one anomaly, and \\"NO\\" if there are no anomalies. >>> check_anomalies(3, [[2, 9, 12, 13, 18], [3, 10, 14, 12, 16, 15, 19], [1, 20, 26]]) \\"YES\\" >>> check_anomalies(2, [[2, 8, 12, 14, 18], [1, 0, 5]]) \\"NO\\"","solution":"def check_anomalies(n, employees_intervals): for intervals in employees_intervals: m = intervals[0] intervals = intervals[1:] if any(end > 24 or start < 0 or start >= end for start, end in zip(intervals[::2], intervals[1::2])): return \\"YES\\" sorted_intervals = sorted((start, end) for start, end in zip(intervals[::2], intervals[1::2])) for i in range(len(sorted_intervals) - 1): if sorted_intervals[i][1] > sorted_intervals[i + 1][0]: return \\"YES\\" return \\"NO\\""},{"question":"def evaluate_stock_portfolio(n: int, stock_prices_table: List[List[int]]) -> Tuple[Tuple[str, str, str], Tuple[str, str, str]]: Evaluate the performance of a stock portfolio. Args: n: number of days stock_prices_table: stock prices table with n rows and 3 columns Returns: A tuple containing: 1. Tuple of average prices of the three companies' stocks over n days, each as a string with 2 decimal places. 2. Tuple of total percentage changes of the three companies' stocks from the first to the last day, each as a string with 2 decimal places and a '%' symbol. # Your implementation here. def test_evaluate_stock_portfolio(): # Test case 1 n = 5 stock_prices_table = [ [100, 150, 200], [110, 140, 210], [120, 130, 220], [130, 120, 230], [140, 110, 240] ] expected_avg_prices = (\\"120.00\\", \\"130.00\\", \\"220.00\\") expected_percentage_changes = (\\"40.00%\\", \\"-26.67%\\", \\"20.00%\\") avg_prices, percentage_changes = evaluate_stock_portfolio(n, stock_prices_table) assert avg_prices == expected_avg_prices assert percentage_changes == expected_percentage_changes # Test case 2 n = 3 stock_prices_table = [ [50, 60, 70], [60, 70, 80], [70, 80, 90] ] expected_avg_prices = (\\"60.00\\", \\"70.00\\", \\"80.00\\") expected_percentage_changes = (\\"40.00%\\", \\"33.33%\\", \\"28.57%\\") avg_prices, percentage_changes = evaluate_stock_portfolio(n, stock_prices_table) assert avg_prices == expected_avg_prices assert percentage_changes == expected_percentage_changes # Test case 3 - No percentage change if first day's price is zero n = 2 stock_prices_table = [ [0, 500, 1000], [0, 0, 2000] ] expected_avg_prices = (\\"0.00\\", \\"250.00\\", \\"1500.00\\") expected_percentage_changes = (\\"0.00%\\", \\"-100.00%\\", \\"100.00%\\") avg_prices, percentage_changes = evaluate_stock_portfolio(n, stock_prices_table) assert avg_prices == expected_avg_prices assert percentage_changes == expected_percentage_changes # Test case 4 - Single day prices n = 1 stock_prices_table = [ [200, 400, 600] ] expected_avg_prices = (\\"200.00\\", \\"400.00\\", \\"600.00\\") expected_percentage_changes = (\\"0.00%\\", \\"0.00%\\", \\"0.00%\\") avg_prices, percentage_changes = evaluate_stock_portfolio(n, stock_prices_table) assert avg_prices == expected_avg_prices assert percentage_changes == expected_percentage_changes test_evaluate_stock_portfolio()","solution":"def evaluate_stock_portfolio(n, stock_prices_table): company_1_total = 0 company_2_total = 0 company_3_total = 0 first_day_prices = stock_prices_table[0] last_day_prices = stock_prices_table[-1] for prices in stock_prices_table: company_1_total += prices[0] company_2_total += prices[1] company_3_total += prices[2] avg_company_1 = company_1_total / n avg_company_2 = company_2_total / n avg_company_3 = company_3_total / n avg_prices = (f\\"{avg_company_1:.2f}\\", f\\"{avg_company_2:.2f}\\", f\\"{avg_company_3:.2f}\\") percentage_change_1 = ((last_day_prices[0] - first_day_prices[0]) / first_day_prices[0]) * 100 if first_day_prices[0] != 0 else 0 percentage_change_2 = ((last_day_prices[1] - first_day_prices[1]) / first_day_prices[1]) * 100 if first_day_prices[1] != 0 else 0 percentage_change_3 = ((last_day_prices[2] - first_day_prices[2]) / first_day_prices[2]) * 100 if first_day_prices[2] != 0 else 0 percentage_changes = (f\\"{percentage_change_1:.2f}%\\", f\\"{percentage_change_2:.2f}%\\", f\\"{percentage_change_3:.2f}%\\") return avg_prices, percentage_changes"},{"question":"def filter_alphanumeric(input_str: str) -> str: Extracts only the alphanumeric characters from the input string, preserving their original order. Args: input_str (str): The string containing a mix of alphanumeric characters and special symbols. Returns: str: A string containing only the alphanumeric characters from the input, in their original order. Examples: >>> filter_alphanumeric(\\"a1b!2@c#3d^4&e*5\\") 'a1b2c3d4e5' >>> filter_alphanumeric(\\"%&^A2B3@!C\\") 'A2B3C' from typing import List def test_example_1(): assert filter_alphanumeric(\\"a1b!2@c#3d^4&e*5\\") == \\"a1b2c3d4e5\\" def test_example_2(): assert filter_alphanumeric(\\"%&^A2B3@!C\\") == \\"A2B3C\\" def test_only_alphanumeric(): assert filter_alphanumeric(\\"abc123XYZ\\") == \\"abc123XYZ\\" def test_no_alphanumeric(): assert filter_alphanumeric(\\"!@#%^&*(){}[]\\") == \\"\\" def test_mixed_content(): assert filter_alphanumeric(\\"T!e@#%^&*s(t_)+=123456\\") == \\"Test123456\\" def test_empty_string(): assert filter_alphanumeric(\\"\\") == \\"\\" def test_substring_all_alphanumeric(): assert filter_alphanumeric(\\"%%%abcABC123%%%\\") == \\"abcABC123\\" def test_special_characters_interleaved(): assert filter_alphanumeric(\\"N0@#o1% n&*u2-4m3+=b2e!r8\\") == \\"N0o1nu24m3b2er8\\" def test_numbers_only(): assert filter_alphanumeric(\\"12!34#56\\") == \\"123456\\" def test_letters_only(): assert filter_alphanumeric(\\"a!b@c#d\\") == \\"abcd\\"","solution":"def filter_alphanumeric(input_str): Returns a string with only the alphanumeric characters from input_str, preserving their original order. return ''.join(c for c in input_str if c.isalnum())"},{"question":"def max_pieces(N): Returns the maximum number of pieces you can get by cutting the cake with N straight lines. >>> max_pieces(0) == 1 >>> max_pieces(1) == 2 >>> max_pieces(2) == 4 >>> max_pieces(3) == 7 >>> max_pieces(4) == 11 >>> max_pieces(10) == 56 def handle_test_cases(T, test_cases): Returns the list of results for each test case. >>> handle_test_cases(3, [0, 1, 2]) == [1, 2, 4] >>> handle_test_cases(2, [3, 4]) == [7, 11] >>> handle_test_cases(5, [0, 1, 2, 3, 10]) == [1, 2, 4, 7, 56]","solution":"def max_pieces(N): Returns the maximum number of pieces you can get by cutting the cake with N straight lines. return (N * (N + 1)) // 2 + 1 def handle_test_cases(T, test_cases): results = [] for N in test_cases: results.append(max_pieces(N)) return results # Example usage T = 3 test_cases = [0, 1, 2] print(handle_test_cases(T, test_cases)) # Expected: [1, 2, 4]"},{"question":"def generate_fibonacci(n): Generate the first n numbers of the Fibonacci sequence. :param n: Number of Fibonacci numbers to generate :type n: int :return: A list containing the first n numbers of the Fibonacci sequence :rtype: list of int >>> generate_fibonacci(4) [0, 1, 1, 2] >>> generate_fibonacci(7) [0, 1, 1, 2, 3, 5, 8] >>> generate_fibonacci(1) [0]","solution":"def generate_fibonacci(n): Returns the first n numbers of the Fibonacci sequence. :param n: Number of Fibonacci numbers to generate :type n: int :return: A list containing the first n numbers of the Fibonacci sequence :rtype: list of int if n <= 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for _ in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def longestSubsequence(arr: List[int], target: int) -> int: Returns the length of the longest consecutive subsequence in \`arr\` whose sum is less than or equal to \`target\`. >>> longestSubsequence([1, 2, 3, 4, 5], 11) 4 >>> longestSubsequence([7, 3, 5, 6], 12) 2","solution":"def longestSubsequence(arr, target): Returns the length of the longest consecutive subsequence in \`arr\` whose sum is less than or equal to \`target\`. n = len(arr) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > target: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def is_toeplitz_matrix(matrix): Check if the given 2D matrix is a Toeplitz matrix. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements. Args: matrix (List[List[int]]): 2D list of integers representing the matrix. Returns: bool: True if the matrix is Toeplitz, False otherwise. pass # Unit tests def test_example1(): matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2] ] assert is_toeplitz_matrix(matrix) == True def test_example2(): matrix = [ [1,2], [2,2] ] assert is_toeplitz_matrix(matrix) == False def test_single_element_matrix(): matrix = [ [5] ] assert is_toeplitz_matrix(matrix) == True def test_non_toeplitz_matrix(): matrix = [ [1,2,3], [4,1,2], [5,4,1], [6,5,2] ] assert is_toeplitz_matrix(matrix) == False def test_empty_matrix(): matrix = [ [] ] assert is_toeplitz_matrix(matrix) == True def test_another_toeplitz_matrix(): matrix = [ [3, 7, 8], [5, 3, 7], [6, 5, 3], [0, 6, 5] ] assert is_toeplitz_matrix(matrix) == True","solution":"def is_toeplitz_matrix(matrix): Check if the given 2D matrix is a Toeplitz matrix. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements. Args: matrix (List[List[int]]): 2D list of integers representing the matrix. Returns: bool: True if the matrix is Toeplitz, False otherwise. rows = len(matrix) cols = len(matrix[0]) for i in range(rows - 1): for j in range(cols - 1): if matrix[i][j] != matrix[i + 1][j + 1]: return False return True"},{"question":"def findPosition(arr, V): Returns the index of V in arr or the index where it can be inserted to maintain sorted order. >>> findPosition([1, 3, 5, 6], 5) 2 >>> findPosition([1, 3, 5, 6], 2) 1","solution":"def findPosition(arr, V): Returns the index of V in arr or the index where it can be inserted to maintain sorted order. left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < V: left = mid + 1 else: right = mid return left"},{"question":"def puzzle_rotation(input_str): Modify the given grid by rotating all eligible m x m subgrids by 90 degrees clockwise. >>> puzzle_rotation(5 1 2 3 4 5 1 0 0 0 1 1 0 8 0 1 1 0 0 0 1 1 2 3 4 5) \\"1 2 3 4 5n1 0 0 0 1n1 0 8 0 1n1 0 0 0 1n1 2 3 4 5\\" >>> puzzle_rotation(4 1 1 1 1 1 2 3 1 1 4 5 1 1 1 1 1) \\"1 1 1 1n1 4 2 1n1 5 3 1n1 1 1 1\\" >>> puzzle_rotation(3 2 2 2 2 0 2 2 2 2) \\"2 2 2n2 0 2n2 2 2\\" def str_to_matrix(s): Helper function to convert input string to a grid matrix pass def matrix_to_str(matrix): Helper function to convert grid matrix to output string pass def rotate_subgrid(grid): Helper function to rotate the subgrids if the conditions are met pass def can_rotate(x, y, m, grid): Helper function to check if a subgrid can be rotated pass def rotate_clockwise(x, y, m, grid): Helper function to rotate a subgrid clockwise pass","solution":"def rotate_subgrid(grid): N = len(grid) def can_rotate(x, y, m): for i in range(m+2): if grid[x][y+i] == 0 or grid[x+m+1][y+i] == 0 or grid[x+i][y] == 0 or grid[x+i][y+m+1] == 0: return False return True def rotate_clockwise(x, y, m): subgrid = [row[y:y+m] for row in grid[x:x+m]] for i in range(m): for j in range(m): grid[x+j][y+m-1-i] = subgrid[i][j] for size in range(1, N-1): for i in range(N-size-1): for j in range(N-size-1): if can_rotate(i, j, size): rotate_clockwise(i+1, j+1, size) return grid def str_to_matrix(s): lines = s.strip().split('n') N = int(lines[0]) grid = [list(map(int, line.split())) for line in lines[1:]] return grid def matrix_to_str(matrix): return 'n'.join(' '.join(map(str, row)) for row in matrix) def puzzle_rotation(input_str): grid = str_to_matrix(input_str) rotated_grid = rotate_subgrid(grid) return matrix_to_str(rotated_grid)"},{"question":"def find_segment(n: int, m: int, k: int, grid: List[List[int]]) -> Union[Tuple[int, int, int], int]: Lara is a young archaeologist who has recently discovered an ancient board game in a deserted temple. The board game consists of a grid of size n x m, filled with numbers. To initiate the game, she has to find a segment in any row (consecutive cells in a horizontal line) whose sum is divisible by a given integer k. Help Lara find such a segment in the grid. If there are multiple such segments, you can return any one of them. If no such segment exists, return -1. Args: n (int): number of rows m (int): number of columns k (int): the given integer grid (List[List[int]]): the 2D grid of integers Returns: Union[Tuple[int, int, int], int]: the row index (1-based), the start column index (1-based), and the end column index (1-based) of the segment found. If no such segment exists, return -1. Examples: >>> find_segment(3, 4, 5, [[4, 8, 6, 2], [1, 12, 10, 6], [4, 3, 7, 5]]) (1, 1, 4) >>> find_segment(2, 5, 10, [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) (2, 2, 5) >>> find_segment(2, 3, 13, [[1, 2, 3], [4, 5, 6]]) -1 from typing import List, Tuple, Union def test_case_1(): n, m, k = 3, 4, 5 grid = [ [4, 8, 6, 2], [1, 12, 10, 6], [4, 3, 7, 5] ] result = find_segment(n, m, k, grid) assert result != -1 r, sc, ec = result assert (sum(grid[r-1][sc-1:ec]) % k == 0) def test_case_2(): n, m, k = 2, 5, 10 grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10] ] result = find_segment(n, m, k, grid) assert result != -1 r, sc, ec = result assert (sum(grid[r-1][sc-1:ec]) % k == 0) def test_case_3(): n, m, k = 2, 3, 13 grid = [ [1, 2, 3], [4, 5, 6] ] assert find_segment(n, m, k, grid) == -1 def test_case_4(): n, m, k = 1, 5, 3 grid = [ [1, 2, 3, 4, 5] ] result = find_segment(n, m, k, grid) assert result != -1 r, sc, ec = result assert (sum(grid[r-1][sc-1:ec]) % k == 0) def test_case_5(): n, m, k = 4, 4, 4 grid = [ [2, 4, 6, 8], [3, 6, 9, 12], [1, 1, 1, 1], [10, 20, 30, 40] ] result = find_segment(n, m, k, grid) assert result != -1 r, sc, ec = result assert (sum(grid[r-1][sc-1:ec]) % k == 0)","solution":"def find_segment(n, m, k, grid): for row_index in range(n): for start_col in range(m): current_sum = 0 for end_col in range(start_col, m): current_sum += grid[row_index][end_col] if current_sum % k == 0: return row_index + 1, start_col + 1, end_col + 1 return -1"},{"question":"from typing import List def combinationSum2(nums: List[int], target: int) -> List[List[int]]: Given an array of integers nums and an integer target, return all unique combinations in nums where the candidate numbers sum to target. Each number in nums may only be used once in the combination. The solution set must not contain duplicate combinations. Args: nums (List[int]): List of integers to find combinations from target (int): The target sum for the combinations Returns: List[List[int]]: List of unique combinations that sum to target Example: >>> combinationSum2([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] >>> combinationSum2([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]","solution":"from typing import List def combinationSum2(nums: List[int], target: int) -> List[List[int]]: nums.sort() result = [] combination = [] def backtrack(start, target): if target == 0: result.append(list(combination)) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue combination.append(nums[i]) backtrack(i + 1, target - nums[i]) combination.pop() backtrack(0, target) return result"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the given string is a valid palindrome considering only alphanumeric characters and ignoring case, otherwise returns False. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\" \\") == True","solution":"def is_palindrome(s: str) -> bool: Returns True if the given string is a valid palindrome considering only alphanumeric characters and ignoring case, otherwise returns False. # Filter the alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare the filtered list with its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def countGreaterThanX(arr: List[int], X: int) -> int: Returns the count of elements in arr that are greater than X. >>> countGreaterThanX([1, 2, 3, 4, 5], 3) 2 >>> countGreaterThanX([10, 8, 5, 1, 7], 6) 3","solution":"def countGreaterThanX(arr, X): Returns the count of elements in arr that are greater than X. count = 0 for num in arr: if num > X: count += 1 return count"},{"question":"def is_palindrome(num: int) -> bool: Check if a given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False def next_palindrome(N: int) -> int: Returns the smallest palindrome number greater than N. >>> next_palindrome(123) 131 >>> next_palindrome(9999) 10001","solution":"def is_palindrome(num): Check if a given number is a palindrome. return str(num) == str(num)[::-1] def next_palindrome(N): Returns the smallest palindrome number greater than N. N += 1 while not is_palindrome(N): N += 1 return N"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flattenTree(root): Given the root of the binary tree, this function flattens the tree into a singly linked list in-place following the pre-order traversal. # Implementation here def buildTree(nodes): Constructs binary tree from a list of values with 'n' representing None. # Implementation here def preOrderTraversal(root): Returns the pre-order traversal of the tree as a list. # Implementation here def solution(test_cases): Given a list of test cases where each test case is a serialized form of binary tree, this function flattens each tree and returns the pre-order traversal of each flattened tree. results = [] for case in test_cases: nodes = case.split(',') root = buildTree(nodes) flattenTree(root) results.append(' '.join(map(str, preOrderTraversal(root)))) return results import pytest def test_flattenTree_example1(): nodes = ['1', '2', '5', '3', '4', 'n', '6'] root = buildTree(nodes) flattenTree(root) assert preOrderTraversal(root) == [1, 2, 3, 4, 5, 6] def test_flattenTree_example2(): nodes = ['1', 'n', '2', '3'] root = buildTree(nodes) flattenTree(root) assert preOrderTraversal(root) == [1, 2, 3] def test_flattenTree_single_node(): nodes = ['1'] root = buildTree(nodes) flattenTree(root) assert preOrderTraversal(root) == [1] def test_flattenTree_none(): nodes = [] root = buildTree(nodes) flattenTree(root) assert preOrderTraversal(root) == [] def test_solution(): test_cases = [\\"1,2,5,3,4,n,6\\", \\"1,n,2,3\\"] expected = [\\"1 2 3 4 5 6\\", \\"1 2 3\\"] assert solution(test_cases) == expected","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flattenTree(root): Given the root of the binary tree, this function flattens the tree into a singly linked list in-place following the pre-order traversal. if not root: return # Using a stack to implement iterative pre-order traversal stack = [root] prev = None while stack: current = stack.pop() if prev: prev.right = current prev.left = None if current.right: stack.append(current.right) if current.left: stack.append(current.left) prev = current def buildTree(nodes): Constructs binary tree from a list of values with 'n' representing None. if not nodes: return None root = TreeNode(int(nodes[0])) queue = [root] i = 1 while queue and i < len(nodes): current_node = queue.pop(0) if nodes[i] != 'n': current_node.left = TreeNode(int(nodes[i])) queue.append(current_node.left) i += 1 if i < len(nodes) and nodes[i] != 'n': current_node.right = TreeNode(int(nodes[i])) queue.append(current_node.right) i += 1 return root def preOrderTraversal(root): Returns the pre-order traversal of the tree as a list. traversal = [] current = root while current: traversal.append(current.val) current = current.right return traversal def solution(test_cases): results = [] for case in test_cases: nodes = case.split(',') root = buildTree(nodes) flattenTree(root) results.append(' '.join(map(str, preOrderTraversal(root)))) return results"},{"question":"def largest_number(S: str) -> str: Returns the largest number that can be formed by removing exactly one digit from the string S. Parameters: S (str): A string consisting only of digits ('0'-'9'). Returns: str: The largest number obtainable by removing one digit. Examples: >>> largest_number(\\"12345\\") \\"2345\\" >>> largest_number(\\"54321\\") \\"5432\\" >>> largest_number(\\"1000\\") \\"100\\" >>> largest_number(\\"1023\\") \\"123\\" >>> largest_number(\\"45632\\") \\"5632\\" >>> largest_number(\\"22222\\") \\"2222\\" >>> largest_number(\\"1\\") \\"\\"","solution":"def largest_number(S): Returns the largest number that can be formed by removing exactly one digit from the string S. Parameters: S (str): A string consisting only of digits ('0'-'9'). Returns: str: The largest number obtainable by removing one digit. # Initialize the largest number to be the one without the first digit max_number = S[1:] # Iterate through the string to find the largest possible number by removing one digit for i in range(1, len(S)): current_number = S[:i] + S[i+1:] if current_number > max_number: max_number = current_number return max_number"},{"question":"def has_event_overlap(events: List[Tuple[int, int]]) -> str: Determine if any event windows overlap in the given list of events. Given a list of events, where each event is represented by its start and end times, the function checks if any two events have overlapping windows. >>> has_event_overlap([(1, 5), (6, 10), (2, 4)]) \\"NO\\" >>> has_event_overlap([(1, 5), (5, 10), (2, 7), (8, 12)]) \\"YES\\" >>> has_event_overlap([(0, 10), (5, 15)]) \\"YES\\"","solution":"def has_event_overlap(events): Determine if any event windows overlap in the given list of events. Args: events (list of tuples): List of events where each event is represented as (start, end) Returns: str: \\"YES\\" if any event windows overlap, otherwise \\"NO\\" # Sort events by start time events.sort() # Iterate over the events and check for overlap previous_end = -1 for start, end in events: if start < previous_end: return \\"YES\\" previous_end = end return \\"NO\\""},{"question":"def isUppercaseInOrder(S: str) -> bool: Determine if all the uppercase letters in the string S appear in alphabetical order. >>> isUppercaseInOrder(\\"aBcDeF\\") True >>> isUppercaseInOrder(\\"aCBdEf\\") False","solution":"def isUppercaseInOrder(S): Determine if all the uppercase letters in the string S appear in alphabetical order. :param S: str, a string consisting of lowercase and uppercase alphabets :return: bool, True if all the uppercase letters appear in alphabetical order last_upper = None for char in S: if char.isupper(): if last_upper and char < last_upper: return False last_upper = char return True"},{"question":"def findMaxLength(nums): Returns the maximum length of a subarray that contains equal number of 1's and 0's. :param nums: List[int] - List of integers containing 0's and 1's :return: int - Maximum length of the subarray >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 1, 1, 0, 1, 1, 1, 0]) 4","solution":"def findMaxLength(nums): Returns the maximum length of a subarray that contains equal number of 1's and 0's. :param nums: List[int] - List of integers containing 0's and 1's :return: int - Maximum length of the subarray count = 0 max_length = 0 count_index_map = {0: -1} # Initialized with count 0 at index -1 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_index_map: max_length = max(max_length, i - count_index_map[count]) else: count_index_map[count] = i return max_length"},{"question":"def unique_gears_count(clock1: str, clock2: str) -> int: Returns the number of unique gears in the union of two clock strings. >>> unique_gears_count(\\"abc\\", \\"bcd\\") 4 >>> unique_gears_count(\\"xyz\\", \\"yz\\") 3 >>> unique_gears_count(\\"aaa\\", \\"aaa\\") 1 >>> unique_gears_count(\\"abc\\", \\"xyz\\") 6 >>> unique_gears_count(\\"\\", \\"abc\\") 3 pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes multiple test cases and returns the results. >>> process_test_cases([(\\"abc\\", \\"bcd\\"), (\\"xyz\\", \\"yz\\")]) [4, 3] >>> process_test_cases([(\\"aaa\\", \\"aaa\\"), (\\"abc\\", \\"xyz\\")]) [1, 6] >>> process_test_cases([(\\"\\", \\"abc\\")]) [3] >>> process_test_cases([(\\"abcdefg\\", \\"hijklmn\\"), (\\"aaa\\", \\"bbb\\")]) [14, 2] >>> process_test_cases([(\\"\\", \\"\\"), (\\"a\\", \\"\\")]) [0, 1] >>> process_test_cases([(\\"a\\" * 100, \\"b\\" * 100), (\\"a\\", \\"a\\" * 100)]) [2, 1] pass","solution":"def unique_gears_count(clock1, clock2): Returns the number of unique gears in the union of two clock strings. unique_gears = set(clock1) | set(clock2) return len(unique_gears) def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for clock1, clock2 in test_cases: results.append(unique_gears_count(clock1, clock2)) return results"},{"question":"def find_two_sum_indices(N: int, T: int, arr: List[int]) -> Tuple[int, int]: Returns a tuple of two distinct indices (i, j) such that arr[i] + arr[j] = T, or an empty tuple if no such indices exist. >>> find_two_sum_indices(5, 9, [2, 7, 11, 15, 1]) (0, 1) >>> find_two_sum_indices(4, 6, [3, 2, 4, 5]) (1, 2) >>> find_two_sum_indices(3, 10, [1, 2, 3]) ()","solution":"def find_two_sum_indices(N, T, arr): Returns a tuple of two indices (i, j) such that arr[i] + arr[j] = T, or an empty tuple if no such indices exist. seen = {} for i in range(N): complement = T - arr[i] if complement in seen: return (seen[complement], i) seen[arr[i]] = i return ()"},{"question":"def min_additional_sensors(n: int, d: int, m: int, positions: List[int]) -> int: Determines the minimum number of additional sensors needed to ensure that the entire area from 0 to n is covered by sensors with given range d. >>> min_additional_sensors(10, 2, 0, []) 2 >>> min_additional_sensors(100, 5, 0, []) 10 >>> min_additional_sensors(10, 2, 3, [1, 4, 8]) 0 >>> min_additional_sensors(10, 2, 1, [1]) 2 >>> min_additional_sensors(20, 3, 2, [3, 17]) 1 >>> min_additional_sensors(50, 10, 2, [10, 30]) 1 >>> min_additional_sensors(0, 1, 0, []) 0 >>> min_additional_sensors(0, 1, 1, [0]) 0 >>> min_additional_sensors(1, 1, 0, []) 1 >>> min_additional_sensors(1, 1, 1, [0]) 0 >>> min_additional_sensors(1000, 100, 10, list(range(0, 1000, 100))) 0 >>> min_additional_sensors(1000, 100, 0, []) 5","solution":"def min_additional_sensors(n, d, m, positions): Determines the minimum number of additional sensors needed to ensure that the entire area from 0 to n is covered by sensors with given range d. if m == 0: # If no existing sensors, we calculate how many sensors we need for the entire area return (n + 2 * d) // (2 * d + 1) # Convert positions into intervals sensors = sorted([(max(0, p - d), min(n, p + d)) for p in positions]) # Merge overlapping or contiguous intervals merged = [] for interval in sensors: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) # Now determine the gaps between the merged intervals additional_sensors = 0 current_coverage = 0 for interval in merged: if current_coverage < interval[0]: gap_length = interval[0] - current_coverage - 1 if gap_length > 0: additional_sensors += (gap_length + 2 * d) // (2 * d + 1) current_coverage = max(current_coverage, interval[1]) # Check the remaining uncovered area from the last covered point to n if current_coverage < n: gap_length = n - current_coverage additional_sensors += (gap_length + 2 * d) // (2 * d + 1) return additional_sensors"},{"question":"def n_th_wonderful_permutation(n: int, s: str) -> str: Given a string s, return the n-th lexicographically smallest wonderful permutation of the characters in the string, or \\"Impossible\\" if such a permutation does not exist. A wonderful permutation is defined as a permutation where no two consecutive characters are the same. Args: n (int): The rank of the permutation. s (str): The input string. Returns: str: The n-th lexicographically smallest wonderful permutation or \\"Impossible\\". Examples: >>> n_th_wonderful_permutation(3, \\"abc\\") \\"bac\\" >>> n_th_wonderful_permutation(10, \\"abc\\") \\"Impossible\\"","solution":"from itertools import permutations def n_th_wonderful_permutation(n, s): Returns the n-th lexicographically smallest wonderful permutation of the characters in the string s, or \\"Impossible\\" if such a permutation does not exist. def is_wonderful(perm): # Check if no two consecutive characters are the same in perm for i in range(len(perm) - 1): if perm[i] == perm[i + 1]: return False return True # Find all unique permutations of the string perm_list = sorted(set(permutations(s))) # Filter out non-wonderful permutations wonderful_perms = [perm for perm in perm_list if is_wonderful(perm)] # Check if the n-th wonderful permutation exists if n <= len(wonderful_perms): return ''.join(wonderful_perms[n-1]) else: return \\"Impossible\\" # Read input if __name__ == \\"__main__\\": n, l = map(int, input().split()) s = input().strip() # Print the result print(n_th_wonderful_permutation(n, s))"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of string s. >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 pass def process_input(input_data: str) -> list: Processes multiple datasets from input and returns the output. >>> process_input('abcnaaann') [6, 3] >>> process_input('abcdnabacnn') [10, 9] pass","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of string s. substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return len(substrings) def process_input(input_data): Processes multiple datasets from input and returns the output. lines = input_data.strip().split('n') results = [] for line in lines: if line: results.append(count_distinct_substrings(line)) return results"},{"question":"def process_commands(commands): Processes MOVE and WHERE commands to track item locations. Parameters: commands (list): List of strings, each string is a command. Returns: list: List of results for each WHERE command. locations = {} results = [] def process_input(data): Processes the input data to separate each dataset and feed it to the process_commands function. Parameters: data (str): Multi-line string containing all data. Returns: list: List of results from all datasets. lines = data.strip().split(\\"n\\") index = 0 results = [] while index < len(lines): N, M = map(int, lines[index].split()) if N == 0 and M == 0: break commands = [] for _ in range(M): index += 1 commands.append(lines[index]) results.extend(process_commands(commands)) index += 1 return results # Unit tests def test_single_dataset(): input_data = \\"3 5nMOVE 1 100nMOVE 2 200nWHERE 1nWHERE 2nWHERE 3n0 0\\" expected_output = [\\"100\\", \\"200\\", \\"UNKNOWN\\"] assert process_input(input_data) == expected_output def test_multiple_datasets(): input_data = \\"3 5nMOVE 1 100nMOVE 2 200nWHERE 1nWHERE 2nWHERE 3n2 3nMOVE 1 300nMOVE 2 400nWHERE 1n0 0\\" expected_output = [\\"100\\", \\"200\\", \\"UNKNOWN\\", \\"300\\"] assert process_input(input_data) == expected_output def test_no_moves(): input_data = \\"2 1nWHERE 1n0 0\\" expected_output = [\\"UNKNOWN\\"] assert process_input(input_data) == expected_output def test_all_unknown(): input_data = \\"3 3nWHERE 1nWHERE 2nWHERE 3n0 0\\" expected_output = [\\"UNKNOWN\\", \\"UNKNOWN\\", \\"UNKNOWN\\"] assert process_input(input_data) == expected_output def test_large_input(): input_data = \\"100000 1nWHERE 1n0 0\\" expected_output = [\\"UNKNOWN\\"] assert process_input(input_data) == expected_output","solution":"def process_commands(commands): Processes MOVE and WHERE commands to track item locations. Parameters: commands (list): List of strings, each string is a command. Returns: list: List of results for each WHERE command. locations = {} results = [] for command in commands: parts = command.split() if parts[0] == \\"MOVE\\": item = int(parts[1]) location = int(parts[2]) locations[item] = location elif parts[0] == \\"WHERE\\": item = int(parts[1]) if item in locations: results.append(str(locations[item])) else: results.append(\\"UNKNOWN\\") return results def process_input(data): Processes the input data to separate each dataset and feed it to the process_commands function. Parameters: data (str): Multi-line string containing all data. Returns: list: List of results from all datasets. lines = data.strip().split(\\"n\\") index = 0 results = [] while index < len(lines): N, M = map(int, lines[index].split()) if N == 0 and M == 0: break commands = [] for _ in range(M): index += 1 commands.append(lines[index]) results.extend(process_commands(commands)) index += 1 return results # Example usage: # input_data = \\"3 5nMOVE 1 100nMOVE 2 200nWHERE 1nWHERE 2nWHERE 3n2 3nMOVE 1 300nMOVE 2 400nWHERE 1n0 0\\" # print(\\"n\\".join(process_input(input_data)))"},{"question":"def number_of_island_groups(N: int, M: int, bridges: List[Tuple[int, int]]) -> int: Determine the number of groups of islands. >>> number_of_island_groups(4, 2, [(1, 2), (3, 4)]) 2 >>> number_of_island_groups(4, 3, [(1, 2), (2, 3), (4, 3)]) 1 >>> number_of_island_groups(5, 0, []) 5 >>> number_of_island_groups(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> number_of_island_groups(6, 4, [(1, 2), (2, 3), (4, 5)]) 3 >>> number_of_island_groups(7, 3, [(1, 2), (3, 4), (5, 6)]) 4","solution":"def number_of_island_groups(N, M, bridges): from collections import defaultdict, deque # Adjacency list for graph graph = defaultdict(list) # Construct the graph for u, v in bridges: graph[u].append(v) graph[v].append(u) visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) groups = 0 # Traverse all nodes to count connected components for i in range(1, N+1): if i not in visited: bfs(i) groups += 1 return groups"},{"question":"def is_almost_palindromic(s: str) -> str: Determine if a given string is almost palindromic. A string is almost palindromic if it can be converted into a palindromic string by changing at most one character. >>> is_almost_palindromic(\\"abca\\") 'YES' >>> is_almost_palindromic(\\"racecar\\") 'YES' >>> is_almost_palindromic(\\"abcdef\\") 'NO'","solution":"def is_almost_palindromic(s): Determine if the string s is almost palindromic. left, right = 0, len(s) - 1 mismatch_count = 0 while left < right: if s[left] != s[right]: mismatch_count += 1 if mismatch_count > 1: return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"import heapq from typing import List, Tuple def shortest_path(N: int, M: int, K: int, roads: List[Tuple[int, int, int]], C: int) -> int: Function to find the shortest travel time from capital city to target city. Parameters: N : int - Number of cities M : int - Number of roads K : int - Target city roads : list of tuples - List of roads where each tuple contains (u, v, w) C : int - Capital city Returns: int - Shortest travel time from capital city to target city or -1 if not reachable >>> shortest_path(5, 7, 4, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (3, 5, 5), (4, 5, 1)], 1) 6 >>> shortest_path(3, 3, 3, [(1, 2, 4), (2, 3, 3), (1, 3, 8)], 1) 7 >>> shortest_path(4, 2, 4, [(1, 2, 4), (2, 3, 3)], 1) -1 def test_shortest_path(): # Test case 1: Example given assert shortest_path(5, 7, 4, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (3, 5, 5), (4, 5, 1)], 1) == 6 # Additional test cases # Test case 2: Another set of numbers assert shortest_path(3, 3, 3, [(1, 2, 4), (2, 3, 3), (1, 3, 8)], 1) == 7 # Test case 3: Target city not reachable assert shortest_path(4, 2, 4, [(1, 2, 4), (2, 3, 3)], 1) == -1 # Test case 4: Minimum input values (direct connection) assert shortest_path(2, 1, 2, [(1, 2, 10)], 1) == 10 # Test case 5: Single road, not enough to connect all assert shortest_path(4, 1, 4, [(1, 2, 10)], 1) == -1 # Test case 6: Multiple paths, selecting shortest assert shortest_path(4, 5, 4, [(1, 2, 1), (2, 4, 10), (1, 3, 3), (3, 4, 1), (1, 4, 20)], 1) == 4","solution":"import heapq def shortest_path(N, M, K, roads, C): Function to find the shortest travel time from capital city to target city. Parameters: N : int - Number of cities M : int - Number of roads K : int - Target city roads : list of tuples - List of roads where each tuple contains (u, v, w) C : int - Capital city Returns: int - Shortest travel time from capital city to target city or -1 if not reachable # Create adjacency list graph = {i: [] for i in range(1, N + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Initialize priority queue and distances queue = [(0, C)] # (distance, city) distances = {i: float('inf') for i in range(1, N + 1)} distances[C] = 0 while queue: current_distance, current_city = heapq.heappop(queue) if current_distance > distances[current_city]: continue for neighbor, weight in graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) return distances[K] if distances[K] != float('inf') else -1"},{"question":"def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome. >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"abba\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"abccba\\") == True >>> is_palindrome(\\"a bcc ba\\") == False >>> is_palindrome(\\"a\\" * 1000) == True >>> is_palindrome(\\"Aa\\") == False","solution":"def is_palindrome(s): Checks if a given string is a palindrome. return s == s[::-1] # Example Usage if __name__ == \\"__main__\\": s = input().strip() if is_palindrome(s): print(\\"Yes\\") else: print(\\"No\\")"},{"question":"def max_subsequence_sum(n: int, k: int, sequence: List[int]) -> int: Returns the maximum sum of a sub-sequence of length k from the given sequence of integers. :param n: Length of the sequence :param k: Length of sub-sequence :param sequence: List of integers representing the sequence :return: Maximum sum of a sub-sequence of length k >>> max_subsequence_sum(5, 3, [2, 1, 5, 1, 3]) 10 >>> max_subsequence_sum(6, 2, [-1, -2, -3, -4, -5, -6]) -3","solution":"def max_subsequence_sum(n, k, sequence): Returns the maximum sum of a sub-sequence of length k from the given sequence of integers. :param n: Length of the sequence :param k: Length of sub-sequence :param sequence: List of integers representing the sequence :return: Maximum sum of a sub-sequence of length k # Sort the sequence in descending order sorted_sequence = sorted(sequence, reverse=True) # Take the first k elements from the sorted sequence max_subsequence = sorted_sequence[:k] # Return the sum of these k elements return sum(max_subsequence)"},{"question":"def count_active_sessions(n: int, k: int, logs: List[Tuple[int, int, str]]) -> Dict[int, int]: Calculate the number of active sessions for each user. Args: n (int): The number of messages in the chat log. k (int): The maximum allowed minutes between consecutive messages in an active session. logs (List[Tuple[int, int, str]]): List of tuples where each tuple represents a message with user_id, timestamp, and message. Returns: Dict[int, int]: Dictionary where keys are user_ids and values are the count of active sessions for each user. Example: >>> count_active_sessions(5, 10, [(1, 10, \\"Hello\\"), (2, 15, \\"Hi\\"), (1, 20, \\"How are you?\\"), (1, 50, \\"Goodbye\\"), (2, 60, \\"See you\\")]) {1: 2, 2: 2}","solution":"def count_active_sessions(n, k, logs): from collections import defaultdict # Dictionary to store user's messages sorted by timestamp user_messages = defaultdict(list) # Populate the dictionary with user message logs for log in logs: user_id, timestamp, message = log user_messages[user_id].append(timestamp) # Result dictionary to store the count of active sessions for each user active_sessions = {} # Calculate active sessions for each user for user_id in sorted(user_messages.keys()): timestamps = sorted(user_messages[user_id]) session_count = 1 for i in range(1, len(timestamps)): if timestamps[i] - timestamps[i-1] > k: session_count += 1 active_sessions[user_id] = session_count return active_sessions # Example usage (You can remove this part before actual testing or submission) if __name__ == \\"__main__\\": logs_input = [ (1, 10, \\"Hello\\"), (2, 15, \\"Hi\\"), (1, 20, \\"How are you?\\"), (1, 50, \\"Goodbye\\"), (2, 60, \\"See you\\"), ] n = 5 k = 10 result = count_active_sessions(n, k, logs_input) for user_id, sessions in result.items(): print(f\\"{user_id} {sessions}\\")"},{"question":"def is_path_exist(matrix: List[List[str]]) -> str: Checks if there is a path from the top-left corner to the bottom-right corner in the given matrix. >>> is_path_exist([ ... ['O', 'X', 'O'], ... ['O', 'X', 'O'], ... ['O', 'O', 'O'] ... ]) == \\"YES\\" >>> is_path_exist([ ... ['O', 'X', 'O'], ... ['X', 'X', 'X'], ... ['O', 'O', 'O'] ... ]) == \\"NO\\" >>> is_path_exist([['O']]) == \\"YES\\" >>> is_path_exist([['X']]) == \\"NO\\" >>> is_path_exist([ ... ['O', 'O', 'O', 'O'], ... ['X', 'X', 'O', 'X'], ... ['O', 'O', 'O', 'O'], ... ['O', 'X', 'X', 'O'] ... ]) == \\"YES\\" >>> is_path_exist([ ... ['O', 'O', 'O', 'O'], ... ['X', 'X', 'O', 'X'], ... ['O', 'O', 'O', 'X'], ... ['O', 'X', 'X', 'X'] ... ]) == \\"NO\\"","solution":"def is_path_exist(matrix): Checks if there is a path from the top-left corner to the bottom-right corner in the given matrix. m = len(matrix) n = len(matrix[0]) if matrix[0][0] == 'X' or matrix[m-1][n-1] == 'X': return \\"NO\\" visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): # Base condition: if reach the bottom-right corner if x == m - 1 and y == n - 1: return True # Mark the cell as visited visited[x][y] = True # Explore the 4 adjacent cells directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and not visited[new_x][new_y] and matrix[new_x][new_y] == 'O': if dfs(new_x, new_y): return True return False return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def find_manager_average_rating(n, employees, m): Calculates the average performance rating of the subtree of the given manager. :param n: int, number of employees :param employees: list of dicts, each dict {id: int, manager: int, rating: int} :param m: int, id of the manager to calculate the average rating for :return: float, average rating rounded to two decimal places, or -1 if the manager does not exist pass # Test cases def test_average_rating_regular_case(): employees = [ {\\"id\\": 1, \\"manager\\": 0, \\"rating\\": 5}, {\\"id\\": 2, \\"manager\\": 1, \\"rating\\": 3}, {\\"id\\": 3, \\"manager\\": 1, \\"rating\\": 4}, {\\"id\\": 4, \\"manager\\": 2, \\"rating\\": 2}, {\\"id\\": 5, \\"manager\\": 2, \\"rating\\": 3}, {\\"id\\": 6, \\"manager\\": 3, \\"rating\\": 4} ] assert find_manager_average_rating(6, employees, 1) == 3.50 def test_average_rating_single_employee(): employees = [ {\\"id\\": 1, \\"manager\\": 0, \\"rating\\": 5} ] assert find_manager_average_rating(1, employees, 1) == 5.00 def test_average_rating_with_no_subordinates(): employees = [ {\\"id\\": 1, \\"manager\\": 0, \\"rating\\": 5}, {\\"id\\": 2, \\"manager\\": 1, \\"rating\\": 3}, {\\"id\\": 3, \\"manager\\": 1, \\"rating\\": 4}, ] assert find_manager_average_rating(3, employees, 3) == 4.00 def test_average_rating_with_some_subordinates(): employees = [ {\\"id\\": 1, \\"manager\\": 0, \\"rating\\": 5}, {\\"id\\": 2, \\"manager\\": 1, \\"rating\\": 3}, {\\"id\\": 3, \\"manager\\": 1, \\"rating\\": 4}, {\\"id\\": 4, \\"manager\\": 2, \\"rating\\": 2}, {\\"id\\": 5, \\"manager\\": 2, \\"rating\\": 3}, ] assert find_manager_average_rating(5, employees, 2) == 2.67 def test_manager_does_not_exist(): employees = [ {\\"id\\": 1, \\"manager\\": 0, \\"rating\\": 5}, {\\"id\\": 2, \\"manager\\": 1, \\"rating\\": 3}, {\\"id\\": 3, \\"manager\\": 1, \\"rating\\": 4}, ] assert find_manager_average_rating(3, employees, 4) == -1","solution":"def find_manager_average_rating(n, employees, m): Calculates the average performance rating of the subtree of the given manager. :param n: int, number of employees :param employees: list of dicts, each dict {id: int, manager: int, rating: int} :param m: int, id of the manager to calculate the average rating for :return: float, average rating rounded to two decimal places, or -1 if the manager does not exist # Create a mapping for employees id_to_employee = {emp['id']: emp for emp in employees} # Check if the manager exists if m not in id_to_employee: return -1 def get_all_subordinates(manager_id): subordinates = [] for emp in employees: if emp['manager'] == manager_id: subordinates.append(emp['id']) subordinates.extend(get_all_subordinates(emp['id'])) return subordinates # Get all subordinates of the given manager all_employees = get_all_subordinates(m) all_employees.append(m) # include the manager themselves # Calculate the average rating total_rating = sum(id_to_employee[emp_id]['rating'] for emp_id in all_employees) average_rating = total_rating / len(all_employees) return round(average_rating, 2)"},{"question":"def next_player(H: int, S: int) -> str: Determines which player should start the next turn based on the number of balls potted. Args: H (int): Number of balls potted by Player A S (int): Number of balls potted by Player B Returns: str: \\"PLAYER A\\" if it's Player A's turn next, \\"PLAYER B\\" otherwise >>> next_player(5, 3) \\"PLAYER A\\" >>> next_player(2, 6) \\"PLAYER A\\" >>> next_player(7, 7) \\"PLAYER B\\" pass","solution":"def next_player(H, S): Determines which player should start the next turn based on the number of balls potted. Args: H (int): Number of balls potted by Player A S (int): Number of balls potted by Player B Returns: str: \\"PLAYER A\\" if it's Player A's turn next, \\"PLAYER B\\" otherwise if H == S: return \\"PLAYER B\\" else: return \\"PLAYER A\\""},{"question":"def is_toeplitz_matrix(matrix: List[List[int]]) -> bool: Determines if a given matrix is a Toeplitz matrix. Args: matrix (list of list of int): The matrix to check. Returns: bool: True if the matrix is a Toeplitz matrix, False otherwise. >>> is_toeplitz_matrix([[1, 2, 3, 4], [5, 1, 2, 3], [9, 5, 1, 2]]) True >>> is_toeplitz_matrix([[1, 2], [2, 2]]) False from typing import List","solution":"def is_toeplitz_matrix(matrix): Determines if a given matrix is a Toeplitz matrix. Args: matrix (list of list of int): The matrix to check. Returns: bool: True if the matrix is a Toeplitz matrix, False otherwise. # Get dimensions of the matrix rows = len(matrix) cols = len(matrix[0]) # Check if every diagonal from top-left to bottom-right has the same element for r in range(rows): for c in range(cols): if r > 0 and c > 0 and matrix[r][c] != matrix[r-1][c-1]: return False return True"},{"question":"def is_palindrome(number: int) -> str: Determines if a given number is a palindrome. >>> is_palindrome(121) \\"YES\\" >>> is_palindrome(123) \\"NO\\" def check_palindromes(test_cases: List[int]) -> List[str]: For each number in test_cases, determines if it is a palindrome and returns the result as a list of 'YES' or 'NO'. from solution import is_palindrome, check_palindromes def test_is_palindrome(): assert is_palindrome(121) == \\"YES\\" assert is_palindrome(123) == \\"NO\\" assert is_palindrome(111) == \\"YES\\" assert is_palindrome(1) == \\"YES\\" assert is_palindrome(22) == \\"YES\\" assert is_palindrome(10) == \\"NO\\" def test_check_palindromes(): test_cases = [121, 123, 111] assert check_palindromes(test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] test_cases = [1, 22, 333, 4444, 12321] assert check_palindromes(test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] test_cases = [10, 123456, 98789] assert check_palindromes(test_cases) == [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def is_palindrome(number): Returns 'YES' if the given number is a palindrome, otherwise returns 'NO'. str_number = str(number) if str_number == str_number[::-1]: return \\"YES\\" else: return \\"NO\\" def check_palindromes(test_cases): For each number in test_cases, determines if it is a palindrome and returns the result as a list of 'YES' or 'NO'. results = [] for number in test_cases: results.append(is_palindrome(number)) return results"},{"question":"def can_partition_to_equal_subsequences(S: str) -> str: Determines if string S can be partitioned into two non-empty subsequences that are equal when sorted. >>> can_partition_to_equal_subsequences(\\"abba\\") \\"YES\\" >>> can_partition_to_equal_subsequences(\\"abcd\\") \\"NO\\" >>> can_partition_to_equal_subsequences(\\"abacabad\\") \\"YES\\" >>> can_partition_to_equal_subsequences(\\"a\\") \\"NO\\" >>> can_partition_to_equal_subsequences(\\"aa\\") \\"YES\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases for the problem. >>> process_test_cases(3, [\\"abba\\", \\"abcd\\", \\"abacabad\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(2, [\\"a\\", \\"aa\\"]) [\\"NO\\", \\"YES\\"] >>> process_test_cases(1, [\\"abcde\\"]) [\\"NO\\"] from typing import List","solution":"def can_partition_to_equal_subsequences(S): Determines if string S can be partitioned into two non-empty subsequences that are equal when sorted. Args: S (str): The input string consisting of lowercase Latin letters. Returns: str: \\"YES\\" if it's possible to partition the string as required, \\"NO\\" otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(S) # Check if there's at least one character that appears more than once for count in char_count.values(): if count > 1: return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): Processes multiple test cases for the problem. Args: T (int): The number of test cases. test_cases (list of str): The list of test case strings. Returns: list of str: List of results for each test case. results = [] for S in test_cases: results.append(can_partition_to_equal_subsequences(S)) return results"},{"question":"def generate_pyramid(height): Generate a right-aligned pyramid pattern consisting of consecutive numbers. If the input height is not a valid positive integer or is less than 2, return \\"INVALID\\". Each level of the pyramid should be right-aligned. Args: height (int): The height of the pyramid. Returns: str: The pyramid pattern as a string. >>> generate_pyramid(1) \\"INVALID\\" >>> generate_pyramid(3) \\" 1n 2 2n3 3 3\\" >>> generate_pyramid(5) \\" 1n 2 2n 3 3 3n 4 4 4 4n5 5 5 5 5\\" def process_inputs(inputs): Process multiple heights and generate the corresponding pyramid patterns. Args: inputs (list): List of integers representing the heights. Returns: str: The pyramid patterns separated by double newlines. >>> process_inputs([1, 3, 5, 8, -1]) \\"INVALIDnn 1n 2 2n3 3 3nn 1n 2 2n 3 3 3n 4 4 4 4n5 5 5 5 5nn 1n 2 2n 3 3 3n 4 4 4 4n 5 5 5 5 5n 6 6 6 6 6 6n 7 7 7 7 7 7 7n8 8 8 8 8 8 8 8nnINVALID\\"","solution":"def generate_pyramid(height): if not isinstance(height, int) or height < 2 or height > 15: return \\"INVALID\\" result = [] for i in range(1, height + 1): row = \\" \\" * (height - i) + (\\" \\".join([str(i)] * i)) result.append(row) return \\"n\\".join(result) def process_inputs(inputs): results = [] for height in inputs: results.append(generate_pyramid(height)) return \\"nn\\".join(results)"},{"question":"def uniquePaths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a grid. :param m: int - number of rows :param n: int - number of columns :return: int - number of unique paths >>> uniquePaths(3, 2) 3 >>> uniquePaths(1, 5) 1 >>> uniquePaths(5, 1) 1 >>> uniquePaths(3, 3) 6 >>> uniquePaths(10, 10) 48620 >>> uniquePaths(15, 15) 40116600 >>> uniquePaths(1, 1) 1","solution":"def uniquePaths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a grid. :param m: int - number of rows :param n: int - number of columns :return: int - number of unique paths # Create a 2D array to store the number of paths to each cell dp = [[0]*n for _ in range(m)] # There is only 1 way to reach any cell in the first row, by moving right for i in range(n): dp[0][i] = 1 # There is only 1 way to reach any cell in the first column, by moving down for i in range(m): dp[i][0] = 1 # Calculate the number of paths for each cell in the grid for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return the number of paths to the bottom-right corner return dp[m-1][n-1]"},{"question":"def merge_and_remove_duplicates(L1, L2): Merges two sorted lists and removes duplicates to create a single sorted list with unique elements. Args: L1 (List[int]): The first sorted linked list. L2 (List[int]): The second sorted linked list. Returns: List[int]: A sorted list with unique elements. >>> merge_and_remove_duplicates([1, 3, 5, 7, 9], [2, 3, 5, 8]) [1, 2, 3, 5, 7, 8, 9] >>> merge_and_remove_duplicates([1, 1, 2], [2, 2, 3, 3]) [1, 2, 3]","solution":"def merge_and_remove_duplicates(L1, L2): Merges two sorted lists and removes duplicates to create a single sorted list with unique elements. merged = sorted(set(L1 + L2)) return merged # Example usage: # L1 = [1, 3, 5, 7, 9] # L2 = [2, 3, 5, 8] # print(merge_and_remove_duplicates(L1, L2)) # Output: [1, 2, 3, 5, 7, 8, 9]"},{"question":"def find_integer(n: int) -> int: Returns the smallest integer m such that the product of the digits of m equals n. If no such integer exists, return -1. >>> find_integer(5) 15 >>> find_integer(12) 26 >>> find_integer(17) -1 >>> find_integer(36) 49 >>> find_integer(0) -1 >>> find_integer(-5) -1 >>> find_integer(9) 19 >>> find_integer(100) 455 >>> find_integer(37) -1 >>> find_integer(101) -1 >>> find_integer(10) 25 >>> find_integer(27) 39","solution":"def find_integer(n): Returns the smallest integer m such that the product of the digits of m equals n. If no such integer exists, return -1. Parameters: n (int): Integer for which to find the smallest integer m. Returns: int: The smallest integer m where product of its digits equals n or -1 if no such m exists. if n <= 0: return -1 # Check for single digit factorization if n < 10: return n + 10 factors = [] for i in range(9, 1, -1): while n % i == 0: factors.append(i) n //= i if n != 1: return -1 factors = sorted(factors) m = int(''.join(map(str, factors))) return m if m >= 10 else -1"},{"question":"def grid_operations(R: int, C: int, queries: List[str]) -> List[int]: Perform operations on a grid of size RxC based on the given queries. Args: R (int): Number of rows in the grid. C (int): Number of columns in the grid. queries (List[str]): List of queries to perform on the grid. Returns: List[int]: List of results for each query operation. Example: >>> grid_operations(4, 5, ['I 1 1 2 2 3', 'I 0 0 1 1 2', 'Q 1 1', 'Q 2 2', 'I 0 0 3 4 1', 'Q 3 4']) [5, 3, 1] >>> grid_operations(3, 3, ['Q 0 0', 'Q 1 1', 'Q 2 2']) [0, 0, 0]","solution":"def grid_operations(R, C, queries): grid = [[0] * C for _ in range(R)] results = [] for query in queries: parts = query.split() if parts[0] == 'I': r0, c0, r1, c1, x = map(int, parts[1:]) for i in range(r0, r1 + 1): for j in range(c0, c1 + 1): grid[i][j] += x elif parts[0] == 'Q': r, c = map(int, parts[1:]) results.append(grid[r][c]) return results"},{"question":"def longest_unique_subarray_length(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with all unique elements. >>> longest_unique_subarray_length([5, 1, 3, 5, 2, 3, 4, 1]) == 5 >>> longest_unique_subarray_length([1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray_length([1, 1, 1, 1, 1]) == 1 >>> longest_unique_subarray_length([1, 2, 3, 4, 1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray_length([]) == 0 >>> longest_unique_subarray_length([1]) == 1 >>> longest_unique_subarray_length([1, 2, 1, 3, 1, 2, 3, 4]) == 4 >>> longest_unique_subarray_length([1, 2, 3, 2, 1, 2, 3, 4]) == 4","solution":"def longest_unique_subarray_length(arr): Returns the length of the longest contiguous subarray with all unique elements. start = 0 max_length = 0 unique_elements = set() for end in range(len(arr)): while arr[end] in unique_elements: unique_elements.remove(arr[start]) start += 1 unique_elements.add(arr[end]) max_length = max(max_length, end - start + 1) return max_length"},{"question":"def separate_dragons_unicorns(T, test_cases): In a mystical land, there are two types of magical creatures, Dragons and Unicorns. Dragons are represented by 0 and Unicorns are represented by 1. The King of this land wants to perform a magical spell that requires separating Dragons and Unicorns into two different groups. Each group can be represented by a separate array, with all Dragons in one array and all Unicorns in another. Your task is to help the King by writing a program to achieve this separation. Parameters: T (int): the number of test cases test_cases (list): a list of tuples, where each tuple contains an integer N and a list of integers representing the elements of the array B. Returns: list: a list of tuples, where each tuple contains two lists - the first list contains all Dragons (0's) and the second list contains all Unicorns (1's). Example: >>> separate_dragons_unicorns(2, [(3, [0, 1, 0]), (5, [1, 0, 1, 1, 0])]) [([0, 0], [1]), ([0, 0], [1, 1, 1])]","solution":"def separate_dragons_unicorns(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] creatures = test_cases[i][1] dragons = [creature for creature in creatures if creature == 0] unicorns = [creature for creature in creatures if creature == 1] results.append((dragons, unicorns)) return results"},{"question":"def min_blocks_required(string): Returns the minimum number of contiguous blocks required such that no two consecutive blocks have the same starting character. >>> min_blocks_required(\\"aabcc\\") 3 >>> min_blocks_required(\\"abcde\\") 1 >>> min_blocks_required(\\"aaa\\") 3 def process_test_cases(T, test_cases): Processes multiple test cases and returns a list of results for the minimum number of blocks required for each test case. >>> process_test_cases(3, [\\"aabcc\\", \\"abcde\\", \\"aaa\\"]) [3, 1, 3] >>> process_test_cases(2, [\\"abbcc\\", \\"a\\"]) [3, 1]","solution":"def min_blocks_required(string): Returns the minimum number of contiguous blocks required such that no two consecutive blocks have the same starting character. if not string: return 0 # Initialize count of blocks block_count = 1 # Iterate over the string to check consecutive characters for i in range(1, len(string)): if string[i] == string[i-1]: block_count += 1 return block_count def process_test_cases(T, test_cases): results = [] for string in test_cases: results.append(min_blocks_required(string)) return results if __name__ == \\"__main__\\": T = int(input()) test_cases = [input().strip() for _ in range(T)] results = process_test_cases(T, test_cases) for result in results: print(result)"},{"question":"def final_value(k: int, operations: List[str]) -> int: Calculates the final value of the variable n after performing a series of 'n++' and 'n--' operations. Parameters: k (int): The number of operations. operations (list of str): The list of operations, each of which is either 'n++' or 'n--'. Returns: int: The final value of n. Examples: >>> final_value(3, [\\"n++\\", \\"n++\\", \\"n--\\"]) 1 >>> final_value(4, [\\"n--\\", \\"n++\\", \\"n++\\", \\"n++\\"]) 2","solution":"def final_value(k, operations): Calculates the final value of the variable n after performing a series of 'n++' and 'n--' operations. Parameters: k (int): The number of operations. operations (list of str): The list of operations, each of which is either 'n++' or 'n--'. Returns: int: The final value of n. n = 0 for operation in operations: if operation == \\"n++\\": n += 1 elif operation == \\"n--\\": n -= 1 return n"},{"question":"def count_ways_to_split(n: int, k: int, sequence: List[int]) -> int: Return the number of ways to split the sequence into exactly k contiguous subarrays with each subarray's sum being even. Args: n (int): Length of the sequence. k (int): Number of contiguous subarrays. sequence (List[int]): List of integers representing the sequence. Returns: int: Number of ways to split the sequence accordingly. Examples: >>> count_ways_to_split(5, 2, [1, 3, 2, 6, 4]) 2 >>> count_ways_to_split(3, 2, [2, 2, 2]) 2 pass # Test cases def test_count_ways_to_split(): assert count_ways_to_split(5, 2, [1, 3, 2, 6, 4]) == 2 assert count_ways_to_split(3, 2, [2, 2, 2]) == 2 assert count_ways_to_split(4, 2, [1, 1, 1, 1]) == 0 assert count_ways_to_split(6, 3, [4, 2, 2, 4, 2, 4]) == 10 assert count_ways_to_split(1, 1, [2]) == 1 assert count_ways_to_split(1, 1, [1]) == 0 assert count_ways_to_split(5, 1, [1, 2, 3, 4, 5]) == 1","solution":"def count_ways_to_split(n, k, sequence): Return the number of ways to split the sequence into exactly k contiguous subarrays with each subarray's sum being even. even_count = [0] * (n + 1) for i in range(n): even_count[i + 1] = even_count[i] + (sequence[i] % 2 == 0) from functools import lru_cache @lru_cache(None) def dp(i, j): if j == 0: return 1 if i == 0 else 0 if i == 0: return 0 ways = 0 for p in range(i): if (even_count[i] - even_count[p]) > 0: ways += dp(p, j-1) return ways return dp(n, k)"},{"question":"def count_rectangles(points): Given a list of 2D integer points, determine the number of rectangles (aligned with coordinate axes) that can be formed using these points as vertices. >>> count_rectangles([(1, 1), (1, 4), (2, 1), (2, 4), (4, 1), (4, 4)]) 3 >>> count_rectangles([(0, 0), (1, 2), (2, 1), (3, 3)]) 0 >>> count_rectangles([(1, 1)]) 0 >>> count_rectangles([(1, 1), (2, 2)]) 0 >>> count_rectangles([(1, 1), (1, 2), (2, 1), (2, 3)]) 0 >>> count_rectangles([(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]) 3","solution":"def count_rectangles(points): Given a list of 2D integer points, determine the number of rectangles (aligned with coordinate axes) that can be formed using these points as vertices. point_set = set(points) rectangles = 0 # Iterate over all pairs of points for i in range(len(points)): for j in range(i + 1, len(points)): x1, y1 = points[i] x2, y2 = points[j] # Check if we can form a diagonal of the rectangle if x1 != x2 and y1 != y2: # Check the opposite corners if (x1, y2) in point_set and (x2, y1) in point_set: rectangles += 1 # Each rectangle is counted twice, so divide by 2 return rectangles // 2 # Example usage: # points_input = [(1, 1), (1, 4), (2, 1), (2, 4), (4, 1), (4, 4)] # print(count_rectangles(points_input)) # Output: 3"},{"question":"def is_possible_to_rearrange(S: str, K: int) -> bool: Checks if it is possible to rearrange the characters in the string such that any two adjacent characters are at least K distance apart. >>> is_possible_to_rearrange(\\"aabbcc\\", 2) True >>> is_possible_to_rearrange(\\"aaabc\\", 3) False >>> is_possible_to_rearrange(\\"abcdef\\", 3) True >>> is_possible_to_rearrange(\\"aaa\\", 2) False >>> is_possible_to_rearrange(\\"a\\", 1) True def process_cases(T: int, cases: list) -> list: Process multiple cases and returns the results for each case. >>> process_cases(3, [(\\"aabbcc\\", 2), (\\"aaabc\\", 3), (\\"abcdef\\", 3)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_cases(2, [(\\"aaa\\", 2), (\\"a\\", 1)]) [\\"NO\\", \\"YES\\"]","solution":"from collections import Counter import heapq def is_possible_to_rearrange(S, K): if K == 1: return True # Any arrangement is possible when distance K is 1 # Count frequency of each character counter = Counter(S) # Create a max heap based on frequency of characters max_heap = [(-cnt, char) for char, cnt in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Decrease the count and add to the wait queue count += 1 # since count is negative, we add 1 to reduce (make more positive) wait_queue.append((count, char)) # If the wait queue is of size K, re-add the character back to the heap if len(wait_queue) >= K: readd_count, readd_char = wait_queue.pop(0) if readd_count < 0: heapq.heappush(max_heap, (readd_count, readd_char)) return len(result) == len(S) def process_cases(T, cases): results = [] for i in range(T): S, K = cases[i] if is_possible_to_rearrange(S, int(K)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sum_of_second_smallest_and_second_largest(lst): Create an algorithm that finds the sum of the second smallest and second largest unique elements in a given list of integers. If there are less than four unique elements, return None. >>> sum_of_second_smallest_and_second_largest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) 8 >>> sum_of_second_smallest_and_second_largest([1, 2, 2, 3]) None >>> sum_of_second_smallest_and_second_largest([1, 2, 3, 4]) 5 >>> sum_of_second_smallest_and_second_largest([10, 20, 30, 40, 50, 60, 70]) 80 >>> sum_of_second_smallest_and_second_largest([1]) None >>> sum_of_second_smallest_and_second_largest([10, 20, 10, 20, 10, 20]) None >>> sum_of_second_smallest_and_second_largest([5, 5, 1, 1, 2, 2, 3, 3, 4, 4]) 6 >>> sum_of_second_smallest_and_second_largest([4, 3, 3, 4, 4, 4, 2, 2, 1, 1]) 5","solution":"def sum_of_second_smallest_and_second_largest(lst): Returns the sum of the second smallest and second largest unique elements in the list. If there are less than four unique elements, return None. unique_elements = sorted(set(lst)) if len(unique_elements) < 4: return None second_smallest = unique_elements[1] second_largest = unique_elements[-2] return second_smallest + second_largest"},{"question":"def hasEqualFrequency(s: str) -> bool: Determines if all unique characters in the string appear the same number of times. Args: s (str): Input string consisting of lowercase English letters. Returns: bool: True if all unique characters appear the same number of times, False otherwise. Examples: >>> hasEqualFrequency(\\"abacbc\\") True >>> hasEqualFrequency(\\"aaabb\\") False import pytest def test_case_1(): assert hasEqualFrequency(\\"abacbc\\") == True def test_case_2(): assert hasEqualFrequency(\\"aaabb\\") == False def test_edge_case_1(): assert hasEqualFrequency(\\"a\\") == True def test_edge_case_2(): assert hasEqualFrequency(\\"ab\\") == True def test_mixed_case(): assert hasEqualFrequency(\\"aabbcc\\") == True def test_irregular_case(): assert hasEqualFrequency(\\"aabbccc\\") == False","solution":"def hasEqualFrequency(s): Determines if all unique characters in the string appear the same number of times. Args: s (str): Input string consisting of lowercase English letters. Returns: bool: True if all unique characters appear the same number of times, False otherwise. from collections import Counter # Count the frequency of each character in the string char_counts = Counter(s) # Get all frequency values frequency_values = list(char_counts.values()) # Check if all frequencies are the same return len(set(frequency_values)) == 1"},{"question":"def min_cost_to_establish_links(N: int, costs: List[List[int]]) -> int: Determines the minimum cost to establish the required communication links. The function calculates the minimum total cost of establishing bidirectional communication links between nodes in a distributed database system, ensuring that any update can be propagated through at most one intermediate node. Args: N (int): The number of nodes in the distributed database system. costs (List[List[int]]): A 2D list where costs[i][j] represents the cost of a direct link between node i and j. Returns: int: The minimum total cost to establish the required communication links. Example: >>> N = 4 >>> costs = [ >>> [0, 2, 6, 8], >>> [2, 0, 4, 7], >>> [6, 4, 0, 3], >>> [8, 7, 3, 0] >>> ] >>> min_cost_to_establish_links(N, costs) 7","solution":"import heapq def min_cost_to_establish_links(N, costs): # Using Prim's algorithm to find the minimum spanning tree (MST) min_heap = [(0, 0)] # (cost, node) visited = [False] * N total_cost = 0 edges_used = 0 while min_heap and edges_used < N: cost, node = heapq.heappop(min_heap) if not visited[node]: visited[node] = True total_cost += cost edges_used += 1 for neighbor in range(N): if not visited[neighbor]: heapq.heappush(min_heap, (costs[node][neighbor], neighbor)) return total_cost"},{"question":"def max_energy_collected(n: int, m: int, grid: List[List[int]]) -> int: Find the path that maximizes the total energy collected by the robot. The robot can only move right or down. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the grid with energy levels. Returns: int: Maximum energy collected. Examples: >>> n, m = 3, 3 >>> grid = [ >>> [1, -2, 3], >>> [4, 5, -6], >>> [7, 8, 9] >>> ] >>> max_energy_collected(n, m, grid) 27 >>> n, m = 1, 4 >>> grid = [ >>> [3, 2, -1, 4] >>> ] >>> max_energy_collected(n, m, grid) 8","solution":"def max_energy_collected(n, m, grid): # Create a 2D dp array to store the maximum energy collected up to each cell dp = [[0] * m for _ in range(n)] # Initialize the top left cell dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The answer is the maximum energy collected at the bottom-right corner return dp[n - 1][m - 1] # Function to parse input and call max_energy_collected def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [] index = 2 for i in range(n): grid.append([int(data[index + j]) for j in range(m)]) index += m print(max_energy_collected(n, m, grid)) if __name__ == \\"__main__\\": main()"},{"question":"def min_cars_needed(test_cases): Determine the minimum number of cars required to accommodate all the friends comfortably. Args: test_cases: A list of tuples, each containing two integers representing the number of friends and the seating capacity of one car respectively. Returns: A list of integers representing the minimum number of cars needed for each test case. >>> min_cars_needed([(12, 5), (9, 4), (6, 3)]) [3, 3, 2] >>> min_cars_needed([(5, 5), (3, 5)]) [1, 1] def process_input(input_str): Process the input string into the required format for min_cars_needed function. Args: input_str: A string containing the number of test cases, followed by the number of friends and the seating capacity of one car for each test case. Returns: A list of tuples, each containing two integers as required by min_cars_needed function. >>> process_input(\\"3n12 5n9 4n6 3\\") [(12, 5), (9, 4), (6, 3)] def process_output(output): Process the output from the min_cars_needed function into the required output format. Args: output: A list of integers representing the minimum number of cars needed for each test case. Returns: A string representing the processed output. >>> process_output([3, 3, 2]) \\"3n3n2\\" def solve(input_str): Solve the problem given the input string. Args: input_str: A string containing the input in the specified format. Returns: A string representing the output in the specified format. >>> solve(\\"3n12 5n9 4n6 3\\") \\"3n3n2\\"","solution":"import math def min_cars_needed(test_cases): result = [] for m, n in test_cases: result.append(math.ceil(m / n)) return result def process_input(input_str): lines = input_str.splitlines() T = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:T+1]] return test_cases def process_output(output): return \\"n\\".join(map(str, output)) def solve(input_str): test_cases = process_input(input_str) result = min_cars_needed(test_cases) return process_output(result)"},{"question":"from typing import List def max_subarray_length(nums: List[int], k: int) -> int: Find the maximum length of a contiguous subarray that sums to \`k\`. Args: nums (List[int]): A list of integers. k (int): The target sum. Returns: int: The length of the longest subarray that sums to \`k\`. Examples: >>> max_subarray_length([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_length([-2, -1, 2, 1], 1) 2 >>> max_subarray_length([1, 1, 1], 5) 0 >>> max_subarray_length([1, -1, 1, -1, 2, 3, -2, 3, 2], 4) 5","solution":"from typing import List def max_subarray_length(nums: List[int], k: int) -> int: sum_index_map = {} current_sum = 0 max_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum == k: max_length = i + 1 if current_sum - k in sum_index_map: max_length = max(max_length, i - sum_index_map[current_sum - k]) if current_sum not in sum_index_map: sum_index_map[current_sum] = i return max_length"},{"question":"def is_subsequence(S1: str, S2: str) -> str: Given two strings, S1 and S2, determine if S2 is a subsequence of S1. Returns \\"YES\\" if S2 is a subsequence, otherwise returns \\"NO\\". >>> is_subsequence(\\"abcde\\", \\"ace\\") \\"YES\\" >>> is_subsequence(\\"abcde\\", \\"aec\\") \\"NO\\" >>> is_subsequence(\\"abcdef\\", \\"abcdef\\") \\"YES\\" >>> is_subsequence(\\"abcdef\\", \\"abcdefgh\\") \\"NO\\" >>> is_subsequence(\\"abcde\\", \\"\\") \\"YES\\" >>> is_subsequence(\\"\\", \\"a\\") \\"NO\\"","solution":"def is_subsequence(S1: str, S2: str) -> str: Returns \\"YES\\" if S2 is a subsequence of S1, otherwise \\"NO\\". iter_S1 = iter(S1) return \\"YES\\" if all(char in iter_S1 for char in S2) else \\"NO\\""},{"question":"from typing import List, Tuple, Dict def track_stamps(transactions: List[Tuple[str, str]]) -> Dict[str, Dict[str, int]]: Track the number of stamps each customer has and determine when they are eligible for a free album. Each time a customer buys an album, they receive a loyalty card stamp. Once they have collected 10 stamps, they can get a free album. This function accepts a list of transactions and returns a dictionary indicating how many stamps each customer has and how many free albums they have received. >>> track_stamps([('Alice', 'buy'), ('Bob', 'buy'), ('Alice', 'buy')]) {'Alice': {'stamps': 2, 'free_albums': 0}, 'Bob': {'stamps': 1, 'free_albums': 0}} >>> track_stamps([('Alice', 'buy')] * 10) {'Alice': {'stamps': 0, 'free_albums': 1}} pass","solution":"from typing import List, Tuple, Dict def track_stamps(transactions: List[Tuple[str, str]]) -> Dict[str, Dict[str, int]]: result = {} for customer_name, transaction in transactions: if transaction == 'buy': if customer_name not in result: result[customer_name] = {'stamps': 0, 'free_albums': 0} result[customer_name]['stamps'] += 1 if result[customer_name]['stamps'] == 10: result[customer_name]['stamps'] = 0 result[customer_name]['free_albums'] += 1 return result"},{"question":"from typing import List, Tuple def most_frequent_element(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the most frequently occurring element in a list of integers for multiple test cases. If there is a tie, return the smallest one. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing an integer N and a list of N integers. Returns: List[int]: A list of the most frequently occurring elements for each test case. Examples: >>> most_frequent_element(2, [(6, [1, 2, 2, 3, 3, 3]), (4, [5, 5, 4, 4])]) [3, 4] >>> most_frequent_element(1, [(4, [999999999, 999999999, 1000000000, 1000000000])]) [999999999] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parses the input string to extract the number of test cases and the test cases. Parameters: input_string (str): The input string containing the number of test cases and the test cases. Returns: Tuple[int, List[Tuple[int, List[int]]]]: A tuple containing the number of test cases and a list of test cases. Examples: >>> parse_input(\\"2n6n1 2 2 3 3 3n4n5 5 4 4\\") (2, [(6, [1, 2, 2, 3, 3, 3]), (4, [5, 5, 4, 4])]) >>> parse_input(\\"1n4n999999999 999999999 1000000000 1000000000\\") (1, [(4, [999999999, 999999999, 1000000000, 1000000000])]) pass from solution import most_frequent_element, parse_input def test_example(): input_string = \\"2n6n1 2 2 3 3 3n4n5 5 4 4\\" T, test_cases = parse_input(input_string) assert most_frequent_element(T, test_cases) == [3, 4] def test_single_element(): input_string = \\"1n1n1\\" T, test_cases = parse_input(input_string) assert most_frequent_element(T, test_cases) == [1] def test_all_different_elements(): input_string = \\"1n5n1 2 3 4 5\\" T, test_cases = parse_input(input_string) assert most_frequent_element(T, test_cases) == [1] def test_tie_with_multiple_elements(): input_string = \\"1n6n1 2 3 3 2 1\\" T, test_cases = parse_input(input_string) assert most_frequent_element(T, test_cases) == [1] def test_large_numbers(): input_string = \\"1n4n999999999 999999999 1000000000 1000000000\\" T, test_cases = parse_input(input_string) assert most_frequent_element(T, test_cases) == [999999999] def test_multiple_test_cases(): input_string = \\"3n3n1 1 2n5n3 3 3 4 4n6n2 2 2 3 3 3\\" T, test_cases = parse_input(input_string) assert most_frequent_element(T, test_cases) == [1, 3, 2] def test_all_same_elements(): input_string = \\"1n5n7 7 7 7 7\\" T, test_cases = parse_input(input_string) assert most_frequent_element(T, test_cases) == [7]","solution":"from collections import Counter def most_frequent_element(T, test_cases): results = [] for i in range(T): N, sequence = test_cases[i] counter = Counter(sequence) max_freq = max(counter.values()) most_frequent = [num for num, freq in counter.items() if freq == max_freq] results.append(min(most_frequent)) return results # Helper function to parse inputs def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] for i in range(1, T * 2, 2): N = int(lines[i]) sequence = list(map(int, lines[i+1].split())) test_cases.append((N, sequence)) return T, test_cases"},{"question":"from typing import List, Tuple def solve(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[str]: Determines if Alice and Bob can meet on the grid while avoiding obstacles. >>> solve(3, [(3, 3, [\\"...\\", \\"..#\\", \\"...\\"]), (3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]), (2, 2, [\\"..\\", \\"\\"])]) [\\"YES\\", \\"NO\\", \\"YES\\"] results = [] for i in range(t): n, m, grid = test_cases[i] # Your solution logic goes here to determine if Alice and Bob can meet. can_alice_and_bob_meet = False # set this boolean based on your logic results.append(\\"YES\\" if can_alice_and_bob_meet else \\"NO\\") return results def test_solver(): input_data = [ (3, [ (3, 3, [\\"...\\", \\"..#\\", \\"...\\"]), (3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]), (2, 2, [\\"..\\", \\"\\"]) ]) ] expected_outputs = [ [\\"YES\\", \\"NO\\", \\"YES\\"] ] for i, (t, test_cases) in enumerate(input_data): results = solve(t, test_cases) assert results == expected_outputs[i] test_solver()","solution":"from collections import deque def can_meet(n, m, grid): def bfs(start): queue = deque([start]) visited = [[False] * m for _ in range(n)] visited[start[0]][start[1]] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] reachable = set() while queue: x, y = queue.popleft() reachable.add((x, y)) for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < n and 0 <= new_y < m and not visited[new_x][new_y] and grid[new_x][new_y] == '.': visited[new_x][new_y] = True queue.append((new_x, new_y)) return reachable alice_reachable = bfs((0, 0)) bob_reachable = bfs((n-1, m-1)) return bool(alice_reachable & bob_reachable) def solve(t, test_cases): results = [] for i in range(t): n, m, grid = test_cases[i] if can_meet(n, m, grid): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_increasing_triplet(nums: List[int]) -> bool: Returns True if there exists a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. Args: nums (List[int]): A list of integers. Returns: bool: True if there exists an increasing triplet, otherwise False. >>> is_increasing_triplet([1, 2, 3, 4, 5]) True >>> is_increasing_triplet([5, 4, 3, 2, 1]) False >>> is_increasing_triplet([2, 1, 5, 0, 4, 6]) True >>> is_increasing_triplet([1, 2, -10, -8, -7]) True","solution":"def is_increasing_triplet(nums): Returns True if there exists a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. Args: nums (List[int]): A list of integers. Returns: bool: True if there exists an increasing triplet, otherwise False. first = float('inf') second = float('inf') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"def check_winner(grid): Check if the first player wins based on the given 3x3 grid. >>> check_winner([ ['X', 'X', 'X'], ['.', '.', '.'], ['.', '.', '.']]) \\"First\\" >>> check_winner([ ['X', '.', '.'], ['X', '.', '.'], ['X', '.', '.']]) \\"First\\" >>> check_winner([ ['X', '.', '.'], ['.', 'X', '.'], ['.', '.', 'X']]) \\"First\\" >>> check_winner([ ['X', 'O', 'X'], ['X', 'X', 'O'], ['O', 'X', 'O']]) \\"No Winner\\" >>> check_winner([ ['X', '.', '.'], ['.', 'X', '.'], ['.', '.', 'O']]) \\"No Winner\\" pass","solution":"def check_winner(grid): Check if the first player wins based on the given 3x3 grid. def is_winner(cells): return cells == ['X', 'X', 'X'] n = 3 # assuming the grid is always 3x3 for this problem # Check rows for row in grid: if is_winner(row): return \\"First\\" # Check columns for col in range(n): if is_winner([grid[row][col] for row in range(n)]): return \\"First\\" # Check diagonals if is_winner([grid[i][i] for i in range(n)]) or is_winner([grid[i][n-i-1] for i in range(n)]): return \\"First\\" return \\"No Winner\\""},{"question":"def minOperations(nums): Given an array nums of n integers where nums[i] is in the range [1, n] inclusive, you must perform operations to transform the array such that every integer in the array appears only once. These operations are: 1. Insert any missing integers into the array, 2. Remove any duplicates until each integer appears only once. Your task is to find the minimum number of operations required to achieve this transformation. Args: nums: List[int] - The input array of integers Returns: int - The minimum number of operations required Examples: >>> minOperations([4, 3, 2, 7, 8, 2, 3, 1]) 2 >>> minOperations([1, 1, 2, 2]) 2 >>> minOperations([1, 2, 3, 4]) 0 >>> minOperations([1, 1, 1, 1]) 3 >>> minOperations([1, 2, 3, 4, 5]) 0 >>> minOperations([6, 7, 8, 9, 10]) 5 >>> minOperations([1, 3, 3, 5, 5, 7, 7, 7]) 4","solution":"def minOperations(nums): n = len(nums) num_set = set(nums) complete_set = set(range(1, n + 1)) missing_nums = complete_set - num_set total_missing = len(missing_nums) total_duplicates = len(nums) - len(num_set) return max(total_missing, total_duplicates)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root: TreeNode) -> int: Given a binary tree, find the length of the longest path which comprises nodes with consecutive values in path. >>> root = TreeNode(1) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(2) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(5) >>> longest_consecutive_path(root) 3 >>> root = TreeNode(2) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(2) >>> root.right.left.left = TreeNode(1) >>> longest_consecutive_path(root) 2","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root): if not root: return 0 def dfs(node, parent_val, length): if not node: return length if node.value == parent_val + 1: length += 1 else: length = 1 left_length = dfs(node.left, node.value, length) right_length = dfs(node.right, node.value, length) return max(length, left_length, right_length) return dfs(root, root.value - 1, 0)"},{"question":"def min_breaks_needed(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculates the minimum number of breaks required for each work schedule. Parameters: T : int The number of test cases. test_cases : List[Tuple[int, List[int]]] A list of tuples where each tuple contains an integer (the number of work periods) and a list of integers (the duration of each work period in hours). Returns: List[int]: A list of integers where each integer represents the minimum number of breaks required for the corresponding test case. Examples: >>> min_breaks_needed(2, [(3, [4, 3, 2]), (2, [6, 7])]) [2, 1] >>> min_breaks_needed(1, [(1, [5])]) [0] pass","solution":"def min_breaks_needed(T, test_cases): Returns the minimum number of breaks needed for each test case :param T: int, number of test cases :param test_cases: list of tuples, each tuple contains a list of work periods in hours for that test case :return: list of int, minimum number of breaks required for each test case results = [] for case in test_cases: N, periods = case if N == 0: results.append(0) else: results.append(N - 1) return results"},{"question":"class UnionFind: def __init__(self, n): Initializes the UnionFind data structure with n elements. self.parent = list(range(n + 1)) self.rank = [0] * (n + 1) def find(self, u): Finds the representative of the set to which element u belongs. if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): Merges the sets containing elements u and v. root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def process_queries(n, queries): Processes a list of union/find queries on a set of n elements. Args: - n: The number of elements. - queries: A list of queries where each query is in the form [1 u v] or [2 u v]. Returns: - A list of strings \\"YES\\" or \\"NO\\" corresponding to the type 2 queries. >>> process_queries(5, [[1, 1, 2], [2, 1, 2], [1, 3, 4], [2, 1, 3], [1, 2, 3], [2, 1, 4]]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n + 1)) self.rank = [0] * (n + 1) def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def process_queries(n, queries): uf = UnionFind(n) results = [] for query in queries: if query[0] == 1: uf.union(query[1], query[2]) elif query[0] == 2: if uf.find(query[1]) == uf.find(query[2]): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_total_modification_cost(arr: List[int]) -> int: Finds the element which minimizes the total modification cost when all elements are set to this value. Returns the minimum total modification cost. >>> min_total_modification_cost([1, 3, 2]) 2 >>> min_total_modification_cost([4, 1, 7, 1]) 9 >>> min_total_modification_cost([10, 20, 30]) 20 >>> min_total_modification_cost([5, 5, 5, 5]) 0 >>> min_total_modification_cost([]) 0 >>> min_total_modification_cost([1000000, 1000000, 1000001]) 1 >>> min_total_modification_cost([1, 1, 1, 2, 2, 2]) 3 >>> min_total_modification_cost([42]) 0","solution":"def min_total_modification_cost(arr): Finds the element that minimizes the total modification cost to equalize array elements, and returns the minimum total modification cost. if not arr: return 0 # The optimal element to minimize the absolute difference is the median arr.sort() median = arr[len(arr) // 2] # Calculate the total modification cost total_cost = sum(abs(x - median) for x in arr) return total_cost"},{"question":"from typing import List, Tuple def closest_distance(points: List[Tuple[int, int]]) -> str: Returns the minimum distance between any two points formatted to six decimal places. >>> closest_distance([(0, 0), (3, 4), (1, 1)]) '1.414214' >>> closest_distance([(1, 1), (4, 4), (5, 1), (3, 3), (0, 0)]) '1.414214' >>> closest_distance([(0, 0), (0, 3), (4, 0), (4, 3)]) '3.000000' >>> closest_distance([(1, 1), (1, 1)]) '0.000000' >>> closest_distance([(0, 0), (1000000, 1000000)]) '1414213.562373' >>> closest_distance([(0, 0), (3, 4), (6, 8), (9, 12)]) '5.000000'","solution":"from math import sqrt def euclidean_distance(p1, p2): Returns the Euclidean distance between two points p1 and p2. Each point is a tuple of (x, y). return sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2) def closest_pair_of_points(points): Returns the minimum distance between any two points from a list of points. Each point is a tuple of (x, y). n = len(points) min_distance = float('inf') for i in range(n): for j in range(i + 1, n): distance = euclidean_distance(points[i], points[j]) if distance < min_distance: min_distance = distance return min_distance def closest_distance(points): Returns the minimum distance between any two points formatted to six decimal places. min_distance = closest_pair_of_points(points) return f\\"{min_distance:.6f}\\""},{"question":"def transform_string(s: str, k: int) -> None: Perform the transformation on the string as specified. >>> transform_string(\\"aabbbccccd\\", 3) ab bc c d >>> transform_string(\\"aaaaaaa\\", 2) a a a a >>> transform_string(\\"abcdefg\\", 2) ab cd ef g >>> transform_string(\\"abcdefghij\\", 3) abc def ghi j >>> transform_string(\\"abcdefghij\\", 1) a b c d e f g h i j","solution":"def transform_string(s: str, k: int) -> None: for i in range(0, len(s), k): substring = s[i:i+k] unique_chars = [] seen = set() for char in substring: if char not in seen: seen.add(char) unique_chars.append(char) print(\\"\\".join(unique_chars))"},{"question":"def simplify_text(s: str) -> str: Returns a new string with all sequences of multiple spaces replaced by a single space and no leading or trailing spaces. >>> simplify_text(\\"This is a test.\\") \\"This is a test.\\" >>> simplify_text(\\" Hello World! \\") \\"Hello World!\\" >>> simplify_text(\\"Python is great.\\") \\"Python is great.\\" >>> simplify_text(\\"No leading or trailing spaces.\\") \\"No leading or trailing spaces.\\"","solution":"def simplify_text(s): Returns a new string with all sequences of multiple spaces replaced by a single space and no leading or trailing spaces. cleaned_sentence = [] is_prev_char_space = False for char in s: if char.isspace(): if not is_prev_char_space: cleaned_sentence.append(' ') is_prev_char_space = True else: cleaned_sentence.append(char) is_prev_char_space = False return ''.join(cleaned_sentence).strip()"},{"question":"def calculate_final_bill(n, k, d1, d2, bills): Calculate the final bill amount for each customer after applying respective discounts. Parameters: n (int): Number of customers. k (int): Threshold amount for primary discount. d1 (int): Primary discount percentage. d2 (int): Loyalty discount percentage. bills (list of tuples): Each tuple contains bill amount (float) and loyalty membership status (int). Returns: list of floats: The final bill amount for each customer rounded to two decimal places. Examples: >>> calculate_final_bill(1, 100, 10, 0, [(120.00, 0)]) [108.00] >>> calculate_final_bill(1, 100, 0, 5, [(120.00, 1)]) [114.00] >>> calculate_final_bill(1, 100, 10, 5, [(120.00, 1)]) [102.60] >>> calculate_final_bill(1, 100, 10, 5, [(90.00, 0)]) [90.00] >>> calculate_final_bill(3, 100, 10, 5, [(120.00, 1), (90.00, 0), (150.00, 1)]) [102.60, 90.00, 128.25] >>> calculate_final_bill(1, 100, 10, 5, [(0.00, 1)]) [0.00] >>> calculate_final_bill(1, 100, 10, 5, [(100.00, 1)]) [95.00]","solution":"def calculate_final_bill(n, k, d1, d2, bills): Calculate the final bill amount for each customer after applying respective discounts. Parameters: n (int): Number of customers. k (int): Threshold amount for primary discount. d1 (int): Primary discount percentage. d2 (int): Loyalty discount percentage. bills (list of tuples): Each tuple contains bill amount (float) and loyalty membership status (int). Returns: list of floats: The final bill amount for each customer rounded to two decimal places. final_bills = [] for bill, is_loyal in bills: if bill > k: bill -= bill * (d1 / 100.0) if is_loyal: bill -= bill * (d2 / 100.0) final_bills.append(round(bill, 2)) return final_bills"},{"question":"from typing import List, Tuple def precompute_prefix_sums(arr: List[int]) -> List[int]: Precompute prefix sums of the array. Args: arr (List[int]): The input array. Returns: List[int]: The prefix sums array. # Implement the precompute_prefix_sums function here def sum_of_subarray(prefix_sums: List[int], li: int, ri: int) -> int: Calculate the sum of subarray from li to ri using prefix sums. Args: prefix_sums (List[int]): The prefix sums array. li (int): The starting index of the subarray. ri (int): The ending index of the subarray. Returns: int: The sum of the subarray. # Implement the sum_of_subarray function here def solve(n: int, arr: List[int], m: int, queries: List[Tuple[int, int]]) -> List[int]: Solve the sum of subarray queries. Args: n (int): The number of elements in the array. arr (List[int]): The array of elements. m (int): The number of queries. queries (List[Tuple[int, int]]): The list of queries. Returns: List[int]: The list of results for each query. Examples: >>> solve(5, [1, 2, 3, 4, 5], 3, [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> solve(3, [100000, -100000, 100000], 1, [(1, 3)]) [100000] # Implement the solve function here","solution":"def precompute_prefix_sums(arr): Precompute prefix sums of the array. Args: arr (List[int]): The input array. Returns: List[int]: The prefix sums array. prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] return prefix_sums def sum_of_subarray(prefix_sums, li, ri): Calculate the sum of subarray from li to ri using prefix sums. Args: prefix_sums (List[int]): The prefix sums array. li (int): The starting index of the subarray. ri (int): The ending index of the subarray. Returns: int: The sum of the subarray. return prefix_sums[ri] - prefix_sums[li - 1] def solve(n, arr, m, queries): Solve the sum of subarray queries. Args: n (int): The number of elements in the array. arr (List[int]): The array of elements. m (int): The number of queries. queries (List[Tuple[int, int]]): The list of queries. Returns: List[int]: The list of results for each query. prefix_sums = precompute_prefix_sums(arr) results = [] for li, ri in queries: results.append(sum_of_subarray(prefix_sums, li, ri)) return results"},{"question":"def total_free_time(meetings): Returns the total free time available between meetings. Args: meetings (list of tuples): A list of non-overlapping meeting intervals represented as (start, end). Returns: int: The total number of free hours between the meetings. >>> total_free_time([]) == 0 >>> total_free_time([(0, 1)]) == 0 >>> total_free_time([(1, 3), (3, 6), (6, 8)]) == 0 >>> total_free_time([(1, 3), (5, 6), (8, 10)]) == 4 >>> total_free_time([(1, 5), (6, 10)]) == 1 >>> total_free_time([(0, 2), (3, 5), (7, 8), (10, 12)]) == 5 >>> total_free_time([(0, 6), (7, 12), (13, 18), (19, 23)]) == 3","solution":"def total_free_time(meetings): Returns the total free time available between meetings. Args: meetings (list of tuples): A list of non-overlapping meeting intervals represented as (start, end). Returns: int: The total number of free hours between the meetings. # Initialize free time free_time = 0 # Sort meetings by their start time meetings.sort() # Iterate over the meetings to calculate free time for i in range(1, len(meetings)): # Calculate the gap between the end of the previous meeting and the start of the current meeting free_time += meetings[i][0] - meetings[i-1][1] return free_time"},{"question":"from typing import List def generate_anti_anagram(s: str) -> str: Generates an anti-anagram for the given string if possible. Otherwise, returns 'IMPOSSIBLE'. Args: s (str): The input string of lowercase alphabet characters. Returns: str: The anti-anagram of the input string or 'IMPOSSIBLE' if not possible. >>> generate_anti_anagram(\\"abc\\") 'bca' >>> generate_anti_anagram(\\"aa\\") 'IMPOSSIBLE' >>> generate_anti_anagram(\\"abcd\\") 'abdc' >>> generate_anti_anagram(\\"a\\") 'IMPOSSIBLE'","solution":"from random import shuffle def generate_anti_anagram(s): Generates an anti-anagram for the given string if possible. Otherwise, returns 'IMPOSSIBLE'. if len(s) == 1: return \\"IMPOSSIBLE\\" chars = list(s) length = len(chars) # Try creating a shuffled version that meets the anti-anagram criteria for _ in range(100): # Give up after 100 attempts shuffle(chars) if all(chars[i] != s[i] for i in range(length)): return ''.join(chars) return \\"IMPOSSIBLE\\""},{"question":"from typing import List, Tuple def are_all_computers_connected(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determine if all computers in the network are connected directly or indirectly. >>> are_all_computers_connected(4, 3, [(1, 2), (2, 3), (2, 4)]) == \\"YES\\" >>> are_all_computers_connected(4, 2, [(1, 2), (2, 3)]) == \\"NO\\" >>> are_all_computers_connected(1, 0, []) == \\"YES\\" pass def test_all_computers_connected_sample_input_1(): result = are_all_computers_connected(4, 3, [(1, 2), (2, 3), (2, 4)]) assert result == \\"YES\\" def test_all_computers_connected_sample_input_2(): result = are_all_computers_connected(4, 2, [(1, 2), (2, 3)]) assert result == \\"NO\\" def test_all_computers_connected_sample_input_3(): result = are_all_computers_connected(1, 0, []) assert result == \\"YES\\" def test_minimal_case_no_edges(): result = are_all_computers_connected(2, 0, []) assert result == \\"NO\\" def test_two_computers_connected(): result = are_all_computers_connected(2, 1, [(1, 2)]) assert result == \\"YES\\" def test_disconnected_large_network(): result = are_all_computers_connected(5, 2, [(1, 2), (4, 5)]) assert result == \\"NO\\" def test_fully_connected_network(): result = are_all_computers_connected(3, 3, [(1, 2), (2, 3), (3, 1)]) assert result == \\"YES\\"","solution":"def are_all_computers_connected(n, m, connections): from collections import defaultdict, deque if n == 1: return \\"YES\\" graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) visited = set() queue = deque([1]) # start BFS from the node 1 (any node would suffice) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return \\"YES\\" if len(visited) == n else \\"NO\\""},{"question":"def max_sum_rectangle(matrix: List[List[int]]) -> int: Find the sum of the elements in the maximum sum rectangular submatrix. Args: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: int: The sum of the elements in the maximum sum rectangular submatrix. Examples: >>> max_sum_rectangle([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 >>> max_sum_rectangle([ ... [-10, 4, 5, -3, 6] ... ]) 12 >>> max_sum_rectangle([ ... [-10], ... [4], ... [5], ... [-3], ... [6] ... ]) 12 >>> max_sum_rectangle([ ... [-3, -2, -1], ... [-10, -20, -30], ... [-5, -9, -6] ... ]) -1 >>> max_sum_rectangle([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) 136 >>> max_sum_rectangle([ ... [1] ... ]) 1 >>> max_sum_rectangle([ ... [-1, -2], ... [-3, -4] ... ]) -1","solution":"def max_sum_rectangle(matrix): Function to find the maximum sum rectangle in a 2D matrix. :param matrix: List[List[int]] :return: int if not matrix: return 0 def kadane(arr): Helper function to implement Kadane's algorithm for 1D array. max_sum = float('-inf') current_sum = 0 for num in arr: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for row in range(n): temp[row] += matrix[row][right] current_sum = kadane(temp) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def max_nonconsec_days(n: int, weather: List[int]) -> int: Determine the maximum number of days Peter can either walk or read without repeating the same activity on consecutive days, given the weather conditions. >>> max_nonconsec_days(5, [1, 0, 1, 0, 1]) == 5 >>> max_nonconsec_days(5, [0, 0, 0, 0, 0]) == 5 >>> max_nonconsec_days(5, [1, 1, 1, 1, 1]) == 5 >>> max_nonconsec_days(6, [1, 0, 1, 0, 1, 0]) == 6 >>> max_nonconsec_days(6, [1, 1, 0, 0, 1, 1]) == 6 >>> max_nonconsec_days(1, [0]) == 1 >>> max_nonconsec_days(1, [1]) == 1","solution":"def max_nonconsec_days(n, weather): count = 0 last_activity = None for i in range(n): if weather[i] == 1: if last_activity != 'walk': last_activity = 'walk' count += 1 else: last_activity = 'read' count += 1 else: last_activity = 'read' count += 1 return count"},{"question":"from typing import List def merge_and_remove_duplicates(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into one sorted array and removes duplicates. Parameters: arr1 (List[int]): First sorted array. arr2 (List[int]): Second sorted array. Returns: List[int]: Merged and deduplicated sorted array. >>> merge_and_remove_duplicates([1, 3, 4, 5, 7], [2, 3, 5, 6]) [1, 2, 3, 4, 5, 6, 7] >>> merge_and_remove_duplicates([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_remove_duplicates([1, 3, 4], [1, 3, 4]) [1, 3, 4] >>> merge_and_remove_duplicates([], [1, 2, 3]) [1, 2, 3] >>> merge_and_remove_duplicates([1, 2, 3], []) [1, 2, 3] >>> merge_and_remove_duplicates([], []) []","solution":"from typing import List def merge_and_remove_duplicates(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into one sorted array and removes duplicates. Parameters: arr1 (List[int]): First sorted array. arr2 (List[int]): Second sorted array. Returns: List[int]: Merged and deduplicated sorted array. merged_set = set(arr1).union(arr2) # Create a set to remove duplicates using union of two arrays return sorted(merged_set) # Return sorted list of the merged set"},{"question":"def get_formatted_increasing_sales_employees(input_data: str) -> str: Identify employees who had increasing sales through all four quarters for multiple datasets. >>> get_formatted_increasing_sales_employees(\\"3nAlice 5 6 7 8nBob 3 4 5 6nCharlie 4 5 6 7nENDn\\") \\"AlicenBobnCharlie\\" >>> get_formatted_increasing_sales_employees(\\"2nDavid 1 2 2 4nEve 4 3 2 1nENDn\\") \\"None\\" >>> get_formatted_increasing_sales_employees(\\"3nAlice 5 6 8 10nBob 3 7 7 9nCharlie 2 3 4 5nENDn2nDavid 1 2 3 4nEve 4 3 2 1nENDn\\") \\"AlicenCharlienDavid\\" >>> get_formatted_increasing_sales_employees(\\"1nZara 0 1 2 3nENDn\\") \\"Zara\\" >>> get_formatted_increasing_sales_employees(\\"1nCarl 1 2 1 4nENDn\\") \\"None\\"","solution":"def find_increasing_sales_employees(datasets): result = [] for data in datasets: employees = data.split('n') n = int(employees[0]) increasing_sales_employees = [] for i in range(1, n + 1): entry = employees[i].split() name = entry[0] sales = list(map(int, entry[1:])) if sales == sorted(sales) and len(set(sales)) == 4: increasing_sales_employees.append(name) if increasing_sales_employees: result.extend(increasing_sales_employees) else: result.append(\\"None\\") return result def get_formatted_increasing_sales_employees(input_data): datasets = input_data.strip().split('nENDn') formatted_results = find_increasing_sales_employees(datasets) return 'n'.join(formatted_results)"},{"question":"from typing import List def min_replacements_to_balance(s: str) -> int: Determine the minimum number of character replacements required to make the string balanced. A balanced string is defined as a string where each character appears the same number of times. Args: s (str): A string consisting of characters 'a', 'b', and 'c' only. Returns: int: The minimum number of replacements needed to make the string balanced. >>> min_replacements_to_balance(\\"aabb\\") 2 >>> min_replacements_to_balance(\\"abcabc\\") 0 >>> min_replacements_to_balance(\\"aaabbbccc\\") 0 pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases to determine the minimum number of replacements needed for each. Args: t (int): The number of test cases. test_cases (List[str]): The list of strings for each test case. Returns: List[int]: The list of results for each test case. >>> process_test_cases(3, [\\"aabb\\", \\"abcabc\\", \\"aaabbbccc\\"]) [2, 0, 0] >>> process_test_cases(2, [\\"abcabc\\", \\"aaabbb\\"]) [0, 2] >>> process_test_cases(1, [\\"aaaaaa\\"]) [4] pass","solution":"def min_replacements_to_balance(s): from collections import Counter # Count the frequency of each character char_count = Counter(s) # Find the desired count for a balanced string n = len(s) target_count = n // 3 # Calculate the number of replacements needed replacements = 0 for char in 'abc': if char_count[char] > target_count: replacements += char_count[char] - target_count return replacements def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_replacements_to_balance(s)) return results"},{"question":"def highest_sum_path(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Find the highest sum of values along any simple path in the graph. Parameters: n (int): Number of vertices in the graph. values (List[int]): List of integer values for each vertex. edges (List[Tuple[int, int]]): List of edges in the graph, where each edge is represented by a tuple (u, v). Returns: int: The highest sum of values along any simple path in the graph. Example: >>> highest_sum_path(6, [1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 21 >>> highest_sum_path(1, [10], []) 10","solution":"def highest_sum_path(n, values, edges): from collections import defaultdict import sys # Create the adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(node, visited): visited.add(node) max_1, max_2 = 0, 0 total = values[node - 1] for neighbor in graph[node]: if neighbor not in visited: path_sum = dfs(neighbor, visited) if path_sum > max_1: max_2 = max_1 max_1 = path_sum elif path_sum > max_2: max_2 = path_sum max_sum_path[0] = max(max_sum_path[0], max_1 + max_2 + total) return max_1 + total max_sum_path = [-sys.maxsize] visited = set() dfs(1, visited) return max_sum_path[0] def process_input(input_data): i = 0 results = [] input_lines = input_data.strip().split(\\"n\\") while i < len(input_lines): n = int(input_lines[i]) if n == 0: break i += 1 values = list(map(int, input_lines[i].split())) i += 1 edges = [] for _ in range(n - 1): u, v = map(int, input_lines[i].split()) edges.append((u, v)) i += 1 results.append(highest_sum_path(n, values, edges)) return results def main(input_data): results = process_input(input_data) for result in results: print(result)"},{"question":"def convert_currency(amount, from_currency, to_currency): Convert a given price from one currency to another. >>> convert_currency(100, \\"EUR\\", \\"JPY\\") # Output: Amount in JPY >>> convert_currency(50, \\"GBP\\", \\"INR\\") # Output: Amount in INR >>> convert_currency(75, \\"USD\\", \\"EUR\\") # Output: Amount in EUR >>> convert_currency(1000, \\"INR\\", \\"USD\\") # Output: Amount in USD >>> convert_currency(5000, \\"JPY\\", \\"GBP\\") # Output: Amount in GBP # Your code here","solution":"def convert_currency(amount, from_currency, to_currency): exchange_rates = { \\"EUR\\": 1.12, \\"GBP\\": 1.30, \\"JPY\\": 0.0091, \\"INR\\": 0.013 } reverse_rates = { \\"EUR\\": 0.89, \\"GBP\\": 0.77, \\"JPY\\": 109.89, \\"INR\\": 76.60 } # If the from_currency is USD if from_currency == \\"USD\\": amount_in_usd = amount else: amount_in_usd = amount * exchange_rates[from_currency] # If the to_currency is USD if to_currency == \\"USD\\": return amount_in_usd else: return amount_in_usd * reverse_rates[to_currency] # Example usage: print(convert_currency(100, \\"EUR\\", \\"JPY\\")) # Output: Amount in JPY"},{"question":"def can_reach_city(M, K, D): Determine if Jenny can reach the city without refueling. Parameters: M (int): Maximum fuel tank capacity in liters K (int): Fuel consumption rate in kilometers per liter D (int): Distance to the city in kilometers Returns: str: \\"Possible\\" if Jenny can reach the city, \\"Impossible\\" otherwise >>> can_reach_city(10, 5, 45) 'Possible' >>> can_reach_city(8, 6, 50) 'Impossible' pass def handle_input(num_tests, test_cases): Process multiple test cases to determine if Jenny can reach each city without refueling. Parameters: num_tests (int): Number of test cases test_cases (list of tuples): List of test cases, where each test case is a tuple (M, K, D) Returns: list of str: List of results for each test case (\\"Possible\\" or \\"Impossible\\") >>> handle_input(4, [(10, 5, 45), (8, 6, 50), (15, 10, 140), (20, 4, 75)]) ['Possible', 'Impossible', 'Possible', 'Possible'] pass","solution":"def can_reach_city(M, K, D): Determine if Jenny can reach the city without refueling. Parameters: M (int): Maximum fuel tank capacity in liters K (int): Fuel consumption rate in kilometers per liter D (int): Distance to the city in kilometers Returns: str: \\"Possible\\" if Jenny can reach the city, \\"Impossible\\" otherwise max_distance = M * K if max_distance >= D: return \\"Possible\\" else: return \\"Impossible\\" def handle_input(num_tests, test_cases): results = [] for i in range(num_tests): M, K, D = test_cases[i] results.append(can_reach_city(M, K, D)) return results"},{"question":"from typing import List def findSubArrayWithSum(arr: List[int], target_sum: int) -> bool: Returns True if there exists at least one subarray with the given sum in the array \`arr\`, otherwise returns False. Examples: >>> findSubArrayWithSum([1, 4, 20, 3, 10, 5], 33) True >>> findSubArrayWithSum([1, 4, 0, 0, 3, 10, 5], 7) True >>> findSubArrayWithSum([1, 4], 0) False pass def test_findSubArrayWithSum_case1(): arr = [1, 4, 20, 3, 10, 5] target_sum = 33 assert findSubArrayWithSum(arr, target_sum) == True def test_findSubArrayWithSum_case2(): arr = [1, 4, 0, 0, 3, 10, 5] target_sum = 7 assert findSubArrayWithSum(arr, target_sum) == True def test_findSubArrayWithSum_case3(): arr = [1, 4] target_sum = 0 assert findSubArrayWithSum(arr, target_sum) == False def test_findSubArrayWithSum_negative_case(): arr = [-3, 2, 1, 3] target_sum = 0 assert findSubArrayWithSum(arr, target_sum) == True def test_findSubArrayWithSum_large_case(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] target_sum = 15 assert findSubArrayWithSum(arr, target_sum) == True def test_findSubArrayWithSum_no_subarray(): arr = [1, 2, 3, 4, 5] target_sum = 20 assert findSubArrayWithSum(arr, target_sum) == False def test_findSubArrayWithSum_single_element(): arr = [5] target_sum = 5 assert findSubArrayWithSum(arr, target_sum) == True def test_findSubArrayWithSum_single_element_not_matching(): arr = [5] target_sum = 10 assert findSubArrayWithSum(arr, target_sum) == False","solution":"def findSubArrayWithSum(arr, target_sum): Returns True if there exists at least one subarray with the given sum in the array \`arr\`, otherwise returns False. current_sum = 0 sum_dict = {} for num in arr: current_sum += num if current_sum == target_sum: return True if current_sum - target_sum in sum_dict: return True sum_dict[current_sum] = True return False"},{"question":"def fizz_buzz_variation(arr): Given an array of integers, return a new array where: - each number n that is divisible by 3 is replaced with \\"Fizz\\", - each number n that is divisible by 5 is replaced with \\"Buzz\\", - each number n that is divisible by both 3 and 5 is replaced with \\"FizzBuzz\\", - any other number remains unchanged. >>> fizz_buzz_variation([3, 5, 15, 7, 20, 9]) ['Fizz', 'Buzz', 'FizzBuzz', 7, 'Buzz', 'Fizz'] >>> fizz_buzz_variation([1, 2, 3, 4, 5, 6]) [1, 2, 'Fizz', 4, 'Buzz', 'Fizz'] >>> fizz_buzz_variation([30, 33, 35, 37, 40]) ['FizzBuzz', 'Fizz', 'Buzz', 37, 'Buzz'] >>> fizz_buzz_variation([10, 11, 12, 13, 14, 15]) ['Buzz', 11, 'Fizz', 13, 14, 'FizzBuzz'] >>> fizz_buzz_variation([1, 2, 4, 7, 8]) [1, 2, 4, 7, 8]","solution":"def fizz_buzz_variation(arr): Given an array of integers, return a new array where: - each number n that is divisible by 3 is replaced with \\"Fizz\\", - each number n that is divisible by 5 is replaced with \\"Buzz\\", - each number n that is divisible by both 3 and 5 is replaced with \\"FizzBuzz\\", - any other number remains unchanged. result = [] for n in arr: if n % 3 == 0 and n % 5 == 0: result.append(\\"FizzBuzz\\") elif n % 3 == 0: result.append(\\"Fizz\\") elif n % 5 == 0: result.append(\\"Buzz\\") else: result.append(n) return result"},{"question":"def is_palindromic_path_exist(n: int, grid: List[str]) -> str: Determine whether there exists a path from the top-left corner of the grid to the bottom-right corner that forms a palindrome. Parameters: n (int): The size of the grid. grid (List[str]): The grid represented as a list of strings. Returns: str: \\"YES\\" if there exists a palindromic path, otherwise \\"NO\\". >>> is_palindromic_path_exist(3, [\\"aba\\", \\"bcb\\", \\"aba\\"]) \\"YES\\" >>> is_palindromic_path_exist(2, [\\"ab\\", \\"bc\\"]) \\"NO\\" >>> is_palindromic_path_exist(1, [\\"a\\"]) \\"YES\\" >>> is_palindromic_path_exist(2, [\\"aa\\", \\"aa\\"]) \\"YES\\" >>> is_palindromic_path_exist(5, [\\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\", \\"uvwxy\\"]) \\"NO\\" pass","solution":"def is_palindromic_path_exist(n, grid): Returns 'YES' if there exists a palindromic path from the top-left to the bottom-right of the grid, otherwise 'NO'. from collections import deque def is_palindrome(s): return s == s[::-1] queue = deque([(0, 0, grid[0][0], grid[0][0])]) # (x, y, forward path, backward path) while queue: x, y, fwd, bwd = queue.popleft() if x == n - 1 and y == n - 1: if is_palindrome(fwd): return \\"YES\\" if x + 1 < n: queue.append((x + 1, y, fwd + grid[x + 1][y], grid[x + 1][y] + bwd)) if y + 1 < n: queue.append((x, y + 1, fwd + grid[x][y + 1], grid[x][y + 1] + bwd)) return \\"NO\\""},{"question":"def count_unique_integers(n, q, array, queries): Return the count of unique integers in the given subarrays specified by the queries. :param n: Integer representing the number of elements in the array :param q: Integer representing the number of queries :param array: List of integers representing the array :param queries: List of tuples representing the queries (l, r) :return: List of integers representing the count of unique integers in each subarray >>> count_unique_integers(6, 3, [1, 2, 1, 3, 2, 4], [(1, 3), (2, 4), (1, 6)]) [2, 3, 4] >>> count_unique_integers(5, 2, [1, 1, 1, 1, 1], [(1, 3), (2, 5)]) [1, 1] >>> count_unique_integers(1, 1, [42], [(1, 1)]) [1] >>> count_unique_integers(4, 2, [9, 8, 7, 6], [(1, 3), (2, 4)]) [3, 3] >>> count_unique_integers(8, 3, [1, 2, 2, 3, 4, 4, 5, 5], [(1, 5), (3, 7), (1, 8)]) [4, 4, 5]","solution":"def count_unique_integers(n, q, array, queries): Return the count of unique integers in the given subarrays specified by the queries. :param n: Integer representing the number of elements in the array :param q: Integer representing the number of queries :param array: List of integers representing the array :param queries: List of tuples representing the queries (l, r) :return: List of integers representing the count of unique integers in each subarray results = [] for l, r in queries: subarray = array[l-1:r] unique_elements = set(subarray) results.append(len(unique_elements)) return results"},{"question":"def longest_contiguous_segment(n: int, dna_sequence: str, character: str) -> int: Returns the length of the longest contiguous segment of the specified character in the DNA sequence. Args: n (int): The length of the DNA sequence. dna_sequence (str): The DNA sequence. character (str): The character to analyze Returns: int: The length of the longest contiguous segment of the specified character. Examples: >>> longest_contiguous_segment(10, 'ACGTACGTAA', 'A') 2 >>> longest_contiguous_segment(12, 'GGTACCAGTCCA', 'C') 2","solution":"def longest_contiguous_segment(n, dna_sequence, character): Returns the length of the longest contiguous segment of the specified character in the DNA sequence. longest_length = 0 current_length = 0 for char in dna_sequence: if char == character: current_length += 1 if current_length > longest_length: longest_length = current_length else: current_length = 0 return longest_length"},{"question":"def min_removals_for_increasing_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the minimum number of removals to form a strictly increasing sequence Args: t: int, number of test cases test_cases: list of tuples, where each tuple contains an int (length of array) and a list of ints (the array itself) Returns: list of ints, results for each test case indicating the minimum number of elements to remove for forming a strictly increasing sequence or -1 if not possible. pass","solution":"def min_removals_for_increasing_sequence(t, test_cases): Finds the minimum number of removals to form a strictly increasing sequence :param t: int, number of test cases :param test_cases: list of tuples, where each tuple contains an int (length of array) and a list of ints (the array itself) :return: list of ints, results for each test case results = [] for n, arr in test_cases: found = False for i in range(n): potential_sequence = arr[:i] + arr[i+1:] if all(potential_sequence[j] < potential_sequence[j+1] for j in range(len(potential_sequence) - 1)): results.append(0) found = True break if not found: results.append(-1) return results"},{"question":"def min_operations_to_beautiful(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of operations required to make the array beautiful. An array is considered beautiful if for each element a[i] (1 â‰¤ i â‰¤ n), the sum of all elements to its left is less than or equal to the sum of all elements to its right. >>> min_operations_to_beautiful(2, [(5, [1, 2, 3, 4, 5]), (4, [-1, -3, -2, -4])]) [0, 2] >>> min_operations_to_beautiful(1, [(1, [10])]) [0] >>> min_operations_to_beautiful(1, [(3, [5, 5, 5])]) [0] >>> min_operations_to_beautiful(1, [(5, [5, 4, 3, 2, 1])]) [4] >>> min_operations_to_beautiful(1, [(6, [3, 1, -2, 4, -5, 7])]) [5]","solution":"def min_operations_to_beautiful(t, test_cases): results = [] for test in test_cases: n, arr = test sorted_arr = sorted(arr) operations = sum(1 for i in range(n) if arr[i] != sorted_arr[i]) results.append(operations) return results"},{"question":"from typing import List def sumDivisibleByThreeAndFive(numbers: List[int]) -> int: Determine the sum of the numbers that are divisible by both 3 and 5. >>> sumDivisibleByThreeAndFive([15, 30, 45, 20, 10, -15]) 75 >>> sumDivisibleByThreeAndFive([8, 12, 5, 7, 9]) 0","solution":"def sumDivisibleByThreeAndFive(numbers): Returns the sum of numbers that are divisible by both 3 and 5. return sum(num for num in numbers if num % 15 == 0)"},{"question":"def is_rotated_version(original, rotated): Determines if the given 'rotated' string is a rotated version of the 'original' string. Parameters: original (str): The original string. rotated (str): The string to check. Returns: bool: True if 'rotated' is a rotated version of 'original', False otherwise. pass def test_is_rotated_version_true(): assert is_rotated_version(\\"hello\\", \\"llohe\\") == True assert is_rotated_version(\\"abcdef\\", \\"defabc\\") == True assert is_rotated_version(\\"rotation\\", \\"tationro\\") == True def test_is_rotated_version_false(): assert is_rotated_version(\\"hello\\", \\"heoll\\") == False assert is_rotated_version(\\"abcdef\\", \\"abcfed\\") == False assert is_rotated_version(\\"rotation\\", \\"atationro\\") == False def test_is_rotated_version_different_lengths(): assert is_rotated_version(\\"hello\\", \\"helloo\\") == False assert is_rotated_version(\\"longerstring\\", \\"longstringer\\") == False def test_is_rotated_version_same_string(): assert is_rotated_version(\\"abc\\", \\"abc\\") == True assert is_rotated_version(\\"rotation\\", \\"rotation\\") == True def test_is_rotated_version_single_character(): assert is_rotated_version(\\"a\\", \\"a\\") == True assert is_rotated_version(\\"b\\", \\"a\\") == False","solution":"def is_rotated_version(original, rotated): Determines if the given 'rotated' string is a rotated version of the 'original' string. Parameters: original (str): The original string. rotated (str): The string to check. Returns: bool: True if 'rotated' is a rotated version of 'original', False otherwise. if len(original) != len(rotated): return False # Concatenate the original string with itself concatenated = original + original # Check if the rotated string is a substring of the concatenated string return rotated in concatenated"},{"question":"def find_missing_positive_integer(nums: str) -> int: Finds the smallest positive integer missing from the list >>> find_missing_positive_integer(\\"1 2 3\\") == 4 >>> find_missing_positive_integer(\\"-1 -2 0 1\\") == 2 >>> find_missing_positive_integer(\\"3 5 7 9\\") == 1 >>> find_missing_positive_integer(\\"1 3 4 6\\") == 2 >>> find_missing_positive_integer(\\"\\") == 1 >>> find_missing_positive_integer(\\"1000 999 50\\") == 1 >>> find_missing_positive_integer(\\"-10 -20 -30 -40\\") == 1 >>> find_missing_positive_integer(\\"1\\") == 2 >>> find_missing_positive_integer(\\"2\\") == 1","solution":"def find_missing_positive_integer(nums): Finds the smallest positive integer missing from the list nums # Convert the space-separated string into a list of integers nums = list(map(int, nums.split())) # If the list is empty, return 1 if not nums: return 1 # Create a set from the given list num_set = set(nums) # Start checking from 1 upwards for the smallest positive integer not in the set smallest_positive = 1 while smallest_positive in num_set: smallest_positive += 1 return smallest_positive"},{"question":"def checkSubarraySum(nums: List[int], k: int) -> bool: Determine if there is a continuous subarray of size at least 2 that sums up to a multiple of k. Args: nums: List[int] - List of integers. k: int - The integer to check multiples of. Returns: bool - True if such a subarray exists, False otherwise. >>> checkSubarraySum([23, 2, 4, 6, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 13) False","solution":"def checkSubarraySum(nums, k): Determine if there is a continuous subarray of size at least 2 that sums up to a multiple of k. if len(nums) < 2: return False prefix_sum_mod_k = {0: -1} # Handles the case where the subarray starts at index 0 current_sum = 0 for i, num in enumerate(nums): current_sum += num if k != 0: current_sum %= k if current_sum in prefix_sum_mod_k: if i - prefix_sum_mod_k[current_sum] > 1: return True else: prefix_sum_mod_k[current_sum] = i return False"},{"question":"def day_of_week(day): Returns the name of the day of the week corresponding to the given integer. Args: day (int): Integer representing the day of the week (1 for Monday, 2 for Tuesday, ..., 7 for Sunday). Returns: str: The name of the day of the week or \\"Invalid day\\" if the input is not in the range from 1 to 7. Examples: >>> day_of_week(1) \\"Monday\\" >>> day_of_week(5) \\"Friday\\" >>> day_of_week(7) \\"Sunday\\" >>> day_of_week(0) \\"Invalid day\\"","solution":"def day_of_week(day): Returns the name of the day of the week corresponding to the given integer. Args: day (int): Integer representing the day of the week (1 for Monday, 2 for Tuesday, ..., 7 for Sunday). Returns: str: The name of the day of the week or \\"Invalid day\\" if the input is not in the range from 1 to 7. days = { 1: \\"Monday\\", 2: \\"Tuesday\\", 3: \\"Wednesday\\", 4: \\"Thursday\\", 5: \\"Friday\\", 6: \\"Saturday\\", 7: \\"Sunday\\" } return days.get(day, \\"Invalid day\\")"},{"question":"def are_shifting_strings(a: str, b: str) -> bool: Determines if two strings are shifting strings of each other. >>> are_shifting_strings(\\"abc\\", \\"bca\\") True >>> are_shifting_strings(\\"aabbcc\\", \\"bbccaa\\") True >>> are_shifting_strings(\\"abc\\", \\"def\\") False >>> are_shifting_strings(\\"abc\\", \\"abcd\\") False def shifting_strings(t: int, cases: list[tuple[str, str]]) -> list[str]: Determines the result for multiple test cases. >>> shifting_strings(3, [(\\"abc\\", \\"bca\\"), (\\"aabbcc\\", \\"bbccaa\\"), (\\"abc\\", \\"def\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> shifting_strings(1, [(\\"aabbcc\\", \\"ccbbaa\\")]) [\\"YES\\"] >>> shifting_strings(1, [(\\"abc\\", \\"xyz\\")]) [\\"NO\\"]","solution":"def are_shifting_strings(a, b): Determines if two strings are shifting strings of each other. Parameters: a (str): The first string. b (str): The second string. Returns: bool: True if the strings are shifting strings of each other, otherwise False. # If the lengths are not the same, they cannot be shifting strings if len(a) != len(b): return False # Check if both strings have the same character counts from collections import Counter return Counter(a) == Counter(b) def shifting_strings(t, cases): Determines the result for multiple test cases. Parameters: t (int): Number of test cases. cases (list of tuples): Each tuple contains two strings a and b. Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. results = [] for a, b in cases: if are_shifting_strings(a, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_difference(n: int, values: List[int]) -> int: John is an avid collector of antique coins. He has a collection of n coins, each with a known value. John wants to split his coins into two groups such that the absolute difference of the total values of the two groups is minimized. This function returns the minimum possible absolute difference between the sum of the values of the two groups. Args: n (int): the number of coins in John's collection values (List[int]): the values of John's coins Returns: int: the minimum possible absolute difference between the sum of the values of the two groups Example: >>> min_difference(4, [1, 2, 3, 4]) 0 >>> min_difference(3, [2, 2, 3]) 1","solution":"def min_difference(n, values): Returns the minimum possible absolute difference between the sum of the values of the two groups. total_sum = sum(values) target = total_sum // 2 dp = [0] * (target + 1) for value in values: for i in range(target, value - 1, -1): dp[i] = max(dp[i], dp[i - value] + value) best_split_sum = dp[target] return abs((total_sum - best_split_sum) - best_split_sum)"},{"question":"from typing import List def topThreeStudents(file_path: str) -> List[str]: Determine the average score for each student and identify the top three students with the highest average scores. The function accepts a file path as an argument and returns a list containing the names of the top three students sorted by their average scores in descending order. If there are fewer than three students, return the names of all students sorted by their average scores. In case of a tie, sort the names alphabetically. >>> topThreeStudents('students.txt') ['Daisy', 'Alice', 'Charlie'] >>> topThreeStudents('test_students.txt') ['Alice', 'Bob', 'Charlie'] pass from solution import topThreeStudents def create_test_file(contents): with open('test_students.txt', 'w') as file: file.write(contents) def test_top_three_students_with_tie(): contents = Alice,88 Bob,72 Alice,95 Charlie,85 Bob,78 Charlie,90 Daisy,93 create_test_file(contents) expected = ['Daisy', 'Alice', 'Charlie'] assert topThreeStudents('test_students.txt') == expected def test_top_three_students_without_tie(): contents = Alice,100 Bob,90 Charlie,85 create_test_file(contents) expected = ['Alice', 'Bob', 'Charlie'] assert topThreeStudents('test_students.txt') == expected def test_top_three_students_fewer_than_three_students(): contents = Alice,100 Bob,90 create_test_file(contents) expected = ['Alice', 'Bob'] assert topThreeStudents('test_students.txt') == expected def test_top_three_students_single_student(): contents = Alice,100 create_test_file(contents) expected = ['Alice'] assert topThreeStudents('test_students.txt') == expected def test_top_three_students_with_same_scores(): contents = Alice,100 Bob,100 Charlie,100 Daisy,99 create_test_file(contents) expected = ['Alice', 'Bob', 'Charlie'] assert topThreeStudents('test_students.txt') == expected","solution":"def topThreeStudents(file_path: str): from collections import defaultdict student_scores = defaultdict(list) with open(file_path, 'r') as file: for line in file: name, score = line.strip().split(',') score = int(score) student_scores[name].append(score) average_scores = {name: sum(scores)/len(scores) for name, scores in student_scores.items()} sorted_students = sorted(average_scores.keys(), key=lambda x: (-average_scores[x], x)) return sorted_students[:3]"},{"question":"def capitalize_words(s: str) -> str: Capitalizes the first letter of each word in the document. Words are separated by punctuation marks. >>> capitalize_words(\\"hello,world!this.is?a:test;\\") \\"Hello,World!This.Is?A:Test;\\" >>> capitalize_words(\\"python,coding;is.fun\\") \\"Python,Coding;Is.Fun\\"","solution":"def capitalize_words(s): Capitalizes the first letter of each word in the document. Words are separated by punctuation marks. result = [] word = [] for char in s: if char.isalpha(): word.append(char) else: if word: result.append(''.join(word).capitalize()) word = [] result.append(char) if word: # Add last word if any result.append(''.join(word).capitalize()) return ''.join(result)"},{"question":"def generate_words(input_cases: list) -> list: For each string in input_cases, generate all possible valid words by replacing the wildcard character '*' with any lowercase letter from 'a' to 'z'. The words should be distinct and sorted lexicographically. Args: input_cases (list): List of input strings containing the wildcard character. Returns: result (list): List of lists, each containing sorted words for the corresponding input string. >>> generate_words([\\"a*c\\"]) [[\\"aac\\", \\"abc\\", \\"acc\\", \\"adc\\", \\"aec\\", \\"afc\\", \\"agc\\", \\"ahc\\", \\"aic\\", \\"ajc\\", \\"akc\\", \\"alc\\", \\"amc\\", \\"anc\\", \\"aoc\\", \\"apc\\", \\"aqc\\", \\"arc\\", \\"asc\\", \\"atc\\", \\"auc\\", \\"avc\\", \\"awc\\", \\"axc\\", \\"ayc\\", \\"azc\\"]] >>> generate_words([\\"*b\\"]) [[\\"ab\\", \\"bb\\", \\"cb\\", \\"db\\", \\"eb\\", \\"fb\\", \\"gb\\", \\"hb\\", \\"ib\\", \\"jb\\", \\"kb\\", \\"lb\\", \\"mb\\", \\"nb\\", \\"ob\\", \\"pb\\", \\"qb\\", \\"rb\\", \\"sb\\", \\"tb\\", \\"ub\\", \\"vb\\", \\"wb\\", \\"xb\\", \\"yb\\", \\"zb\\"]]","solution":"def generate_words(input_cases): For each string in input_cases, generate all possible words by replacing the wildcard character '*' with any lowercase letter from 'a' to 'z'. Args: input_cases (list): List of input strings containing the wildcard character. Returns: result (list): List of lists, each containing sorted words for the corresponding input string. result = [] for s in input_cases: words = [] for ch in 'abcdefghijklmnopqrstuvwxyz': words.append(s.replace('*', ch)) words.sort() result.append(words) return result"},{"question":"def pig_latin(sentence: str) -> str: Transforms a given sentence into Pig Latin. Each word is transformed such that the first character of the word is moved to the end followed by the characters 'ay'. Punctuation should be preserved in place. :param sentence: A string containing words and punctuation. :return: A new string with each word transformed with Pig Latin rules. >>> pig_latin(\\"hello world!\\") 'ellohay orldway!' >>> pig_latin(\\"Pig latin is cool\\") 'igPay atinlay siay oolcay' from solution import pig_latin def test_pig_latin_simple(): assert pig_latin(\\"hello\\") == \\"ellohay\\" assert pig_latin(\\"world\\") == \\"orldway\\" def test_pig_latin_sentence(): assert pig_latin(\\"hello world\\") == \\"ellohay orldway\\" assert pig_latin(\\"Pig latin is cool\\") == \\"igPay atinlay siay oolcay\\" def test_pig_latin_with_punctuation(): assert pig_latin(\\"hello world!\\") == \\"ellohay orldway!\\" assert pig_latin(\\"Hi, how are you?\\") == \\"iHay, owhay reaay ouyay?\\" def test_pig_latin_with_multiple_spaces(): assert pig_latin(\\"hello world\\") == \\"ellohay orldway\\" assert pig_latin(\\"this is a test\\") == \\"histay siay aay esttay\\" def test_pig_latin_with_only_punctuation(): assert pig_latin(\\"!!!\\") == \\"!!!\\" assert pig_latin(\\"?!\\") == \\"?!\\" def test_edge_cases(): assert pig_latin(\\"a\\") == \\"aay\\" assert pig_latin(\\"I\\") == \\"Iay\\" assert pig_latin(\\"e\\") == \\"eay\\"","solution":"def pig_latin(sentence): Transforms a given sentence into Pig Latin. :param sentence: A string containing words and punctuation :return: A new string with each word transformed with Pig Latin rules. result = [] words = sentence.split(' ') for word in words: if word.isalpha(): result.append(word[1:] + word[0] + 'ay') else: # Split the word and punctuation punctuations = ''.join([char for char in word if not char.isalpha()]) clean_word = ''.join([char for char in word if char.isalpha()]) if clean_word: new_word = clean_word[1:] + clean_word[0] + 'ay' else: new_word = '' result.append(new_word + punctuations) return ' '.join(result)"},{"question":"def translateToMorse(sentence: str) -> str: Converts a given sentence into Morse code. >>> translateToMorse(\\"HELLO WORLD\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" >>> translateToMorse(\\"hello world\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" >>> translateToMorse(\\"HeLLo WoRLd\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" >>> translateToMorse(\\"HELLO 123\\") \\".... . .-.. .-.. --- .---- ..--- ...--\\" >>> translateToMorse(\\"\\") \\"\\" >>> translateToMorse(\\"HELLO, WORLD!\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" >>> translateToMorse(\\"E\\") \\".\\" >>> translateToMorse(\\"T\\") \\"-\\" >>> translateToMorse(\\"HELLO WORLD\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\"","solution":"def translateToMorse(sentence: str) -> str: MORSE_CODE_DICT = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', } words = sentence.upper().split() morse_words = [] for word in words: morse_chars = [MORSE_CODE_DICT[char] for char in word if char in MORSE_CODE_DICT] morse_words.append(' '.join(morse_chars)) return ' '.join(morse_words)"},{"question":"def matrix_threshold_sum(matrix, threshold): Calculates the sum of all integers in the matrix that are greater than the specified threshold value. Args: matrix: A list of lists where each inner list represents a row of integers. threshold: An integer representing the threshold value. Returns: An integer that is the sum of all the elements in the matrix that are greater than the given threshold. Example: >>> matrix_threshold_sum([ >>> [3, 5, 7], >>> [1, 6, 8], >>> [4, 9, 2] >>> ], 5) 30 >>> matrix_threshold_sum([ >>> [10, 20, 30], >>> [40, 50, 60], >>> [70, 80, 90] >>> ], 25) 420 >>> matrix_threshold_sum([ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ], 7) 17","solution":"def matrix_threshold_sum(matrix, threshold): Returns the sum of matrix elements that are greater than the threshold. Args: matrix -- list of lists where each inner list represents a row of integers threshold -- int, the threshold value Returns: int, the sum of elements greater than the threshold total_sum = 0 for row in matrix: for element in row: if element > threshold: total_sum += element return total_sum"},{"question":"def evaluate(expression: str) -> int: Evaluates a string containing an arithmetic expression with numbers and +, - operators. Processing the expression from left to right, ignoring operator precedence. Parameters: expression (str): The arithmetic expression as a string. Returns: int: The result of evaluating the expression. >>> evaluate(\\"3+2-5\\") 0 >>> evaluate(\\"10-4+7\\") 13 from evaluate import evaluate def test_evaluate_simple(): assert evaluate(\\"3+2-5\\") == 0 assert evaluate(\\"10-4+7\\") == 13 def test_evaluate_with_single_number(): assert evaluate(\\"8\\") == 8 def test_evaluate_with_simple_operations(): assert evaluate(\\"4+5\\") == 9 assert evaluate(\\"20-3\\") == 17 def test_evaluate_multiple_operations(): assert evaluate(\\"1+2+3+4+5\\") == 15 assert evaluate(\\"9-1-2-3\\") == 3 assert evaluate(\\"15+10-5+8-2\\") == 26 def test_evaluate_with_leading_zero(): assert evaluate(\\"0+0-0\\") == 0 assert evaluate(\\"0+5-3\\") == 2 def test_evaluate_edge_cases(): assert evaluate(\\"0\\") == 0 assert evaluate(\\"100\\") == 100 assert evaluate(\\"100-100\\") == 0","solution":"def evaluate(expression): Evaluates a string containing an arithmetic expression with numbers and +, - operators. Processing the expression from left to right, ignoring operator precedence. Parameters: expression (str): The arithmetic expression as a string. Returns: int: The result of evaluating the expression. result = 0 current_number = 0 current_operator = '+' # Start with a default '+' to handle the first number for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) else: if current_operator == '+': result += current_number elif current_operator == '-': result -= current_number current_operator = char current_number = 0 # Apply the last pending operation if current_operator == '+': result += current_number elif current_operator == '-': result -= current_number return result"},{"question":"def move_zeros(nums): Moves all zeros to the end of the list while maintaining the order of non-zero elements. Modifies the list in-place. :param nums: List of integers","solution":"def move_zeros(nums): Moves all zeros to the end of the list while maintaining the order of non-zero elements. Modifies the list in-place. :param nums: List of integers last_non_zero_found_at = 0 for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at], nums[i] = nums[i], nums[last_non_zero_found_at] last_non_zero_found_at += 1"},{"question":"def isValidCode(code: str) -> bool: Determine if the given code is valid based on the criteria: - It contains exactly two '6's. - There is at least one digit between the two '6's. - It does not contain any '7's. >>> isValidCode(\\"1234569856\\") True >>> isValidCode(\\"1661\\") False >>> isValidCode(\\"2617616\\") False","solution":"def isValidCode(code: str) -> bool: Determine if the given code is valid based on the criteria: 1. It contains exactly two '6's. 2. There is at least one digit between the two '6's. 3. It does not contain any '7's. Parameters: - code: A string of digits (0-9) Returns: - True if the code is valid, otherwise False if '7' in code: return False # Find positions of '6' positions_of_6 = [i for i, ch in enumerate(code) if ch == '6'] # Check there are exactly two '6's and at least one digit between them if len(positions_of_6) == 2 and positions_of_6[1] - positions_of_6[0] > 1: return True return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Examples: >>> maxDepth(None) 0 >>> t1 = TreeNode(1) >>> maxDepth(t1) 1 >>> t1 = TreeNode(1) >>> t2 = TreeNode(2) >>> t3 = TreeNode(3) >>> t4 = TreeNode(4) >>> t5 = TreeNode(5) >>> t1.left = t2 >>> t1.right = t3 >>> t2.left = t4 >>> t2.right = t5 >>> maxDepth(t1) 3 >>> t1 = TreeNode(1) >>> t2 = TreeNode(2) >>> t3 = TreeNode(3) >>> t4 = TreeNode(4) >>> t1.left = t2 >>> t2.left = t3 >>> t3.left = t4 >>> maxDepth(t1) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"from typing import List def is_balanced(sequence: str) -> str: Check whether a given sequence of brackets is balanced. >>> is_balanced(\\"()\\") 'YES' >>> is_balanced(\\"([{}])\\") 'YES' >>> is_balanced(\\"{[()]}\\") 'YES' >>> is_balanced(\\"([)]\\") 'NO' >>> is_balanced(\\"][\\") 'NO' pass def check_brackets(n: int, sequences: List[str]) -> List[str]: Check multiple sequences of brackets and determine if each is balanced. >>> check_brackets(5, [\\"()\\", \\"([{}])\\", \\"{[()]}\\", \\"([)]\\", \\"][\\"]) ['YES', 'YES', 'YES', 'NO', 'NO'] pass","solution":"def is_balanced(sequence): stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in sequence: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or stack.pop() != matching_bracket[char]: return \\"NO\\" return \\"YES\\" if stack == [] else \\"NO\\" def check_brackets(n, sequences): results = [] for sequence in sequences: results.append(is_balanced(sequence)) return results"},{"question":"def group_files_by_type(files): Groups files by their extensions and sorts each group lexicographically, ignoring case. Args: files (list of str): List of file names with extensions. Returns: dict: Dictionary where keys are file types and values are sorted lists of file names. Example: >>> files = [\\"notes.txt\\", \\"photo1.JPG\\", \\"photo2.jpg\\", \\"document.PDF\\", \\"summary.pdf\\", \\"archive.zip\\"] >>> group_files_by_type(files) { 'txt': ['notes.txt'], 'jpg': ['photo1.JPG', 'photo2.jpg'], 'pdf': ['document.PDF', 'summary.pdf'], 'zip': ['archive.zip'] }","solution":"def group_files_by_type(files): Groups files by their extensions and sorts each group lexicographically. Args: files (list of str): List of file names with extensions. Returns: dict: Dictionary where keys are file types and values are sorted lists of file names. from collections import defaultdict file_dict = defaultdict(list) for file in files: ext = file.split('.')[-1].lower() file_dict[ext].append(file) for ext in file_dict: file_dict[ext] = sorted(file_dict[ext], key=lambda x: x.lower()) return dict(file_dict)"},{"question":"def min_partition_sum(nums): Given an integer array nums of positive integers, return the minimum sum of partitioning the array into non-overlapping subarrays such that each subarray consists of consecutive elements and has strictly increasing values. The sum of the subarray is the sum of its elements. Example 1: >>> min_partition_sum([4, 2, 3, 6, 1, 7, 8]) 21 Example 2: >>> min_partition_sum([1, 3, 5, 8, 6, 7, 9]) 18 pass","solution":"def min_partition_sum(nums): Returns the minimum sum of partitioning the array nums into non-overlapping subarrays such that each subarray consists of consecutive elements and has strictly increasing values. n = len(nums) if n == 0: return 0 min_sum = 0 i = 0 while i < n: current_sum = nums[i] i += 1 while i < n and nums[i] > nums[i-1]: current_sum += nums[i] i += 1 min_sum += current_sum return min_sum"},{"question":"class PrimeScheduler: A class to manage the PrimeScheduler software by handling meeting scheduling, cancellation, and querying. Methods: - add_meeting(start: int, end: int): Schedules a new meeting. - cancel_meeting(start: int, end: int): Cancels an existing meeting. - query_meetings(time: int): Queries the number of ongoing meetings at a specified time. def __init__(self): self.meetings = [] def add_meeting(self, start: int, end: int): Schedules a new meeting starting at 'start' and ending at 'end'. def cancel_meeting(self, start: int, end: int): Cancels an existing meeting that matches the 'start' and 'end' times exactly. def query_meetings(self, time: int) -> int: Returns the number of meetings that are ongoing at the given 'time'. count = 0 for start, end in self.meetings: if start <= time < end: count += 1 return count from solution import PrimeScheduler def test_prime_scheduler(): scheduler = PrimeScheduler() # Initial meetings scheduler.add_meeting(900, 1030) scheduler.add_meeting(1100, 1200) scheduler.add_meeting(1500, 1600) # Query at 930 assert scheduler.query_meetings(930) == 1 # Add a new meeting scheduler.add_meeting(1400, 1500) # Query at 1430 assert scheduler.query_meetings(1430) == 1 # Cancel a meeting scheduler.cancel_meeting(1100, 1200) # Query at 930 again assert scheduler.query_meetings(930) == 1 # Query at 1500 assert scheduler.query_meetings(1500) == 1 # Query at 1100 (after cancellation) assert scheduler.query_meetings(1100) == 0","solution":"class PrimeScheduler: def __init__(self): self.meetings = [] def add_meeting(self, start, end): self.meetings.append((start, end)) def cancel_meeting(self, start, end): if (start, end) in self.meetings: self.meetings.remove((start, end)) def query_meetings(self, time): count = 0 for start, end in self.meetings: if start <= time < end: count += 1 return count"},{"question":"from typing import List, Tuple def can_complete_courses(n: int, m: int, prerequisites: List[Tuple[int, int]]) -> str: Determine if it is possible to complete all courses given the prerequisites. Args: n (int): The number of courses. m (int): The number of prerequisite pairs. prerequisites (List[Tuple[int, int]]): List of pairs where each pair (a, b) indicates course 'a' is a prerequisite for course 'b'. Returns: str: \\"Possible\\" if it is feasible to complete all courses, otherwise \\"Impossible\\". >>> can_complete_courses(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"Possible\\" >>> can_complete_courses(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) == \\"Impossible\\"","solution":"def can_complete_courses(n, m, prerequisites): from collections import defaultdict, deque # Create an adjacency list and in-degree count adj_list = defaultdict(list) in_degree = {i: 0 for i in range(1, n+1)} for a, b in prerequisites: adj_list[a].append(b) in_degree[b] += 1 # Queue to perform topological sort using courses with no prerequisites queue = deque([node for node in in_degree if in_degree[node] == 0]) visited = 0 while queue: course = queue.popleft() visited += 1 for neighbor in adj_list[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if visited == n: return \\"Possible\\" else: return \\"Impossible\\""},{"question":"def longestNonDecreasingSublist(performance: List[int]) -> int: Returns the length of the longest contiguous non-decreasing sublist from the input list. >>> longestNonDecreasingSublist([5, 3, 4, 8, 6, 7, 7, 8]) 4 >>> longestNonDecreasingSublist([1, 2, 2, 3, 4]) 5 >>> longestNonDecreasingSublist([10, 8, 7, 5, 4]) 1 pass","solution":"def longestNonDecreasingSublist(performance): Returns the length of the longest contiguous non-decreasing sublist from the input list. if not performance: return 0 max_length = 1 current_length = 1 for i in range(1, len(performance)): if performance[i] >= performance[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def sumMiddle(B, n): Finds and returns the sum of the middle two elements of the array B of size n. Parameters: B (list): The input array. n (int): The size of the array. Returns: int: The sum of the middle two elements. Examples: >>> sumMiddle([1, 2, 3, 4, 5, 6], 6) 7 >>> sumMiddle([3, 1, 7, 5], 4) 8","solution":"def sumMiddle(B, n): Finds and returns the sum of the middle two elements of the array B of size n. Parameters: B (list): The input array. n (int): The size of the array. Returns: int: The sum of the middle two elements. # Indices of the middle two elements mid1 = n // 2 - 1 mid2 = n // 2 return B[mid1] + B[mid2]"},{"question":"def distinct_elements_in_subarray(n: int, q: int, A: List[int], queries: List[List[int]]) -> List[int]: Process the given queries and return the results for type 1 queries. Args: n : int : Number of elements in the array q : int : Number of queries A : List[int] : The elements of the array queries : List[List[int]] : The list of queries. Each query is a list where the first element is the query type, followed by the required parameters. Returns: List[int] : List of results for each type 1 query. >>> distinct_elements_in_subarray(6, 5, [1, 1, 2, 3, 4, 2], [[1, 1, 3], [1, 2, 4], [2, 3, 5], [1, 1, 3], [1, 3, 6]]) [2, 3, 2, 4] >>> distinct_elements_in_subarray(5, 3, [1, 2, 3, 4, 5], [[1, 1, 5], [2, 2, 3], [1, 1, 5]]) [5, 4]","solution":"def distinct_elements_in_subarray(n, q, A, queries): result = [] for query in queries: if query[0] == 1: l, r = query[1] - 1, query[2] subarray = A[l:r] distinct_count = len(set(subarray)) result.append(distinct_count) elif query[0] == 2: l, x = query[1] - 1, query[2] A[l] = x return result # Example usage: n = 6 q = 5 A = [1, 1, 2, 3, 4, 2] queries = [ [1, 1, 3], [1, 2, 4], [2, 3, 5], [1, 1, 3], [1, 3, 6] ] print(distinct_elements_in_subarray(n, q, A, queries))"},{"question":"def count_even_sum_pairs(N, A): Returns the number of pairs (i, j) where 1 <= i < j <= N and the sum of A[i] and A[j] is even. >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs(4, [2, 4, 6, 8]) 6 >>> count_even_sum_pairs(4, [1, 3, 5, 7]) 6 >>> count_even_sum_pairs(4, [1, 2, 3, 4]) 2 >>> count_even_sum_pairs(1, [1]) 0 >>> count_even_sum_pairs(2, [2, 4]) 1 >>> count_even_sum_pairs(2, [1, 3]) 1 >>> count_even_sum_pairs(2, [1, 2]) 0","solution":"def count_even_sum_pairs(N, A): Returns the number of pairs (i, j) where 1 <= i < j <= N and the sum of A[i] and A[j] is even. odd_count = 0 even_count = 0 for number in A: if number % 2 == 0: even_count += 1 else: odd_count += 1 # Pairs of evens even_pairs = even_count * (even_count - 1) // 2 # Pairs of odds odd_pairs = odd_count * (odd_count - 1) // 2 return even_pairs + odd_pairs"},{"question":"def sum_two_largest_distinct(lst: List[int]) -> int: Given a list of integers, this function returns the sum of the two largest distinct integers. If there are fewer than two distinct integers, it returns the largest integer or -1 if the list is empty. >>> sum_two_largest_distinct([4, 1, 7, 7, 3, 3, 5]) 12 >>> sum_two_largest_distinct([5, 5, 5, 5]) 5 >>> sum_two_largest_distinct([]) -1 >>> sum_two_largest_distinct([1, 2]) 3 >>> sum_two_largest_distinct([3, 4, 1, 6, 5]) 11 >>> sum_two_largest_distinct([10**6, 10**5, 1, -10**6]) 1100000 >>> sum_two_largest_distinct([-3, -1, -2, -4]) -3 >>> sum_two_largest_distinct([-3, 1, 2, -2]) 3 >>> sum_two_largest_distinct([9]) 9","solution":"def sum_two_largest_distinct(lst): This function returns the sum of the two largest distinct integers in the list. If there are fewer than two distinct integers, it returns the largest integer or -1 if the list is empty. if not lst: return -1 distinct_numbers = list(set(lst)) if len(distinct_numbers) == 1: return distinct_numbers[0] distinct_numbers.sort(reverse=True) return distinct_numbers[0] + distinct_numbers[1]"},{"question":"def find_single_number(arr): Finds the integer that appears only once in the list where every other integer appears exactly twice. Args: arr (list of int): The list of integers. Returns: int: The integer that appears only once. Examples: >>> find_single_number([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_single_number([7, 9, 5, 7, 5, 3, 9, 6, 3]) 6 >>> find_single_number([10, 10, 20, 30, 20, 30, 40]) 40 >>> find_single_number([-1, -1, -2, -3, -2, -3, -4]) -4 >>> find_single_number([-1, 1, -1, 2, 2]) 1 >>> find_single_number([0, 1, 0]) 1 >>> find_single_number([42]) 42 # Your code goes here","solution":"def find_single_number(arr): Finds the integer that appears only once in the list where every other integer appears exactly twice. Args: arr (list of int): The list of integers. Returns: int: The integer that appears only once. # Using XOR to find the single occurrence number result = 0 for number in arr: result ^= number return result"},{"question":"from typing import List, Tuple def get_due_tasks(tasks: List[Tuple[int, str]], current_date: str, D: int) -> List[int]: Returns a sorted list of task IDs due within the next D days from current_date. Args: tasks (list of tuples): list of tasks where each task is represented as (task_id, due_date). current_date (str): the current date in the format \\"YYYY-MM-DD\\". D (int): the number of days within which tasks are due. Returns: list: sorted list of task IDs. >>> get_due_tasks([(1, \\"2023-10-01\\"), (2, \\"2023-10-05\\"), (3, \\"2023-10-10\\")], \\"2023-10-01\\", 5) [1, 2] >>> get_due_tasks([(1, \\"2023-10-01\\"), (2, \\"2023-10-05\\"), (3, \\"2023-10-10\\"), (4, \\"2023-10-04\\")], \\"2023-10-02\\", 2) [4]","solution":"from datetime import datetime, timedelta def get_due_tasks(tasks, current_date, D): Returns a sorted list of task IDs due within the next D days from current_date. Args: tasks (list of tuples): list of tasks where each task is represented as (task_id, due_date). current_date (str): the current date in the format \\"YYYY-MM-DD\\". D (int): the number of days within which tasks are due. Returns: list: sorted list of task IDs. current_date_obj = datetime.strptime(current_date, \\"%Y-%m-%d\\") end_date_obj = current_date_obj + timedelta(days=D) due_tasks = [ task_id for task_id, due_date in tasks if current_date_obj <= datetime.strptime(due_date, \\"%Y-%m-%d\\") <= end_date_obj ] return sorted(due_tasks)"},{"question":"from collections import Counter import heapq def rearrange_string(s: str) -> str: Given a string S consisting of lowercase alphabets, determine if it is possible to rearrange the characters of the string such that every adjacent pair of characters are distinct. If it is possible, return a possible rearrangement of the string. If it is not possible, return 'Not possible'. >>> rearrange_string(\\"aaabb\\") 'ababa' >>> rearrange_string(\\"aaab\\") 'Not possible' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"ab\\") 'ab' >>> rearrange_string(\\"aaa\\") 'Not possible' >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaabbcc\\") 'abcabca'","solution":"import heapq from collections import Counter def rearrange_string(s): # Count frequency of each character char_count = Counter(s) # If any character occurs more than (n+1)//2 times, it's not possible to rearrange max_freq = max(char_count.values()) if max_freq > (len(s) + 1) // 2: return \\"Not possible\\" # Max heap to store characters by frequency max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If previously used character's frequency is still more than 0, push it back to heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update previous character and frequency prev_char = char prev_freq = freq + 1 # Decrease frequency since we used one occurrence return ''.join(result)"},{"question":"from typing import List def sort_messages(messages: List[str], id_length: int) -> List[str]: Sorts messages primarily based on their identifiers in ascending order. Args: messages (List[str]): List of messages with identifiers. id_length (int): Fixed number of identifier digits after the '#' symbol. Returns: List[str]: Sorted list of messages by identifier. pass def test_sort_messages_basic(): messages = [\\"#123Hello\\", \\"#456World\\", \\"#123Again\\", \\"#789Compete\\"] id_length = 3 assert sort_messages(messages, id_length) == ['#123Hello', '#123Again', '#456World', '#789Compete'] def test_sort_messages_single_message(): messages = [\\"#001Only\\"] id_length = 3 assert sort_messages(messages, id_length) == [\\"#001Only\\"] def test_sort_messages_with_ties(): messages = [\\"#111Alpha\\", \\"#222Beta\\", \\"#111Gamma\\", \\"#333Delta\\"] id_length = 3 assert sort_messages(messages, id_length) == [\\"#111Alpha\\", \\"#111Gamma\\", \\"#222Beta\\", \\"#333Delta\\"] def test_sort_messages_large_identifiers(): messages = [\\"#900Hello\\", \\"#123World\\", \\"#456Again\\", \\"#123Fox\\"] id_length = 3 assert sort_messages(messages, id_length) == ['#123World', '#123Fox', '#456Again', '#900Hello'] def test_sort_messages_varied_message_length(): messages = [\\"#987Short\\", \\"#003A much longer message\\", \\"#454Middle\\", \\"#003Another long message\\"] id_length = 3 assert sort_messages(messages, id_length) == ['#003A much longer message', '#003Another long message', '#454Middle', '#987Short']","solution":"from typing import List def sort_messages(messages: List[str], id_length: int) -> List[str]: Sorts messages primarily based on their identifiers in ascending order. Args: messages (List[str]): List of messages with identifiers. id_length (int): Fixed number of identifier digits after the '#' symbol. Returns: List[str]: Sorted list of messages by identifier. def extract_id(msg: str) -> int: # Extract numerical identifier after the '#' symbol return int(msg[1:1 + id_length]) # Sort messages based on the extracted identifier return sorted(messages, key=extract_id)"},{"question":"def can_sort_by_swaps(n: int, a: List[int]) -> str: Determine if it is possible to sort the array in non-decreasing order by performing swaps on adjacent elements whose sum is even. >>> can_sort_by_swaps(5, [3, 5, 2, 8, 6]) \\"YES\\" >>> can_sort_by_swaps(4, [1, 3, 5, 7]) \\"NO\\"","solution":"def can_sort_by_swaps(n, a): Determine if the array can be sorted in non-decreasing order by performing swaps on adjacent elements whose sum is even. # First, try to separate even and odd numbers even_count = 0 odd_count = 0 # Count the number of even and odd elements for num in a: if num % 2 == 0: even_count += 1 else: odd_count += 1 # If there are no even or no odd numbers, then the array cannot be sorted # Because all numbers would be the same parity and never able to swap to different positions. if even_count == 0 or odd_count == 0: return \\"NO\\" # Otherwise, it is possible to sort the array if we have both even and odd numbers return \\"YES\\""},{"question":"def find_max_subarray_closest_to_threshold(n: int, t: int, execution_times: List[int]) -> int: Find the starting index of the maximum-length subarray such that the sum of the subarray's elements is closest to t without exceeding it. Args: n (int): The number of log entries. t (int): The threshold. execution_times (List[int]): List of execution times in milliseconds. Returns: int: The starting index (0-based) of the maximum-length subarray. Examples: >>> find_max_subarray_closest_to_threshold(5, 15, [1, 2, 3, 4, 5]) 0 >>> find_max_subarray_closest_to_threshold(4, 8, [3, 1, 4, 2]) 0 >>> find_max_subarray_closest_to_threshold(6, 10, [6, 1, 2, 7, 3, 5]) 1 from solution import find_max_subarray_closest_to_threshold def test_example1(): assert find_max_subarray_closest_to_threshold(5, 15, [1, 2, 3, 4, 5]) == 0 def test_example2(): assert find_max_subarray_closest_to_threshold(4, 8, [3, 1, 4, 2]) == 0 def test_example3(): assert find_max_subarray_closest_to_threshold(6, 10, [6, 1, 2, 7, 3, 5]) == 1 def test_single_element(): assert find_max_subarray_closest_to_threshold(1, 5, [3]) == 0 def test_no_valid_subarray(): assert find_max_subarray_closest_to_threshold(3, 1, [2, 2, 2]) == 0 def test_multiple_possible_answers(): assert find_max_subarray_closest_to_threshold(6, 10, [2, 3, 1, 4, 2, 1]) == 0","solution":"def find_max_subarray_closest_to_threshold(n, t, execution_times): left = 0 current_sum = 0 max_length = 0 closest_sum = 0 start_index = 0 for right in range(n): current_sum += execution_times[right] while current_sum > t: current_sum -= execution_times[left] left += 1 if right - left + 1 > max_length or (right - left + 1 == max_length and current_sum > closest_sum): max_length = right - left + 1 closest_sum = current_sum start_index = left return start_index"},{"question":"def place_fence_posts(n: int, m: int): Determines the possible coordinates of the four fence posts to form a rectangle within an \`n x m\` grid, avoiding peripheral cells. :param n: int, the width (number of columns) of the garden :param m: int, the length (number of rows) of the garden :return: list of tuples with coordinates of the four fence posts or \\"Impossible\\" >>> place_fence_posts(5, 4) [(2, 2), (2, 3), (3, 2), (3, 3)] >>> place_fence_posts(2, 2) \\"Impossible\\"","solution":"def place_fence_posts(n, m): Determines the possible coordinates of the four fence posts to form a rectangle within an \`n x m\` grid, avoiding peripheral cells. :param n: int, the width (number of columns) of the garden :param m: int, the length (number of rows) of the garden :return: list of tuples with coordinates of the four fence posts or \\"Impossible\\" if n < 3 or m < 3: return \\"Impossible\\" return [(2, 2), (2, 3), (3, 2), (3, 3)]"},{"question":"def maxConsecutiveMountains(N: int, heights: List[int]) -> int: You are given a list of N integers representing the heights of mountains in a range. A hiker wants to cross this range from left to right. However, the hiker can only move to adjacent mountains of equal or greater height. The hiker can start from any mountain and needs to determine the maximum number of consecutive mountains they can traverse. Parameters: N (int): the number of mountains heights (List[int]): the heights of the mountains Returns: int: the maximum number of consecutive mountains the hiker can traverse >>> maxConsecutiveMountains(6, [5, 4, 7, 7, 1, 3]) 3 >>> maxConsecutiveMountains(5, [2, 2, 3, 4, 4]) 5","solution":"def maxConsecutiveMountains(N, heights): Returns the maximum number of consecutive mountains the hiker can traverse based on the given heights of the mountains. if not heights: return 0 # Initialize the variables to track the current streak and max streak of consecutive mountains max_streak = 1 current_streak = 1 # Iterate through the list of mountain heights for i in range(1, N): # If the current mountain height is equal or greater than the previous one if heights[i] >= heights[i - 1]: current_streak += 1 else: # If not, reset the current streak current_streak = 1 # Update the max streak if the current streak is greater max_streak = max(max_streak, current_streak) return max_streak"},{"question":"def shortest_travel_time(num_stations: int, num_sections: int, sections: List[Tuple[int, int, int, int]]) -> int: Determine the shortest travel time from the starting station (station 1) to the destination station (station N). Constraints: 2 â‰¤ N â‰¤ 1,000 and 1 â‰¤ M â‰¤ 10,000 Each railway section is defined with (u, v, t, s): u and v are integers representing the start and end stations t represents the travel time if the train moves at the maximum speed allowed s represents the maximum speed limit for that railway section. 1 â‰¤ u, v â‰¤ N, 1 â‰¤ t â‰¤ 10^8, and 1 â‰¤ s â‰¤ 300. If no possible route exists, return -1. Example: >>> shortest_travel_time(3, 3, [(1, 2, 2, 150), (2, 3, 3, 200), (1, 3, 10, 300)]) 5 >>> shortest_travel_time(4, 4, [(1, 2, 5, 100), (2, 4, 5, 100), (1, 3, 2, 200), (3, 4, 2, 200)]) 4 >>> shortest_travel_time(4, 2, [(1, 2, 2, 150), (3, 4, 3, 200)]) -1","solution":"import heapq def shortest_travel_time(num_stations, num_sections, sections): graph = {i: [] for i in range(1, num_stations + 1)} for u, v, t, s in sections: graph[u].append((v, t)) graph[v].append((u, t)) def dijkstra(start, end): heap = [(0, start)] travel_time = {i: float('inf') for i in range(1, num_stations + 1)} travel_time[start] = 0 while heap: current_time, current_station = heapq.heappop(heap) if current_station == end: return current_time if current_time > travel_time[current_station]: continue for neighbor, section_time in graph[current_station]: time = current_time + section_time if time < travel_time[neighbor]: travel_time[neighbor] = time heapq.heappush(heap, (time, neighbor)) return -1 if travel_time[end] == float('inf') else travel_time[end] return dijkstra(1, num_stations)"},{"question":"from typing import List, Tuple, Union def find_pair_with_difference(arr: List[int], K: int) -> Union[Tuple[int, int], int]: Find a pair of distinct indices i and j, such that the absolute difference between the integers at these indices is equal to K. Args: arr: List of integers K: Target absolute difference Returns: A tuple of two integers (i, j) representing the indices (1-indexed) such that the absolute difference between arr[i] and arr[j] is K. If no such pair exists, returns -1. Examples: >>> find_pair_with_difference([1, 5, 3, 4, 2], 3) (1, 4) >>> find_pair_with_difference([8, 3, 6, 10], 2) (2, 3) >>> find_pair_with_difference([1, 2, 3, 4, 5], 10) -1 # Unit tests def test_find_pair_with_difference_example_1(): arr = [1, 5, 3, 4, 2] K = 3 i, j = find_pair_with_difference(arr, K) assert abs(arr[i - 1] - arr[j - 1]) == 3 def test_find_pair_with_difference_example_2(): arr = [8, 3, 6, 10] K = 2 i, j = find_pair_with_difference(arr, K) assert abs(arr[i - 1] - arr[j - 1]) == 2 def test_find_pair_with_difference_no_pair(): arr = [1, 2, 3, 4, 5] K = 10 assert find_pair_with_difference(arr, K) == -1 def test_find_pair_with_difference_multiple_pairs(): arr = [1, 5, 3, 4, 2, 7] K = 2 i, j = find_pair_with_difference(arr, K) assert abs(arr[i - 1] - arr[j - 1]) == 2 def test_find_pair_with_difference_large_numbers(): arr = [-1000000000, 0, 1000000000] K = 1000000000 i, j = find_pair_with_difference(arr, K) assert abs(arr[i - 1] - arr[j - 1]) == 1000000000","solution":"def find_pair_with_difference(arr, K): value_to_index = {} for i in range(len(arr)): if arr[i] + K in value_to_index: return value_to_index[arr[i] + K] + 1, i + 1 if arr[i] - K in value_to_index: return value_to_index[arr[i] - K] + 1, i + 1 value_to_index[arr[i]] = i return -1"},{"question":"def find_pair(nums: list, target: int) -> str: Determines if there are two distinct integers in the list that add up to the target integer. Args: nums (list): A list of integers. target (int): The target integer. Returns: str: \\"POSSIBLE\\" if such a pair exists, otherwise \\"IMPOSSIBLE\\". Examples: >>> find_pair([2, 7, 11, 15], 9) \\"POSSIBLE\\" >>> find_pair([1, 2, 3, 4], 8) \\"IMPOSSIBLE\\"","solution":"def find_pair(nums: list, target: int) -> str: Determines if there are two distinct integers in the list that add up to the target integer. Args: nums (list): A list of integers. target (int): The target integer. Returns: str: \\"POSSIBLE\\" if such a pair exists, otherwise \\"IMPOSSIBLE\\". num_set = set() for num in nums: if target - num in num_set: return \\"POSSIBLE\\" num_set.add(num) return \\"IMPOSSIBLE\\""},{"question":"def productExceptSelf(nums): Returns a list where each element is the product of all elements in nums except the one at its own index. Example 1: >>> productExceptSelf([1, 2, 3, 4]) [24, 12, 8, 6] Example 2: >>> productExceptSelf([2, 3, 4, 5]) [60, 40, 30, 24]","solution":"def productExceptSelf(nums): Returns a list where each element is the product of all elements in nums except the one at its own index. length = len(nums) output = [1] * length # Calculate product of elements to the left of each index left_product = 1 for i in range(length): output[i] = left_product left_product *= nums[i] # Calculate product of elements to the right of each index and multiply right_product = 1 for i in range(length - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def is_palindromic_permutation_possible(string: str) -> bool: Check if a palindromic permutation of the given string is possible. >>> is_palindromic_permutation_possible(\\"aabb\\") True >>> is_palindromic_permutation_possible(\\"abc\\") False def count_palindromic_permutations(string: str) -> int: Count the number of distinct palindromic permutations of the given string. >>> count_palindromic_permutations(\\"aabb\\") 2 >>> count_palindromic_permutations(\\"abc\\") 0 def count_palindromic_permutations_for_cases(test_cases: List[str]) -> List[int]: For a list of test cases, count the number of distinct palindromic permutations for each. >>> count_palindromic_permutations_for_cases([\\"aabb\\", \\"abc\\", \\"aaa\\"]) [2, 0, 1]","solution":"from collections import Counter from math import factorial def is_palindromic_permutation_possible(string): counter = Counter(string) odd_count = sum(1 for count in counter.values() if count % 2 != 0) return odd_count <= 1 def count_palindromic_permutations(string): if not is_palindromic_permutation_possible(string): return 0 counter = Counter(string) half_counter = {char: count // 2 for char, count in counter.items()} half_length = sum(half_counter.values()) result = factorial(half_length) for count in half_counter.values(): result //= factorial(count) return result def count_palindromic_permutations_for_cases(test_cases): results = [] for string in test_cases: results.append(count_palindromic_permutations(string)) return results"},{"question":"from typing import List def longest_consecutive_ones(arr: List[int]) -> int: Helper function to find the longest sequence of consecutive ones >>> longest_consecutive_ones([1, 0, 1, 1, 0, 1]) 2 >>> longest_consecutive_ones([1, 1, 1, 1, 0, 1]) 4 >>> longest_consecutive_ones([1, 1, 1, 0, 0, 1]) 3 >>> longest_consecutive_ones([0, 0, 0, 0, 0]) 0 >>> longest_consecutive_ones([1, 1, 1, 1, 1]) 5 def process_operations(n: int, m: int, array: List[int], operations: List[str]) -> List[int]: Process the given operations on the array and return results for each \\"query\\" >>> process_operations(6, 5, [1, 0, 1, 1, 0, 1], [\\"query\\", \\"flip 1\\", \\"query\\", \\"flip 3\\", \\"query\\"]) [2, 4, 3] >>> process_operations(3, 3, [1, 1, 1], [\\"query\\", \\"flip 0\\", \\"query\\"]) [3, 2] >>> process_operations(4, 4, [0, 0, 0, 0], [\\"query\\", \\"flip 2\\", \\"query\\", \\"flip 2\\"]) [0, 1] def handle_input(): Handle input from standard input Input format: 6 5 1 0 1 1 0 1 query flip 1 query flip 3 query 0 0 Output: 2 4 3","solution":"def longest_consecutive_ones(arr): Helper function to find the longest sequence of consecutive ones max_count = 0 current_count = 0 for num in arr: if num == 1: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 return max_count def process_operations(n, m, array, operations): results = [] for operation in operations: if operation.startswith(\\"flip\\"): _, i = operation.split() i = int(i) array[i] = 1 - array[i] elif operation == \\"query\\": results.append(longest_consecutive_ones(array)) return results def handle_input(): import sys input = sys.stdin.read data = input().strip().split(\\"n\\") index = 0 results = [] while index < len(data): n, m = map(int, data[index].strip().split()) if n == 0 and m == 0: break index += 1 array = list(map(int, data[index].strip().split())) index += 1 operations = [] for _ in range(m): operations.append(data[index].strip()) index += 1 results.extend(process_operations(n, m, array, operations)) for result in results: print(result)"},{"question":"def can_travel_to_all_villages(n: int, m: int, pathways: List[Tuple[int, int, int]]) -> bool: Determine if it's possible for a wizard to travel from Village 1 to each of the other villages at least once without any pathways vanishing. >>> can_travel_to_all_villages(5, 6, [(1, 2, 3), (1, 3, 1), (2, 3, 2), (2, 4, 1), (3, 4, 1), (4, 5, 2)]) == True >>> can_travel_to_all_villages(4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) == True >>> can_travel_to_all_villages(4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 0)]) == False from typing import List, Tuple def test_can_travel_to_all_villages(): assert can_travel_to_all_villages(5, 6, [(1, 2, 3), (1, 3, 1), (2, 3, 2), (2, 4, 1), (3, 4, 1), (4, 5, 2)]) == True assert can_travel_to_all_villages(4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) == True assert can_travel_to_all_villages(4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 0)]) == False assert can_travel_to_all_villages(6, 5, [(1, 2, 2), (2, 3, 2), (3, 4, 0), (4, 5, 1), (5, 6, 1)]) == False assert can_travel_to_all_villages(3, 0, []) == False assert can_travel_to_all_villages(1, 0, []) == True # Running the unit tests test_can_travel_to_all_villages()","solution":"from collections import defaultdict, deque def can_travel_to_all_villages(n, m, pathways): def bfs(adj_list): visited = [False] * n queue = deque([0]) while queue: node = queue.popleft() if not visited[node]: visited[node] = True for neighbor in adj_list[node]: if not visited[neighbor]: queue.append(neighbor) return all(visited) # Create adjacency list for BFS adj_list = defaultdict(list) for u, v, w in pathways: if w > 0: # Only consider the edges that can be used at least once adj_list[u-1].append(v-1) # Check if all nodes can be visited starting from node 0 (village 1) return bfs(adj_list) # Example usage and input parsing def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) pathways = [] index = 2 for i in range(m): u = int(data[index]) v = int(data[index+1]) w = int(data[index+2]) pathways.append((u, v, w)) index += 3 if can_travel_to_all_villages(n, m, pathways): print(\\"YES\\") else: print(\\"NO\\") if __name__ == \\"__main__\\": main()"},{"question":"def has_all_ones_submatrix(matrix, n, m, k): Check if there is at least one k x k submatrix that contains only 1's. >>> has_all_ones_submatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3, 3, 2) 'YES' >>> has_all_ones_submatrix([[1, 1, 1, 0], [1, 1, 1, 0], [0, 0, 1, 1], [1, 1, 1, 1]], 4, 4, 3) 'NO' def solve(test_cases): Solves the given test cases and returns the results. >>> solve([(3, 3, 2, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]), (4, 4, 3, [[1, 1, 1, 0], [1, 1, 1, 0], [0, 0, 1, 1], [1, 1, 1, 1]])]) ['YES', 'NO'] def process_input(input_data): Processes the input string to extract test cases. >>> input_data = \\"2n3 3 2n1 1 1n1 1 1n1 1 1n4 4 3n1 1 1 0n1 1 1 0n0 0 1 1n1 1 1 1\\" >>> process_input(input_data) [(3, 3, 2, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]), (4, 4, 3, [[1, 1, 1, 0], [1, 1, 1, 0], [0, 0, 1, 1], [1, 1, 1, 1]])]","solution":"def has_all_ones_submatrix(matrix, n, m, k): # Iterate over each possible top-left corner of k x k submatrix for i in range(n - k + 1): for j in range(m - k + 1): if all(matrix[i + x][j + y] == 1 for x in range(k) for y in range(k)): return \\"YES\\" return \\"NO\\" def solve(test_cases): results = [] for case in test_cases: n, m, k, matrix = case result = has_all_ones_submatrix(matrix, n, m, k) results.append(result) return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n, m, k = map(int, lines[index].split()) index += 1 matrix = [] for _ in range(n): row = list(map(int, lines[index].split())) matrix.append(row) index += 1 test_cases.append((n, m, k, matrix)) return test_cases"},{"question":"def solve(test_cases: List[Tuple[int, int, List[str]]]) -> List[str]: Given a grid of characters, determine if there exists a cycle of the same letter. A cycle is a path in the grid where the first and last letter are the same, with each letter being distinct (i.e., no letter repeats unless it is the start and endpoint). The path must consist of at least four nodes. >>> solve([(3, 4, [\\"aaaa\\", \\"abca\\", \\"aaaa\\"]), (4, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]), (5, 5, [\\"abcde\\", \\"abfde\\", \\"abfde\\", \\"abcde\\", \\"abcde\\"])]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> solve([(2, 2, [\\"ab\\", \\"cd\\"])]) [\\"No\\"] >>> solve([(3, 3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"])]) [\\"Yes\\"] >>> solve([(5, 5, [\\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\", \\"uvwxy\\"])]) [\\"No\\"] >>> solve([(1, 1, [\\"a\\"])]) [\\"No\\"]","solution":"from collections import deque def in_bounds(x, y, n, m): return 0 <= x < n and 0 <= y < m def bfs(grid, start, n, m): x0, y0 = start visited = [[False] * m for _ in range(n)] queue = deque([(x0, y0, -1, -1)]) start_char = grid[x0][y0] while queue: x, y, px, py = queue.popleft() for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]: nx, ny = x + dx, y + dy if in_bounds(nx, ny, n, m) and grid[nx][ny] == start_char: if not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, x, y)) elif (nx, ny) != (px, py) and (nx, ny) != start: return True return False def has_cycle(grid, n, m): for i in range(n): for j in range(m): if bfs(grid, (i, j), n, m): return True return False def solve(test_cases): results = [] for n, m, grid in test_cases: result = \\"Yes\\" if has_cycle(grid, n, m) else \\"No\\" results.append(result) return results"},{"question":"def min_trip_cost(n: int, clusters: List[List[int]]) -> int: Finds the minimum cost to visit exactly one spot from each cluster. Parameters: n (int): Number of clusters clusters (list of list of int): List containing sub-lists of costs for each cluster Returns: int: The minimum total cost for the trip Examples: >>> min_trip_cost(3, [[10, 50, 70], [20, 40], [5, 20, 40, 10]]) 35 >>> min_trip_cost(1, [[10]]) 10 >>> min_trip_cost(1, [[10, 20, 5]]) 5 pass # Your implementation goes here","solution":"def min_trip_cost(n, clusters): Finds the minimum cost to visit exactly one spot from each cluster. Parameters: n (int): Number of clusters clusters (list of list of int): List containing sub-lists of costs for each cluster Returns: int: The minimum total cost for the trip total_cost = 0 for cluster in clusters: total_cost += min(cluster) return total_cost"},{"question":"def canFormPalindrome(s: str) -> bool: Determines if the given string s can be rearranged to form a palindrome. A palindrome is a word that reads the same backward as forward. This function should return True if the given string can be rearranged into a palindrome, else False. Args: s (str): A string containing lowercase English alphabets. Returns: bool: True if the string can be rearranged to form a palindrome, else False. Examples: >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"aabbccdd\\") True >>> canFormPalindrome(\\"otter\\") False >>> canFormPalindrome(\\"apple\\") False","solution":"def canFormPalindrome(s: str) -> bool: Determines if the given string s can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. This is because the characters can be mirrored around the center of the palindrome. Args: s (str): A string containing lowercase English alphabets. Returns: bool: True if the string can be rearranged to form a palindrome, else False. from collections import Counter # Count the frequency of each character in the string counter = Counter(s) # Check the number of characters with odd frequency odd_count = sum(1 for freq in counter.values() if freq % 2 != 0) # For a string to be rearranged into a palindrome, # there should be at most one character with an odd frequency return odd_count <= 1"},{"question":"def find_unique_species(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[str]: Consolidate observations into a list of unique animal species IDs observed on only one of the two days. Args: T (int): number of test cases. test_cases (List[Tuple[int, int, List[int], List[int]]]): List containing the cases with number of species on both days and the species IDs observed. Returns: List[str]: List where each element is a string of space-separated species IDs observed on one of the two days, in ascending order. >>> T = 1 >>> test_cases = [ >>> ( >>> 6, 5, >>> [10, 20, 30, 40, 50, 60], >>> [20, 30, 70, 80, 90] >>> ) >>> ] >>> find_unique_species(T, test_cases) [\\"10 40 50 60 70 80 90\\"]","solution":"def find_unique_species(T, test_cases): results = [] for case in test_cases: N, M, day1_species, day2_species = case set1 = set(day1_species) set2 = set(day2_species) # Find species only in one of the two days unique_species = set1.symmetric_difference(set2) # Convert to sorted list unique_species_sorted = sorted(list(unique_species)) results.append(\\" \\".join(map(str, unique_species_sorted))) return results"},{"question":"def max_sub_rectangle_sum(matrix): Returns the maximum sum of elements in any sub-rectangle of the matrix. >>> max_sub_rectangle_sum([ ... [1, 2, -1], ... [-3, 4, 2], ... [1, -5, 3] ... ]) 7 >>> max_sub_rectangle_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_sub_rectangle_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -1 >>> max_sub_rectangle_sum([[10]]) 10 >>> max_sub_rectangle_sum([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 pass","solution":"def max_sub_rectangle_sum(matrix): Returns the maximum sum of elements in any sub-rectangle of the matrix. if not matrix or not matrix[0]: return 0 N = len(matrix) M = len(matrix[0]) max_sum = float('-inf') # Helper function to find the max subarray sum using Kadane's algorithm def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Iterate over all possible pairs of columns for left in range(M): temp = [0] * N for right in range(left, M): for i in range(N): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) matrix = [] idx = 2 for _ in range(n): row = list(map(int, data[idx:idx + m])) matrix.append(row) idx += m return matrix if __name__ == \\"__main__\\": matrix = read_input() print(max_sub_rectangle_sum(matrix)) # For testing purpose RETURN ONLY max_sub_rectangle_sum AND NOT read_input OR main SCOPE. # Hence user need to modify it while testing."},{"question":"def is_fully_occupied(grid): Determine if there is at least one row or one column that is fully occupied by 'X'. Parameters: grid (list of list of str): A 3x3 grid represented as a list of lists, where each element is either '.' or 'X'. Returns: str: 'YES' if there is at least one fully occupied row or column, otherwise 'NO'. def test_is_fully_occupied_row(): grid = [ ['X', '.', 'X'], ['X', 'X', 'X'], ['.', 'X', '.'] ] assert is_fully_occupied(grid) == 'YES' def test_is_fully_occupied_column(): grid = [ ['X', '.', '.'], ['X', '.', '.'], ['X', '.', '.'] ] assert is_fully_occupied(grid) == 'YES' def test_is_not_fully_occupied(): grid = [ ['X', '.', '.'], ['.', 'X', '.'], ['.', '.', 'X'] ] assert is_fully_occupied(grid) == 'NO' def test_is_empty_grid(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert is_fully_occupied(grid) == 'NO' def test_is_fully_occupied_last_row(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['X', 'X', 'X'] ] assert is_fully_occupied(grid) == 'YES' def test_is_fully_occupied_first_col(): grid = [ ['X', '.', '.'], ['X', '.', '.'], ['X', '.', '.'] ] assert is_fully_occupied(grid) == 'YES'","solution":"def is_fully_occupied(grid): Determine if there is at least one row or one column that is fully occupied by 'X'. Parameters: grid (list of list of str): A 3x3 grid represented as a list of lists, where each element is either '.' or 'X'. Returns: str: 'YES' if there is at least one fully occupied row or column, otherwise 'NO'. for row in grid: if all(cell == 'X' for cell in row): return 'YES' for col in range(3): if all(grid[row][col] == 'X' for row in range(3)): return 'YES' return 'NO'"},{"question":"def rearrangeArray(arr): Rearranges the array such that every second element is greater than its left and right neighbors. :param arr: List of integers :return: Rearranged list of integers >>> rearrangeArray([5, 6, 1, 3, 8, 2]) [1, 3, 2, 6, 5, 8] >>> rearrangeArray([10, 20, 30, 40, 50, 60, 70]) [10, 30, 20, 50, 40, 70, 60] >>> rearrangeArray([1]) [1] >>> rearrangeArray([2, 1]) [1, 2] >>> rearrangeArray([1, 2, 3, 4, 5, 6]) [1, 3, 2, 5, 4, 6] >>> rearrangeArray([1000000000, 99999999, 88888888, 77777777]) [77777777, 88888888, 99999999, 1000000000]","solution":"def rearrangeArray(arr): Rearranges the array such that every second element is greater than its left and right neighbors. :param arr: List of integers :return: Rearranged list of integers n = len(arr) if n <= 1: return arr # Sort the array arr.sort() # Swap adjacent elements to satisfy the condition for i in range(1, n, 2): if i + 1 < n: arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr"},{"question":"def check_az(S: str) -> str: Determine if the string contains both 'a' and 'z'. >>> check_az(\\"amazing\\") 'Success' >>> check_az(\\"alphabet\\") 'Fail'","solution":"def check_az(S): Returns \\"Success\\" if the string S contains both 'a' and 'z', otherwise returns \\"Fail\\". if 'a' in S and 'z' in S: return \\"Success\\" else: return \\"Fail\\""},{"question":"def min_abs_difference(nums: List[int]) -> int: Divide the list into two subsets such that the absolute difference between the sum of elements in the first subset and the sum of elements in the second subset is minimized. >>> min_abs_difference([1, -2, 3, 4]) 0 >>> min_abs_difference([5, -7, 3]) 1 >>> min_abs_difference([1, 2, 3, 9]) 3 >>> min_abs_difference([1, 1, 1, 1, 1, 1]) 0 >>> min_abs_difference([100, 100, 100, -100, -100]) 100 from typing import List def test_case_1(): assert min_abs_difference([1, -2, 3, 4]) == 0 def test_case_2(): assert min_abs_difference([5, -7, 3]) == 1 def test_case_3(): assert min_abs_difference([1, 2, 3, 9]) == 3 def test_case_4(): assert min_abs_difference([1, 1, 1, 1, 1, 1]) == 0 def test_case_5(): assert min_abs_difference([100, 100, 100, -100, -100]) == 100","solution":"def min_abs_difference(nums): total = sum(abs(num) for num in nums) n = len(nums) # DP to track possible sums dp = [False] * (total + 1) dp[0] = True for num in nums: current = [False] * (total + 1) for s in range(total + 1): if dp[s]: current[s] = True if s + abs(num) <= total: current[s + abs(num)] = True dp = current min_diff = float('inf') for s in range((total // 2) + 1): if dp[s]: min_diff = min(min_diff, total - 2 * s) return min_diff"},{"question":"class Inventory: def __init__(self): Initializes a new instance of the Inventory class. pass def add(self, productId: int, quantity: int): Adds the specified quantity of the product with the given productId to the inventory. >>> inventory = Inventory() >>> inventory.add(101, 5) >>> inventory.add(102, 10) >>> assert inventory.query(100, 200) == 15 pass def query(self, startProductId: int, endProductId: int) -> int: Returns the total quantity of products in the inventory whose product IDs are between startProductId and endProductId (inclusive). >>> inventory = Inventory() >>> inventory.add(101, 5) >>> inventory.add(102, 10) >>> assert inventory.query(100, 200) == 15 >>> inventory.add(101, 10) >>> assert inventory.query(100, 102) == 25 pass","solution":"class Inventory: def __init__(self): # Using a dictionary to store the quantities of each product self.inventory = {} def add(self, productId, quantity): if productId in self.inventory: self.inventory[productId] += quantity else: self.inventory[productId] = quantity def query(self, startProductId, endProductId): total_quantity = 0 for productId in range(startProductId, endProductId + 1): if productId in self.inventory: total_quantity += self.inventory[productId] return total_quantity"},{"question":"from collections import Counter def most_common_characters(S: str) -> None: Count the frequency of each character in the string using the Counter class, and print the 3 most common characters along with their counts. If there are ties, sort the characters in lexicographical (alphabetical) order. Input: S (str): A string consisting of lowercase English alphabets. Output: None: The function prints the result. Example: >>> most_common_characters(\\"aabbbccde\\") b 3 a 2 c 2 # Your implementation here # Example usage (you can remove or comment this out before running unit tests) if __name__ == \\"__main__\\": S = input().strip() most_common_characters(S) Unit Test: from solution import most_common_characters def test_most_common_characters_example_case(capsys): S = \\"aabbbccde\\" most_common_characters(S) captured = capsys.readouterr() assert captured.out == \\"b 3na 2nc 2n\\" def test_most_common_characters_all_unique(capsys): S = \\"abcdefg\\" most_common_characters(S) captured = capsys.readouterr() assert captured.out == \\"a 1nb 1nc 1n\\" def test_most_common_characters_ties(capsys): S = \\"aabbccc\\" most_common_characters(S) captured = capsys.readouterr() assert captured.out == \\"c 3na 2nb 2n\\" def test_most_common_characters_large_string(capsys): S = \\"a\\" * 10000 + \\"b\\" * 5000 + \\"c\\" * 2000 + \\"d\\" * 300 + \\"e\\" * 100 most_common_characters(S) captured = capsys.readouterr() assert captured.out == \\"a 10000nb 5000nc 2000n\\"","solution":"from collections import Counter def most_common_characters(S): # Create a Counter object from the string S counter = Counter(S) # Get the 3 most common characters common_chars = counter.most_common() # Sort the characters first by frequency, then by lexicographic order in case of ties common_chars.sort(key=lambda pair: (-pair[1], pair[0])) # Extract the top 3 characters top_three = common_chars[:3] # Print the top 3 most common characters and their counts for char, count in top_three: print(char, count) # Example usage if __name__ == \\"__main__\\": S = \\"aabbbccde\\" most_common_characters(S)"},{"question":"def rotate_array(arr, k): Rotates the array to the right by k positions. Parameters: arr (list): A list of integers. k (int): Number of positions to rotate. Returns: list: Rotated array. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> rotate_array([1], 10) [1] >>> rotate_array([1, 2], 1) [2, 1] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100]","solution":"def rotate_array(arr, k): Rotates the array to the right by k positions. Parameters: arr (list): A list of integers. k (int): Number of positions to rotate. Returns: list: Rotated array. n = len(arr) k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"from typing import List, Tuple def process_datasets(datasets: List[Tuple[int, int, List[Tuple[int, int, int, int]]]]) -> List[int]: Processes multiple datasets and returns the results of each query. Each dataset contains a number of intersections and a number of queries/updates. The function simulates the addition of roads and finds shortest paths as specified in the queries. Args: datasets: A list of tuples containing: - an integer \`m\` (number of intersections) - an integer \`q\` (number of queries/updates) - a list of operations (queries or updates) Returns: A list of integers representing the results of the queries. For each query, it returns the shortest distance between the specified intersections, or -1 if no path exists. Example: >>> datasets = [ >>> (4, 5, [(1, 1, 2, 10), (1, 2, 3, 20), (0, 1, 3), (1, 3, 4, 25), (0, 1, 4)]), >>> (3, 3, [(0, 1, 2), (1, 1, 2, 15), (0, 1, 3)]), >>> ] >>> process_datasets(datasets) [30, 55, -1, -1] pass def dijkstra(num_nodes: int, adj_list: dict, start: int, end: int) -> int: Finds the shortest path between two nodes using Dijkstra's algorithm. Args: num_nodes: Number of nodes in the graph. adj_list: Adjacency list representing the graph. start: The starting node. end: The ending node. Returns: The shortest path length if a path exists, otherwise -1. pass def parse_input(input_str: str) -> List[Tuple[int, int, List[Tuple[int, int, int, int]]]]: Parses the input string into a format suitable for process_datasets. Args: input_str: String representation of the input. Returns: A list of tuples, each representing a dataset. pass from solution import process_datasets, parse_input def test_sample_input(): input_str = \\"4 5n1 1 2 10n1 2 3 20n0 1 3n1 3 4 25n0 1 4n3 3n0 1 2n1 1 2 15n0 1 3n0 0\\" expected_output = [30, 55, -1, -1] datasets = parse_input(input_str) assert process_datasets(datasets) == expected_output def test_disconnected_graph(): input_str = \\"3 4n1 1 2 5n1 2 3 10n0 1 3n0 1 2n0 0\\" expected_output = [15, 5] datasets = parse_input(input_str) assert process_datasets(datasets) == expected_output def test_no_queries(): input_str = \\"4 3n1 1 2 10n1 2 3 20n1 3 4 30n0 0\\" expected_output = [] datasets = parse_input(input_str) assert process_datasets(datasets) == expected_output def test_simple_query(): input_str = \\"2 2n1 1 2 10n0 1 2n0 0\\" expected_output = [10] datasets = parse_input(input_str) assert process_datasets(datasets) == expected_output def test_multiple_datasets(): input_str = \\"2 2n1 1 2 10n0 1 2n4 5n1 1 2 10n1 2 3 15n0 1 3n1 3 4 20n0 1 4n0 0\\" expected_output = [10, 25, 45] datasets = parse_input(input_str) assert process_datasets(datasets) == expected_output","solution":"import heapq def process_datasets(datasets): results = [] for data in datasets: m, q, operations = data adj_list = {i: [] for i in range(1, m + 1)} for operation in operations: if operation[0] == 1: _, a, b, l = operation adj_list[a].append((b, l)) adj_list[b].append((a, l)) elif operation[0] == 0: _, x, y = operation shortest_path = dijkstra(m, adj_list, x, y) results.append(shortest_path) return results def dijkstra(num_nodes, adj_list, start, end): dist = {i: float('inf') for i in range(1, num_nodes + 1)} dist[start] = 0 priority_queue = [(0, start)] # (distance, node) visited = set() while priority_queue: curr_dist, node = heapq.heappop(priority_queue) if node in visited: continue visited.add(node) if node == end: return curr_dist for neighbor, weight in adj_list[node]: if neighbor not in visited and curr_dist + weight < dist[neighbor]: dist[neighbor] = curr_dist + weight heapq.heappush(priority_queue, (dist[neighbor], neighbor)) return -1 def parse_input(input_str): datasets = [] lines = input_str.strip().split(\\"n\\") idx = 0 while idx < len(lines): m, q = map(int, lines[idx].split()) idx += 1 if m == 0 and q == 0: break operations = [] for _ in range(q): operations.append(tuple(map(int, lines[idx].split()))) idx += 1 datasets.append((m, q, operations)) return datasets"},{"question":"def sortedMatrixElements(matrix): Given an nÃ—n matrix matrix where each of the rows and columns is sorted in ascending order, return all elements of the matrix in sorted order in an array. :param matrix: a 2D list of integers with dimension n x n. :return: List of integers: a list containing all matrix elements in sorted order. >>> sortedMatrixElements([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ]) [1, 5, 9, 10, 11, 12, 13, 13, 15] >>> sortedMatrixElements([ ... [-5, -4], ... [-3, -1] ... ]) [-5, -4, -3, -1] pass def test_sortedMatrixElements_sample_input_0(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] assert sortedMatrixElements(matrix) == [1, 5, 9, 10, 11, 12, 13, 13, 15] def test_sortedMatrixElements_sample_input_1(): matrix = [ [-5, -4], [-3, -1] ] assert sortedMatrixElements(matrix) == [-5, -4, -3, -1] def test_sortedMatrixElements_single_element(): matrix = [ [1] ] assert sortedMatrixElements(matrix) == [1] def test_sortedMatrixElements_all_same_elements(): matrix = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert sortedMatrixElements(matrix) == [2, 2, 2, 2, 2, 2, 2, 2, 2] def test_sortedMatrixElements_large_values(): matrix = [ [1000000000, 1000000001], [1000000002, 1000000003] ] assert sortedMatrixElements(matrix) == [1000000000, 1000000001, 1000000002, 1000000003]","solution":"def sortedMatrixElements(matrix): Given an nÃ—n matrix matrix where each of the rows and columns is sorted in ascending order, return all elements of the matrix in sorted order in an array. :param matrix: a 2D list of integers with dimension n x n. :return: List of integers: a list containing all matrix elements in sorted order. all_elements = [] for row in matrix: all_elements.extend(row) return sorted(all_elements)"},{"question":"from typing import List def unique_combinations(n: int, items: List[str], r: int) -> List[List[str]]: Returns all unique combinations of r items from the list of n items. Args: n : int : number of unique items items : list of str : list of unique items r : int : number of items to be selected in each combination Returns: list of lists : all unique combinations of r items from items >>> unique_combinations(4, [\\"vase\\", \\"book\\", \\"candle\\", \\"frame\\"], 2) [['book', 'candle'], ['book', 'frame'], ['book', 'vase'], ['candle', 'frame'], ['candle', 'vase'], ['frame', 'vase']] >>> unique_combinations(2, [\\"vase\\", \\"book\\"], 1) [['book'], ['vase']] >>> unique_combinations(1, [\\"vase\\"], 1) [['vase']]","solution":"from itertools import combinations def unique_combinations(n, items, r): Returns all unique combinations of r items from the list of n items. Args: n : int : number of unique items items : list of str : list of unique items r : int : number of items to be selected in each combination Returns: list of lists : all unique combinations of r items from items items.sort() # Ensure the items are sorted to maintain lexicographical order result = list(combinations(items, r)) return [list(combo) for combo in result]"},{"question":"def check_bonus_eligibility(test_cases: List[int]) -> List[str]: Given the efficiency of an employee, determine if they are eligible for the bonus. Eligibility threshold is 50. >>> check_bonus_eligibility([10, 20, 30, 40]) [\\"Not Eligible\\", \\"Not Eligible\\", \\"Not Eligible\\", \\"Not Eligible\\"] >>> check_bonus_eligibility([60, 70, 80, 90]) [\\"Eligible\\", \\"Eligible\\", \\"Eligible\\", \\"Eligible\\"] >>> check_bonus_eligibility([50, 50, 50, 50]) [\\"Not Eligible\\", \\"Not Eligible\\", \\"Not Eligible\\", \\"Not Eligible\\"] >>> check_bonus_eligibility([30, 55, 50, 75]) [\\"Not Eligible\\", \\"Eligible\\", \\"Not Eligible\\", \\"Eligible\\"] >>> check_bonus_eligibility([1, 100]) [\\"Not Eligible\\", \\"Eligible\\"]","solution":"def check_bonus_eligibility(test_cases): threshold = 50 results = [] for efficiency in test_cases: if efficiency > threshold: results.append(\\"Eligible\\") else: results.append(\\"Not Eligible\\") return results"},{"question":"def distinct_species_in_barn(barn: str, queries: List[Tuple[int, int]]) -> List[int]: For each query, returns the count of distinct species within the specified segment of the barn. >>> distinct_species_in_barn(\\"abcabc\\", [(1, 3), (2, 5), (1, 6)]) [3, 3, 3] >>> distinct_species_in_barn(\\"aaaaaa\\", [(1, 2), (3, 6), (1, 6)]) [1, 1, 1]","solution":"def distinct_species_in_barn(barn, queries): For each query, returns the count of distinct species within the specified segment of the barn. result = [] for li, ri in queries: segment = barn[li-1:ri] count_distinct = len(set(segment)) result.append(count_distinct) return result"},{"question":"def are_anagrams(word1: str, word2: str) -> bool: Check if two words are anagrams of each other (case insensitive). >>> are_anagrams(\\"listen\\", \\"silent\\") == True >>> are_anagrams(\\"hello\\", \\"world\\") == False >>> are_anagrams(\\"Listen\\", \\"SiLeNt\\") == True >>> are_anagrams(\\"Triangle\\", \\"Integral\\") == True >>> are_anagrams(\\"apple\\", \\"pabble\\") == False pass def check_anagrams(pairs: List[Tuple[str, str]]) -> List[str]: Takes a list of word pairs and returns a list of \\"YES\\" or \\"NO\\" for each pair indicating whether the words are anagrams. >>> check_anagrams([(\\"listen\\", \\"silent\\"), (\\"hello\\", \\"world\\")]) == [\\"YES\\", \\"NO\\"] >>> check_anagrams([(\\"Triangle\\", \\"Integral\\"), (\\"apple\\", \\"pabble\\")]) == [\\"YES\\", \\"NO\\"] >>> check_anagrams([(\\"Dormitory\\", \\"DirtyRoom\\"), (\\"Astronomer\\", \\"MoonStarer\\")]) == [\\"YES\\", \\"YES\\"] pass","solution":"def are_anagrams(word1, word2): Check if two words are anagrams of each other (case insensitive). return sorted(word1.lower()) == sorted(word2.lower()) def check_anagrams(pairs): Takes a list of word pairs and returns a list of \\"YES\\" or \\"NO\\" for each pair indicating whether the words are anagrams. results = [] for word1, word2 in pairs: if are_anagrams(word1, word2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def fill_missing_values(arr): Fills in the missing values represented by -1 in the array by replacing each -1 with the arithmetic mean of its immediate neighbors. If -1 is at the beginning or end of the array, use only its single neighbor to replace it. Parameters: arr (list of int): The input array with missing values represented as -1. Returns: list of float: The array with missing values filled. Examples: >>> fill_missing_values([10, -1, 5, 6, -1, 3, 8]) [10, 7.5, 5, 6, 4.5, 3, 8] >>> fill_missing_values([-1, 3, 2, -1, 1]) [3, 3, 2, 1.5, 1] from solution import fill_missing_values def test_example_1(): arr = [10, -1, 5, 6, -1, 3, 8] expected = [10, 7.5, 5, 6, 4.5, 3, 8] assert fill_missing_values(arr) == expected def test_example_2(): arr = [-1, 3, 2, -1, 1] expected = [3, 3, 2, 1.5, 1] assert fill_missing_values(arr) == expected def test_multiple_missing_values(): arr = [1, -1, 3, -1, 5, -1, 7] expected = [1, 2, 3, 4, 5, 6, 7] assert fill_missing_values(arr) == expected def test_missing_at_beginning_and_end(): arr = [-1, 1, 2, 3, -1] expected = [1, 1, 2, 3, 3] assert fill_missing_values(arr) == expected def test_single_missing_value(): arr = [1, 2, -1, 4, 5] expected = [1, 2, 3, 4, 5] assert fill_missing_values(arr) == expected def test_all_values_present(): arr = [1, 2, 3, 4, 5] expected = [1, 2, 3, 4, 5] assert fill_missing_values(arr) == expected","solution":"def fill_missing_values(arr): Fills in the missing values represented by -1 in the array by replacing each -1 with the arithmetic mean of its immediate neighbors. If -1 is at the beginning or end of the array, use only its single neighbor to replace it. n = len(arr) for i in range(n): if arr[i] == -1: if i == 0: arr[i] = arr[i + 1] elif i == n - 1: arr[i] = arr[i - 1] else: arr[i] = (arr[i - 1] + arr[i + 1]) / 2.0 return arr"},{"question":"def max_gold_path(grid: List[List[int]]) -> int: Returns the maximum amount of gold that can be collected along a path from the top-left cell to the bottom-right cell, moving only right or down. >>> max_gold_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_gold_path([ ... [1, 2, 5], ... [3, 2, 1], ... [4, 3, 1] ... ]) == 12 >>> max_gold_path([[5]]) == 5 >>> max_gold_path([[1, 2, 3, 4, 5]]) == 15 >>> max_gold_path([[1], [2], [3], [4], [5]]) == 15 >>> max_gold_path([[1000, 1000], [1000, 1000]]) == 3000 >>> max_gold_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0","solution":"def max_gold_path(grid): Returns the maximum amount of gold that can be collected along a path from the top-left cell to the bottom-right cell, moving only right or down. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Create a DP table to store max gold collected up to each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell will have the answer return dp[n-1][m-1]"},{"question":"from typing import List def rob(nums: List[int]) -> int: Determine the maximum amount of money the thief can rob tonight without alerting the police. It is impossible to rob two adjacent houses due to the alarm system. Houses are arranged in a circle, meaning the first house is the neighbor of the last one. >>> rob([2, 3, 2]) # Example 1 3 >>> rob([1, 2, 3, 1]) # Example 2 4 >>> rob([5]) # Single house 5 >>> rob([4, 5]) # Two houses 5 >>> rob([2, 7, 9]) # Three houses 9 >>> rob([1, 1, 1, 1]) # Same value houses 2 >>> rob([1, 2, 3, 4, 5, 6, 7, 8, 9]) 24 >>> rob([]) # Empty list 0","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without alerting the police. Since houses are arranged in a circle, the thief cannot rob the first and last house both. def rob_linear(nums): prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return curr_max n = len(nums) if n == 1: return nums[0] return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, returns the product of all the elements in the array except itself for each position in the output array. The result should be modulo 1000000007. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1, 1]) [1, 1, 1, 1, 1] >>> product_except_self([2, 3, 4, 5, 6]) [360, 240, 180, 144, 120] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900] >>> product_except_self([10]) [1]","solution":"def product_except_self(nums): Returns a list such that each element at index i is the product of all the elements of nums except nums[i]. MOD = 1000000007 n = len(nums) if n == 1: return [1] # Step 1: Generate prefix and suffix products prefix_products = [1] * n suffix_products = [1] * n for i in range(1, n): prefix_products[i] = prefix_products[i-1] * nums[i-1] % MOD for i in range(n-2, -1, -1): suffix_products[i] = suffix_products[i+1] * nums[i+1] % MOD # Step 2: Calculate result result = [1] * n for i in range(n): result[i] = prefix_products[i] * suffix_products[i] % MOD return result"},{"question":"def max_non_overlapping_performances(performance_slots: [(int, int)]) -> int: Returns the maximum number of non-overlapping performances that can be attended. :param performance_slots: List of tuples, where each tuple contains start and end times of a performance. :return: Integer representing the maximum number of non-overlapping performances. >>> max_non_overlapping_performances([(1, 4), (3, 5), (0, 6), (5, 7), (8, 9), (5, 9)]) 3 >>> max_non_overlapping_performances([(1, 2)]) 1 >>> max_non_overlapping_performances([]) 0 >>> max_non_overlapping_performances([(1, 5), (2, 6), (3, 7)]) 1 >>> max_non_overlapping_performances([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_performances([(1, 3), (2, 5), (4, 6), (5, 7), (6, 8)]) 3 >>> max_non_overlapping_performances([(i, i + 1000) for i in range(0, 10000, 1001)]) 10","solution":"def max_non_overlapping_performances(performance_slots): Returns the maximum number of non-overlapping performances that can be attended. :param performance_slots: List of tuples, where each tuple contains start and end times of a performance. :return: Integer representing the maximum number of non-overlapping performances. # Sort the performance slots by their end times sorted_slots = sorted(performance_slots, key=lambda x: x[1]) # Initialize variables max_performances = 0 last_end_time = 0 # Iterate through the sorted performance slots for start, end in sorted_slots: if start >= last_end_time: # Check if the performance can be attended max_performances += 1 last_end_time = end # Update the end time to the end of the current performance return max_performances"},{"question":"def subarraySum(arr, k): Determine whether there exists a subarray whose sum equals k. Args: arr: list of integers k: target sum integer Returns: 'Yes' if such a subarray exists, otherwise 'No' >>> subarraySum([1, 2, 3, 4, 5], 9) 'Yes' >>> subarraySum([1, -1, 1, -1], 0) 'Yes' >>> subarraySum([4, 3, 2], 6) 'No' >>> subarraySum([1, 2, 3], 5) 'Yes' >>> subarraySum([1, 2, 3], 10) 'No' >>> subarraySum([-1, -2, -3, 4, 1], 0) 'Yes' >>> subarraySum([1], 1) 'Yes' >>> subarraySum([2], 1) 'No' >>> subarraySum([], 0) 'No' >>> subarraySum([1, 1, 1, 1], 2) 'Yes' >>> subarraySum([1, 2, 3, 7, 2, 1], 10) 'Yes' >>> subarraySum([0, 0, 0, 0, 0], 0) 'Yes'","solution":"def subarraySum(arr, k): Determine whether there exists a subarray whose sum equals k. Args: arr: list of integers k: target sum integer Returns: 'Yes' if such a subarray exists, otherwise 'No' current_sum = 0 sum_map = {0: -1} # This handles the case when subarray starts from index 0 for i, num in enumerate(arr): current_sum += num if (current_sum - k) in sum_map: return \\"Yes\\" sum_map[current_sum] = i return \\"No\\""},{"question":"MOD = 1000000007 def num_ways_to_arrange_plants(T, test_cases): Calculate the number of ways to arrange N plants in a row following the given height constraint. Args: T (int): the number of test cases. test_cases (List[int]): a list of integers where each integer indicates the number of plants in a row for each test case. Returns: List[int]: a list of integers where each integer is the number of ways to arrange the corresponding number of plants. >>> num_ways_to_arrange_plants(1, [1]) [1] >>> num_ways_to_arrange_plants(1, [3]) [3] >>> num_ways_to_arrange_plants(2, [1, 3]) [1, 3] >>> num_ways_to_arrange_plants(1, [10]) [89] >>> num_ways_to_arrange_plants(5, [1, 1, 1, 1, 1]) [1, 1, 1, 1, 1] >>> num_ways_to_arrange_plants(4, [2, 3, 4, 5]) [2, 3, 5, 8]","solution":"MOD = 1000000007 def num_ways_to_arrange_plants(T, test_cases): max_n = max(test_cases) # DP array to store the number of ways to arrange up to the maximum N dp = [0] * (max_n + 1) dp[1] = 1 if max_n > 1: dp[2] = 2 for i in range(3, max_n + 1): dp[i] = (dp[i - 1] + dp[i - 2]) % MOD result = [] for n in test_cases: result.append(dp[n]) return result # Example usage: # T = 2 # test_cases = [1, 3] # print(num_ways_to_arrange_plants(T, test_cases)) # Output: [1, 3]"},{"question":"def num_decodings(s: str) -> int: Returns the number of ways the given encoded message can be decoded into corresponding English letters. >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"0\\") 0","solution":"def num_decodings(s): Returns the number of ways the given encoded message can be decoded into corresponding English letters. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # An empty string has one way to be decoded dp[1] = 1 if s[0] != '0' else 0 # The first character (assuming it's not '0') has one way to be decoded for i in range(2, n + 1): single_digit = int(s[i - 1:i]) two_digits = int(s[i - 2:i]) if 1 <= single_digit <= 9: # Decode as a single digit (1-9) dp[i] += dp[i - 1] if 10 <= two_digits <= 26: # Decode as a two-digit number (10-26) dp[i] += dp[i - 2] return dp[n]"},{"question":"def pyramid(n: int) -> List[List[int]]: Write a function \`pyramid(n)\` that takes an integer \`n\` and returns a list of lists representing a pyramid with height \`n\`. Each sublist should contain the integers from 1 up to the current level number, centered with leading and trailing zeroes to make each sublist of equal length. >>> pyramid(1) == [[1]] >>> pyramid(2) == [[0, 1, 0], [1, 2, 1]] >>> pyramid(3) == [[0, 0, 1, 0, 0], [0, 1, 2, 1, 0], [1, 2, 3, 2, 1]] >>> pyramid(4) == [[0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 2, 1, 0, 0], [0, 1, 2, 3, 2, 1, 0], [1, 2, 3, 4, 3, 2, 1]]","solution":"def pyramid(n): Returns a pyramid of height n as a list of lists. Each sublist represents a level in the pyramid. pyramid_list = [] for i in range(1, n + 1): row = [] # append leading zeroes for _ in range(n - i): row.append(0) # append ascending numbers for j in range(1, i + 1): row.append(j) # append descending numbers for j in range(i - 1, 0, -1): row.append(j) # append trailing zeroes for _ in range(n - i): row.append(0) pyramid_list.append(row) return pyramid_list"},{"question":"def count_and_sum_primes_in_range(a: int, b: int) -> (int, int): Returns a tuple containing the number of prime numbers and their sum within the range [a, b]. >>> count_and_sum_primes_in_range(10, 20) (4, 60) >>> count_and_sum_primes_in_range(1, 10) (4, 17) >>> count_and_sum_primes_in_range(5, 5) (1, 5) >>> count_and_sum_primes_in_range(8, 10) (0, 0) >>> count_and_sum_primes_in_range(1, 100) (25, 1060) >>> count_and_sum_primes_in_range(17, 23) (3, 59)","solution":"def count_and_sum_primes_in_range(a: int, b: int) -> (int, int): Returns a tuple containing the number of prime numbers and their sum within the range [a, b]. def sieve(n: int): Utilize the Sieve of Eratosthenes to find all primes up to and including n. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 is_prime[0] = is_prime[1] = False return {i for i in range(n + 1) if is_prime[i]} primes = sieve(b) count = 0 total_sum = 0 for num in range(a, b + 1): if num in primes: count += 1 total_sum += num return (count, total_sum)"},{"question":"from typing import List, Tuple def find_largest_component(N: int, M: int, edges: List[Tuple[int, int]], values: List[int]) -> int: Returns the sum of the values of the largest connected component in an undirected graph. Arguments: N : int : Number of nodes M : int : Number of edges edges : List[Tuple[int, int]] : List of edges values : List[int] : List of values associated with each node Returns: int : Sum of the values of the largest connected component Example: >>> find_largest_component(4, 2, [(0, 1), (2, 3)], [1, 2, 3, 4]) 7 >>> find_largest_component(3, 2, [(0, 1), (1, 2)], [10, 20, 30]) 60 >>> find_largest_component(5, 2, [(0, 1), (3, 4)], [5, 5, 5, 5, 5]) 10 pass # Unit tests def test_example1(): assert find_largest_component( 4, 2, [(0, 1), (2, 3)], [1, 2, 3, 4] ) == 7 def test_example2(): assert find_largest_component( 3, 2, [(0, 1), (1, 2)], [10, 20, 30] ) == 60 def test_example3(): assert find_largest_component( 5, 2, [(0, 1), (3, 4)], [5, 5, 5, 5, 5] ) == 10 def test_single_node(): assert find_largest_component( 1, 0, [], [42] ) == 42 def test_disconnected_graph(): assert find_largest_component( 7, 3, [(0, 1), (2, 3), (4, 5)], [5, 10, 15, 20, 25, 30, 35] ) == 55 def test_full_graph(): assert find_largest_component( 4, 6, [(0, 1), (1, 2), (2, 3), (0, 3), (0, 2), (1, 3)], [2, 4, 6, 8] ) == 20","solution":"def find_largest_component(N, M, edges, values): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * N max_sum = 0 def bfs(node): queue = deque([node]) total_sum = 0 while queue: current = queue.popleft() if not visited[current]: visited[current] = True total_sum += values[current] for neighbor in graph[current]: if not visited[neighbor]: queue.append(neighbor) return total_sum for i in range(N): if not visited[i]: component_sum = bfs(i) if component_sum > max_sum: max_sum = component_sum return max_sum"},{"question":"def product_pair_exists(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine whether there are two distinct elements in the array whose product is exactly k. >>> product_pair_exists(3, [(4, 15, [1, 2, 3, 5]), (5, 9, [7, 1, 3, 4, 2]), (6, 6, [2, 3, 1, 6, 9, 4])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> product_pair_exists(1, [(4, 10, [1, 2, 3, 4])]) [\\"NO\\"] >>> product_pair_exists(1, [(2, 6, [2, 3])]) [\\"YES\\"] >>> product_pair_exists(1, [(4, 12, [3, 4, 6, 2])]) [\\"YES\\"] >>> product_pair_exists(1, [(5, 999999999, [999999996, 8, 7, 5, 9])]) [\\"NO\\"] >>> product_pair_exists(1, [(2, 2, [1, 2])]) [\\"YES\\"] >>> product_pair_exists(1, [(5, 0, [0, 0, 0, 0, 0])]) [\\"NO\\"]","solution":"def product_pair_exists(t, test_cases): results = [] for case in test_cases: n, k, arr = case seen = set() found = False for num in arr: if num != 0 and k % num == 0 and (k // num) in seen: results.append(\\"YES\\") found = True break seen.add(num) if not found: results.append(\\"NO\\") return results # Example Usage t = 3 test_cases = [ (4, 15, [1, 2, 3, 5]), (5, 9, [7, 1, 3, 4, 2]), (6, 6, [2, 3, 1, 6, 9, 4]) ] print(product_pair_exists(t, test_cases))"},{"question":"def process_operations(m: int, B: List[int], p: int, operations: List[Tuple[int, int, int]]) -> List[int]: Perform operations on an integer sequence B. Perform add(i, x) that increments b_i by x or get(i) that returns the value of b_i. Args: m (int): the number of elements in B. B (List[int]): the list of integers. p (int): the number of operations. operations (List[Tuple[int, int, int]]): the operations to be performed on B. Each operation is a tuple where: - the first element is the type of operation (0 for add, 1 for get) - the second element is the index i - the third element is the value x (used only for add operations) Returns: List[int]: the results of get operations. Example: >>> process_operations(5, [2, 4, -1, 3, 6], 4, [(0, 3, 2), (1, 3, 0), (0, 2, -3), (1, 2, 0)]) [5, -4] >>> process_operations(3, [1, 2, 3], 4, [(0, 0, 10), (0, 1, -5), (0, 2, 2), (0, 1, 1)]) [] >>> process_operations(2, [5, -5], 2, [(1, 0, 0), (1, 1, 0)]) [5, -5] >>> process_operations(2, [-1000000000, 1000000000], 2, [(1, 0, 0), (1, 1, 0)]) [-1000000000, 1000000000] >>> process_operations(4, [1, 2, 3, 4], 6, [(0, 0, 3), (0, 1, -2), (1, 1, 0), (0, 2, 5), (0, 3, -1), (1, 3, 0)]) [0, 3]","solution":"def process_operations(m, B, p, operations): results = [] for operation in operations: com, i, x = operation if com == 0: # add(i, x) B[i] += x elif com == 1: # get(i) results.append(B[i]) return results"},{"question":"def can_rearrange_bouquets(test_cases: List[Tuple[str, str]]) -> List[str]: Determine if each pair of bouquets can be rearranged to form each other. Args: test_cases (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings representing the bouquets. Returns: List[str]: A list of strings, each being \\"YES\\" if the bouquets can be rearranged to form each other, otherwise \\"NO\\". Examples: >>> can_rearrange_bouquets([(\\"rose\\", \\"sore\\"), (\\"lily\\", \\"ylli\\"), (\\"tulip\\", \\"tulips\\")]) ['YES', 'YES', 'NO'] >>> can_rearrange_bouquets([(\\"daisy\\", \\"daisy\\"), (\\"sunflower\\", \\"roses\\")]) ['YES', 'NO']","solution":"def can_rearrange_bouquets(test_cases): results = [] for A, B in test_cases: if sorted(A) == sorted(B): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def find_shortest_route(N: int, travel_times: List[List[int]]) -> int: Determine the shortest possible total travel time for the delivery van to complete its route. >>> find_shortest_route(3, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> find_shortest_route(4, [[0, 29, 20, 21, 15], [29, 0, 15, 17, 12], [20, 15, 0, 28, 10], [21, 17, 28, 0, 18], [15, 12, 10, 18, 0]]) 78 >>> find_shortest_route(1, [[0, 5], [5, 0]]) 10 >>> find_shortest_route(2, [[0, 4, 6], [4, 0, 8], [6, 8, 0]]) 18 >>> find_shortest_route(3, [[0, 999, 999, 999], [999, 0, 999, 999], [999, 999, 0, 999], [999, 999, 999, 0]]) 3996","solution":"from itertools import permutations def calculate_travel_time(route, travel_times): total_time = 0 for i in range(len(route) - 1): total_time += travel_times[route[i]][route[i + 1]] total_time += travel_times[route[-1]][route[0]] # returning to the warehouse return total_time def find_shortest_route(N, travel_times): # Generate all possible routes starting and ending at the warehouse (0) locations = list(range(1, N + 1)) all_routes = permutations(locations) min_time = float('inf') for route in all_routes: route = (0,) + route + (0,) travel_time = calculate_travel_time(route, travel_times) if travel_time < min_time: min_time = travel_time return min_time"},{"question":"def max_average_visitor_count(t: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[float]: Calculates the maximum average number of visitors over any window of size K within the dataset for each test case. >>> t = 2 >>> cases = [((5, 2), [1, 2, 3, 4, 5]), ((7, 3), [5, 1, 2, 6, 4, 9, 3])] >>> max_average_visitor_count(t, cases) [4.5, 6.333333333333333] >>> t = 1 >>> cases = [((5, 2), [0, 0, 0, 0, 0])] >>> max_average_visitor_count(t, cases) [0.0] >>> t = 1 >>> cases = [((1, 1), [10])] >>> max_average_visitor_count(t, cases) [10.0] >>> t = 1 >>> cases = [((5, 5), [1, 2, 3, 4, 5])] >>> max_average_visitor_count(t, cases) [3.0] >>> t = 1 >>> cases = [((4, 1), [1, 2, 3, 4])] >>> max_average_visitor_count(t, cases) [4.0]","solution":"def max_average_visitor_count(t, cases): results = [] for i in range(t): D, K = cases[i][0] visitors = cases[i][1] max_avg = sum(visitors[:K]) / K current_sum = sum(visitors[:K]) for j in range(1, D - K + 1): current_sum = current_sum - visitors[j - 1] + visitors[j + K - 1] current_avg = current_sum / K if current_avg > max_avg: max_avg = current_avg results.append(max_avg) return results"},{"question":"def max_invert_length(test_cases: List[Dict[str, Union[int, List[int]]]]) -> List[int]: Given a list of test cases, each containing an array of integers, find the maximum length of a contiguous subarray which, when inverted, becomes sorted in increasing order. Parameters: test_cases (list): A list where each element is a dictionary with keys 'n' (length of array) and 'arr' (the array of integers). Returns: list: A list of integers where each integer is the result for the respective test case. >>> max_invert_length([{'n': 5, 'arr': [4, 3, 2, 1, 5]}]) == [4] >>> max_invert_length([{'n': 6, 'arr': [7, 6, 5, 4, 3, 2]}]) == [6] >>> max_invert_length([{'n': 3, 'arr': [1, 5, 3]}]) == [2] >>> max_invert_length([{'n': 4, 'arr': [10, 20, 30, 40]}]) == [1] >>> max_invert_length([{'n': 5, 'arr': [4, 3, 2, 1, 5]}, {'n': 6, 'arr': [7, 6, 5, 4, 3, 2]}, {'n': 3, 'arr': [1, 5, 3]}, {'n': 4, 'arr': [10, 20, 30, 40]}]) == [4, 6, 2, 1] pass","solution":"def max_invert_length(test_cases): Given a list of test cases, each containing an array of integers, find the maximum length of a contiguous subarray which, when inverted, becomes sorted in increasing order. Parameters: test_cases (list): A list where each element is a dictionary with keys 'n' (length of array) and 'arr' (the array of integers). Returns: list: A list of integers where each integer is the result for the respective test case. results = [] for case in test_cases: n = case['n'] arr = case['arr'] max_len = 1 current_len = 1 for i in range(1, n): if arr[i] <= arr[i-1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 results.append(max_len) return results"},{"question":"def longest_common_prefix(strings): Find the longest common prefix string amongst an array of strings. # YOUR CODE HERE def find_longest_common_prefix_for_identifier(test_cases): results = [] for case in test_cases: N, entries, identifier_query = case strings = [entry[1] for entry in entries if entry[0] == identifier_query] longest_prefix = longest_common_prefix(strings) results.append(longest_prefix) return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) entries = [] for i in range(1, N + 1): identifier, string = lines[idx + i].split() entries.append((identifier, string)) identifier_query = lines[idx + N + 1] test_cases.append((N, entries, identifier_query)) idx += N + 2 return test_cases def main(input_data): test_cases = process_input(input_data) results = find_longest_common_prefix_for_identifier(test_cases) return \\"n\\".join(results) # Tests def test_main(): input_data = 2 4 id1 banana id1 bandana id2 candy id1 banner id1 3 id3 apple id3 apricot id3 avocado id3 expected_output = ban a assert main(input_data) == expected_output def test_no_common_prefix(): input_data = 1 3 id1 dog id1 cat id1 mouse id1 expected_output = \\"\\" assert main(input_data) == expected_output def test_single_entry(): input_data = 1 1 id1 singular id1 expected_output = \\"singular\\" assert main(input_data) == expected_output def test_no_strings_with_identifier(): input_data = 1 2 id1 example id2 different id3 expected_output = \\"\\" assert main(input_data) == expected_output def test_multiple_prefix_entries(): input_data = 1 4 id1 abcdef id1 abc id1 abcd id1 abcxyz id1 expected_output = \\"abc\\" assert main(input_data) == expected_output if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def longest_common_prefix(strings): Find the longest common prefix string amongst an array of strings. if not strings: return \\"\\" prefix = strings[0] for string in strings[1:]: while not string.startswith(prefix): prefix = prefix[:-1] if prefix == \\"\\": return \\"\\" return prefix def find_longest_common_prefix_for_identifier(test_cases): results = [] for case in test_cases: N, entries, identifier_query = case strings = [entry[1] for entry in entries if entry[0] == identifier_query] longest_prefix = longest_common_prefix(strings) results.append(longest_prefix) return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) entries = [] for i in range(1, N + 1): identifier, string = lines[idx + i].split() entries.append((identifier, string)) identifier_query = lines[idx + N + 1] test_cases.append((N, entries, identifier_query)) idx += N + 2 return test_cases def main(input_data): test_cases = process_input(input_data) results = find_longest_common_prefix_for_identifier(test_cases) return \\"n\\".join(results)"},{"question":"def max_value_truck(capacity, items): Returns the maximum total value the truck can carry without exceeding its capacity. Parameters: capacity (int): The maximum capacity of the truck. items (list of tuples): Each tuple contains (weight, value) of an item. Returns: int: The maximum total value. >>> max_value_truck(4, [(2, 3), (1, 2), (3, 4)]) 6 >>> max_value_truck(10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90 >>> max_value_truck(10, []) 0 >>> max_value_truck(1, [(2, 3), (3, 4)]) 0 >>> max_value_truck(10, [(10, 100)]) 100 >>> max_value_truck(5, [(10, 100)]) 0 >>> max_value_truck(5, [(1, 1), (1, 1), (1, 1), (1, 1), (5, 10)]) 10 >>> max_value_truck(5, [(5, 10), (1, 1), (1, 1), (1, 1), (1, 1)]) 10","solution":"def max_value_truck(capacity, items): Returns the maximum total value the truck can carry without exceeding its capacity. Parameters: capacity (int): The maximum capacity of the truck. items (list of tuples): Each tuple contains (weight, value) of an item. Returns: int: The maximum total value. # Initialize DP table dp = [0] * (capacity + 1) # Iterate through all items for weight, value in items: # Update the dp table in reverse order to avoid recomputation for current_capacity in range(capacity, weight - 1, -1): dp[current_capacity] = max(dp[current_capacity], dp[current_capacity - weight] + value) return dp[capacity] # Example usage: # capacity = 4 # items = [(2, 3), (1, 2), (3, 4)] # print(max_value_truck(capacity, items)) # Output: 6"},{"question":"from typing import List, Tuple def min_operations_to_equalize(test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, find the minimum number of operations needed to make all integers in the list equal. >>> min_operations_to_equalize([(3, [1, 2, 3])]) [3] >>> min_operations_to_equalize([(4, [4, 4, 4, 4])]) [0] >>> min_operations_to_equalize([(5, [10, 10, 10, 1, 2])]) [28] >>> min_operations_to_equalize([ ... (3, [1, 2, 3]), ... (4, [4, 4, 4, 4]), ... (5, [10, 10, 10, 1, 2]) ... ]) [3, 0, 28]","solution":"def min_operations_to_equalize(test_cases): results = [] for case in test_cases: n, arr = case min_val = min(arr) operations = sum(a - min_val for a in arr) results.append(operations) return results"},{"question":"from typing import List, Tuple def expand_abbreviations(abbreviations: List[Tuple[str, str]], text: List[str]) -> List[str]: Expands abbreviations in the given text based on the provided dictionary of abbreviations. Args: - abbreviations (list of tuples): Each tuple contains an abbreviation and its full form. - text (list of strings): Lines of text which may contain abbreviations. Returns: - list of strings: Text with all abbreviations expanded to their full forms. >>> abbrs = [(\\"Dr\\", \\"Doctor\\"), (\\"St\\", \\"Street\\"), (\\"Mr\\", \\"Mister\\")] >>> text = [ ... \\"Dr Smith lives on St. Patrick's St.\\", ... \\"Mr Johnson is their neighbor.\\" ... ] >>> expand_abbreviations(abbrs, text) ['Doctor Smith lives on Street. Patrick's Street.', 'Mister Johnson is their neighbor.'] import re def test_expand_single_abbr(): abbrs = [(\\"Dr\\", \\"Doctor\\")] text = [\\"Dr Smith was here.\\"] expected = [\\"Doctor Smith was here.\\"] assert expand_abbreviations(abbrs, text) == expected def test_expand_multiple_abbr(): abbrs = [(\\"Dr\\", \\"Doctor\\"), (\\"St\\", \\"Street\\"), (\\"Mr\\", \\"Mister\\")] text = [ \\"Dr Smith lives on St. Patrick's St.\\", \\"Mr Johnson is their neighbor.\\" ] expected = [ \\"Doctor Smith lives on Street. Patrick's Street.\\", \\"Mister Johnson is their neighbor.\\" ] assert expand_abbreviations(abbrs, text) == expected def test_abbr_with_punctuation(): abbrs = [(\\"Mr\\", \\"Mister\\"), (\\"Dr\\", \\"Doctor\\")] text = [\\"Hello, Mr. Smith! How is Dr. Brown?\\"] expected = [\\"Hello, Mister. Smith! How is Doctor. Brown?\\"] assert expand_abbreviations(abbrs, text) == expected def test_expand_nonexistent_abbr(): abbrs = [(\\"Dr\\", \\"Doctor\\")] text = [\\"Mrs Smith was here.\\"] expected = [\\"Mrs Smith was here.\\"] assert expand_abbreviations(abbrs, text) == expected def test_expand_case_sensitive(): abbrs = [(\\"Dr\\", \\"Doctor\\")] text = [\\"dr smith is here.\\", \\"Dr Smith is here.\\"] expected = [\\"dr smith is here.\\", \\"Doctor Smith is here.\\"] assert expand_abbreviations(abbrs, text) == expected","solution":"import re def expand_abbreviations(abbreviations, text): Expands abbreviations in the given text based on the provided dictionary of abbreviations. Args: - abbreviations (list of tuples): Each tuple contains an abbreviation and its full form. - text (list of strings): Lines of text which may contain abbreviations. Returns: - list of strings: Text with all abbreviations expanded to their full forms. # Create a dictionary from the list of tuples for quick lookup abbr_dict = dict(abbreviations) # Process each line of the text expanded_text = [] for line in text: expanded_line = line for abbr, full_form in abbr_dict.items(): pattern = r'b' + re.escape(abbr) + r'b' expanded_line = re.sub(pattern, full_form, expanded_line) expanded_text.append(expanded_line) return expanded_text"},{"question":"import heapq from typing import List, Tuple def min_magical_resistances(N: int, M: int, connections: List[Tuple[int, int, int]]) -> List[int]: Computes the minimum possible magical resistance to reach each cave from cave 1. Args: N : int : number of caves M : int : number of connections connections : list of tuples : connections described by (u, v, w) Returns: list : minimum resistance to each cave >>> min_magical_resistances(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 2), (2, 5, 7), (4, 5, 3)]) [0, 2, 3, 5, 8] >>> min_magical_resistances(2, 1, [(1, 2, 5)]) [0, 5] >>> min_magical_resistances(2, 0, []) [0, -1] >>> min_magical_resistances(3, 3, [(1, 2, 1), (1, 3, 4), (2, 3, 2)]) [0, 1, 3] >>> min_magical_resistances(4, 4, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 4, 10)]) [0, 2, 4, 6] pass","solution":"import heapq def min_magical_resistances(N, M, connections): Computes the minimum possible magical resistance to reach each cave from cave 1. Args: N : int : number of caves M : int : number of connections connections : list of tuples : connections described by (u, v, w) Returns: list : minimum resistance to each cave # Initialize adjacency list graph = {i: [] for i in range(1, N+1)} for u, v, w in connections: graph[u].append((w, v)) graph[v].append((w, u)) # Initialize distances and priority queue distances = {i: float('inf') for i in range(1, N+1)} distances[1] = 0 pq = [(0, 1)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for weight, neighbor in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) result = [] for i in range(1, N+1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"def find_intersection(a1, b1, a2, b2): Finds the intersection of two intervals [a1, b1] and [a2, b2]. Returns the intersection as a tuple (start, end) if they intersect, or \\"NO\\" if they do not. # Your code here def process_test_cases(t, test_cases): Processes multiple test cases to find interval intersections. Args: t : int - Number of test cases. test_cases : List[Tuple[int, int, int, int]] - List containing the intervals for each test case. Returns: List[Union[Tuple[int, int], str]]: A list containing the results of each test case. # Your code here # Unit test def test_find_intersection(): assert find_intersection(1, 5, 2, 6) == (2, 5) assert find_intersection(1, 2, 3, 4) == \\"NO\\" assert find_intersection(5, 7, 1, 6) == (5, 6) assert find_intersection(2, 5, 5, 10) == (5, 5) assert find_intersection(1, 3, 3, 5) == (3, 3) assert find_intersection(6, 8, 1, 5) == \\"NO\\" def test_process_test_cases(): test_cases = [ (1, 5, 2, 6), (1, 2, 3, 4), (5, 7, 1, 6), (2, 5, 5, 10) ] assert process_test_cases(4, test_cases) == [(2, 5), \\"NO\\", (5, 6), (5, 5)] test_cases = [ (1, 3, 3, 5), (6, 8, 1, 5) ] assert process_test_cases(2, test_cases) == [(3, 3), \\"NO\\"] def test_edge_cases(): assert find_intersection(1, 1, 1, 1) == (1, 1) # Overlapping single point assert find_intersection(1, 10**9, 1, 10**9) == (1, 10**9) # Full overlap assert find_intersection(1, 5, 6, 10**9) == \\"NO\\" # No overlap","solution":"def find_intersection(a1, b1, a2, b2): Finds the intersection of two intervals [a1, b1] and [a2, b2]. Returns the intersection as a tuple (start, end) if they intersect, or \\"NO\\" if they do not. start = max(a1, a2) end = min(b1, b2) if start <= end: return (start, end) else: return \\"NO\\" def process_test_cases(t, test_cases): results = [] for i in range(t): a1, b1, a2, b2 = test_cases[i] result = find_intersection(a1, b1, a2, b2) results.append(result) return results"},{"question":"from typing import List def rearrange_string(s: str) -> str: Checks if the string can be rearranged to form two identical substrings of equal length. If possible, returns one such rearrangement. Otherwise, returns \\"IMPOSSIBLE\\". >>> rearrange_string(\\"aabbcc\\") 'abcabc' >>> rearrange_string(\\"aabbccddeeff\\") 'abcdefabcdef' >>> rearrange_string(\\"abab\\") 'abab' >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"abcabcabc\\") 'IMPOSSIBLE' >>> rearrange_string(\\"abc\\") 'IMPOSSIBLE' >>> rearrange_string(\\"aabbcd\\") 'IMPOSSIBLE' >>> rearrange_string(\\"abcd\\") 'IMPOSSIBLE' >>> rearrange_string(\\"a\\") 'IMPOSSIBLE' >>> rearrange_string(\\"aa\\") 'aa' >>> rearrange_string(\\"ab\\") 'IMPOSSIBLE'","solution":"from collections import Counter def rearrange_string(s): Checks if the string can be rearranged to form two identical substrings of equal length. If possible, returns one such rearrangement. Otherwise, returns \\"IMPOSSIBLE\\". if len(s) % 2 != 0: return \\"IMPOSSIBLE\\" count = Counter(s) half_length = len(s) // 2 for char in count: if count[char] % 2 != 0: return \\"IMPOSSIBLE\\" result = [] for char in count: result.extend([char] * (count[char] // 2)) return ''.join(result) * 2"},{"question":"def can_transform_by_reversing_subsegments(s1: str, s2: str) -> str: Determines if the first string can be transformed into the second string by reversing any number (including zero) of subsegments. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: str: \\"YES\\" if s1 can be transformed into s2, otherwise \\"NO\\".","solution":"def can_transform_by_reversing_subsegments(s1, s2): Determines if the first string can be transformed into the second string by reversing any number (including zero) of subsegments. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: str: \\"YES\\" if s1 can be transformed into s2, otherwise \\"NO\\". if sorted(s1) == sorted(s2): return \\"YES\\" else: return \\"NO\\""},{"question":"def rearrange_string(s: str) -> str: Rearrange the string such that no two adjacent characters are the same. If no such rearrangement is possible, return an empty string. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") '' pass # Test cases def test_rearrange_string_common_cases(): assert rearrange_string(\\"aab\\") in [\\"aba\\"] assert rearrange_string(\\"aaab\\") == \\"\\" assert rearrange_string(\\"baaba\\") in [\\"ababa\\", \\"abbaa\\", \\"baaba\\"] def test_rearrange_string_single_char(): assert rearrange_string(\\"z\\") == \\"z\\" assert rearrange_string(\\"aaa\\") == \\"\\" def test_rearrange_string_empty_string(): assert rearrange_string(\\"\\") == \\"\\" def test_rearrange_string_long_input(): s = \\"a\\" * (10**6 // 2) + \\"b\\" * (10**6 // 2) result = rearrange_string(s) assert result.count(\\"a\\") == 10**6 // 2 assert result.count(\\"b\\") == 10**6 // 2 for i in range(len(result) - 1): assert result[i] != result[i + 1] def test_rearrange_string_balanced_input(): s = \\"abcabc\\" result = rearrange_string(s) # check that frequencies match assert all(result.count(c) == s.count(c) for c in set(s)) # check that no two adjacent chars are the same for i in range(len(result) - 1): assert result[i] != result[i + 1]","solution":"import heapq from collections import Counter def rearrange_string(s: str) -> str: if not s: return \\"\\" # Count the frequency of each character char_count = Counter(s) # Create a max heap based on character frequencies max_heap = [] for char, freq in char_count.items(): heapq.heappush(max_heap, (-freq, char)) # push negative frequency to create a max-heap # Result list to store the eventual rearranged string result = [] # Previous character and frequency prev_freq, prev_char = 0, '' while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If there was a previous character, push it back into the heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update previous character and frequency prev_freq, prev_char = freq + 1, char # Increment frequency (since it's negative, add 1) # Join the list into a string rearranged = ''.join(result) # Check if the rearranged string's length matches the original string if len(rearranged) != len(s): return \\"\\" return rearranged"},{"question":"def smallest_int_with_product(N: int) -> int: Returns the smallest positive integer M such that the product of digits of M is equal to N. If no such M exists, returns -1. >>> smallest_int_with_product(10) == 25 >>> smallest_int_with_product(17) == -1 >>> smallest_int_with_product(1) == 1 >>> smallest_int_with_product(36) == 49 # 7*7 >>> smallest_int_with_product(512) == 888 # 8*8*8","solution":"def smallest_int_with_product(N): Returns the smallest positive integer M such that the product of digits of M is equal to N. If no such M exists, returns -1. if N == 1: return 1 # The smallest product of digits to get 1 is the number 1 itself. if N < 10: return N # For single-digit product, the number itself is the smallest. # To find the smallest number with the same product of digits: factors = [] for d in range(9, 1, -1): while N % d == 0: factors.append(d) N //= d if N != 1: return -1 # No valid factors found, return -1. factors.sort() M = int(''.join(map(str, factors))) return M"},{"question":"from typing import List, Tuple def solution(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: A group of adventurers is planning a journey through a series of caves. The caves are connected by one-way tunnels, and each tunnel has a certain travel cost. The adventurers want to determine if it is possible to travel from the entrance of the cave system to the treasure located deep inside, and if so, what is the minimum travel cost. The cave system can be represented as a directed graph, where nodes represent caves, and edges represent tunnels with associated travel costs. The entrance is always node 1, and the treasure is always node N (the highest numbered node). Your task is to determine the minimum cost to travel from cave 1 to cave N. If it is impossible to reach cave N from cave 1, return -1. --------- Input: --------- T: int - Number of test cases test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]] - Test cases. Each test case is a tuple where: - First element is N, the number of caves (nodes) - Second element is M, the number of tunnels (edges) - Third element is a list of tuples, each containing three integers u, v, w representing a tunnel from cave u to cave v with a travel cost of w. --------- Output: --------- A list of integers representing the minimum travel cost from cave 1 to cave N for each test case. If there is no path, output -1. --------- Example: --------- >>> solution(2, [(5, 6, [(1, 2, 2), (1, 3, 3), (2, 4, 1), (3, 4, 1), (4, 5, 4), (3, 5, 2)]), (4, 3, [(1, 2, 3), (1, 3, 5), (2, 4, 1), (3, 4, 2)])]) [5, 4] >>> solution(1, [(3, 2, [(1, 2, 1), (2, 3, 2)])]) [3] >>> solution(1, [(4, 2, [(1, 2, 1), (2, 3, 2)])]) [-1] pass # implement this function def test_solution(): # Test case 1 T = 2 test_cases = [ (5, 6, [ (1, 2, 2), (1, 3, 3), (2, 4, 1), (3, 4, 1), (4, 5, 4), (3, 5, 2) ]), (4, 3, [ (1, 2, 3), (1, 3, 5), (2, 4, 1), (3, 4, 2) ]) ] expected_results = [5, 4] assert solution(T, test_cases) == expected_results def test_no_path(): # Test case where no path exists T = 1 test_cases = [ (3, 2, [ (1, 2, 1), (2, 3, 2) ]) ] expected_results = [3] assert solution(T, test_cases) == expected_results def test_unreachable_node(): # A test case where the treasure cave is unreachable T = 1 test_cases = [ (4, 2, [ (1, 2, 1), (2, 3, 2) ]) ] expected_results = [-1] assert solution(T, test_cases) == expected_results","solution":"import heapq def find_min_travel_cost(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] M = test_cases[t][1] edges = test_cases[t][2] adjacency_list = [[] for _ in range(N+1)] for u, v, w in edges: adjacency_list[u].append((v, w)) min_cost = dijkstra(N, adjacency_list) results.append(min_cost) return results def dijkstra(N, adjacency_list): min_heap = [(0, 1)] distances = [float('inf')] * (N+1) distances[1] = 0 while min_heap: current_cost, u = heapq.heappop(min_heap) if u == N: return current_cost for v, travel_cost in adjacency_list[u]: new_cost = current_cost + travel_cost if new_cost < distances[v]: distances[v] = new_cost heapq.heappush(min_heap, (new_cost, v)) return -1 # Implementation for the provided input format def solution(T, test_cases): return find_min_travel_cost(T, test_cases)"},{"question":"def count_month_occurrences(dates): Given a list of dates in \\"YYYY-MM-DD\\" format, return a dictionary where the keys are the months written as two-digit strings, and the values are the number of occurrences of that particular month. >>> count_month_occurrences([\\"2022-03-15\\"]) {\\"03\\": 1} >>> count_month_occurrences([\\"2022-03-15\\", \\"2022-03-20\\", \\"2022-03-25\\"]) {\\"03\\": 3} >>> count_month_occurrences([\\"2022-03-15\\", \\"2022-04-20\\", \\"2022-05-25\\"]) {\\"03\\": 1, \\"04\\": 1, \\"05\\": 1} >>> count_month_occurrences([\\"2022-03-15\\", \\"2022-03-20\\", \\"2022-04-25\\", \\"2022-04-05\\"]) {\\"03\\": 2, \\"04\\": 2} >>> count_month_occurrences([ \\"2022-01-15\\", \\"2022-02-15\\", \\"2022-03-15\\", \\"2022-04-15\\", \\"2022-05-15\\", \\"2022-06-15\\", \\"2022-07-15\\", \\"2022-08-15\\", \\"2022-09-15\\", \\"2022-10-15\\", \\"2022-11-15\\", \\"2022-12-15\\" ]) { \\"01\\": 1, \\"02\\": 1, \\"03\\": 1, \\"04\\": 1, \\"05\\": 1, \\"06\\": 1, \\"07\\": 1, \\"08\\": 1, \\"09\\": 1, \\"10\\": 1, \\"11\\": 1, \\"12\\": 1 }","solution":"def count_month_occurrences(dates): Given a list of dates in \\"YYYY-MM-DD\\" format, return a dictionary where the keys are the months written as two-digit strings, and the values are the number of occurrences of that particular month. month_count = {} for date in dates: month = date[5:7] # Extracting the month part from the date string if month in month_count: month_count[month] += 1 else: month_count[month] = 1 return month_count"},{"question":"def minimized_sum_of_max_elements(n: int, k: int, array: List[int]) -> int: Returns the minimized sum of the maximum values of k contiguous subarrays after rearranging the elements of the given array. Args: n : int : the length of the array k : int : the number of subarrays array : List[int] : the elements of the array Returns: int : the minimized sum of the maximum values of the k contiguous subarrays Example: >>> minimized_sum_of_max_elements(7, 3, [4, 2, 1, 10, 5, 8, 6]) 24 >>> minimized_sum_of_max_elements(1, 1, [5]) 5 from typing import List def test_example(): assert minimized_sum_of_max_elements(7, 3, [4, 2, 1, 10, 5, 8, 6]) == 24 def test_single_element(): assert minimized_sum_of_max_elements(1, 1, [5]) == 5 def test_all_same_elements(): assert minimized_sum_of_max_elements(5, 2, [7, 7, 7, 7, 7]) == 14 def test_k_greater_than_one(): assert minimized_sum_of_max_elements(5, 4, [1, 2, 3, 4, 5]) == 14 # Just as an example with max elements being [2,3,4,5] def test_larger_values(): assert minimized_sum_of_max_elements(6, 3, [100, 200, 300, 400, 500, 600]) == 1500 def test_large_array(): array = list(range(1, 100001)) assert minimized_sum_of_max_elements(100000, 1, array) == 100000 def test_k_equals_n(): assert minimized_sum_of_max_elements(4, 4, [4, 3, 2, 1]) == 10","solution":"def minimized_sum_of_max_elements(n, k, array): Returns the minimized sum of the maximum values of k contiguous subarrays after rearranging the elements of the given array. # Sort the array in ascending order array.sort() # To minimize the sum of maximum values in k subarrays, we can: # Split the sorted array into k subarrays sum_max = 0 for i in range(k): # Consider the largest remaining elements for each subarray sum_max += array[n - 1 - i] return sum_max"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. # TODO: Implement this function def prime_game_winner(prime_numbers: List[int]) -> str: Determines the winner of the prime number game given a list of integers. John always starts first and both play optimally. # TODO: Implement this function def prime_game(test_cases: List[str]) -> List[str]: Processes multiple test cases to determine the winner for each. :param test_cases: List of strings where each string contains space-separated integers. :return: List of results, either \\"John\\" or \\"Opponent\\" for each test case. # TODO: Implement this function # Test cases def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(11) == True assert is_prime(15) == False assert is_prime(1) == False assert is_prime(0) == False assert is_prime(-7) == False def test_prime_game_winner(): assert prime_game_winner([2, 3, 4, 5, 6]) == \\"John\\" assert prime_game_winner([13, 11, 17, 19, 23, 29, 31, 37, 41, 43, 47]) == \\"John\\" assert prime_game_winner([4, 6, 8, 9, 10]) == \\"Opponent\\" assert prime_game_winner([2, 3, 5, 7]) == \\"Opponent\\" assert prime_game_winner([31, 37, 41, 43, 47, 53, 59]) == \\"John\\" assert prime_game_winner([12, 18, 20, 22, 25]) == \\"Opponent\\" def test_prime_game(): test_cases = [ \\"2 3 4 5 6\\", # Expect \\"John\\" \\"13 11 17 19 23 29 31 37 41 43 47\\", # Expect \\"John\\" \\"4 6 8 9 10\\", # Expect \\"Opponent\\" \\"2 3 5 7\\", # Expect \\"Opponent\\" \\"31 37 41 43 47 53 59\\", # Expect \\"John\\" \\"12 18 20 22 25\\", # Expect \\"Opponent\\" ] expected = [\\"John\\", \\"John\\", \\"Opponent\\", \\"Opponent\\", \\"John\\", \\"Opponent\\"] assert prime_game(test_cases) == expected","solution":"def is_prime(n): Helper function to check if n is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def prime_game_winner(prime_numbers): Determines the winner of the prime number game given a list of integers. John always starts first and both play optimally. primes = [num for num in prime_numbers if is_prime(num)] prime_count = len(primes) if prime_count % 2 == 0: return \\"Opponent\\" else: return \\"John\\" def prime_game(test_cases): Processes multiple test cases to determine the winner for each. results = [] for case in test_cases: prime_numbers = list(map(int, case.split())) results.append(prime_game_winner(prime_numbers)) return results"},{"question":"def mars_resource_distribution(r, q, initial_resources, queries): Simulate the redistribution of resources across regions on a Martian base. Args: r (int): The number of regions. q (int): The number of queries. initial_resources (List[int]): The initial amounts of resources in each region. queries (List[List[int]]): Each query represented as a list of integers. Returns: List[int]: The results for each query of the second type. >>> mars_resource_distribution(5, 4, [10, 20, 30, 40, 50], [[1, 1, 3, 10], [2, 3], [2, 1], [1, 3, 5, 10]]) [40, 0] >>> mars_resource_distribution(2, 1, [10, 20], [[2, 1]]) [10] >>> mars_resource_distribution(2, 1, [10, 20], [[1, 1, 2, 5]]) []","solution":"def mars_resource_distribution(r, q, initial_resources, queries): resources = initial_resources[:] results = [] for query in queries: if query[0] == 1: start, end, amount = query[1] - 1, query[2] - 1, query[3] resources[start] -= amount resources[end] += amount elif query[0] == 2: region = query[1] - 1 results.append(resources[region]) return results"},{"question":"def max_items_produced(test_cases): Determine the maximum number of items that can be produced given the constraints of the shift time and production rate of each machine. >>> max_items_produced([ [(3, 30), (5, 1), (3, 2), (2, 5)], [(2, 60), (7, 3), (2, 5)] ]) [105, 14] >>> max_items_produced([ [(1, 10), (6, 2)] ]) [30]","solution":"def max_items_produced(test_cases): results = [] for case in test_cases: M, T = case[0] total_items = 0 for i in range(1, M + 1): p, t = case[i] if t > 0: total_items += (T // t) * p results.append(total_items) return results"},{"question":"def longestWord(text: str) -> str: Returns the longest word in a given string of text. If there are two or more words that are the same length, the first one encountered is returned. Punctuation is not counted as part of the word length. >>> longestWord(\\"The quick brown fox!\\") == \\"quick\\" >>> longestWord(\\"The quick brown fox jumps\\") == \\"quick\\" >>> longestWord(\\"This is an extraordinary example\\") == \\"extraordinary\\" >>> longestWord(\\"Hello, world!\\") == \\"Hello\\" >>> longestWord(\\"\\") == \\"\\" >>> longestWord(\\"a b c d\\") == \\"a\\" >>> longestWord(\\"one two six ten\\") == \\"one\\"","solution":"def longestWord(text): Returns the longest word in the given text. If there are multiple words with the same longest length, the first one encountered is returned. Punctuation is not counted as part of the word length. :param text: A string of text :return: The longest word in the text import re # Remove punctuation using regex sanitized_text = re.sub(r'[^ws]', '', text) # Split the sanitized text into words words = sanitized_text.split() # Initialize variable to keep track of the longest word longest = \\"\\" # Iterate through each word to find the longest for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"from typing import List, Tuple def find_path(maze: List[List[int]]) -> List[Tuple[int, int]]: Find the shortest path from the top-left corner to the bottom-right corner of the maze. Returns a list of (row, column) tuples representing the path. If no path exists, returns an empty list. Example: >>> find_path([[0]]) [(0, 0)] >>> find_path([[0, 0, 1], [1, 0, 0], [1, 1, 0]]) [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)] >>> find_path([[0, 1], [1, 0]]) [] >>> find_path([[0, 0, 0, 1], [0, 1, 0, 1], [0, 1, 0, 0], [1, 0, 0, 0]]) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (3, 3)] >>> find_path([[0, 0], [1, 0]]) [(0, 0), (0, 1), (1, 1)] >>> find_path([[0, 1, 1], [1, 1, 1], [1, 1, 0]]) []","solution":"from collections import deque def find_path(maze): Finds the shortest path from the top-left corner to the bottom-right corner of the maze. Returns a list of (row, column) tuples representing the path. If no path exists, returns an empty list. if not maze or not maze[0]: return [] rows, cols = len(maze), len(maze[0]) start, end = (0, 0), (rows-1, cols-1) # Check if start or end is a wall if maze[0][0] == 1 or maze[rows-1][cols-1] == 1: return [] # Directions for moving in the maze directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue for BFS queue = deque([(start, [start])]) visited = set([start]) while queue: (current, path) = queue.popleft() if current == end: return path for d in directions: next_row, next_col = current[0] + d[0], current[1] + d[1] if 0 <= next_row < rows and 0 <= next_col < cols and maze[next_row][next_col] == 0: next_pos = (next_row, next_col) if next_pos not in visited: visited.add(next_pos) queue.append((next_pos, path + [next_pos])) return []"},{"question":"def reverseArray(N, A): Reverses the array A and prints its elements in reversed order. Parameters: N (int): Size of the array A. A (list): A list of integers. pass # Unit tests from io import StringIO import sys def test_reverseArray_example_1(): A = [1, 2, 3, 4] N = 4 captured_output = StringIO() sys.stdout = captured_output reverseArray(N, A) sys.stdout = sys.__stdout__ assert captured_output.getvalue().strip() == \\"4 3 2 1\\" def test_reverseArray_example_2(): A = [10, 20, 30, 40, 50] N = 5 captured_output = StringIO() sys.stdout = captured_output reverseArray(N, A) sys.stdout = sys.__stdout__ assert captured_output.getvalue().strip() == \\"50 40 30 20 10\\" def test_reverseArray_single_element(): A = [1] N = 1 captured_output = StringIO() sys.stdout = captured_output reverseArray(N, A) sys.stdout = sys.__stdout__ assert captured_output.getvalue().strip() == \\"1\\" def test_reverseArray_large_input(): A = list(range(1, 100001)) N = 100000 captured_output = StringIO() sys.stdout = captured_output reverseArray(N, A) sys.stdout = sys.__stdout__ expected_output = \\" \\".join(map(str, range(100000, 0, -1))) assert captured_output.getvalue().strip() == expected_output","solution":"def reverseArray(N, A): Reverses the array A and prints its elements in reversed order. Parameters: N (int): Size of the array A. A (list): A list of integers. reversed_A = A[::-1] print(\\" \\".join(map(str, reversed_A)))"},{"question":"def min_max_sum(n: int, m: int, r: int) -> Tuple[int, int]: Determine the minimum and maximum possible sum of all elements in the grid after performing exactly r operations. >>> min_max_sum(2, 2, 1) (1, 4) >>> min_max_sum(2, 2, 3) (3, 12)","solution":"def min_max_sum(n, m, r): Returns the minimum and maximum possible sum of all elements in the grid after performing exactly r subgrid increment operations. # The minimum sum is achieved by incrementing the same cell r times min_sum = r # The maximum sum is achieved by incrementing all cells in the grid evenly r times # The operation affects all cells, so the sum is incremented r times for each cell max_sum = r * n * m return (min_sum, max_sum)"},{"question":"def is_subset_sum_possible(n, gold_coins, k): Determines if there is a subset of villagers' gold coins that sum up to exactly k coins. Args: n (int): Number of villagers. gold_coins (list of int): List of integers representing the number of gold coins each villager has. k (int): Exact amount of gold coins the dragon demands. Returns: str: \\"Possible\\" if there exists a subset of the villagers' gold coins that sums up to exactly k, otherwise \\"Impossible\\". # Example Test Cases def test_is_subset_sum_possible_case1(): assert is_subset_sum_possible(5, [3, 34, 4, 12, 5], 9) == \\"Possible\\" def test_is_subset_sum_possible_case2(): assert is_subset_sum_possible(4, [1, 2, 3, 8], 7) == \\"Impossible\\" def test_is_subset_sum_possible_case3(): assert is_subset_sum_possible(3, [2, 4, 6], 6) == \\"Possible\\" def test_is_subset_sum_possible_case4(): assert is_subset_sum_possible(3, [2, 4, 6], 5) == \\"Impossible\\" def test_is_subset_sum_possible_case5(): assert is_subset_sum_possible(1, [1], 1) == \\"Possible\\" def test_is_subset_sum_possible_case6(): assert is_subset_sum_possible(1, [1], 2) == \\"Impossible\\" # running individual test functions to verify correctness test_is_subset_sum_possible_case1() test_is_subset_sum_possible_case2() test_is_subset_sum_possible_case3() test_is_subset_sum_possible_case4() test_is_subset_sum_possible_case5() test_is_subset_sum_possible_case6()","solution":"def is_subset_sum_possible(n, gold_coins, k): Determines if there is a subset of villagers' gold coins that sum up to exactly k coins. Args: n (int): Number of villagers. gold_coins (list of int): List of integers representing the number of gold coins each villager has. k (int): Exact amount of gold coins the dragon demands. Returns: str: \\"Possible\\" if there exists a subset of the villagers' gold coins that sums up to exactly k, otherwise \\"Impossible\\". # Create a dp array initialized to False dp = [False] * (k + 1) dp[0] = True # sum of 0 is always possible for coin in gold_coins: # Traverse backwards to avoid recomputing dp array for the same coin for j in range(k, coin - 1, -1): dp[j] = dp[j] or dp[j - coin] return \\"Possible\\" if dp[k] else \\"Impossible\\" # Example Usage (uncomment to test): # if __name__ == \\"__main__\\": # n = 5 # gold_coins = [3, 34, 4, 12, 5] # k = 9 # print(is_subset_sum_possible(n, gold_coins, k)) # Should output: Possible # n = 4 # gold_coins = [1, 2, 3, 8] # k = 7 # print(is_subset_sum_possible(n, gold_coins, k)) # Should output: Impossible"},{"question":"def rob(nums: List[int]) -> int: Calculate the maximum amount of money you can steal tonight without alerting the police. You cannot steal from two consecutive houses. :param nums: List[int] - the amount of money in each house :return: int - maximum money you can steal >>> rob([2, 3, 2]) == 3 >>> rob([1, 2, 3, 1]) == 4 >>> rob([5]) == 5 >>> rob([2, 3]) == 3 >>> rob([2, 7, 9, 3, 1]) == 11 >>> rob([2, 1, 1, 2]) == 3","solution":"def rob(nums): Calculate the maximum amount of money you can steal tonight without alerting the police. You cannot steal from two consecutive houses. :param nums: List[int] - the amount of money in each house :return: int - maximum money you can steal if not nums: return 0 if len(nums) == 1: return nums[0] def rob_linear(houses): rob1, rob2 = 0, 0 for money in houses: new_rob = max(rob1 + money, rob2) rob1 = rob2 rob2 = new_rob return rob2 # Since this is a circular problem we have two cases: # 1. Include the first house and exclude the last house (nums[:-1]) # 2. Exclude the first house and include the last house (nums[1:]) return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def shortest_removable_substring_length(S: str) -> int: Given a string S, find the length of the shortest substring that can be removed such that the remaining string contains no two adjacent characters that are the same. >>> shortest_removable_substring_length(\\"aabcc\\") 2 >>> shortest_removable_substring_length(\\"aaa\\") 2 pass def solve(test_cases: list) -> list: Given a list of test cases, where each test case is a string, return a list of results for each test case. >>> solve([\\"aabcc\\", \\"aaa\\"]) [2, 2] >>> solve([\\"abcd\\", \\"abccba\\"]) [4, 2] pass","solution":"def shortest_removable_substring_length(S): Given a string S, find the length of the shortest substring that can be removed such that the remaining string contains no two adjacent characters that are the same. n = len(S) min_length = n for i in range(n - 1): if S[i] == S[i + 1]: min_length = 2 # The smallest required substring can have length 2 return min_length def solve(test_cases): results = [] for S in test_cases: results.append(shortest_removable_substring_length(S)) return results"},{"question":"def count_distinct_days(timestamps: List[str]) -> int: Given a list of timestamps, returns the total number of distinct days on which events occurred. Args: timestamps (list of str): List of timestamps in the format 'YYYY-MM-DD HH:MM:SS'. Returns: int: Number of distinct days with events. Examples: >>> count_distinct_days([\\"2023-04-15 12:34:56\\", \\"2023-04-15 15:45:12\\", \\"2023-04-16 08:00:00\\"]) 2 >>> count_distinct_days([\\"2023-01-01 00:00:01\\", \\"2023-01-01 23:59:59\\", \\"2023-12-31 12:34:56\\"]) 2 >>> count_distinct_days([\\"2023-05-05 05:05:05\\"]) 1 >>> count_distinct_days([]) 0 >>> count_distinct_days([\\"2023-10-10 10:10:10\\", \\"2023-10-10 22:22:22\\"]) 1 >>> count_distinct_days([\\"2023-01-01 01:01:01\\", \\"2023-02-01 02:02:02\\", \\"2023-03-01 03:03:03\\"]) 3","solution":"def count_distinct_days(timestamps): Given a list of timestamps, returns the total number of distinct days on which events occurred. Args: timestamps (list of str): List of timestamps in the format 'YYYY-MM-DD HH:MM:SS'. Returns: int: Number of distinct days with events. days = set() for timestamp in timestamps: date = timestamp.split()[0] days.add(date) return len(days)"},{"question":"def max_cash(cash: List[int]) -> int: Returns the maximum amount of cash that can be collected from any contiguous subsequence in the queue. Parameters: cash (list of int): Array containing the amount of cash each person has. Returns: int: Maximum amount of cash from any contiguous subsequence. >>> max_cash([1, 2, 3, 4, 5]) 15 >>> max_cash([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6","solution":"def max_cash(cash): Returns the maximum amount of cash that can be collected from any contiguous subsequence in the queue. Parameters: cash (list of int): Array containing the amount of cash each person has. Returns: int: Maximum amount of cash from any contiguous subsequence. max_so_far = float('-inf') max_ending_here = 0 for amount in cash: max_ending_here = max_ending_here + amount if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far"},{"question":"def min_path_sum(mat): Calculate the minimum path sum from the top-left to bottom-right corner of the matrix. Args: mat: List[List[int]] - 2D list of non-negative integers representing the input matrix. Returns: int - the minimum path sum. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3], [4, 5, 6]]) 12 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 99, 1], [1, 99, 1], [1, 1, 1]]) 5 >>> min_path_sum([[0,0,0],[0,0,0],[0,0,0]]) 0","solution":"def min_path_sum(mat): Calculate the minimum path sum from the top-left to bottom-right corner of the matrix. Args: mat: List[List[int]] - 2D list of non-negative integers representing the input matrix. Returns: int - the minimum path sum. n = len(mat) m = len(mat[0]) # Initialize a dp array with the same dimensions as mat dp = [[0] * m for _ in range(n)] # Set the initial value dp[0][0] = mat[0][0] # Fill the first row (can only come horizontally) for j in range(1, m): dp[0][j] = dp[0][j-1] + mat[0][j] # Fill the first column (can only come vertically) for i in range(1, n): dp[i][0] = dp[i-1][0] + mat[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[n-1][m-1]"},{"question":"def can_be_palindrome_by_one_transform(s: str) -> bool: Determines whether it is possible to make the given string a palindrome by performing at most one transformation. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if it is possible to make the string a palindrome by one transformation, otherwise False. Examples: >>> can_be_palindrome_by_one_transform(\\"abca\\") True >>> can_be_palindrome_by_one_transform(\\"racecar\\") True >>> can_be_palindrome_by_one_transform(\\"abcdef\\") False","solution":"def can_be_palindrome_by_one_transform(s): Determines whether it is possible to make the given string a palindrome by performing at most one transformation. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if it is possible to make the string a palindrome by one transformation, otherwise False. left, right = 0, len(s) - 1 mismatches = 0 while left < right: if s[left] != s[right]: mismatches += 1 if mismatches > 1: return False left += 1 right -= 1 return True"},{"question":"def convert_currency(yen_to_dollar, dollar_to_yen, queries): Implements a conversion tool for Yen to Dollar and Dollar to Yen conversions. Arguments: yen_to_dollar -- conversion rate from Yen to Dollar (float) dollar_to_yen -- conversion rate from Dollar to Yen (float) queries -- a list of queries in the format 'C amount', where 'C' is 'Y' or 'D' and 'amount' is a float Returns: A list of conversion results, rounded to 2 decimal places. >>> convert_currency(0.0091, 110.35, [\\"Y 1000\\", \\"D 50\\", \\"Y 2000\\"]) [9.10, 5517.50, 18.20] >>> convert_currency(0.0091, 110.35, [\\"D 100\\"]) [11035.00] >>> convert_currency(0.0091, 110.35, [\\"Y 0\\", \\"D 0\\"]) [0.00, 0.00]","solution":"def convert_currency(yen_to_dollar, dollar_to_yen, queries): results = [] for query in queries: type_conversion, amount = query.split() amount = float(amount) if type_conversion == 'Y': converted_amount = amount * yen_to_dollar elif type_conversion == 'D': converted_amount = amount * dollar_to_yen else: raise ValueError(\\"Invalid conversion type\\") results.append(round(converted_amount, 2)) return results"},{"question":"def sum_of_multiples(N: int) -> int: Returns the sum of all numbers between 1 and N (inclusive) that are multiples of either 3 or 5. >>> sum_of_multiples(10) 33 >>> sum_of_multiples(1) 0 >>> sum_of_multiples(20) 98","solution":"def sum_of_multiples(N): Returns the sum of all numbers between 1 and N (inclusive) that are multiples of either 3 or 5. return sum(i for i in range(1, N + 1) if i % 3 == 0 or i % 5 == 0)"},{"question":"def is_balanced(expression: str) -> str: Determines if the input string has balanced parentheses. Args: expression (str): The input string containing parentheses and other characters. Returns: str: \\"Yes\\" if the parentheses are balanced, \\"No\\" otherwise. Examples: >>> is_balanced(\\"a*(b+c)-{d/e}\\") \\"Yes\\" >>> is_balanced(\\"(a*[b-c]+{d/e}\\") \\"No\\" >>> is_balanced(\\"a*(b+c)]+{d/e}\\") \\"No\\" Test cases: assert is_balanced(\\"a*(b+c)-{d/e}\\") == \\"Yes\\" assert is_balanced(\\"(a*[b-c]+{d/e}\\") == \\"No\\" assert is_balanced(\\"a*(b+c)]+{d/e}\\") == \\"No\\" assert is_balanced(\\"\\") == \\"Yes\\" assert is_balanced(\\"(){}[]\\") == \\"Yes\\" assert is_balanced(\\"({[)})\\") == \\"No\\" assert is_balanced(\\"{[(a+b)*(c-d)]/e}\\") == \\"Yes\\" assert is_balanced(\\"{[(a+b)*(c-d])/e}\\") == \\"No\\"","solution":"def is_balanced(expression: str) -> str: Determines if the input string has balanced parentheses. Args: expression (str): The input string containing parentheses and other characters. Returns: str: \\"Yes\\" if the parentheses are balanced, \\"No\\" otherwise. stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in expression: if char in matching_parentheses.values(): # if it is one of '(', '{', '[' stack.append(char) elif char in matching_parentheses: # if it is one of ')', '}', ']' if not stack or stack[-1] != matching_parentheses[char]: return \\"No\\" stack.pop() return \\"Yes\\" if not stack else \\"No\\""},{"question":"def smallest_palindrome(n: int, s: str) -> str: Emma wants to replace each question mark in a string with a lowercase alphabet such that the final string is a palindrome. Return the lexicographically smallest palindrome possible, or -1 if impossible. >>> smallest_palindrome(5, 'a?b?a') 'aabaa' >>> smallest_palindrome(3, 'ab?') 'aba' >>> smallest_palindrome(4, 'ab??') 'abba' >>> smallest_palindrome(3, 'a?b') '-1'","solution":"def smallest_palindrome(n, s): s = list(s) # Convert string to a list for mutability left, right = 0, n - 1 while left <= right: if s[left] == s[right] == '?': s[left], s[right] = 'a', 'a' elif s[left] == '?': s[left] = s[right] elif s[right] == '?': s[right] = s[left] elif s[left] != s[right]: return \\"-1\\" left += 1 right -= 1 return \\"\\".join(s)"},{"question":"def find_minimum_sum_of_distances(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: For each test case, return the minimum sum of distances from each picture point to the nearest tree. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], List[int]]]): List of test cases, each containing: - The number of trees (N) - The number of points (M) - A list of integers representing the positions of the trees - A list of integers representing the points where pictures are to be taken Returns: List[int]: A list of integers representing the minimum sum of distances for each test case Example: >>> find_minimum_sum_of_distances(2, [(3, 2, [1, 5, 9], [2, 7]), (4, 3, [2, 6, 8, 10], [1, 12, 9])]) [3, 4]","solution":"def find_minimum_sum_of_distances(T, test_cases): results = [] for case in test_cases: N, M, trees, points = case trees.sort() distance_sum = 0 for point in points: left, right = 0, N - 1 while left < right: mid = (left + right) // 2 if trees[mid] < point: left = mid + 1 else: right = mid if left > 0 and abs(trees[left - 1] - point) < abs(trees[left] - point): left -= 1 distance_sum += abs(trees[left] - point) results.append(distance_sum) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N, M = map(int, lines[idx].split()) trees = list(map(int, lines[idx + 1].split())) points = list(map(int, lines[idx + 2].split())) test_cases.append((N, M, trees, points)) idx += 3 return T, test_cases def main(input_str): T, test_cases = parse_input(input_str) results = find_minimum_sum_of_distances(T, test_cases) for result in results: print(result)"},{"question":"def max_balanced_teams(p, q, r): Returns the maximum number of balanced teams that can be formed where each team consists of an equal number of males and females. :param p: Total number of participants :param q: Total number of males :param r: Total number of females :return: Maximum number of balanced teams >>> max_balanced_teams(12, 5, 7) 5 >>> max_balanced_teams(9, 10, 9) 9 >>> max_balanced_teams(1000000000, 500000000, 500000000) 500000000 >>> max_balanced_teams(100, 30, 70) 30","solution":"def max_balanced_teams(p, q, r): Returns the maximum number of balanced teams that can be formed where each team consists of an equal number of males and females. :param p: Total number of participants :param q: Total number of males :param r: Total number of females :return: Maximum number of balanced teams # The maximum number of balanced teams is determined by the minimum of q and r return min(q, r)"},{"question":"def find_combinations(lst, target): Finds all unique combinations of numbers in lst that sum up to the target. Args: lst: A list of distinct integers. target: An integer target sum. Returns: A list of lists, where each inner list represents a unique combination of numbers summing to the target. >>> find_combinations([2, 3, 6, 7], 7) [[7]] >>> find_combinations([2, 3, 5], 8) [[3, 5]] >>> find_combinations([2, 4, 6], 5) [] >>> find_combinations([1, 2, 3, 4, 5], 15) [[1, 2, 3, 4, 5]] >>> find_combinations([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3], [5]]","solution":"def find_combinations(lst, target): Finds all unique combinations of numbers in lst that sum up to the target. Args: lst: A list of distinct integers. target: An integer target sum. Returns: A list of lists, where each inner list represents a unique combination of numbers summing to the target. def backtrack(start, target, path, res): if target == 0: res.append(path) return if target < 0: return for i in range(start, len(lst)): backtrack(i + 1, target - lst[i], path + [lst[i]], res) result = [] backtrack(0, target, [], result) return result"},{"question":"def rearrange_string(s: str) -> str: Re-arrange the string such that no two adjacent characters are the same. If it's not possible, return an empty string. >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaab\\") == \\"\\" True >>> rearrange_string(\\"aabbbcc\\") != \\"\\" True pass Unit Test: def test_rearrange_string_valid(): assert rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] assert rearrange_string(\\"aabbbcc\\") != \\"\\" assert rearrange_string(\\"xxyz\\") in [\\"xyxz\\", \\"yxzx\\"] def test_rearrange_string_invalid(): assert rearrange_string(\\"aaab\\") == \\"\\" assert rearrange_string(\\"aaa\\") == \\"\\" def test_rearrange_string_edge_cases(): # Single character string assert rearrange_string(\\"a\\") == \\"a\\" # Two different characters assert rearrange_string(\\"ab\\") == \\"ab\\" or rearrange_string(\\"ab\\") == \\"ba\\" # String with more than one possible arrangement assert rearrange_string(\\"aabbcc\\") != \\"\\" result = rearrange_string(\\"aaabbbcc\\") assert result != \\"\\" and len(result) == 8 def test_rearrange_string_large_input(): long_input = \\"a\\" * 500 + \\"b\\" * 500 result = rearrange_string(long_input) assert result != \\"\\" and len(result) == 1000 # Ensure no two adjacent characters are the same for i in range(1, len(result)): assert result[i] != result[i-1]","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If it's not possible, returns an empty string. if not s: return \\"\\" # Count frequencies of each character freq = Counter(s) # Create a max heap with negative frequencies since heapq is a min heap by default max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = count + 1 else: return \\"\\" return \\"\\".join(result)"},{"question":"def can_be_majority(T, test_cases): Determine whether a specified integer can be the majority element in an array. A majority element is one that appears more than n/2 times in an array of size n. Parameters: T (int): Number of test cases test_cases (list): List of test case tuples where each tuple contains (n (int): size of the array, x (int): the integer to check for majority, arr (list): the list of integers representing the array) Returns: list: A list with \\"Yes\\" or \\"No\\" for each test case. results = [] for case in test_cases: n, x, arr = case # Implement the logic to check if x can be the majority element in arr pass return results def get_test_cases(input_lines): Parse the input data into the number of test cases and the test case details. Parameters: input_lines (str): The input data containing number of test cases, and test case details as per the provided format. Returns: tuple: A tuple containing T (int), the number of test cases, and a list of test case tuples as described in the can_be_majority docstring. lines = input_lines.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): n, x = map(int, lines[idx].split()) arr = list(map(int, lines[idx + 1].split())) test_cases.append((n, x, arr)) idx += 2 return T, test_cases # Sample usage if __name__ == \\"__main__\\": input_data = \\"2n5 3n1 2 3 3 3n4 2n1 2 2 3\\" T, test_cases = get_test_cases(input_data) results = can_be_majority(T, test_cases) for result in results: print(result)","solution":"def can_be_majority(T, test_cases): results = [] for i in range(T): n, x = test_cases[i][0], test_cases[i][1] arr = test_cases[i][2] x_count = arr.count(x) if x_count > n / 2: results.append(\\"Yes\\") else: results.append(\\"No\\") return results def get_test_cases(input_lines): lines = input_lines.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): n, x = map(int, lines[idx].split()) arr = list(map(int, lines[idx + 1].split())) test_cases.append((n, x, arr)) idx += 2 return T, test_cases"},{"question":"def longest_continuous_rainfall(days: int, rainfall: List[int]) -> int: Calculate the longest number of consecutive days with positive rainfall. >>> longest_continuous_rainfall(10, [0, 10, 20, 0, 5, 0, 0, 15, 30, 25]) 3 >>> longest_continuous_rainfall(7, [0, 0, 0, 0, 0, 0, 0]) 0 >>> longest_continuous_rainfall(5, [5, 5, 5, 5, 5]) 5 pass from typing import List def test_example1(): days = 10 rainfall = [0, 10, 20, 0, 5, 0, 0, 15, 30, 25] assert longest_continuous_rainfall(days, rainfall) == 3 def test_example2(): days = 7 rainfall = [0, 0, 0, 0, 0, 0, 0] assert longest_continuous_rainfall(days, rainfall) == 0 def test_example3(): days = 5 rainfall = [5, 5, 5, 5, 5] assert longest_continuous_rainfall(days, rainfall) == 5 def test_no_rainfall(): days = 4 rainfall = [0, 0, 0, 0] assert longest_continuous_rainfall(days, rainfall) == 0 def test_alternating_rainfall(): days = 6 rainfall = [10, 0, 10, 0, 10, 0] assert longest_continuous_rainfall(days, rainfall) == 1 def test_single_day_rainfall(): days = 1 rainfall = [5] assert longest_continuous_rainfall(days, rainfall) == 1 def test_decreasing_rain(): days = 6 rainfall = [6, 5, 4, 3, 2, 1] assert longest_continuous_rainfall(days, rainfall) == 6","solution":"def longest_continuous_rainfall(days, rainfall): max_count = 0 current_count = 0 for amount in rainfall: if amount > 0: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 return max_count"},{"question":"def max_level(x: int) -> int: Determines the maximum level a player can reach given the total XP \`x\`. >>> max_level(0) 1 >>> max_level(1) 2 >>> max_level(2) 2 >>> max_level(6) 3 >>> max_level(7) 4 >>> max_level(15) 5 >>> max_level(1000000000000) 40 >>> max_level(10**12) 40","solution":"def max_level(x): Determines the maximum level a player can reach given the total XP \`x\`. if x == 0: return 1 level = 1 required_xp = 0 while x >= required_xp: level += 1 required_xp += 2 ** (level - 2) return level - 1"},{"question":"def min_operations_to_all_ones(n: int, k: int) -> int: Returns the minimum number of operations needed to turn an n x k grid full of zeros into a grid full of ones. >>> min_operations_to_all_ones(2, 2) 1 >>> min_operations_to_all_ones(3, 3) 1 >>> min_operations_to_all_ones(2, 3) 1 >>> min_operations_to_all_ones(10, 10) 1 >>> min_operations_to_all_ones(1, 1) 1 >>> min_operations_to_all_ones(1000, 1000) 1","solution":"def min_operations_to_all_ones(n, k): Returns the minimum number of operations needed to turn an n x k grid full of zeros into a grid full of ones. # Regardless of the dimensions of the grid, selecting any single cell toggles the whole grid return 1"},{"question":"from typing import List, Tuple def count_unique_pairs(arr: List[int], target: int) -> int: Returns the number of unique pairs (a, b) in the array \`arr\` such that a + b equals the \`target\` sum. >>> count_unique_pairs([1, 5, 7, -1], 6) 2 >>> count_unique_pairs([10, 20, 30], 50) 1 pass def process_test_cases(test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Processes multiple test cases and returns a list of results where each result indicates the number of unique pairs that sum up to the target for each test case. >>> process_test_cases([(4, [1, 5, 7, -1], 6), (3, [10, 20, 30], 50)]) [2, 1] pass","solution":"def count_unique_pairs(arr, target): Returns the number of unique pairs (a, b) in the array \`arr\` such that a + b equals the \`target\` sum. seen = set() pairs = set() count = 0 for num in arr: if target - num in seen: if (num, target - num) not in pairs and (target - num, num) not in pairs: pairs.add((num, target - num)) count += 1 seen.add(num) return count def process_test_cases(test_cases): results = [] for test_case in test_cases: N, arr, K = test_case result = count_unique_pairs(arr, K) results.append(result) return results"},{"question":"def minimum_walls_to_reinforce(N, heights, H): Returns the minimum number of walls that need to be increased in height to be safe from the cannon. Parameters: N (int): The number of walls. heights (list): A list of integers representing the height of each wall. H (int): The maximum height that the cannon can destroy. Returns: int: The number of walls that need to be reinforced. def test_minimum_walls_to_reinforce_example_1(): assert minimum_walls_to_reinforce(5, [1, 2, 3, 4, 5], 3) == 3 def test_minimum_walls_to_reinforce_example_2(): assert minimum_walls_to_reinforce(4, [6, 7, 8, 9], 5) == 0 def test_minimum_walls_to_reinforce_all_same_height_below_H(): assert minimum_walls_to_reinforce(4, [1, 1, 1, 1], 2) == 4 def test_minimum_walls_to_reinforce_all_same_height_above_H(): assert minimum_walls_to_reinforce(4, [3, 3, 3, 3], 2) == 0 def test_minimum_walls_to_reinforce_mixed_heights(): assert minimum_walls_to_reinforce(6, [1, 3, 5, 7, 9, 11], 5) == 3 def test_minimum_walls_to_reinforce_edge_case(): assert minimum_walls_to_reinforce(1, [1], 1) == 1 assert minimum_walls_to_reinforce(1, [2], 1) == 0","solution":"def minimum_walls_to_reinforce(N, heights, H): Returns the minimum number of walls that need to be increased in height to be safe from the cannon. Parameters: N (int): The number of walls. heights (list): A list of integers representing the height of each wall. H (int): The maximum height that the cannon can destroy. Returns: int: The number of walls that need to be reinforced. count = 0 for height in heights: if height <= H: count += 1 return count"},{"question":"def earliest_negative_day(n: int, profits: List[int]) -> int: Identify the earliest day when cumulative profit becomes negative. Arguments: n -- number of days profits -- list of daily profits Returns: The earliest day when cumulative profit becomes negative, else -1 if it never becomes negative. Examples: >>> earliest_negative_day(7, [5, -4, -3, 2, 3, -1, -2]) 3 >>> earliest_negative_day(5, [4, 3, -1, -2, 1]) -1","solution":"def earliest_negative_day(n, profits): Identify the earliest day when cumulative profit becomes negative. Arguments: n -- number of days profits -- list of daily profits Returns: The earliest day when cumulative profit becomes negative, else -1 if it never becomes negative. cumulative_profit = 0 for day in range(n): cumulative_profit += profits[day] if cumulative_profit < 0: return day + 1 # day is 0-indexed, so we return day + 1 return -1 # Example usage # n = 7 # profits = [5, -4, -3, 2, 3, -1, -2] # print(earliest_negative_day(n, profits)) # Output: 3"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in s. >>> longest_palindromic_substring_length(\\"babad\\") == 3 >>> longest_palindromic_substring_length(\\"cbbd\\") == 2 def process_test_cases(T: int, cases: List[str]) -> List[int]: Process multiple test cases and return the results >>> process_test_cases(2, [\\"babad\\", \\"cbbd\\"]) == [3, 2] # Unit tests def test_single_character(): assert process_test_cases(1, [\\"a\\"]) == [1] assert process_test_cases(1, [\\"z\\"]) == [1] def test_two_character_palindrome(): assert process_test_cases(1, [\\"aa\\"]) == [2] assert process_test_cases(1, [\\"bb\\"]) == [2] def test_long_palindrome(): assert process_test_cases(1, [\\"babad\\"]) == [3] assert process_test_cases(1, [\\"cbbd\\"]) == [2] assert process_test_cases(1, [\\"forgeeksskeegfor\\"]) == [10] def test_non_palindromic_string(): assert process_test_cases(1, [\\"abcde\\"]) == [1] assert process_test_cases(1, [\\"xyz\\"]) == [1] def test_mixed_string(): assert process_test_cases(1, [\\"abbac\\"]) == [4] assert process_test_cases(1, [\\"racecar\\"]) == [7] assert process_test_cases(1, [\\"aabaa\\"]) == [5] def test_multiple_test_cases(): assert process_test_cases(2, [\\"abc\\", \\"kabcbak\\"]) == [1, 7] assert process_test_cases(3, [\\"abba\\", \\"abcd\\", \\"racecar\\"]) == [4, 1, 7]","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in s. n = len(s) if n == 0: return 0 # Create a DP table to store results of subproblems dp = [[False]*n for _ in range(n)] # All substrings of length 1 are palindromes max_length = 1 for i in range(n): dp[i][i] = True start = 0 # Check for sub-string of length 2. for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 # Check for lengths greater than 2. for k in range(3, n+1): # Fix the starting index for i in range(n-k+1): # Get the ending index of substring from starting index i and length k j = i + k - 1 # checking for sub-string from ith index to jth index # if s[i+1] to s[j-1] is a palindrome if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True if k > max_length: start = i max_length = k return max_length def process_test_cases(T, cases): results = [] for case in cases: results.append(longest_palindromic_substring_length(case)) return results"},{"question":"def sort_books_by_pages(test_cases): Given a list of test cases, each containing a number of books and their respective page counts, this function sorts the page counts in non-decreasing order while maintaining the relative order of equal elements. # Your implementation here def parse_input(input_str): Parses the input string and returns a list of test cases. # Your implementation here def format_output(results): Formats the output for the given sorted pages list to match the required output format. # Your implementation here # Test cases to validate the solution def test_sort_books_by_pages(): input_data = '3n5n100 300 200 100 400n4n500 100 100 200n6n50 40 50 30 20 50n' expected_output = '100 100 200 300 400n100 100 200 500n20 30 40 50 50 50' test_cases = parse_input(input_data) sorted_pages = sort_books_by_pages(test_cases) output = format_output(sorted_pages) assert output == expected_output def test_sort_books_single_case(): input_data = '1n3n10 5 15n' expected_output = '5 10 15' test_cases = parse_input(input_data) sorted_pages = sort_books_by_pages(test_cases) output = format_output(sorted_pages) assert output == expected_output def test_sort_books_all_same(): input_data = '1n5n7 7 7 7 7n' expected_output = '7 7 7 7 7' test_cases = parse_input(input_data) sorted_pages = sort_books_by_pages(test_cases) output = format_output(sorted_pages) assert output == expected_output def test_sort_books_already_sorted(): input_data = '1n4n1 2 3 4n' expected_output = '1 2 3 4' test_cases = parse_input(input_data) sorted_pages = sort_books_by_pages(test_cases) output = format_output(sorted_pages) assert output == expected_output def test_sort_books_reverse_sorted(): input_data = '1n4n4 3 2 1n' expected_output = '1 2 3 4' test_cases = parse_input(input_data) sorted_pages = sort_books_by_pages(test_cases) output = format_output(sorted_pages) assert output == expected_output","solution":"def sort_books_by_pages(test_cases): Given a list of test cases, each containing a number of books and their respective page counts, this function sorts the page counts in non-decreasing order while maintaining the relative order of equal elements. results = [] for pages in test_cases: sorted_pages = sorted(pages) results.append(sorted_pages) return results def parse_input(input_str): Parses the input string and returns a list of test cases. lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) pages = list(map(int, lines[index + 1].split())) test_cases.append(pages) index += 2 return test_cases def format_output(results): Formats the output for the given sorted pages list to match the required output format. return 'n'.join(' '.join(map(str, result)) for result in results)"},{"question":"from typing import List, Tuple def find(parent: List[int], i: int) -> int: Find the root of the element i in the union-find structure. >>> parent = [0, 1, 2, 3] >>> find(parent, 0) 0 >>> find(parent, 1) 1 pass def union(parent: List[int], rank: List[int], x: int, y: int): Perform union operation in the union-find structure. >>> parent = [0, 1, 2, 3] >>> rank = [0, 0, 0, 0] >>> union(parent, rank, 0, 1) >>> parent[1] == 0 True >>> find(parent, 0) == find(parent, 1) True pass def min_additional_links(N: int, connections: List[Tuple[int, int]]) -> int: Determine the minimum number of additional communication links required to ensure that the network remains connected if any single server goes down. >>> min_additional_links(4, [(1, 2), (2, 3), (3, 4)]) 0 >>> min_additional_links(4, [(1, 2), (2, 3)]) 1 >>> min_additional_links(4, []) 3 pass def process_test_cases(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Process multiple test cases and return the results. >>> test_cases = [ ... (4, 3, [(1, 2), (2, 3), (3, 4)]), ... (4, 2, [(1, 2), (2, 3)]), ... (4, 0, []) ... ] >>> process_test_cases(test_cases) [0, 1, 3] pass","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def min_additional_links(N, connections): parent = [i for i in range(N)] rank = [0] * N for u, v in connections: union(parent, rank, u - 1, v - 1) roots = len({find(parent, i) for i in range(N)}) # Add at least (roots - 1) links return max(roots - 1, 0) def process_test_cases(test_cases): results = [] for N, M, edges in test_cases: results.append(min_additional_links(N, edges)) return results"},{"question":"def max_sweetness(n: int, k: int, sweetness_values: List[int]) -> int: Find the maximum possible sweetness value of a cake using exactly k ingredients out of n available ingredients. Parameters: n (int): The number of ingredients. k (int): The number of ingredients to be used in a cake. sweetness_values (list of int): The sweetness values of the ingredients. Returns: int: The maximum possible sweetness value of the cake. >>> max_sweetness(5, 3, [1, 2, 5, 8, 3]) 16 >>> max_sweetness(6, 3, [-5, -8, -3, -2, -1, 0]) -3 >>> max_sweetness(4, 2, [10, 20, -5, -10]) 30","solution":"def max_sweetness(n, k, sweetness_values): Find the maximum possible sweetness value of a cake using exactly k ingredients out of n available ingredients. Parameters: n (int): The number of ingredients. k (int): The number of ingredients to be used in a cake. sweetness_values (list of int): The sweetness values of the ingredients. Returns: int: The maximum possible sweetness value of the cake. # Sort the sweetness values in descending order sorted_sweetness = sorted(sweetness_values, reverse=True) # Sum up the top k sweetness values max_sweetness_value = sum(sorted_sweetness[:k]) return max_sweetness_value"},{"question":"from typing import List, Tuple def max_painting_value(T: int, cases: List[Tuple[int, int, List[Tuple[int, ...]]]]) -> List[int]: Determine the maximum sum of the values of the paintings Emma can hang in each room while satisfying the condition that no two adjacent rooms have paintings with the same dominant color. Args: T: int - The number of test cases. cases: List of Tuples, where each tuple (N, R, List of Tuples) contains: - N: int - The number of rooms. - R: int - The number of possible dominant colors. - List of Tuples containing painting data for each room: - Each inner tuple starts with M (number of paintings for the room) followed by M pairs (color, value). Returns: List[int]: List of maximum values for each test case. Examples: >>> max_painting_value(1, [(3, 3, [(2, 1, 100, 2, 200), (3, 1, 300, 2, 400, 3, 500), (2, 2, 150, 3, 250)])]) [850] >>> max_painting_value(2, [(2, 2, [(2, 1, 100, 2, 200), (2, 1, 150, 2, 250)]), (3, 3, [(2, 1, 100, 2, 200), (3, 1, 300, 2, 400, 3, 500), (2, 2, 150, 3, 250)])]) [350, 850]","solution":"def max_painting_value(T, cases): results = [] for case in cases: N, R, paintings = case # Initialize DP table dp = [[0] * R for _ in range(N)] room_paintings = [] for room, painting_data in enumerate(paintings): M = painting_data[0] room_paintings.append(painting_data[1:]) # Fill the DP table for room in range(N): for color in range(R): if room == 0: dp[0][color] = 0 for i in range(0, len(room_paintings[room]), 2): if room_paintings[0][i] - 1 == color: # -1 because color is 1-based dp[0][color] = max(dp[0][color], room_paintings[0][i+1]) else: dp[room][color] = 0 for i in range(0, len(room_paintings[room]), 2): if room_paintings[room][i] - 1 == color: max_prev_value = 0 for prev_color in range(R): if prev_color != color: max_prev_value = max(max_prev_value, dp[room-1][prev_color]) dp[room][color] = max_prev_value + room_paintings[room][i+1] # Get the maximum value for the last room result = max(dp[N-1]) results.append(result) return results"},{"question":"from typing import List, Tuple def filter_and_reduce_tasks(tasks: List[Tuple[str, int]], threshold: int) -> List[Tuple[str, int]]: Filters and reduces the duration of tasks based on a given threshold. Args: tasks (List[Tuple[str, int]]): List of tuples where each tuple contains a task name and its duration in minutes. threshold (int): The duration threshold. Returns: List[Tuple[str, int]]: List of tuples with task names and their reduced durations. Examples: >>> filter_and_reduce_tasks([(\\"disassemble\\", 50), (\\"recharge\\", 20), (\\"calibrate\\", 30)], 25) [('disassemble', 25), ('calibrate', 5)] >>> filter_and_reduce_tasks([(\\"test\\", 10), (\\"charge\\", 5)], 15) []","solution":"from typing import List, Tuple def filter_and_reduce_tasks(tasks: List[Tuple[str, int]], threshold: int) -> List[Tuple[str, int]]: Filters and reduces the duration of tasks based on a given threshold. Args: tasks (List[Tuple[str, int]]): List of tuples where each tuple contains a task name and its duration in minutes. threshold (int): The duration threshold. Returns: List[Tuple[str, int]]: List of tuples with task names and their reduced durations. filtered_tasks = [] for task in tasks: task_name, task_duration = task if task_duration >= threshold: reduced_duration = task_duration - threshold filtered_tasks.append((task_name, reduced_duration)) return filtered_tasks"},{"question":"def validate_garden(H: int, W: int, flower_beds: List[Tuple[int, int, int, int]]) -> str: Determines if the given set of flower beds can be placed within the garden without overlapping each other and within the garden's boundaries. Args: H (int): Height of the garden. W (int): Width of the garden. flower_beds (list of tuples): Each tuple contains (xi1, yi1, xi2, yi2) coordinates of a flower bed. Returns: str: 'valid' if all flower beds can be placed as specified, 'invalid' otherwise. >>> validate_garden(5, 5, [(1, 1, 3, 3), (2, 2, 4, 4)]) 'invalid' >>> validate_garden(4, 4, [(0, 0, 2, 2), (2, 2, 4, 4)]) 'valid' >>> validate_garden(8, 8, [(1, 1, 3, 3), (4, 4, 6, 6), (7, 7, 8, 8)]) 'valid' import pytest def test_example1(): assert validate_garden(5, 5, [(1, 1, 3, 3), (2, 2, 4, 4)]) == 'invalid' def test_example2(): assert validate_garden(4, 4, [(0, 0, 2, 2), (2, 2, 4, 4)]) == 'valid' def test_example3(): assert validate_garden(8, 8, [(1, 1, 3, 3), (4, 4, 6, 6), (7, 7, 8, 8)]) == 'valid' def test_flower_bed_outside_garden(): assert validate_garden(5, 5, [(0, 0, 6, 6)]) == 'invalid' def test_flower_beds_overlap(): assert validate_garden(10, 10, [(1, 1, 5, 5), (4, 4, 7, 7)]) == 'invalid' def test_flower_beds_touching_but_not_overlapping(): assert validate_garden(6, 6, [(0, 0, 3, 3), (3, 3, 6, 6)]) == 'valid'","solution":"def validate_garden(H, W, flower_beds): Determines if the given set of flower beds can be placed within the garden without overlapping each other and within the garden's boundaries. Args: H (int): Height of the garden. W (int): Width of the garden. flower_beds (list of tuples): Each tuple contains (xi1, yi1, xi2, yi2) coordinates of a flower bed. Returns: str: 'valid' if all flower beds can be placed as specified, 'invalid' otherwise. # Create a garden matrix garden = [[0] * W for _ in range(H)] for (xi1, yi1, xi2, yi2) in flower_beds: # Check if flower bed is within the garden's boundary if xi1 < 0 or yi1 < 0 or xi2 > W or yi2 > H: return 'invalid' # Mark the garden with this flower bed for i in range(yi1, yi2): for j in range(xi1, xi2): if garden[i][j] == 1: return 'invalid' # Overlap detected garden[i][j] = 1 return 'valid'"},{"question":"import math def is_perfect_square(n: int) -> str: Determines if a given positive integer n is a perfect square. Parameters: - n (int): A positive integer to be checked Returns: - str: \\"YES\\" if n is a perfect square, otherwise \\"NO\\" >>> is_perfect_square(16) == \\"YES\\" True >>> is_perfect_square(20) == \\"NO\\" True","solution":"import math def is_perfect_square(n): Determines if a given positive integer n is a perfect square. Parameters: - n (int): A positive integer to be checked Returns: - str: \\"YES\\" if n is a perfect square, otherwise \\"NO\\" sqrt_n = math.isqrt(n) if sqrt_n * sqrt_n == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_reorder_no_adjacent_equals(n: int, arr: List[int]) -> str: Determine if it is possible to reorder the array such that no two adjacent elements are equal. >>> can_reorder_no_adjacent_equals(6, [1, 1, 2, 3, 3, 4]) \\"YES\\" >>> can_reorder_no_adjacent_equals(5, [1, 1, 1, 1, 2]) \\"NO\\" >>> can_reorder_no_adjacent_equals(1, [1]) \\"YES\\" >>> can_reorder_no_adjacent_equals(3, [1, 2, 3]) \\"YES\\"","solution":"def can_reorder_no_adjacent_equals(n, arr): from collections import Counter counts = Counter(arr) max_count = max(counts.values()) # If the most frequent element appears more than (n + 1) // 2 times, it's impossible to rearrange if max_count > (n + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"def find_palindromes(words: List[str]) -> List[str]: Write a function that takes a list of strings and returns a new list containing only those strings that are palindromes. A palindrome is a word that reads the same backward as forward. >>> find_palindromes([\\"racecar\\", \\"hello\\", \\"madam\\", \\"world\\", \\"level\\"]) ['racecar', 'madam', 'level'] >>> find_palindromes([\\"hello\\", \\"world\\", \\"abcd\\"]) [] :param words: List of strings :return: List of palindrome strings","solution":"def find_palindromes(words): Returns a list of palindromes from the given list of words. :param words: List of strings :return: List of palindrome strings return [word for word in words if word == word[::-1]]"},{"question":"def count_beautiful_subarrays(n: int, a: List[int]) -> int: Compute the number of non-empty beautiful subarrays of a. >>> count_beautiful_subarrays(3, [1, 2, 3]) 4 >>> count_beautiful_subarrays(2, [4, 8]) 3","solution":"def count_beautiful_subarrays(n, a): count = 0 even_length = 0 for num in a: if num % 2 == 0: even_length += 1 else: count += even_length * (even_length + 1) // 2 even_length = 0 # In case the array ends with even numbers count += even_length * (even_length + 1) // 2 return count"},{"question":"def max_difference(arr: List[int]) -> int: Find the maximum difference between any two elements such that the larger element appears after the smaller element. >>> max_difference([1, 2, 90, 10, 110]) 109 >>> max_difference([7, 9, 5, 6, 3, 2]) 2","solution":"def max_difference(arr): if len(arr) < 2: return 0 # If there's less than 2 elements, return 0 (no valid difference) min_val = arr[0] max_diff = 0 for i in range(1, len(arr)): if arr[i] < min_val: min_val = arr[i] else: diff = arr[i] - min_val if diff > max_diff: max_diff = diff return max_diff # Example usage: # print(max_difference([1, 2, 90, 10, 110])) # should return 109 # print(max_difference([7, 9, 5, 6, 3, 2])) # should return 2"},{"question":"def shortest_cycle(N, roads): Compute the shortest possible cycle that visits all checkpoints. If such a cycle does not exist, return -1. Args: N (int): the number of checkpoints roads (List[Tuple[int, int, int]]): list of tuples containing u, v (checkpoints) and d (distance) Returns: int: minimum distance of the cycle visiting all checkpoints, or -1 if no such cycle exists Examples: >>> shortest_cycle(4, [(1, 2, 10), (2, 3, 15), (3, 4, 20), (4, 1, 25), (1, 3, 30), (2, 4, 35)]) 70 >>> shortest_cycle(3, [(1, 2, 10), (2, 3, 20)]) -1 pass def test_tsp(): assert shortest_cycle(4, [(1, 2, 10), (2, 3, 15), (3, 4, 20), (4, 1, 25), (1, 3, 30), (2, 4, 35)]) == 70 assert shortest_cycle(3, [(1, 2, 10), (2, 3, 20)]) == -1 assert shortest_cycle(2, [(1, 2, 1), (2, 1, 1)]) == 2 assert shortest_cycle(5, [(1, 2, 10), (2, 3, 20), (3, 4, 30), (4, 5, 40), (5, 1, 50), (1, 3, 60), (2, 4, 70)]) == 150 def test_tsp_single_node(): assert shortest_cycle(1, []) == 0","solution":"import sys def tsp(N, dist): # dp[mask][i] will be the minimum cost to reach node i with the set of nodes in mask dp = [[sys.maxsize] * N for _ in range(1 << N)] dp[1][0] = 0 for mask in range(1 << N): for u in range(N): if mask & (1 << u): for v in range(N): if mask & (1 << v) == 0: dp[mask | (1 << v)][v] = min(dp[mask | (1 << v)][v], dp[mask][u] + dist[u][v]) res = min(dp[(1 << N) - 1][i] + dist[i][0] for i in range(1, N)) return res if res < sys.maxsize else -1 def shortest_cycle(N, roads): if N == 1: return 0 dist = [[sys.maxsize] * N for _ in range(N)] for u, v, d in roads: dist[u-1][v-1] = d dist[v-1][u-1] = d return tsp(N, dist) # Sample inputs to verify the implementation def main(): import sys input = sys.stdin.read data = input().split() idx = 0 N = int(data[idx]) M = int(data[idx+1]) idx += 2 roads = [] for _ in range(M): u = int(data[idx]) v = int(data[idx+1]) d = int(data[idx+2]) roads.append((u, v, d)) idx += 3 print(shortest_cycle(N, roads)) if __name__ == \\"__main__\\": main()"},{"question":"def game_result(test_cases): Given a list of test cases, determine the result of the game for each case. :param test_cases: List of tuples where each tuple contains: - n: length of sequences - A: list of integers representing sequence A - B: list of integers representing sequence B :return: List of results, each being \\"Alice\\", \\"Bob\\" or \\"Draw\\" # Write your solution here def parse_input(input_text): Parses the input text into a structured format. :param input_text: A string containing the input data for the game :return: A list of tuples, each tuple containing: - n: length of sequences - A: list of integers representing sequence A - B: list of integers representing sequence B # Write your solution here def print_results(results): Prints the results line by line. :param results: List of results to be printed # Write your solution here # Example usage: input_text = \\"2n3n1 2 3n4 5 6n4n-1 -2 -3 -4n-4 -3 -2 -1\\" test_cases = parse_input(input_text) results = game_result(test_cases) print_results(results)","solution":"def game_result(test_cases): Given a list of test cases, determine the result of the game for each case. :param test_cases: List of tuples where each tuple contains: - n: length of sequences - A: list of integers representing sequence A - B: list of integers representing sequence B :return: List of results, each being \\"Alice\\", \\"Bob\\" or \\"Draw\\" results = [] for case in test_cases: n, A, B = case max_A = max(sum(A), 0) max_B = max(sum(B), 0) if max_A > max_B: results.append(\\"Alice\\") elif max_B > max_A: results.append(\\"Bob\\") else: results.append(\\"Draw\\") return results def parse_input(input_text): Parses the input text into a structured format. lines = input_text.split(\\"n\\") T = int(lines[0]) test_cases = [] offset = 1 for _ in range(T): n = int(lines[offset]) A = list(map(int, lines[offset + 1].split())) B = list(map(int, lines[offset + 2].split())) test_cases.append((n, A, B)) offset += 3 return test_cases def print_results(results): Prints the results line by line. for result in results: print(result)"},{"question":"def find_central_hub(N: int, M: int, roads: List[Tuple[int, int, int]]) -> Tuple[int, int]: In a country with N cities and M bi-directional roads, find the city that should be chosen as a hub such that the maximum distance from the hub to any other city is minimized. Args: N: The number of cities. M: The number of roads. roads: A list of tuples where each tuple contains three integers u, v, and l indicating a road between cities u and v with length l. Returns: A tuple containing: - The 1-indexed city number chosen as the hub. - The minimized maximum distance to any other city. Example: >>> find_central_hub(4, 5, [(1, 2, 5), (1, 3, 10), (2, 3, 2), (2, 4, 3), (3, 4, 1)]) (2, 5) >>> find_central_hub(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) (2, 1)","solution":"import sys import heapq def find_central_hub(N, M, roads): # Construct the graph graph = {i: [] for i in range(1, N+1)} for u, v, l in roads: graph[u].append((v, l)) graph[v].append((u, l)) def dijkstra(start): distances = {i: float('inf') for i in range(1, N+1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances min_max_distance = float('inf') best_city = -1 for city in range(1, N+1): distances = dijkstra(city) max_distance = max(distances.values()) if max_distance < min_max_distance: min_max_distance = max_distance best_city = city return best_city, min_max_distance # Sample Input execution if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) roads = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index + 1]) l = int(data[index + 2]) roads.append((u, v, l)) index += 3 city, distance = find_central_hub(N, M, roads) print(city, distance)"},{"question":"def maxConcurrentSessions(sessions: List[Tuple[int, int]]) -> int: Returns the maximum number of concurrent sessions >>> maxConcurrentSessions([(1, 3), (2, 5), (4, 6)]) 2 >>> maxConcurrentSessions([(1, 4), (2, 3), (3, 5), (3, 6)]) 3","solution":"def maxConcurrentSessions(sessions): Returns the maximum number of concurrent sessions events = [] # Collect start and end times in the events list for start, end in sessions: events.append((start, 'start')) events.append((end, 'end')) # Sort the events, firstly by time, secondly \`end\` before \`start\` events.sort(key=lambda x: (x[0], x[1] == 'start')) max_concurrent = 0 current_concurrent = 0 # Traverse the events for event in events: if event[1] == 'start': current_concurrent += 1 max_concurrent = max(max_concurrent, current_concurrent) else: current_concurrent -= 1 return max_concurrent"},{"question":"from typing import List, Tuple def maxReward(budget: int, cities: List[Tuple[int, int]]) -> int: Determine the maximum reward you can obtain without exceeding the budget. >>> maxReward(300, [(150, 70), (200, 90), (120, 60)]) 130 >>> maxReward(100, [(50, 40), (60, 50)]) 50","solution":"def maxReward(budget, cities): # Implement a dynamic programming solution dp = [0] * (budget + 1) # dp[i] = maximum reward we can get with a budget of i for cost, reward in cities: # We iterate backwards to make sure each city is chosen only once for b in range(budget, cost - 1, -1): dp[b] = max(dp[b], dp[b - cost] + reward) return max(dp) # The maximum reward we can get with budgets from 0 to the given budget"},{"question":"def maxSubarraySum(arr: List[int], k: int) -> int: Returns the maximum sum of a subarray of length k. Parameters: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. Examples: >>> maxSubarraySum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> maxSubarraySum([-1, -2, 3, 4, -5, 6], 2) 7 >>> maxSubarraySum([5, -1, -2, 10, 1], 3) 9 >>> maxSubarraySum([1, 2, 3, 4], 2) 7 from solution import maxSubarraySum def test_maxSubarraySum_basic(): assert maxSubarraySum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) == 39 def test_maxSubarraySum_with_negatives(): assert maxSubarraySum([-1, -2, 3, 4, -5, 6], 2) == 7 def test_maxSubarraySum_mixed_signs(): assert maxSubarraySum([5, -1, -2, 10, 1], 3) == 9 def test_maxSubarraySum_short_array(): assert maxSubarraySum([1, 2, 3, 4], 2) == 7 def test_maxSubarraySum_all_negatives(): assert maxSubarraySum([-10, -5, -2, -1, -7], 2) == -3 def test_maxSubarraySum_all_same_values(): assert maxSubarraySum([7, 7, 7, 7, 7], 3) == 21 def test_maxSubarraySum_k_equals_array_length(): assert maxSubarraySum([1, 3, 5, 7], 4) == 16 def test_maxSubarraySum_single_value_subarray(): assert maxSubarraySum([1, 4, 2, 10, 23], 1) == 23","solution":"def maxSubarraySum(arr, k): Returns the maximum sum of a subarray of length k. Parameters: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. n = len(arr) if n < k: raise ValueError(\\"The length of the array must be at least k.\\") max_sum = curr_sum = sum(arr[:k]) for i in range(k, n): curr_sum = curr_sum + arr[i] - arr[i - k] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"from typing import List, Tuple def compare(x: str, y: str) -> int: Helper comparison function that determines the order of two strings x and y such that the combination x + y or y + x forms a larger number. pass def largest_number(arr: List[int]) -> str: Takes an array of non-negative integers and arranges them such that they form the largest possible number. >>> largest_number([10, 2, 9]) == \\"9210\\" >>> largest_number([3, 30, 34, 5, 9]) == \\"9534330\\" >>> largest_number([1, 0]) == \\"10\\" pass def handle_multiple_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Handles multiple test cases and returns the largest number for each case. >>> test_cases = [ (3, [10, 2, 9]), (4, [3, 30, 34, 5, 9]), (2, [1, 0]) ] >>> handle_multiple_test_cases(3, test_cases) == [\\"9210\\", \\"9534330\\", \\"10\\"] pass","solution":"from functools import cmp_to_key def compare(x, y): Helper comparison function that determines the order of two strings x and y such that the combination x + y or y + x forms a larger number. if x + y > y + x: return -1 else: return 1 def largest_number(arr): Takes an array of non-negative integers and arranges them such that they form the largest possible number. # Convert all integers to strings for ease of comparison. arr = list(map(str, arr)) # Sort array with custom comparator. arr.sort(key=cmp_to_key(compare)) # Join all numbers to form the largest number. largest_num = ''.join(arr) # Edge case: If the number consists of only zeros. if largest_num[0] == '0': return '0' return largest_num def handle_multiple_test_cases(T, test_cases): Handles multiple test cases and returns the largest number for each case. results = [] for i in range(T): n, arr = test_cases[i] largest_num = largest_number(arr) results.append(largest_num) return results"},{"question":"class Node: def __init__(self, data, next=None): self.data = data self.next = next def reverse_linked_list(head): Reverses a singly linked list. Parameters: head (Node): The head node of the singly linked list. Returns: Node: The new head node of the reversed singly linked list. pass def stringify(node): Converts a linked list into a string representation. Parameters: node (Node): The head node of the linked list. Returns: str: String representation of the linked list. result = [] while node: result.append(str(node.data)) node = node.next result.append(\\"None\\") return \\" -> \\".join(result)","solution":"class Node: def __init__(self, data, next=None): self.data = data self.next = next def reverse_linked_list(head): Reverses a singly linked list. Parameters: head (Node): The head node of the singly linked list. Returns: Node: The new head node of the reversed singly linked list. prev = None current = head while current is not None: next_node = current.next # remember next node current.next = prev # reverse the link prev = current # move prev to current current = next_node # move to next node return prev def stringify(node): Converts a linked list into a string representation. Parameters: node (Node): The head node of the linked list. Returns: str: String representation of the linked list. result = [] while node: result.append(str(node.data)) node = node.next result.append(\\"None\\") return \\" -> \\".join(result)"},{"question":"from typing import List def most_accessed_resource(logs: List[str]) -> str: Analyze log data from a web server and find the most accessed resource. >>> logs = [ ... \\"192.168.1.1 - [01/Jan/2020:10:00:00] - /home\\", ... \\"192.168.1.2 - [01/Jan/2020:10:05:00] - /about\\", ... \\"192.168.1.1 - [01/Jan/2020:10:10:00] - /home\\" ... ] >>> most_accessed_resource(logs) '/home' >>> logs = [ ... \\"192.168.1.1 - [01/Jan/2020:10:00:00] - /home\\", ... \\"192.168.1.2 - [01/Jan/2020:10:05:00] - /about\\", ... \\"192.168.1.1 - [01/Jan/2020:10:10:00] - /home\\", ... \\"192.168.1.3 - [01/Jan/2020:10:15:00] - /about\\" ... ] >>> result = most_accessed_resource(logs) >>> result in [\\"/home\\", \\"/about\\"] True","solution":"from collections import defaultdict from typing import List def most_accessed_resource(logs: List[str]) -> str: resource_count = defaultdict(int) for log in logs: _, _, resource = log.split(\\" - \\") resource_count[resource] += 1 # Find the resource with the maximum count most_accessed = max(resource_count, key=resource_count.get) return most_accessed"},{"question":"def calculate_working_time(start_h, start_m, end_h, end_m): In a company, employees can work either in the morning shift or in the evening shift. The morning shift starts from 9:00 AM to 5:00 PM, and the evening shift starts from 6:00 PM to 2:00 AM the next day. Each working day consists of exactly 8 hours. Calculate the total time worked by an employee in hours and minutes. The input consists of two times in 24-hour notation: - start time in the format \\"HH MM\\" - end time in the format \\"HH MM\\" The output should be the total working time in the format: \\"X hours Y minutes\\" >>> calculate_working_time(9, 0, 17, 0) '8 hours 0 minutes' >>> calculate_working_time(18, 30, 2, 30) '8 hours 0 minutes' >>> calculate_working_time(20, 0, 4, 0) '8 hours 0 minutes' >>> calculate_working_time(23, 0, 7, 0) '8 hours 0 minutes' >>> calculate_working_time(13, 0, 21, 0) '8 hours 0 minutes' >>> calculate_working_time(17, 0, 1, 0) '8 hours 0 minutes'","solution":"def calculate_working_time(start_h, start_m, end_h, end_m): Calculate the total working time given the start and end times. It returns the total time in hours and minutes. # Convert the start and end times to minutes from midnight start_total_minutes = start_h * 60 + start_m end_total_minutes = end_h * 60 + end_m # If end total minutes is less than start total minutes, it means the end time is on the next day if end_total_minutes <= start_total_minutes: end_total_minutes += 24 * 60 # add 24 hours in minutes to the end time # Calculate the total duration in minutes total_minutes_worked = end_total_minutes - start_total_minutes worked_hours = total_minutes_worked // 60 worked_minutes = total_minutes_worked % 60 return f\\"{worked_hours} hours {worked_minutes} minutes\\""},{"question":"def count_invalid_predictions(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Counts the number of invalid rainfall predictions for multiple test cases. :param T: int, number of test cases :param test_cases: list of tuples, each containing: - int N: number of days - list of int: predicted rainfall amounts :return: list of int, number of invalid predictions for each test case Example: >>> count_invalid_predictions(2, [(5, [10, 20, -30, 110, 50]), (3, [70, 85, 200])]) [2, 1] >>> count_invalid_predictions(1, [(5, [0, 100, -1, 101, 50])]) [2] >>> count_invalid_predictions(3, [(1, [0]), (1, [100]), (1, [101])]) [0, 0, 1] >>> count_invalid_predictions(1, [(5, [101, 110, 150, 200, -5])]) [5] >>> count_invalid_predictions(1, [(0, [])]) [0]","solution":"def count_invalid_predictions(T, test_cases): Counts the number of invalid rainfall predictions for multiple test cases. :param T: int, number of test cases :param test_cases: list of tuples, each containing: - int N: number of days - list of int: predicted rainfall amounts :return: list of int, number of invalid predictions for each test case results = [] for i in range(T): N, predictions = test_cases[i] invalid_count = sum(1 for pred in predictions if pred < 0 or pred > 100) results.append(invalid_count) return results"},{"question":"def max_distinct_integers(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function takes the number of test cases and the test cases themselves, and returns the maximum number of distinct integers that can be obtained in each test case. Args: t (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing the number of elements in the array and the array itself Returns: List[int]: A list of integers representing the maximum number of distinct integers for each test case >>> max_distinct_integers(3, [(3, [1, 2, 3]), (4, [4, 5, 6, 7]), (5, [10, 20, 30, 40, 50])]) == [3, 4, 5] >>> max_distinct_integers(2, [(4, [1, 1, 1, 1]), (5, [2, 3, 2, 3, 2])]) == [1, 2]","solution":"def max_distinct_integers(t, test_cases): This function takes the number of test cases and the test cases themselves, and returns the maximum number of distinct integers that can be obtained in each test case. results = [] for test_case in test_cases: n, a = test_case distinct_elements = len(set(a)) results.append(distinct_elements) return results"},{"question":"def can_schedule_events(test_cases): Determine whether events can be scheduled without overlap for multiple test cases. Args: test_cases (List[List[Tuple[int, int]]]): A list of test cases, each containing a list of events represented as (start_time, end_time) tuples. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case indicating if events can be scheduled without overlap. >>> can_schedule_events([[(1, 3), (2, 5), (6, 7)], [(1, 2), (3, 4)]]) ['NO', 'YES'] >>> can_schedule_events([[(1, 2), (3, 5), (6, 7)], [(1, 4), (5, 6)]]) ['YES', 'YES'] def parse_input(input_str): Parse the input string into a list of test cases each containing a list of events. Args: input_str (str): The input string containing multiple test cases. Returns: List[List[Tuple[int, int]]]: A list of test cases, each containing a list of (start_time, end_time) tuples. >>> parse_input(\\"1n2n1 2n3 4n\\") [[(1, 2), (3, 4)]] >>> parse_input(\\"2n3n1 3n2 5n6 7n2n1 2n3 4n\\") [[(1, 3), (2, 5), (6, 7)], [(1, 2), (3, 4)]] def solve(input_str): Solve the problem of scheduling events without overlap given the input string. Args: input_str (str): The input string containing multiple test cases. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case indicating if events can be scheduled without overlap. >>> solve(\\"2n3n1 3n2 5n6 7n2n1 2n3 4n\\") ['NO', 'YES'] >>> solve(\\"1n3n1 2n3 4n5 6n\\") ['YES']","solution":"def can_schedule_events(test_cases): results = [] for events in test_cases: events.sort() # Sort events by their start time can_schedule = True end_time = -1 for s, e in events: if s < end_time: can_schedule = False break end_time = e results.append(\\"YES\\" if can_schedule else \\"NO\\") return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 events = [] for _ in range(N): S, E = map(int, lines[index].split()) index += 1 events.append((S, E)) test_cases.append(events) return test_cases def solve(input_str): test_cases = parse_input(input_str) return can_schedule_events(test_cases)"},{"question":"def get_depth_and_ancestors(hierarchy: dict, object_id: str) -> tuple: Calculate the depth and ancestors of a given object ID in a hierarchy. Args: hierarchy (dict): The hierarchical structure of the game objects. Keys are object IDs and values are lists of child object IDs. object_id (str): The ID of the object to analyze. Returns: tuple: A tuple where the first value is an integer representing the depth of the given object ID and the second value is a list of strings representing the ancestor object IDs from the root to the parent of the given object ID. If the object ID is not present, returns (None, []). Examples: >>> hierarchy = { ... \\"root\\": [\\"child1\\", \\"child2\\", \\"child3\\"], ... \\"child1\\": [\\"subchild1\\", \\"subchild2\\"], ... \\"child2\\": [], ... \\"child3\\": [\\"subchild3\\"], ... \\"subchild1\\": [], ... \\"subchild2\\": [], ... \\"subchild3\\": [\\"subsubchild1\\"], ... \\"subsubchild1\\": [] ... } >>> get_depth_and_ancestors(hierarchy, \\"subchild2\\") (2, [\\"root\\", \\"child1\\"]) >>> get_depth_and_ancestors(hierarchy, \\"subsubchild1\\") (3, [\\"root\\", \\"child3\\", \\"subchild3\\"]) >>> get_depth_and_ancestors(hierarchy, \\"nonexistent\\") (None, []) pass # Example usage hierarchy = { \\"root\\": [\\"child1\\", \\"child2\\", \\"child3\\"], \\"child1\\": [\\"subchild1\\", \\"subchild2\\"], \\"child2\\": [], \\"child3\\": [\\"subchild3\\"], \\"subchild1\\": [], \\"subchild2\\": [], \\"subchild3\\": [\\"subsubchild1\\"], \\"subsubchild1\\": [] } print(get_depth_and_ancestors(hierarchy, \\"subchild2\\")) # Output: (2, [\\"root\\", \\"child1\\"]) print(get_depth_and_ancestors(hierarchy, \\"subsubchild1\\")) # Output: (3, [\\"root\\", \\"child3\\", \\"subchild3\\"]) print(get_depth_and_ancestors(hierarchy, \\"nonexistent\\")) # Output: (None, [])","solution":"def get_depth_and_ancestors(hierarchy, object_id): # Helper function to find the depth and ancestors of an object def find_depth_and_ancestors(current, target, depth, ancestors): if current == target: return depth, ancestors for child in hierarchy.get(current, []): found_depth, found_ancestors = find_depth_and_ancestors(child, target, depth + 1, ancestors + [current]) if found_depth is not None: return found_depth, found_ancestors return None, [] # Find the root (assuming single root, for simplicity) root = None # Determine root by finding the key that is not in any value list all_nodes = set(hierarchy.keys()) for children in hierarchy.values(): all_nodes -= set(children) if len(all_nodes) == 1: root = all_nodes.pop() else: return None, [] return find_depth_and_ancestors(root, object_id, 0, []) # Example usage hierarchy = { \\"root\\": [\\"child1\\", \\"child2\\", \\"child3\\"], \\"child1\\": [\\"subchild1\\", \\"subchild2\\"], \\"child2\\": [], \\"child3\\": [\\"subchild3\\"], \\"subchild1\\": [], \\"subchild2\\": [], \\"subchild3\\": [\\"subsubchild1\\"], \\"subsubchild1\\": [] } print(get_depth_and_ancestors(hierarchy, \\"subchild2\\")) # Output: (2, [\\"root\\", \\"child1\\"]) print(get_depth_and_ancestors(hierarchy, \\"subsubchild1\\")) # Output: (3, [\\"root\\", \\"child3\\", \\"subchild3\\"]) print(get_depth_and_ancestors(hierarchy, \\"nonexistent\\")) # Output: (None, [])"},{"question":"def is_valid_hexadecimal(s: str) -> bool: Determines if the given string s is a valid hexadecimal number. >>> is_valid_hexadecimal(\\"0x1A3F\\") True >>> is_valid_hexadecimal(\\"0x\\") True >>> is_valid_hexadecimal(\\"0xGHIJ\\") False >>> is_valid_hexadecimal(\\"1A3F\\") False >>> is_valid_hexadecimal(\\"\\") False","solution":"def is_valid_hexadecimal(s): Determines if the given string s is a valid hexadecimal number. if not s.startswith(\\"0x\\"): return False hex_part = s[2:] for char in hex_part: if not (char.isdigit() or 'a' <= char <= 'f' or 'A' <= char <= 'F'): return False return True"},{"question":"def longest_palindromic_subsequence(word: str) -> int: Returns the length of the longest palindromic subsequence in the given word. >>> longest_palindromic_subsequence(\\"bbabcbcab\\") == 7 >>> longest_palindromic_subsequence(\\"abcba\\") == 5 def solve_longest_palindromic_subsequence(test_cases: List[str]) -> List[int]: Solve multiple test cases of finding the longest palindromic subsequence. >>> solve_longest_palindromic_subsequence([\\"bbabcbcab\\", \\"abcba\\"]) == [7, 5]","solution":"def longest_palindromic_subsequence(word): Returns the length of the longest palindromic subsequence in the given word. n = len(word) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if word[i] == word[j] and cl == 2: dp[i][j] = 2 elif word[i] == word[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve_longest_palindromic_subsequence(test_cases): results = [] for word in test_cases: results.append(longest_palindromic_subsequence(word)) return results"},{"question":"MOD = 10**9 + 7 def count_sequences(n: int, k: int) -> int: Compute the number of unique sequences with specified rules. Args: n (int): Number of different stones. k (int): Length of the sequence. Returns: int: Number of unique sequences modulo 10^9 + 7. >>> count_sequences(3, 2) 2 >>> count_sequences(4, 3) 0 >>> count_sequences(2, 5) 0 # Implement the function logic here pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Solve the problem for given test cases. Args: test_cases (List[Tuple[int, int]]): List of test cases where each tuple contains (N, K). Returns: List[int]: List of results for each test case. results = [] for n, k in test_cases: results.append(count_sequences(n, k)) return results def process_input(input_data: str) -> List[Tuple[int, int]]: Process the raw input into list of test cases. Args: input_data (str): Raw input data. Returns: List[Tuple[int, int]]: List of test cases. lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(1, T + 1): n, k = map(int, lines[i].split()) test_cases.append((n, k)) return test_cases","solution":"MOD = 10**9 + 7 def count_sequences(n, k): if k == 1: return 1 # Only one sequence: [1] if k % 2 == 0: return pow(n - 1, k // 2, MOD) else: return 0 # No valid sequence for odd k def solve(test_cases): results = [] for n, k in test_cases: results.append(count_sequences(n, k)) return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(1, T + 1): n, k = map(int, lines[i].split()) test_cases.append((n, k)) return test_cases"},{"question":"def has_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with n nodes and m edges, determine if there is a cycle in the graph. >>> has_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> has_cycle(3, 2, [(1, 2), (2, 3)]) 'NO'","solution":"def has_cycle(n, m, edges): from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): return \\"YES\\" return \\"NO\\""},{"question":"def minimize_max_latency(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[float]: For each test case, calculate the minimum possible value of the maximum latency after placing one load balancer between the main data center and each remote data center. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case is a tuple containing the number of remote data centers and a list of latencies for each remote data center. Returns: List[float]: A list containing the minimum possible value of the maximum latency for each test case. >>> minimize_max_latency(3, [(3, [10, 20, 30]), (2, [100, 200]), (4, [1, 2, 3, 4])]) [15.0, 100.0, 2.0] >>> minimize_max_latency(1, [(5, [8, 16, 24, 32, 48])]) [24.0] >>> minimize_max_latency(1, [(1, [1])]) [0.5] >>> minimize_max_latency(1, [(3, [1000000, 999999, 1000000])]) [500000.0]","solution":"def minimize_max_latency(t, test_cases): results = [] for i in range(t): n, latencies = test_cases[i] max_latency = max(latencies) / 2 results.append(max_latency) return results"},{"question":"def determine_winner(S: str, T: str) -> str: Determine the winner of the game with strings S and T assuming both Alice and Bob play optimally. Parameters: S (str): The string of Alice. T (str): The string of Bob. Returns: str: \\"Alice\\" if Alice will win the game, \\"Bob\\" if Bob will win the game. >>> determine_winner(\\"abc\\", \\"bcx\\") \\"Alice\\" >>> determine_winner(\\"abcdef\\", \\"abcdef\\") \\"Bob\\" >>> determine_winner(\\"a\\", \\"b\\") \\"Alice\\" >>> determine_winner(\\"abcd\\", \\"wxyz\\") \\"Bob\\" >>> determine_winner(\\"abc\\", \\"xyz\\") \\"Alice\\" >>> determine_winner(\\"abc\\", \\"abd\\") \\"Alice\\" >>> determine_winner(\\"ab\\", \\"cd\\") \\"Bob\\" >>> determine_winner(\\"abcdefghi\\", \\"abcdxefxyi\\") \\"Alice\\"","solution":"def determine_winner(S, T): Determine the winner of the game with strings S and T assuming both Alice and Bob play optimally. Parameters: S (str): The string of Alice. T (str): The string of Bob. Returns: str: \\"Alice\\" if Alice will win the game, \\"Bob\\" if Bob will win the game. # Count the number of positions where the characters of S and T differ differences = sum(1 for s, t in zip(S, T) if s != t) # If the number of different positions is odd, Alice will win. Otherwise, Bob will win. if differences % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def min_subset_difference(num_cases: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of integers, partition it into two subsets such that the absolute difference between the sums of the subsets is minimized. You need to write a function that returns the minimum difference. >>> min_subset_difference(3, [(4, [1, 2, 3, 9]), (3, [1, 2, 3]), (6, [3, 1, 4, 2, 2, 1])]) [3, 0, 1] >>> min_subset_difference(1, [(3, [10, 20, 15])]) [5] def parse_input(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Function to parse input data for multiple test cases. Args: input_data (str): A string containing multiple lines of input data. Returns: Tuple[int, List[Tuple[int, List[int]]]]: Number of test cases and list of tuples containing number of elements and the list of integers. >>> parse_input(\\"3n4n1 2 3 9n3n1 2 3n6n3 1 4 2 2 1\\") (3, [(4, [1, 2, 3, 9]), (3, [1, 2, 3]), (6, [3, 1, 4, 2, 2, 1])]) >>> parse_input(\\"1n3n10 20 15\\") (1, [(3, [10, 20, 15])])","solution":"def min_subset_difference(num_cases, cases): def find_min_diff(arr): total_sum = sum(arr) n = len(arr) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in arr: for j in range(total_sum // 2, num - 1, -1): dp[j] = dp[j] or dp[j - num] for j in range(total_sum // 2, -1, -1): if dp[j]: return total_sum - 2 * j results = [] for case in cases: n, arr = case results.append(find_min_diff(arr)) return results # Input function to parse multiple test cases def parse_input(input_data): lines = input_data.strip().split('n') num_cases = int(lines[0]) cases = [] index = 1 for _ in range(num_cases): n = int(lines[index]) arr = list(map(int, lines[index + 1].strip().split())) cases.append((n, arr)) index += 2 return num_cases, cases"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Given the root of a binary tree, return the sum of all root-to-leaf numbers. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> sumNumbers(root) 25 >>> root = TreeNode(4) >>> root.left = TreeNode(9) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(1) >>> sumNumbers(root) 1026 >>> root = TreeNode(1) >>> sumNumbers(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> sumNumbers(root) 123 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> sumNumbers(root) 123","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Given the root of a binary tree, return the sum of all root-to-leaf numbers. def dfs(node, current_number): if node is None: return 0 current_number = current_number * 10 + node.val if node.left is None and node.right is None: return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"def maximize_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Calculate the optimal contiguous subarray for each testcase, such that the difference between the sum of subarray elements and the number of distinct elements in the subarray is maximized. Args: t: Number of test cases test_cases: List of tuples, where each tuple contains an integer n and a list of integers representing the skill levels of the students. Returns: List of tuples, where each tuple contains the starting and ending indices (1-based) of the optimal subarray for each test case. >>> maximize_difference(3, [(5, [1, 2, 3, 3, 4]), (4, [2, 2, 1, 3]), (3, [1, 1, 1])]) [(1, 5), (1, 4), (1, 3)] >>> maximize_difference(1, [(1, [100])]) [(1, 1)] >>> maximize_difference(1, [(5, [1, 2, 3, 4, 5])]) [(1, 5)] >>> maximize_difference(1, [(4, [5, 5, 5, 5])]) [(1, 4)] >>> maximize_difference(1, [(6, [1, 3, 2, 2, 3, 1])]) [(1, 6)]","solution":"def maximize_difference(t, test_cases): results = [] for case in test_cases: n, b = case max_diff = -float('inf') l, r = 0, 0 sum_so_far = 0 distinct_so_far = {} # We use a sliding window approach with two pointers start = 0 for end in range(n): sum_so_far += b[end] if b[end] in distinct_so_far: distinct_so_far[b[end]] += 1 else: distinct_so_far[b[end]] = 1 # Calculate the difference current_diff = sum_so_far - len(distinct_so_far) if current_diff > max_diff: max_diff = current_diff l, r = start + 1, end + 1 # Adjust the start pointer if necessary while sum_so_far - len(distinct_so_far) < max_diff and start <= end: sum_so_far -= b[start] distinct_so_far[b[start]] -= 1 if distinct_so_far[b[start]] == 0: del distinct_so_far[b[start]] start += 1 results.append((l, r)) return results"},{"question":"def unique_domino_arrangements(N: int) -> int: Calculate the number of unique symmetrical arrangements possible for N dominoes. Args: N: int - The number of dominoes. Returns: int - The number of unique symmetrical arrangements modulo 998244353. >>> unique_domino_arrangements(1) 1 >>> unique_domino_arrangements(2) 2 >>> unique_domino_arrangements(3) 3 # This is a placeholder example value. >>> unique_domino_arrangements(4) 5 # This is a placeholder example value. # Implementation here def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Process multiple test cases for unique domino arrangements. Args: T: int - The number of test cases. test_cases: List[int] - A list of integers representing the number of dominoes for each test case. Returns: List[int] - A list of results for each test case. >>> process_test_cases(3, [1, 2, 3]) [1, 2, 3] # This is a placeholder example value. >>> process_test_cases(2, [5, 6]) [8, 13] # This is a placeholder example value. # Implementation here","solution":"MOD = 998244353 def unique_domino_arrangements(N): Calculate the number of unique symmetrical arrangements possible for N dominoes. if N == 1: return 1 if N == 2: return 2 dp = [0] * (N + 1) dp[1] = 1 dp[2] = 2 for i in range(3, N + 1): dp[i] = (dp[i - 1] + dp[i - 2]) % MOD return dp[N] def process_test_cases(T, test_cases): results = [] for n in test_cases: results.append(unique_domino_arrangements(n)) return results # Example usage: # T = 3 # test_cases = [1, 2, 3] # print(process_test_cases(T, test_cases)) # Output should be [1, 2, 3]"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations needed to transform the given string into a palindrome. >>> min_operations_to_palindrome(\\"aab\\") 1 >>> min_operations_to_palindrome(\\"abcde\\") 4 >>> min_operations_to_palindrome(\\"racecar\\") 0","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations needed to transform the given string into a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1 return dp[0][n-1]"},{"question":"def convert_base(N: int, B: int) -> str: Converts a base-10 number N to base B. :param N: int, the base-10 number to convert. :param B: int, the base to convert to (2 â‰¤ B â‰¤ 36). :return: str, the number represented in base B. >>> convert_base(255, 2) '11111111' >>> convert_base(100, 16) '64' >>> convert_base(345, 8) '531' >>> convert_base(0, 2) '0' >>> convert_base(1, 2) '1' >>> convert_base(1, 36) '1' >>> convert_base(36, 36) '10' >>> convert_base(10**9, 16) '3B9ACA00' def batch_convert_base(test_cases: List[Tuple[int, int]]) -> List[str]: Converts a list of base-10 numbers to their respective bases. :param test_cases: List of tuples [(N1, B1), (N2, B2), ...]. :return: List of strings, the numbers represented in their respective bases. >>> test_cases = [ ... (255, 2), ... (100, 16), ... (345, 8), ... (0, 2), ... (1, 2), ... (1, 36), ... (36, 36), ... (10**9, 16) ... ] >>> batch_convert_base(test_cases) ['11111111', '64', '531', '0', '1', '1', '10', '3B9ACA00']","solution":"def convert_base(N, B): Converts a base-10 number N to base B. :param N: int, the base-10 number to convert. :param B: int, the base to convert to (2 â‰¤ B â‰¤ 36). :return: str, the number represented in base B. if N == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = [] while N > 0: remainder = N % B result.append(digits[remainder]) N //= B return ''.join(result[::-1]) def batch_convert_base(test_cases): Converts a list of base-10 numbers to their respective bases. :param test_cases: List of tuples [(N1, B1), (N2, B2), ...]. :return: List of strings, the numbers represented in their respective bases. results = [] for N, B in test_cases: results.append(convert_base(N, B)) return results"},{"question":"def reverseWordsInSentence(sentence: str) -> str: Reverses the words in a sentence without reversing the characters in each word. >>> reverseWordsInSentence(\\"hello world this is a test\\") 'test a is this world hello' >>> reverseWordsInSentence(\\"hello\\") 'hello' >>> reverseWordsInSentence(\\"\\") '' >>> reverseWordsInSentence(\\" hello world \\") 'world hello' >>> reverseWordsInSentence(\\"hello world\\") 'world hello'","solution":"def reverseWordsInSentence(sentence): Reverses the words in a sentence without reversing the characters in each word. words = sentence.split() reversed_sentence = ' '.join(reversed(words)) return reversed_sentence"},{"question":"def longest_alternating_substring(T: str) -> int: Returns the length of the longest alternating substring in T. >>> longest_alternating_substring(\\"OXOXOX\\") == 6 >>> longest_alternating_substring(\\"X\\") == 1 >>> longest_alternating_substring(\\"OOO\\") == 1 >>> longest_alternating_substring(\\"XOX\\") == 3 >>> longest_alternating_substring(\\"XXOXXOX\\") == 3","solution":"def longest_alternating_substring(T): Returns the length of the longest alternating substring in T. max_length = 1 current_length = 1 for i in range(1, len(T)): if T[i] != T[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Final check to account for the last potential longest alternating substring max_length = max(max_length, current_length) return max_length"},{"question":"def make_aesthetic_string(n: int, s: str) -> str: Convert the given string to an aesthetic string by making all characters the same. >>> make_aesthetic_string(5, \\"abcde\\") \\"aaaaa\\" >>> make_aesthetic_string(6, \\"abacbd\\") \\"aaaaaa\\" >>> make_aesthetic_string(4, \\"zzzz\\") \\"zzzz\\" def process_test_cases(test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases and returns the resulting aesthetic strings. >>> process_test_cases([(5, \\"abcde\\"), (6, \\"abacbd\\"), (4, \\"zzzz\\")]) [\\"aaaaa\\", \\"aaaaaa\\", \\"zzzz\\"]","solution":"def make_aesthetic_string(n, s): Convert the given string to an aesthetic string by making all characters the same. if n == 0: return s # We can take any character (the first one in this case) and repeat it n times return s[0] * n def process_test_cases(test_cases): results = [] for n, s in test_cases: results.append(make_aesthetic_string(n, s)) return results"},{"question":"def longest_common_subsequence(A: str, B: str) -> int: Given two strings, A and B, find the longest common subsequence (LCS) between them and return its length. A subsequence is a sequence derived from another sequence by deleting some elements without changing the order of the remaining elements. Args: A (str): First input string. B (str): Second input string. Returns: int: Length of the longest common subsequence. Examples: >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABC\\") 4 >>> longest_common_subsequence(\\"XMJYAUZ\\", \\"MZJAWXU\\") 4 from solution import longest_common_subsequence def test_lcs_example_1(): assert longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABC\\") == 4 def test_lcs_example_2(): assert longest_common_subsequence(\\"XMJYAUZ\\", \\"MZJAWXU\\") == 4 def test_lcs_no_common(): assert longest_common_subsequence(\\"ABC\\", \\"DEF\\") == 0 def test_lcs_identical_strings(): assert longest_common_subsequence(\\"ABCDE\\", \\"ABCDE\\") == 5 def test_lcs_partial_overlap(): assert longest_common_subsequence(\\"ABC\\", \\"AC\\") == 2 def test_lcs_case_sensitivity(): assert longest_common_subsequence(\\"aBc\\", \\"AbC\\") == 0 def test_lcs_single_character(): assert longest_common_subsequence(\\"A\\", \\"A\\") == 1 assert longest_common_subsequence(\\"A\\", \\"B\\") == 0 def test_lcs_empty_strings(): assert longest_common_subsequence(\\"\\", \\"\\") == 0 assert longest_common_subsequence(\\"A\\", \\"\\") == 0 assert longest_common_subsequence(\\"\\", \\"B\\") == 0","solution":"def longest_common_subsequence(A: str, B: str) -> int: Returns the length of the longest common subsequence between two strings A and B. m = len(A) n = len(B) # Create a 2D array to store the length of longest common subsequence L = [[0] * (n+1) for _ in range(m+1)] # Building the LCS table in bottom-up fashion for i in range(m+1): for j in range(n+1): if i == 0 or j == 0: L[i][j] = 0 elif A[i-1] == B[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) return L[m][n]"},{"question":"def ticketing_system(input_lines): You are tasked with designing a part of a simple ticketing system for movie theaters. The system needs to manage reservations of seats in a theater that has a specified number of rows and columns of seats. Each seat has a unique number assigned in a row-major order starting from 0 (top-left). When you receive a reserve command, if the seat is available (i.e., not reserved), you should mark it reserved. If the seat is already reserved, do nothing. When you receive a cancel command, if the seat is reserved, you should mark it available. If the seat is already available, do nothing. When you receive a check command, you need to check if the seat is reserved or not and output the appropriate message. >>> ticketing_system([\\"3 5\\", \\"6\\", \\"A 2\\", \\"A 5\\", \\"Q 2\\", \\"C 2\\", \\"Q 2\\", \\"Q 5\\", \\"2 2\\", \\"3\\", \\"Q 2\\", \\"A 2\\", \\"Q 2\\", \\"0 0\\"]) ['Reserved', 'Available', 'Reserved', '', 'Available', 'Reserved'] >>> ticketing_system([\\"1 1\\", \\"1\\", \\"Q 0\\", \\"0 0\\"]) ['Available']","solution":"def ticketing_system(input_lines): output = [] idx = 0 while idx < len(input_lines): r, c = map(int, input_lines[idx].split()) if r == 0 and c == 0: break seat_count = r * c seats = [False] * seat_count idx += 1 n = int(input_lines[idx]) idx += 1 dataset_output = [] for _ in range(n): command = input_lines[idx].split() cmd_type = command[0] seat_num = int(command[1]) if cmd_type == 'A': seats[seat_num] = True elif cmd_type == 'C': seats[seat_num] = False elif cmd_type == 'Q': dataset_output.append(\\"Reserved\\" if seats[seat_num] else \\"Available\\") idx += 1 output.extend(dataset_output) output.append(\\"\\") return output[:-1] # Remove the last empty string # Example usage and test input_data = [ \\"3 5\\", \\"6\\", \\"A 2\\", \\"A 5\\", \\"Q 2\\", \\"C 2\\", \\"Q 2\\", \\"Q 5\\", \\"2 2\\", \\"3\\", \\"Q 2\\", \\"A 2\\", \\"Q 2\\", \\"0 0\\" ] print(ticketing_system(input_data))"},{"question":"def min_colors_to_ppaint_buildings(n: int, heights: List[int]) -> int: Determine the minimum number of colors needed to paint all buildings such that no two adjacent buildings have the same color. >>> min_colors_to_paint_buildings(3, [1, 2, 1]) 2 >>> min_colors_to_paint_buildings(4, [4, 4, 4, 4]) 1","solution":"def min_colors_to_paint_buildings(n, heights): Determine the minimum number of colors needed to paint all buildings such that no two adjacent buildings have the same color. if n == 1: return 1 # The maximum number of colors needed is 2 (even and odd index) return 2 if any(heights[i] != heights[i + 1] for i in range(n - 1)) else 1 # Example Inputs # Testing the function with provided examples print(min_colors_to_paint_buildings(3, [1, 2, 1])) # Output: 2 print(min_colors_to_paint_buildings(4, [4, 4, 4, 4])) # Output: 1"},{"question":"def minimum_days_needed(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Find the smallest number of days needed to distribute meals to all the families. >>> read_input(\\"2n5 10n3 8 2 7 5n3 5n10 5 5\\") (2, [((5, 10), [3, 8, 2, 7, 5]), ((3, 5), [10, 5, 5])]) >>> minimum_days_needed(2, [((5, 10), [3, 8, 2, 7, 5]), ((3, 5), [10, 5, 5])]) [5, 3] pass def read_input(input_str: str) -> Tuple[int, List[Tuple[Tuple[int, int], List[int]]]]: Read the input string and return a tuple with the number of test cases and a list of test cases. >>> read_input(\\"2n5 10n3 8 2 7 5n3 5n10 5 5\\") (2, [((5, 10), [3, 8, 2, 7, 5]), ((3, 5), [10, 5, 5])]) pass # Test Cases input_str = 2 5 10 3 8 2 7 5 3 5 10 5 5 T, test_cases = read_input(input_str) print(minimum_days_needed(T, test_cases))","solution":"def minimum_days_needed(T, test_cases): results = [] for t in range(T): N, D = test_cases[t][0] family_members = test_cases[t][1] days = 0 for members in family_members: days += 1 results.append(days) return results # Input reading helper function def read_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N, D = map(int, lines[idx].split()) family_members = list(map(int, lines[idx + 1].split())) test_cases.append(((N, D), family_members)) idx += 2 return T, test_cases # Example usage: input_str = 2 5 10 3 8 2 7 5 3 5 10 5 5 T, test_cases = read_input(input_str) print(minimum_days_needed(T, test_cases))"},{"question":"def is_cyclic_path(path: str) -> bool: Determine if a given path is cyclic (starts and ends at the same point). >>> is_cyclic_path(\\"NESW\\") True >>> is_cyclic_path(\\"NNSS\\") True >>> is_cyclic_path(\\"EW\\") True >>> is_cyclic_path(\\"NNEESWWS\\") True >>> is_cyclic_path(\\"NS\\") True >>> is_cyclic_path(\\"NE\\") False def count_cyclic_paths(test_cases: List[str]) -> List[int]: Count the number of cyclic paths in the given list of strings. >>> count_cyclic_paths([\\"NESW\\", \\"NNSS\\", \\"EW\\", \\"NNEESWWS\\"]) [1, 1, 1, 1] >>> count_cyclic_paths([\\"NSWE\\", \\"NNSSEEWW\\", \\"E\\", \\"WWWNNNEEE\\"]) [1, 1, 0, 0] >>> count_cyclic_paths([\\"NS\\", \\"EW\\", \\"N\\", \\"S\\"]) [1, 1, 0, 0] >>> count_cyclic_paths([\\"\\"]) [1]","solution":"def is_cyclic_path(path): Determines if a given path is cyclic (starts and ends at the same point). Parameters: path (str): A string representing the path taken by the bird. Returns: bool: True if the path is cyclic, otherwise False. x, y = 0, 0 for direction in path: if direction == 'N': y += 1 elif direction == 'S': y -= 1 elif direction == 'E': x += 1 elif direction == 'W': x -= 1 return x == 0 and y == 0 def count_cyclic_paths(test_cases): Counts the number of cyclic paths in the given list of paths. Parameters: test_cases (list): A list of strings, where each string represents a path. Returns: list: A list of integers where each integer represents the count of cyclic paths. return [1 if is_cyclic_path(path) else 0 for path in test_cases]"},{"question":"def max_total_size(n: int, k: int, files: List[Tuple[int, int]]) -> int: Find the maximum total size of files that the server can process concurrently. >>> max_total_size(3, 2, [(10, 1), (20, 2), (30, 1)]) 40 >>> max_total_size(4, 1, [(5, 5), (10, 4), (5, 3), (8, 1)]) 8 >>> max_total_size(2, 3, [(15, 2), (10, 1)]) 25","solution":"def max_total_size(n, k, files): # Sort the files first by their required number of computers, # and by their size in descending order if computers required is the same files.sort(key=lambda x: (x[1], -x[0])) max_size = 0 count = 0 # Track the number of files processed concurrently for size, comps in files: if count < k: max_size += size count += 1 else: break return max_size"},{"question":"def longest_repeated_substring(text: str) -> str: You are given a large text consisting of multiple words separated by spaces. Your task is to find the longest substring in the text that appears more than once and has no overlapping characters. If there are several substrings that match the length requirement, return any of them. >>> longest_repeated_substring(\\"banana\\") 'ana' >>> longest_repeated_substring(\\"abcabc\\") 'abc' >>> longest_repeated_substring(\\"abcdef\\") '' >>> longest_repeated_substring(\\"aabcaabc\\") 'aabc' or 'abca' >>> longest_repeated_substring(\\"aaaaaa\\") 'aaaaa' >>> longest_repeated_substring(\\"ababa\\") 'aba' >>> large_input = \\"a\\" * 50000 + \\"b\\" + \\"a\\" * 49999 >>> longest_repeated_substring(large_input) 'a' * 49999","solution":"def longest_repeated_substring(text): def search_substring_of_length(L, text): This function searches for substrings of length L that repeat more than once in the text. It uses a hash set to store seen substrings and checks for repeats. seen = set() for i in range(len(text) - L + 1): sub = text[i:i+L] if sub in seen: return sub seen.add(sub) return None low, high = 0, len(text) result = \\"\\" while low <= high: mid = (low + high) // 2 candidate = search_substring_of_length(mid, text) if candidate: result = candidate low = mid + 1 # Try to find a longer valid substring else: high = mid - 1 # Shorten the length to search for a valid substring return result"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearrange the characters of the string such that no two adjacent characters are the same. Args: s (str): The input string containing only lowercase alphabets. Returns: str: The rearranged string if possible, otherwise an empty string. def process_cases(t: int, cases: List[str]) -> List[str]: Process multiple cases of rearranging strings such that no two adjacent characters are the same. Args: t (int): The number of test cases. cases (List[str]): The list of strings for each test case. Returns: List[str]: The list of results for each test case with rearranged strings or empty strings for impossibilities. # Below are some test cases to validate the solution from solution import process_cases def test_rearrange_string_possible_simple(): assert process_cases(1, [\\"aabbcc\\"]) == [\\"abcabc\\"] def test_rearrange_string_impossible(): assert process_cases(1, [\\"aaab\\"]) == [\\"\\"] def test_rearrange_string_empty_case(): assert process_cases(1, [\\"\\"]) == [\\"\\"] def test_rearrange_string_single_char(): assert process_cases(1, [\\"a\\"]) == [\\"a\\"] def test_rearrange_string_multiple_cases(): assert process_cases(2, [\\"aabbcc\\", \\"aaab\\"]) == [\\"abcabc\\", \\"\\"]","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s): Rearrange the characters of the string such that no two adjacent characters are the same. Args: s (str): The input string containing only lowercase alphabets. Returns: str: The rearranged string if possible, otherwise an empty string. count = Counter(s) max_heap = [] for char, freq in count.items(): heappush(max_heap, (-freq, char)) # Use negative frequency for max heap (heapq is a min-heap by default) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # Decrement the frequency result_str = ''.join(result) if len(result_str) != len(s): return \\"\\" return result_str def process_cases(t, cases): results = [] for case in cases: results.append(rearrange_string(case)) return results"},{"question":"def max_path_sum(grid): Returns the maximum sum of numbers along any path from the top-left cell to the bottom-right cell. Parameters: grid (List[List[int]]): A 2D grid of integers. Returns: int: The maximum sum along any valid path from (1, 1) to (n, n). Examples: >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_path_sum([[5]]) 5 >>> max_path_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_path_sum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -15 >>> max_path_sum([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 7 >>> max_path_sum([[1, -1, 1], [-1, 1, -1], [1, -1, 1]]) 3","solution":"def max_path_sum(grid): Returns the maximum sum of numbers along any path from the top-left cell to the bottom-right cell. n = len(grid) dp = [[-float('inf')] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(n): for j in range(n): if i+1 < n: dp[i+1][j] = max(dp[i+1][j], dp[i][j] + grid[i+1][j]) if j+1 < n: dp[i][j+1] = max(dp[i][j+1], dp[i][j] + grid[i][j+1]) if i+1 < n and j+1 < n: dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + grid[i+1][j+1]) return dp[n-1][n-1]"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring_length(\\"banana\\") 5 >>> longest_palindromic_substring_length(\\"racecar\\") 7 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list of results for each input string. >>> process_test_cases([\\"banana\\", \\"racecar\\"]) [5, 7] >>> process_test_cases([\\"a\\", \\"ab\\"]) [1, 1]","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string s. n = len(s) if n == 0: return 0 longest = 1 dp = [[False]*n for _ in range(n)] for i in range(n): dp[i][i] = True start = 0 for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j] and dp[i+1][j-1]) if dp[i][j] and length > longest: longest = length start = i return longest def process_test_cases(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_substring_length(s)) return results"},{"question":"def longestStrChain(words: List[str]) -> int: Given a list of words, find the length of the longest chain of words that can be formed where each word in the chain has exactly one more character than the previous word, and the previous word can be obtained by deleting exactly one character from the current word. No reordering of characters is allowed. >>> longestStrChain([\\"a\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"]) 4 >>> longestStrChain([\\"xbc\\",\\"pcxbcf\\",\\"xb\\",\\"cxbc\\",\\"pcxbc\\"]) 5 >>> longestStrChain([\\"a\\"]) 1 >>> longestStrChain([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\"]) 1 >>> longestStrChain([\\"abcd\\", \\"dbqca\\", \\"bcd\\", \\"a\\", \\"bc\\", \\"b\\"]) 4","solution":"def longestStrChain(words): words.sort(key=len) dp = {} max_length = 1 for word in words: dp[word] = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in dp: dp[word] = max(dp[word], dp[predecessor] + 1) max_length = max(max_length, dp[word]) return max_length"},{"question":"def evaluate_postfix(expression: str) -> float: Evaluates a postfix expression (reverse Polish notation) and returns the result rounded to two decimal places. >>> evaluate_postfix(\\"3 4 +\\") 7.00 >>> evaluate_postfix(\\"3 4 + 2 *\\") 14.00 >>> evaluate_postfix(\\"10 2 8 * + 3 -\\") 23.00 >>> evaluate_postfix(\\"6 3 / 2 3 * +\\") 8.00 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14.00 >>> evaluate_postfix(\\"2.5 3.5 + 2 *\\") 12.00 >>> evaluate_postfix(\\"3\\") 3.00 pass","solution":"def evaluate_postfix(expression): Evaluates a postfix expression (reverse Polish notation) and returns the result rounded to two decimal places. stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = a / b stack.append(result) else: stack.append(float(token)) return round(stack.pop(), 2)"},{"question":"def modified_fibonacci_sequence(N, M): Returns the first N terms of the modified Fibonacci sequence where each term is the remainder when the corresponding Fibonacci number is divided by M. >>> modified_fibonacci_sequence(5, 3) [0, 1, 1, 2, 0] >>> modified_fibonacci_sequence(10, 5) [0, 1, 1, 2, 3, 0, 3, 3, 1, 4] import doctest doctest.testmod() def test_basic_input(): assert modified_fibonacci_sequence(5, 3) == [0, 1, 1, 2, 0] def test_larger_input(): assert modified_fibonacci_sequence(10, 5) == [0, 1, 1, 2, 3, 0, 3, 3, 1, 4] def test_minimum_input(): assert modified_fibonacci_sequence(1, 5) == [0] def test_larger_modulus(): assert modified_fibonacci_sequence(7, 10) == [0, 1, 1, 2, 3, 5, 8] def test_different_modulus(): assert modified_fibonacci_sequence(8, 4) == [0, 1, 1, 2, 3, 1, 0, 1]","solution":"def modified_fibonacci_sequence(N, M): Returns the first N terms of the modified Fibonacci sequence where each term is the remainder when the corresponding Fibonacci number is divided by M. if N == 0: return [] if N == 1: return [0] fib_sequence = [0, 1] for i in range(2, N): next_fib = (fib_sequence[-1] + fib_sequence[-2]) % M fib_sequence.append(next_fib) return fib_sequence"},{"question":"def process_queries(N, Q, scores, queries): Process the range sum queries on given scores. Args: N : int : number of participants Q : int : number of queries scores : list of int : scores of participants queries : list of tuple of int : each tuple contains (L, R) representing the range Returns: list of int : sum of scores for each query # Your implementation here def test_process_queries(): # Test case 1 N = 5 Q = 3 scores = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] expected_output = [6, 9, 15] assert process_queries(N, Q, scores, queries) == expected_output # Test case 2 N = 6 Q = 2 scores = [10, 20, 30, 40, 50, 60] queries = [(1, 3), (4, 6)] expected_output = [60, 150] assert process_queries(N, Q, scores, queries) == expected_output # Test case 3 N = 4 Q = 2 scores = [5, 5, 5, 5] queries = [(1, 2), (3, 4)] expected_output = [10, 10] assert process_queries(N, Q, scores, queries) == expected_output # Test case 4 N = 5 Q = 1 scores = [1, 1, 1, 1, 1] queries = [(1, 5)] expected_output = [5] assert process_queries(N, Q, scores, queries) == expected_output # Test case 5 N = 3 Q = 1 scores = [100, 200, 300] queries = [(2, 3)] expected_output = [500] assert process_queries(N, Q, scores, queries) == expected_output","solution":"def process_queries(N, Q, scores, queries): Process the range sum queries on given scores. Args: N : int : number of participants Q : int : number of queries scores : list of int : scores of participants queries : list of tuple of int : each tuple contains (L, R) representing the range Returns: list of int : sum of scores for each query # Create a prefix sum array prefix_sum = [0] * (N + 1) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + scores[i - 1] results = [] for L, R in queries: # Sum of scores from indices L to R can be derived from prefix sum sum_range = prefix_sum[R] - prefix_sum[L - 1] results.append(sum_range) return results"},{"question":"def min_socks(N: int) -> int: Returns the minimum number of socks Alice has to pull out to ensure she has at least one matching pair. >>> min_socks(3) 4 >>> min_socks(5) 6 >>> min_socks(1) 2 >>> min_socks(0) 1 >>> min_socks(10) 11 from solution import min_socks def test_min_socks(): assert min_socks(3) == 4 assert min_socks(5) == 6 assert min_socks(1) == 2 assert min_socks(10) == 11 assert min_socks(0) == 1 # Edge case where there are no pairs assert min_socks(100000) == 100001 def test_min_socks_single_pair(): # Test extremely small value assert min_socks(1) == 2 def test_min_socks_large_number_of_pairs(): # Test extremely large value assert min_socks(100000) == 100001 def test_min_socks_no_pairs(): # Test zero pairs, should return 1 as per edge case handling assert min_socks(0) == 1","solution":"def min_socks(N): Returns the minimum number of socks Alice has to pull out to ensure she has at least one matching pair. :param N: An integer representing the number of pairs of socks :return: An integer representing the minimum number of socks # To ensure at least one matching pair, she needs to pull out N+1 socks return N + 1 # Example usage: # N = 3 # The result will be 4 because if she pulls out 4 socks from 3 pairs, # she will definitely have at least one matching pair. min_socks(3) # 4"},{"question":"def kangaroo_crossing(n: int, k: int, heights: List[int]) -> int: Determines if the kangaroo can reach the last rock and calculates the minimum jumps required. Parameters: n (int): The number of rocks. k (int): The maximum height difference the kangaroo can jump. heights (list of int): Heights of the rocks. Returns: int: Minimum number of jumps required or -1 if it's not possible. >>> kangaroo_crossing(5, 3, [1, 2, 2, 5, 2]) 2 >>> kangaroo_crossing(4, 1, [1, 2, 3, 4]) 3 >>> kangaroo_crossing(4, 1, [1, 3, 4, 2]) -1 >>> kangaroo_crossing(3, 1000000000, [1, 1000000000, 1]) 1 >>> kangaroo_crossing(2, 999999999, [1, 1000000000]) 1 >>> kangaroo_crossing(5, 4, [1, 2, 3, 7, 11]) 3 >>> kangaroo_crossing(5, 2, [1, 4, 6, 8, 12]) -1","solution":"from collections import deque def kangaroo_crossing(n, k, heights): Determines if the kangaroo can reach the last rock and calculates the minimum jumps required. Parameters: n (int): The number of rocks. k (int): The maximum height difference the kangaroo can jump. heights (list of int): Heights of the rocks. Returns: int: Minimum number of jumps required or -1 if it's not possible. if n == 2: return 1 if abs(heights[1] - heights[0]) <= k else -1 queue = deque([(0, 0)]) # (index, jump_count) visited = [False] * n visited[0] = True while queue: current_index, jump_count = queue.popleft() for next_index in range(current_index + 1, n): if abs(heights[next_index] - heights[current_index]) <= k: if next_index == n - 1: return jump_count + 1 if not visited[next_index]: visited[next_index] = True queue.append((next_index, jump_count + 1)) else: break return -1"},{"question":"def above_threshold(test_cases: List[Dict[str, Any]]) -> str: Identify the students who scored above a certain threshold for each test case. >>> cases = [ ... {'threshold': 75, 'students': [{'name': 'Alice', 'score': 80}, {'name': 'Bob', 'score': 70}, {'name': 'Carol', 'score': 77}]} ... ] >>> above_threshold(cases) 'AlicenCarol' >>> cases = [ ... {'threshold': 80, 'students': [{'name': 'Alice', 'score': 80}, {'name': 'Bob', 'score': 70}, {'name': 'Carol', 'score': 77}]} ... ] >>> above_threshold(cases) 'No students' >>> cases = [ ... {'threshold': 75, 'students': []} ... ] >>> above_threshold(cases) 'No students' >>> cases = [ ... {'threshold': 75, 'students': [{'name': 'Alice', 'score': 80}, {'name': 'Bob', 'score': 70}, {'name': 'Carol', 'score': 77}]}, ... {'threshold': 50, 'students': [{'name': 'David', 'score': 60}, {'name': 'Eve', 'score': 45}, {'name': 'Frank', 'score': 90}]} ... ] >>> above_threshold(cases) 'AlicenCarolnDavidnFrank' >>> cases = [ ... {'threshold': 50, 'students': [{'name': 'Grace', 'score': 50}, {'name': 'Heidi', 'score': 51}, {'name': 'Ivan', 'score': 49}]}, ... {'threshold': 100, 'students': [{'name': 'Judy', 'score': 100}, {'name': 'Ken', 'score': 101}]} ... ] >>> above_threshold(cases) 'HeidinKen'","solution":"def above_threshold(test_cases): results = [] for case in test_cases: T, students = case['threshold'], case['students'] names_above_threshold = [student['name'] for student in students if student['score'] > T] if names_above_threshold: results.append('n'.join(names_above_threshold)) else: results.append(\\"No students\\") return 'n'.join(results)"},{"question":"def maxShade(shade: List[int], k: int) -> int: Returns the maximum amount of shade that can be obtained from any k consecutive trees. >>> maxShade([2, 1, 5, 1, 3, 2], 3) 9 >>> maxShade([4, 2, 3, 1, 7], 2) 8 >>> maxShade([1, 1, 1, 1, 1], 2) 2 >>> maxShade([5, 3, 8, 6, 4], 1) 8 >>> maxShade([10], 1) 10 >>> maxShade([2, 4, 6, 8, 10], 5) 30 >>> maxShade([1, 2, 3, 4, 5], 5) 15 >>> maxShade([1, 2, 3, 4, 5], 3) 12 >>> maxShade([], 1) 0","solution":"def maxShade(shade, k): Returns the maximum amount of shade that can be obtained from any k consecutive trees. n = len(shade) if k > n: return 0 # Compute the sum of the first 'k' elements max_shade = current_shade = sum(shade[:k]) # Use sliding window technique to find the maximum sum of 'k' consecutive elements for i in range(k, n): current_shade += shade[i] - shade[i - k] max_shade = max(max_shade, current_shade) return max_shade"},{"question":"def countDistinctCharacters(s: str, n: int) -> int: Determine the number of distinct characters in every substring of length n in the given string s. If the substring length n is greater than the length of the string s, return -1. >>> countDistinctCharacters(\\"abcabc\\", 3) [3, 3, 3, 3] >>> countDistinctCharacters(\\"abcdef\\", 2) [2, 2, 2, 2, 2] >>> countDistinctCharacters(\\"hello\\", 6) -1","solution":"def countDistinctCharacters(s, n): Returns the number of distinct characters in every substring of length n in the given string s. If the substring length n is greater than the length of the string s, returns -1. if n > len(s): return -1 distinct_counts = [] for i in range(len(s) - n + 1): substring = s[i:i+n] distinct_counts.append(len(set(substring))) return distinct_counts"},{"question":"def is_palindrome(n): Returns 'Yes' if the number n is a palindrome, otherwise returns 'No'. >>> is_palindrome(121) 'Yes' >>> is_palindrome(12345) 'No' pass def process_input(input_list): Processes a list of numbers and outputs whether each number is a palindrome. The list ends with a single zero, which is not processed. >>> process_input([121, 23432, 12321, 12345, 0]) ['Yes', 'Yes', 'Yes', 'No'] >>> process_input([1, 11, 12345, 0]) ['Yes', 'Yes', 'No'] pass","solution":"def is_palindrome(n): Returns 'Yes' if the number n is a palindrome, otherwise returns 'No'. str_n = str(n) if str_n == str_n[::-1]: return 'Yes' else: return 'No' def process_input(input_list): Processes a list of numbers and outputs whether each number is a palindrome. The list ends with a single zero, which is not processed. results = [] for n in input_list: if n == 0: break results.append(is_palindrome(n)) return results"},{"question":"def rob(nums): Returns the maximum amount of money the thief can rob without alerting the police. :param nums: List[int] :return: int pass # Unit tests def test_rob_empty_list(): assert rob([]) == 0 def test_rob_single_house(): assert rob([5]) == 5 def test_rob_two_houses(): assert rob([2, 3]) == 3 def test_rob_multiple_houses(): assert rob([2, 7, 9, 3, 1]) == 12 assert rob([1, 2, 3, 1]) == 4 assert rob([2, 1, 1, 2]) == 4 def test_rob_large_list(): nums = [i for i in range(1001)] assert rob(nums) == sum(nums[::2]) # Maximum for numbers 0 through 1000 def test_rob_alternating_values(): assert rob([10, 20, 30, 40, 50]) == 90 # 10 + 30 + 50","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without alerting the police. :param nums: List[int] :return: int if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]) return dp[-1]"},{"question":"def max_non_overlapping_sessions(sessions): Given a list of sessions defined by start and end times, computes the maximum number of non-overlapping sessions that can be attended. Args: sessions (List[Tuple[int, int]]): List of tuples where each tuple represents the start and end times of a session Returns: int: The maximum number of non-overlapping sessions Examples: >>> max_non_overlapping_sessions([(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_sessions([(1, 2), (2, 3), (3, 4), (1, 5)]) 3","solution":"def max_non_overlapping_sessions(sessions): Given a list of sessions defined by start and end times, computes the maximum number of non-overlapping sessions that can be attended. Args: sessions (List[Tuple[int, int]]): List of tuples where each tuple represents the start and end times of a session Returns: int: The maximum number of non-overlapping sessions # Sort the sessions based on their end times sessions.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in sessions: if start >= last_end_time: count += 1 last_end_time = end return count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().splitlines() N = int(data[0]) sessions = [tuple(map(int, session.split())) for session in data[1:]] result = max_non_overlapping_sessions(sessions) print(result)"},{"question":"def countSunnyBuildings(heights): Returns the number of buildings that are considered sunny. A building is considered sunny if it is taller than all the buildings to its left. >>> countSunnyBuildings([7, 4, 8, 2, 9, 5]) 3 >>> countSunnyBuildings([1, 2, 3, 4, 5]) 5 >>> countSunnyBuildings([5, 4, 3, 2, 1]) 1","solution":"def countSunnyBuildings(heights): Returns the number of buildings that are considered sunny. A building is considered sunny if it is taller than all the buildings to its left. if not heights: return 0 count = 1 # The first building is always sunny max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"def max_height_difference(test_cases): For each range query in each test case, finds the maximum height difference between any two buildings. :param test_cases: List of test cases, each containing buildings heights and queries. :returns: List of maximum height differences for the queries. # Your code here def parse_input(input_string): Parses the input string for the problem and returns a list of test cases :param input_string: A string containing the input for the problem :returns: A list of test cases # Your code here import pytest def test_parse_input(): input_string = '2n5n1 3 5 7 9n2n1 3n2 5n4n4 8 2 10n1n1 4n' expected_output = [ { 'heights': [1, 3, 5, 7, 9], 'queries': [(1, 3), (2, 5)] }, { 'heights': [4, 8, 2, 10], 'queries': [(1, 4)] } ] assert parse_input(input_string) == expected_output def test_max_height_difference(): # Test Case 1 test_cases = [ { 'heights': [1, 3, 5, 7, 9], 'queries': [(1, 3), (2, 5)] }, { 'heights': [4, 8, 2, 10], 'queries': [(1, 4)] } ] # Expected Output # Query (1, 3) => max diff = 5 - 1 = 4 # Query (2, 5) => max diff = 9 - 3 = 6 # Query (1, 4) => max diff = 10 - 2 = 8 expected_output = [4, 6, 8] assert max_height_difference(test_cases) == expected_output def test_max_height_difference_single_case(): # Test Case test_cases = [ { 'heights': [1, 2, 3], 'queries': [(1, 3)] } ] # Expected Output expected_output = [2] assert max_height_difference(test_cases) == expected_output def test_max_height_difference_single_query(): # Test Case test_cases = [ { 'heights': [3, 1, 4, 1, 5, 9], 'queries': [(3, 6)] } ] # Expected Output expected_output = [8] # 9 - 1 = 8 assert max_height_difference(test_cases) == expected_output if __name__ == '__main__': pytest.main()","solution":"def max_height_difference(test_cases): For each range query in each test case, finds the maximum height difference between any two buildings. :param test_cases: List of test cases, each containing buildings heights and queries. :returns: List of maximum height differences for the queries. results = [] for case in test_cases: heights = case['heights'] queries = case['queries'] for L, R in queries: max_height = max(heights[L-1:R]) min_height = min(heights[L-1:R]) results.append(max_height - min_height) return results # Helper function to parse the input def parse_input(input_string): input_lines = input_string.strip().split('n') index = 0 t = int(input_lines[index]) index += 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) index += 1 heights = list(map(int, input_lines[index].split())) index += 1 q = int(input_lines[index]) index += 1 queries = [] for __ in range(q): L, R = map(int, input_lines[index].split()) queries.append((L, R)) index += 1 test_cases.append({ 'heights': heights, 'queries': queries }) return test_cases"},{"question":"def total_coins(n, i, j): Calculate the total number of coins earned by completing tasks from the i-th task to the j-th task. Parameters: - n (int): Total number of tasks. - i (int): Starting task index in the range (1-indexed). - j (int): Ending task index in the range (1-indexed). Returns: - int: Total coins earned. Examples: >>> total_coins(5, 2, 4) 9 >>> total_coins(5, 3, 3) 3 >>> total_coins(5, 1, 5) 15 >>> total_coins(10, 7, 10) 34 >>> total_coins(10, 1, 1) 1","solution":"def total_coins(n, i, j): Calculate the total number of coins earned by completing tasks from the i-th task to the j-th task. Parameters: - n (int): Total number of tasks. - i (int): Starting task index in the range (1-indexed). - j (int): Ending task index in the range (1-indexed). Returns: - int: Total coins earned. # Sum of the first j natural numbers: j * (j + 1) // 2 # Sum of the first (i-1) natural numbers: (i-1) * i // 2 sum_total_until_j = j * (j + 1) // 2 sum_total_until_i_minus_1 = (i - 1) * i // 2 return sum_total_until_j - sum_total_until_i_minus_1"},{"question":"def manage_inventory(n, initial_quantities, m, transactions): Returns the final quantities in stock for each product after processing the transactions. Parameters: n (int): number of different products initial_quantities (list of int): initial quantities of each product m (int): number of transactions transactions (list of tuple): list of transactions, each represented by (product_index, quantity_change) Returns: list of int: final quantities of each product # Process each transaction for product_index, quantity_change in transactions: # Adjust the quantity for the specified product initial_quantities[product_index - 1] += quantity_change # Return the final quantities return initial_quantities from solution import manage_inventory def test_manage_inventory_example(): n = 4 initial_quantities = [100, 200, 150, 175] m = 6 transactions = [ (1, -50), (2, 120), (3, -30), (4, 70), (1, 20), (3, -50) ] expected_output = [70, 320, 70, 245] assert manage_inventory(n, initial_quantities, m, transactions) == expected_output def test_manage_inventory_all_additions(): n = 3 initial_quantities = [50, 100, 150] m = 3 transactions = [ (1, 30), (2, 20), (3, 40) ] expected_output = [80, 120, 190] assert manage_inventory(n, initial_quantities, m, transactions) == expected_output def test_manage_inventory_all_removals(): n = 2 initial_quantities = [200, 150] m = 2 transactions = [ (1, -50), (2, -100) ] expected_output = [150, 50] assert manage_inventory(n, initial_quantities, m, transactions) == expected_output def test_manage_inventory_zero_transactions(): n = 2 initial_quantities = [30, 40] m = 0 transactions = [] expected_output = [30, 40] assert manage_inventory(n, initial_quantities, m, transactions) == expected_output def test_manage_inventory_large_transaction(): n = 1 initial_quantities = [500] m = 1 transactions = [ (1, -500) ] expected_output = [0] assert manage_inventory(n, initial_quantities, m, transactions) == expected_output","solution":"def manage_inventory(n, initial_quantities, m, transactions): Returns the final quantities in stock for each product after processing the transactions. Parameters: n (int): number of different products initial_quantities (list of int): initial quantities of each product m (int): number of transactions transactions (list of tuple): list of transactions, each represented by (product_index, quantity_change) Returns: list of int: final quantities of each product # Process each transaction for product_index, quantity_change in transactions: # Adjust the quantity for the specified product initial_quantities[product_index - 1] += quantity_change # Return the final quantities return initial_quantities"},{"question":"from typing import List, Tuple def is_road_unmonitored(N: int, L: int, cameras: List[Tuple[int, int]]) -> bool: Determine if there exist any unmonitored sections on the road. Parameters: N (int): The number of surveillance cameras L (int): The length of the road cameras (List[Tuple[int, int]]): A list of tuples, each containing the position and range of a camera Returns: bool: True if there are any unmonitored sections on the road, False otherwise. Examples: >>> is_road_unmonitored(3, 10, [(2, 3), (8, 2), (5, 1)]) False >>> is_road_unmonitored(2, 10, [(1, 4), (7, 2)]) True # Your code here def test_all_covered(): assert is_road_unmonitored(3, 10, [(2, 3), (8, 2), (5, 1)]) == False def test_with_gaps(): assert is_road_unmonitored(2, 10, [(1, 4), (7, 2)]) == True def test_single_camera_full_coverage(): assert is_road_unmonitored(1, 10, [(5, 10)]) == False def test_single_camera_partial_coverage(): assert is_road_unmonitored(1, 10, [(0, 5)]) == True def test_all_left_side_unmonitored(): assert is_road_unmonitored(1, 10, [(10, 5)]) == True def test_all_right_side_unmonitored(): assert is_road_unmonitored(1, 10, [(0, 5)]) == True","solution":"def is_road_unmonitored(N, L, cameras): Returns whether on the road of length L there are any unmonitored sections given N cameras. Parameters: N (int): Number of cameras L (int): Length of the road cameras (list of tuples): List containing tuples with position and range of each camera. Returns: bool: True if there is an unmonitored section, False otherwise. monitored = [False] * (L + 1) for pos, ran in cameras: start = max(0, pos - ran) end = min(L, pos + ran) for i in range(start, end + 1): monitored[i] = True return not all(monitored) # Example function call print(is_road_unmonitored(3, 10, [(2, 3), (8, 2), (5, 1)])) print(is_road_unmonitored(2, 10, [(1, 4), (7, 2)]))"},{"question":"from typing import List, Tuple def sort_array_based_on_parity(test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Sort the array such that even numbers appear in ascending order on the left side and the odd numbers appear in descending order on the right side. >>> sort_array_based_on_parity([(5, [4, 3, 2, 7, 6]), (6, [5, 4, 3, 2, 1, 0])]) [[2, 4, 6, 7, 3], [0, 2, 4, 5, 3, 1]] pass def parse_input(input_lines: List[str]) -> List[Tuple[int, List[int]]]: Parses the input and returns a list of test cases where each test case is a tuple containing the size of the array and the array itself. >>> parse_input([\\"2\\", \\"5\\", \\"4 3 2 7 6\\", \\"6\\", \\"5 4 3 2 1 0\\"]) [(5, [4, 3, 2, 7, 6]), (6, [5, 4, 3, 2, 1, 0])] pass def main(input_lines: List[str]) -> None: Main function to process the input and print the sorted arrays. >>> main([\\"2\\", \\"5\\", \\"4 3 2 7 6\\", \\"6\\", \\"5 4 3 2 1 0\\"]) 2 4 6 7 3 0 2 4 5 3 1 pass","solution":"def sort_array_based_on_parity(test_cases): results = [] for case in test_cases: n, arr = case even_numbers = sorted([x for x in arr if x % 2 == 0]) odd_numbers = sorted([x for x in arr if x % 2 != 0], reverse=True) results.append(even_numbers + odd_numbers) return results def parse_input(input_lines): index = 0 T = int(input_lines[index]) index += 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) index += 1 array = list(map(int, input_lines[index].split())) index += 1 test_cases.append((N, array)) return test_cases def main(input_lines): test_cases = parse_input(input_lines) results = sort_array_based_on_parity(test_cases) for result in results: print(\\" \\".join(map(str, result)))"},{"question":"def can_distribute_stones(t: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Check if Polycarp can distribute stones among the boxes such that each box contains at least one stone after exactly \`k\` operations. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers n, m, and k. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. >>> can_distribute_stones(4, [(3, 5, 3), (4, 8, 5), (2, 3, 1), (5, 10, 0)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> can_distribute_stones(3, [(1, 1, 0), (2, 2, 0), (2, 100, 100)]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_distribute_stones(t, test_cases): results = [] for n, m, k in test_cases: if m >= n and k >= m - n: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def detect_right_angle_triangle(stars): Determine if any three stars form a right-angle triangle. Parameters: stars (list of tuples): List of tuples where each tuple contains the (x, y) coordinates of a star. Returns: str: 'YES' if there exist three stars forming a right-angle triangle, otherwise 'NO' n = len(stars) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if is_right_angle(stars[i][0], stars[i][1], stars[j][0], stars[j][1], stars[k][0], stars[k][1]): return \\"YES\\" return \\"NO\\" def is_right_angle(x1, y1, x2, y2, x3, y3): Returns True if points (x1, y1), (x2, y2), and (x3, y3) form a right-angle triangle. # Calculate the square of the lengths of sides a2 = (x2 - x1) ** 2 + (y2 - y1) ** 2 b2 = (x3 - x1) ** 2 + (y3 - y1) ** 2 c2 = (x3 - x2) ** 2 + (y3 - y2) ** 2 # Check the Pythagorean theorem return a2 + b2 == c2 or a2 + c2 == b2 or b2 + c2 == a2 # Test cases def test_detect_right_angle_triangle(): assert detect_right_angle_triangle([(1, 1), (7, 1), (1, 5), (6, 10), (7, 5)]) == \\"YES\\" assert detect_right_angle_triangle([(0, 0), (1, 1), (2, 2), (3, 3)]) == \\"NO\\" assert detect_right_angle_triangle([(0, 0), (3, 0), (0, 4)]) == \\"YES\\" assert detect_right_angle_triangle([(0, 0), (1, 1), (0, 1)]) == \\"YES\\" assert detect_right_angle_triangle([(0, 0), (1, 1), (2, 2), (1, 3), (2, 1)]) == \\"YES\\" assert detect_right_angle_triangle([(0, 0), (-1, -1), (-2, -2), (0, 1)]) == \\"NO\\" if __name__ == \\"__main__\\": test_detect_right_angle_triangle() print(\\"All tests passed.\\")","solution":"def is_right_angle(x1, y1, x2, y2, x3, y3): Returns True if points (x1, y1), (x2, y2), and (x3, y3) form a right-angle triangle. # Calculate the square of the lengths of sides a2 = (x2 - x1) ** 2 + (y2 - y1) ** 2 b2 = (x3 - x1) ** 2 + (y3 - y1) ** 2 c2 = (x3 - x2) ** 2 + (y3 - y2) ** 2 # Check the Pythagorean theorem return a2 + b2 == c2 or a2 + c2 == b2 or b2 + c2 == a2 def detect_right_angle_triangle(stars): Determine if any three stars form a right-angle triangle. Parameters: stars (list of tuples): List of tuples where each tuple contains the (x, y) coordinates of a star. Returns: str: 'YES' if there exist three stars forming a right-angle triangle, otherwise 'NO' n = len(stars) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if is_right_angle(stars[i][0], stars[i][1], stars[j][0], stars[j][1], stars[k][0], stars[k][1]): return \\"YES\\" return \\"NO\\""},{"question":"def count_connected_components(n: int, m: int, grid: List[List[str]]) -> int: Find the number of distinct connected components of \`.\` characters in the grid. >>> count_connected_components(3, 3, [ ['.', '.', '#'], ['#', '.', '#'], ['#', '#', '.'] ]) 2 >>> count_connected_components(4, 4, [ ['#', '#', '#', '#'], ['#', '.', '.', '#'], ['#', '#', '#', '#'], ['#', '.', '.', '#'] ]) 2 >>> count_connected_components(3, 3, [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ]) 1 >>> count_connected_components(3, 3, [ ['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#'] ]) 0 >>> count_connected_components(3, 3, [ ['#', '#', '#'], ['#', '.', '#'], ['#', '#', '#'] ]) 1","solution":"def count_connected_components(n, m, grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != '.': return grid[x][y] = '#' # Mark visited dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': dfs(i, j) count += 1 return count # Example usage: if __name__ == '__main__': n, m = map(int, input().split()) grid = [list(input().strip()) for _ in range(n)] print(count_connected_components(n, m, grid))"},{"question":"def is_well_formed(s: str) -> int: Check if the string is well-formed. A string is well-formed if it contains only alphabetic characters and has equal numbers of uppercase and lowercase letters. >>> is_well_formed(\\"aAbB\\") 4 >>> is_well_formed(\\"abcD\\") -1 >>> is_well_formed(\\"XYzZxy\\") 6 def process_strings(n: int, strings: List[str]) -> List[int]: Process a list of strings and determine if each string is well-formed. :param n: An integer, the number of strings. :param strings: A list of strings to be processed. :return: A list of integers where each integer is the length of the corresponding string if it is well-formed, otherwise -1. >>> process_strings(3, [\\"aAbB\\", \\"abcD\\", \\"XYzZxy\\"]) [4, -1, 6] >>> process_strings(2, [\\"aA\\", \\"aAbb\\"]) [2, -1]","solution":"def is_well_formed(s): Check if the string is well-formed. A string is well-formed if it contains only alphabetic characters and has equal numbers of uppercase and lowercase letters. if not s.isalpha(): return -1 uppercase_count = sum(1 for c in s if c.isupper()) lowercase_count = len(s) - uppercase_count return len(s) if uppercase_count == lowercase_count else -1 def process_strings(n, strings): Process a list of strings and determine if each string is well-formed. :param n: An integer, the number of strings. :param strings: A list of strings to be processed. :return: A list of integers where each integer is the length of the corresponding string if it is well-formed, otherwise -1. results = [] for s in strings: results.append(is_well_formed(s)) return results"},{"question":"def transformed_string_length(S: str) -> int: Returns the length of the string after all possible transformations. >>> transformed_string_length(\\"abba\\") == 0 >>> transformed_string_length(\\"abcba\\") == 1 >>> transformed_string_length(\\"abcd\\") == 4 >>> transformed_string_length(\\"a\\") == 1 >>> transformed_string_length(\\"aa\\") == 0 >>> transformed_string_length(\\"abcddcba\\") == 0 >>> transformed_string_length(\\"abccba\\") == 0 >>> transformed_string_length(\\"abcdefghijklmnop\\") == 16 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list of integers. >>> process_test_cases([\\"abba\\", \\"abcba\\", \\"abcd\\"]) == [0, 1, 4] >>> process_test_cases([\\"a\\", \\"aa\\", \\"abcddcba\\"]) == [1, 0, 0] >>> process_test_cases([\\"abccba\\", \\"abcdefghijklmnop\\"]) == [0, 16]","solution":"def transformed_string_length(S): Returns the length of the string after all possible transformations. left, right = 0, len(S) - 1 while left < right and S[left] == S[right]: left += 1 right -= 1 return right - left + 1 def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list of integers. results = [transformed_string_length(S) for S in test_cases] return results"},{"question":"def optimal_cart_usage(carts, materials): Determine the optimal number of carts to be used to transport materials. Args: carts (list): List of integers representing the maximum capacities of each cart. materials (list): List of integers representing the weights of the materials. Returns: int: The number of carts used optimally. >>> optimal_cart_usage([10, 15, 20, 25, 30], [5, 10, 15, 20, 25, 30]) 5 >>> optimal_cart_usage([10, 20, 30], [40, 50, 60]) 0 >>> optimal_cart_usage([40, 50, 60], [10, 20, 30]) 3 >>> optimal_cart_usage([15, 10, 5, 25, 10], [5, 15, 10, 20, 25]) 4 >>> optimal_cart_usage([10, 20, 30], []) 0 >>> optimal_cart_usage([], [10, 20, 30]) 0 >>> optimal_cart_usage([15, 10], [5, 10, 20, 25, 15]) 2","solution":"def optimal_cart_usage(carts, materials): Determine the optimal number of carts to be used to transport materials. Args: carts (list): List of integers representing the maximum capacities of each cart. materials (list): List of integers representing the weights of the materials. Returns: int: The number of carts used optimally. # Sort carts capacities and materials weights carts.sort(reverse=True) materials.sort(reverse=True) cart_count = 0 i = 0 # index for carts j = 0 # index for materials while i < len(carts) and j < len(materials): if materials[j] <= carts[i]: cart_count += 1 i += 1 # Move to the next cart j += 1 # Move to the next material else: j += 1 # Move to the next material return cart_count # Example usage carts = [10, 15, 20, 25, 30] materials = [5, 10, 15, 20, 25, 30] print(optimal_cart_usage(carts, materials)) # Output: 5"},{"question":"def group_anagrams(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[List[str]]: Group anagrams together for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of pairs, where the first element is the number of strings, and the second element is the list of strings. Returns: List[List[str]]: A list where each element is a list of strings with anagrams grouped together for each test case. Examples: >>> group_anagrams(2, [(6, ['bat', 'tab', 'cat', 'act', 'tac', 'dog']), (4, ['listen', 'silent', 'enlist', 'inlets'])]) [['bat', 'tab', 'cat', 'act', 'tac', 'dog'], ['listen', 'silent', 'enlist', 'inlets']] >>> group_anagrams(1, [(1, ['abc'])]) [['abc']] >>> group_anagrams(1, [(5, ['abc', 'bca', 'cab', 'xyz', 'zyx'])]) [['abc', 'bca', 'cab', 'xyz', 'zyx']] >>> group_anagrams(1, [(3, ['abc', 'def', 'ghi'])]) [['abc', 'def', 'ghi']]","solution":"def group_anagrams(T, test_cases): result = [] for case in test_cases: N, strings = case sorted_dict = {} for s in strings: sorted_str = ''.join(sorted(s)) if sorted_str in sorted_dict: sorted_dict[sorted_str].append(s) else: sorted_dict[sorted_str] = [s] grouped_strings = [] for key in sorted_dict: grouped_strings.extend(sorted_dict[key]) result.append(grouped_strings) return result # Example of input: # T = 2 # test_cases = [ # (6, ['bat', 'tab', 'cat', 'act', 'tac', 'dog']), # (4, ['listen', 'silent', 'enlist', 'inlets']) # ]"},{"question":"def nth_permutation(elements, n): Returns the nth permutation (1-based) of the list of elements. If n is greater than the total number of permutations, returns \\"Invalid Input\\". >>> nth_permutation(['a', 'b', 'c'], 4) 'b c a' >>> nth_permutation(['1', '2', '3'], 7) 'Invalid Input' >>> nth_permutation(['a', 'b', 'c'], 1) 'a b c' >>> nth_permutation(['3', '2', '1'], 6) '3 2 1' >>> nth_permutation(['a', 'b', 'c', 'd'], 24) 'd c b a' pass def process_test_cases(test_cases): Processes a list of test cases and returns the result for each test case. >>> process_test_cases([(3, ['a', 'b', 'c'], 4), (3, ['1', '2', '3'], 7)]) ['b c a', 'Invalid Input'] pass def parse_input(input_lines): Parses the input lines into the format required for the process_test_cases function. >>> parse_input([\\"2\\", \\"3\\", \\"a b c\\", \\"4\\", \\"3\\", \\"1 2 3\\", \\"7\\"]) [(3, ['a', 'b', 'c'], 4), (3, ['1', '2', '3'], 7)] pass","solution":"from math import factorial def nth_permutation(elements, n): Returns the nth permutation (1-based) of the list of elements. If n is greater than the total number of permutations, returns \\"Invalid Input\\". elements = sorted(elements) length = len(elements) if n > factorial(length): return \\"Invalid Input\\" n -= 1 # Convert to 0-based index result = [] for i in range(length, 0, -1): index, n = divmod(n, factorial(i-1)) result.append(elements.pop(index)) return \\" \\".join(result) def process_test_cases(test_cases): results = [] for test in test_cases: N, elements, P = test result = nth_permutation(elements, P) results.append(result) return results def parse_input(input_lines): Parses the input lines into the format required for the process_test_cases function. test_cases = [] current_line = 0 T = int(input_lines[current_line]) current_line += 1 for _ in range(T): N = int(input_lines[current_line]) current_line += 1 elements = input_lines[current_line].split() current_line += 1 P = int(input_lines[current_line]) current_line += 1 test_cases.append((N, elements, P)) return test_cases"},{"question":"def invert_availability(product_dict): Returns a dictionary where the keys are store names and the values are lists of products available in each store. Parameters: product_dict (dict): A dictionary where keys are product names and values are lists of stores where the product is available. Returns: dict: A dictionary where keys are store names and values are lists of products available in each store. # Your code here def test_invert_availability_basic(): input_data = { \\"Milk\\": [\\"Store1\\", \\"Store2\\"], \\"Bread\\": [\\"Store1\\"], \\"Cheese\\": [\\"Store2\\", \\"Store3\\"] } expected_output = { \\"Store1\\": [\\"Milk\\", \\"Bread\\"], \\"Store2\\": [\\"Milk\\", \\"Cheese\\"], \\"Store3\\": [\\"Cheese\\"] } assert invert_availability(input_data) == expected_output def test_invert_availability_single_store_multiple_products(): input_data = { \\"Milk\\": [\\"Store1\\"], \\"Bread\\": [\\"Store1\\"], \\"Cheese\\": [\\"Store1\\"], \\"Butter\\": [\\"Store1\\"] } expected_output = { \\"Store1\\": [\\"Milk\\", \\"Bread\\", \\"Cheese\\", \\"Butter\\"] } assert invert_availability(input_data) == expected_output def test_invert_availability_empty(): input_data = {} expected_output = {} assert invert_availability(input_data) == expected_output def test_invert_availability_single_product_multiple_stores(): input_data = { \\"Milk\\": [\\"Store1\\", \\"Store2\\", \\"Store3\\"] } expected_output = { \\"Store1\\": [\\"Milk\\"], \\"Store2\\": [\\"Milk\\"], \\"Store3\\": [\\"Milk\\"] } assert invert_availability(input_data) == expected_output def test_invert_availability_multiple_products_single_store(): input_data = { \\"Milk\\": [\\"Store1\\"], \\"Bread\\": [\\"Store2\\"], \\"Cheese\\": [\\"Store3\\"] } expected_output = { \\"Store1\\": [\\"Milk\\"], \\"Store2\\": [\\"Bread\\"], \\"Store3\\": [\\"Cheese\\"] } assert invert_availability(input_data) == expected_output def test_invert_availability_repeated_products(): input_data = { \\"Milk\\": [\\"Store1\\", \\"Store2\\"], \\"Milk\\": [\\"Store2\\", \\"Store3\\"], \\"Bread\\": [\\"Store1\\", \\"Store3\\"] } expected_output = { \\"Store2\\": [\\"Milk\\"], \\"Store3\\": [\\"Milk\\", \\"Bread\\"], \\"Store1\\": [\\"Bread\\"] } assert invert_availability(input_data) == expected_output","solution":"def invert_availability(product_dict): Returns a dictionary where the keys are store names and the values are lists of products available in each store. Parameters: product_dict (dict): A dictionary where keys are product names and values are lists of stores where the product is available. Returns: dict: A dictionary where keys are store names and values are lists of products available in each store. store_dict = {} for product, stores in product_dict.items(): for store in stores: if store not in store_dict: store_dict[store] = [] store_dict[store].append(product) return store_dict"},{"question":"def answer_queries(arr, queries): You are given an array of integers a = [a_1, a_2, ..., a_n] and m queries. Each query is described by a pair of integers l_i, r_i (1 â‰¤ l_i â‰¤ r_i â‰¤ n). For each query, find the maximum integer in the subarray a[l_i..r_i]. Preprocess the array for fast query responses. Args: arr : list : list of integers representing the array. queries : list : list of tuples containing the queries. Returns: list : list of integers where each element is the answer to the corresponding query. >>> answer_queries([1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [3, 5, 5] >>> answer_queries([5, 1, 3, 7, 9, 2, 6, 8], [(3, 4), (1, 7), (2, 8), (4, 8)]) [7, 9, 9, 9] pass","solution":"def preprocess(arr, n): Preprocess the list using a sparse table for fast range_maximum queries. import math k = int(math.log2(n)) + 1 st = [[0] * (k + 1) for _ in range(n)] # Initialize the sparse table for the intervals with size 1 for i in range(n): st[i][0] = arr[i] # Compute values from smaller to bigger intervals j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 return st def range_maximum(st, l, r): Query the maximum value in the range [l, r] using the preprocessed sparse table. import math j = int(math.log2(r - l + 1)) return max(st[l][j], st[r - (1 << j) + 1][j]) def answer_queries(arr, queries): Answer the given queries using the preprocessed sparse table n = len(arr) st = preprocess(arr, n) results = [] for l, r in queries: result = range_maximum(st, l - 1, r - 1) results.append(result) return results"},{"question":"def maxCounterValue(N: int, arr: List[str]) -> int: Returns the maximum value of the counter during the sequence of operations. Parameters: N (int): The number of operations. arr (list of str): The sequence of operations, each being either '+' or '-'. Returns: int: The maximum value of the counter. Examples: >>> maxCounterValue(5, ['+', '-', '+', '+', '-']) 2 >>> maxCounterValue(4, ['-', '-', '-', '-']) 0","solution":"def maxCounterValue(N, arr): Returns the maximum value of the counter during the sequence of operations. Parameters: N (int): The number of operations. arr (list of str): The sequence of operations, each being either '+' or '-'. Returns: int: The maximum value of the counter. counter = 0 max_value = 0 for operation in arr: if operation == '+': counter += 1 elif operation == '-': counter -= 1 if counter > max_value: max_value = counter return max_value"},{"question":"def merge_and_sort(list1, list2): Merges the two lists into one, removes any duplicate elements, and sorts the remaining elements in descending order. >>> merge_and_sort([3, 1, 4], [4, 5, 9, 1]) [9, 5, 4, 3, 1] >>> merge_and_sort([], []) [] >>> merge_and_sort([1], []) [1] >>> merge_and_sort([], [2, 3]) [3, 2] >>> merge_and_sort([10, 20, 30], [20, 20, 60, 10]) [60, 30, 20, 10]","solution":"def merge_and_sort(list1, list2): Merges two lists, removes duplicates, and sorts in descending order. merged_list = list(set(list1 + list2)) merged_list.sort(reverse=True) return merged_list"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given N x N matrix by 90 degrees clockwise in-place. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given N x N matrix by 90 degrees clockwise in-place. N = len(matrix) # Transpose the matrix for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(N): matrix[i].reverse() return matrix"},{"question":"from typing import List def generate_custom_messages(templates: List[str], user_inputs: List[str]) -> List[str]: Generates customized messages based on templates and user inputs. Args: templates (List[str]): List of predefined templates as strings. user_inputs (List[str]): List of user input strings. Returns: List[str]: List of generated messages. Examples: >>> templates = [ ... \\"Happy {occasion}, {name}! We hope you have a great day on {date}.\\", ... \\"Dear {name}, wishing you a wonderful {occasion} on {date}.\\", ... \\"{date} is a special day for celebrating {occasion} with {name}.\\" ... ] >>> user_inputs = [ ... \\"1 name=Alice occasion=Birthday date=05/06/2023\\", ... \\"2 name=Bob occasion=Anniversary date=12/09/2023\\", ... \\"3 name=Charlie occasion=Graduation date=07/08/2023\\", ... \\"1 name=Diane occasion=Christmas date=25/12/2023\\" ... ] >>> generate_custom_messages(templates, user_inputs) [ \\"Happy Birthday, Alice! We hope you have a great day on 05/06/2023.\\", \\"Dear Bob, wishing you a wonderful Anniversary on 12/09/2023.\\", \\"07/08/2023 is a special day for celebrating Graduation with Charlie.\\", \\"Happy Christmas, Diane! We hope you have a great day on 25/12/2023.\\" ]","solution":"def generate_custom_messages(templates, user_inputs): Generates customized messages based on templates and user inputs. :param templates: List of predefined templates as strings :param user_inputs: List of user input strings :return: List of generated messages result = [] for input_str in user_inputs: parts = input_str.split() template_index = int(parts[0]) - 1 template = templates[template_index] placeholders = {} for part in parts[1:]: key, value = part.split('=') placeholders[key] = value for placeholder, value in placeholders.items(): template = template.replace(f\\"{{{placeholder}}}\\", value) result.append(template) return result # Read inputs def main(): import sys input = sys.stdin.read data = input().splitlines() t = int(data[0]) templates = data[1:t + 1] n = int(data[t + 1]) user_inputs = data[t + 2:] messages = generate_custom_messages(templates, user_inputs) for message in messages: print(message)"},{"question":"def distributeChocolates(n: int, k: int) -> int: Determines the number of ways to distribute n chocolates among k employees such that no employee receives more than 1 extra chocolate. >>> distributeChocolates(7, 3) 1 >>> distributeChocolates(8, 3) 2 >>> distributeChocolates(6, 3) 1 >>> distributeChocolates(10, 2) 1 >>> distributeChocolates(2000001, 1000000) 1","solution":"def distributeChocolates(n, k): Returns the number of ways to distribute n chocolates among k employees such that no employee receives more than 1 extra chocolate. # Step 1: Calculate the minimum chocolates each employee can get base_chocolates = n // k # Step 2: Calculate the remainder chocolates remainder_chocolates = n % k # Step 3: Determine the number of ways the distribution can be made if remainder_chocolates == 0: return 1 # All employees get exactly base_chocolates else: return remainder_chocolates # Employees receiving extra chocolate"},{"question":"def count_unique_outfits(T: int, B: int, S: int) -> int: Returns the total number of unique outfits that can be created. Parameters: T (int): Number of tops B (int): Number of bottoms S (int): Number of shoes Returns: int: Total number of unique outfits >>> count_unique_outfits(3, 2, 4) 24 >>> count_unique_outfits(5, 5, 5) 125 >>> count_unique_outfits(1, 1, 10) 10","solution":"def count_unique_outfits(T, B, S): Returns the total number of unique outfits that can be created. Parameters: T (int): Number of tops B (int): Number of bottoms S (int): Number of shoes Returns: int: Total number of unique outfits return T * B * S"},{"question":"def max_palace_length(n, m, matrix): Determines the maximum number of consecutive cells in any single row that can form the palace. :param n: Number of rows :param m: Number of columns :param matrix: 2D list representing the heights of the cells in the matrix :return: Maximum number of consecutive cells that can form the palace >>> max_palace_length(4, 5, [[1, 2, 3, 4, 5], [4, 3, 2, 1, 0], [5, 6, 7, 8, 9], [1, 3, 2, 4, 6]]) 5 >>> max_palace_length(1, 4, [[1, 2, 3, 4]]) 4 >>> max_palace_length(1, 4, [[4, 3, 2, 1]]) 1 >>> max_palace_length(3, 5, [[1, 3, 5, 2, 4], [1, 2, 3, 4, 5], [5, 1, 2, 3, 1]]) 5 >>> max_palace_length(3, 4, [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) 4","solution":"def max_palace_length(n, m, matrix): Determines the maximum number of consecutive cells in any single row that can form the palace. :param n: Number of rows :param m: Number of columns :param matrix: 2D list representing the heights of the cells in the matrix :return: Maximum number of consecutive cells that can form the palace max_length = 0 for row in matrix: current_length = 1 for col in range(1, m): if row[col] > row[col - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def is_prime(number): Checks if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def max_prime_subsequence_sum(n, elements): Returns the sum of the prime subsequence with the highest sum, or \\"NONE\\" if no prime subsequence exists. >>> max_prime_subsequence_sum(5, [2, 3, 6, 7, 11]) 23 >>> max_prime_subsequence_sum(6, [4, 6, 8, 9, 10, 15]) \\"NONE\\" >>> max_prime_subsequence_sum(8, [-11, 7, -5, 3, -2, 5, 1, 11]) 26 >>> max_prime_subsequence_sum(1, [15]) \\"NONE\\" def process_input(input_list): Processes a list of input strings and returns the results for each dataset. >>> input_data = [\\"5\\", \\"2 3 6 7 11\\", \\"6\\", \\"4 6 8 9 10 15\\", \\"8\\", \\"-11 7 -5 3 -2 5 1 11\\", \\"1\\", \\"15\\", \\"0\\"] >>> process_input(input_data) [23, \\"NONE\\", 26, \\"NONE\\"] >>> input_data = [\\"4\\", \\"13 22 19 15\\", \\"3\\", \\"20 25 6\\", \\"0\\"] >>> process_input(input_data) [32, \\"NONE\\"]","solution":"def is_prime(number): Checks if a number is prime. if number <= 1: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True def max_prime_subsequence_sum(n, elements): Returns the sum of the prime subsequence with the highest sum, or \\"NONE\\" if no prime subsequence exists. prime_elements = [x for x in elements if is_prime(x)] if not prime_elements: return \\"NONE\\" return sum(prime_elements) def process_input(input_list): Processes a list of input strings and returns the results for each dataset. results = [] i = 0 while i < len(input_list): n = int(input_list[i]) if n == 0: break elements = list(map(int, input_list[i + 1].split())) result = max_prime_subsequence_sum(n, elements) results.append(result) i += 2 return results"},{"question":"def next_nearest_multiple(test_cases): Function to find the next nearest multiple of given integer N that is greater than or equal to a given integer M for each test case. :param test_cases: List of tuples [(N1, M1), (N2, M2), ..., (T, M)] N and M being the integers given in each test case. :return: List of results - the next nearest multiples for each test case >>> next_nearest_multiple([(10, 95)]) [100] >>> next_nearest_multiple([(7, 150)]) [154] >>> next_nearest_multiple([(25, 250)]) [250] >>> next_nearest_multiple([(1, 999), (100, 1000)]) [999, 1000]","solution":"def next_nearest_multiple(test_cases): Function to find the next nearest multiple of given integer N that is greater than or equal to a given integer M for each test case. :param test_cases: List of tuples [(N1, M1), (N2, M2), ..., (Nt, Mt)] N and M being the integers given in each test case. :return: List of results - the next nearest multiples for each test case results = [] for N, M in test_cases: if M % N == 0: results.append(M) else: results.append(((M // N) + 1) * N) return results"},{"question":"def determine_winner(A: int, B: int) -> str: Determines the winner between Gary and Harry given the number of stones in two heaps A and B. Gary always goes first. The player who cannot make a move loses. >>> determine_winner(2, 3) == \\"HARRY\\" >>> determine_winner(5, 4) == \\"HARRY\\" >>> determine_winner(1, 1) == \\"GARY\\" >>> determine_winner(8, 8) == \\"GARY\\" ... # Your code here def game_winners(test_cases: List[Tuple[int, int]]) -> List[str]: Determines the winners for multiple test cases. test_cases: List of tuples [(A, B), (A, B), ...] Returns a list of results [\\"GARY\\", \\"HARRY\\", ...] >>> game_winners([(2, 3), (5, 4), (1, 1)]) == [\\"HARRY\\", \\"HARRY\\", \\"GARY\\"] >>> game_winners([(10, 10), (1, 2), (3, 5)]) == [\\"GARY\\", \\"HARRY\\", \\"HARRY\\"] >>> game_winners([(7, 7)]) == [\\"GARY\\"] >>> game_winners([(13, 7), (7, 7), (4, 3), (8, 7)]) == [\\"HARRY\\", \\"GARY\\", \\"HARRY\\", \\"HARRY\\"] ... # Your code here","solution":"def determine_winner(A, B): Determines the winner between Gary and Harry given the number of stones in two heaps A and B. Gary always goes first. The player who cannot make a move loses. Returns \\"GARY\\" if Gary wins, otherwise \\"HARRY\\". if (A ^ B) == 0: return \\"GARY\\" else: return \\"HARRY\\" def game_winners(test_cases): Determines the winners for multiple test cases. test_cases: List of tuples [(A, B), (A, B), ...] Returns a list of results [\\"GARY\\", \\"HARRY\\", ...] results = [] for A, B in test_cases: results.append(determine_winner(A, B)) return results"},{"question":"from typing import List, Tuple def network_efficiency(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Calculate the network efficiency for each test case by finding the total weight of the minimum spanning tree (MST) of the network. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): List of test cases where each test case is a tuple containing: - An integer N, the number of nodes in the network. - An integer M, the number of edges in the network. - A list of M tuples where each tuple contains three integers u, v, and w representing an edge between nodes u and v with weight w. Returns: List[int]: List containing the total weight of the MST for each test case. Example: >>> T = 2 >>> test_cases = [ ... (4, 5, [(0, 1, 10), (0, 2, 6), (1, 2, 5), (2, 3, 4), (1, 3, 1)]), ... (3, 3, [(0, 1, 2), (0, 2, 3), (1, 2, 1)]) ... ] >>> network_efficiency(T, test_cases) [11, 3]","solution":"from heapq import heappop, heappush def find(parent, i): # Find function with path compression if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): # Union function with union by rank root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(N, edges): # Kruskal's algorithm for finding the Minimum Spanning Tree (MST) parent = [i for i in range(N)] rank = [0] * N mst_weight = 0 mst_edges = [] edges.sort(key=lambda x: x[2]) # Sort edges by weight for edge in edges: u, v, w = edge if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += w mst_edges.append(edge) return mst_weight def network_efficiency(T, test_cases): results = [] for test_case in test_cases: N, M, edges = test_case mst_weight = kruskal(N, edges) results.append(mst_weight) return results # Example usage: # Define the number of test cases T = 2 test_cases = [ (4, 5, [(0, 1, 10), (0, 2, 6), (1, 2, 5), (2, 3, 4), (1, 3, 1)]), (3, 3, [(0, 1, 2), (0, 2, 3), (1, 2, 1)]) ] # Output the MST weight for each test case print(network_efficiency(T, test_cases))"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Determine the maximum possible profit from a single buy and sell operation over a list of stock prices. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([5, 11, 3, 50, 60]) == 57 pass","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"def find_pair_with_difference(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine for each test case whether there exists a pair of elements in the array whose absolute difference is exactly k. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, int, List[int]]]): List of tuples, each containing: - an integer n (number of elements in the array) - an integer k (required difference) - a list of n distinct integers representing the array Returns: List[str]: List of results for each test case, \\"YES\\" if there is at least one pair of elements in the array with an absolute difference of k, otherwise \\"NO\\". >>> find_pair_with_difference(3, [(5, 2, [1, 5, 3, 4, 2]), (4, 7, [10, 15, 20, 25]), (5, 1, [3, 8, 2, 1, 6])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> find_pair_with_difference(1, [(4, 10, [1, 2, 3, 4])]) [\\"NO\\"] >>> find_pair_with_difference(1, [(5, 3, [1, 4, 7, 10, 13])]) [\\"YES\\"] >>> find_pair_with_difference(1, [(3, 999999999, [1, 2, 1000000000])]) [\\"YES\\"] >>> find_pair_with_difference(1, [(2, 1, [1, 100])]) [\\"NO\\"]","solution":"def find_pair_with_difference(t, test_cases): results = [] for case in test_cases: n, k, array = case num_set = set(array) found = False for num in array: if num + k in num_set or num - k in num_set: found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: t = 3 test_cases = [ (5, 2, [1, 5, 3, 4, 2]), (4, 7, [10, 15, 20, 25]), (5, 1, [3, 8, 2, 1, 6]) ] print(find_pair_with_difference(t, test_cases))"},{"question":"def determine_winner(test_cases): Given the total points of two participants, determine the winner or if there is a tie. >>> determine_winner([(100, 150)]) == [\\"Participant 2\\"] >>> determine_winner([(200, 200)]) == [\\"TIE\\"] >>> determine_winner([(85, 70)]) == [\\"Participant 1\\"] >>> determine_winner([(100, 150), (200, 200), (85, 70)]) == [\\"Participant 2\\", \\"TIE\\", \\"Participant 1\\"] >>> determine_winner([(5, 3), (3, 2), (8, 7)]) == [\\"Participant 1\\", \\"Participant 1\\", \\"Participant 1\\"] >>> determine_winner([(2, 5), (1, 3), (7, 8)]) == [\\"Participant 2\\", \\"Participant 2\\", \\"Participant 2\\"] >>> determine_winner([(0, 0), (1000, 1000), (500, 500)]) == [\\"TIE\\", \\"TIE\\", \\"TIE\\"]","solution":"def determine_winner(test_cases): results = [] for S1, S2 in test_cases: if S1 > S2: results.append(\\"Participant 1\\") elif S1 < S2: results.append(\\"Participant 2\\") else: results.append(\\"TIE\\") return results"},{"question":"from typing import List def box_operations(operations: List[str]) -> List[int]: Simulate the operations of a collection of boxes and their items and return results for query operations. Args: operations (List[str]): A list of operations where each operation is one of \\"CREATE X\\", \\"ADD X Y\\", \\"MOVE X Y\\", \\"QUERY X\\". Returns: List[int]: A list of results for each \\"QUERY X\\" operation. Example: >>> box_operations([\\"CREATE 1\\", \\"CREATE 2\\", \\"ADD 1 101\\", \\"ADD 1 102\\", \\"MOVE 1 2\\", \\"QUERY 1\\", \\"QUERY 2\\"]) [0, 2] >>> box_operations([\\"CREATE 1\\", \\"CREATE 2\\", \\"QUERY 1\\", \\"QUERY 2\\"]) [0, 0]","solution":"def box_operations(operations): boxes = {} results = [] for operation in operations: op = operation.split() if op[0] == 'CREATE': x = int(op[1]) boxes[x] = [] elif op[0] == 'ADD': x = int(op[1]) y = int(op[2]) boxes[x].append(y) elif op[0] == 'MOVE': x = int(op[1]) y = int(op[2]) boxes[y].extend(boxes[x]) boxes[x] = [] elif op[0] == 'QUERY': x = int(op[1]) results.append(len(boxes[x])) return results"},{"question":"from typing import List, Tuple def calculate_min_waiting_times(N: int, intersections: List[List[int]]) -> List[int]: Calculate the minimum total waiting time for vehicles at each intersection based on the new regulation. Args: N (int): The number of intersections. intersections (List[List[int]]): A list of intersections, each represented by a list where the first element is the number of traffic lights L_i, followed by 2*L_i integers representing the green and red light durations. Returns: List[int]: A list of minimum total waiting times for each intersection over one complete cycle. >>> calculate_min_waiting_times(3, [[2, 3, 5, 2, 6], [3, 1, 2, 2, 1, 1, 1], [1, 10, 15]]) [16, 8, 25] pass def parse_input(input_data: str) -> Tuple[int, List[List[int]]]: Parse the input data to extract the number of intersections and their respective traffic light configurations. Args: input_data (str): A string representation of the input data. Returns: Tuple[int, List[List[int]]]: A tuple containing the number of intersections and the list of intersection data. >>> parse_input(\\"3n2 3 5 2 6n3 1 2 2 1 1 1n1 10 15n\\") (3, [[2, 3, 5, 2, 6], [3, 1, 2, 2, 1, 1, 1], [1, 10, 15]]) pass def get_waiting_times_from_input(input_data: str) -> List[int]: Get the minimum total waiting times for each intersection from the input data. Args: input_data (str): A string representation of the input data. Returns: List[int]: A list of minimum total waiting times for each intersection over one complete cycle. >>> get_waiting_times_from_input(\\"3n2 3 5 2 6n3 1 2 2 1 1 1n1 10 15n\\") [16, 8, 25] pass # Unit Tests def test_calculate_min_waiting_times(): N = 3 intersections = [ [2, 3, 5, 2, 6], [3, 1, 2, 2, 1, 1, 1], [1, 10, 15] ] expected = [16, 8, 25] assert calculate_min_waiting_times(N, intersections) == expected def test_calculate_min_waiting_times_single_intersection(): N = 1 intersections = [ [2, 4, 6, 3, 7] ] expected = [20] assert calculate_min_waiting_times(N, intersections) == expected def test_parse_input(): input_data = \\"3n2 3 5 2 6n3 1 2 2 1 1 1n1 10 15n\\" expected_N = 3 expected_intersections = [ [2, 3, 5, 2, 6], [3, 1, 2, 2, 1, 1, 1], [1, 10, 15] ] assert parse_input(input_data) == (expected_N, expected_intersections) def test_get_waiting_times_from_input(): input_data = \\"3n2 3 5 2 6n3 1 2 2 1 1 1n1 10 15n\\" expected_output = [16, 8, 25] assert get_waiting_times_from_input(input_data) == expected_output","solution":"def calculate_min_waiting_times(N, intersections): min_waiting_times = [] for intersection in intersections: L_i = intersection[0] traffic_lights = intersection[1:] total_waiting_time = 0 for j in range(L_i): G = traffic_lights[2 * j] R = traffic_lights[2 * j + 1] total_waiting_time += (G + R) min_waiting_times.append(total_waiting_time) return min_waiting_times # Input parsing function def parse_input(input_data): lines = input_data.strip().split('n') N = int(lines[0]) intersections = [] for i in range(1, N + 1): data = list(map(int, lines[i].split())) intersections.append(data) return N, intersections # Composition function def get_waiting_times_from_input(input_data): N, intersections = parse_input(input_data) return calculate_min_waiting_times(N, intersections)"},{"question":"def cumulativeQuerySum(arr: List[int], n: int, queries: List[Tuple[int, int]], q: int) -> int: Given an array Arr[] of N elements, process Q queries. Each query consists of two integers L and R. For each query, find the sum of elements in the given range [L...R]. After processing all queries, return the cumulative sum of all the individual query results. Args: arr (List[int]): The input array of integers. n (int): Number of elements in the array. queries (List[Tuple[int, int]]): List of queries where each query is represented as a tuple (L, R). q (int): Number of queries. Returns: int: The cumulative sum of all query results. Example: >>> cumulativeQuerySum([1, 2, 3, 4, 5], 5, [(1, 3), (0, 2)], 2) 15 >>> cumulativeQuerySum([10, 20, 30, 40], 4, [(1, 2)], 1) 50","solution":"def cumulativeQuerySum(arr, n, queries, q): prefix_sum = [0] * (n + 1) # Compute prefix sums for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] result = 0 # Process each query for query in queries: L, R = query result += prefix_sum[R + 1] - prefix_sum[L] return result"},{"question":"def num_land_regions(grid, n, m): Returns the number of distinct land regions in the grid. >>> num_land_regions( ... [['L', 'W', 'W', 'L', 'L'], ... ['L', 'L', 'W', 'L', 'L'], ... ['W', 'L', 'L', 'L', 'L'], ... ['W', 'W', 'W', 'W', 'W'], ... ['L', 'L', 'L', 'W', 'L']], ... 5, 5) 3 >>> num_land_regions( ... [['W', 'W', 'W'], ... ['W', 'L', 'W'], ... ['W', 'W', 'W']], ... 3, 3) 1","solution":"def num_land_regions(grid, n, m): Returns the number of distinct land regions in the grid. def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] != 'L': return grid[x][y] = 'W' dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': count += 1 dfs(i, j) return count # Reading the input and utilizing the function if __name__ == \\"__main__\\": n, m = map(int, input().split()) grid = [list(input().strip()) for _ in range(n)] print(num_land_regions(grid, n, m))"},{"question":"from heapq import heappop, heappush from typing import List, Tuple def dijkstra(grid: List[List[int]], n: int, m: int) -> int: Uses Dijkstra's algorithm to find the minimum cost path in a grid from (0,0) to (n-1,m-1). Args: grid (List[List[int]]): 2D list representing the grid with costs. n (int): Number of rows. m (int): Number of columns. Returns: int: The minimum cost to reach the bottom-right corner from the top-left corner. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(grid[0][0], 0, 0)] # (cost, x, y) distances = {(0, 0): grid[0][0]} while min_heap: cost, x, y = heappop(min_heap) if x == n - 1 and y == m - 1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = cost + grid[nx][ny] if (nx, ny) not in distances or new_cost < distances[(nx, ny)]: distances[(nx, ny)] = new_cost heappush(min_heap, (new_cost, nx, ny)) def find_shortest_paths(datasets: List[Tuple[List[List[int]], Tuple[int, int]]]) -> List[int]: Computes the minimum cost paths for multiple datasets. Args: datasets (List[Tuple[List[List[int]], Tuple[int, int]]]): List of datasets where each dataset consists of a grid and its dimensions. Returns: List[int]: List of minimum costs for each dataset. results = [] for grid, dimensions in datasets: n, m = dimensions results.append(dijkstra(grid, n, m)) return results def parse_input(input_data: str) -> List[Tuple[List[List[int]], Tuple[int, int]]]: Parses the input data to extract multiple datasets. Args: input_data (str): The input data as a string. Returns: List[Tuple[List[List[int]], Tuple[int, int]]]: The parsed datasets. lines = input_data.strip().split('n') datasets = [] idx = 0 while idx < len(lines): n, m = map(int, lines[idx].split()) if n == 0 and m == 0: break idx += 1 grid = [] for i in range(n): grid.append(list(map(int, lines[idx].split()))) idx += 1 datasets.append((grid, (n, m))) return datasets def main(input_data: str) -> None: Main function to read input, find shortest paths, and print the results. Args: input_data (str): The input data as a string. datasets = parse_input(input_data) results = find_shortest_paths(datasets) for result in results: print(result) # Example Usage EXAMPLE_INPUT = 3 3 1 3 1 1 5 1 4 2 1 2 2 1 2 1 1 0 0 main(EXAMPLE_INPUT)","solution":"from heapq import heappop, heappush def dijkstra(grid, n, m): Uses Dijkstra's algorithm to find the minimum cost path in a grid from (0,0) to (n-1,m-1). directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(grid[0][0], 0, 0)] # (cost, x, y) distances = {(0, 0): grid[0][0]} while min_heap: cost, x, y = heappop(min_heap) if x == n - 1 and y == m - 1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = cost + grid[nx][ny] if (nx, ny) not in distances or new_cost < distances[(nx, ny)]: distances[(nx, ny)] = new_cost heappush(min_heap, (new_cost, nx, ny)) def find_shortest_paths(datasets): results = [] for grid, dimensions in datasets: n, m = dimensions results.append(dijkstra(grid, n, m)) return results def parse_input(input_data): lines = input_data.strip().split('n') datasets = [] idx = 0 while idx < len(lines): n, m = map(int, lines[idx].split()) if n == 0 and m == 0: break idx += 1 grid = [] for i in range(n): grid.append(list(map(int, lines[idx].split()))) idx += 1 datasets.append((grid, (n, m))) return datasets def main(input_data): datasets = parse_input(input_data) results = find_shortest_paths(datasets) for result in results: print(result) # Test the solution with an example input EXAMPLE_INPUT = 3 3 1 3 1 1 5 1 4 2 1 2 2 1 2 1 1 0 0 main(EXAMPLE_INPUT)"},{"question":"from typing import List, Tuple def highest_electricity_consumption(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the highest electricity consumption for each test case. >>> test_cases = [(5, [10, 20, 5, 30, 25]), (3, [7, 12, 6])] >>> highest_electricity_consumption(test_cases) [30, 12] def process_input(input_string: str) -> List[Tuple[int, List[int]]]: Process input string and return list of test cases >>> input_string = \\"2n5n10 20 5 30 25n3n7 12 6\\" >>> process_input(input_string) [(5, [10, 20, 5, 30, 25]), (3, [7, 12, 6])]","solution":"def highest_electricity_consumption(test_cases): results = [] for days, consumptions in test_cases: results.append(max(consumptions)) return results def process_input(input_string): data = input_string.strip().split('n') test_cases = [] index = 0 T = int(data[index]) index += 1 for _ in range(T): N = int(data[index]) index += 1 consumptions = list(map(int, data[index].split())) index += 1 test_cases.append((N, consumptions)) return test_cases"},{"question":"def largestPark(n: int, m: int, grid: List[List[int]]) -> int: Function to find the largest square area of contiguous empty cells (0) in the grid. >>> largestPark(5, 6, [ [1, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0] ]) 4 >>> largestPark(3, 3, [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 0 ...","solution":"def largestPark(n, m, grid): Function to find the largest square area of contiguous empty cells (0) in the grid. if not grid or n == 0 or m == 0: return 0 # Create a 2D DP array initialized to 0s dp = [[0] * m for _ in range(n)] max_side = 0 # Iterate over the grid to fill the DP table for i in range(n): for j in range(m): if grid[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 # Edge case where we can't have a larger square else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) # Return the area of the largest square return max_side * max_side"},{"question":"def minPalindromePartition(s: str) -> int: Given a string 's', partition it into as few substrings as possible so that each substring is a palindrome. >>> minPalindromePartition(\\"aab\\") 1 >>> minPalindromePartition(\\"a\\") 0 >>> minPalindromePartition(\\"abc\\") 2 Unit Test: def test_minPalindromePartition(): assert minPalindromePartition(\\"aab\\") == 1 assert minPalindromePartition(\\"a\\") == 0 assert minPalindromePartition(\\"abc\\") == 2 assert minPalindromePartition(\\"aaabb\\") == 1 assert minPalindromePartition(\\"abccba\\") == 0 assert minPalindromePartition(\\"racecar\\") == 0 assert minPalindromePartition(\\"abcba\\") == 0 assert minPalindromePartition(\\"abac\\") == 1 assert minPalindromePartition(\\"aabaa\\") == 0 assert minPalindromePartition(\\"abba\\") == 0 if __name__ == \\"__main__\\": test_minPalindromePartition() print(\\"All tests passed.\\")","solution":"def minPalindromePartition(s): n = len(s) # Initialize a table to store the minimum number of cuts needed for palindrome partitioning dp = [[0] * n for _ in range(n)] # Table to store if substrings are palindrome is_palindrome = [[False] * n for _ in range(n)] for i in range(n): is_palindrome[i][i] = True for length in range(2, n+1): for i in range(n - length + 1): j = i + length - 1 if length == 2: is_palindrome[i][j] = (s[i] == s[j]) else: is_palindrome[i][j] = (s[i] == s[j] and is_palindrome[i+1][j-1]) # Create the DP table for minimum cuts for i in range(n): if is_palindrome[0][i]: dp[0][i] = 0 else: dp[0][i] = float('inf') for j in range(1, i+1): if is_palindrome[j][i] and dp[0][j-1] + 1 < dp[0][i]: dp[0][i] = dp[0][j-1] + 1 return dp[0][n-1]"},{"question":"from typing import List def num_islands(grid: List[List[int]]) -> int: Returns the number of distinct islands in the given 2D grid. >>> num_islands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0]]) 3 >>> num_islands([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) 2 >>> num_islands([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 0 >>> num_islands([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 1 >>> num_islands([[1]]) 1 >>> num_islands([[0]]) 0","solution":"def num_islands(grid): Returns the number of distinct islands in the given 2D grid. if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Mark the cell as visited dfs(x - 1, y) dfs(x + 1, y) dfs(x, y - 1) dfs(x, y + 1) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: num_islands += 1 dfs(i, j) return num_islands"},{"question":"def min_changes_to_beautiful(s): Returns the minimum number of changes required to make the string \`s\` beautiful. >>> min_changes_to_beautiful(\\"aab\\") 1 >>> min_changes_to_beautiful(\\"aabb\\") 2 >>> min_changes_to_beautiful(\\"abcabc\\") 0 def min_changes_for_multiple_tests(t, test_cases): Given multiple test cases, returns the results for each case. >>> min_changes_for_multiple_tests(3, [\\"aab\\", \\"aabb\\", \\"abcabc\\"]) [1, 2, 0] >>> min_changes_for_multiple_tests(2, [\\"ababab\\", \\"aaaa\\"]) [0, 3] >>> min_changes_for_multiple_tests(4, [\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\"]) [0, 1, 2, 3] >>> min_changes_for_multiple_tests(1, [\\"ab\\"]) [0]","solution":"def min_changes_to_beautiful(s): Returns the minimum number of changes required to make the string \`s\` beautiful. changes = 0 for i in range(1, len(s)): if s[i] == s[i-1]: changes += 1 return changes def min_changes_for_multiple_tests(t, test_cases): Given multiple test cases, returns the results for each case. results = [] for s in test_cases: results.append(min_changes_to_beautiful(s)) return results"},{"question":"def find_winner(candidates: List[str]) -> str: Given an array of strings where each string represents a possible vote for one of the candidates in an election, determine the winner of the election. The winner is the candidate who has received the most votes. If there is a tie, return the lexicographically smallest name among the top candidates. Args: candidates: List of strings where each string is a vote for a candidate. Returns: The winning candidate's name. Examples: >>> find_winner(['alice', 'bob', 'alice']) 'alice' >>> find_winner(['john', 'john', 'jack', 'jack']) 'jack' # Your implementation here def determine_winners(test_cases: List[List[str]]) -> List[str]: Given multiple test cases, each containing a list of votes, determine the winners for all the test cases. Args: test_cases: A list of list of strings, where each sublist represents votes of a test case. Returns: A list of winning candidate names for each test case. Examples: >>> determine_winners([ ... ['alice', 'bob', 'alice'], ... ['john', 'john', 'jack', 'jack'] ... ]) ['alice', 'jack'] # Your implementation here # Unit tests def test_single_winner(): assert find_winner(['alice', 'bob', 'alice']) == 'alice' def test_tie_breaker(): assert find_winner(['john', 'john', 'jack', 'jack']) == 'jack' def test_all_unique_candidates(): assert find_winner(['alice', 'bob', 'carol', 'dave']) == 'alice' def test_one_candidate(): assert find_winner(['bob']) == 'bob' def test_all_same_candidate(): assert find_winner(['alice', 'alice', 'alice']) == 'alice' def test_determine_winners(): test_cases = [ ['alice', 'bob', 'alice'], ['john', 'john', 'jack', 'jack'] ] assert determine_winners(test_cases) == ['alice', 'jack'] # Running Tests def test_all(): test_single_winner() test_tie_breaker() test_all_unique_candidates() test_one_candidate() test_all_same_candidate() test_determine_winners() test_all()","solution":"def find_winner(candidates): from collections import defaultdict vote_count = defaultdict(int) for candidate in candidates: vote_count[candidate] += 1 # Find the candidate(s) with the maximum votes max_votes = max(vote_count.values()) top_candidates = [name for name, votes in vote_count.items() if votes == max_votes] # Return the lexicographically smallest candidate among the top candidates return min(top_candidates) def determine_winners(test_cases): results = [] for votes in test_cases: results.append(find_winner(votes)) return results"},{"question":"def min_moves_to_form_towers(n: int, heights: List[int]) -> int: Returns the minimum number of moves required to rearrange the blocks into towers of equal height. >>> min_moves_to_form_towers(4, [1, 2, 3, 3]) 2 >>> min_moves_to_form_towers(5, [4, 4, 4, 4, 4]) 0 >>> min_moves_to_form_towers(3, [2, 3, 4]) 2 from typing import List def test_min_moves_to_form_towers_examples(): assert min_moves_to_form_towers(4, [1, 2, 3, 3]) == 2 assert min_moves_to_form_towers(5, [4, 4, 4, 4, 4]) == 0 assert min_moves_to_form_towers(3, [2, 3, 4]) == 2 def test_min_moves_to_form_towers_edge_cases(): assert min_moves_to_form_towers(1, [1]) == 0 # Only one block assert min_moves_to_form_towers(2, [1, 1]) == 0 # Two blocks of the same height assert min_moves_to_form_towers(2, [1, 2]) == 1 # Two blocks of different height def test_min_moves_to_form_towers_varied_cases(): assert min_moves_to_form_towers(6, [1, 2, 2, 3, 3, 3]) == 3 assert min_moves_to_form_towers(7, [1, 1, 1, 2, 2, 2, 3]) == 4 assert min_moves_to_form_towers(8, [5, 5, 6, 6, 6, 7, 7, 7]) == 5","solution":"def min_moves_to_form_towers(n, heights): Returns the minimum number of moves required to rearrange the blocks into towers of equal height. :param n: int - Number of blocks :param heights: list of int - Heights of the blocks :return: int - Minimum number of moves required from collections import Counter # Count the frequency of each height counter = Counter(heights) # Find the maximum frequency max_frequency = max(counter.values()) # The minimum number of moves is the total number of blocks minus the maximum frequency return n - max_frequency"},{"question":"def is_divisible_by_3(test_cases: List[str]) -> List[str]: Determine if large integers represented as strings are divisible by 3. A number is divisible by 3 if the sum of its digits is divisible by 3. Args: test_cases (List[str]): A list of strings where each string represents a large integer. Returns: List[str]: A list of strings where each element is \\"YES\\" if the corresponding integer is divisible by 3, otherwise \\"NO\\". Examples: >>> is_divisible_by_3([\\"123\\", \\"111111\\", \\"987654321\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> is_divisible_by_3([\\"10\\", \\"200000000000\\"]) [\\"NO\\", \\"NO\\"] # Your implementation here from solution import is_divisible_by_3 def test_is_divisible_by_3_all_yes(): assert is_divisible_by_3([\\"123\\", \\"111111\\", \\"987654321\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_is_divisible_by_3_all_no(): assert is_divisible_by_3([\\"10\\", \\"200000000000\\"]) == [\\"NO\\", \\"NO\\"] def test_is_divisible_by_3_mixed(): assert is_divisible_by_3([\\"222\\", \\"11\\", \\"300\\", \\"100000000000000\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] def test_is_divisible_by_3_single_digit(): assert is_divisible_by_3([\\"3\\", \\"1\\", \\"6\\", \\"8\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] def test_is_divisible_by_3_large_number(): assert is_divisible_by_3([\\"999999999999999999\\"]) == [\\"YES\\"] def test_is_divisible_by_3_edge_case(): assert is_divisible_by_3([\\"0\\", \\"0000\\", \\"999\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_divisible_by_3(test_cases): result = [] for number in test_cases: digit_sum = sum(int(digit) for digit in number) if digit_sum % 3 == 0: result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def find_kth_smallest(m: int, n: int, matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a sorted matrix. :param m: Number of rows in the matrix :param n: Number of columns in the matrix :param matrix: List of lists, where each sublist represents a row of the matrix :param k: The k-th smallest element to find :return: The k-th smallest element in the matrix # Your code here from solution import find_kth_smallest def test_example_case(): m = 3 n = 3 matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 assert find_kth_smallest(m, n, matrix, k) == 13 def test_single_element(): m = 1 n = 1 matrix = [ [7] ] k = 1 assert find_kth_smallest(m, n, matrix, k) == 7 def test_small_matrix(): m = 2 n = 2 matrix = [ [1, 2], [3, 4] ] k = 3 assert find_kth_smallest(m, n, matrix, k) == 3 def test_large_k(): m = 3 n = 3 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 9 assert find_kth_smallest(m, n, matrix, k) == 9 def test_first_element(): m = 3 n = 3 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 1 assert find_kth_smallest(m, n, matrix, k) == 1","solution":"def find_kth_smallest(m, n, matrix, k): Returns the k-th smallest element in a sorted matrix. :param m: Number of rows in the matrix :param n: Number of columns in the matrix :param matrix: List of lists, where each sublist represents a row of the matrix :param k: The k-th smallest element to find :return: The k-th smallest element in the matrix import heapq # Create a min-heap min_heap = [] # Initialize heap with the first element of each row for r in range(min(len(matrix), k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min from heap k times num_count = 0 while min_heap: val, r, c = heapq.heappop(min_heap) num_count += 1 if num_count == k: return val if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) # Example usage: # m = 3 # n = 3 # matrix = [ # [1, 5, 9], # [10, 11, 13], # [12, 13, 15] # ] # k = 8 # print(find_kth_smallest(m, n, matrix, k)) # Output: 13"},{"question":"def busiest_distribution_center(T: int, test_cases: List[Tuple[int, List[Tuple[str, int]]]]) -> List[str]: Determine the busiest distribution center by processing the shipment data. The busiest distribution center is the one which has handled the most number of shipments within a certain time frame. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[str, int]]]]): Each test case contains the number of distribution centers, and a list of tuples with each distribution center's name and the number of shipments it has handled. Returns: List[str]: The names of the busiest distribution centers for each test case. Example: >>> busiest_distribution_center(2, [ ... (3, [(\\"centerA\\", 100), (\\"centerB\\", 150), (\\"centerC\\", 150)]), ... (2, [(\\"centerX\\", 200), (\\"centerY\\", 200)]) ... ]) [\\"centerB\\", \\"centerX\\"]","solution":"def busiest_distribution_center(T, test_cases): results = [] for i in range(T): D = test_cases[i][0] centers = test_cases[i][1] max_shipments = -1 busiest_center = None for name, shipments in centers: if shipments > max_shipments or (shipments == max_shipments and busiest_center is None): max_shipments = shipments busiest_center = name results.append(busiest_center) return results"},{"question":"def max_beauty(n, A): Returns the maximum beauty for a binary array A of length n. >>> max_beauty(5, [1, 0, 1, 1, 0]) 5 >>> max_beauty(4, [0, 0, 1, 0]) 4 def solve(t, test_cases): Solves the problem for t test cases and returns a list of results. >>> solve(2, [(5, [1, 0, 1, 1, 0]), (4, [0, 0, 1, 0])]) [5, 4] >>> solve(2, [(1, [0]), (1, [1])]) [1, 1] >>> solve(1, [(5, [0, 0, 0, 0, 0])]) [5] >>> solve(1, [(5, [1, 1, 1, 1, 1])]) [5] >>> solve(1, [(6, [1, 0, 1, 0, 1, 0])]) [6] >>> solve(1, [(100000, [1] * 100000)]) [100000]","solution":"def max_beauty(n, A): Returns the maximum beauty for a binary array A of length n. # Maximum length of subarray return n def solve(t, test_cases): results = [] for i in range(t): n, A = test_cases[i] results.append(max_beauty(n, A)) return results"},{"question":"def is_bipartite_graph(N, M, edges): Determines if a graph can be colored using exactly two colors such that no two adjacent nodes have the same color. >>> is_bipartite_graph(3, 3, [(1, 2), (1, 3), (2, 3)]) \\"NO\\" >>> is_bipartite_graph(4, 4, [(1, 2), (1, 3), (2, 4), (3, 4)]) \\"YES\\" >>> is_bipartite_graph(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) \\"NO\\" >>> is_bipartite_graph(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) \\"YES\\" >>> is_bipartite_graph(1, 0, []) \\"YES\\" >>> is_bipartite_graph(2, 1, [(1, 2)]) \\"YES\\" >>> is_bipartite_graph(3, 2, [(1, 2), (2, 3)]) \\"YES\\"","solution":"def is_bipartite_graph(N, M, edges): Determines if a graph can be colored using exactly two colors such that no two adjacent nodes have the same color. from collections import deque # Create an adjacency list adjacency_list = [[] for _ in range(N)] for u, v in edges: adjacency_list[u-1].append(v-1) adjacency_list[v-1].append(u-1) colors = [-1] * N # -1 signifies no color assigned yet def bfs(source): queue = deque([source]) colors[source] = 0 while queue: node = queue.popleft() current_color = colors[node] for neighbor in adjacency_list[node]: if colors[neighbor] == -1: # If the neighbor hasn't been colored, color it with opposite color to current node colors[neighbor] = 1 - current_color queue.append(neighbor) elif colors[neighbor] == current_color: # If the neighbor is colored and has the same color as current node, it's not bipartite return False return True # As the graph could be disconnected, we need to check each component for node in range(N): if colors[node] == -1: if not bfs(node): return \\"NO\\" return \\"YES\\""},{"question":"def is_palindrome(arr: List[int]) -> str: Determines whether the given array of integers is a palindrome. Returns \\"YES\\" if the array is a palindrome, \\"NO\\" otherwise. >>> is_palindrome([1, 2, 2, 1]) \\"YES\\" >>> is_palindrome([1, 2, 3, 4]) \\"NO\\"","solution":"def is_palindrome(arr): Determines whether the given array is a palindrome. Parameters: arr (list of int): The array of integers to check. Returns: str: \\"YES\\" if the array is a palindrome, \\"NO\\" otherwise. return \\"YES\\" if arr == arr[::-1] else \\"NO\\" def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) arr = [int(x) for x in data[1:n+1]] print(is_palindrome(arr)) if __name__ == \\"__main__\\": main()"},{"question":"def parse_input_output(input_text): Parse the input text and determine how the announcer should call each participant's name. Args: input_text (str): Input string containing test cases as described in the task description. Returns: str: The expected output format for the names of participants after processing all test cases. >>> input_text = '''2 ... 3 ... john newyork ... mike losangeles ... john boston ... 4 ... alice seattle ... bob seattle ... alice seattle ... charlie seattle''' >>> print(parse_input_output(input_text)) john newyork mike john boston alice seattle bob alice seattle charlie","solution":"def resolve_names(test_cases): results = [] for case in test_cases: n, participants = case city_map = {} result_for_case = [] for first_name, city_name in participants: if first_name not in city_map: city_map[first_name] = {} if city_name not in city_map[first_name]: city_map[first_name][city_name] = 0 city_map[first_name][city_name] += 1 for first_name, city_name in participants: if len(city_map[first_name]) == 1 and city_map[first_name][city_name] == 1: result_for_case.append(first_name) else: result_for_case.append(f\\"{first_name} {city_name}\\") results.append(result_for_case) return results # Function to parse input and format output def parse_input_output(input_text): lines = input_text.strip().split(\\"n\\") index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 participants = [] for _ in range(N): participant_info = lines[index].split() participants.append(participant_info) index += 1 test_cases.append((N, participants)) results = resolve_names(test_cases) return 'n'.join('n'.join(result) for result in results)"},{"question":"def max_unique_locks(n, keys): Determine the maximum number of unique locks Annie can unlock from the given sequence of keys. Parameters: n (int): the number of unique locks (and keys). keys (list): the sequence of keys. Returns: int: the maximum number of unique locks that can be opened. >>> max_unique_locks(5, [4, 5, 5, 2, 3, 1, 4, 2, 3]) == 5 >>> max_unique_locks(3, [1, 1, 1, 1, 1]) == 1 >>> max_unique_locks(4, []) == 0 >>> max_unique_locks(4, [1, 2, 3, 4]) == 4 >>> max_unique_locks(3, [1, 2, 2, 3, 3, 1, 2]) == 3","solution":"def max_unique_locks(n, keys): This function calculates the maximum number of unique locks that can be opened using the given sequence of keys. Parameters: n (int): the number of unique locks (and keys). keys (list): the sequence of keys. Returns: int: the maximum number of unique locks that can be opened. opened_locks = set() unique_locks_opened = 0 for key in keys: if key not in opened_locks and key <= n: unique_locks_opened += 1 opened_locks.add(key) return unique_locks_opened"},{"question":"def can_become_palindrome(s: str) -> bool: Determines if the string can become a palindrome by removing at most one character. :param s: Input string consisting of lowercase alphabetic characters. :return: True if the string can become a palindrome by removing at most one character, False otherwise. >>> can_become_palindrome(\\"abca\\") True >>> can_become_palindrome(\\"abcd\\") False >>> can_become_palindrome(\\"abccba\\") True","solution":"def can_become_palindrome(s): Determines if the string can become a palindrome by removing at most one character. :param s: Input string consisting of lowercase alphabetic characters. :return: True if the string can become a palindrome by removing at most one character, False otherwise. def is_palindrome_range(l, r): while l < r: if s[l] != s[r]: return False l += 1 r -= 1 return True l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: return is_palindrome_range(l+1, r) or is_palindrome_range(l, r-1) l += 1 r -= 1 return True"},{"question":"class Queue: def __init__(self, max_size): self.queue = [] self.max_size = max_size def enqueue(self, x): Add an element to the end of the queue. Args: x (int): The integer to be enqueued. Returns: str: \\"ERROR\\" if the queue exceeds its maximum size, else None. pass def dequeue(self): Remove an element from the front of the queue. Returns: str: \\"ERROR\\" if the queue is empty, else the dequeued element. pass def get_front(self): Return the element at the front of the queue without removing it. Returns: str: \\"ERROR\\" if the queue is empty, else the front element. pass def get_size(self): Return the current size of the queue. Returns: int: The current size of the queue. pass def is_empty(self): Check if the queue is empty. Returns: bool: True if the queue is empty, False otherwise. pass def process_operations(operations, max_size): Processes a series of operations on the queue and prints the appropriate responses. Args: operations (list): A list of operations to process. max_size (int): The maximum size of the queue. Returns: list: The results of the operations. >>> process_operations([\\"enqueue 1\\", \\"enqueue 2\\", \\"get_front\\", \\"get_size\\", \\"dequeue\\", \\"get_front\\", \\"get_size\\", \\"dequeue\\", \\"dequeue\\", \\"is_empty\\"], 5) [\\"1\\", \\"2\\", \\"2\\", \\"1\\", \\"ERROR\\", \\"true\\"] >>> process_operations([\\"enqueue 1\\", \\"enqueue 2\\", \\"enqueue 3\\", \\"enqueue 4\\", \\"enqueue 5\\", \\"enqueue 6\\"], 5) [\\"ERROR\\"] >>> process_operations([\\"dequeue\\"], 5) [\\"ERROR\\"] >>> process_operations([\\"get_front\\"], 5) [\\"ERROR\\"] >>> process_operations([\\"is_empty\\", \\"enqueue 1\\", \\"is_empty\\", \\"dequeue\\", \\"is_empty\\"], 5) [\\"true\\", \\"false\\", \\"true\\"] pass","solution":"class Queue: def __init__(self, max_size): self.queue = [] self.max_size = max_size def enqueue(self, x): if len(self.queue) < self.max_size: self.queue.append(x) else: return \\"ERROR\\" def dequeue(self): if self.queue: return self.queue.pop(0) else: return \\"ERROR\\" def get_front(self): if self.queue: return self.queue[0] else: return \\"ERROR\\" def get_size(self): return len(self.queue) def is_empty(self): return len(self.queue) == 0 def process_operations(operations, max_size): q = Queue(max_size) results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"enqueue\\": result = q.enqueue(int(parts[1])) if result == \\"ERROR\\": results.append(\\"ERROR\\") elif command == \\"dequeue\\": result = q.dequeue() if result == \\"ERROR\\": results.append(\\"ERROR\\") elif command == \\"get_front\\": result = q.get_front() if result == \\"ERROR\\": results.append(\\"ERROR\\") else: results.append(str(result)) elif command == \\"get_size\\": results.append(str(q.get_size())) elif command == \\"is_empty\\": results.append(\\"true\\" if q.is_empty() else \\"false\\") return results"},{"question":"from typing import List, Tuple def min_cost_to_connect_all_cities(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum possible cost to connect all cities with the given roads. Args: N (int): The number of cities. M (int): The number of potential roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing a road between cities u and v with cost w. Returns: int: The minimum possible cost to connect all cities. If it is impossible to connect all the cities, return -1. Examples: >>> min_cost_to_connect_all_cities(4, 5, [(1, 2, 3), (1, 3, 4), (4, 2, 2), (4, 3, 5), (3, 2, 6)]) 9 >>> min_cost_to_connect_all_cities(3, 1, [(1, 2, 7)]) -1 def test_min_cost_to_connect_all_cities(): assert min_cost_to_connect_all_cities(4, 5, [(1, 2, 3), (1, 3, 4), (4, 2, 2), (4, 3, 5), (3, 2, 6)]) == 9 assert min_cost_to_connect_all_cities(3, 1, [(1, 2, 7)]) == -1 assert min_cost_to_connect_all_cities(2, 1, [(1, 2, 1)]) == 1 assert min_cost_to_connect_all_cities(5, 7, [(1, 2, 2), (1, 3, 3), (2, 3, 4), (2, 4, 2), (3, 4, 5), (4, 5, 6), (2, 5, 8)]) == 13 assert min_cost_to_connect_all_cities(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 3)]) == 2","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def min_cost_to_connect_all_cities(N, M, roads): # If there are too few edges, we cannot connect all cities if M < N - 1: return -1 roads.sort(key=lambda x: x[2]) # Sort by cost parent = list(range(N + 1)) rank = [0] * (N + 1) mst_cost = 0 edges_used = 0 for u, v, w in roads: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w edges_used += 1 # If we have used exactly N-1 edges, we have our MST if edges_used == N - 1: return mst_cost # If we exit the loop without having used N-1 edges, it's impossible to connect all cities return -1"},{"question":"from typing import List, Tuple def floyd_warshall(n: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]: Uses Floyd-Warshall algorithm to compute shortest paths between all pairs of nodes. Parameters: n (int): The number of nodes. edges (list of tuples): Each tuple represents an edge (u, v, l) where u and v are nodes and l is the latency. Returns: dist (list of lists): dist[i][j] will be the minimum latency from node i to node j. pass def handle_queries(n: int, dist: List[List[int]], queries: List[Tuple[int, int]]) -> List[int]: Handles the queries to find the minimum latency between pairs of nodes. Parameters: n (int): The number of nodes. dist (list of lists): Precomputed distance matrix. queries (list of tuples): Each tuple represents a query (a, b). Returns: results (list of int): Result for each query. pass def main(n: int, m: int, q: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: dist = floyd_warshall(n, edges) results = handle_queries(n, dist, queries) return results","solution":"def floyd_warshall(n, edges): Uses Floyd-Warshall algorithm to compute shortest paths between all pairs of nodes. Parameters: n (int): The number of nodes. edges (list of tuples): Each tuple represents an edge (u, v, l) where u and v are nodes and l is the latency. Returns: dist (list of lists): dist[i][j] will be the minimum latency from node i to node j. # Initialize the distance between every pair of nodes to infinity inf = float('inf') dist = [[inf] * n for _ in range(n)] # Distance to self is zero for i in range(n): dist[i][i] = 0 # Initialize distances based on direct edges for u, v, l in edges: dist[u-1][v-1] = l dist[v-1][u-1] = l # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][k] < inf and dist[k][j] < inf: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist def handle_queries(n, dist, queries): Handles the queries to find the minimum latency between pairs of nodes. Parameters: n (int): The number of nodes. dist (list of lists): Precomputed distance matrix. queries (list of tuples): Each tuple represents a query (a, b). Returns: results (list of int): Result for each query. results = [] for a, b in queries: latency = dist[a-1][b-1] if latency == float('inf'): results.append(-1) else: results.append(latency) return results def main(n, m, q, edges, queries): dist = floyd_warshall(n, edges) results = handle_queries(n, dist, queries) return results"},{"question":"import math from typing import List, Tuple class CardCollection: def __init__(self, values: List[int]): self.values = values def is_prime(self, n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(math.sqrt(n)) for i in range(3, max_divisor + 1, 2): if n % i == 0: return False return True def update(self, i: int, x: int) -> None: Update the card at index i to the new value x. self.values[i - 1] = x def count_primes_in_range(self, L: int, R: int) -> int: Count the number of primes in the range from L to R (inclusive). >>> cards = CardCollection([1, 6, 3, 7, 5]) >>> cards.count_primes_in_range(1, 3) 1 >>> cards.count_primes_in_range(1, 5) 3 count = 0 for i in range(L - 1, R): if self.is_prime(self.values[i]): count += 1 return count def process_queries(N: int, card_values: List[int], M: int, queries: List[Tuple[int, int, int]]) -> List[int]: Process the queries and return the results of the count primes queries. >>> N = 5 >>> card_values = [1, 6, 3, 4, 5] >>> M = 3 >>> queries = [(2, 1, 3), (1, 4, 7), (2, 1, 5)] >>> process_queries(N, card_values, M, queries) [1, 3] card_collection = CardCollection(card_values) results = [] for query in queries: if query[0] == 1: _, i, x = query card_collection.update(i, x) elif query[0] == 2: _, L, R = query results.append(card_collection.count_primes_in_range(L, R)) return results","solution":"import math class CardCollection: def __init__(self, values): self.values = values def is_prime(self, n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(math.sqrt(n)) for i in range(3, max_divisor + 1, 2): if n % i == 0: return False return True def update(self, i, x): self.values[i - 1] = x def count_primes_in_range(self, L, R): count = 0 for i in range(L - 1, R): if self.is_prime(self.values[i]): count += 1 return count def process_queries(N, card_values, M, queries): card_collection = CardCollection(card_values) results = [] for query in queries: if query[0] == 1: _, i, x = query card_collection.update(i, x) elif query[0] == 2: _, L, R = query results.append(card_collection.count_primes_in_range(L, R)) return results"},{"question":"from typing import List def filter_valid_emails(emails: List[str]) -> List[str]: Filter out invalid email addresses and return a list of valid ones. An email address is considered valid based on the following rules: 1. The email address must contain exactly one \\"@\\" character. 2. The local part (the part before the \\"@\\") must only contain alphanumeric characters and the special characters: \\".\\", \\"_\\", \\"+\\", \\"-\\". 3. The domain part (the part after the \\"@\\") must contain at least one \\".\\" character that is not the first or the last character of the domain. 4. The position of \\".\\" in the domain should not be consecutive (e.g., \\"example..com\\" is invalid). 5. Both the local part and the domain part must be non-empty. 6. The email address should not contain any spaces. >>> filter_valid_emails([\\"valid.email@example.com\\", \\"invalid.email@.com\\", \\"another.invalid@com.\\", \\"noatsign.com\\", \\"too.many@at@signs.com\\", \\"local@domain_with_no_dot\\", \\"good.email+filter@example-domain.com\\"]) ['valid.email@example.com', 'good.email+filter@example-domain.com'] >>> filter_valid_emails([\\"valid.email@example.com\\", \\"good.email+filter@example-domain.com\\"]) ['valid.email@example.com', 'good.email+filter@example-domain.com'] >>> filter_valid_emails([\\"invalid.email.example.com\\"]) [] >>> filter_valid_emails([\\"too.many@at@signs.com\\"]) [] >>> filter_valid_emails([\\"local@domain_with_no_dot\\"]) [] >>> filter_valid_emails([\\"invalid.email@.com\\"]) [] >>> filter_valid_emails([\\"another.invalid@com.\\"]) [] >>> filter_valid_emails([\\"invalid email@domain.com\\"]) [] >>> filter_valid_emails([\\"invalid.email@exa..mple.com\\"]) [] >>> filter_valid_emails([\\"valid.email@example.com\\", \\"invalid.email@.com\\", \\"local@domain_with_no_dot\\", \\"good.email+filter@example-domain.com\\"]) ['valid.email@example.com', 'good.email+filter@example-domain.com']","solution":"import re def filter_valid_emails(emails): def is_valid_email(email): if email.count('@') != 1: return False local, domain = email.split('@') if not local or not domain: return False if not re.match(r'^[a-zA-Z0-9._+-]+', local): return False if '..' in domain: return False if domain[0] == '.' or domain[-1] == '.': return False if domain.count('.') == 0: return False if ' ' in email: return False return True return [email for email in emails if is_valid_email(email)] # Example usage: emails = [ \\"valid.email@example.com\\", \\"invalid.email@.com\\", \\"another.invalid@com.\\", \\"noatsign.com\\", \\"too.many@at@signs.com\\", \\"local@domain_with_no_dot\\", \\"good.email+filter@example-domain.com\\", ] print(filter_valid_emails(emails)) # Output: ['valid.email@example.com', 'good.email+filter@example-domain.com']"},{"question":"def reverseRows(mat): Reverses the rows of a matrix such that the first row becomes the last row, the second row becomes the second last row, and so on. :param mat: List of lists representing the matrix :return: List of lists representing the modified matrix >>> reverseRows([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 8, 9], [4, 5, 6], [1, 2, 3]] >>> reverseRows([[10, 20], [30, 40]]) [[30, 40], [10, 20]] >>> reverseRows([[1, 2], [3, 4], [5, 6]]) [[5, 6], [3, 4], [1, 2]] >>> reverseRows([[5, 10, 15], [20, 25, 30], [35, 40, 45]]) [[35, 40, 45], [20, 25, 30], [5, 10, 15]]","solution":"def reverseRows(mat): Reverses the rows of a matrix such that the first row becomes the last row, the second row becomes the second last row, and so on. :param mat: List of lists representing the matrix :return: List of lists representing the modified matrix return mat[::-1]"},{"question":"def camel_case(s: str) -> str: Converts a given string into camelCase. >>> camel_case(\\"hello world\\") == \\"helloWorld\\" >>> camel_case(\\"This is a test\\") == \\"thisIsATest\\" >>> camel_case(\\"another example here\\") == \\"anotherExampleHere\\"","solution":"def camel_case(s): Converts a given string into camelCase. Parameters: s (str): The input string. Returns: str: The camelCase version of the string. words = s.strip().split() if not words: return '' first_word = words[0].lower() other_words = [word.capitalize() for word in words[1:]] return first_word + ''.join(other_words)"},{"question":"def longest_substring_two_distinct(s: str) -> str: Find the longest substring of a given string that contains at most two distinct characters. >>> longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") \\"bcbbbbcccb\\" >>> longest_substring_two_distinct(\\"eceba\\") \\"ece\\"","solution":"def longest_substring_two_distinct(s): Finds the longest substring with at most two distinct characters. n = len(s) if n < 3: return s left, right = 0, 0 freq = {} max_len, max_substr = 0, \\"\\" while right < n: if len(freq) < 3: freq[s[right]] = right right += 1 if len(freq) == 3: del_idx = min(freq.values()) del freq[s[del_idx]] left = del_idx + 1 if (right - left) > max_len or (right - left == max_len and s[left:right] < max_substr): max_len = right - left max_substr = s[left:right] return max_substr"},{"question":"def findWinner(N: int) -> str: Determines the winner of the game given an NxN grid. >>> findWinner(1) 'Alice' >>> findWinner(2) 'Bob' >>> findWinner(3) 'Alice' >>> findWinner(4) 'Bob'","solution":"def findWinner(N: int) -> str: Determines the winner of the game given an NxN grid. # Since Alice goes first, and if N is odd she will always win # by starting in the center or any cell. Bob will be forced into # a losing position. If N is even, Bob gets more opportunities # and thus he will win. return \\"Alice\\" if N % 2 == 1 else \\"Bob\\""},{"question":"def shortest_paths_from_hq(n, m, k, roads): Determines the shortest travel time from the headquarters to each intersection in the city. Parameters: n (int): Number of intersections. m (int): Number of roads. k (int): Index of the headquarter intersection. roads (list of tuples): Roads, where each road is represented as (u, v, t). u (int): Starting intersection of the road. v (int): Ending intersection of the road. t (int): Travel time between u and v. Returns: list: A list of shortest travel times from the headquarters to each intersection. \\"INF\\" if an intersection is not reachable from the headquarters. def test_shortest_paths_from_hq(): n, m, k = 5, 6, 0 roads = [ (0, 1, 2), (1, 2, 4), (0, 2, 5), (2, 3, 6), (1, 4, 10), (3, 4, 1) ] expected_output = [0, 2, 5, 11, 12] assert shortest_paths_from_hq(n, m, k, roads) == expected_output def test_no_roads(): n, m, k = 5, 0, 0 roads = [] expected_output = [0, \\"INF\\", \\"INF\\", \\"INF\\", \\"INF\\"] assert shortest_paths_from_hq(n, m, k, roads) == expected_output def test_single_intersection(): n, m, k = 1, 0, 0 roads = [] expected_output = [0] assert shortest_paths_from_hq(n, m, k, roads) == expected_output def test_disconnected_graph(): n, m, k = 4, 2, 0 roads = [ (0, 1, 1), (2, 3, 1) ] expected_output = [0, 1, \\"INF\\", \\"INF\\"] assert shortest_paths_from_hq(n, m, k, roads) == expected_output","solution":"import heapq def shortest_paths_from_hq(n, m, k, roads): Determines the shortest travel time from the headquarters to each intersection in the city. Parameters: n (int): Number of intersections. m (int): Number of roads. k (int): Index of the headquarter intersection. roads (list of tuples): Roads, where each road is represented as (u, v, t). u (int): Starting intersection of the road. v (int): Ending intersection of the road. t (int): Travel time between u and v. Returns: list: A list of shortest travel times from the headquarters to each intersection. \\"INF\\" if an intersection is not reachable from the headquarters. from collections import defaultdict import heapq # Create an adjacency list graph = defaultdict(list) for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # assuming undirected graph # Implement Dijkstra's algorithm distances = [float('inf')] * n distances[k] = 0 priority_queue = [(0, k)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Replace float('inf') with \\"INF\\" for unreachable nodes return [distance if distance != float('inf') else \\"INF\\" for distance in distances]"},{"question":"def rearrangeString(s: str) -> str: Rearranges the given string such that no two adjacent characters are the same. If no such arrangement is possible, returns an empty string. >>> rearrangeString(\\"aab\\") \\"aba\\" >>> rearrangeString(\\"aaab\\") \\"\\"","solution":"import heapq from collections import Counter def rearrangeString(s): Rearranges the given string such that no two adjacent characters are the same. If no such arrangement is possible, returns an empty string. # Count frequency of each character count = Counter(s) # Max heap to store characters by their frequency max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If previous character can still be pushed (has remaining count) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char # Decrease freq since we used one occurrence of char result_str = ''.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"import sys import math def is_prime(num): Check if a given number is a prime number. >>> is_prime(2) True >>> is_prime(4) False pass def filter_prime_fish_sizes(N, fish_sizes): Given the sequence of fish sizes, return the sequence of fish sizes that are prime numbers in the order they appeared in the original sequence. >>> filter_prime_fish_sizes(6, [4, 6, 7, 10, 11, 13]) [7, 11, 13] >>> filter_prime_fish_sizes(5, [1, 2, 3, 4, 5]) [2, 3, 5] pass def main(): input = sys.stdin.read data = input().split() N = int(data[0]) fish_sizes = list(map(int, data[1:N+1])) result = filter_prime_fish_sizes(N, fish_sizes) print(\\" \\".join(map(str, result))) if __name__ == \\"__main__\\": main()","solution":"import sys import math def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def filter_prime_fish_sizes(N, fish_sizes): prime_fish_sizes = [size for size in fish_sizes if is_prime(size)] return prime_fish_sizes # Read input from stdin def main(): input = sys.stdin.read data = input().split() N = int(data[0]) fish_sizes = list(map(int, data[1:N+1])) result = filter_prime_fish_sizes(N, fish_sizes) print(\\" \\".join(map(str, result))) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def process_events(events: List[str]) -> List: Simulate a simplified scheduler that picks the highest priority process to run next. Each event is represented by a single line of input that can be one of the following: 1. \\"NEW p t\\" â€” a new process with priority p and unique PID t arrives 2. \\"RUN\\" â€” the scheduler should pick the next process to run according to the described rules 3. \\"END\\" â€” end of the input (note that this event is guaranteed to be the last event) The function processes a sequence of events related to process management and outputs the execution order of the processes. ---Input--- - The input consists of multiple lines. Each line represents one of the possible events. - The priority p is an integer between 1 and 100 inclusive. - The PID t is an integer that is unique and not negative. ---Output--- - For each \\"RUN\\" event, output the PID of the next process to be run. - If there are no processes available to run when a \\"RUN\\" event is received, output \\"NO PROCESS\\". ---Examples--- >>> process_events([ \\"NEW 10 1\\", \\"NEW 5 2\\", \\"NEW 10 3\\", \\"RUN\\", \\"RUN\\", \\"RUN\\", \\"RUN\\", \\"END\\" ]) [2, 1, 3, \\"NO PROCESS\\"] >>> process_events([ \\"RUN\\", \\"END\\" ]) [\\"NO PROCESS\\"] >>> process_events([ \\"NEW 50 1\\", \\"RUN\\", \\"RUN\\", \\"END\\" ]) [1, \\"NO PROCESS\\"] >>> process_events([ \\"NEW 10 1\\", \\"NEW 10 2\\", \\"NEW 10 3\\", \\"RUN\\", \\"RUN\\", \\"RUN\\", \\"RUN\\", \\"END\\" ]) [1, 2, 3, \\"NO PROCESS\\"] >>> process_events([ \\"NEW 50 1\\", \\"NEW 30 2\\", \\"NEW 20 3\\", \\"RUN\\", \\"RUN\\", \\"RUN\\", \\"END\\" ]) [3, 2, 1]","solution":"from collections import deque import heapq class Scheduler: def __init__(self): self.processes = [] # Min-heap to keep processes by priority and arrival order self.counter = 0 # Counter to keep track of the arrival order def new_process(self, priority, pid): heapq.heappush(self.processes, (priority, self.counter, pid)) self.counter += 1 def run_process(self): if self.processes: _, _, pid = heapq.heappop(self.processes) return pid else: return \\"NO PROCESS\\" def process_events(events): scheduler = Scheduler() result = [] for event in events: parts = event.split() if parts[0] == \\"NEW\\": _, priority, pid = parts scheduler.new_process(int(priority), int(pid)) elif parts[0] == \\"RUN\\": result.append(scheduler.run_process()) elif parts[0] == \\"END\\": break return result"},{"question":"def is_isogram(string: str) -> bool: Determines if the input string is an isogram. An isogram is a word or phrase without repeating letters, regardless of letter case. Args: string (str): The string to check. Returns: bool: True if the string is an isogram, False otherwise. >>> is_isogram(\\"Machine\\") True >>> is_isogram(\\"Programming\\") False >>> is_isogram(\\"\\") True >>> is_isogram(\\"a\\") True >>> is_isogram(\\"AbCDef\\") True >>> is_isogram(\\"aAbB\\") False","solution":"def is_isogram(string): Determines if the input string is an isogram. An isogram is a word or phrase without repeating letters, regardless of letter case. Args: string (str): The string to check. Returns: bool: True if the string is an isogram, False otherwise. cleaned_string = string.lower() return len(set(cleaned_string)) == len(cleaned_string)"},{"question":"def largestSquare(grid): Returns the area of the largest square containing only 1s. >>> grid = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> largestSquare(grid) 4 >>> grid = [[1]] >>> largestSquare(grid) 1 >>> grid = [[0]] >>> largestSquare(grid) 0 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> largestSquare(grid) 9 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> largestSquare(grid) 0 >>> grid = [ ... [1, 1, 0, 0], ... [1, 1, 0, 1], ... [0, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> largestSquare(grid) 4","solution":"def largestSquare(grid): Returns the area of the largest square containing only 1s. if not grid: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def rearrange_sequence_to_minimize_abs_difference(n: int, sequence: List[int]) -> List[int]: Rearranges the sequence to minimize the sum of absolute differences between consecutive elements. :param n: int, the number of elements in the sequence :param sequence: list of int, the elements of the sequence :return: list of int, rearranged sequence that minimizes the sum of absolute differences between consecutive elements >>> rearrange_sequence_to_minimize_abs_difference(4, [4, 2, 1, 3]) [1, 2, 3, 4] >>> rearrange_sequence_to_minimize_abs_difference(5, [10, 1, 5, 7, 2]) [1, 2, 5, 7, 10]","solution":"def rearrange_sequence_to_minimize_abs_difference(n, sequence): Rearranges the sequence to minimize the sum of absolute differences between consecutive elements. :param n: int, the number of elements in the sequence :param sequence: list of int, the elements of the sequence :return: list of int, rearranged sequence that minimizes the sum of absolute differences between consecutive elements return sorted(sequence)"},{"question":"from typing import List, Tuple def kClosest(points: List[Tuple[int, int]], K: int) -> List[Tuple[int, int]]: Find the K closest points to the origin (0, 0). Parameters: points (List[Tuple[int, int]]): List of points in 2D plane. K (int): Number of closest points to return. Returns: List[Tuple[int, int]]: K closest points to the origin. >>> kClosest([(1, 3), (-2, 2)], 1) [(-2, 2)] >>> kClosest([(3, 3), (5, -1), (-2, 4)], 2) [(3, 3), (-2, 4)] >>> kClosest([(1, 1), (0, 0), (-1, -1)], 1) [(0, 0)] >>> kClosest([(1, 1), (-1, -1), (2, 2)], 2) [(1, 1), (-1, -1)] >>> kClosest([(1, 2), (2, 1), (3, 3), (4, 4), (5, 5)], 4) [(1, 2), (2, 1), (3, 3), (4, 4)]","solution":"from heapq import nsmallest from math import sqrt def euclidean_distance(point): Compute the Euclidean distance from the origin (0, 0) for a given point. x, y = point return sqrt(x**2 + y**2) def kClosest(points, K): Find the K closest points to the origin (0, 0). Parameters: points (list of tuples): List of points in 2D plane. K (int): Number of closest points to return. Returns: list of tuples: K closest points to the origin. return nsmallest(K, points, key=euclidean_distance)"},{"question":"def uniquePaths(N: int, M: int, Maze: List[List[int]]) -> int: Find the number of unique paths from the top-left corner to the bottom-right corner in a maze. >>> uniquePaths(2, 2, [[0, 0], [1, 0]]) 1 >>> uniquePaths(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2","solution":"def uniquePaths(N, M, Maze): if Maze[0][0] == 1 or Maze[N-1][M-1] == 1: return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if Maze[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1]"},{"question":"def final_string_length(S: str) -> int: Returns the length of the resulting string after performing the operations described. Parameters: S (str): Input string consisting of lowercase letters. Returns: int: Length of the resulting string after all possible operations. >>> final_string_length(\\"abbaca\\") 2 >>> final_string_length(\\"aabccba\\") 1 >>> final_string_length(\\"abacabadabacaba\\") 15 def solve(t: int, test_cases: List[str]) -> List[int]: Solves the problem for multiple test cases. Parameters: t (int): Number of test cases. test_cases (list of str): List of test case strings. Returns: list of int: List of resulting lengths after all possible operations for each test case. >>> solve(3, [\\"abbaca\\", \\"aabccba\\", \\"abacabadabacaba\\"]) [2, 1, 15] >>> solve(2, [\\"aaaa\\", \\"abcdeedcba\\"]) [0, 0]","solution":"def final_string_length(S): Returns the length of resulting string after performing the operations described. Parameters: S (str): Input string consisting of lowercase letters. Returns: int: Length of the resulting string after all possible operations. stack = [] for char in S: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack) def solve(t, test_cases): Solves the problem for multiple test cases. Parameters: t (int): Number of test cases. test_cases (list of str): List of test case strings. Returns: list of int: List of resulting lengths after all possible operations for each test case. return [final_string_length(S) for S in test_cases]"},{"question":"from typing import List def check_palindrome_transformations(test_cases: List[str]) -> List[int]: Determine if strings can be transformed into palindromes. Args: test_cases: List of strings to check. Returns: List of integers where 1 indicates that the string can be transformed into a palindrome by rearranging its characters and removing at most one character, otherwise 0. >>> check_palindrome_transformations([\\"abca\\"]) [1] >>> check_palindrome_transformations([\\"racecar\\"]) [1] >>> check_palindrome_transformations([\\"abcdef\\"]) [0]","solution":"def can_form_palindrome_with_one_removal(S): Returns 1 if the string can be transformed into a palindrome by rearranging its characters and removing at most one character, otherwise returns 0. from collections import Counter def is_palindrome_possible(s): # Count the occurrences of each character count = Counter(s) # Find the number of characters with odd counts odd_count = sum(1 for c in count.values() if c % 2 == 1) # We can allow at most 1 odd character for the string to be a palindrome return odd_count <= 1 # First, check if the permutation of the string itself can be a palindrome if is_palindrome_possible(S): return 1 # If not, check by trying to remove one character at a time for i in range(len(S)): if is_palindrome_possible(S[:i] + S[i+1:]): return 1 return 0 def check_palindrome_transformations(test_cases): results = [] for S in test_cases: results.append(can_form_palindrome_with_one_removal(S)) return results"},{"question":"def maxSumSubarray(arr): Returns the maximum sum of any non-empty subarray with at most one element removed. >>> maxSumSubarray([1, -2, 0, 3]) 4 >>> maxSumSubarray([1, -2, -2, 3]) 3 >>> maxSumSubarray([-1, -1, -1, -1]) -1","solution":"def maxSumSubarray(arr): Returns the maximum sum of any non-empty subarray with at most one element removed. n = len(arr) if n == 1: return arr[0] max_ending_here = [0] * n max_starting_here = [0] * n max_so_far = arr[0] max_ending_here[0] = arr[0] for i in range(1, n): max_ending_here[i] = max(max_ending_here[i-1] + arr[i], arr[i]) max_so_far = max(max_so_far, max_ending_here[i]) max_starting_here[-1] = arr[-1] for i in range(n-2, -1, -1): max_starting_here[i] = max(max_starting_here[i+1] + arr[i], arr[i]) for i in range(1, n-1): max_so_far = max(max_so_far, max_ending_here[i-1] + max_starting_here[i+1]) return max_so_far"},{"question":"def min_shortcuts(n: int) -> int: Determines the minimum number of shortcuts required so that the maximum travel distance between any two cities is reduced to at most 2. Parameters: n (int): The number of cities in Almeria. Returns: int: The minimum number of shortcuts required. >>> min_shortcuts(5) 0 >>> min_shortcuts(6) 1","solution":"def min_shortcuts(n): Determines the minimum number of shortcuts required so that the maximum travel distance between any two cities is reduced to at most 2. Parameters: n (int): The number of cities in Almeria. Returns: int: The minimum number of shortcuts required. # For n cities arranged in a circle, if n is odd, the maximum distance is already 2 for all pairs of cities. # If n is even, the maximum distance is 3, so we need exactly one shortcut to make the maximum distance 2. return 0 if n % 2 == 1 else 1"},{"question":"def max_global_inversions(arr: List[int]) -> List[int]: Rearrange the list to maximize the number of global inversions. >>> max_global_inversions([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> max_global_inversions([10, 20, 30]) [30, 20, 10]","solution":"def max_global_inversions(arr): Rearrange the list to maximize the number of global inversions. # Sort the array in descending order arr.sort(reverse=True) return arr"},{"question":"def is_hopping_sequence(sequence: List[int]) -> str: Determines if a given sequence is a 'Hopping Sequence'. Parameters: sequence (list of int): The sequence of integers. Returns: str: \\"YES\\" if the sequence is a 'Hopping Sequence', \\"NO\\" otherwise. >>> is_hopping_sequence([1, 2, 3, 4, 5]) \\"YES\\" >>> is_hopping_sequence([1, 3, 5, 8]) \\"NO\\"","solution":"def is_hopping_sequence(sequence): Determines if a given sequence is a 'Hopping Sequence'. Parameters: sequence (list of int): The sequence of integers. Returns: str: \\"YES\\" if the sequence is a 'Hopping Sequence', \\"NO\\" otherwise. n = len(sequence) if n < 3: return \\"YES\\" for i in range(1, n-1): if sequence[i] * 2 != sequence[i-1] + sequence[i+1]: return \\"NO\\" return \\"YES\\""},{"question":"def isValidString(s: str) -> bool: This function checks if the given string containing '(', ')' and '*' is valid. >>> isValidString(\\"(*))\\") True >>> isValidString(\\"(*()\\") True >>> isValidString(\\"(()*)\\") True >>> isValidString(\\"(((*)\\") False >>> isValidString(\\"()\\") True >>> isValidString(\\"(*)\\") True >>> isValidString(\\"(*))((*)\\") True >>> isValidString(\\"(*))((*)()*\\") True >>> isValidString(\\"****\\") True >>> isValidString(\\"((*)*\\") True >>> isValidString(\\"((**)\\") True >>> isValidString(\\")()(\\") False >>> isValidString(\\"()*)\\") True","solution":"def isValidString(s): This function checks if the given string containing '(', ')' and '*' is valid. left_balance = 0 right_balance = 0 for char in s: if char == '(' or char == '*': left_balance += 1 else: left_balance -= 1 if left_balance < 0: return False for char in reversed(s): if char == ')' or char == '*': right_balance += 1 else: right_balance -= 1 if right_balance < 0: return False return True"},{"question":"from typing import List, Tuple def max_sum_after_operations(t: int, testcases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum possible value of the sum of all elements of the array after performing the allowed number of operations. Parameters: t (int): The number of test cases. testcases (List[Tuple[int, int, List[int]]]): List of tuples containing the size of the array (n), the number of allowed operations (k), and the array of integers (a). Returns: List[int]: List of maximum possible sums for each test case. Example: >>> max_sum_after_operations(3, [(5, 2, [1, 2, 3, 4, 5]), (4, 1, [10, 20, 30, 40]), (3, 2, [5, 5, 5])]) [15, 100, 15] results = [] for testcase in testcases: n, k, arr = testcase # To be implemented return results","solution":"def max_sum_after_operations(t, testcases): results = [] for testcase in testcases: n, k, arr = testcase results.append(sum(arr)) return results"},{"question":"from typing import List def segregate_even_odd(nums: List[int]) -> List[int]: Reorders the array such that all even integers are at the beginning followed by all the odd integers. :param nums: List of integers :return: New list with evens followed by odds pass def test_segregate_even_odd_mixed(): result = segregate_even_odd([1, 2, 3, 4]) assert all(x % 2 == 0 for x in result[:2]) and all(x % 2 != 0 for x in result[2:]) result = [2, 4, 1, 3] def test_segregate_even_odd_all_numbers(): result = segregate_even_odd([7, 3, 6, 8, 5, 4]) assert all(x % 2 == 0 for x in result[:3]) and all(x % 2 != 0 for x in result[3:]) result = [6, 8, 4, 7, 3, 5] def test_segregate_even_odd_with_no_even_numbers(): assert segregate_even_odd([9, 15, 1, 3]) == [9, 15, 1, 3] def test_segregate_even_odd_with_no_odd_numbers(): assert segregate_even_odd([2, 4, 6, 8]) == [2, 4, 6, 8] def test_segregate_even_odd_mixed_multiple_zeros(): result = segregate_even_odd([0, 0, 1, 0]) assert all(x % 2 == 0 for x in result[:3]) and all(x % 2 != 0 for x in result[3:]) result = [0, 0, 0, 1] def test_segregate_even_odd_with_empty_list(): assert segregate_even_odd([]) == []","solution":"def segregate_even_odd(nums): Reorders the array such that all even integers are at the beginning followed by all the odd integers. :param nums: List of integers :return: New list with evens followed by odds evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def form_project_team(n: int, employees: List[List[int]]) -> Union[str, List[Tuple[int, int, int]]]: Given a list of employees in a company where each employee has a set of skills, determine if there exists an ability to form a project team where everyone in the team is connected either directly or indirectly through at least one common skill. If possible, return the connections needed. If not, return \\"impossible\\". Parameters: n (int): The number of employees. employees (List[List[int]]): A list where each element is a list and represents the skills of each employee. Returns: Union[str, List[Tuple[int, int, int]]]: Proof of connections in the form of a list of tuples, each containing three integers a, b, and c, where a and b are distinct employees that both possess the skill represented by c, or the string \\"impossible\\" if no such proof exists. Example: >>> form_project_team(5, [ ... [3, 100, 200, 300], ... [2, 300, 400], ... [3, 500, 200, 600], ... [1, 100], ... [2, 400, 500], ... ]) ... # Expected output: a list of tuples representing valid connections or \\"impossible\\" >>> form_project_team(2, [[1, 1], [1, 2]]) \\"impossible\\" >>> form_project_team(2, [[1, 1], [1, 1]]) [(1, 2, 1)] import pytest def test_form_project_team_sample_input(): assert form_project_team(5, [[3, 100, 200, 300], [2, 300, 400], [3, 500, 200, 600], [1, 100], [2, 400, 500]]) != \\"impossible\\" def test_form_project_team_minimal_case_connected(): assert form_project_team(2, [[1, 1], [1, 1]]) == [(1, 2, 1)] def test_form_project_team_minimal_case_disconnected(): assert form_project_team(2, [[1, 1], [1, 2]]) == \\"impossible\\" def test_form_project_team_directly_connected(): assert form_project_team(3, [[2, 1, 2], [1, 2], [1, 2]]) != \\"impossible\\" def test_form_project_team_large_case(): skills = list(range(1, 100001)) employees = [[100, *skills[:100]], [50, *skills[50:100]], [50, *skills[25:75]], [25, *skills[:25]]] assert form_project_team(4, employees) != \\"impossible\\"","solution":"def find(x, parent): if parent[x] != x: parent[x] = find(parent[x], parent) return parent[x] def union(x, y, parent, rank): rootX = find(x, parent) rootY = find(y, parent) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def form_project_team(n, employees): # Union-Find setup parent = list(range(n+1)) rank = [0] * (n + 1) edges = [] skill_to_employees = {} # Map skills to employees for i in range(n): for skill in employees[i][1:]: if skill not in skill_to_employees: skill_to_employees[skill] = [] skill_to_employees[skill].append(i + 1) # Create edges from employees sharing skills for skill, employee_list in skill_to_employees.items(): for i in range(1, len(employee_list)): if find(employee_list[0], parent) != find(employee_list[i], parent): union(employee_list[0], employee_list[i], parent, rank) edges.append((employee_list[0], employee_list[i], skill)) # Check if all employees are connected rep = find(1, parent) for i in range(2, n+1): if find(i, parent) != rep: return \\"impossible\\" # If connected, return the edges return edges"},{"question":"def smallest_possible_maximum(N: int, B: List[int]) -> int: Determine the smallest possible maximum integer that can be achieved in the sequence after performing the given operation any number of times. >>> smallest_possible_maximum(4, [5, 3, 8, 4]) 5 >>> smallest_possible_maximum(3, [7, 7, 7]) 7 pass import pytest def test_single_element(): assert smallest_possible_maximum(1, [1]) == 1 assert smallest_possible_maximum(1, [100]) == 100 def test_two_elements(): assert smallest_possible_maximum(2, [1, 2]) == 2 assert smallest_possible_maximum(2, [100, 50]) == 100 def test_multiple_elements(): assert smallest_possible_maximum(4, [5, 3, 8, 4]) == 5 assert smallest_possible_maximum(3, [7, 7, 7]) == 7 assert smallest_possible_maximum(6, [10, 5, 5, 10, 10, 5]) == 10 def test_large_elements(): assert smallest_possible_maximum(3, [100000, 99999, 99998]) == 100000 assert smallest_possible_maximum(4, [1, 2, 3, 100000]) == 100000 def test_alternate_pattern_elements(): assert smallest_possible_maximum(5, [5, 1, 5, 1, 5]) == 5 assert smallest_possible_maximum(5, [10, 9, 8, 7, 6]) == 10","solution":"def smallest_possible_maximum(N, B): B.sort() return B[-1]"},{"question":"def lexicographically_smallest_string(n: int, strings: List[str]) -> str: Merge n strings into one single string such that the resulting string is the lexicographically smallest possible. Args: n (int): Number of strings. strings (List[str]): A list of n strings. Returns: str: The lexicographically smallest string possible. Examples: >>> lexicographically_smallest_string(3, [\\"aab\\", \\"ab\\", \\"b\\"]) 'aab' * ((100 // len(\\"aab\\")) + 1) >>> lexicographically_smallest_string(2, [\\"banana\\", \\"apple\\"]) 'apple' * ((100 // len(\\"apple\\")) + 1)","solution":"def lexicographically_smallest_string(n, strings): # Find the lexicographically smallest string smallest_string = min(strings) # Repeat the smallest string to produce a very long string result = smallest_string * (100 // len(smallest_string) + 1) return result"},{"question":"def exist(board, word): Check if the word exists in the 2D grid of characters. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. The same letter cell may not be used more than once. Args: board: List[List[str]] : 2D grid of characters. word: str : word to search for in the grid. Returns: str: \\"YES\\" if the word can be found in the grid, otherwise \\"NO\\". >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], 'ABCCED') 'YES' >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], 'SEE') 'YES' >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], 'ABCB') 'NO' >>> exist([['A']], 'A') 'YES' >>> exist([['A', 'B'], ['C', 'D']], 'ACD') 'YES' >>> exist([['A', 'B'], ['C', 'D']], 'BCDC') 'NO' pass","solution":"def exist(board, word): def dfs(board, i, j, word): if len(word) == 0: # All the characters are checked return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]: return False tmp = board[i][j] # first character is found, check the remaining part board[i][j] = \\"#\\" # avoid visiting again # check whether can find \\"word\\" along one direction res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:]) or dfs(board, i+1, j+1, word[1:]) or dfs(board, i-1, j-1, word[1:]) or dfs(board, i+1, j-1, word[1:]) or dfs(board, i-1, j+1, word[1:]) board[i][j] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, i, j, word): return \\"YES\\" return \\"NO\\""},{"question":"def find_missing_letter(n: int, sequence: List[str]) -> str: Returns the missing letter in the given sequence. :param n: Number of elements in the sequence :param sequence: List of N lowercase letters in ascending order :return: The missing letter as a string >>> find_missing_letter(5, ['a', 'b', 'c', 'e', 'f']) 'd' >>> find_missing_letter(3, ['m', 'o', 'p']) 'n' >>> find_missing_letter(4, ['x', 'z', 'a', 'b']) 'y' >>> find_missing_letter(6, ['g', 'h', 'i', 'k', 'l', 'm']) 'j' >>> find_missing_letter(2, ['a', 'c']) 'b' >>> find_missing_letter(5, ['a', 'b', 'c', 'd', 'e']) is None True >>> find_missing_letter(3, ['u', 'v', 'w']) is None True","solution":"def find_missing_letter(n, sequence): Returns the missing letter in the given sequence. :param n: Number of elements in the sequence :param sequence: List of N lowercase letters in ascending order :return: The missing letter as a string for i in range(n - 1): if ord(sequence[i + 1]) != ord(sequence[i]) + 1: return chr(ord(sequence[i]) + 1) return None"},{"question":"from typing import List def tsp(graph: List[List[int]], start: int = 0) -> int: Solve the Traveling Salesman Problem (TSP) to find the minimum total distance that the delivery truck needs to travel to complete the route. Args: graph (List[List[int]]): A 2D list representing the distances between points. start (int, optional): Starting point index. Defaults to 0. Returns: int: The minimum total distance to visit all points and return to the start. >>> graph = [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0], ... ] >>> tsp(graph) 80 >>> graph = [ ... [0, 10], ... [10, 0], ... ] >>> tsp(graph) 20 >>> graph = [ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0], ... ] >>> tsp(graph) 64 >>> graph = [ ... [0, 20, 42, 35], ... [20, 0, 30, 34], ... [42, 30, 0, 12], ... [35, 34, 12, 0], ... ] >>> tsp(graph) 97 >>> graph = [ ... [0, 1, 1, 1], ... [1, 0, 1, 1], ... [1, 1, 0, 1], ... [1, 1, 1, 0], ... ] >>> tsp(graph) 4 pass","solution":"def tsp(graph, start=0): n = len(graph) END_STATE = (1 << n) - 1 cache = [[None] * (1 << n) for _ in range(n)] def find_path(last, visited): if visited == END_STATE: return graph[last][start] if cache[last][visited] is not None: return cache[last][visited] res = float('inf') for city in range(n): if visited & (1 << city) == 0: distance = graph[last][city] + find_path(city, visited | (1 << city)) res = min(res, distance) cache[last][visited] = res return res return find_path(start, 1 << start)"},{"question":"def find_peak(nums: List[int]) -> int: Find a peak element in a list of integers. A peak element is an element that is greater than its neighbors. For corner elements, consider only one neighbor. :param nums: List of integers :return: A peak element (an element that is greater than its neighbors) >>> find_peak([1, 3, 20, 4, 1, 0]) == 20 >>> find_peak([10, 20, 15, 7, 30, 19]) in [20, 30] >>> find_peak([5, 10, 20, 15]) == 20 >>> find_peak([10, 20, 15, 2, 23, 90, 67]) in [20, 90]","solution":"def find_peak(nums): Find a peak element in the list of integers. :param nums: List of integers :return: A peak element (an element that is greater than its neighbors) if not nums: return None left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return nums[left]"},{"question":"from datetime import datetime def calculate_fine(due_date: str, return_date: str) -> int: Calculate the fine for returning a book late. Parameters: due_date (str): The due date in \\"YYYY-MM-DD\\" format. return_date (str): The actual return date in \\"YYYY-MM-DD\\" format. Returns: int: The total fine in currency units. >>> calculate_fine(\\"2023-10-01\\", \\"2023-10-05\\") 4 >>> calculate_fine(\\"2023-10-01\\", \\"2023-09-30\\") 0 >>> calculate_fine(\\"2023-10-01\\", \\"2023-10-01\\") 0","solution":"from datetime import datetime def calculate_fine(due_date: str, return_date: str) -> int: Calculate the fine for returning a book late. Parameters: due_date (str): The due date in \\"YYYY-MM-DD\\" format. return_date (str): The actual return date in \\"YYYY-MM-DD\\" format. Returns: int: The total fine in currency units. due_date = datetime.strptime(due_date, \\"%Y-%m-%d\\") return_date = datetime.strptime(return_date, \\"%Y-%m-%d\\") if return_date <= due_date: return 0 else: delta = return_date - due_date return delta.days"},{"question":"def minimum_key(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Rick found himself in front of a treasure chest locked with a combination lock. The lock can be unlocked by providing the minimum possible numeric key, such that each digit of the key is present in the given lock combination. However, Rick can also use '0' as many times as he needs in between the digits in the final key, but no '0's should be added at the beginning of the key. Help Rick solve this puzzle and find the minimum possible numeric key. [Input] First line contains an integer t indicating the number of test cases. Next line contains an integer n denoting the length of the lock's digits followed by n space-separated integers (each between 1 to 9) denoting the lock's digits. [Output] For each test case, output one line denoting the minimum possible numeric key. [Constraints] 1 â‰¤ t â‰¤ 100 1 â‰¤ n â‰¤ 100000 1 â‰¤ digits[i] â‰¤ 9 SAMPLE INPUT 2 5 3 1 4 1 5 4 2 2 3 3 SAMPLE OUTPUT 11345 2233 >>> minimum_key(1, [(5, [3, 1, 4, 1, 5])]) ['11345'] >>> minimum_key(1, [(4, [2, 2, 3, 3])]) ['2233']","solution":"def minimum_key(t, test_cases): results = [] for i in range(t): n, digits = test_cases[i] digits.sort() result = ''.join(map(str, digits)) results.append(result) return results"},{"question":"def min_moves_to_beautiful_string(s: str) -> int: Returns the minimum number of moves required to transform the string s into a \\"beautiful\\" string, where no two adjacent characters are the same. >>> min_moves_to_beautiful_string(\\"AABBCC\\") 3 >>> min_moves_to_beautiful_string(\\"ABCABC\\") 0 >>> min_moves_to_beautiful_string(\\"AAB\\") 1 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases to determine the minimum number of moves for each case to become \\"beautiful\\". >>> process_test_cases(3, [\\"AABBCC\\", \\"ABCABC\\", \\"AAB\\"]) [3, 0, 1] >>> process_test_cases(4, [\\"AAA\\", \\"ABABAB\\", \\"A\\", \\"CCCCCC\\"]) [2, 0, 0, 5]","solution":"def min_moves_to_beautiful_string(s): Returns the minimum number of moves required to transform the string s into a \\"beautiful\\" string, where no two adjacent characters are the same. n = len(s) if n <= 1: return 0 moves = 0 for i in range(1, n): if s[i] == s[i-1]: moves += 1 return moves def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_moves_to_beautiful_string(s)) return results"},{"question":"from typing import List, Tuple def count_ways_to_divide_cities(n: int, highways: List[Tuple[int, int]]) -> int: Counts the number of ways to divide cities by building exactly one wall along the highways. Args: n (int): Number of cities. highways (List[Tuple[int, int]]): List of tuples representing highways. Returns: int: Number of ways to build exactly one wall to divide cities into two non-empty subsets. pass def test_simple_case(): n = 4 highways = [(1, 2), (2, 3), (3, 4)] assert count_ways_to_divide_cities(n, highways) == 3 def test_linear_cities(): n = 5 highways = [(1, 2), (1, 3), (3, 4), (4, 5)] assert count_ways_to_divide_cities(n, highways) == 4 def test_minimum_input(): n = 2 highways = [(1, 2)] assert count_ways_to_divide_cities(n, highways) == 1 def test_tree_structure(): n = 6 highways = [(1, 2), (1, 3), (3, 4), (3, 5), (5, 6)] assert count_ways_to_divide_cities(n, highways) == 5 def test_star_structure(): n = 5 highways = [(1, 2), (1, 3), (1, 4), (1, 5)] assert count_ways_to_divide_cities(n, highways) == 4","solution":"def count_ways_to_divide_cities(n, highways): Counts the number of ways to divide cities by building exactly one wall along the highways. Args: n (int): Number of cities. highways (List[Tuple[int, int]]): List of tuples representing highways. Returns: int: Number of ways to build exactly one wall to divide cities into two non-empty subsets. from collections import defaultdict, deque # Create adjacency list for the cities adj = defaultdict(list) for a, b in highways: adj[a].append(b) adj[b].append(a) # Find ways to divide cities by removing one edge def bfs(start): visited = [False] * (n + 1) queue = deque([start]) visited[start] = True count = 0 while queue: node = queue.popleft() count += 1 for neighbor in adj[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return count result = 0 for a, b in highways: # Temporarily remove the highway (a, b) adj[a].remove(b) adj[b].remove(a) # Use BFS or DFS to find the sizes of the two sets of cities size_a = bfs(a) size_b = n - size_a # The other subset if size_a > 0 and size_b > 0: result += 1 # Reconnect the highway (a, b) adj[a].append(b) adj[b].append(a) return result"},{"question":"def findMaxLength(N: int, P: List[int]) -> int: Find the length of the longest increasing sub-segment of books' page numbers. Args: N: int, the number of books P: List[int], the list of page numbers for each book Returns: int, the length of the longest non-decreasing sub-segment of book page numbers Examples: >>> findMaxLength(7, [100, 150, 150, 200, 90, 120, 130]) 4 >>> findMaxLength(4, [300, 250, 200, 100]) 1 >>> findMaxLength(1, [250]) 1 >>> findMaxLength(5, [100, 200, 300, 400, 500]) 5 >>> findMaxLength(4, [100, 100, 100, 100]) 4 >>> findMaxLength(8, [10, 20, 30, 10, 20, 30, 40, 50]) 5 >>> findMaxLength(3, [999999997, 999999998, 999999999]) 3 >>> findMaxLength(6, [300, 200, 100, 150, 200, 250]) 4 >>> findMaxLength(0, []) 0","solution":"def findMaxLength(N, P): Returns the length of the longest increasing (or non-decreasing) sub-segment of books based on the number of pages. if N == 0: return 0 max_length = 1 current_length = 1 for i in range(1, N): if P[i] >= P[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def unique_paths_with_obstacles(grid): Determine the number of unique paths the robot can take to reach its destination on a grid where some cells are blocked. Args: grid(List[List[int]]): A 2D grid representing the factory floor. 0 indicates an empty cell and 1 indicates a blocked cell. Returns: int: The number of unique paths from the top-left corner to the bottom-right corner. Example: >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1","solution":"def unique_paths_with_obstacles(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize a 2D DP array dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Fill the first row and first column based on obstacles for i in range(1, m): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1] # Example usage: # m, n = 3, 3 # grid = [ # [0, 0, 0], # [0, 1, 0], # [0, 0, 0] # ] # print(unique_paths_with_obstacles(grid)) # Output: 2"},{"question":"def longest_common_subsequence_interleaved(S1: str, S2: str, T: str) -> int: Determine the length of the longest common subsequence obtainable by interleaving S1 and S2 and comparing with T. Parameters: S1 (str): First string consisting of lowercase English letters. S2 (str): Second string consisting of lowercase English letters. T (str): Target string consisting of lowercase English letters with which to form the common subsequence. Returns: int: The length of the longest common subsequence. Examples: >>> longest_common_subsequence_interleaved(\\"abc\\", \\"def\\", \\"adbecf\\") 6 >>> longest_common_subsequence_interleaved(\\"abc\\", \\"def\\", \\"abcdef\\") 6","solution":"def longest_common_subsequence_interleaved(S1, S2, T): len1, len2, lenT = len(S1), len(S2), len(T) dp = [[[0] * (lenT + 1) for _ in range(len2 + 1)] for __ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): for k in range(1, lenT + 1): if S1[i - 1] == T[k - 1] and S2[j - 1] == T[k - 1]: dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1], dp[i - 1][j - 1][k - 1] + 1) elif S1[i - 1] == T[k - 1]: dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j][k - 1]) + (S1[i - 1] == T[k - 1]) elif S2[j - 1] == T[k - 1]: dp[i][j][k] = max(dp[i][j - 1][k], dp[i][j][k - 1]) + (S2[j - 1] == T[k - 1]) else: dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1]) return dp[len1][len2][lenT]"},{"question":"def sumDivisibleByK(N, arr, k): Returns the sum of all elements in the list that are divisible by k. >>> sumDivisibleByK(6, [2, 4, 5, 6, 9, 12], 3) 27 >>> sumDivisibleByK(5, [1, 2, 3, 4, 5], 2) 6","solution":"def sumDivisibleByK(N, arr, k): Returns the sum of all elements in the list that are divisible by k. return sum(x for x in arr if x % k == 0)"},{"question":"def min_groups(trials): Determine the minimum number of groups required such that each group's height difference does not exceed the given threshold. Each group can have a maximum of three students. Args: trials (List[Tuple[int, int, List[int]]]): A list of test cases. Each test case is a tuple where: - The first element is the number of students (N) - The second element is the maximum allowed difference in height within a group (D) - The third element is a list of integers representing the heights of the students Returns: List[int]: A list of integers, where each integer represents the minimum number of groups required for a corresponding test case. Example: >>> min_groups([(5, 2, [1, 3, 5, 6, 8]), (4, 3, [4, 8, 5, 7])]) [3, 2]","solution":"def min_groups(trials): results = [] for trial in trials: N, D, heights = trial heights.sort() groups = 0 i = 0 while i < N: num_in_group = 1 start_height = heights[i] while i + 1 < N and num_in_group < 3 and abs(heights[i + 1] - start_height) <= D: num_in_group += 1 i += 1 groups += 1 i += 1 results.append(groups) return results # Example usage: # trials = [ # (5, 2, [1, 3, 5, 6, 8]), # (4, 3, [4, 8, 5, 7]) # ] # print(min_groups(trials)) # Output: [3, 2]"},{"question":"def can_become_good_string(S: str) -> str: Determines if the string S can be made a \\"good\\" string by performing the described operation. A good string contains no two consecutive \`A\`s and no two consecutive \`B\`s. Args: S (str): The input string consisting of 'A' and 'B' only. Returns: str: \\"YES\\" if the string can be made good, \\"NO\\" otherwise. # Check for consecutive 'AAA' or 'BBB' if 'AAA' in S or 'BBB' in S: return \\"NO\\" return \\"YES\\" # Test cases def test_example_1(): assert can_become_good_string(\\"AABBAA\\") == \\"YES\\" def test_example_2(): assert can_become_good_string(\\"AAA\\") == \\"NO\\" def test_single_character_A(): assert can_become_good_string(\\"A\\") == \\"YES\\" def test_single_character_B(): assert can_become_good_string(\\"B\\") == \\"YES\\" def test_no_consecutive_AB(): assert can_become_good_string(\\"ABABABAB\\") == \\"YES\\" def test_no_consecutive_BA(): assert can_become_good_string(\\"BABA\\") == \\"YES\\" def test_adjacent_AAB(): assert can_become_good_string(\\"AAB\\") == \\"YES\\" def test_adjacent_BBA(): assert can_become_good_string(\\"BBA\\") == \\"YES\\" def test_adjacent_ABA(): assert can_become_good_string(\\"ABA\\") == \\"YES\\" def test_consecutive_AAA_in_longer_string(): assert can_become_good_string(\\"AABAABAAAABB\\") == \\"NO\\" def test_consecutive_BBB_in_longer_string(): assert can_become_good_string(\\"BBBAAABBB\\") == \\"NO\\"","solution":"def can_become_good_string(S): Determines if the string S can be made a \\"good\\" string by performing the described operation. A good string contains no two consecutive \`A\`s and no two consecutive \`B\`s. Args: S (str): The input string consisting of 'A' and 'B' only. Returns: str: \\"YES\\" if the string can be made good, \\"NO\\" otherwise. # Check for consecutive 'AAA' or 'BBB' if 'AAA' in S or 'BBB' in S: return \\"NO\\" return \\"YES\\""},{"question":"def minimizeDifference(stones: List[int]) -> int: This function returns the minimum possible absolute difference between the sums of two groups formed from the input list \`stones\`. Args: stones: List[int] -> list of integers representing the levels of magic stones. Returns: int: The minimum possible absolute difference between the sums of the two groups. Examples: >>> minimizeDifference([1, 6, 11, 5]) 1 >>> minimizeDifference([3, 1, 4, 2, 2]) 0 from solution import minimizeDifference def test_minimizeDifference_example1(): assert minimizeDifference([1, 6, 11, 5]) == 1 def test_minimizeDifference_example2(): assert minimizeDifference([3, 1, 4, 2, 2]) == 0 def test_minimizeDifference_single_element(): assert minimizeDifference([5]) == 5 def test_minimizeDifference_two_elements(): assert minimizeDifference([10, 20]) == 10 def test_minimizeDifference_equal_elements(): assert minimizeDifference([5, 5, 5, 5]) == 0 def test_minimizeDifference_large_sum(): assert minimizeDifference([30, 60, 90, 10, 20, 50, 40]) == 0 def test_minimizeDifference_max_elements(): assert minimizeDifference([100] * 30) == 0","solution":"def minimizeDifference(stones): This function returns the minimum possible absolute difference between the sums of two groups formed from the input list \`stones\`. total_sum = sum(stones) n = len(stones) dp = [[False for _ in range(total_sum // 2 + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if stones[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-stones[i-1]] else: dp[i][j] = dp[i-1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: sum1 = j break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"def min_water_required(N: int, heights: List[int]) -> int: Determine the minimum amount of water required such that each plant receives enough water without wasting water by watering unevenly. Ensure that the water distribution is non-decreasing from left to right. >>> min_water_required(5, [2, 4, 3, 5, 2]) 20 >>> min_water_required(3, [1, 1, 1]) 3 >>> min_water_required(4, [5, 4, 3, 2]) 20 >>> min_water_required(6, [1, 2, 3, 4, 5, 6]) 21 >>> min_water_required(2, [4, 3]) 8 >>> min_water_required(1, [1]) 1 pass","solution":"def min_water_required(N, heights): # Initialize an array to store the water distribution water = [0] * N # The first plant will get water equal to its height water[0] = heights[0] # Iterate through the plants and ensure non-decreasing water distribution for i in range(1, N): water[i] = max(heights[i], water[i-1]) # Calculate the total amount of water required return sum(water)"},{"question":"class Chessboard: A class to manage the state of an 8x8 chessboard with operations to place, remove, move, and display pieces. Methods: - place(x, y, S): Place a piece at the specified coordinates. - remove(x, y): Remove a piece from the specified coordinates. - move(x1, y1, x2, y2): Move a piece from one coordinate to another. - piece(x, y): Retrieve the piece at the specified coordinates. - display(): Display the current state of the chessboard. >>> cb = Chessboard() >>> cb.place(0, 1, 'K') >>> cb.display() .K...... ........ ........ ........ ........ ........ ........ ........ >>> cb.piece(0, 1) 'K' >>> cb.remove(0, 1) >>> cb.piece(0, 1) 'empty'","solution":"class Chessboard: def __init__(self): self.board = [['.' for _ in range(8)] for _ in range(8)] def place(self, x, y, S): self.board[x][y] = S def remove(self, x, y): self.board[x][y] = '.' def move(self, x1, y1, x2, y2): self.board[x2][y2] = self.board[x1][y1] self.board[x1][y1] = '.' def piece(self, x, y): return self.board[x][y] if self.board[x][y] != '.' else 'empty' def display(self): for row in self.board: print(''.join(row))"},{"question":"def mostFrequentChar(s: str) -> str: Returns the character that appears the most frequently in the string \`s\`. If there is a tie, returns the character that appears first among those tied. If the string is empty, returns '-1'. :param s: The input string :type s: str :return: The character with the highest frequency in the string, or '-1' if the string is empty. :rtype: str >>> mostFrequentChar(\\"hello\\") 'l' >>> mostFrequentChar(\\"test\\") 't' >>> mostFrequentChar(\\"\\") '-1' >>> mostFrequentChar(\\"abcabc\\") 'a'","solution":"def mostFrequentChar(s): Returns the character that appears the most frequently in the string \`s\`. If there is a tie, returns the character that appears first among those tied. If the string is empty, returns '-1'. if not s: return '-1' frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 most_frequent_char = None max_frequency = 0 for char in s: if frequency[char] > max_frequency: most_frequent_char = char max_frequency = frequency[char] return most_frequent_char"},{"question":"def process_list(input_list): Given a list of integers, perform the following operations: - Reverse the entire list. - Square each element of the reversed list. - Return the modified list. Examples: >>> process_list([1, 2, 3, 4]) [16, 9, 4, 1] >>> process_list([-1, -2, -3]) [9, 4, 1] pass # Unit tests def test_process_list_example_1(): assert process_list([1, 2, 3, 4]) == [16, 9, 4, 1] def test_process_list_example_2(): assert process_list([-1, -2, -3]) == [9, 4, 1] def test_process_list_single_element(): assert process_list([5]) == [25] assert process_list([-5]) == [25] def test_process_list_mixed_sign(): assert process_list([10, -10, 10]) == [100, 100, 100] def test_process_list_large_numbers(): assert process_list([100, -100, 50]) == [2500, 10000, 10000] def test_process_list_zero(): assert process_list([0, 1, 2, 3]) == [9, 4, 1, 0]","solution":"def process_list(input_list): Given a list of integers, reverse the list, square each element, and return the modified list. reversed_list = input_list[::-1] squared_list = [x ** 2 for x in reversed_list] return squared_list"},{"question":"def maxChildren(N: int) -> int: Returns the maximum number of children Geek can distribute candies to such that each child gets at least one candy and the number of candies given to each child is in increasing order. >>> maxChildren(7) 3 >>> maxChildren(10) 4 >>> maxChildren(1) 1 >>> maxChildren(1000000000) 44720 >>> maxChildren(2) 1 >>> maxChildren(14) 4","solution":"def maxChildren(N): Returns the maximum number of children Geek can distribute candies to such that each child gets at least one candy and the number of candies given to each child is in increasing order. N: int - number of candies return: int - maximum number of children # Start with k = 1 and keep increasing k while (k * (k + 1)) / 2 <= N k = 0 total = 0 while total <= N: k += 1 total += k return k - 1"},{"question":"def decode_message(n, s): Decodes the given encoded message by shifting each letter backward by n positions in the alphabet. Parameters: n (int): The fixed number of positions each letter in the message was shifted. s (str): The encoded message. Returns: str: The original sentence. pass # Unit Tests def test_decode_message_case1(): assert decode_message(3, \\"khoor zruog\\") == \\"hello world\\" def test_decode_message_case2(): assert decode_message(5, \\"mjqqt btwqi\\") == \\"hello world\\" def test_decode_message_case3(): assert decode_message(25, \\"gdkkn vnqkc\\") == \\"hello world\\" def test_decode_message_with_spaces(): assert decode_message(10, \\"rovvy gybvn\\") == \\"hello world\\" def test_decode_message_no_shift(): assert decode_message(0, \\"hello world\\") == \\"hello world\\" def test_decode_message_full_alphabet_wrap(): assert decode_message(26, \\"hello world\\") == \\"hello world\\" def test_decode_message_large_shifts(): assert decode_message(27, \\"ifmmp xpsme\\") == \\"hello world\\" # Equivalent to a shift of 1 assert decode_message(52, \\"hello world\\") == \\"hello world\\" # Equivalent to no shift","solution":"def decode_message(n, s): Decodes the given encoded message by shifting each letter backward by n positions in the alphabet. Parameters: n (int): The fixed number of positions each letter in the message was shifted. s (str): The encoded message. Returns: str: The original sentence. decoded_message = [] for char in s: if char == ' ': decoded_message.append(char) else: shifted_char = chr(((ord(char) - ord('a') - n) % 26) + ord('a')) decoded_message.append(shifted_char) return ''.join(decoded_message)"},{"question":"def min_operations(A: str, B: str) -> int: Returns the minimum number of operations required to transform string A into string B. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"intention\\", \\"execution\\") 5","solution":"def min_operations(A, B): Returns the minimum number of operations required to transform string A into string B. len_a, len_b = len(A), len(B) # Create a DP table to store results of subproblems dp = [[0 for _ in range(len_b + 1)] for _ in range(len_a + 1)] # Initialize the table for i in range(len_a + 1): dp[i][0] = i # If B is empty, all characters of A need to be deleted for j in range(len_b + 1): dp[0][j] = j # If A is empty, all characters of B need to be inserted # Fill dp table for i in range(1, len_a + 1): for j in range(1, len_b + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1])# Replace return dp[len_a][len_b]"},{"question":"def turtle_fed_optimal_food(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum possible sum of food quantities by choosing a subset of days such that no two chosen days are consecutive. >>> turtle_fed_optimal_food(2, [(4, [3, 2, 5, 10]), (3, [10, 5, 5])]) [13, 15]","solution":"def turtle_fed_optimal_food(T, cases): def max_food_quantities(N, quantities): if N == 0: return 0 elif N == 1: return quantities[0] dp = [0] * N dp[0] = quantities[0] dp[1] = max(quantities[0], quantities[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + quantities[i]) return dp[-1] results = [] for i in range(T): N = cases[i][0] quantities = cases[i][1] results.append(max_food_quantities(N, quantities)) return results # Example usage: T = 2 cases = [ (4, [3, 2, 5, 10]), (3, [10, 5, 5]) ] print(turtle_fed_optimal_food(T, cases)) # Output: [13, 15]"},{"question":"from typing import List, Tuple class Tree: def __init__(self, n: int): Initialize the tree with the given number of nodes. # Implementation here def add_edge(self, u: int, v: int, w: int): Add an edge with weight w between nodes u and v. # Implementation here def bfs(self, root: int): Perform BFS to initialize parent and depth information. # Implementation here def lca(self, u: int, v: int) -> int: Find the sum of weights of edges in the path between nodes u and v. # Implementation here def solve(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given a tree with \`N\` nodes and \`Q\` queries, returns the sum of weights of the edges in the path between nodes \`u\` and \`v\` for each query. >>> solve(5, [(1, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 3)], [(4, 5), (4, 3), (2, 5)]) [10, 15, 12] # Implementation here def test_example(): n = 5 edges = [(1, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 3)] queries = [(4, 5), (4, 3), (2, 5)] expected_output = [18, 15, 12] assert solve(n, edges, queries) == expected_output def test_single_edge(): n = 2 edges = [(1, 2, 10)] queries = [(1, 2)] expected_output = [10] assert solve(n, edges, queries) == expected_output def test_star_topology(): n = 5 edges = [(1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1)] queries = [(2, 3), (4, 5), (2, 5)] expected_output = [2, 2, 2] assert solve(n, edges, queries) == expected_output def test_linear_tree(): n = 4 edges = [(1, 2, 2), (2, 3, 3), (3, 4, 4)] queries = [(1, 4), (2, 3), (1, 3)] expected_output = [9, 3, 5] assert solve(n, edges, queries) == expected_output def test_binary_tree(): n = 7 edges = [(1, 2, 2), (1, 3, 3), (2, 4, 4), (2, 5, 5), (3, 6, 6), (3, 7, 7)] queries = [(4, 5), (4, 6), (5, 7)] expected_output = [9, 15, 17] assert solve(n, edges, queries) == expected_output","solution":"import sys from collections import defaultdict, deque class Tree: def __init__(self, n): self.n = n self.graph = defaultdict(list) self.parent = [-1] * (n + 1) self.depth = [-1] * (n + 1) self.weight_to_parent = [0] * (n + 1) def add_edge(self, u, v, w): self.graph[u].append((v, w)) self.graph[v].append((u, w)) def bfs(self, root): queue = deque([(root, 0)]) self.depth[root] = 0 while queue: u, d = queue.popleft() for v, w in self.graph[u]: if self.depth[v] == -1: self.parent[v] = u self.depth[v] = d + 1 self.weight_to_parent[v] = w queue.append((v, d + 1)) def lca(self, u, v): total_weight = 0 if self.depth[u] < self.depth[v]: u, v = v, u while self.depth[u] > self.depth[v]: total_weight += self.weight_to_parent[u] u = self.parent[u] while u != v: total_weight += self.weight_to_parent[u] + self.weight_to_parent[v] u = self.parent[u] v = self.parent[v] return total_weight def solve(n, edges, queries): tree = Tree(n) for u, v, w in edges: tree.add_edge(u, v, w) tree.bfs(1) results = [] for u, v in queries: results.append(tree.lca(u, v)) return results"},{"question":"def min_possible_height(n: int, heights: List[int], a: int, b: int) -> int: Returns the minimal height that the tallest tower can achieve in the given range of indices by only decreasing their heights. >>> min_possible_height(5, [5, 7, 9, 10, 6], 2, 4) == 7 >>> min_possible_height(6, [4, 8, 5, 9, 7, 10], 3, 6) == 7","solution":"def min_possible_height(n, heights, a, b): Returns the minimal height that the tallest tower can achieve in the given range of indices by only decreasing their heights. :param n: int - the number of towers :param heights: List[int] - heights of the towers :param a: int - start index of the range (1-indexed) :param b: int - end index of the range (1-indexed) :return: int - the minimum possible height of the tallest tower # Adjust range to be 0-indexed for Python list operations range_heights = heights[a-1:b] # The minimum possible height of the tallest tower is the minimum height in the given range return min(range_heights) # Example Usage n = 5 heights = [5, 7, 9, 10, 6] a, b = 2, 4 print(min_possible_height(n, heights, a, b)) # Output: 7"},{"question":"from typing import List def find_min_rotated(nums: List[int]) -> int: Finds the minimum element in a rotated sorted list of unique integers. :param nums: List[int] - rotated sorted list :return: int - minimum element in the list >>> find_min_rotated([3, 4, 5, 1, 2]) == 1 >>> find_min_rotated([6, 7, 8, 9, 10, 1, 2, 3, 4, 5]) == 1 >>> find_min_rotated([2, 3, 4, 5, 6, 7, 8, 9, 1]) == 1 >>> find_min_rotated([1]) == 1","solution":"def find_min_rotated(nums): Finds the minimum element in a rotated sorted list of unique integers. :param nums: List[int] - rotated sorted list :return: int - minimum element in the list left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) else: if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def closestNode(root, target): Given a Binary Search Tree (BST), find the value of the node that is closest to the target value. Parameters: root (TreeNode): The root of the BST. target (int): The target value to compare against the BST nodes. Returns: int: The value of the node that is closest to the target value. Examples: >>> bst1 = None >>> for value in [10, 5, 15, 3, 7]: ... bst1 = insert_into_bst(bst1, value) >>> closestNode(bst1, 6) 5 >>> bst2 = None >>> for value in [5, 3, 8]: ... bst2 = insert_into_bst(bst2, value) >>> closestNode(bst2, 6) 5","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) else: if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def closestNode(root, target): closest = root.value while root: if abs(root.value - target) < abs(closest - target): closest = root.value if target < root.value: root = root.left elif target > root.value: root = root.right else: break return closest"},{"question":"def min_trays(capacity, produce_weights): Determine the minimal number of trays required to hold all the produce using the greedy solution. >>> min_trays(10, [2, 3, 7, 8, 1, 4, 2, 6]) == 4 >>> min_trays(15, [2, 3, 4, 5]) == 1 >>> min_trays(5, [6, 7, 8]) == 3 >>> min_trays(10, [2, 2, 2, 2, 2, 2]) == 2 >>> min_trays(10, [9, 1, 8, 2, 7, 3, 6, 4, 5]) == 5 >>> min_trays(10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 2","solution":"def min_trays(capacity, produce_weights): trays = [] for weight in produce_weights: placed = False for tray in trays: if sum(tray) + weight <= capacity: tray.append(weight) placed = True break if not placed: trays.append([weight]) return len(trays)"},{"question":"from typing import List def findMaxSquare(grid: List[List[str]]) -> int: Given a binary matrix grid, find the largest square containing only 1's and return its area. Args: grid (List[List[str]]): Binary matrix with '0' and '1'. Returns: int: The area of the largest square containing only 1's. Examples: >>> findMaxSquare([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ... ]) 4 >>> findMaxSquare([ ... [\\"0\\",\\"1\\"], ... [\\"1\\",\\"0\\"] ... ]) 1 def test_findMaxSquare_basic_example_1(): grid = [ [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ] assert findMaxSquare(grid) == 4 def test_findMaxSquare_basic_example_2(): grid = [ [\\"0\\",\\"1\\"], [\\"1\\",\\"0\\"] ] assert findMaxSquare(grid) == 1 def test_findMaxSquare_single_row(): grid = [ [\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ] assert findMaxSquare(grid) == 1 def test_findMaxSquare_single_column(): grid = [ [\\"1\\"], [\\"1\\"], [\\"1\\"], [\\"1\\"] ] assert findMaxSquare(grid) == 1 def test_findMaxSquare_all_zeros(): grid = [ [\\"0\\",\\"0\\"], [\\"0\\",\\"0\\"] ] assert findMaxSquare(grid) == 0 def test_findMaxSquare_entire_grid(): grid = [ [\\"1\\",\\"1\\"], [\\"1\\",\\"1\\"] ] assert findMaxSquare(grid) == 4 def test_findMaxSquare_large_grid(): grid = [ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"] ] assert findMaxSquare(grid) == 25","solution":"def findMaxSquare(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if grid[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def min_deletions_to_alternate(s: str) -> int: Given a string s, which consists of characters 'a' and 'b' only, determine the minimum number of deletions required to make the string alternating. Example 1: >>> min_deletions_to_alternate(\\"aab\\") 1 Example 2: >>> min_deletions_to_alternate(\\"aaa\\") 2 Example 3: >>> min_deletions_to_alternate(\\"ababab\\") 0 Example 4: >>> min_deletions_to_alternate(\\"baaaab\\") 3","solution":"def min_deletions_to_alternate(s): Determine the minimum number of deletions required to make the string alternating. deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"def replace_words(words, dictionary): Replaces words in the list with their corresponding values in the dictionary. If a word does not exist in the dictionary, it is replaced with 'UNKNOWN'. Args: words (list of str): List of words to process. dictionary (dict): Dictionary containing words as keys and their replacements as values. Returns: list of str: New list of words after replacements. >>> replace_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], {\\"apple\\": \\"fruit\\", \\"banana\\": \\"fruit\\", \\"cherry\\": \\"fruit\\"}) [\\"fruit\\", \\"fruit\\", \\"fruit\\", \\"UNKNOWN\\"] >>> replace_words([\\"date\\", \\"fig\\", \\"grape\\"], {\\"apple\\": \\"fruit\\", \\"banana\\": \\"fruit\\", \\"cherry\\": \\"fruit\\"}) [\\"UNKNOWN\\", \\"UNKNOWN\\", \\"UNKNOWN\\"]","solution":"def replace_words(words, dictionary): Replaces words in the list with their corresponding values in the dictionary. If a word does not exist in the dictionary, it is replaced with 'UNKNOWN'. Args: words (list of str): List of words to process. dictionary (dict): Dictionary containing words as keys and their replacements as values. Returns: list of str: New list of words after replacements. return [dictionary.get(word, 'UNKNOWN') for word in words]"},{"question":"def find3Numbers(arr, n, X): Determine if there exist three elements in the array whose sum is equal to X. >>> find3Numbers([12, 3, 4, 1, 6, 9], 6, 24) True >>> find3Numbers([1, 2, 3, 4, 5], 5, 10) True >>> find3Numbers([1, 2, 3, 4, 5], 5, 20) False","solution":"def find3Numbers(arr, n, X): arr.sort() for i in range(n - 2): left = i + 1 right = n - 1 while left < right: triplet_sum = arr[i] + arr[left] + arr[right] if triplet_sum == X: return True elif triplet_sum < X: left += 1 else: right -= 1 return False"},{"question":"def longestBitonicSubarray(arr: List[int]) -> int: Given an array of integers, find the length of the longest subarray that is a bitonic sequence. A bitonic sequence is a sequence of numbers that is first strictly increasing and then strictly decreasing. >>> longestBitonicSubarray([12, 4, 78, 90, 45, 23]) 5 >>> longestBitonicSubarray([20, 4, 1, 2, 3, 4, 2, 10]) 5 >>> longestBitonicSubarray([10]) 1 >>> longestBitonicSubarray([1, 2, 3, 4]) 4 >>> longestBitonicSubarray([5, 4, 3, 2, 1]) 5 >>> longestBitonicSubarray([]) 0","solution":"def longestBitonicSubarray(arr): n = len(arr) if n < 2: return n # Arrays to store lengths of increasing and decreasing subarrays inc = [1] * n dec = [1] * n # Fill the inc[] array for i in range(1, n): if arr[i] > arr[i - 1]: inc[i] = inc[i - 1] + 1 # Fill the dec[] array for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: dec[i] = dec[i + 1] + 1 # Calculate the length of the # longest bitonic subarray max_len = 1 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"def spiralOrder(matrix): Returns the elements of the matrix in spiral order. >>> spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiralOrder([]) [] >>> spiralOrder([[1, 2, 3, 4]]) [1, 2, 3, 4] >>> spiralOrder([[1], [2], [3], [4]]) [1, 2, 3, 4] >>> spiralOrder([[1]]) [1] >>> spiralOrder([[1, 2, 3], [4, 5, 6]]) [1, 2, 3, 6, 5, 4] >>> spiralOrder([[1, 2], [3, 4], [5, 6]]) [1, 2, 4, 6, 5, 3]","solution":"def spiralOrder(matrix): Returns the elements of the matrix in spiral order. if not matrix: return [] result = [] m, n = len(matrix), len(matrix[0]) left, right, top, bottom = 0, n - 1, 0, m - 1 while left <= right and top <= bottom: # Traverse from left to right for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def calculate_derived_array(n: int, a: List[int], b: List[int]) -> List[int]: Calculate the derived array c based on the formula c[i] = max(a[i], b[i]) + min(a[i], b[i]) Args: n: int, the size of arrays \`a\` and \`b\` a: list of int, the first array b: list of int, the second array Returns: list of int, the derived array \`c\` >>> calculate_derived_array(3, [1, 3, 5], [2, 4, 6]) [3, 7, 11] >>> calculate_derived_array(4, [0, 1, 2, 3], [3, 2, 1, 0]) [3, 3, 3, 3] >>> calculate_derived_array(2, [1000000000, 1000000000], [1000000000, 1000000000]) [2000000000, 2000000000]","solution":"def calculate_derived_array(n, a, b): Calculate the derived array c based on the formula c[i] = max(a[i], b[i]) + min(a[i], b[i]) Args: n: int, the size of arrays \`a\` and \`b\` a: list of int, the first array b: list of int, the second array Returns: list of int, the derived array \`c\` c = [] for i in range(n): c.append(max(a[i], b[i]) + min(a[i], b[i])) return c"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the string s can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"racecar\\") True def rohits_palindrome_inquiry(n: int, strings: List[str]) -> List[str]: Determines for each string in a list of strings whether it can be rearranged to form a palindrome. >>> rohits_palindrome_inquiry(3, [\\"aabb\\", \\"abc\\", \\"racecar\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> rohits_palindrome_inquiry(2, [\\"civic\\", \\"deified\\"]) [\\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if the string s can be rearranged to form a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) return odd_count <= 1 def rohits_palindrome_inquiry(n, strings): Determines for each string in a list of strings whether it can be rearranged to form a palindrome. results = [] for s in strings: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_be_palindrome(n: int, sequence: List[int]) -> str: Determine if the sequence can be rearranged into a palindrome. >>> can_be_palindrome(5, [1, 2, 3, 2, 1]) \\"YES\\" >>> can_be_palindrome(4, [4, 3, 3, 4]) \\"YES\\" >>> can_be_palindrome(3, [1, 2, 3]) \\"NO\\" >>> can_be_palindrome(1, [7]) \\"YES\\" >>> can_be_palindrome(2, [5, 5]) \\"YES\\" def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases to determine if the sequences can be rearranged into palindromes. >>> test_cases = [ >>> (5, [1, 2, 3, 2, 1]), >>> (4, [4, 3, 3, 4]) >>> ] >>> process_test_cases(2, test_cases) [\\"YES\\", \\"YES\\"] >>> test_cases = [ >>> (3, [1, 2, 3]), >>> (1, [7]), >>> (2, [5, 5]) >>> ] >>> process_test_cases(3, test_cases) [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def can_be_palindrome(n, sequence): from collections import Counter count = Counter(sequence) odd_count = sum(1 for v in count.values() if v % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): n, sequence = test_cases[i] results.append(can_be_palindrome(n, sequence)) return results"},{"question":"from typing import List def combination_sum(nums: List[int], target: int) -> List[List[int]]: Given an array of integers, find all unique combinations of numbers that sum up to a given target number. Each number from the array can be used only once in the combination. The solution set must not contain duplicate combinations. >>> combination_sum([10, 1, 2, 7, 6, 1, 5], 8) [ [1, 1, 6], [1, 2, 5], [1, 7], [2, 6] ] >>> combination_sum([1, 2, 3], 10) [] >>> combination_sum([5], 5) [[5]] >>> combination_sum([2, 5, 2, 1, 2], 5) [ [1, 2, 2], [5] ] >>> combination_sum([], 5) []","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> List[List[int]]: def backtrack(start: int, target: int, path: List[int]): if target == 0: result.append(path[:]) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, target - nums[i], path) path.pop() nums.sort() result = [] backtrack(0, target, []) return result"},{"question":"def can_be_palindrome_by_removing_one_character(str_list: List[str]) -> List[str]: Given a list of strings containing only capital consonants, check if it is possible to make each string a palindrome by removing at most one character. >>> can_be_palindrome_by_removing_one_character(['BCDCB']) == ['Possible'] >>> can_be_palindrome_by_removing_one_character(['BMN']) == ['Not Possible'] >>> can_be_palindrome_by_removing_one_character(['GHQHG']) == ['Possible'] >>> can_be_palindrome_by_removing_one_character(['QWERTY']) == ['Not Possible'] >>> can_be_palindrome_by_removing_one_character(['ABCBA']) == ['Possible']","solution":"def can_be_palindrome_by_removing_one_character(str_list): Given a list of strings containing only capital consonants, this function checks if it is possible to make each string a palindrome by removing at most one character. Parameters: str_list (list of str): List of strings to be checked. Returns: list of str: 'Possible' or 'Not Possible' for each input string. def is_palindrome(s): # Helper function to check if a string is a palindrome return s == s[::-1] def check_palindrome_possibility(s): # Helper function to check if a string can be a palindrome by removing at most one character left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Skip left character or right character and check if either resulting string is a palindrome return is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1]) left += 1 right -= 1 return True # Already a palindrome or can be made a palindrome results = [] for s in str_list: if check_palindrome_possibility(s): results.append('Possible') else: results.append('Not Possible') return results"},{"question":"def calculate_fatality_rate(test_cases): Calculate the fatality rate for a given set of countries. The fatality rate is defined as the number of deaths divided by the number of confirmed cases, expressed as a percentage and rounded to two decimal places. Args: test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains the number of confirmed cases and the number of deaths. Returns: List[str]: A list of strings where each string represents the fatality rate for the corresponding test case rounded to two decimal places. Examples: >>> calculate_fatality_rate([(10000, 500), (15000, 750)]) [\\"5.00\\", \\"5.00\\"] >>> calculate_fatality_rate([(5000, 25)]) [\\"0.50\\"] >>> calculate_fatality_rate([(1, 0)]) [\\"0.00\\"] >>> calculate_fatality_rate([(10000000, 1000000)]) [\\"10.00\\"] >>> calculate_fatality_rate([(2500, 125)]) [\\"5.00\\"]","solution":"def calculate_fatality_rate(test_cases): results = [] for cases, deaths in test_cases: fatality_rate = (deaths / cases) * 100 results.append(f\\"{fatality_rate:.2f}\\") return results"},{"question":"def shift_string(s: str) -> str: Shifts each character in the input string to the next character in the alphabet. 'z' is replaced by 'a'. Spaces remain unchanged. Args: s (str): Input string containing only lowercase alphabets and spaces. Returns: str: Resulting string after shifting. >>> shift_string(\\"abcdefghijklmnopqrstuvwxyz\\") \\"bcdefghijklmnopqrstuvwxyza\\" >>> shift_string(\\"the quick brown fox\\") \\"uif rvjdl cspxo gpy\\" >>> shift_string(\\"aaa\\") \\"bbb\\" >>> shift_string(\\"zzz\\") \\"aaa\\" >>> shift_string(\\"a b c x y z\\") \\"b c d y z a\\"","solution":"def shift_string(s): Shifts each character in the input string to the next character in the alphabet. 'z' is replaced by 'a'. Spaces remain unchanged. Args: s (str): Input string containing only lowercase alphabets and spaces. Returns: str: Resulting string after shifting. new_string = [] for char in s: if char == ' ': new_string.append(char) elif char == 'z': new_string.append('a') else: new_string.append(chr(ord(char) + 1)) return ''.join(new_string)"},{"question":"def optimal_pen_dimensions(L): Given the length of fencing material L, find the dimensions of a rectangular pen that maximize the enclosed area. Parameters: L (int): Total length of fencing material. Returns: tuple: Length and Width of the pen. Examples: >>> optimal_pen_dimensions(20) (5, 5) >>> optimal_pen_dimensions(18) (4, 5) >>> optimal_pen_dimensions(10) (2, 3)","solution":"def optimal_pen_dimensions(L): Given the length of fencing material L, find the dimensions of a rectangular pen that maximize the enclosed area. Parameters: L (int): Total length of fencing material. Returns: tuple: Length and Width of the pen. # Start by checking possible dimensions max_area = 0 optimal_length = 1 optimal_width = 1 # Iterate over potential widths # Length and width sum up to L // 2 for width in range(1, L // 2): length = (L // 2) - width area = length * width if area > max_area: max_area = area optimal_length = length optimal_width = width return optimal_length, optimal_width"},{"question":"def find_max_average_subarray(nums, k): Returns the average of the subarrays of length k that have the maximum sum. Example 1: >>> find_max_average_subarray([1, 12, -5, -6, 50, 3], 4) 12.75 Example 2: >>> find_max_average_subarray([5, 5, 5, 5, 5, 5, 5], 3) 5.0 Example 3: >>> find_max_average_subarray([1, 2, 3, 4, 5, 6], 2) 5.5 Example 4: >>> find_max_average_subarray([5], 1) 5.0 Example 5: >>> find_max_average_subarray([4, 3, 2, 1], 4) 2.5","solution":"def find_max_average_subarray(nums, k): Returns the average of the subarrays of length k that have the maximum sum. n = len(nums) # Initialize the sum of the first window of size k max_sum = sum(nums[:k]) current_sum = max_sum # Traverse the array from the k-th element to the end for i in range(k, n): # Slide the window right by removing the element going out of the window # and adding the new element coming into the window current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) # Calculate and return the average of the subarray having maximum sum return max_sum / k"},{"question":"def checkEvenOdd(M: int) -> str: Given an integer M, determine if the integer is even or odd. If even, return \\"Even\\" If odd, return \\"Odd\\" Examples: >>> checkEvenOdd(7) 'Odd' >>> checkEvenOdd(12) 'Even' >>> checkEvenOdd(0) 'Even'","solution":"def checkEvenOdd(M): Returns \\"Even\\" if M is an even number, otherwise \\"Odd\\". if M % 2 == 0: return \\"Even\\" else: return \\"Odd\\""},{"question":"import heapq from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: Calculate the total area of water that can be trapped in the given elevation map. Parameters: heightMap: List[List[int]]: A 2D grid representing the elevation map. Returns: int: The total trapped water. >>> trapRainWater([ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ]) 4 >>> trapRainWater([ [3, 3, 3, 3, 3], [3, 3, 3, 3, 3] ]) 0 >>> trapRainWater([ [5] ]) 0 >>> trapRainWater([ [1, 1, 1, 1], [1, 2, 2, 1], [1, 1, 1, 1] ]) 0 >>> trapRainWater([ [1, 4, 3, 1], [3, 1, 1, 4], [2, 3, 3, 2] ]) 4","solution":"import heapq def trapRainWater(heightMap): Calculate the total area of water that can be trapped in the given elevation map. Parameters: heightMap: List[List[int]]: A 2D grid representing the elevation map. Returns: int: The total trapped water. if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] min_heap = [] # Add all boundary cells to the min heap for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heapq.heappush(min_heap, (heightMap[i][j], i, j)) visited[i][j] = True water_trapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(min_heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"from typing import List def lcs_length(strings: List[str]) -> int: Find the length of the longest common subsequence (LCS) that can be formed from all the given strings. Parameters: strings (List[str]): A list of strings. Returns: int: The length of the longest common subsequence. Examples: >>> lcs_length([\\"abc\\", \\"ac\\", \\"bca\\"]) 1 >>> lcs_length([\\"abc\\", \\"abc\\", \\"abc\\"]) 3 >>> lcs_length([\\"abcdefg\\", \\"abdfg\\", \\"acf\\"]) 2 >>> lcs_length([\\"single\\"]) 6 >>> lcs_length([\\"abc\\", \\"def\\", \\"ghi\\"]) 0 def test_lcs_length_case1(): assert lcs_length([\\"abc\\", \\"ac\\", \\"bca\\"]) == 1 def test_lcs_length_case2(): assert lcs_length([\\"abc\\", \\"abc\\", \\"abc\\"]) == 3 def test_lcs_length_case3(): assert lcs_length([\\"abcdefg\\", \\"abdfg\\", \\"acf\\"]) == 2 def test_lcs_length_single_string(): assert lcs_length([\\"single\\"]) == 6 def test_lcs_length_disjoint_strings(): assert lcs_length([\\"abc\\", \\"def\\", \\"ghi\\"]) == 0 if __name__ == \\"__main__\\": test_lcs_length_case1() test_lcs_length_case2() test_lcs_length_case3() test_lcs_length_single_string() test_lcs_length_disjoint_strings() print(\\"All tests passed.\\")","solution":"def lcs_length(strings): from functools import lru_cache @lru_cache(None) def dp(i, x, y, z): if i == len(shortest_string): return 0 max_lcs = dp(i + 1, x, y, z) for nx, jx in enumerate(positions[0][x:], start=x): if shortest_string[i] == strings[0][nx]: for ny, jy in enumerate(positions[1][y:], start=y): if shortest_string[i] == strings[1][ny]: for nz, jz in enumerate(positions[2][z:], start=z): if shortest_string[i] == strings[2][nz]: max_lcs = max(max_lcs, 1 + dp(i + 1, nx + 1, ny + 1, nz + 1)) return max_lcs n = len(strings) if n == 1: return len(strings[0]) if n > 3: raise ValueError(\\"The number of strings should be exactly 3 for this implementation.\\") shortest_string = min(strings, key=len) positions = [list() for _ in range(n)] for i in range(n): for j, char in enumerate(strings[i]): positions[i].append(j) return dp(0, 0, 0, 0) # Example usage # input: 3 strings as defined in the example n = 3 strings = [\\"abc\\", \\"ac\\", \\"bca\\"] # invoke the function longest_common_subsequence_length = lcs_length(strings) print(longest_common_subsequence_length)"},{"question":"def categorize_recipe(recipe: List[str]) -> int: Categorizes the recipe based on the presence of main ingredients: - 1 for Tomatoes - 2 for Cheese - 3 for Chocolate Arguments: recipe -- list of strings representing the recipe Returns: int -- the category number >>> categorize_recipe([ \\"100\\", \\"Summer Salad\\", \\"2 large tomatoes\\", \\"1 cucumber\\", \\"1 red onion\\", \\"2 tablespoons olive oil\\", \\"Salt and pepper to taste\\" ]) 1 >>> categorize_recipe([ \\"101\\", \\"Chocolate Cake\\", \\"200g dark chocolate\\", \\"100g butter\\", \\"150g sugar\\", \\"3 eggs\\", \\"50g flour\\" ]) 3 >>> categorize_recipe([ \\"101\\", \\"Cheese Omelette\\", \\"3 eggs\\", \\"50g cheese\\", \\"Salt to taste\\", \\"1 tablespoon butter\\" ]) 2 >>> categorize_recipe([ \\"103\\", \\"Simple Salad\\", \\"1 cucumber\\", \\"1 red onion\\", \\"2 tablespoons olive oil\\", \\"Salt and pepper to taste\\" ]) 0","solution":"def categorize_recipe(recipe): Categorizes the recipe based on the presence of main ingredients: - 1 for Tomatoes - 2 for Cheese - 3 for Chocolate Arguments: recipe -- list of strings representing the recipe Returns: int -- the category number ingredients = \\"n\\".join(recipe[2:]) if \\"tomato\\" in ingredients.lower(): return 1 elif \\"cheese\\" in ingredients.lower(): return 2 elif \\"chocolate\\" in ingredients.lower(): return 3 else: # Default return value if no main ingredient is found return 0"},{"question":"def max_subarray_sum(arr, k): Returns the maximum sum of a subarray with exactly k elements. If the list has fewer than k elements, the function returns None. >>> max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum([1, 2, 3, 4, 5], 5) 15 >>> max_subarray_sum([1, 2], 3) None >>> max_subarray_sum([], 1) None pass # Unit Tests def test_max_subarray_sum_normal_cases(): assert max_subarray_sum([1, 2, 3, 4, 5], 2) == 9 assert max_subarray_sum([1, 2, 3, 4, 5], 5) == 15 assert max_subarray_sum([-1, -2, -3, -4, -5], 2) == -3 assert max_subarray_sum([4, -1, 2, 1, 6], 3) == 9 def test_max_subarray_sum_edge_cases(): assert max_subarray_sum([1, 2], 3) == None assert max_subarray_sum([], 1) == None assert max_subarray_sum([5, 4, 3, 2, 1], 1) == 5 assert max_subarray_sum([5, 1, 3, 2, 6], 1) == 6 def test_max_subarray_sum_large_array(): assert max_subarray_sum(list(range(10000)), 10000) == sum(range(10000)) assert max_subarray_sum(list(range(10000)), 9999) == sum(range(1, 10000)) def test_max_subarray_sum_k_zero(): assert max_subarray_sum([1, 2, 3, 4, 5], 0) == None def test_max_subarray_sum_negative_k(): assert max_subarray_sum([1, 2, 3, 4, 5], -2) == None","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of a subarray with exactly k elements. If the list has fewer than k elements, the function returns None. if len(arr) < k or k <= 0: return None # Initialize the sum of the first subarray of size k max_sum = current_sum = sum(arr[:k]) # Use a sliding window to find the maximum sum of subarray with exactly k elements for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def arrange_books(n, m, k, w, book_width): Determine if it is possible to place all the books on the shelves satisfying the constraints, and if possible, print one such arrangement. Parameters: n (int): number of shelves m (int): number of books k (int): maximum number of books that can fit on any shelf w (List[int]): maximum width of each shelf book_width (List[int]): width of each book Returns: Union[int, List[List[int]]]: -1 if not possible, or a list of lists indicating the arrangement of books on shelves Examples: >>> arrange_books(3, 5, 3, [10, 10, 10], [2, 3, 4, 5, 1]) [[1, 5], [2, 4], [3]] >>> arrange_books(2, 3, 2, [6, 9], [5, 2, 3]) [[1, 3], [2]] >>> arrange_books(2, 4, 1, [5, 9], [4, 3, 5, 6]) -1","solution":"def arrange_books(n, m, k, w, book_width): book_indices = list(range(1, m + 1)) # Book indices start from 1 # Create list of tuples (width, index) and sort by width descending books_with_indices = sorted(zip(book_width, book_indices), key=lambda x: x[0]) shelves = [[] for _ in range(n)] # Result array for shelves shelf_widths = [0] * n # Current used width for each shelf shelf_books = [0] * n # Current number of books on each shelf for width, index in books_with_indices: found_shelf = False for i in range(n): if shelf_books[i] < k and (shelf_widths[i] + width) <= w[i]: shelves[i].append(index) shelf_widths[i] += width shelf_books[i] += 1 found_shelf = True break if not found_shelf: return -1 return shelves"},{"question":"def find_number_of_collaboration_groups(M: int, N: int, collaborations: List[Tuple[int, int]]) -> int: Determine the number of collaboration groups among employees. >>> find_number_of_collaboration_groups(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_number_of_collaboration_groups(4, 0, []) 4 >>> find_number_of_collaboration_groups(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> find_number_of_collaboration_groups(6, 3, [(1, 2), (3, 4), (5, 6)]) 3 >>> find_number_of_collaboration_groups(1, 0, []) 1 # Implementation here","solution":"def find_number_of_collaboration_groups(M, N, collaborations): from collections import defaultdict, deque # Create adjacency list for the graph adj_list = defaultdict(list) for a, b in collaborations: adj_list[a].append(b) adj_list[b].append(a) visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Count connected components number_of_groups = 0 for employee in range(1, M + 1): if employee not in visited: bfs(employee) number_of_groups += 1 return number_of_groups"},{"question":"def count_char_in_substring(s: str, queries: List[Tuple[int, int, str]]) -> List[int]: For each query, determine how many times the character appears in the substring Parameters: s (str): The input string queries (list of tuples): Each tuple contains two integers l, r and a character c Returns: list: A list of integers representing the count of character c in each query's substring >>> s = \\"abracadabra\\" >>> queries = [(1, 3, 'a')] >>> count_char_in_substring(s, queries) [2] >>> queries = [(1, 3, 'a'), (0, 4, 'b'), (2, 6, 'r')] >>> count_char_in_substring(s, queries) [2, 1, 1]","solution":"def count_char_in_substring(s, queries): For each query, determine how many times the character appears in the substring Parameters: s (str): The input string queries (list of tuples): Each tuple contains two integers l, r and a character c Returns: list: A list of integers representing the count of character c in each query's substring results = [] for l, r, c in queries: substring = s[l:r+1] count = substring.count(c) results.append(count) return results"},{"question":"def is_valid_product_name(product_name): Verifies if the product name follows the given naming convention. >>> is_valid_product_name(\\"A123Bc\\") True >>> is_valid_product_name(\\"X567yz\\") True >>> is_valid_product_name(\\"2fgHJ\\") False >>> is_valid_product_name(\\"Q890de\\") True pass def validate_product_names(product_names): Validates a list of product names and prints whether each name is valid or invalid. >>> validate_product_names([\\"A123Bc\\", \\"X567yz\\", \\"2fgHJ\\", \\"Q890de\\"]) [\\"Valid\\", \\"Valid\\", \\"Invalid\\", \\"Valid\\"] >>> validate_product_names([\\"A123Bc\\", \\"X567yz\\", \\"A12Bc\\", \\"abc123YZ\\"]) [\\"Valid\\", \\"Valid\\", \\"Invalid\\", \\"Invalid\\"] pass","solution":"import re def is_valid_product_name(product_name): Verifies if the product name follows the given naming convention. pattern = r'^[A-Z][0-9]{3}[A-Za-z]{2}' return bool(re.match(pattern, product_name)) def validate_product_names(product_names): Validates a list of product names and prints whether each name is valid or invalid. results = [] for name in product_names: if is_valid_product_name(name): results.append(\\"Valid\\") else: results.append(\\"Invalid\\") return results"},{"question":"def min_changes_to_identical(s: str) -> int: Determine the minimum number of changes required to make all characters in the string identical. >>> min_changes_to_identical('ABBABA') 3 >>> min_changes_to_identical('AAAAA') 0 >>> min_changes_to_identical('BBBBB') 0 >>> min_changes_to_identical('ABABAB') 3 >>> min_changes_to_identical('A') 0","solution":"def min_changes_to_identical(s): Returns the minimum number of changes required to make all characters in the string identical. count_A = s.count('A') count_B = s.count('B') # Minimum of the two counts needs to be changed to make all characters identical return min(count_A, count_B) # Example usage: # print(min_changes_to_identical(\\"ABBABA\\")) # Output: 3"},{"question":"def longest_ascending_subsequence(N: int, heights: List[int]) -> int: Returns the length of the longest ascending subsequence of mountains. >>> longest_ascending_subsequence(6, [5, 3, 4, 8, 6, 7]) 4 >>> longest_ascending_subsequence(5, [9, 8, 7, 6, 5]) 1 >>> longest_ascending_subsequence(5, [1, 2, 3, 4, 5]) 5 >>> longest_ascending_subsequence(7, [3, 4, 2, 1, 10, 6, 7]) 4 >>> longest_ascending_subsequence(7, [1, 2, 2, 2, 3, 3, 3]) 3 >>> longest_ascending_subsequence(1, [5]) 1 >>> longest_ascending_subsequence(0, []) 0 pass","solution":"def longest_ascending_subsequence(N, heights): Returns the length of the longest ascending subsequence of mountains. if N == 0: return 0 dp = [1] * N for i in range(1, N): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def min_changes_to_avoid_adjacent_duplicates(n: int, colors: List[int]) -> int: Determine the minimum number of flags that need to be changed to ensure that no two adjacent flags are of the same color. >>> min_changes_to_avoid_adjacent_duplicates(6, [1, 1, 2, 3, 3, 3]) 2 >>> min_changes_to_avoid_adjacent_duplicates(5, [3, 3, 3, 3, 3]) 2 >>> min_changes_to_avoid_adjacent_duplicates(1, [1]) 0 >>> min_changes_to_avoid_adjacent_duplicates(5, [1, 2, 3, 4, 5]) 0 >>> min_changes_to_avoid_adjacent_duplicates(4, [2, 2, 2, 2]) 2 >>> min_changes_to_avoid_adjacent_duplicates(7, [1, 2, 1, 2, 1, 2, 1]) 0 >>> min_changes_to_avoid_adjacent_duplicates(10, [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) 5 pass","solution":"def min_changes_to_avoid_adjacent_duplicates(n, colors): changes = 0 for i in range(1, n): if colors[i] == colors[i - 1]: changes += 1 if i + 1 < n and colors[i + 1] != colors[i]: colors[i] = colors[i - 1] else: colors[i] = colors[i - 1] + 1 return changes"},{"question":"def shortest_substring_with_char(s: str, c: str) -> int: This function takes a string s and a character c, and returns the length of the shortest substring of s that contains at least one occurrence of c. If the character c does not appear in the string s, it returns -1. >>> shortest_substring_with_char(\\"hello\\", \\"e\\") 1 >>> shortest_substring_with_char(\\"abc\\", \\"a\\") 1 >>> shortest_substring_with_char(\\"xyz\\", \\"x\\") 1 >>> shortest_substring_with_char(\\"abcdef\\", \\"z\\") -1 pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: This function takes a list of test cases, where each test case is a tuple containing a string s and a character c. It processes each test case using the shortest_substring_with_char function and returns a list of results. pass","solution":"def shortest_substring_with_char(s, c): This function takes a string s and a character c, and returns the length of the shortest substring of s that contains at least one occurrence of c. If the character c does not appear in the string s, it returns -1. if c not in s: return -1 shortest_length = float('inf') for i in range(len(s)): if s[i] == c: shortest_length = 1 # The character itself is a substring of length 1 break return shortest_length def process_test_cases(test_cases): results = [] for s, c in test_cases: results.append(shortest_substring_with_char(s, c)) return results"},{"question":"def remove_duplicates(nums): Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. >>> remove_duplicates([1, 1, 2]) [1, 2, \\"_\\"] >>> remove_duplicates([0,0,1,1,1,2,2,3,3,4]) [0, 1, 2, 3, 4, \\"_\\", \\"_\\", \\"_\\", \\"_\\", \\"_\\"] >>> remove_duplicates([1, 2, 3, 4]) [1, 2, 3, 4] >>> remove_duplicates([1]) [1] >>> remove_duplicates([]) []","solution":"def remove_duplicates(nums): Removes duplicates in a sorted array in-place and fills the remaining elements with '_'. if not nums: return nums unique_index = 0 for i in range(1, len(nums)): if nums[unique_index] != nums[i]: unique_index += 1 nums[unique_index] = nums[i] for i in range(unique_index + 1, len(nums)): nums[i] = \\"_\\" return nums"},{"question":"MOD = 1000000007 def valid_spell_sequences(n: int) -> int: Determine the number of valid spell sequences of length n. >>> valid_spell_sequences(2) 4 >>> valid_spell_sequences(3) 6 >>> valid_spell_sequences(4) 10 pass def process_test_cases(test_cases: List[int]) -> List[int]: Process each test case to determine the number of valid spell sequences. >>> process_test_cases([2, 3, 4]) [4, 6, 10] pass","solution":"MOD = 1000000007 def valid_spell_sequences(n): if n == 1: return 2 # \\"F\\", \\"I\\" dp = [0] * (n + 1) dp[1], dp[2] = 2, 4 # \\"F\\" or \\"I\\" for n == 1: [F, I], for n == 2: [FF, FI, IF, II] for i in range(3, n + 1): dp[i] = (dp[i-1] + dp[i-2]) % MOD return dp[n] def process_test_cases(test_cases): results = [] for n in test_cases: results.append(valid_spell_sequences(n)) return results # Input and Output Processing def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [int(data[i]) for i in range(1, T + 1)] results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def length_of_lis(nums: List[int]) -> int: Find the length of the longest strictly increasing subsequence in an array of integers. Args: nums: List[int] - A list of integers. Returns: int - The length of the longest strictly increasing subsequence. Examples: >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([5, 4, 3, 2, 1]) 1","solution":"def length_of_lis(nums): Returns the length of the longest strictly increasing subsequence in the given list of integers. if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] represents the length of the LIS ending with nums[i] for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def calculate_book_orders(programs): Calculate the minimum number of copies needed for each book based on a list of reading programs. Args: - programs (list of dict): List of dictionaries where each dictionary specifies the number of copies of each book required by a reading program. Returns: - dict: A dictionary where each key is a book name and its value is the maximum number of copies required across all reading programs. Examples: >>> programs = [ >>> {\\"BookA\\": 5, \\"BookB\\": 3}, >>> {\\"BookA\\": 1, \\"BookB\\": 4, \\"BookC\\": 2}, >>> {\\"BookA\\": 2, \\"BookB\\": 0, \\"BookC\\": 3}, >>> ] >>> calculate_book_orders(programs) {\\"BookA\\": 5, \\"BookB\\": 4, \\"BookC\\": 3} from solution import calculate_book_orders def test_calculate_book_orders_multiple_books(): programs = [ {\\"BookA\\": 5, \\"BookB\\": 3}, {\\"BookA\\": 1, \\"BookB\\": 4, \\"BookC\\": 2}, {\\"BookA\\": 2, \\"BookB\\": 0, \\"BookC\\": 3}, ] expected = {\\"BookA\\": 5, \\"BookB\\": 4, \\"BookC\\": 3} assert calculate_book_orders(programs) == expected def test_calculate_book_orders_single_program(): programs = [ {\\"BookA\\": 2, \\"BookB\\": 3, \\"BookC\\": 1} ] expected = {\\"BookA\\": 2, \\"BookB\\": 3, \\"BookC\\": 1} assert calculate_book_orders(programs) == expected def test_calculate_book_orders_with_different_books_in_programs(): programs = [ {\\"BookA\\": 2}, {\\"BookB\\": 3}, {\\"BookC\\": 1} ] expected = {\\"BookA\\": 2, \\"BookB\\": 3, \\"BookC\\": 1} assert calculate_book_orders(programs) == expected def test_calculate_book_orders_with_no_books(): programs = [{}] expected = {} assert calculate_book_orders(programs) == expected def test_calculate_book_orders_with_single_books_varied_counts(): programs = [ {\\"BookA\\": 0}, {\\"BookA\\": 3}, {\\"BookA\\": 2} ] expected = {\\"BookA\\": 3} assert calculate_book_orders(programs) == expected","solution":"def calculate_book_orders(programs): Calculate the minimum number of copies needed for each book. Args: - programs (list of dict): List of dictionaries where each dictionary specifies the number of copies of each book required by a reading program. Returns: - dict: A dictionary where each key is a book name and its value is the maximum number of copies required across all reading programs. book_orders = {} for program in programs: for book, count in program.items(): if book not in book_orders: book_orders[book] = count else: book_orders[book] = max(book_orders[book], count) return book_orders"},{"question":"def can_transform(S: str, T: str) -> str: Determines if T can be formed from S by deleting some characters without reordering the remaining. :param S: The source string :param T: The target string :return: \\"YES\\" if T can be obtained as a subsequence of S, otherwise \\"NO\\" >>> can_transform(\\"abacdef\\", \\"acdf\\") 'YES' >>> can_transform(\\"xyaab\\", \\"abc\\") 'NO' >>> can_transform(\\"abcdef\\", \\"abcdef\\") 'YES' >>> can_transform(\\"abcdef\\", \\"ace\\") 'YES' >>> can_transform(\\"abcdef\\", \\"ghij\\") 'NO' >>> can_transform(\\"abcdef\\", \\"\\") 'YES' >>> can_transform(\\"\\", \\"a\\") 'NO' >>> can_transform(\\"abc\\", \\"abcd\\") 'NO'","solution":"def can_transform(S, T): Determines if T can be formed from S by deleting some characters without reordering the remaining. :param S: The source string :param T: The target string :return: \\"YES\\" if T can be obtained as a subsequence of S, otherwise \\"NO\\" t_len = len(T) s_index = 0 t_index = 0 while s_index < len(S) and t_index < t_len: if S[s_index] == T[t_index]: t_index += 1 s_index += 1 return \\"YES\\" if t_index == t_len else \\"NO\\""},{"question":"def max_money_two_dishes(n: int, m: int, prices: List[int]) -> int: In a bustling market, food stalls offer a wide variety of dishes, each with a specific price. You are given a list of prices of dishes and the total money you have. Your objective is to purchase exactly two dishes such that the total money spent is maximized but does not exceed the money you have. However, there's a catch: the prices of the dishes must come from the list, and no dish can be purchased more than once. Args: n (int): The number of dishes available. m (int): The total money you have. prices (List[int]): The prices of the dishes. Returns: int: The maximum total money spent on two dishes without exceeding the total money given, or -1 if it is not possible to buy such two dishes. Examples: >>> max_money_two_dishes(5, 10, [2, 4, 6, 8, 3]) 10 >>> max_money_two_dishes(4, 5, [1, 3, 9, 4]) 5 >>> max_money_two_dishes(3, 7, [10, 20, 30]) -1","solution":"def max_money_two_dishes(n, m, prices): prices.sort() left, right = 0, n - 1 max_spent = -1 while left < right: total = prices[left] + prices[right] if total > m: right -= 1 else: max_spent = max(max_spent, total) left += 1 return max_spent"},{"question":"from typing import List def aggregateArray(arr: List[int]) -> List[int]: Rearranges the elements of the array such that all positive numbers appear before all negative numbers, while preserving the relative ordering of the positive numbers and the relative ordering of the negative numbers. >>> aggregateArray([3, -2, 2, -1, -7, 10, 1, -3]) [3, 2, 10, 1, -2, -1, -7, -3] >>> aggregateArray([-5, -1, -3, 4, 2]) [4, 2, -5, -1, -3] >>> aggregateArray([4, 3, 2, 1]) [4, 3, 2, 1] >>> aggregateArray([-1, -2, -3, -4]) [-1, -2, -3, -4] >>> aggregateArray([5]) [5] >>> aggregateArray([-5]) [-5] >>> aggregateArray([]) [] >>> aggregateArray([-1, -2, -3]) [-1, -2, -3] >>> aggregateArray([1, 2, 3]) [1, 2, 3] >>> aggregateArray([0, 1, 2, -1, -2]) [1, 2, -1, -2] >>> aggregateArray([0, 0, 0]) []","solution":"from typing import List def aggregateArray(arr: List[int]) -> List[int]: Rearranges the elements of the array such that all positive numbers appear before all negative numbers, while preserving the relative ordering of the positive numbers and the relative ordering of the negative numbers. positives = [num for num in arr if num > 0] negatives = [num for num in arr if num < 0] return positives + negatives"},{"question":"def minOperations(A: str, B: str) -> int: Calculate the minimum number of operations required to convert string A to string B. The allowed operations are insert, delete, and replace a character. :param A: str - The original string. :param B: str - The target string. :return: int - Minimum number of operations. >>> minOperations(\\"kitten\\", \\"sitting\\") 3 >>> minOperations(\\"flaw\\", \\"lawn\\") 2 >>> minOperations(\\"example\\", \\"example\\") 0 >>> minOperations(\\"\\", \\"abc\\") 3 >>> minOperations(\\"abc\\", \\"\\") 3 >>> minOperations(\\"a\\", \\"b\\") 1 >>> minOperations(\\"abc\\", \\"abcd\\") 1 >>> minOperations(\\"abcd\\", \\"abc\\") 1 >>> minOperations(\\"abc\\", \\"abd\\") 1 >>> minOperations(\\"intention\\", \\"execution\\") 5","solution":"def minOperations(A, B): Calculate the minimum number of operations required to convert string A to string B. The allowed operations are insert, delete, and replace a character. :param A: str - The original string. :param B: str - The target string. :return: int - Minimum number of operations. m, n = len(A), len(B) # Create a DP table to store the minimum operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the first row and column for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the rest of the DP table for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Delete dp[i][j - 1] + 1, # Insert dp[i - 1][j - 1] + 1) # Replace return dp[m][n]"},{"question":"MOD = 10**9 + 7 def perform_operations(n, q, array, operations): Perform a series of operations on an array. The operations can be: 1. \\"SET i x\\": Update the element at index i to x. 2. \\"SUM L R\\": Calculate the sum of elements from index L to R, inclusive. 3. \\"MUL L R\\": Calculate the product of elements from index L to R, inclusive. The product should be computed modulo 10^9 + 7. Parameters: - n (int): The length of the array. - q (int): The number of operations. - array (List[int]): The initial array of integers. - operations (List[List[str]]): List of operations to be performed on the array. Returns: - List[int]: The results of \\"SUM\\" and \\"MUL\\" operations. Example: >>> perform_operations(5, 6, [1, 2, 3, 4, 5], [[\\"SUM\\", \\"1\\", \\"3\\"], [\\"MUL\\", \\"2\\", \\"4\\"], [\\"SET\\", \\"3\\", \\"10\\"], [\\"SUM\\", \\"1\\", \\"3\\"], [\\"MUL\\", \\"2\\", \\"4\\"], [\\"SUM\\", \\"1\\", \\"5\\"]]) [6, 24, 13, 80, 22] # Your implementation goes here from solution import perform_operations def test_operations(): n = 5 q = 6 array = [1, 2, 3, 4, 5] operations = [ [\\"SUM\\", \\"1\\", \\"3\\"], [\\"MUL\\", \\"2\\", \\"4\\"], [\\"SET\\", \\"3\\", \\"10\\"], [\\"SUM\\", \\"1\\", \\"3\\"], [\\"MUL\\", \\"2\\", \\"4\\"], [\\"SUM\\", \\"1\\", \\"5\\"] ] result = perform_operations(n, q, array, operations) expected_result = [6, 24, 13, 80, 22] assert result == expected_result def test_operations_with_set_only(): n = 3 q = 3 array = [10, 20, 30] operations = [ [\\"SET\\", \\"1\\", \\"50\\"], [\\"SET\\", \\"2\\", \\"60\\"], [\\"SET\\", \\"3\\", \\"70\\"] ] result = perform_operations(n, q, array, operations) expected_result = [] assert result == expected_result def test_operations_with_sum_only(): n = 4 q = 2 array = [5, 7, 9, 11] operations = [ [\\"SUM\\", \\"1\\", \\"2\\"], [\\"SUM\\", \\"1\\", \\"4\\"] ] result = perform_operations(n, q, array, operations) expected_result = [12, 32] assert result == expected_result def test_operations_with_mul_only(): n = 3 q = 2 array = [2, 3, 4] operations = [ [\\"MUL\\", \\"1\\", \\"2\\"], [\\"MUL\\", \\"1\\", \\"3\\"] ] result = perform_operations(n, q, array, operations) expected_result = [6, 24] assert result == expected_result def test_operations_mixed(): n = 5 q = 5 array = [1, 3, 5, 7, 9] operations = [ [\\"SUM\\", \\"1\\", \\"3\\"], [\\"MUL\\", \\"1\\", \\"3\\"], [\\"SET\\", \\"2\\", \\"10\\"], [\\"SUM\\", \\"1\\", \\"3\\"], [\\"MUL\\", \\"2\\", \\"4\\"] ] result = perform_operations(n, q, array, operations) expected_result = [9, 15, 16, 350] assert result == expected_result","solution":"MOD = 10**9 + 7 def perform_operations(n, q, array, operations): results = [] for operation in operations: op_type = operation[0] if op_type == \\"SET\\": i, x = int(operation[1]), int(operation[2]) array[i-1] = x elif op_type == \\"SUM\\": L, R = int(operation[1]), int(operation[2]) results.append(sum(array[L-1:R])) elif op_type == \\"MUL\\": L, R = int(operation[1]), int(operation[2]) product = 1 for num in array[L-1:R]: product = (product * num) % MOD results.append(product) return results"},{"question":"from typing import List, Tuple def find_pairs_with_sum(n: int, arr: List[int], target: int) -> List[Tuple[int, int]]: Returns all unique pairs of numbers from the array that add up to the target value. Each pair and the list of pairs are sorted in ascending order. Args: n: Integer - size of the array. arr: List of integers - the elements of the array. target: Integer - the target value to which pairs must sum to. Returns: List of unique pairs sorted in required order. >>> find_pairs_with_sum(6, [1, 2, 3, 4, 3, 5], 6) [(1, 5), (2, 4), (3, 3)] >>> find_pairs_with_sum(5, [1, 2, 3, 4, 5], 10) [] >>> find_pairs_with_sum(5, [1, 1, 2, 2, 4], 3) [(1, 2)] >>> find_pairs_with_sum(6, [-1, -2, -3, -4, 1, 5], -3) [(-4, 1), (-2, -1)] >>> find_pairs_with_sum(7, [-4, -2, -1, 1, 2, 3, 4], 0) [(-4, 4), (-2, 2), (-1, 1)] >>> find_pairs_with_sum(4, [3, 3, 3, 3], 6) [(3, 3)] >>> find_pairs_with_sum(1, [5], 5) [] >>> find_pairs_with_sum(0, [], 5) []","solution":"def find_pairs_with_sum(n, arr, target): Returns all unique pairs of numbers from the array that add up to the target value. Each pair and the list of pairs are sorted in ascending order. Args: n: Integer - size of the array. arr: List of integers - the elements of the array. target: Integer - the target value to which pairs must sum to. Returns: List of unique pairs sorted in required order. arr.sort() seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return sorted(list(pairs))"},{"question":"def find_largest_k(nums): Returns the largest integer k such that both k and -k exist in the array. If there is no such integer, return 0. >>> find_largest_k([3, 2, -2, 5, -3]) 3 >>> find_largest_k([1, 2, 3, -4]) 0","solution":"def find_largest_k(nums): Returns the largest integer k such that both k and -k exist in the array. If there is no such integer, return 0. num_set = set(nums) largest_k = 0 for num in nums: if -num in num_set: largest_k = max(largest_k, abs(num)) return largest_k"},{"question":"def spiral_walk(matrix): Simulates a \\"spiral walk\\" through the given square matrix and returns the elements in the order they are encountered. :param matrix: A 2D list representing the square matrix. :return: A list of elements in spiral order. >>> spiral_walk([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_walk([[1]]) == [1] >>> spiral_walk([ ... [1, 2], ... [3, 4] ... ]) == [1, 2, 4, 3] >>> spiral_walk([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiral_walk([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) == [1, 2, 3, 4, 5, 10, 15, 20, 25, 24, 23, 22, 21, 16, 11, 6, 7, 8, 9, 14, 19, 18, 17, 12, 13]","solution":"def spiral_walk(matrix): Simulates a \\"spiral walk\\" through the given square matrix and returns the elements in the order they are encountered. :param matrix: A 2D list representing the square matrix. :return: A list of elements in spiral order. result = [] while matrix: # Add the first row to result result += matrix.pop(0) # Add the last element of each remaining row if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # Add the last row in reverse order if matrix: result += matrix.pop()[::-1] # Add the first element of each remaining row in reverse order if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"def merge_records(records1, records2): Merge two lists of student records, combining course lists for students with the same ID. Args: records1 (List[Dict[str, Union[str, List[str]]]]): First list of student records. records2 (List[Dict[str, Union[str, List[str]]]]): Second list of student records. Returns: List[Dict[str, Union[str, List[str]]]]: Merged list of student records. Example: >>> records1 = [ ... {'name': 'Alice', 'student_id': 'S001', 'courses': ['Math', 'Science']}, ... {'name': 'Bob', 'student_id': 'S002', 'courses': ['History']} ... ] >>> records2 = [ ... {'name': 'Alice B.', 'student_id': 'S001', 'courses': ['English']}, ... {'name': 'Charlie', 'student_id': 'S003', 'courses': ['Math']} ... ] >>> merge_records(records1, records2) [{'name': 'Alice', 'student_id': 'S001', 'courses': ['Math', 'Science', 'English']}, {'name': 'Bob', 'student_id': 'S002', 'courses': ['History']}, {'name': 'Charlie', 'student_id': 'S003', 'courses': ['Math']}] ... def test_merge_records_simple(): records1 = [ {'name': 'Alice', 'student_id': 'S001', 'courses': ['Math', 'Science']}, {'name': 'Bob', 'student_id': 'S002', 'courses': ['History']} ] records2 = [ {'name': 'Alice B.', 'student_id': 'S001', 'courses': ['English']}, {'name': 'Charlie', 'student_id': 'S003', 'courses': ['Math']} ] merged = merge_records(records1, records2) expected = [ {'name': 'Alice', 'student_id': 'S001', 'courses': ['Math', 'Science', 'English']}, {'name': 'Bob', 'student_id': 'S002', 'courses': ['History']}, {'name': 'Charlie', 'student_id': 'S003', 'courses': ['Math']} ] def sort_function(record): return (record['student_id'], sorted(record['courses'])) assert sorted(merged, key=sort_function) == sorted(expected, key=sort_function) def test_merge_records_no_duplicates(): records1 = [ {'name': 'Alice', 'student_id': 'S001', 'courses': ['Math']} ] records2 = [ {'name': 'Bob', 'student_id': 'S002', 'courses': ['Science']} ] merged = merge_records(records1, records2) expected = [ {'name': 'Alice', 'student_id': 'S001', 'courses': ['Math']}, {'name': 'Bob', 'student_id': 'S002', 'courses': ['Science']} ] assert merged == expected def test_merge_records_with_empty_lists(): records1 = [] records2 = [] merged = merge_records(records1, records2) expected = [] assert merged == expected def test_merge_records_some_empty_lists(): records1 = [] records2 = [ {'name': 'Alice', 'student_id': 'S001', 'courses': ['Math', 'Science']} ] merged = merge_records(records1, records2) expected = [ {'name': 'Alice', 'student_id': 'S001', 'courses': ['Math', 'Science']} ] assert merged == expected","solution":"def merge_records(records1, records2): student_dict = {} # Merge records from the first list for record in records1: student_id = record['student_id'] if student_id not in student_dict: student_dict[student_id] = record else: # Merge courses if the student exists student_dict[student_id]['courses'] = list(set(student_dict[student_id]['courses'] + record['courses'])) # Merge records from the second list for record in records2: student_id = record['student_id'] if student_id not in student_dict: student_dict[student_id] = record else: # Merge courses if the student exists student_dict[student_id]['courses'] = list(set(student_dict[student_id]['courses'] + record['courses'])) # Return the list of merged records return list(student_dict.values())"},{"question":"class Rectangle: def __init__(self, width, height): Initialize a new rectangle with the given width and height. :param width: The width of the rectangle. :param height: The height of the rectangle. self.width = width self.height = height def perimeter(self): Calculate the perimeter of the rectangle. :return: The perimeter of the rectangle. pass def area(self): Calculate the area of the rectangle. :return: The area of the rectangle. pass def scale(self, factor): Scale the dimensions of the rectangle by the given factor. :param factor: The factor to scale the dimensions by. pass # Example usage: # rect = Rectangle(2, 3) # print(rect.perimeter()) # Expected Output: 10 # print(rect.area()) # Expected Output: 6 # rect.scale(2) # print(rect.perimeter()) # Expected Output: 20 # print(rect.area()) # Expected Output: 24","solution":"class Rectangle: def __init__(self, width, height): self.width = width self.height = height def perimeter(self): return 2 * (self.width + self.height) def area(self): return self.width * self.height def scale(self, factor): self.width *= factor self.height *= factor # Example usage: rect = Rectangle(2, 3) print(rect.perimeter()) # Output: 10 print(rect.area()) # Output: 6 rect.scale(2) print(rect.perimeter()) # Output: 20 print(rect.area()) # Output: 24"},{"question":"def number_to_words(num: int) -> str: Convert a number to its English representation. >>> number_to_words(123) 'One Hundred Twenty Three' >>> number_to_words(1001) 'One Thousand One' >>> number_to_words(-45) 'Negative Forty Five' >>> number_to_words(0) 'Zero' >>> number_to_words(5) 'Five' >>> number_to_words(-5) 'Negative Five' >>> number_to_words(13) 'Thirteen' >>> number_to_words(-13) 'Negative Thirteen' >>> number_to_words(85) 'Eighty Five' >>> number_to_words(-85) 'Negative Eighty Five' >>> number_to_words(123) 'One Hundred Twenty Three' >>> number_to_words(-123) 'Negative One Hundred Twenty Three' >>> number_to_words(1001) 'One Thousand One' >>> number_to_words(-1001) 'Negative One Thousand One' >>> number_to_words(1000000) 'One Million' >>> number_to_words(-1000000) 'Negative One Million' >>> number_to_words(1234567891) 'One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One'","solution":"def number_to_words(num): Convert a number to its English representation. if num == 0: return \\"Zero\\" if num < 0: return \\"Negative \\" + number_to_words(-num) below_twenty = [ \\"Zero\\", \\"One\\", \\"Two\\", \\"Three\\", \\"Four\\", \\"Five\\", \\"Six\\", \\"Seven\\", \\"Eight\\", \\"Nine\\", \\"Ten\\", \\"Eleven\\", \\"Twelve\\", \\"Thirteen\\", \\"Fourteen\\", \\"Fifteen\\", \\"Sixteen\\", \\"Seventeen\\", \\"Eighteen\\", \\"Nineteen\\" ] tens = [ \\"\\", \\"\\", \\"Twenty\\", \\"Thirty\\", \\"Forty\\", \\"Fifty\\", \\"Sixty\\", \\"Seventy\\", \\"Eighty\\", \\"Ninety\\" ] thousands = [ \\"\\", \\"Thousand\\", \\"Million\\", \\"Billion\\" ] def words(n): if n == 0: return [] elif n < 20: return [below_twenty[n]] elif n < 100: return [tens[n // 10]] + words(n % 10) elif n < 1000: return [below_twenty[n // 100]] + ['Hundred'] + words(n % 100) else: for idx, word in enumerate(thousands): if n < 1000 ** (idx + 1): return words(n // (1000 ** idx)) + [word] + words(n % (1000 ** idx)) return ' '.join(words(num)).strip()"},{"question":"def anagramSubstring(S1: str, S2: str) -> int: Determines if S2 is an anagram of a substring of S1. Returns 1 if true, otherwise 0. >>> anagramSubstring(\\"google\\", \\"ogle\\") == 1 >>> anagramSubstring(\\"opensource\\", \\"coder\\") == 0 from solution import anagramSubstring def test_anagram_in_beginning(): assert anagramSubstring(\\"google\\", \\"ogle\\") == 1 def test_anagram_in_middle(): assert anagramSubstring(\\"abcdefg\\", \\"dec\\") == 1 def test_no_anagram(): assert anagramSubstring(\\"opensource\\", \\"coder\\") == 0 def test_single_character_anagram(): assert anagramSubstring(\\"a\\", \\"a\\") == 1 assert anagramSubstring(\\"a\\", \\"b\\") == 0 def test_same_length_anagram(): assert anagramSubstring(\\"listen\\", \\"silent\\") == 1 assert anagramSubstring(\\"triangle\\", \\"integral\\") == 1 def test_s2_longer_than_s1(): assert anagramSubstring(\\"short\\", \\"toolong\\") == 0 def test_anagram_at_end(): assert anagramSubstring(\\"abracadabra\\", \\"cad\\") == 1 def test_large_input(): s1 = \\"a\\" * 5000 + \\"b\\" * 5000 s2 = \\"a\\" * 5000 assert anagramSubstring(s1, s2) == 1 def test_large_input_no_match(): s1 = \\"a\\" * 5000 + \\"b\\" * 5000 s2 = \\"c\\" * 5000 assert anagramSubstring(s1, s2) == 0","solution":"def anagramSubstring(S1, S2): Determines if S2 is an anagram of a substring of S1. Returns 1 if true, otherwise 0. from collections import Counter len_S1 = len(S1) len_S2 = len(S2) if len_S2 > len_S1: return 0 S2_count = Counter(S2) window_count = Counter(S1[:len_S2]) if window_count == S2_count: return 1 for i in range(len_S2, len_S1): window_count[S1[i]] += 1 window_count[S1[i - len_S2]] -= 1 if window_count[S1[i - len_S2]] == 0: del window_count[S1[i - len_S2]] if window_count == S2_count: return 1 return 0"},{"question":"def longest_arithmetic_subarray(n: int, array: List[int]) -> int: Returns the length of the longest arithmetic subarray in the given sequence. >>> longest_arithmetic_subarray(5, [10, 7, 4, 6, 8]) == 3 >>> longest_arithmetic_subarray(7, [9, 7, 5, 3, 2, 0, 1]) == 4 >>> longest_arithmetic_subarray(1, [5]) == 1 >>> longest_arithmetic_subarray(5, [3, 3, 3, 3, 3]) == 5 >>> longest_arithmetic_subarray(4, [1, 2, 4, 7]) == 2 >>> longest_arithmetic_subarray(6, [10, 8, 6, 4, 4, 4]) == 4","solution":"def longest_arithmetic_subarray(n, array): Returns the length of the longest arithmetic subarray in the given sequence. if n == 1: return 1 max_length = 2 current_length = 2 current_diff = array[1] - array[0] for i in range(2, n): if array[i] - array[i - 1] == current_diff: current_length += 1 else: current_diff = array[i] - array[i - 1] current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"def top_influencers(n, m, posts): Determine the list of users in descending order based on the total number of likes received on their posts. >>> top_influencers(5, 3, [(1, 1, 20), (2, 2, 15), (1, 3, 5)]) [1, 2, 3, 4, 5] >>> top_influencers(4, 4, [(1, 1, 10), (2, 2, 20), (1, 3, 20), (3, 4, 15)]) [1, 2, 3, 4] from solution import top_influencers def test_no_posts(): assert top_influencers(5, 0, []) == [1, 2, 3, 4, 5] def test_all_posts_by_one_user(): assert top_influencers(5, 3, [(1, 1, 20), (1, 2, 30), (1, 3, 50)]) == [1, 2, 3, 4, 5] def test_multiple_users_with_equal_likes(): assert top_influencers(3, 3, [(1, 1, 10), (2, 2, 10), (3, 3, 10)]) == [1, 2, 3] def test_assorted_likes(): assert top_influencers(4, 4, [(1, 1, 10), (2, 2, 20), (1, 3, 20), (3, 4, 15)]) == [1, 2, 3, 4] def test_users_with_and_without_posts(): assert top_influencers(4, 2, [(1, 1, 30), (4, 2, 40)]) == [4, 1, 2, 3]","solution":"def top_influencers(n, m, posts): likes_count = {i: 0 for i in range(1, n+1)} # Initialize like count for each user for u, p, l in posts: likes_count[u] += l # Add likes to the respective user # Sort by total likes (descending) and user ID (ascending) sorted_users = sorted(likes_count.keys(), key=lambda x: (-likes_count[x], x)) return sorted_users # Example Input n = 4 m = 4 posts = [(1, 1, 10), (2, 2, 20), (1, 3, 20), (3, 4, 15)] print(top_influencers(n, m, posts))"},{"question":"def find_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: Given an array of integers and a target sum, return the array of all unique pairs of numbers that add up to the target sum. Each pair should be returned as a tuple and the pairs should be sorted in ascending order. The elements within each pair should also be sorted. >>> find_pairs([2, 4, 3, 5, 7, 8, -1], 7) [(-1, 8), (2, 5), (3, 4)] >>> find_pairs([1, 1, 1, 2, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 2, 3, 4], 10) [] >>> find_pairs([-1, -2, -3, 1, 2, 3], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> find_pairs([0, 0, 0, 0], 0) [(0, 0)] >>> find_pairs([1, 2, 1, 2, 3, 3], 4) [(1, 3), (2, 2)]","solution":"def find_pairs(arr, target): Returns a list of unique pairs that add up to the target sum. Each pair is returned as a tuple and sorted in ascending order. pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(pairs)"},{"question":"from typing import List def findSmallestMissingPositive(arr: List[int]) -> int: Returns the smallest positive missing integer from the list. >>> findSmallestMissingPositive([3, 4, -1, 1, 2]) 5 >>> findSmallestMissingPositive([1, 2, 0]) 3","solution":"from typing import List def findSmallestMissingPositive(arr: List[int]) -> int: n = len(arr) # Create a set of all positive numbers in the array positives = set(x for x in arr if x > 0) # Start checking from 1 upwards to find the smallest missing positive for i in range(1, n + 2): if i not in positives: return i"},{"question":"def are_isomorphic(A: str, B: str) -> bool: Determines if two given strings A and B are isomorphic. >>> are_isomorphic(\\"egg\\", \\"add\\") True >>> are_isomorphic(\\"foo\\", \\"bar\\") False >>> are_isomorphic(\\"paper\\", \\"title\\") True >>> are_isomorphic(\\"abca\\", \\"zbyz\\") True","solution":"def are_isomorphic(A: str, B: str) -> bool: Determines if two given strings A and B are isomorphic. if len(A) != len(B): return False map_A_to_B = {} map_B_to_A = {} for a, b in zip(A, B): if a in map_A_to_B: if map_A_to_B[a] != b: return False else: map_A_to_B[a] = b if b in map_B_to_A: if map_B_to_A[b] != a: return False else: map_B_to_A[b] = a return True"},{"question":"def min_partition_score(n: int, sequence: List[int]) -> int: Calculate the minimum possible total score for partitioning the sequence into strictly increasing continuous subsequences. Parameters: n (int): The length of the sequence sequence (List[int]): The sequence of integers Returns: int: The minimum possible total score >>> min_partition_score(1, [1]) == 0 >>> min_partition_score(5, [1, 2, 3, 4, 5]) == 0 >>> min_partition_score(4, [4, 3, 2, 1]) == 3 >>> min_partition_score(5, [1, 2, 3, 2, 4]) == 1 >>> min_partition_score(7, [1, 3, 2, 5, 4, 6, 7]) == 2 >>> min_partition_score(6, [1, 1, 2, 2, 3, 3]) == 3","solution":"def min_partition_score(n, sequence): Calculate the minimum possible total score for partitioning the sequence into strictly increasing continuous subsequences. if n == 1: return 0 score = 0 for i in range(1, n): if sequence[i] <= sequence[i - 1]: score += 1 return score"},{"question":"def compare_sales(data_month_1: str, data_month_2: str) -> List[Tuple[int, int]]: Compare the sales performance of products between two months. Args: data_month_1: A string containing daily sales data for month 1 in the format \\"product_id,sales\\" Each entry is separated by a newline. data_month_2: A string containing daily sales data for month 2 in the format \\"product_id,sales\\" Each entry is separated by a newline. Returns: A list of tuples where each tuple contains a product ID and the absolute difference in total sales between the two months for that product. The output list is sorted in ascending order of product ID. Examples: >>> compare_sales(\\"101,300n102,250n103,500n\\", \\"101,400n102,300n103,450n\\") [(101, 100), (102, 50), (103, 50)] >>> compare_sales(\\"101,0n102,0n103,0n\\", \\"101,0n102,0n103,0n\\") [(101, 0), (102, 0), (103, 0)]","solution":"def parse_sales_data(data): sales_dict = {} for line in data.splitlines(): if line.strip(): product_id, sales = map(int, line.split(\\",\\")) if product_id in sales_dict: sales_dict[product_id] += sales else: sales_dict[product_id] = sales return sales_dict def compare_sales(data_month_1, data_month_2): sales_month_1 = parse_sales_data(data_month_1) sales_month_2 = parse_sales_data(data_month_2) all_products = sorted(set(sales_month_1.keys()).union(sales_month_2.keys())) result = [] for product_id in all_products: total_sales_1 = sales_month_1.get(product_id, 0) total_sales_2 = sales_month_2.get(product_id, 0) difference = abs(total_sales_1 - total_sales_2) result.append((product_id, difference)) return result"},{"question":"def min_changes_to_palindrome(s: str) -> int: Given a string, determine the minimum number of changes required to make it a palindrome. You can modify the given string by inserting, deleting, or replacing characters. Args: s (str): Input string Returns: int: Minimum number of changes required Examples: >>> min_changes_to_palindrome(\\"race\\") 2 >>> min_changes_to_palindrome(\\"madam\\") 0 >>> min_changes_to_palindrome(\\"abcbxa\\") 1 pass","solution":"def min_changes_to_palindrome(s: str) -> int: n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1]) return dp[0][n - 1]"},{"question":"from typing import List from collections import Counter, defaultdict def min_window_substring(s: str, pattern: str) -> str: Returns the minimum window substring of s that contains all the characters of pattern. If no such window exists, returns an empty string. Args: s (str): The string in which to find the substring. pattern (str): The pattern string containing characters to match in the window. Returns: str: The minimum window substring that contains all characters of pattern or an empty string. Examples: >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window_substring(\\"a\\", \\"a\\") \\"a\\" >>> min_window_substring(\\"a\\", \\"b\\") \\"\\" def test_min_window_substring_example_cases(): assert min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" assert min_window_substring(\\"a\\", \\"a\\") == \\"a\\" assert min_window_substring(\\"a\\", \\"b\\") == \\"\\" def test_min_window_substring_general_cases(): assert min_window_substring(\\"this is a test string\\", \\"tist\\") == \\"t stri\\" assert min_window_substring(\\"geeksforgeeks\\", \\"ork\\") == \\"ksfor\\" assert min_window_substring(\\"abcde\\", \\"f\\") == \\"\\" assert min_window_substring(\\"abdabca\\", \\"abc\\") == \\"abc\\" assert min_window_substring(\\"abc\\", \\"ab\\") == \\"ab\\" def test_min_window_substring_edge_cases(): assert min_window_substring(\\"\\", \\"a\\") == \\"\\" assert min_window_substring(\\"a\\", \\"\\") == \\"\\" assert min_window_substring(\\"a\\", \\"aa\\") == \\"\\" assert min_window_substring(\\"bba\\", \\"ab\\") == \\"ba\\"","solution":"from collections import Counter, defaultdict def min_window_substring(s: str, pattern: str) -> str: Returns the minimum window substring of s that contains all the characters of pattern. If no such window exists, returns an empty string. if not s or not pattern: return \\"\\" pattern_count = Counter(pattern) current_count = defaultdict(int) start = 0 min_length = float('inf') min_window = \\"\\" have, need = 0, len(pattern_count) for end, char in enumerate(s): if char in pattern_count: current_count[char] += 1 if current_count[char] == pattern_count[char]: have += 1 while have == need: window_length = end - start + 1 if window_length < min_length: min_length = window_length min_window = s[start:end+1] current_count[s[start]] -= 1 if s[start] in pattern_count and current_count[s[start]] < pattern_count[s[start]]: have -= 1 start += 1 return min_window"},{"question":"from typing import List, Tuple def minimum_travel_times(n: int, tasks: List[Tuple[int, int]]) -> List[int]: Determines the shortest travel times for the given tasks. Args: n : int : The number of parks. tasks : List[Tuple[int, int]] : The list of tasks where each task is a pair (a, b) representing a travel request from park a to park b. Returns: List[int] : A list of integers where each integer is the minimum travel time for the corresponding task in the input list. Examples: >>> minimum_travel_times(5, [(1, 3)]) [3] >>> minimum_travel_times(5, [(2, 2)]) [1] >>> minimum_travel_times(5, [(1, 3), (4, 5), (2, 4)]) [3, 2, 3] >>> minimum_travel_times(3, [(1, 2), (2, 3), (1, 3)]) [2, 2, 3] >>> minimum_travel_times(1, [(1, 1)]) [1] >>> minimum_travel_times(100000, [(1, 100000)]) [100000] >>> minimum_travel_times(100000, [(100000, 1)]) [100000]","solution":"from typing import List, Tuple def minimum_travel_times(n: int, tasks: List[Tuple[int, int]]) -> List[int]: Determines the shortest travel times for the given tasks. travel_times = [] for a, b in tasks: travel_time = abs(a - b) + 1 travel_times.append(travel_time) return travel_times"},{"question":"from typing import List def min_partition_difference(arr: List[int]) -> int: Function to find the minimal absolute difference between the sums of two partitions of an array. Given an array of positive integers, partition the array into two non-empty parts such that the absolute difference between the sums of the two parts is minimized. >>> min_partition_difference([10, 20, 15, 5]) 0 >>> min_partition_difference([1, 2, 3]) 0 >>> min_partition_difference([3, 1, 4, 2, 2]) 0 >>> min_partition_difference([1, 6, 11, 5]) 1 >>> min_partition_difference([1, 3, 3, 4]) 1","solution":"def min_partition_difference(arr): Function to find the minimal absolute difference between the sums of two partitions of an array. total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: subset1_sum = j break subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum)"},{"question":"from typing import List, Dict def length_of_longest_substring_k_distinct(test_cases: List[Dict[str, int]]) -> List[int]: Find the length of the longest substring that contains at most \`k\` distinct characters for each test case. Args: test_cases (List[Dict[str, int]]): A list of dictionaries, where each dictionary contains: - \\"string\\": A string \`s\` - \\"k\\": An integer \`k\` representing the maximum number of distinct characters allowed in the substring Returns: List[int]: The lengths of the longest substrings for each test case. Example: >>> length_of_longest_substring_k_distinct([ ... {\\"string\\": \\"araaci\\", \\"k\\": 2}, ... {\\"string\\": \\"araaci\\", \\"k\\": 1}, ... {\\"string\\": \\"cbbebi\\", \\"k\\": 3} ... ]) [4, 2, 5]","solution":"def length_of_longest_substring_k_distinct(test_cases): def longest_substring_k_distinct(s, k): window_start = 0 max_length = 0 char_frequency = {} for window_end in range(len(s)): right_char = s[window_end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length results = [] for case in test_cases: s = case['string'] k = case['k'] results.append(longest_substring_k_distinct(s, k)) return results"},{"question":"from typing import List, Tuple def find_triplet(arr: List[int]) -> str: Determine whether there exists three indices i, j, k such that A[i] < A[j] < A[k] >>> find_triplet([1, 2, 3, 4, 5]) == \\"YES\\" >>> find_triplet([5, 4, 3, 2]) == \\"NO\\" >>> find_triplet([1, 2, 6, 4, 5, 3]) == \\"YES\\" pass def process_input(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases to find whether there exists a triplet for each >>> test_cases = [ ... (5, [1, 2, 3, 4, 5]), ... (4, [5, 4, 3, 2]), ... (6, [1, 2, 6, 4, 5, 3]) ... ] >>> process_input(3, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] pass def test_find_triplet(): assert find_triplet([1, 2, 3, 4, 5]) == \\"YES\\" assert find_triplet([5, 4, 3, 2]) == \\"NO\\" assert find_triplet([1, 2, 6, 4, 5, 3]) == \\"YES\\" assert find_triplet([10, 20, 5, 6, 1, 2]) == \\"NO\\" assert find_triplet([1, 3, 2, 4]) == \\"YES\\" assert find_triplet([1, 1, 1, 1]) == \\"NO\\" assert find_triplet([3, 2, 1, 0]) == \\"NO\\" assert find_triplet([1, 5, 4, 6, 2]) == \\"YES\\" def test_process_input(): test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [5, 4, 3, 2]), (6, [1, 2, 6, 4, 5, 3]) ] assert process_input(3, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] test_cases = [ (4, [10, 20, 5, 6]), (5, [1, 1, 1, 1, 1]), (4, [1, 5, 4, 6]) ] assert process_input(3, test_cases) == [\\"NO\\", \\"NO\\", \\"YES\\"] test_cases = [ (3, [3, 2, 1]), (5, [1, 3, 2, 4, 5]), (3, [-1, 0, 1]) ] assert process_input(3, test_cases) == [\\"NO\\", \\"YES\\", \\"YES\\"] if __name__ == \\"__main__\\": test_find_triplet() test_process_input() print(\\"All tests passed!\\")","solution":"def find_triplet(arr): n = len(arr) if n < 3: return \\"NO\\" left_min = [float('inf')] * n right_max = [float('-inf')] * n left_min[0] = arr[0] for i in range(1, n): left_min[i] = min(left_min[i-1], arr[i]) right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) for j in range(1, n-1): if left_min[j-1] < arr[j] < right_max[j+1]: return \\"YES\\" return \\"NO\\" def process_input(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(find_triplet(arr)) return results"},{"question":"from typing import List def unique_quadruplets(nums: List[int], target: int) -> int: Find the number of unique quadruplets in the array that sum up to the given target. >>> unique_quadruplets([1, 0, -1, 0, -2, 2], 0) 3 >>> unique_quadruplets([1, 1, 1, 1], 10) 0 >>> unique_quadruplets([0], 0) 0 >>> unique_quadruplets([0, 0, 0, 0, 0, 0], 0) 1 >>> unique_quadruplets([-5, -4, -3, -2, -1], -10) 1 >>> unique_quadruplets([1000000000, 1000000000, 1000000000, -1000000000, -1000000000, -1000000000, 0], 0) 1 >>> unique_quadruplets([2, 2, 2, 2, 2, 2], 8) 1","solution":"from typing import List from itertools import combinations def unique_quadruplets(nums: List[int], target: int) -> int: nums.sort() # Sort the array for easier management of indices n = len(nums) quadruplets = set() for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: four_sum = nums[i] + nums[j] + nums[left] + nums[right] if four_sum == target: quadruplets.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif four_sum < target: left += 1 else: right -= 1 return len(quadruplets)"},{"question":"import math def calculate_shortest_path(x1, y1, x2, y2): Calculates the Euclidean distance between two points (x1, y1) and (x2, y2). >>> calculate_shortest_path(1, 2, 4, 6) 5.00 >>> calculate_shortest_path(3, 3, 3, 3) 0.00 >>> calculate_shortest_path(0, 0, 3, 4) 5.00 >>> calculate_shortest_path(-2, -3, -4, -6) 3.61 >>> calculate_shortest_path(1, -1, -1, 2) 3.61","solution":"import math def calculate_shortest_path(x1, y1, x2, y2): Calculates the Euclidean distance between two points (x1, y1) and (x2, y2). distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) return round(distance, 2)"},{"question":"from typing import List def can_rearrange_no_adjacent_difference_one(arr: List[int]) -> str: Determine if it's possible to rearrange the array such that no two adjacent elements have a difference of 1. If possible, return 'YES' and the rearranged array, otherwise return 'NO'. >>> can_rearrange_no_adjacent_difference_one([1, 2, 3, 4, 5]) 'NO' >>> can_rearrange_no_adjacent_difference_one([10, 20, 30, 40, 50, 60]) 'YES 10 20 30 40 50 60' >>> can_rearrange_no_adjacent_difference_one([2, 1, 3]) 'NO' def process_test_cases(T: int, test_cases: List[List[int]]) -> List[str]: Process multiple test cases and return results for each. >>> process_test_cases(3, [[1, 2, 3, 4, 5], [10, 20, 30, 40, 50, 60], [2, 1, 3]]) ['NO', 'YES 10 20 30 40 50 60', 'NO']","solution":"def can_rearrange_no_adjacent_difference_one(arr): Determine if it's possible to rearrange the array such that no two adjacent elements have a difference of 1. If possible, return 'YES' and the rearranged array, otherwise return 'NO'. arr.sort() n = len(arr) for i in range(1, n): if arr[i] - arr[i - 1] == 1: return \\"NO\\" return \\"YES \\" + ' '.join(map(str, arr)) def process_test_cases(T, test_cases): results = [] for i in range(T): arr = test_cases[i] results.append(can_rearrange_no_adjacent_difference_one(arr)) return results"},{"question":"def decompress_string(s: str) -> str: Decompresses a string according to the given rules. The string will contain characters, digits, square brackets ('[' and ']') and nested brackets. The characters between the brackets need to be repeated as many times as the digits before the brackets indicate. You can assume input format will always be valid, e.g., no need to check for input format correctness. >>> decompress_string(\\"3[a]2[bc]\\") \\"aaabcbc\\" >>> decompress_string(\\"3[a2[c]]\\") \\"accaccacc\\" >>> decompress_string(\\"2[abc]3[cd]ef\\") \\"abcabccdcdcdef\\" >>> decompress_string(\\"abc3[cd]xyz\\") \\"abccdcdcdxyz\\"","solution":"def decompress_string(s): stack = [] current_num = 0 current_str = '' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append(current_str) stack.append(current_num) current_str = '' current_num = 0 elif char == ']': num = stack.pop() prev_str = stack.pop() current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"def path_exists(n, r, c, cr, roads, a, b, closed_cities, closed_roads): Determine if there exists a path between two given cities, avoiding the closed cities and roads. Args: n (int): number of cities r (int): number of roads c (int): number of closed cities cr (int): number of closed roads roads (List[Tuple[int, int]]): list of bidirectional roads between cities a (int): starting city b (int): destination city closed_cities (List[int]): list of closed cities closed_roads (List[Tuple[int, int]]): list of closed roads Returns: str: \\"YES\\" if there exists a path, \\"NO\\" otherwise Example: >>> path_exists(6, 7, 2, 1, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 6), (5, 6)], 2, 1, [3, 5], [(1, 3)]) \\"YES\\" >>> path_exists(6, 7, 2, 1, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 6), (5, 6)], 1, 5, [2], [(1, 3)]) \\"NO\\"","solution":"def path_exists(n, r, c, cr, roads, a, b, closed_cities, closed_roads): from collections import defaultdict, deque def bfs(start, end, graph, closed_cities, closed_roads): queue = deque([start]) visited = set([start]) while queue: current = queue.popleft() if current == end: return True for neighbor in graph[current]: if neighbor not in visited and neighbor not in closed_cities and (current, neighbor) not in closed_roads and (neighbor, current) not in closed_roads: visited.add(neighbor) queue.append(neighbor) return False graph = defaultdict(list) for u, v in roads: if u not in closed_cities and v not in closed_cities: graph[u].append(v) graph[v].append(u) closed_cities_set = set(closed_cities) closed_roads_set = set((min(x, y), max(x, y)) for x, y in closed_roads) if a in closed_cities_set or b in closed_cities_set: return \\"NO\\" return \\"YES\\" if bfs(a, b, graph, closed_cities_set, closed_roads_set) else \\"NO\\" # The function can be called with appropriate inputs to test."},{"question":"def count_ways(n): Returns the number of ways to assign values to a list of length n such that the sum of any two consecutive integers is odd. Parameters: n (int): Length of the list Returns: int: The number of ways to assign values to the list, modulo (10^9 + 7) def solve(T, test_cases): Solves multiple test cases and return the results for each case. Parameters: T (int): Number of test cases test_cases (list): List of integers denoting the length of the list for each test case Returns: list: List containing the results for each test case. # Sample Unit Test def test_count_ways(): assert count_ways(1) == 2 assert count_ways(2) == 2 assert count_ways(3) == 4 assert count_ways(4) == 4 assert count_ways(5) == 8 assert count_ways(10**9) == (2 * pow(2, (10**9 - 1) // 2, 10**9 + 7)) % (10**9 + 7) def test_solve(): assert solve(3, [3, 4, 5]) == [4, 4, 8] assert solve(2, [1, 2]) == [2, 2] assert solve(1, [10**9]) == [(2 * pow(2, (10**9 - 1) // 2, 10**9 + 7)) % (10**9 + 7)]","solution":"def count_ways(n): Returns the number of ways to assign values to a list of length n such that the sum of any two consecutive integers is odd. Parameters: n (int): Length of the list Returns: int: The number of ways to assign values to the list, modulo (10^9 + 7) MOD = 10**9 + 7 # For n = 1, there are 2 ways (either odd or even) if n == 1: return 2 # For other n, there are 2 ways to place odd or even at the first place # and remaining (n-1) can be set alternately in 2^((n-1) // 2) ways return (2 * pow(2, (n-1) // 2, MOD)) % MOD def solve(T, test_cases): Solves multiple test cases and return the results for each case. Parameters: T (int): Number of test cases test_cases (list): List of integers denoting the length of the list for each test case Returns: list: List containing the results for each test case. results = [] for n in test_cases: results.append(count_ways(n)) return results"},{"question":"def derangements(n: int) -> int: Returns the number of derangements for given n >>> derangements(0) == 1 >>> derangements(1) == 0 >>> derangements(2) == 1 >>> derangements(3) == 2 >>> derangements(4) == 9 >>> derangements(5) == 44 def solve(t: int, test_cases: List[int]) -> List[int]: Given the number of test cases and a list of test cases, returns a list with derangement counts for each test case. >>> solve(5, [1, 2, 3, 4, 5]) == [0, 1, 2, 9, 44] >>> solve(3, [0, 1, 2]) == [1, 0, 1]","solution":"def derangements(n): Returns the number of derangements for given n if n == 0: return 1 # by definition, the derangement of an empty set is 1 if n == 1: return 0 # no derangement possible for a single element # dp[i] represents the number of derangements of \`i\` items dp = [0] * (n + 1) dp[0] = 1 # base case dp[1] = 0 # base case for i in range(2, n + 1): dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) return dp[n] def solve(t, test_cases): results = [] for n in test_cases: results.append(derangements(n)) return results"},{"question":"import math def min_tiles_required(n, m, a, b): Calculates the minimum number of tiles required to cover a rectangular garden of dimensions n x m with tiles of dimensions a x b. The tiles can be rotated 90 degrees. >>> min_tiles_required(6, 6, 4, 3) 4 >>> min_tiles_required(5, 5, 2, 3) 6 >>> min_tiles_required(10, 10, 2, 2) 25 >>> min_tiles_required(8, 5, 3, 2) 8 >>> min_tiles_required(1, 1, 1, 1) 1 >>> min_tiles_required(1000000000, 1000000000, 1, 1) 1000000000000000000 >>> min_tiles_required(1000000000, 1000000000, 500000000, 500000000) 4","solution":"import math def min_tiles_required(n, m, a, b): Calculates the minimum number of tiles required to cover a rectangular garden of dimensions n x m with tiles of dimensions a x b. The tiles can be rotated 90 degrees. # Calculate the number of tiles required when tiles are placed normally (a x b) tiles_normal = (math.ceil(n / a) * math.ceil(m / b)) # Calculate the number of tiles required when tiles are rotated (b x a) tiles_rotated = (math.ceil(n / b) * math.ceil(m / a)) # Return the minimum of the two configurations return min(tiles_normal, tiles_rotated) # Sample usage print(min_tiles_required(6, 6, 4, 3)) # Output should be 4"},{"question":"def longest_arithmetic_subsequence_length(nums: List[int]) -> int: Given a list of integers, find the longest subsequence where the difference between consecutive elements is the same. Print the length of this subsequence. >>> longest_arithmetic_subsequence_length([3, 6, 9, 12, 15, 18, 21]) 7 >>> longest_arithmetic_subsequence_length([5]) 1 >>> longest_arithmetic_subsequence_length([1, 2, 4, 7, 11]) 2 >>> longest_arithmetic_subsequence_length([5, 10, 15, 8, 6]) 3 >>> longest_arithmetic_subsequence_length([1, 3, 1, 3, 1, 3, 1, 3]) 2 >>> longest_arithmetic_subsequence_length([1000000, -1000000]) 2 >>> longest_arithmetic_subsequence_length([1, 3, 5, 7, 10, 15, 20, 17, 14, 11]) 4","solution":"def longest_arithmetic_subsequence_length(nums): if len(nums) <= 1: return len(nums) max_length = 1 current_length = 1 common_diff = None for i in range(1, len(nums)): diff = nums[i] - nums[i-1] if common_diff is None: common_diff = diff current_length += 1 elif diff == common_diff: current_length += 1 else: common_diff = diff current_length = 2 if current_length > max_length: max_length = current_length return max_length # Read from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = list(map(int, data[1:])) print(longest_arithmetic_subsequence_length(nums))"},{"question":"def can_form_closed_polygon(n, lengths): Determines if it is possible to form a closed polygon with given segment lengths. Parameters: n (int): The number of segments. lengths (List[int]): The lengths of the segments. Returns: str: \\"yes\\" if it is possible to form a closed polygon, otherwise \\"no\\". Examples: >>> can_form_closed_polygon(4, [3, 5, 6, 7]) \\"yes\\" >>> can_form_closed_polygon(3, [2, 2, 5]) \\"no\\" >>> can_form_closed_polygon(5, [1, 1, 1, 1, 1]) \\"yes\\"","solution":"def can_form_closed_polygon(n, lengths): Determines if it is possible to form a closed polygon with given segment lengths. Parameters: n (int): The number of segments. lengths (List[int]): The lengths of the segments. Returns: str: \\"yes\\" if it is possible to form a closed polygon, otherwise \\"no\\". total_length = sum(lengths) max_length = max(lengths) if total_length > 2 * max_length: return \\"yes\\" else: return \\"no\\" # Example of usage: # n = 4 # lengths = [3, 5, 6, 7] # print(can_form_closed_polygon(n, lengths)) # Should print \\"yes\\""},{"question":"def findNthChar(n: int) -> str: Given a positive integer n, generate the nth term in the concatenated sequence of all previous natural numbers. Args: n (int): The zero-based index of the term to find in the concatenated sequence. Returns: str: The nth term in the concatenated sequence of natural numbers. Example: >>> findNthChar(5) '5' >>> findNthChar(15) '2' >>> findNthChar(0) '0' >>> findNthChar(9) '9' >>> findNthChar(10) '1' >>> findNthChar(1000) '3'","solution":"def findNthChar(n): Returns the nth character in the concatenated sequence of all previous natural numbers. concatenated = \\"\\" i = 0 while len(concatenated) <= n: concatenated += str(i) i += 1 return concatenated[n]"},{"question":"def min_subset_difference(n: int, sweetness_levels: List[int]) -> int: Serval is studying at a kindergarten and just received an unusual snack: a collection of n candies. Each candy has a sweetness level denoted by an integer value. Serval's task is to split these candies into two non-empty subsets such that the absolute difference between the sum of sweetness levels in the two subsets is minimized. Parameters: n (int): the number of candies sweetness_levels (List[int]): the sweetness levels of the candies Returns: int: the minimum absolute difference between the sums of the two subsets Examples: >>> min_subset_difference(3, [8, 4, 5]) 1 >>> min_subset_difference(4, [1, 1, 1, 1]) 0","solution":"def min_subset_difference(n, sweetness_levels): total_sum = sum(sweetness_levels) half_sum = total_sum // 2 dp = [0] * (half_sum + 1) for sweetness in sweetness_levels: for i in range(half_sum, sweetness - 1, -1): dp[i] = max(dp[i], dp[i - sweetness] + sweetness) subset1_sum = dp[half_sum] subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum)"},{"question":"def largest_clique_size(N: int, M: int, relationships: List[Tuple[int, int]]) -> int: Determine the size of the largest clique in the given network of friendships. >>> largest_clique_size(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 2 >>> largest_clique_size(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5), (2, 4)]) 3 >>> largest_clique_size(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 4 >>> largest_clique_size(6, 7, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (2, 4)]) 3 >>> largest_clique_size(2, 0, []) 1","solution":"from itertools import combinations def largest_clique_size(N, M, relationships): graph = {i: set() for i in range(1, N+1)} for a, b in relationships: graph[a].add(b) graph[b].add(a) def is_clique(group): for u, v in combinations(group, 2): if v not in graph[u]: return False return True max_clique = 1 # Minimum clique size is 1 for size in range(2, N+1): for group in combinations(range(1, N+1), size): if is_clique(group): max_clique = size return max_clique"},{"question":"from typing import List def shortestPath(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid with obstacles. If no such path exists, returns -1. # Your code here import pytest def test_case_1(): grid = [ [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert shortestPath(grid) == 9 def test_case_2(): grid = [ [0, 1, 1, 1], [1, 1, 1, 0], [1, 1, 1, 0], [1, 1, 0, 0] ] assert shortestPath(grid) == -1 def test_no_obstacles(): grid = [ [0, 0], [0, 0] ] assert shortestPath(grid) == 3 def test_start_end_blocked(): grid = [ [1, 0], [0, 0] ] assert shortestPath(grid) == -1 grid = [ [0, 0], [0, 1] ] assert shortestPath(grid) == -1 def test_one_cell_grid(): grid = [ [0] ] assert shortestPath(grid) == 1 def test_blocked_path(): grid = [ [0, 1, 0], [0, 1, 0], [0, 1, 0] ] assert shortestPath(grid) == -1","solution":"from collections import deque def shortestPath(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid with obstacles. If no such path exists, returns -1. n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 # if start or end is an obstacle, return -1 immediately directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # queue stores tuples of (row, col, path_length) visited = set((0, 0)) while queue: row, col, path_length = queue.popleft() if (row, col) == (n-1, n-1): return path_length for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < n and 0 <= newCol < n and (newRow, newCol) not in visited and grid[newRow][newCol] == 0: queue.append((newRow, newCol, path_length + 1)) visited.add((newRow, newCol)) return -1"},{"question":"import random import string from typing import List, Tuple def generate_keys(T: int, test_cases: List[Tuple[int, int]]) -> List[List[str]]: Generate N unique alphanumeric keys for each test case, where each key is of length L. :param T: int: Number of test cases :param test_cases: List[Tuple[int, int]]: List of tuples where each tuple contains N and L for each test case :return: List[List[str]]: List of lists, where each list contains N unique alphanumeric keys of length L. >>> T = 2 >>> test_cases = [(3, 8), (2, 5)] >>> results = generate_keys(T, test_cases) >>> len(results[0]) == 3 True >>> all(len(key) == 8 for key in results[0]) True >>> len(results[1]) == 2 True >>> all(len(key) == 5 for key in results[1]) True >>> len(set(results[0])) == 3 True >>> len(set(results[1])) == 2 True","solution":"import random import string def generate_keys(T, test_cases): results = [] for case in test_cases: N, L = case keys = set() while len(keys) < N: key = ''.join(random.choices(string.ascii_letters + string.digits, k=L)) keys.add(key) results.append(list(keys)) return results"},{"question":"def generalized_fibonacci(a: int, b: int, n: int) -> list: Generates the first n terms of a generalized Fibonacci sequence, starting with integers a and b. >>> generalized_fibonacci(1, 1, 5) [1, 1, 2, 3, 5] >>> generalized_fibonacci(2, 3, 7) [2, 3, 5, 8, 13, 21, 34] >>> generalized_fibonacci(0, 5, 4) [0, 5, 5, 10] def process_cases(T: int, cases: list) -> list: Processes T cases of generalized Fibonacci sequences. >>> process_cases(3, [(5, 1, 1), (7, 2, 3), (4, 0, 5)]) [[1, 1, 2, 3, 5], [2, 3, 5, 8, 13, 21, 34], [0, 5, 5, 10]] def main(T: int, cases: list): Processes and prints T cases of generalized Fibonacci sequences. >>> main(3, [(5, 1, 1), (7, 2, 3), (4, 0, 5)]) 1 1 2 3 5 2 3 5 8 13 21 34 0 5 5 10","solution":"def generalized_fibonacci(a, b, n): Generates the first n terms of a generalized Fibonacci sequence, starting with integers a and b. if n == 1: return [a] if n == 2: return [a, b] sequence = [a, b] for _ in range(2, n): next_term = sequence[-1] + sequence[-2] sequence.append(next_term) return sequence def process_cases(T, cases): Processes T cases of generalized Fibonacci sequences. results = [] for case in cases: n, a, b = case sequence = generalized_fibonacci(a, b, n) results.append(sequence) return results def main(T, cases): results = process_cases(T, cases) for result in results: print(\\" \\".join(map(str, result))) # Example usage with sample input: # main(3, [(5, 1, 1), (7, 2, 3), (4, 0, 5)])"},{"question":"def can_form_pattern_string(s): Determine if the string \`s\` can be rearranged to form a pattern string. >>> can_form_pattern_string(\\"aabb\\") True >>> can_form_pattern_string(\\"abc\\") False pass def process_test_cases(test_cases): For each test case, determine if the input string can be rearranged to form a pattern string. >>> process_test_cases([\\"aabb\\", \\"abc\\", \\"aabbcc\\", \\"xyxy\\", \\"ppqqpp\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_form_pattern_string(s): Determine if the string \`s\` can be rearranged to form a pattern string. distinct_characters = set(s) return len(distinct_characters) == 2 def process_test_cases(test_cases): For each test case, determine if the input string can be rearranged to form a pattern string. results = [] for s in test_cases: if can_form_pattern_string(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def game_simulation(initial_stones: int): Simulates a game where two players take turns removing stones from a pile. Players can remove 1, 2, or 3 stones on their turn. The player who takes the last stone wins the game. Args: initial_stones (int): Initial number of stones in the pile. Returns: list: The sequence of moves made by each player in the format (player, stones_taken, stones_remaining). str: The name of the winning player. pass def test_game_simulation_10_stones(): moves, winner = game_simulation(10) expected_moves = [ (1, 2, 8), (2, 3, 5), (1, 1, 4), (2, 3, 1), (1, 1, 0) ] assert moves == expected_moves assert winner == \\"Player 1 wins!\\" def test_game_simulation_4_stones(): moves, winner = game_simulation(4) expected_moves = [ (1, 3, 1), (2, 1, 0) ] assert moves == expected_moves assert winner == \\"Player 2 wins!\\" def test_game_simulation_5_stones(): moves, winner = game_simulation(5) expected_moves = [ (1, 1, 4), (2, 3, 1), (1, 1, 0) ] assert moves == expected_moves assert winner == \\"Player 1 wins!\\" def test_game_simulation_1_stone(): moves, winner = game_simulation(1) expected_moves = [ (1, 1, 0) ] assert moves == expected_moves assert winner == \\"Player 1 wins!\\" def test_game_simulation_3_stones(): moves, winner = game_simulation(3) expected_moves = [ (1, 3, 0) ] assert moves == expected_moves assert winner == \\"Player 1 wins!\\"","solution":"def game_simulation(initial_stones): Simulates a game where two players take turns removing stones from a pile. Players can remove 1, 2, or 3 stones on their turn. The player who takes the last stone wins the game. Args: initial_stones (int): Initial number of stones in the pile. Returns: list: The sequence of moves made by each player in the format (player, stones_taken, stones_remaining). str: The name of the winning player. moves = [] stones = initial_stones player = 1 # Player 1 starts # The strategy: always try to force the opponent to face a multiple of 4 stones left. while stones > 0: if stones % 4 == 0: move = 3 # Best play to maximize chances of winning else: move = stones % 4 # This ensures we leave a multiple of 4 for the opponent stones -= move moves.append((player, move, stones)) if stones == 0: winner = f\\"Player {player} wins!\\" break # Switch player for next turn player = 2 if player == 1 else 1 return moves, winner"},{"question":"def min_operations_to_make_equal(N: int, A: List[int]) -> int: Find the minimum number of operations required to make all elements of a circular array equal. >>> min_operations_to_make_equal(4, [3, 6, 4, 2]) 3 >>> min_operations_to_make_equal(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_make_equal(3, [1, 10, 1]) 2","solution":"def min_operations_to_make_equal(N, A): total_sum = sum(A) target = total_sum // N if all(x == target for x in A): return 0 current_sum = 0 operations = 0 for value in A: current_sum += value if current_sum == (operations + 1) * target: continue operations += 1 return operations"},{"question":"def min_operations(s1: str, s2: str) -> int: This function calculates the minimum number of operations required to convert s1 into s2. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"a\\", \\"\\") 1 >>> min_operations(\\"\\", \\"a\\") 1 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"a\\", \\"b\\") 1 pass def process_queries(queries: List[Tuple[str, str]]) -> List[int]: This function processes the list of queries and returns the results. >>> process_queries([(\\"kitten\\", \\"sitting\\"), (\\"horse\\", \\"ros\\")]) [3, 3] >>> process_queries([(\\"\\", \\"\\"), (\\"a\\", \\"\\"), (\\"\\", \\"a\\")]) [0, 1, 1] >>> process_queries([(\\"a\\", \\"a\\"), (\\"a\\", \\"b\\")]) [0, 1] pass","solution":"def min_operations(s1, s2): This function calculates the minimum number of operations required to convert s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, insert all characters of s2 elif j == 0: dp[i][j] = i # If s2 is empty, remove all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # remove dp[i][j - 1], # insert dp[i - 1][j - 1]) # replace return dp[m][n] def process_queries(queries): results = [] for s1, s2 in queries: results.append(min_operations(s1, s2)) return results"},{"question":"def minimize_total_distance(n: int, distances: List[int]) -> int: Compute and return the minimized total distance for visiting all points exactly once and returning to the starting point. Args: n (int): Number of points. distances (List[int]): List of distances between consecutive points. Returns: int: Minimized total distance. >>> minimize_total_distance(3, [1, 2, 3]) 6 >>> minimize_total_distance(4, [4, 3, 2, 5]) 14 from typing import List def test_minimize_distance_example1(): assert minimize_total_distance(3, [1, 2, 3]) == 6 def test_minimize_distance_example2(): assert minimize_total_distance(4, [4, 3, 2, 5]) == 14 def test_minimize_distance_small(): assert minimize_total_distance(3, [1, 1, 1]) == 3 def test_minimize_distance_large(): assert minimize_total_distance(5, [10**6, 10**6, 10**6, 10**6, 10**6]) == 5 * 10**6 def test_minimize_distance_mixed(): assert minimize_total_distance(4, [10**6, 1, 100, 999999]) == 10**6 + 1 + 100 + 999999","solution":"def minimize_total_distance(n, distances): Returns the minimized total distance for the given distances array. # As we must visit all points and return to the starting point, the minimized total distance # is simply the sum of all the given distances. return sum(distances)"},{"question":"def find_first_repeating_element(test_cases): This function takes a list of test cases, where each test case is a tuple containing the number of elements in the list and the list of integers. It returns a list of the first repeating element for each test case or -1 if there is none. >>> find_first_repeating_element([(5, [1, 2, 3, 4, 3]), (4, [1, 2, 3, 4])]) [3, -1] >>> find_first_repeating_element([(3, [1, 2, 3]), (6, [10, 20, 30, 40, 50, 60])]) [-1, -1] >>> find_first_repeating_element([(5, [1, 1, 2, 2, 3])]) [1] >>> find_first_repeating_element([(1, [1])]) [-1] >>> find_first_repeating_element([(100001, list(range(100000)) + [0])]) [0] >>> find_first_repeating_element([(10, [1, 2, 3, 4, 2, 3, 4, 5, 6, 7])]) [2] >>> find_first_repeating_element([(8, [5, 3, 4, 6, 3, 8, 2, 1])]) [3]","solution":"def find_first_repeating_element(test_cases): This function takes a list of test cases, where each test case is a tuple containing the number of elements in the list and the list of integers. It returns a list of the first repeating element for each test case or -1 if there is none. results = [] for _, elements in test_cases: seen = {} first_repeating = -1 for index, element in enumerate(elements): if element in seen: first_repeating = element break else: seen[element] = index results.append(first_repeating) return results"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(nodes_info): Builds a binary tree from the list of node information. Args: nodes_info: A list of tuples with information of each node in the format (u, v, l, r). - u: index of the node - v: value of the node - l: index of the left child (or -1 if there is no left child) - r: index of the right child (or -1 if there is no right child) Returns: The root of the binary tree. pass def get_subtree_sums(root): Calculates the sum of values of the nodes in the subtree for each node. Args: root: The root node of the binary tree. Returns: A list containing the sum of the values for the subtree of each node in the tree. pass def test_single_node_tree(): nodes_info = [(1, 3, -1, -1)] root = build_tree(nodes_info) subtree_sums = get_subtree_sums(root) assert subtree_sums == [3] def test_tree_with_multiple_nodes(): nodes_info = [ (1, 3, 2, 3), (2, 2, -1, -1), (3, 5, 4, 5), (4, 1, -1, -1), (5, -2, -1, -1) ] root = build_tree(nodes_info) subtree_sums = get_subtree_sums(root) assert subtree_sums == [9, 2, 4, 1, -2] def test_tree_with_negative_values(): nodes_info = [ (1, -3, 2, 3), (2, -1, -1, -1), (3, -2, -1, -1) ] root = build_tree(nodes_info) subtree_sums = get_subtree_sums(root) assert subtree_sums == [-6, -1, -2]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(nodes_info): nodes = {} for u, v, l, r in nodes_info: if u not in nodes: nodes[u] = TreeNode(v) else: nodes[u].value = v if l != -1: if l not in nodes: nodes[l] = TreeNode(0) nodes[u].left = nodes[l] if r != -1: if r not in nodes: nodes[r] = TreeNode(0) nodes[u].right = nodes[r] return nodes[1] # Assuming that the root is always node 1 def subtree_sum(node): if not node: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) total_sum = node.value + left_sum + right_sum node.sum = total_sum return total_sum def get_subtree_sums(root): subtree_sum(root) sums = [] nodes = [root] while nodes: current = nodes.pop(0) sums.append(current.sum) if current.left: nodes.append(current.left) if current.right: nodes.append(current.right) return sums def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) nodes_info = [] index = 1 for _ in range(N): u = int(data[index]) v = int(data[index + 1]) l = int(data[index + 2]) r = int(data[index + 3]) nodes_info.append((u, v, l, r)) index += 4 root = build_tree(nodes_info) subtree_sums = get_subtree_sums(root) for sum_val in subtree_sums: print(sum_val) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def collatz_sequence_info(N: int) -> Tuple[int, int]: Determine the length of the integer sequence and the maximum value attained, based on the Collatz sequence rules. >>> collatz_sequence_info(5) (6, 16) >>> collatz_sequence_info(3) (8, 16) >>> collatz_sequence_info(6) (9, 16) def process_test_cases(T: int, test_cases: List[int]) -> List[str]: Process multiple test cases and return the results for each test case. >>> process_test_cases(3, [5, 3, 6]) [\\"6 16\\", \\"8 16\\", \\"9 16\\"] # Unit tests def test_collatz_sequence_case_1(): assert collatz_sequence_info(5) == (6, 16) def test_collatz_sequence_case_2(): assert collatz_sequence_info(3) == (8, 16) def test_collatz_sequence_case_3(): assert collatz_sequence_info(6) == (9, 16) def test_process_test_cases(): T = 3 test_cases = [5, 3, 6] results = process_test_cases(T, test_cases) expected = [\\"6 16\\", \\"8 16\\", \\"9 16\\"] assert results == expected def test_collatz_large_number(): length, max_value = collatz_sequence_info(27) assert (length, max_value) == (112, 9232) def test_collatz_smallest_number(): assert collatz_sequence_info(1) == (1, 1) def test_process_test_cases_with_variety(): T = 5 test_cases = [1, 2, 7, 13, 1024] results = process_test_cases(T, test_cases) expected = [ \\"1 1\\", \\"2 2\\", \\"17 52\\", \\"10 40\\", \\"11 1024\\" ] assert results == expected","solution":"def collatz_sequence_info(N): length = 1 max_value = N while N != 1: if N % 2 == 0: N //= 2 else: N = 3 * N + 1 max_value = max(max_value, N) length += 1 return length, max_value def process_test_cases(T, test_cases): results = [] for N in test_cases: length, max_value = collatz_sequence_info(N) results.append(f\\"{length} {max_value}\\") return results"},{"question":"def calculateVolume(choice: int, arr: List[int]) -> int: Returns the volume of a cube (if choice is 1) or a triangular prism (if choice is 2) Parameters: choice (int): The choice indicating the shape. arr (list): List of integers containing the necessary dimensions. Returns: int: Calculated volume of either the cube or the triangular prism. >>> calculateVolume(1, [3]) 27 >>> calculateVolume(2, [4, 5, 6]) 60 from solution import calculateVolume def test_calculateVolume_cube(): assert calculateVolume(1, [3]) == 27 assert calculateVolume(1, [1]) == 1 assert calculateVolume(1, [10]) == 1000 def test_calculateVolume_triangular_prism(): assert calculateVolume(2, [4, 5, 6]) == 60 assert calculateVolume(2, [2, 3, 4]) == 12 assert calculateVolume(2, [10, 10, 10]) == 500 def test_calculateVolume_edge_cases(): assert calculateVolume(1, [100]) == 1000000 assert calculateVolume(2, [100, 100, 100]) == 500000 assert calculateVolume(2, [1,1,1]) == 0.5 def test_calculateVolume_invalid_case(): # Test for cases that shouldn't happen according to problem constraints # This is just to make sure our function doesn't break in unexpected ways assert calculateVolume(3, []) == None # Note: Actual production tests might need more robust error handling, this is a simple demonstration.","solution":"def calculateVolume(choice, arr): Returns the volume of a cube (if choice is 1) or a triangular prism (if choice is 2) Parameters: choice (int): The choice indicating the shape. arr (list): List of integers containing the necessary dimensions. Returns: int: Calculated volume of either the cube or the triangular prism. if choice == 1: # Calculate volume of the cube C = arr[0] return C ** 3 elif choice == 2: # Calculate volume of the triangular prism A, B, H = arr return (0.5 * A * H) * B"},{"question":"def max_area(heights): Returns the maximum area of a rectangle formed by any two of the buildings. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 1]) 1 >>> max_area([4, 3, 2, 1, 4]) 16 >>> max_area([1, 2, 4, 3]) 4","solution":"def max_area(heights): Returns the maximum area of a rectangle formed by any two of the buildings. max_area = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_unique_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_unique_substring(\\"bbbbb\\") == 1 >>> length_of_longest_unique_substring(\\"pwwkew\\") == 3 from solution import length_of_longest_unique_substring def test_length_of_longest_unique_substring_example1(): assert length_of_longest_unique_substring(\\"abcabcbb\\") == 3 def test_length_of_longest_unique_substring_example2(): assert length_of_longest_unique_substring(\\"bbbbb\\") == 1 def test_length_of_longest_unique_substring_example3(): assert length_of_longest_unique_substring(\\"pwwkew\\") == 3 def test_length_of_longest_unique_substring_single_char(): assert length_of_longest_unique_substring(\\"a\\") == 1 def test_length_of_longest_unique_substring_all_unique(): assert length_of_longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 def test_length_of_longest_unique_substring_repeated_pattern(): assert length_of_longest_unique_substring(\\"abcabcabcabcabc\\") == 3 def test_length_of_longest_unique_substring_mixed(): assert length_of_longest_unique_substring(\\"abac\\") == 3 def test_length_of_longest_unique_substring_ending_repetition(): assert length_of_longest_unique_substring(\\"abcdabcd\\") == 4 def test_length_of_longest_unique_substring_large_input(): assert length_of_longest_unique_substring(\\"a\\" * 1000) == 1","solution":"def length_of_longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. n = len(s) max_length = 0 start = 0 char_index = {} for end in range(n): if s[end] in char_index: start = max(char_index[s[end]] + 1, start) char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def dna_sequence_occurrence(dna_strand: str) -> str: Given a sequence of lowercased alphabetic string representing DNA strands, identify if a certain pattern repeats in the strand. >>> dna_sequence_occurrence(\\"cggtaa\\") \\"no occurrence\\" >>> dna_sequence_occurrence(\\"cgatgcggctaa\\") \\"single occurrence\\" >>> dna_sequence_occurrence(\\"atgcatgcgcta\\") \\"multiple occurrences\\"","solution":"def dna_sequence_occurrence(dna_strand): Returns a string indicating the number of times the sequence \\"atgc\\" appears in the dna_strand. occurrences = dna_strand.count(\\"atgc\\") if occurrences == 0: return \\"no occurrence\\" elif occurrences == 1: return \\"single occurrence\\" else: return \\"multiple occurrences\\""},{"question":"def total_loyalty_points(n, purchases): Calculate the total number of loyalty points distributed from given purchases. :param n: Number of purchases :param purchases: List of tuples where each tuple contains customer ID and points received :return: Total points distributed >>> total_loyalty_points(3, [(101, 20), (102, 15), (101, 30)]) 65 >>> total_loyalty_points(5, [(1001, 45), (1002, 75), (1003, 60), (1001, 80), (1002, 90)]) 350 >>> total_loyalty_points(1, [(1001, 50)]) 50 >>> total_loyalty_points(3, [(1001, 20), (1001, 30), (1001, 50)]) 100 >>> total_loyalty_points(2, [(9999, 100), (8888, 100)]) 200 >>> total_loyalty_points(3, [(1001, 0), (1002, 0), (1003, 0)]) 0 >>> total_loyalty_points(4, [(1001, 5), (1002, 15), (1001, 25), (1003, 35)]) 80","solution":"def total_loyalty_points(n, purchases): Calculate the total number of loyalty points distributed from given purchases. :param n: Number of purchases :param purchases: List of tuples where each tuple contains customer ID and points received :return: Total points distributed total_points = 0 for customer_id, points in purchases: total_points += points return total_points"},{"question":"def total_honeycomb_cells(n: int) -> int: Calculate the total number of honeycomb cells in n concentric rings. Parameters: n (int): Number of concentric rings, including the central cell Returns: int: Total number of cells in the honeycomb >>> total_honeycomb_cells(1) 1 >>> total_honeycomb_cells(2) 7 >>> total_honeycomb_cells(3) 19 >>> total_honeycomb_cells(4) 37 >>> total_honeycomb_cells(10) 271 >>> total_honeycomb_cells(100) 29701 >>> total_honeycomb_cells(1000000) 2999997000001 pass","solution":"def total_honeycomb_cells(n): Calculate the total number of honeycomb cells in n concentric rings. Parameters: n (int): Number of concentric rings, including the central cell Returns: int: Total number of cells in the honeycomb if n == 1: return 1 return 1 + 3 * n * (n - 1)"},{"question":"def count_difficulty_levels(T: int, test_cases: List[List[int]]) -> List[List[int]]: Returns a list of the counts of difficulties from 1 to 10 for each test case. Parameters: T (int): Number of test cases. test_cases (list of lists): Each list contains the problems for a test case. Returns: list of lists: Each list contains the counts of difficulties from 1 to 10. >>> count_difficulty_levels(2, [[1, 2, 2, 3, 3], [4, 4, 5, 5, 6, 6, 6]]) [[1, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 3, 0, 0, 0, 0]] from typing import List def test_single_case_with_varied_difficulties(): T = 1 test_cases = [ [1, 2, 2, 3, 3] ] expected = [ [1, 2, 2, 0, 0, 0, 0, 0, 0, 0] ] assert count_difficulty_levels(T, test_cases) == expected def test_multiple_cases(): T = 2 test_cases = [ [1, 2, 2, 3, 3], [4, 4, 5, 5, 6, 6, 6] ] expected = [ [1, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 3, 0, 0, 0, 0] ] assert count_difficulty_levels(T, test_cases) == expected def test_case_with_all_difficulties(): T = 1 test_cases = [ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ] expected = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ] assert count_difficulty_levels(T, test_cases) == expected def test_case_with_single_difficulty(): T = 1 test_cases = [ [5, 5, 5, 5, 5] ] expected = [ [0, 0, 0, 0, 5, 0, 0, 0, 0, 0] ] assert count_difficulty_levels(T, test_cases) == expected def test_case_with_no_difficulties(): T = 1 test_cases = [ [] ] expected = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ] assert count_difficulty_levels(T, test_cases) == expected","solution":"def count_difficulty_levels(T, test_cases): Returns a list of the counts of difficulties from 1 to 10 for each test case. Parameters: T (int): Number of test cases. test_cases (list of lists): Each list contains the problems for a test case. Returns: list of lists: Each list contains the counts of difficulties from 1 to 10. results = [] for case in test_cases: counts = [0] * 10 for difficulty in case: counts[difficulty - 1] += 1 results.append(counts) return results # Example usage T = 2 test_cases = [ [1, 2, 2, 3, 3], [4, 4, 5, 5, 6, 6, 6] ] print(count_difficulty_levels(T, test_cases))"},{"question":"def max_package_weight(n: int, W: int, weights: List[int]) -> int: Determine the maximum possible weight of a single package that can be formed by combining the given packages without exceeding a specific weight limit. >>> max_package_weight(5, 10, [2, 3, 7, 4, 6]) 10 >>> max_package_weight(4, 15, [5, 5, 5, 5]) 15","solution":"from itertools import combinations def max_package_weight(n, W, weights): max_weight = 0 for i in range(1, n + 1): for combo in combinations(weights, i): weight_sum = sum(combo) if weight_sum <= W: max_weight = max(max_weight, weight_sum) return max_weight"},{"question":"def longest_non_decreasing_period(n: int, prices: List[int]) -> int: Function to find the length of the longest period of non-decreasing stock prices. :param n: int - number of days :param prices: list of int - daily stock prices :return: int - length of longest period of non-decreasing stock prices >>> longest_non_decreasing_period(6, [100, 100, 105, 103, 105, 107]) 3 >>> longest_non_decreasing_period(5, [90, 90, 90, 90, 90]) 5 >>> longest_non_decreasing_period(1, [100]) 1 >>> longest_non_decreasing_period(2, [100, 101]) 2 >>> longest_non_decreasing_period(2, [101, 100]) 1 >>> longest_non_decreasing_period(6, [100, 101, 100, 101, 100, 101]) 2 >>> longest_non_decreasing_period(5, [5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_period(100000, [i for i in range(1, 100001)]) 100000 >>> longest_non_decreasing_period(10, [3, 3, 4, 5, 5, 6, 7, 7, 8, 9]) 10","solution":"def longest_non_decreasing_period(n, prices): Function to find the length of the longest period of non-decreasing stock prices. :param n: int - number of days :param prices: list of int - daily stock prices :return: int - length of longest period of non-decreasing stock prices if n <= 1: return n max_length = 1 current_length = 1 for i in range(1, n): if prices[i] >= prices[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def count_gcd_pairs(N: int, Q: int, A: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Given an array A of N integers, process Q queries to determine the number of index pairs (i, j) in the subarray [L, R] such that the greatest common divisor (GCD) of A[i] and A[j] is greater than or equal to K. Args: N : int : number of elements in the array. Q : int : number of queries. A : List[int] : the array of integers. queries : List[Tuple[int, int, int]] : a list of tuples representing the queries, where each tuple contains three integers (L, R, and K). Returns: List[int] : a list of integers where each integer is the result of a corresponding query. Example: >>> count_gcd_pairs(5, 3, [10, 15, 25, 20, 30], [(1, 3, 5), (2, 5, 10), (1, 5, 15)]) [3, 2, 1]","solution":"import math from collections import defaultdict def count_gcd_pairs(N, Q, A, queries): def gcd(x, y): while y: x, y = y, x % y return x results = [] for query in queries: L, R, K = query L -= 1 # Convert to zero-based index R -= 1 # Convert to zero-based index gcd_count = defaultdict(int) for i in range(L, R + 1): for j in range(i + 1, R + 1): if gcd(A[i], A[j]) >= K: gcd_count[(i, j)] += 1 results.append(sum(gcd_count.values())) return results # Sample Input N = 5 Q = 3 A = [10, 15, 25, 20, 30] queries = [(1, 3, 5), (2, 5, 10), (1, 5, 15)] print(count_gcd_pairs(N, Q, A, queries))"},{"question":"def fizz_buzz(n: int) -> List[str]: Returns a list of strings representing numbers from 1 to n with special rules: - \\"Fizz\\" for multiples of three, - \\"Buzz\\" for multiples of five, - \\"FizzBuzz\\" for multiples of both three and five, - The number itself as a string for all other numbers. >>> fizz_buzz(5) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\"] >>> fizz_buzz(15) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"] from solution import fizz_buzz def test_fizz_buzz_small_numbers(): assert fizz_buzz(1) == [\\"1\\"] assert fizz_buzz(2) == [\\"1\\", \\"2\\"] assert fizz_buzz(3) == [\\"1\\", \\"2\\", \\"Fizz\\"] assert fizz_buzz(5) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\"] def test_fizz_buzz_multiples_3_and_5(): assert fizz_buzz(6) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\"] assert fizz_buzz(10) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\"] def test_fizz_buzz_fizzbuzz(): assert fizz_buzz(15) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"] def test_fizz_buzz_large_numbers(): assert fizz_buzz(20) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\", \\"16\\", \\"17\\", \\"Fizz\\", \\"19\\", \\"Buzz\\"]","solution":"def fizz_buzz(n): Returns a list of strings representing numbers from 1 to n with special rules: - \\"Fizz\\" for multiples of three, - \\"Buzz\\" for multiples of five, - \\"FizzBuzz\\" for multiples of both three and five, - The number itself as a string for all other numbers. result = [] for i in range(1, n + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def find_two_largest_sum(arr): Returns the sum of the two largest distinct integers in the array \`arr\`. If there are less than two distinct integers, return None. >>> find_two_largest_sum([10, 14, 2, 23, 19]) 42 >>> find_two_largest_sum([1, 1, 1, 1]) None >>> find_two_largest_sum([1]) None >>> find_two_largest_sum([1, 5, 3, 9, 7, 7, 8]) 17 >>> find_two_largest_sum([]) None >>> find_two_largest_sum([-1, -5, -3, -9, -7, -8, -2]) -3 >>> find_two_largest_sum([-1, 5, 3, -9, 7, 7, 8]) 15","solution":"def find_two_largest_sum(arr): Returns the sum of the two largest distinct integers in the array \`arr\`. If there are less than two distinct integers, return None. # Removing duplicates by converting to set, then sorting in descending order unique_sorted = sorted(set(arr), reverse=True) # Check if there are at least two distinct numbers if len(unique_sorted) < 2: return None # Sum of the two largest distinct numbers return unique_sorted[0] + unique_sorted[1]"},{"question":"def longestZeroSumSubarray(A): Find the longest subarray with sum 0. :param A: List[int] -- input array :return: int -- length of the longest subarray with sum 0 >>> longestZeroSumSubarray([15, -2, 2, -8, 1, 7, 10, 23]) 5 >>> longestZeroSumSubarray([1, 2, 3, 4, 5]) 0 >>> longestZeroSumSubarray([1, -1, 3, -3, 4, -4]) 6 >>> longestZeroSumSubarray([-1, -1, 1, 1]) 4 >>> longestZeroSumSubarray([1, 2, -3, 3, -1]) 3 def process_test_cases(T, test_cases): Process multiple test cases to find the length of longest subarray with sum 0 for each. :param T: int -- number of test cases :param test_cases: List[Tuple[int, List[int]]] -- list of test cases, each containing size of array and the array itself :return: List[int] -- list of results for each test case >>> process_test_cases(3, [(8, [15, -2, 2, -8, 1, 7, 10, 23]), (5, [1, 2, 3, 4, 5]), (6, [1, -1, 3, -3, 4, -4])]) [5, 0, 6]","solution":"def longestZeroSumSubarray(A): Find the longest subarray with sum 0. :param A: List[int] -- input array :return: int -- length of the longest subarray with sum 0 sum_index_map = {} max_length = 0 current_sum = 0 for i in range(len(A)): current_sum += A[i] if current_sum == 0: max_length = i + 1 elif current_sum in sum_index_map: max_length = max(max_length, i - sum_index_map[current_sum]) else: sum_index_map[current_sum] = i return max_length def process_test_cases(T, test_cases): results = [] for i in range(T): _, array = test_cases[i] results.append(longestZeroSumSubarray(array)) return results"},{"question":"from typing import List, Tuple def longest_continuous_sunlight(n: int, intervals: List[Tuple[int, int]]) -> Tuple[int, int]: Find the longest continuous interval of sunlight seen in a single day based on given start and end times of intervals. Args: n : int : the number of intervals of sunlight. intervals : List[Tuple[int, int]] : list of tuples where each tuple contains two integers representing the start and end times of the sunlight interval. Returns: Tuple[int, int] : two integers representing the start and end time of the longest continuous sunlight interval. Example: >>> longest_continuous_sunlight(3, [(1, 5), (10, 15), (5, 10)]) (1, 15) >>> longest_continuous_sunlight(4, [(1, 3), (2, 6), (8, 10), (9, 11)]) (1, 6) >>> longest_continuous_sunlight(2, [(1, 2), (2, 3)]) (1, 3)","solution":"def longest_continuous_sunlight(n, intervals): intervals.sort() max_interval = (0, 0) current_start, current_end = intervals[0] for i in range(1, n): start, end = intervals[i] if start <= current_end: current_end = max(current_end, end) else: if (current_end - current_start) > (max_interval[1] - max_interval[0]): max_interval = (current_start, current_end) current_start, current_end = start, end if (current_end - current_start) > (max_interval[1] - max_interval[0]): max_interval = (current_start, current_end) return max_interval"},{"question":"def add_binary(a: str, b: str) -> str: Given two binary numbers represented as strings, returns their sum as a binary string. >>> add_binary(\\"11\\", \\"1\\") '100' >>> add_binary(\\"1010\\", \\"1011\\") '10101'","solution":"def add_binary(a: str, b: str) -> str: Given two binary numbers represented as strings, returns their sum as a binary string. # Initialize result string and carry result = [] carry = 0 # Reverse the strings to add from least significant digit a = a[::-1] b = b[::-1] # Get the maximum length of the binaries max_len = max(len(a), len(b)) for i in range(max_len): # Get the binary digit for a and b or 0 if the index exceeds the length digit_a = int(a[i]) if i < len(a) else 0 digit_b = int(b[i]) if i < len(b) else 0 # Calculate the sum of the current digits and the carry total = digit_a + digit_b + carry # The resulting digit (0 or 1) is the mod 2 of total result_digit = total % 2 result.append(str(result_digit)) # Calculate the new carry (0 or 1) carry = total // 2 # If there's any carry left, add it as the new most significant digit if carry: result.append('1') # Reverse the result list to get the final binary sum string return ''.join(result[::-1])"},{"question":"def count_adjacent_mines(grid, m, n): Determine the number of mines adjacent to each cell in the given grid. Each cell in the resulting grid contains a number representing the count of mines adjacent to that cell. >>> count_adjacent_mines([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ], 3, 3) [[9, 3, 9], [3, 9, 3], [9, 3, 9]] >>> count_adjacent_mines([ ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 0] ... ], 4, 4) [[1, 1, 1, 0], [1, 9, 2, 1], [1, 2, 9, 1], [0, 1, 1, 1]] >>> count_adjacent_mines([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ], 3, 3) [[1, 1, 1], [1, 9, 1], [1, 1, 1]] >>> count_adjacent_mines([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ], 3, 3) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> count_adjacent_mines([ ... [1, 1], ... [1, 1] ... ], 2, 2) [[9, 9], [9, 9]]","solution":"def count_adjacent_mines(grid, m, n): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def count_mines(x, y): count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: count += 1 return count result = [[0 for _ in range(n)] for _ in range(m)] for i in range(m): for j in range(n): if grid[i][j] == 0: result[i][j] = count_mines(i, j) else: result[i][j] = 9 # Adding 9 just to indicate the presence of a mine for testing purposes. return result"},{"question":"def min_diff_books(n: int, thicknesses: List[int]) -> int: Determines the minimum possible absolute difference between the total thickness of the two piles of books. >>> min_diff_books(3, [1, 2, 3]) 0 >>> min_diff_books(4, [10, 20, 30, 25]) 5","solution":"def min_diff_books(n, thicknesses): total_sum = sum(thicknesses) half_sum = total_sum // 2 dp = [False] * (half_sum + 1) dp[0] = True for t in thicknesses: for j in range(half_sum, t - 1, -1): if dp[j - t]: dp[j] = True for j in range(half_sum, -1, -1): if dp[j]: diff = total_sum - 2 * j break return diff"},{"question":"def smallest_lexicographical_order_string(test_cases): Returns a list of strings where each string is the smallest lexicographical order string that can be formed by jumbling the characters of the input strings. Parameters: test_cases (List[str]): A list of strings containing lowercase characters in the range [a-z] only. Returns: List[str]: A list of strings with characters sorted in lexicographical order. Examples: >>> smallest_lexicographical_order_string([\\"example\\", \\"zxy\\", \\"coding\\"]) ['aeelmpx', 'xyz', 'cdgino'] >>> smallest_lexicographical_order_string([\\"\\", \\"aaaa\\", \\"bbbb\\"]) ['', 'aaaa', 'bbbb']","solution":"def smallest_lexicographical_order_string(test_cases): Returns a list of strings where each string is the smallest lexicographical order string that can be formed by jumbling the characters of the input strings. results = [] for string in test_cases: results.append(''.join(sorted(string))) return results"},{"question":"def find_rmi(M: int, collections: List[List[int]]) -> int: Finds the Rare Manuscript Identifier (RMI) which appears exactly once in each collection. If it doesn't exist or there are multiple such identifiers, return -1. Args: M: int - Number of collections. collections: List[List[int]] - List of collections, each containing identifiers as positive integers. Returns: int: The RMI if it exists, -1 otherwise. Example: >>> find_rmi(3, [[11, 23, 11, 45], [23, 45, 11, 11], [11, 23, 33, 23]]) -1 >>> find_rmi(3, [[1, 2, 3], [2, 3, 4], [1, 3, 5]]) 3","solution":"def find_rmi(M, collections): Finds the Rare Manuscript Identifier (RMI) which appears exactly once in each collection. If it doesn't exist or there are multiple such identifiers, return -1. Returns: int: The RMI if it exists, -1 otherwise. from collections import Counter # Dictionary to count all occurrences of an identifier across all collections global_count = Counter() # List of counters to keep track of individual collection counts collection_counters = [] for collection in collections: count = Counter(collection) collection_counters.append(count) global_count.update(count) # Check identifiers that appear in every collection exactly once rm_candidates = [] for identifier in global_count: if global_count[identifier] == M and all(collection_count[identifier] == 1 for collection_count in collection_counters if identifier in collection_count): rm_candidates.append(identifier) # If there's exactly one RMI candidate, return it; otherwise, return -1 if len(rm_candidates) == 1: return rm_candidates[0] else: return -1"},{"question":"def simulate_elevator(F, N, requests): Simulates the elevator movement based on given requests. Args: F (int): Number of floors in the building. N (int): Number of requests. requests (List[int]): List of requested floors. Returns: List[int]: Sequence of floors visited by the elevator. pass # Unit tests def test_simulate_elevator_basic_case(): F = 5 N = 7 requests = [2, 3, 5, 4, 1, 4, 2] expected = [1, 2, 3, 5, 4, 1, 4, 2] assert simulate_elevator(F, N, requests) == expected def test_simulate_elevator_single_floor(): F = 1 N = 1 requests = [1] expected = [1, 1] assert simulate_elevator(F, N, requests) == expected def test_simulate_elevator_no_requests(): F = 5 N = 0 requests = [] expected = [1] assert simulate_elevator(F, N, requests) == expected def test_simulate_elevator_multiple_same_requests(): F = 5 N = 6 requests = [3, 3, 3, 3, 3, 3] expected = [1, 3, 3, 3, 3, 3, 3] assert simulate_elevator(F, N, requests) == expected def test_simulate_elevator_request_outside_range(): F = 5 N = 4 requests = [1, 6, 0, 3] expected = [1, 1, 3] assert simulate_elevator(F, N, requests) == expected","solution":"def simulate_elevator(F, N, requests): Simulates the elevator movement based on given requests. Args: F (int): Number of floors in the building. N (int): Number of requests. requests (List[int]): List of requested floors. Returns: List[int]: Sequence of floors visited by the elevator. # Starting at the ground floor, which is floor 1 current_floor = 1 visited_floors = [current_floor] for request in requests: if 1 <= request <= F: current_floor = request visited_floors.append(current_floor) return visited_floors # Example usage: # F = 5 # N = 7 # requests = [2, 3, 5, 4, 1, 4, 2] # print(simulate_elevator(F, N, requests))"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing digits (0-9), '+' and '*' following the standard order of operations (multiplication before addition). >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3+5*2+1\\") 14 from typing import List def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing digits (0-9), '+' and '*'. It respects the order of operations, i.e., multiplication before addition. Args: expression (str): A string representing the mathematical expression. Returns: int: The result of the evaluated expression. def test_evaluate_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_evaluate_simple_multiplication(): assert evaluate_expression(\\"3*2\\") == 6 def test_evaluate_mixed_operations_1(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_evaluate_mixed_operations_2(): assert evaluate_expression(\\"3+5*2+1\\") == 14 def test_evaluate_mixed_operations_3(): assert evaluate_expression(\\"2*3+4*5\\") == 26 def test_evaluate_mixed_operations_4(): assert evaluate_expression(\\"2*2*2+3*3*3\\") == 35 def test_evaluate_long_expression(): assert evaluate_expression(\\"1+2*3+4*5*6+7\\") == 134 def test_evaluate_single_number(): assert evaluate_expression(\\"42\\") == 42 def test_evaluate_single_operation(): assert evaluate_expression(\\"8*9\\") == 72 def test_evaluate_no_operations(): assert evaluate_expression(\\"999\\") == 999","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing digits (0-9), '+' and '*'. It respects the order of operations, i.e., multiplication before addition. # Splitting the expression by '+' to handle additions separately additions = expression.split('+') # Calculating the value of each term (separated by '+') considering '*' multiplication total_sum = 0 for term in additions: factors = term.split('*') product = 1 for factor in factors: product *= int(factor) total_sum += product return total_sum"},{"question":"def chain_calls(callables: list, initial_arg): Applies each callable in the list to the result of the previous callable, starting with the initial_arg. Parameters: - callables (list): A list of callables that each accept a single argument. - initial_arg: The initial argument to pass to the first callable in the list. Returns: - The result of applying the last function to the intermediate results of each preceding function. Example: >>> def add_one(x): >>> return x + 1 >>> def square(x): >>> return x * x >>> def to_str(x): >>> return str(x) >>> result = chain_calls([add_one, square, to_str], 3) >>> print(result) \\"16\\"","solution":"def chain_calls(callables: list, initial_arg): Applies each callable in the list to the result of the previous callable, starting with the initial_arg. Parameters: - callables (list): A list of callables that each accept a single argument. - initial_arg: The initial argument to pass to the first callable in the list. Returns: - The result of applying the last function to the intermediate results of each preceding function. result = initial_arg for func in callables: result = func(result) return result"},{"question":"def min_books_to_remove(m: int, c: int, books: List[int]) -> int: Returns the minimum number of books that need to be removed to ensure no rack exceeds its capacity. Args: m (int): Number of racks c (int): Capacity of each rack books (list of int): List of integers representing the number of books on each rack Returns: int: Minimum number of books to be removed >>> min_books_to_remove(5, 10, [12, 5, 14, 8, 7]) 6 >>> min_books_to_remove(3, 15, [20, 10, 5]) 5 >>> min_books_to_remove(4, 8, [8, 8, 8, 8]) 0","solution":"def min_books_to_remove(m, c, books): Returns the minimum number of books that need to be removed to ensure no rack exceeds its capacity. Args: m (int): Number of racks c (int): Capacity of each rack books (list of int): List of integers representing the number of books on each rack Returns: int: Minimum number of books to be removed total_books_to_remove = 0 for b in books: if b > c: total_books_to_remove += (b - c) return total_books_to_remove"},{"question":"def shortest_palindromic_length(s: str) -> int: This function finds the length of the shortest palindromic string by appending characters to the end of the given string \`s\`. >>> shortest_palindromic_length(\\"abac\\") 5 >>> shortest_palindromic_length(\\"race\\") 7 >>> shortest_palindromic_length(\\"madam\\") 5 >>> shortest_palindromic_length(\\"a\\") 1 >>> shortest_palindromic_length(\\"ab\\") 3 >>> shortest_palindromic_length(\\"aa\\") 2 >>> shortest_palindromic_length(\\"abcd\\") 7 >>> shortest_palindromic_length(\\"aacecaaa\\") 9 >>> shortest_palindromic_length(\\"abcdefghij\\") 19 >>> shortest_palindromic_length(\\"abccba\\") 6 >>> shortest_palindromic_length(\\"abccbx\\") 11","solution":"def shortest_palindromic_length(s): This function finds the length of the shortest palindromic string by appending characters to the end of the given string \`s\`. def is_palindrome(x): return x == x[::-1] if is_palindrome(s): return len(s) for i in range(len(s)): substring = s[:len(s)-i] if is_palindrome(substring): return len(s) + i # If no palindrome detected (which is unlikely given constraints) return 2 * len(s) - 1"},{"question":"def consecutiveSums(n: int) -> int: Given a positive integer n, return the number of ways to express n as a sum of two or more consecutive positive integers. >>> consecutiveSums(9) 2 >>> consecutiveSums(15) 3 >>> consecutiveSums(1) 0 >>> consecutiveSums(1000000) > 0 True >>> consecutiveSums(16) 0","solution":"def consecutiveSums(n): Returns the number of ways to express n as a sum of two or more consecutive positive integers. ways = 0 k = 1 while k * (k + 1) < 2 * n: numerator = n - (k * (k + 1)) // 2 if numerator % (k + 1) == 0: ways += 1 k += 1 return ways"},{"question":"def can_form_palindrome(n: int, test_cases: List[Tuple[str, str]]) -> List[str]: Determines for each test case if it's possible to form a palindrome by rearranging the characters of the concatenation of s1 and s2. >>> can_form_palindrome(3, [(\\"aabb\\", \\"ccdd\\"), (\\"abc\\", \\"def\\"), (\\"ab\\", \\"ba\\")]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_form_palindrome(1, [(\\"a\\", \\"a\\")]) [\\"YES\\"]","solution":"def can_form_palindrome(n, test_cases): Determines for each test case if it's possible to form a palindrome by rearranging the characters of the concatenation of s1 and s2. Parameters: n (int): Number of test cases test_cases (list of tuples): Each tuple contains two strings, s1 and s2 Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each test case results = [] for s1, s2 in test_cases: s = s1 + s2 # Count the frequency of each character in the concatenated string char_count = {} for char in s: if char not in char_count: char_count[char] = 0 char_count[char] += 1 # Check the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd frequency if odd_count <= 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_fit_through_machine(t, W, L, H, boxes): Determine if each box in the list of boxes can fit through the sorting machine. Parameters: t (int): the number of test cases. W (int): the maximum permitted width. L (int): the maximum permitted length. H (int): the maximum permitted height. boxes (List[Tuple[int, int, int]]): the dimensions of the boxes. Returns: List[str]: a list of strings \\"YES\\" or \\"NO\\" indicating if each corresponding box can fit through the sorting machine. >>> can_fit_through_machine(3, 5, 10, 8, [(4, 5, 6), (10, 5, 4), (11, 5, 10)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_fit_through_machine(2, 5, 5, 5, [(6, 6, 6), (5, 5, 6)]) [\\"NO\\", \\"NO\\"]","solution":"def can_fit_through_machine(t, W, L, H, boxes): results = [] for i in range(t): w, l, h = sorted(boxes[i]) if w <= W and l <= L and h <= H: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # t = 3 # W, L, H = 5, 10, 8 # boxes = [(4, 5, 6), (10, 5, 4), (11, 5, 10)] # print(can_fit_through_machine(t, W, L, H, boxes)) # Output should be [\\"YES\\", \\"YES\\", \\"NO\\"]"},{"question":"def insert_character(string, position, character): Inserts a character at the specified position in the string. # Your code here pass def delete_character(string, position): Deletes the character at the specified position in the string. # Your code here pass def count_distinct_characters(string): Returns the number of distinct characters in the string. # Your code here pass","solution":"def insert_character(string, position, character): Inserts a character at the specified position in the string. return string[:position] + character + string[position:] def delete_character(string, position): Deletes the character at the specified position in the string. return string[:position] + string[position+1:] def count_distinct_characters(string): Returns the number of distinct characters in the string. return len(set(string))"},{"question":"def compress_string(input_str: str) -> str: Compress a string by counts of repeated characters. For each group of consecutive repeating characters, the compressed string includes the character followed by the count of repetition. If the compressed string is not smaller than the original string, return the original string. The function is case-sensitive and handles alphabetic characters only. Args: input_str (str): The input string containing only alphabetic characters. Returns: str: The compressed string or the original string if compression is not efficient. Examples: >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abc\\") 'abc' # Test cases def test_compressed_is_smaller(): assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" def test_original_is_smaller(): assert compress_string(\\"abc\\") == \\"abc\\" def test_single_character(): assert compress_string(\\"a\\") == \\"a\\" def test_case_sensitivity(): assert compress_string(\\"aabcccccAAAaaa\\") == \\"a2b1c5A3a3\\" def test_all_repeating_single_char(): assert compress_string(\\"aaaaa\\") == \\"a5\\" def test_alternating_chars(): assert compress_string(\\"ababab\\") == \\"ababab\\" def test_long_repeating_chars(): assert compress_string(\\"bbbbbbbbb\\") == \\"b9\\"","solution":"def compress_string(input_str: str) -> str: compressed = [] count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: compressed.append(input_str[i - 1] + str(count)) count = 1 compressed.append(input_str[-1] + str(count)) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(input_str) else input_str"},{"question":"def robot_paths(m: int, n: int) -> int: Returns the number of unique paths the robot can take to reach the end of an m x n grid. This is solved using dynamic programming. >>> robot_paths(3, 3) 6 >>> robot_paths(4, 4) 20","solution":"def robot_paths(m, n): Returns the number of unique paths the robot can take to reach the end of an m x n grid. This is solved using dynamic programming. # Create a 2D table to store solutions to subproblems dp = [[0] * n for _ in range(m)] # There is only one way to reach any cell in the first row, which is by moving right from the start for i in range(m): dp[i][0] = 1 # There is only one way to reach any cell in the first column, which is by moving down from the start for j in range(n): dp[0][j] = 1 # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def minimum_cost_to_construct(N, M, roads, K, new_roads): The Kingdom of Codesland has N cities connected by M bidirectional roads. Each road connects two cities and has an associated travel cost. The King wants to build new roads in such a way that there is exactly one path between any two cities (i.e., the road network is a tree). The function calculates the minimum total cost to construct a road network that meets the conditions. Parameters: N (int): The number of cities. M (int): The number of existing roads. roads (List[Tuple[int, int, int]]): The list of existing roads where each road is defined by a tuple (u, v, w) representing the endpoints (u, v) and its travel cost (w). K (int): The number of potential new roads. new_roads (List[Tuple[int, int, int]]): The list of potential new roads where each road is defined by a tuple (u, v, w) representing the endpoints (u, v) and its travel cost (w). Returns: int: The minimum total cost to construct the road network, or -1 if it's impossible. >>> minimum_cost_to_construct(4, 3, [(1, 2, 3), (2, 3, 1), (3, 4, 4)], 2, [(1, 4, 2), (2, 4, 3)]) 6 >>> minimum_cost_to_construct(3, 2, [(1, 2, 5), (2, 3, 10)], 1, [(1, 3, 1)]) 6 >>> minimum_cost_to_construct(3, 1, [(1, 2, 1)], 0, []) -1 >>> minimum_cost_to_construct(3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 10)], 0, []) 10 >>> minimum_cost_to_construct(4, 0, [], 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 4)]) 3","solution":"def find(parent, i): if parent[i] == i: return i parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def minimum_cost_to_construct(N, M, roads, K, new_roads): edges = roads + new_roads edges.sort(key=lambda x: x[2]) parent = list(range(N + 1)) rank = [0] * (N + 1) mst_cost = 0 edges_used = 0 for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w edges_used += 1 if edges_used == N - 1: break if edges_used != N - 1: return -1 return mst_cost"},{"question":"def minimize_groups(n, a, b): Returns the minimum number of groups needed to organize the attendees. Parameters: n (int): Number of attendees a (int): Minimum group size b (int): Maximum group size Returns: int: Minimum number of groups Examples: >>> minimize_groups(15, 4, 5) 3 >>> minimize_groups(100, 7, 10) 10 >>> minimize_groups(25, 1, 25) 1","solution":"def minimize_groups(n, a, b): Returns the minimum number of groups needed to organize the attendees. Parameters: n (int): Number of attendees a (int): Minimum group size b (int): Maximum group size Returns: int: Minimum number of groups # To minimize the number of groups, we should use the largest group size possible return (n + b - 1) // b # The ceiling of n / b"},{"question":"def find_cycle_in_graph(test_cases): You are given an undirected, unweighted graph with \`V\` vertices and \`E\` edges. Your task is to find out if the graph contains a cycle. Input: - The first line contains an integer \`T\` representing the number of test cases. - For each test case, the first line contains two space-separated integers \`V\` and \`E\`, representing the number of vertices and edges in the graph, respectively. - The next \`E\` lines each contain two integers \`u\` and \`v\` representing an edge between vertex \`u\` and vertex \`v\`. Output: - For each test case, output \\"YES\\" if the graph contains a cycle, otherwise output \\"NO\\". Constraints: - 1 â‰¤ T â‰¤ 100 - 2 â‰¤ V â‰¤ 1000 - 1 â‰¤ E â‰¤ 2000 - 1 â‰¤ u, v â‰¤ V Sample Input: 2 3 3 1 2 2 3 3 1 4 2 1 2 2 3 Sample Output: YES NO Examples: >>> find_cycle_in_graph([(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 2, [(1, 2), (2, 3)])]) ['YES', 'NO'] >>> find_cycle_in_graph([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) ['YES', 'NO']","solution":"def find_cycle_in_graph(test_cases): def has_cycle(graph, V): visited = [False] * (V + 1) def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif parent != neighbor: return True return False for node in range(1, V + 1): if not visited[node]: if dfs(node, -1): return True return False results = [] for V, E, edges in test_cases: graph = [[] for _ in range(V + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) if has_cycle(graph, V): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def smallest_missing_positive(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the smallest missing positive integer greater than 0 for each test case. >>> smallest_missing_positive(3, [(3, [1, 2, 0]), (4, [3, 4, -1, 1]), (5, [7, 8, 9, 11, 12])]) [3, 2, 1] >>> smallest_missing_positive(1, [(5, [-1, -2, -3, -4, -5])]) [1]","solution":"def smallest_missing_positive(t, test_cases): def find_missing_positive(arr): s = set(arr) i = 1 while True: if i not in s: return i i += 1 results = [] for i in range(t): n, arr = test_cases[i] results.append(find_missing_positive(arr)) return results"},{"question":"def count_twin_primes(n: int) -> int: Returns the number of twin prime pairs (p1, p2) such that both p1 and p2 are less than or equal to n. >>> count_twin_primes(10) 2 >>> count_twin_primes(20) 4","solution":"def is_prime(x): Helper function to check if a number x is prime. if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True def count_twin_primes(n): Returns the number of twin prime pairs (p1, p2) such that both p1 and p2 are less than or equal to n. twin_primes_count = 0 last_prime = 2 # the first prime number for current in range(3, n + 1, 2): # iterate only odd numbers starting from 3 if is_prime(current): if current - last_prime == 2: twin_primes_count += 1 last_prime = current return twin_primes_count"},{"question":"def count_growth_days(n: int, heights: List[int]) -> int: Calculate the number of days the plant height increased compared to the previous day. :param n: integer, number of days :param heights: list of integers, heights of the plant over the days :return: integer, number of days of growth >>> count_growth_days(5, [1, 2, 2, 3, 5]) 3 >>> count_growth_days(4, [10, 9, 8, 7]) 0 from typing import List, Tuple def test_example_1(): assert count_growth_days(5, [1, 2, 2, 3, 5]) == 3 def test_example_2(): assert count_growth_days(4, [10, 9, 8, 7]) == 0 def test_all_same_height(): assert count_growth_days(5, [3, 3, 3, 3, 3]) == 0 def test_always_increasing_height(): assert count_growth_days(4, [1, 2, 3, 4]) == 3 def test_decreases_and_increases(): assert count_growth_days(6, [4, 3, 2, 3, 4, 5]) == 3 def test_minimum_input(): assert count_growth_days(1, [1]) == 0 def test_fluctuating_heights(): assert count_growth_days(6, [1, 3, 2, 4, 2, 5]) == 3","solution":"def count_growth_days(n, heights): Returns the number of days the plant height increased compared to the previous day. :param n: integer, number of days :param heights: list of integers, heights of the plant over the days :return: integer, number of days of growth growth_days = 0 for i in range(1, n): if heights[i] > heights[i - 1]: growth_days += 1 return growth_days"},{"question":"def perform_operations(N: int, Q: int, array: List[int], operations: List[Tuple[str, str]]) -> List[int]: Given a set of N integers, performs a series of Q operations on it: 1. Add a value X to all the elements in the array. 2. Retrieve the value of a specific element in the array, considering all the additions that have been applied up to that point. Parameters: N: int - size of the array Q: int - number of operations array: List[int] - initial values of the array operations: List[Tuple[str, str]] - operations to be performed Returns: List[int] - results of the retrieve operations Example: >>> perform_operations(5, 5, [1, 2, 3, 4, 5], [(\\"1\\", \\"10\\"), (\\"2\\", \\"3\\"), (\\"1\\", \\"-3\\"), (\\"2\\", \\"1\\"), (\\"2\\", \\"5\\")]) [13, 8, 12] pass","solution":"def perform_operations(N, Q, array, operations): addition_sum = 0 output = [] for operation in operations: if operation[0] == '1': # Add operation addition_sum += int(operation[1]) elif operation[0] == '2': # Retrieve operation idx = int(operation[1]) - 1 # Convert to 0-based index result = array[idx] + addition_sum output.append(result) return output"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in the string s. Parameters: s (str): The input string containing words separated by spaces. Returns: str: A string with the order of words reversed. >>> reverse_words(\\"the sky is blue\\") 'blue is sky the' >>> reverse_words(\\"hello\\") 'hello' >>> reverse_words(\\" hello world \\") 'world hello' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"a quick brown fox\\") 'fox brown quick a'","solution":"def reverse_words(s: str) -> str: Reverses the order of words in the string s. Parameters: s (str): The input string containing words separated by spaces. Returns: str: A string with the order of words reversed. # Split the string into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the words back into a single string with spaces in between return ' '.join(reversed_words)"},{"question":"def remove_duplicates(n, integers): Removes duplicates from a list of integers while maintaining the order of first occurrences. :param n: Number of integers :param integers: List of integers :return: List of integers with duplicates removed >>> remove_duplicates(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates(5, [1, 2, 2, 3, 4]) [1, 2, 3, 4] >>> remove_duplicates(5, [1, 1, 1, 1, 1]) [1] >>> remove_duplicates(0, []) [] >>> remove_duplicates(8, [4, 3, 2, 3, 4, 1, 1, 2]) [4, 3, 2, 1]","solution":"def remove_duplicates(n, integers): Removes duplicates from a list of integers while maintaining the order of first occurrences. :param n: Number of integers :param integers: List of integers :return: List of integers with duplicates removed seen = set() result = [] for number in integers: if number not in seen: seen.add(number) result.append(number) return result"},{"question":"def generate_email_aliases(n: int, employees: List[Tuple[str, str]]) -> List[str]: Generates unique email aliases for a list of employees based on their first and last names. The format of the email alias is: - If the combination of first and last name is unique, the alias is \\"firstname.lastname\\". - If the combination is not unique, it appends a number to the alias, starting from 1 and incrementing by 1 until it is unique. Args: n (int): The number of employees. employees (list of tuple): A list of tuples, each containing two strings: the first name and the last name of an employee. Returns: list of str: A list of unique email aliases. Example: >>> generate_email_aliases(4, [(\\"john\\", \\"doe\\"), (\\"jane\\", \\"doe\\"), (\\"john\\", \\"doe\\"), (\\"john\\", \\"smith\\")]) [\\"john.doe\\", \\"jane.doe\\", \\"john.doe1\\", \\"john.smith\\"] pass # Unit tests def test_generate_email_aliases_unique_names(): employees = [(\\"john\\", \\"doe\\"), (\\"jane\\", \\"doe\\"), (\\"john\\", \\"smith\\")] expected = [\\"john.doe\\", \\"jane.doe\\", \\"john.smith\\"] assert generate_email_aliases(3, employees) == expected def test_generate_email_aliases_duplicate_names(): employees = [(\\"john\\", \\"doe\\"), (\\"john\\", \\"doe\\"), (\\"john\\", \\"doe\\")] expected = [\\"john.doe\\", \\"john.doe1\\", \\"john.doe2\\"] assert generate_email_aliases(3, employees) == expected def test_generate_email_aliases_mixed_names(): employees = [(\\"john\\", \\"doe\\"), (\\"jane\\", \\"doe\\"), (\\"john\\", \\"doe\\"), (\\"john\\", \\"smith\\")] expected = [\\"john.doe\\", \\"jane.doe\\", \\"john.doe1\\", \\"john.smith\\"] assert generate_email_aliases(4, employees) == expected def test_generate_email_aliases_minimum_case(): employees = [(\\"a\\", \\"b\\")] expected = [\\"a.b\\"] assert generate_email_aliases(1, employees) == expected def test_generate_email_aliases_all_different(): employees = [(\\"a\\", \\"a\\"), (\\"b\\", \\"b\\"), (\\"c\\", \\"c\\"), (\\"d\\", \\"d\\")] expected = [\\"a.a\\", \\"b.b\\", \\"c.c\\", \\"d.d\\"] assert generate_email_aliases(4, employees) == expected","solution":"def generate_email_aliases(n, employees): Generates unique email aliases for a list of employees. Args: n (int): The number of employees. employees (list of tuple of str): List of tuples containing first and last name of employees. Returns: list of str: A list of unique email aliases. email_counts = {} result = [] for first_name, last_name in employees: base_alias = f\\"{first_name}.{last_name}\\" if base_alias not in email_counts: email_counts[base_alias] = 1 result.append(base_alias) else: email_counts[base_alias] += 1 alias = f\\"{base_alias}{email_counts[base_alias] - 1}\\" result.append(alias) email_counts[alias] = 1 return result"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determine if the input string is a permutation of a palindrome. >>> is_palindrome_permutation(\\"tacocat\\") True >>> is_palindrome_permutation(\\"ivicc\\") True >>> is_palindrome_permutation(\\"hello\\") False >>> is_palindrome_permutation(\\"civil\\") False","solution":"def is_palindrome_permutation(s: str) -> bool: from collections import Counter # Count frequencies of each character in the string char_count = Counter(s) # Check how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be a permutation of a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def smallest_subarray_with_sum(nums, k): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, return -1. >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 11) == 3 >>> smallest_subarray_with_sum([2, 3, 1, 2, 4, 3], 7) == 2 >>> smallest_subarray_with_sum([1, 1, 1], 5) == -1","solution":"def smallest_subarray_with_sum(nums, k): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, return -1. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def road_trip(n, fun_ratings, d): Determine the sequence of city indices to visit during a road trip. Parameters: n (int): The number of cities. fun_ratings (List[int]): A list of integers representing the fun-ratings of the cities. d (int): The direction of the trip, 1 for clockwise and 2 for counter-clockwise. Returns: List[int]: The sequence of city indices in the order the friends will visit them. >>> road_trip(5, [3, 2, 4, 1, 5], 1) [5, 1, 2, 3, 4] >>> road_trip(4, [2, 2, 3, 3], 2) [3, 2, 1, 4]","solution":"def road_trip(n, fun_ratings, d): highest_fun = max(fun_ratings) start_index = fun_ratings.index(highest_fun) + 1 if d == 1: # Clockwise sequence = [(start_index + i - 1) % n + 1 for i in range(n)] else: # Counter-clockwise sequence = [(start_index - i - 1) % n + 1 for i in range(n)] return sequence"},{"question":"def min_elements_to_target_sum(num_cases: int, test_cases: list[tuple[int, int, list[int]]]) -> list[int]: Given an array of positive integers and a target sum, determine the minimum number of elements from the array that sum up to exactly the target sum. If it's not possible to achieve the target sum using any subset of the elements, return -1. Args: num_cases (int): The number of test cases. test_cases (list[tuple]): Each test case is a tuple where the first element is the number of elements in the array (n), the second element is the target sum (t), and the third element is a list of integers representing the array. Returns: list[int]: A list of integers representing the result for each test case. The result for each test case is the minimum number of elements that sum up to exactly the target sum, or -1 if not possible. Example: >>> min_elements_to_target_sum(3, [(5, 11, [1, 2, 3, 5, 10]), (4, 9, [3, 5, 7, 8]), (3, 6, [4, 5, 6])]) [2, -1, 1] >>> min_elements_to_target_sum(1, [(1, 1, [1])]) [1] >>> min_elements_to_target_sum(1, [(0, 10, [])]) [-1] from sys import stdin, maxsize def read_input(): input = stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): n = int(data[idx]) t = int(data[idx + 1]) idx += 2 array = list(map(int, data[idx:idx + n])) idx += n test_cases.append((n, t, array)) return T, test_cases if __name__ == \\"__main__\\": T, test_cases = read_input() results = min_elements_to_target_sum(T, test_cases) for result in results: print(result)","solution":"def min_elements_to_target_sum(num_cases, test_cases): from sys import maxsize results = [] for i in range(num_cases): n, t, array = test_cases[i] # Initialize DP table dp = [maxsize] * (t + 1) dp[0] = 0 for num in array: for j in range(t, num - 1, -1): if dp[j - num] != maxsize: dp[j] = min(dp[j], dp[j - num] + 1) result = dp[t] if dp[t] != maxsize else -1 results.append(result) return results # Reading the input def read_input(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): n = int(data[idx]) t = int(data[idx + 1]) idx += 2 array = list(map(int, data[idx:idx + n])) idx += n test_cases.append((n, t, array)) return T, test_cases if __name__ == \\"__main__\\": T, test_cases = read_input() results = min_elements_to_target_sum(T, test_cases) for result in results: print(result)"},{"question":"def multiply_arrays(arr1, arr2): Multiplies each element of arr1 by the corresponding element of arr2. If the arrays have different lengths, multiplies up to the length of the shorter array. >>> multiply_arrays([1, 2, 3], [4, 5, 6]) [4, 10, 18] >>> multiply_arrays([1, 2], [3, 4, 5]) [3, 8] >>> multiply_arrays([7, 8, 9], [1, 2]) [7, 16]","solution":"def multiply_arrays(arr1, arr2): Multiplies each element of arr1 by the corresponding element of arr2. If the arrays have different lengths, multiplies up to the length of the shorter array. :param arr1: List[int], the first array of integers :param arr2: List[int], the second array of integers :return: List[int], the resulting array of the multiplications return [a * b for a, b in zip(arr1, arr2)]"},{"question":"from typing import List def can_sum_to_s(n: int, s: int, piles: List[List[int]]) -> str: Determine if Bessie can pick one card from each pile such that their values sum to exactly s. Parameters: n (int): Number of piles. s (int): Target sum. piles (List[List[int]]): List of piles where each pile is a list of integers. Returns: str: \\"YES\\" if it is possible to pick one card from each pile such that their values sum to s, otherwise \\"NO\\". Examples: >>> can_sum_to_s(3, 15, [[8, 5, 2], [12, 7, 4, 3], [6, 1]]) \\"YES\\" >>> can_sum_to_s(2, 10, [[7, 3], [4, 5, 6]]) \\"NO\\"","solution":"from itertools import product def can_sum_to_s(n, s, piles): # Generate all possible combinations of picking one card from each pile all_combinations = product(*piles) # Check if any combination sums to s for combination in all_combinations: if sum(combination) == s: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def product_except_self(arr: List[int], mod: int = 10**9+7) -> List[int]: Computes the product of all elements in the array except for the one at the same position, with each product taken modulo 10^9 + 7. Args: arr (List[int]): The input list of distinct integers. mod (int): The modulo value to be used for the product calculations. Returns: List[int]: A list of integers where each integer is the product of all the elements in the input list except the one at the same position, modulo 10^9 + 7. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([10**9, 10**9 + 1]) [10**9 + 1, 10**9] pass def compute_products_for_all_cases(test_cases: List[List[int]]) -> List[List[int]]: Computes the product_except_self for each test case. Args: test_cases (List[List[int]]): A list of test cases where each test case is a list of distinct integers. Returns: List[List[int]]: A list of results for each test case. Example: >>> compute_products_for_all_cases([[1, 2, 3, 4]]) [[24, 12, 8, 6]] >>> compute_products_for_all_cases([[2, 3], [4, 5, 6]]) [[3, 2], [30, 24, 20]] pass def parse_input_input(input_string: str) -> List[List[int]]: Parses the input string and returns a list of test cases. Args: input_string (str): The input string containing the number of test cases, followed by the test cases themselves. Returns: List[List[int]]: A list of test cases. Example: >>> parse_input_input('2n2n2 3n3n4 5 6n') [[2, 3], [4, 5, 6]] >>> parse_input_input('1n4n1 2 3 4n') [[1, 2, 3, 4]] pass","solution":"def product_except_self(arr, mod=10**9+7): n = len(arr) if n < 2: return [] result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product = (left_product * arr[i]) % mod right_product = 1 for i in range(n-1, -1, -1): result[i] = (result[i] * right_product) % mod right_product = (right_product * arr[i]) % mod return result def compute_products_for_all_cases(test_cases): results = [] for case in test_cases: results.append(product_except_self(case)) return results def parse_input_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0].strip()) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index].strip()) index += 1 case = list(map(int, input_lines[index].strip().split())) index += 1 test_cases.append(case) return test_cases"},{"question":"def subset_sum_exists(n, m, nums): Determines if there exists a subset of the list \`nums\` such that the sum of the subset is equal to \`m\`. Parameters: n (int): The number of elements in the list. m (int): The target sum value. nums (list): The list of integers. Returns: str: \\"YES\\" if such a subset exists, \\"NO\\" otherwise. >>> subset_sum_exists(5, 9, [3, 34, 4, 12, 5]) \\"YES\\" >>> subset_sum_exists(3, 0, [7, -3, 2]) \\"YES\\" >>> subset_sum_exists(4, 15, [1, 2, 3, 4]) \\"NO\\" pass def handle_multiple_cases(tc): Handles multiple test cases. Parameters: tc (list of tuples): Each tuple contains (n, m, nums) representing a test case. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. >>> handle_multiple_cases([(5, 9, [3, 34, 4, 12, 5]), (3, 0, [7, -3, 2]), (4, 15, [1, 2, 3, 4])]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def subset_sum_exists(n, m, nums): Determines if there exists a subset of the list \`nums\` such that the sum of the subset is equal to \`m\`. Parameters: n (int): The number of elements in the list. m (int): The target sum value. nums (list): The list of integers. Returns: str: \\"YES\\" if such a subset exists, \\"NO\\" otherwise. # Helper function to check subset sum def subset_sum(nums, target, index): if target == 0: return True if index >= len(nums) or target < 0: return False # Include the number at index include = subset_sum(nums, target - nums[index], index + 1) # Exclude the number and move to the next exclude = subset_sum(nums, target, index + 1) return include or exclude return \\"YES\\" if subset_sum(nums, m, 0) else \\"NO\\" def handle_multiple_cases(tc): Handles multiple test cases. Parameters: tc (list of tuples): Each tuple contains (n, m, nums) representing a test case. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for t in tc: n, m, nums = t results.append(subset_sum_exists(n, m, nums)) return results"},{"question":"def add_truck(fleet, subordinates, capacities, p, c, x): Add a new truck \`p\` with load capacity \`x\` as a subordinate to truck \`c\`. pass def update_truck_capacity(capacities, p, x): Update the load capacity of truck \`p\` to \`x\`. pass def query_total_capacity(subordinates, capacities, c): Calculate the combined load capacity of a lead truck \`c\` and all the trucks it directly or indirectly manages. pass def manage_fleet(N, initial_loads, connections, queries): Manages the fleet operations and returns the results for query operations. >>> N = 5 >>> initial_loads = [10, 5, 8, 3, 7] >>> connections = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> queries = [ ... ('Q', 1), ... ('Q', 2), ... ('A', 6, 2, 1), ... ('U', 4, 10), ... ('Q', 1), ... ('Q', 2) ... ] >>> manage_fleet(N, initial_loads, connections, queries) [33, 15, None, None, 42, 22] pass def test_manage_fleet(): N = 5 initial_loads = [10, 5, 8, 3, 7] connections = [(1, 2), (1, 3), (2, 4), (2, 5)] queries = [ ('Q', 1), ('Q', 2), ('A', 6, 2, 1), ('U', 4, 10), ('Q', 1), ('Q', 2) ] expected_outputs = [33, 15, None, None, 42, 22] results = manage_fleet(N, initial_loads, connections, queries) assert results == expected_outputs[:2] + expected_outputs[4:]","solution":"def add_truck(fleet, subordinates, capacities, p, c, x): capacities.append(x) # Add new truck capacity fleet[p] = c # Set super truck relationship if c in subordinates: subordinates[c].append(p) else: subordinates[c] = [p] def update_truck_capacity(capacities, p, x): capacities[p-1] = x # Update capacity of truck \`p\` def query_total_capacity(subordinates, capacities, c): def dfs(truck): total = capacities[truck-1] if truck in subordinates: for sub in subordinates[truck]: total += dfs(sub) return total return dfs(c) def manage_fleet(N, initial_loads, connections, queries): capacities = initial_loads[:] # Copy the initial loads fleet = {i + 1: None for i in range(N)} subordinates = {} for u, v in connections: if u in subordinates: subordinates[u].append(v) else: subordinates[u] = [v] fleet[v] = u results = [] for query in queries: if query[0] == 'A': add_truck(fleet, subordinates, capacities, query[1], query[3], query[2]) elif query[0] == 'U': update_truck_capacity(capacities, query[1], query[2]) elif query[0] == 'Q': results.append(query_total_capacity(subordinates, capacities, query[1])) return results"},{"question":"def smallest_value_after_operations(test_cases): This function takes a list of test cases and returns the smallest possible value in the array after applying the (N-1) operations for each test case. Args: test_cases: List of tuples. Each tuple contains an integer N and a list of N integers. Returns: List of integers representing the smallest possible value for each test case. Examples: >>> smallest_value_after_operations([(3, [1, 2, 3])]) [6] >>> smallest_value_after_operations([(3, [1, 2, 3]), (4, [4, 2, 5, 1])]) [6, 12]","solution":"def smallest_value_after_operations(test_cases): This function takes a list of test cases and returns the smallest possible value in the array after applying the (N-1) operations for each test case. results = [] for case in test_cases: N, array = case total_sum = sum(array) results.append(total_sum) return results"},{"question":"def is_any_book_late(books): Checks if any book in the list of book returns was returned late. Parameters: books (list): A list of dictionaries, where each dictionary contains: - 'borrower' (str): The name of the borrower - 'title' (str): The title of the book - 'overdue_days' (int): The number of overdue days Returns: bool: True if any book was returned late, otherwise False Example usage: >>> books = [ ... {'borrower': 'Alice', 'title': '1984', 'overdue_days': 0}, ... {'borrower': 'Bob', 'title': 'To Kill a Mockingbird', 'overdue_days': 2}, ... {'borrower': 'Charlie', 'title': 'Moby Dick', 'overdue_days': -1}, ... ] >>> is_any_book_late(books) True","solution":"def is_any_book_late(books): Checks if any book in the list of book returns was returned late. Parameters: books (list): A list of dictionaries, where each dictionary contains: - 'borrower' (str): The name of the borrower - 'title' (str): The title of the book - 'overdue_days' (int): The number of overdue days Returns: bool: True if any book was returned late, otherwise False for book in books: if book.get('overdue_days', 0) > 0: return True return False"},{"question":"def smallest_missing_positive(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the smallest positive integer that is not present in each of the arrays in the test cases. Parameters: - T (int): The number of test cases. - test_cases (list of tuples): Each tuple contains an integer representing the size of the array and the array itself. Returns: - list of int: The smallest positive integer not present in each of the arrays. >>> smallest_missing_positive(3, [(3, [1, 2, 0]), (5, [3, 4, -1, 1]), (1, [-1])]) [3, 2, 1] >>> smallest_missing_positive(2, [(4, [2, 3, 7, 6]), (6, [-1, -3, 1, 2, 6, 5])]) [1, 3] >>> smallest_missing_positive(2, [(5, [-1, -2, -3, -4, -5]), (4, [10, 9, 8, 7])]) [1, 1] >>> smallest_missing_positive(1, [(5, [0, 0, 0, 1, 1])]) [2] >>> smallest_missing_positive(1, [(3, [999999999, 1000000000, 1000000001])]) [1] >>> smallest_missing_positive(1, [(7, [1, 2, 3, 4, 5, 6, 8])]) [7] >>> smallest_missing_positive(1, [(0, [])]) [1]","solution":"def smallest_missing_positive(T, test_cases): Returns the smallest positive integer that is not present in each of the arrays in the test cases. Parameters: - T (int): The number of test cases. - test_cases (list of tuples): Each tuple contains an integer representing the size of the array and the array itself. Returns: - list of int: The smallest positive integer not present in each of the arrays. results = [] for case in test_cases: N, arr = case arr_set = set(arr) smallest_missing = 1 while smallest_missing in arr_set: smallest_missing += 1 results.append(smallest_missing) return results"},{"question":"class StudentScores: def __init__(self, scores): Initialize the scores. Args: scores (List[int]): List of student scores. self.scores = scores def update(self, i, x): Update the score of a specific student. Args: i (int): The index of the student (1-based). x (int): The new score to be assigned. self.scores[i-1] = x def query(self, l, r): Find the maximum score within a given range of students. Args: l (int): The start index of the range (1-based). r (int): The end index of the range (1-based). Returns: int: The maximum score within the specified range. return max(self.scores[l-1:r]) def process_operations(n, q, scores, operations): Process a list of update and query operations on student scores. Args: n (int): Number of students. q (int): Number of operations. scores (List[int]): List of initial scores of the students. operations (List[List[int]]): List of operations to be performed. Returns: List[int]: The results of all query operations. >>> process_operations(5, 5, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 3, 6], [2, 2, 4], [1, 5, 1], [2, 3, 5]]) [3, 6, 6] >>> process_operations(3, 2, [10, 15, 20], [[1, 2, 25], [2, 1, 3]]) [25] student_scores = StudentScores(scores) output = [] for operation in operations: t = operation[0] if t == 1: i, x = operation[1], operation[2] student_scores.update(i, x) elif t == 2: l, r = operation[1], operation[2] output.append(student_scores.query(l, r)) return output","solution":"class StudentScores: def __init__(self, scores): self.scores = scores def update(self, i, x): self.scores[i-1] = x def query(self, l, r): return max(self.scores[l-1:r]) def process_operations(n, q, scores, operations): student_scores = StudentScores(scores) output = [] for operation in operations: t = operation[0] if t == 1: i, x = operation[1], operation[2] student_scores.update(i, x) elif t == 2: l, r = operation[1], operation[2] output.append(student_scores.query(l, r)) return output # Example usage: n = 5 q = 5 scores = [1, 2, 3, 4, 5] operations = [ [2, 1, 3], [1, 3, 6], [2, 2, 4], [1, 5, 1], [2, 3, 5] ] results = process_operations(n, q, scores, operations) for result in results: print(result)"},{"question":"def two_sum_exists(nums, target): Determine if there exist two distinct indices i and j in the array such that nums[i] + nums[j] is equal to the target. >>> two_sum_exists([2, 7, 11, 15, 3], 9) == \\"YES\\" >>> two_sum_exists([1, 2, 3, 4], 8) == \\"NO\\" >>> two_sum_exists([-1, -2, -3], -5) == \\"YES\\" >>> two_sum_exists(list(range(1, 100001)), 200000) == \\"NO\\" >>> two_sum_exists([1, 1, 1, 1, 1], 2) == \\"YES\\" >>> two_sum_exists([-10, -20, -30], -50) == \\"YES\\" >>> two_sum_exists([0, 4, -4], 0) == \\"YES\\" >>> two_sum_exists([5, 3, 10, 2], 20) == \\"NO\\"","solution":"def two_sum_exists(nums, target): Determine if there exist two distinct indices i and j in the array such that nums[i] + nums[j] is equal to the target. seen = set() for num in nums: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) nums = list(map(int, data[1:n+1])) target = int(data[n+1]) print(two_sum_exists(nums, target))"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"anana\\") == \\"anana\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"z\\") == \\"z\\" >>> longest_palindromic_substring(\\"abcdedcba\\") in [\\"abcdedcba\\", \\"ded\\"] >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" >>> longest_palindromic_substring(\\"\\") == \\"\\" >>> longest_palindromic_substring(\\"ac\\") == \\"a\\" or \\"c\\" >>> longest_palindromic_substring(\\"aa\\") == \\"aa\\" >>> longest_palindromic_substring(\\"ab\\") == \\"a\\" or \\"b\\" # Your code here","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" # Initialize start and end indexes of the longest palindromic substring start = 0 max_length = 1 # Function to expand around the center and update start and max_length def expand_around_center(left, right): nonlocal start, max_length while left >= 0 and right < n and s[left] == s[right]: current_length = right - left + 1 if current_length > max_length: start = left max_length = current_length left -= 1 right += 1 # Iterate over each character and find the longest palindrome by expanding around the center for i in range(n): # Odd length palindromes (single character center) expand_around_center(i, i) # Even length palindromes (two character center) expand_around_center(i, i + 1) return s[start:start + max_length]"},{"question":"def count_paths(n: int, m: int, grid: List[List[str]]) -> int: Determine if it's possible to reach the bottom-right cell from the top-left cell, and if so, find the number of different paths you can take modulo 10^9+7. Constraints: 1 <= n, m <= 1000 >>> count_paths(3, 4, [['.', '.', '.', '#'], ['.', '#', '.', '.'], ['.', '.', '.', '.']]) 3 >>> count_paths(2, 2, [['.', '#'], ['#', '.']]) 0 >>> count_paths(1, 1, [['.']]) 1 >>> count_paths(1, 1, [['#']]) 0 >>> count_paths(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 6 >>> count_paths(3, 3, [['.', '.', '#'], ['#', '#', '#'], ['#', '#', '.']]) 0 >>> count_paths(4, 4, [['.']*4 for _ in range(4)]) 20 >>> count_paths(4, 4, [['.', '.', '.', '#'], ['.', '#', '.', '.'], ['#', '.', '.', '.'], ['.', '.', '#', '.']]) 2","solution":"MOD = 10**9 + 7 def count_paths(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1] # Example usage: # n, m = 3, 4 # grid = [ # ['.', '.', '.', '#'], # ['.', '#', '.', '.'], # ['.', '.', '.', '.'] # ] # print(count_paths(n, m, grid)) # output should be 3"},{"question":"from itertools import combinations def smallest_zero_sum_subset(n: int, nums: List[int]) -> int: Determine if there exists a subset of given integers that sums to zero. Returns the size of the smallest subset that sums to zero, or -1 if no such subset exists. >>> smallest_zero_sum_subset(5, [3, 1, -4, 2, -2]) 2 >>> smallest_zero_sum_subset(4, [1, 2, 5, 6]) -1 >>> smallest_zero_sum_subset(1, [0]) 1 >>> smallest_zero_sum_subset(2, [-1, 1]) 2","solution":"from itertools import combinations def smallest_zero_sum_subset(n, nums): Returns the size of the smallest subset of nums that sums to zero. If no such subset exists, returns -1. for size in range(1, n + 1): for subset in combinations(nums, size): if sum(subset) == 0: return size return -1 # Example usage: # n = 5 # nums = [3, 1, -4, 2, -2] # result = smallest_zero_sum_subset(n, nums) # print(result) # Output should be 2"},{"question":"def shopping_list(commands): Simulates a shopping list based on the given commands. Parameters: commands (list of str): A list of commands to process the shopping list. Returns: list of str: A list of strings representing the output of each PRINT command. >>> shopping_list([\\"ADD milk\\", \\"ADD bread\\", \\"PRINT\\"]) [\\"breadnmilk\\"] >>> shopping_list([\\"ADD milk\\", \\"ADD bread\\", \\"REMOVE milk\\", \\"PRINT\\"]) [\\"bread\\"] >>> shopping_list([\\"ADD milk\\", \\"REMOVE bread\\", \\"PRINT\\"]) [\\"milk\\"] >>> shopping_list([\\"PRINT\\"]) [\\"EMPTY\\"] >>> shopping_list([\\"ADD milk\\", \\"ADD bread\\", \\"REMOVE bread\\", \\"REMOVE milk\\", \\"PRINT\\"]) [\\"EMPTY\\"] >>> shopping_list([ \\"ADD milk\\", \\"ADD bread\\", \\"ADD butter\\", \\"PRINT\\", \\"REMOVE butter\\", \\"REMOVE fruit\\", \\"PRINT\\", \\"REMOVE bread\\", \\"PRINT\\", \\"REMOVE milk\\", \\"PRINT\\" ]) [\\"breadnbutternmilk\\", \\"breadnmilk\\", \\"milk\\", \\"EMPTY\\"]","solution":"def shopping_list(commands): Simulates a shopping list based on the given commands. Parameters: commands (list of str): A list of commands to process the shopping list. Returns: list of str: A list of strings representing the output of each PRINT command. shopping_set = set() result = [] for command in commands: if command.startswith(\\"ADD \\"): item = command[4:] shopping_set.add(item) elif command.startswith(\\"REMOVE \\"): item = command[7:] shopping_set.discard(item) elif command == \\"PRINT\\": if shopping_set: sorted_list = sorted(shopping_set) result.append(\\"n\\".join(sorted_list)) else: result.append(\\"EMPTY\\") return result"},{"question":"def can_rearrange(S: str, K: int) -> str: Determine whether it is possible to rearrange the characters of the string such that no two adjacent characters are the same and the difference between the positions of any two identical characters in the rearranged string is at least \`K\`. >>> can_rearrange(\\"aabbcc\\", 2) 'Possible' >>> can_rearrange(\\"aa\\", 2) 'Impossible' >>> can_rearrange(\\"abcabc\\", 3) 'Possible' def solve(test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases where each test case contains a string \`S\` and an integer \`K\`, and return a list of results indicating whether it is possible to rearrange the string according to the specified conditions or not. >>> test_cases = [(\\"aabbcc\\", 2), (\\"aa\\", 2), (\\"abcabc\\", 3)] >>> solve(test_cases) ['Possible', 'Impossible', 'Possible'] from solution import solve def test_example_cases(): test_cases = [(\\"aabbcc\\", 2), (\\"aa\\", 2), (\\"abcabc\\", 3)] results = solve(test_cases) assert results == [\\"Possible\\", \\"Impossible\\", \\"Possible\\"] def test_all_unique_chars(): test_cases = [(\\"abcdef\\", 2)] results = solve(test_cases) assert results == [\\"Possible\\"] def test_single_char(): test_cases = [(\\"a\\", 1)] results = solve(test_cases) assert results == [\\"Possible\\"] def test_repetition_with_high_k(): test_cases = [(\\"aaa\\", 3)] results = solve(test_cases) assert results == [\\"Impossible\\"] def test_no_rearrangement_needed(): test_cases = [(\\"aba\\", 1)] results = solve(test_cases) assert results == [\\"Possible\\"] def test_impossible_case(): test_cases = [(\\"aabb\\", 3)] results = solve(test_cases) assert results == [\\"Impossible\\"] def test_large_test_case(): test_cases = [(\\"a\\" * 100, 2)] results = solve(test_cases) assert results == [\\"Impossible\\"]","solution":"from collections import Counter import heapq def can_rearrange(S, K): if K == 1: return \\"Possible\\" freq = Counter(S) max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) wait_list = [] result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_list.append((char, count + 1)) if len(wait_list) < K: continue front_char, front_count = wait_list.pop(0) if front_count < 0: heapq.heappush(max_heap, (front_count, front_char)) return \\"Possible\\" if len(result) == len(S) else \\"Impossible\\" def solve(test_cases): results = [] for S, K in test_cases: results.append(can_rearrange(S, K)) return results"},{"question":"def subarray_parity_queries(n, q, arr, queries): Determines if the sum of elements in the subarray given by each query is odd or even. Parameters: n (int): Number of elements in the array. q (int): Number of queries. arr (list): List of integers representing the array. queries (list): List of tuples, each containing two integers l and r representing the subarray indices (1-based). Returns: list: List of strings 'Odd' or 'Even' for each query result.","solution":"def subarray_parity_queries(n, q, arr, queries): Determines if the sum of elements in the subarray given by each query is odd or even. Parameters: n (int): Number of elements in the array. q (int): Number of queries. arr (list): List of integers representing the array. queries (list): List of tuples, each containing two integers l and r representing the subarray indices (1-based). Returns: list: List of strings 'Odd' or 'Even' for each query result. results = [] prefix_sum = [0] * (n + 1) # Building the prefix sum array for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Processing each query for l, r in queries: subarray_sum = prefix_sum[r] - prefix_sum[l - 1] if subarray_sum % 2 == 0: results.append(\\"Even\\") else: results.append(\\"Odd\\") return results"},{"question":"def min_pallets(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determines the minimum number of pallets required to store all items without exceeding the weight limit. :param t: int, number of test cases :param test_cases: list of tuples, each containing two elements: - a tuple of two integers (n, m) where n is the number of items and m is the max weight limit of each pallet, - a list of integers, representing the weights of the items. :return: List of integers, each representing the minimum number of pallets required for the respective test cases. pass # Example test cases def test_min_pallets(): assert min_pallets(1, [((3, 10), [5, 5, 5])]) == [2] def test_multiple_test_cases(): assert min_pallets(3, [((3, 10), [5, 5, 5]), ((4, 10), [6, 5, 3, 2]), ((5, 15), [5, 5, 5, 7, 8])]) == [2, 2, 2] def test_edge_case_all_items_fitting_in_one_pallet(): assert min_pallets(1, [((3, 15), [5, 5, 5])]) == [1] def test_edge_case_each_item_requires_separate_pallet(): assert min_pallets(1, [((3, 1), [1, 1, 1])]) == [3] def test_large_number_of_items(): weights = [1] * 100 assert min_pallets(1, [((100, 10), weights)]) == [10]","solution":"def min_pallets(t, test_cases): Determines the minimum number of pallets required to store all items without exceeding the weight limit. :param t: int, number of test cases :param test_cases: list of tuples, each containing two elements: - a tuple of two integers (n, m) where n is the number of items and m is the max weight limit of each pallet, - a list of integers, representing the weights of the items. :return: List of integers, each representing the minimum number of pallets required for the respective test cases. results = [] for case in test_cases: (n, m), weights = case weights.sort(reverse=True) pallets = 0 current_weight = 0 for weight in weights: if current_weight + weight > m: pallets += 1 current_weight = weight else: current_weight += weight if current_weight > 0: pallets += 1 results.append(pallets) return results"},{"question":"def longest_subarray(arr: List[int]) -> int: Given an array of integers, find the length of the longest subarray where the absolute difference between any two elements is at most 1. >>> longest_subarray([1, 1, 2, 2, 4, 4, 5, 5, 5]) 5 >>> longest_subarray([4, 6, 5, 3, 3, 1]) 3 >>> longest_subarray([1]) 1 >>> longest_subarray([7, 7, 7, 7, 7, 7]) 6 >>> longest_subarray([1, 3, 5, 7, 9]) 1 >>> longest_subarray([1, 2, 1, 2, 1, 2]) 6 >>> longest_subarray([-1, -2, -1, -2, -1, -2, -3, -3]) 6 >>> longest_subarray([1, -1, 2, -2, 3, -3]) 2 >>> longest_subarray([]) 0 >>> longest_subarray(list(range(10000))) 2","solution":"from collections import defaultdict def longest_subarray(arr): Returns the length of the longest subarray where the absolute difference between any two elements is at most 1. if not arr: return 0 frequency = defaultdict(int) max_length = 0 for num in arr: frequency[num] += 1 for key in frequency: current_length = frequency[key] + frequency.get(key - 1, 0) max_length = max(max_length, current_length) return max_length"},{"question":"def sort_products(products): Sorts the list of products based on the urgency score in descending order. If two products have the same urgency score, they are sorted by their identifier in ascending order. Args: products (list of tuples): List where each element is a tuple containing the product's identifier and urgency score. Returns: list of tuples: Sorted list of products. >>> sort_products([(101, 5), (305, 3), (205, 5), (402, 2), (104, 5)]) [(101, 5), (104, 5), (205, 5), (305, 3), (402, 2)] >>> sort_products([(101, 5), (101, 5), (205, 5), (402, 2), (104, 5)]) [(101, 5), (101, 5), (104, 5), (205, 5), (402, 2)] >>> sort_products([(101, 5)]) [(101, 5)] >>> sort_products([(305, 5), (205, 4), (201, 3), (104, 2), (101, 1)]) [(305, 5), (205, 4), (201, 3), (104, 2), (101, 1)] >>> sort_products([(105, 4), (305, 6), (205, 6), (104, 4), (106, 4)]) [(205, 6), (305, 6), (104, 4), (105, 4), (106, 4)] # Sort by urgency score descending, and by identifier ascending","solution":"def sort_products(products): Sorts the list of products based on the urgency score in descending order. If two products have the same urgency score, they are sorted by their identifier in ascending order. Args: products (list of tuples): List where each element is a tuple containing the product's identifier and urgency score. Returns: list of tuples: Sorted list of products. # Sort by urgency score descending, and by identifier ascending return sorted(products, key=lambda x: (-x[1], x[0]))"},{"question":"import re from typing import List def normalize_number(number: str) -> str: Normalize the mobile number by removing any non-numeric characters. >>> normalize_number(\\"123-456-7890\\") '1234567890' >>> normalize_number(\\"(123) 456 7890\\") '1234567890' pass def count_unique_numbers(numbers: List[str]) -> int: Count the number of unique normalized mobile numbers. >>> count_unique_numbers([\\"123-456-7890\\", \\"123 456 7890\\", \\"1234567890\\", \\"(123) 456-7890\\", \\"9876543210\\"]) 2 >>> count_unique_numbers([\\"987-654-3210\\", \\"(987)654 3210\\", \\"8765432100\\"]) 2 pass","solution":"import re def normalize_number(number): Normalize the mobile number by removing any non-numeric characters. return re.sub(r'D', '', number) def count_unique_numbers(numbers): Count the number of unique normalized mobile numbers. normalized_numbers = set(normalize_number(number) for number in numbers) return len(normalized_numbers)"},{"question":"def can_rearrange_frequencies(message: str) -> str: Analyze a given message to verify if it is possible to rearrange the characters so that the highest frequency and the lowest frequency are the same. >>> can_rearrange_frequencies(\\"aabbcc\\") 'YES' >>> can_rearrange_frequencies(\\"aaabbc\\") 'NO'","solution":"def can_rearrange_frequencies(message): from collections import Counter # Count the frequency of each character freq = Counter(message) # Get the list of frequencies freq_values = list(freq.values()) freq_count = Counter(freq_values) # There can be only one frequency or if they are different, only one can have one occurrence if len(freq_count) == 1: return \\"YES\\" elif len(freq_count) == 2: # Get the two frequencies key1, key2 = freq_count.keys() # Check the condition: one frequency should appear only once and be either 1 or its difference with the other key should be 1 if (freq_count[key1] == 1 and (key1 == 1 or (key1 - key2 == 1))) or (freq_count[key2] == 1 and (key2 == 1 or (key2 - key1 == 1))): return \\"YES\\" return \\"NO\\""},{"question":"def is_palindrome(s: str) -> str: Returns \\"YES\\" if the string s is a palindrome, otherwise \\"NO\\". >>> is_palindrome(\\"12321\\") == \\"YES\\" >>> is_palindrome(\\"404\\") == \\"YES\\" >>> is_palindrome(\\"123456\\") == \\"NO\\" def check_palindromes(t: int, test_cases: List[str]) -> List[str]: Given the number of test cases t and a list of numerical strings test_cases, returns a list of results where each result is \\"YES\\" if the string is a palindrome and \\"NO\\" otherwise. >>> check_palindromes(3, [\\"12321\\", \\"404\\", \\"123456\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_palindromes(2, [\\"1\\", \\"22\\"]) == [\\"YES\\", \\"YES\\"]","solution":"def is_palindrome(s): Returns \\"YES\\" if the string s is a palindrome, otherwise \\"NO\\". if s == s[::-1]: return \\"YES\\" else: return \\"NO\\" def check_palindromes(t, test_cases): Given the number of test cases t and a list of numerical strings test_cases, returns a list of results where each result is \\"YES\\" if the string is a palindrome and \\"NO\\" otherwise. results = [] for s in test_cases: results.append(is_palindrome(s)) return results"},{"question":"def calculateGrades(students): Calculate the average score and grade for each student based on their scores in Math, Science, and English. Parameters: students (list of dict): A list of dictionaries where each dictionary contains a student's name and their scores in Math, Science, and English. Returns: list of dict: A list of dictionaries with each student's name, average score, and grade. Example: >>> students = [ ... {\\"name\\": \\"John\\", \\"Math\\": 85, \\"Science\\": 90, \\"English\\": 88}, ... {\\"name\\": \\"Jane\\", \\"Math\\": 79, \\"Science\\": 72, \\"English\\": 70} ... ] >>> calculateGrades(students) [ {\\"name\\": \\"John\\", \\"average_score\\": 87.67, \\"grade\\": \\"B\\"}, {\\"name\\": \\"Jane\\", \\"average_score\\": 73.67, \\"grade\\": \\"C\\"} ]","solution":"def calculateGrades(students): def compute_grade(average_score): if 90 <= average_score <= 100: return 'A' elif 80 <= average_score < 90: return 'B' elif 70 <= average_score < 80: return 'C' elif 60 <= average_score < 70: return 'D' else: return 'F' result = [] for student in students: average_score = round((student[\\"Math\\"] + student[\\"Science\\"] + student[\\"English\\"]) / 3, 2) grade = compute_grade(average_score) result.append({\\"name\\": student[\\"name\\"], \\"average_score\\": average_score, \\"grade\\": grade}) return result"},{"question":"def merge_rows(n: int, a: List[int]) -> Tuple[int, int]: Calculates the minimum number of operations required to merge all rows into a single row, and the sum of the final single row after all merges. Parameters: n (int): The number of rows in the grid. a (list of int): The values of the rows. Returns: tuple: A pair (number of operations, final single row value). >>> merge_rows(4, [4, 3, 2, 6]) (3, 15) >>> merge_rows(1, [10]) (0, 10) >>> merge_rows(2, [1, 2]) (1, 3) >>> merge_rows(5, [1, 2, 3, 4, 5]) (4, 15) >>> merge_rows(3, [1000000000, 1000000000, 1000000000]) (2, 3000000000) >>> merge_rows(4, [5, 5, 5, 5]) (3, 20) pass","solution":"def merge_rows(n, a): Calculates the minimum number of operations required to merge all rows into a single row, and the sum of the final single row after all merges. Parameters: n (int): The number of rows in the grid. a (list of int): The values of the rows. Returns: tuple: A pair (number of operations, final single row value). # The minimum number of operations is always n-1 for n rows. min_operations = n - 1 # The sum of the final single row is the sum of all elements in the input array. final_row_value = sum(a) return min_operations, final_row_value"},{"question":"def max_product(arr): Determine the maximum product that can be obtained from either: 1. Three of its elements. 2. Two of its elements and the integer 1. >>> max_product([1, 10, 2, 6, -1]) 120 >>> max_product([-10, -10, 5, 2]) 500 >>> max_product([1, 2, 3, 4]) 24 >>> max_product([-10, -2, -3, -4]) -24 >>> max_product([1000, 999, -1000, -999, 0]) 999000000 >>> max_product([-1, -2, -3, -4, -5]) -6","solution":"def max_product(arr): Determine the maximum product that can be obtained from either: 1. Three of its elements. 2. Two of its elements and the integer 1. arr.sort() # Consider the maximum from either top 3 numbers or minimum 2 (negative) and highest positive return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"def getMaxConsecutiveOnes(nums: List[int]) -> int: Returns the maximum number of consecutive 1s in the list nums. >>> getMaxConsecutiveOnes([1, 1, 0, 1, 1, 1]) 3 >>> getMaxConsecutiveOnes([1, 0, 1, 1, 0, 1]) 2 Test cases: def test_simple_case(): assert getMaxConsecutiveOnes([1, 1, 0, 1, 1, 1]) == 3 def test_no_consecutive_ones(): assert getMaxConsecutiveOnes([0, 0, 0, 0, 0]) == 0 def test_all_ones(): assert getMaxConsecutiveOnes([1, 1, 1, 1, 1]) == 5 def test_mixed_case(): assert getMaxConsecutiveOnes([1, 0, 1, 1, 0, 1]) == 2 def test_trailing_ones(): assert getMaxConsecutiveOnes([0, 0, 0, 1, 1, 1]) == 3 def test_single_one(): assert getMaxConsecutiveOnes([0, 0, 1, 0, 0]) == 1 def test_consecutive_ones_at_start(): assert getMaxConsecutiveOnes([1, 1, 1, 0, 0, 0]) == 3 def test_single_element(): assert getMaxConsecutiveOnes([1]) == 1 assert getMaxConsecutiveOnes([0]) == 0 def test_empty_list(): assert getMaxConsecutiveOnes([]) == 0","solution":"def getMaxConsecutiveOnes(nums): Returns the maximum number of consecutive 1s in the list nums. max_count = 0 count = 0 for num in nums: if num == 1: count += 1 else: max_count = max(max_count, count) count = 0 # Check once more in case the longest sequence is at the end of the list max_count = max(max_count, count) return max_count"},{"question":"from typing import List, Tuple def min_operations_to_make_equal(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Amelias's challenge is to make all the array elements equal using the minimum number of operations. In one operation, select any two different elements of the array, and replace both of them with their sum. Args: test_cases : List of tuples where each tuple contains: - an integer \`n\`: the length of the array - a list of \`n\` integers representing the array Returns: List of integers where each integer is the minimum number of operations required to make all elements of the array equal. >>> test_cases = [(3, [2, 4, 6]), (4, [1, 1, 1, 1]), (5, [1, 2, 3, 4, 5])] >>> min_operations_to_make_equal(test_cases) [2, 0, 4] # Your code here def parse_input(input_str: str) -> List[Tuple[int, List[int]]]: Parse the input string and return test cases. Args: input_str : A single string of input separated by spaces and newlines Returns: List of tuples where each tuple represents a single test case. # Your code here def test_min_operations_to_make_equal(): input_data = \\"3n3n2 4 6n4n1 1 1 1n5n1 2 3 4 5n\\" test_cases = parse_input(input_data) result = min_operations_to_make_equal(test_cases) assert result == [2, 0, 4] def test_min_operations_all_elements_equal(): input_data = \\"2n3n7 7 7n4n9 9 9 9n\\" test_cases = parse_input(input_data) result = min_operations_to_make_equal(test_cases) assert result == [0, 0] def test_min_operations_two_elements(): input_data = \\"2n2n2 3n2n10 10n\\" test_cases = parse_input(input_data) result = min_operations_to_make_equal(test_cases) assert result == [1, 0] if __name__ == \\"__main__\\": test_min_operations_to_make_equal() test_min_operations_all_elements_equal() test_min_operations_two_elements() print(\\"All tests passed!\\")","solution":"def min_operations_to_make_equal(test_cases): results = [] for case in test_cases: n, arr = case unique_elements = len(set(arr)) operations_needed = unique_elements - 1 results.append(operations_needed) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return test_cases"},{"question":"class Matrix: def __init__(self, a, b, c, d): Initialize the 2x2 matrix with elements a, b, c, and d. pass def determinant(self): Calculate and return the determinant of the matrix. Det = (a*d) - (b*c) pass def multiply(self, other): Multiply this matrix by another 2x2 matrix and return the result as a new Matrix. pass","solution":"class Matrix: def __init__(self, a, b, c, d): Initialize the 2x2 matrix with elements a, b, c, and d. self.a = a self.b = b self.c = c self.d = d def determinant(self): Calculate and return the determinant of the matrix. Det = (a*d) - (b*c) return (self.a * self.d) - (self.b * self.c) def multiply(self, other): Multiply this matrix by another 2x2 matrix and return the result as a new Matrix. a1, b1, c1, d1 = self.a, self.b, self.c, self.d a2, b2, c2, d2 = other.a, other.b, other.c, other.d new_a = a1 * a2 + b1 * c2 new_b = a1 * b2 + b1 * d2 new_c = c1 * a2 + d1 * c2 new_d = c1 * b2 + d1 * d2 return Matrix(new_a, new_b, new_c, new_d)"},{"question":"from itertools import permutations from typing import List, Tuple def permute_books(book_list: List[str]) -> List[Tuple[str]]: Returns all unique permutations of the books in lexicographical order. >>> permute_books([\\"red\\", \\"blue\\", \\"green\\"]) [('blue', 'green', 'red'), ('blue', 'red', 'green'), ('green', 'blue', 'red'), ('green', 'red', 'blue'), ('red', 'blue', 'green'), ('red', 'green', 'blue')] >>> permute_books([\\"mystery\\", \\"fantasy\\", \\"thriller\\"]) [('fantasy', 'mystery', 'thriller'), ('fantasy', 'thriller', 'mystery'), ('mystery', 'fantasy', 'thriller'), ('mystery', 'thriller', 'fantasy'), ('thriller', 'fantasy', 'mystery'), ('thriller', 'mystery', 'fantasy')] def print_permutations(book_str: str) -> None: Print all unique permutations of the input books in lexicographical order. >>> print_permutations(\\"red blue green\\") blue green red blue red green green blue red green red blue red blue green red green blue >>> print_permutations(\\"mystery fantasy thriller\\") fantasy mystery thriller fantasy thriller mystery mystery fantasy thriller mystery thriller fantasy thriller fantasy mystery thriller mystery fantasy","solution":"from itertools import permutations def permute_books(book_list): Returns all unique permutations of the books in lexicographical order. book_list = sorted(book_list) # Ensure the input list is sorted lexicographically perm = permutations(book_list) unique_permutations = list(dict.fromkeys(perm)) # Remove duplicate permutations return unique_permutations def print_permutations(book_str): Print all unique permutations of the input books in lexicographical order. book_list = book_str.split() permutations_list = permute_books(book_list) for perm in permutations_list: print(' '.join(perm))"},{"question":"def most_frequent_char(s: str) -> str: Determines the character that appears most frequently in a string. If multiple characters have the same highest frequency, returns the lexicographically smallest one. Parameters: s (str): A string of lowercase letters Returns: char: The most frequent character >>> most_frequent_char(\\"aabbbccde\\") 'b' >>> most_frequent_char(\\"abcabcabcd\\") 'a' >>> most_frequent_char(\\"zzzxyzz\\") 'z'","solution":"def most_frequent_char(s): Determines the character that appears most frequently in a string. If multiple characters have the same highest frequency, returns the lexicographically smallest one. Parameters: s (str): A string of lowercase letters Returns: char: The most frequent character from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Find the maximum frequency max_count = max(count.values()) # Find all characters with the maximum frequency candidates = [char for char, freq in count.items() if freq == max_count] # Return the lexicographically smallest character among the candidates return min(candidates)"},{"question":"def max_sum_piles(num_decks: int, decks: List[List[Tuple[str, int]]]) -> List[int]: Determine the maximum possible sum of values by dividing the cards into two piles while satisfying the rule. >>> max_sum_piles(2, [ ... [('H', 3), ('D', 5), ('C', 4), ('S', 2), ('H', 7)], ... [('D', 1), ('C', 3), ('S', 8), ('C', 5)] ... ]) [21, 17] >>> max_sum_piles(1, [[('H', 1)]]) [1] >>> max_sum_piles(1, [[('H', 5), ('D', 6), ('C', 7), ('S', 8)]]) [26] pass def parse_input(input_string: str) -> Tuple[int, List[List[Tuple[str, int]]]]: Parse the input string to return the number of decks and the list of decks. >>> parse_input(\\"2n5nH 3nD 5nC 4nS 2nH 7n4nD 1nC 3nS 8nC 5n\\") (2, [[('H', 3), ('D', 5), ('C', 4), ('S', 2), ('H', 7)], [('D', 1), ('C', 3), ('S', 8), ('C', 5)]]) >>> parse_input(\\"1n1nH 1n\\") (1, [[('H', 1)]]) >>> parse_input(\\"1n4nH 5nD 6nC 7nS 8n\\") (1, [[('H', 5), ('D', 6), ('C', 7), ('S', 8)]]) pass","solution":"def max_sum_piles(num_decks, decks): def calculate_max_sum(decks): suits = ['H', 'D', 'C', 'S'] results = [] for deck in decks: cards = {'H': [], 'D': [], 'C': [], 'S': []} for suit, value in deck: cards[suit].append(value) max_sum = 0 for i in range(1 << 4): pile1_sum = pile2_sum = 0 suits_in_pile1 = {suits[j] for j in range(4) if i & (1 << j)} suits_in_pile2 = set(suits) - suits_in_pile1 for suit in suits_in_pile1: pile1_sum += sum(cards[suit]) for suit in suits_in_pile2: pile2_sum += sum(cards[suit]) max_sum = max(max_sum, pile1_sum + pile2_sum) results.append(max_sum) return results return calculate_max_sum(decks) def parse_input(input_string): lines = input_string.strip().split('n') num_decks = int(lines[0]) decks = [] index = 1 for _ in range(num_decks): k = int(lines[index]) deck = [] for j in range(k): suit, value = lines[index + j + 1].split() deck.append((suit, int(value))) decks.append(deck) index += k + 1 return num_decks, decks if __name__ == \\"__main__\\": import sys input_string = sys.stdin.read() num_decks, decks = parse_input(input_string) results = max_sum_piles(num_decks, decks) for result in results: print(result)"},{"question":"def max_subarray_sum_and_length(arr): Finds the maximum sum of a contiguous subarray and its length. Parameters: arr (List[int]): The array of integers. Returns: Tuple[int, int]: The maximum sum and the length of the subarray. >>> max_subarray_sum_and_length([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 4) >>> max_subarray_sum_and_length([1]) (1, 1) >>> max_subarray_sum_and_length([-1]) (-1, 1) >>> max_subarray_sum_and_length([1, 2, 3, 4, 5]) (15, 5) >>> max_subarray_sum_and_length([-1, -2, -3, -4, -5]) (-1, 1) >>> max_subarray_sum_and_length([1, -2, 3, 10, -4, 7, 2, -5]) (18, 5) >>> max_subarray_sum_and_length([-1, 2, -1, 2, -1]) (3, 3)","solution":"def max_subarray_sum_and_length(arr): Finds the maximum sum of a contiguous subarray and its length. Parameters: arr (List[int]): The array of integers. Returns: Tuple[int, int]: The maximum sum and the length of the subarray. max_sum = float('-inf') current_sum = 0 current_length = 0 max_length = 0 for number in arr: if current_sum + number > number: current_sum += number current_length += 1 else: current_sum = number current_length = 1 if current_sum > max_sum: max_sum = current_sum max_length = current_length elif current_sum == max_sum: max_length = max(max_length, current_length) return (max_sum, max_length)"},{"question":"def find_three_numbers_sum(arr, target): This function finds whether there exist three numbers in the array that sum up to the target value. Args: arr (List[int]): The list of integers to check. target (int): The target value to find from the sum of three integers from the list. Returns: str: \\"YES\\" if there exist three numbers that sum up to the target, otherwise \\"NO\\". Examples: >>> find_three_numbers_sum([12, 3, 4, 1, 6, 9], 24) \\"YES\\" >>> find_three_numbers_sum([1, 2, 3, 4, 5], 50) \\"NO\\"","solution":"def find_three_numbers_sum(arr, target): This function finds whether there exist three numbers in the array that sum up to the target value. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return \\"YES\\" elif current_sum < target: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def firstUnique(nums: List[int]) -> int: Returns the first unique integer in the list nums. If there is no unique integer, returns -1. >>> firstUnique([4, 5, 6, 7, 5, 6, 4]) == 7 >>> firstUnique([1, 2, 2, 1, 3, 4, 4, 5]) == 3 >>> firstUnique([6, 4, 4, 6]) == -1 >>> firstUnique([8, 7, 8, 7, 3, 5, 5]) == 3 >>> firstUnique([2, 2, 2, 2]) == -1 >>> firstUnique([10]) == 10 >>> firstUnique([]) == -1 >>> firstUnique([-1, -2, -2, -1, -3, -4, -4]) == -3","solution":"def firstUnique(nums): Returns the first unique integer in the list nums. If there is no unique integer, returns -1. count = {} for num in nums: if num in count: count[num] += 1 else: count[num] = 1 for num in nums: if count[num] == 1: return num return -1"},{"question":"def find_min_edges_for_resilience(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of edges required to ensure that every node in the network can still communicate with every other node, even if any one node fails. >>> find_min_edges_for_resilience(4, 2, [(1, 2), (3, 4)]) 3 >>> find_min_edges_for_resilience(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 from typing import List, Tuple import unittest class TestFindMinEdgesForResilience(unittest.TestCase): def test_single_component(self): n = 4 m = 2 edges = [(1, 2), (3, 4)] self.assertEqual(find_min_edges_for_resilience(n, m, edges), 1) def test_multiple_components(self): n = 5 m = 3 edges = [(1, 2), (2, 3), (4, 5)] self.assertEqual(find_min_edges_for_resilience(n, m, edges), 1) def test_already_resilient(self): n = 6 m = 7 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (2, 5)] self.assertEqual(find_min_edges_for_resilience(n, m, edges), 0) def test_single_edge(self): n = 2 m = 1 edges = [(1, 2)] self.assertEqual(find_min_edges_for_resilience(n, m, edges), 0) def test_disconnected(self): n = 3 m = 0 edges = [] self.assertEqual(find_min_edges_for_resilience(n, m, edges), 2) if __name__ == \\"__main__\\": unittest.main()","solution":"def find_min_edges_for_resilience(n, m, edges): from collections import defaultdict, deque def bfs(start, graph, visited): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Initialize graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Check connected components visited = set() components = 0 for node in range(1, n + 1): if node not in visited: components += 1 bfs(node, graph, visited) # To make the graph 2-vertex-connected, when we have multiple components, # we need at least (components - 1) edges to connect them. return max(0, components - 1) # Example usage (uncomment to test) # n = 4 # m = 2 # edges = [(1, 2), (3, 4)] # print(find_min_edges_for_resilience(n, m, edges)) # Output: 3 # n = 5 # m = 3 # edges = [(1, 2), (2, 3), (4, 5)] # print(find_min_edges_for_resilience(n, m, edges)) # Output: 2"},{"question":"def find_starting_bench(N: int, K: int) -> int: Returns the starting bench number that maximizes the sum of K consecutive benches. >>> find_starting_bench(8, 3) 6 >>> find_starting_bench(12, 5) 8 >>> find_starting_bench(5, 1) 5 >>> find_starting_bench(10, 1) 10 >>> find_starting_bench(5, 5) 1 >>> find_starting_bench(7, 7) 1 >>> find_starting_bench(10, 4) 7","solution":"def find_starting_bench(N, K): Returns the starting bench number that maximizes the sum of K consecutive benches. max_sum = 0 start_bench = 1 for i in range(1, N + 1): current_sum = sum(range(i, i + K)) if i + K - 1 <= N else sum(range(i, N + 1)) + sum(range(1, i + K - N)) if current_sum > max_sum: max_sum = current_sum start_bench = i return start_bench"},{"question":"def check_consistency(ops): Determine if operations are consistent. >>> check_consistency([\\"+1\\", \\"+2\\", \\"-1\\"]) \\"CONSISTENT\\" >>> check_consistency([\\"+1\\", \\"-1\\", \\"+1\\", \\"-1\\"]) \\"CONSISTENT\\" >>> check_consistency([\\"-1\\", \\"+1\\", \\"-1\\"]) \\"INCONSISTENT\\"","solution":"def check_consistency(ops): Determine if operations are consistent. :param ops: list of strings, operations of entering or leaving a section. :return: str, \\"CONSISTENT\\" or \\"INCONSISTENT\\" sections = set() for op in ops: if op[0] == '+': section = op[1:] if section in sections: return \\"INCONSISTENT\\" sections.add(section) elif op[0] == '-': section = op[1:] if section not in sections: return \\"INCONSISTENT\\" sections.remove(section) return \\"CONSISTENT\\""},{"question":"from typing import List def length_of_longest_subarray_with_distinct_elements(N: int, A: List[int]) -> int: Given an array A consisting of N integers, this function finds the length of the longest contiguous subarray where all elements are distinct. Args: N (int): The length of the array. A (list): List of integers representing the elements of the array. Returns: int: The length of the longest contiguous subarray with all distinct elements. >>> length_of_longest_subarray_with_distinct_elements(5, [1, 2, 3, 4, 5]) 5 >>> length_of_longest_subarray_with_distinct_elements(7, [1, 2, 2, 3, 4, 4, 5]) 3 >>> length_of_longest_subarray_with_distinct_elements(4, [1, 1, 1, 1]) 1 >>> length_of_longest_subarray_with_distinct_elements(1, [10]) 1 >>> length_of_longest_subarray_with_distinct_elements(3, [7, 7, 7]) 1 >>> length_of_longest_subarray_with_distinct_elements(2, [1, 2]) 2 >>> length_of_longest_subarray_with_distinct_elements(6, [1, 2, 1, 2, 3, 3]) 3 >>> length_of_longest_subarray_with_distinct_elements(100000, list(range(1, 100001))) 100000 pass","solution":"def length_of_longest_subarray_with_distinct_elements(N, A): Given an array A consisting of N integers, this function finds the length of the longest contiguous subarray where all elements are distinct. Args: N (int): The length of the array. A (list): List of integers representing the elements of the array. Returns: int: The length of the longest contiguous subarray with all distinct elements. # Dictionary to store the last positions of elements last_seen = {} max_length = 0 start = 0 for end in range(N): if A[end] in last_seen and last_seen[A[end]] >= start: start = last_seen[A[end]] + 1 last_seen[A[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def format_output(n: int, arr: List[int]) -> str: Given the size of the array and the array itself, determine if it is possible to rearrange the array into a palindrome. If possible, return \\"YES\\" followed by the rearranged array. If not possible, return \\"NO\\". >>> format_output(5, [1, 2, 3, 2, 1]) 'YESn1 2 3 2 1' >>> format_output(4, [1, 2, 3, 4]) 'NO' :param n: Integer, the number of elements in the array. :param arr: List of integers, the array elements. :return: String indicating whether a palindrome is possible, and the palindrome if it is possible. # Your code here # Unit Tests def test_possible_palindrome_odd(): assert format_output(5, [1, 2, 3, 2, 1]) == \\"YESn1 2 3 2 1\\" def test_possible_palindrome_even(): assert format_output(6, [1, 2, 2, 1, 1, 1]) == \\"YESn1 1 2 2 1 1\\" def test_impossible_palindrome(): assert format_output(4, [1, 2, 3, 4]) == \\"NO\\" def test_single_element(): assert format_output(1, [1]) == \\"YESn1\\" def test_all_same_elements(): assert format_output(4, [2, 2, 2, 2]) == \\"YESn2 2 2 2\\" def test_multiple_palindromes_possible(): result = format_output(5, [4, 4, 1, 4, 4]) assert result.startswith(\\"YESn\\") permutation = result.split(\\"n\\")[1].split(\\" \\") assert permutation == permutation[::-1] # Check it is a palindrome","solution":"from collections import Counter def can_form_palindrome(n, arr): Determines if it is possible to rearrange the elements of the array to form a palindrome. If possible, returns a valid palindrome permutation. If not, returns \\"NO\\". :param n: Integer, the number of elements in the array. :param arr: List of integers, the array elements. :return: Tuple (String, List of integers/None) where the string is either 'YES' or 'NO', and the list is a valid palindrome permutation if possible, None otherwise. counter = Counter(arr) odd_count = sum(1 for count in counter.values() if count % 2 != 0) if odd_count > 1: return \\"NO\\", None first_half = [] second_half = [] middle = None for num, count in counter.items(): if count % 2 != 0: middle = [num] * count else: half_count = count // 2 first_half.extend([num] * half_count) second_half.extend([num] * half_count) if middle is not None: first_half.extend(middle) palindrome = first_half + second_half[::-1] return \\"YES\\", palindrome # Function to format output as specified in the question def format_output(n, arr): result, permutation = can_form_palindrome(n, arr) if result == \\"NO\\": return result else: return result + \\"n\\" + ' '.join(map(str, permutation))"},{"question":"from typing import List def countPalletGroups(warehouse: List[List[int]]) -> int: Determine the number of connected groups of pallets in a warehouse. Parameters: warehouse (List[List[int]]): A 2D list representing the warehouse where 0 is an empty section and 1 is a section with a pallet. Returns: int: The number of connected groups of pallets. >>> countPalletGroups([[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [0, 0, 1, 1]]) 3 >>> countPalletGroups([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> countPalletGroups([[1]]) 1 >>> countPalletGroups([[0]]) 0 >>> countPalletGroups([[1, 1], [1, 1]]) 1 >>> countPalletGroups([[1, 0, 1], [1, 1, 1], [0, 1, 0]]) 1 >>> countPalletGroups([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) 4 >>> countPalletGroups([[1, 0, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1]]) 5","solution":"from typing import List def countPalletGroups(warehouse: List[List[int]]) -> int: Returns the number of connected groups of pallets in the warehouse. if not warehouse: return 0 n, m = len(warehouse), len(warehouse[0]) visited = [[False] * m for _ in range(n)] def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or visited[x][y] or warehouse[x][y] == 0: return visited[x][y] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: dfs(x + dx, y + dy) count = 0 for i in range(n): for j in range(m): if warehouse[i][j] == 1 and not visited[i][j]: count += 1 dfs(i, j) return count"},{"question":"from typing import List, Tuple def minimum_steps(n: int, m: int, x1: int, y1: int, x2: int, y2: int, b: int, obstacles: List[Tuple[int, int]]) -> int: Determine if there is a path for the rover to reach the target position within the battery limit. If a path exists, return the least number of cells the rover needs to travel through to reach the target. If no such path exists, return -1. >>> minimum_steps(5, 3, 0, 0, 4, 4, 8, [(1, 0), (1, 1), (1, 2)]) 8 >>> minimum_steps(5, 0, 0, 0, 4, 4, 10, []) 8 >>> minimum_steps(5, 0, 0, 0, 4, 4, 5, []) -1 >>> minimum_steps(5, 5, 0, 0, 4, 4, 10, [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4)]) -1 >>> minimum_steps(5, 0, 0, 0, 0, 0, 10, []) 0 from collections import deque def minimum_steps(n: int, m: int, x1: int, y1: int, x2: int, y2: int, b: int, obstacles: List[Tuple[int, int]]) -> int: # Implement the function here","solution":"from collections import deque def minimum_steps(n, m, x1, y1, x2, y2, b, obstacles): # creating the grid grid = [[0]*n for _ in range(n)] # marking obstacles in the grid for ox, oy in obstacles: grid[ox][oy] = 1 # directions array for moving in the grid directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS queue to store the current position and steps taken queue = deque([(x1, y1, 0)]) visited = set() visited.add((x1, y1)) while queue: x, y, steps = queue.popleft() if (x, y) == (x2, y2): return steps if steps >= b: continue for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, steps+1)) return -1"},{"question":"from typing import List from collections import Counter def count_common_elements(arr1: List[int], arr2: List[int]) -> int: Returns the count of common elements between arr1 and arr2 considering their multiplicities. >>> count_common_elements([1, 2, 2, 3, 4], [2, 2, 3, 3]) 3 >>> count_common_elements([1, 2, 3], [4, 5, 6]) 0","solution":"from collections import Counter def count_common_elements(arr1, arr2): Returns the count of common elements between arr1 and arr2 considering their multiplicities. count1 = Counter(arr1) count2 = Counter(arr2) common_count = 0 for element in count1: if element in count2: common_count += min(count1[element], count2[element]) return common_count"},{"question":"def find_minimum_range(nums: List[int], queries: List[int]) -> List[List[int]]: For each target in queries, find the minimum range in nums that contains the target value at least twice. >>> find_minimum_range([1, 2, 2, 3, 4, 5, 5, 5, 6, 6], [2, 5, 9]) [[1, 2], [5, 6], [-1, -1]] >>> find_minimum_range([1, 3, 5, 7, 9], [1, 3, 5]) [[-1, -1], [-1, -1], [-1, -1]] >>> find_minimum_range([5, 5, 5, 5, 5], [5, 6]) [[0, 1], [-1, -1]] >>> find_minimum_range([1, 2, 4, 4, 4, 5, 7, 8, 8, 10], [4, 8, 2]) [[2, 3], [7, 8], [-1, -1]] >>> find_minimum_range([1], [1]) [[-1, -1]] >>> find_minimum_range([1, 2, 2, 3, 4, 5, 1000000000, 1000000000], [2, 1000000000]) [[1, 2], [6, 7]]","solution":"def find_minimum_range(nums, queries): For each target in queries, find the minimum range in nums that contains the target value at least twice. from collections import defaultdict # Create a dictionary to store the indices of each value in nums index_map = defaultdict(list) for idx, num in enumerate(nums): index_map[num].append(idx) result = [] for target in queries: if target in index_map and len(index_map[target]) > 1: # If the target is found more than once, get the smallest range result.append([index_map[target][0], index_map[target][1]]) else: # Otherwise, return [-1, -1] result.append([-1, -1]) return result"},{"question":"def first_unique_char(s: str) -> int: Returns the index of the first non-repeating character in the string s. If no such character exists, returns -1. >>> first_unique_char(\\"leetcode\\") == 0 >>> first_unique_char(\\"loveleetcode\\") == 2 >>> first_unique_char(\\"aabb\\") == -1","solution":"def first_unique_char(s): Returns the index of the first non-repeating character in the string s. If no such character exists, returns -1. # Dictionary to store count of each character char_count = {} # Populate dictionary with character counts for char in s: char_count[char] = char_count.get(char, 0) + 1 # Find the first character with a count of 1 for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"def minimum_height_difference(N: int, heights: List[int]) -> int: Returns the minimum possible height difference between any two adjacent trees when they are arranged optimally. Args: - N: number of trees (int) - heights: list of tree heights (list of int) Returns: - Minimum height difference (int) >>> minimum_height_difference(5, [4, 8, 2, 6, 5]) 1 >>> minimum_height_difference(1, [4]) inf","solution":"def minimum_height_difference(N, heights): Returns the minimum possible height difference between any two adjacent trees when they are arranged optimally. Args: - N: number of trees (int) - heights: list of tree heights (list of int) Returns: - Minimum height difference (int) # Sort the heights to find the minimum differences easily heights.sort() # Initialize the minimum difference as infinity min_diff = float('inf') # Iterate through the sorted heights and find the minimum difference for i in range(1, N): min_diff = min(min_diff, heights[i] - heights[i-1]) return min_diff"},{"question":"from typing import List def find_intersection(nums1: List[int], nums2: List[int]) -> List[int]: Returns the intersection of nums1 and nums2, maintaining the order of their first appearance in nums1. >>> find_intersection([1, 2, 2, 1], [2, 2]) [2, 2] >>> find_intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> find_intersection([1], [1]) [1] >>> find_intersection([1, 2, 3], [4, 5, 6]) [] # Your code here def test_find_intersection_example_1(): assert find_intersection([1, 2, 2, 1], [2, 2]) == [2, 2] def test_find_intersection_example_2(): assert find_intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [4, 9] def test_find_intersection_example_3(): assert find_intersection([1], [1]) == [1] def test_find_intersection_example_4(): assert find_intersection([1, 2, 3], [4, 5, 6]) == [] def test_find_intersection_empty_nums1(): assert find_intersection([], [1, 2]) == [] def test_find_intersection_empty_nums2(): assert find_intersection([1, 2], []) == [] def test_find_intersection_no_common_elements(): assert find_intersection([1, 3, 7], [2, 4, 8]) == [] def test_find_intersection_all_common_elements(): assert find_intersection([2, 2, 2], [2, 2, 2]) == [2, 2, 2] def test_find_intersection_partial_common_elements(): assert find_intersection([1, 2, 3, 4, 5], [3, 4, 7, 8]) == [3, 4] def test_find_intersection_repeated_elements(): assert find_intersection([1, 2, 2, 3], [2, 2, 2]) == [2, 2] def test_find_intersection_order_preserved(): assert find_intersection([4, 5, 6], [6, 5]) == [5, 6]","solution":"def find_intersection(nums1, nums2): Returns the intersection of nums1 and nums2, maintaining the order of their first appearance in nums1. intersection = [] nums2_counts = {} for num in nums2: if num in nums2_counts: nums2_counts[num] += 1 else: nums2_counts[num] = 1 for num in nums1: if num in nums2_counts and nums2_counts[num] > 0: intersection.append(num) nums2_counts[num] -= 1 return intersection"},{"question":"from typing import List from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearrange a string so that no two adjacent characters are the same. Returns the rearranged string if possible, otherwise returns \\"NO\\". >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] >>> rearrange_string(\\"aaab\\") \\"NO\\" >>> rearrange_string(\\"abb\\") in [\\"bab\\", \\"bba\\"] pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases for rearranging strings. Returns a list of rearranged strings or \\"NO\\" where rearrangement is not possible. >>> process_test_cases(3, [\\"aabb\\", \\"aaab\\", \\"abb\\"]) Results should include: [\\"abab\\", \\"NO\\", \\"bab\\"] pass import pytest def test_rearrange_possible(): assert rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] def test_rearrange_impossible(): assert rearrange_string(\\"aaab\\") == \\"NO\\" def test_rearrange_short_string(): assert rearrange_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] def test_rearrange_single_char(): assert rearrange_string(\\"a\\") == \\"a\\" def test_rearrange_all_same_char(): assert rearrange_string(\\"bbbb\\") == \\"NO\\" def test_process_test_cases(): test_cases = [\\"aabb\\", \\"aaab\\", \\"abb\\"] results = process_test_cases(3, test_cases) assert results[0] in [\\"abab\\", \\"baba\\"] assert results[1] == \\"NO\\" assert results[2] in [\\"bab\\", \\"bba\\"] if __name__ == \\"__main__\\": pytest.main([])","solution":"from collections import Counter import heapq def rearrange_string(s): Rearrange a string so that no two adjacent characters are the same. Returns the rearranged string if possible, otherwise returns \\"NO\\". # Count the frequency of each character char_count = Counter(s) # Use a max-heap to store characters, -count for max behavior with min-heap max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char is not None: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char if count + 1 < 0 else None prev_count = count + 1 res_str = ''.join(result) if len(res_str) != len(s): return \\"NO\\" return res_str def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"def max_books_on_shelf(n: int, m: int, books: List[Tuple[int, int]]) -> int: Determine the maximum number of books that can be placed on a shelf of length \`m\`. Args: n : int : the number of books m : int : the length of the shelf books : List[Tuple[int, int]] : list of tuples where each tuple has two integers denoting the width and height of a book Returns: int : the maximum number of books that can be placed on the shelf without exceeding its length Example: >>> max_books_on_shelf(5, 10, [(1, 3), (2, 5), (3, 1), (4, 2), (2, 4)]) 4 >>> max_books_on_shelf(3, 5, [(2, 5), (2, 5), (2, 5)]) 2 pass def process_input(data: str) -> int: Process the given input data to compute the maximum number of books that can be placed on the shelf. Args: data : str : multi-line string containing the number of books, the shelf length, and the dimensions of each book Returns: int : the maximum number of books that can be placed on the shelf Example: >>> input_data = \\"5 10n1 3n2 5n3 1n4 2n2 4n\\" >>> process_input(input_data) 4 >>> input_data = \\"3 5n2 5n2 5n2 5n\\" >>> process_input(input_data) 2 pass","solution":"def max_books_on_shelf(n, m, books): books.sort(key=lambda x: x[0]) # Sort books by width total_width = 0 count = 0 for width, height in books: if total_width + width <= m: total_width += width count += 1 else: break return count # Function to parse and process input def process_input(data): lines = data.strip().split('n') n, m = map(int, lines[0].split()) books = [tuple(map(int, line.split())) for line in lines[1:]] return max_books_on_shelf(n, m, books)"},{"question":"def findWord(grid: List[List[str]], word: str) -> bool: Determines whether a given word can be found in a grid of characters. The word can be constructed from letters of sequentially adjacent cells. Adjacent cells are horizontally or vertically neighboring, and each cell can be used only once. Args: grid: List[List[str]]: The m x n matrix of characters. word: str: The word to find in the grid. Returns: bool: True if the word is found in the grid, False otherwise. Example: >>> findWord([ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], \\"ABCCED\\") True >>> findWord([ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], \\"ABCB\\") False","solution":"def findWord(grid, word): rows, cols = len(grid), len(grid[0]) def dfs(x, y, idx): if idx == len(word): return True if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != word[idx]: return False temp = grid[x][y] grid[x][y] = '#' found = (dfs(x + 1, y, idx + 1) or dfs(x - 1, y, idx + 1) or dfs(x, y + 1, idx + 1) or dfs(x, y - 1, idx + 1)) grid[x][y] = temp return found for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"import math from typing import List def generate_spiral(n: int) -> List[List[int]]: Create a 2-dimensional array of a spiral of integers starting from 1 in the top-left corner and increasing in value, laid out in a clockwise direction. The size of the spiral will be a given perfect square integer \`n\`, where \`n\` is greater than 0. The function should return a 2D array of size \`sqrt(n) x sqrt(n)\` where each element represents a number in the spiral. >>> generate_spiral(9) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral(16) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral(1) [[1]] >>> generate_spiral(4) [[1, 2], [4, 3]] >>> generate_spiral(25) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"import math def generate_spiral(n): Generates a 2D spiral array starting from 1 up to the given perfect square integer n. size = int(math.sqrt(n)) spiral = [[0] * size for _ in range(size)] left, right, top, bottom = 0, size - 1, 0, size - 1 current_number = 1 while left <= right and top <= bottom: # Traverse from left to right for i in range(left, right + 1): spiral[top][i] = current_number current_number += 1 top += 1 # Traverse downwards for i in range(top, bottom + 1): spiral[i][right] = current_number current_number += 1 right -= 1 # Traverse from right to left for i in range(right, left - 1, -1): spiral[bottom][i] = current_number current_number += 1 bottom -= 1 # Traverse upwards for i in range(bottom, top - 1, -1): spiral[i][left] = current_number current_number += 1 left += 1 return spiral"},{"question":"def max_heart_rate_difference(n: int, heart_rates: List[int]) -> int: Given the number of heart rate recordings and an array of recorded heart rates throughout the day, calculate the maximum upward heart rate difference where the latter recording comes after the former. Args: n : int : number of heart rate recordings heart_rates : List[int] : recorded heart rates in the order they were recorded Returns: int : the maximum upward heart rate difference or 0 if no such difference exists Examples: >>> max_heart_rate_difference(7, [70, 85, 75, 90, 80, 95, 100]) 30 >>> max_heart_rate_difference(5, [100, 90, 80, 70, 60]) 0","solution":"def max_heart_rate_difference(n, heart_rates): Returns the maximum upward heart rate difference. if n <= 1: return 0 min_heart_rate = heart_rates[0] max_diff = 0 for i in range(1, n): if heart_rates[i] > min_heart_rate: max_diff = max(max_diff, heart_rates[i] - min_heart_rate) min_heart_rate = min(min_heart_rate, heart_rates[i]) return max_diff"},{"question":"def count_non_empty_positions(n: int, m: int, grid: List[List[int]]) -> int: Determine the number of positions that will not be empty after moving each item once. >>> count_non_empty_positions(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 9 >>> count_non_empty_positions(2, 2, [ ... [1, 2], ... [3, 4] ... ]) 4","solution":"def count_non_empty_positions(n, m, grid): non_empty_positions = set() # Processing each cell to determine their new location for i in range(n): for j in range(m): non_empty_positions.add((i, j)) # original position # Valid moves if i > 0: # move up non_empty_positions.add((i-1, j)) if i < n-1: # move down non_empty_positions.add((i+1, j)) if j > 0: # move left non_empty_positions.add((i, j-1)) if j < m-1: # move right non_empty_positions.add((i, j+1)) # The set 'non_empty_positions' will contain all unique positions with items. return len(non_empty_positions)"},{"question":"def max_storage(N, C, volumes): Calculate the maximum storage used without exceeding the capacity when optimal selection of shipments is done. Args: N (int): the number of shipments. C (int): the warehouse capacity. volumes (List[int]): the volumes of the shipments. Returns: int: the maximum volume that can be utilized without exceeding the storage capacity. Examples: >>> max_storage(4, 10, [5, 4, 7, 3]) 10 >>> max_storage(1, 10**5, [10**5]) 100000","solution":"def max_storage(N, C, volumes): dp = [0] * (C + 1) for volume in volumes: for j in range(C, volume - 1, -1): dp[j] = max(dp[j], dp[j - volume] + volume) return dp[C] # Example usage: # result = max_storage(4, 10, [5, 4, 7, 3]) # print(result) # Should print: 10"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Write a function that determines the minimum number of single-character insertions required to make a given string a palindrome. A palindrome is a string that reads the same forwards and backwards. Parameters: s (str): A single string s of length n (1 <= n <= 5000). The string s will contain only lowercase English letters. Returns: int: An integer representing the minimum number of single-character insertions required to make the string a palindrome. Examples: >>> min_insertions_to_palindrome(\\"abca\\") 1 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"aabb\\") 2 pass","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of single-character insertions required to make string s a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for gap in range(1, n): for l in range(n - gap): r = l + gap if s[l] == s[r]: dp[l][r] = dp[l+1][r-1] else: dp[l][r] = min(dp[l][r-1], dp[l+1][r]) + 1 return dp[0][n-1]"},{"question":"from typing import List, Tuple def find_cheapest_flight(start: str, end: str, flights: List[Tuple[str, str, int]], max_layovers: int) -> int: Finds the cheapest flight from start to end with up to max_layovers layovers. Args: start (str): Starting city. end (str): Destination city. flights (list): List of tuples (source, destination, cost). max_layovers (int): Maximum number of layovers allowed. Returns: int: Minimum cost of the trip or -1 if no valid route exists. >>> flights = [(\\"A\\", \\"B\\", 100), (\\"B\\", \\"C\\", 100), (\\"A\\", \\"C\\", 300)] >>> find_cheapest_flight(\\"A\\", \\"C\\", flights, 0) 300 >>> find_cheapest_flight(\\"A\\", \\"C\\", flights, 1) 200 >>> find_cheapest_flight(\\"A\\", \\"D\\", flights, 0) -1","solution":"import heapq from collections import defaultdict, deque def find_cheapest_flight(start, end, flights, max_layovers): Finds the cheapest flight from start to end with up to max_layovers layovers. Args: start (str): Starting city. end (str): Destination city. flights (list): List of tuples (source, destination, cost). max_layovers (int): Maximum number of layovers allowed. Returns: int: Minimum cost of the trip or -1 if no valid route exists. # Create a graph from the flights data graph = defaultdict(list) for src, dst, cost in flights: graph[src].append((dst, cost)) # Min-heap to store the cost and current city (cost, city, stops) heap = [(0, start, 0)] visited = defaultdict(lambda: float('inf')) # Perform Dijkstra-like algorithm but keep track of stops/layovers while heap: current_cost, current_city, current_stops = heapq.heappop(heap) # If destination is reached with allowable stops if current_city == end: return current_cost if current_stops <= max_layovers: for neighbor, price in graph[current_city]: new_cost = current_cost + price if new_cost < visited[(neighbor, current_stops + 1)]: visited[(neighbor, current_stops + 1)] = new_cost heapq.heappush(heap, (new_cost, neighbor, current_stops + 1)) return -1"},{"question":"def full_sized_worker_ants(m, p, observation_times): Calculate the number of full-sized worker ants present in the colony at each given observation time. Parameters: - m (int): The number of minutes the study lasts. - p (int): The number of observation points. - observation_times (List[int]): List of minutes at which the population of full-sized worker ants is to be reported. Returns: - List[int]: A list where the ith element represents the number of full-sized worker ants at minute observation_times[i]. Example: >>> full_sized_worker_ants(5, 3, [1, 3, 5]) [0, 2, 4] >>> full_sized_worker_ants(10, 4, [2, 5, 7, 10]) [1, 4, 6, 9]","solution":"def full_sized_worker_ants(m, p, observation_times): def workers_count_at(t): return max(0, t - 1) results = [] for t in observation_times: results.append(workers_count_at(t)) return results"},{"question":"def findSingleNumber(arr): Given an array of integers where every element appears three times except for one, which appears exactly once, find the element that appears only once. :param arr: List[int] -- A list of integers where every element appears three times except for one. :return: int -- The element that appears only once. >>> findSingleNumber([2, 2, 3, 2]) # returns 3 >>> findSingleNumber([0, 1, 0, 1, 0, 1, 99]) # returns 99","solution":"def findSingleNumber(arr): Returns the element that appears only once in the array where every other element appears three times. :param arr: List[int] -- A list of integers where every element appears three times except for one. :return: int -- The element that appears only once. ones, twos = 0, 0 for num in arr: # \`ones\` will have the elements appearing 3k+1 times. ones = (ones ^ num) & ~twos # \`twos\` will have the elements appearing 3k+2 times. twos = (twos ^ num) & ~ones return ones"},{"question":"def maxSubsequenceSum(A, N): Returns the maximum sum of a non-empty subsequence of A where no two elements are consecutive in the original array. Args: A (List[int]): The list of integers. N (int): The number of elements in the list A. Returns: int: The maximum sum of the subsequence with non-consecutive elements. Examples: >>> maxSubsequenceSum([3, 2, 7, 10], 4) 13 >>> maxSubsequenceSum([3, 2, 5, 10, 7], 5) 20","solution":"def maxSubsequenceSum(A, N): Returns the maximum sum of a non-empty subsequence of A where no two elements are consecutive in the original array. if N == 0: return 0 if N == 1: return A[0] # Initialize two variables to store the maximum sum without selecting the previous element prev2 = 0 prev1 = A[0] for i in range(1, N): curr = max(prev1, prev2 + A[i]) prev2 = prev1 prev1 = curr return prev1"},{"question":"def count_commented_lines(n: int, lines: List[str]) -> int: Returns the total number of commented lines in the given list of code lines. Parameters: n (int): Number of lines of code. lines (list of str): List of strings, each representing a line of code. Returns: int: The total number of commented lines. >>> count_commented_lines(5, [\\"#include <iostream>\\", \\"// This is a comment\\", \\"int main() {\\", \\" // Another comment\\", \\" std::cout << 'Hello, World!';\\", \\" return 0;\\", \\"}\\"]) 2 >>> count_commented_lines(4, [\\"int main() {\\", \\" std::cout << 'Hello, World!';\\", \\" return 0;\\", \\"}\\"]) 0 pass from solution import count_commented_lines def test_sample_input(): lines = [ \\"#include <iostream>\\", \\"// This is a comment\\", \\"int main() {\\", \\" // Another comment\\", \\" std::cout << \\"Hello, World!\\";\\", \\" return 0;\\", \\"}\\" ] assert count_commented_lines(len(lines), lines) == 2 def test_no_comments(): lines = [ \\"int main() {\\", \\" std::cout << \\"Hello, World!\\";\\", \\" return 0;\\", \\"}\\" ] assert count_commented_lines(len(lines), lines) == 0 def test_all_comments(): lines = [ \\"// Comment 1\\", \\"// Comment 2\\", \\"// Comment 3\\" ] assert count_commented_lines(len(lines), lines) == 3 def test_comments_with_spaces(): lines = [ \\" // Comment 1\\", \\"// Comment 2 \\", \\" // Comment 3\\" ] assert count_commented_lines(len(lines), lines) == 3 def test_comments_in_code(): lines = [ \\"int main() {\\", \\" std::cout << \\"Hello\\"; // This is a code comment\\", \\" std::cout << \\"World\\"; \\", \\"// Standalone comment\\", \\" return 0;\\", \\"}\\" ] assert count_commented_lines(len(lines), lines) == 1 def test_empty_lines(): lines = [ \\"\\", \\"// Comment 1\\", \\"\\", \\"int main() {\\", \\" return 0;\\", \\"}\\", \\"\\" ] assert count_commented_lines(len(lines), lines) == 1","solution":"def count_commented_lines(n, lines): Returns the total number of commented lines in the given list of code lines. Parameters: n (int): Number of lines of code. lines (list of str): List of strings, each representing a line of code. Returns: int: The total number of commented lines. comment_prefix = \\"//\\" count = 0 for line in lines: stripped_line = line.strip() if stripped_line.startswith(comment_prefix): count += 1 return count"},{"question":"def generate_smallest_id(N: int, letters: str) -> str: Generate the lexicographically smallest possible ID that follows the rules. >>> generate_smallest_id(5, \\"ABC\\") \\"ABABA\\" >>> generate_smallest_id(3, \\"QV\\") \\"QVQ\\" >>> generate_smallest_id(4, \\"XYZ\\") \\"XYXY\\" pass def process_input(T: int, cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases to generate the smallest possible IDs. >>> process_input(3, [(5, \\"ABC\\"), (3, \\"QV\\"), (4, \\"XYZ\\")]) [\\"ABABA\\", \\"QVQ\\", \\"XYXY\\"] >>> process_input(4, [(5, \\"ABC\\"), (3, \\"AB\\"), (6, \\"DE\\"), (2, \\"GH\\")]) [\\"ABABA\\", \\"ABA\\", \\"DEDEDE\\", \\"GH\\"] pass","solution":"def generate_smallest_id(N, letters): letters = sorted(letters) result = [letters[0]] for i in range(1, N): for letter in letters: if letter != result[-1]: result.append(letter) break return ''.join(result) def process_input(T, cases): results = [] for N, letters in cases: results.append(generate_smallest_id(N, letters)) return results"},{"question":"def findPair(nums, target): Finds two indices such that the elements at these indices sum up to the target. Args: nums (list): List of integers. target (int): Target sum. Returns: list: List containing two indices if such a pair exists, otherwise an empty list. Examples: >>> findPair([2, 7, 11, 15], 9) [0, 1] >>> findPair([3, 2, 4], 6) [1, 2] from solution import findPair def test_example_1(): nums = [2, 7, 11, 15] target = 9 assert findPair(nums, target) == [0, 1] def test_example_2(): nums = [3, 2, 4] target = 6 assert findPair(nums, target) == [1, 2] def test_no_pair_exists(): nums = [1, 2, 3] target = 7 assert findPair(nums, target) == [] def test_single_element(): nums = [1] target = 1 assert findPair(nums, target) == [] def test_large_numbers(): nums = [10**9, 3, -10**9] target = 0 assert findPair(nums, target) == [0, 2] def test_negative_numbers(): nums = [-1, -2, -3, -4] target = -6 assert findPair(nums, target) == [1, 3] def test_no_matching_pair(): nums = [1, 5, 6, 7] target = 100 assert findPair(nums, target) == []","solution":"def findPair(nums, target): Finds two indices such that the elements at these indices sum up to the target. Args: nums (list): List of integers. target (int): Target sum. Returns: list: List containing two indices if such a pair exists, otherwise an empty list. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return [seen[complement], i] seen[num] = i return []"},{"question":"def who_wins(n: int) -> str: Determine who will win the game if both players play optimally. Alice starts the game and can remove a prime number of tokens. Bob takes the next turn and can remove a perfect square number of tokens. >>> who_wins(10) \\"Alice\\" >>> who_wins(15) \\"Bob\\" >>> who_wins(2) \\"Alice\\" >>> who_wins(1) \\"Bob\\" >>> who_wins(1000000) \\"Alice\\"","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def has_prime(n): Check if there is any prime number <= n. for i in range(2, n + 1): if is_prime(i): return True return False def has_perfect_square(n): Check if there is any perfect square number <= n. i = 1 while i * i <= n: i += 1 return (i - 1) * i - 1 <= n def who_wins(n): Function to determine who wins the game. if n == 0: return \\"Bob\\" turn = \\"Alice\\" while n > 0: if turn == \\"Alice\\": if not has_prime(n): return \\"Bob\\" for i in range(n, 0, -1): if is_prime(i): n -= i break turn = \\"Bob\\" else: if not has_perfect_square(n): return \\"Alice\\" for i in range(int(n**0.5), 0, -1): if i * i <= n: n -= i * i break turn = \\"Alice\\" return \\"Alice\\" if turn == \\"Bob\\" else \\"Bob\\""},{"question":"from typing import List, Tuple def minimize_fairness(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Anna wants to distribute prizes such that the fairness value (difference between maximum and minimum total prize values) is minimized. Args: T : int : Number of test cases test_cases : List[Tuple[int, int, List[int]]] : Each tuple contains N (number of prizes), M (number of participants), and a list of N integers representing the prize values Returns: List[int] : A list of minimized fairness values for each test case >>> minimize_fairness(2, [(5, 2, [8, 4, 3, 2, 5]), (4, 3, [1, 1, 1, 1])]) [1, 0] >>> minimize_fairness(1, [(1, 1, [5])]) [0] >>> minimize_fairness(1, [(3, 2, [1000000000, 1000000001, 1000000002])]) [1] >>> minimize_fairness(1, [(4, 2, [3, 5, 7, 9])]) [2]","solution":"def minimize_fairness(T, test_cases): results = [] for test_case in test_cases: N, M, prizes = test_case prizes.sort() # initialize the minimum difference to a large number min_diff = float('inf') # We only need to check the windows of size M within the sorted list for i in range(N - M + 1): current_diff = prizes[i + M - 1] - prizes[i] min_diff = min(min_diff, current_diff) results.append(min_diff) return results"},{"question":"def min_guards(n: int, intervals: List[Tuple[int, int]]) -> int: Determines the minimum number of guards required to cover all entrance points, given their time intervals. >>> min_guards(3, [(1, 4), (2, 5), (6, 8)]) # Should return 2 >>> min_guards(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) # Should return 2 >>> min_guards(1, [(1, 4)]) # Should return 1 >>> min_guards(3, [(1, 4), (5, 8), (9, 12)]) # Should return 3 >>> min_guards(3, [(1, 4), (2, 5), (3, 6)]) # Should return 1 >>> min_guards(0, []) # Should return 0","solution":"def min_guards(n, intervals): Determines the minimum number of guards required to cover all entrance points, given their time intervals. :param n: Number of entrance points :param intervals: List of tuples, each containing the start and end times of a guarding interval :return: Minimum number of guards required if not intervals: return 0 # Sort the intervals based on the end time intervals.sort(key=lambda x: x[1]) guards = 0 last_end_time = -1 for start, end in intervals: if start > last_end_time: # We need a new guard for this interval guards += 1 last_end_time = end return guards"},{"question":"from typing import List def longest_substring_max_one_a_b_c(s: str) -> int: Returns the length of the longest substring with at most one 'a', one 'b', and one 'c'. >>> longest_substring_max_one_a_b_c(\\"abc\\") 3 >>> longest_substring_max_one_a_b_c(\\"aa\\") 1 >>> longest_substring_max_one_a_b_c(\\"abccba\\") 3 >>> longest_substring_max_one_a_b_c(\\"bb\\") 1 >>> longest_substring_max_one_a_b_c(\\"ccbb\\") 2 >>> longest_substring_max_one_a_b_c(\\"ababcabcabc\\") 3 >>> longest_substring_max_one_a_b_c(\\"accbbca\\") 3 >>> longest_substring_max_one_a_b_c(\\"aabcabcabc\\") 3 pass def process_input(input_data: str) -> List[int]: Processes the input data and returns a list of results for each test case. >>> process_input(\\"3nabcnaanabccba\\") [3, 1, 3] >>> process_input(\\"2nabacnccbbaa\\") [3, 2] pass","solution":"def longest_substring_max_one_a_b_c(s): Returns the length of the longest substring with at most one 'a', one 'b', and one 'c'. max_length = 0 start = 0 counts = {'a': 0, 'b': 0, 'c': 0} for end in range(len(s)): if s[end] in counts: counts[s[end]] += 1 while all(count <= 1 for count in counts.values()) is False: if s[start] in counts: counts[s[start]] -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) results = [] for i in range(1, T + 1): results.append(longest_substring_max_one_a_b_c(lines[i])) return results"},{"question":"from typing import List, Tuple def max_histogram_area(heights: List[int]) -> int: Helper function to calculate the maximum rectangular area in a histogram. >>> max_histogram_area([2, 1, 5, 6, 2, 3, 4]) 10 >>> max_histogram_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> max_histogram_area([5, 5, 5, 5, 5]) 25 pass # Your implementation here def max_rectangular_area(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum rectangular area for a list of test cases. Each test case contains the number of buildings and their heights. >>> max_rectangular_area([(7, [2, 1, 5, 6, 2, 3, 4])]) [10] >>> max_rectangular_area([(5, [5, 5, 5, 5, 5])]) [25] pass # Your implementation here","solution":"def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_rectangular_area(test_cases): results = [] for n, heights in test_cases: results.append(max_histogram_area(heights)) return results"},{"question":"from typing import List, Tuple from datetime import datetime, timedelta class Library: A class to manage a library's book lending process. Attributes: borrowing_period (int): number of days a book can be borrowed. borrowing_limit (int): maximum number of books a member can borrow. Methods: borrow_book: borrow a book if it's available and the member hasn't exceeded the limit. return_book: return a book if it was borrowed by the member. get_due_date: get the due date of a borrowed book. get_borrowed_books: get the list of books currently borrowed by a member. get_lending_info: get the member ID and due date of a borrowed book. def __init__(self, borrowing_period: int, borrowing_limit: int): self.borrowing_period = borrowing_period self.borrowing_limit = borrowing_limit self.books = {} # ISBN -> (borrower_id, due_date) self.members = {} # member_id -> set of borrowed ISBNs def borrow_book(self, isbn: str, member_id: str, borrow_date: str) -> str: Allows a member to borrow a book if possible and returns the due date. Parameters: isbn (str): unique identifier of the book. member_id (str): unique identifier of the member. borrow_date (str): date when the book is borrowed (format 'YYYY-MM-DD'). Returns: str: due date if successful, else appropriate message. >>> library = Library(borrowing_period=14, borrowing_limit=5) >>> library.borrow_book('978-3-16-148410-0', 'member01', '2023-01-01') '2023-01-15' >>> library.borrow_book('978-3-16-148410-0', 'member02', '2023-01-01') 'Book not available' pass def return_book(self, isbn: str, member_id: str, return_date: str) -> str: Marks a book as returned if it was borrowed by the member. Parameters: isbn (str): unique identifier of the book. member_id (str): unique identifier of the member. return_date (str): date when the book is returned (format 'YYYY-MM-DD'). Returns: str: \\"Book returned successfully\\" or appropriate error message. >>> library = Library(borrowing_period=14, borrowing_limit=5) >>> library.borrow_book('978-3-16-148410-0', 'member01', '2023-01-01') '2023-01-15' >>> library.return_book('978-3-16-148410-0', 'member02', '2023-01-10') 'Book not borrowed by member' >>> library.return_book('978-3-16-148410-0', 'member01', '2023-01-10') 'Book returned successfully' pass def get_due_date(self, isbn: str) -> str: Returns the due date of a borrowed book. Parameters: isbn (str): unique identifier of the book. Returns: str: due date of the book or \\"Book not borrowed\\". >>> library = Library(borrowing_period=14, borrowing_limit=5) >>> library.borrow_book('978-3-16-148410-0', 'member01', '2023-01-01') '2023-01-15' >>> library.get_due_date('978-3-16-148410-0') '2023-01-15' >>> library.get_due_date('non-existent-book') 'Book not borrowed' pass def get_borrowed_books(self, member_id: str) -> List[str]: Returns a list of ISBN numbers of books currently borrowed by the member. Parameters: member_id (str): unique identifier of the member. Returns: List[str]: list of ISBN numbers of borrowed books. >>> library = Library(borrowing_period=14, borrowing_limit=5) >>> library.borrow_book('978-3-16-148410-0', 'member01', '2023-01-01') '2023-01-15' >>> library.get_borrowed_books('member01') ['978-3-16-148410-0'] >>> library.get_borrowed_books('non-existent-member') [] pass def get_lending_info(self, isbn: str) -> Tuple[str, str]: Returns the member ID and due date of a borrowed book. Parameters: isbn (str): unique identifier of the book. Returns: Tuple[str, str]: member ID and due date or (\\"\\", \\"\\") if book is not borrowed. >>> library = Library(borrowing_period=14, borrowing_limit=5) >>> library.borrow_book('978-3-16-148410-0', 'member01', '2023-01-01') '2023-01-15' >>> library.get_lending_info('978-3-16-148410-0') ('member01', '2023-01-15') >>> library.get_lending_info('non-existent-book') ('', '') pass","solution":"from typing import List, Tuple from datetime import datetime, timedelta class Library: def __init__(self, borrowing_period: int, borrowing_limit: int): self.borrowing_period = borrowing_period self.borrowing_limit = borrowing_limit self.books = {} # ISBN -> (borrower_id, due_date) self.members = {} # member_id -> set of borrowed ISBNs def borrow_book(self, isbn: str, member_id: str, borrow_date: str) -> str: if isbn in self.books: return \\"Book not available\\" if member_id not in self.members: self.members[member_id] = set() if len(self.members[member_id]) >= self.borrowing_limit: return \\"Member has exceeded borrowing limit\\" borrow_date_dt = datetime.strptime(borrow_date, '%Y-%m-%d') due_date_dt = borrow_date_dt + timedelta(days=self.borrowing_period) due_date_str = due_date_dt.strftime('%Y-%m-%d') self.books[isbn] = (member_id, due_date_str) self.members[member_id].add(isbn) return due_date_str def return_book(self, isbn: str, member_id: str, return_date: str) -> str: if isbn not in self.books or self.books[isbn][0] != member_id: return \\"Book not borrowed by member\\" del self.books[isbn] self.members[member_id].remove(isbn) return \\"Book returned successfully\\" def get_due_date(self, isbn: str) -> str: if isbn not in self.books: return \\"Book not borrowed\\" return self.books[isbn][1] def get_borrowed_books(self, member_id: str) -> List[str]: if member_id not in self.members: return [] return list(self.members[member_id]) def get_lending_info(self, isbn: str) -> Tuple[str, str]: if isbn not in self.books: return (\\"\\", \\"\\") return self.books[isbn]"},{"question":"def max_employees_with_bonus(n: int, k: int, salaries: List[int]) -> int: Calculate the maximum number of employees that can receive the bonus. >>> max_employees_with_bonus(4, 100, [30, 20, 10, 40]) 4 >>> max_employees_with_bonus(5, 17, [10, 20, 30, 40, 50]) 1 >>> max_employees_with_bonus(6, 50, [10, 5, 20, 15, 10, 25]) 4 >>> max_employees_with_bonus(3, 30, [25, 15, 20]) 1 >>> max_employees_with_bonus(1, 100, [50]) 1 >>> max_employees_with_bonus(8, 150, [25, 30, 15, 40, 50, 35, 20, 10]) 6 >>> max_employees_with_bonus(2, 5, [4, 3]) 1","solution":"def max_employees_with_bonus(n, k, salaries): salaries.sort() max_employees = 0 total_bonus_given = 0 for i in range(n): if total_bonus_given + salaries[i] <= k: total_bonus_given += salaries[i] max_employees += 1 else: break return max_employees"},{"question":"def find_top_participant(N, M, results): Find the participant who solved the most number of problems and the number of problems they solved. Args: N (int): The number of participants. M (int): The number of problems. results (List[List[int]]): The results matrix where each row represents a participant's problem-solving results. Returns: tuple: A tuple containing two integers - the ID of the participant who solved the most problems and the number of problems they solved. >>> N, M = 5, 4 >>> results = [ ... [1, 0, 0, 1], ... [1, 1, 1, 0], ... [0, 1, 0, 1], ... [1, 1, 0, 0], ... [0, 0, 1, 1] ... ] >>> find_top_participant(N, M, results) (2, 3) >>> N, M = 3, 3 >>> results = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> find_top_participant(N, M, results) (1, 1)","solution":"def find_top_participant(N, M, results): max_solved = -1 top_participant_id = -1 for i in range(N): solved_problems = sum(results[i]) if solved_problems > max_solved or (solved_problems == max_solved and top_participant_id > i + 1): max_solved = solved_problems top_participant_id = i + 1 return top_participant_id, max_solved"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"dvdf\\") == 3","solution":"def length_of_longest_substring(s): Given a string s, returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def can_reach_city_N(N: int, M: int, routes: List[Tuple[int, int]]) -> str: Determines if it is possible to reach City N starting from City 1 by following one-way routes. Parameters: N (int): Total number of cities M (int): Total number of routes routes (List[Tuple[int, int]]): List of tuples representing the routes (u_i, v_i) Returns: str: \\"YES\\" if it is possible to reach City N from City 1, otherwise \\"NO\\" Examples: >>> can_reach_city_N(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 'YES' >>> can_reach_city_N(4, 3, [(1, 2), (2, 3), (3, 4)]) 'YES' >>> can_reach_city_N(5, 3, [(1, 2), (2, 3), (4, 5)]) 'NO' >>> can_reach_city_N(4, 1, [(1, 4)]) 'YES' >>> can_reach_city_N(4, 4, [(1, 2), (2, 4), (1, 3), (3, 4)]) 'YES'","solution":"from collections import defaultdict, deque def can_reach_city_N(N, M, routes): Determines if it is possible to reach City N starting from City 1 by following one-way routes. :param N: Total number of cities :param M: Total number of routes :param routes: List of tuples representing the routes (u_i, v_i) :return: \\"YES\\" if it is possible to reach City N from City 1, otherwise \\"NO\\" graph = defaultdict(list) for u, v in routes: graph[u].append(v) # Perform BFS from city 1 queue = deque([1]) visited = set([1]) while queue: current_city = queue.popleft() if current_city == N: return \\"YES\\" for neighbor in graph[current_city]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return \\"NO\\""},{"question":"from math import gcd from typing import List, Tuple def count_coprime_pairs(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases T and a list of test_cases where each test case consists of an integer n (number of gemstones) and a list of integers representing the magical power of each gemstone, returns a list of results where each result is the number of co-prime pairs in the corresponding test case. Example: >>> count_coprime_pairs(2, [(3, [2, 3, 4]), (4, [2, 4, 6, 8])]) [2, 0] def test_single_case_with_pairs(): T = 1 test_cases = [ (3, [2, 3, 4]) ] assert count_coprime_pairs(T, test_cases) == [2] def test_single_case_no_pairs(): T = 1 test_cases = [ (4, [2, 4, 6, 8]) ] assert count_coprime_pairs(T, test_cases) == [0] def test_multiple_cases(): T = 2 test_cases = [ (3, [2, 3, 4]), (4, [2, 4, 6, 8]) ] assert count_coprime_pairs(T, test_cases) == [2, 0] def test_minimal_case(): T = 1 test_cases = [ (2, [1, 2]) ] assert count_coprime_pairs(T, test_cases) == [1] def test_large_numbers(): T = 1 test_cases = [ (3, [1000000, 9999999, 9999991]) ] assert count_coprime_pairs(T, test_cases) == [3] def test_identical_numbers(): T = 1 test_cases = [ (3, [6, 6, 6]) ] assert count_coprime_pairs(T, test_cases) == [0]","solution":"from math import gcd def count_coprime_pairs(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] gemstones = test_cases[i][1] count = 0 for j in range(n): for k in range(j + 1, n): if gcd(gemstones[j], gemstones[k]) == 1: count += 1 results.append(count) return results"},{"question":"def calculate_average_score(scores): Calculate the average of adjusted scores. If a score is less than 50, it is capped at 50. :param scores: list of 6 integers representing scores. :return: the average of the adjusted scores. pass # Example usage: # scores = [45, 60, 72, 30, 95, 88] # print(calculate_average_score(scores)) # Output: 77 from solution import calculate_average_score def test_calculate_average_score_all_above_50(): scores = [60, 72, 80, 96, 55, 88] assert calculate_average_score(scores) == (60+72+80+96+55+88) / 6 def test_calculate_average_score_some_below_50(): scores = [45, 60, 72, 30, 95, 88] assert calculate_average_score(scores) == (50+60+72+50+95+88) / 6 def test_calculate_average_score_all_below_50(): scores = [10, 20, 30, 40, 45, 49] assert calculate_average_score(scores) == 50 def test_calculate_average_score_mixed_values(): scores = [0, 100, 50, 75, 23, 51] assert calculate_average_score(scores) == (50+100+50+75+50+51) / 6 def test_calculate_average_score_all_at_cutoff(): scores = [50, 50, 50, 50, 50, 50] assert calculate_average_score(scores) == 50","solution":"def calculate_average_score(scores): Calculate the average of adjusted scores. If a score is less than 50, it is capped at 50. :param scores: list of 6 integers representing scores. :return: the average of the adjusted scores. # Apply capping to each score adjusted_scores = [max(score, 50) for score in scores] # Calculate average average_score = sum(adjusted_scores) / len(adjusted_scores) return average_score"},{"question":"def generate_x_matrix(N: int) -> list: Generates an X-Matrix of size N. Args: N (int): Size of the matrix Returns: List[List[int]]: The generated X-Matrix as a 2D list >>> generate_x_matrix(2) [[1, 0, 1], [0, 1, 0], [1, 0, 1]] >>> generate_x_matrix(3) [[1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]] pass def print_x_matrix(matrix: list) -> None: Prints the X-Matrix Args: matrix (List[List[int]]): The X-Matrix to be printed >>> print_x_matrix([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 1 0 1 0 1 0 1 0 1 >>> print_x_matrix([[1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]]) 1 0 0 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 pass","solution":"def generate_x_matrix(N): Generates an X-Matrix of size N. Args: N (int): Size of the matrix Returns: List[List[int]]: The generated X-Matrix as a 2D list size = 2 * N - 1 matrix = [[0] * size for _ in range(size)] for i in range(size): matrix[i][i] = 1 matrix[i][size - 1 - i] = 1 return matrix def print_x_matrix(matrix): Prints the X-Matrix Args: matrix (List[List[int]]): The X-Matrix to be printed for row in matrix: print(' '.join(map(str, row))) # Example usage: # N = int(input().strip()) # matrix = generate_x_matrix(N) # print_x_matrix(matrix)"},{"question":"def can_form_square(n, pieces): Determines if it is possible to create a square using all the pieces of wood. Args: n (int): The number of pieces of wood. pieces (List[int]): A list of lengths of the wood pieces. Returns: str: \\"YES\\" if it is possible to form a square, otherwise \\"NO\\". >>> can_form_square(4, [1, 1, 1, 1]) 'YES' >>> can_form_square(5, [2, 2, 2, 2, 2]) 'NO' def process_datasets(d, datasets): Processes multiple datasets to determine if a square can be formed for each. Args: d (int): The number of datasets. datasets (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains the number of pieces and a list of lengths. Returns: List[str]: A list of results for each dataset. >>> process_datasets(2, [(4, [1, 1, 1, 1]), (5, [2, 2, 2, 2, 2])]) ['YES', 'NO']","solution":"from itertools import combinations def can_form_square(n, pieces): if n < 4: return \\"NO\\" total_length = sum(pieces) if total_length % 4 != 0: return \\"NO\\" side_length = total_length // 4 pieces.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == n: return sides[0] == sides[1] == sides[2] == sides[3] == side_length for i in range(4): if sides[i] + pieces[index] <= side_length: sides[i] += pieces[index] if dfs(index + 1): return True sides[i] -= pieces[index] if sides[i] == 0: break return False return \\"YES\\" if dfs(0) else \\"NO\\" def process_datasets(d, datasets): results = [] for dataset in datasets: n, pieces = dataset result = can_form_square(n, pieces) results.append(result) return results"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(1) False def sum_of_primes(numbers: list) -> int: Returns the sum of all prime numbers in the given list. >>> sum_of_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 17 >>> sum_of_primes([11, 13, 16, 19, 24, 30]) 43 >>> sum_of_primes([4, 6, 8, 12]) 0 >>> sum_of_primes([31, 37, 41, 43]) 152 >>> sum_of_primes([]) 0 >>> sum_of_primes([999, 1000]) 0","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def sum_of_primes(numbers: list) -> int: Returns the sum of all prime numbers in the given list. return sum(num for num in numbers if is_prime(num))"},{"question":"def min_cost_to_palindrome(s: str) -> int: Determine the minimum cost to convert the given string into a palindrome. The function returns the minimum cost to convert a given string into a palindrome with the least number of character replacements. The cost is defined as the number of character replacements needed. >>> min_cost_to_palindrome('abca') 1 >>> min_cost_to_palindrome('abcdef') 3","solution":"def min_cost_to_palindrome(s): This function returns the minimum cost to convert a given string into a palindrome. The cost is defined as the number of character replacements needed. n = len(s) cost = 0 # Compare characters from the two ends of the string towards the center. for i in range(n // 2): if s[i] != s[n - i - 1]: cost += 1 return cost"},{"question":"def process_queries(queries): Check if the sequence can be made strictly increasing and output one such possible sequence. Each query is a tuple (n, sequence). >>> process_queries([(5, [1, 2, 3, 4, 5])]) ['1 2 3 4 5'] >>> process_queries([(4, [3, 1, 2, 4])]) ['1 2 3 4'] >>> process_queries([(3, [7, 5, 7])]) ['Impossible'] >>> process_queries([(4, [6, 5, 5, 2])]) ['Impossible']","solution":"def make_strictly_increasing(a): n = len(a) for i in range(n-1): if a[i] >= a[i+1]: return \\"Impossible\\" return \\" \\".join(map(str, a)) def process_queries(queries): results = [] for query in queries: n, sequence = query sorted_seq = sorted(sequence) result = make_strictly_increasing(sorted_seq) results.append(result) return results"},{"question":"def maximalRectangle(matrix): Given a binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Args: matrix (List[List[int]]): A 2D list representing the binary matrix. Returns: int: The area of the largest rectangular submatrix containing only 1's. >>> maximalRectangle([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) 6 >>> maximalRectangle([ [1, 1, 1, 1, 1] ]) 5 >>> maximalRectangle([ [1], [1], [1], [1] ]) 4 >>> maximalRectangle([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> maximalRectangle([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 9 >>> maximalRectangle([ [1, 0, 1, 1], [1, 1, 1, 1], [1, 1, 0, 1] ]) 4 >>> maximalRectangle([]) 0 >>> maximalRectangle([ [1] ]) 1 >>> maximalRectangle([ [0] ]) 0","solution":"def maximalRectangle(matrix): Given a binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. if not matrix: return 0 max_area = 0 n = len(matrix) m = len(matrix[0]) heights = [0] * (m + 1) for row in matrix: for i in range(m): if row[i] == 1: heights[i] += 1 else: heights[i] = 0 stack = [-1] for i in range(m + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"import heapq from typing import List, Tuple def minDeliveryTime(N: int, M: int, pathways: List[Tuple[int, int, int]]) -> int: Calculate the minimum combined travel time to deliver packages to all locations. Parameters: N (int): The number of locations. M (int): The number of pathways. pathways (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers, \`u\`, \`v\`, and \`t\`. Returns: int: The minimum combined travel time. Examples: >>> minDeliveryTime(4, 4, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 3)]) 6 >>> minDeliveryTime(3, 3, [(1, 2, 2), (1, 3, 3), (2, 3, 1)]) 3","solution":"import heapq def minDeliveryTime(N, M, pathways): # Create adjacency list for the graph graph = {i: [] for i in range(1, N+1)} for u, v, t in pathways: graph[u].append((v, t)) graph[v].append((u, t)) # Function to perform Prim's algorithm to find MST def prim(start): visited = set() min_heap = [(0, start)] total_cost = 0 while min_heap: cost, node = heapq.heappop(min_heap) if node in visited: continue total_cost += cost visited.add(node) for adj, weight in graph[node]: if adj not in visited: heapq.heappush(min_heap, (weight, adj)) return total_cost if len(visited) == N else float('inf') # Start from any node, here starting from node 1 return prim(1)"},{"question":"def max_connected_components(grid): Determines the maximum number of connected components of empty cells in the grid. Parameters: grid (list of str): The grid represented as a list of strings. Returns: int: The number of connected components of empty cells.","solution":"def max_connected_components(grid): Determines the maximum number of connected components of empty cells in the grid. Parameters: grid (list of str): The grid represented as a list of strings. Returns: int: The number of connected components of empty cells. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) visited = [[False] * m for _ in range(n)] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y] def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if is_valid(nx, ny): visited[nx][ny] = True stack.append((nx, ny)) components = 0 for i in range(n): for j in range(m): if grid[i][j] == '.' and not visited[i][j]: visited[i][j] = True components += 1 dfs(i, j) return components"},{"question":"from typing import List def can_schedule_conferences(T: int, conferences: List[List[List[int]]]) -> List[str]: Determine if it is possible to schedule all the sessions of each conference without any time overlap within the same conference. Parameters: T (int): The number of conferences. conferences (List[List[List[int]]]): List of conferences where each conference is represented by a list of sessions, each session being represented by a list of two integers [A, B] denoting the start and end time. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each conference depending on whether its sessions can be scheduled without overlap. >>> can_schedule_conferences(2, [[[60, 120], [0, 30], [90, 150]], [[600, 660], [720, 780]]]) ['NO', 'YES'] >>> can_schedule_conferences(1, [[[0, 30], [30, 60], [60, 90]]]) ['YES']","solution":"def can_schedule_conferences(T, conferences): results = [] for conference in conferences: sessions = sorted(conference, key=lambda x: x[0]) no_overlap = True for i in range(1, len(sessions)): if sessions[i][0] < sessions[i - 1][1]: no_overlap = False break if no_overlap: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example execution # Sample Input: # 2 # 3 # [60, 120], [0, 30], [90, 150] # 2 # [600, 660], [720, 780] T = 2 conferences = [ [[60, 120], [0, 30], [90, 150]], [[600, 660], [720, 780]] ] print(can_schedule_conferences(T, conferences)) # Expected Output: ['NO', 'YES']"},{"question":"def final_position(movements: str) -> str: Determine the final position of RoboCleaner on the grid after executing a sequence of movements. Args: movements (str): A sequence of characters representing the movement commands, with 'U' for up, 'D' for down, 'L' for left, and 'R' for right. Returns: str: Two space-separated integers representing the x and y coordinates of the final position. Examples: >>> final_position(\\"UUDDLRLR\\") '0 0' >>> final_position(\\"UUUU\\") '0 4' >>> final_position(\\"LDRU\\") '0 0' >>> final_position(\\"RRUU\\") '2 2' >>> final_position(\\"LLDD\\") '-2 -2'","solution":"def final_position(movements): x, y = 0, 0 for move in movements: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return f\\"{x} {y}\\""},{"question":"def longest_palindromic_substring_length(n: int, s: str) -> int: Returns the length of the longest palindromic substring within the given string s. Args: n (int): The length of the string. s (str): The string to analyze. Returns: int: The length of the longest palindromic substring. Examples: >>> longest_palindromic_substring_length(4, \\"abba\\") 4 >>> longest_palindromic_substring_length(5, \\"abcba\\") 5 >>> longest_palindromic_substring_length(3, \\"abc\\") 1","solution":"def longest_palindromic_substring_length(n, s): Returns the length of the longest palindromic substring within the given string s. if n == 0: return 0 dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 for i in range(n): dp[i][i] = True for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 for length in range(3, n+1): for i in range(n-length+1): j = i+length-1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length"},{"question":"from typing import List from collections import Counter def is_valid_string(s: str) -> str: Determine whether it is possible to achieve a valid string by removing no more than one character. >>> is_valid_string(\\"aabbcc\\") \\"YES\\" >>> is_valid_string(\\"aabbccc\\") \\"YES\\" >>> is_valid_string(\\"abc\\") \\"YES\\" # Implement the function here def valid_strings(T: int, strings: List[str]) -> List[str]: Given a list of strings, determine for each whether it can be made valid by removing at most one character. >>> valid_strings(3, [\\"aabbcc\\", \\"aabbccc\\", \\"abc\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] # Implement the function here def test_is_valid_string(): assert is_valid_string(\\"aabbcc\\") == \\"YES\\" assert is_valid_string(\\"aabbccc\\") == \\"YES\\" assert is_valid_string(\\"abc\\") == \\"YES\\" assert is_valid_string(\\"aabbcccc\\") == \\"NO\\" assert is_valid_string(\\"a\\") == \\"YES\\" assert is_valid_string(\\"aa\\") == \\"YES\\" assert is_valid_string(\\"ab\\") == \\"YES\\" assert is_valid_string(\\"abcc\\") == \\"YES\\" assert is_valid_string(\\"abccc\\") == \\"NO\\" def test_valid_strings(): assert valid_strings(3, [\\"aabbcc\\", \\"aabbccc\\", \\"abc\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\"] assert valid_strings(2, [\\"abcc\\", \\"abccc\\"]) == [\\"YES\\", \\"NO\\"] if __name__ == \\"__main__\\": test_is_valid_string() test_valid_strings() print(\\"All tests passed.\\")","solution":"from collections import Counter def is_valid_string(s): freq_counter = Counter(s) freq_values = list(freq_counter.values()) freq_counter = Counter(freq_values) if len(freq_counter) == 1: return \\"YES\\" elif len(freq_counter) == 2: key1, key2 = list(freq_counter.keys()) if (freq_counter[key1] == 1 and (key1 == 1 or key1 - 1 == key2)) or (freq_counter[key2] == 1 and (key2 == 1 or key2 - 1 == key1)): return \\"YES\\" return \\"NO\\" def valid_strings(T, strings): results = [] for s in strings: results.append(is_valid_string(s)) return results"},{"question":"def reverse_words(sentence: str) -> str: Reverses each word's letters in the sentence but keeps the words in their original order. Example: >>> reverse_words(\\"Hello World\\") 'olleH dlroW' >>> reverse_words(\\"Programming is fun\\") 'gnimmargorP si nuf' >>> reverse_words(\\"Code every day\\") 'edoC yreve yad'","solution":"def reverse_words(sentence): Reverses each word in the sentence but keeps the words in their original order. Parameters: sentence (str): The input English sentence to be processed. Returns: str: The sentence with each word's letters reversed. words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"import sys from collections import defaultdict, deque def build_tree(n, edges): Build a tree (an acyclic connected graph) from the list of edges. >>> build_tree(5, [(1, 2, 3), (1, 3, 4), (2, 4, 2), (2, 5, 6)]) {1: [(2, 3), (3, 4)], 2: [(1, 3), (4, 2), (5, 6)], 3: [(1, 4)], 4: [(2, 2)], 5: [(2, 6)]} tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) return tree def bfs(tree, start): Perform a BFS (Breadth First Search) to find shortest path from starting node. >>> bfs({1: [(2, 3), (3, 4)], 2: [(1, 3), (4, 2), (5, 6)], 3: [(1, 4)], 4: [(2, 2)], 5: [(2, 6)]}, 1) {1: 0, 2: 3, 3: 4, 4: 5, 5: 9} distances = {start: 0} queue = deque([start]) while queue: node = queue.popleft() current_distance = distances[node] for neighbor, weight in tree[node]: if neighbor not in distances: distances[neighbor] = current_distance + weight queue.append(neighbor) return distances def answer_queries(tree, queries): Answer the queries on shortest path lengths between pairs of points. >>> answer_queries({1: [(2, 3), (3, 4)], 2: [(1, 3), (4, 2), (5, 6)], 3: [(1, 4)], 4: [(2, 2)], 5: [(2, 6)]}, [(4, 5), (3, 4), (1, 5)]) [8, 9, 9] results = [] for a, b in queries: distances = bfs(tree, a) results.append(distances[b]) return results def solve(n, q, edges, queries): Main function to build the tree and answer the queries. >>> solve(5, 3, [(1, 2, 3), (1, 3, 4), (2, 4, 2), (2, 5, 6)], [(4, 5), (3, 4), (1, 5)]) [8, 9, 9] tree = build_tree(n, edges) return answer_queries(tree, queries)","solution":"import sys from collections import defaultdict, deque def build_tree(n, edges): tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) return tree def bfs(tree, start): distances = {start: 0} queue = deque([start]) while queue: node = queue.popleft() current_distance = distances[node] for neighbor, weight in tree[node]: if neighbor not in distances: distances[neighbor] = current_distance + weight queue.append(neighbor) return distances def answer_queries(tree, queries): results = [] for a, b in queries: distances = bfs(tree, a) results.append(distances[b]) return results def solve(n, q, edges, queries): tree = build_tree(n, edges) return answer_queries(tree, queries) # Main Execution if __name__ == \\"__main__\\": input = sys.stdin.read data = input().split() n = int(data[0]) q = int(data[1]) edges = [] index = 2 for _ in range(n-1): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 queries = [] for _ in range(q): a = int(data[index]) b = int(data[index + 1]) queries.append((a, b)) index += 2 result = solve(n, q, edges, queries) for res in result: print(res)"},{"question":"def rearrange_array(arr: List[int]) -> List[int]: Returns the array arr sorted in non-decreasing order such that for the first half of the result, every integer is less than or equal to every integer in the second half of the result. >>> rearrange_array([4, 3, 1, 2]) [1, 2, 3, 4] >>> rearrange_array([11, 9, 13, 10, 12]) [9, 10, 11, 12, 13]","solution":"def rearrange_array(arr): Returns the array arr sorted in non-decreasing order such that for the first half of the result, every integer is less than or equal to every integer in the second half of the result. return sorted(arr)"},{"question":"def transform_string(k, S): Transforms the string S by replacing each character with the k-th next character in the alphabet. Wrap around if necessary. pass # Implement the string transformation logic here def process_cases(T, cases): Process multiple test cases and return the list of results for each case. pass # Implement the case processing logic here def test_transform_string(): assert transform_string(1, \\"abcd\\") == \\"bcde\\" assert transform_string(2, \\"xyz\\") == \\"zab\\" assert transform_string(3, \\"hello\\") == \\"khoor\\" assert transform_string(26, \\"hello\\") == \\"hello\\" # k is a multiple of 26; string should be unchanged assert transform_string(0, \\"test\\") == \\"test\\" # k is 0; string should be unchanged def test_process_cases(): cases = [(1, \\"abcd\\"), (2, \\"xyz\\"), (3, \\"hello\\")] assert process_cases(3, cases) == [\\"bcde\\", \\"zab\\", \\"khoor\\"] cases = [(0, \\"world\\"), (5, \\"abc\\"), (26, \\"def\\")] assert process_cases(3, cases) == [\\"world\\", \\"fgh\\", \\"def\\"] if __name__ == \\"__main__\\": test_transform_string() test_process_cases() print(\\"All tests passed!\\")","solution":"def transform_string(k, S): Transforms the string S by replacing each character with the k-th next character in the alphabet. Wrap around if necessary. transformed = [] for char in S: transformed_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) transformed.append(transformed_char) return ''.join(transformed) def process_cases(T, cases): Process multiple test cases and return the list of results for each case. results = [] for k, S in cases: result = transform_string(k, S) results.append(result) return results"},{"question":"def can_cover_grid(n: int, tile_counts: List[int]) -> str: Determine if it is possible to cover an n x n grid using the given tiles exactly. :param n: int -- size of the grid (n x n) :param tile_counts: list of int -- number of tiles available for each terrain type :return: str -- \\"YES\\" if it's possible to cover the grid exactly, otherwise \\"NO\\" >>> can_cover_grid(4, [8, 4, 4]) 'YES' >>> can_cover_grid(3, [5, 3, 2]) 'NO' from typing import List def test_can_cover_grid_case1(): assert can_cover_grid(4, [8, 4, 4]) == \\"YES\\" def test_can_cover_grid_case2(): assert can_cover_grid(3, [5, 3, 2]) == \\"NO\\" def test_can_cover_grid_edge_case_minimum(): assert can_cover_grid(1, [1]) == \\"YES\\" assert can_cover_grid(1, [2]) == \\"NO\\" def test_can_cover_grid_large_case(): assert can_cover_grid(10, [10, 20, 30, 40]) == \\"YES\\" assert can_cover_grid(10, [10, 20, 30]) == \\"NO\\" def test_can_cover_grid_multiple_tile_types(): assert can_cover_grid(4, [4, 4, 4, 4]) == \\"YES\\" assert can_cover_grid(2, [1, 1, 2]) == \\"YES\\" assert can_cover_grid(2, [1, 1, 3]) == \\"NO\\"","solution":"def can_cover_grid(n, tile_counts): Determine if it is possible to cover an n x n grid using the given tiles exactly. :param n: int -- size of the grid (n x n) :param tile_counts: list -- number of tiles available for each terrain type :return: str -- \\"YES\\" if it's possible to cover the grid exactly, otherwise \\"NO\\" total_tiles_needed = n * n total_tiles_available = sum(tile_counts) if total_tiles_needed == total_tiles_available: return \\"YES\\" else: return \\"NO\\""},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseList(head): Reverses a singly linked list in-place. Args: head (ListNode): Head of the singly linked list. Returns: ListNode: New head of the reversed singly linked list. # Implementation needed import pytest def list_to_array(head): Helper method to convert linked list to array for testing arr = [] while head: arr.append(head.val) head = head.next return arr def array_to_list(arr): Helper method to convert array to linked list for testing if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head def test_reverseList_single_element(): head = array_to_list([1]) new_head = reverseList(head) assert list_to_array(new_head) == [1] def test_reverseList_two_elements(): head = array_to_list([1, 2]) new_head = reverseList(head) assert list_to_array(new_head) == [2, 1] def test_reverseList_multiple_elements(): head = array_to_list([1, 2, 3, 4]) new_head = reverseList(head) assert list_to_array(new_head) == [4, 3, 2, 1] def test_reverseList_empty(): head = array_to_list([]) new_head = reverseList(head) assert list_to_array(new_head) == [] def test_reverseList_large_input(): head = array_to_list(list(range(1, 100001))) new_head = reverseList(head) assert list_to_array(new_head) == list(range(100000, 0, -1)) # Run the tests if __name__ == \\"__main__\\": pytest.main()","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseList(head): Reverses a singly linked list in-place. Args: head (ListNode): Head of the singly linked list. Returns: ListNode: New head of the reversed singly linked list. prev = None current = head while current: next_temp = current.next # store next node current.next = prev # reverse the link prev = current # move prev to current current = next_temp # move to next node return prev"},{"question":"import math def max_coins(L: float, W: float, D: float) -> int: Returns the maximum number of coins of diameter D that can be placed in a drawer of dimensions L by W. >>> max_coins(5.0, 3.0, 1.0) 15 >>> max_coins(4.0, 4.0, 1.0) 16 >>> max_coins(4.5, 3.7, 1.0) 12 >>> max_coins(10.0, 10.0, 5.0) 4 >>> max_coins(7.0, 7.0, 2.0) 9","solution":"import math def max_coins(L, W, D): Returns the maximum number of coins of diameter D that can be placed in a drawer of dimensions L by W. coins_in_length = math.floor(L / D) coins_in_width = math.floor(W / D) return coins_in_length * coins_in_width"},{"question":"from typing import List, Tuple def shortest_path_through_node(n: int, e: int, s: int, t: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the shortest path passing through a specific node in a directed graph. :param n: Number of nodes in the graph :param e: Number of edges in the graph :param s: Start node :param t: End node :param m: Required node that must be part of the path :param edges: List of edges where each edge is represented as a tuple (u, v, w) with u as the source node, v as the destination node, and w as the travel time :return: The total travel time of the shortest path from start node to end node passing through the required node. Returns -1 if no such path exists. >>> shortest_path_through_node(5, 7, 0, 4, 2, [(0, 1, 10), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 8), (2, 4, 5), (3, 4, 2)]) 8 >>> shortest_path_through_node(4, 3, 0, 3, 2, [(0, 1, 10), (1, 3, 5), (0, 3, 100)]) -1 >>> shortest_path_through_node(3, 3, 0, 2, 1, [(0, 1, 5), (1, 2, 10), (0, 2, 20)]) 15 >>> shortest_path_through_node(5, 5, 0, 4, 3, [(0, 1, 2), (1, 2, 4), (2, 3, 1), (3, 4, 3), (0, 4, 10)]) 10","solution":"import heapq def dijkstra(graph, start, n): dist = [float('inf')] * n dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, node = heapq.heappop(priority_queue) if current_dist > dist[node]: continue for neighbor, weight in graph[node]: new_dist = current_dist + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist heapq.heappush(priority_queue, (new_dist, neighbor)) return dist def shortest_path_through_node(n, e, s, t, m, edges): graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) dist_from_start = dijkstra(graph, s, n) dist_from_m = dijkstra(graph, m, n) if dist_from_start[m] == float('inf') or dist_from_m[t] == float('inf'): return -1 return dist_from_start[m] + dist_from_m[t] # Sample input parsing def main(): import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]); idx += 1 e = int(data[idx]); idx += 1 s = int(data[idx]); idx += 1 t = int(data[idx]); idx += 1 m = int(data[idx]); idx += 1 edges = [] for _ in range(e): u = int(data[idx]); idx += 1 v = int(data[idx]); idx += 1 w = int(data[idx]); idx += 1 edges.append((u, v, w)) print(shortest_path_through_node(n, e, s, t, m, edges)) if __name__ == '__main__': main()"},{"question":"def closest_quality_difference(n: int, target: int, qualities: List[int]) -> int: Returns the closest absolute difference between any two valid pairs of jeans and the given target. :param n: Number of qualities :param target: Target difference :param qualities: List of qualities of the jeans :return: Smallest absolute difference from the target >>> closest_quality_difference(5, 10, [3, 8, 15, 1, 10]) 1 >>> closest_quality_difference(4, 7, [3, 10, 5, 12]) 0 >>> closest_quality_difference(6, 5, [1, 2, 3, 9, 10, 11]) 1 >>> closest_quality_difference(1, 5, [5]) inf >>> closest_quality_difference(3, 50000, [1, 100000, 50000]) 0","solution":"def closest_quality_difference(n, target, qualities): Returns the closest absolute difference between any two valid pairs of jeans and the given target. :param n: Number of qualities :param target: Target difference :param qualities: List of qualities of the jeans :return: Smallest absolute difference from the target # Sorting the qualities to make comparisons easier qualities.sort() closest_diff = float('inf') for i in range(n): for j in range(i+1, n): diff = qualities[j] - qualities[i] current_diff = abs(diff - target) if current_diff < closest_diff: closest_diff = current_diff return closest_diff"},{"question":"def min_window_substr_len(S: str, T: str) -> int: Returns the length of the shortest substring in S that contains all characters of T. If no such substring exists, return -1. >>> min_window_substr_len(\\"adobecodebanc\\", \\"abc\\") 4 >>> min_window_substr_len(\\"a\\", \\"aa\\") -1 from collections import Counter def test_min_window_substr_len_sample1(): assert min_window_substr_len(\\"adobecodebanc\\", \\"abc\\") == 4 def test_min_window_substr_len_sample2(): assert min_window_substr_len(\\"a\\", \\"aa\\") == -1 def test_min_window_substr_len_no_match(): assert min_window_substr_len(\\"abcdef\\", \\"xyz\\") == -1 def test_min_window_substr_len_full_match(): assert min_window_substr_len(\\"aaaaaa\\", \\"aaa\\") == 3 def test_min_window_substr_len_exact_match(): assert min_window_substr_len(\\"abcde\\", \\"abcde\\") == 5 def test_min_window_substr_len_repeated_chars(): assert min_window_substr_len(\\"abbcac\\", \\"abc\\") == 3 def test_min_window_substr_len_single_char(): assert min_window_substr_len(\\"a\\", \\"a\\") == 1 def test_min_window_substr_len_incl_duplicates(): assert min_window_substr_len(\\"abacbab\\", \\"aba\\") == 3","solution":"from collections import Counter def min_window_substr_len(S, T): Returns the length of the shortest substring in S that contains all characters of T. If no such substring exists, returns -1. if not S or not T or len(S) < len(T): return -1 count_T = Counter(T) count_window = {} left = 0 min_len = float('inf') formed = 0 required = len(count_T) for right in range(len(S)): char = S[right] count_window[char] = count_window.get(char, 0) + 1 if char in count_T and count_window[char] == count_T[char]: formed += 1 while left <= right and formed == required: char = S[left] min_len = min(min_len, right - left + 1) count_window[char] -= 1 if char in count_T and count_window[char] < count_T[char]: formed -= 1 left += 1 return min_len if min_len != float('inf') else -1"},{"question":"def min_direct_communications(n, k): This function calculates the minimum number of direct communications required such that every device in a network can communicate with every other device either directly or indirectly. Parameters: n (int): Number of devices k (int): Maximum ID difference for direct communication Returns: int: Minimum number of direct communications required Examples: >>> min_direct_communications(4, 1) 3 >>> min_direct_communications(5, 2) 3","solution":"def min_direct_communications(n, k): This function calculates the minimum number of direct communications required such that every device in a network can communicate with every other device either directly or indirectly. Parameters: n (int): Number of devices k (int): Maximum ID difference for direct communication Returns: int: Minimum number of direct communications required return max(0, n - k)"},{"question":"from math import comb def count_flower_distributions(m: int, n: int) -> int: Returns the number of distinct ways to distribute n flowers in m flower beds, such that each flower bed contains at least one flower. >>> count_flower_distributions(4, 10) 84 >>> count_flower_distributions(1, 1) 1 >>> count_flower_distributions(5, 5) 1 >>> count_flower_distributions(5, 15) 1001 >>> count_flower_distributions(10, 20) 92378 >>> count_flower_distributions(3, 4) 3 def test_example_case(): assert count_flower_distributions(4, 10) == 84 def test_minimum_edge_case(): assert count_flower_distributions(1, 1) == 1 def test_equal_flowers_and_beds(): assert count_flower_distributions(5, 5) == 1 def test_large_number_of_flowers(): assert count_flower_distributions(5, 15) == 1001 def test_large_number_of_beds(): assert count_flower_distributions(10, 20) == 92378 def test_flowers_just_above_beds(): assert count_flower_distributions(3, 4) == 3","solution":"from math import comb def count_flower_distributions(m, n): Returns the number of distinct ways to distribute n flowers in m flower beds, such that each flower bed contains at least one flower. This can be calculated using the stars and bars method: comb(n-1, m-1) return comb(n-1, m-1)"},{"question":"def three_sum_zero(nums): Determine if there exist three distinct elements in the list that sum up to zero. :param nums: List of integers :return: \\"YES\\" or \\"NO\\" >>> three_sum_zero([-1, 2, 1, -4, 2]) 'YES' >>> three_sum_zero([1, 2, 3, 4]) 'NO' >>> three_sum_zero([0, 0, 0, 0, 0, 0]) 'YES' >>> three_sum_zero([-1, -1, 2, 3]) 'YES' >>> three_sum_zero([5, 1, 2, 7, 9]) 'NO' >>> three_sum_zero([1, 2, -3, 2, -1, -2]) 'YES' >>> three_sum_zero([-100000, 50000, 50000, 100000, -50000]) 'YES'","solution":"def three_sum_zero(nums): Determine if there exist three distinct elements in the list that sum up to zero. :param nums: List of integers :return: \\"YES\\" or \\"NO\\" nums.sort() n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, n-1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: return \\"YES\\" elif total < 0: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def find_two_unique_numbers(arr): This function finds the two unique numbers in an array where each number except two appear twice. >>> find_two_unique_numbers([1, 2, 1, 3, 2, 4]) (3, 4) >>> find_two_unique_numbers([4, 1, 2, 1, 3, 2]) (3, 4) >>> find_two_unique_numbers([1, -2, 1, 3, -2, 4]) (3, 4) >>> find_two_unique_numbers([-1, 2, -1, 3, 2, -4]) (3, -4) >>> find_two_unique_numbers([100, 333]) (100, 333) >>> find_two_unique_numbers([i for i in range(1, 50001)] * 2 + [50001, 50002]) (50001, 50002)","solution":"def find_two_unique_numbers(arr): This function finds the two unique numbers in an array where each number except two appear twice. # XOR of all elements will give us XOR of the two unique numbers xor = 0 for num in arr: xor ^= num # Find rightmost set bit in xor set_bit = xor & -xor # Divide elements into two sets by comparing rightmost set bit of xor with the bit at the same position in each element x = 0 y = 0 for num in arr: if num & set_bit: x ^= num else: y ^= num return x, y"},{"question":"def determine_best_house(n: int, scores: List[Tuple[str, int, int]]) -> List[str]: Determine and output the house that has the highest median score for each subject. Houses: 'G' for Gryffindor 'H' for Hufflepuff 'R' for Ravenclaw 'S' for Slytherin Example: >>> determine_best_house(8, [('G', 0, 90), ('H', 0, 85), ('R', 0, 88), ('S', 0, 91), ('G', 1, 77), ('H', 1, 93), ('R', 1, 89), ('S', 1, 84)]) [\\"S\\", \\"H\\"] >>> determine_best_house(6, [('G', 0, 60), ('H', 0, 55), ('R', 0, 62), ('S', 0, 64), ('G', 1, 70), ('H', 1, 72)]) [\\"S\\", \\"H\\"]","solution":"def determine_best_house(n, scores): from collections import defaultdict import statistics houses = {'G': 'Gryffindor', 'H': 'Hufflepuff', 'R': 'Ravenclaw', 'S': 'Slytherin'} house_scores = defaultdict(lambda: defaultdict(list)) # Parsing all scores into a dictionary for house, subject, score in scores: house_scores[subject][house].append(score) result = [] # Determine the best house based on median score for each subject for subject in sorted(house_scores.keys()): best_house = None best_median = float('-inf') for house in sorted(houses.keys()): # sorting to handle alphabetical order in case of tie if house in house_scores[subject]: median_score = statistics.median(house_scores[subject][house]) if median_score > best_median or (median_score == best_median and (best_house is None or house < best_house)): best_median = median_score best_house = house result.append(best_house) return result"},{"question":"def subarray_sum(nums, target): Determine if there exists a continuous subarray that sums to the target integer. Args: nums (List[int]): List of integers. target (int): The target sum. Returns: bool: True if such a subarray exists, False otherwise. >>> subarray_sum([1, 2, 3, 4, 5], 9) True >>> subarray_sum([1, 2, 3, 4, 5], 20) False >>> subarray_sum([-1, 2, 9, -7, 3, 1], 4) True >>> subarray_sum([1, -1, 3, 1, 2], 3) True >>> subarray_sum([1,2,3], 0) False >>> subarray_sum([-1, -1, 1, 1], 0) True >>> subarray_sum([], 1) False >>> subarray_sum([1], 1) True >>> subarray_sum([1], 0) False >>> subarray_sum([0, 0, 0, 0], 0) True","solution":"def subarray_sum(nums, target): Returns True if there exists a continuous subarray that sums to the target, otherwise False. curr_sum = 0 sum_map = {0: -1} # To handle cases where the subarray starts from index 0 for i, num in enumerate(nums): curr_sum += num if (curr_sum - target) in sum_map: return True sum_map[curr_sum] = i return False"},{"question":"def is_path_exists(matrix, N, M): Determine if there exists a path from the top-left corner to the bottom-right corner of the matrix. >>> is_path_exists([ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ], 3, 3) \\"YES\\" >>> is_path_exists([ ... ['.', '#', '.'], ... ['#', '#', '.'], ... ['.', '.', '.'] ... ], 3, 3) \\"NO\\" def process_test_cases(test_cases): Process multiple test cases to determine if there exists a path from the top-left corner to the bottom-right corner of the matrix. >>> process_test_cases([ ... {'N': 3, 'M': 3, 'matrix': [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]}, ... {'N': 3, 'M': 3, 'matrix': [ ... ['.', '#', '.'], ... ['#', '#', '.'], ... ['.', '.', '.'] ... ]} ... ]) [\\"YES\\", \\"NO\\"]","solution":"def is_path_exists(matrix, N, M): if matrix[0][0] == '#' or matrix[N-1][M-1] == '#': return \\"NO\\" def dfs(x, y): if x == N-1 and y == M-1: return True if x < 0 or y < 0 or x >= N or y >= M or matrix[x][y] == '#': return False matrix[x][y] = '#' # Mark as visited by converting to the obstacle # check right and down for possible paths if dfs(x+1, y) or dfs(x, y+1): return True return False return \\"YES\\" if dfs(0, 0) else \\"NO\\" def process_test_cases(test_cases): results = [] for case in test_cases: N, M, matrix = case['N'], case['M'], case['matrix'] results.append(is_path_exists(matrix, N, M)) return results"},{"question":"def unique_pairs_with_sum(arr, target): Finds the number of unique pairs in the array whose sum equals the given target. :param arr: List[int] - The array of integers. :param target: int - The target sum. :return: int - The number of unique pairs that sum up to the target. >>> unique_pairs_with_sum([1, 5, 7, -1, 5], 6) 2 >>> unique_pairs_with_sum([1, 1, 1, 1], 2) 1 >>> unique_pairs_with_sum([1, 2, 3, 4, 5], 10) 0 >>> unique_pairs_with_sum([1], 2) 0 >>> unique_pairs_with_sum([100000, -50000, 25000, 75000], 100000) 1","solution":"def unique_pairs_with_sum(arr, target): Finds the number of unique pairs in the array whose sum equals the given target. :param arr: List[int] - The array of integers. :param target: int - The target sum. :return: int - The number of unique pairs that sum up to the target. seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return len(pairs)"},{"question":"def minimize_difference(N: int, A: List[int]) -> int: Divide the array into two non-empty parts such that the absolute difference between their sums is minimized and return this minimum possible absolute difference. Args: N : int : Number of integers in the array A : List[int] : List of integers in the array Returns: int : Minimum possible absolute difference between the sums of the two parts Examples: >>> minimize_difference(5, [1, 2, 3, 4, 5]) 1 >>> minimize_difference(4, [8, 4, 5, 8]) 1 >>> minimize_difference(3, [3, 1, 2]) 0","solution":"def minimize_difference(N, A): Returns the minimum possible absolute difference between the sums of two non-empty parts of the array A. total_sum = sum(A) half = total_sum // 2 dp = [False] * (half + 1) dp[0] = True for num in A: for j in range(half, num - 1, -1): dp[j] |= dp[j - num] for i in range(half, -1, -1): if dp[i]: sum1 = i break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"from typing import List def find_majority_element(nums: List[int]) -> int: Finds the majority element in the array which appears more than n/2 times. >>> find_majority_element([3, 2, 3]) 3 >>> find_majority_element([1, 2, 3, 2, 2, 2, 2]) 2 >>> find_majority_element([1]) 1 >>> find_majority_element([4, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([5, 1, 5, 2, 5, 3, 5, 4, 5]) 5","solution":"from typing import List def find_majority_element(nums: List[int]) -> int: Finds the majority element in the array which appears more than n/2 times. candidate = None count = 0 for num in nums: if count == 0: candidate = num if num == candidate: count += 1 else: count -= 1 return candidate"},{"question":"def max_product_subarray(nums): Returns the maximum product of any continuous subarray of the given array. >>> max_product_subarray([2, 3, -2, 4, -1]) 48 >>> max_product_subarray([5]) 5 >>> max_product_subarray([-5]) -5 >>> max_product_subarray([0, 0, 0, 0]) 0 >>> max_product_subarray([1, 2, 3, 4, 5]) 120 >>> max_product_subarray([-1, -2, -3, -4, -5]) 120 >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([2, 3, 0, -2, 4, -1]) 8 >>> max_product_subarray([-2, 0, -1]) 0","solution":"def max_product_subarray(nums): Returns the maximum product of any continuous subarray of the given array. max_product = float('-inf') current_max, current_min = 1, 1 for num in nums: if num == 0: current_max, current_min = 1, 1 max_product = max(max_product, 0) else: temp = current_max * num current_max = max(num * current_max, num * current_min, num) current_min = min(temp, num * current_min, num) max_product = max(max_product, current_max) return max_product"},{"question":"from typing import List def trap_water(heights: List[int]) -> int: Calculate the total volume of water that will be trapped between the buildings after the rain. >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_water([4,2,0,3,2,5]) 9 >>> trap_water([2,0,2]) 2 from solution import trap_water def test_trap_water_example_1(): assert trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_water_example_2(): assert trap_water([4,2,0,3,2,5]) == 9 def test_trap_water_example_3(): assert trap_water([2,0,2]) == 2 def test_trap_water_no_building(): assert trap_water([]) == 0 def test_trap_water_flat_surface(): assert trap_water([1,1,1,1]) == 0 def test_trap_water_single_building(): assert trap_water([1]) == 0 def test_trap_water_two_buildings(): assert trap_water([2,1]) == 0 def test_trap_water_mixed_height(): assert trap_water([3,1,2,1,2,1,5]) == 8","solution":"from typing import List def trap_water(heights: List[int]) -> int: if not heights or len(heights) <= 2: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def generate_spiral_matrix(m: int): Generate an m x m 2D spiral matrix. >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(0) []","solution":"def generate_spiral_matrix(m): Generate an m x m 2D spiral matrix. if m <= 0: return [] matrix = [[0] * m for _ in range(m)] num = 1 left, right, top, bottom = 0, m - 1, 0, m - 1 while left <= right and top <= bottom: # Traverse from left to right along top row for col in range(left, right + 1): matrix[top][col] = num num += 1 top += 1 # Traverse from top to bottom along rightmost column for row in range(top, bottom + 1): matrix[row][right] = num num += 1 right -= 1 if top <= bottom: # Traverse from right to left along bottom row for col in range(right, left - 1, -1): matrix[bottom][col] = num num += 1 bottom -= 1 if left <= right: # Traverse from bottom to top along leftmost column for row in range(bottom, top - 1, -1): matrix[row][left] = num num += 1 left += 1 return matrix"},{"question":"def find_array(n: int, query_function) -> List[int]: Find the array elements with minimum queries and output the entire array. The function takes in an integer n, the number of elements in the array, and a query_function which simulates the interaction by returning the value at the specified index. Parameters: n (int): The number of elements in the array. query_function (func): A function that simulates the query interaction. Returns: List[int]: The entire array found through queries. >>> def mock_query_function(queries, expected_responses): ... response_map = {query: response for query, response in zip(queries, expected_responses)} ... def query_fn(query): ... return response_map[query] ... return query_fn ... >>> queries = [f\\"? {i}\\" for i in range(1, 6)] >>> expected_responses = [3, 5, 8, 12, 15] >>> query_fn = mock_query_function(queries, expected_responses) >>> find_array(5, query_fn) [3, 5, 8, 12, 15]","solution":"def find_array(n, query_function): array = [] for i in range(1, n + 1): query = f\\"? {i}\\" val = query_function(query) array.append(val) # Output the final array result = \\" \\".join(map(str, array)) print(f\\"! {result}\\") return array"},{"question":"def minimize_difficulty_difference(n: int, k: int, difficulties: List[int]) -> int: Returns the minimized difference between the highest and lowest difficulty levels among the chosen k problems. Args: n (int): Total number of problems. k (int): Number of problems to select. difficulties (List[int]): List of difficulty levels for each problem. Returns: int: The minimized difficulty difference between the selected k problems. >>> minimize_difficulty_difference(5, 3, [10, 12, 15, 20, 25]) 5 >>> minimize_difficulty_difference(1, 1, [100]) 0","solution":"def minimize_difficulty_difference(n, k, difficulties): Returns the minimized difference between the highest and lowest difficulty levels among the chosen k problems. # Sort the difficulty levels difficulties.sort() # Initialize the minimum difference to a large number min_difference = float('inf') # Iterate through the sorted list and find the minimum difference for k problems for i in range(n - k + 1): difference = difficulties[i + k - 1] - difficulties[i] if difference < min_difference: min_difference = difference return min_difference"},{"question":"def min_platforms(trains): Returns the minimum number of platforms required for the given schedule of trains. :param trains: List of tuples where each tuple represents arrival and departure time in \\"HH:MM\\" format :type trains: List[Tuple[str, str]] :return: Minimum number of platforms required :rtype: int >>> min_platforms([(\\"09:00\\", \\"09:10\\"), (\\"09:40\\", \\"12:00\\"), (\\"09:50\\", \\"11:20\\"), (\\"11:00\\", \\"11:30\\"), (\\"15:00\\", \\"19:00\\"), (\\"18:00\\", \\"19:30\\")]) 3 >>> min_platforms([(\\"10:00\\", \\"10:30\\"), (\\"10:20\\", \\"10:40\\"), (\\"10:30\\", \\"10:50\\")]) 2 >>> min_platforms([(\\"10:00\\", \\"10:30\\")]) 1 >>> min_platforms([(\\"10:00\\", \\"10:30\\"), (\\"10:00\\", \\"10:30\\"), (\\"10:00\\", \\"10:30\\")]) 3 >>> min_platforms([(\\"10:00\\", \\"10:30\\"), (\\"11:00\\", \\"11:30\\"), (\\"12:00\\", \\"12:30\\")]) 1 >>> min_platforms([(\\"09:15\\", \\"10:00\\"), (\\"09:45\\", \\"11:00\\"), (\\"10:00\\", \\"10:45\\"), (\\"11:00\\", \\"12:15\\")]) 2 # Implementation","solution":"def min_platforms(trains): Returns the minimum number of platforms required for the given schedule of trains. :param trains: List of tuples where each tuple represents arrival and departure time in \\"HH:MM\\" format :type trains: List[Tuple[str, str]] :return: Minimum number of platforms required :rtype: int from datetime import datetime # Convert the time strings to datetime objects for easy comparison arrivals = [datetime.strptime(train[0], \\"%H:%M\\") for train in trains] departures = [datetime.strptime(train[1], \\"%H:%M\\") for train in trains] # Sort the arrival and departure times arrivals.sort() departures.sort() platform_needed = 0 max_platforms = 0 i = 0 j = 0 n = len(trains) # Loop through all the train timings while i < n and j < n: # If a train arrives before the last departure, we need a new platform if arrivals[i] < departures[j]: platform_needed += 1 i += 1 if platform_needed > max_platforms: max_platforms = platform_needed else: # If a train departs, we can free up a platform platform_needed -= 1 j += 1 return max_platforms"},{"question":"def word_count(sentence: str) -> dict: Returns a dictionary mapping each unique word to the number of times it appears in the sentence. Words should be considered case-insensitively and punctuation should be ignored. >>> word_count(\\"Hello, world! Hello, Developer.\\") == {\\"hello\\": 2, \\"world\\": 1, \\"developer\\": 1}","solution":"import re from collections import defaultdict def word_count(sentence): Returns a dictionary mapping each unique word to the number of times it appears in the sentence. Words are considered case-insensitively and punctuation is ignored. # Convert to lowercase sentence = sentence.lower() # Remove punctuation using regex sentence = re.sub(r'[,.!?]', '', sentence) # Split the sentence into words words = sentence.split() # Create a defaultdict to count words word_counts = defaultdict(int) # Count each word for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"def count_peak_time_slots(T: int, A: List[int]) -> int: Counts the number of peak time slots given the total number of slots T and login attempts array A. A time slot is considered a peak if it has more login attempts than the slot before and after it. :param T: int : Total number of time slots :param A: list of int : List containing login attempts at each time slot :return: int : The number of peak time slots >>> count_peak_time_slots(5, [1, 3, 2, 4, 2]) == 2 >>> count_peak_time_slots(5, [1, 2, 2, 2, 1]) == 0 >>> count_peak_time_slots(5, [1, 2, 3, 2, 1]) == 1 >>> count_peak_time_slots(7, [0, 2, 1, 3, 1, 2, 0]) == 3 >>> count_peak_time_slots(4, [5, 5, 5, 5]) == 0 >>> count_peak_time_slots(3, [1, 2, 1]) == 1","solution":"def count_peak_time_slots(T, A): Counts the number of peak time slots given the total number of slots T and login attempts array A. A time slot is considered a peak if it has more login attempts than the slot before and after it. :param T: int : Total number of time slots :param A: list of int : List containing login attempts at each time slot :return: int : The number of peak time slots peak_count = 0 for i in range(1, T - 1): if A[i] > A[i - 1] and A[i] > A[i + 1]: peak_count += 1 return peak_count"},{"question":"def knight_tour(n: int, k: int, x: int, y: int) -> str: Determines if the knight can travel to every square on the board within k moves. Args: n: Size of the chessboard (n x n). k: Number of allowable moves. x: Starting position's x-coordinate. y: Starting position's y-coordinate. Returns: \\"possible\\" if the knight can visit every square within k moves, otherwise \\"impossible\\". Examples: >>> knight_tour(5, 32, 1, 1) \\"possible\\" >>> knight_tour(5, 10, 1, 1) \\"impossible\\"","solution":"def knight_tour(n, k, x, y): Determines if the knight can travel to every square on the board within k moves. Args: n: Size of the chessboard (n x n). k: Number of allowable moves. x: Starting position's x-coordinate. y: Starting position's y-coordinate. Returns: \\"possible\\" if the knight can visit every square within k moves, otherwise \\"impossible\\". def is_inside_board(x, y): return 1 <= x <= n and 1 <= y <= n def backtrack(x, y, visited, move_count): if move_count > k: return False if len(visited) == n * n: return True moves = [ (x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1), (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2) ] for nx, ny in moves: if is_inside_board(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) if backtrack(nx, ny, visited, move_count + 1): return True visited.remove((nx, ny)) return False starting_pos = (x, y) visited = {starting_pos} if backtrack(x, y, visited, 0): return \\"possible\\" else: return \\"impossible\\""},{"question":"def is_non_decreasing_when_reversed(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if reversing a list of integers forms a non-decreasing sequence for each test case. >>> is_non_decreasing_when_reversed(2, [(4, [1, 2, 3, 4]), (5, [5, 4, 3, 3, 2])]) [\\"NO\\", \\"YES\\"] >>> is_non_decreasing_when_reversed(1, [(1, [5])]) [\\"YES\\"] def process_input(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Processes the input data and returns the number of test cases and the test cases themselves. >>> process_input(\\"2n4n1 2 3 4n5n5 4 3 3 2\\") (2, [(4, [1, 2, 3, 4]), (5, [5, 4, 3, 3, 2])]) def test_is_non_decreasing_when_reversed(): input_data = 2 4 1 2 3 4 5 5 4 3 3 2 t, test_cases = process_input(input_data) results = is_non_decreasing_when_reversed(t, test_cases) expected_results = [\\"NO\\", \\"YES\\"] assert results == expected_results def test_single_element(): input_data = 1 1 5 t, test_cases = process_input(input_data) results = is_non_decreasing_when_reversed(t, test_cases) expected_results = [\\"YES\\"] assert results == expected_results def test_already_non_decreasing(): input_data = 1 3 3 2 1 t, test_cases = process_input(input_data) results = is_non_decreasing_when_reversed(t, test_cases) expected_results = [\\"YES\\"] assert results == expected_results def test_mixed_elements(): input_data = 1 4 1 3 2 4 t, test_cases = process_input(input_data) results = is_non_decreasing_when_reversed(t, test_cases) expected_results = [\\"NO\\"] assert results == expected_results def test_large_input(): input_data = \\"1n100000n\\" + \\" \\".join(map(str, range(100000, 0, -1))) t, test_cases = process_input(input_data) results = is_non_decreasing_when_reversed(t, test_cases) expected_results = [\\"YES\\"] assert results == expected_results","solution":"def is_non_decreasing_when_reversed(t, test_cases): results = [] for case in test_cases: n, lst = case # Reverse the list reversed_lst = lst[::-1] # Check if it is non-decreasing is_non_decreasing = all(reversed_lst[i] <= reversed_lst[i + 1] for i in range(n - 1)) if is_non_decreasing: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] current_line = 1 for _ in range(t): n = int(lines[current_line]) lst = list(map(int, lines[current_line + 1].split())) test_cases.append((n, lst)) current_line += 2 return t, test_cases"},{"question":"def max_sum_of_k_adjacent_elements(n: int, k: int, arr: List[int]) -> int: Returns the maximum possible sum of k adjacent elements in the array. >>> max_sum_of_k_adjacent_elements(5, 2, [1, 2, 3, 4, 5]) == 9 >>> max_sum_of_k_adjacent_elements(8, 3, [-1, -2, 3, 4, -5, 6, 7, 8]) == 21","solution":"def max_sum_of_k_adjacent_elements(n, k, arr): Returns the maximum possible sum of k adjacent elements in the array. Parameters: n (int): The length of the array. k (int): The number of adjacent elements to consider. arr (list): The list of integers. Returns: int: The maximum sum of k adjacent elements. if n == 0 or k > n: return 0 # Initializing the sum of the first 'k' elements max_sum = current_sum = sum(arr[:k]) # Sliding over the rest of the elements for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string s. >>> count_distinct_substrings(\\"abc\\") == 6 >>> count_distinct_substrings(\\"aaa\\") == 3","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of the given string s. substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def are_elements_distinct(n, arr): Determines if all elements in the list arr are distinct. Outputs \\"YES\\" if all elements are distinct, otherwise \\"NO\\". >>> are_elements_distinct(5, [1, 2, 3, 4, 5]) == \\"YES\\" >>> are_elements_distinct(4, [1, 2, 2, 3]) == \\"NO\\"","solution":"def are_elements_distinct(n, arr): Determines if all elements in the list arr are distinct. Outputs \\"YES\\" if all elements are distinct, otherwise \\"NO\\". if len(arr) != n: raise ValueError(\\"Length of array does not match provided N\\") return \\"YES\\" if len(set(arr)) == n else \\"NO\\""},{"question":"from typing import List def four_sum(L: List[int], target: int) -> List[List[int]]: Given a list of integers L sorted in ascending order and an integer T, find all unique quadruplets (a, b, c, d) in L such that a + b + c + d = T. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] # Unit Tests def test_example_1(): assert sorted(four_sum([1, 0, -1, 0, -2, 2], 0)) == sorted([[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]) def test_example_2(): assert four_sum([2, 2, 2, 2, 2], 8) == [[2, 2, 2, 2]] def test_no_quadruplets(): assert four_sum([1, 2, 3, 4], 100) == [] def test_all_negative_numbers(): assert sorted(four_sum([-5, -4, -3, -2, -1], -10)) == sorted([[-4, -3, -2, -1]]) def test_mixed_sign_numbers(): assert sorted(four_sum([-1, 2, 2, -5, 0, -1, 4], 3)) == sorted([[-5, 2, 2, 4], [-1, 0, 2, 2]]) def test_duplicate_quadruplets(): assert sorted(four_sum([1, 1, 1, 1, 1, 1, 1, 1], 4)) == [[1, 1, 1, 1]]","solution":"def four_sum(L, target): Returns a list of all unique quadruplets (a, b, c, d) in L where a + b + c + d = target. L.sort() quadruplets = [] n = len(L) for i in range(n - 3): if i > 0 and L[i] == L[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and L[j] == L[j - 1]: continue left = j + 1 right = n - 1 while left < right: total = L[i] + L[j] + L[left] + L[right] if total == target: quadruplets.append([L[i], L[j], L[left], L[right]]) while left < right and L[left] == L[left + 1]: left += 1 while left < right and L[right] == L[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def max_population_in_date_range(observations, start_date, end_date): Returns the maximum plant population recorded in each region within the specified date range. :param observations: List of tuples containing (region_id, date, population) :param start_date: Start date of the range in format \\"YYYY-MM-DD\\" :param end_date: End date of the range in format \\"YYYY-MM-DD\\" :return: Dictionary with region IDs as keys and maximum population as values >>> observations = [ ... (1, \\"2022-01-15\\", 150), ... (2, \\"2022-01-16\\", 200), ... (1, \\"2022-02-10\\", 180), ... (2, \\"2022-02-15\\", 220), ... (1, \\"2022-03-05\\", 170) ... ] >>> start_date = \\"2022-01-01\\" >>> end_date = \\"2022-02-28\\" >>> max_population_in_date_range(observations, start_date, end_date) {1: 180, 2: 220} >>> observations = [ ... (1, \\"2021-01-15\\", 150), ... (2, \\"2021-01-16\\", 200), ... (1, \\"2021-02-10\\", 180) ... ] >>> start_date = \\"2022-01-01\\" >>> end_date = \\"2022-02-28\\" >>> max_population_in_date_range(observations, start_date, end_date) {} >>> observations = [ ... (1, \\"2022-01-15\\", 150), ... (1, \\"2022-01-16\\", 200), ... (1, \\"2022-01-17\\", 180) ... ] >>> start_date = \\"2022-01-01\\" >>> end_date = \\"2022-02-28\\" >>> max_population_in_date_range(observations, start_date, end_date) {1: 200} >>> observations = [ ... (1, \\"2022-01-15\\", 150), ... (2, \\"2022-01-16\\", 200), ... (1, \\"2022-01-16\\", 180) ... ] >>> start_date = \\"2022-01-16\\" >>> end_date = \\"2022-01-16\\" >>> max_population_in_date_range(observations, start_date, end_date) {2: 200, 1: 180}","solution":"from datetime import datetime def max_population_in_date_range(observations, start_date, end_date): Returns the maximum plant population recorded in each region within the specified date range. :param observations: List of tuples containing (region_id, date, population) :param start_date: Start date of the range in format \\"YYYY-MM-DD\\" :param end_date: End date of the range in format \\"YYYY-MM-DD\\" :return: Dictionary with region IDs as keys and maximum population as values start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") max_population = {} for region_id, date, population in observations: observation_date = datetime.strptime(date, \\"%Y-%m-%d\\") if start_date <= observation_date <= end_date: if region_id not in max_population: max_population[region_id] = population else: max_population[region_id] = max(max_population[region_id], population) return max_population"},{"question":"def unique_gift_bags(t, test_cases): Given the number of test cases and a list of list of treats per test case, returns a list with the number of unique gift bags possible for each test case. pass def process_input(input_string): Processes the input string into appropriate function inputs. pass # Example usage and test cases if __name__ == \\"__main__\\": input_string = 2 4 1 2 3 4 3 1 2 2 t, test_cases = process_input(input_string) result = unique_gift_bags(t, test_cases) print(result) # Expected output: [6, 1] input_string = 1 3 1 1 1 t, test_cases = process_input(input_string) result = unique_gift_bags(t, test_cases) print(result) # Expected output: [0] input_string = 1 5 1 2 3 4 5 t, test_cases = process_input(input_string) result = unique_gift_bags(t, test_cases) print(result) # Expected output: [10] input_string = 1 2 3 4 t, test_cases = process_input(input_string) result = unique_gift_bags(t, test_cases) print(result) # Expected output: [1] input_string = 2 2 1 2 3 4 4 5 t, test_cases = process_input(input_string) result = unique_gift_bags(t, test_cases) print(result) # Expected output: [1, 1]","solution":"def unique_gift_bags(t, test_cases): Given the number of test cases and a list of list of treats per test case, returns a list with the number of unique gift bags possible for each test case. results = [] for i in range(t): n, treats = test_cases[i] unique_treats = set(treats) count = len(unique_treats) if count < 2: results.append(0) else: # Using combinatorial formula nC2 = n * (n-1) / 2 for unique pairs results.append(count * (count - 1) // 2) return results # Auxiliary function to process input strings into appropriate function inputs def process_input(input_string): input_lines = input_string.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) treats = list(map(int, input_lines[index + 1].split())) test_cases.append((n, treats)) index += 2 return t, test_cases"},{"question":"def find_largest_in_matrix(n: int, matrix: List[List[int]]) -> int: Returns the largest integer in the given n x n matrix. >>> find_largest_in_matrix(3, [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ]) 5 >>> find_largest_in_matrix(2, [ [99, 100], [100, 101] ]) 101 >>> find_largest_in_matrix(4, [ [1, 1, 2, 2], [1, 2, 2, 3], [2, 3, 4, 4], [3, 3, 4, 5] ]) 5","solution":"def find_largest_in_matrix(n, matrix): Returns the largest integer in the given n x n matrix. max_value = float('-inf') for row in matrix: row_max = max(row) max_value = max(max_value, row_max) return max_value"},{"question":"class SegmentTree: def __init__(self, data): n = len(data) self.n = n self.tree = [0] * (2 * n) self.build(data) def build(self, data): n = self.n for i in range(n): self.tree[n + i] = data[i] for i in range(n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos >>= 1 self.tree[pos] = self.tree[pos << 1] + self.tree[pos << 1 | 1] def range_sum(self, l, r): res = 0 l += self.n r += self.n while l < r: if l & 1: res += self.tree[l] l += 1 if r & 1: r -= 1 res += self.tree[r] l >>= 1 r >>= 1 return res def process_operations(n, q, array, operations): Process operations on the array. Parameters: n (int): number of elements in the array. q (int): number of operations. array (List[int]): list of integers representing the array. operations (List[Tuple[int, int, int]]): list of operations to be performed on the array. Returns: List[int]: list of results for the sum operations. Example: >>> process_operations(5, 5, [1, 2, 3, 4, 5], [(2, 1, 5), (1, 3, 10), (2, 1, 3), (1, 5, 6), (2, 4, 5)]) [15, 13, 10]","solution":"class SegmentTree: def __init__(self, data): n = len(data) self.n = n self.tree = [0] * (2 * n) self.build(data) def build(self, data): n = self.n # Insert leaf nodes in tree for i in range(n): self.tree[n + i] = data[i] # Build the tree by calculating parents for i in range(n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def update(self, pos, value): # Update the value at position pos pos += self.n self.tree[pos] = value # Move upward and update parents while pos > 1: pos >>= 1 self.tree[pos] = self.tree[pos << 1] + self.tree[pos << 1 | 1] def range_sum(self, l, r): # Compute the sum in the range [l, r) res = 0 l += self.n r += self.n while l < r: if l & 1: res += self.tree[l] l += 1 if r & 1: r -= 1 res += self.tree[r] l >>= 1 r >>= 1 return res def process_operations(n, q, array, operations): seg_tree = SegmentTree(array) results = [] for op in operations: if op[0] == 1: _, x, y = op seg_tree.update(x - 1, y) # Convert to 0-based index elif op[0] == 2: _, l, r = op result = seg_tree.range_sum(l - 1, r) # Convert to 0-based index results.append(result) return results"},{"question":"class ATM: Simulates an ATM machine with deposit, withdraw, and balance functionalities. Actions: - deposit amount: Deposit a specified amount into the ATM. Print the number of each type of bill deposited. - withdraw amount: Withdraw a specified amount using the minimum number of bills. Print the number of each type of bill used for the withdrawal. - balance: Print the total amount of money currently in the ATM. >>> atm = ATM() >>> atm.deposit(205) Bills deposited: 50x4 5x1 >>> atm.get_balance() 205 >>> atm.withdraw(35) Bills used: 20x1 10x1 5x1 >>> atm.get_balance() 170 >>> atm.withdraw(50) Bills used: 50x1 def __init__(self): self.balance = 0 def deposit(self, amount): pass # Implement the deposit logic def withdraw(self, amount): pass # Implement the withdraw logic def get_balance(self): pass # Implement the get_balance logic","solution":"class ATM: def __init__(self): self.balance = 0 def deposit(self, amount): if amount % 5 != 0: raise ValueError(\\"Amount must be a multiple of 5\\") self.balance += amount bills = {50: 0, 20: 0, 10: 0, 5: 0} remaining = amount for bill in bills: while remaining >= bill: bills[bill] += 1 remaining -= bill deposit_details = \\"Bills deposited: \\" + \\" \\".join(f\\"{bill}x{count}\\" for bill, count in bills.items() if count > 0) print(deposit_details) def withdraw(self, amount): if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount bills = {50: 0, 20: 0, 10: 0, 5: 0} remaining = amount for bill in bills: while remaining >= bill: bills[bill] += 1 remaining -= bill withdraw_details = \\"Bills used: \\" + \\" \\".join(f\\"{bill}x{count}\\" for bill, count in bills.items() if count > 0) print(withdraw_details) def get_balance(self): print(self.balance) # Example usage flow (commented out when implement tests) # atm = ATM() # atm.deposit(205) # atm.get_balance() # atm.withdraw(35) # atm.get_balance() # atm.withdraw(50)"},{"question":"from typing import List, Union def find_majority_elements(n: int, elements: List[int]) -> Union[List[int], str]: Given an integer array of size \`n\`, determine which elements, if any, appear more than half the time (i.e., more than âŒŠn/2âŒ‹ times). If there is no such element, return \\"None\\". If there are multiple such elements, return all of them in ascending order. >>> find_majority_elements(7, [3, 3, 4, 2, 4, 4, 4]) [4] >>> find_majority_elements(5, [3, 1, 3, 2, 4]) 'None' >>> find_majority_elements(3, [1, 1, 2]) [1] >>> find_majority_elements(4, [2, 2, 2, 2]) [2] >>> find_majority_elements(0, []) 'None' >>> find_majority_elements(6, [2, 2, 2, 3, 3, 3]) 'None'","solution":"def find_majority_elements(n, elements): from collections import Counter element_count = Counter(elements) threshold = n // 2 majority_elements = [key for key, count in element_count.items() if count > threshold] if majority_elements: return sorted(majority_elements) else: return \\"None\\""},{"question":"from typing import List, Tuple, Union def find_unreachable_zones(Z: int, R: int, roads: List[Tuple[int, int]]) -> Union[str, List[int]]: A delivery company needs to optimize the delivery routes for their drivers. They have a certain number of delivery zones in the city, and each zone is connected to certain other zones via roads. A driver starts from a central hub located in zone number 1. The objective is to figure out which zones are unreachable from the central hub using the roads provided. Parameters: - Z: int - number of zones (1 â‰¤ Z â‰¤ 200000) - R: int - number of roads (1 â‰¤ R â‰¤ 200000) - roads: List[Tuple[int, int]] - list of roads, each road connects two different zones Returns: - Union[str, List[int]] - A sorted list of unreachable zones or the string \\"All Zones Accessible\\" if all zones are reachable Examples: >>> find_unreachable_zones(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"All Zones Accessible\\" >>> find_unreachable_zones(5, 3, [(1, 2), (2, 3), (3, 4)]) [5] >>> find_unreachable_zones(8, 5, [(1, 3), (2, 4), (5, 6), (7, 8), (3, 5)]) [2, 4, 7, 8]","solution":"def find_unreachable_zones(Z, R, roads): from collections import defaultdict, deque # Create a graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Use BFS to find all reachable zones from the central hub (zone 1) visited = set() queue = deque([1]) while queue: zone = queue.popleft() if zone not in visited: visited.add(zone) for neighbour in graph[zone]: if neighbour not in visited: queue.append(neighbour) # Find all zones that are not visited unreachable = sorted([zone for zone in range(1, Z+1) if zone not in visited]) if not unreachable: return \\"All Zones Accessible\\" else: return unreachable"},{"question":"def longest_consecutive_ones(N: int) -> int: Returns the length of the longest consecutive sequence of 1s in the binary representation of N. >>> longest_consecutive_ones(156) 3 >>> longest_consecutive_ones(0) 0 >>> longest_consecutive_ones(7) 3 >>> longest_consecutive_ones(15) 4 >>> longest_consecutive_ones(31) 5 >>> longest_consecutive_ones(10) 1 >>> longest_consecutive_ones(255) 8 >>> longest_consecutive_ones(1023) 10 >>> longest_consecutive_ones(170) 1","solution":"def longest_consecutive_ones(N): Returns the length of the longest consecutive sequence of 1s in the binary representation of N. # Convert N to binary representation and split by '0' # This gives us segments of consecutive '1's binary_representation = bin(N)[2:] segments_of_ones = binary_representation.split('0') # Find the length of the longest segment of '1's longest_sequence = max(segments_of_ones, key=len) return len(longest_sequence)"},{"question":"# Initial inventory setup items = [10, 5, 3, 8, 6] def vending_machine(slot: int, action: str) -> int: Function to simulate a vending machine. Parameters: slot (int): The slot number (0-4). action (str): The action to perform ('dispense' or 'count'). Returns: bool/int: True if dispensing was successful, False if not, item count if 'count', -1 for invalid slot. >>> vending_machine(1, 'dispense') == True >>> vending_machine(0, 'count') == 10 >>> vending_machine(3, 'dispense') == True >>> vending_machine(-1, 'dispense') == False >>> vending_machine(2, 'count') == 3","solution":"# Initial inventory setup items = [10, 5, 3, 8, 6] def vending_machine(slot, action): Function to simulate a vending machine. Parameters: slot (int): The slot number (0-4). action (str): The action to perform ('dispense' or 'count'). Returns: bool/int: True if dispensing was successful, False if not, item count if 'count', -1 for invalid slot. if slot < 0 or slot >= len(items): return False if action == 'dispense' else -1 if action == 'dispense': if items[slot] > 0: items[slot] -= 1 return True else: return False elif action == 'count': return items[slot] return False # If action is neither 'dispense' nor 'count'."},{"question":"def longest_common_prefix(strs: List[str]) -> str: Calculate the longest common prefix of a given list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"fluctuate\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) \\"inters\\" >>> longest_common_prefix([\\"throne\\", \\"throne\\"]) \\"throne\\" >>> longest_common_prefix([\\"throne\\", \\"dungeon\\"]) \\"\\" >>> longest_common_prefix([\\"a\\"]) \\"a\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"c\\", \\"c\\"]) \\"c\\" >>> longest_common_prefix([\\"reflower\\", \\"flow\\", \\"flight\\"]) \\"\\" >>> longest_common_prefix([\\"cir\\", \\"car\\"]) \\"c\\" >>> longest_common_prefix([\\"\\"]) \\"\\" >>> longest_common_prefix([\\"\\", \\"\\"]) \\"\\"","solution":"def longest_common_prefix(strs): Returns the longest common prefix from a list of strings. if not strs: return \\"\\" # The shortest string in the list shortest_str = min(strs, key=len) for i in range(len(shortest_str)): char = shortest_str[i] for string in strs: if string[i] != char: return shortest_str[:i] return shortest_str"},{"question":"def count_valid_strings(N): Returns the number of valid strings of length N. >>> count_valid_strings(1) == 2 >>> count_valid_strings(2) == 3 >>> count_valid_strings(3) == 5 >>> count_valid_strings(10) == 144 def solve_xoron_language(T, cases): Given the number of test cases T and a list of lengths of strings, returns a list of the number of valid strings for each length. >>> solve_xoron_language(1, [1]) == [2] >>> solve_xoron_language(1, [2]) == [3] >>> solve_xoron_language(3, [1, 2, 3]) == [2, 3, 5] >>> solve_xoron_language(2, [4, 5]) == [8, 13]","solution":"def count_valid_strings(N): Returns the number of valid strings of length N. if N == 1: return 2 if N == 2: return 3 # Use dynamic programming to find the count of valid strings of length N dp = [0] * (N + 1) dp[1] = 2 dp[2] = 3 for i in range(3, N + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[N] def solve_xoron_language(T, cases): results = [] for N in cases: results.append(count_valid_strings(N)) return results"},{"question":"def row_with_max_1s(matrix): Returns the index of the row with the maximum number of 1s. If there are multiple rows with the same number of maximum 1s, returns the index of the first such row. If the input is invalid, returns None. >>> row_with_max_1s([[0, 1, 1], [1, 1, 1], [0, 0, 0]]) == 1 >>> row_with_max_1s([[1, 0], [0, 1], [1, 1]]) == 2 >>> row_with_max_1s([[0, 0], [0, 0], [0, 0]]) == None >>> row_with_max_1s(\\"invalid\\") == None >>> row_with_max_1s([]) == None","solution":"def row_with_max_1s(matrix): Returns the index of the row with the maximum number of 1s. If there are multiple rows with the same number of maximum 1s, returns the index of the first such row. If the input is invalid, returns None. if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return None if not matrix: return None max_1s = -1 max_row_index = None for index, row in enumerate(matrix): if not all(cell in [0, 1] for cell in row): return None num_1s = sum(row) if num_1s > max_1s: max_1s = num_1s max_row_index = index return max_row_index if max_1s > 0 else None"},{"question":"def sort_binary_numbers(numbers): Sorts a list of binary number strings in ascending order based on their decimal values. Parameters: numbers (list of str): List of binary number strings. Returns: list of str: List of sorted binary number strings. pass def main(): # Read input n = int(input().strip()) binary_numbers = [input().strip() for _ in range(n)] # Get the sorted list sorted_binary_numbers = sort_binary_numbers(binary_numbers) # Print each sorted binary number on a new line for binary in sorted_binary_numbers: print(binary) if __name__ == \\"__main__\\": main()","solution":"def sort_binary_numbers(numbers): Sorts a list of binary number strings in ascending order based on their decimal values. Parameters: numbers (list of str): List of binary number strings. Returns: list of str: List of sorted binary number strings. # Convert binary strings to integers, sort the integers and finally convert back to binary strings sorted_numbers = sorted(numbers, key=lambda x: int(x, 2)) return sorted_numbers def main(): # Read input n = int(input().strip()) binary_numbers = [input().strip() for _ in range(n)] # Get the sorted list sorted_binary_numbers = sort_binary_numbers(binary_numbers) # Print each sorted binary number on a new line for binary in sorted_binary_numbers: print(binary) if __name__ == \\"__main__\\": main()"},{"question":"import math from typing import List def max_gcd_after_removal(n: int, arr: List[int]) -> int: Jaime loves playing with sequences of numbers and challenges his friends with puzzles about them. One day, he thought of a new puzzle involving the greatest common divisor (GCD) and decided to test his friends using this idea. Given a sequence of n integers a_1, a_2, ..., a_n, Jaime wants to find the maximum GCD value he can obtain by removing exactly one element from the sequence. However, since the GCD of just one element is the element itself, removing a single element and finding the GCD of the remaining sequence is necessary. >>> max_gcd_after_removal(3, [3, 9, 15]) 3 >>> max_gcd_after_removal(5, [12, 15, 18, 21, 24]) 3 >>> max_gcd_after_removal(4, [1, 1, 1, 1]) 1","solution":"import math def max_gcd_after_removal(n, arr): if n == 2: return max(arr) # With only 2 elements, removing one leaves the other. # Compute the prefix and suffix GCD arrays prefix_gcd = [0] * n suffix_gcd = [0] * n prefix_gcd[0] = arr[0] for i in range(1, n): prefix_gcd[i] = math.gcd(prefix_gcd[i - 1], arr[i]) suffix_gcd[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): suffix_gcd[i] = math.gcd(suffix_gcd[i + 1], arr[i]) # Compute maximum GCD after removing an element max_gcd = 0 for i in range(n): if i == 0: max_gcd = max(max_gcd, suffix_gcd[1]) elif i == n - 1: max_gcd = max(max_gcd, prefix_gcd[n - 2]) else: max_gcd = max(max_gcd, math.gcd(prefix_gcd[i - 1], suffix_gcd[i + 1])) return max_gcd # Example Usage n = 3 arr = [3, 9, 15] print(max_gcd_after_removal(n, arr)) # Output: 3"},{"question":"def is_symmetric(matrix: List[List[int]]) -> bool: Checks if the given square matrix is symmetric. Args: matrix (list of lists of int): Square matrix to check. Returns: bool: True if the matrix is symmetric, False otherwise. >>> matrix1 = [ ... [1, 2, 3], ... [2, 1, 4], ... [3, 4, 1] ... ] >>> is_symmetric(matrix1) True >>> matrix2 = [ ... [1, 0, 3], ... [2, 1, 4], ... [3, 4, 1] ... ] >>> is_symmetric(matrix2) False","solution":"def is_symmetric(matrix): Checks if the given square matrix is symmetric. Args: matrix (list of lists of int): Square matrix to check. Returns: bool: True if the matrix is symmetric, False otherwise. n = len(matrix) for i in range(n): for j in range(i, n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"def count_color_blocks(n, arr): Counts the number of distinct color blocks in the array. Parameters: n (int): Length of the array arr (list of int): The array elements Returns: int: Number of distinct color blocks Example: >>> count_color_blocks(7, [1, 2, 2, 3, 3, 3, 4]) 4 >>> count_color_blocks(1, [1]) 1 pass from solution import count_color_blocks def test_single_element_array(): assert count_color_blocks(1, [1]) == 1 def test_no_repeated_elements(): assert count_color_blocks(5, [1, 2, 3, 4, 5]) == 5 def test_all_elements_same(): assert count_color_blocks(4, [2, 2, 2, 2]) == 1 def test_multiple_color_blocks(): assert count_color_blocks(7, [1, 2, 2, 3, 3, 3, 4]) == 4 assert count_color_blocks(5, [1, 1, 1, 2, 2]) == 2 def test_empty_array(): assert count_color_blocks(0, []) == 0","solution":"def count_color_blocks(n, arr): Counts the number of distinct color blocks in the array. Parameters: n (int): Length of the array arr (list of int): The array elements Returns: int: Number of distinct color blocks if n == 0: return 0 color_blocks = 1 for i in range(1, n): if arr[i] != arr[i-1]: color_blocks += 1 return color_blocks"},{"question":"def tsp(start, routes): Calculate the shortest time required for Alice to visit all cities starting and ending at the specified city. >>> tsp(\\"A\\", [(\\"A\\", \\"B\\", 4), (\\"A\\", \\"C\\", 2), (\\"A\\", \\"D\\", 5), (\\"B\\", \\"C\\", 1), (\\"B\\", \\"D\\", 3), (\\"C\\", \\"D\\", 6)]) 11 >>> tsp(\\"A\\", [(\\"A\\", \\"B\\", 10), (\\"A\\", \\"C\\", 15), (\\"A\\", \\"D\\", 20), (\\"B\\", \\"C\\", 35), (\\"B\\", \\"D\\", 25), (\\"C\\", \\"D\\", 30)]) 80 >>> tsp(\\"A\\", [(\\"A\\", \\"B\\", 10), (\\"A\\", \\"C\\", 20), (\\"B\\", \\"C\\", 30)]) 60 >>> tsp(\\"A\\", [(\\"A\\", \\"B\\", 5)]) 10 >>> tsp(\\"A\\", [(\\"A\\", \\"B\\", 10), (\\"A\\", \\"C\\", 10), (\\"B\\", \\"C\\", 10)]) 30 >>> routes = [(\\"A\\", \\"B\\", 10), (\\"A\\", \\"C\\", 15), (\\"A\\", \\"D\\", 20), (\\"B\\", \\"C\\", 35), (\\"B\\", \\"D\\", 25), (\\"C\\", \\"D\\", 30), (\\"A\\", \\"E\\", 10), (\\"E\\", \\"B\\", 10), (\\"E\\", \\"C\\", 20), (\\"E\\", \\"D\\", 10)] >>> tsp(\\"A\\", routes) 75","solution":"import itertools def tsp(start, routes): # Create a dictionary to store the graph graph = {} for route in routes: city1, city2, time = route if city1 not in graph: graph[city1] = {} if city2 not in graph: graph[city2] = {} graph[city1][city2] = time graph[city2][city1] = time # Get all the cities in the graph cities = list(graph.keys()) # Remove the starting city from the list of cities to visit cities.remove(start) # Generate all possible permutations of the cities to visit permutations = itertools.permutations(cities) # Calculate the minimum cost min_cost = float('inf') for perm in permutations: current_cost = 0 current_city = start for city in perm: current_cost += graph[current_city][city] current_city = city current_cost += graph[current_city][start] min_cost = min(min_cost, current_cost) return min_cost"},{"question":"def move_target_to_end(nums, target): Given an integer array, nums, move all instances of a specific target value to the end of the array while maintaining the relative order of the non-target elements. Do this in-place with minimal additional space. Parameters: nums (list of int): The array of integers target (int): The target integer to move to the end Returns: list of int: The modified array with all instances of target value at the end Examples: >>> move_target_to_end([0, 1, 0, 3, 12], 0) [1, 3, 12, 0, 0] >>> move_target_to_end([4, 2, 4, 1, 4, 3, 4], 4) [2, 1, 3, 4, 4, 4, 4] def test_move_target_to_end(): assert move_target_to_end([0, 1, 0, 3, 12], 0) == [1, 3, 12, 0, 0] assert move_target_to_end([4, 2, 4, 1, 4, 3, 4], 4) == [2, 1, 3, 4, 4, 4, 4] assert move_target_to_end([2, 2, 2, 2, 2], 2) == [2, 2, 2, 2, 2] assert move_target_to_end([1, 2, 3, 4, 5], 3) == [1, 2, 4, 5, 3] assert move_target_to_end([4, 1, 4, 5, 4], 4) == [1, 5, 4, 4, 4] assert move_target_to_end([], 1) == []","solution":"def move_target_to_end(nums, target): Moves all instances of target value to the end of the array while maintaining the relative order of non-target elements. Modifies the array in place. Parameters: nums (list of int): The array of integers target (int): The target integer to move to the end Returns: list of int: The modified array with all instances of target value at the end index = 0 # index to place the next non-target element # Iterate through the array for num in nums: if num != target: nums[index] = num index += 1 # Fill the remaining part of nums with the target while index < len(nums): nums[index] = target index += 1 return nums"},{"question":"def gcd(a: int, b: int) -> int: Compute the greatest common divisor (gcd) of two integers using Euclid's algorithm. a (int): First integer b (int): Second integer Returns: int: The gcd of a and b >>> gcd(48, 18) 6 >>> gcd(7, 13) 1 >>> gcd(10, 1) 1 >>> gcd(10, 10) 10 >>> gcd(1000, 250) 250 >>> gcd(18, 48) 6 >>> gcd(1, 1) 1 >>> gcd(1, 1000) 1 >>> gcd(1000, 1000) 1000","solution":"def gcd(a, b): Returns the greatest common divisor of a and b using Euclid's algorithm. while b != 0: a, b = b, a % b return a"},{"question":"def find(parent, i): Find the root of the set in which element i is located. pass def union(parent, rank, x, y): Perform the union of two sets x and y. pass def kruskal(n, edges): Implement Kruskal's algorithm to find the Minimum Spanning Tree and return the maximum edge weight in the MST. pass def min_max_travel_time(t, test_cases): Determine the minimum possible maximum travel time between any two intersections after an optimal rearrangement of the roads. t: number of test cases test_cases: a list of test cases, each containing n (number of intersections), m (number of roads), and edges (list of tuples as edges) >>> t = 2 >>> test_cases = [ >>> {'n': 3, 'm': 3, 'edges': [(0, 1, 4), (1, 2, 3), (0, 2, 5)]}, >>> {'n': 4, 'm': 4, 'edges': [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 0, 40)]} >>> ] >>> min_max_travel_time(t, test_cases) [4, 30] pass","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] i = 0 # index variable for sorted edges e = 0 # index variable for result[] parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) edges = sorted(edges, key=lambda item: item[2]) while e < n - 1: u, v, w = edges[i] i += 1 x = find(parent, u) y = find(parent, v) if x != y: e += 1 result.append([u, v, w]) union(parent, rank, x, y) max_edge_in_mst = max(result, key=lambda item: item[2])[2] return max_edge_in_mst def min_max_travel_time(t, test_cases): results = [] for case in test_cases: n, m = case['n'], case['m'] edges = case['edges'] results.append(kruskal(n, edges)) return results # Example usage def main(): t = 2 test_cases = [ {'n': 3, 'm': 3, 'edges': [(0, 1, 4), (1, 2, 3), (0, 2, 5)]}, {'n': 4, 'm': 4, 'edges': [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 0, 40)]} ] results = min_max_travel_time(t, test_cases) for result in results: print(result) main()"},{"question":"def replace_words(T: int, rules: List[str], original_text: str) -> str: In a text editing application, there's a feature that allows users to replace certain words with specified replacements throughout a document. This feature requires a function that takes the original text and a series of replacement rules, and then returns the modified text. Args: T: the number of replacement rules. rules: a list of strings where each string contains a pair of words: the word to be replaced and the word to replace it with. original_text: the original text in which replacements should be done. Returns: The modified text after all replacements have been made. The replacement should be case-insensitive, but should match the case of the first letter of the word being replaced (i.e., if the word being replaced is capitalized, the replacement should be capitalized as well). >>> replace_words(1, [\\"hello hi\\"], \\"Hello world!\\") 'Hi world!' >>> replace_words(3, [\\"hello hi\\", \\"world Earth\\", \\"this That\\"], 'This is a test. Hello world!nHello there. Is this the real world?') 'That is a test. Hi Earth!nHi there. Is That the real Earth?' >>> replace_words(2, [\\"apple banana\\", \\"Orange citrus\\"], \\"I have an Apple and an orange.\\") 'I have an Banana and an citrus.' >>> replace_words(2, [\\"cat dog\\", \\"bird fish\\"], \\"There is a tree in the garden.\\") 'There is a tree in the garden.' >>> replace_words(3, [\\"sun moon\\", \\"light dark\\", \\"hello goodbye\\"], 'Hello! The sun shines bright with light everywhere.') 'Goodbye! The moon shines bright with dark everywhere.'","solution":"def replace_words(T, rules, original_text): def replace_word(match): word = match.group(0) lower_word = word.lower() if lower_word in replacements: replacement = replacements[lower_word] if word.istitle(): return replacement.capitalize() elif word.isupper(): return replacement.upper() else: return replacement return word import re # Create a dictionary for the replacements replacements = {} for rule in rules: src, dest = rule.split() replacements[src.lower()] = dest pattern = re.compile('|'.join(re.escape(key) for key in replacements.keys()), re.IGNORECASE) modified_text = re.sub(pattern, replace_word, original_text) return modified_text"},{"question":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be attended. :param events: List of tuples [(start1, end1), (start2, end2), ...] :return: Maximum number of non-overlapping events Example: >>> max_non_overlapping_events([(1, 4), (2, 6), (8, 10), (3, 5), (5, 7)]) 3","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be attended. :param events: List of tuples [(start1, end1), (start2, end2), ...] :return: Maximum number of non-overlapping events # Sort events based on their end time events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = 0 for start, end in events: if start > last_end_time: max_events += 1 last_end_time = end return max_events # Example usage if __name__ == \\"__main__\\": n = 5 events = [(1, 4), (2, 6), (8, 10), (3, 5), (5, 7)] print(max_non_overlapping_events(events)) # Output: 3"},{"question":"def is_balanced(s: str) -> str: Determines if a sequence of brackets is balanced. Returns \\"YES\\" if balanced, otherwise \\"NO\\". >>> is_balanced(\\"{[()]}\\") \\"YES\\" >>> is_balanced(\\"{[(])}\\") \\"NO\\"","solution":"def is_balanced(s: str) -> str: Determines if a sequence of brackets is balanced. Returns \\"YES\\" if balanced, otherwise \\"NO\\". stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if not stack or stack.pop() != bracket_map[char]: return \\"NO\\" else: return \\"NO\\" # If the character is not a recognized bracket return \\"YES\\" if not stack else \\"NO\\""},{"question":"def sum_at_depth(n, edges, values, depth): Determine the sum of values of all nodes at exact depth D from the root. Parameters: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): List of edges where each edge is represented by a tuple (u, v). values (List[int]): The values associated with each node. depth (int): The depth for which the sum of node values is to be calculated. Returns: int: The sum of values of all nodes at the exact depth D from the root. >>> sum_at_depth(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [3, 5, 8, 2, 1, 7, 9], 2) 19 >>> sum_at_depth(3, [(1, 2), (1, 3)], [10, 20, 30], 3) 0 >>> sum_at_depth(1, [], [42], 0) 42 >>> sum_at_depth(3, [(1, 2), (1, 3)], [1, 2, 3], 1) 5 >>> sum_at_depth(5, [(1, 2), (1, 3), (2, 4), (2, 5)], [1, 2, 3, 4, 5], 2) 9","solution":"def sum_at_depth(n, edges, values, depth): from collections import defaultdict, deque # Step 1: Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Step 2: Perform BFS to find nodes at the given depth queue = deque([(1, 0)]) # (node, current depth) visited = set([1]) sum_at_given_depth = 0 while queue: node, current_depth = queue.popleft() if current_depth == depth: sum_at_given_depth += values[node - 1] if current_depth < depth: for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_depth + 1)) return sum_at_given_depth"},{"question":"from typing import List, Tuple def is_connected_after_removal(n: int, m: int, edges: List[Tuple[int, int, int]]) -> str: Function to determine if the graph remains connected after removing any single road. :param n: int: number of cities :param m: int: number of roads :param edges: list of tuples: each tuple (u, v, l) represents a road between city u and city v with length l :return: str: \\"Yes\\" if the graph remains connected after removing any single road, \\"No\\" otherwise Examples: >>> is_connected_after_removal(5, 5, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (1, 5, 3)]) \\"Yes\\" >>> is_connected_after_removal(4, 3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) \\"No\\" pass","solution":"from collections import defaultdict, deque def is_connected_after_removal(n, m, edges): Function to determine if the graph remains connected after removing any single road. :param n: int: number of cities :param m: int: number of roads :param edges: list of tuples: each tuple (u, v, l) represents a road between city u and city v with length l :return: str: \\"Yes\\" if the graph remains connected after removing any single road, \\"No\\" otherwise if m > n - 1: # The graph has redundant edges return \\"Yes\\" # Function to perform BFS and count reachable nodes def bfs_count(start, adjacency_list, removed_edge): visited = [False] * (n + 1) queue = deque([start]) visited[start] = True count = 0 while queue: node = queue.popleft() count += 1 for neighbor in adjacency_list[node]: if not visited[neighbor] and (node, neighbor) != removed_edge and (neighbor, node) != removed_edge: visited[neighbor] = True queue.append(neighbor) return count # Build adjacency list adjacency_list = defaultdict(list) for u, v, l in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Perform connectivity check after removing each edge for u, v, l in edges: if bfs_count(1, adjacency_list, (u, v)) != n: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List, Tuple def shortest_subarray_length(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given the number of test cases and an array containing integers, find the length of the shortest subarray for each test case such that its largest value equals the given integer k. If no such subarray exists, returns -1. >>> shortest_subarray_length(4, [(5, 4, [1, 2, 4, 3, 5]), (3, 10, [3, 10, 2]), (6, 7, [7, 2, 3, 1, 7, 8]), (4, 1, [1, 1, 1, 1])]) [2, 1, 1, 1] >>> shortest_subarray_length(1, [(5, 6, [1, 2, 3, 4, 5])]) [-1] >>> shortest_subarray_length(1, [(4, 2, [2, 2, 2, 2])]) [1] >>> shortest_subarray_length(2, [(1, 3, [3]), (1, 2, [3])]) [1, -1] >>> shortest_subarray_length(1, [(7, 5, [1, 5, 3, 2, 5, 4, 5])]) [1]","solution":"def shortest_subarray_length(t, test_cases): results = [] for n, k, arr in test_cases: min_length = float('inf') for i in range(n): if arr[i] == k: results.append(1) break else: results.append(-1) return results"},{"question":"def toy_purchase_possibility(N, M, A, B): Determines if it is possible to buy exactly M toys with a budget of N dollars where there are two types of toys available: Type 1 costs A dollars, Type 2 costs B dollars. Parameters: N (int): Budget in dollars. M (int): Required number of toys. A (int): Cost of Type 1 toy. B (int): Cost of Type 2 toy. Returns: str: 'POSSIBLE' if it is possible to buy exactly M toys within the budget N, otherwise 'IMPOSSIBLE'. >>> toy_purchase_possibility(20, 4, 3, 5) 'POSSIBLE' >>> toy_purchase_possibility(10, 5, 3, 3) 'IMPOSSIBLE' >>> toy_purchase_possibility(9, 3, 3, 5) 'POSSIBLE' >>> toy_purchase_possibility(8, 3, 3, 5) 'IMPOSSIBLE' >>> toy_purchase_possibility(15, 3, 5, 5) 'POSSIBLE' >>> toy_purchase_possibility(1000, 100, 10, 10) 'POSSIBLE'","solution":"def toy_purchase_possibility(N, M, A, B): Determines if it is possible to buy exactly M toys with a budget of N dollars where there are two types of toys available: Type 1 costs A dollars, Type 2 costs B dollars. Parameters: N (int): Budget in dollars. M (int): Required number of toys. A (int): Cost of Type 1 toy. B (int): Cost of Type 2 toy. Returns: str: 'POSSIBLE' if it is possible to buy exactly M toys within the budget N, otherwise 'IMPOSSIBLE'. for i in range(M + 1): if i * A + (M - i) * B <= N: return 'POSSIBLE' return 'IMPOSSIBLE' # Example Usage # result = toy_purchase_possibility(20, 4, 3, 5) # print(result) # Output: \\"POSSIBLE\\""},{"question":"def apply_commands(N: int, M: int, commands: List[Tuple[int, int, int, int, int]]) -> List[List[int]]: Apply a series of commands to update a grid and return the final grid. >>> apply_commands(3, 3, [(1, 1, 2, 2, 1), (2, 2, 3, 3, 2), (1, 3, 3, 3, 3)]) [[1, 1, 3], [1, 3, 5], [0, 2, 5]] >>> apply_commands(2, 2, [(1, 1, 2, 2, 10)]) [[10, 10], [10, 10]]","solution":"def apply_commands(N, M, commands): grid = [[0] * M for _ in range(N)] for command in commands: x1, y1, x2, y2, v = command for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): grid[i][j] += v return grid"},{"question":"from typing import List, Tuple def max_values_at_levels(n: int, nodes: List[Tuple[int, int, int]]) -> List[int]: Given a number of nodes and a list of tuples representing the binary tree nodes (value, left child, right child), find the maximum value of the node levels. >>> max_values_at_levels(7, [(1, 2, 3), (2, 4, 5), (3, -1, 6), (4, -1, -1), (5, -1, -1), (6, 7, -1), (7, -1, -1)]) [1, 3, 6, 7] >>> max_values_at_levels(1, [(1, -1, -1)]) [1] def test_max_values_at_levels_basic(): n = 7 nodes = [ (1, 2, 3), (2, 4, 5), (3, -1, 6), (4, -1, -1), (5, -1, -1), (6, 7, -1), (7, -1, -1) ] result = max_values_at_levels(n, nodes) assert result == [1, 3, 6, 7] def test_single_node(): n = 1 nodes = [ (1, -1, -1) ] result = max_values_at_levels(n, nodes) assert result == [1] def test_no_children(): n = 3 nodes = [ (1, -1, 2), (2, -1, 3), (3, -1, -1) ] result = max_values_at_levels(n, nodes) assert result == [1, 2, 3] def test_left_heavy_tree(): n = 5 nodes = [ (1, 2, -1), (2, 3, -1), (3, 4, -1), (4, 5, -1), (5, -1, -1) ] result = max_values_at_levels(n, nodes) assert result == [1, 2, 3, 4, 5] def test_right_heavy_tree(): n = 4 nodes = [ (1, -1, 2), (2, -1, 3), (3, -1, 4), (4, -1, -1) ] result = max_values_at_levels(n, nodes) assert result == [1, 2, 3, 4]","solution":"from collections import defaultdict, deque def max_values_at_levels(n, nodes): if n == 0: return [] tree = defaultdict(lambda: [-1, -1]) for v, l, r in nodes: tree[v] = [l, r] levels = defaultdict(list) queue = deque([(1, 0)]) # (node value, level) while queue: node, level = queue.popleft() if node == -1: continue levels[level].append(node) left, right = tree[node] queue.append((left, level + 1)) queue.append((right, level + 1)) result = [] for level in range(len(levels)): result.append(max(levels[level])) return result # Helper function to parse input and call the main function def solve(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) nodes = [] for i in range(n): v, l, r = int(data[3 * i + 1]), int(data[3 * i + 2]), int(data[3 * i + 3]) nodes.append((v, l, r)) result = max_values_at_levels(n, nodes) for value in result: print(value)"},{"question":"def unique_paths(N, M, grid): Determine the total number of unique paths from the top-left to the bottom-right booth. Each path consists of down and right moves only. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[List[str]]): 2D grid representing the souvenir booths. Returns: int: Total number of unique paths modulo 1000003 Example: >>> unique_paths(3, 3, [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]) 6 >>> unique_paths(2, 2, [['a', 'b'], ['c', 'd']]) 2","solution":"def unique_paths(N, M, grid): MOD = 1000003 dp = [[0]*M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[N-1][M-1]"},{"question":"def max_total_productivity(n: int, d: int, developers: List[Tuple[int, int, int]]) -> int: Determine the maximum productivity that can be achieved by selecting one developer to work on the project on each day. Args: n (int): Number of developers. d (int): Number of days the project lasts. developers (List[Tuple[int, int, int]]): A list of tuples, each containing three integers representing the start day, end day, and productivity score of the developer. Returns: int: The maximum total productivity that can be achieved by optimally choosing one developer to work each day. >>> max_total_productivity(3, 5, [(1, 3, 5), (2, 5, 8), (4, 5, 10)]) 41 >>> max_total_productivity(2, 1, [(1, 1, 7), (1, 1, 10)]) 10 >>> max_total_productivity(2, 4, [(1, 2, 5), (3, 4, 10)]) 30 >>> max_total_productivity(4, 5, [(1, 1, 3), (2, 2, 5), (3, 3, 2), (4, 4, 8), (5, 5, 10)]) 28 >>> max_total_productivity(3, 5, [(1, 5, 5), (1, 5, 5), (1, 5, 5)]) 25","solution":"def max_total_productivity(n, d, developers): # Initialize the productivity array with 0 for each day productivity = [0] * (d + 1) # Loop through each developer for s, e, p in developers: # Loop through the range of days the developer is available and set the productivity for day in range(s, e + 1): productivity[day] = max(productivity[day], p) # Sum up the maximum productivity for all days return sum(productivity[1:]) # productivity[0] is unused # Example usage: n = 3 d = 5 developers = [(1, 3, 5), (2, 5, 8), (4, 5, 10)] print(max_total_productivity(n, d, developers)) # Output: 41"},{"question":"def calculate_bonuses(T: int, test_cases: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int, int]]: Calculate the exact bonuses for employees based on their performance scores and total bonus pool. >>> calculate_bonuses(1, [(1, 1, 1, 300)]) [(100, 100, 100)] >>> calculate_bonuses(1, [(2, 3, 5, 1000)]) [(200, 300, 500)] >>> calculate_bonuses(1, [(10, 20, 30, 600)]) [(100, 200, 300)]","solution":"def calculate_bonuses(T, test_cases): results = [] for case in test_cases: S1, S2, S3, B = case total_score = S1 + S2 + S3 # Calculate bonuses B1 = round((S1 / total_score) * B) B2 = round((S2 / total_score) * B) B3 = round((S3 / total_score) * B) results.append((B1, B2, B3)) return results"},{"question":"def rearrange_array(arr): Rearranges the array such that all even numbers appear before all odd numbers, preserving the relative order of both. >>> rearrange_array([4, 3, 1, 2, 7, 8]) [4, 2, 8, 3, 1, 7] >>> rearrange_array([2, 4, 6, 1, 3]) [2, 4, 6, 1, 3] # Implementation here def process_testcases(T, testcases): Processes multiple test cases and returns the results as a list of strings. Each string represents the rearranged array from a single test case. >>> process_testcases(2, [(6, [4, 3, 1, 2, 7, 8]), (5, [2, 4, 6, 1, 3])]) ['4 2 8 3 1 7', '2 4 6 1 3'] # Implementation here","solution":"def rearrange_array(arr): Rearranges the array such that all even numbers appear before all odd numbers, preserving the relative order of both. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds def process_testcases(T, testcases): results = [] for case in testcases: N, arr = case rearranged = rearrange_array(arr) results.append(\\" \\".join(map(str, rearranged))) return results"},{"question":"def max_consecutive_wins(n: int, performances: List[str]) -> List[int]: Calculate the maximum number of consecutive wins for each player. Args: n : int : number of players performances : list of str : list of performance strings for each player Returns: list of int : list of maximum consecutive wins for each player >>> max_consecutive_wins(3, [\\"WWLWLW\\", \\"WLWLWLL\\", \\"WWWLLLWWW\\"]) [2, 1, 3] >>> max_consecutive_wins(2, [\\"LWLWLWLW\\", \\"WWWWLWWW\\"]) [1, 4]","solution":"def max_consecutive_wins(n, performances): Calculate the maximum number of consecutive wins for each player. Args: n : int : number of players performances : list of str : list of performance strings for each player Returns: list of int : list of maximum consecutive wins for each player max_wins = [] for performance in performances: max_win_count = 0 current_win_count = 0 for game in performance: if game == 'W': current_win_count += 1 max_win_count = max(max_win_count, current_win_count) else: current_win_count = 0 max_wins.append(max_win_count) return max_wins"},{"question":"def min_jumps(arr): Returns the minimum number of jumps required to reach the end of the list or -1 if it is not possible to reach the end. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([1, 1, 1, 1, 1]) 4 >>> min_jumps([1]) 0 >>> min_jumps([0, 1, 1, 1, 1]) -1 >>> min_jumps([2, 3, 0, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([1, 4, 3, 7, 1, 2, 6, 7, 6, 10]) 3","solution":"def min_jumps(arr): Returns the minimum number of jumps required to reach the end of the list or -1 if it is not possible to reach the end. n = len(arr) if n <= 1: return 0 if arr[0] == 0: return -1 max_reach = arr[0] steps = arr[0] jumps = 1 for i in range(1, n): if i == n - 1: return jumps max_reach = max(max_reach, i + arr[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"def galactic_carrier_route_optimization(test_cases): Calculate the minimum distance required for carriers to travel from the central command station to each other station in the galaxy. Parameters: test_cases (list): A list of test cases. Each test case is a tuple containing: - N: the number of space stations. - M: the number of routes. - edges: a list of tuples representing the routes, each containing: - u: starting station. - v: ending station. - d: distance of the route. Returns: list: A list of lists. Each inner list contains N-1 integers representing the minimum distance from the central command station to each other station in ascending order of their station numbers. If a station cannot be reached, output -1 for that station. Example: >>> galactic_carrier_route_optimization([(4, 4, [(1, 2, 6), (1, 3, 4), (2, 4, 5), (3, 4, 2])]) [[6, 4, 6]] >>> galactic_carrier_route_optimization([(3, 3, [(1, 2, 1), (2, 3, 3), (3, 1, 5])]) [[1, 4]]","solution":"import heapq import sys def dijkstra(graph, n): Uses Dijkstra's algorithm to find the shortest paths from node 1 to every other node. Returns a list of minimum distances (or -1 if a node is unreachable). dist = [float('inf')] * (n + 1) dist[1] = 0 pq = [(0, 1)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return [dist[i] if dist[i] != float('inf') else -1 for i in range(2, n + 1)] def galactic_carrier_route_optimization(test_cases): results = [] for case in test_cases: n, m, edges = case # Create graph graph = [[] for _ in range(n + 1)] for u, v, d in edges: graph[u].append((v, d)) graph[v].append((u, d)) # Get shortest paths from node 1 result = dijkstra(graph, n) results.append(result) return results"},{"question":"def max_rectangle_area(n: int, heights: List[int]) -> int: Given the number of buildings and their heights, determine the maximum area of a rectangle that can be formed from a contiguous subsequence. >>> max_rectangle_area(6, [2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area(1, [5]) 5 >>> max_rectangle_area(2, [5, 6]) 10 >>> max_rectangle_area(5, [5, 4, 3, 2, 1]) 9 >>> max_rectangle_area(5, [1, 2, 3, 4, 5]) 9 >>> max_rectangle_area(4, [3, 3, 3, 3]) 12 >>> max_rectangle_area(3, [1000000000, 1000000000, 1000000000]) 3000000000 >>> max_rectangle_area(7, [6, 2, 5, 4, 5, 1, 6]) 12","solution":"def max_rectangle_area(n, heights): Returns the maximum area of a rectangle formed by choosing a contiguous subsequence of buildings. # Helper function to calculate the maximum area in a histogram def largestRectangleArea(heights): stack = [] max_area = 0 index = 0 while index < len(heights): # If the stack is empty or the current height is greater than or equal to the height of the building # corresponding to the top index in the stack, push the current index onto the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Otherwise, calculate the area for the building corresponding to stack's top top_of_stack = stack.pop() # Width calculation depends on whether the stack is empty or not area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Remaining buildings in the stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area return largestRectangleArea(heights)"},{"question":"def reorganize_string(s: str) -> str: Re-order the letters in such a way that the new string formed has no two adjacent characters that are the same. If such a reordering is not possible, return an empty string. >>> reorganize_string(\\"aab\\") 'aba' >>> reorganize_string(\\"aaab\\") ''","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: # Frequency count of each character frequency = Counter(s) # Max heap of pairs (-frequency, character) max_heap = [(-freq, char) for char, freq in frequency.items()] heapq.heapify(max_heap) # Previous character and its frequency prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If previous character exists, push it back into heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update prev_freq and prev_char for next iteration prev_freq, prev_char = freq + 1, char result = ''.join(result) # If the length of result is the same as original string, it's valid return result if len(result) == len(s) else ''"},{"question":"def min_books_to_remove(arr): Function to find the minimum number of books to add or remove to make the sequence strictly increasing. >>> min_books_to_remove([1, 3, 2, 4, 5]) 1 >>> min_books_to_remove([3, 2, 1, 2, 3]) 2 >>> min_books_to_remove([1, 2, 3, 4, 5, 6, 7]) 0 from solution import min_books_to_remove def test_min_books_to_remove_example_1(): assert min_books_to_remove([1, 3, 2, 4, 5]) == 1 def test_min_books_to_remove_example_2(): assert min_books_to_remove([3, 2, 1, 2, 3]) == 2 def test_min_books_to_remove_example_3(): assert min_books_to_remove([1, 2, 3, 4, 5, 6, 7]) == 0 def test_min_books_to_remove_already_increasing(): assert min_books_to_remove([1, 2, 3, 4]) == 0 def test_min_books_to_remove_all_same_elements(): assert min_books_to_remove([5, 5, 5, 5]) == 3 def test_min_books_to_remove_single_element(): assert min_books_to_remove([7]) == 0 def test_min_books_to_remove_decreasing_sequence(): assert min_books_to_remove([5, 4, 3, 2, 1]) == 4 def test_min_books_to_remove_almost_increasing(): assert min_books_to_remove([1, 3, 2, 4]) == 1 def test_min_books_to_remove_two_elements(): assert min_books_to_remove([5, 3]) == 1 assert min_books_to_remove([3, 4]) == 0","solution":"def min_books_to_remove(arr): Function to find the minimum number of books to add or remove to make the sequence strictly increasing. n = len(arr) dp = [1] * n # dp[i] will store the length of LIS ending at index i for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) lis = max(dp) # the length of the longest increasing subsequence return n - lis"},{"question":"def is_object_in_description(description: str, object: str) -> bool: Determine if the object is mentioned in the room description. >>> is_object_in_description(\\"A dusty old bOoK lays on the wooden table near the window.\\", \\"book\\") True >>> is_object_in_description(\\"A shiny red apple sits in a basket on the kitchen counter.\\", \\"banana\\") False >>> is_object_in_description(\\"The quick brown foX jumps over the lazy dOg.\\", \\"fox\\") True >>> is_object_in_description(\\"There is a lamp in the corner.\\", \\"lamp\\") True >>> is_object_in_description(\\"There is a lamp in the corner.\\", \\"lam\\") True","solution":"def is_object_in_description(description, object): Returns true if the object is found in the description ignoring case, false otherwise. # Convert both strings to lowercase to make the search case-insensitive description_lower = description.lower() object_lower = object.lower() # Check if the object is in the description return object_lower in description_lower"},{"question":"def calculate_working_time(start_time: str, end_time: str) -> int: Calculate the total working time in minutes from the start and end times provided in HH:MM format. Args: - start_time (str): The start time in HH:MM format. - end_time (str): The end time in HH:MM format. Returns: - int: The total working time in minutes. >>> calculate_working_time(\\"09:00\\", \\"17:30\\") 510 >>> calculate_working_time(\\"00:00\\", \\"01:00\\") 60 >>> calculate_working_time(\\"23:00\\", \\"23:59\\") 59 >>> calculate_working_time(\\"08:15\\", \\"12:45\\") 270 >>> calculate_working_time(\\"12:00\\", \\"13:30\\") 90 >>> calculate_working_time(\\"21:00\\", \\"23:59\\") 179","solution":"def calculate_working_time(start_time, end_time): Calculate the total working time in minutes from the start and end times provided in HH:MM format. start_hours, start_minutes = map(int, start_time.split(':')) end_hours, end_minutes = map(int, end_time.split(':')) start_total_minutes = start_hours * 60 + start_minutes end_total_minutes = end_hours * 60 + end_minutes total_working_minutes = end_total_minutes - start_total_minutes return total_working_minutes"},{"question":"from typing import List def is_subarray_sum_divisible(arr: List[int], K: int) -> str: Calculates the SubArraySum value for the given array and checks if it is divisible by K. Parameters: arr (List[int]): List of integers. K (int): Divisor. Returns: str: \\"YES\\" if the SubArraySum value is divisible by K, otherwise \\"NO\\". >>> is_subarray_sum_divisible([1, 2, 3], 3) \\"NO\\" >>> is_subarray_sum_divisible([1, 2, 3], 5) \\"YES\\" >>> is_subarray_sum_divisible([1, 2, 3, 4], 2) \\"YES\\" >>> is_subarray_sum_divisible([1000000, 1000000, 1000000], 1000000) \\"YES\\" >>> is_subarray_sum_divisible([10], 5) \\"YES\\" >>> is_subarray_sum_divisible([10], 3) \\"NO\\" >>> large_array = [i for i in range(1, 1001)] >>> is_subarray_sum_divisible(large_array, 100) \\"YES\\"","solution":"def is_subarray_sum_divisible(arr, K): Calculates the SubArraySum value and checks if it is divisible by K. Parameters: arr (list): List of integers. K (int): Divisor. Returns: str: \\"YES\\" if the SubArraySum value is divisible by K, otherwise \\"NO\\". N = len(arr) subarray_sum = 0 # Calculate total SubArraySum value for i in range(N): subarray_sum += arr[i] * (N - i) * (i + 1) # Check divisibility if subarray_sum % K == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def flatten_json(json_obj, delimiter): Flattens a nested JSON object into a single-level dictionary. Parameters: - json_obj (dict): The nested JSON object. - delimiter (str): The string used to separate keys in the flattened dictionary. Returns: - dict: The flattened JSON object. >>> flatten_json({}, \\".\\") {} >>> flatten_json({\\"a\\": 1, \\"b\\": 2}, \\".\\") {\\"a\\": 1, \\"b\\": 2} >>> flatten_json({ \\"a\\": { \\"b\\": { \\"c\\": 1 } }, \\"d\\": 2 }, \\".\\") { \\"a.b.c\\": 1, \\"d\\": 2 } >>> flatten_json({ \\"a\\": [1, 2, {\\"b\\": 3}], \\"c\\": 4 }, \\".\\") { \\"a[0]\\": 1, \\"a[1]\\": 2, \\"a[2].b\\": 3, \\"c\\": 4 } >>> flatten_json({ \\"name\\": \\"John\\", \\"address\\": { \\"street\\": \\"1234 Main St\\", \\"city\\": \\"Anytown\\", \\"postal\\": { \\"code\\": \\"12345\\", \\"type\\": \\"home\\" } }, \\"contacts\\": [ {\\"type\\": \\"email\\", \\"value\\": \\"john@example.com\\"}, {\\"type\\": \\"phone\\", \\"value\\": \\"555-555-5555\\"} ] }, \\".\\") { \\"name\\": \\"John\\", \\"address.street\\": \\"1234 Main St\\", \\"address.city\\": \\"Anytown\\", \\"address.postal.code\\": \\"12345\\", \\"address.postal.type\\": \\"home\\", \\"contacts[0].type\\": \\"email\\", \\"contacts[0].value\\": \\"john@example.com\\", \\"contacts[1].type\\": \\"phone\\", \\"contacts[1].value\\": \\"555-555-5555\\" }","solution":"def flatten_json(json_obj, delimiter): Flattens a nested JSON object into a single-level dictionary. Parameters: - json_obj (dict): The nested JSON object. - delimiter (str): The string used to separate keys in the flattened dictionary. Returns: - dict: The flattened JSON object. def flatten(current_obj, parent_key, flattened_dict): if isinstance(current_obj, dict): for key, value in current_obj.items(): new_key = f\\"{parent_key}{delimiter}{key}\\" if parent_key else key flatten(value, new_key, flattened_dict) elif isinstance(current_obj, list): for i, item in enumerate(current_obj): new_key = f\\"{parent_key}[{i}]\\" flatten(item, new_key, flattened_dict) else: flattened_dict[parent_key] = current_obj result = {} flatten(json_obj, \\"\\", result) return result"},{"question":"def total_active_time(intervals: List[Tuple[int, int]]) -> int: Given a list of intervals [Li, Ri], this function calculates the total length of time where there is at least one active thread. Args: intervals (list of tuples): List of (Li, Ri) tuples representing active intervals of threads. Returns: int: Total length of time where there is at least one active thread. >>> total_active_time([(1, 5), (2, 6), (8, 10), (5, 9), (3, 4), (11, 12)]) 10 >>> total_active_time([(1, 3), (2, 4), (5, 7)]) 5 >>> total_active_time([(1, 2), (2, 3), (3, 5)]) 4 >>> total_active_time([(1, 5), (6, 10)]) 8 >>> total_active_time([(1, 2)]) 1 >>> total_active_time([]) 0 >>> total_active_time([(0, 4), (4, 5), (3, 7)]) 7","solution":"def total_active_time(intervals): Given a list of intervals [Li, Ri], this function calculates the total length of time where there is at least one active thread. Args: intervals (list of tuples): List of (Li, Ri) tuples representing active intervals of threads. Returns: int: Total length of time where there is at least one active thread. if not intervals: return 0 # First, we sort the intervals based on their start time intervals.sort(key=lambda x: x[0]) # We initialize variables to keep track of the merged intervals merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # There is an overlap current_end = max(current_end, end) else: # No overlap, push the previous interval to the list merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Don't forget to append the last interval merged_intervals.append((current_start, current_end)) # To calculate the total active time, we sum up the lengths of the merged intervals total_time = 0 for start, end in merged_intervals: total_time += end - start return total_time"},{"question":"import re def longestWord(s: str) -> str: Returns the longest word in the string. If there are multiple words with the same length, returns the first one encountered. Words are defined as sequences of letters and optionally one apostrophe. >>> longestWord(\\"Hello world!\\") == \\"Hello\\" >>> longestWord(\\"The quick brown fox\\") == \\"quick\\" >>> longestWord(\\"It's a wonderful life\\") == \\"wonderful\\" >>> longestWord(\\"To infinity and beyond!\\") == \\"infinity\\" >>> longestWord(\\"I can't believe it's not butter\\") == \\"believe\\"","solution":"import re def longestWord(s): Returns the longest word in the string. If there are multiple words with the same length, returns the first one encountered. Words are defined as sequences of letters and optionally one apostrophe. # Regular expression for extracting words with optional apostrophe words = re.findall(r\\"b[a-zA-Z]+(?:'[a-zA-Z]+)?b\\", s) longest = \\"\\" max_length = 0 for word in words: if len(word) > max_length: longest = word max_length = len(word) return longest"},{"question":"def final_position(movements: str) -> tuple: Returns the final position of the robot on the 2D grid after performing all movements. Parameters: movements (str): A string of characters where: 'U' (up) increases the y-coordinate by 1, 'D' (down) decreases the y-coordinate by 1, 'L' (left) decreases the x-coordinate by 1, 'R' (right) increases the x-coordinate by 1. Returns: tuple: A tuple of two integers representing the final (x, y) coordinates of the robot. from solution import final_position def test_final_position_sample(): assert final_position(\\"UDLR\\") == (0, 0) def test_final_position_up(): assert final_position(\\"U\\") == (0, 1) def test_final_position_down(): assert final_position(\\"D\\") == (0, -1) def test_final_position_left(): assert final_position(\\"L\\") == (-1, 0) def test_final_position_right(): assert final_position(\\"R\\") == (1, 0) def test_final_position_mixed(): assert final_position(\\"UUDDLLRR\\") == (0, 0) assert final_position(\\"UUUDDLRL\\") == (-1, 1) def test_final_position_long_sequence(): sequence = \\"R\\" * 500 + \\"L\\" * 500 + \\"U\\" * 250 + \\"D\\" * 250 assert final_position(sequence) == (0, 0)","solution":"def final_position(movements): Returns the final position of the robot on the 2D grid after performing all movements. Parameters: movements (str): A string of characters where: 'U' (up) increases the y-coordinate by 1, 'D' (down) decreases the y-coordinate by 1, 'L' (left) decreases the x-coordinate by 1, 'R' (right) increases the x-coordinate by 1. Returns: tuple: A tuple of two integers representing the final (x, y) coordinates of the robot. x, y = 0, 0 for move in movements: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x, y"},{"question":"def reorganizeString(S: str) -> str: Given a string S consisting of lowercase alphabets, constructs a new string by rearranging the characters of S such that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, returns an empty string. >>> reorganizeString(\\"aab\\") in [\\"aba\\"] True >>> reorganizeString(\\"aaab\\") == \\"\\" True","solution":"import heapq from collections import Counter def reorganizeString(S): Returns a rearranged string such that no two adjacent characters are the same. If it is not possible, returns an empty string. if not S: return \\"\\" # Count frequency of each character char_count = Counter(S) # Use a max heap to store characters by their frequency max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) # The result list result = [] # The previous element to keep track of the last placed character prev_freq, prev_char = 0, '' while max_heap: # Get the most frequent character freq, char = heapq.heappop(max_heap) # Add the previous character back if its frequency is more than zero if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Add current character to result result.append(char) # Update the frequency of the current character prev_freq, prev_char = freq + 1, char reorganized_string = ''.join(result) # Check if the reorganized string has the same length as the original string if len(reorganized_string) != len(S): return \\"\\" return reorganized_string"},{"question":"def evaluate_equations(equations: List[str]) -> List[bool]: Evaluates the validity of a list of equations. Parameters: equations (list of str): List of equations in string format. Returns: list of bool: List of booleans indicating whether each equation is valid. Examples: >>> evaluate_equations([\\"a = 5 + 3\\", \\"b = a - 2\\", \\"c = a * 0\\", \\"d = c / b\\", \\"e = b / 0\\"]) [True, True, True, True, False] >>> evaluate_equations([\\"x = 7 - 4\\", \\"y = x + 1\\", \\"z = y * 2\\", \\"w = z / y\\", \\"q = z / -1\\"]) [True, True, True, True, True] >>> evaluate_equations([\\"m = 8 / 2\\", \\"n = m * 3\\", \\"o = n - 4\\", \\"p = 0 / 0\\", \\"q = o + p\\"]) [True, True, True, False, False] pass from solution import evaluate_equations def test_basic_operations(): equations = [\\"a = 1 + 1\\", \\"b = a - 1\\", \\"c = a * b\\", \\"d = c / a\\"] assert evaluate_equations(equations) == [True, True, True, True] def test_division_by_zero(): equations = [\\"a = 1 + 1\\", \\"b = a - 1\\", \\"c = a * b\\", \\"d = c / 0\\"] assert evaluate_equations(equations) == [True, True, True, False] def test_complex_division_by_zero(): equations = [\\"a = 1 + 1\\", \\"b = a - 2\\", \\"c = a * b\\", \\"d = 0 / 0\\"] assert evaluate_equations(equations) == [True, True, True, False] def test_continued_invalid_operations(): equations = [\\"a = 1 + 1\\", \\"b = a - 1\\", \\"c = a * b\\", \\"d = c / 0\\", \\"e = d + 2\\"] assert evaluate_equations(equations) == [True, True, True, False, False] def test_use_previous_variables(): equations = [\\"x = 7 - 4\\", \\"y = x + 1\\", \\"z = y * 2\\", \\"w = z / y\\", \\"q = z / -1\\"] assert evaluate_equations(equations) == [True, True, True, True, True] def test_all_invalid_preceding(): equations = [\\"m = 8 / 2\\", \\"n = m * 3\\", \\"o = n - 4\\", \\"p = 0 / 0\\", \\"q = o + p\\"] assert evaluate_equations(equations) == [True, True, True, False, False]","solution":"def evaluate_equations(equations): Evaluates the validity of a list of equations. Parameters: equations (list of str): List of equations in string format. Returns: list of bool: List of booleans indicating whether each equation is valid. variables = {} results = [] for eq in equations: parts = eq.split('=') var = parts[0].strip() expr = parts[1].strip() try: # Replace variables in the expression with their values for v in variables: expr = expr.replace(v, str(variables[v])) # Check if the expression would result in division by zero if '/' in expr: parts_div = expr.split('/') div_result = eval(parts_div[-1]) if div_result == 0: results.append(False) continue # Evaluate the expression value = eval(expr) # Assign the variable variables[var] = value results.append(True) except ZeroDivisionError: results.append(False) except Exception: results.append(False) return results"},{"question":"def minimum_crossing_time(n: int, times: List[int]) -> int: Calculate the minimum crossing time for n friends with given times. :param n: number of friends :param times: list of times taken by each friend to cross the river :return: minimum total crossing time >>> minimum_crossing_time(3, [1, 2, 5]) 8 >>> minimum_crossing_time(4, [1, 2, 5, 10]) 17 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases. :param test_cases: list of tuples, each tuple contains (n, times) :return: list of results for each test case >>> process_test_cases([(3, [1, 2, 5]), (4, [1, 2, 5, 10])]) [8, 17] pass def test_minimum_crossing_time(): assert minimum_crossing_time(3, [1, 2, 5]) == 8 assert minimum_crossing_time(4, [1, 2, 5, 10]) == 17 assert minimum_crossing_time(5, [1, 2, 5, 10, 15]) == 28 assert minimum_crossing_time(4, [1, 3, 6, 8]) == 18 assert minimum_crossing_time(4, [1, 10, 2, 5]) == 17 def test_process_test_cases(): test_cases = [ (3, [1, 2, 5]), (4, [1, 2, 5, 10]), (5, [1, 2, 5, 10, 15]), (4, [1, 3, 6, 8]), (4, [1, 10, 2, 5]), ] expected_results = [8, 17, 28, 18, 17] assert process_test_cases(test_cases) == expected_results","solution":"def minimum_crossing_time(n, times): Calculate the minimum crossing time for n friends with given times. :param n: number of friends :param times: list of times taken by each friend to cross the river :return: minimum total crossing time times.sort() total_time = 0 while n > 3: if 2 * times[1] < times[0] + times[n - 2]: total_time += 2 * times[1] + times[0] + times[n - 1] else: total_time += times[n - 1] + times[n - 2] + 2 * times[0] n -= 2 if n == 3: total_time += times[0] + times[1] + times[2] elif n == 2: total_time += times[1] return total_time def process_test_cases(test_cases): Process multiple test cases :param test_cases: list of tuples, each tuple contains (n, times) :return: list of results for each test case results = [] for n, times in test_cases: results.append(minimum_crossing_time(n, times)) return results"},{"question":"def is_balanced(S: str) -> int: Checks if the string S is balanced. If balanced, returns the number of distinct characters in the string. Otherwise, returns -1. >>> is_balanced(\\"aabb\\") 2 >>> is_balanced(\\"xyzxyz\\") 3 >>> is_balanced(\\"aabbb\\") -1 >>> is_balanced(\\"apple\\") -1 >>> is_balanced(\\"aabbccdd\\") 4 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases, returning a list of results for each test case. >>> process_test_cases(5, [\\"aabb\\", \\"xyzxyz\\", \\"aabbb\\", \\"apple\\", \\"aabbccdd\\"]) [2, 3, -1, -1, 4]","solution":"def is_balanced(S): Checks if the string S is balanced. If balanced, returns the number of distinct characters in the string. Otherwise, returns -1. from collections import Counter char_count = Counter(S) counts = list(char_count.values()) if all(count == counts[0] for count in counts): return len(char_count) else: return -1 def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(is_balanced(S)) return results"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring consisting of '(' and ')'. >>> longest_balanced_substring(\\"(()))\\") == 4 >>> longest_balanced_substring(\\")()())\\") == 4 >>> longest_balanced_substring(\\"()()\\") == 4 >>> longest_balanced_substring(\\"())\\") == 2 >>> longest_balanced_substring(\\"((()\\") == 2 # Unit Tests def test_example_cases(): assert longest_balanced_substring(\\"(()))\\") == 4 assert longest_balanced_substring(\\")()())\\") == 4 assert longest_balanced_substring(\\"()()\\") == 4 assert longest_balanced_substring(\\"())\\") == 2 assert longest_balanced_substring(\\"((()\\") == 2 def test_empty_string(): assert longest_balanced_substring(\\"\\") == 0 def test_single_character(): assert longest_balanced_substring(\\"(\\") == 0 assert longest_balanced_substring(\\")\\") == 0 def test_no_balanced_substring(): assert longest_balanced_substring(\\"(((\\") == 0 assert longest_balanced_substring(\\")))\\") == 0 def test_balanced_substring_at_the_beginning(): assert longest_balanced_substring(\\"()(()\\") == 2 def test_balanced_substring_with_nested_parentheses(): assert longest_balanced_substring(\\"((()))\\") == 6 def test_balanced_substring_with_multiple_balanced_sections(): assert longest_balanced_substring(\\"()(())\\") == 6 def test_balanced_substring_with_unbalanced_characters(): assert longest_balanced_substring(\\"(())((\\") == 4","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring consisting of '(' and ')'. max_len = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: # char == ')' stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: stack.append(i) return max_len"},{"question":"def calculate_final_price(M: int) -> float: Calculate the final price Divya has to pay after applying any applicable discount. If the meal cost is a prime number, apply a 20% discount. Parameters: M (int): Cost of the meal in dollars. Returns: float: Final price to be paid, rounded to two decimal places. Examples: >>> calculate_final_price(17) 13.60 >>> calculate_final_price(21) 21.00","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def calculate_final_price(M): Returns the final price Divya has to pay after applying discount if necessary. if is_prime(M): return round(M * 0.80, 2) else: return round(M, 2)"},{"question":"from typing import List def find_lexicographically_smallest_substring(n: int, s: str, q: int, queries: List[int]) -> List[str]: Given a string s of length n and a number of queries q where each query requests the lexicographically smallest substring of length Li, return the results for all queries. >>> find_lexicographically_smallest_substring(7, \\"abcdeed\\", 3, [2, 3, 4]) [\\"ab\\", \\"abc\\", \\"abcd\\"] >>> find_lexicographically_smallest_substring(4, \\"dcba\\", 1, [2]) [\\"ba\\"] >>> find_lexicographically_smallest_substring(5, \\"abcde\\", 2, [3, 4]) [\\"abc\\", \\"abcd\\"] >>> find_lexicographically_smallest_substring(8, \\"aabbccdd\\", 3, [2, 3, 4]) [\\"aa\\", \\"aab\\", \\"aabb\\"] >>> find_lexicographically_smallest_substring(1, \\"z\\", 1, [1]) [\\"z\\"] >>> find_lexicographically_smallest_substring(5, \\"abcde\\", 1, [5]) [\\"abcde\\"]","solution":"def find_lexicographically_smallest_substring(n, s, q, queries): Given a string s of length n and a number of queries q where each query requests the lexicographically smallest substring of length Li, return the results for all queries. results = [] for length in queries: min_substring = s[0:length] # Initialize with the first substring of given length for i in range(1, n - length + 1): current_substring = s[i:i+length] if current_substring < min_substring: min_substring = current_substring results.append(min_substring) return results"},{"question":"def most_frequent_letter(words): Write a function that, given an array of words (strings), returns the most frequent letter in those words. If there are multiple letters with the same highest frequency, return the one which comes first alphabetically. Assume all letters are lowercase and input words only consist of lowercase letters. >>> most_frequent_letter([\\"hello\\"]) == 'l' >>> most_frequent_letter([\\"hello\\", \\"world\\"]) == 'l' >>> most_frequent_letter([\\"aab\\", \\"abb\\"]) == 'a' >>> most_frequent_letter([]) == '' >>> most_frequent_letter([\\"abcdefghij\\"]) == 'a' >>> most_frequent_letter([\\"apple\\", \\"banana\\"]) == 'a'","solution":"def most_frequent_letter(words): Returns the most frequent letter from an array of words. If multiple letters have the same frequency, returns the one which comes first alphabetically. from collections import Counter import string letter_count = Counter() for word in words: letter_count.update(word) most_frequent = '' max_count = 0 for letter in string.ascii_lowercase: if letter_count[letter] > max_count: max_count = letter_count[letter] most_frequent = letter return most_frequent"},{"question":"def max_sum_after_operation(test_cases): This function takes a list of test cases, each consisting of the length of the list and the list of integers, and returns a list of the maximum possible sums after performing the special operation. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of test cases. Returns: List[int]: A list of the maximum possible sums for each test case. >>> test_cases = [(5, [1, 2, 3, 4, 5]), (3, [5, 5, 5]), (4, [1, 2, 2, 1])] >>> max_sum_after_operation(test_cases) [15, 15, 6] pass def parse_input(s): This function takes a string representing the input, parses it, and returns a list of test cases. Parameters: s (str): A string representing the input. Returns: List[Tuple[int, List[int]]]: A list of test cases. >>> parse_input(\\"3n5n1 2 3 4 5n3n5 5 5n4n1 2 2 1\\") [(5, [1, 2, 3, 4, 5]), (3, [5, 5, 5]), (4, [1, 2, 2, 1])] pass def format_output(results): This function takes a list of results and converts it to the required output format. Parameters: results (List[int]): A list of results. Returns: str: A formatted string of results. >>> format_output([15, 15, 6]) '15n15n6' pass","solution":"def max_sum_after_operation(test_cases): results = [] for n, arr in test_cases: max_sum = sum(arr) results.append(max_sum) return results # Input parsing function def parse_input(s): lines = s.split(\\"n\\") t = int(lines[0]) test_cases = [] line_index = 1 for _ in range(t): n = int(lines[line_index]) arr = list(map(int, lines[line_index + 1].split())) test_cases.append((n, arr)) line_index += 2 return test_cases # Function to convert output to the required format def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeDuplicates(head): Given a linked list with n nodes, where each node contains an integer value, remove all nodes that have duplicate numbers, leaving only distinct numbers from the original list. The order of the linked list should be preserved. >>> ll = list_to_linked_list([1, 2, 3, 2, 1, 4]) >>> result = removeDuplicates(ll) >>> linked_list_to_list(result) [3, 4] >>> ll = list_to_linked_list([1, 2, 3, 3, 2]) >>> result = removeDuplicates(ll) >>> linked_list_to_list(result) [1] >>> ll = list_to_linked_list([1, 1, 1]) >>> result = removeDuplicates(ll) >>> linked_list_to_list(result) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeDuplicates(head): if not head: return None # First pass: count the occurrences of each value count = {} current = head while current: count[current.val] = count.get(current.val, 0) + 1 current = current.next # Second pass: build a new list with only distinct values dummy = ListNode(0) # A dummy head to simplify inserted nodes current = dummy while head: if count[head.val] == 1: current.next = ListNode(head.val) current = current.next head = head.next return dummy.next"},{"question":"def count_symmetrical_substrings(s: str) -> int: Returns the number of symmetrical substrings (palindromes) in the given string s. >>> count_symmetrical_substrings(\\"abac\\") 5 >>> count_symmetrical_substrings(\\"aaaa\\") 10","solution":"def count_symmetrical_substrings(s): Returns the number of symmetrical substrings (palindromes) in the given string s. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): expand_around_center(i, i) # Odd length palindromes expand_around_center(i, i + 1) # Even length palindromes return count"},{"question":"def count_unique_numbers(s: str) -> int: Given a string 's' representing a number, return the number of unique numbers that can be generated by changing each '6' to '9' or vice versa. >>> count_unique_numbers(\\"69\\") 4 >>> count_unique_numbers(\\"96\\") 4 >>> count_unique_numbers(\\"123\\") 1 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Given the number of test cases T and a list of test cases where each test case is a string representing a number, return a list of integers where each integer represents the count of unique numbers that can be formed for each test case. >>> process_test_cases(3, [\\"69\\", \\"96\\", \\"123\\"]) [4, 4, 1] >>> process_test_cases(2, [\\"666\\", \\"999\\"]) [8, 8]","solution":"def count_unique_numbers(s): Given a string 's' representing a number, return the number of unique numbers that can be generated by changing each '6' to '9' or vice versa. count_6 = s.count('6') count_9 = s.count('9') # Calculate the number of unique permutations by considering independent changes of '6' and '9' unique_count = 2 ** count_6 * 2 ** count_9 return unique_count def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(count_unique_numbers(s)) return results"},{"question":"def longest_consecutive_subsequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest consecutive subsequence of distinct integers. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing the number of elements in the sequence and the sequence itself. Returns: List[int]: A list containing the length of the longest consecutive subsequence for each test case. >>> longest_consecutive_subsequence(3, [(7, [1, 2, 3, 4, 5, 2, 4]), (6, [1, 2, 2, 3, 4, 5]), (5, [5, 1, 2, 3, 1])]) [5, 4, 4] >>> longest_consecutive_subsequence(1, [(5, [2, 2, 2, 2, 2])]) [1] >>> longest_consecutive_subsequence(2, [(6, [1, 2, 1, 2, 1, 2]), (10, [1, 2, 3, 1, 2, 3, 4, 5, 6, 7])]) [2, 7]","solution":"def longest_consecutive_subsequence(t, test_cases): results = [] for i in range(t): n, sequence = test_cases[i] seen = {} # Dictionary to store the last seen position of each element start = 0 # Start of the current window max_length = 0 for j in range(n): if sequence[j] in seen: start = max(start, seen[sequence[j]] + 1) seen[sequence[j]] = j max_length = max(max_length, j - start + 1) results.append(max_length) return results # Example usage: # test_cases = [ # (7, [1, 2, 3, 4, 5, 2, 4]), # (6, [1, 2, 2, 3, 4, 5]), # (5, [5, 1, 2, 3, 1]) # ] # print(longest_consecutive_subsequence(3, test_cases)) # Output: [5, 4, 4]"},{"question":"def shortest_path_maze(N: int, M: int, maze: List[str]) -> Union[int, str]: Determines the shortest path in a maze from (0, 0) to (N-1, M-1). Parameters: N (int): Number of rows in the maze. M (int): Number of columns in the maze. maze (list): List of strings representing the maze grid. Returns: int or str: Length of the shortest path or \\"Impossible\\" if no path exists. Example: >>> N = 4 >>> M = 5 >>> maze = [ \\".....\\", \\".#...\\", \\"....#\\", \\".....\\" ] >>> shortest_path_maze(N, M, maze) 8 >>> N = 3 >>> M = 3 >>> maze = [ \\".#.\\", \\"#\\", \\".#.\\" ] >>> shortest_path_maze(N, M, maze) \\"Impossible\\" pass from collections import deque from typing import List, Union def test_example_1(): N = 4 M = 5 maze = [ \\".....\\", \\".#...\\", \\"....#\\", \\".....\\" ] assert shortest_path_maze(N, M, maze) == 8 def test_example_2(): N = 3 M = 3 maze = [ \\".#.\\", \\"#\\", \\".#.\\" ] assert shortest_path_maze(N, M, maze) == \\"Impossible\\" def test_start_blocked(): N = 3 M = 3 maze = [ \\"#..\\", \\"...\\", \\"...\\" ] assert shortest_path_maze(N, M, maze) == \\"Impossible\\" def test_end_blocked(): N = 3 M = 3 maze = [ \\"...\\", \\"...\\", \\"..#\\" ] assert shortest_path_maze(N, M, maze) == \\"Impossible\\" def test_direct_path(): N = 2 M = 2 maze = [ \\"..\\", \\"..\\" ] assert shortest_path_maze(N, M, maze) == 3 def test_large_maze(): N = 5 M = 5 maze = [ \\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\" ] assert shortest_path_maze(N, M, maze) == 9","solution":"from collections import deque def shortest_path_maze(N, M, maze): Determines the shortest path in a maze from (0, 0) to (N-1, M-1). Parameters: N (int): Number of rows in the maze. M (int): Number of columns in the maze. maze (list): List of strings representing the maze grid. Returns: int or str: Length of the shortest path or \\"Impossible\\" if no path exists. if maze[0][0] == '#' or maze[N-1][M-1] == '#': return \\"Impossible\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * M for _ in range(N)] queue = deque([(0, 0, 1)]) # (row, column, distance) visited[0][0] = True while queue: r, c, dist = queue.popleft() if r == N-1 and c == M-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and not visited[nr][nc] and maze[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return \\"Impossible\\" # Example usage: N = 4 M = 5 maze = [ \\".....\\", \\".#...\\", \\"....#\\", \\".....\\" ] print(shortest_path_maze(N, M, maze)) # Output: 8"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if the string can be rearranged to form a palindrome. Examples: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> can_form_palindrome(\\"TacoCat\\") True >>> can_form_palindrome(\\"randomString\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aa\\") True","solution":"from collections import Counter def can_form_palindrome(s): Determine if the string can be rearranged to form a palindrome. # Filter out non-alphabetic characters and convert to lower case filtered_s = ''.join(filter(str.isalpha, s)).lower() # Count the frequency of each character char_count = Counter(filtered_s) # Check the number of characters with an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd count return odd_count <= 1"},{"question":"from typing import List, Tuple def preprocess_text(text: str) -> str: Preprocess tweet text by converting to lowercase and removing special characters. :param text: The original tweet text :return: The preprocessed tweet text def train_model(training_data: List[Tuple[str, str, str]]) -> dict: Train a simple keyword-based classification model based on keyword frequencies in the training data. :param training_data: List of tuples where each tuple contains tweet_id, tweet_text, category :return: A dictionary with category numbers as keys and keyword frequencies as values def classify_tweet(tweet: str, category_keywords: dict) -> str: Classify a tweet based on the trained keyword frequencies. :param tweet: The tweet text to classify :param category_keywords: A dictionary with category numbers as keys and keyword frequencies as values :return: The predicted category number as a string def classify_tweets(tweets: List[str], category_keywords: dict) -> List[str]: Classify a list of tweets and return their categories. :param tweets: List of tweet texts to classify :param category_keywords: A dictionary with category numbers as keys and keyword frequencies as values :return: A list of predicted category numbers as strings","solution":"import re import csv from collections import defaultdict def preprocess_text(text): Preprocess tweet text by converting to lowercase and removing special characters. text = text.lower() text = re.sub(r'[^ws]', '', text) return text def train_model(training_data): Train a simple keyword-based classification model based on keyword frequencies in the training data. category_keywords = defaultdict(lambda: defaultdict(int)) for tweet_id, tweet_text, category in training_data: words = preprocess_text(tweet_text).split() for word in words: category_keywords[category][word] += 1 return category_keywords def classify_tweet(tweet, category_keywords): Classify a tweet based on the trained keyword frequencies. words = preprocess_text(tweet).split() category_scores = defaultdict(int) for category, keywords in category_keywords.items(): for word in words: category_scores[category] += keywords.get(word, 0) return max(category_scores, key=category_scores.get) def classify_tweets(tweets, category_keywords): Classify a list of tweets and return their categories. return [classify_tweet(tweet, category_keywords) for tweet in tweets] # Example usage of the solution's functions: def main(training_data, test_tweets): category_keywords = train_model(training_data) return classify_tweets(test_tweets, category_keywords)"},{"question":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, graph): edges = [] for i in range(n): for j in range(i+1, n): if graph[i][j] != 0: edges.append((graph[i][j], i, j)) edges.sort() parent = [i for i in range(n)] rank = [0] * n mst_weight = 0 for weight, u, v in edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += weight return mst_weight def calculate_mst_weight(n, adjacency_matrix): Given an undirected, weighted graph represented by its adjacency matrix, determine the weight of the minimum spanning tree using Kruskal's algorithm. >>> calculate_mst_weight(4, [[0, 1, 3, 0], [1, 0, 3, 6], [3, 3, 0, 2], [0, 6, 2, 0]]) 6 >>> calculate_mst_weight(2, [[0, 1], [1, 0]]) 1 >>> calculate_mst_weight(3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, graph): edges = [] for i in range(n): for j in range(i+1, n): if graph[i][j] != 0: edges.append((graph[i][j], i, j)) edges.sort() parent = [i for i in range(n)] rank = [0] * n mst_weight = 0 for weight, u, v in edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += weight return mst_weight def calculate_mst_weight(n, adjacency_matrix): return kruskal_mst(n, adjacency_matrix) # Example Input # n = 4 # matrix = [ # [0, 1, 3, 0], # [1, 0, 3, 6], # [3, 3, 0, 2], # [0, 6, 2, 0] # ] # Output: 6"},{"question":"from collections import deque from typing import List, Tuple def minimum_moves_to_goal(grid: List[List[str]], start: Tuple[int, int], goal: Tuple[int, int]) -> int: Determine the minimum number of moves required for a robot to navigate from its starting position to a given goal position in a grid-based arena. The grid is represented as a list of lists, where '.' denotes an empty cell and '#' denotes an obstacle. Args: grid (List[List[str]]): The grid representing the arena. start (Tuple[int, int]): The starting position of the robot in (row, column) format. goal (Tuple[int, int]): The goal position the robot needs to navigate to in (row, column) format. Returns: int: The minimum number of moves required to reach the goal position from the starting position. Returns -1 if it is not possible to reach the goal. Examples: >>> grid = [ ... ['.', '.', '.', '.', '.'], ... ['.', '#', '#', '#', '.'], ... ['.', '#', '.', '.', '.'], ... ['.', '#', '.', '#', '.'], ... ['.', '.', '.', '.', '.'] ... ] >>> start = (0, 0) >>> goal = (4, 4) >>> minimum_moves_to_goal(grid, start, goal) 8 >>> grid = [ ... ['.', '#', '#', '#', '.'], ... ['#', '#', '#', '#', '.'], ... ['.', '#', '.', '.', '.'], ... ['.', '#', '.', '#', '.'], ... ['.', '.', '.', '.', '.'] ... ] >>> start = (0, 0) >>> goal = (4, 4) >>> minimum_moves_to_goal(grid, start, goal) -1 pass def test_minimum_moves_to_goal(): grid = [ ['.', '.', '.', '.', '.'], ['.', '#', '#', '#', '.'], ['.', '#', '.', '.', '.'], ['.', '#', '.', '#', '.'], ['.', '.', '.', '.', '.'] ] start = (0, 0) goal = (4, 4) assert minimum_moves_to_goal(grid, start, goal) == 8 def test_no_possible_path(): grid = [ ['.', '#', '#', '#', '.'], ['#', '#', '#', '#', '.'], ['.', '#', '.', '.', '.'], ['.', '#', '.', '#', '.'], ['.', '.', '.', '.', '.'] ] start = (0, 0) goal = (4, 4) assert minimum_moves_to_goal(grid, start, goal) == -1 def test_direct_path(): grid = [ ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'] ] start = (0, 0) goal = (4, 4) assert minimum_moves_to_goal(grid, start, goal) == 8 def test_start_is_goal(): grid = [ ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'] ] start = (2, 2) goal = (2, 2) assert minimum_moves_to_goal(grid, start, goal) == 0 def test_large_grid(): grid = [['.'] * 1000 for _ in range(1000)] start = (0, 0) goal = (999, 999) # Simple large grid, need to make sure it doesn't time out assert minimum_moves_to_goal(grid, start, goal) == 1998 def test_obstacle_at_start_or_goal(): grid = [ ['#', '.', '.', '.', '.'], ['.', '#', '#', '#', '.'], ['.', '#', '.', '.', '.'], ['.', '#', '.', '#', '.'], ['.', '.', '.', '.', '#'] ] start = (0, 0) goal = (4, 4) assert minimum_moves_to_goal(grid, start, goal) == -1 start = (0, 1) goal = (4, 4) assert minimum_moves_to_goal(grid, start, goal) == -1","solution":"from collections import deque def minimum_moves_to_goal(grid, start, goal): N, M = len(grid), len(grid[0]) sx, sy = start gx, gy = goal if grid[sx][sy] == '#' or grid[gx][gy] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy, 0)]) # (x, y, distance) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (gx, gy): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def is_subsequence(s: str, t: str) -> bool: Determines if string \`t\` is a subsequence of string \`s\`. Parameters: s (str): The source string. t (str): The target string. Returns: bool: True if \`t\` is a subsequence of \`s\`, False otherwise. Examples: >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"aec\\") False","solution":"def is_subsequence(s, t): Returns True if \`t\` is a subsequence of \`s\`, otherwise False. Parameters: - s (str): The source string. - t (str): The target string. Returns: - bool: True if \`t\` is a subsequence of \`s\`, False otherwise. t_index = 0 s_index = 0 len_t = len(t) len_s = len(s) while t_index < len_t and s_index < len_s: if t[t_index] == s[s_index]: t_index += 1 s_index += 1 return t_index == len_t"},{"question":"def can_attend_all_workshops(n, workshops): Determine whether Mark can attend all workshops without any conflicts. Parameters: n (int): Number of workshops. workshops (list of tuples): A list of tuples where each tuple contains two integers (start_day, end_day). Returns: str: \\"YES\\" if there are no conflicts, otherwise \\"NO\\". >>> can_attend_all_workshops(2, [(1, 5), (6, 10)]) 'YES' >>> can_attend_all_workshops(3, [(1, 3), (4, 6), (2, 5)]) 'NO' >>> can_attend_all_workshops(1, [(1, 365)]) 'YES' >>> can_attend_all_workshops(2, [(10, 20), (300, 310)]) 'YES' >>> can_attend_all_workshops(2, [(1, 100), (101, 200)]) 'YES' >>> can_attend_all_workshops(3, [(1, 2), (2, 3), (3, 4)]) 'NO'","solution":"def can_attend_all_workshops(n, workshops): Determine whether Mark can attend all workshops without any conflicts. Parameters: n (int): Number of workshops. workshops (list of tuples): A list of tuples where each tuple contains two integers (start_day, end_day). Returns: str: \\"YES\\" if there are no conflicts, otherwise \\"NO\\". # Sort workshops by their start time workshops.sort() # Check for overlapping intervals for i in range(1, n): # If the current workshop starts before the previous one ends, there's a conflict if workshops[i][0] <= workshops[i - 1][1]: return \\"NO\\" return \\"YES\\""},{"question":"def is_prime(n): Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False def get_primes(array): Returns a new array containing only the prime numbers from the input array, preserving the order of their first occurrence. >>> get_primes([15, 3, 8, 11, 2, 5, 4, 2]) [3, 11, 2, 5, 2] >>> get_primes([20, 25, 2, 29, 30, 31]) [2, 29, 31] >>> get_primes([]) []","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def get_primes(array): Returns a new array containing only the prime numbers from the input array, preserving the order of their first occurrence. return [num for num in array if is_prime(num)]"},{"question":"from collections import defaultdict class TaskScheduler: A class that handles the scheduling of tasks based on their priorities. The scheduler executes tasks in the order of their priority, from highest to lowest. If two tasks have the same priority, they are executed in the order they were added to the system. def __init__(self): Initializes an empty task scheduler. def add_task(self, priority: int, task: str) -> None: Adds a task with a given priority to the scheduler. def execute_tasks(self) -> list: Executes all tasks in the scheduler based on their priority, returning a list of executed tasks in the order of their execution.","solution":"from collections import defaultdict class TaskScheduler: def __init__(self): self.tasks = defaultdict(list) def add_task(self, priority: int, task: str) -> None: self.tasks[priority].append(task) def execute_tasks(self) -> list: executed_tasks = [] for priority in sorted(self.tasks.keys(), reverse=True): executed_tasks.extend(self.tasks[priority]) return executed_tasks"},{"question":"def check_duplicates(test_cases): Given an integer array arr of size 'n', determine whether there exist two indices i and j such that 1 <= i < j <= n and arr[i] == arr[j]. If such a pair exists, return \\"YES\\". Otherwise, return \\"NO\\". Args: test_cases: List[Tuple[int, List[int]]], where each tuple contains an integer n and a list of n integers. Returns: results: List[str], where each string is either \\"YES\\" or \\"NO\\" for each test case. Example: >>> check_duplicates([(5, [1, 2, 3, 4, 5]), (6, [1, 3, 3, 2, 2, 1])]) ['NO', 'YES'] >>> check_duplicates([(1, [1000000000])]) ['NO'] >>> check_duplicates([(3, [5, 5, 5])]) ['YES'] >>> check_duplicates([(4, [7, 15, 23, 42])]) ['NO'] >>> check_duplicates([(5, [-1, -2, -3, -4, -1])]) ['YES'] def process_input(input_str): Processes the input string into a list of test cases. Args: input_str: str, input string containing the number of test cases, followed by the test cases themselves. Returns: test_cases: List[Tuple[int, List[int]]], processed test cases. Example: >>> process_input(\\"2n5n1 2 3 4 5n6n1 3 3 2 2 1\\") [(5, [1, 2, 3, 4, 5]), (6, [1, 3, 3, 2, 2, 1])] def main(input_str): The main function to process the input string, check for duplicates, and return the results. Args: input_str: str, input string containing the number of test cases, followed by the test cases themselves. Returns: result_str: str, output results concatenated for each test case separated by a newline. Example: >>> main(\\"2n5n1 2 3 4 5n6n1 3 3 2 2 1\\") 'NOnYES'","solution":"def check_duplicates(test_cases): results = [] for case in test_cases: n, arr = case seen = set() found = False for num in arr: if num in seen: results.append(\\"YES\\") found = True break seen.add(num) if not found: results.append(\\"NO\\") return results def process_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return test_cases def main(input_str): test_cases = process_input(input_str) results = check_duplicates(test_cases) return \\"n\\".join(results)"},{"question":"def closestElement(arr, N, X): Given a sorted array arr[] of N integers and an integer X, finds the element in the array that has the closest difference to X. If there are multiple elements with the same closest difference, returns the smallest one. >>> closestElement([1, 2, 4, 8, 16], 5, 7) 8 >>> closestElement([1, 2, 3, 4, 5, 15], 6, 10) 5","solution":"def closestElement(arr, N, X): Returns the element in arr which is closest to X. If there is a tie, returns the smallest element. # Edge Cases if N == 0: return None if X <= arr[0]: return arr[0] if X >= arr[-1]: return arr[-1] # Binary Search to find the closest element low, high = 0, N - 1 close_element = None while low <= high: mid = (low + high) // 2 if arr[mid] == X: return arr[mid] elif arr[mid] < X: close_element = arr[mid] low = mid + 1 else: high = mid - 1 # We have the closest element now, we need to handle tie cases # closest_element could be in arr[high] or arr[low] if there is a tie if close_element is None: close_element = arr[low] closest_diff = abs(close_element - X) if low < N: dist_low = abs(arr[low] - X) if dist_low < closest_diff or (dist_low == closest_diff and arr[low] < close_element): close_element = arr[low] return close_element"},{"question":"def max_coins(grid): Calculates the maximum number of coins Henry can collect by moving from the top-left cell to the bottom-right cell in the grid. >>> max_coins([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_coins([ ... [1, 2, 3, 4] ... ]) 10 >>> max_coins([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_coins([ ... [5] ... ]) 5 >>> max_coins([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29","solution":"def max_coins(grid): N = len(grid) M = len(grid[0]) dp = [[0] * M for _ in range(N)] dp[0][0] = grid[0][0] for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][M-1]"},{"question":"def beautify_flower_beds(input_string: str) -> List[int]: Calculate the maximum possible beauty of Mina's flower bed after rearrangement. Args: input_string (str): The input string describing the test cases and grids. Returns: List[int]: A list of integers representing the maximum possible beauty for each test case. Example: >>> beautify_flower_beds(\\"3n3 3 3n1 2 3n3 2 1n1 3 2n4 4 4n1 2 1 2n2 1 2 1n3 4 3 4n4 3 4 3n5 5 5n1 1 1 1 1n2 2 2 2 2n3 3 3 3 3n4 4 4 4 4n5 5 5 5 5\\") [3, 4, 5] >>> beautify_flower_beds(\\"1n2 2 1n1 1n1 1\\") [4] >>> beautify_flower_beds(\\"1n3 3 3n2 2 2n2 2 2n2 2 2\\") [9] >>> beautify_flower_beds(\\"1n3 3 9n1 2 3n4 5 6n7 8 9\\") [1] >>> beautify_flower_beds(\\"2n2 2 2n1 2n2 1n3 3 3n1 2 3n3 1 2n2 3 1\\") [2, 3] pass def test_beautify_flower_beds(): input_string = \\"3n3 3 3n1 2 3n3 2 1n1 3 2n4 4 4n1 2 1 2n2 1 2 1n3 4 3 4n4 3 4 3n5 5 5n1 1 1 1 1n2 2 2 2 2n3 3 3 3 3n4 4 4 4 4n5 5 5 5 5\\" expected_output = [3, 4, 5] assert beautify_flower_beds(input_string) == expected_output def test_single_type(): input_string = \\"1n2 2 1n1 1n1 1\\" expected_output = [4] assert beautify_flower_beds(input_string) == expected_output def test_no_rearrangement_needed(): input_string = \\"1n3 3 3n2 2 2n2 2 2n2 2 2\\" expected_output = [9] assert beautify_flower_beds(input_string) == expected_output def test_all_unique_types(): input_string = \\"1n3 3 9n1 2 3n4 5 6n7 8 9\\" expected_output = [1] assert beautify_flower_beds(input_string) == expected_output def test_multiple_cases(): input_string = \\"2n2 2 2n1 2n2 1n3 3 3n1 2 3n3 1 2n2 3 1\\" expected_output = [2, 3] assert beautify_flower_beds(input_string) == expected_output","solution":"def max_beauty(grid, N, M): Calculate the maximum possible beauty of the flower bed after rearrangement. flower_counts = {} for row in grid: for flower in row: if flower in flower_counts: flower_counts[flower] += 1 else: flower_counts[flower] = 1 max_line_length = max(flower_counts.values()) return max_line_length def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0].strip()) index = 1 test_cases = [] for _ in range(T): N, M, K = map(int, lines[index].strip().split()) index += 1 grid = [] for i in range(N): grid.append(list(map(int, lines[index].strip().split()))) index += 1 test_cases.append((grid, N, M, K)) return test_cases def beautify_flower_beds(input_string): test_cases = parse_input(input_string) result = [] for grid, N, M, K in test_cases: result.append(max_beauty(grid, N, M)) return result"},{"question":"def min_difference_chocolates(n, k, chocolates): Function to determine the minimum possible difference between the maximum and minimum number of chocolates in k contiguous blocks of houses. n: int - number of houses k: int - number of blocks chocolates: list - list of integers representing chocolates in each house return: int - minimum possible difference between the most and least chocolates in the blocks >>> min_difference_chocolates(5, 2, [1, 3, 2, 6, 4]) 1 >>> min_difference_chocolates(8, 3, [9, 3, 8, 4, 7, 2, 6, 5]) 2 >>> min_difference_chocolates(6, 3, [10, 30, 40, 20, 50, 60]) 20 pass","solution":"def min_difference_chocolates(n, k, chocolates): Function to determine the minimum possible difference between the maximum and minimum number of chocolates in k contiguous blocks of houses. n: int - number of houses k: int - number of blocks chocolates: list - list of integers representing chocolates in each house return: int - minimum possible difference between the most and least chocolates in the blocks chocolates.sort() min_diff = float('inf') for i in range(n - k + 1): current_diff = chocolates[i + k - 1] - chocolates[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 from solution import longest_consecutive def test_example_case_1(): assert longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 def test_example_case_2(): assert longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 def test_empty_array(): assert longest_consecutive([]) == 0 def test_no_consecutive_elements(): assert longest_consecutive([10, 5, 20]) == 1 def test_all_positive_elements(): assert longest_consecutive([10, 1, 11, 3, 2]) == 3 def test_including_negatives(): assert longest_consecutive([1, -1, 0, -2]) == 4 def test_multiple_consecutive_sequences(): assert longest_consecutive([1, 9, 3, 10, 2, 20, 4]) == 4","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) max_length = 0 for num in nums: # Only start counting if \`num\` is the start of a sequence if num - 1 not in num_set: current_num = num current_length = 1 # Count the length of the sequence from \`num\` while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def maximum(x: int, y: int) -> Union[int, str]: Returns the maximum of the two integers x and y. If x and y are equal, returns the string \\"Equal\\". >>> maximum(7, 5) 7 >>> maximum(10, 10) \\"Equal\\" >>> maximum(5, 7) 7 >>> maximum(1, 2) 2 >>> maximum(10**9, 10**9 - 1) 10**9 # Your code goes here","solution":"def maximum(x, y): Returns the maximum of the two integers x and y. If x and y are equal, returns the string \\"Equal\\". if x > y: return x elif y > x: return y else: return \\"Equal\\""},{"question":"def maxSubarraySum(arr: List[int]) -> int: Returns the maximum sum of a contiguous subarray. >>> maxSubarraySum([1, 2, 3]) 6 >>> maxSubarraySum([2, 1, 3, 4]) 10 >>> maxSubarraySum([0, 0, 0, 0]) 0 >>> maxSubarraySum([1, 2, 3, -2, 5]) 9 >>> maxSubarraySum([4, -1, 2, 1]) 6 def process_input(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases of arrays to determine the maximum sum of a contiguous subarray for each. Args: t (int): the number of test cases. cases (List[Tuple[int, List[int]]]): list of tuples where the first element is the length of the array and the second element is the array itself. Returns: List[int]: list of the maximum sum of a contiguous subarray for each test case. >>> process_input(2, [(3, [1, 2, 3]), (4, [2, 1, 3, 4])]) [6, 10] >>> process_input(2, [(5, [1, 2, 3, -2, 5]), (4, [4, -1, 2, 1])]) [9, 6] >>> process_input(2, [(1, [0]), (3, [0, 0, 0])]) [0, 0]","solution":"def maxSubarraySum(arr): Returns the maximum sum of a contiguous subarray. # Initialize our variables max_current = max_global = arr[0] # Iterate through the array starting from the second element for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def process_input(t, cases): results = [] for case in cases: n, arr = case result = maxSubarraySum(arr) results.append(result) return results"},{"question":"def lexicographically_smallest_string(s: str) -> str: Peter was given a string \`s\` which contains only lowercase English letters. He can perform the following operation on the string any number of times: select two different indices \`i\` and \`j\` such that \`s[i] != s[j]\` and swap \`s[i]\` and \`s[j]\`. Peter wants to know the lexicographically smallest string he can obtain after performing any number of these operations. >>> lexicographically_smallest_string(\\"dcba\\") 'abcd' >>> lexicographically_smallest_string(\\"hello\\") 'ehllo' >>> lexicographically_smallest_string(\\"bubble\\") 'bbbelu' >>> lexicographically_smallest_string(\\"algorithm\\") 'aghilmort'","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by any number of swaps. return ''.join(sorted(s))"},{"question":"MOD = 10**9 + 7 def sum_of_divisors(n: int) -> int: Returns the sum of divisors of the given number n. >>> sum_of_divisors(4) 7 >>> sum_of_divisors(6) 12 >>> sum_of_divisors(8) 15 >>> sum_of_divisors(9) 13 >>> sum_of_divisors(10) 18 >>> sum_of_divisors(1) 1 pass def sum_divisors_in_range(numbers: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the sum of divisors for each query range. >>> numbers = [4, 6, 8, 9, 10] >>> queries = [(1, 3), (2, 5)] >>> sum_divisors_in_range(numbers, queries) [34 % MOD, 58 % MOD] >>> numbers = [2, 3, 5, 7, 11, 13, 17, 19] >>> queries = [(1, 8), (1, 4), (5, 8)] >>> expected = [ ... (sum(sum_of_divisors(num) for num in numbers[0:8]) % MOD), ... (sum(sum_of_divisors(num) for num in numbers[0:4]) % MOD), ... (sum(sum_of_divisors(num) for num in numbers[4:8]) % MOD) ... ] >>> sum_divisors_in_range(numbers, queries) expected pass","solution":"MOD = 10**9 + 7 def sum_of_divisors(n): Returns the sum of divisors of the given number n. if n == 1: return 1 total = 1 + n for i in range(2, int(n ** 0.5) + 1): if n % i == 0: total += i if i != n // i: total += n // i return total def sum_divisors_in_range(numbers, queries): Returns the sum of divisors for each query range. results = [] for L, R in queries: range_sum = 0 for i in range(L - 1, R): range_sum += sum_of_divisors(numbers[i]) range_sum %= MOD results.append(range_sum) return results"},{"question":"def filter_words_by_length(words, n): Create a function that takes a list of words and a number \`n\`, and returns a new list containing only the words that have exactly \`n\` characters. Parameters: words (list): List of words. n (int): Number of characters to filter the words by. Returns: list: A new list with words of exactly \`n\` characters. >>> filter_words_by_length([\\"apple\\", \\"pear\\", \\"banana\\", \\"fig\\", \\"kiwi\\"], 4) ['pear', 'kiwi'] >>> filter_words_by_length([\\"cherry\\", \\"plum\\", \\"strawberry\\", \\"mango\\"], 5) ['mango']","solution":"def filter_words_by_length(words, n): Returns a new list containing only the words that have exactly \`n\` characters. Parameters: words (list): List of words. n (int): Number of characters to filter the words by. Returns: list: A new list with words of exactly \`n\` characters. return [word for word in words if len(word) == n]"},{"question":"def snowball_fight(tim, jerry): Determines the winner of the snowball fight based on the number of hits. Parameters: tim (list): List of results of Tim's throws (either \\"hit\\" or \\"miss\\"). jerry (list): List of results of Jerry's throws (either \\"hit\\" or \\"miss\\"). Returns: int: 0 if Tim wins, 1 if Jerry wins, -1 if it's a draw. Examples: >>> snowball_fight([\\"hit\\", \\"miss\\", \\"hit\\"], [\\"miss\\", \\"hit\\", \\"miss\\"]) 0 >>> snowball_fight([\\"hit\\", \\"miss\\", \\"miss\\"], [\\"hit\\", \\"hit\\", \\"miss\\"]) 1 >>> snowball_fight([\\"hit\\", \\"miss\\", \\"hit\\"], [\\"miss\\", \\"hit\\", \\"hit\\"]) -1 >>> snowball_fight([\\"miss\\", \\"miss\\", \\"miss\\"], [\\"miss\\", \\"miss\\", \\"miss\\"]) -1 >>> snowball_fight([\\"hit\\", \\"hit\\", \\"hit\\"], [\\"miss\\", \\"miss\\", \\"miss\\"]) 0 >>> snowball_fight([\\"miss\\", \\"miss\\", \\"miss\\"], [\\"hit\\", \\"hit\\", \\"hit\\"]) 1 >>> snowball_fight([\\"hit\\", \\"miss\\", \\"hit\\", \\"miss\\"], [\\"miss\\", \\"hit\\", \\"miss\\", \\"hit\\"]) -1 >>> snowball_fight([], []) -1","solution":"def snowball_fight(tim, jerry): Determines the winner of the snowball fight based on the number of hits. Parameters: tim (list): List of results of Tim's throws (either \\"hit\\" or \\"miss\\"). jerry (list): List of results of Jerry's throws (either \\"hit\\" or \\"miss\\"). Returns: int: 0 if Tim wins, 1 if Jerry wins, -1 if it's a draw. tim_hits = tim.count(\\"hit\\") jerry_hits = jerry.count(\\"hit\\") if tim_hits > jerry_hits: return 0 elif jerry_hits > tim_hits: return 1 else: return -1"},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: Returns the number of distinct non-overlapping palindromic substrings within a string s. >>> count_distinct_palindromic_substrings(\\"abba\\") 4 >>> count_distinct_palindromic_substrings(\\"abcbaabcb\\") 9","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct non-overlapping palindromic substrings in s. n = len(s) palindrome_set = set() # Helper function to expand around center and add valid palindromes to the set def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: palindrome_set.add(s[left:right+1]) left -= 1 right += 1 # Check all possible centers for palindromes for center in range(n): # Odd-length palindromes expand_around_center(center, center) # Even-length palindromes expand_around_center(center, center + 1) return len(palindrome_set)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a simple mathematical expression consisting of non-negative integers, plus (+) and minus (-) signs, and spaces. Return the result as an integer. >>> evaluate_expression(\\"3 + 5\\") 8 >>> evaluate_expression(\\"10 + 2 - 6\\") 6 >>> evaluate_expression(\\"100 + 200 + 300\\") 600 >>> evaluate_expression(\\"5 - 3\\") 2 >>> evaluate_expression(\\" 1 + 2 + 3 \\") 6","solution":"def evaluate_expression(expression: str) -> int: Evaluate a simple mathematical expression consisting of non-negative integers, plus (+) and minus (-) signs, and spaces. Return the result as an integer. # Split the expression by spaces to process each part tokens = expression.split() # Initialize result with the first number result = int(tokens[0]) # Use a simple state machine to track operations i = 1 while i < len(tokens): operator = tokens[i] operand = int(tokens[i + 1]) if operator == '+': result += operand elif operator == '-': result -= operand i += 2 # Move to the next operator return result"},{"question":"def longest_symmetric_subsequence_length(seq: List[int]) -> int: Returns the length of the longest symmetric subsequence within the given sequence of color codes. >>> longest_symmetric_subsequence_length([1, 4, 5, 9, 4, 1, 1]) 5 >>> longest_symmetric_subsequence_length([1, 2, 3, 2, 1]) 5 def solve_longest_symmetric_subsequence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns a list of integers representing the length of the longest symmetric subsequence for each test case. >>> solve_longest_symmetric_subsequence(2, [(7, [1, 4, 5, 9, 4, 1, 1]), (5, [1, 2, 3, 2, 1])]) [5, 5]","solution":"def longest_symmetric_subsequence_length(seq): Returns the length of the longest symmetric subsequence within the given sequence of color codes. n = len(seq) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if seq[i] == seq[j] and cl == 2: dp[i][j] = 2 elif seq[i] == seq[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve_longest_symmetric_subsequence(T, test_cases): results = [] for case in test_cases: N, seq = case results.append(longest_symmetric_subsequence_length(seq)) return results"},{"question":"def find_winner(n, piles): Determines the winner of the game given the state of the piles. Parameters: n (int): The number of piles. piles (list of int): The number of stones in each pile. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. pass # Your implementation here # Example Test Cases print(find_winner(1, [2])) # Alice print(find_winner(2, [2, 3])) # Bob print(find_winner(3, [3, 3, 3])) # Alice","solution":"def find_winner(n, piles): Determines the winner of the game given the state of the piles. Parameters: n (int): The number of piles. piles (list of int): The number of stones in each pile. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. for pile in piles: if pile > 1: return \\"Alice\\" return \\"Bob\\""},{"question":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the list of integers. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 >>> max_non_adjacent_sum([5]) == 5 >>> max_non_adjacent_sum([2, 10]) == 10 >>> max_non_adjacent_sum([-1, -2, -3, -4]) == 0 >>> max_non_adjacent_sum([-1, 2, -3, 4, -5, 6]) == 12 >>> max_non_adjacent_sum([]) == 0 >>> max_non_adjacent_sum([1000, 1000, 1000, 1000, 1000]) == 3000","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the list of integers. if not nums: return 0 incl = 0 # Max sum including the previous element excl = 0 # Max sum excluding the previous element for num in nums: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl) def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = list(map(int, data[1:])) print(max_non_adjacent_sum(nums))"},{"question":"def isPalindrome(num: int) -> bool: Checks if the given integer is a palindromic number. Returns True if it is, and False otherwise. >>> isPalindrome(121) True >>> isPalindrome(123) False >>> isPalindrome(12321) True >>> isPalindrome(-121) False","solution":"def isPalindrome(num): Checks if the given integer is a palindromic number. Returns True if it is, and False otherwise. if num < 0: return False num_str = str(num) return num_str == num_str[::-1]"},{"question":"def find_subsequence(n: int, k: int, sequence: List[int]) -> str: Determines if there exists a contiguous sub-sequence whose sum is divisible by k. >>> find_subsequence(5, 3, [1, 2, 3, 4, 5]) \\"YES\\" >>> find_subsequence(4, 11, [1, 2, 4, 8]) \\"NO\\" >>> find_subsequence(6, 5, [-1, 2, 9, -4, 3, 1]) \\"YES\\" >>> find_subsequence(3, 7, [14, -3, -4]) \\"YES\\" from typing import List def test_example1(): n = 5 k = 3 sequence = [1, 2, 3, 4, 5] assert find_subsequence(n, k, sequence) == \\"YES\\" def test_example2(): n = 4 k = 11 sequence = [1, 2, 4, 8] assert find_subsequence(n, k, sequence) == \\"NO\\" def test_example3(): n = 6 k = 5 sequence = [-1, 2, 9, -4, 3, 1] assert find_subsequence(n, k, sequence) == \\"YES\\" def test_example4(): n = 3 k = 7 sequence = [14, -3, -4] assert find_subsequence(n, k, sequence) == \\"YES\\" def test_single_element_positive(): n = 1 k = 1 sequence = [1] assert find_subsequence(n, k, sequence) == \\"YES\\" def test_single_element_negative(): n = 1 k = 2 sequence = [1] assert find_subsequence(n, k, sequence) == \\"NO\\" def test_all_negative_numbers(): n = 5 k = 3 sequence = [-1, -2, -3, -4, -5] assert find_subsequence(n, k, sequence) == \\"YES\\" def test_no_subsequence(): n = 5 k = 100 sequence = [1, 1, 1, 1, 1] assert find_subsequence(n, k, sequence) == \\"NO\\" def test_subsequence_at_the_end(): n = 5 k = 10 sequence = [1, 2, 3, 4, 10] assert find_subsequence(n, k, sequence) == \\"YES\\" def test_subsequence_in_the_middle(): n = 7 k = 15 sequence = [1, 2, 15, 2, 1, -15, 1] assert find_subsequence(n, k, sequence) == \\"YES\\"","solution":"def has_subsequence_divisible_by_k(n, k, sequence): prefix_sum = 0 prefix_sums_mod_k = {0} for num in sequence: prefix_sum += num mod_k = prefix_sum % k if mod_k in prefix_sums_mod_k: return \\"YES\\" prefix_sums_mod_k.add(mod_k) return \\"NO\\" # Function to read input and call the core function def find_subsequence(n, k, sequence): return has_subsequence_divisible_by_k(n, k, sequence)"},{"question":"def total_matches(t: int) -> int: Returns the total number of matches that will be played in a tournament where each team needs to play with every other team exactly once. >>> total_matches(4) 6 >>> total_matches(10) 45 >>> total_matches(0) 0 >>> total_matches(1) 0 >>> total_matches(2) 1 >>> total_matches(3) 3","solution":"def total_matches(t): Returns the total number of matches that will be played in a tournament where each team needs to play with every other team exactly once. :param t: Number of teams :return: Total number of matches if t < 2: return 0 return t * (t - 1) // 2"},{"question":"def minimal_moves_to_almost_palindrome(t: int, test_cases: List[str]) -> List[int]: Find the minimal number of moves needed to make the string \\"almost palindrome\\". >>> minimal_moves_to_almost_palindrome(3, ['abca', 'abcd', 'racecar']) [1, 2, 0] >>> minimal_moves_to_almost_palindrome(1, ['a']) [0] >>> minimal_moves_to_almost_palindrome(1, ['aaaa']) [0] >>> minimal_moves_to_almost_palindrome(2, ['abcde', 'abcdefghij']) [2, 5]","solution":"def minimal_moves_to_almost_palindrome(t, test_cases): results = [] for s in test_cases: n = len(s) moves = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: moves += 1 results.append(moves) return results"},{"question":"def min_operations_to_empty_string(t, test_cases): Given a number of test cases and the corresponding strings, return the minimum number of operations required to make each string empty by removing contiguous palindromic substrings. Parameters: t (int): Number of test cases test_cases (List[str]): List of strings for each test case Returns: List[int]: List of integers representing the minimum number of operations for each test case Examples: >>> min_operations_to_empty_string(3, [\\"ababa\\", \\"civic\\", \\"racecar\\"]) [1, 1, 1] >>> min_operations_to_empty_string(3, [\\"abb\\", \\"abc\\", \\"aabb\\"]) [2, 2, 2] >>> min_operations_to_empty_string(4, [\\"ababa\\", \\"abc\\", \\"civic\\", \\"aabb\\"]) [1, 2, 1, 2] >>> min_operations_to_empty_string(3, [\\"a\\", \\"b\\", \\"c\\"]) [1, 1, 1] >>> min_operations_to_empty_string(1, [\\"a\\" * 2000]) [1] >>> min_operations_to_empty_string(1, [\\"a\\" * 1000 + \\"b\\" * 1000]) [2]","solution":"def min_operations_to_empty_string(t, test_cases): Given a number of test cases and the corresponding strings, returns the minimum number of operations required to make each string empty by removing contiguous palindromic substrings. results = [] for s in test_cases: if s == s[::-1]: # Check if the whole string is a palindrome results.append(1) else: results.append(2) # Else we can always do it in 2 steps return results"},{"question":"def letter_combinations(digits: str) -> List[str]: Returns all possible letter combinations that the number could represent on a phone keypad. :param digits: str, containing digits from 2 to 9 inclusive :return: list of str, all possible letter combinations in lexicographical order Examples: >>> letter_combinations('23') ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> letter_combinations('47') ['gp', 'gq', 'gr', 'gs', 'hp', 'hq', 'hr', 'hs', 'ip', 'iq', 'ir', 'is'] >>> letter_combinations('') [] >>> letter_combinations('2') ['a', 'b', 'c']","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent on a phone keypad. :param digits: str, containing digits from 2 to 9 inclusive :return: list of str, all possible letter combinations in lexicographical order if not digits: return [] digit_to_char = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(''.join(path)) return possible_letters = digit_to_char[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def trap(height: List[int]) -> int: Returns the total units of water that can be trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([]) 0 >>> trap([3, 2, 1]) 0 >>> trap([5, 3]) 0 >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([1, 1, 1, 1, 1]) 0","solution":"def trap(height): Returns the total units of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[-1] = height[-1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"def max_stock_value(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum possible value that can be achieved by selling and buying stocks optimally. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list containing T tuples, each representing a test case. Each tuple contains: - N (int): The number of stocks. - K (int): The initial stock number you have. - prices (List[int]): A list of N integers representing the prices of the stocks. Returns: List[int]: A list containing the maximum possible values that can be achieved for each test case. Examples: >>> max_stock_value(2, [(5, 2, [10, 1, 5, 8, 7]), (4, 1, [4, 3, 2, 1])]) [8, 4]","solution":"def max_stock_value(T, test_cases): results = [] for case in test_cases: N, K, prices = case # The current stock index is K-1 because prices are zero-indexed in the list current_index = K - 1 # Iterate through the prices from current index to the end max_price = prices[current_index] for i in range(current_index + 1, N): if prices[i] > max_price: max_price = prices[i] # Append the result for the current test case results.append(max_price) return results"},{"question":"def is_prime(n: int) -> bool: Determines if the given number n is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False # Complete the function def smallest_prime_in_range(a: int, b: int) -> int: Returns the smallest prime number in the inclusive range [a, b]. Returns -1 if there is no such prime number. >>> smallest_prime_in_range(10, 20) 11 >>> smallest_prime_in_range(24, 28) -1 # Complete the function","solution":"def is_prime(n): Determines if the given number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def smallest_prime_in_range(a, b): Returns the smallest prime number in the inclusive range [a, b]. Returns -1 if there is no such prime number. for num in range(a, b + 1): if is_prime(num): return num return -1 # Example usage: # print(smallest_prime_in_range(10, 20)) # Output: 11 # print(smallest_prime_in_range(24, 28)) # Output: -1"},{"question":"def mergeTwoSortedArrays(arr1, arr2): Merges two sorted arrays into one sorted array. >>> mergeTwoSortedArrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> mergeTwoSortedArrays([-1, 2, 5, 10], [0, 3, 6, 12, 15]) [-1, 0, 2, 3, 5, 6, 10, 12, 15] >>> mergeTwoSortedArrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> mergeTwoSortedArrays([1], [2]) [1, 2] >>> mergeTwoSortedArrays([], [1, 2, 3]) [1, 2, 3] >>> mergeTwoSortedArrays([1, 2, 3], []) [1, 2, 3]","solution":"def mergeTwoSortedArrays(arr1, arr2): Merges two sorted arrays into one sorted array. i, j = 0, 0 merged_array = [] # Traverse both arrays and merge them while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append any remaining elements from arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append any remaining elements from arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def maximum_profit(V: int, E: int, edges: List[Tuple[int, int, int]]) -> int: Given the number of planets and the trade routes that connect them, along with the associated values of these trade routes, finds the maximum possible profit that can be obtained by establishing a subset of the trade routes without forming a cycle. >>> maximum_profit(4, 5, [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]) 31 >>> maximum_profit(3, 3, [(0, 1, 5), (1, 2, 4), (0, 2, 3)]) 9 >>> maximum_profit(4, 2, [(0, 1, 1), (2, 3, 2)]) 3 >>> maximum_profit(2, 1, [(0, 1, 100)]) 100 >>> maximum_profit(4, 0, []) 0","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def maximum_profit(V, E, edges): # Sort edges in descending order based on the value (w) edges = sorted(edges, key=lambda item: item[2], reverse=True) parent = [] rank = [] # Initialize disjoint sets for node in range(V): parent.append(node) rank.append(0) max_profit = 0 e = 0 for i in range(E): u, v, w = edges[i] x = find(parent, u) y = find(parent, v) if x != y: e += 1 max_profit += w union(parent, rank, x, y) return max_profit"},{"question":"def max_price_change(prices): Calculate the maximum price change within any three consecutive days. :param prices: List of integers representing prices over days. :return: Integer representing the maximum price change. >>> max_price_change([5, 3, 8, 10, 7]) 7 >>> max_price_change([1, 10, 100, 1000]) 990","solution":"def max_price_change(prices): Calculate the maximum price change within any three consecutive days. :param prices: List of integers representing prices over days. :return: Integer representing the maximum price change. max_change = 0 for i in range(len(prices) - 2): change_first_pair = abs(prices[i] - prices[i + 1]) change_second_pair = abs(prices[i + 1] - prices[i + 2]) total_change = change_first_pair + change_second_pair max_change = max(max_change, total_change) return max_change"},{"question":"def pascalsTriangle(n: int) -> str: Returns a string representing the first n rows of Pascal's Triangle. >>> pascalsTriangle(0) '1' >>> pascalsTriangle(1) '1n1 1' >>> pascalsTriangle(2) '1n1 1n1 2 1' >>> pascalsTriangle(3) '1n1 1n1 2 1n1 3 3 1' >>> pascalsTriangle(5) '1n1 1n1 2 1n1 3 3 1n1 4 6 4 1n1 5 10 10 5 1'","solution":"def pascalsTriangle(n): Returns a string representing the first n rows of Pascal's Triangle. if n == 0: return \\"1\\" def generateNextRow(prevRow): return [1] + [prevRow[i] + prevRow[i+1] for i in range(len(prevRow)-1)] + [1] rows = [[1]] for i in range(1, n+1): rows.append(generateNextRow(rows[-1])) return 'n'.join(' '.join(map(str, row)) for row in rows)"},{"question":"def product_array(arr: List[int]) -> List[int]: Returns a list such that each element at index i is the product of all elements in the array except the one at index i. >>> product_array([1, 2, 3]) [6, 3, 2] >>> product_array([1, 2, 3, 4]) [24, 12, 8, 6]","solution":"def product_array(arr): Returns a list such that each element at index i is the product of all elements in the array except the one at index i. n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Calculate right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Calculate result for i in range(n): result[i] = left_products[i] * right_products[i] return result def solve(test_cases): results = [] for t in range(len(test_cases)): n, arr = test_cases[t] result = product_array(arr) results.append(result) return results def parse_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return test_cases def format_output(results): return 'n'.join(' '.join(map(str, result)) for result in results)"},{"question":"def count_assignments(M: int, N: int, employees_skills: List[List[int]], projects_requirements: List[List[int]]) -> int: Counts the unique ways to assign employees to projects such that every project has at least one employee assigned. >>> count_assignments(3, 2, [[1, 2, 3], [2, 3], [4]], [[1, 2], [4]]) 2 def parse_input(input_str: str) -> Tuple[int, int, List[List[int]], List[List[int]]]: Parses the input from a string format to the required format. >>> parse_input(\\"3 2n3 1 2 3n2 2 3n1 4n2 1 2n1 4\\") (3, 2, [[1, 2, 3], [2, 3], [4]], [[1, 2], [4]]) def main(input_str: str): Main function to read the input, process it and print the result. input: \\"3 2n3 1 2 3n2 2 3n1 4n2 1 2n1 4\\" output: 2","solution":"from itertools import product def can_assign(employee_skills, project_requirement): Check if an employee can be assigned to a project based on skills. return set(project_requirement).issubset(employee_skills) def count_assignments(M, N, employees_skills, projects_requirements): Counts the unique ways to assign employees to projects such that every project has at least one employee assigned. # Matrix that stores which employees can be assigned to which projects can_be_assigned = [[can_assign(employees_skills[e], projects_requirements[p]) for p in range(N)] for e in range(M)] def valid_assignment(assignment): return all(any(can_be_assigned[e][p] for e, a in enumerate(assignment) if a == p) for p in range(N)) # Generate all possible assignments of employees to projects all_possible_assignments = product(range(N), repeat=M) # Filter valid assignments valid_count = sum(1 for assignment in all_possible_assignments if valid_assignment(assignment)) return valid_count # Parsing input def parse_input(input_str): lines = input_str.strip().split('n') M, N = map(int, lines[0].split()) employees_skills = [list(map(int, line.split()[1:])) for line in lines[1:M+1]] projects_requirements = [list(map(int, line.split()[1:])) for line in lines[M+1:M+1+N]] return M, N, employees_skills, projects_requirements # Main function to read the input, process it and print the result def main(input_str): M, N, employees_skills, projects_requirements = parse_input(input_str) print(count_assignments(M, N, employees_skills, projects_requirements))"},{"question":"from typing import List def minimum_energy(N: int, M: int, grid: List[str]) -> int: Determine the minimum energy required to navigate from the top-left cell to the bottom-right cell in a grid. If it is not possible to reach the end, return -1. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[str]): The grid represented as a list of strings. Returns: int: The minimum energy required, or -1 if not possible. Examples: >>> minimum_energy(4, 4, [\\"....\\", \\"..#.\\", \\"..#.\\", \\"....\\"]) 6 >>> minimum_energy(3, 3, [\\".#.\\", \\"#\\", \\"..#\\"]) -1 def test_minimum_energy(): assert minimum_energy(4, 4, [ \\"....\\", \\"..#.\\", \\"..#.\\", \\"....\\" ]) == 6 assert minimum_energy(3, 3, [ \\".#.\\", \\"#\\", \\"..#\\" ]) == -1 assert minimum_energy(1, 1, [ \\".\\" ]) == 0 assert minimum_energy(2, 2, [ \\".#\\", \\"#.\\" ]) == -1 assert minimum_energy(2, 2, [ \\"..\\", \\"..\\" ]) == 2 assert minimum_energy(3, 4, [ \\"...#\\", \\".#.#\\", \\"....\\" ]) == 5 if __name__ == \\"__main__\\": test_minimum_energy() print(\\"All tests passed!\\")","solution":"from collections import deque def minimum_energy(N, M, grid): # Check if the start or end points are blocked if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 # Movement vectors for up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Create a deque for BFS queue = deque([(0, 0, 0)]) # (row, col, cost) visited = set((0, 0)) while queue: x, y, cost = queue.popleft() # If we've reached the bottom-right corner if x == N - 1 and y == M - 1: return cost # Explore all possible moves for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the new position is valid and not blocked if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, cost + 1)) # If no path was found to the bottom-right corner return -1"},{"question":"def is_bitonic(sequence): Check if the sequence is a Bitonic sequence. :param sequence: List of integers :return: True if sequence is Bitonic, False otherwise from solution import is_bitonic def test_valid_bitonic(): assert is_bitonic([1, 3, 8, 12, 4, 2]) == True assert is_bitonic([6, 10, 15, 12, 8, 3, 2, 1]) == True def test_not_bitonic(): assert is_bitonic([1, 2, 3, 4, 5]) == False assert is_bitonic([5, 4, 3, 2, 1]) == False assert is_bitonic([3, 3, 4, 2, 1]) == False assert_is_bitonic([1, 2, 3]) == False # Sequence never decreases def test_edge_cases(): assert is_bitonic([1, 2]) == False # Not enough elements assert is_bitonic([1]) == False # Not enough elements assert is_bitonic([]) == False # Not enough elements","solution":"def is_bitonic(sequence): Check if the sequence is a Bitonic sequence. :param sequence: List of integers :return: True if sequence is Bitonic, False otherwise n = len(sequence) if n < 3: return False increasing = True has_increased = False has_decreased = False for i in range(1, n): if increasing: if sequence[i] > sequence[i-1]: has_increased = True elif sequence[i] < sequence[i-1]: if not has_increased: return False increasing = False has_decreased = True else: return False else: if sequence[i] >= sequence[i-1]: return False else: has_decreased = True return has_increased and has_decreased"},{"question":"def find_pairs(numbers, target_sum): Return all pairs of numbers in the list that add up to the target sum. Each pair is presented as a tuple (a, b) where a and b are elements from the list and the order of elements in the pairs is (a, b) where a <= b. >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 1, 2, 3, 4], 4) [(1, 3)] >>> find_pairs([3, 3, 4, 2], 6) [(2, 4), (3, 3)] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([1, 2, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)]","solution":"def find_pairs(numbers, target_sum): Return all pairs of numbers in the list that add up to the target sum. Each pair is presented as a tuple (a, b) where a and b are elements from the list and the order of elements in the pairs is (a, b) where a <= b. seen = set() pairs = set() for number in numbers: needed = target_sum - number if needed in seen: pairs.add((min(number, needed), max(number, needed))) seen.add(number) return sorted(pairs)"},{"question":"def generate_good_sequence(n, k): Generate a good sequence of length n containing integers no greater than k. Args: n: int - the length of the sequence k: int - the maximum integer value that can be used in the sequence Returns: List[int]: a list of integers which form a good sequence Example: >>> generate_good_sequence(5, 3) [1, 2, 2, 3, 3] >>> generate_good_sequence(5, 2) [1, 2, 1, 2, 1]","solution":"def generate_good_sequence(n, k): Generate a good sequence of length n containing integers no greater than k. sequence = [] for i in range(n): sequence.append(i % k + 1) return sequence"},{"question":"def does_employee_qualify(positions: List[List[Tuple[str, int]]], employees: List[List[Tuple[str, int]]]) -> List[str]: Determine if employees meet the requirements for any positions. Args: positions: A list of positions, each position being a list of tuples where each tuple contains a subject name and the required expertise level. employees: A list of employees, each employee being a list of tuples where each tuple contains a subject name and the expertise level. Returns: A list of 'YES' or 'NO' strings indicating if each employee qualifies for at least one position. Example: >>> positions = [ >>> [('math', 5), ('physics', 7)], >>> [('math', 4), ('physics', 6), ('chemistry', 5)] >>> ] >>> employees = [ >>> [('math', 5), ('physics', 7)], >>> [('math', 5), ('physics', 7), ('chemistry', 4)], >>> [('physics', 8)] >>> ] >>> does_employee_qualify(positions, employees) ['YES', 'YES', 'NO'] >>> positions = [ >>> [('biology', 3)], >>> [('chemistry', 5)] >>> ] >>> employees = [ >>> [('physics', 7)], >>> [('math', 4)] >>> ] >>> does_employee_qualify(positions, employees) ['NO', 'NO']","solution":"def does_employee_qualify(positions, employees): results = [] for employee in employees: employee_knowledge = {subject: level for subject, level in employee} qualifies = False for position in positions: if all(employee_knowledge.get(sub, 0) >= lvl for sub, lvl in position): qualifies = True break results.append('YES' if qualifies else 'NO') return results def main(): import sys input = sys.stdin.read data = input().split('n') N, M = map(int, data[0].strip().split()) positions = [] line_index = 1 for i in range(N): position_data = data[line_index].strip().split() K = int(position_data[0]) position_requirements = [(position_data[j], int(position_data[j + 1])) for j in range(1, 2 * K, 2)] positions.append(position_requirements) line_index += 1 employees = [] for i in range(M): employee_data = data[line_index].strip().split() L = int(employee_data[0]) employee_knowledge = [(employee_data[j], int(employee_data[j + 1])) for j in range(1, 2 * L, 2)] employees.append(employee_knowledge) line_index += 1 results = does_employee_qualify(positions, employees) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flattens the binary tree into a linked list in pre-order traversal order. Modifies the tree in place. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(6) >>> flatten(root) >>> tree_to_list(root) [1, 2, 3, 4, 5, 6] >>> root = TreeNode(1) >>> flatten(root) >>> tree_to_list(root) [1] >>> root = None >>> flatten(root) >>> tree_to_list(root) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> flatten(root) >>> tree_to_list(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> flatten(root) >>> tree_to_list(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right = TreeNode(4) >>> root.right.left = TreeNode(5) >>> root.right.right = TreeNode(6) >>> flatten(root) >>> tree_to_list(root) [1, 2, 3, 4, 5, 6]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flattens the binary tree into a linked list in pre-order traversal order. Modifies the tree in place. if not root: return node = root while node: if node.left: # Find the rightmost node of the left subtree rightmost = node.left while rightmost.right: rightmost = rightmost.right # Rewire the connections rightmost.right = node.right node.right = node.left node.left = None # Move on to the right side of the tree node = node.right"},{"question":"def sum_tuples(tuple_list): Returns a single list containing the sum of corresponding integers from the tuples. Assumes all tuples are of the same length. >>> sum_tuples([(1, 2)]) == [1, 2] >>> sum_tuples([(1, 2), (3, 4), (5, 6)]) == [9, 12] >>> sum_tuples([(4, 5, 6), (7, 8, 9)]) == [11, 13, 15] >>> sum_tuples([]) == [] >>> sum_tuples([(1000000, 2000000), (3000000, 4000000), (5000000, 6000000)]) == [9000000, 12000000] >>> sum_tuples([(-1, -2), (-3, -4), (-5, -6)]) == [-9, -12] >>> sum_tuples([(1, -2), (3, -4), (-5, 6)]) == [-1, 0]","solution":"def sum_tuples(tuple_list): Returns a single list containing the sum of corresponding integers from the tuples. Assumes all tuples are of the same length. if not tuple_list: return [] # Assuming all tuples in the list have the same length tuple_length = len(tuple_list[0]) # Initialize a result list with zeros of the same length result = [0] * tuple_length # Sum corresponding elements for tup in tuple_list: for i in range(tuple_length): result[i] += tup[i] return result"},{"question":"def wordBreak(s: str, words: List[str]) -> bool: Determines if the string s can be segmented into a space-separated sequence of one or more words from the array words. >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> wordBreak(\\"apple\\", [\\"apple\\"]) True >>> wordBreak(\\"applepear\\", [\\"apple\\", \\"pear\\"]) True >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\", \\"leetcode\\"]) True >>> wordBreak(\\"\\", [\\"leet\\", \\"code\\"]) True >>> wordBreak(\\"abcdef\\", [\\"gh\\", \\"ij\\", \\"kl\\"]) False","solution":"def wordBreak(s, words): Determines if the string s can be segmented into a space-separated sequence of one or more words from the array words. words_set = set(words) n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in words_set: dp[i] = True break return dp[-1]"},{"question":"def count_unique_pairs(T, test_cases): This function takes in an integer T, the number of test cases, and a list of test_cases, where each element is a tuple containing: - an integer K, the number of different ribbon colors - a list of integer colors of the ribbons. The function returns a list of integers, where each integer is the number of unique pairs of ribbons that can be formed for the corresponding test case. pass def test_count_unique_pairs(): assert count_unique_pairs(2, [(4, [1, 2, 3, 4]), (5, [1, 1, 2, 3, 4])]) == [6, 10] def test_single_pair(): assert count_unique_pairs(1, [(2, [1, 2])]) == [1] def test_larger_case(): assert count_unique_pairs(1, [(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])]) == [45] def test_identical_colors(): assert count_unique_pairs(1, [(5, [1, 1, 1, 1, 1])]) == [10] def test_minimum_case(): assert count_unique_pairs(1, [(2, [1, 2])]) == [1]","solution":"def count_unique_pairs(T, test_cases): This function takes in an integer T, the number of test cases, and a list of test_cases, where each element is a tuple containing: - an integer K, the number of different ribbon colors - a list of integer colors of the ribbons. The function returns a list of integers, where each integer is the number of unique pairs of ribbons that can be formed for the corresponding test case. results = [] for case in test_cases: K, ribbons = case # We need to calculate the number of unique pairs from the K colors unique_pairs = K * (K - 1) // 2 results.append(unique_pairs) return results # Function to read input and use count_unique_pairs def main(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): K = int(input_lines[index]) ribbons = list(map(int, input_lines[index + 1].split())) test_cases.append((K, ribbons)) index += 2 result = count_unique_pairs(T, test_cases) return 'n'.join(map(str, result))"},{"question":"def find_first_duplicate_index(arr): Finds the index of the first duplicate element in the array. If no duplicates are found, returns -1. Args: arr (list): List of integers to be checked for duplicates. Returns: int: Index of the first duplicate element, or -1 if there are no duplicates. Examples: >>> find_first_duplicate_index([1, 2, 3, 4, 5]) -1 >>> find_first_duplicate_index([1, 2, 3, 4, 5, 2]) 5 pass def process_arrays(t, arrays): Processes multiple arrays to find the first duplicate index in each one. Args: t (int): The number of arrays to be processed. arrays (list of lists): A list containing t arrays of integers. Returns: list: A list containing the result for each array. Examples: >>> process_arrays(1, [[1, 2, 3, 4, 5]]) [-1] >>> process_arrays(3, [[1, 2, 3, 4, 5], [1, 2, 3, 2], [3, 3, 3, 3]]) [-1, 3, 1] pass","solution":"def find_first_duplicate_index(arr): Finds the index of the first duplicate element in the array. If no duplicates are found, returns -1. seen = {} for i, num in enumerate(arr): if num in seen: return i seen[num] = True return -1 def process_arrays(t, arrays): Processes multiple arrays to find the first duplicate index in each one. Args: t (int): The number of arrays to be processed. arrays (list of lists): A list containing t arrays of integers. Returns: list: A list containing the result for each array. results = [] for array in arrays: results.append(find_first_duplicate_index(array)) return results"},{"question":"def merchant_max_value(n, W, items): Determine the maximum value of goods that David can carry in his caravan. >>> merchant_max_value(3, 50, [(10, 60), (20, 100), (30, 120)]) 220 >>> merchant_max_value(1, 10, [(10, 100)]) 100 >>> merchant_max_value(1, 10, [(20, 100)]) 0 >>> merchant_max_value(3, 60, [(10, 60), (20, 100), (30, 120)]) 280 >>> merchant_max_value(4, 50, [(10, 60), (20, 100), (30, 120), (25, 115)]) 220 >>> merchant_max_value(3, 0, [(10, 60), (20, 100), (30, 120)]) 0 >>> merchant_max_value(3, 1000, [(10, 60), (20, 100), (30, 120)]) 280","solution":"def knapsack(n, W, items): # Create a DP table with dimensions (n+1) x (W+1) dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] # Populate the table for i in range(1, n + 1): weight, value = items[i - 1] for w in range(W + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][W] # Function to parse the input and call the knapsack function def merchant_max_value(n, W, items): return knapsack(n, W, items)"},{"question":"def determine_winner(s: str) -> str: Determines the winner of the game based on the initial string. >>> determine_winner(\\"aaa\\") \\"Alice\\" >>> determine_winner(\\"abc\\") \\"Alice\\" >>> determine_winner(\\"aba\\") \\"Bob\\"","solution":"def determine_winner(s: str) -> str: Determines the winner of the game based on the length of the string. if len(s) % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def minimum_steps(t: int, cases: List[Tuple[int, int]]) -> List[int]: Returns the minimum number of steps required to fill the bucket with the desired ratio of apples to bananas. Parameters: t (int): The number of test cases. cases (list of tuples): A list of tuples where each tuple contains two integers (m, n) representing the desired ratio of apples to bananas. Returns: list of int: A list containing the minimum number of steps for each test case. >>> minimum_steps(3, [(1, 1), (3, 2), (5, 3)]) [2, 5, 8] >>> minimum_steps(1, [(1, 1)]) [2]","solution":"def minimum_steps(t, cases): Returns the minimum number of steps required to fill the bucket with the desired ratio of apples to bananas. Parameters: t (int): The number of test cases. cases (list of tuples): A list of tuples where each tuple contains two integers (m, n) representing the desired ratio of apples to bananas. Returns: list of int: A list containing the minimum number of steps for each test case. from math import gcd results = [] for m, n in cases: g = gcd(m, n) steps = (m // g) + (n // g) results.append(steps) return results"},{"question":"def next_lexicographical_permutation(arr: List[int]) -> List[int]: Returns the next lexicographical permutation of the input list. If no such permutation exists, returns the sorted list in ascending order. >>> next_lexicographical_permutation([1, 2, 3, 6, 5, 4]) [1, 2, 4, 3, 5, 6] >>> next_lexicographical_permutation([3, 2, 1]) [1, 2, 3] >>> next_lexicographical_permutation([1, 9, 8, 7, 6]) [6, 1, 7, 8, 9]","solution":"def next_lexicographical_permutation(arr): Returns the next lexicographical permutation of the input list. If no such permutation exists, returns the sorted list in ascending order. n = len(arr) i = n - 2 # Find the rightmost element which is smaller than the next element while i >= 0 and arr[i] >= arr[i + 1]: i -= 1 if i == -1: return sorted(arr) # Find the rightmost element which is greater than arr[i] j = n - 1 while arr[j] <= arr[i]: j -= 1 # Swap elements at i and j arr[i], arr[j] = arr[j], arr[i] # Reverse the elements from i+1 to end arr = arr[:i+1] + arr[i+1:][::-1] return arr"},{"question":"def max_mood_score(T, test_cases): Determine the maximum mood score at any point given a sequence of '+' and '-' signals. Parameters: T (int): Total number of test cases. test_cases (list of tuples): Each tuple contains an integer N (length of the sequence) and a string of length N consisting of '+' and '-' characters. Returns: list: A list of integers where each integer is the maximum mood score for the corresponding test case. >>> max_mood_score(2, [(5, \\"++-+-\\"), (6, \\"+-+++-\\")]) [2, 3] >>> max_mood_score(1, [(3, \\"+++\\")]) [3] >>> max_mood_score(1, [(4, \\"----\\")]) [0]","solution":"def max_mood_score(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] current_mood = 0 max_mood = 0 for char in sequence: if char == '+': current_mood += 1 else: current_mood -= 1 if current_mood > max_mood: max_mood = current_mood results.append(max_mood) return results"},{"question":"import random import string def generate_password(): Generate a random password meeting the following criteria: 1. The password must be at least 8 characters long. 2. The password must contain at least one uppercase letter. 3. The password must contain at least one lowercase letter. 4. The password must contain at least one numeric digit. 5. The password must contain at least one special character from the set: !@#%^&*()-_+= pass Unit Test: from solution import generate_password import string def test_generate_password_length(): password = generate_password() assert len(password) >= 8 def test_generate_password_uppercase(): password = generate_password() assert any(c.isupper() for c in password) def test_generate_password_lowercase(): password = generate_password() assert any(c.islower() for c in password) def test_generate_password_digit(): password = generate_password() assert any(c.isdigit() for c in password) def test_generate_password_special_char(): special_characters = \\"!@#%^&*()-_+=\\" password = generate_password() assert any(c in special_characters for c in password) def test_generate_unique_passwords(): passwords = {generate_password() for _ in range(100)} assert len(passwords) == 100 # Ensuring that all generated passwords are unique","solution":"import random import string def generate_password(): Generate a random password meeting the following criteria: 1. The password must be at least 8 characters long. 2. The password must contain at least one uppercase letter. 3. The password must contain at least one lowercase letter. 4. The password must contain at least one numeric digit. 5. The password must contain at least one special character from the set: !@#%^&*()-_+= length = 8 possible_characters = string.ascii_letters + string.digits + \\"!@#%^&*()-_+=\\" while True: # Generate a random password password = ''.join(random.choice(possible_characters) for _ in range(length)) # Check if password meets all criteria if (any(c.islower() for c in password) and any(c.isupper() for c in password) and any(c.isdigit() for c in password) and any(c in \\"!@#%^&*()-_+=\\" for c in password)): return password"},{"question":"def generate_sequence(n: int) -> str: Generates a sequence of length \`n\` such that the sum of digits at even positions is equal to the sum of digits at odd positions. Args: n (int): The length of the sequence. Returns: str: A sequence of length \`n\` consisting of digits from 0 to 9. >>> generate_sequence(1) '5' >>> generate_sequence(4) '1212' >>> generate_sequence(5) '12121' pass def beaver_sequence(t: int, cases: List[int]) -> List[str]: Generates sequences for multiple test cases. Args: t (int): Number of test cases. cases (List[int]): List of integers where each integer represents the length of the array for that test case. Returns: List[str]: List of sequences corresponding to each test case. >>> beaver_sequence(3, [1, 4, 5]) ['5', '1212', '12121'] >>> beaver_sequence(2, [2, 3]) ['12', '121'] pass","solution":"def generate_sequence(n): Generates a sequence of length n such that the sum of digits at even positions is equal to the sum of digits at odd positions. if n == 1: return \\"5\\" # Any single digit from 0 to 9 will satisfy sequence = [] for i in range(n): if i % 2 == 0: sequence.append(\\"1\\") else: sequence.append(\\"2\\") return \\"\\".join(sequence) def beaver_sequence(t, cases): results = [] for n in cases: results.append(generate_sequence(n)) return results"},{"question":"from typing import List, Tuple def max_smallest_subtree(n: int, edges: List[Tuple[int, int]]) -> int: Find the maximum possible size of the smallest subtree after removing exactly one node. >>> max_smallest_subtree(5, [(1, 2), (1, 3), (1, 4), (4, 5)]) == 2 >>> max_smallest_subtree(3, [(1, 2), (1, 3)]) == 1 >>> max_smallest_subtree(2, [(1, 2)]) == 1 >>> max_smallest_subtree(4, [(1, 2), (2, 3), (3, 4)]) == 2 >>> max_smallest_subtree(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 1","solution":"from collections import defaultdict, deque def calculate_subtree_sizes(n, edges): Calculates the subtree sizes for each node in the tree. tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Calculate sizes using DFS sizes = [0] * (n + 1) visited = [False] * (n + 1) def dfs(node): size = 1 visited[node] = True for neighbor in tree[node]: if not visited[neighbor]: size += dfs(neighbor) sizes[node] = size return size dfs(1) # Assuming node 1 as the root return sizes def max_smallest_subtree(n, edges): Finds the maximum size of the smallest subtree that can result after removing exactly one node. sizes = calculate_subtree_sizes(n, edges) max_min_subtree = float('-inf') for u, v in edges: subtree_size1 = min(sizes[u], sizes[v]) subtree_size2 = n - subtree_size1 max_min_subtree = max(max_min_subtree, min(subtree_size1, subtree_size2)) return max_min_subtree"},{"question":"def CountWays(N: int, Prices: List[int], Amount: int) -> int: Determines the number of distinct ways to spend exactly the given amount using the provided prices. Args: N (int): Number of different prices. Prices (List[int]): Array of item prices. Amount (int): Exact amount of money to be spent. Returns: int: Number of distinct ways to spend the exact amount. >>> CountWays(3, [1, 2, 3], 4) 4 >>> CountWays(2, [2, 3], 6) 2","solution":"def CountWays(N, Prices, Amount): Determines the number of distinct ways to spend exactly the given amount using the provided prices. :param N: int - number of different prices :param Prices: list of int - array of item prices :param Amount: int - exact amount of money to be spent :return: int - number of distinct ways to spend the exact amount # Initialize dp array where dp[i] means number of ways to make sum i dp = [0] * (Amount + 1) dp[0] = 1 # One way to make sum 0, by choosing none of the items # For each price, update the dp array for price in Prices: for j in range(price, Amount + 1): dp[j] += dp[j - price] return dp[Amount]"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: Returns the maximum value that can be obtained by selecting a subset of the given items without exceeding the total weight capacity, W. Parameters: n (int): Number of items W (int): Capacity of the knapsack items (list of tuples): Each tuple contains two integers (weight, value) of the ith item Returns: int: The maximum value that can be obtained >>> knapsack(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) == 90 >>> knapsack(0, 10, []) == 0 >>> knapsack(2, 10, [(5, 10), (5, 20)]) == 30 >>> knapsack(2, 10, [(20, 100), (30, 120)]) == 0 >>> knapsack(1, 10, [(5, 10)]) == 10 >>> knapsack(1, 10, [(15, 10)]) == 0 >>> knapsack(3, 7, [(3, 25), (4, 25), (6, 25)]) == 50 >>> knapsack(4, 1000, [(4, 50), (6, 20), (2, 30), (5, 60)]) == 160","solution":"def knapsack(n, W, items): Returns the maximum value that can be obtained by selecting a subset of the given items without exceeding the total weight capacity, W. Parameters: n (int): Number of items W (int): Capacity of the knapsack items (list of tuples): Each tuple contains two integers (weight, value) of the ith item Returns: int: The maximum value that can be obtained dp = [[0] * (W + 1) for _ in range(n + 1)] for i in range(1, n + 1): weight, value = items[i - 1] for w in range(W + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][W] # Function to read input and call the knapsack function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) W = int(data[1]) items = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(n)] print(knapsack(n, W, items)) if __name__ == \\"__main__\\": main()"},{"question":"def best_prices(store_data): Given a list of tuples (store_name, item_name, price), returns a dictionary where the keys are the items and the values are dictionaries representing the store offering the lowest price for that item. :param store_data: List of tuples (store_name, item_name, price) :return: Dictionary with items as keys and the lowest price info as values >>> best_prices([ ('StoreA', 'apple', 3), ('StoreB', 'apple', 2), ('StoreA', 'banana', 1), ('StoreB', 'banana', 2), ('StoreA', 'milk', 5), ('StoreB', 'milk', 4) ]) {'apple': {'StoreB': 2}, 'banana': {'StoreA': 1}, 'milk': {'StoreB': 4}} >>> best_prices([]) {} >>> best_prices([('StoreA', 'apple', None)]) {}","solution":"def best_prices(store_data): Given a list of tuples (store_name, item_name, price), returns a dictionary where the keys are the items and the values are dictionaries representing the store offering the lowest price for that item. :param store_data: List of tuples (store_name, item_name, price) :return: Dictionary with items as keys and the lowest price info as values price_map = {} for store, item, price in store_data: if price is None: continue if item not in price_map or price_map[item]['price'] > price: price_map[item] = {'store': store, 'price': price} result = {item: {info['store']: info['price']} for item, info in price_map.items()} return result"},{"question":"def is_palindrome(n: int) -> bool: Check if the given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False def min_pal(x: int) -> int: Find the minimum palindromic number that is greater than or equal to x. >>> min_pal(13) 22 >>> min_pal(123) 131 def sum_min_palindromes(a: int, b: int) -> int: Calculate the sum of the minimum palindromic numbers from a to b (inclusive). >>> sum_min_palindromes(13, 20) 176 >>> sum_min_palindromes(123, 127) 655","solution":"def is_palindrome(n): return str(n) == str(n)[::-1] def min_pal(x): while not is_palindrome(x): x += 1 return x def sum_min_palindromes(a, b): total_sum = 0 for num in range(a, b+1): total_sum += min_pal(num) return total_sum # Example usage: # a, b = map(int, input().split()) # print(sum_min_palindromes(a, b))"},{"question":"def findSubStrings(s: str, k: int) -> list: Write a function \`findSubStrings\` that takes a string \`s\` and an integer \`k\`, and returns a list of all unique substrings of length \`k\` in \`s\`, sorted in lexicographical order. >>> findSubStrings(\\"abcabc\\", 3) [\\"abc\\", \\"bca\\", \\"cab\\"] >>> findSubStrings(\\"aaaaa\\", 2) [\\"aa\\"] >>> findSubStrings(\\"abcdefg\\", 1) [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"] >>> findSubStrings(\\"hello\\", 6) []","solution":"def findSubStrings(s, k): Returns a list of all unique substrings of length k in s, sorted in lexicographical order. Parameters: - s (str): The input string. - k (int): The length of the substrings. Returns: - List[str]: A list of unique substrings of length k in s, sorted in lexicographical order. if k > len(s) or k <= 0: return [] substrings = {s[i:i+k] for i in range(len(s) - k + 1)} return sorted(substrings)"},{"question":"def transform_string(s: str) -> str: Returns the lexicographically smallest string with unique characters while maintaining the relative order of first appearance in the original string. >>> transform_string(\\"cbacdcbc\\") 'acdb' >>> transform_string(\\"bcabc\\") 'abc' >>> transform_string(\\"aabbcc\\") 'abc'","solution":"def transform_string(s): Returns the lexicographically smallest string with unique characters while maintaining the relative order of first appearance in the original string. last_occurrence = {char: idx for idx, char in enumerate(s)} stack = [] in_stack = set() for index, char in enumerate(s): if char in in_stack: continue while stack and char < stack[-1] and index < last_occurrence[stack[-1]]: removed_char = stack.pop() in_stack.remove(removed_char) stack.append(char) in_stack.add(char) return ''.join(stack)"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def shortest_path_from_start_to_destination(n: int, m: int, q: int, bus_routes: List[List[int]], queries: List[Tuple[int, int]]) -> List[int]: Finds the shortest path from a given start bus stop to a destination bus stop using any combination of buses. Args: n: Number of bus stops. m: Number of buses. q: Number of queries. bus_routes: List of bus routes where each route begins with an integer k followed by k integers representing the bus stops. queries: List of queries where each query consists of two integers u and v representing the start and destination bus stops. Returns: A list of integers where each integer represents the minimum number of buses needed to travel from the start to the destination for each query. If it is not possible to travel from u to v using the given bus routes, -1 is returned for that query. Examples: >>> shortest_path_from_start_to_destination(5, 2, 2, [[1, 2, 3], [3, 4, 5]], [(1, 5), (2, 3)]) [2, 1] >>> shortest_path_from_start_to_destination(6, 3, 3, [[1, 3, 5, 6], [2, 3, 4], [1, 4]], [(1, 6), (2, 5), (3, 4)]) [1, 2, 1]","solution":"from collections import defaultdict, deque def shortest_path_from_start_to_destination(n, m, q, bus_routes, queries): # Create a map of bus stops to buses that visit those stops stop_to_buses = defaultdict(list) for bus_num, route in enumerate(bus_routes): for stop in route: stop_to_buses[stop].append(bus_num) def bfs(start, destination): if start == destination: return 0 visited_stops = set() visited_buses = set() queue = deque([(start, 0)]) # (current stop, bus count) while queue: current_stop, bus_count = queue.popleft() if current_stop == destination: return bus_count for bus in stop_to_buses[current_stop]: if bus in visited_buses: continue visited_buses.add(bus) for next_stop in bus_routes[bus]: if next_stop not in visited_stops: visited_stops.add(next_stop) queue.append((next_stop, bus_count + 1)) return -1 results = [] for start, destination in queries: results.append(bfs(start, destination)) return results"},{"question":"def max_abs_difference_pairs(t, test_cases): Find two distinct integers from the array such that their absolute difference is maximum. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n and a list of n integers. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two distinct integers from the array with the maximum absolute difference. >>> max_abs_difference_pairs(3, [(5, [1, -3, 4, 8, -6]), (3, [100, 200, -300]), (4, [3, 9, -9, 7])]) [(-6, 8), (-300, 200), (-9, 9)] >>> max_abs_difference_pairs(1, [(5, [-1, -3, -4, -8, -6])]) [(-8, -1)]","solution":"def max_abs_difference_pairs(t, test_cases): results = [] for case in test_cases: n, array = case max_value = max(array) min_value = min(array) results.append((min_value, max_value)) return results # Example usage: # t = 3 # test_cases = [ # (5, [1, -3, 4, 8, -6]), # (3, [100, 200, -300]), # (4, [3, 9, -9, 7]) # ] # print(max_abs_difference_pairs(t, test_cases)) # Output: [(-6, 8), (-300, 200), (-9, 9)]"},{"question":"from typing import List, Tuple def hasConflict(intervals: List[Tuple[int, int]]) -> bool: Check if any two intervals overlap. Parameters: intervals (List[Tuple[int, int]]): List of intervals represented as (start, end). Returns: bool: True if any two intervals overlap, False otherwise. Example: >>> hasConflict([(1, 5), (6, 10), (15, 20), (5, 6)]) False >>> hasConflict([(1, 3), (2, 6), (8, 10), (15, 18)]) True def test_no_overlap(): assert hasConflict([(1, 5), (6, 10), (15, 20), (5, 6)]) == False def test_overlap(): assert hasConflict([(1, 3), (2, 6), (8, 10), (15, 18)]) == True def test_adjacent_intervals(): assert hasConflict([(1, 2), (2, 3), (3, 4), (4, 5)]) == False def test_single_interval(): assert hasConflict([(1, 10)]) == False def test_all_overlapping_intervals(): assert hasConflict([(1, 5), (4, 10), (9, 15)]) == True def test_large_non_overlap(): assert hasConflict([(0, 1), (2, 3), (4, 5), (6, 7), (8, 9)]) == False def test_large_overlap(): assert hasConflict([(0, 5), (1, 4), (3, 6), (5, 10)]) == True","solution":"from typing import List, Tuple def hasConflict(intervals: List[Tuple[int, int]]) -> bool: Check if any two intervals overlap. Parameters: intervals (List[Tuple[int, int]]): List of intervals represented as (start, end). Returns: bool: True if any two intervals overlap, False otherwise. # Sort intervals by their start time intervals.sort(key=lambda x: x[0]) # Iterate through intervals to check for any overlap for i in range(1, len(intervals)): # If the start of the current interval is less than the end of the previous interval, there is a conflict if intervals[i][0] < intervals[i-1][1]: return True return False"},{"question":"def convert_to_2d_array(t: int, test_cases: List[Tuple[int, str]]) -> List[List[str]]: Convert a string into a 2D array with specified rows, filling with dots if necessary. Args: t (int): number of test cases test_cases (List[Tuple[int, str]]): list of tuples, each containing an integer and a string Returns: List[List[str]]: List of 2D arrays for each test case Examples: >>> convert_to_2d_array(2, [(3, 'hello'), (4, 'example')]) [['hel', 'lo.'], ['exam', 'ple.']] >>> convert_to_2d_array(1, [(4, 'a')]) [['a...']]","solution":"def convert_to_2d_array(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] length = len(s) remainder = n - (length % n) if length % n != 0 else 0 s += '.' * remainder rows = [s[j:j+n] for j in range(0, len(s), n)] results.append(rows) return results"},{"question":"from collections import defaultdict from typing import List, Tuple def has_path(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Given a directed graph with \`n\` nodes and \`m\` edges, determine if there exists a path from a node \`u\` to a node \`v\`. Parameters: n (int): The number of nodes. edges (List[Tuple[int, int]]): List of directed edges in the graph. queries (List[Tuple[int, int]]): List of (u, v) pairs to check if there is a path from u to v. Returns: List[str]: List with \\"YES\\" or \\"NO\\" for each query. Examples: >>> has_path(5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], [(1, 5), (1, 3), (2, 5), (5, 1)]) ['YES', 'YES', 'YES', 'NO'] >>> has_path(3, [], [(1, 2), (2, 3)]) ['NO', 'NO']","solution":"from collections import defaultdict, deque def build_graph(n, edges): graph = defaultdict(list) for a, b in edges: graph[a].append(b) return graph def bfs(graph, start, end): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False def has_path(n, edges, queries): # Build the graph graph = build_graph(n, edges) # Answer each query using BFS results = [] for u, v in queries: if bfs(graph, u, v): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def heaviest_edge_on_path(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Alice and Bob are playing a game with a tree. A tree is an undirected graph in which any two vertices are connected by exactly one path. The tree has \`n\` vertices and \`n-1\` edges. Each edge has a weight, given by an integer array \`edges\` of length \`n-1\`. They want to know, for each pair of vertices (u, v), the weight of the heaviest edge on the path from u to v. Args: n (int): the number of vertices in the tree. edges (List[Tuple[int, int, int]]): the edges in the tree, each defined by vertices u, v and weight w. queries (List[Tuple[int, int]]): the queries for each pair of vertices u and v. Returns: List[int]: the answers to the queries with the weight of the heaviest edge on the path from u to v. Example: >>> heaviest_edge_on_path(5, [(1, 2, 4), (2, 3, 3), (3, 4, 5), (4, 5, 6)], [(1, 5), (2, 4), (3, 5)]) [6, 5, 6] >>> heaviest_edge_on_path(4, [(1, 2, 1), (1, 3, 2), (1, 4, 3)], [(2, 3), (2, 4)]) [2, 3] def test_heaviest_edge_on_path_case_1(): n = 5 edges = [ (1, 2, 4), (2, 3, 3), (3, 4, 5), (4, 5, 6) ] queries = [(1, 5), (2, 4), (3, 5)] assert heaviest_edge_on_path(n, edges, queries) == [6, 5, 6] def test_heaviest_edge_on_path_case_2(): n = 4 edges = [ (1, 2, 1), (1, 3, 2), (1, 4, 3) ] queries = [(2, 3), (2, 4)] assert heaviest_edge_on_path(n, edges, queries) == [2, 3] def test_heaviest_edge_on_path_case_3(): n = 3 edges = [ (1, 2, 1), (2, 3, 2) ] queries = [(1, 3)] assert heaviest_edge_on_path(n, edges, queries) == [2] def test_heaviest_edge_on_path_case_4(): n = 6 edges = [ (1, 2, 1), (1, 3, 2), (3, 4, 3), (4, 5, 4), (5, 6, 5) ] queries = [(1, 6), (2, 5), (3, 4)] assert heaviest_edge_on_path(n, edges, queries) == [5, 4, 3]","solution":"from collections import defaultdict, deque def build_tree(n, edges): tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) return tree def bfs_heaviest_edge(tree, n): max_edge = [[0] * (n + 1) for _ in range(n + 1)] for start in range(1, n + 1): visited = [False] * (n + 1) queue = deque([(start, 0)]) visited[start] = True while queue: current_node, current_max = queue.popleft() for neighbor, weight in tree[current_node]: if not visited[neighbor]: visited[neighbor] = True max_edge[start][neighbor] = max_edge[neighbor][start] = max(current_max, weight) queue.append((neighbor, max(weight, current_max))) return max_edge def heaviest_edge_on_path(n, edges, queries): tree = build_tree(n, edges) max_edge = bfs_heaviest_edge(tree, n) results = [] for u, v in queries: results.append(max_edge[u][v]) return results"},{"question":"def double_characters(s: str) -> str: Given a string, return a new string where each character in the original string is doubled. Args: s (str): The input string Returns: str: A new string where each character in the original string is doubled Examples: >>> double_characters(\\"Hello\\") 'HHeelllloo' >>> double_characters(\\"Good job!\\") 'GGoooodd jjoobb!!' >>> double_characters(\\"\\") ''","solution":"def double_characters(s): Given a string, returns a new string where each character in the original string is doubled. Arguments: s -- the input string Returns: A new string where each character in the original string is doubled return ''.join([char * 2 for char in s])"},{"question":"def max_contiguous_blocks(buildings: List[int]) -> int: Determine the maximum number of blocks of contiguous buildings of the same height. >>> max_contiguous_blocks([3, 3, 2, 2, 2, 1]) 3 >>> max_contiguous_blocks([1, 2, 2, 1, 1, 1, 3, 3]) 3 >>> max_contiguous_blocks([1, 2, 3, 4, 5]) 1 from typing import List def test_example_1(): assert max_contiguous_blocks([3, 3, 2, 2, 2, 1]) == 3 def test_example_2(): assert max_contiguous_blocks([1, 2, 2, 1, 1, 1, 3, 3]) == 3 def test_example_3(): assert max_contiguous_blocks([1, 2, 3, 4, 5]) == 1 def test_empty_list(): assert max_contiguous_blocks([]) == 0 def test_single_element(): assert max_contiguous_blocks([3]) == 1 def test_all_same_height(): assert max_contiguous_blocks([4, 4, 4, 4, 4]) == 5 def test_no_contiguous_blocks(): assert max_contiguous_blocks([1, 2, 3, 4, 5]) == 1 def test_two_contiguous_blocks_same_max(): assert max_contiguous_blocks([2, 2, 1, 1, 2, 2]) == 2","solution":"from typing import List def max_contiguous_blocks(buildings: List[int]) -> int: if not buildings: return 0 max_blocks = 1 current_blocks = 1 for i in range(1, len(buildings)): if buildings[i] == buildings[i - 1]: current_blocks += 1 if current_blocks > max_blocks: max_blocks = current_blocks else: current_blocks = 1 return max_blocks"},{"question":"from typing import List def minimum_numbers_to_add_for_gcd_one(n: int, arr: List[int]) -> int: Given a list of n non-negative integers in non-decreasing order, this function returns the minimum number of integers that must be added to the array so that the GCD of the array becomes 1. Parameters: n (int): The number of elements in the array. arr (List[int]): List of n non-negative integers in non-decreasing order. Returns: int: The minimum number of integers that must be added to the array so that the GCD of the array becomes 1. >>> minimum_numbers_to_add_for_gcd_one(3, [2, 4, 8]) 1 >>> minimum_numbers_to_add_for_gcd_one(2, [3, 5]) 0 pass","solution":"from math import gcd from functools import reduce def minimum_numbers_to_add_for_gcd_one(n, arr): Given a list of n non-negative integers in non-decreasing order, this function returns the minimum number of integers that must be added to the array so that the GCD of the array becomes 1. def array_gcd(array): return reduce(gcd, array) current_gcd = array_gcd(arr) if current_gcd == 1: return 0 else: return 1"},{"question":"def max_points(levels): Determines the maximum points that can be scored in each level by selecting non-overlapping notes. Args: levels (List[List[Tuple[int, int, int]]]): A list of levels where each level is a list of tuples. Each tuple contains (start_time, end_time, points). Returns: List[int]: A list of integers representing the maximum points that can be scored in each level. Example: >>> max_points([[(0, 3, 10), (1, 5, 5), (4, 6, 3), (5, 8, 8)], [(2, 4, 6), (1, 3, 4), (0, 2, 5)]]) [18, 11] pass def rhythm_game(T, sequence_data): Prepares the sequence data for each level and calculates the maximum points for each level. Args: T (int): Number of levels. sequence_data (List[Tuple[int, ...]]): A flat list containing the number of notes followed by the notes data for each level. Returns: List[int]: A list containing the maximum points for each level. Example: >>> rhythm_game(2, [4, (0, 3, 10), (1, 5, 5), (4, 6, 3), (5, 8, 8), 3, (2, 4, 6), (1, 3, 4), (0, 2, 5)]) [18, 11] pass def test_multiple_levels(): T = 2 sequence_data = [ 4, # Number of notes in level 1 (0, 3, 10), (1, 5, 5), (4, 6, 3), (5, 8, 8), 3, # Number of notes in level 2 (2, 4, 6), (1, 3, 4), (0, 2, 5) ] result = rhythm_game(T, sequence_data) assert result == [18, 11] def test_every_note_overlapping(): T = 1 sequence_data = [ 3, (1, 4, 5), (2, 5, 6), (3, 6, 7) ] result = rhythm_game(T, sequence_data) assert result == [7] def test_no_overlapping(): T = 1 sequence_data = [ 3, (0, 1, 1), (1, 2, 2), (2, 3, 3) ] result = rhythm_game(T, sequence_data) assert result == [6] def test_large_points(): T = 1 sequence_data = [ 3, (0, 1, 1000000), (1, 2, 1000000), (2, 3, 1000000) ] result = rhythm_game(T, sequence_data) assert result == [3000000]","solution":"def max_points(levels): results = [] for level in levels: notes = level notes.sort(key=lambda x: x[1]) max_points = [0] * len(notes) for i in range(len(notes)): max_points[i] = notes[i][2] for j in range(i): if notes[j][1] <= notes[i][0]: max_points[i] = max(max_points[i], max_points[j] + notes[i][2]) results.append(max(max_points)) return results def rhythm_game(T, sequence_data): levels = [] index = 0 for _ in range(T): N = sequence_data[index] index += 1 notes = [] for _ in range(N): notes.append(sequence_data[index]) index += 1 levels.append(notes) return max_points(levels)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression containing +, -, *, and / operators following the standard operator precedence and associativity rules. >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"10-2*3\\") 4 >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"10/2-3\\") 2 >>> evaluate_expression(\\"14/3*2\\") 8 >>> evaluate_expression(\\"2+3*4-5/2\\") 12 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"0+0*1\\") 0","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression containing +, -, *, and / operators following the standard operator precedence and associativity rules. def apply_ops(ops, values): right = values.pop() left = values.pop() op = ops.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': values.append(int(left / right)) # integer division truncates towards zero precedence = {'+': 1, '-': 1, '*': 2, '/': 2} ops, values, i = [], [], 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 values.append(num) continue while ops and precedence[ops[-1]] >= precedence[expression[i]]: apply_ops(ops, values) ops.append(expression[i]) i += 1 while ops: apply_ops(ops, values) return values[0]"},{"question":"def has_unique_characters(s: str) -> str: Check whether all characters in a string are unique or if there is any repeated character. >>> has_unique_characters(\\"abcdef\\") == \\"Yes\\" >>> has_unique_characters(\\"hello\\") == \\"No\\"","solution":"def has_unique_characters(s): Checks whether all characters in the string are unique. Args: s (str): The input string. Returns: str: \\"Yes\\" if all characters are unique, \\"No\\" otherwise. # Using a set to track characters seen so far seen_chars = set() for char in s: if char in seen_chars: return \\"No\\" seen_chars.add(char) return \\"Yes\\""},{"question":"def longest_alphabetical_substring_length(s: str) -> int: Determine the length of the longest substring of s that consists of characters which appear in the same order in the English alphabet. >>> longest_alphabetical_substring_length(\\"ababc\\") 3 >>> longest_alphabetical_substring_length(\\"dabc\\") 3 >>> longest_alphabetical_substring_length(\\"a\\") 1 >>> longest_alphabetical_substring_length(\\"aaaa\\") 4 >>> longest_alphabetical_substring_length(\\"abzabc\\") 3 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases and return the results for each case. >>> process_test_cases(2, [\\"ababc\\", \\"dabc\\"]) [3, 3] >>> process_test_cases(5, [\\"ababc\\", \\"dabc\\", \\"a\\", \\"aaaa\\", \\"abzabc\\"]) [3, 3, 1, 4, 3]","solution":"def longest_alphabetical_substring_length(s): max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i-1] <= s[i]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len def process_test_cases(t, test_cases): results = [] for i in range(t): results.append(longest_alphabetical_substring_length(test_cases[i])) return results"},{"question":"def decompress_and_sort(s: str) -> List[int]: Takes a compressed string 's' with integers separated by commas and potentially with nested sublists, then returns a single sorted list of integers. >>> decompress_and_sort(\\"[2,3,[1,5],[4,[7,6],8]]\\") == [1, 2, 3, 4, 5, 6, 7, 8] >>> decompress_and_sort(\\"9,3,[4,5,[1,2,8],7],[6,0]\\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] pass def format_output(values: List[int]) -> str: Formats list of integers 'values' into a space separated string. >>> format_output([1, 2, 3, 4, 5, 6, 7, 8]) == \\"1 2 3 4 5 6 7 8\\" >>> format_output([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == \\"0 1 2 3 4 5 6 7 8 9\\" pass","solution":"def decompress_and_sort(s): Takes a compressed string 's' with integers separated by commas and potentially with nested sublists, then returns a single sorted list of integers. import re # Remove all brackets and split the string by commas cleaned_string = re.sub(r'[|]', '', s) str_values = cleaned_string.split(',') # Convert all the string parts to integers int_values = list(map(int, str_values)) # Sort the list of integers sorted_values = sorted(int_values) return sorted_values def format_output(values): Formats list of integers 'values' into a space separated string. return ' '.join(map(str, values))"},{"question":"def determine_winner(M: int, K: int, chests: List[int]) -> str: Determine the winner of the game given the number of chests (M), the maximum number of coins that can be collected in one move (K), and the array of chests with coins. >>> determine_winner(3, 5, [1, 2, 3]) 'First' >>> determine_winner(4, 5, [5, 5, 5, 5]) 'Second' >>> determine_winner(4, 10, [1, 1, 1, 1]) 'First' pass def test_example_1(): assert determine_winner(3, 5, [1, 2, 3]) == \\"First\\" def test_example_2(): assert determine_winner(4, 5, [5, 5, 5, 5]) == \\"Second\\" def test_example_3(): assert determine_winner(4, 10, [1, 1, 1, 1]) == \\"First\\" def test_all_coins_less_than_K(): assert determine_winner(3, 10, [1, 2, 3]) == \\"First\\" def test_all_coins_exactly_K(): assert determine_winner(3, 6, [1, 2, 3]) == \\"First\\" def test_one_chest_with_maximum_coins(): assert determine_winner(1, 1000000000, [1]) == \\"First\\" def test_all_coins_sum_to_less_than_K(): assert determine_winner(4, 15, [1, 2, 3, 4]) == \\"First\\" import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def determine_winner(M, K, chests): Determine the winner of the game given the number of chests (M), the maximum number of coins that can be collected in one move (K), and the array of chests with coins. total_coins = sum(chests) if total_coins <= K: return \\"First\\" max_coins_per_move = max(chests) if max_coins_per_move > K: return \\"Second\\" if (total_coins // K) % 2 == 1: return \\"First\\" else: return \\"Second\\""},{"question":"def is_tree(N: int, M: int, links: List[Tuple[int, int]]) -> str: Determine if the network is a tree (connected and acyclic). >>> is_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> is_tree(4, 4, [(1, 2), (1, 3), (2, 3), (3, 4)]) \\"NO\\" >>> is_tree(4, 2, [(1, 2), (3, 4)]) \\"NO\\" >>> is_tree(3, 2, [(1, 2), (2, 1)]) \\"NO\\" >>> N = 100000 >>> M = 99999 >>> links = [(i, i + 1) for i in range(1, N)] >>> is_tree(N, M, links) \\"YES\\"","solution":"def is_tree(N, M, links): if M != N - 1: return \\"NO\\" parent = list(range(N + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): parent[find(x)] = find(y) for u, v in links: if find(u) == find(v): return \\"NO\\" union(u, v) return \\"YES\\""},{"question":"def minChangesToPalindrome(s: str) -> int: This function returns the minimum number of changes required to make the input string a palindrome. >>> minChangesToPalindrome(\\"race\\") 2 >>> minChangesToPalindrome(\\"abcba\\") 0 >>> minChangesToPalindrome(\\"abcd\\") 2 >>> minChangesToPalindrome(\\"a\\") 0 >>> minChangesToPalindrome(\\"ab\\") 1 >>> minChangesToPalindrome(\\"aa\\") 0 >>> minChangesToPalindrome(\\"abba\\") 0 >>> minChangesToPalindrome(\\"abca\\") 1 >>> minChangesToPalindrome(\\"abcdefg\\") 3 >>> minChangesToPalindrome(\\"a\\" * (10**5)) 0 >>> minChangesToPalindrome(\\"a\\" * (10**5 - 1) + \\"b\\") 1 >>> minChangesToPalindrome(\\"palindromeemordnilap\\") 0","solution":"def minChangesToPalindrome(s: str) -> int: This function returns the minimum number of changes required to make the input string a palindrome. n = len(s) changes = 0 # Compare the characters from beginning and end towards the center for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"import re def is_palindrome(s): Determines if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Parameters: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"12321\\") True","solution":"import re def is_palindrome(s): Determines if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Parameters: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"from typing import List def maxSumSubarray(arr: List[int], K: int) -> int: Find the maximum sum of a subarray of size K. >>> maxSumSubarray([100, 200, 300, 400], 2) 700 >>> maxSumSubarray([1, 2, 3, 4, 5], 4) 14 >>> maxSumSubarray([1, 2], 3) -1","solution":"from typing import List def maxSumSubarray(arr: List[int], K: int) -> int: if len(arr) < K: return -1 max_sum = curr_sum = sum(arr[:K]) for i in range(K, len(arr)): curr_sum = curr_sum - arr[i - K] + arr[i] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"def max_product_and_min_partition(n): Given an integer n, find the maximum product of integers that sum to n. Each integer must be greater than or equal to 1. If there are multiple partitions that result in the maximum product, return the smallest number of integers. >>> max_product_and_min_partition(10) (36, 3) >>> max_product_and_min_partition(5) (6, 2) pass def solve(test_cases): Given a list of integers, return a list of results where each result contains the maximum product and the smallest number of integers that sum up to the corresponding integer in the input list. >>> solve([10, 5]) [\\"36 3\\", \\"6 2\\"] >>> solve([4, 3, 2]) [\\"4 1\\", \\"2 2\\", \\"1 2\\"] pass","solution":"def max_product_and_min_partition(n): if n <= 3: return (n - 1, 2) result_product = 1 count = 0 while n > 4: n -= 3 result_product *= 3 count += 1 result_product *= n count += 1 # At least one part is left return (result_product, count) def solve(test_cases): results = [] for n in test_cases: max_product, min_partition = max_product_and_min_partition(n) results.append(f\\"{max_product} {min_partition}\\") return results"},{"question":"def get_top_students(students): Returns a list of student names who have an average grade of 90 or above. Parameters: - students: List of dictionaries, each containing 'name' (str) and 'grades' (list of int). Returns: - List of student names (str) who have an average of the highest three grades of 90 or above. pass # Unit tests def test_all_eligible_students(): students = [ {\\"name\\": \\"Alice\\", \\"grades\\": [88, 90, 92]}, {\\"name\\": \\"Bob\\", \\"grades\\": [79, 85, 94, 91]}, {\\"name\\": \\"Charlie\\", \\"grades\\": [70, 75, 80]}, {\\"name\\": \\"David\\", \\"grades\\": [91, 92, 93, 96]} ] assert get_top_students(students) == [\\"Alice\\", \\"Bob\\", \\"David\\"] def test_student_with_no_eligible_grades(): students = [ {\\"name\\": \\"Edward\\", \\"grades\\": [85, 89, 90]}, {\\"name\\": \\"Fiona\\", \\"grades\\": [95, 95, 95]}, {\\"name\\": \\"George\\", \\"grades\\": [88, 90, 91]} ] assert get_top_students(students) == [\\"Fiona\\"] def test_student_with_fewer_than_three_grades(): students = [ {\\"name\\": \\"Hannah\\", \\"grades\\": [88, 90]}, {\\"name\\": \\"Isla\\", \\"grades\\": [92, 94, 98]}, {\\"name\\": \\"Jack\\", \\"grades\\": [90, 85, 80, 70]} ] assert get_top_students(students) == [\\"Isla\\"] def test_all_students_below_threshold(): students = [ {\\"name\\": \\"Kim\\", \\"grades\\": [90, 85, 80]}, {\\"name\\": \\"Liam\\", \\"grades\\": [88, 89, 87]}, {\\"name\\": \\"Mia\\", \\"grades\\": [78, 79, 80]} ] assert get_top_students(students) == [] def test_edge_case_with_exactly_three_grades(): students = [ {\\"name\\": \\"Noah\\", \\"grades\\": [90, 90, 90]}, {\\"name\\": \\"Olivia\\", \\"grades\\": [89, 89, 89]}, {\\"name\\": \\"Paul\\", \\"grades\\": [95, 94, 93]} ] assert get_top_students(students) == [\\"Noah\\", \\"Paul\\"]","solution":"def get_top_students(students): Returns a list of student names who have an average grade of 90 or above. Parameters: - students: List of dictionaries, each containing 'name' (str) and 'grades' (list of int). Returns: - List of student names (str) who have an average of the highest three grades of 90 or above. top_students = [] for student in students: grades = student['grades'] if len(grades) >= 3: highest_three_avg = sum(sorted(grades, reverse=True)[:3]) / 3 if highest_three_avg >= 90: top_students.append(student['name']) return top_students"},{"question":"from typing import List def is_valid_hex(s: str) -> bool: Determines if a given string is a valid hexadecimal number. A valid hexadecimal number can contain the characters 0-9, a-f, and A-F, and it may have an optional '0x' or '0X' prefix. >>> is_valid_hex(\\"0x1A3F\\") True >>> is_valid_hex(\\"1B2h\\") False >>> is_valid_hex(\\"ABCDEF\\") True >>> is_valid_hex(\\"0x12G3\\") False pass","solution":"def is_valid_hex(s: str) -> bool: Determines if a given string is a valid hexadecimal number. A valid hexadecimal number can contain the characters 0-9, a-f, and A-F, and it may have an optional '0x' or '0X' prefix. if len(s) > 2 and (s[:2] == '0x' or s[:2] == '0X'): s = s[2:] hex_digits = set(\\"0123456789abcdefABCDEF\\") for char in s: if char not in hex_digits: return False return len(s) > 0 # ensuring there's at least one character to validate"},{"question":"def max_candies(candies, operations): This function takes a list of integers representing the initial types of candies in the containers, and a list of operations to perform on these containers. It returns the results of the operations that check the maximum number of candies of the same type in any single container. :param candies: List[int], the initial types of candies in the containers :param operations: List[str], the operations to perform on the containers :return: List[int], the results for operations that check the maximum number of candies of the same type >>> candies = [1, 2, 2, 3, 1] >>> operations = [\\"2\\", \\"1 2 3\\", \\"2\\", \\"1 5 3\\", \\"2\\"] >>> max_candies(candies, operations) [2, 2, 3] >>> candies = [3, 3, 3, 4, 4] >>> operations = [\\"2\\", \\"1 4 3\\", \\"2\\"] >>> max_candies(candies, operations) [3, 4] >>> candies = [1, 1, 1, 1, 1] >>> operations = [\\"2\\", \\"1 3 2\\", \\"2\\", \\"1 5 2\\", \\"2\\"] >>> max_candies(candies, operations) [5, 4, 3] >>> candies = [1, 2, 3, 4, 5] >>> operations = [\\"2\\", \\"1 1 5\\", \\"2\\", \\"1 2 5\\", \\"2\\"] >>> max_candies(candies, operations) [1, 2, 3] >>> candies = [2, 2, 2, 2, 2, 2] >>> operations = [\\"2\\", \\"1 4 3\\", \\"2\\", \\"1 5 3\\", \\"2\\", \\"1 6 3\\", \\"2\\"] >>> max_candies(candies, operations) [6, 5, 4, 3]","solution":"def max_candies(candies, operations): This function takes a list of integers representing the initial types of candies in the containers, and a list of operations to perform on these containers. It returns the results of the operations that check the maximum number of candies of the same type in any single container. :param candies: List[int], the initial types of candies in the containers :param operations: List[str], the operations to perform on the containers :return: List[int], the results for operations that check the maximum number of candies of the same type from collections import Counter # Initialize the counter for candy types count = Counter(candies) results = [] for operation in operations: if operation[0] == \\"1\\": _, k, x = map(int, operation.split()) k -= 1 # Convert to 0-based index # Update the type of candy in the specified container old_type = candies[k] candies[k] = x # Update the counts count[old_type] -= 1 if count[old_type] == 0: del count[old_type] count[x] += 1 elif operation[0] == \\"2\\": # Find the maximum count across all candy types max_count = max(count.values(), default=0) results.append(max_count) return results"},{"question":"def is_special_sequence(sequence): Determines if the given sequence is special. A sequence is special if the absolute difference between any two consecutive elements is either 1 or 2. >>> is_special_sequence([1, 2, 3]) == \\"YES\\" >>> is_special_sequence([1, 3, 5, 7]) == \\"NO\\" >>> is_special_sequence([5, 6, 4, 3, 7]) == \\"NO\\" >>> is_special_sequence([1, 4]) == \\"NO\\" >>> is_special_sequence([1000000000, 999999999]) == \\"YES\\" pass # Your code goes here def process_test_cases(T, test_cases): Processes multiple test cases to determine if each sequence is special or not. >>> T = 3 >>> test_cases = [ (3, [1, 2, 3]), (4, [1, 3, 5, 7]), (5, [5, 6, 4, 3, 7]) ] >>> process_test_cases(T, test_cases) == [\\"YES\\", \\"NO\\", \\"NO\\"] >>> T = 2 >>> test_cases = [ (2, [1, 4]), (3, [1000000000, 999999999, 1000000000]) ] >>> process_test_cases(T, test_cases) == [\\"NO\\", \\"YES\\"] pass # Your code goes here","solution":"def is_special_sequence(sequence): Determines if the given sequence is special. A sequence is special if the absolute difference between any two consecutive elements is either 1 or 2. for i in range(1, len(sequence)): if abs(sequence[i] - sequence[i - 1]) not in {1, 2}: return \\"NO\\" return \\"YES\\" def process_test_cases(T, test_cases): Processes multiple test cases to determine if each sequence is special or not. results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] results.append(is_special_sequence(sequence)) return results"},{"question":"def resource_with_highest_value(n: int, resource_strings: List[str]) -> str: Returns the resource string with the greatest value. If there's a tie, returns the lexicographically smallest string. >>> resource_with_highest_value(4, [\\"ABCDE\\", \\"XYZ\\", \\"HELLO\\", \\"WORLD\\"]) == \\"XYZ\\" >>> resource_with_highest_value(1, [\\"A\\"]) == \\"A\\" >>> resource_with_highest_value(3, [\\"ABC\\", \\"ACB\\", \\"BAC\\"]) == \\"ABC\\" >>> resource_with_highest_value(4, [\\"\\", \\"A\\", \\"B\\", \\"\\"]) == \\"B\\" >>> resource_with_highest_value(2, [\\"A\\" * 99 + \\"B\\", \\"A\\" * 100]) == \\"A\\" * 99 + \\"B\\"","solution":"def resource_with_highest_value(n, resource_strings): Returns the resource string with the greatest value. If there's a tie, returns the lexicographically smallest string. def calculate_value(resource_string): # Calculate the value of the resource string return sum(ord(char) - ord('A') + 1 for char in resource_string) # Initialize the \\"best\\" resource string and its value best_resource = None best_value = -1 for resource in resource_strings: current_value = calculate_value(resource) if current_value > best_value or (current_value == best_value and resource < best_resource): best_value = current_value best_resource = resource return best_resource"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) of the grid. A cell is represented by a '0' if it is open, and by a '1' if it is blocked. Charlie can move up, down, left, or right, but cannot move diagonally. >>> shortest_path([ ... [0, 0, 1, 0, 0, 0], ... [1, 0, 1, 1, 1, 0], ... [1, 0, 0, 0, 0, 0], ... [0, 0, 1, 1, 0, 1], ... [0, 1, 1, 1, 0, 0] ... ]) == 10 >>> shortest_path([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 5 >>> shortest_path([ ... [0, 1, 0, 0], ... [0, 1, 1, 1], ... [0, 0, 1, 0], ... [1, 1, 0, 0] ... ]) == -1","solution":"from collections import deque def shortest_path(grid): n = len(grid) m = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 # BFS setup queue = deque([(0, 0, 1)]) # (row, col, distance from start) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def longest_non_repeating_substring(s: str) -> str: Given a string, output the longest substring that contains no repeated characters. If there are multiple substrings of the same length, output the one that appears first. >>> longest_non_repeating_substring(\\"abcabcbb\\") 'abc' >>> longest_non_repeating_substring(\\"bbbbb\\") 'b' >>> longest_non_repeating_substring(\\"pwwkew\\") 'wke' >>> longest_non_repeating_substring(\\"a\\") 'a' >>> longest_non_repeating_substring(\\"abcdef\\") 'abcdef' >>> longest_non_repeating_substring(\\"aaaaaaa\\") 'a' >>> longest_non_repeating_substring(\\"abcaabcdba\\") 'abcd' >>> longest_non_repeating_substring(\\"ababababab\\") 'ab' >>> longest_non_repeating_substring(\\"abcdabcdefg\\") 'abcdefg' >>> longest_non_repeating_substring(\\"abcdeabcd\\") 'abcde'","solution":"def longest_non_repeating_substring(s): Returns the longest substring of s that contains no repeated characters. If there are multiple substrings of the same length, the one that appears first is returned. start = 0 max_length = 0 max_substring = \\"\\" used_chars = {} for end, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"def is_fully_connected(n: int, edges: List[Tuple[int, int]]) -> str: Determine if all nodes in the graph belong to a single connected component. Return \\"YES\\" if all nodes are in a single connected component, else \\"NO\\". def process_test_cases(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Process multiple test cases to determine connectivity of graphs. Return a list of strings \\"YES\\" or \\"NO\\" for each test case. from solution import is_fully_connected, process_test_cases def test_example_1(): test_cases = [ (4, 2, [(1, 2), (2, 3)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]), (3, 0, []) ] expected = [\\"NO\\", \\"YES\\", \\"NO\\"] assert process_test_cases(test_cases) == expected def test_disconnected_graph(): test_cases = [ (6, 3, [(1, 2), (2, 3), (4, 5)]) ] expected = [\\"NO\\"] assert process_test_cases(test_cases) == expected def test_condensed_graph(): test_cases = [ (3, 3, [(1, 2), (2, 3), (1, 3)]) ] expected = [\\"YES\\"] assert process_test_cases(test_cases) == expected def test_fully_isolated_nodes(): test_cases = [ (4, 0, []), (1, 0, []) ] expected = [\\"NO\\", \\"YES\\"] assert process_test_cases(test_cases) == expected def test_fully_connected_graph(): test_cases = [ (4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) ] expected = [\\"YES\\"] assert process_test_cases(test_cases) == expected","solution":"def is_fully_connected(n, edges): from collections import defaultdict, deque if n == 0: return \\"NO\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbour in graph[node]: if not visited[neighbour]: visited[neighbour] = True queue.append(neighbour) # Start BFS from node 1 (or any other node) components = 0 for node in range(1, n + 1): if not visited[node]: components += 1 bfs(node) return \\"YES\\" if components == 1 else \\"NO\\" def process_test_cases(test_cases): result = [] for n, m, edges in test_cases: result.append(is_fully_connected(n, edges)) return result"},{"question":"def path_exists(graph, start, end): Determines if a path exists between the start and end nodes in an undirected graph. >>> graph = { ... 1: [(2, 5), (3, 10)], ... 2: [(1, 5), (4, 1)], ... 3: [(1, 10), (4, 2)], ... 4: [(2, 1), (3, 2)] ... } >>> path_exists(graph, 1, 4) == True >>> path_exists(graph, 1, 5) == False pass","solution":"def path_exists(graph, start, end): Determines if a path exists between the start and end nodes in an undirected graph. :param graph: dict, where keys are nodes and values are lists of tuples (node, weight) representing edges :param start: int, starting node :param end: int, destination node :returns: bool, True if there's a path, False otherwise if start not in graph or end not in graph: return False visited = set() stack = [start] while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) for neighbor, _ in graph[node]: if neighbor not in visited: stack.append(neighbor) return False"},{"question":"def findMaxSum(arr: List[int]) -> int: Returns the maximum sum of a subsequence such that no two numbers in the sequence are consecutive in the array. If the array is empty, returns 0. Example: >>> findMaxSum([3, 2, 7, 10]) 13 >>> findMaxSum([3, 2, 5, 10, 7]) 15 >>> findMaxSum([5, 5, 10, 100, 10, 5]) 110","solution":"def findMaxSum(arr): Returns the maximum sum of a subsequence such that no two numbers in the sequence are consecutive in the array. if not arr: return 0 incl = 0 # Maximum sum including the previous element excl = 0 # Maximum sum excluding the previous element for num in arr: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"def check_id_validity(id_number: str) -> str: Returns 'VALID' if the ID number has all distinct digits, 'INVALID' otherwise. >>> check_id_validity(\\"1234567890\\") 'VALID' >>> check_id_validity(\\"112345\\") 'INVALID' def find_id_validity(id_numbers: List[str]) -> List[str]: Given a list of ID numbers, return a list indicating whether each ID number is 'VALID' or 'INVALID'. >>> find_id_validity([\\"1234567890\\", \\"112345\\", \\"9876543210\\", \\"1234321\\"]) ['VALID', 'INVALID', 'VALID', 'INVALID']","solution":"def check_id_validity(id_number): Returns 'VALID' if the ID number has all distinct digits, 'INVALID' otherwise. if len(set(id_number)) == len(id_number): return \\"VALID\\" else: return \\"INVALID\\" def find_id_validity(id_numbers): results = [] for id_number in id_numbers: results.append(check_id_validity(id_number)) return results"},{"question":"from typing import List import math def find_winner(m: int, b: List[int]) -> str: Determine who will win the game between Martin and Clara. :param m: the number of integers in the array :param b: the array of integers :return: \\"Martin\\" if Martin will win, else \\"Clara\\" >>> find_winner(3, [2, 3, 4]) 'Martin' >>> find_winner(4, [6, 9, 12, 15]) 'Clara' pass def test_martin_wins(): assert find_winner(3, [2, 3, 4]) == \\"Martin\\" assert find_winner(2, [7, 9]) == \\"Martin\\" assert find_winner(4, [6, 10, 14, 21]) == \\"Martin\\" def test_clara_wins(): assert find_winner(4, [6, 9, 12, 15]) == \\"Clara\\" assert find_winner(2, [8, 16]) == \\"Clara\\" assert find_winner(3, [10, 20, 30]) == \\"Clara\\" def test_single_element(): assert find_winner(1, [1]) == \\"Martin\\" assert find_winner(1, [10]) == \\"Clara\\" def test_large_numbers(): assert find_winner(2, [1000000000, 999999999]) == \\"Martin\\" assert find_winner(2, [1000000000, 2000000000]) == \\"Clara\\"","solution":"from math import gcd from functools import reduce def find_winner(m, b): Determines the winner of the game based on initial array values. :param m: int - the number of integers in the array :param b: list of int - the array of integers :return: str - \\"Martin\\" if Martin wins, otherwise \\"Clara\\" overall_gcd = reduce(gcd, b) return \\"Martin\\" if overall_gcd == 1 else \\"Clara\\""},{"question":"def count_valid_substrings(s: str) -> int: Returns the number of substrings that start and end with the same character. >>> count_valid_substrings(\\"abcab\\") == 7 >>> count_valid_substrings(\\"aaaa\\") == 10 >>> count_valid_substrings(\\"ababa\\") == 9 >>> count_valid_substrings(\\"a\\") == 1 >>> count_valid_substrings(\\"\\") == 0 >>> count_valid_substrings(\\"ab\\") == 2 >>> count_valid_substrings(\\"racecar\\") == 10","solution":"def count_valid_substrings(s: str) -> int: Returns the number of substrings that start and end with the same character. count = 0 # Traverse s to count the occurrences of each character for i in range(len(s)): # Traverse the substrings starting from index i for j in range(i, len(s)): # Check if the substring starts and ends with the same character if s[i] == s[j]: count += 1 return count"},{"question":"def is_sparse(n: int) -> int: Returns 1 if the number n is Sparse, otherwise returns 0. A number is Sparse if there are no two adjacent set bits (1s) in its binary representation. >>> is_sparse(22) == 0 # 22 in binary is 10110, has adjacent set bits >>> is_sparse(21) == 1 # 21 in binary is 10101, no adjacent set bits >>> is_sparse(1) == 1 # 1 in binary is 1, only one bit set >>> is_sparse(2) == 1 # 2 in binary is 10, no adjacent set bits >>> is_sparse(3) == 0 # 3 in binary is 11, has adjacent set bits >>> is_sparse(7) == 0 # 7 in binary is 111, all bits are adjacent set bits >>> is_sparse(5000) == 0 # 5000 in binary is 1001110001000, contains adjacent set bits >>> is_sparse(1024) == 1 # 1024 in binary is 10000000000, no adjacent set bits","solution":"def is_sparse(n): Returns 1 if the number n is Sparse, otherwise returns 0. A number is Sparse if there are no two adjacent set bits (1s) in its binary representation. # XOR the number with its right shift by 1 if n & (n >> 1): return 0 return 1"}]`),E={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},z={class:"card-container"},C={key:0,class:"empty-state"},D=["disabled"],F={key:0},P={key:1};function O(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"ðŸ¤”prompts chatðŸ§ ")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"ðŸ”",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," âœ• ")):l("",!0)]),t("div",z,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",C,' No results found for "'+c(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",P,"Loading...")):(s(),n("span",F,"See more"))],8,D)):l("",!0)])}const M=m(E,[["render",O],["__scopeId","data-v-880707ef"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/63.md","filePath":"guide/63.md"}'),I={name:"guide/63.md"},G=Object.assign(I,{setup(i){return(e,u)=>(s(),n("div",null,[w(M)]))}});export{B as __pageData,G as default};
