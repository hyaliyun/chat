import{_ as h,o as n,c as i,a as t,m as c,t as u,C as g,M as _,U as y,f as d,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,m,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(u(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(u(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-6f185246"]]),S=JSON.parse('[{"question":"# Scenario: You have been tasked with developing a reporting system for a financial application. One of the requirements is to generate a month-end summary report of account balances. Your goal is to create a function that, given a list of transactions, computes the final balance for each account at the end of the month. # Function Requirements: * Implement a function `calculate_balances` that processes a list of transactions and returns the final balance for each account. * Each transaction is represented as a dictionary with keys `account_id` (string), `type` (string, either \\"debit\\" or \\"credit\\"), and `amount` (float). # Constraints: * The function should handle cases where some accounts have no transactions. * Ensure the output is a dictionary where keys are account IDs and values are the final balances (floats). * Assume all balances start at 0. # Function Signature: ```python def calculate_balances(transactions: List[Dict[str, Any]]) -> Dict[str, float]: pass ``` # Example: ```python transactions = [ {\\"account_id\\": \\"A1\\", \\"type\\": \\"debit\\", \\"amount\\": 100.0}, {\\"account_id\\": \\"A2\\", \\"type\\": \\"credit\\", \\"amount\\": 200.0}, {\\"account_id\\": \\"A1\\", \\"type\\": \\"credit\\", \\"amount\\": 50.0}, {\\"account_id\\": \\"A3\\", \\"type\\": \\"debit\\", \\"amount\\": 300.0}, ] assert calculate_balances(transactions) == { \\"A1\\": -50.0, \\"A2\\": 200.0, \\"A3\\": -300.0 } ``` # Input: - `transactions` (List[Dict[str, Any]]): A list of transaction dictionaries. # Output: - (Dict[str, float]): A dictionary with account IDs as keys and final balances as values. **Good luck!**","solution":"from typing import List, Dict, Any def calculate_balances(transactions: List[Dict[str, Any]]) -> Dict[str, float]: # Initialize a dictionary to keep track of balances account_balances = {} for transaction in transactions: account_id = transaction[\'account_id\'] trans_type = transaction[\'type\'] amount = transaction[\'amount\'] if account_id not in account_balances: account_balances[account_id] = 0.0 if trans_type == \'debit\': account_balances[account_id] -= amount elif trans_type == \'credit\': account_balances[account_id] += amount else: raise ValueError(f\\"Unknown transaction type: {trans_type}\\") return account_balances"},{"question":"# Coding Assessment Question Context: In the realm of automated text processing and analysis, efficiently calculating word frequencies within large bodies of text is a crucial task. Given the capabilities of natural language processing libraries and common data structures in Python, your task is to optimize the text-processing algorithms used to determine the frequencies of words. Task: 1. Implement a function `tokenize_text(text: str) -> list[str]` that splits the input text into individual words. Remove punctuation and convert all words to lowercase. 2. Write a function `compute_word_frequencies(words: list[str]) -> dict[str, int]` that calculates the frequency of each word in the list of words. Constraints: * The text can contain a mix of uppercase and lowercase letters, punctuation, and numbers. * Your solution should focus on string processing and make use of efficient data structures such as dictionaries. * You are not allowed to use external libraries for tokenization or frequency calculation. Example Input and Output: ```python >>> text = \\"Hello, world! This is a test. Hello again, world.\\" >>> tokenize_text(text) [\'hello\', \'world\', \'this\', \'is\', \'a\', \'test\', \'hello\', \'again\', \'world\'] >>> words = tokenize_text(text) >>> compute_word_frequencies(words) {\'hello\': 2, \'world\': 2, \'this\': 1, \'is\': 1, \'a\': 1, \'test\': 1, \'again\': 1} ``` Notes: * Ensure to handle edge cases such as an empty string or strings with only punctuation. * Optimize your code to minimize time complexity, especially during the tokenization process. * Ensure that your implementation is efficient and handles large texts gracefully.","solution":"def tokenize_text(text: str) -> list[str]: Splits the input text into individual words. Removes punctuation and converts all words to lowercase. import re # Use regular expression to replace punctuation with space, then split by whitespace cleaned_text = re.sub(r\'[^ws]\', \' \', text) words = cleaned_text.lower().split() return words def compute_word_frequencies(words: list[str]) -> dict[str, int]: Calculates the frequency of each word in the list of words. word_frequencies = {} for word in words: if word in word_frequencies: word_frequencies[word] += 1 else: word_frequencies[word] = 1 return word_frequencies"},{"question":"# Question: Analyzing Network Traffic Flow In a given undirected graph representing a network of computers connected via cables, determine the minimum number of cables that must be added to ensure there is a direct path between any two computers (i.e., the network is fully connected). Function Signature ```python def min_cables_to_connect_network(graph: Dict[int, List[int]]) -> int: pass ``` # Input: - `graph`: A dictionary where keys represent nodes (computers) and values are lists of adjacent nodes, thus describing an undirected graph. # Output: - An integer representing the minimum number of cables needed to add to the network to make it fully connected. # Constraints: - Each node will have an integer identifier. - The graph will have at most 1000 nodes and 5000 edges. - The graph will be undirected and it can be disconnected initially. # Examples: **Example 1:** ```python graph = { 0: [1], 1: [0, 2], 2: [1], 3: [], 4: [5], 5: [4], } assert min_cables_to_connect_network(graph) == 2 ``` **Example 2:** ```python graph = { 0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3], 5: [6], 6: [5], } assert min_cables_to_connect_network(graph) == 2 ``` # Instructions: 1. Implement Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the connected components of the graph. 2. Identify the number of disconnected components in the graph. 3. Calculate the minimum number of cables required to connect all the components. 4. Return the calculated number of cables. 5. Ensure your solution is efficient with respect to both time and space complexity. # Note: - Your implementation should correctly handle graphs with various degrees of connectivity, including isolated nodes. - The graph can contain cycles, so ensure your method properly considers already connected vertices to prevent redundant connections.","solution":"def min_cables_to_connect_network(graph): Returns the minimum number of cables needed to make the network fully connected. def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() components = 0 for node in graph: if node not in visited: dfs(node, visited) components += 1 # To connect `components` disconnected components, we need `components - 1` cables return components - 1"},{"question":"# Question: Implementing Binary Search on a Sorted List You are required to implement a function that performs a binary search on a sorted list of integers. The function should return the index of the target element if it is present in the list and -1 if it is not found. Function Signature ```python def binary_search(sorted_list: list, target: int) -> int: pass ``` Input * `sorted_list` (list): A list of integers sorted in ascending order. The list can contain zero or more elements. * `target` (int): The integer value to search for in the list. Output * Returns the index of the `target` in the `sorted_list` if found; otherwise, it returns -1. Constraints * All elements in the `sorted_list` are integers. * The length of the `sorted_list` will not exceed 100,000. * The `target` is an integer that can be negative, zero, or positive. # Example Usage: ```python assert binary_search([], 3) == -1 assert binary_search([1], 1) == 0 assert binary_search([1, 2, 3, 4, 5], 3) == 2 assert binary_search([1, 2, 3, 4, 5], 6) == -1 assert binary_search([-5, -3, 0, 1, 2], -3) == 1 ``` # Notes 1. You must handle edge cases such as an empty list or a list with a single element. 2. Ensure that your implementation correctly handles both negative and positive integers. 3. The output index must match the zero-based indexing used in Python. # Performance Requirements * Your solution should run with a time complexity of O(log n) and a space complexity of O(1).","solution":"def binary_search(sorted_list, target): left, right = 0, len(sorted_list) - 1 while left <= right: mid = (left + right) // 2 if sorted_list[mid] == target: return mid elif sorted_list[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are developing a simple in-memory key-value store with additional features for persistence and recovery. The key-value store should be capable of saving its state to a file and restoring it upon restart to ensure data is not lost. You need to implement the core functionality of the store and the persistence mechanism. Objective Develop the `KeyValueStore` class to: 1. Implement basic key-value storage operations. 2. Save the state to a file regularly and upon each significant operation (put and delete). 3. Recover the state upon initialization if the state file exists. Requirements - **Input**: - `filename`: A string representing the name of the file used for storing the state. - **Output**: - No direct output, but the class should manage an internal state that can be persisted and restored. - **Constraints**: - The key-value store should support basic `put(key, value)`, `get(key)`, and `delete(key)` operations. - Ensure the persistence mechanism is robust and efficient. - Handle edge cases such as missing files, corrupted state files, and concurrency issues. Persistence Requirements - Save the state to disk after each `put` and `delete` operation. - Implement a mechanism to reduce disk I/O, such as in-memory buffering with periodic flushing to disk. - Ensure atomicity during save operations to avoid state corruption. Edge Cases & Error Handling - Gracefully handle scenarios where the state file is missing or corrupted. - Ensure operations are thread-safe if accessed from multiple threads. # Scenario You are building a component that requires high reliability and fault tolerance, where data integrity is crucial. The key-value store should recover seamlessly from crashes, ensuring no data is lost. Class Definition ```python class KeyValueStore: def __init__(self, filename: str): self.filename = filename self.store = self._load_state() def _load_state(self) -> dict: # Your implementation to load the state from file pass def _save_state(self) -> None: # Your implementation to save the current state to file pass def put(self, key: str, value: str) -> None: # Your implementation for put operation pass def get(self, key: str) -> str: # Your implementation for get operation pass def delete(self, key: str) -> None: # Your implementation for delete operation pass ``` Example ```python store = KeyValueStore(\\"store_state.txt\\") store.put(\\"name\\", \\"Alice\\") print(store.get(\\"name\\")) # Expected output: Alice store.delete(\\"name\\") print(store.get(\\"name\\")) # Expected output: None ``` The class `KeyValueStore` is expected to interact with the state file, ensuring data persistence across sessions, and handle all edge cases as described.","solution":"import json import os import threading class KeyValueStore: def __init__(self, filename: str): self.filename = filename self.lock = threading.Lock() self.store = self._load_state() def _load_state(self) -> dict: Loads the state from the file if it exists, otherwise returns an empty dictionary. if os.path.exists(self.filename): try: with open(self.filename, \'r\') as file: return json.load(file) except (json.JSONDecodeError, IOError): # Handle file corruption or read errors gracefully return {} return {} def _save_state(self) -> None: Saves the current state to the file. with open(self.filename, \'w\') as file: json.dump(self.store, file) def put(self, key: str, value: str) -> None: Puts the key-value pair into the store and saves the state. with self.lock: self.store[key] = value self._save_state() def get(self, key: str) -> str: Gets the value associated with the key. Returns None if the key does not exist. with self.lock: return self.store.get(key) def delete(self, key: str) -> None: Deletes the key from the store if it exists and saves the state. with self.lock: if key in self.store: del self.store[key] self._save_state()"},{"question":"# Coding Challenge: Repeated Substring Check Background: String manipulation is a fundamental aspect of many programming problems. One interesting problem in this domain is checking if a given string can be constructed by repeating a smaller substring multiple times. Objective: Write a function to determine whether a given string can be formed by repeating one of its substrings multiple times. Task: Implement the function `is_repeated_substring(s: str) -> bool` that: - Takes a single string `s` as an argument. - Returns `True` if the string can be constructed by repeating a substring of it, otherwise returns `False`. Input: - A string `s` consisting of lower-case English letters, with length ( 1 leq text{len}(s) leq 10^5 ). Output: - Returns a boolean indicating whether the given string can be constructed by repeating a smaller substring multiple times. Examples: ```python >>> is_repeated_substring(\\"abab\\") True >>> is_repeated_substring(\\"aba\\") False >>> is_repeated_substring(\\"abcabcabc\\") True >>> is_repeated_substring(\\"abcd\\") False >>> is_repeated_substring(\\"aaa\\") True >>> is_repeated_substring(\\"a\\") False ``` Requirements: 1. The function should have a time complexity of O(n) for efficiency. 2. Handle edge cases thoroughly. 3. Ensure the solution can handle the maximum constraint efficiently (up to (10^5) characters in the string). Constraints: - The function should only consider substrings that fully match the start and end of the given string. - The function should handle lowercase English letters only. Hint: Consider using string concatenation and slicing for a clean and efficient solution.","solution":"def is_repeated_substring(s: str) -> bool: Returns True if the input string can be constructed by repeating a smaller substring, otherwise returns False. n = len(s) # Create a new string by concatenating the input string with itself doubled_s = s + s # Skip the first and last character of the doubled string to prevent trivial matching new_s = doubled_s[1: -1] # Check if the input string is a substring of this new modified string return s in new_s"},{"question":"# Question: Top K Frequent Elements You are tasked with implementing a function `topKFrequent(nums: List[int], k: int) -> List[int]` that returns the `k` most frequent elements from a list of integers. # Function Specification Implement the function `topKFrequent` with the following parameters: 1. **`nums`** (List[int]) - **Description**: A list of integers. - **Input**: A list of integers where each integer represents a number. - **Output**: A list of the `k` most frequent integers from the input list. 2. **`k`** (int) - **Description**: The number of top frequent elements to be returned. - **Input**: A positive integer representing the number of top frequent elements to return. - **Output**: A list containing the `k` most frequent integers. # Constraints - The input list `nums` contains integers within the range [-10^5, 10^5]. - The length of the list `nums` is within the range [1, 10^4]. - The value of `k` is between 1 and the number of unique elements in `nums`. # Example Usage ```python print(topKFrequent([1,1,1,2,2,3], 2)) # Output: [1, 2] print(topKFrequent([1], 1)) # Output: [1] print(topKFrequent([4,4,4,4,6,6,2,2,2,2,3,3,3], 3)) # Output: [4, 2, 3] ``` # Notes - Ensure your solution is optimized to handle large input sizes efficiently. - The result can be returned in any order; there is no need to sort the `k` elements. - Utilize appropriate data structures to keep track of frequency counts and manage the top `k` elements. - Consider edge cases such as when input list contains only one element or when all elements have the same frequency.","solution":"from collections import Counter from heapq import nlargest def topKFrequent(nums, k): Returns the k most frequent elements from a list of integers. Parameters: nums (List[int]): A list of integers. k (int): The number of top frequent elements to be returned. Returns: List[int]: A list containing the k most frequent integers. count = Counter(nums) return [item for item, freq in nlargest(k, count.items(), key=lambda x: x[1])]"},{"question":"# Allocate Resources for Project Distribution **Objective**: Implement a function that fairly distributes resource units among multiple projects based on specified shares. **Function Signature**: `def allocate_resources(total_resources: int, project_shares: dict[str, float]) -> dict[str, int]:` # Input: - `total_resources` (int): The total number of resource units available for distribution. - `project_shares` (dict): A dictionary where keys are project names (strings) and values are their respective shares (floats). The shares denote the proportion of the total resources each project should ideally get. # Output: - Returns a dictionary where keys are project names and values are the whole number of resource units allocated to each project. Any remaining resource units after the initial distribution should be assigned one by one to projects based on the largest fractional parts of their calculated shares, ensuring all resources are allocated. # Constraints: - `total_resources` must be a non-negative integer. - Each share in `project_shares` must be positive and the dictionary must not be empty. - The sum of all shares must be greater than zero. - If the constraints are violated, the function should raise a `ValueError` with an appropriate message. # Examples: 1. `allocate_resources(100, {\\"ProjectA\\": 0.5, \\"ProjectB\\": 0.3, \\"ProjectC\\": 0.2})` should return `{\\"ProjectA\\": 50, \\"ProjectB\\": 30, \\"ProjectC\\": 20}`. 2. `allocate_resources(10, {\\"ProjectA\\": 1, \\"ProjectB\\": 2, \\"ProjectC\\": 1})` should return `{\\"ProjectA\\": 2, \\"ProjectB\\": 4, \\"ProjectC\\": 2}`. 3. `allocate_resources(7, {\\"ProjectA\\": 0.333, \\"ProjectB\\": 0.333, \\"ProjectC\\": 0.333})` could return `{\\"ProjectA\\": 2, \\"ProjectB\\": 2, \\"ProjectC\\": 2}` after distributing the remaining resources based on the largest fractional parts. # Notes: - Ensure that total allocated resources sum up exactly to `total_resources`. - If multiple projects have the same fractional parts when distributing leftover resources, the tie can be broken arbitrarily. - Use appropriate error handling to manage invalid inputs and constraints. # Hints: - Calculate the initial allocation by multiplying total resources with each project\'s share and taking the floor of the result. - Track remaining resources and distribute them based on the largest fractional remainders of their initial calculated shares.","solution":"def allocate_resources(total_resources: int, project_shares: dict): if total_resources < 0: raise ValueError(\\"Total resources must be a non-negative integer.\\") if not project_shares: raise ValueError(\\"Project shares dictionary must not be empty.\\") if any(share <= 0 for share in project_shares.values()): raise ValueError(\\"All project shares must be positive.\\") total_shares = sum(project_shares.values()) if total_shares <= 0: raise ValueError(\\"Total of project shares must be greater than zero.\\") allocated = {} fractions = [] total_allocated = 0 # Initial allocation based on floor value of each project\'s share for project, share in project_shares.items(): allocation = total_resources * share / total_shares whole_number = int(allocation) fraction = allocation - whole_number allocated[project] = whole_number fractions.append((fraction, project)) total_allocated += whole_number # Sort fractions in descending order to allocate remaining resources fractions.sort(reverse=True, key=lambda x: x[0]) remaining_resources = total_resources - total_allocated for i in range(remaining_resources): _, project = fractions[i % len(fractions)] allocated[project] += 1 return allocated"},{"question":"# Problem Statement: # Context: You are coding the heart of a system designed to store customer orders and calculate the total order value for a given customer ID. **Purpose:** Implement a data structure to manage orders efficiently and retrieve the total value associated with a specific customer. # Task: Create a class `OrderManager` that supports the following operations: 1. `add_order(customer_id: int, order_value: float) -> None`: Adds an order for the given customer with the specified order value. 2. `get_total_value(customer_id: int) -> float`: Returns the total value of orders for the specified customer. # Requirements: - You need to implement the `OrderManager` class. - Use appropriate data structures to ensure efficient operations, given the constraints. # Input: - `add_order` method: - `customer_id`: An integer that uniquely identifies a customer (1 <= customer_id <= 10^6). - `order_value`: A float representing the value of the order (0.01 <= order_value <= 10^6). - `get_total_value` method: - `customer_id`: An integer that uniquely identifies a customer (1 <= customer_id <= 10^6). # Output: - `add_order`: This method does not return any value. - `get_total_value`: A float representing the total value of all orders for the specified customer. # Constraints: - Ensure that the `get_total_value` method operates efficiently even with a large number of customers and orders. # Example: ```python manager = OrderManager() manager.add_order(1, 100.0) manager.add_order(1, 50.0) manager.add_order(2, 200.0) print(manager.get_total_value(1)) # Output: 150.0 print(manager.get_total_value(2)) # Output: 200.0 ``` **Note**: Design your class to handle edge cases, such as querying a customer ID that has no orders.","solution":"class OrderManager: def __init__(self): self.customer_orders = {} def add_order(self, customer_id: int, order_value: float) -> None: Adds an order for the given customer with the specified order value. if customer_id in self.customer_orders: self.customer_orders[customer_id] += order_value else: self.customer_orders[customer_id] = order_value def get_total_value(self, customer_id: int) -> float: Returns the total value of orders for the specified customer. return self.customer_orders.get(customer_id, 0.0)"},{"question":"# Coding Assessment Question Context You are developing a utility tool to analyze and manipulate text data. One of the functions required is to reverse the order of words in a given sentence while keeping the order of characters within each word unchanged. This is particularly useful for certain text transformation applications. Problem Statement Implement a Python function named `reverse_words(sentence: str) -> str` that takes a sentence as input and returns a new sentence with the words reversed, but the characters in each word remain in the original order. Requirements 1. **Input Format**: - The function will receive a single string `sentence` which may contain multiple words separated by spaces. 2. **Output Format**: - The function should return a new string with the order of words reversed while preserving the character order within each word. 3. **Constraints**: - The input `sentence` will be a valid string, containing letters and spaces. - The words in the sentence are separated by a single space, and there are no leading or trailing spaces. 4. **Performance**: - The function should run efficiently for sentences of typical length (up to several hundred words). 5. **Scenario**: - Validate the function with various test cases to ensure correctness of word reversals and special scenarios (e.g., single-word sentences). Example Usage ```python >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"Python is great\\") \\"great is Python\\" >>> reverse_words(\\"a b c\\") \\"c b a\\" >>> reverse_words(\\"singleword\\") \\"singleword\\" ``` Implementation Guidelines To achieve the desired effect, you might consider splitting the sentence into words, reversing the list of words, and then joining them back into a single string. Ensure to handle any edge cases related to special characters or varying word lengths.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in the given sentence while keeping the order of characters within each word unchanged. :param sentence: A string containing the sentence to be reversed. :return: A string where the order of words is reversed. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Coding Question You are given a task to write a function that calculates the longest sequence of consecutive 1\'s that can be found in a binary representation of numbers within a specified range, inclusive. Requirements: * Write a function `longest_consecutive_ones(start: int, end: int) -> int` which calculates the maximum number of consecutive 1\'s in the binary representation of any number within the range from `start` to `end` inclusive. * The function should return the length of this longest sequence. Input: * `start (int)`: A non-negative integer (0 ≤ start ≤ 10^6). * `end (int)`: A non-negative integer (start ≤ end ≤ 10^6). Output: * Return an integer representing the maximum length of consecutive 1\'s in the binary representation within the specified range. Example: ```python def longest_consecutive_ones(start: int, end: int) -> int: # Your implementation here # Example usage: print(longest_consecutive_ones(5, 13)) # Output should be 3 ``` Constraints: * The solution should be efficient even for the upper limit of `end`. Notes: * Ensure that the function handles edge cases, such as when `start` equals `end`. * Consider how to efficiently convert numbers to their binary representation and find consecutive 1\'s.","solution":"def longest_consecutive_ones(start: int, end: int) -> int: def count_consecutive_ones(n: int) -> int: Helper function to count maximum consecutive 1s in binary representation of n. return max(map(len, bin(n)[2:].split(\'0\'))) longest = 0 for num in range(start, end + 1): longest = max(longest, count_consecutive_ones(num)) return longest"},{"question":"# Problem Statement You are tasked with implementing a function to process a list of strings, where each string contains multiple words separated by spaces. Your function needs to return a new list where each element is a single word from the original list of strings with additional characters removed. # Task **Implement a function `process_strings(strings)` that processes a list of strings as follows:** 1. Split each string into individual words. 2. Remove any special characters (non-alphanumeric characters except spaces). 3. Eliminate any leading or trailing spaces from each word. **Input Format**: - A list of strings `strings`, where each string contains multiple words separated by spaces. **Output Format**: - A list of processed words. **Examples**: ```python >>> process_strings([\\"Hello, World!\\", \\"This is a test!\\", \\"#Python@Programming\\"]) [\'Hello\', \'World\', \'This\', \'is\', \'a\', \'test\', \'Python\', \'Programming\'] >>> process_strings([\\"One---two...three,\\", \\"Goodbye; see you later!\\"]) [\'One\', \'two\', \'three\', \'Goodbye\', \'see\', \'you\', \'later\'] >>> process_strings([\\"\\"]) [] >>> process_strings([\\"123 456\\"]) [\'123\', \'456\'] >>> process_strings([\\"Specialcharacters#should@be!removed\\"]) [\'Special\', \'characters\', \'should\', \'be\', \'removed\'] ``` # Constraints: - The input list can have an arbitrary number of strings, including an empty list. - Each string in the input list can contain letters, digits, spaces, and special characters. - The function should handle upper and lower case characters in the input. - The function should not use any external libraries for handling special characters.","solution":"import re def process_strings(strings): Processes a list of strings by splitting each string into words, removing special characters, and removing leading/trailing spaces. Args: strings (list): A list of strings. Returns: list: A list of processed words. processed_words = [] for s in strings: # Use re.findall to get only alphanumeric characters (words) words = re.findall(r\'bw+b\', s) processed_words.extend(words) return processed_words"},{"question":"# Coding Question Scenario You have been asked to write a function for a library management system to determine the most popular book based on the borrowing frequency. The library logs book borrowing events in a list of strings, where each string contains the book\'s title. Objective Implement the `most_popular_book` function that identifies the most frequently borrowed book from the library\'s log. Function Signature ```python def most_popular_book(borrowed_books: list[str]) -> str: ``` Input * A list of strings, where each string represents the title of a borrowed book. Output * A string representing the title of the most frequently borrowed book. If there is a tie, return any one of the most frequently borrowed book titles. Constraints * The list can contain between 0 and 10^5 book titles. * Each book title is a non-empty string consisting of alphabetical characters and spaces. * The input list may be empty, in which case return an empty string. Example ```python assert most_popular_book([\\"Harry Potter\\", \\"Lord of the Rings\\", \\"Harry Potter\\", \\"The Hobbit\\"]) == \\"Harry Potter\\" assert most_popular_book([]) == \\"\\" assert most_popular_book([\\"1984\\", \\"1984\\", \\"Brave New World\\"]) in [\\"1984\\", \\"Brave New World\\"] ``` Constraints & Performance Requirements * The function should run in linear time relative to the number of borrowed book entries (`O(n)`). * Avoid using more memory than necessary, and aim for a simple and clear solution. Instructions 1. Implement the function `most_popular_book`. 2. Ensure the function correctly handles all the given example cases. 3. Consider edge cases and performance constraints as outlined.","solution":"from collections import Counter def most_popular_book(borrowed_books: list[str]) -> str: if not borrowed_books: return \\"\\" book_counter = Counter(borrowed_books) most_common_book = book_counter.most_common(1)[0][0] return most_common_book"},{"question":"# Coding Assessment Question You are tasked with writing a Python function that processes a given list of dates to find the longest continuous sequence of dates that span over weekends and holidays. **Function Description:** Write a function `longest_continuous_sequence(dates: List[str]) -> List[str]` that takes a list of dates represented as strings in the format `\\"YYYY-MM-DD\\"`. The function should return the longest sequence of continuous dates that forms a valid period including weekends (Saturday and Sunday) and holiday dates. Input: * `dates` (List[str]): A list of date strings in `\\"YYYY-MM-DD\\"` format. Output: * A list of date strings representing the longest continuous sequence. Considerations: * Saturday and Sunday are always considered as part of the sequence. * You are provided a list of holidays that should be treated the same as weekends. * If multiple sequences have the same length, return the first one in the list. * You can assume that the `dates` list provided is always sorted in ascending order. Example: ```python # Input list of dates dates = [ \\"2024-01-05\\", \\"2024-01-06\\", \\"2024-01-07\\", \\"2024-01-08\\", \\"2024-03-14\\", \\"2024-03-15\\", \\"2024-03-16\\", \\"2024-03-17\\", \\"2024-03-18\\", \\"2024-12-25\\", ] holidays = [ \\"2024-01-08\\", \\"2024-03-18\\", ] # Output [ \\"2024-03-14\\", \\"2024-03-15\\", \\"2024-03-16\\", \\"2024-03-17\\", \\"2024-03-18\\" ] ``` Constraints: * Dates are provided in sorted order. * The length of dates will not exceed 1000. * Use `datetime` module to handle date manipulations. * A valid period must include at least 3 consecutive dates including a weekend. **Notes:** * Ensure to handle the edge cases where the sequence might end at the last date or start from the first date. **Tips:** - Pay attention to consecutive dates across weeks and weeks that span across the months. - Do not consider skipped weekdays to be sequential unless they fall on holidays.","solution":"from datetime import datetime, timedelta from typing import List def longest_continuous_sequence(dates: List[str], holidays: List[str]) -> List[str]: holidays_set = set(holidays) date_objects = [datetime.strptime(date, \\"%Y-%m-%d\\") for date in dates] date_strs = [date.strftime(\\"%Y-%m-%d\\") for date in date_objects] def is_weekend_or_holiday(date_str): date_obj = datetime.strptime(date_str, \\"%Y-%m-%d\\") if date_str in holidays_set: return True if date_obj.weekday() in (5, 6): # Saturday or Sunday return True return False max_sequence = [] current_sequence = [] for i in range(len(date_objects)): current_sequence.append(date_strs[i]) if i == len(date_objects) - 1 or (date_objects[i+1] - date_objects[i]).days != 1: if any(is_weekend_or_holiday(date) for date in current_sequence): if len(current_sequence) > len(max_sequence): max_sequence = current_sequence.copy() current_sequence = [] return max_sequence"},{"question":"# Objective Implement a function that simulates the rolling of dice and determines the outcome of a probabilistic game. # Question You\'ve been asked to create a function that simulates rolling a given number of six-sided dice and determines if the outcome matches a target sum. # Function Signature ```python def roll_dice_and_check(sum_target: int, num_dice: int) -> bool: Simulate rolling num_dice six-sided dice and check if the sum equals sum_target. Parameters: - sum_target (int): The target sum to be checked after rolling the dice. - num_dice (int): The number of six-sided dice to be rolled. Returns: - bool: True if the sum of the rolled dice equals sum_target, False otherwise. ``` # Input/Output - **Input**: An integer `sum_target` representing the target sum, and an integer `num_dice` representing the number of dice to roll. - **Output**: A boolean value indicating whether the sum of the rolled dice matches the sum_target. # Constraints - The number of dice will be such that 1 <= num_dice <= 10. - Each die is a standard six-sided die (values range from 1 to 6). - The target sum will be within the possible range for the given number of dice (i.e., between num_dice and 6 * num_dice). # Performance Requirement - The function should simulate the rolling of dice using random number generation, ensuring the results are uniformly distributed. # Example ```python import random def roll_dice_and_check(sum_target: int, num_dice: int) -> bool: rolled_sum = sum(random.randint(1, 6) for _ in range(num_dice)) return rolled_sum == sum_target # Example usage print(roll_dice_and_check(10, 3)) # Output will vary due to randomness print(roll_dice_and_check(18, 3)) # Output will vary due to randomness ``` # Notes: 1. Ensure randomness is handled correctly to avoid bias in the dice rolls. 2. Validate your function with various test cases to handle different numbers of dice and target sums.","solution":"import random def roll_dice_and_check(sum_target: int, num_dice: int) -> bool: Simulate rolling num_dice six-sided dice and check if the sum equals sum_target. Parameters: - sum_target (int): The target sum to be checked after rolling the dice. - num_dice (int): The number of six-sided dice to be rolled. Returns: - bool: True if the sum of the rolled dice equals sum_target, False otherwise. rolled_sum = sum(random.randint(1, 6) for _ in range(num_dice)) return rolled_sum == sum_target"},{"question":"# Coding Assessment Question: You are given a list of integers where each integer represents the frequency of a word in a document. Your task is to implement a function `find_modes` which identifies the mode(s) of the list, that is, the integer(s) that appear the most frequently. # Function Signature: ```python def find_modes(frequencies: List[int]) -> List[int]: pass ``` # Input: * A list of integers `frequencies` where each integer represents the frequency of a word. * Constraints: The length of the list `frequencies` is 0 <= len(frequencies) <= 10^5. * Each element in `frequencies` will be a positive integer less than or equal to 10^6. # Output: * Returns a list of integers representing the mode(s) of the input list. The order of the modes in the output list does not matter. # Examples: ```python >>> find_modes([4, 5, 6, 6, 8, 8, 8]) [8] >>> find_modes([3, 3, 1, 2, 2, 1]) [1, 2, 3] >>> find_modes([7]) [7] >>> find_modes([]) [] ``` # Performance Requirements: * The solution must have an average time complexity of O(n) and a space complexity of O(n), where n is the length of the input list.","solution":"from typing import List from collections import Counter def find_modes(frequencies: List[int]) -> List[int]: Identifies the mode(s) of the list, i.e., the integer(s) that appear the most frequently. :param frequencies: List of integers where each integer represents the frequency of a word. :return: List of integers representing the mode(s) of the input list. if not frequencies: return [] frequency_counter = Counter(frequencies) max_frequency = max(frequency_counter.values()) return [key for key, value in frequency_counter.items() if value == max_frequency]"},{"question":"# Fibonacci Sequence with Memorization and Iterative Approach Context The Fibonacci sequence is a well-known series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. It is a common problem in both recursion and dynamic programming due to its exponential growth and the overlap of subproblems. Objective Write a Python class that computes Fibonacci numbers using two different techniques: memoization (a top-down dynamic programming approach) and an iterative approach. The class should also have functionalities to clear memoization cache and to retrieve computed Fibonacci numbers for any given index efficiently. Core Implementation Requirements 1. Implement a class `FibonacciCalculator` with the following methods: - `__init__(self)`: Initializes any necessary data structures for memoization. - `fibonacci_memoization(self, n)`: Computes and returns the nth Fibonacci number using memoization. - `fibonacci_iterative(self, n)`: Computes and returns the nth Fibonacci number using an iterative approach. - `get_cached_fibonacci(self, n)`: Retrieves the cached (precomputed) Fibonacci number for the given index if available. - `clear_cache(self)`: Clears the memoization cache. Constraints - Ensure that the input value `n` is a non-negative integer. - The maximum value for `n` should be constrained to a value such as `n <= 10^5` to avoid excessive computation and memory use. Example Here\'s an example to illustrate the usage: ```python if __name__ == \\"__main__\\": fib_calc = FibonacciCalculator() # Compute the 10th Fibonacci number using memoization print(fib_calc.fibonacci_memoization(10)) # Output: 55 # Compute the 10th Fibonacci number using iterative approach print(fib_calc.fibonacci_iterative(10)) # Output: 55 # Retrieve the cached Fibonacci number for index 10 print(fib_calc.get_cached_fibonacci(10)) # Output: 55 # Clear the memoization cache fib_calc.clear_cache() # Retrieve the cached Fibonacci number for index 10 after clearing cache print(fib_calc.get_cached_fibonacci(10)) # Output: None ``` Your task is to complete the `FibonacciCalculator` class meeting the specified requirements. Ensure the solution is efficient and handles the constraints properly.","solution":"class FibonacciCalculator: def __init__(self): self.memo = {} def fibonacci_memoization(self, n): Computes the nth Fibonacci number using memoization. Args: n (int): The index of the Fibonacci number to compute. Returns: int: The nth Fibonacci number. if n < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if n in self.memo: return self.memo[n] if n == 0: result = 0 elif n == 1: result = 1 else: result = self.fibonacci_memoization(n - 1) + self.fibonacci_memoization(n - 2) self.memo[n] = result return result def fibonacci_iterative(self, n): Computes the nth Fibonacci number using an iterative approach. Args: n (int): The index of the Fibonacci number to compute. Returns: int: The nth Fibonacci number. if n < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for i in range(2, n + 1): prev, curr = curr, prev + curr return curr def get_cached_fibonacci(self, n): Retrieves the cached Fibonacci number for the given index if available. Args: n (int): The index of the Fibonacci number. Returns: int or None: The cached Fibonacci number if available, otherwise None. return self.memo.get(n, None) def clear_cache(self): Clears the memoization cache. self.memo.clear()"},{"question":"# Coding Assessment Question: **Problem Description**: You are assigned to implement a basic version of a Convolutional Neural Network (CNN) from scratch. The primary focus of this exercise is to demonstrate your understanding of the core tenets of CNN architectures and your ability to implement fundamental units such as convolutional layers, pooling layers, and fully connected layers. **Requirements**: Implement a class `SimpleCNN` that handles basic image classification tasks using a neural network with the following methods: 1. **Constructor `__init__(self, input_shape: tuple, num_classes: int)`** - Initialize the network with input image shape and number of output classes. 2. **Method `forward(self, X: np.ndarray) -> np.ndarray`** - Define the forward pass of the CNN, computing the output class probabilities for the input feature tensor. 3. **Method `train(self, X_train: np.ndarray, y_train: np.ndarray, epochs: int = 10, learning_rate: float = 0.01)`** - Implement simple gradient descent to train the CNN on the training data using cross-entropy loss. 4. **Method `predict(self, X: np.ndarray) -> np.ndarray`** - Predict the class labels for the given input feature tensor. **Input/Output**: 1. **Constructor Parameters**: - `input_shape` (tuple): Shape of the input images (C, H, W) where C is the number of channels, H is the height, and W is the width. - `num_classes` (int): Number of output classes. 2. **Method Parameters for `train`**: - `X_train` (np.ndarray): Training feature tensor of shape (N, C, H, W), where N is the number of samples. - `y_train` (np.ndarray): Training target labels of shape (N,). - `epochs` (int): Number of epochs for training. - `learning_rate` (float): Learning rate for updating parameters. 3. **Method Parameters for `forward` and `predict`**: - `X` (np.ndarray): Input feature tensor of shape (N, C, H, W). 4. **Method Output for `predict`**: - Return (np.ndarray): Array of predicted labels of shape (N,). **Constraints**: - Use a simple architecture with at least one convolutional layer followed by a pooling layer, and a fully connected layer at the end. - Implement using only Numpy (no use of high-level libraries such as TensorFlow or PyTorch). - Assume grayscale images if multi-channel support isn\'t obvious within constraints. - Handle typical edge cases, ensuring computational efficiency. **Performance Requirements**: - Ensure the computations are optimized for small datasets typically seen in educational contexts. **Example**: ```python import numpy as np class SimpleCNN: def __init__(self, input_shape, num_classes): # Initialize network parameters, such as weights and biases pass def forward(self, X): # Implement forward pass, returning class probabilities pass def train(self, X_train, y_train, epochs=10, learning_rate=0.01): # Implement training procedure with gradient descent pass def predict(self, X): # Implement the prediction procedure pass if __name__ == \\"__main__\\": # Fake data np.random.seed(0) X_train = np.random.randn(100, 1, 28, 28) y_train = np.random.randint(0, 10, 100) # Initialize and train the CNN input_shape = (1, 28, 28) num_classes = 10 cnn = SimpleCNN(input_shape, num_classes) cnn.train(X_train, y_train, epochs=5, learning_rate=0.01) # Predict on training data y_pred = cnn.predict(X_train) # Dummy accuracy check accuracy = np.mean(y_pred == y_train) print(f\\"Accuracy: {accuracy:.2f}\\") ``` **Objective**: Ensure that you thoroughly understand the convolutional neural network structure and can apply it to conduct image classification tasks.","solution":"import numpy as np class SimpleCNN: def __init__(self, input_shape, num_classes): self.input_shape = input_shape self.num_classes = num_classes C, H, W = input_shape # Initialize weights and biases for convolutional layer self.conv_W = np.random.randn(4, C, 3, 3) * 0.01 # 4 filters, C channels, 3x3 kernel self.conv_b = np.zeros(4) # Initialize weights and biases for fully connected layer (after pooling) self.fc_W = np.random.randn(4 * 13 * 13, num_classes) * 0.01 # assuming pooled size of 13x13 with 4 channels self.fc_b = np.zeros(num_classes) def relu(self, x): return np.maximum(0, x) def forward(self, X): self.X = X N, C, H, W = X.shape # Convolutional layer self.Z1 = np.zeros((N, 4, H - 2, W - 2)) for n in range(N): for f in range(4): self.Z1[n, f] = self.conv_b[f] for c in range(C): self.Z1[n, f] += self.convolve2d(X[n, c], self.conv_W[f, c]) # Apply ReLU self.A1 = self.relu(self.Z1) # Max pooling layer (2x2) self.Z2 = self.max_pool_2x2(self.A1) # Flatten self.Z2_flat = self.Z2.reshape(N, -1) # Fully connected layer self.Z3 = np.dot(self.Z2_flat, self.fc_W) + self.fc_b self.A3 = self.softmax(self.Z3) return self.A3 def convolve2d(self, x, w): H, W = x.shape h, w = w.shape output = np.zeros((H - h + 1, W - w + 1)) for i in range(H - h + 1): for j in range(W - w + 1): output[i, j] = np.sum(x[i:i+h, j:j+w] * w) return output def max_pool_2x2(self, x): N, C, H, W = x.shape pooled = np.zeros((N, C, H // 2, W // 2)) for n in range(N): for c in range(C): for i in range(0, H, 2): for j in range(0, W, 2): pooled[n, c, i // 2, j // 2] = np.max(x[n, c, i:i+2, j:j+2]) return pooled def softmax(self, x): e_x = np.exp(x - np.max(x, axis=1, keepdims=True)) return e_x / e_x.sum(axis=1, keepdims=True) def cross_entropy_loss(self, y_pred, y_true): N = y_true.shape[0] log_likelihood = -np.log(y_pred[range(N), y_true]) loss = np.sum(log_likelihood) / N return loss def train(self, X_train, y_train, epochs=10, learning_rate=0.01): for epoch in range(epochs): y_pred = self.forward(X_train) loss = self.cross_entropy_loss(y_pred, y_train) print(f\'Epoch {epoch+1}/{epochs}, Loss: {loss:.4f}\') # Backpropagation dZ3 = y_pred dZ3[range(len(y_train)), y_train] -= 1 dZ3 /= len(y_train) # Gradient for fully connected layer dW_fc = np.dot(self.Z2_flat.T, dZ3) db_fc = np.sum(dZ3, axis=0) dZ2_flat = np.dot(dZ3, self.fc_W.T) dZ2 = dZ2_flat.reshape(self.Z2.shape) # Gradient for pooling layer (2x2) dA1 = self.max_pool_2x2_backward(dZ2, self.Z1) # Gradient for convolutional layer dZ1 = dA1 * (self.Z1 > 0) dW_conv = np.zeros(self.conv_W.shape) db_conv = np.zeros(self.conv_b.shape) for n in range(len(X_train)): for f in range(4): for c in range(X_train.shape[1]): dW_conv[f, c] += self.convolve2d(X_train[n, c], dZ1[n, f]) db_conv[f] += np.sum(dZ1[n, f]) # Update weights and biases self.conv_W -= learning_rate * dW_conv self.conv_b -= learning_rate * db_conv self.fc_W -= learning_rate * dW_fc self.fc_b -= learning_rate * db_fc def max_pool_2x2_backward(self, dout, prev_input): N, C, H, W = prev_input.shape dA_prev = np.zeros_like(prev_input) for n in range(N): for c in range(C): for i in range(0, H, 2): for j in range(0, W, 2): h, w = np.unravel_index(np.argmax(prev_input[n, c, i:i+2, j:j+2]), (2, 2)) dA_prev[n, c, i+h, j+w] = dout[n, c, i//2, j//2] return dA_prev def predict(self, X): y_pred = self.forward(X) return np.argmax(y_pred, axis=1)"},{"question":"# Problem: Generating Permutations of a List with Recursion Context You are working on an application that requires generating all possible permutations of a given list. The permutations should be generated using a recursive approach to practice and demonstrate recursive algorithm design techniques. Task 1. **Implement the recursive function** to generate all permutations of a given list. 2. **Ensure that the function handles edge cases** such as empty lists and lists with duplicate elements correctly. Details 1. **Functionality**: - Implement the `generate_permutations` function using recursion to generate all permutations of a list. 2. **Input and Output Formats**: - `generate_permutations(lst: list) -> list`: Given a list `lst`, returns a list of all possible permutations. 3. **Constraints and Requirements**: - The input list can contain any elements (e.g., integers, strings). - The length of the list will not exceed 10 elements. - Handle edge cases, such as empty input lists or lists with repeating elements. - Ensure that all permutations are generated precisely and without omissions. 4. **Example Usage**: - `generate_permutations([1, 2, 3])` should return a list of lists containing all permutations of `[1, 2, 3]`. - `generate_permutations([\'a\', \'b\', \'b\'])` should handle duplicates appropriately. Implementation ```python def generate_permutations(lst: list) -> list: Generates all permutations of a given list using recursion. if len(lst) == 0: return [[]] # To collect all permutations permutations = [] for i in range(len(lst)): # Choose the current element current = lst[i] # Remaining elements remaining = lst[:i] + lst[i + 1:] # Generate all permutations for the remaining elements for p in generate_permutations(remaining): permutations.append([current] + p) return permutations # Example to test print(generate_permutations([1, 2, 3])) # Expected: All permutations of [1, 2, 3] print(generate_permutations([\'a\', \'b\', \'b\'])) # Expected: Handle duplicates appropriately ``` Write your implementation and ensure it passes all test cases provided.","solution":"def generate_permutations(lst: list) -> list: Generates all permutations of a given list using recursion. if len(lst) == 0: return [[]] # To collect all permutations permutations = [] for i in range(len(lst)): # Choose the current element current = lst[i] # Remaining elements remaining = lst[:i] + lst[i + 1:] # Generate all permutations for the remaining elements for p in generate_permutations(remaining): permutations.append([current] + p) return permutations"},{"question":"# Maximum Subarray Sum Background: The Maximum Subarray Problem is a classic algorithmic problem which consists in finding the contiguous subarray within a one-dimensional numeric array, that has the largest sum. Task: You are required to implement the function `max_subarray_sum` as described in the code snippet provided to calculate the maximum sum of a contiguous subarray. Your function should correctly handle edge cases including empty arrays or arrays with all negative numbers. Function Signature: ```python def max_subarray_sum(arr: list) -> int: Calculate the maximum sum of a contiguous subarray. Input Parameters: arr (list): A list of integers representing the array. Returns: int: Maximum sum of a contiguous subarray. Raises: ValueError: If the input array is empty. ``` Example Tests: ```python >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([]) Traceback (most recent call last): ... ValueError: The input array is empty ``` Constraints: * The function should handle both positive and negative integers within the array. * The function should have a time complexity of O(n), where n is the number of elements in the array. * Ensure the input array is not modified within the function.","solution":"def max_subarray_sum(arr: list) -> int: Calculate the maximum sum of a contiguous subarray. Input Parameters: arr (list): A list of integers representing the array. Returns: int: Maximum sum of a contiguous subarray. Raises: ValueError: If the input array is empty. if not arr: raise ValueError(\\"The input array is empty\\") max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Assessment Question You are working as a software engineer at a tech company that deals with large datasets. Your task is to implement a function that can perform data aggregation on a specified column of a dataset. The dataset is a `pandas.DataFrame` and the column contains numerical data. Your goal is to create a function `aggregate_data` that takes in the following parameters: - `df` (pd.DataFrame): The input DataFrame containing the dataset. - `column` (str): The name of the column on which to perform the aggregation. - `aggregation_type` (str): The type of aggregation to perform. It can be one of the following: - \\"sum\\" - \\"mean\\" - \\"median\\" - \\"max\\" - \\"min\\" - \\"std\\" - \\"var\\" - \\"count\\" - \\"quantile\\" - `quantile` (float): The quantile value to compute if `aggregation_type` is \\"quantile\\". It must be between 0 and 1. The function should return the result of the aggregation as a float. Input and Output Formats ```python def aggregate_data(df: pd.DataFrame, column: str, aggregation_type: str, quantile: float = None) -> float: pass # Example usage: import pandas as pd data = {\'A\': [1, 2, 3, 4, 5], \'B\': [6, 7, 8, 9, 10]} df = pd.DataFrame(data) print(aggregate_data(df, \'A\', \'sum\')) # Expected: 15.0 print(aggregate_data(df, \'B\', \'mean\')) # Expected: 8.0 print(aggregate_data(df, \'A\', \'quantile\', quantile=0.5)) # Expected: 3.0 ``` Constraints - The input column must exist in the DataFrame. - The `aggregation_type` must be one of the specified types. - When `aggregation_type` is \\"quantile\\", the `quantile` parameter must be provided and be between 0 and 1. - Handle edge cases for empty DataFrames or columns with non-numeric data. Requirements - Implement error handling for invalid columns and aggregation types. - Optimize for performance using `pandas` built-in aggregation functions. - Ensure numerical accuracy and handle special cases such as missing values. # Note Use the provided code snippets as references for implementing and validating your solution.","solution":"import pandas as pd def aggregate_data(df: pd.DataFrame, column: str, aggregation_type: str, quantile: float = None) -> float: Perform data aggregation on a specified column of a dataset. Parameters: df (pd.DataFrame): The input DataFrame containing the dataset. column (str): The name of the column on which to perform the aggregation. aggregation_type (str): The type of aggregation to perform. quantile (float): The quantile value to compute if aggregation_type is \\"quantile\\". It must be between 0 and 1. Returns: float: The result of the aggregation. if column not in df.columns: raise ValueError(f\\"Column \'{column}\' does not exist in the DataFrame.\\") if aggregation_type == \\"quantile\\" and (quantile is None or not (0 <= quantile <= 1)): raise ValueError(\\"Quantile value must be between 0 and 1.\\") if aggregation_type == \\"sum\\": return df[column].sum() elif aggregation_type == \\"mean\\": return df[column].mean() elif aggregation_type == \\"median\\": return df[column].median() elif aggregation_type == \\"max\\": return df[column].max() elif aggregation_type == \\"min\\": return df[column].min() elif aggregation_type == \\"std\\": return df[column].std() elif aggregation_type == \\"var\\": return df[column].var() elif aggregation_type == \\"count\\": return df[column].count() elif aggregation_type == \\"quantile\\": return df[column].quantile(quantile) else: raise ValueError(f\\"Invalid aggregation type \'{aggregation_type}\'.\\")"},{"question":"# Problem Statement You are tasked with writing a function that compresses a given string using a basic Run-Length Encoding (RLE) technique and then decompresses the encoded string back to its original form. # Function to Implement Implement the function `rle_encode_decode(operations: List[str], values: List[str]) -> List[str]` which: * Encodes or decodes strings based on the specified operations. * The operations list contains strings either `\\"encode\\"` or `\\"decode\\"` that corresponds to the values in the values list. * Each string in values list should be processed according to the operation in the operations list at the same index. # Input Format 1. `operations` (List[str]): A list of operations, either `\\"encode\\"` or `\\"decode\\"`. 2. `values` (List[str]): A list of strings to be encoded or decoded. # Output Format * Returns a list of strings processed according to the specified operations. # Constraints * The length of `operations` and `values` will be the same. * The strings in `values` will contain only lowercase alphabetic characters when the operation is `\\"encode\\"`. * The strings in `values` will be valid RLE encoded strings when the operation is `\\"decode\\"`. # Example Given the following input: ```python operations = [\\"encode\\", \\"decode\\"] values = [\\"aaabbccc\\", \\"2a2b3c\\"] ``` The expected output is: ```python [\\"3a2b3c\\", \\"aabbccc\\"] ``` # Notes * For encoding strings, consecutive repeated characters are compressed into a single character followed by its count. * For decoding strings, each character is expanded based on its preceding count. * Ensure that your solution can handle edge cases such as empty strings or strings without repetitions effectively.","solution":"from typing import List def rle_encode(s: str) -> str: if not s: return \\"\\" encoded = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoded.append(f\\"{count}{s[i]}\\") i += 1 return \'\'.join(encoded) def rle_decode(s: str) -> str: if not s: return \\"\\" decoded = [] i = 0 while i < len(s): count = 0 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 decoded.append(s[i] * count) i += 1 return \'\'.join(decoded) def rle_encode_decode(operations: List[str], values: List[str]) -> List[str]: results = [] for op, val in zip(operations, values): if op == \\"encode\\": results.append(rle_encode(val)) elif op == \\"decode\\": results.append(rle_decode(val)) return results"},{"question":"# Problem Statement You are given an array of integers where each integer appears exactly twice, except for one integer that appears only once. Your task is to find the integer that appears only once without using any extra memory beyond a few variables. Function Signature ```python def find_unique_element(nums: list[int]) -> int: pass ``` Input * `nums`: A list of integers where `1 <= nums.length <= 3 * 10^4`. Output * Returns an integer representing the element that appears only once. Constraints * Every element except for one appears exactly twice. * The constraint on `nums.length` ensures the algorithm should work efficiently for large arrays. Example ```python # Example 1 nums = [2, 2, 1] assert find_unique_element(nums) == 1 # Example 2 nums = [4, 1, 2, 1, 2] assert find_unique_element(nums) == 4 # Example 3 nums = [1] assert find_unique_element(nums) == 1 # Example 4 nums = [3, 3, 9, 11, 9] assert find_unique_element(nums) == 11 ``` Notes * Aim for a solution with a linear runtime complexity and O(1) space complexity. * Make use of bitwise XOR operation which can help solve the problem in linear time with constant space. * Assume no additional auxiliary data structures are allowed for the solution, sticking to the requirement of constant extra memory usage.","solution":"def find_unique_element(nums): Returns the element that appears only once in the list. Uses XOR operation to achieve O(n) time complexity and O(1) space complexity. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Scenario You are tasked with creating a log management system to record and query log entries. Each log entry consists of a timestamp and a message. The goal is to implement a system that allows efficient insertion of logs and querying based on a time range. # Task Description Implement a `LogManager` class that provides the following functionalities: 1. Add a new log entry. 2. Retrieve all log entries within a specified time range. # Input and Output Formats `LogManager` class should have the following methods: - `add_log(timestamp: int, message: str)`: Adds a new log entry with the given timestamp and message. - `get_logs(start_time: int, end_time: int) -> List[str]`: Returns a list of messages of all log entries whose timestamps fall within the specified `start_time` and `end_time` (inclusive). # Constraints - Timestamps are unique. - Timestamps and range values will be integers. - The number of log entries (`n`) will not exceed (10^5). - Both `add_log` and `get_logs` should operate efficiently, even with the maximum number of log entries. # Example ```python log_manager = LogManager() log_manager.add_log(1, \\"System started\\") log_manager.add_log(5, \\"User login\\") log_manager.add_log(10, \\"File upload\\") assert log_manager.get_logs(1, 5) == [\\"System started\\", \\"User login\\"] assert log_manager.get_logs(0, 10) == [\\"System started\\", \\"User login\\", \\"File upload\\"] assert log_manager.get_logs(6, 10) == [\\"File upload\\"] ``` # Requirements Ensure that your implementation is efficient and handles all edge cases appropriately.","solution":"from bisect import bisect_left, bisect_right class LogManager: def __init__(self): self.logs = [] # This will store tuples of (timestamp, message) def add_log(self, timestamp: int, message: str): # Insert log maintaining the order of timestamps self.logs.append((timestamp, message)) self.logs.sort() def get_logs(self, start_time: int, end_time: int): # Use binary search to quickly find the range of timestamps start_index = bisect_left(self.logs, (start_time, \\"\\")) end_index = bisect_right(self.logs, (end_time, \\"{\\")) return [message for timestamp, message in self.logs[start_index:end_index]]"},{"question":"# Rotated Array Search Given the following problem: You are given a rotated sorted array (an array that was originally sorted in ascending order but then rotated at some unknown pivot). It might contain duplicates. Your task is to search for a target value in this array. If the target is found in the array, return the smallest index at which it occurs. Otherwise, return -1. **Task**: Implement a function `search_rotated_array(arr: List[int], target: int) -> int` that returns the index of the target value if it exists in the array, or -1 if it does not. Function Signature ```python def search_rotated_array(arr: List[int], target: int) -> int: ``` Input * `arr`: A list of integers representing the rotated sorted array. The length of the list will be at most (10^4). * `target`: An integer representing the value to search for in the array. Output * Return an integer which is the smallest index at which the target value occurs, or -1 if it does not exist in the array. Constraints * The array contains integers that fit within the signed 32-bit integer range. * The length of the array is at most ( 10^4 ). * The array might contain duplicate values. * The function should have a time complexity of (O(log n)) in the best case scenario (considering binary search properties). Example ```python assert search_rotated_array([4,5,6,7,0,1,2], 0) == 4 assert search_rotated_array([4,5,6,7,0,1,2], 3) == -1 assert search_rotated_array([1], 0) == -1 assert search_rotated_array([1, 3, 1, 1, 1], 3) == 1 assert search_rotated_array([1, 1, 1, 3, 1], 3) == 3 ``` Additional Notes * Consider handling edge cases where the array has only one element, or where the array is not rotated. * It\'s important to handle duplicates effectively to maintain (O(log n)) complexity if possible. * Think about different strategies to split and conquer the array considering its rotated nature. * Optimize the solution for both theoretical and practical scenarios considering the array size constraints.","solution":"from typing import List def search_rotated_array(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: # Continue searching to the left to find the smallest index while mid > left and arr[mid - 1] == target: mid -= 1 return mid if arr[left] < arr[mid] or arr[left] == arr[mid] and arr[mid] > arr[right]: # left part is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 elif arr[mid] < arr[right] or arr[left] == arr[mid] and arr[mid] < arr[right]: # right part is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 else: # if we can\'t determine which part is sorted, just increase left or decrease right to skip duplicates if arr[left] == arr[mid]: left += 1 if arr[right] == arr[mid]: right -= 1 return -1"},{"question":"# Context You are building an application that processes and analyzes various statistical data. One of the features requires analyzing an array of integers to perform a specific operation frequently. For this purpose, you need to implement a function that, given a sorted array, finds the count of unique elements within a given range [L, R] efficiently. # Task Implement the function `count_unique_elements_in_range` that takes a sorted list of integers and two integers L and R, and returns the count of unique elements in the range [L, R] inclusive. Function Signature ```python def count_unique_elements_in_range(arr: List[int], L: int, R: int) -> int: pass ``` Input - `arr` (List[int]): A sorted list of integers, 1 ≤ len(arr) ≤ 10^6, -10^9 ≤ arr[i] ≤ 10^9 - `L` (int): The lower bound of the range, -10^9 ≤ L ≤ 10^9 - `R` (int): The upper bound of the range, -10^9 ≤ R ≤ 10^9 Output - Returns an integer representing the count of unique elements in the range [L, R]. # Constraints - The list is sorted in non-decreasing order. - L <= R # Performance Requirements - The solution should be efficient, ideally O(n) where n is the number of elements in the given range. # Example ```python # Example 1 print(count_unique_elements_in_range([1, 2, 2, 3, 4, 4, 5], 2, 4)) # Output: 3 # Example 2 print(count_unique_elements_in_range([-10, -5, 0, 5, 10], -5, 5)) # Output: 3 ``` # Hints - Use a set to track unique elements within the range efficiently as you iterate through the list. - Consider using binary search to find the starting point of the range within the sorted list.","solution":"from typing import List import bisect def count_unique_elements_in_range(arr: List[int], L: int, R: int) -> int: Returns the count of unique elements in the range [L, R] inclusive in a sorted array. start_index = bisect.bisect_left(arr, L) # find the first index where arr[index] >= L end_index = bisect.bisect_right(arr, R) # find the first index where arr[index] > R unique_elements = set(arr[start_index:end_index]) return len(unique_elements)"},{"question":"# Problem Statement Design a function `most_frequent_char` that takes a string as input and returns the character that appears most frequently in the string. If there are multiple characters with the same highest frequency, return the one that appears first in the string. The input string may contain spaces, punctuation, and special characters, and it is case-sensitive. # Function Signature ```python def most_frequent_char(s: str) -> str: pass ``` # Input: - `s` (str): A string that may include spaces, punctuation, and special characters. # Output: - Returns a single character (str) that appears most frequently in the input string. # Constraints: - The input string is not empty. # Examples: ```python >>> most_frequent_char(\\"aabcc\\") \'a\' >>> most_frequent_char(\\"aabbcc\\") \'a\' >>> most_frequent_char(\\"!@#@!\\") \'@\' >>> most_frequent_char(\\"This is a test\\") \' \' >>> most_frequent_char(\\"ZZzzZz\\") \'Z\' ``` # Notes: - The function should consider all characters, including spaces, punctuation, and special characters. - The function should be efficient in terms of time complexity, aiming for O(n) complexity where n is the length of the string. - If there is a tie in frequency, return the character that appears first in the string.","solution":"def most_frequent_char(s: str) -> str: char_count = {} max_char = \'\' max_count = 0 for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 if char_count[char] > max_count: max_count = char_count[char] max_char = char return max_char"},{"question":"# Question: Rotating a Matrix Context: Rotating a matrix is a fundamental operation in computer graphics and image processing. Given a square matrix, rotating it 90 degrees clockwise involves transforming each element to a new position. Task: Implement a function that rotates a given n x n 2D matrix 90 degrees clockwise in place. Requirements: * **Input Formats**: - A matrix represented as a list of n lists, each containing n elements. * **Output Formats**: - The transformed matrix, rotated 90 degrees clockwise. * **Constraints**: - The size of the matrix is between 1 and 100 (1 ≤ n ≤ 100). - Elements of the matrix can be any integer within the range -1000 to 1000. Example: ```python def rotate_matrix(matrix: list[list[int]]) -> None: Rotate n x n 2D matrix 90 degrees clockwise in place. # Implementation here # Example usage matrix = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix) print(matrix) # Output: [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] ``` **Note**: You must follow the function signature provided below. ```python def rotate_matrix(matrix: list[list[int]]) -> None: n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first # Save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top # Example doctests: >>> matrix1 = [[1]] >>> rotate_matrix(matrix1) >>> matrix1 [[1]] >>> matrix2 = [[1, 2], [3, 4]] >>> rotate_matrix(matrix2) >>> matrix2 [[3, 1], [4, 2]] >>> matrix3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> rotate_matrix(matrix3) >>> matrix3 [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ```","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first # Save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"# Task: Implement a Rate Limiter Function Problem Statement You are required to design a rate limiter function that controls the number of times a particular event is allowed to occur over a specified time period. This functionality is essential for preventing abuse of resources in scenarios such as API requests, login attempts, or data submissions. The function should track events and enforce the limits, raising an exception if the limit is exceeded. Function Signature ```python def rate_limiter(event_name: str, limit: int, time_window: float) -> bool: pass ``` Input - `event_name` (str): The name of the event to be tracked. - `limit` (int): The maximum number of times the event is allowed to occur within the `time_window`. - `time_window` (float): The time window in seconds during which the `limit` applies. Output - Returns `True` if the event is allowed (i.e., it hasn\'t exceeded the limit in the given time window). - Raises a `RateLimitExceededException` if the event has already occurred `limit` times within the `time_window`. Constraints 1. The `event_name` is a non-empty string. 2. The `limit` is a positive integer. 3. The `time_window` is a positive float representing time in seconds. 4. Handle invalid inputs by raising appropriate `ValueError`. Exception ```python class RateLimitExceededException(Exception): pass ``` Example ```python >>> rate_limiter(\\"login_attempt\\", 5, 60) True # First call, within limit >>> rate_limiter(\\"login_attempt\\", 5, 60) True # Second call, within limit >>> rate_limiter(\\"login_attempt\\", 5, 60) ... (repeated 3 more times within 60 seconds) True # Fifth call, within limit >>> rate_limiter(\\"login_attempt\\", 5, 60) Traceback (most recent call last): ... RateLimitExceededException: The rate limit for event login_attempt has been exceeded. >>> rate_limiter(\\"login_attempt\\", -1, 60) Traceback (most recent call last): ... ValueError: Limit must be a positive integer. >>> rate_limiter(\\"\\", 5, 60) Traceback (most recent call last): ... ValueError: Event name must be a non-empty string. >>> rate_limiter(\\"login_attempt\\", 5, -10) Traceback (most recent call last): ... ValueError: Time window must be a positive float. ``` Requirements - Implement the rate limiter function to track the occurrences of events and enforce limits. - Store and manage the timestamps of when events occur to calculate if the limit is reached within the given time window. - Ensure proper error handling for invalid inputs. Notes - Use appropriate data structures to track events and their timestamps efficiently. - Optimize for both time and space complexity, ensuring the function is capable of handling high-frequency calls without significant performance degradation.","solution":"from collections import defaultdict, deque from time import time class RateLimitExceededException(Exception): pass event_timestamps = defaultdict(deque) def rate_limiter(event_name: str, limit: int, time_window: float) -> bool: Determines if an event is allowed based on the given rate limit. if not isinstance(event_name, str) or not event_name: raise ValueError(\\"Event name must be a non-empty string.\\") if not isinstance(limit, int) or limit <= 0: raise ValueError(\\"Limit must be a positive integer.\\") if not isinstance(time_window, (int, float)) or time_window <= 0: raise ValueError(\\"Time window must be a positive float.\\") current_time = time() timestamps = event_timestamps[event_name] # Remove timestamps that are outside the current time window while timestamps and timestamps[0] < current_time - time_window: timestamps.popleft() if len(timestamps) < limit: timestamps.append(current_time) return True else: raise RateLimitExceededException(f\\"The rate limit for event {event_name} has been exceeded.\\")"},{"question":"# Context Operations involving strings and patterns are common in programming challenges and interviews. One such fundamental operation is to implement a simple pattern matcher to identify if a pattern exists within a given text. # Problem Statement Implement a function `pattern_match(text: str, pattern: str) -> bool` that takes a string `text` and a string `pattern`, and returns `True` if the pattern exists in the text, otherwise returns `False`. You must implement this function without using Python\'s built-in string search functions (like `in`, `.find()`, `.index()`, etc.). Instead, you should use a basic substring search algorithm. # Requirements 1. **pattern_match(text: str, pattern: str) -> bool**: Returns `True` if the pattern is found in the text otherwise returns `False`. # Input and Output Formats * **Input**: * `text`: A string representing the text to be searched. * `pattern`: A string representing the pattern to search for in the text. * **Output**: * A boolean value. `True` if the pattern is found in the text; otherwise, `False`. # Constraints * The lengths of `text` and `pattern` can be up to 1000 characters. * The characters in `text` and `pattern` are limited to ASCII characters. * The comparison should be case-sensitive. # Performance Considerations * The time complexity should be considered when designing the pattern matching algorithm. * Optimize for cases where the pattern is significantly shorter than the text. # Example ```python assert pattern_match(\\"hello world\\", \\"world\\") == True assert pattern_match(\\"hello world\\", \\"WORLD\\") == False assert pattern_match(\\"abcdef\\", \\"def\\") == True assert pattern_match(\\"abcdef\\", \\"gh\\") == False assert pattern_match(\\"aaaaa\\", \\"aaa\\") == True assert pattern_match(\\"abcde\\", \\"abcde\\") == True assert pattern_match(\\"abc\\", \\"abcd\\") == False ``` # Edge Cases to Consider * Empty text or pattern. * Pattern longer than text. * Pattern with special characters. Implement the function: ```python def pattern_match(text: str, pattern: str) -> bool: # Get lengths of text and pattern n, m = len(text), len(pattern) # If pattern is empty, it trivially matches if m == 0: return True # If pattern is longer than the text, it cannot match if m > n: return False # Brute-force check each substring of text that matches the length of pattern for i in range(n - m + 1): if text[i:i + m] == pattern: return True return False ```","solution":"def pattern_match(text: str, pattern: str) -> bool: Returns True if the pattern exists in the text, otherwise returns False. Implements a basic substring search algorithm without using built-in search functions. # Get lengths of text and pattern n, m = len(text), len(pattern) # If pattern is empty, it trivially matches if m == 0: return True # If pattern is longer than the text, it cannot match if m > n: return False # Brute-force check each substring of text that matches the length of pattern for i in range(n - m + 1): if text[i:i + m] == pattern: return True return False"},{"question":"# Coding Question Context You are working on a data analytics project that involves handling readings from various sensors placed in an industrial setup. These readings are captured at precise intervals and often need to be filtered based on dynamic criteria defined by the system. One common requirement is to extract a continuous subset of readings that lie within a specified range and have the maximum possible number of readings. Task Write a function `max_sensor_readings_in_range(readings: List[float], low: float, high: float) -> List[float]` that takes a list of sensor readings and two floating-point numbers defining the inclusive lower and upper bounds of the acceptable range. Your function should determine and return the longest continuous subset of readings where all values lie within the specified range. # Function Signature ```python from typing import List def max_sensor_readings_in_range(readings: List[float], low: float, high: float) -> List[float]: pass ``` # Input - `readings`: A list of floats representing sensor readings. - `low`: A float defining the inclusive lower bound of the acceptable range. - `high`: A float defining the inclusive upper bound of the acceptable range. # Output - A list of floats representing the longest continuous subset of `readings` where each value is between `low` and `high` inclusive. # Constraints - 0 ≤ len(readings) ≤ 10000 - All readings are valid floating-point numbers. - `low` ≤ `high` # Examples ```python readings = [1.2, 3.5, 4.0, 4.5, 5.0, 2.2, 1.8, 3.4, 4.3, 3.9] low = 3.0 high = 4.5 output = max_sensor_readings_in_range(readings, low, high) print(output) # Output should be [3.5, 4.0, 4.5, 3.4, 4.3, 3.9] readings = [5.5, 2.1, 4.5, 3.2, 3.5, 4.1, 2.9, 1.5, 3.8, 4.2] low = 3.5 high = 4.2 output = max_sensor_readings_in_range(readings, low, high) print(output) # Output should be [3.5, 4.1] ``` Notes - If there are multiple subsets with the same maximum length, return any one of them. - Ensure your function handles edge cases where no readings fall within the range, returning an empty list in such scenarios.","solution":"from typing import List def max_sensor_readings_in_range(readings: List[float], low: float, high: float) -> List[float]: max_length = 0 max_start_index = 0 current_length = 0 current_start_index = 0 for i, reading in enumerate(readings): if low <= reading <= high: if current_length == 0: current_start_index = i current_length += 1 if current_length > max_length: max_length = current_length max_start_index = current_start_index else: current_length = 0 if max_length == 0: return [] else: return readings[max_start_index:max_start_index + max_length]"},{"question":"# Knapsack Problem - Memoization Implementation Objective Implement the solution for the 0/1 Knapsack problem using memoization. Problem Statement Given two lists representing weights and values of (N) items, and a maximum weight capacity (W), create a function that determines the maximum value that can be obtained by selecting items without exceeding the weight capacity. Use memoization to optimize your solution. Input and Output * **Input Format**: - An integer (N) denoting the number of items. - A list of (N) integers representing the weights of the items. - A list of (N) integers representing the values of the items. - An integer (W) representing the maximum weight capacity of the knapsack. * **Output Format**: - An integer representing the maximum value obtainable. Constraints 1. (1 leq N leq 100) 2. (1 leq text{weights}[i] leq 1000) 3. (1 leq text{values}[i] leq 1000) 4. (1 leq W leq 10000) Requirements * **Function**: 1. `knapsack(weights: list[int], values: list[int], W: int) -> int` Detailed Requirements * Utilize memoization to store intermediate results and avoid redundant calculations. * Ensure the implementation handles the constraints efficiently. * Consider using a helper function to implement the recursive step with memoization. Example ```python weights = [1, 3, 4, 5] values = [1, 4, 5, 7] W = 7 # Finding the maximum value max_value = knapsack(weights, values, W) print(max_value) # Should output 9 ```","solution":"def knapsack(weights, values, W): Returns the maximum value obtainable with given weights and values within weight limit W. n = len(weights) # Create a memoization table memo = [[None] * (W + 1) for _ in range(n + 1)] def knapsack_recursive(index, remaining_weight): if index == 0 or remaining_weight == 0: return 0 if memo[index][remaining_weight] is not None: return memo[index][remaining_weight] if weights[index - 1] > remaining_weight: result = knapsack_recursive(index - 1, remaining_weight) else: include = values[index - 1] + knapsack_recursive(index - 1, remaining_weight - weights[index - 1]) exclude = knapsack_recursive(index - 1, remaining_weight) result = max(include, exclude) memo[index][remaining_weight] = result return result return knapsack_recursive(n, W)"},{"question":"# Problem Statement You are required to write a function that takes an integer array as input and returns the maximum product of two numbers in the array. Ensure that the solution properly handles both positive and negative numbers to maximize the product. # Function Signature ```python def max_product(arr: List[int]) -> int: ``` # Input - A list of integers `arr`, where the length of `arr` is at least 2 and up to 10^4. - Each integer in the array can range from (-10^4) to (10^4). # Output - Return an integer representing the maximum product of two numbers in the array. # Constraints - (2 leq text{length of arr} leq 10^4) - (-10^4 leq text{arr[i]} leq 10^4) # Example 1. Example 1: - Input: `arr = [3, 4, 5, 2]` - Output: `20` - Explanation: The maximum product is (4 times 5 = 20). 2. Example 2: - Input: `arr = [-1, -3, -4, 2, 0, -5]` - Output: `20` - Explanation: The maximum product is ((-4) times (-5) = 20). 3. Example 3: - Input: `arr = [1, 2, 3, 4, 5]` - Output: `20` - Explanation: The maximum product is (4 times 5 = 20). # Additional Notes - Consider both the highest positive numbers and the lowest (most negative) numbers for the maximum product. - Ensure the function includes appropriate input validation and handling of invalid cases with descriptive error messages. # Testing Utilize provided test cases and edge cases to verify the correctness of your implementation. ```python def max_product(arr: List[int]) -> int: if len(arr) < 2: raise ValueError(\\"Invalid input: The array should have at least 2 integers.\\") max1, max2 = float(\'-inf\'), float(\'-inf\') min1, min2 = float(\'inf\'), float(\'inf\') for num in arr: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List def max_product(arr: List[int]) -> int: if len(arr) < 2: raise ValueError(\\"Invalid input: The array should have at least 2 integers.\\") max1, max2 = float(\'-inf\'), float(\'-inf\') min1, min2 = float(\'inf\'), float(\'inf\') for num in arr: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2)"},{"question":"# Sorting Large File of Numbers Context: You are working as a software engineer in a company that handles large datasets. One day, you receive a task to sort a large file containing a list of integers. The file is so large that it cannot fit into the memory all at once. To solve this problem efficiently, you need to implement an external merge sort algorithm that handles the file in chunks. Task: Write a function `external_merge_sort` that: 1. **Reads input**: - The file path to a text file containing integers. - An integer `chunk_size` which indicates how many numbers can be loaded into memory at once. 2. **Processes**: - Read, sort, and write individual chunks from the file. - Merge the sorted chunks to produce a fully sorted output file. 3. **Outputs**: - Creates a new file `\\"sorted_output.txt\\"` that contains all of the integers sorted in non-decreasing order. Input: * A string `file_path`, representing the path to the input text file. * An integer `chunk_size`, indicating how many numbers can be processed in memory at once. Output: * A new file `sorted_output.txt` containing all the integers from the input file, sorted in non-decreasing order. Constraints: * The input file size exceeds the available RAM. * Assume you have access to a temporary directory for intermediate storage. * `chunk_size` <= 100000 Example: ```python def external_merge_sort(file_path: str, chunk_size: int): pass # Example usage: external_merge_sort(\'large_numbers.txt\', 50000) # This should create a file named \'sorted_output.txt\' with all the integers sorted. ``` Performance Criteria: * Efficient use of I/O operations. * Minimal amount of passes through the file data. * Correct handling of very large datasets. * Clear and readable code.","solution":"import heapq import os def external_merge_sort(file_path: str, chunk_size: int): def read_numbers(file): Generator to read numbers from file chunk by chunk. while True: lines = file.readlines(chunk_size * len(str(2**31)) + chunk_size) if not lines: break for line in lines: yield int(line.strip()) def sort_and_save_chunk(numbers, index): Sorts a chunk of numbers and saves to a temporary file. numbers.sort() chunk_file = f\\"chunk_{index}.txt\\" with open(chunk_file, \'w\') as f: for num in numbers: f.write(f\\"{num}n\\") return chunk_file def merge_chunks(chunk_files, output_file): Merge sorted chunks into the final sorted file. open_files = [open(chunk, \'r\') for chunk in chunk_files] heap = [] for i, file in enumerate(open_files): num = int(file.readline().strip()) heapq.heappush(heap, (num, i)) with open(output_file, \'w\') as f: while heap: min_num, idx = heapq.heappop(heap) f.write(f\\"{min_num}n\\") next_line = open_files[idx].readline().strip() if next_line: heapq.heappush(heap, (int(next_line), idx)) for file in open_files: file.close() # Step 1: Read chunks of the file, sort and save them chunk_files = [] with open(file_path, \'r\') as f: numbers = [] for number in read_numbers(f): numbers.append(number) if len(numbers) >= chunk_size: chunk_file = sort_and_save_chunk(numbers, len(chunk_files)) chunk_files.append(chunk_file) numbers = [] if numbers: chunk_file = sort_and_save_chunk(numbers, len(chunk_files)) chunk_files.append(chunk_file) # Step 2: Merge all sorted chunks into the final output file merge_chunks(chunk_files, \\"sorted_output.txt\\") # Clean up temporary chunk files for chunk_file in chunk_files: os.remove(chunk_file)"},{"question":"# Coding Question: Longest Increasing Subsequence Scenario You are developing a feature for a personal productivity tool that analyzes sequences of task completion times. One of the metrics of interest is the longest sequence of tasks completed in increasing order of time taken. Problem Write a function to determine the length of the longest increasing subsequence from a list of task completion times. Function Signature ```python def longest_increasing_subsequence(arr: list) -> int: ``` Input * `arr`: A list of integers representing task completion times. (1 ≤ len(arr) ≤ 10^5, 1 ≤ arr[i] ≤ 10^6) Output * An integer representing the length of the longest subsequence where each element is greater than the previous one. Constraints * The input list will contain at least one element and at most 100,000 elements. Performance Requirements * Your solution should have a time complexity of O(n log n). Example ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6 ``` Note: * The function `longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])` returns 4 because the longest increasing subsequence is [2, 3, 7, 101]. * For `longest_increasing_subsequence([0, 1, 0, 3, 2, 3])`, the sequences [0, 1, 2, 3] or [0, 1, 2, 3] each give a length of 4. * When all elements are the same, the length of the longest increasing subsequence is 1. * For `longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6])`, the result is the subsequence [1, 3, 6, 7, 9, 10], which gives a length of 6. Implement the function `longest_increasing_subsequence`.","solution":"from bisect import bisect_left def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the list arr. if not arr: return 0 # Initialize an array to store the smallest ending value of the LIS of different lengths dp = [] for num in arr: # Find the position to place num in the dp array pos = bisect_left(dp, num) # If pos is equal to the length of dp, it means num is greater than any element in dp, we can extend dp if pos == len(dp): dp.append(num) else: # Otherwise, we update the existing position to maintain the lowest possible value for future comparisons dp[pos] = num # The length of dp array will be the length of longest increasing subsequence return len(dp)"},{"question":"# Question Problem Statement Write a function `find_kth_permutation(n, k)` that generates the kth permutation sequence of the numbers `1` to `n` (1-indexed). The permutations should be listed in lexicographic order. # Function Signature ```python def find_kth_permutation(n: int, k: int) -> str: pass ``` # Input - `n` (1 ≤ n ≤ 9): An integer representing the range of numbers from `1` to `n`. - `k` (1 ≤ k ≤ n!): An integer representing the kth permutation sequence. # Output - Return a string representing the kth permutation sequence of numbers `1` to `n`. # Examples Example 1 ```python n = 3 k = 3 result = find_kth_permutation(n, k) print(result) # Output: \\"213\\" ``` Example 2 ```python n = 4 k = 9 result = find_kth_permutation(n, k) print(result) # Output: \\"2314\\" ``` # Explanation - For `n = 3` and `k = 3`, all permutations in lexicographic order are: [\\"123\\", \\"132\\", \\"213\\", \\"231\\", \\"312\\", \\"321\\"], hence the 3rd permutation is \\"213\\". - For `n = 4` and `k = 9`, all permutations in lexicographic order are: [\\"1234\\", \\"1243\\", \\"1324\\", \\"1342\\", \\"1423\\", \\"1432\\", \\"2134\\", \\"2143\\", \\"2314\\", \\"2341\\", ..., \\"4321\\"], hence the 9th permutation is \\"2314\\". # Notes - Consider factorial number system or other combinatorial logic to generate the permutation directly without generating all permutations. - Ensure the function handles edge cases where `k` is 1 or `n!`. --- Compose the function to efficiently determine the `k`th permutation sequence leveraging combinatorial mathematics rather than generating all permutations directly to ensure performance for higher values of `n`.","solution":"def find_kth_permutation(n: int, k: int) -> str: Returns the kth permutation sequence of numbers from 1 to n. from math import factorial numbers = list(range(1, n+1)) k -= 1 # Convert k to a 0-indexed value permutation = [] for i in range(n, 0, -1): fact = factorial(i-1) index = k // fact permutation.append(str(numbers[index])) numbers.pop(index) k %= fact return \'\'.join(permutation)"},{"question":"# Scenario: You need to develop a solution to efficiently track the top K elements in a dynamic dataset, where elements are being added over time. The dataset might get exceptionally large, and you need to ensure that your solution remains performant. # Task: Write a class `TopKElements` that provides the following methods: 1. `add_element(value)`: Adds a new element to the dataset. 2. `get_top_k()`: Returns a list of the top K elements from the dataset in descending order. # Input Formats: - The `add_element` method takes an integer `value`: -10^6 <= value <= 10^6. - The `get_top_k` method takes no arguments and returns a list of integers. # Constraints: - Ensure the performance is optimized, considering large datasets. - Focus on both time and space efficiency during implementation. - K will be provided during the instantiation of the `TopKElements` class and is guaranteed to be a positive integer. # Example: ```python # Example Usage k_elements = TopKElements(3) k_elements.add_element(4) k_elements.add_element(1) k_elements.add_element(6) k_elements.add_element(3) k_elements.add_element(2) k_elements.add_element(10) # Expected Output print(k_elements.get_top_k()) # Output: [10, 6, 4] ``` # Implementation: Implement the `TopKElements` class using a min-heap to efficiently track the top K elements. ```python import heapq class TopKElements: def __init__(self, k: int): self.k = k self.min_heap = [] def add_element(self, value: int): if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, value) else: heapq.heappushpop(self.min_heap, value) def get_top_k(self) -> list[int]: return sorted(self.min_heap, reverse=True) # Example usage k_elements = TopKElements(3) k_elements.add_element(4) k_elements.add_element(1) k_elements.add_element(6) k_elements.add_element(3) k_elements.add_element(2) k_elements.add_element(10) print(k_elements.get_top_k()) # Output: [10, 6, 4] ```","solution":"import heapq class TopKElements: def __init__(self, k: int): self.k = k self.min_heap = [] def add_element(self, value: int): if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, value) else: heapq.heappushpop(self.min_heap, value) def get_top_k(self) -> list: return sorted(self.min_heap, reverse=True) # Example usage k_elements = TopKElements(3) k_elements.add_element(4) k_elements.add_element(1) k_elements.add_element(6) k_elements.add_element(3) k_elements.add_element(2) k_elements.add_element(10) print(k_elements.get_top_k()) # Output: [10, 6, 4]"},{"question":"# Problem Statement You are given a list of strings, where each string represents a mathematical expression that may include various operators and parentheses. Your task is to write a function `evaluate_expressions(expressions: List[str]) -> List[float]` that takes this list of expressions and returns the result for each expression, evaluated in the order they appear in the input list. # Function Signature ```python def evaluate_expressions(expressions: List[str]) -> List[float]: pass ``` # Input - `expressions`: A list of strings, where each string contains a valid mathematical expression. Each expression may include the operators `+`, `-`, `*`, `/`, and parentheses `()`. - The length of `expressions` list will be between 1 and 100 (inclusive). # Output - A list of floating-point numbers, where each number is the result of evaluating the corresponding expression from the input list. # Constraints - Each expression will contain at least one operator and one numerical value. - Each expression will be a valid Python expression consisting of numbers, operators, and parentheses. - You may assume the input strings will not result in division by zero. # Example ```python assert evaluate_expressions([ \\"2 + 3 * 4\\", \\"(1 + 2) * (3 + 4)\\", \\"10 / 2 + 5 * 3\\", \\"3 + 4 * (2 - 1)\\" ]) == [14.0, 21.0, 20.0, 7.0] assert evaluate_expressions([ \\"100 - (2 * 5)\\", \\"(10 + 2) / 2\\", \\"50 + 50 - 10\\", \\"(3 + 5) * 2 / 4\\" ]) == [90.0, 6.0, 90.0, 4.0] ``` # Additional Information - You are expected to use Python’s built-in capabilities for expression evaluation. - Ensure your solution correctly handles operator precedence and parentheses. - The performance of the solution must be efficient enough to handle up to 100 expressions. **Note**: Do not modify the function signature, and ensure your solution passes the provided test cases.","solution":"from typing import List def evaluate_expressions(expressions: List[str]) -> List[float]: results = [] for expr in expressions: result = eval(expr) results.append(float(result)) return results"},{"question":"# Problem Statement You are tasked with implementing a small library that allows for basic arithmetic expression evaluation and variable assignments. Create a class `SimpleCalculator` that provides methods to evaluate arithmetic expressions and manage variable assignments. Task 1: `assign(variable: str, value: float) -> None` - **Input**: - `variable`: A string representing the variable name to assign a value to. - `value`: A float representing the value to be assigned to the variable. - **Output**: - This method should store the variable and its value in the instance. Task 2: `evaluate(expression: str) -> float` - **Input**: - `expression`: A string containing a valid arithmetic expression to be evaluated. The expression may contain numbers, variables, and the operators `+`, `-`, `*`, and `/`. - **Output**: - Returns the evaluated result of the arithmetic expression as a float. Requirements and Constraints 1. **Assumptions**: - Variable names are case-sensitive and consist of alphabetic characters (a-z, A-Z). - Arithmetic expressions are well-formed and do not require error handling for malformed expressions. - Only valid arithmetic operations (`+`, `-`, `*`, and `/`) are present in the expression. - Assigned values and arithmetic results are within the range of floating-point numbers. 2. **Constraints**: - Variable names do not exceed 20 characters. - Expression length will not exceed 100 characters. Implementation Details - The library should maintain an internal state of variable assignments. - Handle edge cases such as undefined variables used in expressions. - Optimize for quick lookups and evaluations. # Example ```python class SimpleCalculator: def __init__(self): # initialization code here def assign(self, variable: str, value: float) -> None: # implementation here def evaluate(self, expression: str) -> float: # implementation here # Example usage: calc = SimpleCalculator() calc.assign(\\"a\\", 5) calc.assign(\\"b\\", 10) result1 = calc.evaluate(\\"a + b\\") # Expected output: 15.0 result2 = calc.evaluate(\\"a * b + 3 - 2 / b\\") # Expected output: 52.8 result3 = calc.evaluate(\\"b / 2\\") # Expected output: 5.0 ``` Notes: - Ensure your implementation handles the storing and retrieving of variable values correctly. - Include test cases to demonstrate the functionality and correctness of your library.","solution":"class SimpleCalculator: def __init__(self): self.variables = {} def assign(self, variable: str, value: float) -> None: self.variables[variable] = value def evaluate(self, expression: str) -> float: for variable in self.variables: if variable in expression: expression = expression.replace(variable, str(self.variables[variable])) return eval(expression)"},{"question":"# Problem Statement Write a function `merge_and_filter_strings(list1: List[str], list2: List[str], banned_words: List[str]) -> List[str]` that merges two lists of strings, removes any strings that contain any of the banned words, and returns the cleaned and merged list of strings. # Expected Behavior The function should: 1. Merge `list1` and `list2` into a single list. 2. Remove any string from the merged list that contains at least one word present in `banned_words`. 3. Return the cleaned and merged list of strings in the same order as they appear in the input lists. # Input and Output **Input**: - `list1`: A list of non-empty strings. - `list2`: A list of non-empty strings. - `banned_words`: A list of non-empty strings representing banned words. **Output**: - A list of strings that have been filtered based on the banned words. # Constraints - All list elements are valid, non-empty strings. - Words in strings are separated by spaces. - Function should preserve the order of the strings as they appear in `list1` and `list2`. # Example ```python from typing import List def merge_and_filter_strings(list1: List[str], list2: List[str], banned_words: List[str]) -> List[str]: # Write your implementation here # Example Usage list1 = [ \\"hello world\\", \\"this is a test\\", \\"goodbye\\" ] list2 = [ \\"another test\\", \\"filter me out\\", \\"keep this one\\" ] banned_words = [\\"test\\", \\"filter\\"] result = merge_and_filter_strings(list1, list2, banned_words) # Expected Output: # [\\"hello world\\", \\"goodbye\\", \\"keep this one\\"] ``` Implement the function according to the specified behavior and constraints.","solution":"from typing import List def merge_and_filter_strings(list1: List[str], list2: List[str], banned_words: List[str]) -> List[str]: Merges two lists of strings and removes any strings containing banned words. Args: list1 (List[str]): First list of strings. list2 (List[str]): Second list of strings. banned_words (List[str]): List of banned words. Returns: List[str]: The merged and filtered list of strings. banned_set = set(banned_words) def contains_banned_word(s: str) -> bool: for word in s.split(): if word in banned_set: return True return False merged_list = list1 + list2 filtered_list = [s for s in merged_list if not contains_banned_word(s)] return filtered_list"},{"question":"# Context: You are managing a popular food delivery platform where drivers travel between users\' locations to deliver orders. For an upcoming promotion, you have to analyze and optimize the delivery paths. Specifically, you need to efficiently determine the shortest path between any two given locations in the city, where the city is represented as a graph. # Task: Your task is to complete the `ShortestPath` class with the necessary functions to utilize Dijkstra’s algorithm for finding the shortest path between two nodes in a graph. Below is the given `ShortestPath` class outline: ```python import heapq class ShortestPath: def __init__(self, n: int) -> None: self.n = n self.graph = {i: [] for i in range(n)} def add_edge(self, u: int, v: int, w: int) -> None: # Implementation details to add edges into the graph def dijkstra(self, start: int, end: int) -> int: # To be implemented by students ``` # Requirements: - Implement the `add_edge` function to add a directed edge of weight `w` between nodes `u` and `v`. - Implement the `dijkstra` function to find and return the length of the shortest path from node `start` to node `end` using Dijkstra’s algorithm. # Constraints: - 1 ≤ n ≤ 10^5 (number of nodes) - 1 ≤ edges ≤ 2 * 10^5 (number of edges) - 1 ≤ u, v < n - w ≥ 1 (weight of each edge) - The graph may have multiple edges between the same nodes but no self-loops. # Examples: ```python # Initializing the shortest path object for a graph with 5 nodes. sp = ShortestPath(5) # Adding edges with respective weights. sp.add_edge(0, 1, 2) sp.add_edge(0, 2, 4) sp.add_edge(1, 2, 1) sp.add_edge(1, 3, 7) sp.add_edge(2, 3, 3) sp.add_edge(3, 4, 1) # Calculating shortest path from node 0 to node 4. print(sp.dijkstra(0, 4)) # Should output 8 # Calculating shortest path from node 1 to node 4. print(sp.dijkstra(1, 4)) # Should output 4 ``` # Additional Notes: - The graph is represented as an adjacency list. - If there is no path between `start` and `end`, return infinity (`float(\'inf\')`) or an appropriate sentinel value. Ensure your solution efficiently handles the graph\'s size and density to fit within competitive programming limits.","solution":"import heapq class ShortestPath: def __init__(self, n: int) -> None: self.n = n self.graph = {i: [] for i in range(n)} def add_edge(self, u: int, v: int, w: int) -> None: Adds a directed edge from node u to node v with weight w to the graph. self.graph[u].append((v, w)) def dijkstra(self, start: int, end: int) -> int: Finds the shortest path from node start to node end using Dijkstra\'s algorithm. Returns the length of the shortest path, or float(\'inf\') if no path exists. distances = {i: float(\'inf\') for i in range(self.n)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_vertex == end: return current_distance if current_distance > distances[current_vertex]: continue for neighbor, weight in self.graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float(\'inf\') else -1"},{"question":"# Question: Implement an Optimized Pancake Sort The goal is to improve the efficiency of the Pancake Sort algorithm. Your task is to combine the basic idea of Pancake Sort with some optimization techniques to reduce the number of flips performed and improve performance. Requirements: * Implement a hybrid sorting algorithm using Pancake Sort principles but with optimizations such as tracking partially sorted segments. * Ensure the algorithm maintains a good average time complexity comparable to O(n log n). # Function Signature: ```python def hybrid_pancake_sort(arr: list) -> list: Sorts a list of integers or other comparable elements using a hybrid Pancake Sort method. :param arr: A list of integers or comparable elements. :return: A sorted list of integers or comparable elements. ``` # Input: * A list of integers or other comparable elements. # Output: * A sorted list of integers or other comparable elements in ascending order. # Constraints: * You can assume the collection size is up to 10^5 elements. * Ensure the algorithm aims for O(n log n) average time complexity by introducing suitable optimizations. # Example: ```python >>> hybrid_pancake_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> hybrid_pancake_sort([-2, 5, 0, -45]) [-45, -2, 0, 5] >>> hybrid_pancake_sort([10]) [10] ``` # Instructions: 1. Implement a helper function `pancake_flip` that reverses the order of the first `k` elements in the list. 2. Implement an auxiliary function `find_max_index` that returns the index of the maximum element in the unsorted part of the list. 3. Optimize the Pancake Sort by tracking already sorted sections and adjusting the number of flips accordingly. 4. Combine these elements in the `hybrid_pancake_sort` function to achieve an optimized sort.","solution":"def pancake_flip(arr, k): Perform a flip on the first k elements of the array. :param arr: List of elements to flip. :param k: The number of elements to flip. arr[:k] = arr[:k][::-1] def find_max_index(arr, end): Find the index of the maximum element in the array up to the given end index. :param arr: List of elements to search. :param end: The end index up to which to search. :return: The index of the maximum element. max_index = 0 for i in range(1, end + 1): if arr[i] > arr[max_index]: max_index = i return max_index def hybrid_pancake_sort(arr): Sorts a list of integers or other comparable elements using a hybrid Pancake Sort method. :param arr: A list of integers or comparable elements. :return: A sorted list of integers or comparable elements. n = len(arr) for current_size in range(n, 1, -1): max_index = find_max_index(arr, current_size - 1) if max_index != current_size - 1: # Flip the max number to the front if it\'s not already there. if max_index != 0: pancake_flip(arr, max_index + 1) # Then flip it to its correct position pancake_flip(arr, current_size) return arr"},{"question":"# Scenario As part of a data processing pipeline, you need to create a function that can efficiently compute the running average of a stream of numerical data. This is crucial for smoothing noisy signals or monitoring values in real-time applications. # Task Implement a function that calculates the running average over a specified window size for a given list of numbers. Your solution should handle potential edge cases, such as varying window sizes and arrays of arbitrary length, and aim for optimal performance. # Specifications * Write a function `running_average` which takes two parameters: - `data` (list): A list of real numbers representing the incoming data stream. - `window_size` (int): The size of the moving window over which to compute the average. * Output should be a list where each element is the average of the current window of values. # Formula For a given window size `k`, the running average at position `i` in the list `data` is defined as: [ text{running_avg}_i = frac{1}{k} sum_{j=i-(k-1)}^{i} text{data}_j ] # Assumptions - The list `data` can have arbitrary length. - `window_size` will always be a positive integer. - If at any position there are fewer than `window_size` elements available (i.e., at the beginning of the list), compute the average using only the available elements. # Examples ```python >>> running_average([1, 2, 3, 4, 5], window_size=3) [1.0, 1.5, 2.0, 3.0, 4.0] >>> running_average([10, 20, 30, 40, 50], window_size=2) [10.0, 15.0, 25.0, 35.0, 45.0] >>> running_average([4, 5, 6, 7, 8], window_size=1) [4.0, 5.0, 6.0, 7.0, 8.0] ```","solution":"def running_average(data, window_size): Calculate the running average over a specified window size for a given list of numbers. Parameters: data (list): A list of real numbers representing the incoming data stream. window_size (int): The size of the moving window over which to compute the average. Returns: list: A list where each element is the average of the current window of values. if not data or window_size <= 0: return [] result = [] running_sum = 0.0 for i in range(len(data)): running_sum += data[i] if i >= window_size: running_sum -= data[i - window_size] if i >= window_size - 1: result.append(running_sum / window_size) else: result.append(running_sum / (i + 1)) return result"},{"question":"# Data Structure for Grouped Anagrams You are required to implement a class called `GroupedAnagrams`, which manages a collection of anagrams. An anagram is a word or phrase formed by rearranging the letters of another word or phrase, typically using all original letters exactly once. The `GroupedAnagrams` class will support adding words and retrieving grouped anagrams. Class Definition Implement the `GroupedAnagrams` class with the following methods: - `add_word(word: str)`: Adds a word to the collection. - `get_anagrams() -> List[List[str]]`: Returns a list of lists, where each sublist contains words that are anagrams of each other. - `__str__() -> str`: Returns a string representation of the grouped anagrams in a readable format. Requirements: 1. Each group of anagrams should be reported in any order. 2. If a word does not have any anagram in the collection, it should be reported as a single-element list. 3. The class should efficiently manage the addition of words and retrieval of anagram groups. 4. The operations should have optimal time complexity for inserting and retrieving anagrams. Example: ```python class GroupedAnagrams: def __init__(self): # Initialize your internal structures here pass def add_word(self, word: str) -> None: # Add your code here pass def get_anagrams(self) -> List[List[str]]: # Add your code here pass def __str__(self) -> str: # Add your code here pass # Example usage: # ga = GroupedAnagrams() # ga.add_word(\\"listen\\") # ga.add_word(\\"silent\\") # ga.add_word(\\"enlist\\") # ga.add_word(\\"hello\\") # ga.add_word(\\"world\\") # print(ga) # assert ga.get_anagrams() == [[\'listen\', \'silent\', \'enlist\'], [\'hello\'], [\'world\']] ``` The class definition includes part of the structure. Implement the methods to satisfy the described functionality and ensure performance against the criteria mentioned.","solution":"from typing import List, Dict from collections import defaultdict class GroupedAnagrams: def __init__(self): self.word_map = defaultdict(list) def add_word(self, word: str) -> None: # Sort the word and use it as the key sorted_word = \'\'.join(sorted(word)) self.word_map[sorted_word].append(word) def get_anagrams(self) -> List[List[str]]: return list(self.word_map.values()) def __str__(self) -> str: grouped_anagrams = self.get_anagrams() return \'n\'.join([\'[\' + \', \'.join(words) + \']\' for words in grouped_anagrams])"},{"question":"# Coding Assessment Question: Weather Data Analyzer Context: You are provided with a dataset containing daily weather information for a specific location. Each entry in the dataset consists of the date, temperature (in Celsius), humidity (in percentage), and precipitation (in millimeters). Your task is to implement a function that analyzes this data to generate a summary report, which includes the highest and lowest temperatures, the average humidity, and the total precipitation for a given month. Task: Implement the `generate_weather_report` function that generates a summary weather report for a specified month and year. Function Signature: ```python def generate_weather_report(data: list[tuple[str, float, float, float]], month: int, year: int) -> dict: pass ``` Input: - `data` (list[tuple[str, float, float, float]]): A list of tuples where each tuple represents weather data for a day in the format `(date: str, temperature: float, humidity: float, precipitation: float)`. - `date`: Date in the format \'YYYY-MM-DD\'. - `temperature`: The temperature in Celsius. - `humidity`: The humidity percentage. - `precipitation`: The precipitation in millimeters. - `month` (int): The month for which the report is to be generated (1 for January, 2 for February, ..., 12 for December). - `year` (int): The year for which the report is to be generated. Output: - A dictionary containing the summary report for the specified month, with the keys: - `highest_temp` (float): The highest temperature recorded in the month. - `lowest_temp` (float): The lowest temperature recorded in the month. - `average_humidity` (float): The average humidity for the month. - `total_precipitation` (float): The total precipitation for the month. Constraints: - The function should handle cases where there is no data for the specified month (return a report with `None` or 0 values). - Assume valid date formats and ranges but handle empty or missing data gracefully. - The temperature, humidity, and precipitation values will be realistic and within normal ranges. Example: ```python data = [ (\\"2023-01-01\\", 5.0, 80.0, 10.0), (\\"2023-01-02\\", 7.0, 75.0, 5.0), (\\"2023-02-01\\", 10.0, 90.0, 0.0), (\\"2023-02-02\\", 12.0, 85.0, 0.0), (\\"2023-01-15\\", -2.0, 60.0, 20.0), (\\"2023-01-20\\", 3.0, 70.0, 15.0) ] month = 1 year = 2023 report = generate_weather_report(data, month, year) # Expected output: # { # \\"highest_temp\\": 7.0, # \\"lowest_temp\\": -2.0, # \\"average_humidity\\": 71.25, # \\"total_precipitation\\": 50.0 # } ``` **Note**: The function should iterate over the dataset, filter the entries for the specified month and year, and compute the required statistics accurately.","solution":"def generate_weather_report(data, month, year): Generates a summary weather report for a specified month and year. Args: data (list[tuple[str, float, float, float]]): A list of tuples representing daily weather data. month (int): The month for which the report is generated (1 for January, ..., 12 for December). year (int): The year for which the report is generated. Returns: dict: A dictionary containing the summary weather report. filtered_data = [entry for entry in data if int(entry[0][5:7]) == month and int(entry[0][:4]) == year] if not filtered_data: return { \\"highest_temp\\": None, \\"lowest_temp\\": None, \\"average_humidity\\": None, \\"total_precipitation\\": 0.0 } highest_temp = max(entry[1] for entry in filtered_data) lowest_temp = min(entry[1] for entry in filtered_data) average_humidity = sum(entry[2] for entry in filtered_data) / len(filtered_data) total_precipitation = sum(entry[3] for entry in filtered_data) return { \\"highest_temp\\": highest_temp, \\"lowest_temp\\": lowest_temp, \\"average_humidity\\": average_humidity, \\"total_precipitation\\": total_precipitation }"},{"question":"**Question: Custom HashMap Implementation** **Context:** Bob frequently works with hash tables in his software projects and wants to implement his custom `HashMap` to better understand the underlying mechanics. He aims to create a basic version of a hash map with fundamental functionalities like adding, retrieving, and removing key-value pairs. **Task:** Your task is to implement a custom `HashMap` class with the following specifications: 1. Implement methods for adding (`put`), retrieving (`get`), and removing (`remove`) key-value pairs. 2. Ensure that the `HashMap` handles collisions using separate chaining (linked lists). 3. Implement a method to check the current size of the `HashMap`. **Class Definition:** ```python class HashMap: def __init__(self, initial_capacity=100): pass def put(self, key, value): pass def get(self, key): pass def remove(self, key): pass def size(self): pass ``` **Methods:** - `__init__(self, initial_capacity=100)`: Initialize the `HashMap` with a given capacity (default 100). - `put(self, key, value)`: Add or update the given key-value pair. - `get(self, key)`: Retrieve the value associated with the given key. Return `None` if the key does not exist. - `remove(self, key)`: Remove the key-value pair associated with the given key. Return the value if the key exists, otherwise return `None`. - `size(self)`: Return the current number of key-value pairs in the `HashMap`. **Constraints:** - `key` can be of any hashable type (e.g., int, string, tuple). - `value` can be any data type. - The average time complexity should be (O(1)) for all operations. **Examples:** 1. ```python map = HashMap() map.put(\\"apple\\", 1) map.put(\\"banana\\", 2) assert map.get(\\"apple\\") == 1 assert map.get(\\"banana\\") == 2 assert map.size() == 2 ``` 2. ```python map = HashMap() map.put(\\"apple\\", 1) map.put(\\"apple\\", 10) assert map.get(\\"apple\\") == 10 assert map.size() == 1 assert map.remove(\\"banana\\") == None assert map.remove(\\"apple\\") == 10 assert map.get(\\"apple\\") == None ``` **Additional Notes:** 1. Use a simple hash function for demonstration purposes. 2. Ensure that the `HashMap` properly handles key collisions using a linked list implementation. 3. Provide thorough error checking for operations that might access non-existent keys.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class HashMap: def __init__(self, initial_capacity=100): self.capacity = initial_capacity self.size_ = 0 self.buckets = [None] * initial_capacity def _hash(self, key): Simple hash function to compute the index for a given key return hash(key) % self.capacity def put(self, key, value): index = self._hash(key) if self.buckets[index] is None: self.buckets[index] = Node(key, value) self.size_ += 1 return current = self.buckets[index] while True: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) self.size_ += 1 def get(self, key): index = self._hash(key) current = self.buckets[index] while current is not None: if current.key == key: return current.value current = current.next return None def remove(self, key): index = self._hash(key) current = self.buckets[index] prev = None while current is not None: if current.key == key: if prev is None: self.buckets[index] = current.next else: prev.next = current.next self.size_ -= 1 return current.value prev = current current = current.next return None def size(self): return self.size_"},{"question":"# Context Binary Search Tree (BST) is a popular data structure used to efficiently manage sorted data. Understanding the properties and traversal methods of BSTs is crucial for various computational problems. Consider a problem where we need to find and return elements within a specified range in a Binary Search Tree. # Question Write a function `range_bst` that takes a root of a binary search tree and two integers representing a range (inclusive) and returns a list of values filtered within that range. Your implementation should leverage the properties of BST for efficiency. # Function Signature ```python def range_bst(root: Optional[TreeNode], low: int, high: int) -> List[int]: Returns all elements in the BST within the given range (inclusive). :param root: The root node of the binary search tree. :param low: The lower bound of the range. :param high: The upper bound of the range. :return: A list of integers within the specified range. ``` # Input * `root`: Root node of a binary search tree. * `low`: Integer representing the lower bound of the range. * `high`: Integer representing the upper bound of the range. # Output * List of integers within the specified range, sorted in ascending order. # Constraints * The binary search tree will contain unique values. * The tree can be empty (i.e., `root` can be `None`). * Time complexity should be optimized by leveraging BST properties. # Examples ```python from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right # Example 1 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(12) root.right.right = TreeNode(18) assert range_bst(root, 5, 15) == [5, 7, 10, 12, 15] # Example 2 assert range_bst(root, 3, 18) == [3, 5, 7, 10, 12, 15, 18] # Example 3 assert range_bst(root, 6, 13) == [7, 10, 12] # Example 4 assert range_bst(None, 1, 10) == [] # Example 5 single_node = TreeNode(5) assert range_bst(single_node, 1, 10) == [5] assert range_bst(single_node, 6, 10) == [] ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def range_bst(root: Optional[TreeNode], low: int, high: int) -> List[int]: Returns all elements in the BST within the given range (inclusive). :param root: The root node of the binary search tree. :param low: The lower bound of the range. :param high: The upper bound of the range. :return: A list of integers within the specified range. result = [] def helper(node): if not node: return if low <= node.val <= high: helper(node.left) result.append(node.val) helper(node.right) elif node.val < low: helper(node.right) else: helper(node.left) helper(root) return result"},{"question":"# Question You are required to implement a specific function related to the binary search tree (BST) data structure described below. Problem Statement Given the root of a binary search tree (BST) and an integer `k`, implement a function `find_kth_smallest` that returns the kth smallest element in the BST. A binary search tree ensures that left sub-tree elements are less than the root and right sub-tree elements are greater. Function Signature ```python def find_kth_smallest(root: TreeNode | None, k: int) -> int: ``` Input - `root` (TreeNode | None): The root node of the BST. It can be `None` if the tree is empty. - `k` (int): The k-th position to find the smallest element in the BST. Output - `int`: The k-th smallest element in the BST. If the tree is empty or `k` is out of boundary, return -1. Constraints 1. The number of nodes in the tree is in the range [0, 10^4]. 2. Each node\'s value is in the range [-10^4, 10^4]. 3. 1 ≤ k ≤ Number of nodes in the BST. Example ```python # Tree structure: # 5 # / # 3 6 # / # 2 4 # / #1 tree = TreeNode(5) tree.left = TreeNode(3) tree.right = TreeNode(6) tree.left.left = TreeNode(2) tree.left.right = TreeNode(4) tree.left.left.left = TreeNode(1) print(find_kth_smallest(tree, 3)) # Output: 3 ``` Requirements - Implement the `find_kth_smallest` function ensuring it operates effectively within the given constraints. - Consider edge cases such as an empty tree, a single-node tree, and cases where `k` might be out of valid range. - The function should efficiently handle the upper limit of the constraints. Ensure that the solution accounts for BST properties to achieve optimal performance.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_smallest(root: TreeNode | None, k: int) -> int: Returns the k-th smallest element in the BST. if not root: return -1 def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) sorted_elements = in_order_traversal(root) if 1 <= k <= len(sorted_elements): return sorted_elements[k-1] return -1"},{"question":"# Task Overview: You are given a compressed string that uses run-length encoding (RLE) for compression. Your task is to decompress the string back to its original format. # Function Signature: ```python def decompress_string(encoded: str) -> str: Decompress the given RLE encoded string. Parameters: encoded (str): A run-length encoded string. Returns: str: The decompressed original string. ``` # Input: - `encoded`: A string representing the run-length encoded data. The format uses numbers to denote the count of characters, followed by the character itself. # Output: - A string that represents the decompressed version of the input. # Constraints: - The encoded string will consist of alternating segments of digits and letters. - The digits will always be greater than 0. # Examples: ```python >>> decompress_string(\\"4a1b3c\\") \\"aaaabccc\\" >>> decompress_string(\\"2p3q2r1s\\") \\"ppqqqrrs\\" >>> decompress_string(\\"1a5b\\") \\"abbbbb\\" >>> decompress_string(\\"10z2x\\") \\"zzzzzzzzzzxx\\" ``` # Explanation: 1. **First Example:** The encoded string \\"4a1b3c\\" translates to: four \'a\'s, one \'b\', and three \'c\'s. The decompressed string is \\"aaaabccc\\". 2. **Second Example:** The encoded string \\"2p3q2r1s\\" translates to: two \'p\'s, three \'q\'s, two \'r\'s, and one \'s\'. The decompressed string is \\"ppqqqrrs\\". 3. **Third Example:** The encoded string \\"1a5b\\" translates to: one \'a\' and five \'b\'s. The decompressed string is \\"abbbbb\\". 4. **Fourth Example:** The encoded string \\"10z2x\\" translates to: ten \'z\'s and two \'x\'s. The decompressed string is \\"zzzzzzzzzzxx\\". # Additional Notes: You must ensure that the decompression correctly handles multiple digit numbers and preserves the order of characters as specified by the encoded string.","solution":"def decompress_string(encoded: str) -> str: Decompress the given RLE encoded string. Parameters: encoded (str): A run-length encoded string. Returns: str: The decompressed original string. decompressed = [] count = \'\' for char in encoded: if char.isdigit(): count += char else: decompressed.append(char * int(count)) count = \'\' return \'\'.join(decompressed)"},{"question":"# Problem Statement **Context**: You are developing a scheduling application that needs to handle various tasks within a predefined set of time slots. The application must ensure that tasks do not overlap and are efficiently scheduled to maximize usage of the available time slots. One key challenge is to determine if a new task can be inserted into the current schedule without conflicts. **Task**: Given a list of existing tasks with their start and end times, and a new task with its start and end time, implement a function `can_schedule` to check if the new task can be successfully added to the schedule without overlapping any existing tasks. Each task is represented by a tuple of integers `(start, end)`, where `start` is the start time and `end` is the end time. # Function Signature: ```python def can_schedule(existing_tasks: List[Tuple[int, int]], new_task: Tuple[int, int]) -> bool: Check if the new task can be scheduled without overlapping any existing tasks. Parameters: - existing_tasks (List[Tuple[int, int]]): A list of tuples representing the start and end times of the existing tasks. - new_task (Tuple[int, int]): A tuple representing the start and end times of the new task. Returns: - bool: True if the new task can be scheduled without conflicts, False otherwise. ``` # Input: - `existing_tasks`: A list of tuples where each tuple (start, end) represents the start and end times of a task (0 <= start < end <= 24). - `new_task`: A tuple (start, end) representing the start and end time of the new task (0 <= start < end <= 24). # Output: - A boolean value indicating whether the new task can be scheduled without conflicts (`True` means no conflict, `False` means there is a conflict). # Constraints: - There will be no more than 100 existing tasks. - All time values are integers in the 24-hour format (from 0 to 24). - The task times are strictly non-overlapping and within a valid range. # Example: ```python existing_tasks = [(1, 3), (5, 8), (12, 14)] new_task = (3, 5) can_be_scheduled = can_schedule(existing_tasks, new_task) # Expected output: True ``` # Explanation: In the given example: - The existing tasks occupy the following time slots: [1-3], [5-8], [12-14]. - The new task is scheduled from 3 to 5, which does not overlap with any existing tasks. Therefore, the new task can be scheduled, and the function should return `True`.","solution":"def can_schedule(existing_tasks, new_task): Check if the new task can be scheduled without overlapping any existing tasks. Parameters: - existing_tasks (list of tuple of int): A list of tuples representing the start and end times of the existing tasks. - new_task (tuple of int): A tuple representing the start and end times of the new task. Returns: - bool: True if the new task can be scheduled without conflicts, False otherwise. new_start, new_end = new_task for start, end in existing_tasks: if not (new_end <= start or new_start >= end): return False return True"},{"question":"# Question Given a binary string, you need to maximize the number of palindromic substrings that can be obtained by rearranging the characters of the string. A substring is defined as a contiguous sequence of characters within a string. Write a function `max_palindromic_substrings(s: str) -> int` that accepts: - `s`: A string containing only characters \'0\' and \'1\'. The function should return an integer representing the maximum number of palindromic substrings that can be formed by rearranging the characters of the string. Example ```python assert max_palindromic_substrings(\\"00011\\") == 5 assert max_palindromic_substrings(\\"001\\") == 3 assert max_palindromic_substrings(\\"1111\\") == 6 ``` Constraints - `1 <= len(s) <= 100` - The input string will only contain \'0\' and \'1\'. Notes - A palindromic substring is defined as a sequence that reads the same forward and backward. - You may assume that rearranging the characters within the string is allowed. - The goal is to count the maximum possible palindromic substrings, not necessarily of the same length.","solution":"def max_palindromic_substrings(s: str) -> int: Returns the maximum number of palindromic substrings that can be formed by rearranging the characters of the string s. from collections import Counter # Count the occurrences of each character count = Counter(s) # Number of 0s and 1s in the string zeros = count[\'0\'] ones = count[\'1\'] # Maximum number of palindromic substrings we can get # Single characters are always palindromic, so: max_substrings = zeros + ones return max_substrings"},{"question":"# Question Scenario You are tasked with developing a function that uses dynamic programming to solve the problem of determining the maximum sum you can achieve by picking non-adjacent elements from a list of integers. The purpose of this problem is to assess your ability to optimize recursive solutions using dynamic programming techniques. Task Write a Python function `max_non_adjacent_sum` that calculates the maximum sum of non-adjacent elements in a list of integers. Function Specification ```python def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent elements from the list. Args: arr (list of ints): A list of integers. Returns: int: The maximum sum of non-adjacent elements in the list. ``` Constraints - The length of the input list `arr` will be between `1` and `1000`. - The elements in the list can be negative as well as positive. - The input list may contain duplicates. Example ```python arr = [3, 2, 5, 10, 7] assert max_non_adjacent_sum(arr) == 15 # Choose 3 + 10 + 2 arr = [-2, 1, 3, -4, 5] assert max_non_adjacent_sum(arr) == 8 # Choose 3 + 5 arr = [5, 5, 10, 100, 10, 5] assert max_non_adjacent_sum(arr) == 110 # Choose 5 + 100 + 5 ``` Performance Requirements - The function should be optimized to run in linear time, O(n). - Memory usage should be efficient, ideally using O(n) space complexity. Additional Notes - Consider edge cases, such as when the list contains all negative numbers or only one or two elements. - Ensure your solution handles a mix of positive and negative integers effectively.","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent elements from the list. Args: arr (list of ints): A list of integers. Returns: int: The maximum sum of non-adjacent elements in the list. if not arr: return 0 n = len(arr) if n == 1: return max(0, arr[0]) if n == 2: return max(0, max(arr[0], arr[1])) dp = [0] * n dp[0] = max(0, arr[0]) dp[1] = max(dp[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + arr[i]) return dp[-1]"},{"question":"# Array Subset Sum Verification **Objective**: Given an array `arr` of integers and a target sum `S`, your challenge is to write a function that determines if there is a subset of the array which sums up to `S`. **Problem Statement**: Write a function `is_subset_sum_possible(arr: List[int], S: int) -> bool` that checks whether any subset of the given array `arr` sums up to the target sum `S`. **Constraints**: 1. The input array consists of non-negative integers. 2. The length of the input array ranges from 0 to 100. 3. Each element in the array has a value between 1 and 10^4. 4. The target sum `S` is a non-negative integer not exceeding 10^5. **Expected Input and Output**: *Function Signature*: ```python def is_subset_sum_possible(arr: List[int], S: int) -> bool: pass ``` - Input: ```python is_subset_sum_possible([1, 2, 3, 7], 6) ``` - Output: ```python True ``` **Examples**: 1. `is_subset_sum_possible([1, 2, 3, 9], 8)` should return `False`. 2. `is_subset_sum_possible([1, 2, 3, 4, 5], 10)` should return `True`. 3. `is_subset_sum_possible([3, 34, 4, 12, 5, 2], 9)` should return `True`. **Performance Requirements**: 1. Time Complexity: O(n * S) 2. Space Complexity: O(S) # Additional Information To handle edge cases: 1. If the array is empty and the target sum is zero, the function should return `True`. 2. If the array is empty and the target sum is positive, the function should return `False`. 3. If no subset with the desired sum is present, the function should return `False`. Write your function considering the constraints and requirements mentioned. Ensure to handle edge cases and validate the correctness with comprehensive test cases.","solution":"from typing import List def is_subset_sum_possible(arr: List[int], S: int) -> bool: n = len(arr) # Initialize a DP table of size S+1 with all False values. dp = [False] * (S + 1) # There\'s always a subset with sum 0 (the empty subset). dp[0] = True for num in arr: # Update the dp table in reverse order. for i in range(S, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[S]"},{"question":"# Problem Statement: You are tasked with tracking visitor entries and exits to a museum throughout a day. Each entry or exit is recorded with a timestamp. Your goal is to determine the maximum number of visitors present in the museum at any given time of the day. # Requirements: 1. **Input**: * A list of tuples, each describing an event: (timestamp, type). The `type` can be either \\"entry\\" or \\"exit\\". * The `timestamp` follows a 24-hour format (HH:MM). 2. **Output**: * An integer representing the maximum number of visitors present at any time. # Constraints: * The list of events will have a length between 1 to 2000. * Timestamps will be valid and follow a 24-hour format (e.g., \\"18:30\\"). * Events are provided in chronological order. # Instructions: 1. Implement a function `process_events` that takes the list of events and determines the maximum number of visitors present in the museum at any point. 2. Write test cases to verify the implementation. # Function Signature: ```python def process_events(events): pass ``` # Example: ```python if __name__ == \\"__main__\\": events = [(\\"09:00\\", \\"entry\\"), (\\"09:15\\", \\"entry\\"), (\\"10:00\\", \\"exit\\"), (\\"10:30\\", \\"entry\\"), (\\"11:00\\", \\"entry\\"), (\\"11:15\\", \\"exit\\"), (\\"12:00\\", \\"exit\\")] max_visitors = process_events(events) print(max_visitors) # 3 ``` In this example, the maximum number of visitors present at one time in the museum is 3, which occurs just before the first visitor exits at \\"10:00\\".","solution":"def process_events(events): Determines the maximum number of visitors in the museum at any point in time. Parameters: - events: List[Tuple[str, str]]: A list of tuples, where each tuple contains a timestamp in HH:MM format and an event type (\\"entry\\" or \\"exit\\"). Returns: - int: Maximum number of visitors present at any point in time. max_visitors = 0 current_visitors = 0 for timestamp, event in events: if event == \\"entry\\": current_visitors += 1 elif event == \\"exit\\": current_visitors -= 1 if current_visitors > max_visitors: max_visitors = current_visitors return max_visitors"},{"question":"You are required to implement a function that validates if a given string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is a valid expression. A valid expression is one where every opening bracket has a corresponding closing bracket and the brackets are correctly nested. # Scenario You are working on a code editor that needs to provide real-time feedback on whether a string of brackets is properly balanced. To do so, you should implement an efficient algorithm to validate the bracket expressions. # Function Signature ```python def is_valid_expression(s: str) -> bool: pass ``` # Input * `s`: A string containing the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. # Output * A boolean value: `True` if the string is a valid expression, `False` otherwise. # Constraints * The length of the string `s` is at most `10^4`. # Examples ```python is_valid_expression(\\"()\\") # Output: True is_valid_expression(\\"()[]{}\\") # Output: True is_valid_expression(\\"(]\\") # Output: False is_valid_expression(\\"([)]\\") # Output: False is_valid_expression(\\"{[]}\\") # Output: True is_valid_expression(\\"\\") # Output: True ``` # Performance Requirements * The algorithm should operate with a time complexity of O(n), where n is the length of the string. # Hints * Utilize a stack to keep track of open brackets. * When encountering a closing bracket, check if it matches the most recent open bracket on the stack. * If unmatched closing brackets are encountered, or the stack is not empty when the string has been fully parsed, the expression is not valid. Implement a robust solution that handles edge cases efficiently, ensuring the program performs well on large inputs.","solution":"def is_valid_expression(s: str) -> bool: Validate if the given string of brackets is a valid expression. Args: s (str): The input string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Returns: bool: True if the string is a valid expression, False otherwise. # Stack to keep track of opening brackets stack = [] # Dictionary to match closing brackets to their corresponding opening brackets matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} # Iterate over each character in the string for char in s: if char in matching_bracket.values(): # If it\'s an opening bracket, push it onto the stack stack.append(char) elif char in matching_bracket.keys(): # If it\'s a closing bracket, check if the stack is empty or the top of the stack is mismatched if stack == [] or matching_bracket[char] != stack.pop(): return False # If the stack is empty at the end, all open brackets have been matched return stack == [] # Examples print(is_valid_expression(\\"()\\")) # True print(is_valid_expression(\\"()[]{}\\")) # True print(is_valid_expression(\\"(]\\")) # False print(is_valid_expression(\\"([)]\\")) # False print(is_valid_expression(\\"{[]}\\")) # True print(is_valid_expression(\\"\\")) # True"},{"question":"# Narcissistic Number Checker A narcissistic number (also known as a pluperfect number, or an Armstrong number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. For example, 153 is a narcissistic number because (1^3 + 5^3 + 3^3 = 153). Task Write a function `is_narcissistic(number: int) -> bool` that takes an integer `number` as input and returns a boolean indicating whether the number is a narcissistic number or not. Input * A single integer `number` where (0 leq text{number} leq 10^6). Output * A boolean: `True` if the number is a narcissistic number, `False` otherwise. Constraints * The function should efficiently handle up to 10^6 integer values with typical execution times. * Consider edge cases including single digit numbers and numbers with trailing zeroes. Performance Requirements * Aim for a time complexity of O(d) where `d` is the number of digits in the number. * Space complexity should be minimized appropriately. Example ```python >>> is_narcissistic(153) True >>> is_narcissistic(9474) True >>> is_narcissistic(123) False >>> is_narcissistic(5) True ``` You may use predefined math functions to compute powers in your solution to enhance accuracy and performance.","solution":"def is_narcissistic(number: int) -> bool: Checks if a number is a narcissistic number. Args: number (int): The number to check. Returns: bool: True if the number is a narcissistic number, False otherwise. digits = [int(digit) for digit in str(number)] power = len(digits) narcissistic_sum = sum(digit ** power for digit in digits) return narcissistic_sum == number"},{"question":"# Problem Statement You need to implement a function `hex_to_decimal` that converts a given hexadecimal (base-16) string (prefixed with \\"0x\\") to its corresponding non-negative integer representation. # Function Signature ```python def hex_to_decimal(hex_str: str) -> int: ``` # Input - **hex_str (str)**: A string representing the hexadecimal number prefixed with \\"0x\\" (1 ≤ len(hex_str) ≤ 10, and 0 ≤ integer value of hex_str ≤ 10^6). # Output - **int**: An integer representing the decimal value of the given hexadecimal string. # Constraints 1. The input hex_str will always be a valid hexadecimal string prefixed with \\"0x\\". 2. Optimize for both time and space complexity. 3. The function should be capable of handling both upper and lower case letters in the hexadecimal string. # Example ```python >>> hex_to_decimal(\'0x2\') 2 >>> hex_to_decimal(\'0xA\') 10 >>> hex_to_decimal(\'0x64\') 100 >>> hex_to_decimal(\'0x100\') 256 >>> hex_to_decimal(\'0xffff\') 65535 >>> hex_to_decimal(\'0x0\') 0 ``` # Explanation of Examples - `0x2` in hexadecimal is `2` in decimal. - `0xA` in hexadecimal is `10` in decimal (A raises to 10 in base-16). - `0x64` in hexadecimal is `100` in decimal (6*16+4 raises to 6*16^1 + 4*16^0). - `0x100` in hexadecimal is `256` in decimal (1*16^2 + 0*16^1 + 0*16^0). - `0xffff` in hexadecimal is `65535` in decimal (F raises to 15 in base-16, thus 15*16^3 + 15*16^2 + 15*16^1 + 15*16^0). - `0x0` in hexadecimal is `0` in decimal. # Edge Cases to Consider - The smallest number (0). - Typical use cases for various hexadecimal strings. - Limits of input size and valid structure to evaluate performance.","solution":"def hex_to_decimal(hex_str: str) -> int: Converts a given hexadecimal (base-16) string prefixed with \\"0x\\" to its corresponding non-negative integer representation. Args: hex_str (str): A string representing the hexadecimal number prefixed with \\"0x\\". Returns: int: An integer representing the decimal value of the given hexadecimal string. return int(hex_str, 16)"},{"question":"# Bitwise XOR Swap You need to implement a function that swaps the values of two variables without using additional memory (i.e., don\'t use a third variable for temporary storage). Instead, you should use the bitwise XOR operation to perform the swap in place. # Function Signature ```python def xor_swap(a: int, b: int) -> (int, int): pass ``` # Input - `a` (int): An integer value. - `b` (int): Another integer value. # Output - Returns a tuple with the values of `a` and `b` swapped. # Constraints - Inputs will be valid integers within the range of typical integer values supported by the language (usually 32-bit or 64-bit integers). # Example ```python assert xor_swap(5, 9) == (9, 5) assert xor_swap(-1, 0) == (0, -1) assert xor_swap(123456, 654321) == (654321, 123456) assert xor_swap(0, 0) == (0, 0) ``` # Explanation The bitwise XOR operation can be used to swap two numbers without utilizing additional storage. Applying the following three XOR operations will swap the values of `a` and `b`: 1. `a = a ^ b` 2. `b = a ^ b` (which effectively sets `b` to the original value of `a`) 3. `a = a ^ b` (which sets `a` to the original value of `b`) # Context This question evaluates your understanding of bitwise operations and challenges you to think about how to manipulate data at the bit level to achieve efficient algorithms.","solution":"def xor_swap(a: int, b: int) -> (int, int): Swaps the values of a and b using Bitwise XOR without using additional memory. a = a ^ b b = a ^ b a = a ^ b return a, b"},{"question":"# Question: Frequency of Distinct Integers in List You are required to implement a function to determine the frequency of distinct integers in a given list of integers. The function should return a dictionary where the keys are the distinct integers and the values are their respective counts in the list. **Function Signature**: ```python def count_distinct_elements(arr: List[int]) -> Dict[int, int]: ``` **Input**: - `arr` (List[int]): A list of integers. The length of the list can be up to 10^6. **Output**: - (Dict[int, int]): A dictionary with distinct integers as keys and their counts as values. **Constraints**: - You must handle non-list inputs by raising a `ValueError` and providing a relevant message. - The function should work efficiently even for very large lists. **Example**: ```python assert count_distinct_elements([1, 2, 2, 3, 3, 3, 4]) == {1: 1, 2: 2, 3: 3, 4: 1} assert count_distinct_elements([5, 5, 5, 5, 5]) == {5: 5} assert count_distinct_elements([]) == {} assert count_distinct_elements(\\"12345\\") == ValueError(\\"Expected list input, got <class \'str\'>\\") assert count_distinct_elements([1, 2, 3, 1, 2, 1]) == {1: 3, 2: 2, 3: 1} assert count_distinct_elements([10**9, 10**9, -10**9, 2]) == {10**9: 2, -10**9: 1, 2: 1} ``` **Explanation**: 1. The function should iterate through each element in the input list and keep track of the count of each distinct element. 2. Use a dictionary to store the counts of each element. 3. Handle non-list inputs by raising a `ValueError` with a relevant error message. **Notes**: - Be mindful of performance and avoid using inefficient methods for counting elements. - Ensure the function handles both small and very large lists effectively. - The implementation should be clear, concise, and efficient, focusing on correct counting and handling edge cases like empty lists.","solution":"from typing import List, Dict def count_distinct_elements(arr: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are the distinct integers from the input list `arr` and the values are their respective counts. Parameters: arr (List[int]): A list of integers. Returns: Dict[int, int]: A dictionary with distinct integers as keys and their counts as values. if not isinstance(arr, list): raise ValueError(f\\"Expected list input, got {type(arr)}\\") counts = {} for num in arr: if num in counts: counts[num] += 1 else: counts[num] = 1 return counts"},{"question":"# Coding Question: Calculate the Greatest Common Divisor (GCD) Context You are tasked with creating a function that calculates the Greatest Common Divisor (GCD) of two given integers. This is particularly useful in fields such as cryptography, number theory, and algorithm optimization. Task Write a function `gcd(a: int, b: int) -> int` that takes two integers `a` and `b` as input and returns their greatest common divisor. You must implement the Euclidean algorithm to achieve this. Expected Input and Output * **Input**: Two integer parameters `a` and `b`. * **Output**: An integer representing the greatest common divisor of `a` and `b`. Constraints 1. The function should raise a `ValueError` if either `a` or `b` is negative. 2. The function should raise a `TypeError` if the inputs are not integers. Examples ```python >>> gcd(48, 18) 6 >>> gcd(17, 5) 1 >>> gcd(20, 100) 20 >>> gcd(7, -3) Traceback (most recent call last): ... ValueError: Inputs must not be negative >>> gcd(3.5, 7) Traceback (most recent call last): ... TypeError: Inputs must be integers ``` - **Negative Input Example**: `gcd(-20, 30)` should raise `ValueError`. - **Non-integer Input Example**: `gcd(15, \\"30\\")` should raise `TypeError`. # Edge Cases and Performance Expectations Consider and handle edge cases such as: * Zero as input for one or both parameters. * Large integers. * Invalid input types (strings, floating-point numbers, etc.). Your solution should account for these scenarios and operate efficiently.","solution":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor of a and b using the Euclidean algorithm. Raises: ValueError: if either a or b is negative. TypeError: if either a or b is not an integer. if not isinstance(a, int) or not isinstance(b, int): raise TypeError(\\"Inputs must be integers\\") if a < 0 or b < 0: raise ValueError(\\"Inputs must not be negative\\") while b != 0: a, b = b, a % b return a"},{"question":"# Graph Traversal - City Navigation You have been tasked with developing a navigation system for a city\'s public transportation. The city\'s transport network can be represented as a graph where each node represents a station, and each edge represents a direct route between two stations with a specific travel time. Your goal is to find the shortest travel time from one station (source) to another station (destination). Use Dijkstra\'s algorithm to determine the shortest path from the source station to the destination station and implement the solution. Function Signature ```python def find_shortest_path(graph: List[List[Tuple[int, int]]], source: int, destination: int) -> List[int]: ``` Input - **graph**: A list of lists where `graph[i]` is a list of tuples `(j, w)` such that there is an edge from station `i` to station `j` with travel time `w`. - **source**: An integer representing the starting station ID. - **destination**: An integer representing the destination station ID. Output - Returns a list of integers representing the sequence of station IDs that form the shortest path from the source to the destination. If there is no path, return an empty list. Constraints - The number of stations (N) is between 1 and 100. - The travel times are non-negative integers not exceeding 1000. - Source and destination are valid station indices in the graph. Example ```python graph = [ [(1, 4), (2, 1)], [(3, 1)], [(1, 2), (3, 5)], [] ] source = 0 destination = 3 assert find_shortest_path(graph, source, destination) == [0, 2, 1, 3] ``` Notes - Use the `heapq` module to implement the priority queue for Dijkstra\'s algorithm. - Ensure efficient handling of graph updates and edge cases like no available path from source to destination. - Consider all edge cases including zero-weight edges and single-node graphs. Write the function `find_shortest_path` to implement Dijkstra\'s algorithm as outlined in the problem statement.","solution":"import heapq from typing import List, Tuple def find_shortest_path(graph: List[List[Tuple[int, int]]], source: int, destination: int) -> List[int]: N = len(graph) min_heap = [(0, source)] # (total_distance, node) distances = [float(\'inf\')] * N distances[source] = 0 previous_nodes = [-1] * N while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node == destination: break if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(min_heap, (distance, neighbor)) # Retrieve the path path = [] if distances[destination] == float(\'inf\'): return path # no path found current_node = destination while current_node != -1: path.append(current_node) current_node = previous_nodes[current_node] return path[::-1] # reverse path to get it from source to destination"},{"question":"# Problem Statement Given a list of integers, determine if there exists a subsequence within it that sums up to a given target value. Implement the function `subsequence_sum_exists(nums, target)` that takes a list of integers `nums` and an integer `target` and returns a boolean indicating if such a subsequence exists. # Function Signature ```python def subsequence_sum_exists(nums: List[int], target: int) -> bool: ``` # Input - `nums`: A list of integers where `1 <= len(nums) <= 100` and the absolute value of any element is within the range `0 <= |nums[i]| <= 1000`. - `target`: An integer where `-10000 <= target <= 10000`. # Output - A boolean value representing whether there is a subsequence within `nums` that sums up to the given `target` value. # Example ```python print(subsequence_sum_exists([1, 2, 3], 5)) # Outputs: True (2 + 3 = 5) print(subsequence_sum_exists([1, 2, 3, 7], 10)) # Outputs: True (3 + 7 = 10) print(subsequence_sum_exists([1, 2, 3, 4], 11)) # Outputs: False print(subsequence_sum_exists([], 0)) # Outputs: True (Empty subsequence sums to 0) ``` # Constraints - Focus on handling both positive and negative numbers in the input list. - Ensure efficient handling of edge cases with minimal computational delays. # Scenario Imagine a financial application that needs to verify whether certain transactions (represented by a list of values) can combine to achieve a specific target amount. This function will help in analyzing whether a sequence of selected transactions meets the desired criteria. # Notes - Approach the problem using dynamic programming or backtracking efficiently to determine the existence of the subsequence sum. - Test with edge cases such as an empty list, lists containing negative numbers, and a target that is larger or smaller than any sum of all elements in the list combined.","solution":"def subsequence_sum_exists(nums, target): Determine if there exists a subsequence within nums that sums up to the given target. n = len(nums) dp = {0} # A set to hold all achievable sums for num in nums: new_dp = dp.copy() for t in dp: new_dp.add(t + num) dp = new_dp return target in dp"},{"question":"# Problem Statement You are given a list of integers which represent the number of items required by customers in a store. Additionally, you are given an integer that represents the total inventory available. Your task is to determine whether it is possible to satisfy all customers\' demands without running out of inventory. # Task Write a function `can_satisfy_demands(demands: List[int], inventory: int) -> bool` that returns a boolean indicating whether all customer demands can be met without exceeding the total inventory. # Input - A list of integers `demands` (1 ≤ len(demands) ≤ 10^4), where each integer (1 ≤ demands[i] ≤ 10^4) represents the number of items demanded by a customer. - An integer `inventory` (1 ≤ inventory ≤ 10^9), representing the total inventory available. # Output - Return a boolean value: `True` if it is possible to fulfill all customer demands with the given inventory, `False` otherwise. # Constraints 1. The length of the `demands` list will be between 1 and 10,000 inclusive. 2. Each customer\'s demand will be between 1 and 10,000 inclusive. 3. The total inventory value will be between 1 and 1,000,000,000 inclusive. # Example - Given `demands = [5, 10, 3, 4]` and `inventory = 25`, the output should be `True` because the total demand (5+10+3+4 = 22) is less than the inventory (25). - Given `demands = [5, 10, 3, 8]` and `inventory = 25`, the output should be `False` because the total demand (5+10+3+8 = 26) exceeds the inventory (25). # Implementation Guide 1. Calculate the total demand by summing all the values in the `demands` list. 2. Compare the total demand to the inventory. 3. Return `True` if the total demand is less than or equal to the inventory, otherwise return `False`. ```python from typing import List def can_satisfy_demands(demands: List[int], inventory: int) -> bool: Determines if all customer demands can be satisfied with the given inventory. Parameters: demands (List[int]): List of integers representing customer demands. inventory (int): The total inventory available. Returns: bool: True if all demands can be met, False otherwise. total_demand = sum(demands) return total_demand <= inventory # Example usage: print(can_satisfy_demands([5, 10, 3, 4], 25)) # Output: True print(can_satisfy_demands([5, 10, 3, 8], 25)) # Output: False ```","solution":"from typing import List def can_satisfy_demands(demands: List[int], inventory: int) -> bool: Determines if all customer demands can be satisfied with the given inventory. Parameters: demands (List[int]): List of integers representing customer demands. inventory (int): The total inventory available. Returns: bool: True if all demands can be met, False otherwise. total_demand = sum(demands) return total_demand <= inventory"},{"question":"# Scenario A popular fitness app wants to include a feature that tracks the longest streak of consecutive days a user has logged their exercise. You are tasked with creating a function that finds the length of the longest consecutive exercise streak from a given list of dates. # Problem Statement Implement a Python function called `longest_consecutive_streak` that calculates the longest streak of consecutive days from a given list of dates. # Function Signature ```python def longest_consecutive_streak(dates: list[str]) -> int: ``` # Inputs * `dates`: A list of strings where each string represents a date in the \\"YYYY-MM-DD\\" format. The list can be empty or contain any number of dates in any order. # Outputs * An integer representing the length of the longest streak of consecutive days. # Constraints * The function must raise a `ValueError` with the message \\"Invalid date format\\" if any date is not in the \\"YYYY-MM-DD\\" format. * If the list is empty, the function should return 0. * The function should correctly handle any valid dates, including leap years. # Performance Requirements * The solution should have a time complexity of O(n log n) due to sorting and a space complexity of O(n). # Example ```python assert longest_consecutive_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", \\"2023-01-05\\"]) == 3 assert longest_consecutive_streak([\\"2022-12-31\\", \\"2023-01-01\\", \\"2023-01-02\\", \\"2022-12-30\\", \\"2023-01-04\\"]) == 4 assert longest_consecutive_streak([\\"2021-03-15\\", \\"2021-03-12\\", \\"2021-03-14\\", \\"2021-03-13\\", \\"2021-03-16\\"]) == 5 assert longest_consecutive_streak([]) == 0 try: longest_consecutive_streak([\\"2021-15-03\\"]) except ValueError as e: assert str(e) == \\"Invalid date format\\" ``` Implement the `longest_consecutive_streak` function to meet the given requirements and optimize for performance. Provide sufficient error handling for edge cases. Write clear and concise code, ensuring maintainability and readability.","solution":"from datetime import datetime, timedelta def longest_consecutive_streak(dates: list[str]) -> int: if not dates: return 0 # Check date format and parse dates try: parsed_dates = [datetime.strptime(date, \\"%Y-%m-%d\\") for date in dates] except ValueError: raise ValueError(\\"Invalid date format\\") # Sort the dates sorted_dates = sorted(parsed_dates) longest_streak = 1 current_streak = 1 for i in range(1, len(sorted_dates)): if sorted_dates[i] == sorted_dates[i - 1] + timedelta(days=1): current_streak += 1 longest_streak = max(longest_streak, current_streak) else: current_streak = 1 return longest_streak"},{"question":"# Scenario: You are responsible for maintaining a log management system in which logs from various services are received as list of integers, representing timestamps in seconds when each log entry was created. Analyzing these logs quickly and efficiently is crucial for your operations team. # Problem Statement: Your task is to implement a method called `find_kth_recent` in the `LogManagement` class that will return the k-th most recent log timestamp. The logs are stored in a list where the most recent log is at the end of the list. Implementation Requirements: - The method `find_kth_recent` should be added to the `LogManagement` class. - It should return the k-th most recent log timestamp, where k is a 1-based index. - If k is `1`, it returns the most recent log. - If k is `2`, it returns the second most recent log, etc. - If k is greater than the number of logs, the method should return `None`. # Constraints: 1. Assume that the number of logs will not exceed 100,000. 2. k will always be a positive integer. Input: - There is no direct input; logs are managed within the `LogManagement` class. - k is passed as an argument to the method `find_kth_recent`. Output: - An integer representing the k-th most recent log timestamp or `None` if k is out of bounds. # Example: Assuming you have a `LogManagement` instance as follows: ```python logs = LogManagement([1587888888, 1587887890, 1587888999, 1587890000]) ``` After implementing `find_kth_recent`, calling `logs.find_kth_recent(1)` will return `1587890000`. Calling `logs.find_kth_recent(3)` will return `1587887890`. Calling `logs.find_kth_recent(5)` will return `None`. # Instructions: 1. Add your method to the `LogManagement` class. 2. Ensure it runs correctly for the example scenarios. 3. Check edge cases such as invalid values of k, empty logs, and very large lists of logs. Good luck!","solution":"class LogManagement: def __init__(self, logs): Initializes the LogManagement instance with a list of logs. :param logs: List of integers representing log timestamps. self.logs = logs def find_kth_recent(self, k): Returns the k-th most recent log timestamp. :param k: 1-based index indicating the k-th most recent log to find. :return: Integer timestamp of the k-th most recent log or None if k is out of bounds. if k <= 0 or k > len(self.logs): return None return self.logs[-k]"},{"question":"# Question: You are tasked with implementing a feature for a text-based application. Specifically, you need to write a function that identifies the most frequently occurring word in a given text. If there are multiple words with the same highest frequency, return the one that appears first in the text. Function Signature ```python def most_frequent_word(text: str) -> str: pass ``` # Input: - A string `text` (1 ≤ length of text ≤ 10^6) consisting of words separated by spaces. Words consist of lowercase alphabetic characters only. # Output: - A string representing the most frequently occurring word. # Constraints: - You should expect input texts up to the provided maximum length and optimize your solution to handle such cases efficiently. # Performance Requirements: - The solution should execute within a reasonable time frame even with the largest input sizes. # Examples: - `most_frequent_word(\\"apple banana apple orange banana apple\\") -> \\"apple\\"` - `most_frequent_word(\\"banana orange banana apple orange banana\\") -> \\"banana\\"` - `most_frequent_word(\\"car bike car bike bus\\") -> \\"car\\"` # Additional Context: You can employ a dictionary or a similar data structure to count the occurrences of each word. Iteratively update the count and keep track of the most frequent word using a single pass through the list of words to ensure an efficient solution. The task involves: 1. Splitting the text into words. 2. Counting the frequency of each word. 3. Identifying the word with the highest frequency, ensuring you return the first one in case of ties. Ensure your solution adheres to the performance requirements by considering the use of efficient data structures and algorithms.","solution":"def most_frequent_word(text: str) -> str: Returns the most frequently occurring word in the given text. If multiple words have the same highest frequency, returns the one that appears first. word_counts = {} words = text.split() for word in words: if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 max_count = 0 most_frequent = \\"\\" for word in words: if word_counts[word] > max_count: max_count = word_counts[word] most_frequent = word return most_frequent"},{"question":"# String Manipulation and Validation You are tasked with writing a function to validate and clean a list of email addresses. The goal is to ensure that each email address meets specific criteria and to standardize them for consistent parsing. **Function Signature** ```python def clean_and_validate_emails(emails: List[str]) -> dict: ``` # Input 1. `emails` (List[str]): A list of email addresses as strings. # Output A `dict` with the following keys: * `\\"valid_emails\\"` (List[str]): List of email addresses that are valid and cleaned. * `\\"invalid_emails\\"` (List[str]): List of email addresses that are invalid. # Constraints * An email address is considered valid if it matches the pattern `username@domain.tld` (e.g., user@domain.com). * Remove any leading or trailing whitespace from the email addresses. * Convert all valid email addresses to lowercase. * Emails must not contain any spaces or special characters outside of `@` and `.`. * Preserve the order of input emails in the output lists. # Examples ```python emails = [ \\"Valid.Email@Example.com \\", \\"invalid-email@example...com\\", \\"another.Valid+Email@example.co.uk\\", \\"invalid.email@domain\\", \\" valid.email@domain.COM\\" ] result = clean_and_validate_emails(emails) print(result) # Output: # { # \\"valid_emails\\": [\\"valid.email@example.com\\", \\"another.valid+email@example.co.uk\\", \\"valid.email@domain.com\\"], # \\"invalid_emails\\": [\\"invalid-email@example...com\\", \\"invalid.email@domain\\"] # } ``` # Hint Use regular expressions to validate the email pattern and string methods for cleaning and formatting. This additional question follows the style, complexity, and topic consistency of the existing questions, focusing on a practical programming task that involves string manipulation, validation, and error handling.","solution":"import re from typing import List, Dict def clean_and_validate_emails(emails: List[str]) -> Dict[str, List[str]]: Validates and cleans a list of email addresses. Args: emails (List[str]): A list of email addresses as strings. Returns: dict: A dictionary with keys \'valid_emails\' and \'invalid_emails\' containing cleaned valid and invalid emails respectively. # Email validation regex pattern pattern = re.compile(r\'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\') valid_emails = [] invalid_emails = [] for email in emails: cleaned_email = email.strip().lower() if pattern.match(cleaned_email) and \'..\' not in cleaned_email: valid_emails.append(cleaned_email) else: invalid_emails.append(email.strip()) # retain original format for invalid emails return { \\"valid_emails\\": valid_emails, \\"invalid_emails\\": invalid_emails }"},{"question":"**Scenario**: You are a software engineer responsible for developing a checkout system for an online retail store. One of the system\'s requirements is to apply discount coupons to the total purchase amount. The coupons can either provide a percentage discount or a flat amount discount. Each coupon has a unique code and can only be used once. The queue data structure provided below is used to manage the coupons available. When a user applies a coupon, it should be removed from the queue and applied to the total purchase amount accordingly. **Objective**: Using the queue data structure provided, implement the `apply_coupon` function, which should handle applying the next coupon in the queue to the total purchase amount. # Function Signature ```python def apply_coupon(queue: Queue[dict], total_amount: float) -> float: pass ``` # Input - A `Queue` of dictionaries, each representing a coupon with two keys: `\'type\'` which can be `\\"percentage\\"` or `\\"flat\\"`, and `\'value\'` which holds the discount value (a percentage or a flat amount). - A float `total_amount` representing the total purchase amount before applying the coupon. # Output - A float representing the new total amount after applying the coupon from the front of the queue. # Constraints - The function should return the original `total_amount` if the queue is empty. - Percentage discounts should be applied first if there are multiple coupons in the queue, but only the first coupon should be removed from the queue, regardless. # Example Usage ```python >>> queue = Queue() >>> queue.enqueue({\'type\': \'percentage\', \'value\': 10}) # 10% off >>> queue.enqueue({\'type\': \'flat\', \'value\': 20}) # 20 off >>> total_amount = 100 >>> apply_coupon(queue, total_amount) 90.0 # 10% off on 100 >>> apply_coupon(queue, 80) 60.0 # 20 off on 80 >>> queue.is_empty() True >>> apply_coupon(queue, 50) 50.0 # No more coupons ``` # Additional Notes - Ensure the function properly handles the queue operations and calculates the updated total amount after applying the respective coupon. - Percentage discounts should be calculated as a reduction of the total amount by the given percentage. - Flat discounts should directly subtract the given value from the total amount. Ensure the total amount does not go below zero.","solution":"from queue import Queue def apply_coupon(queue: Queue[dict], total_amount: float) -> float: if queue.empty(): # If the queue is empty, return the original amount return total_amount coupon = queue.get() # Get the first coupon in the queue if coupon[\'type\'] == \'percentage\': discount = total_amount * (coupon[\'value\'] / 100.0) total_amount -= discount elif coupon[\'type\'] == \'flat\': total_amount -= coupon[\'value\'] # Ensure total_amount does not go below zero if total_amount < 0: total_amount = 0 return total_amount"},{"question":"# Problem Statement You are tasked with implementing a function to efficiently compute the number of distinct items in a list while maintaining their original order of appearance. # Functional Requirements Implement a function `get_distinct_items(input_list: list) -> list` that: - Returns a list containing the distinct items from `input_list` in the order they first appear. - Preserves the order and only includes the first occurrence of each unique item. # Constraints - The `input_list` can include mixed data types (e.g., integers, strings, floats). - The function should handle input lists up to 10^5 elements efficiently. # Example ```python def get_distinct_items(input_list: list) -> list: seen = set() distinct_items = [] for item in input_list: if item not in seen: seen.add(item) distinct_items.append(item) return distinct_items # Test cases print(get_distinct_items([1, 2, 2, 3, 4, 3, 5])) # [1, 2, 3, 4, 5] print(get_distinct_items([\'a\', \'b\', \'a\', \'c\', \'b\'])) # [\'a\', \'b\', \'c\'] print(get_distinct_items([1.1, 2.2, 3.3, 2.2, 4.4])) # [1.1, 2.2, 3.3, 4.4] print(get_distinct_items([True, False, True, True])) # [True, False] print(get_distinct_items([])) # [] # Edge case with large input large_list = list(range(100000)) + list(range(100000)) print(get_distinct_items(large_list) == list(range(100000))) # True ``` # Your Task Implement the `get_distinct_items` function according to the specifications above. Ensure the function performs efficiently for large inputs and properly handles mixed data types and an empty input list. **Note**: Use the provided test cases to verify your implementation.","solution":"def get_distinct_items(input_list: list) -> list: Returns a list of distinct items from the input list, maintaining their original order. seen = set() distinct_items = [] for item in input_list: if item not in seen: seen.add(item) distinct_items.append(item) return distinct_items"},{"question":"# Problem Statement You are tasked with implementing a function named `find_influencers` that identifies the most influential users in a social network based on the number of connections (followers). Your task is to analyze the graph structure and efficiently determine the top k users with the highest number of followers. # Function Signature ```python def find_influencers( social_graph: Dict[int, Set[int]], k: int ) -> List[int]: Find the top k influencers (users with the most followers) in the social network. Parameters: social_graph (Dict[int, Set[int]]): A dictionary where keys represent user IDs and values are sets of user IDs representing the followers of the key user. k (int): The number of top influencers to return. Returns: List[int]: A list of user IDs representing the top k influencers in sorted order by their number of followers (most to least). pass ``` # Input * `social_graph` is a dictionary where each key is a user ID (an integer), and each value is a set containing the IDs of users who follow the key user. * `k` is an integer representing the number of top influencers to return. # Output The function returns a list of user IDs representing the top `k` influencers, sorted by the number of followers in descending order. If two users have the same number of followers, the user with the smaller ID should appear first. # Constraints * The social graph should have at least one user and at most 10^5 users. * Each user can have at most 10^4 followers. * `k` should be a positive integer and less than or equal to the total number of users. * User IDs are non-negative integers. # Performance Requirements * The function should efficiently handle graphs with up to 10^5 users and up to 10^4 followers per user. * The solution should be optimized to handle large sets and ensure the results are returned promptly. # Scenarios 1. **Basic Functionality**: Implement the algorithm to find influencers based on follower count and return them in the correct order. 2. **Edge Cases**: Handle cases where multiple users have the same number of followers, and ensure the user with the smaller ID comes first. 3. **Optimization**: Optimize the algorithm to ensure it can handle the upper limits of the constraints efficiently. # Example ```python social_graph = { 1: {2, 3}, 2: {3}, 3: {1, 2, 4}, 4: {} } k = 2 find_influencers(social_graph, k) # Expected output: [3, 1] ``` In this example, user 3 has the highest number of followers (3 followers), followed by user 1 (2 followers). Thus, the function should return `[3, 1]`.","solution":"def find_influencers(social_graph, k): Find the top k influencers (users with the most followers) in the social network. Parameters: social_graph (Dict[int, Set[int]]): A dictionary where keys represent user IDs and values are sets of user IDs representing the followers of the key user. k (int): The number of top influencers to return. Returns: List[int]: A list of user IDs representing the top k influencers in sorted order by their number of followers (most to least). # Create a dictionary to store user id and their number of followers followers_count = {user: len(followers) for user, followers in social_graph.items()} # Sort the dictionary items by followers count first (descending), and then by userID (ascending) sorted_users = sorted( followers_count.items(), key=lambda item: (-item[1], item[0]) ) # Extract the top k user IDs top_k_influencers = [user_id for user_id, _ in sorted_users[:k]] return top_k_influencers"},{"question":"# Context An online store tracks inventory and wants to implement an efficient system to process customer orders. Each order may contain different types of items, and the store needs to ensure it has enough stock to fulfill each order. If an order can be fulfilled, the stock should be updated; if not, the order should be rejected. # Task Implement the function `process_orders(inventory, orders)` that takes: 1. `inventory`: A dictionary where the keys are item names (strings) and the values are integers representing the quantity in stock. 2. `orders`: A list of dictionaries, where each dictionary represents a single order with item names as keys and quantities as values. The function should return a list of boolean values where each element is `True` if the corresponding order can be fulfilled, and `False` otherwise. If an order is fulfilled, the inventory should be updated accordingly. # Input Format - `inventory` is a dictionary with item names as keys and integers as values indicating the quantity in stock. - `orders` is a list of dictionaries, where each dictionary\'s keys are item names and the values are the quantities requested. # Output Format - Return a list of boolean values indicating whether each order can be fulfilled. # Constraints - (1 leq text{length of inventory} leq 1000) - (1 leq text{length of orders} leq 100) - Each item name will be a non-empty string of at most 100 characters. - Quantities in `inventory` and each `order` are non-negative integers. # Example Input: ```python inventory = {\'apple\': 10, \'banana\': 5, \'orange\': 7} orders = [{\'apple\': 3, \'banana\': 2}, {\'apple\': 5, \'orange\': 2}, {\'banana\': 3, \'orange\': 5}] ``` Output: ```python [True, True, False] ``` # Function Signature ```python def process_orders(inventory: dict[str, int], orders: list[dict[str, int]]) -> list[bool]: pass ```","solution":"def process_orders(inventory, orders): Processes a list of orders based on the available inventory. Parameters: inventory (dict): A dictionary with item names as keys and quantities as values. orders (list): A list of dictionaries, each representing an order with item names as keys and quantities as values. Returns: list: A list of boolean values indicating whether each order can be fulfilled. result = [] for order in orders: can_fulfill = True # Check if the order can be fulfilled with the current inventory for item, qty in order.items(): if item not in inventory or inventory[item] < qty: can_fulfill = False break # If the order can be fulfilled, update the inventory if can_fulfill: for item, qty in order.items(): inventory[item] -= qty result.append(can_fulfill) return result"},{"question":"# Question: Matrix Transpose with In-Place Modifications You are tasked with implementing a function to transpose a square matrix in place. Given an NxN matrix, where `N` is the number of rows and columns, modify the input matrix such that its rows become columns and its columns become rows. # Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> None: pass ``` # Input - A square matrix `matrix`, represented as a list of `N` lists, each containing `N` integers. # Output - The function does not need to return anything. It should modify the input matrix in place. # Constraints - The function should handle matrices where `1 <= N <= 1000`. - Do not use any extra memory for another matrix; manipulate the matrix directly. # Examples 1. **Input**: `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` - **Output**: The same matrix modified to `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]` 2. **Input**: `[[5]]` - **Output**: The same matrix modified to `[[5]]` 3. **Input**: `[[1, 0], [0, 1]]` - **Output**: The same matrix modified to `[[1, 0], [0, 1]]` # Sample Test ```python matrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] transpose_matrix(matrix1) assert matrix1 == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] matrix2 = [[5]] transpose_matrix(matrix2) assert matrix2 == [[5]] matrix3 = [[1, 0], [0, 1]] transpose_matrix(matrix3) assert matrix3 == [[1, 0], [0, 1]] ``` # Hint To transpose a matrix in place, consider iterating over the elements only in the upper triangle of the matrix (excluding the diagonal) and swapping elements `[i][j]` with `[j][i]` for each element in that region.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> None: Transposes a square matrix in place. Args: matrix (List[List[int]]): A square matrix (NxN) to be transposed. Returns: None: The function modifies the input matrix in place. N = len(matrix) for i in range(N): for j in range(i+1, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Problem Statement: Implement a pattern-matching function to verify if a given string matches a given pattern. The pattern can include the special character \'?\' which matches exactly one character, and \'*\' which matches zero or more characters. # Detailed Requirements: 1. Create a function `is_match(s: str, p: str) -> bool` that accepts two strings: * `s`: the input string to be matched. * `p`: the pattern string containing special characters. 2. Constraints: * The input string `s` contains only lowercase alphabetic characters. * The pattern string `p` contains lowercase alphabetic characters and the special characters \'?\' and \'*\'. * \'?\' matches exactly one character. * \'*\' matches zero or more characters. * Both input strings should be of length between 1 and 1000. 3. Input and Output formats: * The function will receive two strings `s` and `p` and return a boolean indicating if the string `s` matches the pattern `p`. * Example input: `is_match(\\"baaabab\\", \\"ba*a?\\")` * Example output: `True` # Performance: * The function `is_match` should aim for a time complexity of O(n * m), where `n` is the length of the input string `s`, and `m` is the length of the pattern `p`. * The space complexity should be proportional to the lengths of the inputs. # Example: ```python # Sample usage of the is_match function print(is_match(\\"baaabab\\", \\"ba*a?\\")) # Output: True print(is_match(\\"abc\\", \\"a*c\\")) # Output: True print(is_match(\\"abcd\\", \\"a*d\\")) # Output: True print(is_match(\\"abcd\\", \\"a*c?\\")) # Output: False print(is_match(\\"abcd\\", \\"a?c\\")) # Output: False ```","solution":"def is_match(s: str, p: str) -> bool: Returns True if string s matches pattern p, which may contain the special characters \'?\' and \'*\'. \'?\' matches exactly one character, \'*\' matches zero or more characters. # Initialize dp matrix dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Fill the first row (s is an empty string) for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Fill the dp table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'?\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"# Substring Removal to Form Palindrome You have been given a problem where you need to remove the minimum number of characters from a given string to form a palindrome. Write a function `min_deletions_to_palindrome` that achieves this. Function Signature ```python def min_deletions_to_palindrome(s: str) -> int: ``` Input - The function takes a single input parameter, `s`: - `s` (a string): the input string consisting of lowercase alphabets with length ( 1 leq |s| leq 1000 ). Output - The function should return an integer which is the minimum number of characters that need to be deleted to make the string a palindrome. Example ```python >>> min_deletions_to_palindrome(\\"abca\\") 1 >>> min_deletions_to_palindrome(\\"racecar\\") 0 >>> min_deletions_to_palindrome(\\"abcdef\\") 5 ``` Constraints - You must ensure that the solution is efficient and runs within a reasonable time limit. Task 1. Implement the function `min_deletions_to_palindrome` to calculate the minimum number of deletions required to form a palindrome from the given string `s`. Notes - Consider using dynamic programming or memoization to optimize your solution. - A palindrome is a word, phrase, number, or other sequences of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).","solution":"def min_deletions_to_palindrome(s: str) -> int: def lps(s: str) -> int: n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] n = len(s) len_lps = lps(s) return n - len_lps"},{"question":"# Problem Statement You are tasked with implementing a function `moving_average` that calculates the moving average of an array of integers over a given window size. # Input - A list of integers `items` where (0 leq text{items}[i] leq 10^6). - An integer `window_size` where (1 leq text{window_size} leq text{len(items)}). # Output - A list of floating-point numbers representing the moving average of the array over the window size. # Constraints 1. The length of the array will be between 1 and 10,000 inclusive. 2. The window size will always be a valid positive integer less than or equal to the length of `items`. # Examples ```python moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) # Output: [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0] moving_average([10, 20, 30, 40, 50], 5) # Output: [30.0] moving_average([1, 1, 1, 1, 1], 2) # Output: [1.0, 1.0, 1.0, 1.0] moving_average([5, 15, 25, 35, 45], 1) # Output: [5.0, 15.0, 25.0, 35.0, 45.0] ``` # Performance Requirements Ensure that your solution runs efficiently within the given constraints. The expected time complexity is (O(n)).","solution":"from typing import List def moving_average(items: List[int], window_size: int) -> List[float]: Calculates the moving average of items over the specified window size. n = len(items) if n == 0 or window_size <= 0 or window_size > n: raise ValueError(\\"Invalid input\\") result = [] window_sum = sum(items[:window_size]) result.append(window_sum / window_size) for i in range(window_size, n): window_sum += items[i] - items[i - window_size] result.append(window_sum / window_size) return result"},{"question":"# Binary Search Tree Enhancement You have been provided with a basic implementation of a Binary Search Tree (BST) in Python. The provided implementation includes functionalities to insert a node, search for a node, and find the minimum and maximum values in the tree. Your task is to enhance this BST implementation with the additional features listed below while adhering to the given constraints: 1. **Height Calculation (`get_height`)**: Add a method to calculate the height of the BST. 2. **Inorder Successor (`inorder_successor`)**: Add a method to find the inorder successor of a given value in the BST. 3. **Node Deletion (`delete`)**: Implement a method to delete a node with a specified value, ensuring the BST property is maintained after deletion. Constraints * The methods should handle edge cases effectively. For example, `inorder_successor` should raise an appropriate exception if the given value doesn\'t exist in the BST. * You must maintain the BST property during the insertion and deletion operations. * Utilize recursion or iteration as required to ensure efficient and clean implementations. Function Signatures ```python class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): # Implement insert here def search(self, value): # Implement search here def find_min(self): # Implement find_min here def find_max(self): # Implement find_max here def get_height(self): # Implement get_height here def inorder_successor(self, value): # Implement inorder_successor here def delete(self, value): # Implement delete here ``` Example Usage ```python # Example usage bst = BinarySearchTree() bst.insert(10).insert(5).insert(15).insert(2).insert(7) print(bst.get_height()) # Output: 3 print(bst.inorder_successor(10).value) # Output: 15 bst.delete(5) print(bst.search(5)) # Output: None (since 5 is deleted) print(bst.find_min().value) # Output: 2 print(bst.find_max().value) # Output: 15 ``` Complete the Binary Search Tree implementation by adding these features. Ensure you include tests to verify the correctness of your implementations.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) return self def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def search(self, value): return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None or node.value == value: return node if value < node.value: return self._search_recursive(node.left, value) return self._search_recursive(node.right, value) def find_min(self): return self._find_min_node(self.root) def _find_min_node(self, node): current = node while current and current.left: current = current.left return current def find_max(self): return self._find_max_node(self.root) def _find_max_node(self, node): current = node while current and current.right: current = current.right return current def get_height(self): return self._get_height_recursive(self.root) def _get_height_recursive(self, node): if node is None: return 0 left_height = self._get_height_recursive(node.left) right_height = self._get_height_recursive(node.right) return max(left_height, right_height) + 1 def inorder_successor(self, value): node = self.search(value) if node is None: raise ValueError(\\"Value not found in the tree\\") if node.right: return self._find_min_node(node.right) successor = None ancestor = self.root while ancestor != node: if node.value < ancestor.value: successor = ancestor ancestor = ancestor.left else: ancestor = ancestor.right return successor def delete(self, value): self.root = self._delete_node(self.root, value) def _delete_node(self, node, value): if node is None: return node if value < node.value: node.left = self._delete_node(node.left, value) elif value > node.value: node.right = self._delete_node(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._find_min_node(node.right) node.value = temp.value node.right = self._delete_node(node.right, temp.value) return node"},{"question":"# Sorting an Array Using Merge Sort Context You are asked to implement the merge sort algorithm to sort an array of integers. Merge sort is a classical divide-and-conquer algorithm that divides the array into halves, recursively sorts each half, and then merges the sorted halves back together. Requirements Write a function `merge_sort` that takes a list of integers and returns a new list that is sorted in ascending order. You must use the merge sort algorithm to achieve this. 1. **`merge_sort(arr: List[int]) -> List[int]`**: A function that takes a list of integers and returns a new list with the integers in ascending order. This function should not modify the input list. Additional Details - Use the divide-and-conquer approach to implement the merge sort. - Divide the list into two halves, recursively sort each half, and then merge the sorted halves. - Ensure that the merge operation maintains the order. Constraints - The input array will have a length of at most (10^5). - Each integer in the array will be within the range [-10^6, 10^6]. Example ```python def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array # Example usage: arr = [34, 7, 23, 32, 5, 62] sorted_arr = merge_sort(arr) print(sorted_arr) # Output: [5, 7, 23, 32, 34, 62] ``` In the provided example, the `merge_sort` function takes an array `[34, 7, 23, 32, 5, 62]` and returns `[5, 7, 23, 32, 34, 62]`, demonstrating that the merge sort algorithm correctly sorts the input array.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"# Coding Challenge: Efficient Breadth-First Search for Shortest Path in Graph Objective Implement an optimized version of the Breadth-First Search (BFS) algorithm to find the shortest path in an undirected graph, with additional features to handle large graphs efficiently. Problem Statement Create a function `shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]` that returns the shortest path from the `start` vertex to the `end` vertex in the given `graph` using BFS. If there\'s no path, return an empty list. Function Signature ```python def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: # Your code here ``` Input - `graph`: a dictionary where keys are vertices and values are lists of adjacent vertices (1 <= `n` <= 10^5, where `n` is the number of vertices). - `start`: an integer (0 <= `start` < `n`) - the starting vertex. - `end`: an integer (0 <= `end` < `n`) - the destination vertex. Output - Returns a list of integers representing the shortest path from `start` to `end`. Return an empty list if no path exists. Constraints - The graph is undirected and unweighted. - The graph may contain up to 10^5 vertices and edges. - Each vertex is represented by an integer within the range [0, n-1]. Example ```python >>> graph = { ... 0: [1, 2], ... 1: [0, 3], ... 2: [0], ... 3: [1, 4], ... 4: [3] ... } >>> shortest_path(graph, 0, 4) [0, 1, 3, 4] >>> shortest_path(graph, 0, 2) [0, 2] >>> shortest_path(graph, 4, 2) [] ``` Performance Requirements - The function must handle graphs with up to 10^5 vertices efficiently. - BFS should be implemented with an optimal handling of the queue and visited data structures. Detailed Instructions 1. Initialize necessary data structures for BFS: a queue, a visited set, and a parent dictionary to reconstruct the path. 2. Perform BFS from the `start` vertex, marking visited vertices and recording their parents. 3. When the `end` vertex is reached, reconstruct the path using the parent dictionary. 4. Return the path or an empty list if the `end` vertex is not reachable from the `start`. Edge Cases to Consider - When `start` is equal to `end`. - Disconnected graphs where some vertices have no paths to others. - Large graphs to ensure the algorithm performs efficiently.","solution":"from collections import deque from typing import Dict, List def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: Find the shortest path in an undirected graph using BFS. :param graph: Dictionary representing the adjacency list of the graph. :param start: The starting vertex. :param end: The destination vertex. :return: List of integers representing the shortest path from start to end. if start == end: return [start] queue = deque([start]) visited = set([start]) parent = {start: None} while queue: current = queue.popleft() for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) parent[neighbor] = current queue.append(neighbor) if neighbor == end: # If we reach the end, build the path path = [] while neighbor is not None: path.append(neighbor) neighbor = parent[neighbor] return path[::-1] return []"},{"question":"# Coding Assessment Question Scenario You are developing a utility that processes a list of numerical data from various sources to ensure it adheres to specific formatting rules. One of the requirements is to pad numbers with leading zeros to ensure a consistent length of digits in the list. This uniformity is crucial for downstream formatting processes and data comparisons. Your task is to write a function that takes a list of integers and ensures each integer is represented as a string with a specified number of digits, padded with leading zeros if necessary. Task Implement a function `pad_numbers` that takes a list of integers and an integer specifying the desired length of digits, and returns a new list of strings where each number is padded with leading zeros to match the specified length. Input - A list of integers `numbers` (with length between 1 and 1000). - An integer `length` denoting the desired number of digits for each number (1 ≤ length ≤ 10). Output - A list of strings where each integer from the input list is padded with leading zeros to match the specified length. Constraints - Each integer in the input list can range from 0 to 10^9. - You must handle numbers that are originally shorter or longer than the specified length appropriately. Examples ```python >>> pad_numbers([7, 45, 123, 6], 3) [\'007\', \'045\', \'123\', \'006\'] >>> pad_numbers([0, 89, 456], 5) [\'00000\', \'00089\', \'00456\'] >>> pad_numbers([78910, 34, 5], 2) [\'78910\', \'34\', \'05\'] >>> pad_numbers([999, 12345, 77], 4) [\'0999\', \'12345\', \'0077\'] >>> pad_numbers([42], 1) [\'42\'] ``` Implementation ```python def pad_numbers(numbers: list, length: int) -> list: Ensure all numbers in the list are strings of specific length, padded with leading zeros if necessary. return [str(number).zfill(length) for number in numbers] # Sample test cases to validate your function assert pad_numbers([7, 45, 123, 6], 3) == [\'007\', \'045\', \'123\', \'006\'] assert pad_numbers([0, 89, 456], 5) == [\'00000\', \'00089\', \'00456\'] assert pad_numbers([78910, 34, 5], 2) == [\'78910\', \'34\', \'05\'] assert pad_numbers([999, 12345, 77], 4) == [\'0999\', \'12345\', \'0077\'] assert pad_numbers([42], 1) == [\'42\'] print(\\"All tests passed!\\") ```","solution":"def pad_numbers(numbers: list, length: int) -> list: Ensure all numbers in the list are strings of specific length, padded with leading zeros if necessary. return [str(number).zfill(length) for number in numbers]"},{"question":"# Balanced String Split Objective: Write a function to determine the maximum number of balanced substrings that can be obtained from a given string consisting only of characters \'L\' and \'R\'. # Background: A balanced substring has an equal number of \'L\' and \'R\' characters. Given a string `s` which only consists of \'L\' or \'R\', you need to divide the string into the maximum number of balanced substrings. Function Signature: ```python def balanced_string_split(s: str) -> int: pass ``` Expected Input and Output: * **Input**: A single string `s` composed only of \'L\' and \'R\' (1 <= len(s) <= 10^4). * **Output**: An integer representing the maximum number of balanced substrings. Constraints and Assumptions: * The input string will always have a valid number of L and R characters. * The string length will not exceed 10,000 characters. Guiding Points: 1. **Greedy Approach**: Consider a greedy method to iterate through the string and count balanced substrings on the fly. 2. **Tracked Balance**: Maintain a balance counter that tracks the difference between the number of \'L\' and \'R\' characters. 3. **Iteration and Counting**: Iterate through the string and update the balance for each character. Whenever the balance reaches zero, increment your balanced substring count. Implementation Example ```python def balanced_string_split(s: str) -> int: count = 0 balance = 0 for char in s: if char == \'L\': balance += 1 elif char == \'R\': balance -= 1 if balance == 0: count += 1 return count # Example Usage: # balanced_string_split(\\"RLRRLLRLRL\\") should return 4 # balanced_string_split(\\"RLLLLRRRLR\\") should return 3 # balanced_string_split(\\"LLLLRRRR\\") should return 1 ``` Submit your solution with test cases to confirm that the implementation is correct.","solution":"def balanced_string_split(s: str) -> int: count = 0 balance = 0 for char in s: if char == \'L\': balance += 1 elif char == \'R\': balance -= 1 if balance == 0: count += 1 return count"},{"question":"**Question: Inorder Successor in a Binary Search Tree** You are given a Binary Search Tree (BST) where each node contains an integer key. Implement a function `find_inorder_successor(root: Node, target: int) -> Optional[Node]`: that finds the Inorder Successor of a given target node in the BST. # Function Signature: ```python def find_inorder_successor(root: Node, target: int) -> Optional[Node]: ``` # Input: - `root` (Node): The root of the binary search tree. - `target` (int): The key of the node whose inorder successor should be found in the BST. # Output: - The inorder successor node (Node or None): The next node in the inorder traversal of the BST after the node with `target` key. Return `None` if no successor exists. # Constraints: - Assume the BST does not contain duplicate keys. - Each node in the BST has the following structure: ```python class Node: def __init__(self, key: int): self.key = key self.left = None self.right = None ``` # Example: ```python root = Node(20) root.left = Node(10) root.right = Node(30) root.left.left = Node(5) root.left.right = Node(15) root.right.left = Node(25) root.right.right = Node(35) assert find_inorder_successor(root, 10).key == 15 assert find_inorder_successor(root, 15).key == 20 assert find_inorder_successor(root, 30).key == 35 assert find_inorder_successor(root, 35) is None ``` # Description: 1. An inorder successor of a node in a BST is the next node in the inorder traversal of the BST. For a node with key `target`: - If the node has a right subtree, the inorder successor is the leftmost node in the right subtree. - If the node does not have a right subtree, you need to look at the ancestors of the node until you find the node which is the left child of its parent. The parent of that node will be the inorder successor. 2. Your function should traverse the BST and return the node which is the inorder successor of the node with the given `target` key. 3. Return `None` if the node with the given key is not found or has no inorder successor.","solution":"class Node: def __init__(self, key: int): self.key = key self.left = None self.right = None def find_inorder_successor(root: Node, target: int) -> Node: Finds the inorder successor of the given target key in a BST. Args: root: Node - the root of the binary search tree. target: int - the key of the node whose inorder successor needs to be found. Returns: Node - the inorder successor node, or None if no successor exists. target_node = find_node(root, target) if not target_node: return None if target_node.right: return find_min(target_node.right) successor = None current = root while current: if target < current.key: successor = current current = current.left elif target > current.key: current = current.right else: break return successor def find_node(root: Node, target: int) -> Node: Finds and returns the node with the given key in the BST. Args: root: Node - the root of the binary search tree. target: int - the key of the node to be found. Returns: Node - the node with the given key, or None if the node does not exist. current = root while current: if target == current.key: return current elif target < current.key: current = current.left else: current = current.right return None def find_min(node: Node) -> Node: Finds the node with the minimum key in the given subtree. Args: node: Node - the root of the subtree. Returns: Node - the node with the minimum key. current = node while current.left: current = current.left return current"},{"question":"# Balloon Altitude Calculation Background: In meteorology and aviation, the altitude of a balloon can be affected by factors such as temperature, atmospheric pressure, and ascent rate. Accurate altitude calculation is crucial for weather forecasting, flight path planning, and research. Task: You are required to implement the function `calculate_altitude` as described in the code snippet provided to determine the exact altitude of a weather balloon after a given time. The balloon\'s ascent rate may change at specified times due to variations in atmospheric conditions. Function Signature: ```python def calculate_altitude(init_altitude: float, ascent_rates: list, changes: list) -> float: Calculate the altitude of a weather balloon after a set duration given its initial altitude and changes in ascent rates. Input Parameters: init_altitude (float): Initial altitude of the balloon in meters. ascent_rates (list): List of tuples representing the ascent rate in meters per second and the duration in seconds for which the rate applies. [(ascent_rate_1, duration_1), (ascent_rate_2, duration_2), ...] Each rate is applied sequentially. changes (list): List of times (in seconds) at which the ascent rate changes. Returns: float: Final altitude of the weather balloon after all specified intervals. Raises: ValueError: If `ascent_rates` and `changes` lists are not of the same length. ``` Example Tests: ```python >>> calculate_altitude(500, [(5, 300), (3, 600), (8, 200)], [300, 900, 1100]) 30500.0 >>> calculate_altitude(1000, [(2, 400), (1, 600)], [400, 1000]) 3000.0 >>> calculate_altitude(0, [(4, 50), (-2, 30), (6, 20)], [50, 80, 100]) 260.0 >>> calculate_altitude(200, [(10, 100), (-5, 60)], [100, 160]) 800.0 >>> calculate_altitude(100, [(3, 100), (0, 200), (7, 150)], [100, 300, 450]) 4750.0 >>> calculate_altitude(0, [(2, 100)], [100]) # single ascent rate, short duration 200.0 ``` Constraints: * The function should handle floating-point numbers with up to precision of at least two decimal places. * The `init_altitude` can be any real number representing meters. * The `ascent_rates` and `changes` lists must be of the same length, and all durations should be positive integers. * Ensure input parameters are realistic within the constraints of the problem (e.g., ascent rates and durations should be physically meaningful).","solution":"def calculate_altitude(init_altitude, ascent_rates, changes): Calculate the altitude of a weather balloon after given time intervals with changing ascent rates. Parameters: init_altitude (float): Initial altitude of the balloon in meters. ascent_rates (list): List of tuples representing the ascent rate in meters per second and the duration in seconds for which the rate applies. changes (list): List of times (in seconds) at which the ascent rate changes. Returns: float: Final altitude of the weather balloon after all intervals. if len(ascent_rates) != len(changes): raise ValueError(\\"The ascent_rates and changes lists must have the same length.\\") altitude = init_altitude last_change_time = 0 for i in range(len(ascent_rates)): rate, duration = ascent_rates[i] time_for_rate = changes[i] - last_change_time altitude += rate * min(time_for_rate, duration) last_change_time = changes[i] return altitude"},{"question":"# Context: Processing large datasets efficiently is a key part of various applications like data analysis, machine learning, and scientific computing. One way to achieve this is by utilizing hash tables to store and search data. One common operation is to find all pairs of numbers in a dataset that add up to a specific target sum. # Problem Statement: Write a function `find_pairs_with_sum` that takes a list of integers and a target sum, then returns a list of unique pairs of numbers from the input list that add up to the given target sum. Each pair should be sorted in ascending order, and the list of pairs should not contain duplicates. # Specifications: - **Input**: - `numbers`: List of integers. - `target_sum`: Integer representing the target sum for which pairs need to be found. - **Output**: - List of tuples, each containing a pair of integers that add up to the `target_sum`. # Function Signature: ```python def find_pairs_with_sum(numbers: list[int], target_sum: int) -> list[tuple[int, int]]: pass ``` # Constraints: - The input list `numbers` may contain positive and negative integers. - Pairs should be returned without duplicates, and each pair should be sorted in ascending order. - The list of pairs should be sorted based on the first element of the pair and then by the second element in case of a tie. # Example: ```python numbers = [1, 2, 3, 4, 5, 6, 7] target_sum = 8 result = find_pairs_with_sum(numbers, target_sum) print(result) # Expected Output: [(1, 7), (2, 6), (3, 5)] ``` # Note: - The same element cannot be used twice in creating a pair. - Solutions should be efficient in terms of both time and space complexity. # Solution Explanation: The function `find_pairs_with_sum` will utilize a hash table (dictionary) to keep track of the numbers that have been seen so far and their indices. This allows for an efficient way to check if the complement (i.e., `target_sum` - current number) of each number exists in the dataset, enabling the function to find pairs in linear time. The resulting pairs will then be formatted and sorted as required by the constraints.","solution":"def find_pairs_with_sum(numbers: list[int], target_sum: int) -> list[tuple[int, int]]: seen = set() pairs = set() for number in numbers: complement = target_sum - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return sorted(pairs)"},{"question":"# Implement a Simplified Database Management System (DBMS) You are required to implement a simplified in-memory Database Management System (DBMS) that supports basic CRUD (Create, Read, Update, Delete) operations on table records. Each record in the table is represented as a dictionary where the keys are column names and values are the column values. Function Signature ```python class InMemoryDB: def __init__(self): Initialize an empty database. pass def create_table(self, table_name: str, columns: list) -> None: Create a new table with the specified columns. Args: table_name (str): The name of the table to be created. columns (list): The list of column names for the table. Returns: None def insert(self, table_name: str, record: dict) -> None: Insert a new record into the specified table. Args: table_name (str): The name of the table to insert the record into. record (dict): The record to be inserted, with keys as column names. Returns: None def fetch_all(self, table_name: str) -> list: Fetch all records from the specified table. Args: table_name (str): The name of the table to fetch records from. Returns: list: A list of dictionaries representing the records. def update(self, table_name: str, record_id: int, updated_record: dict) -> None: Update a record in the specified table by its index. Args: table_name (str): The name of the table where the record exists. record_id (int): The index of the record to be updated. updated_record (dict): A dictionary representing the updated record. Returns: None def delete(self, table_name: str, record_id: int) -> None: Delete a record from the specified table by its index. Args: table_name (str): The name of the table where the record exists. record_id (int): The index of the record to be deleted. Returns: None ``` Constraints 1. Each table must have a unique name. 2. Each record is represented as a dictionary where keys are the column names defined during table creation. 3. Support CRUD operations: - `create_table` to define a new table. - `insert` to add a new record. - `fetch_all` to retrieve all records from a table. - `update` to modify a record by its index. - `delete` to remove a record by its index. 4. Ensure proper error handling for invalid table names or indices. Requirements 1. Implement the `InMemoryDB` class. 2. Implement each method to manage the in-memory data efficiently. 3. Focus on simple and clear data manipulation operations. Example ```python db = InMemoryDB() # Creating a table db.create_table(\'users\', [\'id\', \'name\', \'email\']) # Inserting records db.insert(\'users\', {\'id\': 1, \'name\': \'John Doe\', \'email\': \'john@example.com\'}) db.insert(\'users\', {\'id\': 2, \'name\': \'Jane Doe\', \'email\': \'jane@example.com\'}) # Fetching records print(db.fetch_all(\'users\')) # Output: [{\'id\': 1, \'name\': \'John Doe\', \'email\': \'john@example.com\'}, {\'id\': 2, \'name\': \'Jane Doe\', \'email\': \'jane@example.com\'}] # Updating a record db.update(\'users\', 1, {\'id\': 1, \'name\': \'John Smith\', \'email\': \'johnsmith@example.com\'}) print(db.fetch_all(\'users\')) # Output: [{\'id\': 1, \'name\': \'John Smith\', \'email\': \'johnsmith@example.com\'}, {\'id\': 2, \'name\': \'Jane Doe\', \'email\': \'jane@example.com\'}] # Deleting a record db.delete(\'users\', 0) print(db.fetch_all(\'users\')) # Output: [{\'id\': 2, \'name\': \'Jane Doe\', \'email\': \'jane@example.com\'}] ``` Notes - Ensure that the table names and records are managed properly within the class. - Handle edge cases such as fetching from a non-existent table or updating a non-existent record.","solution":"class InMemoryDB: def __init__(self): Initialize an empty database. self.db = {} def create_table(self, table_name: str, columns: list) -> None: Create a new table with the specified columns. Args: table_name (str): The name of the table to be created. columns (list): The list of column names for the table. Returns: None if table_name in self.db: raise ValueError(\\"Table already exists.\\") self.db[table_name] = {\'columns\': columns, \'records\': []} def insert(self, table_name: str, record: dict) -> None: Insert a new record into the specified table. Args: table_name (str): The name of the table to insert the record into. record (dict): The record to be inserted, with keys as column names. Returns: None if table_name not in self.db: raise ValueError(\\"Table does not exist.\\") if set(record.keys()) != set(self.db[table_name][\'columns\']): raise ValueError(\\"Record does not match table columns.\\") self.db[table_name][\'records\'].append(record) def fetch_all(self, table_name: str) -> list: Fetch all records from the specified table. Args: table_name (str): The name of the table to fetch records from. Returns: list: A list of dictionaries representing the records. if table_name not in self.db: raise ValueError(\\"Table does not exist.\\") return self.db[table_name][\'records\'] def update(self, table_name: str, record_id: int, updated_record: dict) -> None: Update a record in the specified table by its index. Args: table_name (str): The name of the table where the record exists. record_id (int): The index of the record to be updated. updated_record (dict): A dictionary representing the updated record. Returns: None if table_name not in self.db: raise ValueError(\\"Table does not exist.\\") if record_id < 0 or record_id >= len(self.db[table_name][\'records\']): raise IndexError(\\"Record index out of range.\\") if set(updated_record.keys()) != set(self.db[table_name][\'columns\']): raise ValueError(\\"Updated record does not match table columns.\\") self.db[table_name][\'records\'][record_id] = updated_record def delete(self, table_name: str, record_id: int) -> None: Delete a record from the specified table by its index. Args: table_name (str): The name of the table where the record exists. record_id (int): The index of the record to be deleted. Returns: None if table_name not in self.db: raise ValueError(\\"Table does not exist.\\") if record_id < 0 or record_id >= len(self.db[table_name][\'records\']): raise IndexError(\\"Record index out of range.\\") del self.db[table_name][\'records\'][record_id]"},{"question":"# Problem Statement Develop a function to approximate the square root of a given non-negative integer using the **Babylonian (or Heron\'s) method**. This classical algorithm iteratively estimates the square root by improving on a guess until the desired level of precision is achieved. # Detailed Requirements 1. **Input**: - An integer `X` representing the non-negative integer whose square root is to be approximated. - An integer `N` that denotes the number of decimal places to which the square root should be approximated. 2. **Output**: - A string representation of the square root of `X` accurate to `N` decimal places. 3. **Constraints**: - `0 ≤ X ≤ 10^6` - `1 ≤ N ≤ 100` # Algorithm Babylonian Method: The Babylonian method for computing the square root of `X` can be summarized as follows: 1. Start with a guess `g`. 2. Update the guess `g` using the formula: [ g = frac{g + frac{X}{g}}{2} ] 3. Repeat the update step until the difference between successive guesses is less than the desired precision. Instructions: 1. Implement the `calculate_sqrt(X, N)` function that uses the Babylonian method. 2. Ensure that the final result is accurate to `N` decimal places. # Performance Your implementation should handle the precision required up to 100 decimal places efficiently. ```python def calculate_sqrt(X: int, N: int) -> str: Calculate the square root of X using the Babylonian method to N decimal places. :param X: The non-negative integer whose square root is to be calculated. :param N: The number of decimal places to which the square root should be approximated. :return: String representation of the square root of X to N decimal places. pass # Example usage print(calculate_sqrt(2, 15)) # Expected output: \\"1.414213562373095\\" (or close to it with correct precision) print(calculate_sqrt(5000, 10)) # Expected output: \\"70.7106781187\\" (or close to it with correct precision) ``` Test your function with various values of `X` and `N` to ensure accuracy and performance.","solution":"def calculate_sqrt(X: int, N: int) -> str: Calculate the square root of X using the Babylonian method to N decimal places. :param X: The non-negative integer whose square root is to be calculated. :param N: The number of decimal places to which the square root should be approximated. :return: String representation of the square root of X to N decimal places. if X == 0: return f\\"{0:.{N}f}\\" precision = 10 ** (-N) guess = X / 2.0 while True: next_guess = (guess + X / guess) / 2.0 if abs(next_guess - guess) < precision: break guess = next_guess format_str = f\\"{{:.{N}f}}\\" return format_str.format(next_guess)"},{"question":"# Custom Sort Function Implementation You are tasked with implementing a custom sort function for sorting a list of objects based on multiple attributes. The objects will represent employees with attributes such as ID, name, age, and salary. The custom sort function should provide flexible sorting based on one or more attributes in a specified order. Scenario: Imagine you work at a company\'s HR department, and you need to sort a list of employee records based on various criteria. Sometimes, the records need to be sorted by age in ascending order, and other times by salary in descending order. Your task is to create and demonstrate a custom sort function for this purpose. Requirements: 1. **Class Definition**: Define a class `Employee` with attributes `id`, `name`, `age`, and `salary`. 2. **Custom Sort Function**: * Implement a function `custom_sort` that accepts a list of `Employee` objects and a list of sorting keys. * The sorting keys should be specified as tuples, where each tuple contains the attribute name and the order (either \'asc\' for ascending or \'desc\' for descending). 3. **Sorting Logic**: * Sort the list of employees based on the provided sorting keys. * Ensure stable sorting to maintain the relative order of employees when keys are equal. Input and Output Formats: * **Input**: * Employee objects with attributes `id`, `name`, `age`, and `salary`. * `custom_sort` function: Takes two arguments - a list of `Employee` objects and a list of sorting keys. * **Output**: * A sorted list of `Employee` objects based on the specified sorting criteria. Constraints: * Employee attributes `id` and `age` will be integers, `name` will be a string, and `salary` will be a float. * Sorting keys can include one or more of the attributes with specified order directions. Example Usage: ```python class Employee: def __init__(self, id, name, age, salary): self.id = id self.name = name self.age = age self.salary = salary def __repr__(self): return f\'({self.id}, {self.name}, {self.age}, {self.salary})\' def custom_sort(employees, sorting_keys): employees.sort(key=lambda emp: [ (getattr(emp, key[0]), -1 if key[1] == \'desc\' else 1) for key in sorting_keys ]) return employees # Example Employees e1 = Employee(1, \'Alice\', 35, 75000.0) e2 = Employee(2, \'Bob\', 25, 50000.0) e3 = Employee(3, \'Charlie\', 30, 80000.0) e4 = Employee(4, \'David\', 35, 85000.0) # Custom sorting employees = [e1, e2, e3, e4] # Sort by age asc, then by salary desc sorting_keys = [(\'age\', \'asc\'), (\'salary\', \'desc\')] sorted_employees = custom_sort(employees, sorting_keys) print(sorted_employees) # Output: [(2, Bob, 25, 50000.0), (3, Charlie, 30, 80000.0), (4, David, 35, 85000.0), (1, Alice, 35, 75000.0)] ``` Notes: * Ensure your solution uses Python\'s built-in sorting algorithms efficiently. * Test the implementation with different sorting key combinations to verify the functionality.","solution":"class Employee: def __init__(self, id, name, age, salary): self.id = id self.name = name self.age = age self.salary = salary def __repr__(self): return f\'({self.id}, {self.name}, {self.age}, {self.salary})\' def custom_sort(employees, sorting_keys): def sort_key(employee): key = [] for attr, order in sorting_keys: value = getattr(employee, attr) if order == \'desc\': key.append((-value, order)) else: key.append((value, order)) return key employees.sort(key=sort_key) return employees"},{"question":"# Coding Question **Objective**: Write a function that calculates the minimum number of swaps required to sort an array of non-repeated integers in ascending order. **Function Signature**: ```python def minimum_swaps_to_sort(arr: List[int]) -> int: Determine the minimum number of swaps required to sort the array in ascending order. :param arr: A list of non-repeated integers. :return: An integer representing the minimum number of swaps. Example: >>> minimum_swaps_to_sort([4, 3, 1, 2]) 3 >>> minimum_swaps_to_sort([1, 5, 4, 3, 2]) 2 ``` **Input**: * `arr`: A list of non-repeated integers (1 ≤ len(arr) ≤ 10^5). **Output**: * An integer representing the minimum number of swaps required to sort the array. **Constraints**: * Each element in the array is unique. * The array length does not exceed 100,000. **Performance Requirements**: * The solution should efficiently handle input sizes up to 100,000 elements. # Solution Requirements: 1. **Cycle Detection**: - Treat the array as a graph where each element points to its correct position. - Find all cycles in the permutation of the array and sum up the cycle lengths. 2. **Minimum Swap Calculation**: - For each cycle of length `k`, `k-1` swaps are needed to sort that cycle. - Iterate through the array to detect cycles and count the swaps. 3. **Edge Case Management**: - Ensure the solution correctly handles already sorted arrays with zero swaps. - Optimize for arrays with longer length while maintaining efficiency. # Scenario: Given an unsorted array of distinct integers, you need to determine the number of adjacent element swaps you must make to sort the array. This will help you understand underlying permutation cycles and their transformations, a fundamental aspect of sorting and computational optimization.","solution":"from typing import List def minimum_swaps_to_sort(arr: List[int]) -> int: Determine the minimum number of swaps required to sort the array in ascending order. :param arr: A list of non-repeated integers. :return: An integer representing the minimum number of swaps required to sort the array. # Create a list of tuples where each tuple is (value, index) indexed_arr = [(value, index) for index, value in enumerate(arr)] # Sort the list of tuples based on the value indexed_arr.sort(key=lambda x: x[0]) visited = [False] * len(arr) swaps = 0 for i in range(len(arr)): # If already visited or already in the correct place if visited[i] or indexed_arr[i][1] == i: continue cycle_size = 0 j = i # Follow the cycle while not visited[j]: visited[j] = True j = indexed_arr[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"# Coding Assessment Question **Problem Statement:** You are asked to write a function that simulates a basic version of a ticket reservation system for a train. The function should handle a variety of inputs specifying the number of tickets to reserve, cancel, and check availability. **Function Signature:** ```python def ticket_reservation_system(commands: List[str], verbose: bool = False) -> List[str]: pass ``` **Input:** - `commands`: A list of strings where each string is a command in the format: - `\\"RESERVE <number_of_tickets>\\"`: Reserves the specified number of tickets. - `\\"CANCEL <number_of_tickets>\\"`: Cancels the specified number of tickets. - `\\"AVAILABILITY\\"`: Returns the current number of available tickets as a string. - `verbose`: A boolean flag indicating whether to print detailed information about the internal state after each command (default is `False`). **Output:** - A list of results for the \\"AVAILABILITY\\" commands executed. Each result should be a string representing the available number of tickets. **Constraints:** 1. The train has a fixed capacity of 100 tickets. 2. The reservation and cancellation commands will always be valid (i.e., they will not try to reserve more tickets than available or cancel more tickets than reserved). 3. The sequence of commands can include any number of valid commands, including multiple \\"AVAILABILITY\\" requests. **Examples:** ```python assert ticket_reservation_system([ \\"RESERVE 10\\", \\"AVAILABILITY\\", \\"RESERVE 20\\", \\"AVAILABILITY\\", \\"CANCEL 5\\", \\"AVAILABILITY\\"], verbose=False) == [\\"90\\", \\"70\\", \\"75\\"] assert ticket_reservation_system([ \\"RESERVE 50\\", \\"RESERVE 25\\", \\"AVAILABILITY\\", \\"CANCEL 30\\", \\"AVAILABILITY\\", \\"RESERVE 10\\", \\"AVAILABILITY\\"], verbose=False) == [\\"25\\", \\"55\\", \\"45\\"] assert ticket_reservation_system([\\"RESERVE 100\\", \\"AVAILABILITY\\", \\"CANCEL 100\\", \\"AVAILABILITY\\"], verbose=False) == [\\"0\\", \\"100\\"] ``` **Additional Notes:** - Implement and thoroughly test your solution in Python. - Ensure to handle verbose output to see the detailed internal state after each command. - Handle edge cases such as no commands, consecutive availability requests, and commands that completely reserve or cancel all tickets.","solution":"from typing import List def ticket_reservation_system(commands: List[str], verbose: bool = False) -> List[str]: total_capacity = 100 available_tickets = total_capacity results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"RESERVE\\": number_of_tickets = int(parts[1]) available_tickets -= number_of_tickets if verbose: print(f\\"RESERVE {number_of_tickets}, Available tickets: {available_tickets}\\") elif action == \\"CANCEL\\": number_of_tickets = int(parts[1]) available_tickets += number_of_tickets if verbose: print(f\\"CANCEL {number_of_tickets}, Available tickets: {available_tickets}\\") elif action == \\"AVAILABILITY\\": results.append(str(available_tickets)) if verbose: print(f\\"AVAILABILITY, Available tickets: {available_tickets}\\") return results"},{"question":"# Description You are to implement a function that will reverse the words in a given string while keeping the order of special characters intact. A word is defined as a sequence of alphanumeric characters, and special characters are punctuation marks or spaces. # Requirements 1. **Input**: - A single string `s` containing alphanumeric characters and special characters (punctuation marks or spaces). 2. **Output**: - A string where each alphanumeric word from the input has been reversed, but all special characters remain in their original positions. # Constraints 1. Ensure that the relative positions of special characters do not change. 2. The function should handle edge cases such as empty strings, strings with no alphanumeric characters, and strings with only special characters. # Performance Requirements 1. The function should run efficiently, even for longer strings. 2. Aim for clarity and maintainability while implementing the solution. # Function Signature ```python def reverse_words(s: str) -> str: pass ``` # Examples ```python # Example 1: print(reverse_words(\\"hello, world!\\")) # Expected output: \\"olleh, dlrow!\\" # Example 2: print(reverse_words(\\"a,bc\\")) # Expected output: \\"a,bc\\" # Example 3: print(reverse_words(\\"abc def gh!\\")) # Expected output: \\"cba fed hg!\\" # Example 4: print(reverse_words(\\"123 456 789!\\")) # Expected output: \\"321 654 987!\\" ``` # Note In this implementation, make sure you account for scenarios where: - The string contains multiple consecutive special characters. - The input string contains no alphanumeric characters, in which case the output should be the same as the input.","solution":"def reverse_words(s: str) -> str: Reverses the words in a given string, while keeping the order of special characters intact. # Split the string to extract words, handling special characters import re words = re.split(r\'(W+)\', s) # This will split the string and keep the special characters # Reverse the alphanumeric words in the list of words reversed_words = [ word[::-1] if word.isalnum() else word for word in words ] # Join the list back into a single string return \'\'.join(reversed_words)"},{"question":"# Question: Detect Cycle in a Directed Graph Using Depth-First Search Implement a function to detect if there is a cycle in a directed graph. You should use Depth-First Search (DFS) to identify back edges which indicate cycles. Requirements: 1. **Input**: * A list of edges, where each edge is a tuple of two integers (start, end) representing a directed edge from `start` to `end`. * An integer `n` indicating the number of nodes in the graph, numbered from 0 to `n-1`. 2. **Output**: * A boolean value `True` if there is a cycle in the graph, otherwise `False`. 3. **Constraints**: * The graph may have multiple edges and loops. * Assume no duplicate edges. Example: ```python edges = [(0, 1), (1, 2), (2, 0), (3, 4)] n = 5 assert detect_cycle_in_directed_graph(edges, n) == True edges2 = [(0, 1), (1, 2), (2, 3), (3, 4)] n2 = 5 assert detect_cycle_in_directed_graph(edges2, n2) == False ``` Steps to Implement: 1. **Graph Representation**: Represent the graph using an adjacency list. 2. **DFS Traversal**: Use a stack to perform DFS traversal. 3. **Cycle Detection**: Maintain two states for each node: * `visited`: If a node has been fully processed. * `recStack`: If a node is currently in the recursion stack of the DFS. 4. If a node is encountered that is already in the `recStack`, a cycle exists. Tips: * Use Python lists and sets to implement the graph and track node states. * Carefully handle edge cases where the graph is disconnected or has isolated nodes. * Ensure your function efficiently finds cycles in various configurations of directed graphs. Implement the following function: ```python def detect_cycle_in_directed_graph(edges, n): # Implementation goes here ``` # Example Usage ```python edges = [(0, 1), (1, 2), (2, 0), (3, 4)] n = 5 print(detect_cycle_in_directed_graph(edges, n)) # Output: True edges2 = [(0, 1), (1, 2), (2, 3), (3, 4)] n2 = 5 print(detect_cycle_in_directed_graph(edges2, n2)) # Output: False ```","solution":"def detect_cycle_in_directed_graph(edges, n): from collections import defaultdict def dfs(node, visited, recStack): visited[node] = True recStack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, visited, recStack): return True elif recStack[neighbor]: return True recStack[node] = False return False graph = defaultdict(list) for start, end in edges: graph[start].append(end) visited = [False] * n recStack = [False] * n for node in range(n): if not visited[node]: if dfs(node, visited, recStack): return True return False"},{"question":"# Data Structure Traversal with Specific Sum You are provided with a binary tree, where each node contains an integer value. Your task is to identify if there exists a path from the root to any leaf such that the sum of the values along the path equals a specified target sum. If such a path exists, return the values of nodes along the path; otherwise, return an empty list. Requirements: 1. Traverse the binary tree to find a root-to-leaf path where the sum of the node values equals the target sum. 2. Return the path as a list of node values. 3. If no such path exists, return an empty list. # Function Specification Implement a function `find_path_with_sum(root: TreeNode, target_sum: int) -> List[int]` that checks for a path in the binary tree with the specified sum and returns the path values in order. Inputs: - `root`: The root node of the binary tree. - `target_sum`: An integer specifying the target sum of the path. Outputs: - A list of integers representing the values of the nodes along the path from root to leaf that sum to `target_sum`. Return an empty list if no such path exists. Constraints: - The number of nodes in the tree will be in the range [0, 1000]. - The values of the nodes are integers within the range [-1000, 1000]. Example Usage: ```python # Define the TreeNode class class TreeNode: def __init__(self, value: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right # Example tree: # 5 # / # 4 8 # / / # 11 13 4 # / #7 2 1 root = TreeNode(5, TreeNode(4, TreeNode(11, TreeNode(7), TreeNode(2))), TreeNode(8, TreeNode(13), TreeNode(4, None, TreeNode(1)))) target_sum = 22 path = find_path_with_sum(root, target_sum) print(path) # Output: [5, 4, 11, 2] ```","solution":"# Define the TreeNode class class TreeNode: def __init__(self, value: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def find_path_with_sum(root: TreeNode, target_sum: int): def traverse(node, current_sum, path): if not node: return None current_sum += node.value path.append(node.value) if not node.left and not node.right: # reached leaf if current_sum == target_sum: return path.copy() left_path = traverse(node.left, current_sum, path) right_path = traverse(node.right, current_sum, path) path.pop() return left_path or right_path path_result = traverse(root, 0, []) if path_result: return path_result else: return []"},{"question":"# String Anagram Checker Scenario You are building a feature for a text processing application that checks if two given strings are anagrams of each other. An anagram is a rearrangement of the letters of one word to form another word. For example, the words \\"listen\\" and \\"silent\\" are anagrams. Problem Statement Write a function `are_anagrams` that takes two strings `s1` and `s2` and returns a boolean value indicating whether the strings are anagrams of each other. Input and Output * **Input**: * `s1`: A string containing only lowercase English letters. * `s2`: A string containing only lowercase English letters. * **Output**: A boolean value - `True` if `s1` and `s2` are anagrams of each other, and `False` otherwise. Constraints: * The length of each string is at most 10^5. * The function should be efficient and handle large inputs within reasonable time and space limits. Example: ```python >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"car\\", \\"rat\\") False >>> are_anagrams(\\"\\", \\"\\") True ``` Requirements: * You may not use any external libraries. * Focus on achieving an optimal solution in terms of time and space complexity, ensuring that it can handle the input size within practical limits. Notes: * Consider edge cases such as empty strings or strings of different lengths. * Ensure the function compares the frequency of characters in both strings effectively. * The function must be self-contained and written in Python.","solution":"def are_anagrams(s1, s2): Checks if two strings are anagrams of each other. Args: s1 (str): The first string to compare. s2 (str): The second string to compare. Returns: bool: True if s1 and s2 are anagrams, False otherwise. if len(s1) != len(s2): return False # Count the frequency of each character in s1 count1 = {} for char in s1: if char in count1: count1[char] += 1 else: count1[char] = 1 # Count the frequency of each character in s2 count2 = {} for char in s2: if char in count2: count2[char] += 1 else: count2[char] = 1 # Compare the frequency counts return count1 == count2"},{"question":"# Longest Common Subsequence You are given two sequences, and you need to find the length of their longest common subsequence (LCS). The subsequence is a sequence that appears in the same relative order but not necessarily consecutively in both sequences. Implement a function `longest_common_subsequence` that finds the length of the LCS between two given sequences. # Function Signature: ```python def longest_common_subsequence(seq1: str, seq2: str) -> int: Returns the length of the longest common subsequence between seq1 and seq2. Parameters: seq1 (str): The first sequence. seq2 (str): The second sequence. Returns: int: The length of the longest common subsequence. # Your implementation goes here. ``` # Example Use: ```python print(longest_common_subsequence(\\"abcde\\", \\"ace\\")) # Output should be 3 print(longest_common_subsequence(\\"abc\\", \\"abc\\")) # Output should be 3 print(longest_common_subsequence(\\"abc\\", \\"def\\")) # Output should be 0 ``` # Explanation - In the first example, the longest common subsequence between \\"abcde\\" and \\"ace\\" is \\"ace\\", which has a length of 3. - In the second example, the longest common subsequence between \\"abc\\" and \\"abc\\" is \\"abc\\", which has a length of 3. - In the third example, there is no common subsequence between \\"abc\\" and \\"def\\", so the output is 0. # Constraints: - The input sequences will only consist of lowercase alphabets (a-z). - Length of seq1 (n) and seq2 (m) will be in the range 1 <= n, m <= 1000. # Performance: - Ensure that the solution has a time complexity of O(n*m) where n is the length of seq1 and m is the length of seq2. # Approach: - Use dynamic programming to solve this problem efficiently. - Create a 2D table where `dp[i][j]` represents the length of the LCS of the first `i` characters of `seq1` and the first `j` characters of `seq2`. - Fill the table using the relation: - `dp[i][j] = dp[i-1][j-1] + 1` if `seq1[i-1] == seq2[j-1]` - Otherwise, `dp[i][j] = max(dp[i-1][j], dp[i][j-1])` - The length of LCS will be found at `dp[n][m]`.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> int: Returns the length of the longest common subsequence between seq1 and seq2. Parameters: seq1 (str): The first sequence. seq2 (str): The second sequence. Returns: int: The length of the longest common subsequence. n = len(seq1) m = len(seq2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"# Coding Question Implement a function that verifies if the given binary tree is a complete binary tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_complete_binary_tree(root: TreeNode) -> bool: pass ``` # Input Format - `root`: The root node of a binary tree. # Output Format - Returns a boolean value `True` if the binary tree is a complete binary tree, otherwise `False`. # Constraints - The number of nodes in the tree will be in the range `[1, 1000]`. - Node values will be integers in the range `[-1000, 1000]`. # Examples ```python # Example 1 # Input root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) # Output: True print(is_complete_binary_tree(root)) # Output: True # Example 2 # Input root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # Output: False print(is_complete_binary_tree(root)) # Output: False ``` # Notes A binary tree is complete if all levels are completely filled except possibly the last level, and the last level has all nodes as far left as possible. Use level-order traversal (BFS) to check whether every node fulfills these conditions. This problem usually involves using a queue to facilitate the traversal.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_complete_binary_tree(root: TreeNode) -> bool: if not root: return True queue = [root] end = False while queue: node = queue.pop(0) if node is None: end = True else: if end: return False queue.append(node.left) queue.append(node.right) return True"},{"question":"# Longest Consecutive Sequence in an Array Design algorithms to find the longest consecutive sequence of integers from an unsorted list. Your solution should aim to accomplish this in linear time, utilizing a hash-based approach for efficiency. Task 1: Implementing the Longest Consecutive Sequence Finder Write a function, `longest_consecutive(nums: list[int]) -> int`, that takes an unsorted list of integers and returns the length of the longest consecutive elements sequence. Input: - A list of integers `nums`. Output: - An integer representing the length of the longest consecutive elements sequence. Example: ```python # Given integers nums = [100, 4, 200, 1, 3, 2] # Find the length of the longest consecutive sequence result = longest_consecutive(nums) # Output: 4, because the longest consecutive sequence is [1, 2, 3, 4] ``` Constraints: - The length of list `nums` is such that `0 ≤ len(nums) ≤ 105`. - Each element in `nums` is an integer within the range `-109` to `109`. Performance Requirements: - The solution should achieve a time complexity of `O(n)` where `n` is the length of the input list. # Hints: - Use a HashSet to achieve the desired linear time complexity. - Iterate through the list and ensure that you explore the beginning of each possible sequence. This problem tests your ability to work with hash-based data structures for efficient lookup and insertion operations as well as your understanding of sequence detection within an unsorted aggregation of elements.","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: # Start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Binary Search Tree: Inorder Predecessor and Successor **Scenario**: You are required to perform operations on a Binary Search Tree (BST). Specifically, your task involves finding the inorder predecessor and successor of a given key in the BST. This problem is frequently encountered in numerous applications, such as database indexing and range queries. **Task**: Implement a class **BST** featuring the ability to insert nodes, and find the inorder predecessor and successor for a given key in a BST. **Function Signatures**: ```python class Node: def __init__(self, data: int) -> None: self.data = data self.left = None self.right = None class BST: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: pass def find_predecessor(self, key: int) -> int: pass def find_successor(self, key: int) -> int: pass ``` # Constraints: 1. **Inputs**: - `key`: Integer, the value whose predecessor and successor need to be found. 2. **Outputs**: - The predecessor and successor of the given key, if they exist. If either does not exist, return `None` for that value. **Example**: ```python # Example of inserting nodes and finding predecessor/successor: bst = BST() keys = [20, 8, 22, 4, 12, 10, 14] for key in keys: bst.insert(key) # Find predecessor and successor for key 10 pred = bst.find_predecessor(10) succ = bst.find_successor(10) print(f\\"Predecessor: {pred}, Successor: {succ}\\") # Expected Output: Predecessor: 8, Successor: 12 # Find predecessor and successor for key 8 pred = bst.find_predecessor(8) succ = bst.find_successor(8) print(f\\"Predecessor: {pred}, Successor: {succ}\\") # Expected Output: Predecessor: 4, Successor: 10 # Find predecessor and successor for a non-existing key 15 pred = bst.find_predecessor(15) succ = bst.find_successor(15) print(f\\"Predecessor: {pred}, Successor: {succ}\\") # Expected Output: Predecessor: 14, Successor: 20 ``` # Performance Requirements: 1. Ensure that the insertion operation maintains the properties of a BST. 2. Optimize the predecessor and successor search operations with respect to the typical time complexity constraints of a BST. 3. Handle edge cases such as finding predecessors and successors at the boundary nodes (minimum and maximum values) efficiently.","solution":"class Node: def __init__(self, data: int) -> None: self.data = data self.left = None self.right = None class BST: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: self.root = self._insert_rec(self.root, key) def _insert_rec(self, root: Node, key: int) -> Node: if root is None: return Node(key) if key < root.data: root.left = self._insert_rec(root.left, key) else: root.right = self._insert_rec(root.right, key) return root def find_predecessor(self, key: int) -> int: node, pred = self.root, None while node: if key <= node.data: node = node.left else: # Potential predecessor pred = node node = node.right if pred: return pred.data return None def find_successor(self, key: int) -> int: node, succ = self.root, None while node: if key >= node.data: node = node.right else: # Potential successor succ = node node = node.left if succ: return succ.data return None"},{"question":"# Coding Assessment Question Consider the provided `BinaryTree` class implementation. Your task is to enhance the class with the following two operations: 1. `find_lca(node1, node2)` - Finds the lowest common ancestor (LCA) of two given nodes in the binary tree. 2. `is_balanced()` - Checks if the binary tree is height-balanced. A binary tree is balanced if, for every node, the height difference between the left and right subtree is at most 1. Implement the following methods with the exact signatures and constraints as shown. Expected Input and Output Formats: ```python class BinaryTree: ... def find_lca(self, node1: int, node2: int) -> int: Finds the lowest common ancestor of two given nodes in the binary tree. >>> bt = BinaryTree() >>> bt.insert(20) >>> bt.insert(8) >>> bt.insert(22) >>> bt.insert(4) >>> bt.insert(12) >>> bt.insert(10) >>> bt.insert(14) >>> bt.find_lca(10, 14) 12 >>> bt.find_lca(4, 22) 20 >>> bt.find_lca(4, 8) 8 def is_balanced(self) -> bool: Checks if the binary tree is height-balanced. >>> bt = BinaryTree() >>> bt.insert(1) >>> bt.insert(2) >>> bt.insert(3) >>> bt.insert(4) >>> bt.is_balanced() False >>> bt = BinaryTree() >>> bt.insert(3) >>> bt.insert(2) >>> bt.insert(5) >>> bt.insert(1) >>> bt.insert(4) >>> bt.insert(6) >>> bt.is_balanced() True ``` Constraints: - The `find_lca` method should not recreate the tree structure but operate on the existing tree. - Performance targets: - Finding LCA should ideally be done in O(N) time complexity where N is the number of nodes. - Checking if the tree is balanced should also aim for O(N) time complexity. **Scenario/Context**: Your task involves maintaining a large directory structure as a binary tree where files and folders are represented as nodes. You frequently need to find the lowest common ancestor of given nodes and ensure that your tree remains balanced for efficient querying and updates. Implement these functionalities to facilitate effective directory management.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.key: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find_lca(self, node1, node2): def _find_lca(root, node1, node2): if root is None: return None if root.key == node1 or root.key == node2: return root left_lca = _find_lca(root.left, node1, node2) right_lca = _find_lca(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca lca_node = _find_lca(self.root, node1, node2) return lca_node.key if lca_node else None def is_balanced(self): def _check_height_and_balance(root): if root is None: return 0, True left_height, left_balanced = _check_height_and_balance(root.left) right_height, right_balanced = _check_height_and_balance(root.right) current_height = max(left_height, right_height) + 1 if not left_balanced or not right_balanced: return current_height, False if abs(left_height - right_height) > 1: return current_height, False return current_height, True _, balanced = _check_height_and_balance(self.root) return balanced"},{"question":"# Problem Statement Given a linked list, implement a function to reorder it such that you move the last node to the head, the second last node to the second position, and so on. The order of the nodes should be reversed and interleaved. Specifically, you will need to implement the following function: `reorder_linked_list(head)` This function should reorder the linked list as described and return the new head of the list. # Input * The function takes a single argument: * `head`: The head node of the linked list (with type `ListNode`). # Output * The function should return: * The head of the reordered linked list. # Constraints * The number of nodes in the linked list is in the range [0, 1000]. * Node values are in the range [-1000, 1000]. # Examples ```python # Define helper classes/functions from __future__ import annotations from dataclasses import dataclass @dataclass class ListNode: val: int next: ListNode | None = None def make_list() -> ListNode: return ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) def print_list(head: ListNode) -> list: result = [] while head: result.append(head.val) head = head.next return result # Example head = make_list() reordered_head = reorder_linked_list(head) assert print_list(reordered_head) == [4, 1, 3, 2] ``` # Detailed Requirements 1. **Reordering Process**: Implement `reorder_linked_list(head)` to reorder the linked list by interleaving the nodes from the end to the beginning: * Hint: Use a two-pointer approach to find the middle of the linked list, then reverse the second half, and finally merge the two halves in the required order. 2. **Edge Cases**: Ensure to handle all edge cases, such as an empty linked list or a linked list with a single node, with the function returning the original list in such cases. # Note: * Make sure your solution operates in O(n) time complexity where n is the number of nodes in the linked list. * Avoid using extra space more than O(1) for the input storage itself.","solution":"from __future__ import annotations from dataclasses import dataclass @dataclass class ListNode: val: int next: ListNode | None = None def reorder_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head # Find the middle of the linked list slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Merge two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first, second = temp1, temp2 return head"},{"question":"Palindrome Partitioning You are tasked with implementing a function that partitions a given string into the minimum number of palindromic substrings. A palindromic substring is a substring that reads the same backward as forward. To achieve this, you will write several helper functions and the main function `min_palindrome_partitions` which assembles the overall solution. Requirements: 1. **Palindrome Check**: - Implement the function `is_palindrome(s, start, end)` that checks if the substring `s[start:end+1]` is a palindrome. 2. **Palindrome Cuts**: - Implement the function `min_cuts(s, start, end)` that computes the minimum cuts needed to partition the substring `s[start:end+1]` into palindromic substrings. 3. **Main Function**: - Implement the function `min_palindrome_partitions(s)` that returns the minimum number of palindromic substrings the input string can be partitioned into. # Inputs and Outputs **Function**: `is_palindrome` - **Input**: - `s` (str): Input string - `start` (int): Starting index of the substring. - `end` (int): Ending index of the substring. - **Output**: - Boolean: `True` if the substring `s[start:end+1]` is a palindrome, `False` otherwise. **Function**: `min_cuts` - **Input**: - `s` (str): Input string - `start` (int): Starting index of the substring. - `end` (int): Ending index of the substring. - **Output**: - Integer: Minimum number of cuts required. **Function**: `min_palindrome_partitions` - **Input**: - `s` (str): Input string. - **Output**: - Integer: Minimum number of palindromic substrings. # Example ```python def is_palindrome(s, start, end): # Your implementation here def min_cuts(s, start, end): # Your implementation here def min_palindrome_partitions(s): # Your implementation here # Example s = \\"aab\\" print(min_palindrome_partitions(s)) # Output: 1 (\'aa\' | \'b\') ``` # Performance Requirements: - The solution should handle strings up to length 2000 efficiently. - Aim to minimize the computational complexity, using dynamic programming where applicable.","solution":"def is_palindrome(s, start, end): Check if the substring s[start:end+1] is a palindrome. while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True def min_cuts(s, start, end): Compute the minimum cuts needed to partition the substring s[start:end+1] into palindromic substrings. n = end - start + 1 dp = [0] * (n + 1) for i in range(n + 1): dp[i] = i - 1 for i in range(1, n + 1): for j in range(i): if is_palindrome(s, start + j, start + i - 1): dp[i] = min(dp[i], dp[j] + 1) return dp[n] def min_palindrome_partitions(s): Return the minimum number of palindromic substrings the input string can be partitioned into. return min_cuts(s, 0, len(s) - 1)"},{"question":"# Question You are given a list of `n` integers where the integers already form a binary search tree represented in level-order (breadth-first search) traversal format. Write a function `is_valid_bst` to determine if the provided list actually represents a valid binary search tree (BST). **Function Signature**: ```python def is_valid_bst(nums: list[int]) -> bool: ``` **Input**: - `nums` (list of int): List representing the values of a binary search tree in level-order traversal. The length of the list is `n`. **Output**: - A boolean value: `True` if the list represents a valid BST according to binary search tree properties, `False` otherwise. **Constraints**: - 1 <= n <= 10^5 - Each `nums[i]` is a unique integer. # Examples ```python # Example 1 nums = [10, 5, 15, 3, 7, 12, 18] print(is_valid_bst(nums)) # Output: True # Example 2 nums = [10, 15, 5, 3, 7, 12, 18] print(is_valid_bst(nums)) # Output: False # Example 3 nums = [2, 1, 3] print(is_valid_bst(nums)) # Output: True # Example 4 nums = [5, 1, 4, None, None, 3, 6] print(is_valid_bst(nums)) # Output: False ``` **Notes**: - A binary search tree is valid if for every node, all values to the left subtree are less than the node\'s value, and all values to the right subtree are greater than the node\'s value. - The `nums` list will not necessarily form a complete binary tree; there might be `None` values representing absent children. - The function should efficiently validate the BST properties by traversing the tree in the appropriate manner.","solution":"def is_valid_bst(nums): Determines if the provided list represents a valid binary search tree (BST) in level-order traversal. # Helper function to recursively check the validity of a BST def validate_bst(index, low, high): if index >= len(nums) or nums[index] is None: return True val = nums[index] if val <= low or val >= high: return False left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 return (validate_bst(left_child_index, low, val) and validate_bst(right_child_index, val, high)) return validate_bst(0, float(\'-inf\'), float(\'inf\'))"},{"question":"# Sum of Multiple Arrays In this task, you are required to implement a function that takes multiple arrays of integers and returns the sum of each array. The function should handle an arbitrary number of arrays, and each array can have a different length. Requirements: - The function should accept multiple arrays as input. - It should return a list containing the sum of each input array. - If an input array is empty, its sum should be considered as 0. Function Signature: ```python def sum_of_multiple_arrays(*arrays: List[List[int]]) -> List[int]: Calculate the sum of each provided array. Parameters: *arrays (List[List[int]]): Variable number of arrays containing integers. Returns: List[int]: A list where each element is the sum of the corresponding input array. ``` Constraints: - Each array contains integers only. - The number of arrays and the number of elements within each array can vary. - The sum of an individual array shouldn\'t exceed the typical integer limits in Python. Example Usage: ```python # Sum of each array print(sum_of_multiple_arrays([1, 2, 3], [4, 5], [-1, -2, -3], [])) # Should output: [6, 9, -6, 0] print(sum_of_multiple_arrays([10, 20], [30, 40, 50])) # Should output: [30, 120] ``` Performance Requirements: - The function should efficiently handle a large number of arrays and elements within them. - Ensure the function runs in linear time relative to the total number of integers across all arrays.","solution":"def sum_of_multiple_arrays(*arrays): Calculate the sum of each provided array. Parameters: *arrays (tuple): Variable number of arrays containing integers. Returns: List[int]: A list where each element is the sum of the corresponding input array. return [sum(array) for array in arrays]"},{"question":"Problem Statement You are given a list of integers, and your task is to find the maximum product of any two distinct elements in the list. Write a function `max_product_of_two` that takes a list of integers and returns the maximum product of any two distinct elements. # Input * A list of integers `numbers` with at least two elements. # Output * An integer representing the maximum product of any two distinct elements in the list, or an appropriate error message if the list contains fewer than two elements. # Function Signature ```python def max_product_of_two(numbers: List[int]) -> Union[int, str]: ``` # Examples ```python max_product_of_two([1, 2, 3]) # Expected output: 6 max_product_of_two([-10, -20, 5, 3]) # Expected output: 200 max_product_of_two([0, 2, 4, -1]) # Expected output: 8 max_product_of_two([1]) # Expected output: \'Invalid input\' max_product_of_two([]) # Expected output: \'Invalid input\' ``` # Constraints * The list will contain at least `0` and at most `10^6` integers. * The elements in the list are integers and the values are between `-10^9` and `10^9`. # Notes * Ensure the function gracefully handles cases where the input list contains fewer than two elements by returning an appropriate error message.","solution":"from typing import List, Union def max_product_of_two(numbers: List[int]) -> Union[int, str]: if len(numbers) < 2: return \'Invalid input\' # Initialize the two largest and two smallest numbers max1 = max2 = float(\'-inf\') min1 = min2 = float(\'inf\') # Iterate through each number in the list for num in numbers: # Update the two largest numbers if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num # Update the two smallest numbers if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # The maximum product is either the product of the two largest # numbers or the product of the two smallest numbers (if both are negatives) return max(max1 * max2, min1 * min2)"},{"question":"# Coding Exercise: Reconstruct the Itinerary from Flight Tickets You are given a list of flight tickets, represented as directed edges between departure and arrival airports. Each airport is identified by a string code (e.g., \\"JFK\\"). Your task is to reconstruct the itinerary in lexical order starting from the airport \\"JFK\\". Implement a function `reconstruct_itinerary(tickets: List[Tuple[str, str]]) -> List[str]` that returns the complete itinerary starting from \\"JFK\\" in the lexicographically smallest order possible. If multiple valid itineraries exist, return the one that is smallest in lexical order. Input * `tickets` (1 ≤ len(tickets) ≤ 300): A list of tuples where each tuple `(from, to)` represents a directed edge from airport `from` to airport `to`. Output * A list of strings representing the itinerary starting from \\"JFK\\". Constraints * You may assume all airports are represented by three-letter codes and all tickets form at least one valid itinerary. * You must use all the given tickets exactly once. * The itinerary must start at \\"JFK\\". # Example ```python def reconstruct_itinerary(tickets: List[Tuple[str, str]]) -> List[str]: # Write your code here. # Example Usage tickets = [(\\"MUC\\", \\"LHR\\"), (\\"JFK\\", \\"MUC\\"), (\\"SFO\\", \\"SJC\\"), (\\"LHR\\", \\"SFO\\")] print(reconstruct_itinerary(tickets)) # Expected Output: [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] tickets = [(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")] print(reconstruct_itinerary(tickets)) # Expected Output: [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"] ``` # Hints 1. **Hierholzer\'s Algorithm**: Consider using Hierholzer’s algorithm to find an Eulerian path or circuit, which will allow you to explore all tickets exactly once. 2. **Recursive Depth-First Search (DFS)**: Utilize recursive DFS to construct the path, ensuring you visit nodes in lexicographical order when multiple edges exist from the same node. 3. **Graph Representation**: Use an adjacency list to represent the graph, sorted lexicographically to guarantee the smallest order itinerary.","solution":"from typing import List, Tuple from collections import defaultdict, deque def reconstruct_itinerary(tickets: List[Tuple[str, str]]) -> List[str]: graph = defaultdict(deque) # Create the graph, sorting each adjacency list lexicographically for start, end in sorted(tickets): graph[start].append(end) itinerary = [] def dfs(airport): while graph[airport]: next_airport = graph[airport].popleft() dfs(next_airport) itinerary.append(airport) # Start the journey from \'JFK\' dfs(\'JFK\') # Since we add airports after visiting the end of their edges, reverse the result return itinerary[::-1]"},{"question":"# Problem Statement You are given a sequence of `n` integers. You need to perform a series of queries on this sequence, where each query either updates an element in the sequence or finds and returns the minimum element in a specified range. Write two classes: 1. `RangeQuery(sequence: List[int])`: This class initializes with a sequence of integers and supports two methods: - `update(index: int, value: int) -> None`: This method updates the element at the specified index to the given value. - `range_min(left: int, right: int) -> int`: This method returns the minimum element in the inclusive range between `left` and `right` indices. # Input: * `sequence` (List[int]): The initial list of integers. * For the `update` method: - `index` (int): The index of the element to be updated (0-based). - `value` (int): The new value to be placed at the specified index. * For the `range_min` method: - `left` (int): The starting index of the range (0-based). - `right` (int): The ending index of the range (0-based). # Output: * For the `update` method: - This method does not return anything. * For the `range_min` method: - It returns an integer denoting the minimum element in the specified range from `left` to `right` inclusive. # Constraints: * 1 <= n <= 10^5 (The number of elements in the sequence) * -10^9 <= sequence[i] <= 10^9 * The update and range query operations will be called at most 10^5 times. # Example: ```python sequence = [5, 2, 4, 3, 1] rq = RangeQuery(sequence) # Initialize with the sequence [5, 2, 4, 3, 1] assert rq.range_min(0, 2) == 2 # The minimum between index 0 and 2 is 2 rq.update(1, 6) # Now the sequence is [5, 6, 4, 3, 1] assert rq.range_min(0, 2) == 4 # The minimum between index 0 and 2 is 4 rq.update(3, -1) # Now the sequence is [5, 6, 4, -1, 1] assert rq.range_min(2, 4) == -1 # The minimum between index 2 and 4 is -1 ``` # Note: * The `RangeQuery` class should be implemented efficiently to handle both `update` and `range_min` operations quickly. * Consider using data structures that allow for efficient range queries and point updates, such as Segment Trees or Fenwick Trees.","solution":"class RangeQuery: def __init__(self, sequence): self.sequence = sequence self.n = len(sequence) self.segment_tree = [0] * (4 * self.n) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: self.segment_tree[node] = self.sequence[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(left_child, start, mid) self.build(right_child, mid + 1, end) self.segment_tree[node] = min(self.segment_tree[left_child], self.segment_tree[right_child]) def update(self, index, value): def _update(node, start, end): if start == end: self.sequence[index] = value self.segment_tree[node] = value else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= index <= mid: _update(left_child, start, mid) else: _update(right_child, mid + 1, end) self.segment_tree[node] = min(self.segment_tree[left_child], self.segment_tree[right_child]) _update(0, 0, self.n - 1) def range_min(self, left, right): def _range_min(node, start, end, l, r): if r < start or end < l: return float(\'inf\') if l <= start and end <= r: return self.segment_tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_min = _range_min(left_child, start, mid, l, r) right_min = _range_min(right_child, mid + 1, end, l, r) return min(left_min, right_min) return _range_min(0, 0, self.n - 1, left, right)"},{"question":"# Context You are building a recommendation system that calculates user-item interaction scores based on various user and item features. Your task is to implement a Matrix Factorization algorithm using Stochastic Gradient Descent (SGD) to optimize the latent factors for users and items. # Requirements 1. Implement the Matrix Factorization using SGD to decompose the user-item interaction matrix. 2. Optimize for the given user features, item features, and interaction matrix. 3. Ensure correct calculations, updates to latent factors, and convergence checks. # Input/Output 1. **Function**: `matrix_factorization(interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations)` - **Arguments**: - `interaction_matrix`: 2D list or array representing user-item interactions. Dimensions: `(num_users, num_items)`. - `user_features`: 2D list or array representing user features. Dimensions: `(num_users, num_user_features)`. - `item_features`: 2D list or array representing item features. Dimensions: `(num_items, num_item_features)`. - `latent_dim`: Integer, the number of latent dimensions for user and item factors. - `learning_rate`: Float value, learning rate for SGD. - `iterations`: Integer, the number of iterations for SGD. - **Returns**: Tuple `(user_latent_factors, item_latent_factors)` representing the optimized latent factors for users and items. # Constraints - Assume no missing values in the interaction matrix. - Learning rate and number of iterations are predefined. - Features and interaction matrix are given in proper format. # Example ```python interaction_matrix = [ [5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4], ] user_features = [ [0.2, 0.8], [0.5, 0.5], [0.9, 0.1], [0.4, 0.6], [0.1, 0.9], ] item_features = [ [0.3, 0.7], [0.6, 0.4], [0.7, 0.3], [0.8, 0.2], ] latent_dim = 3 learning_rate = 0.01 iterations = 1000 user_latent_factors, item_latent_factors = matrix_factorization( interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations ) print(user_latent_factors) print(item_latent_factors) # Output would be the optimized user and item latent factors. ``` # Criteria - Correct implementation of Matrix Factorization using SGD. - Proper convergence checks and updates to latent factors. - Solution efficiency and correct handling of the given data structures.","solution":"import numpy as np def matrix_factorization(interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations): num_users, num_items = len(interaction_matrix), len(interaction_matrix[0]) user_features = np.array(user_features) item_features = np.array(item_features) interaction_matrix = np.array(interaction_matrix) # Initialize user and item latent factors randomly user_latent_factors = np.random.rand(num_users, latent_dim) item_latent_factors = np.random.rand(num_items, latent_dim) for iteration in range(iterations): for i in range(num_users): for j in range(num_items): if interaction_matrix[i][j] > 0: # Calculate the error of the prediction prediction = np.dot(user_latent_factors[i,:], item_latent_factors[j,:]) error = interaction_matrix[i][j] - prediction # Update user and item latent factors for k in range(latent_dim): user_latent_factors[i][k] += learning_rate * (2 * error * item_latent_factors[j][k]) item_latent_factors[j][k] += learning_rate * (2 * error * user_latent_factors[i][k]) return user_latent_factors, item_latent_factors"},{"question":"Given a list of file paths represented by a nested dictionary structure, implement a function `flatten_paths(nested_paths: dict) -> dict` that flattens the dictionary into a single dictionary where the keys are the file paths and the values are the file contents. # Input - **Dictionary** representing nested file paths, where keys are folder names, and values can be either another dictionary (representing sub-folders) or a string (representing file content). # Output - **Dictionary** where: - Keys are strings representing the full path to the files. - Values are strings representing the file contents. # Constraints 1. The nested dictionary can contain a maximum depth of (10) levels. 2. Each folder and file name consists of alphanumeric characters and/or underscores. 3. The total number of files and folders can be up to (10^4). # Example ```python nested_paths_1 = { \\"folder1\\": { \\"folder2\\": { \\"file1.txt\\": \\"content1\\", \\"file2.txt\\": \\"content2\\" }, \\"file3.txt\\": \\"content3\\" }, \\"folder3\\": { \\"file4.txt\\": \\"content4\\" } } print(flatten_paths(nested_paths_1)) # Output: { # \\"folder1/folder2/file1.txt\\": \\"content1\\", # \\"folder1/folder2/file2.txt\\": \\"content2\\", # \\"folder1/file3.txt\\": \\"content3\\", # \\"folder3/file4.txt\\": \\"content4\\" # } nested_paths_2 = { \\"a\\": { \\"b\\": { \\"c.txt\\": \\"data\\" } } } print(flatten_paths(nested_paths_2)) # Output: {\\"a/b/c.txt\\": \\"data\\"} ``` Notes - Construct the full paths using \\"/\\" to separate folder and file names. - Consider using a recursive approach to traverse the nested dictionary and build the paths properly. Implement the function `flatten_paths(nested_paths: dict) -> dict` by completing this task.","solution":"def flatten_paths(nested_paths: dict, parent_key: str = \'\') -> dict: Flattens the nested dictionary of file paths into a single dictionary where keys are the file paths and values are the file contents. flat_paths = {} for key, value in nested_paths.items(): new_key = f\\"{parent_key}/{key}\\" if parent_key else key if isinstance(value, dict): flat_paths.update(flatten_paths(value, new_key)) else: flat_paths[new_key] = value return flat_paths"},{"question":"***Graph Traversal and Shortest Path*** # Context In this challenge, you will implement a solution for finding the shortest path in a weighted graph. The graph is represented as an adjacency matrix where the value at cell `(i, j)` represents the weight of the edge from node `i` to node `j`. If there is no edge between two nodes, the weight is considered as infinity (`float(\'inf\')`). # Task Implement the functions necessary to find the shortest path between two nodes in a weighted graph using Dijkstra\'s Algorithm. # Functions to Implement 1. **initialize_graph(n: int) -> list[list[float]]** - Initialize an `n x n` adjacency matrix for the graph with `float(\'inf\')` representing no direct edge. 2. **add_edge(graph: list[list[float]], u: int, v: int, weight: float) -> None** - Add or update an edge between node `u` and node `v` with the specified weight in the adjacency matrix. 3. **dijkstra(graph: list[list[float]], start: int) -> list[float]** - Implement Dijkstra\'s Algorithm to find the shortest path from the `start` node to all other nodes in the graph. 4. **shortest_path(graph: list[list[float]], start: int, end: int) -> float** - Find the shortest path from the `start` node to the `end` node using the results from Dijkstra\'s Algorithm. # Constraints - The number of nodes `n` should be at least 2 and at most 100. - Weights are non-negative and can vary from 0 to 1000. - Avoid using any third-party libraries for implementing the algorithm. # Input/Output Format - The main function `shortest_path(graph: list[list[float]], start: int, end: int) -> float` takes an adjacency matrix `graph`, and two integers `start` and `end`, indicating the start and end nodes respectively. - Returns a float representing the shortest path weight. If no path exists, return `float(\'inf\')`. # Example Usage ```python >>> graph = initialize_graph(5) >>> add_edge(graph, 0, 1, 10) >>> add_edge(graph, 1, 2, 1) >>> add_edge(graph, 2, 3, 4) >>> add_edge(graph, 3, 4, 2) >>> add_edge(graph, 0, 4, 15) >>> shortest_path(graph, 0, 4) 13.0 >>> shortest_path(graph, 0, 3) 15.0 ``` # Requirements - Ensure your solution handles edge cases such as graphs with nodes having no outgoing edges or graphs where some nodes are completely disconnected. - Provide efficient implementations for initializing and manipulating large graphs within the given constraints.","solution":"import heapq def initialize_graph(n: int) -> list[list[float]]: Initialize an n x n adjacency matrix for the graph with float(\'inf\') representing no direct edge. return [[float(\'inf\')] * n for _ in range(n)] def add_edge(graph: list[list[float]], u: int, v: int, weight: float) -> None: Add or update an edge between node u and node v with the specified weight in the adjacency matrix. graph[u][v] = weight def dijkstra(graph: list[list[float]], start: int) -> list[float]: Implement Dijkstra\'s Algorithm to find the shortest path from the start node to all other nodes in the graph. n = len(graph) dist = [float(\'inf\')] * n dist[start] = 0 visited = [False] * n pq = [(0, start)] # (distance, node) while pq: current_distance, u = heapq.heappop(pq) if visited[u]: continue visited[u] = True for v in range(n): if graph[u][v] != float(\'inf\') and not visited[v]: new_distance = current_distance + graph[u][v] if new_distance < dist[v]: dist[v] = new_distance heapq.heappush(pq, (new_distance, v)) return dist def shortest_path(graph: list[list[float]], start: int, end: int) -> float: Find the shortest path from the start node to the end node using the results from Dijkstra\'s Algorithm. dist = dijkstra(graph, start) return dist[end]"},{"question":"# Coding Assessment Question **Scenario**: You are part of a development team working on a project that involves a large dataset of user actions. For efficient processing, you need to keep track of the most recent actions by users in an ordered manner. One of the useful data structures for this task is a Balanced Binary Search Tree (BST). To ensure you can effectively implement and utilize such a tree, you need to perform specific tasks on it. **Task**: Implement the `BalancedBST` class by completing the following methods: 1. **insert**: ```python def insert(self, node: Optional[TreeNode], key: int) -> TreeNode: ``` - **Input**: - `node` (TreeNode or None): The root node of the BST or a subtree. - `key` (int): The value to be inserted into the tree. - **Output**: Returns the new root of the BST (or subtree) after insertion. 2. **delete**: ```python def delete(self, node: Optional[TreeNode], key: int) -> Optional[TreeNode]: ``` - **Input**: - `node` (TreeNode or None): The root node of the BST or a subtree. - `key` (int): The value to be deleted from the tree. - **Output**: Returns the new root of the BST (or subtree) after deletion. 3. **find_min**: ```python def find_min(self, node: TreeNode) -> TreeNode: ``` - **Input**: - `node` (TreeNode): The root node of the tree or subtree. - **Output**: Returns the TreeNode with the minimum key value. 4. **find_max**: ```python def find_max(self, node: TreeNode) -> TreeNode: ``` - **Input**: - `node` (TreeNode): The root node of the tree or subtree. - **Output**: Returns the TreeNode with the maximum key value. 5. **in_order_traversal**: ```python def in_order_traversal(self, node: Optional[TreeNode]) -> list[int]: ``` - **Input**: - `node` (TreeNode or None): The root node of the BST or a subtree. - **Output**: Returns a list of keys in in-order traversal manner. **Constraints**: - Assume the values to be inserted into the BST will always be unique and within the range `[-10^6, 10^6]`. - The tree should remain height-balanced after any insertion or deletion operation. **Example**: ```python bst = BalancedBST() root = None # Insert elements root = bst.insert(root, 10) root = bst.insert(root, 20) root = bst.insert(root, 5) root = bst.insert(root, 6) root = bst.insert(root, 3) # In-order traversal print(bst.in_order_traversal(root)) # Output: [3, 5, 6, 10, 20] # Find minimum and maximum print(bst.find_min(root).key) # Output: 3 print(bst.find_max(root).key) # Output: 20 # Delete element root = bst.delete(root, 6) print(bst.in_order_traversal(root)) # Output: [3, 5, 10, 20] ``` Implement the `BSTNode` and `BalancedBST` classes ensuring that the tree remains balanced after any insertion or deletion operation. The tree nodes may carry additional properties to assist in keeping the balance, ensuring the tree\'s efficient performance.","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class BalancedBST: def get_height(self, node: TreeNode) -> int: if not node: return 0 return node.height def get_balance(self, node: TreeNode) -> int: if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def right_rotate(self, y: TreeNode) -> TreeNode: x = y.left T2 = x.right x.right = y y.left = T2 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1 return x def left_rotate(self, x: TreeNode) -> TreeNode: y = x.right T2 = y.left y.left = x x.right = T2 x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def insert(self, node: TreeNode, key: int) -> TreeNode: if not node: return TreeNode(key) if key < node.key: node.left = self.insert(node.left, key) else: node.right = self.insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self.right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self.left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self.left_rotate(node.left) return self.right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def find_min(self, node: TreeNode) -> TreeNode: if node is None or node.left is None: return node return self.find_min(node.left) def find_max(self, node: TreeNode) -> TreeNode: if node is None or node.right is None: return node return self.find_max(node.right) def delete(self, node: TreeNode, key: int) -> TreeNode: if not node: return node if key < node.key: node.left = self.delete(node.left, key) elif key > node.key: node.right = self.delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self.find_min(node.right) node.key = temp.key node.right = self.delete(node.right, temp.key) if not node: return node node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1 balance = self.get_balance(node) # Left Left Case if balance > 1 and self.get_balance(node.left) >= 0: return self.right_rotate(node) # Left Right Case if balance > 1 and self.get_balance(node.left) < 0: node.left = self.left_rotate(node.left) return self.right_rotate(node) # Right Right Case if balance < -1 and self.get_balance(node.right) <= 0: return self.left_rotate(node) # Right Left Case if balance < -1 and self.get_balance(node.right) > 0: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def in_order_traversal(self, node: TreeNode) -> list[int]: if node is None: return [] return self.in_order_traversal(node.left) + [node.key] + self.in_order_traversal(node.right)"},{"question":"# Context: A robot is placed on an infinite 2D grid where it starts at position (0, 0). The robot can receive a string of directional commands to move: \'U\' for up, \'D\' for down, \'L\' for left, and \'R\' for right. The robot will follow these commands sequentially to adjust its position on the grid. # Task: Write a function `robot_final_position(commands)` that takes a string representing a sequence of commands and returns the final coordinates of the robot after executing all the commands. # Input: - `commands`: a string consisting of characters \'U\', \'D\', \'L\', \'R\', with a length between 1 and 1,000,000 inclusive. # Output: - A tuple of two integers representing the final coordinates (x, y) of the robot. # Constraints: - The string length will not exceed 1,000,000 characters. - Each command in the string will be a valid character (\'U\', \'D\', \'L\', \'R\'). # Examples: ```python commands = \\"UUUDDDLLRR\\" assert robot_final_position(commands) == (0, 0) commands = \\"UULDR\\" assert robot_final_position(commands) == (0, 1) commands = \\"LLLLDDDDRRRRUUUU\\" assert robot_final_position(commands) == (0, 0) ``` # Performance Requirements: - The function should efficiently handle the input constraints without excessive memory usage or time delays.","solution":"def robot_final_position(commands): Computes the final position of the robot after executing all commands. :param commands: A string of directions \'U\', \'D\', \'L\', \'R\' :return: A tuple (x, y) representing the final coordinates. x, y = 0, 0 for command in commands: if command == \'U\': y += 1 elif command == \'D\': y -= 1 elif command == \'L\': x -= 1 elif command == \'R\': x += 1 return (x, y)"},{"question":"# Problem Statement You are required to develop a utility that compresses a string using a simple form of run-length encoding (RLE). The goal is to replace consecutive repeating characters with the character followed by the count of repetitions, if the count is greater than one. # Requirements 1. Implement a function `compress_string(input_string: str) -> str` that: - Takes an input string and compresses it using run-length encoding. - If a character is not repeated consecutively, it remains unchanged in the output string. - If a character is repeated consecutively, it should be replaced by the character followed by the number of consecutive repeats. # Input - `input_string`: A string to be compressed using run-length encoding consisting of lowercase alphabetic characters. # Output - Returns the compressed string as per the run-length encoding rules. # Constraints - The input string will contain only lowercase alphabetic characters (a-z). - The length of the input string will be between 1 and 1000. # Example ```python result = compress_string(\\"aaabbcdddde\\") print(result) # Expected Output # \\"a3b2cd4e\\" result = compress_string(\\"abcdef\\") print(result) # Expected Output # \\"abcdef\\" ``` # Function Signature ```python def compress_string(input_string: str) -> str: # Your implementation here pass ```","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 prev_char = input_string[0] for char in input_string[1:]: if char == prev_char: count += 1 else: if count > 1: compressed.append(f\\"{prev_char}{count}\\") else: compressed.append(prev_char) prev_char = char count = 1 if count > 1: compressed.append(f\\"{prev_char}{count}\\") else: compressed.append(prev_char) return \\"\\".join(compressed)"},{"question":"# Scenario You are working on a financial analytics tool and need to create a time series forecasting model to predict future stock prices based on historical data. The tool should use a straightforward approach and be easily interpretable. You decide to implement a simple Moving Average model for this task. # Task Write a Python class `MovingAveragePredictor` that can take in a series of historical stock prices and forecast the future price using a simple moving average approach. # Class Structure ```python class MovingAveragePredictor: def __init__(self, window_size: int) -> None: Initialize the MovingAveragePredictor with the specified window size. pass def fit(self, historical_prices: list[float]) -> None: Fit the model on the historical stock prices. pass def predict(self) -> float: Predict the next stock price using the moving average model. pass ``` # Constraints and Requirements * `window_size` is an integer indicating the number of previous prices to consider for computing the moving average. * `historical_prices` is a list of floating-point numbers representing the historical stock prices, with at least `window_size` elements. * The `fit` method should store the historical prices in the instance. * The `predict` method should return a float representing the predicted next price based on the moving average of the last `window_size` prices. # Example ```python # Example usage hist_prices = [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] window_size = 3 predictor = MovingAveragePredictor(window_size) predictor.fit(hist_prices) print(predictor.predict()) # Expected Output: 108.0 ``` # Important Note Ensure your implementation returns correct predictions for various window sizes and handles edge cases appropriately, such as when historical prices contain less than `window_size` elements or invalid input values.","solution":"class MovingAveragePredictor: def __init__(self, window_size: int) -> None: Initialize the MovingAveragePredictor with the specified window size. :param window_size: The number of previous prices to consider for the moving average. self.window_size = window_size self.historical_prices = [] def fit(self, historical_prices: list[float]) -> None: Fit the model on the historical stock prices. :param historical_prices: List of historical stock prices. if len(historical_prices) < self.window_size: raise ValueError(f\\"Historical prices must contain at least {self.window_size} elements.\\") self.historical_prices = historical_prices def predict(self) -> float: Predict the next stock price using the moving average model. :return: Predicted next price. if len(self.historical_prices) < self.window_size: raise ValueError(f\\"Insufficient data to predict, need at least {self.window_size} prices.\\") recent_prices = self.historical_prices[-self.window_size:] return sum(recent_prices) / self.window_size"},{"question":"# Context You are required to implement a simple file system that supports basic operations on files and directories. The goal is to efficiently manage the file system and provide support for typical file system operations like adding files, creating directories, and searching for files or directories. # Task 1. Implement the `FileSystem` class with the required methods to manage files and directories. 2. Ensure the core functionalities such as adding files, creating directories, and searching are optimized for performance. 3. The core methods should handle nested structures (directories within directories) efficiently. # Expected Input and Output * **add_file(directory_path: str, file_name: str) -> None**: Adds a file with the given `file_name` to the specified `directory_path`. Raises an exception if the directory does not exist. * **create_directory(directory_path: str) -> None**: Creates a new directory at the specified `directory_path`. If the directory already exists, it does nothing. * **find(file_or_directory_name: str) -> List[str]**: Returns a list of all the paths where the specified `file_or_directory_name` exists. If it does not exist, returns an empty list. * **list_directory(directory_path: str) -> List[str]**: Lists all the files and directories in the specified `directory_path`. Raises an exception if the directory does not exist. # Constraints * The file system starts with a single root directory denoted by `/`. * All directory paths are specified using Unix-like notation (e.g., `/home/user/documents`). # Example ```python fs = FileSystem() fs.create_directory(\\"/home\\") fs.create_directory(\\"/home/user\\") fs.add_file(\\"/home/user\\", \\"file1.txt\\") fs.add_file(\\"/home/user\\", \\"file2.txt\\") print(fs.list_directory(\\"/home\\")) # Output: [\'user\'] print(fs.list_directory(\\"/home/user\\")) # Output: [\'file1.txt\', \'file2.txt\'] print(fs.find(\\"file1.txt\\")) # Output: [\'/home/user/file1.txt\'] print(fs.find(\\"file3.txt\\")) # Output: [] ``` # Performance Requirements * Ensure that directory and file operations are efficient and can handle deeply nested structures.","solution":"from collections import defaultdict class FileSystem: def __init__(self): self.fs = {\'/\': {\'type\': \'dir\', \'children\': defaultdict(dict)}} def _find_node(self, path): components = [comp for comp in path.split(\'/\') if comp] node = self.fs[\'/\'] for comp in components: if comp not in node[\'children\'] or node[\'children\'][comp][\'type\'] != \'dir\': raise FileNotFoundError(f\\"Directory \'{path}\' does not exist.\\") node = node[\'children\'][comp] return node def add_file(self, directory_path, file_name): try: dir_node = self._find_node(directory_path) except FileNotFoundError: raise FileNotFoundError(f\\"Directory \'{directory_path}\' does not exist.\\") if file_name in dir_node[\'children\']: raise FileExistsError(f\\"File \'{file_name}\' already exists.\\") dir_node[\'children\'][file_name] = {\'type\': \'file\'} def create_directory(self, directory_path): components = [comp for comp in directory_path.split(\'/\') if comp] node = self.fs[\'/\'] for comp in components: if comp not in node[\'children\']: node[\'children\'][comp] = {\'type\': \'dir\', \'children\': defaultdict(dict)} elif node[\'children\'][comp][\'type\'] != \'dir\': raise FileExistsError(f\\"Cannot create directory; \'{comp}\' already exists and is a file.\\") node = node[\'children\'][comp] def find(self, file_or_directory_name): results = [] def search(node, path): for name, info in node[\'children\'].items(): if name == file_or_directory_name: results.append(path + \'/\' + name) if info[\'type\'] == \'dir\': search(info, path + \'/\' + name) search(self.fs[\'/\'], \'\') return results def list_directory(self, directory_path): try: dir_node = self._find_node(directory_path) except FileNotFoundError: raise FileNotFoundError(f\\"Directory \'{directory_path}\' does not exist.\\") return sorted(list(dir_node[\'children\'].keys()))"},{"question":"# Problem Statement You are given a string containing lowercase English letters, and you need to return a list of all possible unique permutations of the string. # Function Signature ```python def string_permutations(s: str) -> list[str]: ``` # Input * `s`: A string (e.g., `\\"abc\\"`). # Output * A list of strings, where each string is a unique permutation of the input string. # Constraints * The length of string `s` will be at most 10. * All characters in `s` will be lowercase English letters. # Requirements 1. The solution should generate all unique permutations. 2. Duplicates in the input string should not result in duplicate permutations in the output. # Example ```python >>> string_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> string_permutations(\\"aab\\") [\\"aab\\", \\"aba\\", \\"baa\\"] >>> string_permutations(\\"a\\") [\\"a\\"] ``` # Notes * You may assume that the input string will contain only lowercase English letters. * Consider edge cases such as an empty string or a string with all identical characters. # Performance * Ensure your implementation is efficient and handles the permutations generation within the given constraints.","solution":"from itertools import permutations def string_permutations(s: str) -> list[str]: Returns all unique permutations of the given string s. if not s: # handle edge case of empty string return [] # Generate all permutations and convert to set to remove duplicates all_permutations = set(permutations(s)) # Convert each tuple permutation back to string unique_permutations = [\'\'.join(p) for p in all_permutations] return sorted(unique_permutations)"},{"question":"You are tasked with developing a Python function `find_frequent_elements(nums: List[int], k: int) -> List[int]` that identifies the k most frequent elements in a list of integers. # Requirements: 1. **Input**: - `nums`: A list of integers where each integer can be positive or negative. - `k`: A positive integer indicating the number of frequent elements to return. 2. **Output**: A list of the k most frequent elements. If multiple frequencies are the same, any elements satisfying the frequency criteria can be included in the output. 3. **Constraints**: - The length of the list `nums` is between 1 and (10^5). - Each integer in the list can be arbitrarily large and positive or negative. - (1 leq k leq) length of `nums`. # Performance: - The solution should handle large inputs efficiently, ideally using data structures and algorithms that allow for faster processing than (O(n log n)). # Implementation: - Consider utilizing data structures such as heap, dictionary, or collections.Counter for the efficient determination of frequencies. - Implement efficient methods to extract the top k elements based on their frequency. # Example: ```python >>> find_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> find_frequent_elements([1], 1) [1] >>> find_frequent_elements([4, 4, 4, 2, 2, 5, 5, 5, 5], 2) [5, 4] >>> find_frequent_elements([1, 2, 3, 4, 5, 6], 3) [1, 2, 3] >>> find_frequent_elements([-1, -1, -1, -2, -2, -3, -3, -3], 2) [-1, -3] ``` # Special Considerations: - The function should handle edge cases such as lists of length 1 or where all elements are unique with grace. - Ensure valid handling of integers with large absolute values and negative numbers.","solution":"from typing import List import heapq from collections import Counter def find_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the list nums. # Utilize a Counter to get frequency of each element count = Counter(nums) # Use heapq to get the k elements with highest frequencies return [item for item, freq in count.most_common(k)]"},{"question":"# Coding Question: Frequency of Distinct Substrings You need to implement a function to calculate the number of distinct substrings of length `k` in a given text string. The substrings are case-sensitive, meaning \'A\' and \'a\' are considered different characters. Requirements: - **Function Signature**: `def count_distinct_substrings(text: str, k: int) -> int:` - **Input**: - A single string `text` which can include letters, digits, and special characters. - An integer `k` which specifies the length of substrings to consider. - **Output**: An integer that represents the number of distinct substrings of length `k` in the text. Constraints: - The text can range from length 1 to 10,000 characters. - The value of `k` will be between 1 and the length of the text, inclusive. - Substrings are case-sensitive. Performance: - Aim for efficient substring generation and counting, ideally within O(n) time complexity where n is the length of the text. Examples: ```python text = \\"ababc\\" k = 2 # The distinct substrings of length 2 are: \\"ab\\", \\"ba\\", \\"bc\\" assert count_distinct_substrings(text, k) == 3 text = \\"abcdef\\" k = 1 # The distinct substrings of length 1 are: \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\" assert count_distinct_substrings(text, k) == 6 text = \\"aaaaa\\" k = 2 # The distinct substrings of length 2 are: \\"aa\\" assert count_distinct_substrings(text, k) == 1 text = \\"abababab\\" k = 3 # The distinct substrings of length 3 are: \\"aba\\", \\"bab\\" assert count_distinct_substrings(text, k) == 2 ```","solution":"def count_distinct_substrings(text: str, k: int) -> int: This function counts the number of distinct substrings of length k in a given text string. Parameters: text (str): The input text string. k (int): The length of substrings to consider. Returns: int: The number of distinct substrings of length k. substrings = set() for i in range(len(text) - k + 1): substrings.add(text[i:i + k]) return len(substrings)"},{"question":"# Binary Tree Duplicate Subtree Detection As a software engineer, you are tasked with identifying duplicate subtrees within a binary tree. A subtree is considered duplicate if there exists another subtree in the tree with the same structure and node values. Your task is to write a function that takes the root of a binary tree and returns a list of nodes, each representing the root of a duplicate subtree. Each duplicate subtree should only be represented once. 1. **Subtree Identification**: - Traverse the tree to examine all possible subtrees. - Use serialization or a similar technique to detect duplicates. 2. **Output Format**: - Return a list of the root nodes of each duplicate subtree. - Ensure that each duplicate subtree is included only once in the output list. 3. **Considerations**: - Optimize for time and space efficiency. - Handle cases where the tree is empty or has no duplicates. # Function to Implement ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_duplicate_subtrees(root: TreeNode): pass ``` # Input - `root`: A TreeNode representing the root of the binary tree. # Output - A list of TreeNode objects, each representing the root of a duplicate subtree. # Constraints - The number of nodes in the tree will not exceed `10^4`. - Node values are integers and can be negative or positive. # Example ```python # Example Tree: # 1 # / # 2 3 # / / # 4 2 4 # / # 4 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(4) root.right = TreeNode(3) root.right.left = TreeNode(2) root.right.left.left = TreeNode(4) root.right.right = TreeNode(4) # Example Function Call duplicates = find_duplicate_subtrees(root) # Expected Output: A list containing the root nodes of duplicate subtrees. # For this example: # TreeNode(val=2, left=TreeNode(4)) and TreeNode(val=4) # Note: Order of the output nodes does not matter. for node in duplicates: print(node.val) # Output could be: 4, 2 ``` In the above example, there are two duplicate subtrees: - The subtree rooted at the node with value `2`, containing a left child node with value `4`. - The subtree rooted at the node with value `4`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_duplicate_subtrees(root: TreeNode): from collections import defaultdict def serialize(node, lookup, duplicates): if not node: return \\"#\\" path = \\"{},{},{}\\".format( node.val, serialize(node.left, lookup, duplicates), serialize(node.right, lookup, duplicates) ) if lookup[path] == 1: duplicates.append(node) lookup[path] += 1 return path duplicates = [] lookup = defaultdict(int) serialize(root, lookup, duplicates) return duplicates"},{"question":"# Problem Statement You are tasked with writing a function for a photo management application that can calculate the compression ratio of an image file. A compression ratio is defined as the ratio of the original image size to the compressed image size. # Task Write a function `calculate_compression_ratio(original: int, compressed: int) -> float` that returns the compression ratio of an image given the original file size and the compressed file size. # Input - `original`: An integer representing the size of the original image file in bytes ((1 leq text{original} leq 10^9)). - `compressed`: An integer representing the size of the compressed image file in bytes ((1 leq text{compressed} leq text{original})). # Output - Return a float representing the compression ratio rounded to two decimal places. # Example ```python assert calculate_compression_ratio(2000, 500) == 4.00 assert calculate_compression_ratio(10240, 1024) == 10.00 assert calculate_compression_ratio(500, 500) == 1.00 ``` Constraints - Ensure that the function handles large integers efficiently. - The function should return a float rounded to two decimal places. This question tests your understanding of mathematical operations and precision handling in Python.","solution":"def calculate_compression_ratio(original: int, compressed: int) -> float: Returns the compression ratio of an image, given the original and compressed file sizes. ratio = original / compressed return round(ratio, 2)"},{"question":"# Function Dependency Resolver **Scenario**: You are asked to implement a function that resolves dependencies between different modules or packages in a software project. Each module may depend on one or more other modules to function correctly. The task is to determine a valid order in which the modules can be installed or executed based on their dependencies. **Objective**: Your job is to implement a function `resolve_dependencies(modules: list[str], dependencies: dict[str, list[str]]) -> list[str]` to find a valid installation order using topological sorting. If no valid order exists due to circular dependencies, return an empty list. **Function Signature**: ```python def resolve_dependencies(modules: list[str], dependencies: dict[str, list[str]]) -> list[str]: # your code here ``` **Input**: * `modules`: A list of strings where each string is a module name. * `dependencies`: A dictionary where each key is a module name and the corresponding value is a list of modules that it depends on. **Output**: * Returns a list of strings representing the valid installation order of the modules, or an empty list if no valid order exists due to circular dependencies. **Constraints**: * Each module mentioned in the `modules` list may or may not have dependencies. * Modules listed as dependencies will always be included in the `modules` list. * Circular dependencies between modules should be detected and an empty list should be returned in such cases. **Edge Cases**: * The `modules` list is empty. * The `dependencies` dictionary is empty. * There are modules with no dependencies at all. * Circular dependencies exist among some modules. # Example ```python modules = [\'A\', \'B\', \'C\', \'D\'] dependencies = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [], \'D\': [\'C\'] } resolve_dependencies(modules, dependencies) # Returns: [\'C\', \'B\', \'A\', \'D\'] or another valid order modules = [\'A\', \'B\', \'C\', \'D\'] dependencies = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [\'C\'] } resolve_dependencies(modules, dependencies) # Returns: [] (due to circular dependency among A, B, and C) ``` Write your function considering the provided scenarios and constraints. Ensure your implementation efficiently handles all edge cases and returns a valid installation order or an empty list for circular dependencies.","solution":"def resolve_dependencies(modules, dependencies): Given a list of modules and a dictionary mapping each module to its dependencies, returns a valid installation order of the modules using topological sorting, or an empty list if a circular dependency exists. from collections import defaultdict, deque # Create a graph and in-degree count graph = defaultdict(list) in_degree = {module: 0 for module in modules} # Build the graph and in-degree for module, deps in dependencies.items(): for dep in deps: graph[dep].append(module) in_degree[module] += 1 # Initialize the queue with modules having no dependencies (in-degree 0) queue = deque([module for module in modules if in_degree[module] == 0]) order = [] # Perform topological sorting while queue: module = queue.popleft() order.append(module) # Decrease in-degree of neighboring nodes for neighbor in graph[module]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if topological sort is possible (i.e., no circular dependency) if len(order) == len(modules): return order else: return [] # Example usage: modules = [\'A\', \'B\', \'C\', \'D\'] dependencies = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [], \'D\': [\'C\'] } print(resolve_dependencies(modules, dependencies)) # Prints a valid order e.g., [\'C\', \'B\', \'A\', \'D\']"},{"question":"**Question: Balanced Binary Search Tree Construction** **Context:** Bob is tasked with creating a searching mechanism for a large set of data. He learned that a balanced binary search tree (BBST) provides efficient search, insertion, and deletion operations, thus being very useful for dynamic datasets. Bob has a crucial requirement to maintain the tree\'s balance to ensure optimal performance. **Task:** Your task is to implement a function that takes a sorted list of integers and constructs a height-balanced binary search tree (BBST). **Function Signature:** ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_list_to_bst(nums: list) -> TreeNode: pass ``` **Input:** - `nums` (a list of integers): A sorted list of integers in ascending order. **Output:** - The root node of a height-balanced binary search tree (BBST). **Constraints:** - The list may contain up to (10^5) elements. - All elements in the list are unique and sorted in ascending order. **Examples:** 1. `sorted_list_to_bst([-10, -3, 0, 5, 9])` should return the root node of a BST where the elements are balanced. The resulting BST can have a root node with value `0` and structure similar to: ``` 0 / -3 9 / / -10 5 ``` 2. `sorted_list_to_bst([1, 2, 3])` should return the root node of a BST where the elements are balanced. The resulting BST can have a root node with value `2` and structure similar to: ``` 2 / 1 3 ``` 3. `sorted_list_to_bst([1])` should return the root node of a BST with a single node `1`. **Additional Notes:** 1. A height-balanced binary search tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than one. 2. In your implementation, ensure that the tree is constructed in a way that minimizes its height. 3. You can create a class `TreeNode` with an `__init__` method that initializes a node with a given value and pointers to its left and right children as shown in the function signature above.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_list_to_bst(nums: list) -> TreeNode: Constructs a height-balanced binary search tree (BBST) from a sorted list of unique integers. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_list_to_bst(nums[:mid]) root.right = sorted_list_to_bst(nums[mid + 1:]) return root"},{"question":"# Question: Implement a Simple Command-Line Calculator Create a command-line calculator application that supports basic arithmetic operations including addition, subtraction, multiplication, and division. **Class Definition**: `Calculator` **Methods**: 1. `add(x: float, y: float) -> float`: Returns the result of adding `x` and `y`. 2. `subtract(x: float, y: float) -> float`: Returns the result of subtracting `y` from `x`. 3. `multiply(x: float, y: float) -> float`: Returns the result of multiplying `x` and `y`. 4. `divide(x: float, y: float) -> float`: Returns the result of dividing `x` by `y`. If `y` is `0`, handle it by raising a `ValueError` with the message \\"Cannot divide by zero.\\" **Input**: - Each method takes two float numbers as arguments. **Output**: - Each method returns a single float representing the result of the arithmetic operation, except for the `divide()` method which raises an error if the denominator is `0`. # Example ```python calc = Calculator() print(calc.add(5, 3)) # Output: 8.0 print(calc.subtract(5, 3)) # Output: 2.0 print(calc.multiply(5, 3)) # Output: 15.0 try: print(calc.divide(5, 0)) # Raises ValueError: Cannot divide by zero except ValueError as e: print(e) # Output: Cannot divide by zero print(calc.divide(9, 3)) # Output: 3.0 ``` # Performance and Scalability: - Focus on correct handling of arithmetic operations. - Aim to handle inputs accurately without performance degradation for standard usage ranges. - Ensure division by zero is explicitly handled to avoid runtime errors. Implement the `Calculator` class ensuring accuracy and appropriate error handling.","solution":"class Calculator: def add(self, x: float, y: float) -> float: return x + y def subtract(self, x: float, y: float) -> float: return x - y def multiply(self, x: float, y: float) -> float: return x * y def divide(self, x: float, y: float) -> float: if y == 0: raise ValueError(\\"Cannot divide by zero\\") return x / y"},{"question":"# Coding Assessment: Calculate Employee Work Hours Objective You are required to write Python functions that calculate the total work hours for each employee based on a weekly work log input. The log contains entries specifying the date, start time, and end time of each work period. Requirements 1. **Function 1: `parse_work_log(work_log: List[dict]) -> dict`** - Input: - A list of dictionaries, where each dictionary represents a work period with the following structure: ```python { \\"employee_id\\": str, \\"date\\": str, # format: \\"YYYY-MM-DD\\" \\"start_time\\": str, # format: \\"HH:MM\\" \\"end_time\\": str # format: \\"HH:MM\\" } ``` - Output: - A dictionary where the key is the employee ID and the value is the total number of work hours for that employee in the given week, rounded to 2 decimal places. - Constraints: - The \\"start_time\\" and \\"end_time\\" fields are guaranteed to be valid 24-hour times. - Assume \\"end_time\\" is always after \\"start_time\\" on the same day (no overnight shifts). Example ```python >>> work_log = [ {\\"employee_id\\": \\"E001\\", \\"date\\": \\"2023-11-01\\", \\"start_time\\": \\"09:00\\", \\"end_time\\": \\"17:00\\"}, {\\"employee_id\\": \\"E002\\", \\"date\\": \\"2023-11-01\\", \\"start_time\\": \\"10:00\\", \\"end_time\\": \\"18:00\\"}, {\\"employee_id\\": \\"E001\\", \\"date\\": \\"2023-11-02\\", \\"start_time\\": \\"09:00\\", \\"end_time\\": \\"12:00\\"}, {\\"employee_id\\": \\"E002\\", \\"date\\": \\"2023-11-02\\", \\"start_time\\": \\"12:00\\", \\"end_time\\": \\"20:00\\"} ] >>> result = parse_work_log(work_log) >>> print(result) { \\"E001\\": 11.0, \\"E002\\": 16.0 } ``` Notes 1. Calculate the total work hours per employee by summing the durations of all work periods for each week. 2. The output dictionary should contain all employees that have entries in the work log. 3. Handle any unexpected situations gracefully without causing the program to crash. Constraints - Use the `datetime` module for time calculations to ensure accuracy. - The work log will not contain duplicate entries with the same date and time for a single employee. - Ensure the solution works efficiently for large logs (up to 10,000 entries). Performance Requirements - Your solution should handle large inputs efficiently. - Ensure that the solution processes the log data in O(n) time complexity.","solution":"from typing import List, Dict from datetime import datetime def parse_work_log(work_log: List[dict]) -> Dict[str, float]: employee_hours = {} for entry in work_log: employee_id = entry[\\"employee_id\\"] start_time = datetime.strptime(entry[\\"date\\"] + \\" \\" + entry[\\"start_time\\"], \\"%Y-%m-%d %H:%M\\") end_time = datetime.strptime(entry[\\"date\\"] + \\" \\" + entry[\\"end_time\\"], \\"%Y-%m-%d %H:%M\\") time_diff = (end_time - start_time).total_seconds() / 3600 # convert to hours if employee_id in employee_hours: employee_hours[employee_id] += time_diff else: employee_hours[employee_id] = time_diff # Round to 2 decimal places for employee in employee_hours: employee_hours[employee] = round(employee_hours[employee], 2) return employee_hours"},{"question":"Finding Critical Linked List Node You are given a singly linked list, and your task is to determine the node that falls exactly in the middle of the list. If the list has an even number of nodes, return the second of the two middle nodes. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def middle_node(head: ListNode) -> ListNode: ``` # Input * `head` (ListNode): The head node of the singly linked list. # Output * Returns the middle node of the linked list. # Constraints * The number of nodes in the list is in the range ([1, 1000]). * Each node\'s value is an integer between (-1000) and (1000). # Examples ```python # Helper function to create linked list from list def create_linked_list(arr): head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head # Helper function to print linked list from node (for demonstration purposes) def print_linked_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result # Example 1 head = create_linked_list([1, 2, 3, 4, 5]) middle = middle_node(head) assert print_linked_list(middle) == [3, 4, 5] # Example 2 head = create_linked_list([1, 2, 3, 4, 5, 6]) middle = middle_node(head) assert print_linked_list(middle) == [4, 5, 6] ``` # Requirements * Implement the function `middle_node` using the two-pointer technique (one slow and one fast). * Ensure that the function handles lists of different lengths correctly. # Notes * The slow pointer should move one step at a time while the fast pointer moves two steps at a time. * When the fast pointer reaches the end of the list, the slow pointer will be at the middle node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def middle_node(head: ListNode) -> ListNode: # Initialize two pointers, slow and fast. slow = head fast = head # Move fast pointer two steps and slow pointer one step at a time. while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next # When fast pointer reaches the end, slow pointer will be at the middle. return slow"},{"question":"# Autocomplete Feature Implementation You are required to build an autocomplete feature that suggests a list of words from given user inputs. The feature should have the following operations: 1. `insert(word)`: Insert a word into the autocomplete system. 2. `search(prefix)`: Return up to the top 5 words that start with the given prefix, sorted by the insertion order and alphabetically within the same insertion order. # Input and Output Formats: - **insert**: * Input: A string `word` that represents the word to be inserted. * Output: None. - **search**: * Input: A string `prefix` that represents the prefix to search for. * Output: A list of up to 5 words that start with the `prefix`. # Constraints: - The length of `word` and `prefix` will be between 1 and 100. - The total number of words inserted in the system can be at most 50,000. - Words consist of lower-case English letters only. - The search operation should run in O(k + m) time complexity where k is the length of the prefix and m is the number of matching words. # Context Example: Suppose you need to implement an autocomplete feature for a search engine. When users start typing a query, the system can provide them with suggestions based on frequently searched terms. ```python class AutocompleteSystem: def __init__(self): Initialize the AutocompleteSystem. self.trie = {} self.words = [] def insert(self, word: str) -> None: Insert the word into the autocomplete system. current = self.trie for letter in word: if letter not in current: current[letter] = {} current = current[letter] current[\'#\'] = word # Mark the end of a word self.words.append(word) def search(self, prefix: str) -> list: Return up to the top 5 words that start with the given prefix. current = self.trie for letter in prefix: if letter not in current: return [] current = current[letter] return self._find_words(current, prefix)[:5] def _find_words(self, node: dict, prefix: str): result = [] if \'#\' in node: result.append(node[\'#\']) for letter in node: if letter != \'#\': result.extend(self._find_words(node[letter], prefix + letter)) return result # Tests autocomplete = AutocompleteSystem() autocomplete.insert(\\"hello\\") autocomplete.insert(\\"hell\\") autocomplete.insert(\\"heaven\\") autocomplete.insert(\\"heavy\\") autocomplete.insert(\\"he\\") assert autocomplete.search(\\"he\\") == [\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\", \\"he\\"] assert autocomplete.search(\\"hea\\") == [\\"heaven\\", \\"heavy\\"] assert autocomplete.search(\\"hell\\") == [\\"hello\\", \\"hell\\"] assert autocomplete.search(\\"h\\") == [\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\", \\"he\\"] assert autocomplete.search(\\"hi\\") == [] ``` # Note: - Use a Trie (prefix tree) to store the words for efficient retrieval. - Handle edge cases such as no matching prefix or words exceeding the top 5 limit.","solution":"class AutocompleteSystem: def __init__(self): Initialize the AutocompleteSystem. self.trie = {} self.words_order = [] def insert(self, word: str) -> None: Insert the word into the autocomplete system. current = self.trie for letter in word: if letter not in current: current[letter] = {} current = current[letter] current[\'#\'] = word # Mark the end of a word self.words_order.append(word) def search(self, prefix: str) -> list: Return up to the top 5 words that start with the given prefix. current = self.trie for letter in prefix: if letter not in current: return [] current = current[letter] matched_words = [] self._find_words(current, prefix, matched_words) # Sort the matched words based on their insertion order result = sorted(matched_words, key=lambda word: self.words_order.index(word)) return result[:5] def _find_words(self, node: dict, prefix: str, result: list): if \'#\' in node: result.append(node[\'#\']) for letter in node: if letter != \'#\': self._find_words(node[letter], prefix + letter, result)"},{"question":"# Problem Description You are given an unsorted list of `n` integers `arr` and an integer `k`. Your task is to implement the Quickselect algorithm to find the `k`-th smallest element in the list. If `k` is out of the bounds of the list, return `None`. # Implementation Details 1. **Function Signature**: ```python def quickselect(arr: List[int], k: int) -> Union[int, None]: ``` 2. **Input**: - `arr`: A list of `n` integers where `1 <= n <= 10^5` - `k`: An integer representing the 1-based position of the smallest element to find 3. **Output**: - Returns the `k`-th smallest element in `arr` if `1 <= k <= n`, otherwise returns `None`. # Constraints - The function must run in O(n) average time complexity. # Example ```python assert quickselect([3, 2, 1, 5, 4], 1) == 1 assert quickselect([3, 2, 1, 5, 4], 3) == 3 assert quickselect([3, 2, 1, 5, 4], 5) == 5 assert quickselect([3, 2, 1, 5, 4], 6) == None assert quickselect([7, 10, 4, 3, 20, 15], 4) == 10 ``` # Additional Notes 1. Implement a helper function for partitioning the array around a pivot element. 2. Use recursion or iteration to reduce the problem size until the k-th smallest element is found. 3. Handle edge cases such as when `k` is out of the bounds of the list. Good luck and happy coding!","solution":"from typing import List, Union def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect_helper(arr: List[int], low: int, high: int, k: int) -> int: if low <= high: pivot_index = partition(arr, low, high) if pivot_index == k: return arr[pivot_index] elif pivot_index > k: return quickselect_helper(arr, low, pivot_index - 1, k) else: return quickselect_helper(arr, pivot_index + 1, high, k) def quickselect(arr: List[int], k: int) -> Union[int, None]: if not (1 <= k <= len(arr)): return None return quickselect_helper(arr, 0, len(arr) - 1, k - 1)"},{"question":"# Coding Assessment Task: Context: A software company is developing a music recommendation system that suggests playlists based on the user\'s listening history. To enhance the system, the company needs to track the frequency of songs played over a period of time. Problem Statement: Implement a function `most_frequent_songs` that determines the most frequently played song(s) within a specified time frame from a given list of song play events. The function should return a list of song IDs that were played the most frequently during the specified range. If multiple songs share the highest frequency, return all of them in the order they first achieved the highest count. Function Signature: ```python def most_frequent_songs(plays: list, start_time: int, end_time: int) -> list: pass ``` Input/Output: * **Input**: * `plays`: A list of tuples where each tuple consists of an integer timestamp and a song ID (string) in the format `(timestamp, song_id)`. * `start_time`: An integer representing the start of the time frame (inclusive). * `end_time`: An integer representing the end of the time frame (inclusive). * **Output**: A list of song IDs (strings) that were played most frequently within the specified time frame. Constraints: - The `start_time` and `end_time` will be valid integers where `start_time <= end_time`. - The list `plays` is sorted by the timestamp in ascending order. - Each timestamp and each song ID will be unique. Examples: ```python >>> most_frequent_songs([(1, \\"song1\\"), (2, \\"song2\\"), (3, \\"song1\\"), (4, \\"song3\\")], 1, 3) [\\"song1\\"] >>> most_frequent_songs([(1, \\"song1\\"), (2, \\"song2\\"), (3, \\"song2\\"), (4, \\"song1\\"), (5, \\"song1\\")], 1, 5) [\\"song1\\"] >>> most_frequent_songs([(1, \\"song1\\"), (2, \\"song2\\"), (3, \\"song3\\"), (4, \\"song2\\"), (5, \\"song3\\")], 2, 5) [\\"song2\\", \\"song3\\"] ``` Notes: 1. Ensure that your solution is able to handle large datasets efficiently. 2. If the list `plays` is empty, or no plays occurred within the specified time frame, return an empty list. 3. You may assume all timestamps in `plays` are positive integers.","solution":"from collections import defaultdict def most_frequent_songs(plays, start_time, end_time): Determines the most frequently played songs within the specified time frame. :param plays: List of tuples, where each tuple consists of a timestamp and a song ID. :param start_time: Integer representing the start of the time frame (inclusive). :param end_time: Integer representing the end of the time frame (inclusive). :return: List of song IDs that were played most frequently within the specified time frame. song_count = defaultdict(int) # Count the frequency of each song within the specified time frame for timestamp, song_id in plays: if start_time <= timestamp <= end_time: song_count[song_id] += 1 if not song_count: return [] max_count = max(song_count.values()) most_frequent = [song_id for song_id, count in song_count.items() if count == max_count] return most_frequent"},{"question":"# Coding Question: You have been given a list of transactions that represent bank account operations. Each transaction is a tuple containing a transaction type and an amount. There are two types of transactions: \'deposit\' and \'withdraw\'. Your task is to write a function `final_balance` that calculates and returns the final balance of the account after processing all transactions. A transaction is represented as a tuple `(type, amount)`: * `type` (str): The type of the transaction, either \'deposit\' or \'withdraw\'. * `amount` (float): The amount of the transaction. The amount must be positive. Input: * A list of tuples, each representing a transaction. Output: * A float representing the final balance rounded to two decimal places. Constraints: * The initial balance of the account is zero. * If any transaction amount is zero or negative, raise a `ValueError` with the message \\"Transaction amounts must be positive\\". * If any transaction type is not \'deposit\' or \'withdraw\', raise a `ValueError` with the message \\"Unknown transaction type\\". * If the resulting balance ever goes below zero during processing, raise a `ValueError` with the message \\"Insufficient funds\\". **Examples:** ```python >>> final_balance([(\'deposit\', 100), (\'withdraw\', 50), (\'deposit\', 200)]) 250.00 >>> final_balance([(\'deposit\', 150), (\'withdraw\', 60.75), (\'withdraw\', 30.25)]) 59.00 >>> final_balance([(\'deposit\', 0), (\'withdraw\', 50)]) Traceback (most recent call last): ... ValueError: Transaction amounts must be positive >>> final_balance([(\'deposit\', 100), (\'withdraw\', 150)]) Traceback (most recent call last): ... ValueError: Insufficient funds >>> final_balance([(\'spend\', 100), (\'deposit\', 150)]) Traceback (most recent call last): ... ValueError: Unknown transaction type ``` Write the implementation of the function `final_balance(transactions: list[tuple[str, float]]) -> float` below.","solution":"def final_balance(transactions): balance = 0.0 for transaction in transactions: transaction_type, amount = transaction if amount <= 0: raise ValueError(\\"Transaction amounts must be positive\\") if transaction_type == \'deposit\': balance += amount elif transaction_type == \'withdraw\': if balance < amount: raise ValueError(\\"Insufficient funds\\") balance -= amount else: raise ValueError(\\"Unknown transaction type\\") return round(balance, 2)"},{"question":"# Problem Statement: String Compression and Decompression Context Data compression is an essential process in computing to reduce the size of data storage. One common method of compression involves converting a string of characters into a compressed format that effectively reduces the number of characters required to represent the original data. Objective Implement functions named `compress_string` and `decompress_string` to perform data compression and decompression of strings respectively. The compression algorithm should use the Run-Length Encoding (RLE) technique. Function Specifications **Function 1: compress_string** * **Input**: - `input_string`: A string consisting of characters. * **Output**: - Returns a compressed version of the `input_string` using RLE. **Function 2: decompress_string** * **Input**: - `compressed_string`: A string in RLE format. * **Output**: - Returns the original uncompressed string. Constraints * The `input_string` can contain English letters (both lowercase and uppercase) and digits. * The `compressed_string` will be a valid RLE formatted string. * The length of the `input_string` should be between 1 and 10^5. * Outputs should not include any additional leading or trailing spaces. Requirements * The `compress_string` function should efficiently compress the input by summarizing consecutive characters with counts. * The `decompress_string` function should accurately reconstruct the original string from the compressed format. * Handle edge cases like single character strings or strings with no repeating characters. Example ```python >>> compress_string(\\"aaabbbccddd\\") \'a3b3c2d3\' >>> compress_string(\\"abcd\\") \'a1b1c1d1\' >>> decompress_string(\\"a3b3c2d3\\") \'aaabbbccddd\' >>> decompress_string(\\"a1b1c1d1\\") \'abcd\' ``` Implementation Guidelines 1. For `compress_string`, iterate through the `input_string` to count consecutive characters and append them with their counts. 2. For `decompress_string`, parse the `compressed_string` to extract characters and their respective counts, then reconstruct the original string by repeating characters according to their counts. 3. Ensure the functions handle both uppercase and lowercase letters correctly and compress/decompress large strings efficiently. ```python def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 compressed.append(input_string[-1] + str(count)) return \'\'.join(compressed) def decompress_string(compressed_string: str) -> str: decompressed = [] i = 0 while i < len(compressed_string): char = compressed_string[i] count = 0 i += 1 while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed) ``` Testing - Create test cases that cover various lengths and complexities of strings including: - Strings with all unique characters. - Strings with multiple repeated characters. - Very large input strings. - Various combinations of Edge cases like empty strings or strings with numerical digits.","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 compressed.append(input_string[-1] + str(count)) return \'\'.join(compressed) def decompress_string(compressed_string: str) -> str: decompressed = [] i = 0 while i < len(compressed_string): char = compressed_string[i] count = 0 i += 1 while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Coding Assessment Question Prerequisites: Familiarity with graph theory, Breadth-First Search (BFS), and data structures such as queues and dictionaries. Problem Statement: Implement a function `shortest_path_bfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]` that finds the shortest path between two nodes in an unweighted graph using Breadth-First Search (BFS). Function Signature: ```python from typing import List, Dict def shortest_path_bfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: pass ``` Input: - `graph` (Dict[int, List[int]]): A dictionary representing the adjacency list of the graph. Keys are node identifiers (integers) and values are lists of adjacent nodes. - `start` (int): The starting node identifier. - `end` (int): The target node identifier. Output: - A list of integers representing the shortest path from the `start` node to the `end` node, inclusive. If no path exists, return an empty list. Requirements: 1. **Correctness**: Ensure the path returned is the shortest. 2. **Efficiency**: Optimize for both time and space complexity while traversing the graph. Constraints: - The graph may have multiple nodes but will not contain cycles or negative weights. - Handle invalid inputs by raising appropriate Python exceptions: - If either `start` or `end` node is not an integer, raise a `TypeError`. - If `start` or `end` node does not exist in the graph, raise a `ValueError`. Examples: ```python graph = { 1: [2, 4], 2: [1, 3, 4], 3: [2, 4], 4: [1, 2, 3, 5], 5: [4] } assert shortest_path_bfs(graph, 1, 5) == [1, 4, 5] # Shortest path from 1 to 5 is through 4 assert shortest_path_bfs(graph, 2, 3) == [2, 3] # Direct edge between 2 and 3 assert shortest_path_bfs(graph, 5, 1) == [5, 4, 1] # Shortest path from 5 to 1 is through 4 # Edge cases assert shortest_path_bfs(graph, 1, 1) == [1] # Start and end are the same assert shortest_path_bfs(graph, 1, 6) == [] # Node 6 does not exist in the graph ``` Note: - Ensure to handle cyclic graphs gracefully. - Include edge-case testing for disconnected nodes. - Optimize both for readability and performance. - Unit tests are highly recommended.","solution":"from typing import List, Dict, Deque from collections import deque def shortest_path_bfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: if not isinstance(start, int) or not isinstance(end, int): raise TypeError(\\"start and end must be integers\\") if start not in graph or end not in graph: raise ValueError(\\"start or end node not in the graph\\") # BFS initialization queue: Deque[List[int]] = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] # If we reached the end node if node == end: return path # Skip if we have already visited this node if node in visited: continue visited.add(node) for neighbor in graph.get(node, []): new_path = list(path) new_path.append(neighbor) queue.append(new_path) # No path found return []"},{"question":"# Question: Sorting a List of Dictionaries You need to sort a list of dictionaries based on a given key. Each dictionary in the list contains the same keys. Your task is to implement a function that sorts this list in ascending order based on the specified key. Additionally, your function should be capable of handling nested dictionaries for the sorting key. # Requirements: 1. Implement a function `sort_dicts_by_key(dicts: list, sort_key: str) -> list` that accepts: - `dicts`: A list of dictionaries to be sorted. - `sort_key`: A string representing the key on which to sort the dictionaries. 2. Your function should return the list of dictionaries sorted in ascending order. # Input: - A list of dictionaries `dicts`, each having the same set of keys. - A string `sort_key` representing the key for sorting. This key can be nested, indicated by dot notation (e.g., \\"address.city\\"). # Output: - A list of dictionaries sorted in ascending order based on the specified key. # Constraints: - The list will contain up to 1,000 dictionaries. - Each key in the dictionaries is guaranteed to lead to a value that can be compared (i.e., integers, floats, strings, etc.). # Example: ```python # Example usage data = [ {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"address\\": {\\"city\\": \\"New York\\", \\"zip\\": \\"10001\\"}}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"address\\": {\\"city\\": \\"San Francisco\\", \\"zip\\": \\"94102\\"}}, {\\"name\\": \\"Charlie\\", \\"age\\": 40, \\"address\\": {\\"city\\": \\"Houston\\", \\"zip\\": \\"77001\\"}} ] assert sort_dicts_by_key(data, \\"age\\") == [ {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"address\\": {\\"city\\": \\"San Francisco\\", \\"zip\\": \\"94102\\"}}, {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"address\\": {\\"city\\": \\"New York\\", \\"zip\\": \\"10001\\"}}, {\\"name\\": \\"Charlie\\", \\"age\\": 40, \\"address\\": {\\"city\\": \\"Houston\\", \\"zip\\": \\"77001\\"}} ] assert sort_dicts_by_key(data, \\"address.city\\") == [ {\\"name\\": \\"Charlie\\", \\"age\\": 40, \\"address\\": {\\"city\\": \\"Houston\\", \\"zip\\": \\"77001\\"}}, {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"address\\": {\\"city\\": \\"New York\\", \\"zip\\": \\"10001\\"}}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"address\\": {\\"city\\": \\"San Francisco\\", \\"zip\\": \\"94102\\"}} ] ``` # Notes: - Handle nested key sorting by splitting the sort_key on dots and accessing nested dictionaries accordingly. - Ensure that your function can efficiently handle the upper limit of the input list size. - Consider edge cases such as empty lists, lists with one dictionary, and dictionaries with missing nested keys specified in the sort_key.","solution":"def sort_dicts_by_key(dicts, sort_key): def get_nested_value(d, keys): for key in keys: d = d[key] return d keys = sort_key.split(\'.\') return sorted(dicts, key=lambda d: get_nested_value(d, keys))"},{"question":"# Problem Statement You are tasked with implementing a function `sum_of_digit_squares(n: int) -> int` that computes the sum of the squares of the digits of a given positive integer. # Requirements: - The function should handle edge cases such as zero and very small integers. - If the input is zero, the function should return 0. - Ensure efficient handling of large integers. # Input - A single integer `n` where `0 <= n <= 10^12`. # Output - An integer representing the sum of the squares of the digits of the input number. # Constraint - The function should be optimized to handle very large input sizes efficiently. # Example ```python >>> sum_of_digit_squares(0) 0 >>> sum_of_digit_squares(12) 5 >>> sum_of_digit_squares(123) 14 >>> sum_of_digit_squares(1234) 30 >>> sum_of_digit_squares(9876543210) 285 ``` # Performance Requirements - Ensure the solution is efficient, with an approach that avoids unnecessary computations.","solution":"def sum_of_digit_squares(n: int) -> int: Computes the sum of the squares of the digits of the given positive integer. Parameters: n (int): A positive integer Returns: int: The sum of the squares of the digits of n # Convert the integer to a string to easily iterate over each digit return sum(int(digit) ** 2 for digit in str(n))"},{"question":"# Coding Assessment Question Implement a function that simulates a pagination system for a list of items. The function should be able to return a specific page of items from the list based on the provided page number and page size. Additionally, the function should include metadata about the total number of items, total pages, and the current page number. Function Signature ```python def paginate_items( items: list, page_number: int, page_size: int ) -> dict: ``` Input Specifications: - **items** (*list*): A list of items to paginate. - **page_number** (*int*): The page number to retrieve (1-based index). - **page_size** (*int*): The number of items per page. Output Specifications: - **output** (*dict*): A dictionary containing the following keys: - **items** (*list*): A list of items on the current page. - **total_items** (*int*): The total number of items. - **total_pages** (*int*): The total number of pages. - **current_page** (*int*): The current page number. Example Usage: ```python items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] pagination = paginate_items(items, page_number=2, page_size=5) # Expected output: # { # \\"items\\": [6, 7, 8, 9, 10], # \\"total_items\\": 12, # \\"total_pages\\": 3, # \\"current_page\\": 2 # } ``` Constraints: - If the requested page number is out of range (i.e., less than 1 or greater than the total number of pages), return an empty list for **items** and set **current_page** to an appropriate default value (such as 1 or the total number of pages). - If the page size is less than 1, assume a default page size of 1. - Handle edge cases where the list of items is empty or the page size is larger than the number of items. - Ensure that the paginated function is efficient even for large lists of items.","solution":"def paginate_items(items, page_number, page_size): Paginates a list of items based on the provided page number and page size. Parameters: - items: List of items to paginate. - page_number: The page number to retrieve (1-based index). - page_size: The number of items per page. Returns: A dictionary with: - items: List of items on the current page. - total_items: The total number of items. - total_pages: The total number of pages. - current_page: The current page number. total_items = len(items) if page_size < 1: page_size = 1 total_pages = (total_items + page_size - 1) // page_size if page_number < 1 or page_number > total_pages: return { \\"items\\": [], \\"total_items\\": total_items, \\"total_pages\\": total_pages, \\"current_page\\": 1 if total_pages == 0 else total_pages } start_index = (page_number - 1) * page_size end_index = start_index + page_size return { \\"items\\": items[start_index:end_index], \\"total_items\\": total_items, \\"total_pages\\": total_pages, \\"current_page\\": page_number }"},{"question":"# Dynamic Graph Connectivity with Edge Insertion and Deletion Objective: Implement a dynamic graph data structure that supports connectivity queries as well as edge insertions and deletions. Description: You are required to write a graph data structure that efficiently supports checking whether two vertices are connected, and inserting or deleting edges. The goal is to handle dynamic changes in the graph structure while maintaining the ability to quickly determine connectivity. Requirements: * Define the Graph structure and initialize it with a list of edges. * Implement functions to: * Check if there is a path between two vertices. * Insert a new edge into the graph. * Delete an existing edge from the graph. Function Signatures: ```python class DynamicGraph: def __init__(self, edges: List[Tuple[int, int]]) -> None: Initialize the graph with the provided list of edges. pass def are_connected(self, u: int, v: int) -> bool: Check if there is a path between vertex `u` and vertex `v`. pass def insert_edge(self, u: int, v: int) -> None: Insert an edge between vertex `u` and vertex `v`. pass def delete_edge(self, u: int, v: int) -> None: Delete the edge between vertex `u` and vertex `v`, if it exists. pass ``` Example: ```python # Initializing the graph with edges dg = DynamicGraph([(0, 1), (1, 2), (2, 3)]) # Checking connectivity between vertices 0 and 3 assert dg.are_connected(0, 3) == True # Path exists: 0 -> 1 -> 2 -> 3 # Deleting an edge and checking connectivity dg.delete_edge(1, 2) assert dg.are_connected(0, 3) == False # No path exists after deletion # Inserting a new edge and checking connectivity dg.insert_edge(0, 3) assert dg.are_connected(0, 3) == True # Path exists: 0 -> 3 ``` Constraints: * The number of vertices will be between 1 and 10^5. * The number of edges in the initial graph will be between 1 and 10^5. * The number of insertions and deletions will not exceed 10^4. * Check connectivity, edge insertions, and deletions should be handled in logarithmic time or better, if possible.","solution":"from collections import defaultdict class DynamicGraph: def __init__(self, edges): self.graph = defaultdict(set) for u, v in edges: self.graph[u].add(v) self.graph[v].add(u) def are_connected(self, u, v): visited = set() return self._dfs(u, v, visited) def _dfs(self, current, target, visited): if current == target: return True visited.add(current) for neighbor in self.graph[current]: if neighbor not in visited: if self._dfs(neighbor, target, visited): return True return False def insert_edge(self, u, v): self.graph[u].add(v) self.graph[v].add(u) def delete_edge(self, u, v): if v in self.graph[u]: self.graph[u].remove(v) if u in self.graph[v]: self.graph[v].remove(u)"},{"question":"# Paint Fill Algorithm Implement a function that performs a paint fill on a 2D image represented by a grid of integers. Starting from a given cell, the paint fill changes the color of the starting cell and all connected cells with the same color to a new specified color. A cell is considered connected if it is horizontally or vertically adjacent to another cell with the same color as the starting cell. **Input**: * `image` - A 2D list (n x m) of integers representing the image. * `sr` - An integer representing the starting row. * `sc` - An integer representing the starting column. * `new_color` - An integer representing the new color to apply. **Output**: * The function should return the modified image (2D list) after performing the paint fill. **Function Signature**: ```python def paint_fill(image: list[list[int]], sr: int, sc: int, new_color: int) -> list[list[int]]: ``` **Constraints**: * The input image will always be a rectangle (n x m). * 0 <= sr < n * 0 <= sc < m * 0 <= new_color < 1000 **Examples**: Example 1: ```python image = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] sr = 1 sc = 1 new_color = 2 assert paint_fill(image, sr, sc, new_color) == [ [2, 2, 2], [2, 2, 0], [2, 0, 1] ] # The cell (1, 1) and its connected cells with the same color (1) are changed to the new color (2). ``` Example 2: ```python image = [ [0, 0, 0], [0, 0, 0] ] sr = 0 sc = 0 new_color = 3 assert paint_fill(image, sr, sc, new_color) == [ [3, 3, 3], [3, 3, 3] ] # All cells containing the color 0 are connected and changed to the new color (3). ``` Example 3: ```python image = [ [0] ] sr = 0 sc = 0 new_color = 1 assert paint_fill(image, sr, sc, new_color) == [ [1] ] # The only cell is changed to the new color (1). ``` Your task is to complete the `paint_fill` function which will modify the given image in-place to apply the paint fill, and then return the modified image grid.","solution":"def paint_fill(image: list[list[int]], sr: int, sc: int, new_color: int) -> list[list[int]]: old_color = image[sr][sc] if old_color == new_color: return image def fill(x, y): if x < 0 or x >= len(image) or y < 0 or y >= len(image[0]): return if image[x][y] != old_color: return image[x][y] = new_color fill(x + 1, y) fill(x - 1, y) fill(x, y + 1) fill(x, y - 1) fill(sr, sc) return image"},{"question":"# Problem Statement: You are given a list of integer data points and a number `k`. Your task is to implement the following functions: 1. **`moving_average`**: Compute the simple moving average of the data points with a window size of `k`. 2. **`exponential_moving_average`**: Calculate the exponential moving average (EMA) of the data points with a specified smoothing factor `alpha`. 3. **`macd`**: Determine the Moving Average Convergence Divergence (MACD) for the data points using two different window sizes for the moving averages. # Function Signatures: 1. **`def moving_average(data_points: list[int], k: int) -> list[float]:`** 2. **`def exponential_moving_average(data_points: list[int], alpha: float) -> list[float]:`** 3. **`def macd(data_points: list[int], window_size_short: int, window_size_long: int) -> list[float]:`** # Input: - `data_points`: List of integers representing the data points. - `k`: An integer representing the window size for the simple moving average. - `alpha`: A float between 0 and 1 representing the smoothing factor for the exponential moving average. - `window_size_short`: An integer representing the short window size for the MACD. - `window_size_long`: An integer representing the long window size for the MACD. # Output: - The functions should return the corresponding moving averages or MACD values as described in the function signatures. # Constraints: - `1 <= len(data_points) <= 10^5` - `1 <= k <= len(data_points)` - `0 < alpha <= 1` - `1 <= window_size_short <= window_size_long <= len(data_points)` # Example: ```python # Example usage of the functions: data_points = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] k = 3 alpha = 0.5 window_size_short = 2 window_size_long = 5 # Simple Moving Average sma = moving_average(data_points, k) print(sma) # Output: [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] # Exponential Moving Average ema = exponential_moving_average(data_points, alpha) print(ema) # Output: [1, 1.5, 2.25, 3.125, 4.0625, 5.03125, 6.015625, 7.0078125, 8.00390625, 9.001953125] # Moving Average Convergence Divergence macd_values = macd(data_points, window_size_short, window_size_long) print(macd_values) # Output: [0.0, 0.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0] ``` This question is designed to test your understanding of time series data analysis and smoothing techniques, with a focus on different moving average methods.","solution":"def moving_average(data_points, k): Computes the simple moving average of data points with a window size of k. if k <= 0: raise ValueError(\\"Window size k must be greater than 0\\") n = len(data_points) if k > n: raise ValueError(\\"Window size k must be less than or equal to the number of data points\\") moving_averages = [] window_sum = 0 for i in range(n): window_sum += data_points[i] if i >= k: window_sum -= data_points[i - k] if i >= k - 1: moving_averages.append(window_sum / k) return moving_averages def exponential_moving_average(data_points, alpha): Calculates the exponential moving average (EMA) of data points with specified smoothing factor alpha. ema = [] if not (0 < alpha <= 1): raise ValueError(\\"Alpha should be a value between 0 and 1\\") ema.append(data_points[0]) # the first EMA value is the same as the first data point for i in range(1, len(data_points)): ema.append(alpha * data_points[i] + (1 - alpha) * ema[-1]) return ema def macd(data_points, window_size_short, window_size_long): Determines the Moving Average Convergence Divergence (MACD) for data points using two different window sizes for moving averages. if window_size_short > window_size_long: raise ValueError(\\"Short window size must be less than or equal to long window size\\") short_ema = exponential_moving_average(data_points, 2 / (window_size_short + 1)) long_ema = exponential_moving_average(data_points, 2 / (window_size_long + 1)) macd_values = [short_ema[i] - long_ema[i] for i in range(len(data_points))] return macd_values"},{"question":"# Coding Assessment Question You are required to develop a library system management tool for categorizing and tracking books. The system should efficiently sort books based on a multi-part ID, handle different formats of book titles, and perform advanced search operations. The current implementation needs enhancement to support additional functionalities and optimal performance. # Task Details Implement two functions: 1. `normalize_book_title(book_title: str) -> str`: Standardizes book titles by converting all characters to lowercase and replacing any non-alphanumeric characters (excluding spaces) with a space. - **Input**: A string representing the original book title. - **Output**: A string representing the normalized book title. - **Constraints**: - Titles may include alphabets, numbers, and special characters. Only retain alphanumeric characters and spaces. - Multiple consecutive spaces should be merged into a single space. 2. `sort_boooks_by_id(book_ids: List[str]) -> List[str]`: Sorts a list of book IDs based on multiple numerical parts, ensuring numerical sorting within each part. - **Input**: A list of strings representing the book IDs. - **Output**: A list of strings representing the sorted book IDs. - **Constraints**: - Book IDs follow a multi-part numerical format, such as \\"1.10.3\\", \\"1.2.3\\", where parts are separated by dots. - Ensure numeric sorting within each part rather than simple lexicographic sorting. - Validate and handle edge cases where book IDs might not adhere to the expected format by raising a `ValueError` with a clear message. # Example Usage ```python >>> normalize_book_title(\\"The Adventures of Sherlock Holmes!\\") \'the adventures of sherlock holmes\' >>> normalize_book_title(\\"Python Programming 101: A Beginner\'s Guide\\") \'python programming 101 a beginner s guide\' >>> sort_books_by_id([\\"1.10.3\\", \\"1.2.3\\", \\"2.0.1\\", \\"1.10.1\\"]) [\'1.2.3\', \'1.10.1\', \'1.10.3\', \'2.0.1\'] >>> sort_books_by_id([\\"1.10.3\\", \\"1..2.3\\", \\"2.0.1\\", \\"1.10.1\\"]) Traceback (most recent call last): ... ValueError: Invalid book ID format \'1..2.3\' ``` # Additional Requirements - Ensure your implementation includes adequate comments and error handling. - Utilize efficient string manipulation and sorting algorithms to maximize performance. - Provide at least five unit tests that cover a variety of edge cases. Deliver the Python code that passes the above example usages and unit tests provided.","solution":"import re from typing import List def normalize_book_title(book_title: str) -> str: Standardizes book titles by converting all characters to lowercase, and replacing any non-alphanumeric characters (excluding spaces) with a space. Consecutive spaces are merged into a single space. # Convert to lowercase book_title = book_title.lower() # Replace non-alphanumeric characters with spaces book_title = re.sub(r\'[^a-z0-9s]\', \' \', book_title) # Merge consecutive spaces book_title = re.sub(r\'s+\', \' \', book_title).strip() return book_title def sort_books_by_id(book_ids: List[str]) -> List[str]: Sorts a list of book IDs based on multiple numerical parts, ensuring numerical sorting within each part. Raises a ValueError if any book ID is in an invalid format. def validate_and_convert(book_id: str) -> List[int]: Validates and converts a book ID into a list of integers. Raises a ValueError if the book ID is not in a valid format. if not re.fullmatch(r\'(d+(.d+)*)\', book_id): raise ValueError(f\\"Invalid book ID format \'{book_id}\'\\") return [int(part) for part in book_id.split(\'.\')] # Convert and validate all book IDs converted_ids = [validate_and_convert(book_id) for book_id in book_ids] # Sort the book IDs based on the numerical parts sorted_ids = sorted(book_ids, key=lambda book_id: validate_and_convert(book_id)) return sorted_ids"},{"question":"# Coding Assessment Question **Objective**: Write a function named `find_second_largest` that takes a list of integers and returns the second largest integer in the list. The function signature should be: ```python def find_second_largest(nums: list) -> int: ``` # Input Format: - `nums` (list): A list of integers with at least two distinct integers. # Output Format: - The function should return an integer representing the second largest number in the list. # Constraints: - The list will always have at least two distinct integers. - The integers in the list will fit within the standard 32-bit integer range. - The list will not necessarily be sorted. # Example: ```python >>> find_second_largest([12, 35, 1, 10, 34, 1]) 34 >>> find_second_largest([10, 5, 10]) 5 >>> find_second_largest([1, 2]) 1 >>> find_second_largest([4, 99, 23, 56, 7]) 56 ``` # Notes: 1. The function should handle both positive and negative integers. 2. You should aim for an efficient solution with a time complexity better than (O(n^2)) where (n) is the number of elements in the input list. 3. The function should not use any built-in sorting functionality.","solution":"def find_second_largest(nums: list) -> int: Returns the second largest integer in the list. first = second = float(\'-inf\') for num in nums: if num > first: second = first first = num elif first > num > second: second = num return second"},{"question":"Problem Statement You need to design a system to record and retrieve the stock price for a product over multiple days. Implement a `StockPriceManager` class that facilitates this. The class should provide methods to record a stock price for a specific day, retrieve the stock price for a specific day, and find the highest and lowest stock prices within a specified range of days. # Requirements 1. Implement the `StockPriceManager` class with the following methods: - `record_price(day, price)`: - Input: `day` (integer representing the day), `price` (integer representing the stock price) - Output: None - Description: Records the stock price for the given day. Days start from 1. - `get_price(day)`: - Input: `day` (integer representing the day) - Output: Integer representing the stock price for the given day - Description: Returns the stock price for the specified day. If no price is recorded for the given day, return `-1`. - `get_max_price(start_day, end_day)`: - Input: `start_day` (integer representing the start day), `end_day` (integer representing the end day) - Output: Integer representing the highest stock price within the specified range of days (inclusive) - Description: Returns the highest stock price recorded between `start_day` and `end_day`. If no prices are recorded in this range, return `-1`. - `get_min_price(start_day, end_day)`: - Input: `start_day` (integer representing the start day), `end_day` (integer representing the end day) - Output: Integer representing the lowest stock price within the specified range of days (inclusive) - Description: Returns the lowest stock price recorded between `start_day` and `end_day`. If no prices are recorded in this range, return `-1`. # Class Definition ```python class StockPriceManager: def __init__(self): pass def record_price(self, day, price): pass def get_price(self, day): pass def get_max_price(self, start_day, end_day): pass def get_min_price(self, start_day, end_day): pass ``` # Constraints * Days are positive integers starting from 1. * Stock prices are non-negative integers. * You must handle edge cases, such as querying prices for days where no prices were recorded and retrieving max/min prices for ranges not covered by any recorded prices. * Assume the number of recorded days will not exceed (10^4). # Example Usage ```python spm = StockPriceManager() spm.record_price(1, 100) spm.record_price(2, 80) spm.record_price(3, 120) print(spm.get_price(1)) # Output: 100 print(spm.get_price(4)) # Output: -1 print(spm.get_max_price(1, 3)) # Output: 120 print(spm.get_max_price(2, 3)) # Output: 120 print(spm.get_min_price(1, 3)) # Output: 80 print(spm.get_min_price(3, 4)) # Output: 120 print(spm.get_min_price(4, 5)) # Output: -1 ``` # Notes * Be sure to handle cases where there are no recorded prices in the specified range gracefully. * Efficiency is important; make sure your class can handle a large number of days without performance degradation.","solution":"class StockPriceManager: def __init__(self): self.prices = {} def record_price(self, day, price): Records the stock price for the given day. self.prices[day] = price def get_price(self, day): Returns the stock price for the specified day. If no price is recorded for the given day, return -1. return self.prices.get(day, -1) def get_max_price(self, start_day, end_day): Returns the highest stock price recorded between start_day and end_day (inclusive). If no prices are recorded in this range, return -1. prices_in_range = [ self.prices[day] for day in range(start_day, end_day + 1) if day in self.prices ] return max(prices_in_range, default=-1) def get_min_price(self, start_day, end_day): Returns the lowest stock price recorded between start_day and end_day (inclusive). If no prices are recorded in this range, return -1. prices_in_range = [ self.prices[day] for day in range(start_day, end_day + 1) if day in self.prices ] return min(prices_in_range, default=-1)"},{"question":"# Question: Validating Balanced Parentheses with Stars Context You are given a string containing only three types of characters: `\'(\'`, `\')\'`, and `\'*\'`. The variable `\'*\'` can represent any sequence of `\'(\'`, `\')\'`, or an empty string. Implement a function to determine if the given string can be valid balanced parentheses after parsing. Function Signature ```python def is_valid_parentheses(s: str) -> bool: pass ``` Input * A string `s` of length `n` (1 ≤ n ≤ 1000) containing only the characters `\'(\'`, `\')\'`, and `\'*\'`. Output * Return a boolean value: - `True` if the string can be valid parentheses after parsing. - `False` otherwise. Constraints * The input string will not contain any other characters besides `\'(\'`, `\')\'`, and `\'*\'`. Examples Example 1: ```python s = \\"()\\" is_valid_parentheses(s) # Output: True ``` Example 2: ```python s = \\"(*)\\" is_valid_parentheses(s) # Output: True ``` Example 3: ```python s = \\"(*))\\" is_valid_parentheses(s) # Output: True ``` Example 4: ```python s = \\"(()*\\" is_valid_parentheses(s) # Output: True ``` Example 5: ```python s = \\"(()))\\" is_valid_parentheses(s) # Output: False ``` Guidelines To solve the problem, you can use a greedy approach where you keep track of the minimum and maximum possible number of open parentheses. The main idea is: 1. Iterate through the string characters and update the minimum and maximum open count accordingly. 2. Use `\'*\'` to adjust the count flexibility. 3. Ensure at every step that the count does not fall below zero to avoid false negative cases. 4. At the end of the loop, check if the minimum count is zero to confirm a valid match. **Notes**: - This problem requires careful attention to how stars can be interpreted to balance open and close parentheses. - You may create utility functions to aid in the count updating mechanism.","solution":"def is_valid_parentheses(s: str) -> bool: min_open = 0 max_open = 0 for char in s: if char == \'(\': min_open += 1 max_open += 1 elif char == \')\': min_open -= 1 max_open -= 1 else: # character \'*\' min_open -= 1 max_open += 1 if max_open < 0: return False if min_open < 0: min_open = 0 return min_open == 0"},{"question":"# Coding Assessment Question: Implementing a Custom Sort Function for Event Schedules **Scenario:** You have been hired to develop a software system for managing event schedules. One of the key features is to efficiently sort a list of events based on their start time. These events are represented with their start and end times, and they may span multiple days. Your task is to implement a custom sorting function that can handle a large list of event schedules and sort them in ascending order by their start time. **Problem Statement:** Write a function named `sort_events` that sorts a list of event schedules based on their start times. Each event is represented as a tuple `(start_time, end_time)`, where `start_time` and `end_time` are strings in the format \\"YYYY-MM-DD HH:MM\\". **Function Signature:** ```python def sort_events(events: List[Tuple[str, str]]) -> List[Tuple[str, str]]: ``` **Input:** - `events` (List[Tuple[str, str]]): A list of event schedules where each event is represented as a tuple of strings `(start_time, end_time)`. There may be up to `10^5` events. **Output:** - A list of event schedules sorted in ascending order based on their start times. **Constraints:** - The input list may contain up to `10^5` events. - The start and end times are valid strings in the format \\"YYYY-MM-DD HH:MM\\". **Requirements:** - Implement an efficient sorting algorithm to handle the constraints. - Ensure that the sorting is stable, i.e., events with the same start time maintain their relative order from the input list. **Examples:** ```python >>> sort_events([ ... (\\"2023-10-01 14:00\\", \\"2023-10-01 16:00\\"), ... (\\"2023-10-01 09:00\\", \\"2023-10-01 11:30\\"), ... (\\"2023-10-02 10:00\\", \\"2023-10-02 12:00\\") ... ]) [ (\\"2023-10-01 09:00\\", \\"2023-10-01 11:30\\"), (\\"2023-10-01 14:00\\", \\"2023-10-01 16:00\\"), (\\"2023-10-02 10:00\\", \\"2023-10-02 12:00\\") ] >>> sort_events([ ... (\\"2023-09-30 18:00\\", \\"2023-09-30 20:00\\"), ... (\\"2023-09-30 09:00\\", \\"2023-09-30 10:30\\"), ... (\\"2023-09-30 14:00\\", \\"2023-09-30 15:00\\"), ... (\\"2023-09-30 09:00\\", \\"2023-09-30 09:30\\") ... ]) [ (\\"2023-09-30 09:00\\", \\"2023-09-30 10:30\\"), (\\"2023-09-30 09:00\\", \\"2023-09-30 09:30\\"), (\\"2023-09-30 14:00\\", \\"2023-09-30 15:00\\"), (\\"2023-09-30 18:00\\", \\"2023-09-30 20:00\\") ] ``` **Note:** - Be sure to handle edge cases, such as events with the same start times and varying durations. - Performance optimization is crucial given the large potential input size.","solution":"# Python solution from typing import List, Tuple def sort_events(events: List[Tuple[str, str]]) -> List[Tuple[str, str]]: Sorts a list of events based on their start times. :param events: List of event schedules where each event is a tuple (start_time, end_time) :return: List of events sorted by start time in ascending order # Sorting by start time (first element of tuple) return sorted(events, key=lambda event: event[0])"},{"question":"# **Anagram Subsequence Detection** Problem Statement Given a string `s` and a string `t`, an anagram of `t` is any rearrangement of the characters in `t`. Your task is to determine if `t` is an anagram of any contiguous subsequence of `s`. Task Write a function `is_anagram_subsequence` that takes in two strings `s` and `t`, and returns `True` if `t` is an anagram of any contiguous subsequence of `s`, and `False` otherwise. ```python def is_anagram_subsequence(s: str, t: str) -> bool: # Your code here pass ``` Input - A string `s` of length ( 1 leq text{len}(s) leq 10^5 ). - A string `t` of length ( 1 leq text{len}(t) leq 100 ). Output - The function should return a boolean value ( text{True} ) if `t` is an anagram of any contiguous subsequence of `s`, otherwise ( text{False} ). Constraints - Optimize the function to efficiently handle the length constraints of `s` and `t`. Example ```python # Example 1: print(is_anagram_subsequence(\\"cbaebabacd\\", \\"abc\\")) # Expected output: True # Example 2: print(is_anagram_subsequence(\\"eidbaooo\\", \\"ab\\")) # Expected output: True # Example 3: print(is_anagram_subsequence(\\"abcfde\\", \\"fde\\")) # Expected output: True # Example 4: print(is_anagram_subsequence(\\"abcdef\\", \\"gh\\")) # Expected output: False ``` Notes - Use efficient string handling and sliding window techniques to check for anagram subsequences. - Use character frequency arrays or dictionaries to easily compare letter counts between `s` and `t`. - Ensure the function handles edge cases, such as when `t` has characters not in `s`, or when the length of `t` is longer than `s`.","solution":"from collections import Counter def is_anagram_subsequence(s: str, t: str) -> bool: if len(t) > len(s): return False t_count = Counter(t) window_count = Counter(s[:len(t)]) if t_count == window_count: return True for i in range(len(t), len(s)): window_count[s[i]] += 1 window_count[s[i - len(t)]] -= 1 if window_count[s[i - len(t)]] == 0: del window_count[s[i - len(t)]] if t_count == window_count: return True return False"},{"question":"# Duplicate Detection Implement a function that identifies duplicate elements in a list of integers and returns a list of tuples. Each tuple should contain the integer and the number of times it appears in the list. # Function to Implement You need to implement the following function: ```python def find_duplicates(numbers: List[int]) -> List[Tuple[int, int]]: Finds and counts the duplicate elements in a provided list of integers. Parameters: numbers (List[int]): A list of integers. Returns: List[Tuple[int, int]]: A list of tuples, each containing a duplicate integer and its count. pass ``` # Input - A list of integers `numbers` where the length is ( n ). # Output - A list of tuples. Each tuple consists of an integer from the input list that appears more than once and the count of its appearances. # Constraints - ( 0 le n le 10^5 ) - Each integer ( numbers[i] ) will range from (-10^9) to ( 10^9 ) # Example ```python find_duplicates([1, 2, 2, 3, 4, 5, 5, 6, 6, 6]) # Output: [(2, 2), (5, 2), (6, 3)] find_duplicates([10, 20, 30, 40, 50]) # Output: [] find_duplicates([-1, -1, -1, 0, 1, 2, 2, 2, 3]) # Output: [(-1, 3), (2, 3)] ``` # Explanation Given the input list `[1, 2, 2, 3, 4, 5, 5, 6, 6, 6]`: 1. Identify all elements that appear more than once. 2. Count the occurrences of these elements. 3. Return a list of tuples where each tuple contains an element and its count in the input list. Edge cases: - If there are no duplicates, the function should return an empty list. - If the input list is empty, the function should return an empty list. - Elements that appear only once should not be included in the output list. Implementations should ensure efficiency in time complexity, making use of appropriate data structures for optimal performance.","solution":"from typing import List, Tuple from collections import Counter def find_duplicates(numbers: List[int]) -> List[Tuple[int, int]]: Finds and counts the duplicate elements in a provided list of integers. Parameters: numbers (List[int]): A list of integers. Returns: List[Tuple[int, int]]: A list of tuples, each containing a duplicate integer and its count. # Count occurrences of each number counts = Counter(numbers) # Filter only numbers that appear more than once and return as list of tuples return [(num, count) for num, count in counts.items() if count > 1]"},{"question":"# Data Structure Manipulation Challenge Description: You are tasked with implementing a function that processes a list of employee records, each containing an employee\'s name, department, and salary. Your function should return the average salary for each department. Objectives: 1. Implement the function `average_department_salaries` that accepts a list of dictionaries. Each dictionary will contain `name`, `department`, and `salary`. 2. Return a dictionary where the keys are department names and the values are the average salaries for those departments. 3. The function should handle cases where the input list is empty or where some employees might lack a specific department or salary entry by ignoring those entries in the calculation. Function Signature: ```python def average_department_salaries(employees: list[dict[str, str or int]]) -> dict[str, float]: pass ``` Constraints: - Valid employees dictionaries will have the following keys: `name` (string), `department` (string), `salary` (integer). - Ignore any employee records missing required keys. - The input list can be empty, in which case the function should return an empty dictionary. - Departments might appear multiple times, and each occurrence with valid salary data should contribute to the average calculation. Example: ```python employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, {\\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\", \\"salary\\": 110000}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Sales\\", \\"salary\\": 90000}, {\\"name\\": \\"David\\", \\"department\\": \\"Sales\\", \\"salary\\": 87000}, {\\"name\\": \\"Eve\\", \\"department\\": \\"HR\\", \\"salary\\": 70000}, {\\"name\\": \\"Frank\\", \\"department\\": \\"Engineering\\", \\"salary\\": 105000}, {\\"name\\": \\"George\\", \\"department\\": \\"HR\\", \\"salary\\": \\"NaN\\"} # Invalid salary, should be ignored ] result = average_department_salaries(employees) # Expected result: {\'Engineering\': 111666.67, \'Sales\': 88500.0, \'HR\': 70000.0} ``` # Testing: - Implement unit tests to verify average calculations for departments with multiple employees, departments with a single employee and proper handling of missing keys or invalid salary values.","solution":"from collections import defaultdict def average_department_salaries(employees): Calculate the average salary for each department from the given list of employee records. Parameters: employees (list[dict]): List of employee records, each record contains \'name\', \'department\', and \'salary\'. Returns: dict: Dictionary with department names as keys and average salaries as values. department_salaries = defaultdict(list) for employee in employees: try: department = employee[\'department\'] salary = employee[\'salary\'] if isinstance(salary, int): department_salaries[department].append(salary) except KeyError: pass # Ignore entries with missing \'department\' or \'salary\' average_salaries = { department: sum(salaries) / len(salaries) for department, salaries in department_salaries.items() } return average_salaries"},{"question":"# Sensor Network Health Monitor You are tasked with developing a health monitoring module for a sensor network used in environmental monitoring. Each sensor in the network periodically sends data to a central server, which then needs to perform various checks and computations to ensure the network\'s integrity. **Requirements**: 1. Implement a function to initialize the sensor network state. 2. Implement a function to update the readings from a sensor. 3. Implement a function to compute the average value of the readings for a specific sensor. 4. Implement a function to check the status of the network, indicating if any sensor is malfunctioning based on predefined thresholds. # Objectives: - **Function**: `initialize_network(n: int, threshold: float)` - **Input**: - `n`: Integer, number of sensors in the network. - `threshold`: Float, acceptable variance for sensor readings to consider them functioning correctly. - **Output**: Initializes the network with `n` sensors, each with an empty reading list. - **Function**: `update_reading(sensor_id: int, reading: float)` - **Input**: - `sensor_id`: Integer, identifier for the sensor. - `reading`: Float, the latest reading from the sensor. - **Output**: Updates the sensor\'s record with the new reading. - **Function**: `average_reading(sensor_id: int) -> float` - **Input**: - `sensor_id`: Integer, identifier for the sensor. - **Output**: Returns the average reading of the specified sensor. - **Function**: `network_status() -> List[int]` - **Input**: None - **Output**: Returns a list of sensor IDs that are malfunctioning. A sensor is considered malfunctioning if the standard deviation of its readings exceeds the defined threshold. Constraints: - Assume sensor IDs are 0-indexed integers. - Functions should handle cases where no readings are available for a sensor. - Utilize efficient data structures to ensure quick updates and computations. # Example Scenario: 1. Initialize the network with: ```python initialize_network(5, 0.2) ``` 2. Update the sensor readings: ```python update_reading(0, 22.5) update_reading(0, 23.1) update_reading(1, 19.8) update_reading(1, 20.2) update_reading(2, 21.2) update_reading(2, 21.3) ``` 3. Compute and print the average reading for sensor 0: ```python print(average_reading(0)) # Output: 22.8 ``` 4. Check the network status and identify malfunctioning sensors: ```python print(network_status()) # Output might be [0, 1, 2] if all sensors are malfunctioning ``` # Guidelines: - Document edge cases and test the functions thoroughly. - Analyze and comment on the performance for large values of `n`. - Ensure proper handling of floating-point precision for calculations. Are you ready to safeguard the integrity of the sensor network?","solution":"import math from typing import List class SensorNetwork: def __init__(self, n: int, threshold: float): Initializes the sensor network with `n` sensors. Each sensor will have an empty list of readings initially. `threshold` is the acceptable variance for sensor readings. self.sensors = {i: [] for i in range(n)} self.threshold = threshold def update_reading(self, sensor_id: int, reading: float): Updates the sensor\'s record with the new reading. if sensor_id in self.sensors: self.sensors[sensor_id].append(reading) def average_reading(self, sensor_id: int) -> float: Returns the average reading of the specified sensor. If there are no readings, return 0.0. readings = self.sensors[sensor_id] if not readings: return 0.0 return sum(readings) / len(readings) def network_status(self) -> List[int]: Returns a list of sensor IDs that are malfunctioning. A sensor is considered malfunctioning if the standard deviation of its readings exceeds the defined threshold. malfunctioning_sensors = [] for sensor_id, readings in self.sensors.items(): if len(readings) < 2: # Less than 2 readings, variance cannot be computed continue mean = sum(readings) / len(readings) variance = sum((reading - mean) ** 2 for reading in readings) / len(readings) stddev = math.sqrt(variance) if stddev > self.threshold: malfunctioning_sensors.append(sensor_id) return malfunctioning_sensors def initialize_network(n: int, threshold: float): Returns an instance of SensorNetwork. return SensorNetwork(n, threshold)"},{"question":"# Matrix Transpose Checker You are tasked with writing a function to check if one matrix is the transpose of another. In other words, you need to verify that the matrix `B` is the transpose of matrix `A`. Function Specification 1. **transpose_checker(A, B)**: Define a function that accepts two 2D lists of integers representing matrices `A` and `B`. # Input - `A`: A 2D list of integers representing matrix A with dimensions `m x n`. - `B`: A 2D list of integers representing matrix B with dimensions `n x m`. # Output - Return `True` if matrix `B` is the transpose of matrix `A`, otherwise return `False`. # Constraints - The input matrices will only contain integer values. - The dimensions of the matrices will be such that `B` could be the transpose of `A`. # Example Test Cases ```python # Test Case 1 A = [ [1, 2, 3], [4, 5, 6] ] B = [ [1, 4], [2, 5], [3, 6] ] assert transpose_checker(A, B) == True # Test Case 2 A = [ [1, 2], [3, 4] ] B = [ [1, 3], [2, 5] ] assert transpose_checker(A, B) == False # Test Case 3 A = [ [1] ] B = [ [1] ] assert transpose_checker(A, B) == True ``` Implement the `transpose_checker` function according to the specifications and ensure your implementation passes all the given example test cases.","solution":"def transpose_checker(A, B): Checks if matrix B is the transpose of matrix A. Args: A : list of list of integers The matrix A with dimensions m x n. B : list of list of integers The matrix B with dimensions n x m. Returns: bool True if B is the transpose of A, otherwise False. m = len(A) n = len(A[0]) for i in range(m): for j in range(n): if A[i][j] != B[j][i]: return False return True"},{"question":"# Question You are developing a command-line tool that calculates the runtime of several functions to help analyze their performance. To ensure the accuracy of your tool, you must write efficient unit tests that compare the runtime of these functions. Your tool will record the start time and end time of each function execution and calculate the difference to determine the runtime. # Task Using the structure provided in the previous example snippet, write a Python unit test function, `test_calculate_function_runtime`, to mock and verify the runtime calculation of a dummy function using the `time` module. Requirements: - Create a dummy function `dummy_function` that has a known, short runtime. - Mock the `time.time` method to simulate the function\'s runtime without actually waiting. - Implement a function `calculate_function_runtime` that records start and end times and returns the calculated runtime. - Ensure the mock function checks that the start and end times used in the calculation are as expected. - Use the `monkeypatch` fixture to apply the mock. - Verify that the returned runtime from `calculate_function_runtime` matches the expected calculated time. Input and Output: - You don’t need to worry about the input and output format as it\'s a unit test configuration. - If the setup is correct, the unit test should pass by accurately calculating the runtime without an actual wait. Constraints: - Assume the actual runtime of `dummy_function` is negligible. - Network or I/O operations should not be involved. - The timing operations should be fully mocked to simulate a specific runtime. # Example: ```python import time def dummy_function(): return def calculate_function_runtime(func): start_time = time.time() func() end_time = time.time() return end_time - start_time ``` Create the mock unit test function `test_calculate_function_runtime` for the above example.","solution":"import time def dummy_function(): This is a dummy function with a known, short runtime. return def calculate_function_runtime(func): Records the start and end times of a function execution and returns the runtime. start_time = time.time() func() end_time = time.time() return end_time - start_time"},{"question":"# Coding Assessment: Trie-Based Autocomplete System Problem Statement: You are assigned to implement a basic auto-completion feature using a Trie (prefix tree) data structure. This system should efficiently manage a list of words and return autocomplete suggestions based on input prefixes. Your implementation should: * Insert words into the Trie structure. * Provide autocomplete suggestions based on a given prefix. * Handle both repeated and new word additions efficiently. Function Signature Implement the function `auto_complete_system(commands: List[Tuple[str, Optional[str]]]) -> List[Optional[List[str]]]` where: * `commands`: A list of tuples where the first element is either \\"ADD\\" or \\"QUERY\\". * For \\"ADD\\", the second element is the word to be added to the Trie. * For \\"QUERY\\", the second element is the prefix to search for suggestions. The function should return a list where each element corresponds to: * `None` for \\"ADD\\" commands. * A list of words (sorted lexicographically) which are autocomplete suggestions for \\"QUERY\\" commands. Constraints: * `1 <= len(commands) <= 10000` * The length of given words and query prefixes will be within the range [1, 100]. * Words and prefixes consist of lowercase English letters only. * Each word to be added or queried can be considered a unique identifier. Example ```python # Example Input commands = [(\\"ADD\\", \\"hello\\"), (\\"ADD\\", \\"hell\\"), (\\"ADD\\", \\"heaven\\"), (\\"ADD\\", \\"goodbye\\"), (\\"QUERY\\", \\"he\\"), (\\"QUERY\\", \\"hell\\")] # Example Output output = auto_complete_system(commands) # Output output => [None, None, None, None, [\'heaven\', \'hell\', \'hello\'], [\'hell\', \'hello\']] ``` Instructions: 1. Define the TrieNode and Trie classes that support insertion and querying. 2. Implement the `add_word` method to insert words. 3. Implement the `query_prefix` method to fetch all words matching a given prefix. 4. Return the results in the specified format.","solution":"from typing import List, Tuple, Optional class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def add_word(self, word: str): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def query_prefix(self, prefix: str) -> List[str]: def dfs(node: TrieNode, path: str, results: List[str]): if node.is_end_of_word: results.append(path) for char in sorted(node.children.keys()): dfs(node.children[char], path + char, results) current = self.root for char in prefix: if char in current.children: current = current.children[char] else: return [] results = [] dfs(current, prefix, results) return results def auto_complete_system(commands: List[Tuple[str, Optional[str]]]) -> List[Optional[List[str]]]: trie = Trie() result = [] for command, value in commands: if command == \\"ADD\\": trie.add_word(value) result.append(None) elif command == \\"QUERY\\": suggestions = trie.query_prefix(value) result.append(suggestions) return result"},{"question":"# Coding Assessment Question You are working as a developer at a company that provides online courses. One of your tasks is to implement a function that computes the grade distribution for a list of student scores. Create a function `grade_distribution(scores: List[int]) -> Dict[str, int]` that processes a list of scores (integers between 0 and 100 inclusive) and returns the distribution of grades in the form of a dictionary. The grades should be distributed as follows: - A: 90-100 - B: 80-89 - C: 70-79 - D: 60-69 - F: Below 60 Your function should meet the following criteria: * **Input/Output Formats**: * **Input**: * `scores` (List[int]): A list of integer scores, each in the range 0 to 100 inclusive. * **Output**: * (Dict[str, int]): A dictionary with keys \'A\', \'B\', \'C\', \'D\', and \'F\', and values representing the count of scores in each grade range. * **Constraints and Limitations**: * The function should raise an exception with a meaningful message if any score in the input list is not within the range 0 to 100: * If any score is out-of-bounds, raise an Exception with the message \\"Score must be within the range 0 to 100\\". * **Performance Requirements**: * Ensure that the function runs efficiently with a time complexity of O(n) where n is the length of the input list. * Aim for a space complexity of O(1), assuming the dictionary of fixed size grades as constant space. * **Example**: ```python def grade_distribution(scores: List[int]) -> Dict[str, int]: # your implementation here # Test Cases print(grade_distribution([100, 95, 85, 75, 65, 55])) # Expected output: {\'A\': 2, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1} print(grade_distribution([50, 70, 80, 90])) # Expected output: {\'A\': 1, \'B\': 1, \'C\': 1, \'D\': 0, \'F\': 1} try: grade_distribution([50, 101]) # Expected output: Exception(\\"Score must be within the range 0 to 100\\") except Exception as e: print(e) try: grade_distribution([50, -1]) # Expected output: Exception(\\"Score must be within the range 0 to 100\\") except Exception as e: print(e) ``` Implementing this function will ensure a correctly computed distribution of grades for any list of student scores provided within the specified range.","solution":"from typing import List, Dict def grade_distribution(scores: List[int]) -> Dict[str, int]: Computes the grade distribution for a list of student scores. Args: scores (List[int]): A list of integer scores, each in the range 0 to 100 inclusive. Returns: Dict[str, int]: A dictionary with keys \'A\', \'B\', \'C\', \'D\', and \'F\', and values representing the count of scores in each grade range. Raises: Exception: If any score in the input list is outside the range 0 to 100. # Initialize the grade dictionary grade_counts = {\'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'F\': 0} for score in scores: if score < 0 or score > 100: raise Exception(\\"Score must be within the range 0 to 100\\") if score >= 90: grade_counts[\'A\'] += 1 elif score >= 80: grade_counts[\'B\'] += 1 elif score >= 70: grade_counts[\'C\'] += 1 elif score >= 60: grade_counts[\'D\'] += 1 else: grade_counts[\'F\'] += 1 return grade_counts"},{"question":"Friction Force on an Inclined Plane You are developing a simulation for a physics engine and need to calculate the friction force acting on an object on an inclined plane. The object has a given mass, the incline angle, and the coefficient of friction between the object and the plane. Task Write a function `friction_force_incline` that calculates the friction force acting on an object on an inclined plane. Function Signature ```python def friction_force_incline(mass: float, incline_angle: float, friction_coefficient: float) -> float: pass ``` Input - `mass` (float): The mass of the object. It should be a non-negative value. - `incline_angle` (float): The angle of the inclined plane in degrees. It should be between 0 and 90. - `friction_coefficient` (float): The coefficient of friction between the object and the inclined plane. It should be a non-negative value. Output - Returns the friction force (float) acting on the object. Constraints - Mass should be non-negative. - Incline angle should be between 0 and 90 degrees (inclusive). - The friction coefficient should be non-negative. Errors - The function should raise a `ValueError` if any of the input values are invalid (mass, incline_angle, or friction_coefficient out of specified ranges). Examples ```python friction_force_incline(10, 30, 0.5) # Should return 42.435 because friction force = 0.5 * 10 * 9.8 * cos(30 degrees) ≈ 42.435 friction_force_incline(0, 45, 0.5) # Should return 0.0 because mass is 0 friction_force_incline(10, 0, 0.3) # Should return 29.4 because the incline is flat and friction force = 0.3 * 10 * 9.8 ≈ 29.4 friction_force_incline(10, 90, 0.3) # Should return 0.0 because the object is falling vertically ``` Hints - The normal force on an inclined plane is calculated using the formula ( N = m cdot g cdot cos(text{incline_angle}) ), where ( g = 9.8 , text{m/s}^2 ). - The friction force is then ( f = text{friction_coefficient} cdot N ).","solution":"import math def friction_force_incline(mass: float, incline_angle: float, friction_coefficient: float) -> float: Calculates the friction force acting on an object on an inclined plane. Parameters: mass (float): The mass of the object. It should be a non-negative value. incline_angle (float): The angle of the inclined plane in degrees. It should be between 0 and 90. friction_coefficient (float): The coefficient of friction between the object and the inclined plane. It should be a non-negative value. Returns: float: The friction force acting on the object. Raises: ValueError: If any of the input values are invalid. if mass < 0: raise ValueError(\\"Mass must be non-negative\\") if not (0 <= incline_angle <= 90): raise ValueError(\\"Incline angle must be between 0 and 90 degrees\\") if friction_coefficient < 0: raise ValueError(\\"Friction coefficient must be non-negative\\") g = 9.8 # acceleration due to gravity in m/s^2 incline_angle_radians = math.radians(incline_angle) normal_force = mass * g * math.cos(incline_angle_radians) friction_force = friction_coefficient * normal_force return friction_force"},{"question":"# Efficient Word Count in Large Text Files You are tasked with developing an efficient solution to count the frequency of each word in a large text file. **Objective**: Write a Python function named `word_count` that reads a text file and returns a dictionary containing the frequency of each word. The function should handle large files efficiently. **Function Signature**: ```python def word_count(file_path: str) -> dict: pass ``` **Input**: - `file_path` (str): The path to the input text file. **Output**: - (dict): A dictionary where the keys are words and the values are the counts of those words in the text file. **Constraints**: - The input text file can be very large, possibly exceeding available memory if loaded entirely. - Words are considered case-insensitively (e.g., \\"Word\\" and \\"word\\" should be counted as the same). - Non-alphabetic characters should be stripped from words (e.g., \\"word,\\" should be counted as \\"word\\"). **Performance**: - Aim for a time complexity of O(N), where N is the total number of words in the text file. - Space complexity should be efficient, considering the potential size of the file. Use streaming to process the file if necessary. **Python Libraries**: - You may use standard Python libraries such as `collections`. **Example**: ```python # Assuming the text file contains: \\"Hello, world! Hello...\\" word_count(\'example.txt\') # Output: {\'hello\': 2, \'world\': 1} ``` # Context: Efficiently processing and analyzing large text data is a common task in fields like data science, text analytics, and natural language processing. This question aims to test the candidate\'s ability to handle large data streams and implement effective word processing techniques.","solution":"import re from collections import defaultdict def word_count(file_path: str) -> dict: Reads a text file and returns a dictionary with the frequency of each word. Args: file_path (str): The path to the input text file. Returns: dict: A dictionary where the keys are words and the values are the word counts. word_freq = defaultdict(int) word_pattern = re.compile(r\'b[a-z]+b\') with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: words = word_pattern.findall(line.lower()) for word in words: word_freq[word] += 1 return word_freq"},{"question":"# Remove K-th Last Element from Linked List You are given a singly linked list and tasked with writing a function that removes the k-th last element from the list. The function should return the head of the modified linked list. # Requirements 1. Implement the function `remove_kth_from_end(head, k)` where `head` is the head node of the linked list and `k` is an integer representing the k-th last element to remove. 2. The function should perform this in one pass using two pointers. # Input - `head`: The head of the singly linked list. - `k`: An integer representing the k-th last element to remove. # Output - The function should return the head of the modified linked list. # Example ```python class ListNode: def __init__(self, x): self.val = x self.next = None # Helper function to create a linked list from a list and return the head node def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for element in lst[1:]: current.next = ListNode(element) current = current.next return head # Creating a LinkedList [1, 2, 3, 4, 5] head = create_linked_list([1, 2, 3, 4, 5]) k = 2 # Calling your remove_kth_from_end function new_head = remove_kth_from_end(head, k) # Output LinkedList should be: [1, 2, 3, 5] ``` # Constraints 1. The linked list length is at least 1. 2. 1 ≤ k ≤ the length of the linked list. 3. Optimize the function to run in O(n) time complexity, where n is the number of nodes in the linked list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_kth_from_end(head, k): Removes the k-th last element from the linked list and returns the head of the modified list. :param head: ListNode, the head of the linked list :param k: int, the k-th last element to remove :return: ListNode, the head of the modified linked list # Create a dummy node to handle edge cases smoothly dummy = ListNode(0) dummy.next = head # Initialize two pointers first = dummy second = dummy # Move the first pointer so that it is k+1 nodes ahead of the second pointer for _ in range(k+1): first = first.next # Move both pointers until the first one reaches the end while first: first = first.next second = second.next # Remove the k-th last element second.next = second.next.next return dummy.next"},{"question":"# CODING ASSESSMENT QUESTION Introduction You are developing software for a simple microcontroller-based light-dimming system using Pulse Width Modulation (PWM). PWM is a technique used to control the brightness of an LED by varying the duty cycle of a square wave signal. The frequency of the PWM signal is fixed, but the duty cycle determines the brightness level. You need to implement two functions to compute the duty cycle and control the brightness level of an LED accordingly. Problem Description Write two functions `compute_pwm_duty_cycle` and `set_brightness_level`: 1. **PWM Duty Cycle Calculation**: [ text{Duty Cycle (%) }= left(frac{text{brightness}}{255}right) times 100 ] - Inputs: - brightness (int): The brightness level of the LED, ranging from 0 (off) to 255 (full brightness). - Output: (float) The duty cycle in percent. - Constraints: The brightness level should be an integer between 0 and 255 (inclusive). 2. **Setting Brightness Level**: Given a list of brightness levels (integers between 0 and 255), return a corresponding list of duty cycles. - Inputs: - brightness_levels (List[int]): A list of brightness levels. - Output: (List[float]) A list of duty cycles in percent. - Constraints: The list of brightness levels should have at least one element and all values should be integers between 0 and 255 (inclusive). Function Signatures ```python def compute_pwm_duty_cycle(brightness: int) -> float: pass def set_brightness_level(brightness_levels: List[int]) -> List[float]: pass ``` Expected Input and Output ``` >>> compute_pwm_duty_cycle(128) 50.19607843137255 >>> compute_pwm_duty_cycle(255) 100.0 >>> compute_pwm_duty_cycle(0) 0.0 >>> set_brightness_level([0, 64, 128, 192, 255]) [0.0, 25.098039215686274, 50.19607843137255, 75.29411764705883, 100.0] >>> set_brightness_level([100, 150, 200]) [39.21568627450981, 58.82352941176471, 78.43137254901961] ``` Constraints 1. If any brightness level is outside the range of 0 to 255, the function should raise a `ValueError` with a message `Brightness must be between 0 and 255`. 2. Ensure the list of brightness levels has at least one element. Provide a robust solution that factors in edge cases and verify it using the provided examples.","solution":"def compute_pwm_duty_cycle(brightness: int) -> float: Computes the PWM duty cycle as a percentage based on the provided brightness. Parameters: brightness (int): The brightness level of the LED, ranging from 0 (off) to 255 (full brightness). Returns: float: The duty cycle as a percentage. if not 0 <= brightness <= 255: raise ValueError(\'Brightness must be between 0 and 255\') return (brightness / 255) * 100 def set_brightness_level(brightness_levels: list) -> list: Converts a list of brightness levels to their respective duty cycles. Parameters: brightness_levels (List[int]): A list of brightness levels. Returns: List[float]: A list of duty cycles as percentages. if not brightness_levels: raise ValueError(\'The list of brightness levels must contain at least one element\') return [compute_pwm_duty_cycle(brightness) for brightness in brightness_levels]"},{"question":"# Coding Assessment Question Problem Statement You are required to write a function to organize a list of course prerequisites. Given a list of dependencies between courses, you need to determine a valid ordering of courses to take them all, if possible. This involves implementing a topological sort algorithm that can detect cycles and handle invalid inputs properly. Input Format - A list of tuples `prerequisites` where each tuple consists of two integers (a, b) indicating that course `b` must be taken before course `a`. - An integer `num_courses` representing the total number of courses labeled from 0 to `num_courses-1`. Output Format - A list of integers representing a valid order in which to take the courses. - If no valid order exists due to a cycle in the prerequisites, return an empty list. Constraints - 1 <= num_courses <= 1000 - 0 <= a, b < num_courses - The input list `prerequisites` can be empty, indicating no dependencies. Example ```python prerequisites = [(1, 0), (2, 1), (3, 2), (4, 3)] num_courses = 5 print(find_course_order(num_courses, prerequisites)) # Expected Output: [0, 1, 2, 3, 4] prerequisites = [(1, 0), (0, 1)] num_courses = 2 print(find_course_order(num_courses, prerequisites)) # Expected Output: [] ``` Function Signature ```python def find_course_order(num_courses: int, prerequisites: list[tuple[int, int]]) -> list[int]: pass ``` Requirements 1. Implement the `find_course_order` function that correctly follows the stated requirements. 2. Detect and handle cycles by returning an empty list if they exist. 3. Ensure the solution is efficient and can handle the upper limit of input sizes effectively.","solution":"from collections import deque, defaultdict def find_course_order(num_courses: int, prerequisites: list[tuple[int, int]]) -> list[int]: # Create adjacency list and in-degree dictionary adj_list = defaultdict(list) in_degree = [0] * num_courses # Build the graph for dest, src in prerequisites: adj_list[src].append(dest) in_degree[dest] += 1 # Queue for courses with no prerequisites queue = deque([course for course in range(num_courses) if in_degree[course] == 0]) order = [] while queue: course = queue.popleft() order.append(course) for neighbor in adj_list[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if topological sort is possible (i.e., no cycles) if len(order) == num_courses: return order else: return []"},{"question":"**String Transformation to URL** Problem Statement: You are asked to create a function to convert a given string into a valid URL format. Your function should replace spaces with \'%20\', removing leading or trailing whitespaces, and ensure that any consecutive spaces in the middle of the text are reduced to a single \'%20\'. Requirements: - Implement a function `string_to_url` that takes a string input and returns its URL-encoded format. - The function should replace all spaces with \'%20\', ensuring there are no leading or trailing \'%20\'. - Consecutive spaces should be reduced to a single \'%20\' in the middle of the string. Input: - `string` (String input that may contain spaces, leading, trailing, or multiple consecutive spaces). Output: - `str`: A single URL-encoded string. Constraints: - The function should handle any given string with spaces properly encoded. - The use of built-in URL libraries or functions that perform this exact transformation is restricted. # Function Signature: ```python def string_to_url(s: str) -> str: # Transforms the input string into its URL-encoded format. pass ``` Example: ```python assert string_to_url(\\"hello world\\") == \\"hello%20world\\" assert string_to_url(\\" hello world \\") == \\"hello%20world\\" assert string_to_url(\\"John Doe\\") == \\"John%20Doe\\" assert string_to_url(\\" A quick brown fox \\") == \\"A%20quick%20brown%20fox\\" ``` Explanation: 1. For the input `\\"hello world\\"`, there is one space between words that should be converted to \'%20\'. 2. For the input `\\" hello world \\"`, the leading and trailing spaces should be removed, and the single space between `\'hello\'` and `\'world\'` should be represented by \'%20\'. 3. For the input `\\"John Doe\\"`, multiple spaces should be reduced to a single \'%20\'. 4. For the input `\\" A quick brown fox \\"`, remove leading/trailing spaces and replace all spaces between words by a single \'%20\'.","solution":"def string_to_url(s: str) -> str: Transforms the input string into its URL-encoded format by: 1. Removing leading and trailing whitespaces. 2. Replacing all spaces with \'%20\'. 3. Ensuring consecutive spaces are reduced to a single \'%20\'. # Remove leading/trailing whitespaces s = s.strip() # Replace one or more spaces with \'%20\' url_encoded_string = \'%20\'.join(s.split()) return url_encoded_string"},{"question":"# Question: Determine the Least Common Multiple (LCM) of Multiple Integers Background The least common multiple (LCM) of two or more integers is the smallest positive integer that is divisible by each of them. It is a commonly used concept in number theory and has applications in solving problems involving synchronization, scheduling, and more. Task Your task is to write a function that computes the LCM of a list of integers. # Function Specifications `lcm_multiple(nums: List[int]) -> int` - **Input**: `nums` (List of integers) - **Output**: Returns the LCM of the list of integers as an integer. - **Constraints**: - The list `nums` will contain between 2 and 100 integers. - Each integer in `nums` will be between 1 and 10^6 inclusive. # Example Usage ```python print(lcm_multiple([4, 6])) # 12 print(lcm_multiple([1, 2, 3, 4, 5])) # 60 print(lcm_multiple([5, 10, 15])) # 30 print(lcm_multiple([10, 20, 30, 40])) # 120 ``` # Notes 1. You may use helper functions as needed to break down the problem. 2. Consider optimizing the function to handle the upper limits of the constraints efficiently. 3. Edge cases involving large values should be tested to ensure the function performs well without running into performance issues.","solution":"from math import gcd from functools import reduce from typing import List def lcm(a: int, b: int) -> int: Helper function to calculate the least common multiple (LCM) of two numbers a and b. return abs(a * b) // gcd(a, b) def lcm_multiple(nums: List[int]) -> int: Returns the least common multiple (LCM) of a list of integers. return reduce(lcm, nums)"},{"question":"# Coding Assessment Question **Scenario**: As a software engineer, you often encounter scenarios where data structures require modifications based on dynamic conditions. One such scenario is manipulating linked lists to remove elements based on certain criteria. Understanding how to traverse and modify linked lists is crucial in handling database records, real-time data streams, and other applications. **Problem Statement**: Implement a function `remove_elements()` that removes all nodes from a singly linked list that have a specific value. Your task is to create functions that will allow you to define a linked list structure, traverse it, and remove the specified elements. Definitions - Define a `ListNode` class to create linked list nodes. - Implement the function `remove_elements(head: ListNode, val: int) -> ListNode` that removes all nodes from the linked list with the value `val`. Class and Function Signatures ```python # Definition for singly-linked list. class ListNode: def __init__(self, val: int, next: \'ListNode\' = None): self.val = val self.next = next def remove_elements(head: ListNode, val: int) -> ListNode: # Implementation here ``` Input & Output Formats - **Input**: A `head` node of a singly linked list where each node contains an integer value, and an integer `val` which represents the value to be removed. - **Output**: The `head` node of the modified linked list with all nodes containing `val` removed. Constraints - The number of nodes in the linked list is in the range `[0, 10^4]`. - `-10^4 <= Node.val <= 10^4` - `-10^4 <= val <= 10^4` Examples ```python >>> # Example 1 >>> head = ListNode(1, ListNode(2, ListNode(6, ListNode(3, ListNode(4, ListNode(5, ListNode(6))))))) >>> new_head = remove_elements(head, 6) >>> while new_head: >>> print(new_head.val, end=\\" \\") >>> new_head = new_head.next 1 2 3 4 5 >>> # Example 2 >>> head = ListNode(7, ListNode(7, ListNode(7))) >>> new_head = remove_elements(head, 7) >>> new_head is None True >>> # Example 3 >>> head = None >>> new_head = remove_elements(head, 1) >>> new_head is None True ``` **Note**: Make sure your implementation is correct and handles edge cases like an empty list or cases where all nodes need to be removed effectively.","solution":"class ListNode: def __init__(self, val: int, next: \'ListNode\' = None): self.val = val self.next = next def remove_elements(head: ListNode, val: int) -> ListNode: dummy = ListNode(0) dummy.next = head current = dummy while current.next is not None: if current.next.val == val: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"**Context**: Graph traversal algorithms are crucial for exploring the nodes and connections in various data structures, such as social networks, maps, and dependency graphs. Breadth-First Search (BFS) is a fundamental algorithm used for this purpose, characterized by its ability to explore all nodes at the present depth level before moving on to nodes at the next depth level. # Problem Statement Implement the Breadth-First Search (BFS) algorithm to traverse a graph from a specified starting node. Your function should return the order in which nodes are visited. # Requirements * **Function Name**: `bfs_traversal` * **Input**: A dictionary representation of an undirected graph `graph`, and a starting node `start`. * **Output**: A list of nodes in the order they are visited. # Constraints - The graph is represented as an adjacency list. - Ensure all nodes are visited, considering the graph may be disconnected. - The starting node is guaranteed to be in the graph. # Example ```python def bfs_traversal(graph: dict, start: int) -> list: # Your code here # Example: graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1], 5: [2] } print(bfs_traversal(graph, 0)) # Output: [0, 1, 2, 3, 4, 5] print(bfs_traversal(graph, 1)) # Output: [1, 0, 3, 4, 2, 5] print(bfs_traversal(graph, 3)) # Output: [3, 1, 0, 4, 2, 5] ``` # Special Considerations - Ensure the function handles graphs with varying structures, including cycles and disconnected components. - Handle any invalid input gracefully by raising appropriate exceptions or returning suitable error messages. - The function should operate efficiently even for larger graphs. # Testing Create a series of unit tests to validate your function under different scenarios, including edge cases such as empty graphs, graphs with a single node, and graphs with multiple disconnected components.","solution":"from collections import deque def bfs_traversal(graph: dict, start: int) -> list: Perform BFS traversal on the graph starting from the given node. :param graph: Dictionary representing the adjacency list of the graph. :param start: The starting node for BFS traversal. :return: A list of nodes in the order they are visited. visited = set() queue = deque([start]) traversal_order = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) traversal_order.append(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return traversal_order"},{"question":"# Context: You are given a text editor application to manage user documents on a cloud server. In the current scenario, the text editor utilizes an efficient version control system to keep track of changes. Each document is stored along with a history of versions. The goal is to implement additional functions to handle version control for documents effectively. # Problem: 1. Write a method `commit(self, doc_id, content)` that saves the current state of a document as a new version. This method should add a new version to the document\'s history. 2. Write a method `rollback(self, doc_id, version)` that reverts the document to a specified version. This method should replace the current document content with the content from the specified version. # Implementation Details: - Class definition: `class DocumentVersionControl:` - Methods to implement: * `def commit(self, doc_id, content):` * `def rollback(self, doc_id, version):` # Input: - `commit(self, doc_id, content)` takes two parameters: * `doc_id` (string): The unique identifier of the document. * `content` (string): The current content of the document to be saved. - `rollback(self, doc_id, version)` takes two parameters: * `doc_id` (string): The unique identifier of the document. * `version` (int): The version number to which the document should be reverted. # Output: - `commit(self, doc_id, content)` should return the new version number. - `rollback(self, doc_id, version)` should return `None` after reverting the document to the specified version. # Constraints: - The `doc_id` is guaranteed to be unique for each document. - Version numbers are integers starting from 0 for each document. - You can assume the document history is maintained as a list of versions, and each version is a dictionary with a version number and content. - The `version` parameter in `rollback` is guaranteed to be a valid version number. # Performance Requirements: - `commit(self, doc_id, content)` should have an average time complexity of O(1). - `rollback(self, doc_id, version)` should have an average time complexity of O(1). # Example Usage: ```python version_control = DocumentVersionControl() # Committing new versions version_control.commit(\'doc1\', \'Initial content\') version_control.commit(\'doc1\', \'Updated content\') # Rolling back to a previous version version_control.rollback(\'doc1\', 0) # Retrieving the current content of \'doc1\' print(version_control.get_current_content(\'doc1\')) # Output: \'Initial content\' ```","solution":"class DocumentVersionControl: def __init__(self): self.documents = {} def commit(self, doc_id, content): if doc_id not in self.documents: self.documents[doc_id] = [] version = len(self.documents[doc_id]) self.documents[doc_id].append({\'version\': version, \'content\': content}) return version def rollback(self, doc_id, version): if doc_id in self.documents and 0 <= version < len(self.documents[doc_id]): self.documents[doc_id] = self.documents[doc_id][:version + 1] def get_current_content(self, doc_id): if doc_id in self.documents and self.documents[doc_id]: return self.documents[doc_id][-1][\'content\'] return None"},{"question":"# Longest Increasing Subsequence Challenge **Context**: You are developing a component of a stock market predictor that needs to analyze long-term increasing trends in stock prices. An important part of this is to identify the longest sequence of days where stock prices continuously increased. **Problem Statement**: Implement a function `longest_increasing_subsequence` that takes a list of integers representing daily stock prices and returns the length of the longest increasing subsequence (LIS). **Function Signature**: ```python from collections.abc import Sequence def longest_increasing_subsequence(prices: Sequence[int]) -> int: Finds the length of the longest increasing subsequence in the list of stock prices. :param prices: the given list of daily stock prices. :return: the length of the longest increasing subsequence. ``` **Input**: - `prices`: A sequence (list) of integers representing daily stock prices. **Output**: - An integer representing the length of the longest increasing subsequence. **Constraints**: - The elements of `prices` are integers, and can be both positive or negative. - The length of `prices` will be at most 10^6. - If `prices` is empty, the function should return 0. **Examples**: ```python print(longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60])) # Output: 5 (The subsequence is [10, 22, 33, 50, 60]) print(longest_increasing_subsequence([3, 10, 2, 1, 20])) # Output: 3 (The subsequence is [3, 10, 20]) print(longest_increasing_subsequence([3, 2])) # Output: 1 (The subsequence is either [3] or [2]) print(longest_increasing_subsequence([50, 3, 10, 7, 40, 80])) # Output: 4 (The subsequence is [3, 7, 40, 80]) print(longest_increasing_subsequence([-1, -2, -3, -4])) # Output: 1 (The subsequence is any single element) print(longest_increasing_subsequence([])) # Output: 0 ``` **Key Considerations**: - Ensure you handle edge cases such as empty lists and lists with no increasing subsequence correctly. - Optimize both time and space to achieve the best performance given the constraints. The function should be efficient enough to handle up to 1,000,000 elements.","solution":"from collections.abc import Sequence import bisect def longest_increasing_subsequence(prices: Sequence[int]) -> int: Finds the length of the longest increasing subsequence in the list of stock prices. :param prices: the given list of daily stock prices. :return: the length of the longest increasing subsequence. if not prices: return 0 tails = [] for price in prices: pos = bisect.bisect_left(tails, price) if pos == len(tails): tails.append(price) else: tails[pos] = price return len(tails)"},{"question":"# Task Write a function `flatten_nested_list` that takes a list which may contain nested lists of arbitrary depth and returns a flat list containing all the elements in the original list, preserving their order. # Input * A list `nested_list` which may contain integers and/or other nested lists. # Output * A flattened list containing all the integers from the input list and any nested lists, in the same order they appear. # Constraints * Ensure the function handles edge cases such as empty lists or lists with only nested empty lists. * Make sure the function works efficiently for deeply nested lists up to a depth of 10. # Example ```python >>> flatten_nested_list([1, [2, 3, [4, 5]], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_nested_list([1, [2], [[3]], [[[4]]], []]) [1, 2, 3, 4] >>> flatten_nested_list([[]]) [] >>> flatten_nested_list([1, [2, [3, [4, [5, [6]]]]]]) [1, 2, 3, 4, 5, 6] # Notes 1. The function should handle lists of integers and nested lists of arbitrary depth. 2. Make use of recursion or an iterative stack-based approach to access all nested elements. 3. The output list should be a new list containing all elements from the input without any nested structure.","solution":"def flatten_nested_list(nested_list): Flattens a nested list of arbitrary depth. Parameters: nested_list (list): A list containing integers and/or nested lists. Returns: list: A flat list containing all the integers from the nested list in order. flat_list = [] for item in nested_list: if isinstance(item, list): flat_list.extend(flatten_nested_list(item)) else: flat_list.append(item) return flat_list"},{"question":"# Task You are improving an e-commerce website, and you need to add a feature that calculates the total value of items in a shopping cart including the tax. The tax is applied as a percentage of the total price of the items. # Requirements 1. Implement a function to calculate the total price including tax. 2. Efficiently handle different data types for price inputs. 3. Provide appropriate error handling for invalid inputs. # Function Signature ```python def calculate_total(cart: list, tax_rate: float) -> float: Calculates the total price of items in the cart including the tax. Parameters: cart (list): A list of item prices (int or float). tax_rate (float): Tax rate as a percentage (e.g. 5 for 5%). Returns: float: The total price including the tax. Examples: >>> calculate_total([23.99, 15, 9.50], 7) 52.3193 >>> calculate_total([199.99, 35.49, 89.99, 49.95], 10) 416.414 # Your implementation here ``` # Constraints - Ensure `cart` is a list and `tax_rate` is a positive float. Raise a `TypeError` if they aren\'t. - All elements in `cart` must be ints or floats. Raise a `TypeError` for any invalid types. - `tax_rate` should be non-negative. Raise a `ValueError` for negative values. # Testing 1. Verify the implementation with varying sizes of `cart`. 2. Validate the function with edge cases (e.g., cart with a single item, or no items). 3. Include several unit tests to check the correctness of the function under normal and abnormal scenarios.","solution":"def calculate_total(cart: list, tax_rate: float) -> float: Calculates the total price of items in the cart including the tax. Parameters: cart (list): A list of item prices (int or float). tax_rate (float): Tax rate as a percentage (e.g. 5 for 5%). Returns: float: The total price including the tax. # Validate input types if not isinstance(cart, list): raise TypeError(\\"cart must be a list\\") if not isinstance(tax_rate, (int, float)): raise TypeError(\\"tax_rate must be a float or an int\\") # Validate item types and tax_rate values for item in cart: if not isinstance(item, (int, float)): raise TypeError(\\"All items in the cart must be int or float\\") if tax_rate < 0: raise ValueError(\\"tax_rate must be non-negative\\") total_without_tax = sum(cart) tax_amount = total_without_tax * (tax_rate / 100) total_with_tax = total_without_tax + tax_amount return total_with_tax"},{"question":"# Find Pair with Given Sum - Binary Search Challenge **Context**: You are tasked with finding a pair of numbers in a sorted array that adds up to a given target sum. This problem requires an efficient solution that leverages the properties of the sorted array. Your goal is to implement an algorithm that finds such a pair, if it exists, using binary search techniques to optimize performance. **Function to Implement**: ```python def find_pair_with_sum(arr: list[int], target_sum: int) -> tuple[int, int]: pass ``` **Input**: - `arr` (list of ints): A sorted list of integers. - `target_sum` (int): An integer representing the target sum to find. **Output**: - Returns a tuple of two integers representing the pair that adds up to the target sum, or an empty tuple if no such pair exists. **Constraints**: - Array length: 0 <= len(arr) <= 10^3 - Elements value range: -10^6 <= arr[i] <= 10^6 **Performance Requirements**: - Aim for a solution with O(n) time complexity by utilizing the sorted property of the array. **Examples**: ```python assert find_pair_with_sum([1, 2, 3, 4, 6], 6) == (1, 5) assert find_pair_with_sum([2, 3, 4, 8, 12], 16) == (4, 12) assert find_pair_with_sum([1, 1, 1, 1], 2) == (1, 1) assert find_pair_with_sum([-1, 0, 1, 2, 3, 4], 3) == (-1, 4) assert find_pair_with_sum([5, 10, 15], 30) == () ``` **Hint**: - Consider using a two-pointer approach where one pointer starts from the beginning, and the other starts from the end of the array. - Move the pointers towards each other depending on the sum of the elements at the pointers relative to the target sum.","solution":"def find_pair_with_sum(arr, target_sum): Finds a pair of numbers in a sorted array that add up to a given target sum. Params: arr (list of ints): A sorted list of integers. target_sum (int): The target sum for the pair of numbers. Returns: tuple: A tuple containing the pair of numbers that add up to the target sum, or an empty tuple if no such pair exists. left = 0 right = len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target_sum: return (arr[left], arr[right]) elif current_sum < target_sum: left += 1 else: right -= 1 return ()"},{"question":"# Matrix Rotation Problem You are tasked with implementing a function to rotate a given NxN matrix 90 degrees clockwise. The function should handle possible edge cases such as an empty matrix or a non-square matrix input. Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix 90 degrees clockwise. :param matrix: A list of lists representing the NxN matrix. :return: A new list of lists representing the rotated matrix. # Your code here ``` # Input * `matrix`: A list of lists of integers representing the NxN matrix. # Output * A new list of lists of integers representing the rotated matrix. # Constraints * The function should raise an appropriate exception for non-square matrices or non-list inputs. * The function should handle an empty matrix by returning an empty list. * Ensure the function performs optimally for large matrices. # Additional Requirements * You should ensure that the function processes only valid square matrices (NxN). * The function should handle edge cases such as empty matrices or single-element matrices correctly. # Example 1. **Input**: matrix = ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` **Output**: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. **Input**: matrix = ``` [ [1] ] ``` **Output**: ``` [ [1] ] ``` 3. **Input**: matrix = [] **Output**: [] # Implementation Note * Use a layer-by-layer approach to rotate the matrix in place, ensuring memory efficiency. ```python from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: if not isinstance(matrix, list) or any(not isinstance(row, list) for row in matrix): raise TypeError(\\"Input must be a matrix (list of lists).\\") if not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a square matrix.\\") n = len(matrix) if n == 0: return matrix # Rotate the matrix layer by layer for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first top = matrix[first][i] # save top # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top return matrix ``` This question challenges the candidate to handle typical matrix operations, ensuring they respect constraints and handle edge cases. The difficulty is in line with recursive operations and requires knowledge of matrix manipulation techniques.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix 90 degrees clockwise. :param matrix: A list of lists representing the NxN matrix. :return: A new list of lists representing the rotated matrix. if not isinstance(matrix, list) or any(not isinstance(row, list) for row in matrix): raise TypeError(\\"Input must be a matrix (list of lists).\\") if not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a square matrix.\\") n = len(matrix) if n == 0: return matrix # Create a new matrix for the rotated result rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"Genome Sequence Matcher You are given a set of genome sequences as strings. Each sequence is composed of the characters \'A\', \'T\', \'C\', and \'G\'. Your task is to find the longest common subsequence (LCS) between two given sequences. The LCS is the longest sequence that can be derived from both sequences by deleting some elements (without reordering). Your task is to implement the functionality to find this LCS. # Function Definitions Implement the following function: 1. **`longest_common_subsequence`**: Finds the longest common subsequence between two genome sequences. ```python def longest_common_subsequence(seq1: str, seq2: str) -> str: Finds the longest common subsequence between two genome sequences. :param seq1: The first genome sequence as a string. :param seq2: The second genome sequence as a string. :return: The longest common subsequence as a string. pass ``` # Requirements 1. **Performance**: * Ensure the implementation has a time complexity of **O(m * n)**, where `m` and `n` are the lengths of the two sequences. 2. **Edge Cases**: * Handle cases where one or both sequences are empty. * Consider sequences of varying lengths, including very large sequences. * Consider scenarios where there is no common subsequence. # Input and Output * **Input**: Two genome sequences. * **Output**: The longest common subsequence as a string. # Example ```python # Example genome sequences seq1 = \\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\\" seq2 = \\"GTCGTTCGGAATGCCGTTGCTCTGTAAA\\" # Find longest common subsequence lcs = longest_common_subsequence(seq1, seq2) print(lcs) ``` *Expected Output*: ```python \\"GTCGTCGGAAGCCGGCCGAA\\" # Longest common subsequence ``` _Test your function with the following cases:_ 1. `longest_common_subsequence(\\"ATCG\\", \\"ATCG\\")` should return `\\"ATCG\\"`. 2. `longest_common_subsequence(\\"ACGT\\", \\"TGCA\\")` should return `\\"A\\"`. 3. `longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\")` should return `\\"GTAB\\"`. 4. `longest_common_subsequence(\\"\\", \\"AGGTAB\\")` should return `\\"\\"`. 5. `longest_common_subsequence(\\"AGGTAB\\", \\"\\")` should return `\\"\\"`.","solution":"def longest_common_subsequence(seq1, seq2): m, n = len(seq1), len(seq2) # Create a DP table to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the table in bottom-up manner for i in range(m): for j in range(n): if seq1[i] == seq2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) # LCS length is now dp[m][n], we build the LCS string from here i, j = m, n lcs = [] while i > 0 and j > 0: if dp[i][j] == dp[i - 1][j]: i -= 1 elif dp[i][j] == dp[i][j - 1]: j -= 1 else: lcs.append(seq1[i - 1]) i -= 1 j -= 1 return \'\'.join(reversed(lcs))"},{"question":"# Visitor Log System Context In a private library, you are responsible for keeping a log of visitors\' check-ins and check-outs. Each visitor\'s entry and exit times must be recorded, and at the end of the day, a report summarizing the total time each visitor spent in the library is generated. You need to implement a set of functions that can: 1. Add an entry time for a visitor. 2. Add an exit time for a visitor. 3. Calculate the total time spent by a visitor. 4. Generate the daily report. Tasks 1. **Implement the `check_in` function**: - **Input**: A string `visitor_name` and an integer `check_in_time` representing the time in minutes since midnight (0 <= check_in_time < 1440). - **Output**: None. The function should add the check-in time for the visitor in the log. 2. **Implement the `check_out` function**: - **Input**: A string `visitor_name` and an integer `check_out_time` representing the time in minutes since midnight (0 <= check_out_time < 1440). - **Output**: None. The function should add the check-out time for the visitor in the log. 3. **Implement the `total_time_spent` function**: - **Input**: A string `visitor_name`. - **Output**: An integer representing the total time in minutes that the visitor spent in the library. If a visitor has multiple check-ins and check-outs, sum the durations of each visit. 4. **Implement the `generate_report` function**: - **Output**: A dictionary with visitor names as keys and the total time spent as values. Example ```python # check_in and check_out examples check_in(\\"Alice\\", 480) # Alice checks in at 8:00 AM check_out(\\"Alice\\", 1020) # Alice checks out at 5:00 PM check_in(\\"Bob\\", 540) # Bob checks in at 9:00 AM check_out(\\"Bob\\", 660) # Bob checks out at 11:00 AM check_in(\\"Alice\\", 1080) # Alice checks in again at 6:00 PM check_out(\\"Alice\\", 1230) # Alice checks out at 8:30 PM # total_time_spent examples print(total_time_spent(\\"Alice\\")) # should return 690 (540 + 150) print(total_time_spent(\\"Bob\\")) # should return 120 # generate_report example report = generate_report() print(report) # should return {\'Alice\': 690, \'Bob\': 120} ``` **Constraints**: 1. Assume no overlapping check-ins or check-outs for the same visitor within a day. 2. Check-out always happens after a check-in. 3. The time tracking is based on a 24-hour period, i.e., from 00:00 (midnight) to 23:59. **Performance Requirement**: Your solution should efficiently handle typical usages, including multiple visitors with several check-ins and check-outs throughout the day. Optimal performance for very large datasets is not a primary concern.","solution":"from collections import defaultdict # Store the check-in and check-out times visitor_log = defaultdict(list) def check_in(visitor_name, check_in_time): Log the check-in time for a visitor. Args: visitor_name (str): Name of the visitor. check_in_time (int): Check-in time in minutes since midnight. visitor_log[visitor_name].append((check_in_time, None)) def check_out(visitor_name, check_out_time): Log the check-out time for a visitor. Args: visitor_name (str): Name of the visitor. check_out_time (int): Check-out time in minutes since midnight. for i in range(len(visitor_log[visitor_name])): if visitor_log[visitor_name][i][1] is None: visitor_log[visitor_name][i] = (visitor_log[visitor_name][i][0], check_out_time) break def total_time_spent(visitor_name): Calculate the total time spent by a visitor in the library. Args: visitor_name (str): Name of the visitor. Returns: int: Total time spent in minutes. total_time = 0 for check_in_time, check_out_time in visitor_log[visitor_name]: if check_out_time is not None: total_time += check_out_time - check_in_time return total_time def generate_report(): Generate a report of total time spent by each visitor. Returns: dict: Dictionary with visitor names as keys and total time spent as values. report = {} for visitor_name in visitor_log: report[visitor_name] = total_time_spent(visitor_name) return report"},{"question":"# Online Book Store Inventory Management Scenario In an online book store, managing the availability of books is crucial for providing positive customer experiences and ensuring that the inventory is accurately reflected. You need to implement an inventory management system that tracks the stock of books by their unique ISBN (International Standard Book Number). Task You are required to implement functionalities of an InventorySystem. Function Signature ```python class InventorySystem: def __init__(self) -> None: pass def add_book(self, isbn: str, quantity: int) -> None: pass def sell_book(self, isbn: str, quantity: int) -> str: pass def get_stock(self, isbn: str) -> int: pass ``` Requirements 1. **Initialization**: Instantiate the inventory system with no books initially. 2. **Add Book**: Add a certain quantity of a book to the inventory using its ISBN. 3. **Sell Book**: Sell a certain quantity of a book. If the requested quantity exceeds the available stock, return \\"Out of stock\\", otherwise adjust the inventory accordingly and return \\"Sale successful\\". 4. **Get Stock**: Return the current stock level of a given book by its ISBN. Constraints * 1 ≤ quantity ≤ 10^4 * All ISBNs are unique strings with a length of 10 or 13 characters. * The `add_book`, `sell_book`, and `get_stock` functions should run efficiently, ideally in O(1) average time complexity. Examples ```python # Example 1 inventory = InventorySystem() inventory.add_book(\\"1234567890\\", 50) # Add 50 copies of book with ISBN \\"1234567890\\" inventory.add_book(\\"0987654321\\", 30) # Add 30 copies of book with ISBN \\"0987654321\\" print(inventory.get_stock(\\"1234567890\\")) # Output: 50 inventory.sell_book(\\"1234567890\\", 10) # Output: \\"Sale successful\\" print(inventory.get_stock(\\"1234567890\\")) # Output: 40 inventory.sell_book(\\"0987654321\\", 40) # Output: \\"Out of stock\\" # Example 2 inventory = InventorySystem() inventory.add_book(\\"1234567890123\\", 100) # Add 100 copies of book with ISBN \\"1234567890123\\" print(inventory.get_stock(\\"1234567890123\\")) # Output: 100 inventory.sell_book(\\"1234567890123\\", 30) # Output: \\"Sale successful\\" print(inventory.get_stock(\\"1234567890123\\")) # Output: 70 inventory.sell_book(\\"1234567890123\\", 100) # Output: \\"Out of stock\\" ```","solution":"class InventorySystem: def __init__(self) -> None: self.inventory = {} def add_book(self, isbn: str, quantity: int) -> None: if isbn in self.inventory: self.inventory[isbn] += quantity else: self.inventory[isbn] = quantity def sell_book(self, isbn: str, quantity: int) -> str: if isbn not in self.inventory or self.inventory[isbn] < quantity: return \\"Out of stock\\" else: self.inventory[isbn] -= quantity return \\"Sale successful\\" def get_stock(self, isbn: str) -> int: return self.inventory.get(isbn, 0)"},{"question":"# Question: Merge and Reorder Linked Lists Given two singly linked lists, implement a function `merge_and_reorder_linked_lists(list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]` that merges the two linked lists into a single list and reorders the merged list such that the resulting list alternates between elements from `list1` and `list2`. If one list is longer than the other, append the remaining elements to the end of the merged list. # Input Format * `list1`: A singly linked list of integers with length ( 0 leq |list1| leq 10^5 ). * `list2`: A singly linked list of integers with length ( 0 leq |list2| leq 10^5 ). # Output Format * A singly linked list of integers representing the merged and reordered list. # Constraints * The function should maintain the relative order of elements from the original linked lists. # Example ```python # ListNode class definition for reference class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next # Utility function to create a linked list from a list def create_linked_list(vals): dummy = ListNode() current = dummy for val in vals: current.next = ListNode(val) current = current.next return dummy.next # Example usage list1 = create_linked_list([1, 2, 3]) list2 = create_linked_list([4, 5, 6]) result = merge_and_reorder_linked_lists(list1, list2) # Output List: 1 -> 4 -> 2 -> 5 -> 3 -> 6 ``` # Additional Notes 1. Explain the algorithm you used to merge and reorder the linked lists. 2. Highlight any edge cases, such as when one or both linked lists are empty, and how your function handles them. 3. Discuss the time complexity of your solution, ensuring it processes efficiently for the given constraints. By creating this seamless merge and reordering functionality, you\'ll demonstrate proficiency in linked list manipulations and handling edge cases in input data structure scenarios.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_and_reorder_linked_lists(list1, list2): dummy = ListNode() current = dummy toggle = True while list1 and list2: if toggle: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next toggle = not toggle # If any elements left in list1 or list2, append them if list1: current.next = list1 elif list2: current.next = list2 return dummy.next"},{"question":"# Coding Challenge: Longest Consecutive Sequence Problem Description Given an unsorted array of integers, `arr`, write a function that finds the length of the longest consecutive elements sequence. # Function Signature ```python def longest_consecutive_sequence(arr: list[int]) -> int: pass ``` # Input - `arr` (list of integers): An array of integers where we need to find the longest consecutive sequence. # Output - Returns an integer representing the length of the longest consecutive elements sequence. # Constraints - All integers in the array are between -10^6 and 10^6. - The length of the array, `n`, is between 0 and 10^5. # Example ```python # Example 1: arr = [100, 4, 200, 1, 3, 2] # Output should be 4 (sequence: 1, 2, 3, 4) # Example 2: arr = [0, 0, 1, -1, -2, 2] # Output should be 5 (sequence: -2, -1, 0, 1, 2) # Example 3: arr = [9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6] # Output should be 7 (sequence: -1, 0, 1, 3, 4, 5, 6) # Example 4: arr = [] # Output should be 0 (no elements) ``` # Constraints and Requirements - You should handle edge cases, such as an empty array and arrays with duplicate elements. - Aim to optimize the function to achieve a better time complexity than O(n log n). # Performance Requirements - The function should handle arrays with lengths up to 100,000 efficiently. # Scenario In a large dataset of timestamps in seconds, you need to find the longest period where timestamp data was collected consecutively. This helps in identifying the periods of continuous data logging and understanding system uptime.","solution":"def longest_consecutive_sequence(arr: list[int]) -> int: if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: # Only check for the start of the sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Coding Task: Validate Binary Search Tree with Custom Comparator Background Given a binary tree, your task is to implement an algorithm that validates whether it is a Binary Search Tree (BST) using a custom comparator function. The comparator function will dictate the ordering of the nodes. Function Signature ```python def validate_bst(root, comparator): Determine if the binary tree is a valid binary search tree based on the given comparator. root : The root node of the binary tree. comparator : A lambda function used to compare the nodes. Returns True if the tree is a valid BST, otherwise False. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> comparator = lambda x, y: x < y >>> validate_bst(root, comparator) True >>> root = TreeNode(10) >>> root.left = TreeNode(15) # This violates the BST rule >>> root.right = TreeNode(5) >>> comparator = lambda x, y: x < y >>> validate_bst(root, comparator) False ``` Input 1. **root**: An instance of a `TreeNode`, representing the root of the binary tree. 2. **comparator**: A lambda function that takes two arguments and returns a boolean, defining the custom ordering of the nodes. Output * Returns `True` if the binary tree satisfies the BST property based on the comparator, otherwise returns `False`. Constraints * The number of nodes in the tree is in the range [1, 1000]. * The comparator is a valid function that can be applied to node values in the tree. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) comparator = lambda x, y: x < y print(validate_bst(root, comparator)) # Output: True # Example 2 root = TreeNode(10) root.left = TreeNode(15) # This violates the BST rule root.right = TreeNode(5) comparator = lambda x, y: x < y print(validate_bst(root, comparator)) # Output: False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def validate_bst(root, comparator): Determine if the binary tree is a valid binary search tree based on the given comparator. root : The root node of the binary tree. comparator : A lambda function used to compare the nodes. Returns True if the tree is a valid BST, otherwise False. def validate(node, low, high): if not node: return True if low is not None and not comparator(low, node.val): return False if high is not None and not comparator(node.val, high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root, None, None)"},{"question":"# Find Missing Element in Range You are asked to write a function that finds the missing element in an array that contains all the elements from a certain range except one. Specifically, given an array of unique integers that represent a sequence from a start value to an end value, return the missing integer. Function Signature ```python def find_missing_element(arr: list, start: int, end: int) -> int: Finds the missing element in an array containing unique integers within a specified range. Args: arr: List of unique integers representing a sequence with one missing element. start: The starting integer of the range. end: The ending integer of the range. Returns: The missing integer from the array. Example: >>> find_missing_element([1, 2, 4, 5], 1, 5) 3 >>> find_missing_element([10, 11, 13], 10, 13) 12 # Your code goes here ``` Input and Output * **Input**: * `arr` (list): A list of unique integers within the specified range, with exactly one element missing. * `start` (int): The starting integer of the range. * `end` (int): The ending integer of the range. * **Output**: * Return the missing integer from the array. Constraints * The length of `arr` will be `end - start`. * The values in the array and the range will be integers. * The array may contain a mix of positive and negative integers. Performance Requirements * The function should run in linear time, O(n), where n is the length of the array.","solution":"def find_missing_element(arr: list, start: int, end: int) -> int: Finds the missing element in an array containing unique integers within a specified range. Args: arr: List of unique integers representing a sequence with one missing element. start: The starting integer of the range. end: The ending integer of the range. Returns: The missing integer from the array. Example: >>> find_missing_element([1, 2, 4, 5], 1, 5) 3 >>> find_missing_element([10, 11, 13], 10, 13) 12 total_sum = sum(range(start, end + 1)) array_sum = sum(arr) return total_sum - array_sum"},{"question":"# Problem Statement: You are developing a software application for managing a library\'s book inventory. One of the required functionalities is to determine if a book can be categorized as a bestseller. A book is considered a bestseller if it has been checked out at least 50 times. # Requirements: Implement a function `is_bestseller(checkout_count: int) -> bool` that determines whether a book is a bestseller based on the number of times it has been checked out. The function should: 1. Return `True` if the checkout count is 50 or more. 2. Return `False` if the checkout count is less than 50. 3. Raise a `ValueError` with a descriptive message if the checkout count is negative. # Input: * One integer representing the checkout count. # Output: * A boolean value indicating whether the book is a bestseller. # Constraints: * (checkout_count geq 0) # Example: ```python def is_bestseller(checkout_count: int) -> bool: pass # Example Usage: try: print(is_bestseller(60)) # Should output True except ValueError as e: print(e) try: print(is_bestseller(30)) # Should output False except ValueError as e: print(e) try: print(is_bestseller(-5)) # Should raise ValueError except ValueError as e: print(e) # Output: \\"Checkout count cannot be negative\\" ``` # Note: * Ensure proper error handling for invalid inputs. * Focus on maintaining clarity and simplicity in logic.","solution":"def is_bestseller(checkout_count: int) -> bool: Determines if a book is a bestseller based on the checkout count. Args: checkout_count (int): The number of times the book has been checked out. Returns: bool: True if the book is a bestseller (checkout count >= 50), otherwise False. Raises: ValueError: If the checkout count is negative. if checkout_count < 0: raise ValueError(\\"Checkout count cannot be negative\\") return checkout_count >= 50"},{"question":"# Morse Code Encoder and Decoder Objective Implement the encoding and decoding functions for Morse Code. Problem Statement Create functions to encode a given text string into Morse Code and to decode a given Morse Code string back into text. Input and Output * **Input Format**: - A string `text` to be encoded into Morse Code. - A string `morse_code` to be decoded into text. * **Output Format**: - A string representing the encoded Morse Code for the encoding function. - A string representing the decoded text for the decoding function. Constraints 1. The text will only contain uppercase English alphabetical characters and spaces. 2. Each letter in Morse Code will be separated by a single space. 3. Each word in Morse Code will be separated by three spaces. Requirements * **Functions**: 1. `encode(text: str) -> str` 2. `decode(morse_code: str) -> str` Detailed Requirements * Utilize the following Morse Code mappings: ```python morse_code_dict = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'0\': \'-----\', \' \': \' / \' } ``` * Ensure that the encoded and decoded results adhere to the Morse Code standards as outlined above. Example ```python text = \\"HELLO WORLD\\" morse_code = \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" # Encoding the text encoded_text = encode(text) print(encoded_text) # Should output \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" # Decoding the Morse Code decoded_text = decode(morse_code) print(decoded_text) # Should output \\"HELLO WORLD\\" ```","solution":"morse_code_dict = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'0\': \'-----\', \' \': \'/\' } inverse_morse_code_dict = {v: k for k, v in morse_code_dict.items()} def encode(text: str) -> str: Encode given text string into Morse Code. return \' \'.join(morse_code_dict.get(char, \'\') for char in text) def decode(morse_code: str) -> str: Decode given Morse Code string back to text. return \'\'.join(inverse_morse_code_dict.get(code, \'\') for code in morse_code.split(\' \'))"},{"question":"# Problem Statement Create a program that simulates an elevator system in a building. The elevator system should handle requests from multiple floors and move efficiently to serve those requests according to the direction it is moving (up or down). You should implement the `ElevatorSystem` class with the following methods: 1. **Request an Elevator**: - Add a request for the elevator to stop at a specific floor. - The request can come from a floor (for the elevator to stop and pick up passengers) or from inside the elevator (to go to a specific floor). 2. **Move the Elevator**: - Move the elevator one floor up or down, based on the current requests and direction. - The direction of the elevator should reverse when it reaches the top or bottom floor of the building, or when there are no further requests in the current direction. 3. **Status of the Elevator**: - Retrieve the current floor and direction of the elevator. - Display the pending requests in the queue. # Method Signatures ```python class ElevatorSystem: def __init__(self, num_floors: int): Initialize the ElevatorSystem with the given number of floors. Args: - num_floors (int): The total number of floors in the building. pass def request_elevator(self, floor: int) -> None: Add a request for the elevator to stop at a specific floor. Args: - floor (int): The floor to add to the request queue. pass def move_elevator(self) -> None: Move the elevator one floor up or down based on the current requests and direction. Adjust the direction if necessary. pass def status(self) -> dict[str, Any]: Retrieve the current status of the elevator, including the current floor, direction, and the queue of pending requests. Returns: - dict[str, Any]: A dictionary containing \'current_floor\', \'direction\', and \'request_queue\'. pass ``` # Constraints - The building will have at least 2 floors. - The elevator can only move one floor at a time. - Requests can be made at any time from any floor. # Example Usage ```python # Initialize ElevatorSystem with 10 floors elevator = ElevatorSystem(10) # Request elevator to stop at various floors elevator.request_elevator(3) elevator.request_elevator(5) elevator.request_elevator(2) # Simulate elevator movements and print status elevator.move_elevator() status = elevator.status() print(status) # Might print: {\'current_floor\': 1, \'direction\': \'up\', \'request_queue\': [3, 5, 2]} elevator.move_elevator() status = elevator.status() print(status) # Might print: {\'current_floor\': 2, \'direction\': \'up\', \'request_queue\': [3, 5]} # Continue moving the elevator and print status after each move elevator.move_elevator() status = elevator.status() print(status) # Might print: {\'current_floor\': 3, \'direction\': \'up\', \'request_queue\': [5]} elevator.move_elevator() status = elevator.status() print(status) # Might print: {\'current_floor\': 4, \'direction\': \'up\', \'request_queue\': [5]} elevator.move_elevator() status = elevator.status() print(status) # Might print: {\'current_floor\': 5, \'direction\': \'up\', \'request_queue\': []} ``` **Your task is to complete the implementation of the `ElevatorSystem` class to handle the elevator operations as specified above. Ensure efficient handling of requests and direction changes.**","solution":"class ElevatorSystem: def __init__(self, num_floors: int): Initialize the ElevatorSystem with the given number of floors. self.num_floors = num_floors self.current_floor = 1 # Assume ground floor is level 1 self.direction = \'up\' self.request_queue = [] def request_elevator(self, floor: int) -> None: Add a request for the elevator to stop at a specific floor. if 1 <= floor <= self.num_floors and floor not in self.request_queue: self.request_queue.append(floor) self.request_queue.sort() def move_elevator(self) -> None: Move the elevator one floor up or down based on the current requests and direction. Adjust the direction if necessary. if not self.request_queue: return if self.direction == \'up\': next_floor = min((floor for floor in self.request_queue if floor > self.current_floor), default=None) if next_floor is not None: self.current_floor += 1 else: self.direction = \'down\' self.move_elevator() return elif self.direction == \'down\': next_floor = max((floor for floor in self.request_queue if floor < self.current_floor), default=None) if next_floor is not None: self.current_floor -= 1 else: self.direction = \'up\' self.move_elevator() return if self.current_floor in self.request_queue: self.request_queue.remove(self.current_floor) def status(self) -> dict: Retrieve the current status of the elevator. return { \'current_floor\': self.current_floor, \'direction\': self.direction, \'request_queue\': self.request_queue }"},{"question":"# File Compression Utility You\'re tasked with creating a utility function to compress a specified directory into a zip file. The utility should support the following features: 1. **Recursive Compression**: Ensure all subdirectories and their contents are included in the zip file. 2. **Exclusion List**: Allow the user to specify a list of file extensions or names to exclude from compression. 3. **Progress Logging**: Print informative messages for each file or directory being added to the zip file, including the total percentage completed. # Input - A string representing the path to the directory to be compressed. - A list of strings representing file extensions or names to exclude. # Output - The function should create a zip file in the current directory with the compressed contents of the specified directory. - It should name the zip file based on the original directory name followed by the current date-time stamp. - Print informative messages at each stage of the process. # Constraints - Use the given structure but feel free to add additional helper functions or parameters if needed. - Ensure that your code appropriately handles common edge cases such as invalid directory paths, empty directories, and specified exclusions. - The directory size can be large, e.g., up to several gigabytes. # Example ```python # Example main invocation if __name__ == \\"__main__\\": directory_path = \\"./sample_directory\\" exclusions = [\\".tmp\\", \\"ignore.txt\\"] try: compress_directory(directory_path, exclusions) except Exception as e: print(f\\"Failed to compress directory: {e}\\") ``` **Note**: Assume that the utility imports and additional required libraries (e.g., zipfile, os, datetime) are appropriately managed.","solution":"import os import zipfile from datetime import datetime def compress_directory(directory_path, exclusions): Compress the specified directory into a zip file, excluding specified file types or names. Parameters: directory_path (str): The path to the directory to be compressed. exclusions (list): A list of file extensions or names to exclude. if not os.path.isdir(directory_path): raise ValueError(f\\"The path {directory_path} is not a directory or does not exist.\\") # Create a zip file name based on the directory name and current date-time stamp dir_name = os.path.basename(os.path.normpath(directory_path)) zip_filename = f\\"{dir_name}_{datetime.now().strftime(\'%Y%m%d_%H%M%S\')}.zip\\" with zipfile.ZipFile(zip_filename, \'w\', zipfile.ZIP_DEFLATED) as zipf: total_files = sum([len(files) for r, d, files in os.walk(directory_path)]) files_processed = 0 for root, dirs, files in os.walk(directory_path): for file in files: file_path = os.path.join(root, file) relative_path = os.path.relpath(file_path, directory_path) if any(file.endswith(ext) or file == ext for ext in exclusions): continue zipf.write(file_path, relative_path) files_processed += 1 print(f\\"Adding {file_path} ({files_processed}/{total_files}, {files_processed * 100 // total_files}%)\\") print(f\\"Compression complete: {zip_filename}\\")"},{"question":"# Recursive Data Structures - Binary Search Tree Deletion **Objective:** Write a function `delete_node(root: TreeNode, key: int) -> TreeNode` that deletes a node with a given key in a Binary Search Tree (BST) while maintaining its properties, and returns the new root of the tree. **Input:** * `root`: A TreeNode representing the root of the BST. * `key`: An integer representing the value to be deleted from the BST. **Output:** * A TreeNode representing the new root of the BST after deletion. **Constraints:** * The BST will not contain duplicate values. * Each TreeNode has the attributes `val`, `left`, and `right`. **Context:** In a BST, each node follows the property that the value of the left child is less than the value of the node, and the value of the right child is greater than the value of the node. Deleting a node involves three possible scenarios: 1. The node to be deleted is a leaf node. 2. The node to be deleted has only one child. 3. The node to be deleted has two children, in which case you need to find the inorder successor (the smallest value in the right subtree) or the inorder predecessor (the largest value in the left subtree) to replace the node. **Requirements:** 1. Your function should recursively search for the node to be deleted. 2. Handle the above three scenarios for deletion while preserving the BST properties. 3. Ensure the new BST maintains its properties of order. **Example Usage:** ```python # Provided TreeNode class definition: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example function call: root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(6) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(7) new_root = delete_node(root, 3) ``` Expected outcome for the above example would be a tree where the value `3` is deleted, and the structure is adjusted to maintain BST properties. ```python # Helper function to print BST inorder for testing purposes: def inorder_traversal(root: TreeNode): if root: inorder_traversal(root.left) print(root.val, end=\' \') inorder_traversal(root.right) # After deletion, should print a reordered BST without the value 3 inorder_traversal(new_root) ``` Expected output: ``` 2 4 5 6 7 ``` Note: Ensure that all edge cases are handled appropriately, such as deleting a node that doesn\'t exist, deleting the root node, and dealing with an empty tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def delete_node(root: TreeNode, key: int) -> TreeNode: if not root: return root if key < root.val: root.left = delete_node(root.left, key) elif key > root.val: root.right = delete_node(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left # Find the inorder successor (smallest in the right subtree) temp = root.right while temp.left: temp = temp.left # Copy the inorder successor\'s value to the root and delete the successor root.val = temp.val root.right = delete_node(root.right, temp.val) return root def inorder_traversal(root): result = [] if root: result.extend(inorder_traversal(root.left)) result.append(root.val) result.extend(inorder_traversal(root.right)) return result"},{"question":"# Multiplayer Game Scoreboard In an online multiplayer game, players score points based on their performance in various matches. You have been tasked with designing a leaderboard system that efficiently keeps track of scores and announces the top players. **Objective**: Implement a `Leaderboard` class to manage the scores of players, specifically to: - Add a new score for a player (which may update their existing score). - Retrieve the top \'k\' players based on their scores. **Requirements**: 1. **Initialization**: * The class does not require any parameters at initialization. 2. **Methods**: - `add_score(player_id: int, score: int) -> None`: * Add a new score for a player. If the player already exists, update their score by adding the new score to their existing total. - `top(k: int) -> List[int]`: * Return a list of the IDs of the top `k` players by score, sorted in descending order of their scores. If two players have the same score, return the player with the smaller ID first. - `reset(player_id: int) -> None`: * Reset the score of the player to zero. **Constraints**: * `1 <= player_id <= 10^6` * `-10^3 <= score <= 10^3` * `1 <= k <= 100` * Scores must be efficiently updated and queried, ensuring near constant time complexity for all operations. **Example**: ```python # Create a new leaderboard leaderboard = Leaderboard() # Add scores for players leaderboard.add_score(1, 73) leaderboard.add_score(2, 56) leaderboard.add_score(3, 39) leaderboard.add_score(4, 78) leaderboard.add_score(5, 59) leaderboard.add_score(6, 93) leaderboard.add_score(7, 82) # Retrieve top 3 players print(leaderboard.top(3)) # Expected: [6, 4, 7] # Add more scores leaderboard.add_score(3, 61) # Player 3\'s new score is 100 # Retrieve top 3 players again print(leaderboard.top(3)) # Expected: [3, 6, 4] # Reset player 3\'s score leaderboard.reset(3) # Retrieve top 3 players again print(leaderboard.top(3)) # Expected: [6, 4, 7] ``` This question tests the implementation of a data structure and the manipulation of scores while ensuring efficient retrieval and update operations.","solution":"from typing import List import heapq class Leaderboard: def __init__(self): self.scores = {} def add_score(self, player_id: int, score: int) -> None: if player_id in self.scores: self.scores[player_id] += score else: self.scores[player_id] = score def top(self, k: int) -> List[int]: # Use a min-heap to keep track of top k scores top_k = heapq.nlargest(k, self.scores.items(), key=lambda x: (x[1], -x[0])) return [player_id for player_id, _ in top_k] def reset(self, player_id: int) -> None: if player_id in self.scores: self.scores[player_id] = 0"},{"question":"Problem Statement # Context In a software system, you need to monitor activity logs that record user login times. To enhance user experience, you want to implement a feature that can quickly retrieve the most recent login times for a given user within a specified time window. # Task Write a Python function `recent_logins` that retrieves the most recent login timestamps for a specific user within a given time range. # Requirements * **Input**: * `logs` (list of tuples): Each tuple contains two elements: * A string representing a user\'s ID. * An integer representing the login timestamp (in seconds since epoch). * The list is unsorted and can contain multiple entries for the same user. * `user_id` (string): The ID of the user whose recent logins you need to find. * `start_time` (int): The starting timestamp of the time window (inclusive). * `end_time` (int): The ending timestamp of the time window (inclusive). * **Output**: * A list of integers representing the login timestamps of the specified user within the given time range in descending order. If there are no logins in the specified range, return an empty list. # Constraints 1. The logs can be very large (1 ≤ len(logs) ≤ 10^5). 2. Ensure that the function is optimized for performance. # Function Signature ```python def recent_logins(logs: list[tuple[str, int]], user_id: str, start_time: int, end_time: int) -> list[int]: pass ``` # Example ```python logs = [ (\\"user1\\", 1633035600), (\\"user2\\", 1633038600), (\\"user1\\", 1633042200), (\\"user3\\", 1633056000), (\\"user1\\", 1633063200), (\\"user2\\", 1633074000) ] assert recent_logins(logs, \\"user1\\", 1633035600, 1633045000) == [1633042200, 1633035600] assert recent_logins(logs, \\"user2\\", 1633035600, 1633080000) == [1633074000, 1633038600] assert recent_logins(logs, \\"user3\\", 1633056000, 1633060000) == [1633056000] ``` # Performance Considerations Your solution should efficiently handle the potentially large `logs` list by appropriately filtering and sorting the relevant entries for each query.","solution":"def recent_logins(logs, user_id, start_time, end_time): Retrieve the most recent login timestamps for a specific user within a given time range. :param logs: list of tuples, each containing a user ID and a login timestamp :param user_id: string, the user ID to filter logs by :param start_time: int, start of the time range (inclusive) :param end_time: int, end of the time range (inclusive) :return: list of integers, login timestamps in descending order filtered_logins = [ timestamp for uid, timestamp in logs if uid == user_id and start_time <= timestamp <= end_time ] return sorted(filtered_logins, reverse=True)"},{"question":"# Coding Challenge: Implement Breadth-First Search (BFS) for a Graph Context You are given an undirected graph, and your task is to implement the Breadth-First Search (BFS) algorithm to explore all the nodes reachable from a given starting node. BFS is a fundamental graph traversal algorithm used for exploring nodes and edges of a graph level by level. Problem Statement Write a Python function `bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]` that performs BFS on the given graph starting from the `start_node`. Function Signature ```python def bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]: pass ``` Parameters * `graph`: A dictionary representing an undirected graph where the keys are node identifiers and the values are lists of adjacent nodes. * `start_node`: An integer representing the starting node for BFS. Returns * A list of nodes in the order they are visited by the BFS algorithm starting from the `start_node`. Constraints 1. You can assume the `graph` is connected, and there are no isolated nodes. 2. All node identifiers are non-negative integers. 3. No duplicate edges are present, and self-loops are not allowed. Examples ```python # Example 1 graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5, 6], 3: [1], 4: [1], 5: [2], 6: [2] } result = bfs(graph, 0) assert result == [0, 1, 2, 3, 4, 5, 6] # Example 2 graph = { 1: [2, 3], 2: [1, 4, 5], 3: [1], 4: [2], 5: [2, 6], 6: [5] } result = bfs(graph, 1) assert result == [1, 2, 3, 4, 5, 6] # Example 3 graph = { 0: [1], 1: [0, 2], 2: [1, 3] } result = bfs(graph, 2) assert result == [2, 1, 3, 0] # Example 4 graph = { 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2] } result = bfs(graph, 3) assert result == [3, 0, 2, 1] ``` Note: Reference graphs are small for brevity and testing clarity, but the function should handle larger graphs efficiently.","solution":"from collections import deque from typing import Dict, List def bfs(graph: Dict[int, List[int]], start_node: int) -> List[int]: Perform BFS traversal on the graph starting from the start_node. visited = [] # List to keep track of visited nodes queue = deque([start_node]) # Initialize queue with the start node visited_set = set() # Set to keep track of visited nodes for quick lookup while queue: node = queue.popleft() if node not in visited_set: visited.append(node) visited_set.add(node) # Add all unvisited neighbours to the queue for neighbour in graph[node]: if neighbour not in visited_set: queue.append(neighbour) return visited"},{"question":"# Extract Domain from Email Write a Python function called `extract_domain` that accepts a single parameter: 1. `email` (str): An email address. The function should return the domain of the email address as a string. If the input email is invalid (does not contain exactly one `@` symbol), the function should return an appropriate error message. The email address can be considered valid if: - It contains exactly one `@` symbol. - The domain part (part after `@`) should not be empty and should contain at least one `.` symbol. # Constraints: * Only valid email addresses (following the above rules) should be used. * The function should handle unexpected input gracefully and return an informative error message for invalid emails. # Inputs: * `email`: A string representing an email address. # Outputs: * A string representing the domain of the email, or an error message in case of invalid input. # Examples: ```python print(extract_domain(\\"contact@example.com\\")) ``` Should return: `\\"example.com\\"` ```python print(extract_domain(\\"invalid-email.com\\")) ``` Should return: `\\"Invalid email address\\"` ```python print(extract_domain(\\"mailto:contact@sub.example.com\\")) ``` Should return: `\\"sub.example.com\\"` # Hints: * Use string methods like `split()` and `count()` to parse the email address. * Ensure that the domain part has at least one `.` symbol before considering it valid. * Validate the input before attempting to extract the domain.","solution":"def extract_domain(email): Extracts the domain from a given email address. Parameters: email (str): An email address. Returns: str: The domain of the email or an error message if the email is invalid. if not isinstance(email, str): return \\"Invalid input: not a string\\" if email.count(\'@\') != 1: return \\"Invalid email address\\" local_part, domain_part = email.split(\'@\') if not domain_part or \'.\' not in domain_part: return \\"Invalid email address\\" return domain_part"},{"question":"# Problem Statement You are given a linked list where each node contains an integer value. Your task is to implement a function `reverse_linked_list(head: Optional[ListNode]) -> Optional[ListNode]` that reverses the linked list and returns the new head of the list. Input and Output Formats: * **Input**: - `head`: The head of the singly linked list. * **Output**: - Returns the new head of the reversed linked list. Constraints: * The linked list may contain between 0 to 10^4 nodes. * Each node in the linked list will contain an integer value. * The function should use O(1) additional space. Example: 1. Given the linked list `1 -> 2 -> 3 -> 4 -> 5`, calling `reverse_linked_list(head)` should return the linked list `5 -> 4 -> 3 -> 2 -> 1`. 2. Given the linked list `7 -> 14 -> 21`, calling `reverse_linked_list(head)` should return the linked list `21 -> 14 -> 7`. 3. Given the linked list `1`, calling `reverse_linked_list(head)` should return the linked list `1`. Use these test cases to verify the accuracy of your implementation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses a singly linked list. Parameters: - head: ListNode | None, the head of the linked list Returns: - ListNode | None, the new head of the reversed linked list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Coding Question: Robot Movement Paths A robot sits in the top-left corner of an `m x n` grid. The robot can move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (i.e., grid[m-1][n-1]). Write a function `count_paths(m: int, n: int) -> int` that takes two integers, `m` and `n`, representing the number of rows and columns of the grid, respectively. The function should return the number of unique paths that the robot can take to reach the bottom-right corner from the top-left corner. **Input:** * Two integers `m` and `n` (1 ≤ m, n ≤ 100), representing the number of rows and columns of the grid. **Output:** * An integer, representing the number of unique paths to reach the bottom-right corner of the grid. **Example:** ```python >>> count_paths(3, 2) 3 >>> count_paths(7, 3) 28 ``` **Constraints:** * The robot can only move either down or right. * The grid dimensions m and n are both at least 1. **Performance Requirements:** * Aim to solve the problem with a time complexity of O(m * n) and space complexity of O(m * n). **Hint:** Use dynamic programming to store intermediate results for the number of paths to reach each cell in the grid.","solution":"def count_paths(m, n): Returns the number of unique paths from the top-left to the bottom-right of an m x n grid. # Create a 2D array to store the number of ways to reach each cell dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"# **Question: Simulation of a Simple Operating System Scheduler** You are tasked with simulating a simple operating system scheduler that manages a set of processes. Each process has attributes for its Process ID (PID), its arrival time, and its burst time (the time it requires to complete). The scheduler uses the First-Come, First-Served (FCFS) algorithm to determine the order in which processes are executed. In FCFS scheduling, the process that arrives first is executed first. If two processes arrive at the same time, the process with the smaller PID is executed first. **Your task:** Create a function `fcfs_scheduler` that takes a list of tuples representing processes and returns the order in which processes will be executed. **Function Signature:** ```python from typing import List, Tuple def fcfs_scheduler(processes: List[Tuple[int, int, int]]) -> List[int]: pass ``` **Requirements:** 1. **Inputs**: - `processes`: A list of tuples, where each tuple represents a process and contains three integers `(PID, arrival_time, burst_time)`. 2. **Outputs**: - **List of int**: A list of PIDs in the order they will be executed. 3. **Constraints**: - PIDs are unique and positive integers. - `arrival_time` and `burst_time` are non-negative integers. - If two processes have the same `arrival_time`, the process with the smaller PID should be executed first. - At least one process is provided in the input list. 4. **Performance**: - The function should efficiently handle up to 10,000 processes. Below are example usage and expected output: ```python # Example Usage process_list = [(1, 0, 5), (2, 2, 2), (3, 1, 3)] # (PID, arrival_time, burst_time) execution_order = fcfs_scheduler(process_list) print(execution_order) # Output: [1, 3, 2] ``` Implement the function, ensuring it meets the performance requirements and correctly simulates the FCFS scheduling algorithm.","solution":"from typing import List, Tuple def fcfs_scheduler(processes: List[Tuple[int, int, int]]) -> List[int]: Given a list of processes, this function returns the execution order following the First-Come, First-Served (FCFS) scheduling algorithm. # Sort processes by arrival time first, and then by PID for tie breaking. sorted_processes = sorted(processes, key=lambda x: (x[1], x[0])) # Extract PIDs in the sorted order execution_order = [pid for pid, arrival, burst in sorted_processes] return execution_order"},{"question":"# Coding Assessment Question Context You are improving the functionalities of a beginner-friendly string manipulation library. One important feature is to perform efficient string matching operations. You need to implement an algorithm that is more efficient than a naive string matching approach, especially for larger texts and patterns. Task Implement the **Knuth-Morris-Pratt (KMP) Algorithm** to search for occurrences of a pattern string within a text string. The KMP algorithm is more efficient than the naive approach because it avoids redundant comparisons. Requirements 1. **Function Definition**: Implement a function named `kmp_search` which searches for occurrences of a pattern in a text. 2. **Input**: Two strings - `text` and `pattern`. 3. **Output**: A list of starting indices where the pattern is found within the text. If the pattern is not found, return an empty list. 4. **Constraints**: * The function should handle edge cases, such as an empty text or pattern. * Optimize the solution to have a time complexity of O(n + m), where n is the length of the text and m is the length of the pattern. Function Signature ```python def kmp_search(text: str, pattern: str) -> list[int]: pass ``` Example 1. Input: `text = \\"ababcabcabababd\\"`, `pattern = \\"ababd\\"` Output: `[10]` 2. Input: `text = \\"AABAACAADAABAABA\\"`, `pattern = \\"AABA\\"` Output: `[0, 9, 12]` 3. Input: `text = \\"hello\\"`, `pattern = \\"world\\"` Output: `[]` 4. Input: `text = \\"\\"`, `pattern = \\"pattern\\"` Output: `[]` 5. Input: `text = \\"pattern\\"`, `pattern = \\"\\"` Output: `[]` Testing * Ensure to test your KMP implementation with various test cases, including edge cases such as empty strings and non-matching patterns. * Compare your results with Python\'s built-in string `find()` method to verify correctness.","solution":"def kmp_search(text: str, pattern: str) -> list[int]: if not text or not pattern: return [] def compute_lps(pattern): lps = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): while (j > 0 and pattern[i] != pattern[j]): j = lps[j - 1] if pattern[i] == pattern[j]: j += 1 lps[i] = j else: lps[i] = 0 return lps lps = compute_lps(pattern) result = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Question: You are tasked with modeling a simplified warehouse robotic system. Create a function `manage_warehouse` that simulates the movement of a robot within a grid-shaped warehouse, given a series of commands and start position. The robot can perform the following moves: up, down, left, and right. **Function Signature**: ```python def manage_warehouse(commands: str, start_position: tuple) -> tuple: # implement the function ``` # Requirements: 1. **Input Format**: - `commands`: A string containing the movement commands, where each character can be: - \'U\' (up) - \'D\' (down) - \'L\' (left) - \'R\' (right) - `start_position`: A tuple `(x, y)` representing the robot\'s starting coordinates. 2. **Output Format**: - A tuple `(x, y)` representing the robot\'s final position after executing all the commands. # Constraints: - The grid size is virtually infinite, meaning the robot can move in any direction without boundaries. - The command string length will be in the range `1` to `10^6`. - The initial start coordinates can be any integer (positive or negative). # Performance Requirements: - The algorithm should run efficiently for large command sizes, adhering to the given complexity constraints. # Example: ```python final_position = manage_warehouse(\\"UDLR\\", (0, 0)) print(final_position) # Output: (0, 0) final_position = manage_warehouse(\\"UUUDDDDLLL\\", (2, 2)) print(final_position) # Output: (-1, -3) ``` # Function Behavior: 1. Begin at the given start position. 2. Iterate over each command in the input string and update the robot\'s position accordingly: - \'U\': Move up by decreasing the y-coordinate by 1. - \'D\': Move down by increasing the y-coordinate by 1. - \'L\': Move left by decreasing the x-coordinate by 1. - \'R\': Move right by increasing the x-coordinate by 1. 3. Return the final coordinates after processing all commands. # Additional Notes: - Handle edge cases such as no movement commands gracefully. - Consider optimizing the command processing to prevent inefficiencies in handling large sequences of commands. # Hints: * Use a loop to iterate through the command string for efficient processing. * Maintain a running count of x and y coordinates to track the robot\'s position.","solution":"def manage_warehouse(commands: str, start_position: tuple) -> tuple: Simulates the movement of a robot within a grid-shaped warehouse. Parameters: commands (str): A string containing the movement commands (\'U\', \'D\', \'L\', \'R\'). start_position (tuple): A tuple (x, y) representing the robot\'s starting coordinates. Returns: tuple: A tuple (x, y) representing the robot\'s final position after executing all commands. x, y = start_position for command in commands: if command == \'U\': y -= 1 elif command == \'D\': y += 1 elif command == \'L\': x -= 1 elif command == \'R\': x += 1 return (x, y)"},{"question":"# Task Scheduler You are required to build a task scheduler that can schedule tasks to be executed at specified times and handle task conflicts appropriately. Objective: Implement the `TaskScheduler` class with the following functionality: * Add a new task with a specified start and end time. * Check for and prevent scheduling conflicts, i.e., ensure no two tasks overlap in time. * Retrieve the list of all scheduled tasks. Class Signature: ```python class TaskScheduler: def __init__(self): Initializes the TaskScheduler with an empty schedule. pass def add_task(self, task_name: str, start_time: int, end_time: int) -> bool: Adds a task to the schedule if there is no time conflict. Args: - task_name: str: The name of the task. - start_time: int: The starting time of the task (in 24-hour format). - end_time: int: The ending time of the task (in 24-hour format). Returns: - bool: True if the task was added successfully, False if there was a conflict. pass def get_schedule(self) -> list: Retrieves the list of all scheduled tasks. Returns: - list of tuples: Each tuple contains a task name, start time, and end time. pass ``` Input: - `task_name` (str): The name of the task to be scheduled. - `start_time` (int): The starting time of the task (in 24-hour format, e.g., 1300 for 1:00 PM). - `end_time` (int): The ending time of the task (in 24-hour format, e.g., 1500 for 3:00 PM). Output: - The `add_task` method returns a boolean indicating whether the task was added successfully without conflicts. - The `get_schedule` method returns a list of scheduled tasks, where each task is represented as a tuple containing the task name, start time, and end time. Constraints: * The `start_time` and `end_time` are in the 24-hour format (0000 to 2359). * The `start_time` should be less than the `end_time`. * No two tasks should overlap in time. Example Usage: ```python scheduler = TaskScheduler() # Adding tasks assert scheduler.add_task(\\"Task 1\\", 1000, 1200) == True # Task 1 scheduled from 10:00 AM to 12:00 PM assert scheduler.add_task(\\"Task 2\\", 1200, 1300) == True # Task 2 scheduled from 12:00 PM to 01:00 PM assert scheduler.add_task(\\"Task 3\\", 1100, 1230) == False # Conflict with Task 1 # Retrieving the schedule assert scheduler.get_schedule() == [(\\"Task 1\\", 1000, 1200), (\\"Task 2\\", 1200, 1300)] ``` # Additional Notes: - Ensure that the `TaskScheduler` handles overlapping times correctly. - The `end_time` of one task is considered the starting point for the next task without conflict. - Provide meaningful feedback for conflicts when attempting to add a new task.","solution":"class TaskScheduler: def __init__(self): Initializes the TaskScheduler with an empty schedule. self.schedule = [] def add_task(self, task_name: str, start_time: int, end_time: int) -> bool: Adds a task to the schedule if there is no time conflict. Args: - task_name: str: The name of the task. - start_time: int: The starting time of the task (in 24-hour format). - end_time: int: The ending time of the task (in 24-hour format). Returns: - bool: True if the task was added successfully, False if there was a conflict. # Check for valid time range if start_time >= end_time: return False # Check for conflicts with existing tasks for task in self.schedule: existing_start, existing_end = task[1], task[2] if not (end_time <= existing_start or start_time >= existing_end): return False # If no conflict, add the task self.schedule.append((task_name, start_time, end_time)) self.schedule.sort(key=lambda x: x[1]) return True def get_schedule(self) -> list: Retrieves the list of all scheduled tasks. Returns: - list of tuples: Each tuple contains a task name, start time, and end time. return self.schedule"},{"question":"# Scenario You are required to develop an algorithm that efficiently removes duplicated characters in a string while maintaining the original order of the first occurrence of each character. This will help in various scenarios where data sanitization is crucial. # Problem Statement Write a function `remove_duplicates(s: str) -> str` that takes a string `s` as input and returns a new string where: - Each character only appears once. - The order of the first occurrence of each character is preserved in the returned string. # Example ```python >>> remove_duplicates(\\"abcdabc\\") \'abcd\' >>> remove_duplicates(\\"abracadabra\\") \'abrcd\' >>> remove_duplicates(\\"\\") \'\' >>> remove_duplicates(\\"112233\\") \'123\' >>> remove_duplicates(\\"Hello, World!\\") \'Helo, Wrd!\' ``` # Input and Output Formats - **Input**: A single string `s` which will be any length between 0 and 10^5 characters. - **Output**: A string with duplicated characters removed, preserving the order of first occurrences. # Constraints - The input string can contain any printable ASCII character. - The function should be case-sensitive, meaning \'a\' and \'A\' are considered different characters. # Performance Requirements Your solution should aim for a time complexity of O(n) where n is the length of the input string, and a space complexity of O(n).","solution":"def remove_duplicates(s: str) -> str: Removes duplicated characters in the string while maintaining the original order of the first occurrence of each character. Parameters: s (str): The input string from which duplicates are to be removed. Returns: str: A new string with duplicates removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Question Context As a software engineer, you are tasked with creating a mini parser that will process a simple arithmetic expression. The expression contains integers and the operators: `+`, `-`, `*`, and `/`. Your parser should be able to handle nested parenthesis and follow proper operator precedence. Task Write a Python function that can evaluate a given arithmetic expression and return the result as a float. Function Signature ```python def evaluate_expression(expression: str) -> float: pass ``` Input * `expression` (str): A string representing an arithmetic expression which can include positive integers, parenthesis, and the operators: `+`, `-`, `*`, `/`. The expression may have spaces for readability. Output * Returns a float which is the result of the evaluated expression. Constraints and Requirements * The function should handle nested parenthesis correctly following the arithmetic precedence rules. * Division by zero should not occur; assume the input will never include a case where division by zero is possible. * The function should evaluate the expression in linear time concerning the length of the expression. Example ```python assert abs(evaluate_expression(\\"3 + 4 * 2 / ( 1 - 5 )\\") - 1.0) < 1e-9 assert abs(evaluate_expression(\\"10 + 2 * 6\\") - 22.0) < 1e-9 assert abs(evaluate_expression(\\"100 * 2 + 12\\") - 212.0) < 1e-9 assert abs(evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") - 100.0) < 1e-9 ``` Explanation 1. `\\"3 + 4 * 2 / ( 1 - 5 )\\"`: - Inner parenthesis: `( 1 - 5 )` evaluates to `-4` - Expression becomes: `3 + 4 * 2 / -4` - Multiplication and division first: `4 * 2 = 8`, `8 / -4 = -2` - Final addition: `3 + (-2) = 1.0` 2. `\\"10 + 2 * 6\\"`: - Multiplication first: `2 * 6 = 12` - Final addition: `10 + 12 = 22.0` 3. `\\"100 * 2 + 12\\"`: - Multiplication first: `100 * 2 = 200` - Final addition: `200 + 12 = 212.0` 4. `\\"100 * ( 2 + 12 ) / 14\\"`: - Inner parenthesis: `( 2 + 12 )` evaluates to `14` - Expression becomes: `100 * 14 / 14` - Multiplication: `100 * 14 = 1400` - Final division: `1400 / 14 = 100.0`","solution":"def evaluate_expression(expression: str) -> float: def parse_expression(index): def parse_factor(index): if tokens[index] == \'(\': index, value = parse_expression(index + 1) if tokens[index] == \')\': return index + 1, value return index + 1, float(tokens[index]) def parse_term(index): index, value = parse_factor(index) while index < len(tokens) and tokens[index] in \'*/\': oper = tokens[index] index, next_value = parse_factor(index + 1) if oper == \'*\': value *= next_value else: value /= next_value return index, value index, value = parse_term(index) while index < len(tokens) and tokens[index] in \'+-\': oper = tokens[index] index, next_value = parse_term(index + 1) if oper == \'+\': value += next_value else: value -= next_value return index, value tokens = expression.replace(\'(\', \' ( \').replace(\')\', \' ) \').split() _, result = parse_expression(0) return result"},{"question":"# Coding Assessment Question Context: You are provided with a class `MatrixOperations` that holds several methods to handle common matrix operations such as addition, subtraction, and multiplication for 2-dimensional matrices. Your task is to enhance this class by adding a method to compute the matrix inverse. The matrix inversion must be done using the Gauss-Jordan elimination method. The class should handle cases where the matrix is non-invertible by raising an appropriate exception. Task: Implement the `inverse` method in the `MatrixOperations` class using Gauss-Jordan elimination. The method should: 1. Check if the matrix is square. 2. Perform the Gauss-Jordan elimination to obtain the inverse. 3. Raise a `ValueError` if the matrix is not invertible. Expected Input and Output Formats: Function signature: ```python class MatrixOperations: ... def inverse(self) -> typing.List[typing.List[float]]: # your implementation here ``` - **Input**: None (the method operates on the instance\'s matrix attribute). - **Output**: A nested list (2D list) representing the inverse of the matrix. Constraints and Assumptions: - The matrix provided will be a square matrix (n x n). - The matrix elements are float numbers. - Utilize only standard Python libraries (e.g., without using `numpy`, `scipy` or any other external library). Hint: - Create an augmented matrix [A|I] where A is the original matrix and I is the identity matrix of the same size. - Apply Gauss-Jordan elimination to transform [A|I] into [I|A^-1], where A^-1 is the inverse of the original matrix. - Check for rows with all zero values in A and their corresponding values in I. Example Implementation: ```python class MatrixOperations: def __init__(self, matrix: typing.List[typing.List[float]]) -> None: self.matrix = matrix def inverse(self) -> typing.List[typing.List[float]]: # Check if the matrix is square n = len(self.matrix) if not all(len(row) == n for row in self.matrix): raise ValueError(\\"Input must be a square matrix.\\") # Create augmented matrix [A|I] augmented_matrix = [row[:] + [int(i == j) for i in range(n)] for j, row in enumerate(self.matrix)] # Perform Gauss-Jordan Elimination for i in range(n): # Make the diagonal contain all ones pivot = augmented_matrix[i][i] if pivot == 0: for row in range(i+1, n): if augmented_matrix[row][i] != 0: augmented_matrix[i], augmented_matrix[row] = augmented_matrix[row], augmented_matrix[i] break pivot = augmented_matrix[i][i] if pivot == 0: raise ValueError(\\"Matrix is not invertible.\\") augmented_matrix[i] = [elem / pivot for elem in augmented_matrix[i]] # Make the other rows zero in the current column for j in range(n): if i != j: row_factor = augmented_matrix[j][i] augmented_matrix[j] = [ elem_j - row_factor * elem_i for elem_j, elem_i in zip(augmented_matrix[j], augmented_matrix[i]) ] # Extract inverse matrix from the augmented matrix inverse_matrix = [row[n:] for row in augmented_matrix] return inverse_matrix ``` **Note**: Ensure that your method validates the input and raises exceptions accordingly.","solution":"from typing import List class MatrixOperations: def __init__(self, matrix: List[List[float]]) -> None: self.matrix = matrix def inverse(self) -> List[List[float]]: n = len(self.matrix) # Ensure matrix is square if not all(len(row) == n for row in self.matrix): raise ValueError(\\"Input must be a square matrix.\\") # Create the augmented matrix [A|I] augmented_matrix = [row[:] + [float(i == j) for i in range(n)] for j, row in enumerate(self.matrix)] # Apply Gauss-Jordan elimination for i in range(n): # Diagonal element should not be zero, swap rows if necessary if augmented_matrix[i][i] == 0: for k in range(i+1, n): if augmented_matrix[k][i] != 0: augmented_matrix[i], augmented_matrix[k] = augmented_matrix[k], augmented_matrix[i] break else: raise ValueError(\\"Matrix is not invertible.\\") # Normalize the pivot row pivot = augmented_matrix[i][i] if pivot == 0: raise ValueError(\\"Matrix is not invertible.\\") augmented_matrix[i] = [element / pivot for element in augmented_matrix[i]] # Eliminate all other entries in the current column for j in range(n): if i != j: factor = augmented_matrix[j][i] augmented_matrix[j] = [ augmented_matrix[j][x] - factor * augmented_matrix[i][x] for x in range(2 * n) ] # Extract the inverse matrix from the augmented matrix inverse_matrix = [row[n:] for row in augmented_matrix] return inverse_matrix"},{"question":"# Question Scenario You work for a logistics company that needs to optimize their vehicle routing system to ensure timely deliveries. Each delivery point is represented by its coordinates, and you need to find the shortest path that visits each delivery point once and returns to the starting point (Traveling Salesman Problem). Your implementation should aim for an approximate solution using a heuristic approach to handle computational constraints. Task Write a Python function `approximate_tsp` that finds an approximate solution to the Traveling Salesman Problem (TSP) using the Nearest Neighbor heuristic. Function Specification ```python def approximate_tsp(points): Finds an approximate solution to the TSP using the Nearest Neighbor heuristic. Args: points (list of tuple of floats): A list of tuples where each tuple represents the coordinates of a delivery point. Returns: list of tuple of floats: The ordered list of points representing the delivery route. ``` Constraints - Each point is a tuple of two floats representing the (x, y) coordinates. - The number of delivery points, `n`, will be in the range 2 <= `n` <= 1000. - The function should start the route at the first point in the input list. Example ```python points = [(0, 0), (1, 1), (1, 0), (0, 1)] assert approximate_tsp(points) == [(0, 0), (1, 0), (1, 1), (0, 1)] points = [(10.5, 5.2), (3.0, 4.1), (20.7, 2.0), (15.0, 8.5), (0.5, 1.1)] assert approximate_tsp(points) == points == [(10.5, 5.2), (15.0, 8.5), (20.7, 2.0), (3.0, 4.1), (0.5, 1.1)] ``` Performance Requirements - The function should be able to handle up to 1000 points efficiently. - Use memory efficiently to maintain the feasibility of running on standard computing resources.","solution":"import math def calculate_distance(point1, point2): Helper function to calculate the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def approximate_tsp(points): Finds an approximate solution to the TSP using the Nearest Neighbor heuristic. Args: points (list of tuple of floats): A list of tuples where each tuple represents the coordinates of a delivery point. Returns: list of tuple of floats: The ordered list of points representing the delivery route. if not points: return [] visited = [points[0]] to_visit = points[1:] while to_visit: last_visited = visited[-1] nearest = min(to_visit, key=lambda point: calculate_distance(last_visited, point)) visited.append(nearest) to_visit.remove(nearest) return visited"},{"question":"# Problem Description You are given a list of strings containing multiple paths under a directory structure. Your task is to find all the duplicate files in the system based on their content, not their names. Two or more files are considered duplicates if they have the same content. # Input and Output Format * **Input**: A list of strings `paths` where each string is a path that includes one or more files. Each file is represented in the format `root/dir file(content)`. Note that different paths can have the same file content. * `paths`: List of strings representing the directory paths and files. * **Output**: Return a list of lists, where each sublist contains the paths of duplicate files. # Constraints * The length of `paths` is in the range `[1, 10000]`. * The length of each path is in the range `[1, 3000]`. * File names and directory names have length in the range `[1, 30]`. * File content is at most `50` characters long. * All directory paths and file names consist of lowercase English letters, digits, \'/\' and \'(\', \')\'. * No file has zero content. # Implementation Requirements * Implement the function `find_duplicate_files(paths: list[str]) -> list[list[str]]`. # Example ```python def find_duplicate_files(paths: list[str]) -> list[list[str]]: from collections import defaultdict content_mapping = defaultdict(list) for path in paths: elements = path.split() dir_path = elements[0] for file_info in elements[1:]: name, content = file_info.split(\'(\') content = content.strip(\')\') full_path = f\\"{dir_path}/{name}\\" content_mapping[content].append(full_path) duplicates = [files for files in content_mapping.values() if len(files) > 1] return duplicates # Example to test the implementation paths = [ \\"root/a 1.txt(abcd) 2.txt(efgh)\\", \\"root/c 3.txt(abcd)\\", \\"root/c/d 4.txt(efgh)\\", \\"root/4 4.txt(efgh)\\" ] print(find_duplicate_files(paths)) ``` # Explanation Given the paths: ``` \\"root/a 1.txt(abcd) 2.txt(efgh)\\" \\"root/c 3.txt(abcd)\\" \\"root/c/d 4.txt(efgh)\\" \\"root/4 4.txt(efgh)\\" ``` The resulting list should be: ``` [[\'root/a/1.txt\', \'root/c/3.txt\'], [\'root/a/2.txt\', \'root/c/d/4.txt\', \'root/4/4.txt\']] ``` The function correctly identifies the groups of files with identical content.","solution":"def find_duplicate_files(paths: list[str]) -> list[list[str]]: from collections import defaultdict content_mapping = defaultdict(list) for path in paths: elements = path.split() dir_path = elements[0] for file_info in elements[1:]: name, content = file_info.split(\'(\') content = content.strip(\')\') full_path = f\\"{dir_path}/{name}\\" content_mapping[content].append(full_path) duplicates = [files for files in content_mapping.values() if len(files) > 1] return duplicates"},{"question":"**Question: \\"Bacterial Growth Simulation using Logistic Growth Model\\"** **Context**: In microbiology, simulating bacterial growth can be key to understanding population dynamics under different conditions. The logistic growth model is a simple yet effective way to represent this growth, which considers an initial population size and a carrying capacity (maximum population size). **Task**: Implement the function `bacterial_growth_simulation` to estimate bacterial population changes over a given period using the logistic growth model. # Function Signature: ```python def bacterial_growth_simulation(initial_population: int, carrying_capacity: int, growth_rate: float, time_span: int) -> np.ndarray: ``` # Input: - `initial_population` (int): The bacterial population at the start of the simulation (t=0). Must be non-negative. - `carrying_capacity` (int): The maximum population size the environment can sustain. Must be positive. - `growth_rate` (float): The rate at which the population grows. Must be positive. - `time_span` (int): The total time for which the simulation runs. Must be positive. # Output: - Return a numpy array containing the estimated bacterial population at each timestep from t=0 to t=`time_span` inclusive. # Constraints: - The differential equation modeling the logistic growth is `dP/dt = r * P * (1 - P / K)` (Where `P` is the current population, `r` is the growth rate, and `K` is the carrying capacity). # Requirements: - Use an appropriate numerical method (e.g., Euler\'s method) to solve for the population over the given time span. - Handle edge cases such as zero initial population or carrying capacity properly. - Ensure stability and reasonable accuracy in the solution given the constraints and parameters. # Example: ```python # Example input initial_population = 50 carrying_capacity = 500 growth_rate = 0.1 time_span = 10 # Call the function population_estimations = bacterial_growth_simulation(initial_population, carrying_capacity, growth_rate, time_span) ``` In this example, the array `population_estimations` should return values showing the bacterial population growth over a 10-time unit period, reflecting logistic growth and moving towards the carrying capacity. Note that your implementation should demonstrate a valid understanding of the logistic growth model and appropriately handle the provided differential equation.","solution":"import numpy as np def bacterial_growth_simulation(initial_population: int, carrying_capacity: int, growth_rate: float, time_span: int) -> np.ndarray: Simulates bacterial growth using the logistic growth model. Parameters: initial_population (int): The initial size of the bacterial population. carrying_capacity (int): The maximum population size that the environment can sustain. growth_rate (float): The rate at which the population grows. time_span (int): The total time for which the simulation runs. Returns: np.ndarray: An array showing the estimated bacterial population at each timestep. # Ensure inputs are valid if initial_population < 0: raise ValueError(\\"Initial population must be non-negative.\\") if carrying_capacity <= 0: raise ValueError(\\"Carrying capacity must be positive.\\") if growth_rate <= 0: raise ValueError(\\"Growth rate must be positive.\\") if time_span < 0: raise ValueError(\\"Time span must be non-negative.\\") # Initialize the population array population = np.zeros(time_span + 1) population[0] = initial_population # Use Euler\'s method to simulate the logistic growth for t in range(1, time_span + 1): P = population[t - 1] dPdt = growth_rate * P * (1 - P / carrying_capacity) population[t] = P + dPdt return population"},{"question":"# Problem: Implementing Factorial using Recursion Factorial of a non-negative integer ( n ) is the product of all positive integers less than or equal to ( n ). Your task is to implement a recursive function to calculate the factorial of a given non-negative integer. Input * **n**: Non-negative integer representing the number for which the factorial is to be found. Output * Return an integer representing the factorial of ( n ). # Constraints 1. ( 0 leq n leq 20 ) # Example ```python print(factorial_recursive(5)) # Outputs: 120 print(factorial_recursive(0)) # Outputs: 1 print(factorial_recursive(7)) # Outputs: 5040 ``` # Notes * Ensure that your function handles the base case (e.g., factorial of 0 is 1) correctly. * Factorial of a large number grows very quickly, so the given constraint ( ( n leq 20 ) ) is to ensure that the result fits within standard integer range. * Recursion can be tricky with large depths; given the constraints, your solution will work within the limits of most standard recursion depths in programming environments. # Function Signature ```python def factorial_recursive(n: int) -> int: # You need to implement this function ``` # Context Recursion is a fundamental technique in computer science and mathematics, particularly suitable for problems that can be defined in terms of smaller subproblems. This problem will test your understanding of recursion, handling of base cases, and ability to compute correct results using recursive calls.","solution":"def factorial_recursive(n: int) -> int: Return the factorial of a non-negative integer n using recursion. :param n: Non-negative integer :return: Factorial of the input integer if n == 0: return 1 return n * factorial_recursive(n - 1)"},{"question":"# Problem Statement Given an integer array `nums` and an integer `k`, your task is to calculate the maximum values of each subarray of length `k` in the array. Write a function `max_in_subarrays(nums: List[int], k: int) -> List[int]` that finds the maximum value in each subarray of length `k`. Input * A list `nums` of `n` integers, where `nums[i]` is the element in the array on the `i-th` position. (1 ≤ n ≤ 10^5, -10^4 ≤ nums[i] ≤ 10^4) * An integer `k` (1 ≤ k ≤ n) representing the length of the subarrays. Output * A list of integers where each integer corresponds to the maximum value in each subarray of length `k`. Example ``` Input: nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3 Output: [3, 3, 5, 5, 6, 7] ``` In this example: - Subarray [1, 3, -1]: maximum value is 3 - Subarray [3, -1, -3]: maximum value is 3 - Subarray [-1, -3, 5]: maximum value is 5 - Subarray [-3, 5, 3]: maximum value is 5 - Subarray [5, 3, 6]: maximum value is 6 - Subarray [3, 6, 7]: maximum value is 7 Constraints * Your solution must achieve an `O(n)` time complexity. * Use of additional space is allowed, but focus on optimal usage. Implement the function `max_in_subarrays(nums: List[int], k: int) -> List[int]` that meets these requirements.","solution":"from collections import deque from typing import List def max_in_subarrays(nums: List[int], k: int) -> List[int]: if not nums or k <= 0: return [] result = [] deq = deque() # Will store indices of array elements for i in range(len(nums)): # Remove indices that are out of this window if deq and deq[0] < i - k + 1: deq.popleft() # Remove indices whose corresponding values are less than nums[i] while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add the current index at the end of the deque deq.append(i) # We start adding to result from the time we get the first window of size k if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"# Scenario You have to implement a simple caching system called `SimpleCache` to store key-value pairs with an expiration feature. This cache should automatically remove expired items when they are accessed via a retrieval operation. # Problem Statement Create the `SimpleCache` class that provides the following methods: - `put(key: str, value: str, ttl: int) -> None`: Store a key-value pair with a given time-to-live (TTL) in seconds. - `get(key: str) -> str`: Retrieve the value associated with the key if it exists and hasn\'t expired, otherwise return \\"Key not found\\" or \\"Expired\\". - `__str__() -> str`: Return a string representation of all the current non-expired key-value pairs in the cache in the format \\"Key: Value\\". # Input and Output Formats put - **Input**: key (str), value (str), ttl (int) - **Output**: None get - **Input**: key (str) - **Output**: value (str) or \\"Key not found\\" __str__ - **Output**: str, representing the non-expired cache entries in the format \\"Key: Value\\" # Constraints - Key names are unique strings. - Time-to-live (TTL) is a positive integer indicating seconds. # Example ```python import time cache = SimpleCache() cache.put(\\"key1\\", \\"value1\\", 5) # TTL of 5 seconds time.sleep(3) print(cache.get(\\"key1\\")) # \\"value1\\" time.sleep(3) print(cache.get(\\"key1\\")) # \\"Expired\\" cache.put(\\"key2\\", \\"value2\\", 10) print(cache) # \\"Key2: value2\\" time.sleep(11) print(cache) # \\"\\" ``` # Performance Requirements - Ensure that the implementation can handle time-based expiration checks efficiently. - Aim for O(1) retrieval time for keys that are present in cache.","solution":"from time import time class SimpleCache: def __init__(self): # Store cache data as a dictionary: { key: (value, expiration_time) } self.cache = {} def put(self, key: str, value: str, ttl: int) -> None: expiration_time = time() + ttl self.cache[key] = (value, expiration_time) def get(self, key: str) -> str: if key in self.cache: value, expiration_time = self.cache[key] current_time = time() if current_time < expiration_time: return value else: # Remove expired key from cache del self.cache[key] return \\"Expired\\" return \\"Key not found\\" def __str__(self) -> str: current_time = time() items = {k: v for k, (v, exp) in self.cache.items() if exp > current_time} return \\", \\".join(f\\"{k}: {v}\\" for k, v in items.items())"},{"question":"# Merge K Sorted Lists Problem Statement You are given `k` sorted linked lists. Your task is to merge these `k` sorted linked lists into one sorted linked list. Write a function `merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]` that takes a list of linked lists as input and returns a single merged sorted linked list. Input Format * `lists`: A list of `k` sorted linked lists where each linked list\'s nodes contain integer values. Output Format * A single sorted linked list that contains all the elements from the input linked lists. Example Input: ```python lists = [ ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6)) ] ``` Output: ```python # This would represent the merged linked list ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(4, ListNode(5, ListNode(6)))))))) ``` Additional Example Scenarios Input: ```python lists = [ ListNode(1), ListNode(0) ] ``` Output: ```python ListNode(0, ListNode(1)) ``` Constraints * The number of linked lists, `k`, received as input will be between 0 and 100. * Each linked list will have no more than 1000 nodes. * The value of each node in the linked lists will be between -10^4 and 10^4. * The linked lists are sorted in non-decreasing order. Requirements * Implement the function `merge_k_sorted_lists` with the following signature: ```python def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: ``` Performance * The implementation should run efficiently even for the upper limits of the input size. * Aiming towards a time complexity of O(N log k), where N is the total number of elements in all the linked lists and k is the number of lists, will be beneficial.","solution":"from heapq import heappush, heappop from typing import List, Optional class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: heap = [] # Initialize the heap with the head of each list for index, node in enumerate(lists): if node: heappush(heap, (node.val, index, node)) dummy = ListNode(0) current = dummy while heap: value, index, node = heappop(heap) current.next = ListNode(value) current = current.next if node.next: heappush(heap, (node.next.val, index, node.next)) return dummy.next"},{"question":"# Coding Assessment Question You are tasked with designing a function to calculate the n-th Fibonacci number. The Fibonacci sequence is a well-known sequence in mathematics, where each number is the sum of the two preceding ones, usually starting with 0 and 1. Traditionally, Fibonacci sequences are calculated using either iteration or recursion, but your goal is to explore different methods to optimize its calculation. **Task**: Implement two functions for calculating the n-th Fibonacci number: one using matrix exponentiation and one using memoized recursion. # Requirements and Constraints: 1. **Input Format**: * An integer `n`, where `0 <= n <= 10^5`. 2. **Output Format**: * An integer representing the n-th Fibonacci number. 3. **Constraints**: * Ensure your approach can handle very large values of `n` efficiently. * For recursive method, use memoization to cache results and avoid redundant calculations. * For matrix exponentiation, utilize matrix multiplication to achieve optimized performance. # Example: ```python # Function to calculate n-th Fibonacci using memoization in recursion def fib_memoized(n: int, memo={}) -> int: # Your implementation here using memoized recursion # Function to calculate n-th Fibonacci using matrix exponentiation def fib_matrix_exponentiation(n: int) -> int: # Your implementation here using matrix exponentiation # Examples # Memoized Recursion Approach assert fib_memoized(10) == 55 assert fib_memoized(50) == 12586269025 # Matrix Exponentiation Approach assert fib_matrix_exponentiation(10) == 55 assert fib_matrix_exponentiation(50) == 12586269025 ``` **Additional Task**: Analyze and compare the time complexity and space complexity of both methods. Provide a brief explanation of why one method might be preferred over the other in scenarios with very high values of `n`.","solution":"def fib_memoized(n, memo = {0: 0, 1: 1}): Returns the n-th Fibonacci number using memoized recursion. if n in memo: return memo[n] memo[n] = fib_memoized(n-1, memo) + fib_memoized(n-2, memo) return memo[n] def fib_matrix_exponentiation(n): Returns the n-th Fibonacci number using matrix exponentiation. if n == 0: return 0 elif n == 1: return 1 def multiply_matrices(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]], ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] while power: if power % 2: result = multiply_matrices(result, matrix) matrix = multiply_matrices(matrix, matrix) power //= 2 return result F = [[1, 1], [1, 0]] result = matrix_power(F, n-1) return result[0][0]"},{"question":"# Problem Statement You are commissioned to create a module that analyzes and summarizes the service management pattern of a company\'s customer support system. The module should determine the average response time, the average resolution time, and the customer satisfaction rate based on a set of given support ticket data. # Requirements You are to implement three functions `avg_response_time`, `avg_resolution_time`, and `satisfaction_rate` based on the given formulas and input validation logic. Additionally, you are required to write a composite function `service_summary` that leverages these three functions to provide a summary of the service metrics. # Input and Output 1. **Input** - `service_summary(tickets: List[dict]) -> dict` - `tickets`: List of dictionaries, where each dictionary represents a support ticket with the following structure: - `\'response_time\'`: int (time in minutes, must be non-negative) - `\'resolution_time\'`: int (time in minutes, must be non-negative) - `\'satisfaction\'`: bool (True if the customer was satisfied, False otherwise) 2. **Output** - Return a dictionary containing: - `\'average_response_time\'`: float (average response time of all tickets) - `\'average_resolution_time\'`: float (average resolution time of all tickets) - `\'satisfaction_rate\'`: float (percentage of satisfied customers) # Constraints - Each `response_time` and `resolution_time` must be non-negative integers. - The `satisfaction` field must be a boolean. # Example ```python tickets = [ {\'response_time\': 10, \'resolution_time\': 50, \'satisfaction\': True}, {\'response_time\': 5, \'resolution_time\': 30, \'satisfaction\': False}, {\'response_time\': 15, \'resolution_time\': 60, \'satisfaction\': True} ] service_summary(tickets) # Output: {\'average_response_time\': 10.0, \'average_resolution_time\': 46.67, \'satisfaction_rate\': 66.67} tickets = [ {\'response_time\': 20, \'resolution_time\': 40, \'satisfaction\': False}, {\'response_time\': 30, \'resolution_time\': 50, \'satisfaction\': True} ] service_summary(tickets) # Output: {\'average_response_time\': 25.0, \'average_resolution_time\': 45.0, \'satisfaction_rate\': 50.0} ``` # Notes - Handle invalid inputs by raising appropriate exceptions as required. - Ensure calculations are accurate to two decimal points. - You can assume the input list contains at least one ticket. # Implementation Implement the required functions using the provided information and ensure to follow the input validation rigorously.","solution":"from typing import List, Dict def avg_response_time(tickets: List[Dict]) -> float: total_response_time = sum(ticket[\'response_time\'] for ticket in tickets) return round(total_response_time / len(tickets), 2) def avg_resolution_time(tickets: List[Dict]) -> float: total_resolution_time = sum(ticket[\'resolution_time\'] for ticket in tickets) return round(total_resolution_time / len(tickets), 2) def satisfaction_rate(tickets: List[Dict]) -> float: satisfied_count = sum(ticket[\'satisfaction\'] for ticket in tickets) return round((satisfied_count / len(tickets)) * 100, 2) def service_summary(tickets: List[Dict]) -> Dict[str, float]: return { \'average_response_time\': avg_response_time(tickets), \'average_resolution_time\': avg_resolution_time(tickets), \'satisfaction_rate\': satisfaction_rate(tickets) }"},{"question":"# Task: Top K Frequent Elements Given the following problem scenario, create a function that finds the top K most frequent elements in an array. The function should efficiently determine the K most common elements using appropriate data structures for the task. # Problem Scenario: You are given a list of integers representing purchases made in an online store. You are tasked with identifying the top K most frequently purchased items in this dataset. Write a function `top_k_frequent` that receives the list of integers and the value K, and returns a list of the K most frequent elements. # Function Signature: ```python def top_k_frequent(purchases: list[int], k: int) -> list[int]: ``` # Input: * `purchases` - A list of integers representing item IDs from the online store. The list is guaranteed to be non-empty. * `k` - An integer representing the number of top frequent elements to return. # Output: * Returns a list of integers representing the K most frequent elements. If there are multiple answers, return any valid output. # Constraints: - The input list contains at least 1 and at most 10,000 integers. - Each integer in the `purchases` list represents a valid item ID. - 1 ≤ k ≤ number of unique elements in `purchases`. # Performance Requirements: - Time Complexity: O(N log K) where N is the number of elements in the input list. - Space Complexity: O(N) where N is the number of elements in the input list. # Example Usage: ```python >>> top_k_frequent([4, 1, 2, 2, 3, 3, 3, 1, 1, 1, 4, 2], 2) [1, 2] # or [1, 3] depending on implementation specifics >>> top_k_frequent([5, 5, 5, 3, 1], 1) [5] >>> top_k_frequent([6, 7, 8, 8, 7, 6, 6], 3) [6, 7, 8] # order may vary ``` You are to ensure that your function handles all edge cases such as ties in frequency and a variety of distributions of item IDs. # Notes: - Think about using a combination of frequency counting and a heap/priority queue to efficiently find the top K elements. - Be cautious about the space and time complexity as the input size grows.","solution":"from collections import Counter import heapq def top_k_frequent(purchases: list[int], k: int) -> list[int]: Find the top k most frequent elements in the purchases list. :param purchases: List of integers representing item IDs from the online store. :param k: Integer representing the number of top frequent elements to return. :return: List of integers representing the K most frequent elements. # Step 1: Count the frequencies of each element using Counter frequency_count = Counter(purchases) # Step 2: Use a heap to find the top k frequent elements # Since heapq implements a min-heap, we insert negative frequencies to get a max-heap behavior heap = [(-freq, item) for item, freq in frequency_count.items()] heapq.heapify(heap) # Step 3: Extract the top k elements from the heap top_k_elements = [heapq.heappop(heap)[1] for _ in range(k)] return top_k_elements"},{"question":"Context In many applications involving data processing, it\'s often necessary to normalize data to ensure that each feature lies within the same range. One common technique is Min-Max normalization, which rescales the data within a specified range, usually between 0 and 1. Problem You are given a list of numeric values, and you need to implement a function that performs Min-Max normalization on this list. **Input**: - A list of numeric values (integers or floats). The length of the list can vary. **Output**: - A list of the same size, where each element has been normalized to lie between 0 and 1 using the Min-Max normalization formula: [ x_{text{normalized}} = frac{x - min(x)}{max(x) - min(x)} ] **Function Signature**: ```python def min_max_normalize(values: list) -> list: # your code here ``` # Constraints: 1. The input list can be empty, in which case the output should also be an empty list. 2. All input values are assumed to be finite numbers. 3. If the list contains only one unique value, all elements in the normalized list should be 0. # Example: ```python >>> values = [2, 4, 6, 8, 10] >>> min_max_normalize(values) [0.0, 0.25, 0.5, 0.75, 1.0] >>> values = [7.5, 7.5, 7.5] >>> min_max_normalize(values) [0.0, 0.0, 0.0] >>> values = [] >>> min_max_normalize(values) [] ``` Implement the `min_max_normalize` function to return the expected output.","solution":"def min_max_normalize(values: list) -> list: if not values: return [] min_val = min(values) max_val = max(values) if min_val == max_val: return [0.0] * len(values) return [(x - min_val) / (max_val - min_val) for x in values]"},{"question":"# Knapsack Problem with Fractional Items You are given a set of items, each with a weight and a value, and a knapsack with a maximum capacity. Unlike the traditional knapsack problem, you can take any fraction of an item rather than having to take all or none of it. Your task is to implement a function that maximizes the total value of items placed in the knapsack. Function Signature ```python def fractional_knapsack(capacity: float, items: list[tuple[float, float]]) -> float: ``` Input - **capacity**: A float representing the maximum weight capacity of the knapsack. - **items**: A list of tuples, where each tuple `(value, weight)` represents the value and weight of an item. Output - Returns a float representing the maximum value that can be achieved with the given capacity. Constraints 1. The number of items (`n`) will be at most 1000. 2. Weights and values are positive real numbers. # Sample Input ```python capacity = 50.0 items = [ (60, 10), (100, 20), (120, 30), ] ``` # Sample Output ```python 240.0 ``` # Notes - You should consider items in descending order of their value/weight ratio. - If the total weight exceeds the capacity, you can only take a fraction of the item to fill the remaining capacity. - The function should handle edge cases gracefully, such as empty item lists or zero capacity.","solution":"def fractional_knapsack(capacity: float, items: list[tuple[float, float]]) -> float: # Sort items by value-to-weight ratio in descending order items_sorted = sorted(items, key=lambda x: x[0]/x[1], reverse=True) total_value = 0.0 for value, weight in items_sorted: if capacity <= 0: break if weight <= capacity: # Take the whole item total_value += value capacity -= weight else: # Take the fraction of the item total_value += value * (capacity / weight) capacity = 0 return total_value"},{"question":"# Problem Statement Given an array of integers, your task is to implement an algorithm that finds the longest contiguous subarray with equal number of zeroes and ones. If there are multiple such subarrays with the same maximum length, return any one of them. # Function Signature Implement the following function: ```python def find_longest_subarray(arr: List[int]) -> Tuple[int, int]: pass ``` # Input - `arr`: A list of integers containing only 0s and 1s. # Output - A tuple containing two integers representing the starting and ending indices (inclusive) of the longest subarray with equal number of zeroes and ones. If no such subarray exists, return (-1, -1). # Constraints - The length of the array `n` is between 1 and 10^5. - The elements in the array `arr` are only 0s and 1s. # Example ```python arr = [0, 1, 0, 0, 1, 1, 0] start, end = find_longest_subarray(arr) print(start, end) ``` Output: ``` 0 5 ``` # Explanation The longest subarray with equal number of 0s and 1s is from index 0 to index 5 (subarray = `[0, 1, 0, 0, 1, 1]`). # Hints 1. Consider using a hash map to store the cumulative sums of the array, where 0 is treated as -1. 2. Use the hash map to quickly find the start of the longest subarray with the same cumulative sum encountered previously.","solution":"from typing import List, Tuple def find_longest_subarray(arr: List[int]) -> Tuple[int, int]: Finds the longest contiguous subarray with equal number of 0s and 1s in an input array of only 0s and 1s. Returns the starting and ending indices (inclusive) of the longest subarray. If no such subarray exists, returns (-1, -1). # Transform 0s to -1s to use cummulative sum technique cum_sum = 0 index_map = {0: -1} # Initialize with cum_sum 0 at index -1 for the entire prefix max_length = 0 start_index = -1 for i in range(len(arr)): if arr[i] == 0: cum_sum -= 1 else: cum_sum += 1 if cum_sum in index_map: if i - index_map[cum_sum] > max_length: max_length = i - index_map[cum_sum] start_index = index_map[cum_sum] + 1 else: index_map[cum_sum] = i if max_length == 0: return (-1, -1) return (start_index, start_index + max_length - 1)"},{"question":"# Question: Calculate the Product of Array after Omitting an Element Context In many programming problems, you might be asked to manipulate an array and perform certain computations. One such task is to generate a new array where each element at index `i` is the product of all elements in the original array except the element at `i`. Task Write a function `product_array_except_self(nums: List[int]) -> List[int]` that takes a list of integers and returns a new list such that each element at index `i` of the new list is the product of all the numbers in the original list except the one at `i`. Function Signature ```python def product_array_except_self(nums: List[int]) -> List[int]: ``` Inputs - `nums`: A list of integers. Outputs - A list of integers where each element is the product of all the elements in the input list except for the one at the corresponding index. Constraints 1. The length of the input list will be between 1 and 100. 2. Each element in the input list will be between -1000 and 1000. 3. The function should not use the division operation. 4. The function should run in O(n) time complexity. Examples ```python >>> product_array_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_array_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_array_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_array_except_self([0, 0]) [0, 0] >>> product_array_except_self([1]) [1] ``` Additional Information - Ensure that the implementation does not use any division operation. - Consider edge cases such as lists containing zeros or having only one element.","solution":"from typing import List def product_array_except_self(nums: List[int]) -> List[int]: n = len(nums) if n == 1: return [1] left_products = [1] * n right_products = [1] * n # Populate left_products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Populate right_products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate result array result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"# Context In combinatorial mathematics, the binomial coefficient represents the number of ways to choose a subset of elements from a larger set. These coefficients arise naturally in various counting problems, particularly in combinations and binomial theorem expansion. A common task is to calculate the greatest common divisor (GCD) of multiple binomial coefficients. This practice is valuable as it combines knowledge of combinatorial computations with number theory. Given integers `n` and `k`, we need to compute the GCD of the binomial coefficients for all `k` from 1 to `k_max` (inclusive). The binomial coefficient (binom{n}{k}) is defined as: [ binom{n}{k} = frac{n!}{k! cdot (n-k)!} ] # Task Implement a function `gcd_of_binomials` that computes the GCD of binomial coefficients for all `k` from 1 to `k_max` given an integer `n`. 1. **Function Signature**: ```python def gcd_of_binomials(n: int, k_max: int) -> int: pass ``` 2. **Parameters**: - `n` (int): An integer representing the set size from which subsets are to be chosen. - `k_max` (int): An integer representing the maximum subset size for which the binomial coefficient GCD is to be calculated. 3. **Returns**: - An integer representing the GCD of all binomial coefficients (binom{n}{k}) for (k) from 1 to `k_max`. # Constraints - (1 leq n leq 10^6) - (1 leq k_{max} leq n) - The input values will always be such that the computations remain feasible within Python\'s arithmetic capabilities. # Example Consider (n = 6) and (k_{max} = 3): [ binom{6}{1} = 6 ] [ binom{6}{2} = 15 ] [ binom{6}{3} = 20 ] The function should return the GCD of 6, 15, and 20, which is 1. # Implementation Details 1. Calculate the binomial coefficients (binom{n}{k}) for each (k) in the range from 1 to `k_max`. 2. Compute the GCD of these coefficients using an efficient numerical algorithm. 3. Return the resultant GCD.","solution":"import math from functools import reduce def gcd_of_binomials(n: int, k_max: int) -> int: def binomial_coefficient(n, k): if k > n: return 0 if k == 0 or k == n: return 1 k = min(k, n - k) # C(n, k) == C(n, n - k) c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c gcd_value = 0 for k in range(1, k_max + 1): binom = binomial_coefficient(n, k) gcd_value = math.gcd(gcd_value, binom) return gcd_value"},{"question":"# Longest Consecutive Sequence of Even Numbers Write a function to find the length of the longest consecutive sequence of even numbers in a given list of integers. Function Signature ```python def longest_consecutive_even_sequence(nums: list) -> int: Finds the length of the longest consecutive sequence of even numbers. Parameters: nums (list): A list of integers. Returns: int: The length of the longest consecutive sequence of even numbers. ``` Input and Output Formats * **Input**: A list of integers, which can include both positive and negative numbers as well as zero. * **Output**: A single integer representing the length of the longest consecutive sequence of even numbers. Constraints * The list of integers can have any length from 0 to 10^5. * Each integer in the list is within the range of [-10^9, 10^9]. Examples ```python >>> longest_consecutive_even_sequence([1, 2, 4, 6, 7, 8, 10]) 3 >>> longest_consecutive_even_sequence([1, 3, 5, 7, 9]) 0 >>> longest_consecutive_even_sequence([1, 2, 2, 4, 6, 8, 1, 2, 4, 6]) 5 ``` Hint Iterate through the list, keeping track of the current length of consecutive even numbers and updating the maximum length found. Be sure to reset the current count when an odd number is encountered.","solution":"def longest_consecutive_even_sequence(nums: list) -> int: Finds the length of the longest consecutive sequence of even numbers. Parameters: nums (list): A list of integers. Returns: int: The length of the longest consecutive sequence of even numbers. max_len = 0 current_len = 0 for num in nums: if num % 2 == 0: current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 0 return max_len"},{"question":"# Problem Statement Write a function `merge_unique_sorted_lists(list1: list[int], list2: list[int]) -> list[int]` that takes two sorted lists of integers and returns a new sorted list that contains all unique elements from both lists in ascending order. The function should: 1. Merge the two input lists into one. 2. Remove any duplicate values. 3. Return the merged unique elements in ascending order. # Constraints 1. The input lists are already sorted in non-decreasing order. 2. The input lists can contain negative integers. 3. The length of the input lists can be 0. # Input - Two sorted lists of integers, `list1` and `list2`. # Examples ```python merge_unique_sorted_lists([1, 2, 4], [1, 3, 5]) # Output: [1, 2, 3, 4, 5] merge_unique_sorted_lists([-3, -1, 2], [-2, -1, 0, 2]) # Output: [-3, -2, -1, 0, 2] merge_unique_sorted_lists([4, 4, 4], [4, 4]) # Output: [4] merge_unique_sorted_lists([], [1, 3, 5]) # Output: [1, 3, 5] ``` # Implementation Details - Assume the inputs are always lists of integers. - The function should handle empty lists. - Ensure that the output list is in ascending order and contains no duplicates. - Consider efficient ways to merge and deduplicate the input lists without significantly increasing time complexity.","solution":"def merge_unique_sorted_lists(list1, list2): Merges two sorted lists into one sorted list with unique elements. Parameters: list1 (list[int]): The first sorted list of integers. list2 (list[int]): The second sorted list of integers. Returns: list[int]: A new sorted list with unique elements from both lists. merged_list = sorted(set(list1) | set(list2)) return merged_list"},{"question":"Problem Statement You are tasked with enhancing the performance of a given Machine Learning model, specifically a RandomForestClassifier. Your task is to implement a feature scaling method that normalizes the dataset features before they are fed into the model for training. This normalization should ensure each feature of the dataset has a mean of 0 and a standard deviation of 1. # Function to Implement ```python def normalize_features(train_x, test_x): Normalizes the training and test datasets to have zero mean and unit variance. @param train_x: A 2D numpy array of training features. @param test_x: A 2D numpy array of test features. @return: Two 2D numpy arrays: the normalized training features and test features. # Your code here pass ``` # Input and Output Formats Input - `train_x`: A 2D numpy array where each row represents a sample and each column represents a feature of the training set. - `test_x`: A 2D numpy array where each row represents a sample and each column represents a feature of the test set. Output - The function should return two 2D numpy arrays of the same shape as `train_x` and `test_x` respectively, but with normalized features. # Constraints - Apply the same scaling transformation derived from the training data to the test data. - Both `train_x` and `test_x` are guaranteed to be non-empty and of compatible dimensions. # Example ```python # Example Input: train_x = np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]) test_x = np.array([[2.0, 3.0], [4.0, 5.0]]) # Example Output: # normalize_features(train_x, test_x) # (array([[-1.22474487, -1.22474487], # [ 0. , 0. ], # [ 1.22474487, 1.22474487]]), # array([[-0.61237244, -0.61237244], # [ 0.61237244, 0.61237244]])) ``` # Notes - You should use the mean and the standard deviation of the `train_x` features to normalize `train_x` and `test_x`. - Feature scaling is a crucial preprocessing step in many machine learning algorithms, including RandomForestClassifier, to ensure each feature contributes equally to the model.","solution":"import numpy as np def normalize_features(train_x, test_x): Normalizes the training and test datasets to have zero mean and unit variance. @param train_x: A 2D numpy array of training features. @param test_x: A 2D numpy array of test features. @return: Two 2D numpy arrays: the normalized training features and test features. # Calculate mean and standard deviation from the training data mean = np.mean(train_x, axis=0) std = np.std(train_x, axis=0) # Avoid division by zero by setting std to 1 where it is zero std[std == 0] = 1 # Normalize both training and test sets train_x_normalized = (train_x - mean) / std test_x_normalized = (test_x - mean) / std return train_x_normalized, test_x_normalized"},{"question":"# Coding Question Scenario You are designing a library system and need to develop a feature that filters books based on their titles. The application receives a list of book titles (strings) and a keyword. It returns the titles that contain the keyword, case-insensitive. Objective Implement the `filter_books_by_keyword` function that filters book titles based on a given keyword. Function Signature ```python def filter_books_by_keyword(titles: list[str], keyword: str) -> list[str]: ``` Input * A list of strings, where each string represents a book title. * A single string representing the keyword. Output * A list of strings, containing the book titles that include the keyword, case-insensitive. Constraints * The list can contain between 0 and 10^5 book titles. * The length of each title is between 1 and 100 characters. * The keyword length is between 1 and 20 characters. * The input list may be empty. Example ```python assert filter_books_by_keyword([\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"], \\"the\\") == [\\"The Great Gatsby\\", \\"The Catcher in the Rye\\"] assert filter_books_by_keyword([\\"1984\\", \\"Animal Farm\\", \\"Brave New World\\"], \\"Brave\\") == [\\"Brave New World\\"] assert filter_books_by_keyword([\\"1984\\", \\"Animal Farm\\", \\"Brave New World\\"], \\"harry\\") == [] assert filter_books_by_keyword([], \\"any\\") == [] ``` Constraints & Performance Requirements * The function should be case-insensitive. * The solution should efficiently handle up to the maximum constraints. Instructions 1. Implement the function `filter_books_by_keyword`. 2. Write your implementation to pass all the given example cases. 3. Consider edge cases, such as an empty list, no matches, or different letter cases in titles and keyword.","solution":"def filter_books_by_keyword(titles, keyword): Filters book titles that contain the given keyword (case-insensitive). Parameters: - titles (list of str): List of book titles. - keyword (str): A keyword to filter titles by. Returns: - list of str: List of titles containing the keyword. keyword_lower = keyword.lower() filtered_titles = [title for title in titles if keyword_lower in title.lower()] return filtered_titles"},{"question":"# Description: In this task, you need to create a function that calculates the greatest common divisor (GCD) of two given integers using an efficient algorithm. The goal is to test your ability to implement classical algorithms and optimize them for performance. Ensure your solution can handle a wide range of input values effectively. # Objective: Write a function `find_gcd(a: int, b: int) -> int` that returns the greatest common divisor of two integers. Your implementation should correctly manage both positive and negative integers as input. # Input: * Two integer values `a` and `b`, where `-10^18 <= a, b <= 10^18`. # Output: * An integer representing the greatest common divisor of the two provided input numbers `a` and `b`. # Requirements: * Your implementation should use the Euclidean algorithm for finding the GCD. * Handle edge cases such as zeros and negative numbers appropriately. * Write error handling code to manage non-integer inputs. # Constraints: * Do not use any third-party libraries; the built-in `math.gcd` is not allowed. * Ensure that your algorithm is well-optimized, ideally O(log(min(a, b))) for large values. Example: ```python >>> find_gcd(56, 98) 14 >>> find_gcd(-48, -18) 6 >>> find_gcd(0, 5) 5 >>> find_gcd(7, 0) 7 >>> find_gcd(0, 0) 0 >>> find_gcd(\'100\', 50) Traceback (most recent call last): ... TypeError: Both inputs must be integers ``` Test Cases to Validate: ```python assert find_gcd(56, 98) == 14 assert find_gcd(-48, -18) == 6 assert find_gcd(0, 5) == 5 assert find_gcd(7, 0) == 7 assert find_gcd(0, 0) == 0 try: find_gcd(\'100\', 50) except TypeError: print(\\"Caught TypeError as expected\\") ``` # Implementation Function Stub ```python def find_gcd(a: int, b: int) -> int: if not isinstance(a, int) or not isinstance(b, int): raise TypeError(\\"Both inputs must be integers\\") # Applying Euclidean algorithm to find GCD while b != 0: a, b = b, a % b return abs(a) ```","solution":"def find_gcd(a: int, b: int) -> int: Returns the greatest common divisor of two integers using the Euclidean algorithm. Args: a (int): First integer. b (int): Second integer. Returns: int: Greatest common divisor of a and b. Raises: TypeError: If either of the inputs is not an integer. if not isinstance(a, int) or not isinstance(b, int): raise TypeError(\\"Both inputs must be integers\\") # Applying Euclidean algorithm to find GCD while b != 0: a, b = b, a % b return abs(a)"},{"question":"# Coding Question Write a function that extracts specific data from a customer transactions list to generate a report. The function should filter transactions based on a range of years and create a summary report of the total and average transaction amounts per customer within that range. **Function: `transaction_report`** ```python def transaction_report(transactions: list, start_year: int, end_year: int) -> dict: Takes a list of transactions and a date range (start and end years, inclusive), and returns a summary report with total and average transaction amounts per customer. transactions: List of dictionaries representing transaction records. Each transaction has the following keys: - `customer_id` (int): unique identifier for the customer - `amount` (float): the amount of the transaction - `date` (str): the date of the transaction in the format \\"YYYY-MM-DD\\" start_year: The starting year (inclusive) of the range end_year: The ending year (inclusive) of the range Returns a dictionary where keys are customer IDs and values are dictionaries with two keys: \\"total_amount\\" (total transaction amount within the range) \\"average_amount\\" (average transaction amount within the range) Examples: >>> transactions = [ ... {\'customer_id\': 1, \'amount\': 100.0, \'date\': \'2020-01-10\'}, ... {\'customer_id\': 2, \'amount\': 200.0, \'date\': \'2021-05-15\'}, ... {\'customer_id\': 1, \'amount\': 150.0, \'date\': \'2019-08-03\'}, ... {\'customer_id\': 3, \'amount\': 300.0, \'date\': \'2021-11-22\'} ... ] >>> transaction_report(transactions, 2020, 2021) {1: {\'total_amount\': 100.0, \'average_amount\': 100.0}, 2: {\'total_amount\': 200.0, \'average_amount\': 200.0}, 3: {\'total_amount\': 300.0, \'average_amount\': 300.0}} >>> transaction_report([], 2020, 2021) {} >>> transaction_report(transactions, 2023, 2025) {} pass # your code here ``` # Constraints * Transactions list can be empty. * Years will be valid integers. # Example Scenario: You work at a financial reporting company that needs to generate customer transaction reports for a specified range of years. Using the provided transaction data, you need to filter out transactions that fall outside the given range and prepare a summary report for further analysis. **Sample Transactions List:** ```python transactions = [ {\'customer_id\': 1, \'amount\': 100.0, \'date\': \'2020-01-10\'}, {\'customer_id\': 2, \'amount\': 200.0, \'date\': \'2021-05-15\'}, {\'customer_id\': 1, \'amount\': 150.0, \'date\': \'2019-08-03\'}, {\'customer_id\': 3, \'amount\': 300.0, \'date\': \'2021-11-22\'} ] ``` **Calling the Function:** ```python report = transaction_report(transactions, 2020, 2021) ``` **Expected Output:** ```python { 1: {\'total_amount\': 100.0, \'average_amount\': 100.0}, 2: {\'total_amount\': 200.0, \'average_amount\': 200.0}, 3: {\'total_amount\': 300.0, \'average_amount\': 300.0} } ```","solution":"def transaction_report(transactions, start_year, end_year): from collections import defaultdict from datetime import datetime report = defaultdict(lambda: {\'total_amount\': 0, \'count\': 0}) # Filter transactions within the date range for transaction in transactions: year = int(transaction[\'date\'].split(\'-\')[0]) if start_year <= year <= end_year: customer_id = transaction[\'customer_id\'] amount = transaction[\'amount\'] report[customer_id][\'total_amount\'] += amount report[customer_id][\'count\'] += 1 # Prepare the final report final_report = {} for customer_id, data in report.items(): total_amount = data[\'total_amount\'] count = data[\'count\'] average_amount = total_amount / count final_report[customer_id] = { \'total_amount\': total_amount, \'average_amount\': average_amount } return final_report"},{"question":"# Task: Find the Longest Common Subsequence Scenario You are working on a feature for a text comparison application. This feature needs to identify the longest common subsequence (LCS) between two strings, which can help in determining the similarity between two texts. Requirements 1. **Function Implementation**: Implement the function `longest_common_subsequence(seq1, seq2)` in Python that achieves the following: * Takes as input: - `seq1`: a string. - `seq2`: a string. * Returns: - An integer representing the length of the longest common subsequence between the two input strings. Input and Output Format * **Input**: * `seq1`: string (length <= 1000). * `seq2`: string (length <= 1000). * **Output**: * An integer indicating the length of the longest common subsequence. Constraints * Both strings will only contain lowercase English letters. * The length of both strings will be at most 1000. Performance Requirements Your implementation should be efficient in terms of time and space complexity. It should use dynamic programming to optimize the computation of the longest common subsequence. ```python def longest_common_subsequence(seq1, seq2): # Write your code here pass # Example seq1 = \\"abcde\\" seq2 = \\"ace\\" print(longest_common_subsequence(seq1, seq2)) # Output: 3 ``` Explanation Given the strings `\\"abcde\\"` and `\\"ace\\"`, the longest common subsequence is `\\"ace\\"`, which has a length of 3. Therefore, the function should return `3`.","solution":"def longest_common_subsequence(seq1, seq2): Finds the length of the longest common subsequence (LCS) between two strings. m, n = len(seq1), len(seq2) # Create a 2D DP array dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP array for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value in dp[m][n] will be the length of the LCS return dp[m][n]"},{"question":"Task Question Creation for Coding Assessment Additional Question Creation # New Question: In a delivery service, a delivery truck needs to deliver packages to multiple destinations efficiently. Given a number of delivery points, the goal is to find the shortest possible route that visits each destination exactly once and returns to the starting point. This is a well-known problem called the Travelling Salesperson Problem (TSP). Design an algorithm that uses the nearest neighbor heuristic to approximate a solution for the TSP. Function Signature: ```python def nearest_neighbor_tsp(points: List[Tuple[float, float]]) -> List[int]: ``` Input: - `points` (List[Tuple[float, float]]): A list of tuples, each containing the x and y coordinates of a delivery point. Output: - Returns a list of integers representing the sequence of indices of the delivery points in the order they are visited. Constraints: - `2 ≤ len(points) ≤ 1000` - Coordinates values are between -10^4 and 10^4 inclusive. Performance Requirements: - The implementation should be reasonably efficient and should aim to find an approximate solution to the TSP using the nearest neighbor heuristic. Example: ```python points = [(0, 0), (2, 2), (2, 0), (0, 2)] print(nearest_neighbor_tsp(points)) # Expected output: [0, 1, 3, 2] or a similar sequence that represents a short path visiting all points once and returning to the start. ``` Note: - The sequence returned does not have to be the optimal solution, but should provide a reasonably short route using the nearest neighbor heuristic.","solution":"from typing import List, Tuple def nearest_neighbor_tsp(points: List[Tuple[float, float]]) -> List[int]: import math def distance(point1, point2): return math.hypot(point1[0] - point2[0], point1[1] - point2[1]) n = len(points) if n == 0: return [] unvisited = set(range(n)) route = [0] unvisited.remove(0) while unvisited: last = route[-1] next_point = min(unvisited, key=lambda x: distance(points[last], points[x])) route.append(next_point) unvisited.remove(next_point) # Return to start route.append(0) return route"},{"question":"# Problem Statement You are required to develop and test a Library System that manages the collection of books in a library. The system should allow adding new books, removing books, checking out books, and returning books, all while maintaining an efficient structure for quick lookups and updates using hash maps. Implement the `LibrarySystem` class with the following methods: 1. **`__init__`**: - Initialize the necessary data structures to keep track of books and their statuses (checked in/out). 2. **`add_book`**: - Given a unique book ID and book title, add the book to the system. Raise an error if the book ID already exists. 3. **`remove_book`**: - Given a book ID, remove the book from the system. Raise an error if the book ID does not exist or the book is currently checked out. 4. **`checkout_book`**: - Given a book ID, mark it as checked out. Raise an error if the book ID does not exist or the book is already checked out. 5. **`return_book`**: - Given a book ID, mark it as returned. Raise an error if the book ID does not exist or the book is not currently checked out. 6. **`search_book`**: - Given a book title, return the book ID(s) that match the title. Return an empty list if no books are found. # Requirements - For each method, write thorough unittests to verify correctness, including edge cases. - The program should maintain O(1) complexity for adding, removing, checking out, and returning books. - Handle cases where multiple books may have the same title in the `search_book` method. # Example Usage ```python lib = LibrarySystem() lib.add_book(1, \\"1984\\") lib.add_book(2, \\"Brave New World\\") assert lib.search_book(\\"1984\\") == [1] assert lib.search_book(\\"Brave New World\\") == [2] lib.checkout_book(1) lib.return_book(1) lib.remove_book(1) assert lib.search_book(\\"1984\\") == [] ```","solution":"class LibrarySystem: def __init__(self): self.books = {} self.checked_out = set() def add_book(self, book_id, book_title): if book_id in self.books: raise ValueError(\\"Book ID already exists.\\") self.books[book_id] = book_title def remove_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID does not exist.\\") if book_id in self.checked_out: raise ValueError(\\"Book is currently checked out.\\") del self.books[book_id] def checkout_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID does not exist.\\") if book_id in self.checked_out: raise ValueError(\\"Book is already checked out.\\") self.checked_out.add(book_id) def return_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID does not exist.\\") if book_id not in self.checked_out: raise ValueError(\\"Book is not currently checked out.\\") self.checked_out.remove(book_id) def search_book(self, book_title): return [book_id for book_id, title in self.books.items() if title == book_title]"},{"question":"# Problem Statement You are asked to develop a function that processes a list of transactions to determine the net balance for each user. Each transaction involves a payer and a payee with a specified amount. # Objectives 1. **Create a function that calculates the net balance for each user based on the transaction history**. 2. **Ensure the function can handle a variable number of transactions and users**. 3. **Implement input validation to handle incorrect data formats gracefully**. # Requirements 1. Implement the function `calculate_net_balance` which accepts the following parameter: * `transactions` (list): A list of transactions, where each transaction is represented as a dictionary containing `payer` (str), `payee` (str), and `amount` (float). 2. Validate the input parameters: * Ensure each transaction is a dictionary with `payer`, `payee`, and `amount` keys. * Ensure `amount` is a non-negative float. * Raise appropriate error messages for invalid inputs. 3. Calculate the net balance for each user: * The net balance is the total amount received as payee minus the total amount paid as payer for each user. 4. Return a dictionary containing users as keys and their net balances as values. # Input Format * `transactions`: A list of dictionaries, where each dictionary has the following keys: * `payer`: A string representing the user who paid the amount. * `payee`: A string representing the user who received the amount. * `amount`: A positive float representing the transaction amount. # Output Format A dictionary with users as keys and their net balances as floating point values (rounded to two decimal places). # Example ```python transactions = [ {\\"payer\\": \\"Alice\\", \\"payee\\": \\"Bob\\", \\"amount\\": 50.0}, {\\"payer\\": \\"Bob\\", \\"payee\\": \\"Charlie\\", \\"amount\\": 30.0}, {\\"payer\\": \\"Alice\\", \\"payee\\": \\"Charlie\\", \\"amount\\": 20.0}, {\\"payer\\": \\"Charlie\\", \\"payee\\": \\"Alice\\", \\"amount\\": 10.0} ] calculate_net_balance(transactions) # Output: {\'Alice\': -60.0, \'Bob\': 20.0, \'Charlie\': 40.0} ``` # Constraint * The solution should operate with a time complexity of O(n), where n is the number of transactions.","solution":"def calculate_net_balance(transactions): Calculate the net balance for each user based on the transaction history. Parameters: transactions (list): A list of dictionaries, where each dictionary has the following keys: \'payer\' (str): The user who paid the amount. \'payee\' (str): The user who received the amount. \'amount\' (float): A positive float representing the transaction amount. Returns: dict: A dictionary with users as keys and their net balances as floating point values. # Input validation if not isinstance(transactions, list): raise ValueError(\\"Transactions should be a list.\\") net_balance = {} for transaction in transactions: if not isinstance(transaction, dict): raise ValueError(\\"Each transaction should be a dictionary.\\") if \'payer\' not in transaction or \'payee\' not in transaction or \'amount\' not in transaction: raise ValueError(\\"Each transaction should contain \'payer\', \'payee\', and \'amount\' keys.\\") if not isinstance(transaction[\'payer\'], str) or not isinstance(transaction[\'payee\'], str): raise ValueError(\\"\'payer\' and \'payee\' should be strings.\\") if not isinstance(transaction[\'amount\'], (int, float)) or transaction[\'amount\'] < 0: raise ValueError(\\"\'amount\' should be a non-negative float.\\") payer = transaction[\'payer\'] payee = transaction[\'payee\'] amount = round(float(transaction[\'amount\']), 2) if payer not in net_balance: net_balance[payer] = 0.0 if payee not in net_balance: net_balance[payee] = 0.0 net_balance[payer] -= amount net_balance[payee] += amount return net_balance"},{"question":"# Coding Assessment Question: Anagram Pair Detection You are provided with a list of strings and your task is to find all pairs of strings that are anagrams of each other. Objective: Write a Python function `find_anagram_pairs` that: 1. Accepts a list of input strings. 2. Identifies all unique pairs of strings that are anagrams of each other. 3. Returns a list of tuple pairs where each tuple contains two anagram strings. Requirements: 1. Ensure the function handles an edge case where there are no anagram pairs efficiently. 2. Anagram strings are case-insensitive and ignore any non-alphabetic characters. Function Signature: ```python def find_anagram_pairs(input_strings: list[str]) -> list[tuple[str, str]]: pass ``` Input: * `input_strings`: list of strings Output: * `list[tuple[str, str]]`: List of tuples, each containing a pair of anagram strings. Constraints: * Each string in the input list will have a length `1 ≤ length ≤ 1000`. * The total number of strings in the input list will not exceed 10000. Example: ```python input_strings = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"olleh\\", \\"world\\"] result = find_anagram_pairs(input_strings) print(result) # Expected output: [(\'listen\', \'silent\'), (\'listen\', \'enlist\'), (\'silent\', \'enlist\'), (\'hello\', \'olleh\')] ``` Notes: Consider sorting the characters of strings to detect anagram pairs efficiently. Avoid comparing pairs multiple times by keeping track of already checked pairs or using a hashmap for grouping anagrams.","solution":"import re from collections import defaultdict def find_anagram_pairs(input_strings): Identifies all unique pairs of strings that are anagrams of each other. Args: input_strings: List of strings Returns: List of tuple pairs where each tuple contains two anagram strings def clean_string(s): # Remove non-alphabetic characters and convert to lowercase return \'\'.join(sorted(re.sub(r\'[^a-zA-Z]\', \'\', s).lower())) anagram_map = defaultdict(list) for string in input_strings: cleaned = clean_string(string) anagram_map[cleaned].append(string) result = [] for key, anagrams in anagram_map.items(): if len(anagrams) > 1: for i in range(len(anagrams)): for j in range(i + 1, len(anagrams)): result.append((anagrams[i], anagrams[j])) return result"},{"question":"# Coding Assessment Question Context Let\'s say you are developing a rating system and you need to determine the average rating while handling some special conditions. Each rating is an integer in the range from 1 to 5. However, there may be some invalid ratings which are represented by numbers outside this range. Your task is to calculate the average rating by ignoring these invalid ratings. If no valid ratings are found, the average should be 0.0. Objective Implement the function `average_rating(ratings: list[int]) -> float` that calculates the average of valid ratings (ratings from 1 to 5 inclusive). Input/Output Format - **Input**: A list of integers, `ratings`, where each integer represents a rating. - **Output**: A float representing the average rating, rounded to one decimal place. If no valid ratings are found, return `0.0`. Constraints - `0 <= len(ratings) <= 10^5` - `-10^6 <= ratings[i] <= 10^6` Example ```python >>> average_rating([4, 3, 5, 1, 2]) 3.0 # average of valid ratings >>> average_rating([6, -1, 7, 2]) 2.0 # only valid rating is 2 >>> average_rating([]) 0.0 # no ratings >>> average_rating([6, -1, 7, -5]) 0.0 # no valid ratings >>> average_rating([1, 1, 1, 1, 1]) 1.0 # average of valid ratings ``` Requirements 1. Ensure the function handles edge cases such as an empty list and lists with no valid ratings. 2. The solution must run in linear time O(n) and use O(1) extra space.","solution":"def average_rating(ratings): Calculate the average of valid ratings (ratings from 1 to 5 inclusive). :param ratings: List of integers representing ratings. :return: Float representing the average rating, rounded to one decimal place. total = 0 count = 0 for rating in ratings: if 1 <= rating <= 5: total += rating count += 1 if count == 0: return 0.0 return round(total / count, 1)"},{"question":"# Question: Problem Statement: You are required to write a function to multiply two non-negative integers without using the multiplication (`*`), division (`/`), or modulus (`%`) operators. Instead, you should perform repeated addition, and possibly bitwise operations, to achieve the desired result. Function Signature: ```python def multiply(a: int, b: int) -> int: Multiply two non-negative integers without using * / % operators. :param a: First non-negative integer :param b: Second non-negative integer :return: Product of the two integers ``` Input: - `a`: A non-negative integer. - `b`: A non-negative integer. Output: - An integer, representing the product of `a` and `b`. Example: ```python >>> multiply(3, 4) 12 >>> multiply(7, 0) 0 >>> multiply(0, 5) 0 >>> multiply(9, 3) 27 ``` Constraints: - Inputs `a` and `b` will be non-negative integers. - You cannot use the multiplication `*`, division `/`, or modulus `%` operators. Performance Requirements: The function should ideally run in O(n) time complexity with respect to the smaller of the two input values `a` or `b`. Hint: You may use bitwise left shift `<<` and right shift `>>` operations to speed up the addition process (similar to the way the Russian peasant multiplication works). Additionally, careful use of loops and bitwise manipulation can simulate the multiplication process. # Note: Ensure the implementation correctly handles all edge cases, such as one or both inputs being zero. Good luck!","solution":"def multiply(a: int, b: int) -> int: Multiply two non-negative integers without using * / % operators. :param a: First non-negative integer :param b: Second non-negative integer :return: Product of the two integers # Ensure a is the smaller number for efficiency in the loop if a > b: a, b = b, a result = 0 while a > 0: # If the least significant bit of a is 1, add b to result if a & 1: result += b # Shift a to the right by 1 (divide by 2) and shift b to the left by 1 (multiply by 2) a >>= 1 b <<= 1 return result"},{"question":"# Circular Buffer **Scenario**: You are tasked with designing a circular buffer (also known as a ring buffer) for a system that handles streaming data. The buffer should have a fixed size and should efficiently support adding new elements, removing elements, and checking the current buffer state, including its capacity and current number of elements. **Task**: Implement the following methods for a custom `CircularBuffer` class: 1. `add_element`: Adds an element to the buffer. If the buffer is full, the oldest element should be overwritten. 2. `remove_element`: Removes and returns the oldest element from the buffer. Raise an exception if the buffer is empty. 3. `is_empty`: Checks if the buffer is empty. 4. `is_full`: Checks if the buffer is full. 5. `size`: Returns the current number of elements in the buffer. 6. `capacity`: Returns the total capacity of the buffer. **Function Signatures**: ```python class CircularBuffer: def __init__(self, capacity: int) -> None: pass def add_element(self, element: int) -> None: pass def remove_element(self) -> int: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass def size(self) -> int: pass def capacity(self) -> int: pass ``` **Constraints**: - The capacity of the buffer is a positive integer. - The element is an integer. - Ensure the circular nature of the buffer is maintained during add and remove operations. **Example**: ```python buffer = CircularBuffer(3) print(buffer.is_empty()) # Output: True buffer.add_element(10) buffer.add_element(20) print(buffer.is_full()) # Output: False buffer.add_element(30) print(buffer.is_full()) # Output: True print(buffer.remove_element()) # Output: 10 print(buffer.size()) # Output: 2 buffer.add_element(40) print(buffer.size()) # Output: 3 buffer.add_element(50) print(buffer.remove_element()) # Output: 20 ``` Implement `CircularBuffer` considering the described behavior and constraints.","solution":"class CircularBuffer: def __init__(self, capacity: int) -> None: self.capacity_val = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.count = 0 def add_element(self, element: int) -> None: if self.is_full(): self.tail = (self.tail + 1) % self.capacity_val else: self.count += 1 self.buffer[self.head] = element self.head = (self.head + 1) % self.capacity_val def remove_element(self) -> int: if self.is_empty(): raise Exception(\\"Buffer is empty\\") element = self.buffer[self.tail] self.buffer[self.tail] = None self.tail = (self.tail + 1) % self.capacity_val self.count -= 1 return element def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.capacity_val def size(self) -> int: return self.count def capacity(self) -> int: return self.capacity_val"},{"question":"# Weather Data Analysis Using Pandas and Matplotlib For this assessment, you are tasked with analyzing a dataset of weather observations using Pandas and visualizing the results using Matplotlib. You will be given a CSV file with weather data, and you will need to extract meaningful insights and visualize specific aspects of the data. **Problem**: 1. Implement a function `load_data` to read the CSV file into a Pandas DataFrame. 2. Implement a function `analyze_data` to compute summary statistics and trends in the dataset. 3. Implement a function `plot_data` to create visualizations for the weather data. # Input: 1. A string `file_path` representing the path to the CSV file containing the weather data. # Output: 1. A Pandas DataFrame with the loaded data. 2. Summary statistics and trends of the weather observations. 3. Matplotlib visualizations for specified aspects of the data (e.g., temperature trends, precipitation patterns). # Constraints: * Handle missing or incorrect data entries appropriately. * Ensure the visualizations are clear and informative. * Use appropriate titles, labels, and legends in the plots. # CSV Format Example: ``` date,temperature,precipitation,humidity 2023-01-01,32.5,0.0,45 2023-01-02,35.6,0.1,50 ... ``` # Example: ```python import pandas as pd import matplotlib.pyplot as plt def load_data(file_path): # Read the CSV file into a DataFrame df = pd.read_csv(file_path) return df def analyze_data(df): # Compute summary statistics and trends summary = df.describe() trends = { \'Temperature Trend\': df[\'temperature\'].rolling(window=7).mean(), \'Precipitation Trend\': df[\'precipitation\'].rolling(window=7).mean() } return summary, trends def plot_data(df, trends): # Create visualizations for the data plt.figure(figsize=(10, 5)) plt.subplot(2, 1, 1) plt.plot(df[\'date\'], df[\'temperature\'], label=\'Temperature\') plt.plot(df[\'date\'], trends[\'Temperature Trend\'], label=\'7-Day Temperature Trend\', linestyle=\'--\') plt.xlabel(\'Date\') plt.ylabel(\'Temperature (°F)\') plt.title(\'Temperature Over Time\') plt.legend() plt.subplot(2, 1, 2) plt.plot(df[\'date\'], df[\'precipitation\'], label=\'Precipitation\') plt.plot(df[\'date\'], trends[\'Precipitation Trend\'], label=\'7-Day Precipitation Trend\', linestyle=\'--\') plt.xlabel(\'Date\') plt.ylabel(\'Precipitation (in)\') plt.title(\'Precipitation Over Time\') plt.legend() plt.tight_layout() plt.show() def main(): file_path = \'path_to_weather_data.csv\' df = load_data(file_path) summary, trends = analyze_data(df) print(summary) plot_data(df, trends) if __name__ == \\"__main__\\": main() ``` # Evaluation: Evaluate your solution based on: 1. Correctness: Does the function accurately load, analyze, and visualize the weather data? 2. Efficiency: Is your solution optimized for the size of the dataset? 3. Robustness: Does your solution handle missing or incorrect data gracefully?","solution":"import pandas as pd import matplotlib.pyplot as plt def load_data(file_path): Reads the CSV file into a Pandas DataFrame. :param file_path: Path to the CSV file. :return: DataFrame with the loaded data. df = pd.read_csv(file_path) df[\'date\'] = pd.to_datetime(df[\'date\']) return df def analyze_data(df): Computes summary statistics and trends in the dataset. :param df: DataFrame containing the weather data. :return: Summary statistics and calculated trends. # Compute summary statistics summary = df.describe() # Calculate 7-day rolling mean for trends trends = { \'Temperature Trend\': df[\'temperature\'].rolling(window=7).mean(), \'Precipitation Trend\': df[\'precipitation\'].rolling(window=7).mean() } return summary, trends def plot_data(df, trends): Creates visualizations for the weather data. :param df: DataFrame containing the weather data. :param trends: Dictionary containing trends of weather data. plt.figure(figsize=(10, 8)) # Plot temperature trends plt.subplot(2, 1, 1) plt.plot(df[\'date\'], df[\'temperature\'], label=\'Temperature\', color=\'tab:blue\') plt.plot(df[\'date\'], trends[\'Temperature Trend\'], label=\'7-Day Temperature Trend\', linestyle=\'--\', color=\'tab:red\') plt.xlabel(\'Date\') plt.ylabel(\'Temperature (°F)\') plt.title(\'Temperature Over Time\') plt.legend() # Plot precipitation trends plt.subplot(2, 1, 2) plt.plot(df[\'date\'], df[\'precipitation\'], label=\'Precipitation\', color=\'tab:green\') plt.plot(df[\'date\'], trends[\'Precipitation Trend\'], label=\'7-Day Precipitation Trend\', linestyle=\'--\', color=\'tab:orange\') plt.xlabel(\'Date\') plt.ylabel(\'Precipitation (in)\') plt.title(\'Precipitation Over Time\') plt.legend() plt.tight_layout() plt.show() # Example usage # def main(): # file_path = \'path_to_weather_data.csv\' # df = load_data(file_path) # summary, trends = analyze_data(df) # print(summary) # plot_data(df, trends) # # if __name__ == \\"__main__\\": # main()"},{"question":"# Question: Implement a Sudoku Solver Write a class `SudokuSolver` to solve a given Sudoku puzzle. The puzzle is represented by a 9x9 grid where empty cells are denoted by \'.\' and filled cells contain digits \'1\' to \'9\'. Your class should have the following methods: 1. **Constructor `__init__(self, board: list[list[str]])`**: - Initializes the board with the given puzzle. 2. **Method `is_valid(self, row: int, col: int, num: str) -> bool`**: - Returns `True` if placing the number `num` at position `(row, col)` is valid according to Sudoku rules, else returns `False`. 3. **Method `solve(self) -> bool`**: - Solves the Sudoku puzzle using the backtracking technique and returns `True` if the puzzle is solvable, else returns `False`. 4. **Method `get_board(self) -> list[list[str]]**: - Returns the solved Sudoku board. # Example ```python board = [ [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] solver = SudokuSolver(board) if solver.solve(): solved_board = solver.get_board() for row in solved_board: print(row) else: print(\\"No solution exists\\") ``` # Constraints - The input board is a valid 9x9 grid populated with digits \'1\' to \'9\' or \'.\'. - There is only one unique solution for the given Sudoku puzzle. - The implemented solution should efficiently handle the problem within reasonable runtime. Your task is to implement the `SudokuSolver` class to solve the given Sudoku puzzle.","solution":"class SudokuSolver: def __init__(self, board: list[list[str]]): self.board = board def is_valid(self, row: int, col: int, num: str) -> bool: # Check the row for c in range(9): if self.board[row][c] == num: return False # Check the column for r in range(9): if self.board[r][col] == num: return False # Check the 3x3 sub-box start_row, start_col = 3 * (row // 3), 3 * (col // 3) for r in range(start_row, start_row + 3): for c in range(start_col, start_col + 3): if self.board[r][c] == num: return False return True def solve(self) -> bool: for row in range(9): for col in range(9): if self.board[row][col] == \'.\': for num in \'123456789\': if self.is_valid(row, col, num): self.board[row][col] = num if self.solve(): return True self.board[row][col] = \'.\' return False return True def get_board(self) -> list[list[str]]: return self.board"},{"question":"# Queue Simulation with Priority Levels You are tasked to implement a priority queue simulation where different tasks are processed based on their priority levels. Each task has a priority level and a processing time associated with it. The priorities range from 1 (highest) to 5 (lowest). Tasks with higher priority should be processed before tasks with lower priority, and tasks with the same priority should be processed in the order they appear. # Requirements 1. You need to implement a class `PriorityQueueSimulator`. 2. The class should support the following methods: - `add_task(priority: int, processing_time: int) -> None`: Adds a task to the queue. - `process_all_tasks() -> list[int]`: Processes all tasks in the queue based on priority and returns a list of processing times in the order they are processed. # Constraints 1. `priority` will be an integer between 1 and 5. 2. `processing_time` will be a positive integer. 3. There will be at least one task added before processing. # Example ```python pq_sim = PriorityQueueSimulator() pq_sim.add_task(3, 10) pq_sim.add_task(1, 20) pq_sim.add_task(2, 15) pq_sim.add_task(1, 5) processed_times = pq_sim.process_all_tasks() print(processed_times) # Example Output: [20, 5, 15, 10] ``` **Hint**: You can use a list of lists or a dictionary to maintain tasks in different priority levels and ensure proper order of processing.","solution":"from collections import deque class PriorityQueueSimulator: def __init__(self): # Using a dictionary of deques to store tasks based on priority levels self.queues = {i: deque() for i in range(1, 6)} def add_task(self, priority: int, processing_time: int) -> None: if 1 <= priority <= 5 and processing_time > 0: self.queues[priority].append(processing_time) def process_all_tasks(self) -> list: processed_tasks = [] for priority in range(1, 6): while self.queues[priority]: processed_tasks.append(self.queues[priority].popleft()) return processed_tasks"},{"question":"# Question: Implement the Secant Method for Solving Nonlinear Equations You are required to implement the Secant Method for finding the roots of a nonlinear equation `f(x) = 0`. This iterative method approximates the root by using secant lines to better approach the solution. Function Signature ```python def secant_method( func: Callable[[float], float], x0: float, x1: float, tol: float, max_iter: int ) -> float: ``` Parameters: - `func`: A function representing the nonlinear equation `f(x)`, it takes one argument (x) and returns the value of the function at `x`. - `x0`: Initial guess value of `x`. - `x1`: Second guess value of `x`. - `tol`: Tolerance level for convergence. - `max_iter`: Maximum number of iterations allowed. Returns: - A float representing the approximated root of the function `f(x)`. # Constraints: - `x0` and `x1` are distinct floating-point numbers. - `tol > 0` - `max_iter > 0` - Function calls to `func` will provide valid floating-point numbers as inputs. # Example: ```python # Define the nonlinear function def func(x): return x**3 - x - 2 # Initial guesses and parameters x0 = 1.0 x1 = 2.0 tol = 1e-6 max_iter = 100 # Compute the root root = secant_method(func, x0, x1, tol, max_iter) print(root) # Expected output: An approximated value of the root close to 1.52138... ``` # Notes: - Ensure each iteration checks for convergence by comparing the absolute difference between subsequent approximations and `tol`. - If the maximum number of iterations is reached without convergence, return the best approximation available. - Be mindful of the floating-point arithmetic to avoid division by zero errors or extremely small updates in values. - Efficient computation and consideration of edge cases (e.g., repeated roots) are essential.","solution":"def secant_method(func, x0, x1, tol, max_iter): Finds the root of the function `func` using the Secant Method. Parameters: func (Callable[[float], float]): The function for which the root is to be found. x0 (float): Initial guess. x1 (float): Second guess. tol (float): Tolerance for convergence. max_iter (int): Maximum number of iterations. Returns: float: The approximated root of the function `func`. for _ in range(max_iter): # Calculate the function values at x0 and x1 f_x0 = func(x0) f_x1 = func(x1) # Prevent division by zero if f_x1 == f_x0: raise ValueError(\\"Function values at x0 and x1 are equal, leading to division by zero.\\") # Calculate the next x value using the secant method formula x2 = x1 - f_x1 * (x1 - x0) / (f_x1 - f_x0) # Check for convergence if abs(x2 - x1) < tol: return x2 # Update variables for next iteration x0, x1 = x1, x2 # Returning last approximation if maximum iterations are reached return x1"},{"question":"Prime Number Checker with Memoization You are to create a function `is_prime(n: int, memo: dict = {}) -> bool` that checks whether a given integer `n` is a prime number. Use memoization to optimize repeated checks. Requirements: 1. The function should take two parameters: - `n` (int): The number to check for prime status. - `memo` (dict): An optional dictionary that stores previously computed results to avoid redundant computations. 2. The function should return `True` if `n` is a prime number, and `False` otherwise. 3. A prime number is defined as a number greater than 1 that has no positive divisors other than 1 and itself. Input: - `n` (int): An integer to check for prime status. - `memo` (dict, optional): A dictionary storing results of previous prime checks. Output: - A boolean value indicating whether the input integer is a prime number. Example: ```python print(is_prime(7)) # Output: True print(is_prime(4)) # Output: False print(is_prime(2, {2: True}) # Output: True (using memoized value) ``` # Constraints: 1. The input integer `n` will be non-negative and within the range of 0 to 10^6. 2. The function must handle the memoization internally and update the memo dictionary accordingly. 3. The solution should be optimized for performance using memoization. # Additional Notes: - Utilize basic prime-checking algorithms and incorporate memoization to avoid redundant calculations. - Handle the edge cases such as checking small numbers (e.g., 0, 1) appropriately. - Ensure the function can be called multiple times with increasing numbers, illustrating the benefit of memoization.","solution":"def is_prime(n: int, memo: dict = {}) -> bool: Checks if a number is prime with memoization to optimize repeated checks. Parameters: n (int): The number to check. memo (dict): Optional dictionary storing previous prime checks. Returns: bool: True if the number is prime, False otherwise. if n in memo: return memo[n] if n <= 1: memo[n] = False return False if n == 2: memo[n] = True return True if n % 2 == 0: memo[n] = False return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: memo[n] = False return False memo[n] = True return True"},{"question":"# Dynamic Programming for Matrix Path Finding **Context**: You are working on an algorithm to find the number of distinct paths from the top-left to the bottom-right of a matrix, moving only to the right or down at each step. You need to optimize the solution using dynamic programming to handle large matrices efficiently. Problem Statement Implement a function to calculate the number of distinct paths in a matrix from the top-left corner to the bottom-right corner. You should leverage dynamic programming to optimize the solution for larger matrices. 1. **Use dynamic programming to calculate the distinct paths efficiently.** 2. **Your solution should handle matrices up to size 1000 x 1000 within a reasonable time frame.** Function Signature ```python def count_paths(m: int, n: int) -> int: Calculate the number of distinct paths from the top-left to the bottom-right corner of a m x n matrix. Args: m (int): Number of rows. n (int): Number of columns. Returns: int: Number of distinct paths. pass ``` Constraints - (1 leq m, n leq 1000) - You can only move right or down. Example Execution ```python count_paths(3, 3) # Output: 6 count_paths(2, 2) # Output: 2 ``` Explanation For a 3x3 matrix: ``` Paths: 1. Right, Right, Down, Down 2. Right, Down, Right, Down 3. Right, Down, Down, Right 4. Down, Right, Right, Down 5. Down, Right, Down, Right 6. Down, Down, Right, Right ``` For a 2x2 matrix: ``` Paths: 1. Right, Down 2. Down, Right ``` Additional Notes - Optimize your solution to ensure it completes within a reasonable time for the upper limits of the constraints. - Use memoization or tabulation to avoid recalculating intermediate results.","solution":"def count_paths(m: int, n: int) -> int: Calculate the number of distinct paths from the top-left to the bottom-right corner of a m x n matrix. Args: m (int): Number of rows. n (int): Number of columns. Returns: int: Number of distinct paths. if m == 1 or n == 1: return 1 dp = [[0 for _ in range(n)] for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Scenario You are working on a project that involves processing large datasets. One of the tasks requires you to identify duplicate entries in an efficient manner. To achieve this, you need to write a function that can detect and return all duplicate elements in the dataset. # Task Write a function `find_duplicates` that takes a list of elements and returns a list of duplicates found in the original list. Each duplicate should appear only once in the result, regardless of the number of times it is duplicated in the input. # Function Signature ```python from typing import Any, List def find_duplicates(dataset: List[Any]) -> List[Any]: pass ``` # Input - `dataset` (List[Any]): a list of elements of any type. The elements are not guaranteed to be comparable. # Output - Returns a list of elements that are duplicates in the input list, each appearing only once in the output list. # Constraints - The input list may be empty. - The list\'s size does not exceed 10^6 elements. # Performance Requirements - Aim for a time complexity that is efficient for large datasets. # Examples ```python print(find_duplicates([])) # Output: [] print(find_duplicates([1, 2, 3, 4, 5, 5, 6, 7, 1])) # Output: [1, 5] print(find_duplicates([\'a\', \'b\', \'c\', \'a\', \'c\', \'d\'])) # Output: [\'a\', \'c\'] print(find_duplicates([1, 2, 3, 4])) # Output: [] ``` # Hint Consider using a data structure that supports efficient insertion, lookup, and duplication checking to help meet performance requirements.","solution":"from typing import Any, List def find_duplicates(dataset: List[Any]) -> List[Any]: Identifies and returns a list of duplicate elements from the dataset. Each duplicate will appear only once in the result, regardless of the number of times it is duplicated in the input list. :param dataset: List of elements of any type :return: List of duplicate elements, each appearing once seen = set() duplicates = set() for item in dataset: if item in seen: duplicates.add(item) else: seen.add(item) return list(duplicates)"},{"question":"# Scenario You have been exploring ways to interact with data in Python, particularly focusing on sorting and filtering functions. One problem you encounter involves filtering and sorting a list of dictionaries based on multiple criteria. # Problem Statement Write a function `sort_and_filter_students(students: List[Dict[str, Any]], min_score: int) -> List[Dict[str, Any]]` that filters out students who have scored below a certain threshold and then sorts the remaining students first by their score in descending order, and then by their name in ascending order. # Function Signature ```python from typing import List, Dict, Any def sort_and_filter_students(students: List[Dict[str, Any]], min_score: int) -> List[Dict[str, Any]]: ``` # Input * `students` (List[Dict[str, Any]]): A list of dictionaries, where each dictionary contains two keys: * `\\"name\\"` (str): The name of the student. * `\\"score\\"` (int): The score of the student. * `min_score` (int): The minimum score threshold. # Output * A list of dictionaries representing the filtered and sorted students. # Constraints 1. The list of dictionaries `students` can have between 0 and 1000 elements. 2. Each student\'s `name` will be a non-empty string consisting of uppercase and lowercase English letters. 3. Each student\'s `score` will be an integer between 0 and 100. 4. `min_score` will be an integer between 0 and 100. # Examples ```python students = [ {\\"name\\": \\"Alice\\", \\"score\\": 50}, {\\"name\\": \\"Bob\\", \\"score\\": 80}, {\\"name\\": \\"Charlie\\", \\"score\\": 50}, {\\"name\\": \\"David\\", \\"score\\": 90}, {\\"name\\": \\"Eve\\", \\"score\\": 85} ] assert sort_and_filter_students(students, 60) == [ {\\"name\\": \\"David\\", \\"score\\": 90}, {\\"name\\": \\"Eve\\", \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"score\\": 80} ] assert sort_and_filter_students(students, 100) == [] assert sort_and_filter_students([], 50) == [] assert sort_and_filter_students(students, 40) == [ {\\"name\\": \\"David\\", \\"score\\": 90}, {\\"name\\": \\"Eve\\", \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"score\\": 80}, {\\"name\\": \\"Alice\\", \\"score\\": 50}, {\\"name\\": \\"Charlie\\", \\"score\\": 50} ] ``` # Note * The function should be robust enough to handle cases with an empty list of students. * If multiple students have the same score, they should be sorted by their names in ascending order. * Ensure the function adheres to the input constraints and expected output format.","solution":"from typing import List, Dict, Any def sort_and_filter_students(students: List[Dict[str, Any]], min_score: int) -> List[Dict[str, Any]]: # Filter students based on min_score filtered_students = [student for student in students if student[\'score\'] >= min_score] # Sort students by score in descending order, and then by name in ascending order sorted_students = sorted(filtered_students, key=lambda student: (-student[\'score\'], student[\'name\'])) return sorted_students"},{"question":"# Building and Deploying a Simple Graphical User Interface (GUI) **Context**: Your task is to create a simple Graphical User Interface (GUI) using Tkinter, a built-in Python library. The GUI will have several widgets, including labels, entry boxes, buttons, and a text display area. Upon pressing the button, the GUI should take the input from the user, process it in a specified way, and display the result. # Problem Description **Function Signature**: ```python def create_gui(): ``` **Description**: Develop a GUI that allows the user to input a sentence, reverses the words in that sentence, and displays the reversed sentence. Specifically, your GUI should include the following elements: 1. A label that instructs the user to enter a sentence. 2. An entry box for the user to type in a sentence. 3. A button that, when pressed, processes the input sentence. 4. A text area that displays the sentence with the words reversed. # Requirements 1. Create the main window for the application. 2. Add a label that tells the user to enter a sentence. 3. Add an entry widget for the user to input their sentence. 4. Add a button that, when clicked, will read the sentence from the entry widget, reverse the words, and display the reversed sentence in a text area. 5. Add a text area for displaying the reversed sentence. 6. Use appropriate layout managers to arrange your widgets in a neat and understandable manner. # Example ```python if __name__ == \\"__main__\\": create_gui() ``` Expected Behavior: - The main window should display a label \\"Enter a sentence:\\", followed by an entry box where the user can input the sentence. - Below the entry box, there should be a button labeled \\"Reverse Words\\". - Below the button, there should be a text area where the reversed sentence will be displayed after pressing the button. ```python import tkinter as tk def reverse_words(sentence: str) -> str: return \' \'.join(sentence.split()[::-1]) def create_gui(): def on_button_click(): input_text = entry.get() reversed_text = reverse_words(input_text) text_display.delete(1.0, tk.END) text_display.insert(tk.END, reversed_text) window = tk.Tk() window.title(\\"Word Reverser\\") label = tk.Label(window, text=\\"Enter a sentence:\\") label.pack() entry = tk.Entry(window, width=50) entry.pack() button = tk.Button(window, text=\\"Reverse Words\\", command=on_button_click) button.pack() text_display = tk.Text(window, height=10, width=50) text_display.pack() window.mainloop() if __name__ == \\"__main__\\": create_gui() ```","solution":"import tkinter as tk def reverse_words(sentence: str) -> str: return \' \'.join(sentence.split()[::-1]) def create_gui(): def on_button_click(): input_text = entry.get() reversed_text = reverse_words(input_text) text_display.delete(1.0, tk.END) text_display.insert(tk.END, reversed_text) window = tk.Tk() window.title(\\"Word Reverser\\") label = tk.Label(window, text=\\"Enter a sentence:\\") label.pack() entry = tk.Entry(window, width=50) entry.pack() button = tk.Button(window, text=\\"Reverse Words\\", command=on_button_click) button.pack() text_display = tk.Text(window, height=10, width=50) text_display.pack() window.mainloop() if __name__ == \\"__main__\\": create_gui()"},{"question":"# Problem Statement You are given an integer `n` and a 2D list `edges` representing an undirected graph. Each edge in the list `edges` is a pair of vertices that are connected. Write a function `detect_cycle` that determines whether the graph contains a cycle. Return `True` if there is a cycle in the graph, otherwise return `False`. Your solution should make use of depth-first search (DFS) technique to detect cycles in the graph. # Function Signature ```python def detect_cycle(n: int, edges: list[tuple[int, int]]) -> bool: ``` # Input - An integer `n` (0 ≤ n ≤ 1000), representing the number of vertices in the graph. - A list of tuples, `edges`, where each tuple `(u, v)` (0 ≤ u, v < n) represents an edge in the graph. # Output - A boolean value `True` if there is a cycle in the graph; otherwise `False`. # Constraints - The graph may be disconnected. - There are no self-loops or multiple edges between the same pair of vertices. - Each vertex is labeled from `0` to `n-1`. # Example ```python # Example 1 n = 5 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] print(detect_cycle(n, edges)) # Expected output: True # Example 2 n = 4 edges = [(0, 1), (1, 2), (2, 3)] print(detect_cycle(n, edges)) # Expected output: False # Example 3 n = 0 edges = [] print(detect_cycle(n, edges)) # Expected output: False ``` # Additional Notes - You need to account for the case when `n` is 0, which represents an empty graph and should return `False`. - Consider edge cases such as graphs with no edges or multiple disconnected components.","solution":"def detect_cycle(n: int, edges: list[tuple[int, int]]) -> bool: from collections import defaultdict def dfs(vertex, parent): visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if dfs(neighbor, vertex): return True elif parent != neighbor: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * n for v in range(n): if not visited[v]: if dfs(v, -1): return True return False"},{"question":"# String Permutation Checker Write a function that checks whether two given strings are permutations of each other. A permutation of a string is another string that contains the same characters, only the order of characters can be different. Function Signature ```python def are_permutations(str1: str, str2: str) -> bool: Args: - str1 (str): The first string. - str2 (str): The second string. Returns: - bool: True if str1 and str2 are permutations of each other, False otherwise. ``` Input * `str1` : A string containing ASCII characters. * `str2` : A string containing ASCII characters. Output * A boolean value `True` if the strings are permutations of each other, `False` otherwise. Constraints * 0 ≤ len(str1), len(str2) ≤ 10^5 Example ```python >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"triangle\\", \\"integral\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False ``` # Expectations 1. **Correctness**: Your solution should correctly determine if the strings are permutations of each other for various input combinations. 2. **Efficiency**: The solution should efficiently handle the upper limits of the input size without significant performance degradation. 3. **Edge Cases**: Ensure to handle edge cases such as empty strings, strings of different lengths, and strings with repeated characters. Implement your function `are_permutations` based on the above specifications. You can test your solution with the provided examples.","solution":"def are_permutations(str1: str, str2: str) -> bool: Returns True if str1 is a permutation of str2, otherwise False. if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"# Problem Statement: You are given the task of designing an algorithm to determine the shortest path in a simple undirected graph. However, to simulate real-world constraints, you must ensure that the path found does not exceed a given maximum number of steps. # Objective: Write a function `bounded_shortest_path` that accepts the following parameters: 1. **graph**: Dict[int, List[int]] - A dictionary representing an undirected graph where keys are node identifiers and values are lists of adjacent nodes. 2. **start_node**: int - The identifier of the starting node. 3. **end_node**: int - The identifier of the target node. 4. **max_steps**: int - The maximum number of steps allowed for the path. Constraints: 1. The function must handle graphs with at least 2 nodes and up to 1000 nodes. 2. Return the shortest path as a list of node identifiers. If no valid path exists within the step limit, return an empty list. 3. The graph is guaranteed to have non-negative edge weights of 1. # Input/Output: Input: * A graph represented as a dictionary and appropriate parameters as described above. Output: * List[int] - The node identifiers representing the shortest path adhering to the maximum step constraint. # Example: ```python graph = { 0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 3], 3: [1, 2, 4], 4: [3] } result = bounded_shortest_path( graph=graph, start_node=0, end_node=4, max_steps=3 ) print(result) # Expected output: [0, 1, 3, 4] or [0, 2, 3, 4] if feasible within given constraints ``` Your Task: Write the function `bounded_shortest_path` that implements the specification detailed above.","solution":"from collections import deque def bounded_shortest_path(graph, start_node, end_node, max_steps): Finds the shortest path in an undirected graph within a given number of steps. Parameters: graph (Dict[int, List[int]]): The graph represented as an adjacency list. start_node (int): The starting node. end_node (int): The target node. max_steps (int): The maximum number of steps allowed for the path. Returns: List[int]: The node identifiers representing the shortest path. if start_node == end_node: return [start_node] # Queue for BFS: holds tuples of (current_node, path) queue = deque([(start_node, [start_node])]) visited = set([start_node]) while queue: current_node, path = queue.popleft() if len(path) > max_steps + 1: # +1 because path includes the start node itself continue for neighbor in graph[current_node]: if neighbor == end_node: return path + [neighbor] # Found path to end_node if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Unique Words Counter You are given a function that deals with counting unique words in a given text: 1. `count_unique_words(text: str) -> int`: This function takes a string input `text` and returns the number of unique words in it. Words are defined as sequences of characters separated by whitespace and are considered case insensitive. Task Your task is to write a function `unique_words_report(paragraphs: list) -> dict` which processes a list of paragraphs: - The function should count the unique words in each paragraph. - Return a dictionary where each key is the paragraph index (0-based) and the value is the unique words count for that paragraph. Input: - `paragraphs` (list of strings): A list of non-empty strings representing paragraphs. Output: - A dictionary with integer keys and integer values. Each key represents the paragraph\'s index, and the corresponding value is the number of unique words in that paragraph. Constraints: - Each paragraph contains only alphabets and whitespace. - Paragraphs are considered case insensitive. - The list contains at least one paragraph. Examples: 1. **Input**: [\\"This is a test.\\", \\"This test is a Test.\\"] **Output**: {0: 4, 1: 4} 2. **Input**: [\\"Hello world\\", \\"Hello\\"] **Output**: {0: 2, 1: 1} 3. **Input**: [\\"Multiple words here\\", \\"And some more words here\\"] **Output**: {0: 3, 1: 5} Additional Requirements: - Ensure to handle edge cases like paragraphs with repeated words or different capitalizations properly.","solution":"import re from collections import Counter def count_unique_words(text: str) -> int: Returns the number of unique words in the given text. Words are considered case insensitive and any character sequences separated by white space. words = re.findall(r\'bw+b\', text.lower()) return len(set(words)) def unique_words_report(paragraphs: list) -> dict: Processes a list of paragraphs and returns a dictionary where each key is the paragraph index (0-based) and the value is the unique words count for that paragraph. return {i: count_unique_words(paragraph) for i, paragraph in enumerate(paragraphs)}"},{"question":"# Context You are working on a collaborative text editing software. One of the features allows users to interact with a stream of text data and apply a series of commands to undo or redo changes made to the text. Implement this feature to help users revert their actions or redo actions they have undone. # Task Implement a class `TextEditor` that allows for text editing with undo and redo functionality. The class should support the following operations: - `append(self, text: str)`: Appends `text` to the end of the editor content. - `delete(self, count: int)`: Deletes the last `count` characters from the editor content. - `undo(self)`: Undoes the last operation (either append or delete), if possible. - `redo(self)`: Redoes the last undone operation, if possible. - `get_content(self) -> str`: Returns the current content of the editor. # Constraints - All operations will be valid commands according to the specifications. - `count` for `delete` operation will always be less than or equal to the current length of the editor content. - No initial content is present in the editor. - The total number of operations performed will not exceed 10,000. # Example ```python editor = TextEditor() editor.append(\\"hello\\") editor.append(\\" world\\") print(editor.get_content()) # Expected Output: \\"hello world\\" editor.delete(6) print(editor.get_content()) # Expected Output: \\"hello\\" editor.undo() print(editor.get_content()) # Expected Output: \\"hello world\\" editor.undo() print(editor.get_content()) # Expected Output: \\"hello\\" editor.redo() print(editor.get_content()) # Expected Output: \\"hello world\\" ``` # Performance Requirements The implementation should handle a series of up to 10,000 operations efficiently.","solution":"class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] self.redo_stack = [] def append(self, text): self.history.append((\\"append\\", text)) self.content += text self.redo_stack.clear() def delete(self, count): deleted_text = self.content[-count:] self.history.append((\\"delete\\", deleted_text)) self.content = self.content[:-count] self.redo_stack.clear() def undo(self): if self.history: action, text = self.history.pop() if action == \\"append\\": self.content = self.content[:-len(text)] self.redo_stack.append((action, text)) elif action == \\"delete\\": self.content += text self.redo_stack.append((action, text)) def redo(self): if self.redo_stack: action, text = self.redo_stack.pop() if action == \\"append\\": self.content += text self.history.append((action, text)) elif action == \\"delete\\": self.content = self.content[:-len(text)] self.history.append((action, text)) def get_content(self): return self.content"},{"question":"Task Create an additional question for a coding assessment that aligns with the provided sample question ([Question 1]). Objective Analyze the provided sample question and create another question that fits seamlessly in terms of style, complexity, and scope. Guidelines # Question Style - Follow the format and presentation of the given question. - Use consistent tone and language. # Question Length - Match the length of the given question. # Difficulty Level - Ensure the technical challenge is similar. # Topic Alignment - The new question should tackle a related or complementary area within the same general topic. # Question Uniqueness - Avoid repetition; introduce a novel problem. --- New Question # Problem Statement You are given a temperature in Celsius and need to convert this temperature to its equivalent in Fahrenheit. Implement the function `fahrenheit(celsius: float) -> float` that performs this conversion. Input * `celsius` (float): the temperature in Celsius. The value can be any real number, including negative values and non-integer temperatures. Output * The function should return a float representing the temperature in Fahrenheit. Example ```python >>> fahrenheit(0) 32.0 >>> fahrenheit(100) 212.0 >>> fahrenheit(-40) -40.0 >>> fahrenheit(36.6) 97.88 ``` # Constraints * The input `celsius` can range from (-10^3) to (10^3). * The floating-point result should have a precision error not exceeding (10^{-2}). # Requirements * The function should execute in constant time, i.e., O(1). * Minimize the use of multiplication operations in your solution. * Ensure the solution is as accurate as possible, accounting for the limitations of floating-point arithmetic.","solution":"def fahrenheit(celsius: float) -> float: Converts the given temperature in Celsius to Fahrenheit. Formula: (celsius * (9/5)) + 32 :param celsius: Temperature in Celsius :return: Temperature in Fahrenheit return (celsius * 9 / 5) + 32"},{"question":"# Coding Assessment Question K-Nearest Neighbors Model Implementation You need to implement an enhanced K-Nearest Neighbors (KNN) class for regression that includes weighted voting based on the inverse of the distance and a distance metric selection. Task 1. Implement a method `predict_weighted` that predicts the target value for an input point by giving more weight to nearer neighbors. 2. Modify the `fit` function to accept a parameter `metric` which determines the distance calculation method (`\'euclidean\'` or `\'manhattan\'`). Additional Guidelines - Weighted Voting Strategy: - Use the inverse of the distance as weights. Closer neighbors have higher influence on the prediction. Function Signatures and Expected Behavioral Outline ```python class EnhancedKNN: def __init__(self, n_neighbors=5, metric=\'euclidean\'): self.n_neighbors = n_neighbors self.metric = metric self.data = None self.targets = None def fit(self, x, y): # Store the training data and target values self.data = x self.targets = y def predict_weighted(self, x): # Implement weighted KNN prediction for regression pass def _calculate_distance(self, point1, point2): # Private method to calculate distance based on the metric if self.metric == \'euclidean\': return np.sqrt(np.sum((point1 - point2) ** 2)) elif self.metric == \'manhattan\': return np.sum(np.abs(point1 - point2)) else: raise ValueError(\\"Unsupported metric\\") ``` Input Examples and Output Expectations ```python # Sample input datasets x_train = np.array([[10], [20], [30], [40], [50]]) y_train = np.array([5, 10, 15, 20, 25]) x_predict = np.array([15]) # Initialize and train the enhanced KNN model knn = EnhancedKNN(n_neighbors=3, metric=\'euclidean\') knn.fit(x_train, y_train) # Predict using weighted KNN prediction = knn.predict_weighted(x_predict) print(prediction) ``` - **Constraints**: - The n_neighbors value should be <= 10. - Inputs must be 2-dimensional numpy arrays, even if they contain a single feature. - **Performance Requirements**: - Use Mean Squared Error (MSE) to evaluate the quality of the predictions. - Ensure the distance metric choice and weighting are correctly implemented for robust prediction quality. Evaluate the prediction accuracy by comparing the MSE with an unweighted KNN to demonstrate improvement.","solution":"import numpy as np class EnhancedKNN: def __init__(self, n_neighbors=5, metric=\'euclidean\'): self.n_neighbors = n_neighbors self.metric = metric self.data = None self.targets = None def fit(self, x, y): # Store the training data and target values self.data = x self.targets = y def predict_weighted(self, x): predictions = [] for point in x: distances = [self._calculate_distance(point, train_point) for train_point in self.data] neighbors_idx = np.argsort(distances)[:self.n_neighbors] neighbors_distances = np.array(distances)[neighbors_idx] neighbors_targets = self.targets[neighbors_idx] # Avoid division by zero by replacing zero distances with a very small number neighbors_distances[neighbors_distances == 0] = 1e-5 # Using inverse distance as weights weights = 1 / neighbors_distances weighted_sum = np.sum(weights * neighbors_targets) sum_weights = np.sum(weights) weighted_average = weighted_sum / sum_weights predictions.append(weighted_average) return np.array(predictions) def _calculate_distance(self, point1, point2): # Private method to calculate distance based on the metric if self.metric == \'euclidean\': return np.sqrt(np.sum((point1 - point2) ** 2)) elif self.metric == \'manhattan\': return np.sum(np.abs(point1 - point2)) else: raise ValueError(\\"Unsupported metric\\")"},{"question":"# Merge Sort with Inversion Count Objective Design a function that sorts a list using the Merge Sort algorithm and counts the number of inversions in the list. An inversion is defined as a pair of positions (i, j) such that i < j and data[i] > data[j]. Task 1. Implement the merge sort algorithm to sort the input list. 2. Count the number of inversions during the sorting process. 3. Handle edge cases effectively for: - Empty list - All elements being the same - A list that is already sorted - A nearly sorted list Instructions - Implement the function `merge_sort_with_inversions(data: list) -> tuple`. - Your function should return a tuple where the first element is the sorted list in ascending order and the second element is the inversion count. - Optimize your implementation to handle large input sizes efficiently. Example ```python def merge_sort_with_inversions(data: list) -> tuple: # Your implementation here pass # Example Usage print(merge_sort_with_inversions([2, 4, 1, 3, 5])) # Output: ([1, 2, 3, 4, 5], 3) print(merge_sort_with_inversions([])) # Output: ([], 0) print(merge_sort_with_inversions([1, 2, 3, 4, 5])) # Output: ([1, 2, 3, 4, 5], 0) print(merge_sort_with_inversions([5, 4, 3, 2, 1])) # Output: ([1, 2, 3, 4, 5], 10) ``` Constraints - Input list can contain negative and positive integers. - Expect the input list length to be (1 leq n leq 10^5).","solution":"def merge_sort_with_inversions(data): Sorts the list using merge sort and counts inversions. Returns a tuple (sorted_list, inversion_count). def merge_and_count(left, right): result = [] i = j = inversion_count = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) inversion_count += len(left) - i j += 1 result.extend(left[i:]) result.extend(right[j:]) return result, inversion_count def merge_sort_and_count(arr): if len(arr) < 2: return arr, 0 mid = len(arr) // 2 left, left_inversions = merge_sort_and_count(arr[:mid]) right, right_inversions = merge_sort_and_count(arr[mid:]) merged, merge_inversions = merge_and_count(left, right) total_inversions = left_inversions + right_inversions + merge_inversions return merged, total_inversions sorted_list, inversion_count = merge_sort_and_count(data) return sorted_list, inversion_count"},{"question":"# Problem Statement You are tasked with developing a software library management system that models the core operations of managing a collection of books. The system must provide functionalities to add books, remove books, search for a book by its ISBN, and list all available books. **Specifications**: Implement a `Library` class with the following methods: 1. `add_book(isbn: str, title: str, author: str)`: Add a new book to the library. 2. `remove_book(isbn: str)`: Remove a book from the library by its ISBN. 3. `search_book(isbn: str) -> dict`: Search for a book by its ISBN and return its details. 4. `list_books() -> list`: Return a list of all books in the library. **Book Details**: Each book is represented by a dictionary containing the following key-value pairs: - `isbn`: A unique identifier for the book (string). - `title`: The title of the book (string). - `author`: The author of the book (string). **Error Handling**: - *BookNotFoundError*: Raised when attempting to remove or search for a book that does not exist in the library. **Input/Output**: - For `add_book`: None. - For `remove_book`: None. - For `search_book`: A dictionary containing book details. - For `list_books`: A list of dictionaries, each representing a book. # Example: ```python library = Library() library.add_book(\\"978-3-16-148410-0\\", \\"The Catcher in the Rye\\", \\"J.D. Salinger\\") library.add_book(\\"978-1-56619-909-4\\", \\"To Kill a Mockingbird\\", \\"Harper Lee\\") print(library.search_book(\\"978-3-16-148410-0\\")) # Output: {\'isbn\': \'978-3-16-148410-0\', \'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\'} print(library.list_books()) # Output: [{\'isbn\': \'978-3-16-148410-0\', \'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\'}, {\'isbn\': \'978-1-56619-909-4\', \'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\'}] library.remove_book(\\"978-1-56619-909-4\\") print(library.list_books()) # Output: [{\'isbn\': \'978-3-16-148410-0\', \'title\': \'The Catcher in the Rye\', \'author\': \'J.D. Salinger\'}] ``` # Constraints: - ISBN strings are unique and well-formed. - Titles and authors are non-empty strings. - The initial library is empty. # Task: Implement the `Library` class described above, ensuring proper function and error handling compliance.","solution":"class BookNotFoundError(Exception): pass class Library: def __init__(self): self.books = {} def add_book(self, isbn: str, title: str, author: str): self.books[isbn] = { \\"isbn\\": isbn, \\"title\\": title, \\"author\\": author } def remove_book(self, isbn: str): if isbn not in self.books: raise BookNotFoundError(f\\"Book with ISBN {isbn} not found.\\") del self.books[isbn] def search_book(self, isbn: str) -> dict: if isbn not in self.books: raise BookNotFoundError(f\\"Book with ISBN {isbn} not found.\\") return self.books[isbn] def list_books(self) -> list: return list(self.books.values())"},{"question":"# Logistic Regression for Binary Classification You are required to implement a logistic regression model from scratch using batch gradient descent for optimization. Your goal is to: 1. Load and preprocess a given dataset. 2. Implement the logistic regression algorithm using gradient descent to update weights. 3. Evaluate the model using accuracy and precision. Dataset The dataset contains two columns, `Feature` and `Label`, with the first row containing headers. Each row represents a data point with a numeric feature value (`Feature`) and a binary outcome label (`Label`). **Download URL**: ``` https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv ``` Task Requirements 1. **Function to Load Dataset**: - Read and return the dataset as a matrix. - Parse the CSV data from the URL. 2. **Function to Implement Gradient Descent**: - Implement the gradient descent algorithm to minimize the logistic loss. - Update the weight parameters iteratively. 3. **Function to Compute Sigmoid**: - Calculate the sigmoid activation function. 4. **Function to Predict Labels**: - Predict binary class labels based on feature data and weight parameters. 5. **Function to Evaluate Model**: - Compute accuracy and precision comparing the predicted and actual labels. 6. **Main Execution**: - Load the data, process it, and run logistic regression. - Print the final weight vector. - Print the accuracy and precision of the model. Function Signatures You should implement the following functions: 1. `load_dataset() -> np.matrix` 2. `logistic_gradient_descent(data_x: np.matrix, data_y: np.matrix, len_data: int, alpha: float, theta: np.matrix, num_iterations: int) -> np.matrix` 3. `sigmoid(z: np.matrix) -> np.matrix` 4. `predict(data_x: np.matrix, theta: np.matrix) -> np.matrix` 5. `evaluate_model(predicted_y: np.matrix, actual_y: np.matrix) -> tuple` Input & Output Format - Input: **None**. The function should fetch the dataset and perform computations internally. - Output: **Weight vector from the regression model**, printed in the console. **Accuracy and precision metrics**, printed in the console. Example ```python def main(): # Load and process the dataset data = load_dataset() len_data = data.shape[0] data_x = np.c_[np.ones(len_data), data[:, :-1]].astype(float) data_y = data[:, -1].astype(float) # Initial weight vector theta = np.zeros((1, data_x.shape[1])) # Run logistic regression theta = logistic_gradient_descent(data_x, data_y, len_data, alpha=0.001, theta=theta, num_iterations=10000) # Predict and evaluate the model predictions = predict(data_x, theta) accuracy, precision = evaluate_model(predictions, data_y) len_result = theta.shape[1] print(\\"Resultant Feature vector : \\") for i in range(len_result): print(f\\"{theta[0, i]:.5f}\\") print(f\\"Accuracy: {accuracy:.2f}\\") print(f\\"Precision: {precision:.2f}\\") if __name__ == \\"__main__\\": main() ``` Constraints - Handle potential data inconsistencies and missing values in the dataset. - Ensure numerical stability in gradient descent. - Limit the number of iterations to a practical level (e.g., `iterations` <= 100000) and set an appropriate learning rate ( alpha ).","solution":"import numpy as np import pandas as pd from urllib.request import urlopen def load_dataset(): Reads and processes the dataset from the URL. Returns a numpy matrix of the dataset. url = \\"https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv\\" df = pd.read_csv(url) # Example: feature extraction and preprocessing (following example features \'Pclass\' and \'Survived\') # Only taking `Pclass` as an example feature and `Survived` as the label data = df[[\'Pclass\', \'Survived\']].dropna() data_matrix = data.values return data_matrix def sigmoid(z): Computes sigmoid function. return 1 / (1 + np.exp(-z)) def logistic_gradient_descent(data_x, data_y, len_data, alpha, theta, num_iterations): Performs batch gradient descent for logistic regression. for i in range(num_iterations): z = np.dot(data_x, theta.T) h = sigmoid(z) gradient = np.dot(data_x.T, (h - data_y)) / len_data theta -= alpha * gradient.T return theta def predict(data_x, theta): Predicts binary labels using logistic regression model. probabilities = sigmoid(np.dot(data_x, theta.T)) return [1 if prob >= 0.5 else 0 for prob in probabilities] def evaluate_model(predicted_y, actual_y): Evaluates model performance using accuracy and precision metrics. predicted_y = np.array(predicted_y) actual_y = np.array(actual_y) accuracy = np.mean(predicted_y == actual_y) true_positive = np.sum((predicted_y == 1) & (actual_y == 1)) false_positive = np.sum((predicted_y == 1) & (actual_y == 0)) precision = true_positive / (true_positive + false_positive) if (true_positive + false_positive) > 0 else 0 return accuracy, precision def main(): # Load and process the dataset data = load_dataset() len_data = data.shape[0] data_x = np.c_[np.ones(len_data), data[:, :-1]].astype(float) data_y = data[:, -1].astype(float).reshape(-1, 1) # Initial weight vector theta = np.zeros((1, data_x.shape[1])) # Hyperparameters alpha = 0.01 num_iterations = 10000 # Run logistic regression theta = logistic_gradient_descent(data_x, data_y, len_data, alpha, theta, num_iterations) # Predict and evaluate the model predictions = predict(data_x, theta) accuracy, precision = evaluate_model(predictions, data_y) len_result = theta.shape[1] print(\\"Resultant Feature vector:\\") for i in range(len_result): print(f\\"{theta[0, i]:.5f}\\") print(f\\"Accuracy: {accuracy:.2f}\\") print(f\\"Precision: {precision:.2f}\\") if __name__ == \\"__main__\\": main()"},{"question":"# Data Compression Using Huffman Encoding Problem Description: You need to implement a Huffman encoding algorithm for compressing and decompressing text data. The Huffman encoding process involves creating a binary tree where the most frequent characters have the shortest binary codes, and the least frequent characters have longer binary codes. You will encode a given input text, write the encoded data along with the Huffman tree to a file, and then decode the data back to its original form using the stored Huffman tree. Function Signatures: ```python def huffman_encode_and_write(text_filename: str, output_filename: str) -> str: Encodes the text using Huffman encoding and writes it to a file along with the Huffman tree. Args: - text_filename (str): The name of the file containing the text to be encoded. - output_filename (str): The name of the file to save the encoded data and Huffman tree. Returns: - str: The encoded content as a single string. pass def huffman_read_and_decode(encoded_filename: str) -> str: Reads the encoded data and Huffman tree from a file and decodes it back to the original text. Args: - encoded_filename (str): The name of the file containing the encoded data and Huffman tree. Returns: - str: The decoded plaintext message. pass ``` Input: - For `huffman_encode_and_write`: - `text_filename`: A string representing the name of the file containing the plaintext to be encoded. - `output_filename`: A string representing the name of the file to save the encoded data and Huffman tree. - For `huffman_read_and_decode`: - `encoded_filename`: A string representing the name of the file containing the encoded data and Huffman tree. Output: - For `huffman_encode_and_write`: A string representing the encoded content as a single string. - For `huffman_read_and_decode`: A string representing the decoded plaintext message. Constraints: - The text file should be formatted correctly. - Ensure the encoded data and Huffman tree are stored and retrieved correctly for accurate decoding. - Handle characters beyond the basic ASCII set (e.g., Unicode). Performance Requirements: - The functions should work efficiently even for large text files. - Minimize memory usage to avoid potential overflows. - Ensure the compression and decompression processes are optimized. Example: ```python # Example usage of the functions. input_text_filename = \\"input_text.txt\\" encoded_output_file = \\"encoded_data.txt\\" # Encode and write to file encoded_content = huffman_encode_and_write(input_text_filename, encoded_output_file) print(\\"Encoded Content:\\", encoded_content) # Read from file and decode decoded_message = huffman_read_and_decode(encoded_output_file) print(\\"Decoded Message:\\", decoded_message) ``` Note: Assume that the input text files exist and contain valid text data for encoding and decoding.","solution":"import heapq import os from collections import defaultdict, Counter class TreeNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def build_huffman_tree(frequencies): heap = [TreeNode(char, freq) for char, freq in frequencies.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = TreeNode(None, left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(heap, merged) return heap[0] def build_codes(root): def _build_codes_helper(node, current_code): if node is None: return if node.char is not None: huffman_codes[node.char] = current_code _build_codes_helper(node.left, current_code + \'0\') _build_codes_helper(node.right, current_code + \'1\') huffman_codes = {} _build_codes_helper(root, \'\') return huffman_codes def huffman_encode_and_write(text_filename, output_filename): with open(text_filename, \'r\', encoding=\'utf-8\') as file: text = file.read() frequencies = Counter(text) root = build_huffman_tree(frequencies) huffman_codes = build_codes(root) encoded_text = \'\'.join(huffman_codes[char] for char in text) with open(output_filename, \'wb\') as file: file.write(encoded_text.encode(\'utf-8\')) return encoded_text def huffman_read_and_decode(encoded_filename): with open(encoded_filename, \'rb\') as file: encoded_text = file.read().decode(\'utf-8\') return encoded_text"},{"question":"# Sum of Digits in an Integer Context In certain applications, it may be necessary to calculate the sum of the digits of an integer for validation or analysis purposes. Your task is to write functions that: 1. Calculate the sum of the digits of a given integer. 2. Check if the calculated sum of the digits equals a specified value. 3. Convert an input string into an integer safely while ensuring it consists of numeric characters only. Tasks 1. **Implement the `sum_of_digits` function**: - **Input**: A non-negative integer. - **Output**: An integer representing the sum of the digits of the input number. 2. **Implement the `is_valid_sum` function**: - **Input**: Two integers: the original number and the target sum. - **Output**: A boolean indicating if the sum of the digits of the original number equals the target sum. 3. **Implement the `convert_to_integer` function**: - **Input**: A string representing the number. - **Output**: An integer representation of the number if the input is valid. Raise a ValueError if the input contains non-numeric characters or is an empty string. Example ```python # sum_of_digits examples print(sum_of_digits(1234)) # should return 10 print(sum_of_digits(9876)) # should return 30 # is_valid_sum examples print(is_valid_sum(1234, 10)) # should return True print(is_valid_sum(9876, 25)) # should return False # convert_to_integer examples print(convert_to_integer(\\"1234\\")) # should return 1234 print(convert_to_integer(\\"00567\\")) # should return 567 print(convert_to_integer(\\"12a34\\")) # should raise ValueError print(convert_to_integer(\\"\\")) # should raise ValueError ``` **Constraints**: 1. Assume input numbers are typically non-negative. 2. Handle non-numeric input and empty string input appropriately by raising appropriate exceptions. **Performance Requirement**: Your solution should perform efficiently for typical input sizes encountered in real-world scenarios. **Attachment**: Please ensure you include appropriate error handling for invalid input cases, maintaining code readability and efficiency.","solution":"def sum_of_digits(n): Returns the sum of the digits of a non-negative integer n. return sum(int(digit) for digit in str(n)) def is_valid_sum(number, target_sum): Checks if the sum of the digits of the given number equals the target sum. return sum_of_digits(number) == target_sum def convert_to_integer(s): Converts a string s to an integer if it consists of numeric characters only. Raises ValueError if the string is empty or contains non-numeric characters. if not s.isdigit(): raise ValueError(\\"Input string must contain only numeric characters and cannot be empty.\\") return int(s)"},{"question":"# Find the Most Frequent Word Scenario: You are to write a Python function that finds and returns the most frequently occurring word in a given text. This function will be useful for various text analysis tasks, such as identifying common themes or keywords in documents. Task: Write a function `find_most_frequent_word(text: str) -> str` that: 1. Takes a string of text as input. 2. Splits the text into words. 3. Identifies the word that occurs most frequently. 4. Returns the most frequent word. If there are multiple words with the same highest frequency, return any one of them. Requirements: * Treat words in a case-insensitive manner (e.g., \\"The\\" and \\"the\\" should be considered the same word). * Ignore punctuation marks and special characters. * Use Python\'s `collections.Counter` for counting word frequencies. * Handle the input gracefully, ensuring that special characters and varying cases do not affect the word count. Input: * `text` (str): A string of text which can be of any length. Output: * Returns a string which is the most frequently occurring word in the text. Constraints: * Assume the input text is always non-empty. * The text can include punctuation and special characters which should be ignored. Example: ```python find_most_frequent_word(\\"This is a test. This test is a trial.\\") ``` This should return `this` or `is` as they are the most frequent words in the example text. Example of Implementation: ```python import re from collections import Counter def find_most_frequent_word(text: str) -> str: # Remove punctuation and make all words lower case words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word counted_words = Counter(words) # Get the most common word most_common_word, _ = counted_words.most_common(1)[0] return most_common_word ``` This function will analyze the input text, count the occurrences of each word, and return the most frequent one.","solution":"import re from collections import Counter def find_most_frequent_word(text: str) -> str: Finds and returns the most frequently occurring word in a given text. Words are treated in a case-insensitive manner and punctuation is ignored. # Remove punctuation and make all words lower case words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word word_counts = Counter(words) # Get the most common word most_common_word, _ = word_counts.most_common(1)[0] return most_common_word"},{"question":"# Scenario In a game, you are given a 2D grid where each cell contains a certain number of gold coins. Your goal is to collect the maximum number of gold coins starting from the top-left corner and reaching the bottom-right corner of the grid with the following move restrictions: 1. You can only move to the right, down, or diagonally down-right. 2. You must start at the top-left corner and end at the bottom-right corner. # Task Write a function `max_gold_path(grid: List[List[int]]) -> int` that takes a 2D list (grid) where each element represents the number of gold coins in that cell and returns the maximum gold path sum from the top-left corner to the bottom-right corner. Function Signature ```python def max_gold_path(grid: List[List[int]]) -> int: ``` # Input - `grid`: A non-empty list of lists containing integers representing the number of gold coins in each cell. The grid is guaranteed to be non-empty and all rows have the same length. # Output - An integer representing the maximum gold path sum from the top-left to the bottom-right corner. # Constraints - The input grid has at least 1 and at most 100 rows and columns. - Each element in the grid is an integer between 0 and 1000. # Example ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_gold_path(grid) == 12 ``` The path with the maximum gold sum in this example is highlighted: ``` [1] → 3 [1] ↓ ↓ ↓ [1] 5 [1] ↘ ↘ 4 [2] [1] ``` # Implementation Details - Implement the function using dynamic programming to ensure an efficient solution. - Handle any typical edge cases (e.g., smallest grid size, varying gold values). - Assume valid input within the provided constraints.","solution":"from typing import List def max_gold_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # DP table to store maximum gold from start to each cell dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the dp table for i in range(rows): for j in range(cols): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) if i > 0 and j > 0: dp[i][j] = max(dp[i][j], dp[i-1][j-1] + grid[i][j]) return dp[rows-1][cols-1]"},{"question":"**Stock Price Fluctuation Analysis** **Objective**: Design a data structure that efficiently performs the following operations on stock prices: record a new price, retrieve the maximum recorded price, retrieve the minimum recorded price, and calculate the latest recorded price. **Problem Statement**: Write a class `StockPriceTracker` that supports the following operations: 1. `update(timestamp: int, price: int) -> None`: Updates the price of the stock at the given timestamp. 2. `current() -> int`: Returns the current (latest) price of the stock. 3. `maximum() -> int`: Returns the maximum recorded price of the stock. 4. `minimum() -> int`: Returns the minimum recorded price of the stock. **Class Definition**: ```python class StockPriceTracker: def __init__(self): pass def update(self, timestamp: int, price: int) -> None: pass def current(self) -> int: pass def maximum(self) -> int: pass def minimum(self) -> int: pass ``` **Input**: * `timestamp` (integer, 1 ≤ timestamp ≤ 10^5): Represents the time at which the stock price is recorded. Each `timestamp` is unique. * `price` (integer, 1 ≤ price ≤ 10^6): Represents the price of the stock at the given timestamp. **Output**: * The `update` method does not return any value. * The `current` method returns one integer (the latest price). * The `maximum` method returns one integer (the maximum recorded price). * The `minimum` method returns one integer (the minimum recorded price). **Constraints**: * The operations should be optimized for efficient execution. * Each operation method should run in constant or logarithmic time. **Example**: ```python tracker = StockPriceTracker() tracker.update(1, 100) tracker.update(2, 200) tracker.update(3, 150) print(tracker.current()) # Result should be 150 print(tracker.maximum()) # Result should be 200 print(tracker.minimum()) # Result should be 100 ``` **Explanation**: 1. The stock prices are updated at different timestamps. 2. `current` returns the latest updated price, which is 150. 3. `maximum` returns the highest recorded price, which is 200. 4. `minimum` returns the lowest recorded price, which is 100.","solution":"class StockPriceTracker: def __init__(self): self.prices = {} self.current_time = -1 self.current_price = -1 self.sorted_prices = [] def update(self, timestamp: int, price: int) -> None: if timestamp in self.prices: self.sorted_prices.remove(self.prices[timestamp]) self.prices[timestamp] = price self.sorted_prices.append(price) self.sorted_prices.sort() if timestamp >= self.current_time: self.current_time = timestamp self.current_price = price def current(self) -> int: return self.current_price def maximum(self) -> int: return self.sorted_prices[-1] def minimum(self) -> int: return self.sorted_prices[0]"},{"question":"You are tasked with designing a function that generates all possible sequences of length `n` using characters from a given set, with the constraint that no two consecutive characters in any sequence should be the same. **Write a function `generate_sequences(char_set: List[str], n: int) -> List[str]` that returns a list of all possible sequences meeting the criteria.** **Input**: - A list of characters `char_set` (1 <= len(char_set) <= 10), representing the set of characters you can use. - An integer `n` (1 <= n <= 10), representing the length of each sequence. **Output**: - A list of strings, where each string is a sequence of length `n` such that no two consecutive characters are the same. **Examples**: ```python >>> generate_sequences([\'a\', \'b\'], 2) [\'ab\', \'ba\'] >>> generate_sequences([\'a\', \'b\', \'c\'], 3) [\'aba\', \'abc\', \'aca\', \'acb\', \'bab\', \'bac\', \'bca\', \'bcb\', \'cac\', \'cab\', \'cba\', \'cbc\'] ``` **Additional Notes**: - Each character in the sequence must be selected from `char_set`. - Characters can repeat in the sequence as long as they are not consecutive. The implementation should generate all valid sequences efficiently while adhering to the constraints. Consider edge cases, such as when `char_set` has only one character or when `n` is 1, where the constraint of no consecutive characters doesn\'t apply.","solution":"from typing import List def generate_sequences(char_set: List[str], n: int) -> List[str]: def backtrack(seq): if len(seq) == n: result.append(\\"\\".join(seq)) return for char in char_set: if not seq or seq[-1] != char: seq.append(char) backtrack(seq) seq.pop() result = [] backtrack([]) return result"},{"question":"# Connected Components in an Undirected Graph Objective Write a function to determine the number of connected components in an undirected graph using Depth-First Search (DFS). Function Signature ```python def count_connected_components(graph: Dict[int, List[int]]) -> int: pass ``` Input - `graph`: A dictionary representing the adjacency list of an undirected graph, where keys are vertex indices and values are lists of vertices that are directly connected to the key vertex. Output - An integer representing the number of connected components in the graph. Constraints - The graph can have disconnected components. - The number of vertices (`V`) is (1 leq V leq 10^4). - The number of edges (`E`) is (0 leq E leq 10^5). Example ```python # Given the adjacency list representation of the graph: graph = { 0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3] } # The expected output is 2, as there are two connected components: {0, 1, 2} and {3, 4} print(count_connected_components(graph)) # Output: 2 ``` Notes - Use an efficient approach for traversing the graph, such as a recursive DFS function or an iterative approach with a stack. - Ensure to account for vertices with no edges, which should each be considered their own connected component.","solution":"def count_connected_components(graph): Returns the number of connected components in an undirected graph. Parameters: graph (dict): A dictionary where keys are vertex indices and values are lists of directly connected vertices. Returns: int: The number of connected components. def dfs(node, visited): stack = [node] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) stack.extend(set(graph[vertex]) - visited) visited = set() components = 0 for node in graph: if node not in visited: dfs(node, visited) components += 1 return components"},{"question":"# Problem Statement You are asked to implement a function to parse a given log file and generate a summary report based on the IP addresses and the number of times they accessed the server. The log file entries are in chronological order and each line contains an IP address followed by a timestamp of the format `yyyy-mm-dd HH:MM:SS`. # Specifications * **Function**: `generate_ip_report(log: str) -> dict` * **Input**: A string `log` where each line represents an access entry with the format `\\"{IP_ADDRESS} {TIMESTAMP}n\\"`. * **Output**: A dictionary where keys are IP addresses, and values are the counts of their occurrences in the log. # Constraints * The length of the log string will not exceed `10^6` characters. * The number of unique IP addresses will not exceed `10^4`. * Each line within the log will follow the specified format strictly. # Example ```python # Given the following log log = \\"192.168.1.1 2023-03-15 10:15:32n192.168.1.2 2023-03-15 10:17:42n192.168.1.1 2023-03-15 10:18:22n\\" # After running generate_ip_report on the log report = generate_ip_report(log) # report should be {\'192.168.1.1\': 2, \'192.168.1.2\': 1} ``` # Solution ```python def generate_ip_report(log: str) -> dict: ip_count = {} lines = log.splitlines() for line in lines: ip, _ = line.split()[0], line.split()[1:] if ip in ip_count: ip_count[ip] += 1 else: ip_count[ip] = 1 return ip_count ```","solution":"def generate_ip_report(log: str) -> dict: ip_count = {} lines = log.splitlines() for line in lines: ip, _ = line.split(maxsplit=1) if ip in ip_count: ip_count[ip] += 1 else: ip_count[ip] = 1 return ip_count"},{"question":"# Question: Implement Custom Queue with Unique Elements Context In some scenarios, you need a data structure that behaves like a queue but also ensures that all elements within it are unique. You are required to implement such a queue which enforces the uniqueness constraint by not allowing duplicate elements to be inserted. Objective Write a Python class `UniqueQueue` that supports the typical queue operations (`enqueue`, `dequeue`, `peek`, `size`) while maintaining the uniqueness of elements. # Requirements 1. **Class Definition**: Define a `UniqueQueue` class to represent the unique-element queue. 2. **Method Definitions**: - `enqueue(element: int) -> bool`: Adds an element to the queue if it is not already present. Returns `True` if the element was successfully added, otherwise returns `False`. - `dequeue() -> int`: Removes and returns the element at the front of the queue. If the queue is empty, raise a `ValueError` with the message \\"Queue is empty\\". - `peek() -> int`: Returns (without removing) the element at the front of the queue. If the queue is empty, raise a `ValueError` with the message \\"Queue is empty\\". - `size() -> int`: Returns the number of elements currently in the queue. Input Format - `element`: An integer to be added to the queue. Output Format - For `enqueue`, returns `True` or `False`. - For `dequeue`, returns an integer or raises an exception. - For `peek`, returns an integer or raises an exception. - For `size`, returns an integer. Example Usage ```python class UniqueQueue: def __init__(self): self.queue = [] self.elements = set() def enqueue(self, element: int) -> bool: if element not in self.elements: self.queue.append(element) self.elements.add(element) return True return False def dequeue(self) -> int: if not self.queue: raise ValueError(\\"Queue is empty\\") element = self.queue.pop(0) self.elements.remove(element) return element def peek(self) -> int: if not self.queue: raise ValueError(\\"Queue is empty\\") return self.queue[0] def size(self) -> int: return len(self.queue) # Example Operations uq = UniqueQueue() print(uq.enqueue(5)) # True, as 5 is added print(uq.enqueue(5)) # False, as 5 is already in the queue print(uq.size()) # 1, as the queue has one element print(uq.peek()) # 5, as 5 is at the front print(uq.dequeue()) # 5, removes and returns 5 print(uq.size()) # 0, the queue is now empty ``` # Guidelines: - Ensure that the queue maintains the FIFO (First In, First Out) order. - Consider time complexity for each method and optimize as necessary. - Validate and document the solution adequately.","solution":"class UniqueQueue: def __init__(self): self.queue = [] self.elements = set() def enqueue(self, element: int) -> bool: if element not in self.elements: self.queue.append(element) self.elements.add(element) return True return False def dequeue(self) -> int: if not self.queue: raise ValueError(\\"Queue is empty\\") element = self.queue.pop(0) self.elements.remove(element) return element def peek(self) -> int: if not self.queue: raise ValueError(\\"Queue is empty\\") return self.queue[0] def size(self) -> int: return len(self.queue)"},{"question":"# Problem Statement Given an integer array `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Your task is to implement the function `two_sum(nums: list[int], target: int) -> list[int]:` that finds two numbers in the array such that their sum equals the given target. # Input Format - A list of integers `nums` of length n (2 ≤ n ≤ 10^5). - An integer `target` representing the sum of two elements in the list. # Output Format - Return a list containing exactly two integers representing the indices of the elements in `nums` that add up to `target`. # Constraints - Each input is guaranteed to have exactly one solution. - Elements in the list `nums` can be positive, negative, or zero. - You may not use the same element twice. # Example Input ```python nums = [2, 7, 11, 15] target = 9 ``` Output ```python [0, 1] ``` Detailed Explanation - For the element at index `0` (value `2`), the element at index `1` (value `7`) forms a sum of `9`, which matches the target. # Function Signature ```python from typing import List def two_sum(nums: List[int], target: int) -> List[int]: pass ``` # Requirements 1. You must implement the function `two_sum` using an efficient approach with a time complexity of O(n). 2. Use a hash map (or dictionary) to store the visited elements and their indices to achieve the desired efficiency. Good luck!","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in nums that add up to the target. num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i"},{"question":"# Coding Assessment Question Scenario You are tasked with improving the performance of a recommendation system in a social media application. One of the key features of the system is to suggest mutual friends between two users. A mutual friend is a common friend that both users have in their friend lists. Task Implement the following function: ```python def find_mutual_friends(user1_friends: list[int], user2_friends: list[int]) -> list[int]: Finds mutual friends between two users. Parameters: - user1_friends: A list of integers representing the friend IDs of the first user. - user2_friends: A list of integers representing the friend IDs of the second user. Returns: - A sorted list of integers representing the mutual friend IDs. ``` Requirements 1. **`find_mutual_friends` Implementation**: Use efficient data structures to determine mutual friends between two users. 2. **Input Constraints**: Lists are not necessarily sorted. 3. **Output**: A sorted list of mutual friend IDs. Example ```python assert find_mutual_friends([1, 2, 3, 5], [3, 4, 5, 6]) == [3, 5] assert find_mutual_friends([7, 8, 9], [10, 11, 12]) == [] assert find_mutual_friends([], [1, 2, 3]) == [] ``` Additional Notes - Consider the typical use cases of social media where friend lists can be large. - Optimize for performance, possibly using set operations to efficiently find mutual friends. - Handle edge cases such as when one or both users have empty friend lists appropriately.","solution":"def find_mutual_friends(user1_friends, user2_friends): Finds mutual friends between two users. Parameters: - user1_friends: A list of integers representing the friend IDs of the first user. - user2_friends: A list of integers representing the friend IDs of the second user. Returns: - A sorted list of integers representing the mutual friend IDs. # Convert both friend lists to sets to utilize set intersection for finding mutual friends user1_set = set(user1_friends) user2_set = set(user2_friends) # Find the intersection of both sets mutual_friends = user1_set & user2_set # Convert the resulting set to a sorted list return sorted(list(mutual_friends))"},{"question":"# Question: Graph Isomorphism Detection Problem Description: You are given two undirected graphs represented as adjacency lists. Your task is to write a Python function `are_isomorphic(graph1, graph2)` that determines whether the two graphs are isomorphic. Two graphs are isomorphic if one can be transformed into the other by renaming vertices. Input: * `graph1`: A dictionary where the keys are vertices and the values are lists of adjacent vertices representing the first graph. Example: ```python { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'C\'], \'C\': [\'A\', \'B\'] } ``` * `graph2`: A dictionary in the same format representing the second graph. Example: ```python { 1: [2, 3], 2: [1, 3], 3: [1, 2] } ``` Output: * A boolean value `True` if the two graphs are isomorphic, `False` otherwise. Constraints: * There can be up to 10^5 vertices and 10^5 edges in each graph. * The graphs are undirected and may be disconnected. Function Signature: ```python def are_isomorphic(graph1: dict, graph2: dict) -> bool: ``` Examples: 1. **Input**: ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'C\'], \'C\': [\'A\', \'B\'] } graph2 = { 1: [2, 3], 2: [1, 3], 3: [1, 2] } ``` **Output**: ```python True ``` 2. **Input**: ```python graph1 = { \'A\': [\'B\'], \'B\': [\'A\', \'C\'], \'C\': [\'B\', \'D\'], \'D\': [\'C\'] } graph2 = { 1: [2], 2: [1, 3], 3: [2], 4: [3] } ``` **Output**: ```python False ``` 3. **Input**: ```python graph1 = { \'X\': [\'Y\'], \'Y\': [\'X\'], \'Z\': [] } graph2 = { 5: [6], 6: [5], 7: [] } ``` **Output**: ```python True ``` You are required to implement the function `are_isomorphic(graph1, graph2)` that accurately determines whether the two given graphs are isomorphic, considering all constraints and edge cases described.","solution":"from collections import defaultdict def build_degree_sequence(graph): Builds the degree sequence count from an adjacency list representation of a graph. :param graph: A dictionary representing the graph :return: A sorted list of degree counts degree_sequence = defaultdict(int) for node in graph: degree = len(graph[node]) degree_sequence[degree] += 1 return sorted(degree_sequence.items()) def are_isomorphic(graph1, graph2): Determines if two graphs are isomorphic. :param graph1: The first graph as an adjacency list :param graph2: The second graph as an adjacency list :return: True if the graphs are isomorphic, False otherwise if len(graph1) != len(graph2): return False degree_sequence1 = build_degree_sequence(graph1) degree_sequence2 = build_degree_sequence(graph2) return degree_sequence1 == degree_sequence2"},{"question":"# Coding Challenge Problem Statement Given a list of integers, your task is to write a function `find_largest_product` that identifies the largest product that can be obtained from any three integers present in the list. The function should accept a single parameter: - `nums`: A list of integers. Function Signature ```python def find_largest_product(nums: List[int]) -> int: pass ``` Input - `nums` (List[int]): A list of integers (3 <= len(nums) <= 1000, -1000 <= nums[i] <= 1000). Output - Returns an integer representing the largest product obtainable from any three integers in the list. Example ```python print(find_largest_product([1, 2, 3])) # Output: 6 print(find_largest_product([-10, -10, 1, 3, 2])) # Output: 300 print(find_largest_product([5, 1, 5, -5])) # Output: 25 ``` Constraints - The list will contain at least three integers. - The integers in the list can be positive, negative, or zero. - You may assume all input is valid and conforms to the problem constraints. Notes - Consider different possible combinations, including cases with negative numbers. - Optimize your solution to handle larger lists efficiently. - Think about the impact of positive and negative numbers on the product.","solution":"from typing import List def find_largest_product(nums: List[int]) -> int: nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"# Problem Statement Develop a program to handle and manipulate sets of integers, focusing on operations frequently utilized in computational mathematics and data processing such as set union, intersection, and symmetric difference. # Your Task 1. **Set Union**: Implement a function that computes the union of two sets. The union of two sets A and B is a set containing all elements of A or B (or both). 2. **Set Intersection**: Implement a function that computes the intersection of two sets. The intersection of two sets A and B is a set containing all elements that are both in A and B. 3. **Set Symmetric Difference**: Implement a function that computes the symmetric difference of two sets. The symmetric difference of two sets A and B is a set containing elements which are in either of the sets A and B but not in their intersection. # Instructions 1. **set_union**: * **Input**: `set1` (list of ints), and `set2` (list of ints) - the two sets of integers. * **Output**: `set` - a set containing the union of the two sets. * **Constraints**: Both input lists can be empty and may contain duplicate elements. 2. **set_intersection**: * **Input**: `set1` (list of ints), and `set2` (list of ints) - the two sets of integers. * **Output**: `set` - a set containing the intersection of the two sets. * **Constraints**: Both input lists can be empty and may contain duplicate elements. 3. **set_symmetric_difference**: * **Input**: `set1` (list of ints), and `set2` (list of ints) - the two sets of integers. * **Output**: `set` - a set containing the symmetric difference of the two sets. * **Constraints**: Both input lists can be empty and may contain duplicate elements. # Example ```python >>> set_union([1, 2, 3], [3, 4, 5]) {1, 2, 3, 4, 5} >>> set_intersection([1, 2, 3], [3, 4, 5]) {3} >>> set_symmetric_difference([1, 2, 3], [3, 4, 5]) {1, 2, 4, 5} ``` # Requirements - The solutions should handle cases where input lists are empty. - Performance should be optimized for handling large sets. - Use appropriate data structures to ensure operations are efficient. - The resulting sets should not contain duplicate elements.","solution":"def set_union(set1, set2): Returns the union of two sets, set1 and set2. return set(set1).union(set2) def set_intersection(set1, set2): Returns the intersection of two sets, set1 and set2. return set(set1).intersection(set2) def set_symmetric_difference(set1, set2): Returns the symmetric difference of two sets, set1 and set2. return set(set1).symmetric_difference(set2)"},{"question":"# CSV Data Processing and Report Generation You are tasked with designing a utility that processes a CSV file containing sales data and generates a report summarizing the sales performance. The CSV file will have the following columns: \\"Date\\", \\"Salesperson\\", \\"Product\\", \\"Revenue\\". Implement the following two functions: 1. **read_sales_data**: This function should read the CSV file and return the sales data as a list of dictionaries, where each dictionary represents a row in the CSV. * **Input**: A string representing the file path to the CSV file. * **Output**: A list of dictionaries, where each dictionary contains keys \\"Date\\" (str), \\"Salesperson\\" (str), \\"Product\\" (str), and \\"Revenue\\" (float). * **Constraints**: - The function should handle any errors related to file reading or parsing (e.g., file not found, incorrect format). - Ensure that the \\"Revenue\\" value is correctly parsed as a float. 2. **generate_sales_report**: This function should take the sales data and generate a report summarizing the total revenue, the best-performing salesperson, and the best-selling product. * **Input**: A list of dictionaries, where each dictionary contains keys \\"Date\\" (str), \\"Salesperson\\" (str), \\"Product\\" (str), and \\"Revenue\\" (float). * **Output**: A dictionary containing summary statistics: - \\"total_revenue\\" (float): The sum of all revenue. - \\"best_salesperson\\" (str): The salesperson with the highest total revenue. - \\"best_selling_product\\" (str): The product with the highest total revenue. * **Constraints**: - The function should correctly handle cases where the input list is empty or contains incomplete data. - Ensure accurate aggregation of revenue by salesperson and product. # Example ```python # Example usage if __name__ == \\"__main__\\": sales_data = read_sales_data(\\"sales_data.csv\\") report = generate_sales_report(sales_data) print(f\\"Total Revenue: {report[\'total_revenue\']:.2f}\\") print(f\\"Best Salesperson: {report[\'best_salesperson\']}\\") print(f\\"Best Selling Product: {report[\'best_selling_product\']}\\") ``` # Notes - Ensure robust error handling and consider edge cases such as missing or malformed data. - For testing purposes, you can create a mock CSV file or use predefined data to simulate different scenarios. - Performance considerations: optimize reading and processing large CSV files.","solution":"import csv def read_sales_data(file_path): Read the CSV file and return the sales data as a list of dictionaries. Args: file_path (str): Path to the CSV file. Returns: list: List of dictionaries with keys \\"Date\\", \\"Salesperson\\", \\"Product\\", and \\"Revenue\\". sales_data = [] try: with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: sales_data.append({ \\"Date\\": row[\\"Date\\"], \\"Salesperson\\": row[\\"Salesperson\\"], \\"Product\\": row[\\"Product\\"], \\"Revenue\\": float(row[\\"Revenue\\"]) if row[\\"Revenue\\"] else 0.0 }) except (FileNotFoundError, IOError, ValueError) as e: print(f\\"Error reading file {file_path}: {e}\\") return sales_data def generate_sales_report(sales_data): Generate a summary report from the sales data. Args: sales_data (list): List of dictionaries with keys \\"Date\\", \\"Salesperson\\", \\"Product\\", and \\"Revenue\\". Returns: dict: Summary report containing \\"total_revenue\\", \\"best_salesperson\\", and \\"best_selling_product\\". if not sales_data: return { \\"total_revenue\\": 0.0, \\"best_salesperson\\": \\"\\", \\"best_selling_product\\": \\"\\" } total_revenue = 0 salesperson_revenue = {} product_revenue = {} for entry in sales_data: total_revenue += entry[\\"Revenue\\"] if entry[\\"Salesperson\\"] in salesperson_revenue: salesperson_revenue[entry[\\"Salesperson\\"]] += entry[\\"Revenue\\"] else: salesperson_revenue[entry[\\"Salesperson\\"]] = entry[\\"Revenue\\"] if entry[\\"Product\\"] in product_revenue: product_revenue[entry[\\"Product\\"]] += entry[\\"Revenue\\"] else: product_revenue[entry[\\"Product\\"]] = entry[\\"Revenue\\"] best_salesperson = max(salesperson_revenue, key=salesperson_revenue.get, default=\\"\\") best_selling_product = max(product_revenue, key=product_revenue.get, default=\\"\\") return { \\"total_revenue\\": total_revenue, \\"best_salesperson\\": best_salesperson, \\"best_selling_product\\": best_selling_product }"},{"question":"# Problem Statement You are given a list of strings and a target string. Your task is to determine the minimum number of operations required to transform any string in the list to the target string. In each operation, you can change exactly one character in the string to any other character. **Function Signature**: ```python def min_operations_to_transform(strings: List[str], target: str) -> int: ``` # Input: - `strings`: A list of strings where each string has the same length as the `target` string. - `target`: A string representing the target string to which each string in the list should be transformed. # Output: - Returns an integer representing the minimum number of operations required to transform any string in the list to the target string. # Constraints: - Each string in the list and the target string will have a length of at most `100`. - The list `strings` will contain at most `100` strings. - All strings will consist of lowercase alphabets only. # Example: ```python assert min_operations_to_transform([\\"abc\\", \\"def\\", \\"ghi\\"], \\"abb\\") == 2 assert min_operations_to_transform([\\"zzzz\\", \\"abcd\\", \\"pqrs\\"], \\"cdef\\") == 4 assert min_operations_to_transform([\\"xy\\", \\"mn\\", \\"op\\"], \\"aa\\") == 2 assert min_operations_to_transform([\\"aabb\\", \\"bbcc\\", \\"ccdd\\"], \\"aacc\\") == 2 ``` # Additional Information: - The operation count from the string \\"abc\\" to \\"abb\\" would be 1 (changing `c` to `b`). - To solve, compare each string in the list with the target string and compute the transformation cost. Return the minimal cost from all comparisons.","solution":"from typing import List def min_operations_to_transform(strings: List[str], target: str) -> int: def transformation_cost(s: str, t: str) -> int: Returns the number of character changes required to transform string s to string t. return sum(1 for sc, tc in zip(s, t) if sc != tc) return min(transformation_cost(s, target) for s in strings)"},{"question":"# Question: Employee Scheduling Optimization Scenario You are working for a company where employees need to be scheduled for shifts. An optimal schedule ensures that each employee gets the same number of shifts as evenly as possible throughout the week. You have been provided a list of employees and the number of shifts needed. Task You are required to write a function to create a shift schedule that distributes shifts as evenly as possible among the employees. Each employee should be assigned a name and an equal number of shifts as much as possible. If the number of shifts cannot be evenly distributed, the remaining shifts should be allocated starting from the first employee in the list. Implement the following function: 1. `create_shift_schedule(employees: List[str], total_shifts: int) -> Dict[str, int]`: Schedule shifts for the employees evenly. # Input and Output Inputs: * A list `employees` representing the names of employees. * An integer `total_shifts` representing the total number of shifts available. Outputs: * A dictionary where keys are employee names and values are the number of shifts each employee is assigned. # Example Inputs and Outputs ```python # Valid Examples print(create_shift_schedule([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], 7)) # Expected: {\\"Alice\\": 3, \\"Bob\\": 2, \\"Charlie\\": 2} print(create_shift_schedule([\\"Dave\\", \\"Eva\\"], 5)) # Expected: {\\"Dave\\": 3, \\"Eva\\": 2} # Edge Cases print(create_shift_schedule([], 5)) # Expected: {} print(create_shift_schedule([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], 0)) # Expected: {\\"Alice\\": 0, \\"Bob\\": 0, \\"Charlie\\": 0} ``` # Constraints * If no employees are provided, return an empty dictionary `{}`. * If the total number of shifts is zero, each employee gets zero shifts. * If `total_shifts` is negative, assume it represents absolute shifts required (i.e., use the absolute value). # Requirements - Ensure the function handles the distribution of shifts fairly and evenly across employees. - Consider edge cases such as an empty list of employees or zero shifts. - Provide functional documentation and examples for the function.","solution":"from typing import List, Dict def create_shift_schedule(employees: List[str], total_shifts: int) -> Dict[str, int]: Create a shift schedule for employees ensuring as even a distribution as possible. Args: employees (List[str]): List of employee names. total_shifts (int): Total number of shifts to be distributed. Returns: Dict[str, int]: Dictionary with employee names as keys and the number of shifts as values. if not employees: return {} # Use the absolute value of total_shifts if negative total_shifts = abs(total_shifts) num_employees = len(employees) base_shifts = total_shifts // num_employees extra_shifts = total_shifts % num_employees schedule = {} for i, employee in enumerate(employees): shifts = base_shifts + (1 if i < extra_shifts else 0) schedule[employee] = shifts return schedule"},{"question":"# Problem Statement You are required to implement a function that evaluates postfix (Reverse Polish) notation expressions. In postfix notation, the operator follows the operands. For instance, the expression \\"3 4 + 2 * 7 /\\" corresponds to the infix expression \\"(3 + 4) * 2 / 7\\". Task: `evaluate_postfix(expression: str) -> float` - **Input**: - `expression`: A string containing a postfix notation expression. The operands and operators are separated by spaces. - **Output**: - Returns the result of the postfix expression as a float. Requirements and Constraints 1. **Assumptions**: - The expression contains only non-negative integers and the four basic operators: `+`, `-`, `*`, `/`. - The division operator `/` should perform float division. - The input expression is valid and there are no invalid characters or formats. 2. **Constraints**: - The length of the expression does not exceed 200 characters. - The number of operands will always be one more than the number of operators. Implementation Details - Handle division by zero by returning `float(\'inf\')`. - Utilize a stack-based approach to evaluate the postfix expression. - Ensure your function validates input parameters before processing. - Optimize for clarity and maintainability. # Example ```python def evaluate_postfix(expression: str) -> float: # implementation here # Example usage: expression = \\"3 4 + 2 * 7 /\\" result = evaluate_postfix(expression) # Expected output: 2.0 expression = \\"5 1 2 + 4 * + 3 -\\" result = evaluate_postfix(expression) # Expected output: 14.0 ``` Note: - Your solution should produce deterministic results. - Include test cases in your code to demonstrate the functionality.","solution":"def evaluate_postfix(expression: str) -> float: Evaluates a postfix (Reverse Polish) notation expression. Parameters: expression (str): A string containing a postfix notation expression where operands and operators are separated by spaces. Returns: float: The result of the postfix expression. stack = [] operators = {\'+\', \'-\', \'*\', \'/\'} for token in expression.split(): if token not in operators: stack.append(float(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': if b == 0: return float(\'inf\') stack.append(a / b) return stack[0]"},{"question":"**Context**: You are tasked with designing a file synchronization system that ensures consistency between two directories. The directories are represented as trees, where each node denotes a file or a folder, and each edge indicates the structure. Each file is identified by its size and a unique hash. The goal is to identify missing or outdated files in one directory compared to another. **Task**: Implement the `find_sync_differences` function that identifies files in the source directory tree (src) that are missing or outdated in the destination directory tree (dst). The function should return a list of file paths that need to be copied or updated in the destination directory. **Function Signature**: ```python def find_sync_differences(src: dict, dst: dict) -> list: Determine the files that need to be updated or copied from the source to the destination directory. :param src: dict, representing the source directory as a nested dictionary :param dst: dict, representing the destination directory as a nested dictionary :return: list, a list of file paths that are missing or outdated in the destination directory ``` # Input: - `src` (dict): A nested dictionary representing the source directory structure. Each key is either a folder name or a file name, and its value is either a nested dictionary (for folders) or a tuple representing (size, hash) for files. - `dst` (dict): A nested dictionary representing the destination directory structure, with the same format as `src`. # Output: - A list of file paths (strings) that exist in the source directory but are missing or outdated in the destination directory. # Constraints: - A folder can contain other folders or files. - Files are uniquely identified by their path from the root. - File hashes accurately represent the file\'s content. - The directories may not be balanced. # Example: ```python src = { \\"folder1\\": { \\"file1.txt\\": (123, \\"hash1\\"), \\"subfolder\\": { \\"file2.txt\\": (345, \\"hash2\\"), }, }, \\"folder2\\": { \\"file3.txt\\": (567, \\"hash3\\"), }, } dst = { \\"folder1\\": { \\"file1.txt\\": (123, \\"hash1\\"), \\"subfolder\\": { \\"file2.txt\\": (345, \\"wrong_hash\\"), }, }, \\"folder2\\": {}, } assert find_sync_differences(src, dst) == [\\"folder1/subfolder/file2.txt\\", \\"folder2/file3.txt\\"] ``` # Note: - Paths in the output should use \\"/\\" as the directory separator. - The output list does not need to be sorted. - Focus on accuracy and efficient traversal of the directory structures. **Your implementation will be evaluated on correctness, efficiency, and handling of edge cases.**","solution":"def find_sync_differences(src, dst): Determine the files that need to be updated or copied from the source to the destination directory. :param src: dict, representing the source directory as a nested dictionary :param dst: dict, representing the destination directory as a nested dictionary :return: list, a list of file paths that are missing or outdated in the destination directory def traverse(src, dst, path): result = [] for key, value in src.items(): new_path = path + \'/\' + key if path else key if isinstance(value, dict): result += traverse(value, dst.get(key, {}), new_path) else: if key not in dst or dst[key] != value: result.append(new_path) return result return traverse(src, dst, \\"\\")"},{"question":"Below is an additional question designed to align with the provided question in terms of style, complexity, and scope. You are developing a data processing module for a weather monitoring system. The system records temperature readings in Celsius at various timestamps. Your task is to implement a function that calculates the moving average of these temperature readings over a specified window size. **Problem**: Implement a function `moving_average` that calculates the moving average of temperature readings over a given window size. The function should return a list of the averaged temperatures. # Function Signature: ```python def moving_average(readings: list[float], window_size: int) -> list[float]: Parameters: readings (list[float]): List of temperature readings in Celsius. window_size (int): Number of readings to include in each moving average window. Returns: list[float]: List of moving average temperatures. Raises: ValueError: If window_size is less than 1 or greater than the number of readings, or if readings list is empty. ``` # Inputs: * `readings`: A list of temperature readings in Celsius. * `window_size`: An integer specifying the number of readings in each moving average calculation. # Outputs: * Return a list of the moving average temperatures over the specified window size. # Constraints: * `1 ≤ window_size ≤ len(readings)` * `len(readings) ≥ window_size` * Ensure the calculations handle edge cases, such as when the window extends beyond the available readings. # Example: ```python assert moving_average([30.0, 32.1, 33.5, 31.2, 29.5], 3) == [31.866666666666667, 32.266666666666666, 31.4] assert moving_average([25.3, 26.7, 28.4], 1) == [25.3, 26.7, 28.4] assert moving_average([25.3, 26.7, 28.4], 2) == [26.0, 27.55] ``` Hint: Use helper functions to iterate over the readings list and calculate the sum of elements within each window. Do not forget to handle cases when the total number of readings is less than the specified window size or other invalid inputs.","solution":"def moving_average(readings: list[float], window_size: int) -> list[float]: Calculate the moving average of temperature readings over a specified window size. Parameters: readings (list[float]): List of temperature readings in Celsius. window_size (int): Number of readings to include in each moving average window. Returns: list[float]: List of moving average temperatures. Raises: ValueError: If window_size is less than 1 or greater than the number of readings, or if readings list is empty. if window_size < 1 or window_size > len(readings): raise ValueError(\\"Window size must be between 1 and the number of readings\\") if not readings: raise ValueError(\\"Readings list cannot be empty\\") n = len(readings) moving_averages = [] for i in range(n - window_size + 1): window = readings[i:i + window_size] window_average = sum(window) / window_size moving_averages.append(window_average) return moving_averages"},{"question":"Graph Depth-First Search (DFS) Implementation # Background: You are working on developing a graph traversal algorithm for a new software tool used in network analysis. One common method for exploring all nodes and paths in a graph is the Depth-First Search (DFS) algorithm. # Task: Implement DFS for a graph in Python, enabling the traversal starting from a given node, and allowing it to detect cycles within the graph. # Requirements: 1. Create a `Graph` class to represent the graph. 2. Implement a method `dfs_traversal` that performs DFS and returns the traversal order. 3. Write an additional method `detect_cycle` to check for cycles in the graph. # Algorithm Implementation: 1. **Graph Class**: * This class will maintain an adjacency list to represent the graph. * It should have methods to add edges and perform the DFS traversal. * Include a method to detect cycles in the graph. 2. **DFS Traversal**: * Implement `dfs_traversal` method which: * Takes a starting node as a parameter. * Uses a stack to perform the DFS. * Returns the traversal path as a list of nodes. 3. **Cycle Detection**: * Implement `detect_cycle` method which: * Uses recursion and keeps track of visited nodes and recursion stack. * Returns a boolean indicating the presence of a cycle. # Class and Function Definitions: ```python class Graph: def __init__(self): self.adj_list = {} def add_edge(self, src, dest): if src not in self.adj_list: self.adj_list[src] = [] if dest not in self.adj_list: self.adj_list[dest] = [] self.adj_list[src].append(dest) def dfs_traversal(self, start_node): visited = set() stack = [start_node] traversal_order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) traversal_order.append(node) for neighbor in reversed(self.adj_list[node]): stack.append(neighbor) return traversal_order def detect_cycle(self): visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in self.adj_list[node]: if dfs(neighbor): return True rec_stack.remove(node) return False for node in self.adj_list: if dfs(node): return True return False ``` # Input/Output: * **Input**: * Graph edges, starting node for DFS traversal. * Example: ```python graph = Graph() graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) ``` * **Output**: * List of nodes in the order they were visited during DFS traversal. * Boolean indicating whether a cycle is present in the graph. * Example Output: ```python dfs_order = graph.dfs_traversal(2) # Output: [2, 3, 0, 1] has_cycle = graph.detect_cycle() # Output: True ``` # Constraints: * Assume that nodes in the graph are integers. * The graph can be directed and may contain cycles. * Handle edge cases gracefully (e.g., single node, isolated nodes).","solution":"class Graph: def __init__(self): self.adj_list = {} def add_edge(self, src, dest): if src not in self.adj_list: self.adj_list[src] = [] if dest not in self.adj_list: self.adj_list[dest] = [] self.adj_list[src].append(dest) def dfs_traversal(self, start_node): visited = set() stack = [start_node] traversal_order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) traversal_order.append(node) for neighbor in reversed(self.adj_list[node]): stack.append(neighbor) return traversal_order def detect_cycle(self): visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in self.adj_list[node]: if dfs(neighbor): return True rec_stack.remove(node) return False for node in self.adj_list: if dfs(node): return True return False"},{"question":"# Detecting Anomalies in Temperature Data **Background**: A weather monitoring system records temperature data every hour. Sometimes, due to sensor malfunctions, the recorded temperature values can be abnormally high or low compared to usual readings. The system needs a function to identify these anomalies based on historical temperature data. **Objective**: Implement a function that identifies anomalous temperature readings by comparing them to historical data using a simple statistical method. **Task**: 1. Write a function `detect_anomalies(historical_data: list[float], current_data: list[float], threshold: float) -> list[bool]` that: - Accepts two lists of temperature readings: `historical_data` representing past temperature values, and `current_data` representing the latest temperature readings. - A floating-point value `threshold` which specifies the multiple of standard deviations to consider when detecting anomalies. - Returns a list of boolean values indicating whether each reading in `current_data` is anomalous (`True`) or not (`False`). **Function Signature**: ```python def detect_anomalies(historical_data: list[float], current_data: list[float], threshold: float) -> list[bool]: ``` **Input**: - `historical_data`: A list of historical temperature readings with at least 30 values. Example: `[22.5, 23.0, 21.7, 22.8, ...]` - `current_data`: A list of the latest temperature readings to be checked for anomalies. Example: `[22.5, 27.0, 23.1, ...]` - `threshold`: A float representing the number of standard deviations away from the mean to consider a reading anomalous. Example: `2.5` **Output**: - A list of boolean values where each value corresponds to whether the respective temperature in `current_data` is anomalous. Example: `[False, True, False, ...]` **Constraints**: - The length of `historical_data` is at least 30 and has `1 <= len(historical_data) <= 1000`. - The length of `current_data` is `1 <= len(current_data) <= 100`. - The threshold is a positive floating-point number. **Example**: ```python historical_data = [22.5, 23.0, 21.7, 22.8, 23.1, 22.9, 22.6, 23.4, 22.3, 22.7, 23.2, 23.0, 21.9, 22.5, 23.3, 22.7, 22.8, 22.2, 23.1, 22.6, 23.0, 23.2, 22.9, 23.1, 22.8, 23.0, 23.4, 22.9, 23.3, 22.7] current_data = [21.5, 27.0, 24.1, 20.5] threshold = 2.0 result = detect_anomalies(historical_data, current_data, threshold) print(result) # Output: [False, True, False, True] ``` To calculate whether a current reading is anomalous: 1. Compute the mean and standard deviation of the `historical_data`. 2. Determine if each reading in `current_data` lies outside the mean ± (threshold * standard deviation). Using this function can help maintain the accuracy of the temperature monitoring system by flagging potentially erroneous data.","solution":"import statistics def detect_anomalies(historical_data: list[float], current_data: list[float], threshold: float) -> list[bool]: Identifies anomalous temperature readings based on historical data. Parameters: historical_data (list[float]): A list of historical temperature values. current_data (list[float]): A list of current temperature values. threshold (float): Threshold for anomaly detection. Returns: list[bool]: A list of boolean values indicating anomalies in the current_data. mean = statistics.mean(historical_data) stdev = statistics.stdev(historical_data) anomalies = [] for temp in current_data: if abs(temp - mean) > threshold * stdev: anomalies.append(True) else: anomalies.append(False) return anomalies"},{"question":"# Question: Count Unique Elements Context: You are tasked with writing a Python function to count the number of unique elements in a given list. Unique elements are those that appear exactly once in the list. Problem Statement: Write a function `count_unique_elements(arr: List[int]) -> int` that returns the number of unique elements in the input list. Input: * `arr` (List[int]): A list of integers. Output: * `int`: The count of unique integers in the list. Constraints: * The list `arr` can have lengths from 0 to 100,000. * Elements in the list will be within the range from `-10^6` to `10^6`. Example: ```python assert count_unique_elements([1, 2, 2, 3, 4, 4, 5]) == 3 # Unique elements are 1, 3, and 5 assert count_unique_elements([10, 10, 10, 10]) == 0 # No unique elements assert count_unique_elements([100, 200, 300, 400]) == 4 # All elements are unique assert count_unique_elements([]) == 0 # Empty list has 0 unique elements ``` Requirements: * Your solution should have a time complexity of O(N) and a space complexity of O(N), where N is the number of elements in the list. * Ensure correctness for edge cases such as empty lists and lists with no unique elements.","solution":"from typing import List from collections import Counter def count_unique_elements(arr: List[int]) -> int: Returns the count of unique elements in the input list. Unique elements are those that appear exactly once in the list. :param arr: List of integers :return: Number of unique integers in the list # Count the frequency of each element in the list element_count = Counter(arr) # Count the elements that appear exactly once unique_count = sum(1 for count in element_count.values() if count == 1) return unique_count"},{"question":"Word Frequency Analyzer The goal of this task is to build a tool that can analyze the frequency of words in a given text file and provide various statistics about the text. The tool should be able to count the occurrences of each word, ignore common stop words, and provide outputs including the most common words and their frequencies. # Task 1. **Read Text File**: Create a method to read a text file and store its content. 2. **Word Count**: Implement functionality to count the occurrences of each word in the file, where a word is defined as a continuous sequence of alphanumeric characters. 3. **Ignore Stop Words**: Enhance the word-counting method to ignore common English stop words such as \\"the\\", \\"is\\", \\"in\\", etc. You may use a predefined list of stop words. 4. **Statistics**: Provide methods to output statistics such as: * The top N most common words and their counts. * The total number of unique words (excluding stop words). * The frequency of a specific word if queried. # Input and Output - **Input**: A text file for analysis. - **Output**: Console output showing the requested statistics. # Constraints - **Input File**: The text file should be handled gracefully, including checking that the file exists and is readable. - **Case Insensitivity**: The word count should be case-insensitive. - **Data Structures**: Use appropriate data structures to ensure efficient counting and access of words. # Requirements - **File Reading**: Implement file reading with error handling. - **Word Counting**: Create a dictionary or similar structure for counting word occurrences. - **Stop Words**: Utilize a set of stop words to filter out common words from the statistics. - **Statistics Output**: Write methods to provide various text statistics as described. # Example ```python analyzer = WordFrequencyAnalyzer(\'sample.txt\') analyzer.read_file() # Read the file analyzer.count_words() # Count the words analyzer.top_n_words(10) # Display top 10 most common words analyzer.total_unique_words() # Display total number of unique words excluding stop words analyzer.query_word_frequency(\'example\') # Display frequency of the word \'example\' ``` Your task is to implement the `WordFrequencyAnalyzer` class. Make sure to include methods for file reading, word counting, stop word filtering, and statistics outputs. Ensure your implementation is efficient and handles edge cases gracefully.","solution":"import os import string from collections import defaultdict, Counter class WordFrequencyAnalyzer: def __init__(self, file_path): self.file_path = file_path self.word_counts = Counter() self.stop_words = set([\'the\', \'is\', \'in\', \'and\', \'to\', \'a\', \'of\', \'it\', \'that\', \'as\', \'with\', \'for\', \'on\', \'are\', \'this\', \'an\', \'by\', \'be\', \'or\', \'at\']) def read_file(self): if not os.path.exists(self.file_path): raise FileNotFoundError(f\\"{self.file_path} not found\\") with open(self.file_path, \'r\', encoding=\'utf-8\') as file: content = file.read() return content def count_words(self, text): words = text.lower().translate(str.maketrans(\'\', \'\', string.punctuation)).split() filtered_words = [word for word in words if word not in self.stop_words] self.word_counts.update(filtered_words) def top_n_words(self, n): return self.word_counts.most_common(n) def total_unique_words(self): return len(self.word_counts) def query_word_frequency(self, word): return self.word_counts[word.lower()]"},{"question":"# Problem: Calculate Distance Traveled During Free Fall Imagine an object is dropped from a certain height, and it is in free fall under the influence of gravity. The distance an object falls can be calculated using the formula: [ d(t) = frac{1}{2} cdot g cdot t^2 ] where: - ( d(t) ) is the distance fallen at time `t`, - ( g ) is the acceleration due to gravity (9.8 m/s(^2)), - ( t ) is the time in seconds that the object has been falling. Write a function `free_fall_distance` that calculates the distance traveled by an object in free fall after a given time `t`. The output should be rounded to three decimal places. Function Signature ```python def free_fall_distance(time_sec: float) -> float: ``` Input * **time_sec**: A non-negative float representing the time in seconds since the object was dropped. Output * **returns**: A float representing the distance traveled in meters, rounded to three decimal places. Constraints * The input for `time_sec` must be non-negative. * If the input is negative, the function should raise a `ValueError` with an appropriate error message. Examples ```python >>> free_fall_distance(3) 44.100 >>> free_fall_distance(4.5) 99.225 >>> free_fall_distance(0) 0.000 >>> free_fall_distance(-2) Traceback (most recent call last): ... ValueError: Time in seconds must be non-negative. ``` Note that this function leverages the basic concepts of physics and mathematical calculations, ensuring input validation and precise output formatting.","solution":"def free_fall_distance(time_sec: float) -> float: Calculate the distance traveled by an object in free fall after a given time `t`. Args: time_sec (float): Time in seconds since the object was dropped. Returns: float: Distance traveled in meters, rounded to three decimal places. Raises: ValueError: If `time_sec` is negative. if time_sec < 0: raise ValueError(\\"Time in seconds must be non-negative.\\") g = 9.8 # Acceleration due to gravity in m/s^2 distance = 0.5 * g * time_sec ** 2 return round(distance, 3)"},{"question":"# Rotate Linked List **Context**: You\'re part of a software team responsible for developing robust data manipulation utilities for a company\'s internal tools. One common operation involves rotating elements in a linked list to the right by a specified number of positions. **Problem Statement**: Implement a function `rotate_right` that rotates a singly linked list to the right by `k` places. # Function Signature ```python def rotate_right(head: ListNode, k: int) -> ListNode: pass ``` # Input - **head (ListNode)**: The head node of the singly linked list. - **k (int)**: The number of positions to rotate the list. # Output - **ListNode**: The head node of the newly rotated singly linked list. # Constraints 1. The number of nodes in the list is between 0 and 500. 2. `-100 <= Node.val <= 100` 3. `0 <= k <= 2 * 10^9` # Examples ```python # Linked List Node Definition class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example Usage head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) k = 2 new_head = rotate_right(head, k) # Output: The linked list should be rotated to [4, 5, 1, 2, 3] def print_list(node): while node: print(node.val, end=\' \') node = node.next print() print_list(new_head) # Output: 4 5 1 2 3 ``` # Notes * Handle edge cases where the list is empty or contains only one node. * Consider the case where `k` is greater than the length of the list. (Tip: Rotating by the length of the list results in the same list.) * Ensure the solution is efficient, making only a few passes over the list when necessary. # Hints 1. Compute the length of the linked list first. 2. Use modular arithmetic to handle cases where `k` is larger than the length of the list. 3. Rearrange pointers without needing additional allocations for list nodes. **Testing**: Besides the provided example, create additional test cases to ensure your implementation is correct: 1. Lists of varying lengths, including edge cases. 2. Different values of `k`, including zero and values larger than the list length. 3. Lists containing negative and positive values.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Compute the length of the linked list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Effective rotations needed k = k % length if k == 0: return head # Find the new head (the (length - k)th node) steps_to_new_head = length - k prev_new_head = head for _ in range(steps_to_new_head - 1): prev_new_head = prev_new_head.next # Rotate the linked list new_head = prev_new_head.next prev_new_head.next = None tail.next = head return new_head"},{"question":"# Scenario: You are developing a feature for a stock trading application that allows users to analyze the moving average of stock prices over a specified window. Computing the moving average helps users understand the trend of stock prices over time. # Task: Write a function named `moving_average` that takes in a list of stock prices and an integer specifying the window size. The function should return a list of the moving averages. - The moving average for a position `i` is defined as the average of the previous `window_size` stock prices including the price at position `i`. Ensure that the function handles the following edge cases gracefully: - If the window size is greater than the length of the list, return an empty list. - If the window size is 1, the moving average is simply the original list. - If the list is empty, return an empty list. # Input: - A list of stock prices: `prices` (list of floats or ints) - An integer specifying the window size: `window_size` (positive int) # Output: - A list of moving averages (list of floats) # Constraints: - Ensure that the function handles both large and small lists (up to 10^6 elements). - The resulting values should be rounded to 2 decimal places. # Example: ```python >>> moving_average([10, 20, 30, 40, 50], 3) [10.0, 15.0, 20.0, 30.0, 40.0] >>> moving_average([10, 20, 30, 40, 50], 1) [10.0, 20.0, 30.0, 40.0, 50.0] >>> moving_average([10, 20, 30, 40, 50], 6) [] >>> moving_average([], 3) [] ``` Ensure your solution handles the edge cases and constraints specified.","solution":"def moving_average(prices, window_size): Computes the moving average of stock prices over the specified window size. Parameters: prices (list of float/int): List of stock prices. window_size (int): The window size for the moving average. Returns: list of float: List of moving averages rounded to 2 decimal places. n = len(prices) if window_size > n or window_size <= 0: return [] moving_averages = [] current_sum = 0.0 for i in range(n): current_sum += prices[i] if i >= window_size - 1: if i >= window_size: current_sum -= prices[i - window_size] moving_averages.append(round(current_sum / window_size, 2)) else: moving_averages.append(round(current_sum / (i + 1), 2)) return moving_averages"},{"question":"# Problem Statement You are developing a software utility for 2D vector operations. This software should handle basic operations that can be performed on 2D vectors. Your task is to implement the following three functions: `vector_addition`, `vector_subtraction`, and `dot_product`. Each function should perform calculations based on the provided vectors. # Input and Output Format Function 1: `vector_addition(vector1: tuple, vector2: tuple) -> tuple` * **Input**: * `vector1` (tuple): A tuple containing two integers representing the first vector (e.g., (x1, y1)). * `vector2` (tuple): A tuple containing two integers representing the second vector (e.g., (x2, y2)). * **Output**: * Returns a tuple representing the sum of the two vectors (e.g., (x1 + x2, y1 + y2)). Function 2: `vector_subtraction(vector1: tuple, vector2: tuple) -> tuple` * **Input**: * `vector1` (tuple): A tuple containing two integers representing the first vector (e.g., (x1, y1)). * `vector2` (tuple): A tuple containing two integers representing the second vector (e.g., (x2, y2)). * **Output**: * Returns a tuple representing the difference of the two vectors (e.g., (x1 - x2, y1 - y2)). Function 3: `dot_product(vector1: tuple, vector2: tuple) -> int` * **Input**: * `vector1` (tuple): A tuple containing two integers representing the first vector (e.g., (x1, y1)). * `vector2` (tuple): A tuple containing two integers representing the second vector (e.g., (x2, y2)). * **Output**: * Returns an integer representing the dot product of the two vectors (e.g., x1*x2 + y1*y2). # Requirements 1. Each function should raise a `ValueError` with a meaningful message if the length of the input tuples is not 2. 2. Each function should perform the corresponding vector operation correctly. # Example ```python # Example usages of the 2D vector operations assert vector_addition((3, 4), (1, 2)) == (4, 6) assert vector_addition((-1, 5), (2, -2)) == (1, 3) assert vector_subtraction((5, 7), (2, 3)) == (3, 4) assert vector_subtraction((3, 4), (-1, -2)) == (4, 6) assert dot_product((1, 2), (3, 4)) == 11 assert dot_product((-1, 0), (2, -2)) == -2 ``` # Constraints * The input values for the vectors will always be integers in the range of [-10000, 10000]. You are expected to implement these functions in Python, ensuring correctness and efficiency.","solution":"def vector_addition(vector1, vector2): Returns the sum of vector1 and vector2. if len(vector1) != 2 or len(vector2) != 2: raise ValueError(\\"Both vectors must be of length 2\\") return (vector1[0] + vector2[0], vector1[1] + vector2[1]) def vector_subtraction(vector1, vector2): Returns the difference of vector1 and vector2. if len(vector1) != 2 or len(vector2) != 2: raise ValueError(\\"Both vectors must be of length 2\\") return (vector1[0] - vector2[0], vector1[1] - vector2[1]) def dot_product(vector1, vector2): Returns the dot product of vector1 and vector2. if len(vector1) != 2 or len(vector2) != 2: raise ValueError(\\"Both vectors must be of length 2\\") return vector1[0] * vector2[0] + vector1[1] * vector2[1]"},{"question":"# Question Write a function `rotate_string` that takes a string `s` and an integer `n` as input and returns a new string that is the result of rotating `s` to the right by `n` positions. A right rotation by one position means moving the last character of the string to the front. Function Signature ```python def rotate_string(s: str, n: int) -> str: ``` Input * `s`: A string of length at most 10^5, consisting of upper and lowercase English letters. * `n`: An integer (0 ≤ n ≤ 10^5), representing the number of positions to rotate the string. Output * A string that is the result of rotating `s` to the right by `n` positions. Examples ```python >>> rotate_string(\\"abcdef\\", 2) \\"efabcd\\" >>> rotate_string(\\"abcdef\\", 6) \\"abcdef\\" >>> rotate_string(\\"abcdef\\", 0) \\"abcdef\\" ``` In the case of `rotate_string(\\"abcdef\\", 2)`, rotating the string \\"abcdef\\" to the right by 2 positions results in \\"efabcd\\".","solution":"def rotate_string(s: str, n: int) -> str: Rotates the string s to the right by n positions. :param s: The string to be rotated. :param n: The number of positions to rotate the string. :return: The rotated string. if not s: return s n = n % len(s) # To handle cases where n is greater than the length of the string return s[-n:] + s[:-n]"},{"question":"# Question You are assigned the task of implementing a function to compute the square root of a given non-negative integer using the binary search algorithm. The function should return the largest integer whose square is less than or equal to the given number. Function Signature ```python def integer_sqrt(number: int) -> int: pass ``` Input * `number` (int): A non-negative integer. Output * (int): The largest integer whose square is less than or equal to the input number. Constraints * `number` is within the range of 0 to 10^9. * The input is guaranteed to be an integer and non-negative. Performance Requirements * Your function should have a time complexity of O(log n), leveraging the binary search algorithm. * The space complexity should be O(1), aiming for an iterative approach. Example ```python >>> integer_sqrt(16) 4 >>> integer_sqrt(20) 4 >>> integer_sqrt(1) 1 >>> integer_sqrt(15) 3 ``` Additional Notes Ensure that the function handles edge cases, such as when `number` is 0 or 1.","solution":"def integer_sqrt(number: int) -> int: if number < 2: return number left, right = 1, number // 2 while left <= right: mid = (left + right) // 2 mid_squared = mid * mid if mid_squared == number: return mid elif mid_squared < number: left = mid + 1 else: right = mid - 1 return right"},{"question":"Sum of Digit Factorial Numbers Context A number is known as a \'digit factorial number\' if it equals the sum of the factorial of its digits. For example, 145 is a digit factorial number because 1! + 4! + 5! = 1 + 24 + 120 = 145. You are required to find the sum of all such numbers up to a given limit. Objective Implement a function `sum_digit_factorial_numbers(limit: int) -> int` that returns the sum of all digit factorial numbers not exceeding the specified limit. Input/Output Formats - **Input**: * An integer `limit` (1 ≤ limit ≤ 10^6). - **Output**: * An integer representing the sum of all digit factorial numbers not exceeding the specified limit. Constraints - Use efficient algorithms to calculate factorial values and check the condition for all numbers up to the given limit. - Minimize repetitive calculations by caching factorial values for digits 0-9. Performance Requirements - The algorithm should efficiently handle the range up to 10^6, avoiding superfluous computations. Example ```python def sum_digit_factorial_numbers(limit: int) -> int: # Implementation here print(sum_digit_factorial_numbers(1000)) # Expected Output: 40730 print(sum_digit_factorial_numbers(50000)) # Expected Output: 40730 ``` Implement the function by precomputing the factorial values for digits 0 through 9, and then iterating over the range to check for the digit factorial condition. Ensure to keep the solution optimized for larger inputs.","solution":"def sum_digit_factorial_numbers(limit: int) -> int: from math import factorial # Precompute factorials of digits 0-9 factorials = {str(i): factorial(i) for i in range(10)} def is_digit_factorial_number(n: int) -> bool: return n == sum(factorials[digit] for digit in str(n)) # Find all digit factorial numbers up to the limit return sum(n for n in range(10, limit + 1) if is_digit_factorial_number(n))"},{"question":"Finding Connected Components in an Undirected Graph You are provided with a class `Graph` that represents an undirected graph using an adjacency list representation. Your task is to implement a method `connected_components` to find all the connected components in the graph. Implement the following method: ```python def connected_components(self) -> List[List[int]]: pass ``` # Function Specification * **Output**: * Return a list of lists, where each list contains the vertices of one connected component in the graph. # Constraints * The graph can contain up to 10^5 vertices and 2*10^5 edges. * Vertices are denoted as integers starting from 0 to V-1. * The graph may be disconnected, and the vertices within each connected component can be listed in any order. Example ```python g = Graph() g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(3, 4) print(g.connected_components()) # Output: [[0, 1, 2], [3, 4]] or [[1, 0, 2], [4, 3]] etc. ``` # Explanation 1. In the example, the graph has two connected components: one consisting of vertices {0, 1, 2} and the other consisting of vertices {3, 4}. The returned result lists these components. This problem will test your understanding of graph traversal algorithms such as Depth-First Search (DFS) or Breadth-First Search (BFS) and your ability to identify connected components within an undirected graph.","solution":"from typing import List class Graph: def __init__(self, V): self.V = V self.adj_list = [[] for _ in range(V)] def add_edge(self, u, v): self.adj_list[u].append(v) self.adj_list[v].append(u) def connected_components(self) -> List[List[int]]: def dfs(v): stack = [v] visited[v] = True component = [] while stack: node = stack.pop() component.append(node) for neighbor in self.adj_list[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) return component visited = [False] * self.V components = [] for vertex in range(self.V): if not visited[vertex]: component = dfs(vertex) components.append(component) return components"},{"question":"**Problem Statement:** You are tasked with developing a feature that determines the maximum sum of non-adjacent elements from an array of integers. This problem requires understanding and implementing dynamic programming techniques to solve efficiently. Write a function `max_non_adjacent_sum(array: list[int]) -> int` that: - Receives an array of integers `array`. - Returns the maximum sum of non-adjacent elements in the array. # Constraints: - Elements in the array can be negative or positive. - 1 ≤ length of `array` ≤ 10000. # Input: - `array`: List of integers, which can be negative, zero, or positive. # Output: - An integer denoting the maximum sum of non-adjacent elements. # Example: Example 1: ``` Input: array = [3, 2, 5, 10, 7] Output: 15 Explanation: The maximum sum is obtained by taking 3, 5, and 7, which results in 3 + 5 + 7 = 15. ``` Example 2: ``` Input: array = [-2, 1, 3, -4, 5] Output: 8 Explanation: The maximum sum is obtained by taking 1 and 5, which results in 1 + 5 = 6 or by taking 3 and 5, which results in 3 + 5 = 8. ``` Implement a solution that optimally handles the given constraints, particularly focusing on avoiding the selection of adjacent elements and maximally leveraging dynamic programming concepts.","solution":"def max_non_adjacent_sum(array: list[int]) -> int: if not array: return 0 if len(array) == 1: return max(0, array[0]) include = 0 exclude = 0 for num in array: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"# Question You are tasked with implementing and fine-tuning a Random Forest classifier for a given dataset. Your goal is to train a model that accurately classifies instances in the dataset and evaluate its performance using various metrics such as accuracy, precision, recall, and F1-score. # Requirements: - Implement the Random Forest model using `RandomForestClassifier` from the scikit-learn library. - Split the dataset into train and test subsets. - Train the model on the training data. - Evaluate the model on the testing data using accuracy, precision, recall, and F1-score. - Optimize the model using hyperparameters for best performance. - Handle edge cases, such as missing values and class imbalances. # Input: - `features`: a list of lists where each inner list represents the feature vector of an instance. - `target`: a list of integers representing the target classes. # Output: - The overall accuracy, precision, recall, and F1-score of your model on the test dataset. # Constraints: - The dataset should be split into 70% training and 30% testing. - The classifier should implement handling for both overfitting and underfitting. - The evaluation should include all mentioned metrics. # Performance Requirements: - Aim for precision, recall, and F1 scores of no less than 85% on the test dataset. # Scenario: Consider you have been given the Breast Cancer dataset (from sklearn.datasets) to classify whether a tumor is malignant or benign based on its features. Implement the `train_random_forest` function to train and evaluate the model. Use the helper functions provided to handle the dataset. ```python import numpy as np from sklearn.datasets import load_breast_cancer from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score from sklearn.model_selection import train_test_split def data_handling(dataset: dict) -> tuple: Split dataset into features and target return (dataset[\\"data\\"], dataset[\\"target\\"]) def train_random_forest(features: np.ndarray, target: np.ndarray) -> None: Implement and train the Random Forest classifier, then evaluate its performance # Split the dataset x_train, x_test, y_train, y_test = train_test_split(features, target, test_size=0.30) # Create a Random Forest Classifier classifier = RandomForestClassifier(n_estimators=100, random_state=42) # Train the classifier classifier.fit(x_train, y_train) # Predict the test set results y_pred = classifier.predict(x_test) # Calculate evaluation metrics accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) print(f\\"Accuracy: {accuracy * 100:.2f}%\\") print(f\\"Precision: {precision * 100:.2f}%\\") print(f\\"Recall: {recall * 100:.2f}%\\") print(f\\"F1-score: {f1 * 100:.2f}%\\") def main() -> None: # Load Breast Cancer dataset cancer = load_breast_cancer() features, targets = data_handling(cancer) # Train and evaluate the classifier train_random_forest(features, targets) if __name__ == \\"__main__\\": main() ``` **Note**: Ensure to install the required libraries using `pip install scikit-learn` before running your script.","solution":"import numpy as np from sklearn.datasets import load_breast_cancer from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score from sklearn.model_selection import train_test_split from sklearn.impute import SimpleImputer from sklearn.utils import resample def data_handling(dataset: dict) -> tuple: Split dataset into features and target, handle missing values if any. features = dataset[\\"data\\"] target = dataset[\\"target\\"] # Handle missing values imputer = SimpleImputer(strategy=\\"mean\\") features = imputer.fit_transform(features) return (features, target) def balance_data(features: np.ndarray, target: np.ndarray) -> tuple: Balance the classes using resampling techniques. # Combine the features and target for resampling combined = np.c_[features, target] # Split the majority and minority class majority = combined[target == 0] minority = combined[target == 1] # Upsample the minority class minority_upsampled = resample(minority, replace=True, n_samples=len(majority)) # Combine back the resampled dataset combined_upsampled = np.vstack([majority, minority_upsampled]) np.random.shuffle(combined_upsampled) # Split again into features and target features_balanced = combined_upsampled[:, :-1] target_balanced = combined_upsampled[:, -1].astype(int) return features_balanced, target_balanced def train_random_forest(features: np.ndarray, target: np.ndarray) -> dict: Implement and train the Random Forest classifier, then evaluate its performance. # Split the dataset x_train, x_test, y_train, y_test = train_test_split(features, target, test_size=0.30, random_state=42) # Create a Random Forest Classifier classifier = RandomForestClassifier(n_estimators=100, random_state=42) # Train the classifier classifier.fit(x_train, y_train) # Predict the test set results y_pred = classifier.predict(x_test) # Calculate evaluation metrics accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) metrics = { \\"accuracy\\": accuracy, \\"precision\\": precision, \\"recall\\": recall, \\"f1_score\\": f1 } return metrics def main() -> None: # Load Breast Cancer dataset cancer = load_breast_cancer() features, target = data_handling(cancer) # Balance the dataset features_balanced, target_balanced = balance_data(features, target) # Train and evaluate the classifier metrics = train_random_forest(features_balanced, target_balanced) print(f\\"Accuracy: {metrics[\'accuracy\'] * 100:.2f}%\\") print(f\\"Precision: {metrics[\'precision\'] * 100:.2f}%\\") print(f\\"Recall: {metrics[\'recall\'] * 100:.2f}%\\") print(f\\"F1-score: {metrics[\'f1_score\'] * 100:.2f}%\\") if __name__ == \\"__main__\\": main()"},{"question":"# Problem Statement Given a list of integers, implement the quicksort algorithm to sort the list in ascending order. Your task is to write a function that takes an unsorted list of integers and returns a new list with the integers sorted. # Function Signature ```python def quicksort(arr: List[int]) -> List[int]: Args: arr: A list of integers representing the unsorted array. Returns: A sorted list of integers in ascending order. ``` # Input and Output - **Input**: - `arr`: A list of integers `[-10^6, 10^6]` with length `0 <= len(arr) <= 10^4`. - **Output**: A sorted list containing all the integers from the input list in ascending order. # Example ```python print(quicksort([3, 6, 8, 10, 1, 2, 1])) # should return [1, 1, 2, 3, 6, 8, 10] print(quicksort([])) # should return [] print(quicksort([1])) # should return [1] print(quicksort([9, -3, 5, 2, 6, 8, -6, 1, 3])) # should return [-6, -3, 1, 2, 3, 5, 6, 8, 9] ``` # Notes - The provided `quicksort` function should: - Implement the quicksort algorithm using recursion. - Select a pivot element. - Partition the list into two sublists: one with elements less than the pivot and one with elements greater than the pivot. - Recursively apply the same process to the sublists. - Combine the sorted sublists with the pivot to form the final sorted list. - Do not use Python\'s built-in `sorted()` function or any other sorting functions. Implement the quicksort algorithm from scratch. # Constraints - Ensure efficient sorting for the given constraints. The expected average time complexity of your algorithm should be O(n log n). Avoid worst-case scenarios where possible.","solution":"def quicksort(arr): Implements quicksort algorithm to sort the list in ascending order. Args: arr: A list of integers representing the unsorted array. Returns: A sorted list of integers in ascending order. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] less = [x for x in arr if x < pivot] equal = [x for x in arr if x == pivot] greater = [x for x in arr if x > pivot] return quicksort(less) + equal + quicksort(greater)"},{"question":"# Problem Statement You are a software developer tasked with implementing a function to evaluate arithmetic expressions represented as strings. These expressions only contain non-negative integers, the operators `+` and `-`, and spaces. Your function should return the calculated result as an integer. The expression is guaranteed to be valid and does not contain any parentheses. # Requirements: Implement a function `calculate` that takes in a single string representing the arithmetic expression. - The expression can contain: - Non-negative integers (e.g., `42`, `123`). - The operators `+` and `-` to specify addition and subtraction. - Spaces which can occur at any position and should be ignored. # Function Signature: ```python def calculate(expression: str) -> int: pass ``` # Example: ```python print(calculate(\\"3 + 5 - 2\\")) # Output: 6 print(calculate(\\"42 - 10 + 7\\")) # Output: 39 print(calculate(\\"100 + 200 - 150 + 50\\")) # Output: 200 print(calculate(\\"5\\")) # Output: 5 print(calculate(\\"10 - 10 + 5 - 5\\")) # Output: 0 ``` # Additional Examples: ```python print(calculate(\\"2 - 3 + 1\\")) # Output: 0 print(calculate(\\"0 + 1 - 1\\")) # Output: 0 print(calculate(\\"123 + 456 - 789\\")) # Output: -210 print(calculate(\\"5 + 6 + 7 - 8 + 9 - 10\\")) # Output: 9 print(calculate(\\"5-3+2\\")) # Output: 4 ``` # Notes: - The expression will not contain any invalid characters. - Multiple spaces can be present between numbers and operators. - You can assume the input string to be a valid arithmetic expression as per the given specifications.","solution":"def calculate(expression: str) -> int: Evaluates an arithmetic expression represented as a string containing non-negative integers, \'+\' and \'-\' operators, and spaces. :param expression: str, arithmetic expression to evaluate :return: int, result of the expression # Remove any spaces in the expression expression = expression.replace(\' \', \'\') # Initialize variables for the current number and total current_num = 0 total = 0 sign = 1 # 1 for positive, -1 for negative for char in expression: if char.isdigit(): current_num = current_num * 10 + int(char) elif char in \'+-\': total += sign * current_num current_num = 0 sign = 1 if char == \'+\' else -1 # Don\'t forget to add the last number left in current_num total += sign * current_num return total"},{"question":"# Coding Assessment Question Matrix Element Swapping In this task, you are required to write a function that modifies a given square matrix by swapping its diagonal elements. The diagonal elements of the matrix are those located from the top left corner to the bottom right corner (main diagonal) and from the top right corner to the bottom left corner (secondary diagonal). # Problem Statement Function: swap_diagonals Write a function `swap_diagonals` that: - Takes as input a 2D list of integers `matrix` which is a square matrix of size `n x n`. - Modifies the matrix in-place by swapping the elements of its main diagonal with the corresponding elements of its secondary diagonal. Specifications: - Input: 2D list `matrix` of integers. - Output: None. The function should modify the matrix in-place. Constraints: 1. The given matrix will always be square and have dimensions `n x n` where `2 ≤ n ≤ 1000`. 2. Do not use any additional data structures apart from simple variables. # Example Scenario Given the matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Sample Call: ```python swap_diagonals(matrix) ``` Modified Matrix: ```python [ [3, 2, 1], [4, 5, 6], [9, 8, 7] ] ``` Here, the main diagonal `[1, 5, 9]` has been swapped with the secondary diagonal `[3, 5, 7]`, resulting in the modified matrix shown above. # Note: - Ensure the function runs efficiently even for the upper constraint on matrix size. - Handle edge cases where all elements of the main and secondary diagonals might be identical. Write your implementation of the function `swap_diagonals` below.","solution":"def swap_diagonals(matrix): Function to swap the elements of the main diagonal with the corresponding elements of the secondary diagonal. The matrix is modified in-place. n = len(matrix) for i in range(n): # Swap main diagonal element with secondary diagonal element matrix[i][i], matrix[i][n - i - 1] = matrix[i][n - i - 1], matrix[i][i]"},{"question":"# Question Context You are designing an algorithm to perform basic operations on a list of integers. Your task involves implementing a function that takes a list of integers and returns a new list with each integer replaced by the product of all other integers in the original list. This should be done without using division. Task Write a function: 1. `product_except_self(nums: List[int]) -> List[int]`: Given a list of integers `nums`, return a list where each element at index `i` is the product of all integers in the original list except the one at index `i`. - **Input**: A list of integers `nums` (1 <= len(nums) <= 10^5, |nums[i]| <= 1000) - **Output**: A list of integers where each element is the product of all other elements in `nums`. Constraints * The length of `nums` is at least 1 and at most 100,000. * Each element in `nums` is between -1000 and 1000, inclusive. * You must solve this problem without using the division operation. Examples ```python assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([0, 4, 3]) == [12, 0, 0] assert product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] assert product_except_self([2]) == [1] assert product_except_self([5, 0, 2, 6]) == [0, 60, 0, 0] ``` Implement the function ensuring correctness and efficiency. Avoid using the division operator in your solution.","solution":"def product_except_self(nums): Given a list of integers `nums`, return a list where each element at index `i` is the product of all integers in the original list except the one at index `i`. length = len(nums) if length == 1: return [1] # Initialize prefix and suffix products left_products = [1] * length right_products = [1] * length # Fill left-products array for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right-products array for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the result array result = [left_products[i] * right_products[i] for i in range(length)] return result"},{"question":"Problem Statement You are tasked with developing a module to assist in calculating various metrics for a rectangular garden plot based on user inputs for the length and width of the garden. The module should include functions to compute the perimeter, the area, and diagonal length of the garden. # Requirements You are to implement three functions `calculate_perimeter`, `calculate_area`, and `calculate_diagonal` based on the given formulas and input validation logic. Additionally, you are required to write a composite function `garden_summary` that leverages these three functions to provide a summary of the garden\'s dimensions. # Input and Output 1. **Input** - `garden_summary(length: float, width: float) -> dict` - `length`: float (must be positive) - `width`: float (must be positive) 2. **Output** - Return a dictionary containing: - `\'perimeter\'`: float (perimeter of the garden) - `\'area\'`: float (area of the garden) - `\'diagonal\'`: float (diagonal length of the garden) # Constraints - `length > 0` - `width > 0` # Example ```python garden_summary(10, 5) # Output: {\'perimeter\': 30.0, \'area\': 50.0, \'diagonal\': 11.18} garden_summary(8, 6) # Output: {\'perimeter\': 28.0, \'area\': 48.0, \'diagonal\': 10.00} ``` # Notes - Handle invalid inputs by raising appropriate exceptions. - Ensure the calculations are accurate to two decimal points. # Implementation Implement the required functions following the input validation rigorously to ensure that only valid inputs are accepted. The functions should then perform the necessary calculations and format the results appropriately.","solution":"import math def calculate_perimeter(length, width): Calculates the perimeter of a rectangle given its length and width. return 2 * (length + width) def calculate_area(length, width): Calculates the area of a rectangle given its length and width. return length * width def calculate_diagonal(length, width): Calculates the diagonal of a rectangle given its length and width. return round(math.sqrt(length**2 + width**2), 2) def garden_summary(length, width): Provides a summary of the garden\'s dimensions including its perimeter, area, and diagonal. if length <= 0 or width <= 0: raise ValueError(\\"Both length and width must be positive numbers.\\") perimeter = calculate_perimeter(length, width) area = calculate_area(length, width) diagonal = calculate_diagonal(length, width) return { \'perimeter\': round(perimeter, 2), \'area\': round(area, 2), \'diagonal\': diagonal }"},{"question":"# Data Frame Filtering and Aggregation You are tasked with writing a function to filter and aggregate data in a DataFrame. The function will filter out rows based on specific conditions on one of the columns and then compute aggregate statistics on another column for the filtered rows. Problem Statement Write a function `filter_and_aggregate(df, filter_column, filter_value, aggregate_column, aggregate_functions)` that filters the DataFrame based on the condition that values in `filter_column` are equal to `filter_value`, and then computes aggregate statistics on `aggregate_column` using the specified aggregation functions. Input: - `df`: A DataFrame (using a library such as pandas) containing the data, where each row represents a data point and each column represents a feature. - `filter_column`: A string representing the column name on which the filter condition is applied. - `filter_value`: A value used to filter rows in the `filter_column`. - `aggregate_column`: A string representing the column name on which aggregation functions will be applied. - `aggregate_functions`: A list of strings representing the names of the aggregation functions to be applied. Possible functions include \'mean\', \'sum\', \'min\', \'max\', and \'count\'. Output: - A dictionary with the names of the aggregation functions as keys and the computed aggregate values as values. Constraints: - The DataFrame `df` will not be empty and will contain at least one numeric column. - `filter_column` and `aggregate_column` will be valid column names in the DataFrame. - If the filtered DataFrame is empty, return an empty dictionary. Example: ```python import pandas as pd data = { \'category\': [\'A\', \'A\', \'B\', \'B\', \'C\', \'C\'], \'value\': [10, 20, 10, 30, 10, 50] } df = pd.DataFrame(data) filter_column = \'category\' filter_value = \'B\' aggregate_column = \'value\' aggregate_functions = [\'mean\', \'sum\', \'min\', \'max\', \'count\'] result = filter_and_aggregate(df, filter_column, filter_value, aggregate_column, aggregate_functions) print(result) ``` Expected Output: ```python {\'mean\': 20.0, \'sum\': 40, \'min\': 10, \'max\': 30, \'count\': 2} ``` Performance Requirements: The function should perform efficiently when the DataFrame contains up to 1,000,000 rows. Feel free to use libraries like pandas for efficient data manipulation and aggregation. # Hints - Use the `pandas` library for filtering and aggregation. - Ensure to handle cases where the filtered DataFrame might be empty. - Utilize pandas built-in functions for aggregation to maintain efficiency.","solution":"import pandas as pd def filter_and_aggregate(df, filter_column, filter_value, aggregate_column, aggregate_functions): Filters the DataFrame based on a specific condition on one column and then computes aggregate statistics on another column. Parameters: df (pd.DataFrame): The input DataFrame. filter_column (str): The column name on which the filter condition is applied. filter_value: The value to filter rows in filter_column. aggregate_column (str): The column name on which aggregation functions are applied. aggregate_functions (list of str): The list of aggregation functions to be applied. Returns: dict: A dictionary with the names of the aggregation functions as keys and the computed aggregate values as values. # Filter the DataFrame filtered_df = df[df[filter_column] == filter_value] # If filtered DataFrame is empty, return empty dictionary if filtered_df.empty: return {} # Define a dictionary to map function names to pandas aggregation functions aggregation_mapping = { \'mean\': filtered_df[aggregate_column].mean, \'sum\': filtered_df[aggregate_column].sum, \'min\': filtered_df[aggregate_column].min, \'max\': filtered_df[aggregate_column].max, \'count\': filtered_df[aggregate_column].count } # Compute the aggregates result = {} for func in aggregate_functions: if func in aggregation_mapping: result[func] = aggregation_mapping[func]() return result"},{"question":"# Question: Keyword Counter in Text File You need to create a function that reads a text file and counts the occurrences of specific keywords. The function should return a dictionary with each keyword and its respective count. Implement error handling to ensure the file exists and is readable. Your Task Write a function to: 1. Open and read from a text file. 2. Search for and count the occurrences of each keyword. 3. Return a dictionary with the keyword counts. 4. Handle possible file errors gracefully. Function Signature ```python def count_keywords_in_file(file_path: str, keywords: list[str]) -> dict[str, int]: ``` Input - `file_path`: The path to the text file (a string). - `keywords`: A list of keywords (each a string) to count in the file. Output - A dictionary with the keywords as keys and their occurrence counts as values. Constraints - The function should handle file-related errors (like file not found). - All keywords are case-insensitive (e.g., \'Python\' and \'python\' should be considered the same). Examples ```python # Example text file contains: \\"Python programming. Programming in Python is fun. I love python.\\" count_keywords_in_file(\'example.txt\', [\'python\', \'programming\', \'fun\']) # Output: {\'python\': 3, \'programming\': 2, \'fun\': 1} # Example text file contains: \\"Data science is a fascinating field. I enjoy data analysis.\\" count_keywords_in_file(\'data.txt\', [\'data\', \'science\', \'analysis\', \'machine\']) # Output: {\'data\': 2, \'science\': 1, \'analysis\': 1, \'machine\': 0} # Example file path error try: count_keywords_in_file(\'nonexistent.txt\', [\'keyword\']) except FileNotFoundError as e: assert str(e) == \\"The file at nonexistent.txt could not be found.\\" ``` Implement the function to accurately count keywords and handle file-related errors gracefully.","solution":"def count_keywords_in_file(file_path: str, keywords: list[str]) -> dict[str, int]: Opens a text file and counts the occurrences of specific keywords. Args: - file_path: str, path to the text file. - keywords: list of strings, keywords to count in the file. Returns: - dict with keywords as keys and their occurrence counts as values. keyword_counts = {keyword.lower(): 0 for keyword in keywords} try: with open(file_path, \'r\') as file: content = file.read().lower() for keyword in keyword_counts: keyword_counts[keyword] = content.count(keyword) except FileNotFoundError: raise FileNotFoundError(f\\"The file at {file_path} could not be found.\\") return keyword_counts"},{"question":"# Problem Statement Given a sequence of integers, your task is to find the length of the longest subsequence where each element is either strictly increasing or strictly decreasing. This is known as a \\"bitonic sequence,\\" which first increases to a peak and then decreases. # Function Signature ```python def longest_bitonic_subsequence(nums: list[int]) -> int: ``` # Input - A list `nums` of integers representing the sequence. # Output - An integer representing the length of the longest bitonic subsequence. # Constraints - `1 <= len(nums) <= 10^4` - `-10^5 <= nums[i] <= 10^5` # Example ```python nums = [1, 11, 2, 10, 4, 5, 2, 1] print(longest_bitonic_subsequence(nums)) # Expected Output: 6 nums = [12, 4, 78, 90, 45, 23] print(longest_bitonic_subsequence(nums)) # Expected Output: 5 nums = [5, 4, 3, 2, 1] print(longest_bitonic_subsequence(nums)) # Expected Output: 5 ``` # Explanation - In the first example, the longest bitonic subsequence is [1, 2, 10, 4, 2, 1], which has a length of 6. - In the second example, the longest bitonic subsequence is [4, 78, 90, 45, 23], which has a length of 5. - In the third example, the sequence is already strictly decreasing, so the longest bitonic subsequence is the entire sequence [5, 4, 3, 2, 1], with a length of 5. # Notes - Your solution should be efficient to handle the given constraints. - Consider edge cases where the sequence may already be entirely increasing or decreasing. # Hints - Use dynamic programming to calculate the length of the longest increasing subsequence ending at each position. - Similarly, calculate the length of the longest decreasing subsequence starting at each position. - Combine the results to find the longest bitonic subsequence length.","solution":"def longest_bitonic_subsequence(nums: list[int]) -> int: if not nums: return 0 n = len(nums) # Initialize the LIS and LDS arrays lis = [1] * n lds = [1] * n # Compute LIS values from left to right for i in range(1, n): for j in range(i): if nums[i] > nums[j]: lis[i] = max(lis[i], lis[j] + 1) # Compute LDS values from right to left for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if nums[i] > nums[j]: lds[i] = max(lds[i], lds[j] + 1) # Find the maximum value of LIS[i] + LDS[i] - 1 max_length = 0 for i in range(n): max_length = max(max_length, lis[i] + lds[i] - 1) return max_length"},{"question":"# Problem Description You are given a linked list where the nodes have two pointers: one to the next node and one to a random node in the same list. The random pointer can point to any node, including itself, or be null. Your task is to write a function to clone this linked list. The new linked list should have the exact same structure as the old one, where the `next` and `random` pointers still point to the corresponding nodes in the cloned list. # Function Specifications ```python class Node: def __init__(self, x: int, next: \'Node\' = None, random: \'Node\' = None): self.val = x self.next = next self.random = random def copy_random_list(head: \'Node\') -> \'Node\': # Write your code here ``` # Constraints - The number of nodes in the list is in the range `[0, 1000]`. - `-10000 <= Node.val <= 10000` - The list is not necessarily sorted. - Nodes may have `null` as a random pointer. # Example ```python # Creating a linked list with random pointers node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node1.next = node2 node2.next = node3 node3.next = node4 node1.random = node3 node2.random = node1 node3.random = node3 node4.random = node2 cloned_head = copy_random_list(node1) # The cloned list should have the same structure and random pointers as the original one. # Test by checking values and random pointers of the new list. ``` In this example, the original list has nodes with values 1, 2, 3, and 4. The `random` pointers are set in the following way: - Node 1\'s `random` points to Node 3. - Node 2\'s `random` points to Node 1. - Node 3\'s `random` points to itself. - Node 4\'s `random` points to Node 2. Your task is to implement the `copy_random_list` function such that it clones the original list along with the `next` and `random` pointers properly.","solution":"class Node: def __init__(self, x: int, next: \'Node\' = None, random: \'Node\' = None): self.val = x self.next = next self.random = random def copy_random_list(head: \'Node\') -> \'Node\': if not head: return None # First pass: create new nodes and interweave them with original nodes current = head while current: new_node = Node(current.val, current.next, None) current.next = new_node current = new_node.next # Second pass: assign random pointers to the new nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Third pass: separate the original and copied nodes to form two lists current = head copy_head = head.next while current: copy = current.next current.next = copy.next if copy.next: copy.next = copy.next.next current = current.next return copy_head"},{"question":"# Programming Assessment: Warehouse Inventory Tracker You are tasked with enhancing an existing class `WarehouseInventory` to add new functionalities for better inventory management and real-time tracking of stock levels. The `WarehouseInventory` class handles the data for different products stored in a warehouse. Scenario Your company wants to improve the warehouse inventory tracking system by adding new features that allow for better management and monitoring of stock levels. Specifically, you need to enable real-time updates of stock levels and provide alerts when stock levels fall below a certain threshold. # Task Details: 1. **Function Implementation**: - **Method 1**: Implement a `update_stock_level` method within the `WarehouseInventory` class that updates the stock level of a particular product in real time. - **Method 2**: Implement a `check_low_stock` method that continuously monitors the stock levels and raises an alert if any product\'s stock falls below the specified threshold. 2. **Expected Input and Output**: - **update_stock_level**: - Input: `product_id` (str), `quantity` (int) - Output: Updated stock level (int) or error message if product not found. - **check_low_stock**: - Input: threshold level (int, default 10) - Output: List of product IDs that have fallen below the threshold level. 3. **Constraints and Limitations**: - Ensure that the implementation handles concurrency issues gracefully. - Optimize for performance and real-time updates. 4. **Performance Requirements**: - Efficiently update stock levels with minimal delay. - Use efficient data structures to quickly access and update product stock levels. # Method Signatures: ```python class WarehouseInventory: ... def update_stock_level(self, product_id: str, quantity: int) -> Union[int, str]: pass def check_low_stock(self, threshold: int = 10) -> List[str]: pass ... ``` # Notes: - Utilize Python’s built-in `threading` or `asyncio` libraries for real-time updates. - Ensure that the class and methods are thoroughly tested. # Example: ```python # Example usage of the update_stock_level method warehouse = WarehouseInventory() stock_level = warehouse.update_stock_level(\\"product123\\", 50) if isinstance(stock_level, int): print(f\\"Stock level updated to {stock_level}\\") else: print(f\\"Error: {stock_level}\\") # Example usage of the check_low_stock method low_stock_products = warehouse.check_low_stock(5) if low_stock_products: print(f\\"Products with low stock: {\', \'.join(low_stock_products)}\\") else: print(\\"All products have sufficient stock\\") ``` Complete the methods and ensure they work as described.","solution":"from typing import Union, List import threading class WarehouseInventory: def __init__(self): self.inventory = {} self.lock = threading.Lock() def add_product(self, product_id: str, stock_level: int) -> None: with self.lock: self.inventory[product_id] = stock_level def update_stock_level(self, product_id: str, quantity: int) -> Union[int, str]: with self.lock: if product_id in self.inventory: self.inventory[product_id] += quantity return self.inventory[product_id] else: return \\"Product not found\\" def check_low_stock(self, threshold: int = 10) -> List[str]: low_stock_products = [] with self.lock: for product_id, stock_level in self.inventory.items(): if stock_level < threshold: low_stock_products.append(product_id) return low_stock_products"},{"question":"# Question # Recursive Palindrome Checker Context: A palindrome is a string that reads the same forwards and backwards, ignoring spaces, punctuation, and capitalization. For instance, \\"A man, a plan, a canal, Panama!\\" is a palindrome because after removing non-alphabetic characters and normalizing case, it reads \\"amanaplanacanalpanama\\". Task: Write a Python function called `is_palindrome_recursive` that uses recursion to determine if a given string is a palindrome. You should focus on the recursive nature of the solution rather than optimizing for performance. * **Input**: A string `s` containing any printable characters (e.g., letters, numbers, punctuation). * **Output**: A boolean value `True` if the string is a palindrome, `False` otherwise. Constraints: 1. The input string length will not exceed (10^5) characters. 2. The function should ignore non-alphabetic characters and be case-insensitive. Example: ```python def is_palindrome_recursive(s: str) -> bool: # Your recursive implementation goes here # Example usage: print(is_palindrome_recursive(\\"Able , was I saw eLba\\")) # Expected output: True print(is_palindrome_recursive(\\"This is not a palindrome\\")) # Expected output: False ``` Ensure your implementation accurately identifies palindromes using a recursive approach. Write additional test cases to validate its correctness.","solution":"def is_palindrome_recursive(s: str) -> bool: def clean_string(s): return \'\'.join(c.lower() for c in s if c.isalpha()) def recursive_check(clean_s, left, right): if left >= right: return True if clean_s[left] != clean_s[right]: return False return recursive_check(clean_s, left + 1, right - 1) cleaned_s = clean_string(s) return recursive_check(cleaned_s, 0, len(cleaned_s) - 1)"},{"question":"# Rearrange Array Alternately Scenario You are tasked to work on an application that optimizes data arrangement for faster access. One particular module requires you to rearrange an array such that the maximum and minimum elements alternate. Task Write a function `rearrange_alternately(arr: List[int]) -> None` that takes an array of integers as input and rearranges it in-place such that every other element is a maximum or minimum element from the remaining elements. Input The function receives an array: - `arr`: a list of integers (both positive and negative numbers are allowed). Output The function should rearrange the array in-place with no return value. Constraints - The input array will contain at least one integer and at most 10^5 integers. - Rearranging should maintain the relative ordering of original maximum and minimum elements. - The rearrangement should start with the maximum element. Example ```python # Example arr = [1, 2, 3, 4, 5, 6] rearrange_alternately(arr) print(arr) # Output: [6, 1, 5, 2, 4, 3] arr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] rearrange_alternately(arr) print(arr) # Output: [100, 10, 90, 20, 80, 30, 70, 40, 60, 50] ``` # Additional Notes - Think about optimal ways to rearrange the elements without requiring extra space. - Consider edge cases such as arrays that are already sorted in increasing or decreasing order. - Ensure that your solution handles arrays of odd and even lengths correctly.","solution":"from typing import List def rearrange_alternately(arr: List[int]) -> None: Rearranges given list such that elements alternate between maximum and minimum values. n = len(arr) if n <= 1: return # Initialize result list with zeros or None result = [0] * n # Sorting the original array arr.sort() # Pointers to the start and end of the array left, right = 0, n - 1 for i in range(n): if i % 2 == 0: result[i] = arr[right] right -= 1 else: result[i] = arr[left] left += 1 # Copy result to the original array for i in range(n): arr[i] = result[i]"},{"question":"# Scenario: You have been tasked with developing a library system that helps manage the loan of books to patrons. The library wants a system to keep track of which books are available and which books have been checked out. For efficiency, the library uses a `hash table` to store and retrieve book information based on book IDs. # Task: Implement a class `LibrarySystem` that maintains a collection of books and supports the following operations: 1. **Add a book**: Adds a new book with a unique ID and title to the collection. 2. **Check out a book**: Marks a book as checked out if it is available. 3. **Return a book**: Marks a book as available if it has been checked out. 4. **Get book status**: Returns the status of a book (available or checked out) given its ID. 5. **List all available books**: Returns a list of all available books in the library. # Requirements: - Use a hash table for efficient lookups and updates. - Books should be identified uniquely by their `book_id` (an integer). - Each book has a `title` (a string). - You should maintain the status of each book to track if it is available or checked out. # Function Specifications: 1. **add_book(book_id: int, title: str) -> None**: Adds a book with the given `book_id` and `title`. 2. **check_out_book(book_id: int) -> bool**: Marks the book with `book_id` as checked out and returns `True` if successful, or `False` if the book is already checked out or doesn\'t exist. 3. **return_book(book_id: int) -> bool**: Marks the book with `book_id` as available and returns `True` if successful, or `False` if the book is already available or doesn\'t exist. 4. **get_book_status(book_id: int) -> str**: Returns `\'available\'` or `\'checked out\'` depending on the status of the book with `book_id`. If the book does not exist, return `\'not found\'`. 5. **list_available_books() -> list**: Returns a list of `title`s of all available books. # Constraints: - `1 <= book_id <= 10^5` - The length of `title` will not exceed 100 characters. - The number of books will not exceed 10^5. # Example: ```python library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\") library.add_book(2, \\"1984\\") library.add_book(3, \\"To Kill a Mockingbird\\") print(library.get_book_status(1)) # Output: \\"available\\" print(library.check_out_book(1)) # Output: True print(library.get_book_status(1)) # Output: \\"checked out\\" print(library.list_available_books()) # Output: [\\"1984\\", \\"To Kill a Mockingbird\\"] print(library.return_book(1)) # Output: True print(library.get_book_status(1)) # Output: \\"available\\" print(library.list_available_books()) # Output: [\\"1984\\", \\"To Kill a Mockingbird\\", \\"The Great Gatsby\\"] ``` # Note: - The system should handle various edge cases, such as attempting to check out or return a book that doesn\'t exist or is already in the desired state. - The hash table can be implemented using Python\'s `dict` data structure for simplicity.","solution":"class LibrarySystem: def __init__(self): self.books = {} # hash table to store books with their status def add_book(self, book_id: int, title: str) -> None: Adds a book with the given `book_id` and `title`. self.books[book_id] = {\'title\': title, \'status\': \'available\'} def check_out_book(self, book_id: int) -> bool: Marks the book with `book_id` as checked out. Returns `True` if successful, or `False` if the book is already checked out or doesn\'t exist. if book_id in self.books and self.books[book_id][\'status\'] == \'available\': self.books[book_id][\'status\'] = \'checked out\' return True return False def return_book(self, book_id: int) -> bool: Marks the book with `book_id` as available. Returns `True` if successful, or `False` if the book is already available or doesn\'t exist. if book_id in self.books and self.books[book_id][\'status\'] == \'checked out\': self.books[book_id][\'status\'] = \'available\' return True return False def get_book_status(self, book_id: int) -> str: Returns \'available\' or \'checked out\' depending on the status of the book with `book_id`. If the book does not exist, returns \'not found\'. if book_id in self.books: return self.books[book_id][\'status\'] return \'not found\' def list_available_books(self) -> list: Returns a list of titles of all available books. return [book[\'title\'] for book in self.books.values() if book[\'status\'] == \'available\']"},{"question":"# Coding Challenge You are developing a recommendation system for a movie streaming service. The system should recommend movies based on users\' viewing history and the ratings of other similar users using three different approaches, and ensure that the recommended movies are suitable for the users based on their age group. Requirements: 1. **Implement** three recommendation models: - **Collaborative Filtering Recommendation** (`collaborative_filtering_recommendation`). - **Content-Based Recommendation** (`content_based_recommendation`). - **Hybrid Recommendation** (`hybrid_recommendation`). 2. **Implement** a system to check the suitability of the recommended movies: - **Age Group Suitability Checker** (`age_group_suitability_checker`). - **Recommendation Suitability Checker** (`recommendation_suitability_checker`). 3. **Process** users\' viewing history and movie ratings to recommend a list of movies for the user. Verify the suitability of the recommended movies for the user\'s age group using the implemented suitability checker. # Input: - User\'s viewing history as a list of movie IDs. - Users\' age as an integer. - A dictionary with movie details containing ratings and age restrictions. # Output: - A boolean value indicating whether the recommended movies are considered `suitable` or `not suitable` for the user. # Constraints: - Users\' viewing history list will have a minimum size of 5. - Users\' age will be a positive integer. - Movie ratings and age restrictions will be provided in the dictionary format. - Recommendations should handle edge cases like insufficient viewing history gracefully. # Implementation Details: - Implement the recommendation functions `collaborative_filtering_recommendation`, `content_based_recommendation`, `hybrid_recommendation`. - Implement suitability checking functions `age_group_suitability_checker` and `recommendation_suitability_checker`. # Example: ```python viewing_history = [101, 102, 103, 104, 105] user_age = 15 movie_details = { 101: {\'rating\': 4.5, \'age_restriction\': 18}, 102: {\'rating\': 4.0, \'age_restriction\': 13}, 103: {\'rating\': 3.5, \'age_restriction\': 15}, 104: {\'rating\': 5.0, \'age_restriction\': 18}, 105: {\'rating\': 4.8, \'age_restriction\': \'all\'}, } # You need to process the data # Implement recommendation models # Implement suitability checking system # Expected output: # True or False (indicating if the recommended movies are suitable) ```","solution":"def collaborative_filtering_recommendation(viewing_history, movie_details): Recommend movies based on collaborative filtering. This is a placeholder implementation. all_movies = list(movie_details.keys()) recommended_movies = list(set(all_movies) - set(viewing_history))[:5] return recommended_movies def content_based_recommendation(viewing_history, movie_details): Recommend movies based on content similarity. This is a placeholder implementation. all_movies = list(movie_details.keys()) recommended_movies = list(set(all_movies) - set(viewing_history))[:5] return recommended_movies def hybrid_recommendation(viewing_history, movie_details): Recommend movies based on a hybrid approach. This is a placeholder implementation. all_movies = list(movie_details.keys()) recommended_movies = list(set(all_movies) - set(viewing_history))[:5] return recommended_movies def age_group_suitability_checker(movie, user_age): Check if the movie is suitable for the user\'s age group. age_restriction = movie[\'age_restriction\'] if age_restriction == \'all\': return True return user_age >= age_restriction def recommendation_suitability_checker(recommended_movies, user_age, movie_details): Check if all recommended movies are suitable for the user\'s age group. for movie_id in recommended_movies: if not age_group_suitability_checker(movie_details[movie_id], user_age): return False return True def recommend_movies(viewing_history, user_age, movie_details): Generate movie recommendations and check their suitability. recommended_movies = hybrid_recommendation(viewing_history, movie_details) return recommendation_suitability_checker(recommended_movies, user_age, movie_details)"},{"question":"# Problem Statement You are given a list of integers where each integer appears exactly twice, except for one integer which appears only once. Write a function to find that unique integer. Function Signature ```python def find_unique_number(nums: list[int]) -> int: ``` Input - A list of integers `nums` where every element appears twice except for one. - The integers in the list can be both positive and negative numbers. - The length of the list will always be odd and will be between 1 and 10^6. Output - Return the unique integer that appears only once in the list. Constraints - The list will not be empty. - The list will contain exactly one integer that appears only once. Examples ```python assert find_unique_number([2, 3, 2, 4, 3]) == 4 assert find_unique_number([0, 1, 1]) == 0 assert find_unique_number([-1, -2, -2, -1, 5]) == 5 assert find_unique_number([10, 20, 30, 20, 10]) == 30 assert find_unique_number([7]) == 7 ``` Additional Notes - Ensure your solution runs efficiently for large lists. - Consider edge cases such as the smallest possible input list. Scenario Imagine you are maintaining a log of users accessing a system. Each user ID should appear exactly twice in the log, indicating check-in and check-out, except for one ID which accidentally appears only once due to a system fault. Your task is to identify this unique user ID to follow up on the abnormal log entry.","solution":"def find_unique_number(nums: list[int]) -> int: Returns the unique integer that appears only once in the list. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Question: Automatic Email Sender with Attachments Background You are required to implement the functionality of an automatic email sender using Python\'s `smtplib` and `email` libraries. This email sender will support sending emails with attachments. This function will accept necessary email components such as recipient address, subject, body, and file paths for attachments. Requirements 1. **Function Name**: `send_email_with_attachments` 2. **Inputs**: - `recipient_address`: String - The email address of the recipient. - `subject`: String - The subject line of the email. - `body`: String - The body content of the email. - `attachments`: List of Strings - File paths to the attachments (optional, can be empty). 3. **Output**: None. 4. **Behavior**: - Authenticate with the email server using environment variables for the email and password. - Create a MIME email with the provided subject, body, and attachments. - Send the email to the recipient. - Handle errors gracefully and log appropriate error messages. Constraints - The sending email credentials (email and password) should be securely accessed via environment variables. - The function should handle various exceptions and ensure resources are properly released. - The solution should be adaptable to different email servers which use the standard SMTP protocol. Example Scenario 1. You need to send an email with the subject \\"Monthly Report\\" and the body \\"Please find the attached monthly report.\\" to \\"recipient@example.com\\". 2. The email will include two attachments located at \\"path/to/report1.pdf\\" and \\"path/to/report2.csv\\". 3. Your function will authenticate using the environment variables, construct the email with given properties and attachments, and send it to the recipient. ```python import os import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.mime.base import MIMEBase from email import encoders from typing import List def send_email_with_attachments(recipient_address: str, subject: str, body: str, attachments: List[str] = []): try: smtp_server = \\"smtp.example.com\\" # Replace with the actual SMTP server smtp_port = 587 # Replace with appropriate port, typically 587 for TLS, 465 for SSL sender_address = os.getenv(\\"EMAIL_ADDRESS\\") sender_password = os.getenv(\\"EMAIL_PASSWORD\\") # Create a multipart message msg = MIMEMultipart() msg[\'From\'] = sender_address msg[\'To\'] = recipient_address msg[\'Subject\'] = subject # Attach the body with the msg msg.attach(MIMEText(body, \'plain\')) # Attach files for file_path in attachments: with open(file_path, \\"rb\\") as attachment: part = MIMEBase(\\"application\\", \\"octet-stream\\") part.set_payload(attachment.read()) encoders.encode_base64(part) part.add_header(\'Content-Disposition\', f\'attachment; filename={os.path.basename(file_path)}\') msg.attach(part) # Create SMTP session session = smtplib.SMTP(smtp_server, smtp_port) session.starttls() # Enable security session.login(sender_address, sender_password) # Send the email session.sendmail(sender_address, recipient_address, msg.as_string()) session.quit() print(\\"Email sent successfully!\\") except Exception as e: print(f\\"Failed to send email: {e}\\") # Example usage # send_email_with_attachments( # \\"recipient@example.com\\", # \\"Monthly Report\\", # \\"Please find the attached monthly report.\\", # [\\"path/to/report1.pdf\\", \\"path/to/report2.csv\\"] # ) ``` Make sure to implement error handling, resource management, and security best practices to ensure the robustness and reliability of your solution.","solution":"import os import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.mime.base import MIMEBase from email import encoders from typing import List def send_email_with_attachments(recipient_address: str, subject: str, body: str, attachments: List[str] = []): try: smtp_server = os.getenv(\\"SMTP_SERVER\\") smtp_port = int(os.getenv(\\"SMTP_PORT\\")) sender_address = os.getenv(\\"EMAIL_ADDRESS\\") sender_password = os.getenv(\\"EMAIL_PASSWORD\\") # Create a multipart message msg = MIMEMultipart() msg[\'From\'] = sender_address msg[\'To\'] = recipient_address msg[\'Subject\'] = subject # Attach the body with the msg msg.attach(MIMEText(body, \'plain\')) # Attach files for file_path in attachments: with open(file_path, \\"rb\\") as attachment: part = MIMEBase(\\"application\\", \\"octet-stream\\") part.set_payload(attachment.read()) encoders.encode_base64(part) part.add_header(\'Content-Disposition\', f\'attachment; filename={os.path.basename(file_path)}\') msg.attach(part) # Create SMTP session session = smtplib.SMTP(smtp_server, smtp_port) session.starttls() # Enable security session.login(sender_address, sender_password) # Send the email session.sendmail(sender_address, recipient_address, msg.as_string()) session.quit() print(\\"Email sent successfully!\\") except Exception as e: print(f\\"Failed to send email: {e}\\")"},{"question":"# Pathfinding Algorithm Challenge # Background: Pathfinding algorithms are crucial in navigation and game development, used to find the optimal path between two points on a grid representing a map. One classic algorithm for this purpose is the A* (A-star) search algorithm, which combines the benefits of Dijkstra\'s algorithm and best-first search. # Your Task: Implement the `astar` function that finds the shortest path between a start and end position on a given 2D grid map. # Function Signature: ```python def astar( grid: list[list[int]], start: tuple[int, int], end: tuple[int, int] ) -> list[tuple[int, int]]: ``` # Input: 1. **grid (list[list[int]])**: A 2D grid map represented as a list of lists of integers (0 for open cell, 1 for obstacle) with shape (M, N), where M is the number of rows and N is the number of columns. 2. **start (tuple[int, int])**: The starting position on the grid, a tuple of (row index, column index). 3. **end (tuple[int, int])**: The ending position on the grid, a tuple of (row index, column index). # Output: - **path (list[tuple[int, int]])**: A list of coordinate tuples representing the shortest path from the start to end, inclusive. If no path exists, return an empty list. # Constraints: - The grid dimensions must be at most 500 x 500. - The start and end positions must be within the grid and represent open cells (value 0). - The grid must contain only integers 0 or 1. - Cells adjacent in the path can only be horizontally or vertically connected (no diagonal moves). # Requirements: 1. Ensure that the algorithm handles grids with varying sizes up to the maximum dimensions efficiently. 2. Implement heuristic optimizations to improve the A* algorithm’s performance. 3. Consider edge cases such as start or end being obstacles, no available path, and invalid positions. # Example: ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) path = astar(grid, start, end) print(\\"Shortest Path:\\", path) ``` # Additional Task: Write automated tests to validate your astar implementation with varying grid sizes, different start and end positions, and edge cases such as paths with no solution or entirely blocked grids.","solution":"from heapq import heappop, heappush def astar(grid, start, end): def neighbors(node): (x, y) = node for d in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + d[0], y + d[1] if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0: yield (nx, ny) def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) open_set = [] heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, end)} while open_set: _, current = heappop(open_set) if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for neighbor in neighbors(current): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, end) heappush(open_set, (f_score[neighbor], neighbor)) return [] # Example usage: grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) path = astar(grid, start, end) print(\\"Shortest Path:\\", path)"},{"question":"# Context You are given a list of transactions where each transaction is represented by a tuple containing the identifier of the item and the quantity sold in that transaction. The task is to implement a function that calculates the total quantity sold for each unique item. # Requirements Implement a function `calculate_total_quantities` that will aggregate the quantities for each distinct item across all transactions. # Function Specification ```python def calculate_total_quantities(transactions: List[Tuple[str, int]]) -> Dict[str, int]: Calculate the total quantity sold for each unique item. :param transactions: List[Tuple[str, int]], a list of transactions where each transaction is a tuple containing the item identifier and the quantity sold. :return: Dict[str, int], a dictionary where the keys are item identifiers and the values are the total quantities sold for those items. pass ``` # Input - `transactions` - A list of tuples where each tuple contains: - A string representing the item identifier. - An integer representing the quantity sold. # Output - Returns a dictionary where: - The keys are strings representing item identifiers. - The values are integers representing the total quantities sold for each item. # Example ```python # Example input transactions = [(\\"apple\\", 10), (\\"banana\\", 5), (\\"apple\\", 7), (\\"banana\\", 2), (\\"orange\\", 3)] # Running the algorithm result = calculate_total_quantities(transactions) print(result) # Example Output: {\\"apple\\": 17, \\"banana\\": 7, \\"orange\\": 3} ``` # Constraints - Assume the input list contains at least one transaction. - Each quantity in the transactions is a positive integer. # Notes - Focus on using efficient data structures to aggregate the quantities. - Handle cases where there are multiple transactions for the same item correctly.","solution":"from typing import List, Tuple, Dict def calculate_total_quantities(transactions: List[Tuple[str, int]]) -> Dict[str, int]: Calculate the total quantity sold for each unique item. :param transactions: List[Tuple[str, int]], a list of transactions where each transaction is a tuple containing the item identifier and the quantity sold. :return: Dict[str, int], a dictionary where the keys are item identifiers and the values are the total quantities sold for those items. totals = {} for item, quantity in transactions: if item in totals: totals[item] += quantity else: totals[item] = quantity return totals"},{"question":"# Cache-Compatible HTTP Server Implementation You have been assigned to create a cache-compatible HTTP server that can handle GET requests and make use of an internal caching mechanism to improve response performance for static resources. The server should correctly manage cache headers and serve resources from the cache when appropriate. **Function Signature:** ```python def cache_compatible_http_server(): ``` # Requirements: 1. Implement an HTTP server that listens on a specified port and handles GET requests for static files in a directory called `static`. 2. For each GET request, the server should: - Look up the requested file in the `static` directory. - Check if the file is already cached and, if so, verify if the cache is still valid based on the `If-Modified-Since` header. - Serve the cached version (with a 304 status code if the file is not modified) or read from the disk and cache it while setting appropriate headers (such as `Last-Modified`). 3. Ensure the server follows HTTP/1.1 specifications for handling cache headers. # Input: - GET requests from clients specifying a static file path and potentially including the `If-Modified-Since` header. # Output: - HTTP responses that include the appropriate cache control headers, and either a 200 status code with the file contents or a 304 status code indicating the file has not been modified since the date provided in the `If-Modified-Since` header. # Constraints: - The `static` directory is located at the root of the server\'s working directory. - The server should handle concurrent requests efficiently. - Use Python\'s `http.server` module where appropriate, and Python\'s `http.cookies` module to manage any session requirements. # Example: Assume the directory structure and environment setup is as follows. 1. Directory structure: ``` /static/index.html /static/style.css /static/script.js ``` 2. Running the server: ```python import os from http.server import HTTPServer, BaseHTTPRequestHandler # Run the server on localhost port 8080 server_address = (\'\', 8080) httpd = HTTPServer(server_address, YourCustomHandler) httpd.serve_forever() ``` 3. Fetching a file with caching: - First request: ```shell curl -v http://localhost:8080/static/index.html ``` Gets a 200 response with the content of `index.html` and a `Last-Modified` header. - Second request with caching: ```shell curl -v --header \\"If-Modified-Since: <Last-Modified value from previous response>\\" http://localhost:8080/static/index.html ``` Gets a 304 response if the file has not been modified since the provided date. Write a function `cache_compatible_http_server` that sets up and runs the HTTP server with caching mechanism as described. # Example Implementation Snippet: Below is an example showing a skeleton for such a server handler. ```python from http.server import SimpleHTTPRequestHandler, HTTPServer import os import time from email.utils import formatdate from datetime import datetime class CacheCompatibleHTTPRequestHandler(SimpleHTTPRequestHandler): def do_GET(self): filepath = self.translate_path(self.path) if not os.path.exists(filepath): self.send_error(404, \\"File not found\\") return last_modified = os.path.getmtime(filepath) last_modified_str = formatdate(last_modified, usegmt=True) if \'If-Modified-Since\' in self.headers: if_modified_since = self.headers[\'If-Modified-Since\'] if_modified_since_time = time.mktime(datetime.strptime(if_modified_since, \'%a, %d %b %Y %H:%M:%S GMT\').timetuple()) if last_modified <= if_modified_since_time: self.send_response(304) self.end_headers() return self.send_response(200) self.send_header(\'Last-Modified\', last_modified_str) self.end_headers() with open(filepath, \'rb\') as f: self.copyfile(f, self.wfile) def cache_compatible_http_server(): server_address = (\'\', 8080) httpd = HTTPServer(server_address, CacheCompatibleHTTPRequestHandler) print(\\"Serving on port 8080...\\") httpd.serve_forever() if __name__ == \\"__main__\\": cache_compatible_http_server() ``` This setup ensures that your server can handle HTTP GET requests and manage caching effectively, delivering better performance by reducing unnecessary file reads.","solution":"from http.server import SimpleHTTPRequestHandler, HTTPServer import os import time from email.utils import formatdate from datetime import datetime class CacheCompatibleHTTPRequestHandler(SimpleHTTPRequestHandler): def do_GET(self): filepath = self.translate_path(self.path) if not os.path.exists(filepath): self.send_error(404, \\"File not found\\") return last_modified = os.path.getmtime(filepath) last_modified_str = formatdate(last_modified, usegmt=True) if \'If-Modified-Since\' in self.headers: if_modified_since = self.headers[\'If-Modified-Since\'] try: if_modified_since_time = time.mktime(datetime.strptime(if_modified_since, \'%a, %d %b %Y %H:%M:%S GMT\').timetuple()) except ValueError: if_modified_since_time = 0 if last_modified <= if_modified_since_time: self.send_response(304) self.end_headers() return self.send_response(200) self.send_header(\'Last-Modified\', last_modified_str) self.end_headers() with open(filepath, \'rb\') as file: self.copyfile(file, self.wfile) def cache_compatible_http_server(): server_address = (\'\', 8080) httpd = HTTPServer(server_address, CacheCompatibleHTTPRequestHandler) print(\\"Serving on port 8080...\\") httpd.serve_forever() if __name__ == \\"__main__\\": cache_compatible_http_server()"},{"question":"# Question: Create a function `transform_to_roman` that converts a given integer to its corresponding Roman numeral representation. The function should handle values from 1 to 3999. # Objective: Write a Python function that accurately translates decimal integers within the specified range into their Roman numeral equivalents, in accordance with standard Roman numeral conventions. # Requirements: 1. **Input**: An integer `num`, such that `1 <= num <= 3999`. 2. **Output**: A string representing the Roman numeral equivalent of the integer. 3. **Constraints**: * The function should raise a `ValueError` with a clear message if the input is outside the specified range. # Example: ```python def transform_to_roman(num: int) -> str: Convert an integer to its Roman numeral representation. Args: - num: An integer (1 <= num <= 3999). Returns: - A string representing the Roman numeral of the given integer. Raises: - ValueError: If the number is outside the range 1 to 3999. Example: >>> transform_to_roman(4) \'IV\' >>> transform_to_roman(3999) \'MMMCMXCIX\' >>> transform_to_roman(0) ValueError: The number must be between 1 and 3999. pass # Your code here ``` # Instructions: 1. Implement the function `transform_to_roman` to convert the given integer to a Roman numeral string. 2. Use standard Roman numeral symbols (`I`, `V`, `X`, `L`, `C`, `D`, `M`) as usual, with the appropriate subtractive combinations (`IV`, `IX`, `XL`, `XC`, `CD`, `CM`). 3. Ensure the function handles all valid integers within the range 1 to 3999 inclusively. 4. Raise a `ValueError` with the message \\"The number must be between 1 and 3999.\\" for inputs outside the specified range. 5. Verify function output with various test cases to ensure accuracy.","solution":"def transform_to_roman(num: int) -> str: Convert an integer to its Roman numeral representation. Args: - num: An integer (1 <= num <= 3999). Returns: - A string representing the Roman numeral of the given integer. Raises: - ValueError: If the number is outside the range 1 to 3999. if not (1 <= num <= 3999): raise ValueError(\\"The number must be between 1 and 3999.\\") value_mappings = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] roman_numeral = [] for value, numeral in value_mappings: while num >= value: roman_numeral.append(numeral) num -= value return \\"\\".join(roman_numeral)"},{"question":"# Sort Large File of Integers You are given a text file containing a list of integers. Each integer is on a new line. The file is too large to fit into memory all at once. Your task is to sort the integers in ascending order and write them to a new file in a memory-efficient manner. # Requirements: 1. Write a function `sort_large_file(input_filename: str, output_filename: str) -> None` which takes the filename of the unsorted integers and the filename where the sorted integers should be written. 2. Use an external sorting algorithm (e.g., merge sort) to handle the sorting in a memory-efficient way. 3. Ensure that the output file contains the sorted integers, each on a new line. # Input: - `input_filename`: A string representing the path to the file containing the unsorted list of integers. - `output_filename`: A string representing the path to the file where the sorted integers should be written. # Output: - None. The sorted integers should be written directly to `output_filename`. # Constraints: - The file will have a length between 1 and (10^7) lines. - Each line in the file represents a single integer. - The integers in the file are within the range of ([-10^9, 10^9]). # Example: ```python # Example Usage: sort_large_file(\\"large_integers.txt\\", \\"sorted_large_integers.txt\\") # Note: The output file \\"sorted_large_integers.txt\\" should contain the sorted integers from \\"large_integers.txt\\". ``` # Additional Information: - Handling large files efficiently requires splitting the file into smaller chunks, sorting each chunk individually, and then merging the sorted chunks. - You may use any helper functions you find necessary to achieve the correct results.","solution":"import os import heapq def sort_large_file(input_filename: str, output_filename: str) -> None: Sorts a large file of integers in ascending order and writes the sorted integers to output_filename. Parameters: input_filename (str): The path to the input file containing unsorted integers. output_filename (str): The path to the output file to write the sorted integers. # Define the maximum number of integers to read into memory at once CHUNK_SIZE = 1000000 # 1 million integers per chunk def read_chunk(file, chunk_size): Reads a specific chunk of lines from a file chunk = [] for _ in range(chunk_size): line = file.readline() if not line: break chunk.append(int(line.strip())) return chunk def write_chunk(chunk, chunk_num): Writes a sorted chunk to a temporary file chunk.sort() chunk_filename = f\\"chunk_{chunk_num}.tmp\\" with open(chunk_filename, \'w\') as chunk_file: for num in chunk: chunk_file.write(f\\"{num}n\\") return chunk_filename # Step 1: Break the input file into sorted chunks chunk_filenames = [] with open(input_filename, \'r\') as infile: chunk_num = 0 while True: chunk = read_chunk(infile, CHUNK_SIZE) if not chunk: break chunk_filename = write_chunk(chunk, chunk_num) chunk_filenames.append(chunk_filename) chunk_num += 1 # Step 2: Merge sorted chunks with open(output_filename, \'w\') as outfile: min_heaps = [] files = [] # Initialize the heap and file pointers for chunk_filename in chunk_filenames: file = open(chunk_filename, \'r\') files.append(file) num = int(file.readline().strip()) heapq.heappush(min_heaps, (num, file)) while min_heaps: num, file = heapq.heappop(min_heaps) outfile.write(f\\"{num}n\\") line = file.readline().strip() if line: heapq.heappush(min_heaps, (int(line), file)) # Close all temporary files and remove them for file in files: file.close() for chunk_filename in chunk_filenames: os.remove(chunk_filename)"},{"question":"# Problem Statement: You are required to implement a function to determine if a given graph is bipartite. A bipartite graph is one where the set of vertices can be divided into two disjoint and independent subsets, such that no two vertices within the same subset are adjacent. The graph is represented by an adjacency list where each vertex is mapped to a list of neighboring vertices. # Function Signature: ```python def is_bipartite(graph: dict) -> bool: pass ``` # Input: - `graph`: A dictionary representing an undirected graph. The dictionary key is an integer vertex, and its value is a list of integers representing adjacent vertices. # Output: - Returns a boolean value: - `True` if the graph is bipartite. - `False` otherwise. # Constraints: - Vertices are represented as non-negative integers. - The input graph can be empty, but not `None`. - The adjacency list does not guarantee order. - No repeated edges or self-loops. # Example: ```plaintext graph = { 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2] } is_bipartite(graph) # Output: True graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } is_bipartite(graph) # Output: False ``` # Explanation: The function should use a BFS or DFS-based approach to try and color the graph with two colors. If it finds a conflict (i.e., two adjacent vertices having the same color), then the graph is not bipartite, and the function returns `False`. If it successfully colors the graph without conflicts, it returns `True`. # Other Considerations: - Handle disconnected graph components by checking each component. - Ensure the function can handle edge cases like an empty graph or graph with a single vertex.","solution":"def is_bipartite(graph: dict) -> bool: color = {} def bfs(start): queue = [start] color[start] = 0 while queue: node = queue.pop(0) for neighbor in graph[node]: if neighbor not in color: # Assign alternate color to the neighbor color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # If the neighbor has the same color, it\'s not bipartite return False return True for node in graph: if node not in color: if not bfs(node): return False return True"},{"question":"# Convert Temperature from Fahrenheit to Celsius In a weather application, you need to convert temperature readings from Fahrenheit to Celsius. The formula to convert temperatures from Fahrenheit to Celsius is: [ C = frac{5}{9} (F - 32) ] where: * `C` is the temperature in Celsius. * `F` is the temperature in Fahrenheit. Write a function `fahrenheit_to_celsius(fahrenheit: float) -> float` that takes the temperature in Fahrenheit and returns the temperature in Celsius. **Input:** * `fahrenheit` (float): The temperature in Fahrenheit. **Output:** * Return a float representing the temperature in Celsius. **Constraints:** * If the temperature is below absolute zero in Fahrenheit (-459.67), raise a `ValueError` with the message \\"Temperature below absolute zero is not possible\\". # Example: ```python >>> fahrenheit_to_celsius(32) 0.0 >>> fahrenheit_to_celsius(212) 100.0 >>> fahrenheit_to_celsius(0) -17.7778 >>> fahrenheit_to_celsius(-40) -40.0 >>> fahrenheit_to_celsius(-500) Traceback (most recent call last): ... ValueError: Temperature below absolute zero is not possible ``` *Note: The function may be tested using a Python testing library to validate correctness.*","solution":"def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts temperature from Fahrenheit to Celsius. Args: fahrenheit (float): The temperature in Fahrenheit. Returns: float: The temperature in Celsius. Raises: ValueError: If the temperature is below absolute zero. ABSOLUTE_ZERO_F = -459.67 if fahrenheit < ABSOLUTE_ZERO_F: raise ValueError(\\"Temperature below absolute zero is not possible\\") celsius = (5.0 / 9.0) * (fahrenheit - 32) return round(celsius, 4)"},{"question":"# Coding Assessment Question **Context:** You are developing a lightweight command-line utility for system administrators to manage user access to files based on predefined permissions. The utility reads a set of commands and applies the corresponding actions, altering the access permissions for different users on specific files. Permissions can be `read`, `write`, or `execute`. **Function Specification:** - **Function Name**: `manage_permissions` - **Input**: - `commands` (List[Tuple[str, str, str]]): A list of tuples where each tuple represents a command in the format (`operation`, `username`, `filename`). `operation` can be `grant` or `revoke`, and `username` is the name of the user, `filename` is the name of the file. - `permissions` (Set[str]): A set of permissions to be granted or revoked, where each permission is one of `read`, `write`, `execute`. - **Output**: - A dictionary where the keys are filenames, and the values are dictionaries themselves containing usernames as keys and a set of current permissions as values. **Input Constraints**: - `commands` is a non-empty list where each command is a tuple of three strings. - `permissions` is a set containing one or more of `read`, `write`, `execute`. - Filenames and usernames are guaranteed to be unique string identifiers consisting of alphanumeric characters. **Edge Cases to Consider**: - Commands that attempt to revoke permissions not currently held by the user on the file. - Commands that grant permissions already possessed by the user. **Examples**: ```python >>> manage_permissions( commands=[(\'grant\', \'alice\', \'file1\'), (\'grant\', \'bob\', \'file2\'), (\'revoke\', \'alice\', \'file1\')], permissions={\'read\', \'write\'} ) { \'file1\': {}, \'file2\': {\'bob\': {\'read\', \'write\'}} } >>> manage_permissions( commands=[(\'grant\', \'charlie\', \'file3\'), (\'grant\', \'alice\', \'file3\'), (\'revoke\', \'alice\', \'file3\')], permissions={\'execute\'} ) { \'file3\': {\'charlie\': {\'execute\'}} } >>> manage_permissions( commands=[(\'grant\', \'alice\', \'file1\'), (\'grant\', \'alice\', \'file2\'), (\'grant\', \'bob\', \'file1\')], permissions={\'read\'} ) { \'file1\': {\'alice\': {\'read\'}, \'bob\': {\'read\'}}, \'file2\': {\'alice\': {\'read\'}} } ``` **Implementation Notes**: - Make sure to handle edge cases where a user tries to revoke a permission they don\'t possess. - The solution should avoid unnecessary computational overhead and efficiently update the permissions based on the given commands. - You may assume that the initial state of permissions is empty for every file and user.","solution":"def manage_permissions(commands, permissions): Manages the file permissions based on commands to grant or revoke permissions for users on files. :param commands: List of tuples where each tuple represents a command in the format (operation, username, filename). operation can be \'grant\' or \'revoke\'. :param permissions: A set of permissions to be granted or revoked, where each permission is one of \'read\', \'write\', \'execute\'. :return: A dictionary where the keys are filenames, and the values are dictionaries themselves containing usernames as keys and a set of current permissions as values. result = {} for operation, username, filename in commands: if filename not in result: result[filename] = {} if username not in result[filename]: result[filename][username] = set() if operation == \'grant\': result[filename][username].update(permissions) elif operation == \'revoke\': result[filename][username].difference_update(permissions) if not result[filename][username]: del result[filename][username] return result"},{"question":"# Binary Search Tree (BST) Operations Context You need to utilize and extend a `BinarySearchTree` class to efficiently perform specific operations on a binary search tree. This question tests your understanding and ability to implement key BST functionalities. Problem Statement 1. **Find Kth Smallest Element**: Implement a method `kth_smallest(self, k: int) -> int` that returns the k-th smallest element in the BST. * **Input**: `k` is a positive integer representing the position (1-indexed). * **Output**: Return the k-th smallest element in the BST. If `k` is larger than the number of elements in the BST, return `None`. 2. **Delete Node**: Implement a method `delete(self, key: int)` that deletes the node with the given key from the BST. * **Input**: `key` is an integer representing the value to be deleted. * **Output**: Modify the tree in place. # Implementation Details * Implement the following two methods inside the `BinarySearchTree` class provided: ```python class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinarySearchTree: # Existing methods of the class... def kth_smallest(self, k: int) -> int: # Your implementation here def delete(self, key: int): # Your implementation here ``` # Example Usage ```python bst = BinarySearchTree() elements = [5, 3, 7, 2, 4, 6, 8] for el in elements: bst.insert(el) print(bst.kth_smallest(3)) # Should print: 4 (the 3rd smallest element) bst.delete(3) print(bst.kth_smallest(3)) # Should print: 5 (after deleting 3, the new 3rd smallest) ``` * **Constraints**: - Elements within the BST are unique. - The tree should handle cases where `k` is greater than the number of elements gracefully. * **Submission Requirements**: - The `kth_smallest` method should return the k-th smallest element or `None` if `k` is out of range. - The `delete` method should modify the tree in place and should not return anything. Explain your approach briefly after implementing the above methods.","solution":"class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int): if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert_recursive(node.right, key) def kth_smallest(self, k: int) -> int: # Perform in-order traversal def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) elements = inorder_traversal(self.root) if k <= 0 or k > len(elements): return None return elements[k - 1] def delete(self, key: int): def _delete_node(node, key): if node is None: return node if key < node.val: node.left = _delete_node(node.left, key) elif key > node.val: node.right = _delete_node(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.val = min_larger_node.val node.right = _delete_node(node.right, min_larger_node.val) return node self.root = _delete_node(self.root, key) def _find_min(self, node): while node.left is not None: node = node.left return node"},{"question":"# Question: Data Structure Implementation - Min Heap As a software engineer working on optimizing a scheduling system, you are required to implement a custom data structure that efficiently retrieves the minimum item. For this task, you are asked to implement a min-heap, which is a complete binary tree where the value of each node is less than or equal to the values of its children. Class: `MinHeap` You need to implement a class called `MinHeap` that supports the following operations: * `__init__(self)`: Constructor that initializes an empty heap. * `insert(self, key: int)`: Method to insert an integer into the heap. * `extract_min(self) -> int`: Method to remove and return the minimum element from the heap. If the heap is empty, raise an `IndexError`. * `heapify(self, arr: List[int])`: Method to build a heap from an unsorted list of integers. * `get_min(self) -> int`: Method to return the minimum element without removing it. If the heap is empty, raise an `IndexError`. # Constraints * All input values must be of type `int`. * Handle edge cases, such as attempts to extract from or access the minimum element of an empty heap. # Examples ```python # Create a min heap min_heap = MinHeap() # Insert elements min_heap.insert(3) min_heap.insert(1) min_heap.insert(6) min_heap.insert(5) min_heap.insert(2) min_heap.insert(4) # Extract the minimum element print(min_heap.extract_min()) # 1 # Get the current minimum without removal print(min_heap.get_min()) # 2 # Build a heap from an array min_heap.heapify([10, 20, 15, 30, 40]) print(min_heap.get_min()) # 10 ``` # Requirements Your class should: 1. Implement efficient heap operations with a time complexity of O(log n) for insertion and extraction. 2. Provide robust error handling for edge cases. 3. Ensure that the heap properties are maintained after each operation. 4. Raise appropriate exceptions for invalid operations. Start implementing the `MinHeap` class and thoroughly test all functionality to ensure accuracy and robustness. Good luck!","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, key: int): self.heap.append(key) self._bubble_up(len(self.heap) - 1) def extract_min(self) -> int: if not self.heap: raise IndexError(\\"extract_min from empty heap\\") min_elem = self.heap[0] last_elem = self.heap.pop() if self.heap: self.heap[0] = last_elem self._bubble_down(0) return min_elem def heapify(self, arr): self.heap = arr[:] for i in reversed(range(len(self.heap) // 2)): self._bubble_down(i) def get_min(self) -> int: if not self.heap: raise IndexError(\\"get_min from empty heap\\") return self.heap[0] def _bubble_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._bubble_up(parent) def _bubble_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._bubble_down(smallest)"},{"question":"# Problem Statement You are given a list of integers and your task is to determine if there exists a pair of distinct elements in the list such that one element is exactly two times the other. # Input * A list of integers `nums` where `0 <= len(nums) <= 10^5`. # Output * Return `True` if such a pair exists, otherwise return `False`. # Implementation Implement the following function: ```python def check_double(nums: list[int]) -> bool: Determine if there exists a pair of distinct elements where one element is exactly double the other. :param nums: List of integers :return: Boolean indicating if such a pair exists >>> check_double([10, 5, 3, 7, 14]) True >>> check_double([1, 2, 4, 8, 16, 32]) True >>> check_double([1, 3, 9, 27]) False >>> check_double([0, 0]) False >>> check_double([]) False pass ``` # Constraints * The list can be empty. * The list can contain up to `10^5` integers. # Edge Cases * A list with a single element must return `False`. * The list can contain zero. # Example ```python print(check_double([10, 5, 3, 7, 14])) # Output: True print(check_double([1, 2, 4, 8, 16, 32])) # Output: True print(check_double([1, 3, 9, 27])) # Output: False print(check_double([0, 0])) # Output: False print(check_double([])) # Output: False ```","solution":"def check_double(nums: list[int]) -> bool: Determine if there exists a pair of distinct elements where one element is exactly double the other. :param nums: List of integers :return: Boolean indicating if such a pair exists num_set = set(nums) for num in nums: if num != 0 and (num * 2 in num_set or num % 2 == 0 and num // 2 in num_set): return True return False"},{"question":"# Question Scenario: As a junior software engineer at a payment processing company, you are tasked with implementing a system that filters transactions. Each transaction has a unique identifier and a timestamp. Your team has decided to use a filtering mechanism that removes duplicate transactions based on their timestamps while maintaining the order of their first occurrence. Task: Write a Python function `filter_transactions` that filters out duplicate transactions based on their timestamps while preserving the order of their first occurrence. Function Signature: ```python def filter_transactions(transactions: list[tuple[int, int]]) -> list[tuple[int, int]]: ``` Input: - A list of tuples, `transactions`, where each tuple consists of an integer `transaction_id` and an integer `timestamp` (0 <= len(transactions) <= 10^3). Output: - A list of tuples representing the filtered transactions, retaining the order of their first occurrence. Constraints: - Do not use any built-in filter functions. - Ensure that the filtering mechanism is efficient. Performance Requirements: - The implemented solution should handle edge cases efficiently (e.g., empty list, list with only one transaction, list with all transactions having the same timestamp). Example Usage: ```python >>> filter_transactions([(1, 100), (2, 200), (3, 100), (4, 300)]) [(1, 100), (2, 200), (4, 300)] >>> filter_transactions([(1, 500), (2, 500), (3, 500)]) [(1, 500)] >>> filter_transactions([(1, 100), (2, 200), (3, 300)]) [(1, 100), (2, 200), (3, 300)] >>> filter_transactions([]) [] ```","solution":"def filter_transactions(transactions): Filters out duplicate transactions based on their timestamps while preserving the order of their first occurrence. Args: transactions (list[tuple[int, int]]): A list of tuples where each tuple consists of an integer transaction_id and an integer timestamp. Returns: list[tuple[int, int]]: A list of tuples representing the filtered transactions. seen_timestamps = set() filtered_transactions = [] for transaction_id, timestamp in transactions: if timestamp not in seen_timestamps: seen_timestamps.add(timestamp) filtered_transactions.append((transaction_id, timestamp)) return filtered_transactions"},{"question":"# Question: Finding the Shortest Path in a Weighted Graph You are provided with a weighted, undirected graph represented as an adjacency list. Your goal is to implement Dijkstra\'s algorithm to find the shortest path from a source node to a target node. Function Signature Write a function `shortest_path(n: int, edges: List[Tuple[int, int, int]], src: int, dest: int) -> List[int]` Input - `n`: An integer representing the total number of nodes in the graph, numbered from `0` to `n-1`. - `edges`: A list of tuples where each tuple `(u, v, w)` represents an edge between nodes `u` and `v` with a weight `w`. - `src`: An integer representing the source node. - `dest`: An integer representing the destination node. Output - A list of integers representing the shortest path from the source node to the destination node. If there are multiple shortest paths, return any of them. If no path exists, return an empty list. Constraints - The graph may not be connected, meaning there could be nodes that cannot reach certain other nodes. - All edge weights will be non-negative integers. Example ```python n = 5 edges = [(0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 1), (2, 3, 5), (3, 4, 3)] src = 0 dest = 4 print(shortest_path(n, edges, src, dest)) # Expected Output: A valid shortest path such as [0, 2, 1, 3, 4] ``` Notes - Use an efficient implementation for Dijkstra\'s algorithm, utilizing a priority queue to manage the nodes to be processed. - Pay attention to edge cases such as disconnected graphs, multiple shortest paths, and situations where the source and destination are the same.","solution":"import heapq from typing import List, Tuple, Dict def shortest_path(n: int, edges: List[Tuple[int, int, int]], src: int, dest: int) -> List[int]: def build_graph(n: int, edges: List[Tuple[int, int, int]]) -> Dict[int, List[Tuple[int, int]]]: graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) return graph def dijkstra(graph: Dict[int, List[Tuple[int, int]]], src: int, dest: int) -> List[int]: min_heap = [(0, src, [])] # (distance, current_node, path_taken) visited = set() while min_heap: current_dist, current_node, path = heapq.heappop(min_heap) if current_node in visited: continue visited.add(current_node) path = path + [current_node] if current_node == dest: return path for neighbor, weight in graph[current_node]: if neighbor not in visited: heapq.heappush(min_heap, (current_dist + weight, neighbor, path)) return [] graph = build_graph(n, edges) return dijkstra(graph, src, dest)"},{"question":"# **Matrix Search Algorithm** You are required to implement an efficient search algorithm for a sorted matrix. The matrix is sorted in such a way that each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Your task is to find a specific target value within the matrix and return its position (row and column indices). **Function Signature** ```python def search_sorted_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: pass ``` **Parameters** * `matrix` (List[List[int]]): A 2D list of integers where each row and column is sorted in ascending order. * `target` (int): The value to be searched within the matrix. **Returns** * Tuple[int, int]: A tuple containing the row and column indices of the target value. If the target is not found, return `(-1, -1)`. **Constraints and Assumptions** * The function will receive a non-empty matrix with dimensions `m x n`, where `1 <= m, n <= 300`. * The matrix will contain only integers. * The target may or may not be present in the matrix. **Performance Requirements** * Optimize for a time complexity of `O(m + n)` where `m` is the number of rows and `n` is the number of columns. * Use a space complexity of `O(1)`. **Example** ```python >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> target = 5 >>> search_sorted_matrix(matrix, target) (1, 1) >>> target = 20 >>> search_sorted_matrix(matrix, target) (-1, -1) ``` **Implementation Notes** 1. Start the search from the top-right corner of the matrix. 2. Compare the current element to the target: - If the current element equals the target, return its indices. - If the current element is greater than the target, move left. - If the current element is less than the target, move down. 3. Continue this process until either the element is found or the bounds of the matrix are exceeded. 4. If the target is not found, return `(-1, -1)`. **Your Task** Implement the function `search_sorted_matrix` as per the given signature and specifications.","solution":"from typing import List, Tuple def search_sorted_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: Searches the target value in a matrix sorted in ascending order both row-wise and column-wise. Args: matrix (List[List[int]]): 2D list of integers. target (int): The value to search for. Returns: Tuple[int, int]: Returns a tuple of the indices (row, col) if the target is found, otherwise returns (-1, -1). if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Rabin-Karp Algorithm for Substring Search You are given a text string and a pattern string. Your task is to implement the Rabin-Karp algorithm to search for the pattern within the text and return the starting indices of all occurrences of the pattern. # Task 1. Implement a function `hash_function` to compute the rolling hash of a string. 2. Implement the `rabin_karp` function to find all starting indices where the pattern occurs in the text. # Input - Two strings `text` and `pattern` representing the main text and the pattern to be searched. - An integer `prime` (default=101) which is used as the base for the rolling hash function. # Output A list of integers representing the starting indices of all occurrences of `pattern` in `text`, or an empty list if no occurrences are found. # Example ```python text = \\"abracadabra\\" pattern = \\"abra\\" prime = 101 ``` **Output**: ``` [0, 7] ``` # Constraints - The text and pattern consist only of lowercase English letters. - 1 ≤ len(text) ≤ 1000 - 1 ≤ len(pattern) ≤ 100 - The prime number used for hashing is a small prime number. # Notes 1. Use the given `hash_function` and `rabin_karp` templates to build your solution. 2. Ensure your solution handles edge cases like a pattern longer than the text. 3. Optimize for performance, given the constraints. ```python def hash_function(s: str, prime: int = 101) -> int: # Your implementation here def rabin_karp(text: str, pattern: str, prime: int = 101) -> list[int]: # Your implementation here if __name__ == \\"__main__\\": text = input(\\"Enter the text: \\") pattern = input(\\"Enter the pattern: \\") prime = int(input(\\"Enter the prime number: \\")) result = rabin_karp(text, pattern, prime) print(result) ``` # Remarks * Test the implementation with different test cases provided in the examples. * Consider and properly handle edge cases. * Ensure your implementation is efficient and accurate.","solution":"def hash_function(s: str, prime: int = 101) -> int: Compute the rolling hash of a string. Args: s (str): The input string. prime (int): The prime number used for hashing. Returns: int: The hash value of the string. hash_value = 0 for i in range(len(s)): hash_value = (hash_value * 256 + ord(s[i])) % prime return hash_value def rabin_karp(text: str, pattern: str, prime: int = 101) -> list[int]: Implement the Rabin-Karp algorithm to find all starting indices where the pattern occurs in the text. Args: text (str): The main text string. pattern (str): The pattern string to search for. prime (int): The prime number used for hashing. Returns: list[int]: A list of starting indices where the pattern occurs in the text. n = len(text) m = len(pattern) if m > n: return [] pattern_hash = hash_function(pattern, prime) current_hash = hash_function(text[:m], prime) result = [] for i in range(n - m + 1): if current_hash == pattern_hash and text[i:i+m] == pattern: result.append(i) if i < n - m: current_hash = (current_hash * 256 - ord(text[i]) * 256**m + ord(text[i + m])) % prime if current_hash < 0: current_hash += prime return result"},{"question":"# Coding Assessment Question **Objective**: Evaluate candidates\' ability to work with graph data structures, particularly in traversal and shortest path algorithms. **Background**: Graphs are a fundamental data structure used in various domains, including social networks, web link analysis, and transportation networks. One common problem in graph theory is finding the shortest path between nodes, which can be achieved using algorithms like Dijkstra\'s and the A* search algorithm. **Task**: 1. **Function Implementation**: Implement a function called `shortest_path` that: - Accepts a dictionary representing an unweighted, undirected graph and two nodes. - Finds and returns the shortest path between the two given nodes. 2. **Algorithm**: You may use Breadth-First Search (BFS) due to the unweighted nature of the graph. 3. **Edge Cases**: Handle possible edge cases such as: - The graph having no nodes or edges. - The start and end nodes being the same. - Nodes that are not connected by any path. **Input/Output**: - Input: `shortest_path(graph: dict, start: str, end: str) -> list` - `graph`: A dictionary where keys represent nodes and values are lists of adjacent nodes. - `start`: A string representing the starting node. - `end`: A string representing the destination node. - Output: Returns a list of nodes representing the shortest path from `start` to `end`, including both `start` and `end`. If no path exists, return an empty list. **Constraints**: - The graph will contain at most 1000 nodes. - The graph is unweighted and undirected. - Each list of adjacent nodes is not guaranteed to be sorted. # Example ```python def shortest_path(graph: dict, start: str, end: str) -> list: pass # Example Usage graph_example = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } assert shortest_path(graph_example, \'A\', \'F\') == [\'A\', \'C\', \'F\'] assert shortest_path(graph_example, \'A\', \'E\') == [\'A\', \'B\', \'E\'] assert shortest_path(graph_example, \'D\', \'C\') == [\'D\', \'B\', \'A\', \'C\'] assert shortest_path(graph_example, \'A\', \'A\') == [\'A\'] assert shortest_path(graph_example, \'A\', \'G\') == [] # Node \'G\' doesn\'t exist. ``` Provide a well-documented and efficient solution to ensure the function handles typical and edge cases effectively.","solution":"from collections import deque def shortest_path(graph: dict, start: str, end: str) -> list: Finds and returns the shortest path between the two given nodes in an unweighted, undirected graph. :param graph: dict, a dictionary representing the graph where keys are nodes and values are lists of neighbors. :param start: str, the starting node. :param end: str, the destination node. :return: list, the shortest path from start to end (inclusive), or an empty list if no path exists. if start not in graph or end not in graph: return [] if start == end: return [start] visited = set() queue = deque([(start, [start])]) while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph[current_node]: if neighbor == end: return path + [end] queue.append((neighbor, path + [neighbor])) return []"},{"question":"**Unit Conversion Tool** Context: You are tasked with building a utility tool for a software application that performs unit conversions based on user input. The tool needs to convert between different units of length, handling a variety of units such as meters, kilometers, miles, and feet. Task: Implement a class `UnitConverter` that provides methods to convert between different units of length: **Class**: `UnitConverter` - **Method**: `convert_to_meters(value: float, unit: str) -> float` - Converts a given length to its equivalent in meters. - **Input**: A float value representing the length and a string indicating the unit. The unit should be one of \'m\', \'km\', \'mi\', or \'ft\'. - **Output**: A float value representing the length converted to meters. - **Method**: `convert_from_meters(value: float, target_unit: str) -> float` - Converts a given length in meters to the specified target unit. - **Input**: A float value representing the length in meters and a string indicating the target unit. The target unit should be one of \'m\', \'km\', \'mi\', or \'ft\'. - **Output**: A float value representing the length converted from meters to the target unit. Conversion Factors: - 1 kilometer (km) = 1000 meters (m) - 1 mile (mi) = 1609.34 meters (m) - 1 foot (ft) = 0.3048 meters (m) Constraints: 1. Assume the input value is a positive float. 2. If the unit or target unit is not one of the accepted values (\'m\', \'km\', \'mi\', \'ft\'), the methods should raise a `ValueError` with a message indicating the invalid unit. Example: ```python >>> converter = UnitConverter() >>> converter.convert_to_meters(5, \'km\') 5000.0 >>> converter.convert_from_meters(5000, \'mi\') 3.1068559611866697 ``` Implement the class and methods following the given specifications to ensure accurate and reliable conversions.","solution":"class UnitConverter: def convert_to_meters(self, value: float, unit: str) -> float: Converts a given length to its equivalent in meters. Parameters: value (float): The length to be converted. unit (str): The unit of the length. Should be one of \'m\', \'km\', \'mi\', or \'ft\'. Returns: float: The length converted to meters. Raises: ValueError: If the unit is not one of the accepted values (\'m\', \'km\', \'mi\', \'ft\'). if unit == \'m\': return value elif unit == \'km\': return value * 1000 elif unit == \'mi\': return value * 1609.34 elif unit == \'ft\': return value * 0.3048 else: raise ValueError(\\"Invalid unit provided. Please use one of \'m\', \'km\', \'mi\', or \'ft\'\\") def convert_from_meters(self, value: float, target_unit: str) -> float: Converts a given length in meters to the specified target unit. Parameters: value (float): The length in meters to be converted. target_unit (str): The target unit. Should be one of \'m\', \'km\', \'mi\', or \'ft\'. Returns: float: The length converted from meters to the target unit. Raises: ValueError: If the target unit is not one of the accepted values (\'m\', \'km\', \'mi\', \'ft\'). if target_unit == \'m\': return value elif target_unit == \'km\': return value / 1000 elif target_unit == \'mi\': return value / 1609.34 elif target_unit == \'ft\': return value / 0.3048 else: raise ValueError(\\"Invalid target unit provided. Please use one of \'m\', \'km\', \'mi\', or \'ft\'\\")"},{"question":"# Question: You are given a binary tree represented by a list in level-order traversal format where `None` indicates missing nodes. Implement the function `check_balanced_binary_tree(tree: List[Optional[int]]) -> bool` that returns `True` if the binary tree is height-balanced, and `False` otherwise. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than one. Input: * `tree`: a list of integers and `None` values representing the binary tree in level-order. Output: * A boolean value indicating whether the tree is height-balanced or not. Constraints: * `1 <= len(tree) <= 1000` (maximum number of nodes) Example: ```python tree = [1, 2, 3, 4, 5, None, 7] assert check_balanced_binary_tree(tree) == True tree = [1, 2, 3, 4, None, None, 7, 8] assert check_balanced_binary_tree(tree) == False ``` Notes: * Use auxiliary functions if necessary to convert the list representation to a tree structure for processing. * Ensure efficient depth calculations to verify the balanced property. * Consider a bottom-up approach to check the balance of the tree, which can help optimize the solution.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def list_to_tree(lst: List[Optional[int]], index: int = 0) -> Optional[TreeNode]: if index >= len(lst) or lst[index] is None: return None node = TreeNode(lst[index]) node.left = list_to_tree(lst, 2 * index + 1) node.right = list_to_tree(lst, 2 * index + 2) return node def check_balanced_binary_tree(tree: List[Optional[int]]) -> bool: def check_balance(node: Optional[TreeNode]): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = max(left_height, right_height) + 1 if not left_balanced or not right_balanced: return current_height, False if abs(left_height - right_height) <= 1: return current_height, True else: return current_height, False root = list_to_tree(tree) _, is_balanced = check_balance(root) return is_balanced"},{"question":"# Problem: Cache Simulator with LRU Replacement Policy **Scenario**: You are tasked with developing a cache simulator for a web caching service. The simulator needs to implement a Least Recently Used (LRU) replacement policy, which discards the least recently accessed item when the cache capacity is reached. # Function to Implement: Implement a `Cache` class that simulates the LRU cache. The class should provide functionalities to `access` an item and to `evict` the least recently used item. # Inputs and Outputs: 1. **access(key: int, value: int)**: * **Input**: An integer `key` to identify the item and an integer `value` representing the item to be stored. * **Output**: Return the value of the key accessed. If the key is not in the cache, return -1. 2. **evict()**: * **Input**: This function does not take any arguments. * **Output**: This function does not return any value but should correctly evict the least recently accessed item when called. # Constraints: * The cache has a pre-defined maximum capacity, which is provided during initialization. * For `access`, if the cache exceeds its capacity, remove the least recently accessed item. * Ensure all operations are performed in O(1) time complexity. ```python class Cache: def __init__(self, capacity: int): Initialize the cache with the provided capacity. pass def access(self, key: int, value: int) -> int: Access the item with the provided key and value. If the key exists, update its value and make it the most recently used item. If the key does not exist, insert the item and make it the most recently used item. If the cache exceeds capacity, evict the least recently used item. pass def evict(self) -> None: Evict the least recently used item from the cache. pass ``` # Example: ```python # Initialize a cache with capacity of 2 cache = Cache(2) # Access items print(cache.access(1, 1)) # Output: 1 print(cache.access(2, 2)) # Output: 2 # Cache state: {1: 1, 2: 2} with 1 being least recently used # Access an existing item print(cache.access(1, 1)) # Output: 1 # Cache state: {2: 2, 1: 1} with 2 being least recently used # Add a new item (cache capacity exceeded) print(cache.access(3, 3)) # Output: 3 # Cache state: {1: 1, 3: 3} with 1 being least recently used (2 is evicted) # Access non-existing item print(cache.access(4, 4)) # Output: -1 # Cache state: {1: 1, 3: 3} ``` # Notes: * Implement an efficient data structure to manage the LRU policy. * Ensure cache access and eviction operations are performed within the constraints. This question aligns with the previously supplied question in terms of style, complexity, and scope, focusing on algorithm implementation and data structure operation while addressing practical web service challenges.","solution":"from collections import OrderedDict class Cache: def __init__(self, capacity: int): Initialize the cache with the provided capacity. self.capacity = capacity self.cache = OrderedDict() def access(self, key: int, value: int) -> int: Access the item with the provided key and value. If the key exists, update its value and make it the most recently used item. If the key does not exist, insert the item and make it the most recently used item. If the cache exceeds capacity, evict the least recently used item. if key in self.cache: self.cache.move_to_end(key) return self.cache[key] else: if len(self.cache) == self.capacity: self.evict() self.cache[key] = value return value def evict(self) -> None: Evict the least recently used item from the cache. self.cache.popitem(last=False)"},{"question":"# Question: Implement a Fibonacci Number Sequence Generator with Memoization **Context**: Fibonacci numbers form a sequence where each number is the sum of the two preceding ones, usually starting with 0 and 1. This classic problem gives insight into dynamic programming techniques, including recursion with memoization to optimize computations. **Task**: You are required to implement a memoized Fibonacci number generator function that computes the nth Fibonacci number efficiently using a top-down dynamic programming approach. **Function Signature and Inputs**: ```python from typing import Dict def fibonacci_memoized(n: int, memo: Dict[int, int] = {}) -> int: ... ``` **Input Description**: * `n`: An integer n (0 ≤ n ≤ 10^6) representing the position in the Fibonacci sequence for which to compute the corresponding Fibonacci number. * `memo`: A dictionary (optional) used to store previously computed Fibonacci numbers to avoid redundant calculations. **Output Description**: * Return an integer representing the nth Fibonacci number. **Constraints**: * The function should be able to compute the Fibonacci number efficiently, even for large values of n. * Utilize memoization to store and reuse previously computed results. * Handle the base cases for the first two Fibonacci numbers (n=0 and n=1). **Example Usage**: ```python print(fibonacci_memoized(10)) # Outputs 55 print(fibonacci_memoized(50)) # Outputs 12586269025 print(fibonacci_memoized(100)) # Outputs 354224848179261915075 ``` **Additional Notes**: - The function should return correct results even if called multiple times with increasing or decreasing values of n. - Ensure efficient performance by leveraging memoization properly.","solution":"from typing import Dict def fibonacci_memoized(n: int, memo: Dict[int, int] = {}) -> int: if n in memo: return memo[n] if n <= 1: return n memo[n] = fibonacci_memoized(n - 1, memo) + fibonacci_memoized(n - 2, memo) return memo[n]"},{"question":"**Scenario**: You are developing a delivery routing system for an e-commerce platform. The system needs to determine the optimal delivery route that minimizes the total travel distance while visiting a given set of locations starting and ending at the warehouse. **Problem Statement**: Write a function `optimal_delivery_route(locations: list[tuple[int, int]], warehouse: tuple[int, int]) -> list[tuple[int, int]]` that determines the order in which to visit all the given locations starting and ending at the warehouse to achieve the minimum total travel distance. # Input: 1. `locations`: A list of tuples where each tuple represents the coordinates (x, y) of a location. 2. `warehouse`: A tuple representing the coordinates (x, y) of the warehouse, where the delivery route starts and ends. # Output: A list of tuples representing the optimal order of locations (including the warehouse at the start and the end) to minimize the total travel distance. # Constraints: - The length of `locations` list is between 1 and 10, inclusive. - The coordinates for all points are integers. - The total number of points (including the warehouse) is at most 11. # Examples: ```python assert optimal_delivery_route([(1, 2), (3, 4), (5, 6)], (0, 0)) == [(0, 0), (1, 2), (3, 4), (5, 6), (0, 0)] assert optimal_delivery_route([(1, 1), (6, 6), (2, 2)], (0, 0)) == [(0, 0), (1, 1), (2, 2), (6, 6), (0, 0)] assert optimal_delivery_route([(2, 3), (1, 7), (6, 8)], (4, 1)) == [(4, 1), (2, 3), (1, 7), (6, 8), (4, 1)] assert optimal_delivery_route([], (0, 0)) == [(0, 0), (0, 0)] assert optimal_delivery_route([(5, 5)], (3, 3)) == [(3, 3), (5, 5), (3, 3)] ``` # Additional Notes: - Focus on finding the optimal solution, so applying algorithms like the Traveling Salesman Problem (TSP) can be beneficial. - Given the small input size, an exhaustive search or dynamic programming approach is acceptable. - Make sure to handle edge cases such as an empty list of locations gracefully.","solution":"import itertools import math def calculate_distance(p1, p2): Calculates the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_route_distance(route): Calculates the total distance of the given route returning to the start point. if len(route) < 2: return 0 distance = 0 for i in range(len(route) - 1): distance += calculate_distance(route[i], route[i + 1]) distance += calculate_distance(route[-1], route[0]) # Return to warehouse(0) return distance def optimal_delivery_route(locations, warehouse): Determines the optimal order in which to visit all the given locations starting and ending at the warehouse to minimize the total travel distance. if not locations: return [warehouse, warehouse] min_distance = float(\'inf\') min_route = [] for perm in itertools.permutations(locations): current_route = [warehouse] + list(perm) + [warehouse] current_distance = total_route_distance(current_route) if current_distance < min_distance: min_distance = current_distance min_route = current_route return min_route"},{"question":"# Question: Remove N-th Node from End of Linked List # Problem Statement: You are given the head of a linked list and an integer `n`. Write a function to remove the n-th node from the end of the list and return its head. Note that the linked list is 1-indexed from the end. # Function Signature: ```python def remove_nth_from_end(head: ListNode, n: int) -> ListNode: pass ``` # Input: - The function takes two arguments: - `head` - the head node of the singly linked list. - `n` - an integer representing which node, from the end of the list, to remove. - `head: ListNode` - the head node of a non-empty linked list. - `n: int` - an integer where 1 ≤ `n` ≤ length of the linked list. # Output: - The function should return the head of the modified linked list. - `ListNode` - the head node of the updated linked list after removing the n-th node from the end. # Constraints: - The number of nodes in the linked list is in the range `[1, 10^4]`. - The values of the nodes are in the range `[-10^6, 10^6]`. - The linked list is 1-indexed from the end. # Example: ```python # Example 1: # Input: head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) n = 2 # The linked list: 1 -> 2 -> 3 -> 4 -> 5 # After removing the 2nd node from the end, the linked list becomes: 1 -> 2 -> 3 -> 5 updated_head = remove_nth_from_end(head, n) # Expected Output: The head of the updated linked list with the structure shown above. # Example 2: # Input: head = ListNode(1) n = 1 # The linked list: 1 # After removing the 1st node from the end, the linked list becomes: (empty list) updated_head = remove_nth_from_end(head, n) # Expected Output: None (the linked list is now empty). ``` # Additional Notes: - The ListNode class is already defined and available for use. - You must handle edge cases like a linked list with a single node and removing the head node. - Aim to implement your solution with optimal time complexity. # ListNode Class Definition: ```python @dataclass class ListNode: value: int next: ListNode | None = None ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: # Create a dummy node to handle edge cases where we remove the head dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first pointer n+1 steps ahead so the gap between first and second is n nodes for _ in range(n + 1): first = first.next # Move the pointers until the first pointer reaches the end while first is not None: first = first.next second = second.next # Second\'s next is the node to be deleted, adjust the next pointer to skip it second.next = second.next.next return dummy.next"},{"question":"# Scenario You are hired to develop an application that manages and analyzes data about various fruits. One of the modules requires processing and interpreting fruit data shared in a custom CSV format before inserting it into a database. The custom CSV has its fields separated by a semicolon (`;`) instead of the usual comma (`,`). # Task Implement the `process_fruit_data` function that reads and processes fruit data from a CSV file with semicolon-separated values. # Function Signature ```python def process_fruit_data(file_path: str) -> list[dict]: pass ``` # Parameters * `file_path` (str): The file path to the CSV file containing the fruit data. # Output * Returns a list of dictionaries where each dictionary represents a single fruit and its properties. # Constraints * The CSV file will have the following columns: `Name`, `Color`, `Weight(g)`, `Price()`. * Each value in the CSV file will be properly formatted and non-empty. # Requirements 1. **File Reading**: * Open and read the file specified by the file path parameter. * Parse the semicolon-delimited values correctly. 2. **Data Processing**: * Convert each row into a dictionary with the keys being the column headers and the values being the corresponding cell values. * Convert numerical values (`Weight(g)` and `Price()`) from strings to their respective types (integer for weight, float for price). 3. **Output Formatting**: * Return a list of dictionaries that properly represent each recorded fruit\'s details. # Example Suppose the contents of a CSV file (`fruits.csv`) are: ``` Name;Color;Weight(g);Price() Apple;Red;150;0.50 Banana;Yellow;120;0.30 Cherry;Red;10;0.20 ``` ```python >>> file_path = \'path/to/fruits.csv\' >>> process_fruit_data(file_path) [{\'Name\': \'Apple\', \'Color\': \'Red\', \'Weight(g)\': 150, \'Price()\': 0.50}, {\'Name\': \'Banana\', \'Color\': \'Yellow\', \'Weight(g)\': 120, \'Price()\': 0.30}, {\'Name\': \'Cherry\', \'Color\': \'Red\', \'Weight(g)\': 10, \'Price()\': 0.20}] ``` # Notes Ensure to handle potential file I/O errors gracefully while reading the CSV file. The list returned should maintain the same order as the rows in the input file, excluding the header row.","solution":"import csv def process_fruit_data(file_path: str) -> list[dict]: Reads and processes fruit data from a CSV file with semicolon-separated values. Returns a list of dictionaries where each dictionary represents a single fruit and its properties. fruits = [] try: with open(file_path, mode=\'r\', encoding=\'utf-8\') as file: reader = csv.DictReader(file, delimiter=\';\') for row in reader: fruit = { \'Name\': row[\'Name\'], \'Color\': row[\'Color\'], \'Weight(g)\': int(row[\'Weight(g)\']), \'Price()\': float(row[\'Price()\']) } fruits.append(fruit) except FileNotFoundError: print(f\\"Error: The file {file_path} does not exist.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return fruits"},{"question":"# Problem Statement You are tasked with writing a function `unique_remove_sort` that takes a list of integers as an input, removes any duplicate values, and returns a sorted list of the unique integers in ascending order. # Input Format - A single list `collection` of integers where ( 0 leq text{length of collection} leq 10^4 ). - Each integer in the list is in the range ( -10^9 leq x leq 10^9 ). # Output Format - A single list of unique integers sorted in ascending order. # Constraints - The function should be efficient in handling large lists. - The solution should utilize built-in functionalities to ensure the operations are performed effectively while maintaining code readability. # Example Input ```python [3, 1, 2, 3, 4, 5, 1, 2] ``` Output ```python [1, 2, 3, 4, 5] ``` Input ```python [10, -1, 2, -1, 0, 2] ``` Output ```python [-1, 0, 2, 10] ``` Note The input list can have duplicate elements. Your implementation should remove these duplicates and then sort the unique values in ascending order.","solution":"def unique_remove_sort(collection): Takes a list of integers, removes duplicates, and returns a sorted list of unique integers. return sorted(set(collection))"},{"question":"# Coding Question You have been tasked with converting an integer to its equivalent Roman numeral representation. **Objective**: Create a function `int_to_roman(n: int) -> str` that takes a single integer `n` and returns its Roman numeral representation as a string. Input/Output Format * **Input**: - `n` (integer): A number (1 ≤ n ≤ 3999). * **Output**: - Return a string representing the Roman numeral equivalent of the input number. Constraints - 1 ≤ n ≤ 3999 **Background**: Roman numerals are represented by the following characters: - **M** 1000 - **CM** 900 - **D** 500 - **CD** 400 - **C** 100 - **XC** 90 - **L** 50 - **XL** 40 - **X** 10 - **IX** 9 - **V** 5 - **IV** 4 - **I** 1 **Performance Requirement**: - The solution should efficiently handle conversions within the given constraints. Example ```python >>> int_to_roman(9) \'IX\' >>> int_to_roman(40) \'XL\' >>> int_to_roman(3999) \'MMMCMXCIX\' >>> int_to_roman(2021) \'MMXXI\' ``` **Instructions**: - Implement the function `int_to_roman(n: int) -> str`. - Ensure the function adheres to input/output requirements and efficiently handles edge cases.","solution":"def int_to_roman(n: int) -> str: Convert an integer to a Roman numeral. Parameters: n (int): an integer (1 ≤ n ≤ 3999) Returns: str: Roman numeral representation of the input integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syb[i] n -= val[i] i += 1 return roman_num"},{"question":"# **Coding Assessment Question: Shortest Path with Bi-Directional Dijkstra\'s Algorithm** You are a software developer at a transportation logistics company tasked with optimizing route planning. Your goal is to implement a shortest path algorithm on a given undirected, weighted graph representing a network of cities and the distances between them. To enhance the efficiency of the standard Dijkstra\'s algorithm, you will implement a bi-directional version, which simultaneously runs standard Dijkstra\'s algorithm from both the source and target nodes until the shortest path is found. **Task**: Design and implement a function `bi_directional_dijkstra(graph: GraphUndirectedWeighted[T], start: T, target: T) -> tuple[int, list[T]]` that uses the bi-directional Dijkstra\'s algorithm to find the shortest path between `start` and `target` nodes in the given graph. **Input and Notes**: 1. The input parameter, `graph`, is an instance of the `GraphUndirectedWeighted`: ```python class GraphUndirectedWeighted(Generic[T]): def add_node(self, node: T) -> None: # Adds the node to the graph def add_edge(self, node1: T, node2: T, weight: int) -> None: # Adds an edge between node1 and node2 with the given weight ``` 2. Each node in the graph is unique, and the graph uses integer weights greater than zero. 3. Assume the graph is connected and non-empty. 4. If there are multiple shortest paths, return any one of them. **Output**: 1. `distance`: An integer representing the total distance of the shortest path from `start` to `target`. 2. `path`: A list of nodes representing the shortest path from `start` to `target`. **Constraints**: * **Performance**: The solution should be efficient in time and space complexity, optimized for larger graphs with up to 10^5 nodes and 10^6 edges. **Example**: ```python graph = GraphUndirectedWeighted() graph.add_edge(\\"A\\", \\"B\\", 3) graph.add_edge(\\"B\\", \\"C\\", 10) graph.add_edge(\\"C\\", \\"D\\", 5) graph.add_edge(\\"A\\", \\"C\\", 2) graph.add_edge(\\"B\\", \\"D\\", 4) distance, path = bi_directional_dijkstra(graph, \\"A\\", \\"D\\") assert distance == 6 assert path in [[\\"A\\", \\"C\\", \\"D\\"], [\\"A\\", \\"B\\", \\"D\\"]] ``` Implement the `bi_directional_dijkstra` function and ensure it provides correct and efficient results.","solution":"from heapq import heappush, heappop from typing import List, Tuple, Dict, Any, TypeVar, Generic T = TypeVar(\'T\') class GraphUndirectedWeighted(Generic[T]): def __init__(self): self.edges: Dict[T, List[Tuple[T, int]]] = {} def add_node(self, node: T) -> None: if node not in self.edges: self.edges[node] = [] def add_edge(self, node1: T, node2: T, weight: int) -> None: if node1 not in self.edges: self.edges[node1] = [] if node2 not in self.edges: self.edges[node2] = [] self.edges[node1].append((node2, weight)) self.edges[node2].append((node1, weight)) def bi_directional_dijkstra(graph: GraphUndirectedWeighted[T], start: T, target: T) -> Tuple[int, List[T]]: if start == target: return 0, [start] forward_queue = [] backward_queue = [] heappush(forward_queue, (0, start)) heappush(backward_queue, (0, target)) forward_distances = {start: 0} backward_distances = {target: 0} forward_parents = {start: None} backward_parents = {target: None} processed = set() total_distance = float(\'inf\') meet_node = None def dijkstra_step(queue, distances, parents, other_distances): nonlocal total_distance, meet_node if not queue: return current_distance, current_node = heappop(queue) for neighbor, weight in graph.edges[current_node]: distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance parents[neighbor] = current_node heappush(queue, (distance, neighbor)) if neighbor in other_distances: if distance + other_distances[neighbor] < total_distance: total_distance = distance + other_distances[neighbor] meet_node = neighbor while forward_queue or backward_queue: if forward_queue: dijkstra_step(forward_queue, forward_distances, forward_parents, backward_distances) if backward_queue: dijkstra_step(backward_queue, backward_distances, backward_parents, forward_distances) if meet_node: break if meet_node is None: return -1, [] path_forward = [] path_backward = [] node = meet_node while node is not None: path_forward.append(node) node = forward_parents[node] node = backward_parents[meet_node] while node is not None: path_backward.append(node) node = backward_parents[node] path_forward.reverse() path = path_forward + path_backward return total_distance, path"},{"question":"# Question: Enhanced Dictionary Operations Context: Consider a Dictionary (also known as a HashMap) that supports common operations such as insertion, deletion, and lookup. Additionally, it provides the capability to handle complex data manipulations and queries. Task: Extend the functionality of the existing dictionary class with the following new methods: 1. `count_keys_with_prefix(prefix)`: Count and return the number of keys in the dictionary that start with a given prefix. 2. `merge_dictionaries(other)`: Merge another dictionary into the current one. If a key exists in both dictionaries, the value from the other dictionary will override the current one. 3. `group_keys_by_length()`: Group keys by their length and return a dictionary where the keys are lengths and the values are lists of keys of that length. Implementation Details: - **count_keys_with_prefix(prefix)**: - Input: `prefix` (string prefix to search for). - Output: Integer representing the count of matching keys. - **merge_dictionaries(other)**: - Input: `other` (another dictionary of the same type). - Output: None (modifies the dictionary in place). - **group_keys_by_length()**: - Input: None. - Output: Dictionary with integer keys (lengths) and list of keys of that length as values. Constraints: - The dictionary will have at most 10,000 keys. - Keys are strings with a maximum length of 100 characters. - Values are integers. Example: ```python dictionary = Dictionary() dictionary.insert(\\"apple\\", 5) dictionary.insert(\\"appetizer\\", 10) dictionary.insert(\\"banana\\", 6) # Requirements print(dictionary.count_keys_with_prefix(\\"app\\")) # Output: 2 other_dictionary = Dictionary() other_dictionary.insert(\\"apple\\", 15) other_dictionary.insert(\\"berry\\", 7) dictionary.merge_dictionaries(other_dictionary) print(dictionary.lookup(\\"apple\\")) # Output: 15 print(dictionary.group_keys_by_length()) # Output: {5: [\\"apple\\"], 9: [\\"appetizer\\"], 6: [\\"banana\\"], 5: [\\"berry\\"]} ```","solution":"class Dictionary: def __init__(self): self.data = {} def insert(self, key, value): self.data[key] = value def delete(self, key): if key in self.data: del self.data[key] def lookup(self, key): return self.data.get(key, None) def count_keys_with_prefix(self, prefix): count = 0 for key in self.data: if key.startswith(prefix): count += 1 return count def merge_dictionaries(self, other): self.data.update(other.data) def group_keys_by_length(self): length_dict = {} for key in self.data: key_length = len(key) if key_length not in length_dict: length_dict[key_length] = [] length_dict[key_length].append(key) return length_dict"},{"question":"# Problem Statement You are designing a reservation system for a library where both books and e-books can be reserved. Each reservation lasts for a specific period, and we need to track the fees accumulated based on the type of book and the reservation duration. The fees are calculated as follows: - For physical books, the fee is 0.50 per day. - For e-books, the fee is 0.10 per day. Your task is to create a function `calculate_total_fee(reservation_type: str, duration: int) -> float` that calculates and returns the total fee for a reservation given the type of reservation and the duration in days. Make sure to handle edge cases and invalid inputs appropriately. Function Signature ```python def calculate_total_fee(reservation_type: str, duration: int) -> float: pass ``` Input and Output - **Input**: A string `reservation_type` which can be either \\"physical\\" or \\"ebook\\", and an integer `duration` representing the number of days the item is reserved. - **Output**: A float representing the total fee in dollars. Constraints - `reservation_type` will be either \\"physical\\" or \\"ebook\\". - `duration` will be a non-negative integer. Requirements - If `reservation_type` is not \\"physical\\" or \\"ebook\\", raise a ValueError with an appropriate message. - If `duration` is negative, raise a ValueError with an appropriate message. - Ensure that the calculation works correctly for valid inputs. # Examples ```python >>> calculate_total_fee(\\"physical\\", 10) 5.0 >>> calculate_total_fee(\\"ebook\\", 5) 0.5 >>> calculate_total_fee(\\"physical\\", 0) 0.0 >>> calculate_total_fee(\\"ebook\\", 20) 2.0 >>> calculate_total_fee(\\"audio\\", 10) Traceback (most recent call last): ... ValueError: Invalid reservation type >>> calculate_total_fee(\\"physical\\", -5) Traceback (most recent call last): ... ValueError: Duration cannot be negative ``` Validate the function with the provided examples and ensure that the function adheres to the specifications outlined above.","solution":"def calculate_total_fee(reservation_type: str, duration: int) -> float: Calculates the total fee for a reservation given the type of reservation and the duration in days. :param reservation_type: str, type of reservation (\\"physical\\" or \\"ebook\\") :param duration: int, duration of reservation in days :return: float, total fee in dollars if reservation_type not in [\\"physical\\", \\"ebook\\"]: raise ValueError(\\"Invalid reservation type\\") if duration < 0: raise ValueError(\\"Duration cannot be negative\\") fee_per_day = 0.50 if reservation_type == \\"physical\\" else 0.10 return fee_per_day * duration"},{"question":"# Problem Statement: You are tasked with developing a utility for organizing strings. Given a string, you need to generate all possible permutations of its characters and return them in lexicographically sorted order. Write a function `sorted_permutations` that generates and returns a sorted list of all permutations of the input string. Function Signature: ```python def sorted_permutations(s: str) -> list: ``` Input: * `s` (str): A string consisting of lowercase English letters. (1 <= len(s) <= 8) Output: * `permutations` (list): A list of all permutations of the input string `s`, sorted in lexicographical order. Constraints: * The length of the input string will not exceed 8 characters. Example: ```python assert sorted_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert sorted_permutations(\\"a\\") == [\\"a\\"] assert sorted_permutations(\\"ab\\") == [\\"ab\\", \\"ba\\"] assert sorted_permutations(\\"aba\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] assert sorted_permutations(\\"xyz\\") == [\\"xyz\\", \\"xzy\\", \\"yxz\\", \\"yzx\\", \\"zxy\\", \\"zyx\\"] ``` # Evaluation Criteria: * **Correctness**: The function should generate and return all permutations of the input string in the correct sorted order. * **Performance**: The function should complete in a reasonable time frame for inputs up to the specified constraints. * **Code Quality**: Code should be well-documented, readable, and follow best practices. # Hints: 1. Consider using a recursive approach to generate permutations. 2. Use a sorting utility to ensure the permutations are returned in lexicographical order. 3. Handle edge cases such as single-character strings.","solution":"from itertools import permutations def sorted_permutations(s: str) -> list: Generates and returns a sorted list of all permutations of the input string. Args: s (str): A string consisting of lowercase English letters. (1 <= len(s) <= 8) Returns: list: A list of all permutations of the input string `s`, sorted in lexicographical order. all_permutations = set(permutations(s)) sorted_perm_list = sorted(\'\'.join(p) for p in all_permutations) return sorted_perm_list"},{"question":"# Task You are working on a data processing library and want to create a function `moving_average` that computes the moving average of an input sequence. The moving average is a widely used technique in time series analysis that helps smooth out short-term fluctuations and highlight longer-term trends. # Requirements 1. Implement the `moving_average` function. 2. Use numpy to optimize performance. 3. Handle edge cases, particularly with different input lengths and window sizes. 4. Provide appropriate error handling for invalid inputs. # Function Signature ```python def moving_average(sequence: np.ndarray, window_size: int) -> np.ndarray: Computes the moving average of the input sequence. Parameters: sequence (np.ndarray): The input array of numbers. window_size (int): The size of the moving window. Returns: np.ndarray: An array of the moving averages. Examples: >>> moving_average(np.array([1, 2, 3, 4, 5]), 3) array([2. , 3. , 4. ]) >>> moving_average(np.array([10, 20, 30, 40, 50, 60]), 4) array([25., 35., 45., 55.]) # Your implementation here ``` # Constraints - Ensure `sequence` is a numpy array before applying the function. Raise a `TypeError` if it isn\'t. - `window_size` should be an integer and greater than 0; raise a `ValueError` if it isn\'t. - Use numpy\'s vectorized operations for performance and avoid using loops. # Testing 1. Test the function with varying lengths of input sequences and window sizes. 2. Check the implementation with different types of sequences, including sequences with all identical values, increasing values, and random values. 3. Include unit tests to ensure that the moving average calculations are correct and handle edge cases, such as short sequences and large window sizes.","solution":"import numpy as np def moving_average(sequence: np.ndarray, window_size: int) -> np.ndarray: Computes the moving average of the input sequence. Parameters: sequence (np.ndarray): The input array of numbers. window_size (int): The size of the moving window. Returns: np.ndarray: An array of the moving averages. Raises: TypeError: If sequence is not a numpy array. ValueError: If window_size is not a positive integer. Examples: >>> moving_average(np.array([1, 2, 3, 4, 5]), 3) array([2. , 3. , 4. ]) >>> moving_average(np.array([10, 20, 30, 40, 50, 60]), 4) array([25., 35., 45., 55.]) if not isinstance(sequence, np.ndarray): raise TypeError(\\"The input sequence must be a numpy array.\\") if not isinstance(window_size, int) or window_size <= 0: raise ValueError(\\"The window size must be a positive integer.\\") if window_size > len(sequence): raise ValueError(\\"The window size must be less than or equal to the length of the sequence.\\") return np.convolve(sequence, np.ones(window_size)/window_size, mode=\'valid\')"},{"question":"# Problem Description Develop a function that verifies if a sequence of integers is a valid Gray Code sequence. In binary, a Gray Code sequence is an ordering of binary numbers such that two successive numbers differ in only one bit. # Function Definition Define a function `is_valid_gray_code_sequence(seq: List[int]) -> bool` that takes a list of integers and returns a boolean indicating if the sequence of integers represents a valid Gray Code sequence. # Input * **seq** (List[int]): A list of integers representing the binary sequence. # Output * **bool**: `True` if the sequence is a valid Gray Code sequence, `False` otherwise. # Constraints * Each integer in the sequence is a non-negative integer. * The length of the sequence must be a power of 2, and all numbers must have the same number of bits. # Examples Example 1: **Input**: ```python seq = [0, 1, 3, 2] ``` **Output**: ```python True ``` **Explanation**: The sequence [0, 1, 3, 2] is a valid Gray Code sequence in binary as: - 0 (000), 1 (001) differ by 1 bit, - 1 (001), 3 (011) differ by 1 bit, - 3 (011), 2 (010) differ by 1 bit. Example 2: **Input**: ```python seq = [0, 1, 2, 3] ``` **Output**: ```python False ``` **Explanation**: The sequence [0, 1, 2, 3] is not a valid Gray Code sequence because: - 0 (000), 1 (001) differ by 1 bit, - 1 (001), 2 (010) differ by 2 bits, which is invalid. # Notes - Ensure to handle edge cases such as empty sequences or sequences not having lengths that are powers of 2. - Optimize for efficiency while verifying bit differences to ensure faster validation. Implementation Details You may leverage the bitwise XOR operation to count the differing bits between successive integers in the sequence. Implement helper functions as necessary to maintain code clarity and reusability. **Please provide your implementation below:** ```python from typing import List def is_valid_gray_code_sequence(seq: List[int]) -> bool: def count_differing_bits(a: int, b: int) -> int: return bin(a ^ b).count(\'1\') n = len(seq) if (n & (n - 1)) != 0: # Check if the length of the sequence is a power of 2 return False for i in range(1, n): if count_differing_bits(seq[i-1], seq[i]) != 1: return False return True ```","solution":"from typing import List def is_valid_gray_code_sequence(seq: List[int]) -> bool: def count_differing_bits(a: int, b: int) -> int: return bin(a ^ b).count(\'1\') n = len(seq) if n == 0: return False # Cannot be empty if (n & (n - 1)) != 0: # Check if the length of the sequence is a power of 2 return False for i in range(1, n): if count_differing_bits(seq[i-1], seq[i]) != 1: return False return True"},{"question":"# Question Given a binary tree, your task is to find the value of the deepest node in the tree. If there are multiple deepest nodes, return the leftmost deepest node value. Implement the function `find_deepest_node(root: Optional[TreeNode]) -> int` that takes the root of the binary tree and returns the value of the deepest node. Function Signature ```python from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def find_deepest_node(root: Optional[TreeNode]) -> int: pass ``` # Input * `root`: A binary tree node (as defined in the TreeNode class) or None if the tree is empty. # Output * An integer, representing the value of the deepest node (bottom-most and leftmost if there are multiple deepest nodes) in the binary tree. # Examples ```python # Example 1 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root1.left.left = TreeNode(4) root1.left.right = TreeNode(5) root1.right.right = TreeNode(6) root1.right.right.left = TreeNode(7) assert find_deepest_node(root1) == 7 # Example 2 root2 = TreeNode(1) root2.left = TreeNode(2) root2.left.left = TreeNode(3) root2.left.left.left = TreeNode(4) assert find_deepest_node(root2) == 4 # Example 3 root3 = TreeNode(1) assert find_deepest_node(root3) == 1 # Example 4 root4 = None assert find_deepest_node(root4) == None # Handle empty tree case gracefully ``` # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * -1000 <= Node.val <= 1000. # Notes * The tree may be empty, return an appropriate value in such case. * Consider edge cases such as a tree with only one node.","solution":"from typing import Optional from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def find_deepest_node(root: Optional[TreeNode]) -> int: if not root: return None # or raise an appropriate exception queue = deque([root]) deepest_node_value = root.val while queue: current_level_size = len(queue) for i in range(current_level_size): node = queue.popleft() deepest_node_value = node.val # This will end up being the last node at the deepest level. if node.left: queue.append(node.left) if node.right: queue.append(node.right) return deepest_node_value"},{"question":"# Pathfinding in a Grid with Obstacles You are tasked with implementing a pathfinding algorithm in a 2D grid with obstacles. The goal is to find the shortest path from a starting point to an ending point, navigating around any obstacles. **Function Signature**: ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: ``` # Input * `grid` (List[List[int]]): A 2D list representing the grid where `0` indicates a free cell and `1` indicates an obstacle. * `start` (Tuple[int, int]): A tuple `(x, y)` representing the starting point in the grid. * `end` (Tuple[int, int]): A tuple `(x, y)` representing the ending point in the grid. # Output * Returns the length of the shortest path as an integer. If no path exists, returns `-1`. # Constraints * The grid will have at least one cell and at most 10000 cells (100x100 grid). * The start and end coordinates will always be within the bounds of the grid. * The start and end coordinates will always be free cells (i.e., `grid[start[0]][start[1]] == 0` and `grid[end[0]][end[1]] == 0`). # Example ```python >>> grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] >>> start = (0, 0) >>> end = (4, 4) >>> shortest_path(grid, start, end) 10 >>> grid = [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path(grid, start, end) 4 ``` # Additional Information Use a pathfinding algorithm such as Breadth-First Search (BFS) to handle this problem. BFS is suitable for unweighted grids and guarantees the shortest path in the presence of obstacles. The movement is allowed only in the four cardinal directions (up, down, left, right). Ensure that your solution handles edge cases like grids with no obstacles, grids completely filled with obstacles, or scenarios where no path exists from start to end.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Coding Question: Upcoming Holidays Information You are required to write a Python function that fetches and summarizes the next public holidays for a given country using a public holidays API. The API can return detailed information about upcoming public holidays for a specified country. # Function: `fetch_upcoming_holidays` Input: A `country_code` (string) representing the country\'s ISO 3166-1 alpha-2 code (e.g., \\"US\\" for the United States). Output: A list of dictionaries where each dictionary contains the details of an upcoming public holiday: ```python [ { \\"Date\\": str, # format \'YYYY-MM-DD\' \\"Local name\\": str, \\"Name\\": str, \\"Country\\": str, \\"Type\\": str }, ... ] ``` Constraints: 1. The `country_code` will consist of 2 uppercase alphabetical characters. 2. Ensure proper handling of the API\'s rate-limiting and network errors. 3. Optimize for minimal API calls. Note: - If no holidays are found, the function should return an empty list. - Use the actual API endpoint (replace `{country_code}` with the actual country code): `https://date.nager.at/Api/v2/NextPublicHolidaysWorldwide` - The function should handle any exceptions and return relevant error messages if the `country_code` is invalid or the request fails. # Example: ```python def fetch_upcoming_holidays(country_code: str) -> list: # Implement the function here pass # Running the function with specific country code should give results like: print(fetch_upcoming_holidays(\\"US\\")) # Expected Output [ { \\"Date\\": \\"2023-11-23\\", \\"Local name\\": \\"Thanksgiving\\", \\"Name\\": \\"Thanksgiving Day\\", \\"Country\\": \\"United States of America\\", \\"Type\\": \\"Public\\" }, { \\"Date\\": \\"2023-12-25\\", \\"Local name\\": \\"Christmas\\", \\"Name\\": \\"Christmas Day\\", \\"Country\\": \\"United States of America\\", \\"Type\\": \\"Public\\" } ] ``` Use the above analysis and the provided code snippets as a guide to develop the solution to the task.","solution":"import requests def fetch_upcoming_holidays(country_code: str) -> list: Fetches the next public holidays for a given country using Nager.Date API. Args: country_code (str): ISO 3166-1 alpha-2 country code. Returns: list: A list of dictionaries containing the next public holidays. url = \\"https://date.nager.at/Api/v2/NextPublicHolidaysWorldwide\\" try: response = requests.get(url) response.raise_for_status() holidays = response.json() result = [] for holiday in holidays: if holiday[\\"countryCode\\"] == country_code: result.append({ \\"Date\\": holiday[\\"date\\"], \\"Local name\\": holiday[\\"localName\\"], \\"Name\\": holiday[\\"name\\"], \\"Country\\": holiday[\\"country\\"], \\"Type\\": holiday[\\"holidayType\\"] }) return result except requests.exceptions.RequestException as e: print(f\\"An error occurred: {e}\\") return []"},{"question":"# Coding Question: Find the Two Largest Elements in an Array Objective: Write a function to find the two largest distinct elements in an array of integers. Ensure your solution is efficient and handles edge cases properly. Problem Statement: Create a function that accepts an array of integers and returns the two largest distinct elements. If the array does not contain at least two distinct elements, raise a `ValueError` indicating insufficient distinct elements. Implementation Details: 1. **Function**: `find_two_largest(arr: List[int]) -> Tuple[int, int]` - Input: An array of integers. - Output: A tuple containing the two largest distinct integers in the array. - Method: Implement the function using an efficient algorithm, keeping the time complexity in mind. Constraints: - Do not use built-in functions `max()` or `sort()`. - The input array is not guaranteed to be sorted. - If the array contains less than two distinct elements, raise a `ValueError` with the message \\"Insufficient distinct elements\\". Example: ```python find_two_largest([10, 5, 20, 8, 20]) # Returns: (20, 10) find_two_largest([5, 5]) # Raises ValueError: Insufficient distinct elements find_two_largest([-10, -15, -1, -20]) # Returns: (-1, -10) ``` Evaluation: Your implementation will be evaluated based on: - Correctness of logic. - Handling of edge cases. - Adherence to time and space complexity. Considerations: - Think critically about performance for large arrays. - Ensure your approach properly evaluates and returns distinct elements. Make sure your function meets the requirements and passes the given examples and edge cases.","solution":"from typing import List, Tuple def find_two_largest(arr: List[int]) -> Tuple[int, int]: if len(arr) < 2: raise ValueError(\\"Insufficient distinct elements\\") first_max, second_max = None, None for num in arr: if first_max is None or num > first_max: second_max = first_max first_max = num elif num != first_max and (second_max is None or num > second_max): second_max = num if second_max is None: raise ValueError(\\"Insufficient distinct elements\\") return (first_max, second_max)"},{"question":"# Code Exercise: Implement a function that, given a list of integers, returns the second largest number in the list. If the list has fewer than two unique numbers, the function should return `None`. # Function Signature ```python def second_largest(nums: List[int]) -> Optional[int]: ``` # Input - A list of integers `nums`, where 1 ≤ len(nums) ≤ 10,000. # Output - Return an integer representing the second largest number in the list, or `None` if there are fewer than two unique numbers. # Constraints - The list may contain both positive and negative integers, as well as duplicates. # Scenario Imagine you are developing an analytics tool that helps identify competitive statistics. One key feature needs to quickly find the second best score in a dataset, provided there are enough distinct scores to make a comparison. # Example ```python # Example usage: print(second_largest([4, 1, 7, 3, 7])) # Output: 4 print(second_largest([1, 1, 1, 1])) # Output: None ```","solution":"from typing import List, Optional def second_largest(nums: List[int]) -> Optional[int]: Returns the second largest number in the list or None if there are fewer than two unique numbers. unique_nums = set(nums) if len(unique_nums) < 2: return None sorted_nums = sorted(unique_nums, reverse=True) return sorted_nums[1]"},{"question":"# Scenario You are developing a feature for a document processing application that extracts meaningful keywords from a block of text. To streamline this task, you\'ll need to implement a function that identifies the single most frequently used word from the input text. This operation will help to generate summaries and indexes more efficiently. # Task Write a function `most_frequent_word(text: str) -> str` that determines and returns the word that appears the most frequently in the given text. # Input - A string `text` containing words and spaces (1 ≤ length of `text` ≤ 10,000). Words are separated by spaces and may include punctuation. # Output - Return a string representing the word that appears most frequently in the input text. If there are multiple words with the same highest frequency, return the one that appears first based on their first occurrence in the text. # Example ```python input: \\"This is a test. This test is only a test.\\" output: \\"test\\" input: \\"Hello world! Hello everyone. Hello you.\\" output: \\"Hello\\" input: \\"A quick brown fox jumps over the lazy dog.\\" output: \\"A\\" ``` # Constraints - The function should be case-insensitive (e.g., \\"Hello\\" and \\"hello\\" count as the same word). - Punctuation should be ignored when counting word frequencies. - The function should have a time complexity of O(n), where n is the length of the text, and avoid using excessive memory beyond necessary data structures. - Use primitive variables and basic data structures for processing. # Notes - Consider using regular expressions to clean the text and standardize it for accurate word matching and counting. - Be mindful of edge cases such as text with only one word or multiple equally frequent words.","solution":"import re from collections import defaultdict def most_frequent_word(text: str) -> str: Returns the most frequently used word from the given text. # Remove punctuation and lower the case of the text cleaned_text = re.sub(r\'[^ws]\', \'\', text).lower() words = cleaned_text.split() # Dictionary to count word frequencies word_count = defaultdict(int) # Count the frequency of each word for word in words: word_count[word] += 1 # Determine the most frequent word most_frequent = None max_frequency = 0 for word in words: if word_count[word] > max_frequency: most_frequent = word max_frequency = word_count[word] return most_frequent"},{"question":"# Scheduling Algorithm Evaluation Task You are tasked with simulating a simple round-robin scheduling algorithm for a set of processes with varying burst times. Implement the following function: 1. **round_robin_schedule**: This function should take a list of processes, each defined by a tuple containing its name and burst time, and simulate a round-robin scheduling algorithm with a fixed time quantum. The function should return a list of tuples indicating the order in which the processes were executed and the remaining burst time after each time quantum. * **Input**: - A list of tuples, each representing a process with a name (str) and burst time (int). - An integer representing the time quantum. * **Output**: A list of tuples, where each tuple contains the process name (str) and the remaining burst time (int) after each time quantum. * **Constraints**: - Ensure the function handles edge cases, such as processes with burst times less than the time quantum. - The function must correctly simulate the round-robin scheduling, visiting each process in a cyclic order until all processes are completed. # Example ```python # Example usage processes = [(\\"P1\\", 6), (\\"P2\\", 8), (\\"P3\\", 7), (\\"P4\\", 3)] time_quantum = 4 execution_order = round_robin_schedule(processes, time_quantum) print(execution_order) ``` Expected Output: ```python [(\\"P1\\", 2), (\\"P2\\", 4), (\\"P3\\", 3), (\\"P4\\", 0), (\\"P1\\", 0), (\\"P2\\", 0), (\\"P3\\", 0)] ``` # Notes - Assume the processes are provided in the order of their arrival time. - For processes that have burst times equal to or less than the time quantum, the remaining burst time should be zero after the time quantum. - Ensure efficient implementation to avoid unnecessary computations. - The output list should clearly show the process execution order and the remaining burst time after each process\'s execution. --- This question tests fundamental concepts of operating systems and scheduling algorithms, challenging the candidate to implement a practical and efficient scheduling strategy while handling various edge cases in process management.","solution":"def round_robin_schedule(processes, time_quantum): Simulates round-robin scheduling algorithm. :param processes: List of tuples, each representing a process with a name (str) and burst time (int). :param time_quantum: Integer representing the time quantum. :return: List of tuples indicating the order in which the processes were executed and the remaining burst time after each time quantum. execution_order = [] queue = processes[:] while queue: process_name, burst_time = queue.pop(0) if burst_time > time_quantum: execution_order.append((process_name, burst_time - time_quantum)) queue.append((process_name, burst_time - time_quantum)) else: execution_order.append((process_name, 0)) return execution_order"},{"question":"# Question: Implement a function `rotate_2d_matrix(matrix: List[List[int]], direction: str) -> List[List[int]]` that takes in a square matrix of integers and a direction indicating either a clockwise or counterclockwise rotation. The function should return a new matrix that represents the original matrix rotated 90 degrees in the given direction. # Input: - `matrix` (type `List[List[int]]`): A 2D list representing the square matrix of size `n x n`. - `direction` (type `str`): A string indicating the direction of rotation, either `\\"clockwise\\"` or `\\"counterclockwise\\"`. # Output: - A 2D list (type `List[List[int]]`): The resulting matrix after rotating the given matrix by 90 degrees in the specified direction. # Constraints: - The input matrix will always be a square matrix (i.e., the number of rows equals the number of columns). - Valid values for `direction` are `\\"clockwise\\"` and `\\"counterclockwise\\"`. # Examples: 1. Input: `matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]`, `direction = \\"clockwise\\"` Output: `[ [7, 4, 1], [8, 5, 2], [9, 6, 3] ]` Explanation: Rotating the matrix 90 degrees clockwise results in the new matrix. 2. Input: `matrix = [ [1, 2], [3, 4] ]`, `direction = \\"counterclockwise\\"` Output: `[ [2, 4], [1, 3] ]` Explanation: Rotating the matrix 90 degrees counterclockwise results in the new matrix. 3. Input: `matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]`, `direction = \\"clockwise\\"` Output: `[ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ]` Explanation: Rotating the matrix 90 degrees clockwise results in the new matrix. # Notes: - Ensure to handle both clockwise and counterclockwise rotations accurately. - If the input values do not meet the constraints, the function should raise appropriate exceptions.","solution":"from typing import List def rotate_2d_matrix(matrix: List[List[int]], direction: str) -> List[List[int]]: Rotates the given square matrix 90 degrees in the specified direction. Parameters: matrix (List[List[int]]): The square matrix to rotate. direction (str): The direction of rotation, either \\"clockwise\\" or \\"counterclockwise\\". Returns: List[List[int]]: The rotated matrix. if direction not in [\\"clockwise\\", \\"counterclockwise\\"]: raise ValueError(\\"direction must be either \'clockwise\' or \'counterclockwise\'\\") n = len(matrix) if n == 0 or any(len(row) != n for row in matrix): raise ValueError(\\"The input must be a non-empty square matrix\\") rotated_matrix = [[0] * n for _ in range(n)] if direction == \\"clockwise\\": for i in range(n): for j in range(n): rotated_matrix[j][n - i - 1] = matrix[i][j] else: # direction == \\"counterclockwise\\" for i in range(n): for j in range(n): rotated_matrix[n - j - 1][i] = matrix[i][j] return rotated_matrix"},{"question":"# Matrix Rotation Coding Assessment Your task is to implement a function that rotates a given `NxN` matrix by 90 degrees clockwise. The algorithm involves manipulating the matrix in place without using additional memory for another matrix. Function Signature: 1. `def rotate_matrix(matrix: list[list[int]]) -> None:` - **Input**: - `matrix`: a list of lists where each inner list represents a row of the matrix, all rows are of the same length and equal to the number of rows (i.e., square matrix). - **Output**: - None (the matrix should be modified in place) Constraints: - The input matrix will always be a square matrix (i.e., the number of rows equals the number of columns). - The size of the matrix will be at least 2x2 and at most 100x100. - The elements of the matrix will be integers. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Notes: - Ensure the function performs the rotation in place. - Think about breaking down the matrix rotation into manageable steps, possibly by rotating layers of the matrix. - Handle edge cases such as the smallest and largest matrix sizes efficiently.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise in place. Args: matrix (list[list[int]]): The NxN matrix to be rotated. Returns: None: The matrix is modified in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for row in matrix: row.reverse()"},{"question":"# Substring Frequency Analyzer You need to create a program that finds all unique substrings of a given length within a string and counts their frequencies. This will help in text analysis by identifying the repeated patterns within the text. Your function should account for: - The provided length of substrings. - Efficiently handling large input strings. Implementation Specifications Write a function `substring_frequency(text: str, length: int) -> dict[str, int]` that: 1. **Extracts Substrings**: - Input: A string `text`, and `length` as the desired length of substrings. - Output: A dictionary where keys are substrings of the specified length and values are their respective frequencies in the text. 2. **Edge Cases**: - If `length` is less than or equal to 0, return an empty dictionary. - If the length of `text` is less than `length`, return an empty dictionary. 3. **Constraints**: - The input `text` can be any string with letters, digits, spaces, and punctuation. - Efficiently handle input strings of up to 10^6 characters. Examples ```python >>> substring_frequency(\\"banana\\", 3) {\'ban\': 1, \'ana\': 2, \'nan\': 1} >>> substring_frequency(\\"banana\\", 2) {\'ba\': 1, \'an\': 2, \'na\': 2} >>> substring_frequency(\\"banana\\", 4) {\'bana\': 1, \'anan\': 1, \'nana\': 1} >>> substring_frequency(\\"banana\\", 7) {} >>> substring_frequency(\\"banana\\", 0) {} ```","solution":"def substring_frequency(text: str, length: int) -> dict[str, int]: Finds all unique substrings of a given length within a string and counts their frequencies. Parameters: - text (str): The input string to analyze. - length (int): The length of substrings to find. Returns: - dict: A dictionary where keys are substrings and values are their frequencies. if length <= 0 or len(text) < length: return {} freq_dict = {} for i in range(len(text) - length + 1): substring = text[i:i + length] if substring in freq_dict: freq_dict[substring] += 1 else: freq_dict[substring] = 1 return freq_dict"},{"question":"# Coding Assessment Question Scenario You are developing a scheduling application that needs to handle and process recurring events efficiently. The requirement is to keep track of recurring events, with each event having a start time, an end time, and a recurrence interval. You need to be able to query all events that are active within a given time range. Task Implement a class `RecurringEventScheduler` that supports adding recurring events and querying the active events within a given time range. # Class Definition ```python class RecurringEventScheduler: def __init__(self) -> None: # Initialize the class with necessary properties def add_event(self, start: int, end: int, interval: int) -> None: # Add a recurring event with specified start time, end time, and recurrence interval def query_active_events(self, time_start: int, time_end: int) -> List[Tuple[int, int]]: # Query all active events within the specified time range [time_start, time_end] ``` # Method Details * **`__init__(self) -> None`**: * Initializes the scheduler with necessary properties to store events. * **`add_event(self, start: int, end: int, interval: int) -> None`**: * Adds a recurring event that starts at `start`, ends at `end`, and repeats every `interval` time units. * **`query_active_events(self, time_start: int, time_end: int) -> List[Tuple[int, int]]`**: * Returns a list of tuples, each representing the time range `[event_start, event_end)` of all events active within the specified time range `[time_start, time_end)`. Each returned range should reflect the intervals that fall within the queried time span. # Constraints * `0 <= start < end <= 10^9` * `1 <= interval <= 10^9` * `0 <= time_start < time_end <= 10^9` # Output Format * Function method returns a list of tuples. Each tuple `(event_start, event_end)` represents the start and end times of events active within the queried range. # Example ```python scheduler = RecurringEventScheduler() scheduler.add_event(0, 5, 10) # Event occurs at intervals: [0, 5), [10, 15), [20, 25), ... assert scheduler.query_active_events(3, 13) == [(0, 5), (10, 13)] # The event spans [0, 5) and next interval is [10, 15) # Within time range [3, 13), it includes part of the interval [10, 15) ```","solution":"class RecurringEventScheduler: def __init__(self) -> None: self.events = [] def add_event(self, start: int, end: int, interval: int) -> None: self.events.append((start, end, interval)) def query_active_events(self, time_start: int, time_end: int): active_events = [] for start, end, interval in self.events: current_start = start while current_start < time_end: current_end = current_start + (end - start) if current_end > time_start: active_start = max(current_start, time_start) active_end = min(current_end, time_end) if active_start < active_end: active_events.append((active_start, active_end)) current_start += interval return active_events"},{"question":"**Image Compressor** You are asked to implement a function that compresses a given image using the k-means clustering algorithm to reduce the number of colors to \'k\'. Each pixel in the image will be replaced by the nearest of \'k\' colors determined by k-means, thereby reducing the image\'s color space and potentially its size. # Function Signature ```python def compress_image(input_image: list[list[tuple[int, int, int]]], k: int) -> list[list[tuple[int, int, int]]]: ``` # Input - **input_image**: A list of lists where each inner list represents a row of pixels in the image. Each pixel is a tuple of three integers representing the RGB color code, for example, (255, 0, 0) for red. - **k**: An integer representing the number of colors to which the image should be reduced using the k-means clustering algorithm. # Output - A list of lists representing the compressed image in the same format as the input, but with each pixel color mapped to one of \'k\' colors. # Constraints - The dimensions of the input image do not exceed (1000 times 1000) pixels. - ( 1 leq k leq 256 ) - Each RGB color component is an integer between 0 and 255, inclusive. # Example ```python input_image = [ [(255, 0, 0), (255, 255, 0), (0, 255, 0)], [(0, 255, 255), (0, 0, 255), (255, 0, 255)] ] k = 2 compressed_image = compress_image(input_image, k) print(compressed_image) ``` This should print a version of the input image where the colors are reduced to 2 clusters determined by the k-means algorithm. # Requirements 1. **Flatten the Image**: Create a flat list of all pixel values from the input image. 2. **K-means Clustering**: Implement the k-means clustering algorithm to find \'k\' representative colors. 3. **Map Colors**: Replace each pixel in the original image with its nearest centroid found in the k-means clustering process. 4. **Reconstruct Image**: Convert the modified flat list back into the original image dimensions. You are free to use any Python libraries to implement k-means, such as scikit-learn.","solution":"from sklearn.cluster import KMeans import numpy as np def compress_image(input_image, k): Compresses the image to k colors using k-means clustering. Parameters: input_image (list of list of tuple): Image represented as rows of pixels in RGB format. k (int): Number of colors to reduce the image to. Returns: list of list of tuple: Compressed image with each pixel replaced by the nearest of k colors. # Flatten the image into a list of pixels pixels = [pixel for row in input_image for pixel in row] # Convert the list of pixels to a numpy array pixels_array = np.array(pixels, dtype=np.float64) # Perform k-means clustering to find k colors kmeans = KMeans(n_clusters=k, random_state=0).fit(pixels_array) # Get the cluster centers (the k colors) cluster_centers = kmeans.cluster_centers_ # Get the labels for each pixel labels = kmeans.labels_ # Replace each pixel with its corresponding cluster center compressed_pixels = [tuple(map(int, cluster_centers[label])) for label in labels] # Reshape the flat list back into a 2D image compressed_image = [] index = 0 for row in input_image: compressed_image.append(compressed_pixels[index:index + len(row)]) index += len(row) return compressed_image"},{"question":"# Reverse a Linked List You are given the head of a singly linked list. Your task is to reverse the list and return the new head. Implement the function `reverse_linked_list(head: ListNode) -> ListNode` where `ListNode` is a node in the singly linked list, defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Input: - `head`: The first node in the linked list, or `None` if the list is empty. Output: - The new head of the reversed linked list. Constraints: - The length of the linked list is between 0 and 10^4. - The values in the linked list are integers in the range of [-10^5, 10^5]. # Examples: ```python def test_reverse_linked_list(): # Construct linked list 1 -> 2 -> 3 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) # Reverse linked list, expected 3 -> 2 -> 1 new_head = reverse_linked_list(head) assert new_head.val == 3 assert new_head.next.val == 2 assert new_head.next.next.val == 1 # Empty list case assert reverse_linked_list(None) is None # Single node list case single_node = ListNode(1) new_head = reverse_linked_list(single_node) assert new_head.val == 1 assert new_head.next is None print(\\"All tests passed.\\") if __name__ == \\"__main__\\": test_reverse_linked_list() ``` Explanation of the function\'s logic: 1. **Initialization**: Use three pointers: `prev` (initially `None`), `current` (initially pointing to the head), and `next_node`. 2. **Iteration**: Traverse through the linked list, reversing the direction of the `next` pointers until the end of the list is reached. 3. **Returning Result**: Once reversed, the `prev` pointer will point to the new head of the reversed list, which is then returned. The function should correctly handle edge cases like an empty list or a single-node list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The new head of the reversed linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Question Imagine you are given two lists representing the in-order and post-order traversals of a binary tree. Your task is to construct the original binary tree from these traversals. Write a class `TreeNode` and a function `build_tree(inorder: List[int], postorder: List[int]) -> TreeNode` that accepts: - `inorder`: A list of integers representing the in-order traversal of the binary tree. - `postorder`: A list of integers representing the post-order traversal of the binary tree. The function should return the root `TreeNode` of the reconstructed binary tree. A `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Example ```python inorder = [9, 3, 15, 20, 7] postorder = [9, 15, 7, 20, 3] root = build_tree(inorder, postorder) assert root.val == 3 assert root.left.val == 9 assert root.right.val == 20 assert root.right.left.val == 15 assert root.right.right.val == 7 ``` Constraints - Each node value is unique. - The number of nodes in the tree is between 1 and 5000. - `1 <= node.val <= 10^4` Notes - The in-order traversal of a binary tree visits nodes in the left subtree, the root node, and nodes in the right subtree. - The post-order traversal visits the left subtree, the right subtree, and the root node at last. - Utilize the properties of these traversal methods to develop a recursive strategy for tree reconstruction.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(inorder, postorder): if not inorder or not postorder: return None root_val = postorder.pop() root = TreeNode(root_val) inorder_index = inorder.index(root_val) root.right = build_tree(inorder[inorder_index + 1:], postorder) root.left = build_tree(inorder[:inorder_index], postorder) return root"},{"question":"# Question Create a Python function `caesar_cipher` that encrypts and decrypts text using the Caesar cipher technique. The function should support both left and right shifts determined by the key, and handle both uppercase and lowercase letters. Non-alphabetical characters should remain unchanged. # Specifications You are required to implement the function `caesar_cipher(text: str, key: int, direction: str) -> str`. The function should take a string `text`, an integer `key` for the shift amount, and a string `direction` to specify the shift direction (`\\"left\\"` for left, `\\"right\\"` for right). The function returns the resulting encrypted or decrypted text. # Constraints 1. `text` will be a string containing only printable ASCII characters. 2. `key` will be a non-negative integer. 3. `direction` will be either `\\"left\\"` or `\\"right\\"`. 4. A zero `key` or a shift equal to the length of the alphabet (26) should return the original text. # Input and Output Formats Input * `text`: str - The input text to be encrypted or decrypted (e.g., \\"Hello, World!\\"). * `key`: int - The shift key (e.g., 3). * `direction`: str - The shift direction, either `\\"left\\"` or `\\"right\\"` (e.g., \\"left\\"). Output * Returns a string representing the encrypted or decrypted text. # Sample Input and Output Example 1 **Input**: ```python text = \\"Hello, World!\\" key = 3 direction = \\"right\\" ``` **Output**: ```python \\"Khoor, Zruog!\\" ``` Example 2 **Input**: ```python text = \\"Khoor, Zruog!\\" key = 3 direction = \\"left\\" ``` **Output**: ```python \\"Hello, World!\\" ``` # Implementation Notes - Alphabet characters should be shifted correctly maintaining their case. - Non-alphabetical characters should remain unchanged in their positions. - Modular arithmetic can help wrap around the characters (\'z\' to \'a\' and \'a\' to \'z\'). # Skeleton Code ```python def caesar_cipher(text: str, key: int, direction: str) -> str: Encrypts or decrypts text using the Caesar cipher technique. Arguments: text (str): The input text to be processed. key (int): The shift key. direction (str): The shift direction, either \\"left\\" or \\"right\\". Returns: str: The resulting text after applying the caesar cipher. result = [] if direction == \\"left\\": key = -key for char in text: if char.isalpha(): shift = key % 26 if char.islower(): result.append(chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\'))) elif char.isupper(): result.append(chr((ord(char) - ord(\'A\') + shift) % 26 + ord(\'A\'))) else: result.append(char) return \'\'.join(result) # Test cases text_1 = \\"Hello, World!\\" key_1 = 3 direction_1 = \\"right\\" print(caesar_cipher(text_1, key_1, direction_1)) # Should return \\"Khoor, Zruog!\\" text_2 = \\"Khoor, Zruog!\\" key_2 = 3 direction_2 = \\"left\\" print(caesar_cipher(text_2, key_2, direction_2)) # Should return \\"Hello, World!\\" ```","solution":"def caesar_cipher(text: str, key: int, direction: str) -> str: Encrypts or decrypts text using the Caesar cipher technique. Arguments: text (str): The input text to be processed. key (int): The shift key. direction (str): The shift direction, either \\"left\\" or \\"right\\". Returns: str: The resulting text after applying the Caesar cipher. result = [] if direction == \\"left\\": key = -key for char in text: if char.isalpha(): shift = key % 26 if char.islower(): result.append(chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\'))) elif char.isupper(): result.append(chr((ord(char) - ord(\'A\') + shift) % 26 + ord(\'A\'))) else: result.append(char) return \'\'.join(result)"},{"question":"# **Coding Assessment Question** **Objective**: Your task is to develop an efficient data structure that maintains a dynamic set of integers while supporting the following operations efficiently: 1. Insert an integer into the set. 2. Delete an integer from the set. 3. Find the kth smallest element in the set. **Problem Statement**: Implement a class `DynamicIntegerSet` to manage the dynamic set with the specified operations. You need to ensure that the insert, delete, and kth smallest element operations are optimized for performance. **Function Signature**: ```python class DynamicIntegerSet: def __init__(self) -> None: def insert(self, val: int) -> None: def delete(self, val: int) -> None: def kth_smallest(self, k: int) -> int: ``` **Input Format**: - The `insert` function will take an integer `val` to add to the set. - The `delete` function will take an integer `val` to remove from the set. - The `kth_smallest` function will take an integer `k` and return the kth smallest element in the set. **Output Format**: - The `kth_smallest` function should return the kth smallest integer from the set. **Constraints**: - Assume all input integers for insertion, deletion, and kth smallest operations are valid and within the range of -10^6 to 10^6. - Assume `k` is always a valid integer that lies within the current size of the dynamic set. - Optimized performance for large number of operations. **Example Usage**: ```python ds = DynamicIntegerSet() ds.insert(3) ds.insert(1) ds.insert(2) ds.delete(1) print(ds.kth_smallest(2)) # Output should be 3 ``` **Additional Notes**: - Efficiently handle the dynamic updates to the set. - Consider utilizing balanced binary search trees, heaps, or other suitable data structures to achieve the required performance.","solution":"import bisect class DynamicIntegerSet: def __init__(self): self.data = [] def insert(self, val: int) -> None: bisect.insort(self.data, val) def delete(self, val: int) -> None: index = bisect.bisect_left(self.data, val) if index < len(self.data) and self.data[index] == val: self.data.pop(index) def kth_smallest(self, k: int) -> int: return self.data[k - 1]"},{"question":"# Coding Assessment Question **List Rotation** You are given a list of integers and a non-negative integer `k`. Your task is to rotate the list to the right by `k` positions. Rotating a list means that elements are shifted from their current position to the right, and the elements at the end of the list wrap around to the beginning. # Function Signature ```python def rotate_list(nums: List[int], k: int) -> List[int]: Rotate the list to the right by k positions. :param nums: List of integers to be rotated. :param k: Number of positions to rotate the list. :return: The rotated list. ``` # Input and Output - **Input**: A list of integers `nums`, and a non-negative integer `k`. - **Output**: A new list of integers representing the rotated list. # Example ```python # Example 1 assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] # Example 2 assert rotate_list([10, 20, 30, 40, 50], 3) == [30, 40, 50, 10, 20] # Example 3 assert rotate_list([7, 8, 9], 0) == [7, 8, 9] # Example 4 assert rotate_list([1, 2], 3) == [2, 1] ``` # Constraints - The elements of the list can be any valid integer. - The length of the list can range from 1 to 10⁴. - The non-negative integer `k` will be in the range from 0 to 10⁵. # Guidelines - Consider the effect of rotating the list by more than the length of the list. - Handle extreme values and edge cases, such as rotating by 0 and rotating an empty list. - Optimize your solution to handle large inputs efficiently. # Performance Requirements - Your solution should be optimized to run in linear time O(n), where n is the length of the list.","solution":"def rotate_list(nums, k): Rotate the list to the right by k positions. :param nums: List of integers to be rotated. :param k: Number of positions to rotate the list. :return: The rotated list. if not nums: return nums n = len(nums) k = k % n # In case k is greater than the length of the list return nums[-k:] + nums[:-k]"},{"question":"# Coding Assessment Question Scenario Imagine you are developing a utility for a library management system. The library needs a feature to reorganize books on the shelf based on their borrowing frequency. Each book is represented by its borrowing frequency, and the objective is to sort the books in descending order of frequency. However, books with the same frequency should maintain their original relative order. Task Write a function named `reorganize_books` which takes a list of tuples `books` representing book borrowing frequencies and returns a list of tuples sorted in the desired order while preserving the relative order of books with the same frequency. # Function Signature ```python def reorganize_books(books: list[tuple[str, int]]) -> list[tuple[str, int]]: ``` # Input * `books` - A list of tuples, each containing a string (book title) and an integer (borrowing frequency) (1 <= len(books) <= 10^4, 0 <= borrowing frequency <= 10^4). # Output * A list of tuples representing the books sorted by descending borrowing frequency while maintaining the relative order for books with the same frequency. # Constraints * Each book title in the provided list will be unique. * The borrowing frequency is a non-negative integer. * If the books list is empty, return an empty list. # Example ```python >>> reorganize_books([(\\"Harry Potter\\", 5), (\\"The Great Gatsby\\", 9), (\\"1984\\", 5), (\\"The Catcher in the Rye\\", 2)]) [(\'The Great Gatsby\', 9), (\'Harry Potter\', 5), (\'1984\', 5), (\'The Catcher in the Rye\', 2)] >>> reorganize_books([(\\"Book A\\", 0), (\\"Book B\\", 0)]) [(\'Book A\', 0), (\'Book B\', 0)] >>> reorganize_books([]) [] ``` Performance Requirements Your implementation should be efficient enough to handle the upper limits of the constraints effectively. Consider edge cases such as multiple books with the same borrowing frequency. Additionally, ensure that your function handles an empty list correctly by returning an empty list.","solution":"from typing import List, Tuple def reorganize_books(books: List[Tuple[str, int]]) -> List[Tuple[str, int]]: This function takes a list of books represented by their tuple (title, frequency) and returns the list sorted in descending order of frequency while maintaining the relative order of books with the same frequency. return sorted(books, key=lambda x: (-x[1], books.index(x)))"},{"question":"# Problem Statement: Create a script that emulates a library\'s book rental system. In this system, users can perform several operations such as adding a new book, renting out a book, returning a book, and checking the availability of a book. Each book in the library has a unique ID, title, author, and a status that indicates whether it is available for rent. Write a class `Library` that supports the following operations: 1. **add_book(book_id, title, author)**: - Adds a new book to the library with the given `book_id`, `title`, and `author`. - The book should be marked as available upon addition. - If a book with the same `book_id` already exists, raise a `ValueError` with an appropriate message. 2. **rent_book(book_id)**: - Rents out the book specified by `book_id` to a user. - If the book is not available (either already rented out or does not exist), raise a `ValueError` with an appropriate message. - Mark the book as rented out once the operation is successful. 3. **return_book(book_id)**: - Returns the book specified by `book_id` back to the library. - If the book does not exist or is not currently rented out, raise a `ValueError` with an appropriate message. - Mark the book as available once the operation is successful. 4. **check_availability(book_id)**: - Checks whether the book specified by `book_id` is available for rent. - Return `True` if the book is available and `False` otherwise. - If the book does not exist, raise a `ValueError` with an appropriate message. **Class Signature**: ```python class Library: def __init__(self): pass def add_book(self, book_id: int, title: str, author: str): pass def rent_book(self, book_id: int): pass def return_book(self, book_id: int): pass def check_availability(self, book_id: int) -> bool: pass ``` # Requirements: * Implement the `Library` class and its methods. * Ensure that the `library` maintains the integrity and correct status of each book. * Handle invalid operations with appropriate error messages via exceptions. * Maintain computational efficiency and robust handling of the library operations. # Example Usage: ```python >>> library = Library() >>> library.add_book(1, \\"1984\\", \\"George Orwell\\") >>> library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") >>> library.check_availability(1) True >>> library.rent_book(1) >>> library.check_availability(1) False >>> library.return_book(1) >>> library.check_availability(1) True >>> library.rent_book(3) Traceback (most recent call last): ... ValueError: Book with ID 3 does not exist. >>> library.return_book(2) Traceback (most recent call last): ... ValueError: Book with ID 2 is not rented out. ``` # Constraints: * Book IDs are guaranteed to be unique positive integers. * The length of the title and author strings is between 1 and 100 characters. * The library should handle a large number of books efficiently.","solution":"class Library: def __init__(self): self.books = {} # A dictionary to store book info with book_id as the key def add_book(self, book_id: int, title: str, author: str): if book_id in self.books: raise ValueError(f\\"Book with ID {book_id} already exists.\\") self.books[book_id] = {\'title\': title, \'author\': author, \'available\': True} def rent_book(self, book_id: int): if book_id not in self.books: raise ValueError(f\\"Book with ID {book_id} does not exist.\\") if not self.books[book_id][\'available\']: raise ValueError(f\\"Book with ID {book_id} is already rented out.\\") self.books[book_id][\'available\'] = False def return_book(self, book_id: int): if book_id not in self.books: raise ValueError(f\\"Book with ID {book_id} does not exist.\\") if self.books[book_id][\'available\']: raise ValueError(f\\"Book with ID {book_id} is not rented out.\\") self.books[book_id][\'available\'] = True def check_availability(self, book_id: int) -> bool: if book_id not in self.books: raise ValueError(f\\"Book with ID {book_id} does not exist.\\") return self.books[book_id][\'available\']"},{"question":"# Coding Assessment Question # Context A software development team is working on a text-based game that requires user input to create custom character profiles. Each character has distinct attributes like health, strength, defense, and agility. The team needs a function to validate and process the input data, ensuring the attributes fall within acceptable ranges and assigning default values when necessary. # Problem Statement Write a Python function `create_character_profile(raw_input)` that takes a dictionary representing raw user input for a character\'s attributes. The function should return a dictionary with validated attributes and appropriate default values. # Function Signature ```python def create_character_profile(raw_input: dict) -> dict: ``` # Input - `raw_input (dict)`: A dictionary containing user input for character attributes. The keys are strings representing attribute names, and the values are integers indicating the attribute values. The dictionary may include any combination of the following keys: - `health` - `strength` - `defense` - `agility` # Output - `profile (dict)`: A dictionary containing the validated character profile with the following keys: - `health` (int): The character\'s health, default is 100 if not provided or out of range (1-200). - `strength` (int): The character\'s strength, default is 10 if not provided or out of range (1-50). - `defense` (int): The character\'s defense, default is 5 if not provided or out of range (1-50). - `agility` (int): The character\'s agility, default is 15 if not provided or out of range (1-50). # Constraints - The input dictionary may contain none, some, or all of the attribute keys. - Attributes should be within their specified ranges; if not, apply the default values. # Performance Requirements - The implementation should handle invalid user inputs gracefully. - Efficiently validate and assign default values as needed. # Example Usage ```python raw_input = {\'health\': 120, \'strength\': 55, \'defense\': 3, \'agility\': 20} result = create_character_profile(raw_input) ``` # Expected Output ```python { \'health\': 120, \'strength\': 10, # Default applied since 55 is out of range. \'defense\': 3, \'agility\': 20 } ``` # Example Implementation ```python def create_character_profile(raw_input: dict) -> dict: default_values = { \'health\': 100, \'strength\': 10, \'defense\': 5, \'agility\': 15 } ranges = { \'health\': (1, 200), \'strength\': (1, 50), \'defense\': (1, 50), \'agility\': (1, 50) } profile = {} for attribute, default in default_values.items(): value = raw_input.get(attribute, default) min_val, max_val = ranges[attribute] if not (min_val <= value <= max_val): value = default profile[attribute] = value return profile ``` # Notes - This question involves dictionary manipulation, value checking, and default value assignment. - The question is designed to test the candidate\'s ability to handle user input validation and default value logic in Python.","solution":"def create_character_profile(raw_input: dict) -> dict: Validates and processes the input dictionary to create a character profile with default values when necessary. default_values = { \'health\': 100, \'strength\': 10, \'defense\': 5, \'agility\': 15 } ranges = { \'health\': (1, 200), \'strength\': (1, 50), \'defense\': (1, 50), \'agility\': (1, 50) } profile = {} for attribute, default in default_values.items(): value = raw_input.get(attribute, default) min_val, max_val = ranges[attribute] if not (min_val <= value <= max_val): value = default profile[attribute] = value return profile"},{"question":"Question # Context: You are given a list of strings and you need to determine if any of the words can be formed by rearranging the characters of another word from the same list. In other words, you need to find if there are any anagrams present in the list. # Task: Write a Python function `find_anagram_pairs(words) -> List[Tuple[str, str]]` that takes a list of strings and returns a list of tuples, where each tuple contains a pair of words that are anagrams of each other from the given list. # Input: - `words`: A list of strings, where each string is a word consisting of lowercase letters. # Output: - A list of tuples, where each tuple contains two words from the input list that are anagrams of each other. Each pair should be listed only once (order of the pairs does not matter). # Example: ```python def find_anagram_pairs(words) -> List[Tuple[str, str]]: pass # Your implementation here # Examples print(find_anagram_pairs([\'listen\', \'silent\', \'enlist\', \'abc\', \'bca\'])) # Expected output: [(\'listen\', \'silent\'), (\'listen\', \'enlist\'), (\'silent\', \'enlist\'), (\'abc\', \'bca\')] print(find_anagram_pairs([\'abc\', \'def\', \'ghi\'])) # Expected output: [] ``` # Requirements: - You need to implement a function to check if two words are anagrams. - Iterate through the list to find all pairs of anagrams. - Ensure that each pair is included only once. # Performance: - Optimize your solution for efficiency especially with longer lists. - Use appropriate data structures to simplify and speed up your solution.","solution":"from typing import List, Tuple def find_anagram_pairs(words: List[str]) -> List[Tuple[str, str]]: This function returns a list of tuples with each tuple containing pairs of anagrams from the input list. from collections import defaultdict # Dictionary to hold sorted word as key and list of words that are anagrams as value anagram_dict = defaultdict(list) for word in words: # Sort the word and use it as the key sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) # Extract pairs of anagrams anagram_pairs = [] for word_list in anagram_dict.values(): if len(word_list) > 1: for i in range(len(word_list)): for j in range(i + 1, len(word_list)): anagram_pairs.append((word_list[i], word_list[j])) return anagram_pairs"},{"question":"# Task: Validate and Format Date Strings Context: You are working on a data processing application that requires validation and formatting of date strings. The input date strings can come in various formats and may contain invalid dates. Your task is to validate these date strings and convert them to a uniform format. Problem: Create a function `validate_and_format_date` that takes a list of date strings as input and returns a list of validated and formatted date strings. The function should: - Validate the input date strings to check if they are in acceptable formats (MM/DD/YYYY, DD-MM-YYYY, or YYYY.MM.DD). - Convert all valid dates to the format YYYY-MM-DD. - Discard any invalid date strings. Requirements: - **Input**: A list of date strings in various formats. - **Output**: A list of validated date strings, formatted as YYYY-MM-DD. - **Constraints**: - Only accept date strings in the following formats: - MM/DD/YYYY - DD-MM-YYYY - YYYY.MM.DD - Discard dates that do not convert to valid calendar dates (e.g., 30-02-2020 is invalid as February never has 30 days). - Handle typical test cases, edge cases, and erroneous scenarios gracefully. Example: ```python def validate_and_format_date(date_strings): # Implement the function here print(validate_and_format_date([\\"12/31/2020\\", \\"31-12-2020\\", \\"2020.12.31\\", \\"02/30/2020\\"])) # Output: [\'2020-12-31\', \'2020-12-31\', \'2020-12-31\'] ``` Implement the `validate_and_format_date` function to handle the described validation and formatting.","solution":"from datetime import datetime def validate_and_format_date(date_strings): formats = [\\"%m/%d/%Y\\", \\"%d-%m-%Y\\", \\"%Y.%m.%d\\"] valid_dates = [] for date_string in date_strings: valid_date = None for fmt in formats: try: valid_date = datetime.strptime(date_string, fmt).date() break except ValueError: pass if valid_date: valid_dates.append(valid_date.strftime(\\"%Y-%m-%d\\")) return valid_dates"},{"question":"# Coding Assessment Question In this assessment, you need to enhance a basic file processing script to handle CSV files with varying delimiters and manage large file sizes efficiently. The exercise is designed to test your understanding of file I/O, string manipulation, and memory management in Python. Your Task 1. **Support Different Delimiters**: - Modify the script to dynamically detect and handle various delimiters (such as comma, semicolon, tab, and pipe) used in the CSV file. 2. **Memory-Efficient Large File Handling**: - Implement efficient read and write mechanisms that allow processing of large CSV files without consuming excessive memory. # Implementation Details Required Functions: 1. **`detect_delimiter(file_path: str) -> str`**: - Read a sample of the file and determine the delimiter based on the most frequent delimiter character. 2. **`process_large_csv(input_file_path: str, output_file_path: str)`**: - Read a large CSV file in chunks and write the processed data to another file, ensuring minimal memory usage. For each row, append a new column with the row number. 3. **`add_row_numbers(input_file_path: str, output_file_path: str, delimiter: str)`**: - Read the input file, adding a row number column to each row, and write to the output file using the detected delimiter. Constraints: - The CSV file can be up to 1GB in size. - Delimiters may include: comma (`,`), semicolon `;`, tab `t`, or pipe `|`. - The resulting output file should contain the original data plus an additional column for row numbers. Input/Output: - **Input**: - A file path to a CSV file (`large_file.csv`) that may contain up to 1GB of data. - **Output**: - A new CSV file (`processed_large_file.csv`) with the same data and an additional column indicating the row number. # Performance Requirements - The solution must handle files up to 1GB efficiently, ensuring that memory usage remains relatively constant. # Scenario Given a CSV file (`large_file.csv`) that could use various delimiters and contain up to 1GB of data, your goal is to implement functions that can detect the delimiter used, read and process the file in a memory-efficient way, and output a new CSV file with row numbers added. Example: ```python input_file_path = \'large_file.csv\' output_file_path = \'processed_large_file.csv\' delimiter = detect_delimiter(input_file_path) add_row_numbers(input_file_path, output_file_path, delimiter) ``` Original CSV (`large_file.csv`): ``` Name,Age,Country John Doe,28,USA Jane Smith,31,Canada ``` Processed CSV (`processed_large_file.csv`): ``` Row Number,Name,Age,Country 1,John Doe,28,USA 2,Jane Smith,31,Canada ```","solution":"import csv def detect_delimiter(file_path: str) -> str: Detect the delimiter used in the CSV file. It should be one of the following characters: comma, semicolon, tab, pipe. Args: - file_path (str): Path to the CSV file. Returns: - str: The detected delimiter. delimiters = [\',\', \';\', \'t\', \'|\'] delimiter_counts = {d: 0 for d in delimiters} with open(file_path, \'r\') as file: sample = file.read(4096) for delimiter in delimiters: delimiter_counts[delimiter] = sample.count(delimiter) return max(delimiters, key=lambda d: delimiter_counts[d]) def add_row_numbers(input_file_path: str, output_file_path: str, delimiter: str): Process the CSV file, add a \'Row Number\' column, and write the processed data to a new file. Args: - input_file_path (str): Path to the input CSV file. - output_file_path (str): Path to the output CSV file. - delimiter (str): The delimiter used in the CSV file. with open(input_file_path, \'r\') as infile, open(output_file_path, \'w\', newline=\'\') as outfile: reader = csv.reader(infile, delimiter=delimiter) writer = csv.writer(outfile, delimiter=delimiter) headers = next(reader) headers.insert(0, \'Row Number\') writer.writerow(headers) for index, row in enumerate(reader, start=1): row.insert(0, index) writer.writerow(row) def process_large_csv(input_file_path: str, output_file_path: str): Detect the delimiter of the CSV file, then process the file to add a \'Row Number\' column and write to the output file. Args: - input_file_path (str): Path to the input CSV file. - output_file_path (str): Path to the output CSV file. delimiter = detect_delimiter(input_file_path) add_row_numbers(input_file_path, output_file_path, delimiter)"},{"question":"# Interval Scheduling Maximization Objective You are to implement a function that solves the Interval Scheduling Maximization problem. Given a list of intervals where each interval represents the start and end time of a job, your task is to select the maximum number of non-overlapping intervals (jobs) that can be scheduled. Requirements 1. **Interval Structure**: Each interval is represented as a tuple with two integers (start, end), where `start` is the start time and `end` is the end time. 2. **Algorithm**: Implement an efficient algorithm to select the maximum number of non-overlapping intervals. 3. **Sorting Criteria**: Utilize proper sorting and greedy strategies to achieve the maximum number of non-overlapping intervals. Specifications 1. The list of intervals will have a length **N** (1 ≤ N ≤ 10^4). 2. Each interval\'s `start` and `end` will be integers such that `0 ≤ start < end ≤ 10^5`. Input & Output * **Function Signature**: ```python def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: ``` * `intervals` is the list of tuples, where each tuple represents an interval with start and end times. * **Return Value**: * The function should return the maximum number of non-overlapping intervals. Example ```python # Example usage intervals = [(1, 3), (2, 4), (3, 5), (7, 8)] print(max_non_overlapping_intervals(intervals)) # Output: 3 ``` Explanation In the example above, we can select the intervals (1, 3), (3, 5), and (7, 8), which are non-overlapping, so the function should return `3`. Implement the function `max_non_overlapping_intervals` so that it accurately calculates the maximum number of non-overlapping intervals from the given list using an efficient algorithm.","solution":"from typing import List, Tuple def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Calculates the maximum number of non-overlapping intervals from the given list. Args: intervals (List[Tuple[int, int]]): List of tuples, where each tuple contains start and end time of an interval. Returns: int: The maximum number of non-overlapping intervals. # Sort intervals by their end times intervals.sort(key=lambda x: x[1]) count = 0 end_time = 0 for interval in intervals: if interval[0] >= end_time: count += 1 end_time = interval[1] return count"},{"question":"# Coding Question: Matrix Multiplication with Sparse Matrices Background In many scientific and engineering applications, matrices can be very large but contain mostly zeros. These matrices are called sparse matrices. Efficiently multiplying sparse matrices is crucial to optimize computation and memory usage. Objective You are required to implement a function that multiplies two sparse matrices and returns the resulting matrix. Your function should take advantage of the sparse nature of the matrices to perform the multiplication efficiently. Function Signature ```python def sparse_matrix_multiply( mat1: List[List[int]], mat2: List[List[int]] ) -> List[List[int]]: ``` Input 1. **mat1**: A list of lists representing the first sparse matrix (m x n). * Constraints: 0 ≤ m, n ≤ 100 * Each element is either a 0 or a positive integer. 2. **mat2**: A list of lists representing the second sparse matrix (n x p). * Constraints: 0 ≤ n, p ≤ 100 * Each element is either a 0 or a positive integer. Output Return a list of lists representing the resulting sparse matrix (m x p) after multiplication. Examples ```python >>> mat1 = [ ... [1, 0, 0], ... [-1, 0, 3] ... ] >>> mat2 = [ ... [7, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> sparse_matrix_multiply(mat1, mat2) [[7, 0, 0], [-7, 0, 3]] >>> mat1 = [ ... [1, 2, 0], ... [0, 0, 0], ... [4, 0, 0] ... ] >>> mat2 = [ ... [0, 3], ... [0, 0], ... [2, 0] ... ] >>> sparse_matrix_multiply(mat1, mat2) [[0, 3], [0, 0], [0, 12]] >>> mat1 = [ ... [0, 0], ... [0, 0] ... ] >>> mat2 = [ ... [0, 0], ... [0, 0] ... ] >>> sparse_matrix_multiply(mat1, mat2) [[0, 0], [0, 0]] ``` Note * Use efficient data structures that suit sparse matrices. * Ensure to handle edge cases and constraints. * You may assume that matrix sizes are compatible for multiplication.","solution":"from typing import List def sparse_matrix_multiply(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: if not mat1 or not mat2 or not mat1[0] or not mat2[0]: return [[]] m, n = len(mat1), len(mat1[0]) p = len(mat2[0]) result = [[0 for _ in range(p)] for _ in range(m)] # Convert mat1 to a sparse representation sparse_mat1 = {} for i in range(m): for j in range(n): if mat1[i][j] != 0: if i not in sparse_mat1: sparse_mat1[i] = {} sparse_mat1[i][j] = mat1[i][j] # Convert mat2 to a sparse representation sparse_mat2 = {} for j in range(n): for k in range(p): if mat2[j][k] != 0: if j not in sparse_mat2: sparse_mat2[j] = {} sparse_mat2[j][k] = mat2[j][k] # Perform the multiplication for i in sparse_mat1: for j in sparse_mat1[i]: if j in sparse_mat2: for k in sparse_mat2[j]: result[i][k] += sparse_mat1[i][j] * sparse_mat2[j][k] return result"},{"question":"# Question You are given a matrix `n x m` containing distinct integer values. Implement a function that finds the peak element in the matrix. A peak element is defined as an element that is greater than or equal to its four neighbors (left, right, top, bottom). For elements on the boundary of the matrix, we consider only the valid neighbors. # Function Signature ```python def find_peak_element(matrix: List[List[int]]) -> Tuple[int, int]: ... ``` # Input * `matrix`: A list of lists of integers representing the `n x m` matrix. The matrix dimensions and values are such that: * `2 <= n, m <= 100` * Each integer value in the matrix is unique. # Output * Returns a tuple of two integers `(i, j)` which represents the row and column indices of the peak element. # Constraints * The matrix will have at least one peak element. * The solution must not exceed O(n * log(m) + m * log(n)) time complexity. # Example Find the peak element in the given matrix: ```python # Example 1 matrix = [ [10, 20, 15], [21, 30, 14], [7, 16, 32] ] assert find_peak_element(matrix) == (1, 1), \\"Test Case 1 Failed\\" # Example 2 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert find_peak_element(matrix) == (2, 2), \\"Test Case 2 Failed\\" print(\\"All test cases passed!\\") ``` # Notes - **Edge Cases**: Consider small matrices like 2x2 or 2x3 where the peak may be on the boundary. - **Error Handling**: Ensure your indices are managed correctly to avoid index out-of-bounds errors. # Hint - You can use a divide and conquer strategy to solve this problem efficiently.","solution":"from typing import List, Tuple def find_peak_element(matrix: List[List[int]]) -> Tuple[int, int]: def find_peak_in_column(matrix, start_row, end_row, mid_col): max_row = start_row for i in range(start_row, end_row + 1): if matrix[i][mid_col] > matrix[max_row][mid_col]: max_row = i return max_row def find_peak(matrix, start_col, end_col): mid_col = (start_col + end_col) // 2 max_row = find_peak_in_column(matrix, 0, len(matrix) - 1, mid_col) if (mid_col > 0 and matrix[max_row][mid_col] < matrix[max_row][mid_col - 1]): return find_peak(matrix, start_col, mid_col - 1) elif (mid_col < len(matrix[0]) - 1 and matrix[max_row][mid_col] < matrix[max_row][mid_col + 1]): return find_peak(matrix, mid_col + 1, end_col) else: return max_row, mid_col return find_peak(matrix, 0, len(matrix[0]) - 1)"},{"question":"**Scenario:** You work at a company that designs custom calendar applications for clients. The company needs a system that can identify dates for important holidays automatically. These holidays could be fixed (like Christmas) or variable (like Easter or Thanksgiving). Your task is to develop a robust system that calculates the date of specified holidays for a given year. **Problem Statement:** Implement a Python function that calculates the date of a specified holiday for a given year. # Function Specification ```python def calculate_holiday(holiday: str, year: int) -> str: Computes the date of the specified holiday for the given year. :param holiday: Name of the holiday to compute. :param year: Integer representing the year for which to calculate the holiday date. :return: The holiday date in the format \\"YYYY-MM-DD\\". :raises ValueError: If the specified holiday is not supported. pass ``` # Input - `holiday` - A string indicating the name of the holiday. - `year` - An integer representing the year for which the holiday date is to be calculated. # Output - A string representing the holiday date in the format \\"YYYY-MM-DD\\". # Constraints - The `year` will be a valid positive integer. - Raise a `ValueError` if the specified holiday is not supported. - Use built-in Python libraries and datetime operations for date calculations. **Supported Holidays** (Implement at least these four holidays): 1. Christmas (fixed date: December 25) 2. New Year\'s Day (fixed date: January 1) 3. Easter (variable date) 4. Thanksgiving (variable date: fourth Thursday of November) # Examples ```python # Christmas Calculation christmas = calculate_holiday(\\"Christmas\\", 2023) print(christmas) # Expected Output: # \\"2023-12-25\\" # New Year\'s Day Calculation new_year = calculate_holiday(\\"New Year\'s Day\\", 2023) print(new_year) # Expected Output: # \\"2023-01-01\\" # Easter Calculation easter = calculate_holiday(\\"Easter\\", 2023) print(easter) # Expected Output (Example, actual date might be different depending on the Easter calculation): # \\"2023-04-09\\" # Thanksgiving Calculation thanksgiving = calculate_holiday(\\"Thanksgiving\\", 2023) print(thanksgiving) # Expected Output: # \\"2023-11-23\\" ``` # Notes - Ensure that the function handles input validation, particularly for the holiday name. - Use Python\'s `datetime` module and other necessary libraries for efficient date calculations. - Provide accurate calculations for both fixed and variable date holidays. For Easter, you may use algorithms like the Computus to determine the correct date.","solution":"import datetime def calculate_holiday(holiday: str, year: int) -> str: Computes the date of the specified holiday for the given year. :param holiday: Name of the holiday to compute. :param year: Integer representing the year for which to calculate the holiday date. :return: The holiday date in the format \\"YYYY-MM-DD\\". :raises ValueError: If the specified holiday is not supported. if holiday == \\"Christmas\\": return f\\"{year}-12-25\\" elif holiday == \\"New Year\'s Day\\": return f\\"{year}-01-01\\" elif holiday == \\"Easter\\": return calculate_easter(year).strftime(\\"%Y-%m-%d\\") elif holiday == \\"Thanksgiving\\": return calculate_thanksgiving(year).strftime(\\"%Y-%m-%d\\") else: raise ValueError(\\"Holiday not supported.\\") def calculate_easter(year: int) -> datetime.date: Computes the date of Easter for a given year using the Computus algorithm. :param year: Year for which to calculate Easter. :return: Date object representing the date of Easter. a = year % 19 b = year // 100 c = year % 100 d = b // 4 e = b % 4 f = (b + 8) // 25 g = (b - f + 1) // 3 h = (19 * a + b - d - g + 15) % 30 i = c // 4 k = c % 4 l = (32 + 2 * e + 2 * i - h - k) % 7 m = (a + 11 * h + 22 * l) // 451 month = (h + l - 7 * m + 114) // 31 day = ((h + l - 7 * m + 114) % 31) + 1 return datetime.date(year, month, day) def calculate_thanksgiving(year: int) -> datetime.date: Computes the date of Thanksgiving for a given year (fourth Thursday of November). :param year: Year for which to calculate Thanksgiving. :return: Date object representing the date of Thanksgiving. november_first = datetime.date(year, 11, 1) first_thursday = november_first + datetime.timedelta(days=(3 - november_first.weekday()) % 7) fourth_thursday = first_thursday + datetime.timedelta(weeks=3) return fourth_thursday"},{"question":"# Permutations of a String Scenario You are working on a text-processing tool that enables users to explore the different arrangements of a given string. This feature is particularly useful in generating anagrams, studying permutations in cryptography, or validating combinatorial algorithms. Problem Statement Write a function `find_permutations` that generates all the permutations of a given string. The permutations should be returned as a list of strings, each representing a distinct permutation of the input string. Function Signature ```python def find_permutations(s: str) -> list[str]: ``` Input - `s` (str): A string whose permutations need to be generated. The string contains only lowercase alphabets and has a length of at most 6. Output - Returns a list of strings where each string is a unique permutation of the input string. Examples ```python assert find_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert find_permutations(\\"a\\") == [\\"a\\"] assert find_permutations(\\"ab\\") == [\\"ab\\", \\"ba\\"] assert find_permutations(\\"aabb\\") == [\\"aabb\\", \\"abab\\", \\"abba\\", \\"baab\\", \\"baba\\", \\"bbaa\\"] ``` Constraints - The input string can only contain lowercase letters. - The maximum length of the input string is 6 characters. Performance Requirements - The function should efficiently generate all permutations without duplicates, even for the maximum input size. Notes - Utilize a recursive approach or the itertools library to handle permutation generation. - Ensure that the function handles edge cases such as an empty string or strings where all characters are the same. - Maintain the order of permutations as shown in the examples for consistency.","solution":"from itertools import permutations def find_permutations(s: str) -> list[str]: Generates all permutations of the input string. Args: s (str): The input string to generate permutations for. Returns: list[str]: A list of unique permutations of the input string. # Generate permutations using itertools.permutations and convert to set to remove duplicates perm_set = set(permutations(s)) # Convert the set of tuples back to list of strings result = [\'\'.join(p) for p in perm_set] # Sort result to ensure consistent order result.sort() return result"},{"question":"# Context You are developing a system to manage a collection of books in a library. Each book has a unique identifier, a title, and an author. The system should allow books to be added, retrieved by identifier, and also provide a way to retrieve all books sorted by title. # Task Implement a class `Library` to manage the collection of books. The library should support the following operations: 1. **Add a book**: Given a book\'s identifier, title, and author, add it to the collection. 2. **Get a book**: Retrieve the details of a book by its identifier. 3. **Get all books sorted by title**: Retrieve a list of all books sorted alphabetically by their titles. Books have a unique identifier represented as an integer. Implement methods with the following signatures: ```python class Library: def add_book(self, book_id: int, title: str, author: str) -> None: pass def get_book(self, book_id: int) -> dict: pass def get_all_books_sorted_by_title(self) -> list: pass ``` # Requirements 1. Your methods should handle the operations efficiently: - Insertion should be O(1). - Retrieval by identifier should be O(1). - Retrieval of all books sorted by title should be O(n log n). 2. Handle edge cases such as adding books with duplicate identifiers, retrieving a book that does not exist, and maintaining the order when multiple books have the same title. # Constraints * Book identifiers are unique integers within the range [1, 10^9]. * Titles and authors are strings with a maximum length of 100 characters. # Example ```python library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.add_book(3, \\"1984\\", \\"George Orwell\\") print(library.get_book(2)) # Output: {\'id\': 2, \'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\'} books_sorted = library.get_all_books_sorted_by_title() # Output: [ # {\'id\': 3, \'title\': \'1984\', \'author\': \'George Orwell\'}, # {\'id\': 1, \'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\'}, # {\'id\': 2, \'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\'} #] ``` Submission Submit a class `Library` implemented in Python, with the specified methods efficiently handling the management and retrieval of book data as described.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str, author: str) -> None: Adds a book with the given id, title and author to the library collection. If the book_id already exists, it will not add the book again. if book_id not in self.books: self.books[book_id] = {\'id\': book_id, \'title\': title, \'author\': author} def get_book(self, book_id: int) -> dict: Retrieves the details of a book by its identifier. Returns a dictionary containing the book\'s information if found, otherwise an empty dictionary. return self.books.get(book_id, {}) def get_all_books_sorted_by_title(self) -> list: Retrieves a list of all books sorted alphabetically by their titles. Each book is represented as a dictionary containing its id, title, and author. return sorted(self.books.values(), key=lambda x: x[\'title\'])"},{"question":"# Coding Assessment Question: Perfect Number Series Background: A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. For example, the first perfect number is 6, since its divisors (excluding 6) are 1, 2, and 3, and 1 + 2 + 3 = 6. Another example is 28, which has divisors 1, 2, 4, 7, and 14, and 1 + 2 + 4 + 7 + 14 = 28. Given an integer ( N ), find how many perfect numbers are less than or equal to ( N ), and return them in a list sorted in increasing order. # Function Signature ```python def find_perfect_numbers(N: int) -> List[int]: pass ``` # Input - `N` (int): The upper bound for the search of perfect numbers (1 ≤ N ≤ 10^8). # Output - A list of integers representing all perfect numbers less than or equal to ( N ), sorted in increasing order. # Example ```python def test_find_perfect_numbers(): assert find_perfect_numbers(28) == [6, 28], \\"Test case 1 failed\\" assert find_perfect_numbers(100) == [6, 28], \\"Test case 2 failed\\" assert find_perfect_numbers(500) == [6, 28], \\"Test case 3 failed\\" assert find_perfect_numbers(10000) == [6, 28, 496, 8128], \\"Test case 4 failed\\" print(\\"All test cases pass\\") ``` # Notes - Carefully consider the efficiency of your algorithm, especially for large values of ( N ). - A proper divisor is any divisor of the number except the number itself. - Ensure that your implementation can handle large inputs within a reasonable time frame. - It is suggested to precompute known perfect numbers for commonly used smaller values of ( N ).","solution":"def find_perfect_numbers(N): Returns a list of perfect numbers less than or equal to N. # Known perfect numbers less than 10^8 P = [6, 28, 496, 8128, 33550336] return [num for num in P if num <= N]"},{"question":"# Question: Data Summarization by Category You are given a list of transactions, where each transaction is represented by a tuple containing the transaction category and the transaction amount. Your task is to implement a function that summarizes the total amount for each category. Function Signature ```python def summarize_transactions(transactions: list[tuple[str, float]]) -> dict: pass ``` # Input * `transactions` (list[tuple[str, float]]): A list of tuples, where each tuple contains a string (the transaction category) and a float (the transaction amount). # Output * Return a dictionary where the keys are the transaction categories and the values are the total transaction amounts for each category. # Constraints 1. The list of transactions must not be empty. If it is, raise a `ValueError` with the message \\"Transactions list cannot be empty.\\" 2. All transaction amounts must be real numbers (positive, negative or zero) and non-null categories. # Example ```python summarize_transactions([ (\\"groceries\\", 25.50), (\\"rent\\", 1000.00), (\\"groceries\\", 10.00), (\\"utilities\\", 75.75) ]) # Returns {\'groceries\': 35.50, \'rent\': 1000.00, \'utilities\': 75.75} summarize_transactions([ (\\"salary\\", -1000.00), (\\"investment\\", 500.20), (\\"investment\\", -50.00) ]) # Returns {\'salary\': -1000.00, \'investment\': 450.20} summarize_transactions([]) # Raises ValueError: Transactions list cannot be empty ``` # Notes 1. Ensure your implementation handles edge cases effectively. 2. Optimize the implementation for performance, especially for large lists of transactions.","solution":"def summarize_transactions(transactions): Returns a dictionary summarizing the total amount for each transaction category. Raises a ValueError if the list of transactions is empty. if not transactions: raise ValueError(\\"Transactions list cannot be empty.\\") summary = {} for category, amount in transactions: if category in summary: summary[category] += amount else: summary[category] = amount return summary"},{"question":"# File Compression and Decompression Task You are tasked with creating a simple utility that can compress and decompress text files using the gzip compression algorithm. Implement the following two functions: 1. **compress_file**: This function should read the contents of a text file, compress it using gzip, and save the compressed data to a new file. * **Input**: A single string representing the path to the text file to be compressed. * **Output**: None (side effect of saving the compressed file). * **Constraints**: - The function must handle any errors related to file operations (e.g., file not found, permission errors). - The compressed file should be saved in the same directory as the original file with the same name, appended with a `.gz` extension. 2. **decompress_file**: This function should read the contents of a gzip-compressed file, decompress it, and save the decompressed data to a new text file. * **Input**: A single string representing the path to the gzip file to be decompressed. * **Output**: None (side effect of saving the decompressed file). * **Constraints**: - The function must handle any errors related to reading the gzip file or file operations. - The decompressed file should be saved in the same directory as the compressed file with the `.gz` extension removed from the filename. # Example ```python # Example usage if __name__ == \\"__main__\\": original_text_file = \\"example.txt\\" compress_file(original_text_file) compressed_file = \\"example.txt.gz\\" decompress_file(compressed_file) print(f\\"Original file: {original_text_file}nCompressed file: {compressed_file}nDecompressed file: {compressed_file[:-3]}\\") ``` # Notes - Ensure robust error handling and consider edge cases such as empty files and unsupported file formats. - For testing purposes, you can create sample text files with various contents. - Performance considerations: handle large files efficiently and avoid loading entire files into memory when not necessary.","solution":"import gzip import os def compress_file(file_path): Compresses a text file using gzip. Args: file_path (str): Path to the text file to be compressed. Output: None (side effect of saving the compressed file). try: with open(file_path, \'rb\') as f_in: with gzip.open(file_path + \'.gz\', \'wb\') as f_out: f_out.writelines(f_in) except Exception as e: print(f\\"An error occurred while compressing the file: {e}\\") def decompress_file(file_path): Decompresses a gzip file. Args: file_path (str): Path to the gzip file to be decompressed. Output: None (side effect of saving the decompressed file). try: output_file_path = file_path.rstrip(\'.gz\') with gzip.open(file_path, \'rb\') as f_in: with open(output_file_path, \'wb\') as f_out: f_out.writelines(f_in) except Exception as e: print(f\\"An error occurred while decompressing the file: {e}\\")"},{"question":"# Problem Statement You are working on a data processing pipeline that handles a large set of events, each of which is associated with a particular timestamp. To streamline processing, you need to ensure that the events are processed in the correct chronological order. Your task is to write a function that, given a list of events with their timestamps, sorts the events by their timestamps in ascending order and returns the sorted list of events. Write a function named `sort_events_by_timestamp` that takes a list of tuples, where each tuple consists of an event identifier (string) and a timestamp (integer), and returns a list of events sorted by their timestamps. # Input * `events` (list of tuples): A list of tuples, where each tuple contains: * `event_id` (str): A string representing the event identifier. * `timestamp` (int): An integer representing the timestamp of the event. # Output * A list of tuples sorted by the timestamps in ascending order. # Examples ```python # Example 1 assert sort_events_by_timestamp([(\'e1\', 5), (\'e2\', 3), (\'e3\', 8), (\'e4\', 1)]) == [(\'e4\', 1), (\'e2\', 3), (\'e1\', 5), (\'e3\', 8)] # Example 2 assert sort_events_by_timestamp([(\'a\', 2), (\'b\', 1)]) == [(\'b\', 1), (\'a\', 2)] # Example 3 assert sort_events_by_timestamp([(\'x\', 10), (\'y\', 10), (\'z\', 5)]) == [(\'z\', 5), (\'x\', 10), (\'y\', 10)] # Example 4 assert sort_events_by_timestamp([]) == [] # Example 5 assert sort_events_by_timestamp([(\'single\', 3)]) == [(\'single\', 3)] ``` # Constraints * The list of events can be empty. * The number of events will be between 0 and 10^4. * Event identifiers (strings) will have a length between 1 and 20 characters. * The timestamps are non-negative integers. * Timestamps can be the same for different events. # Performance Requirements * The algorithm should run in O(n log n) time complexity, where n is the number of events. # Additional Notes * If the input list is empty, the function should return an empty list. * If the input list contains one tuple, the function should return the same list as there is no need for sorting.","solution":"def sort_events_by_timestamp(events): Sorts the events by their timestamps in ascending order. Args: events (list of tuples): A list of tuples, where each tuple contains: - event_id (str): The event identifier. - timestamp (int): The timestamp of the event. Returns: list of tuples: A list of events sorted by their timestamps in ascending order. return sorted(events, key=lambda event: event[1])"},{"question":"# Coding Assessment Question Implement a function that takes a list of tuples representing ranges and a separate list of integers, and returns a list of the same integers with each integer incremented by 1 if it falls within any of the provided ranges (inclusive). Each range is represented by a tuple of two integers [start, end]. # Function Signature ```python def increment_within_ranges(ranges: List[Tuple[int, int]], numbers: List[int]) -> List[int]: :param ranges: List of tuples, where each tuple represents a range with a start and end integer. :param numbers: List of integers to be checked against ranges. :return: A list of integers with each integer incremented by 1 if it falls within any range. ``` # Input - `ranges`: A list of tuples representing inclusive ranges of integers (1 <= len(ranges) <= 10^3). - `numbers`: A list of integers to be processed (1 <= len(numbers) <= 10^6). # Output - A list of integers with each integer incremented by 1 for each occurrence within any range. # Constraints - It is guaranteed that for any tuple (start, end) in ranges, start <= end. - The processing should be efficient to handle the upper constraints. # Example ```python ranges = [(1, 3), (5, 7)] numbers = [1, 2, 3, 4, 5, 6, 7, 8] output = increment_within_ranges(ranges, numbers) # Expected Output # [2, 3, 4, 4, 6, 7, 8, 8] ``` # Additional Information - The function should efficiently determine if a number falls within any of the provided ranges. - Try to minimize time complexity to handle large inputs within reasonable time limits.","solution":"from typing import List, Tuple def increment_within_ranges(ranges: List[Tuple[int, int]], numbers: List[int]) -> List[int]: For each number in the list `numbers`, increments it by 1 if it falls within any of the provided `ranges`. :param ranges: List of tuples, where each tuple represents a range with a start and end integer. :param numbers: List of integers to be checked against ranges. :return: A list of integers with each integer incremented by 1 if it falls within any range. # Create a list to hold the results result = [] # Iterate over each number in the input list for num in numbers: incremented = False # Check if the number falls within any of the provided ranges for start, end in ranges: if start <= num <= end: result.append(num + 1) incremented = True break # If the number was not incremented, add it as is if not incremented: result.append(num) return result"},{"question":"# Question You are needed to implement a function that identifies if a number is a powerful number. A powerful number is a positive integer `m` such that for every prime number `p` dividing `m`, `p^2` also divides `m`. Your task is to provide two implementations to check whether a given integer is powerful using both iterative and recursive methods. Function Signature ```python def is_powerful_iterative(num: int) -> bool: def is_powerful_recursive(num: int, divisor: int = 2) -> bool: ``` Requirements: 1. **Function 1**: `is_powerful_iterative(num: int) -> bool` - Use an iterative approach to determine if the number is powerful. - Should raise `ValueError` for non-positive integers. 2. **Function 2**: `is_powerful_recursive(num: int, divisor: int = 2) -> bool` - Use recursion to determine if the number is powerful. - Should raise `ValueError` for non-positive integers. - Check divisibility up to the square root of the number. Input - `num`: A positive integer that needs to be checked for being a powerful number. Output - Returns a boolean value, `True` if the number is a powerful number, `False` otherwise. Constraints - `num` must be a positive integer within the range of 1 to (10^6). Example ```python >>> is_powerful_iterative(36) True ``` ```python >>> is_powerful_recursive(28) False ``` Scenario Consider implementing your solution with efficiency in mind, particularly for large inputs. The iterative function should effectively check each prime factor and the recursive function should manage recursive calls up to the number\'s square root. --- This question aligns with the given style, complexity, and domain while introducing a different problem scenario. The length is comparable, and it requires the use of both iterative and recursive strategies, maintaining consistency with the original set.","solution":"def is_powerful_iterative(num: int) -> bool: if num <= 0: raise ValueError(\\"Number must be a positive integer.\\") i = 2 while i * i <= num: count = 0 while num % i == 0: num //= i count += 1 if count == 1: return False i += 1 return num == 1 def is_powerful_recursive(num: int, divisor: int = 2) -> bool: if num <= 0: raise ValueError(\\"Number must be a positive integer.\\") if divisor * divisor > num: return num == 1 count = 0 while num % divisor == 0: num //= divisor count += 1 if count == 1: return False return is_powerful_recursive(num, divisor + 1) # Example Usage: # print(is_powerful_iterative(36)) # Should return True # print(is_powerful_recursive(28)) # Should return False"},{"question":"# Scenario You are developing a recommendation system for an e-commerce platform. Part of this system involves identifying and ranking unique items based on user reviews. Each review contains a list of item ratings in a scale from 1 to 5. You need to implement a function that processes these reviews to output a list of unique items and their average ratings, sorted by the highest average rating. # Task Given a list of user reviews, where each review is a dictionary containing item names as keys and their respective ratings as values, implement the `rank_items_by_review` function which calculates the average rating for each unique item and returns a sorted list of tuples with each item and its average rating. # Function Signature ```python def rank_items_by_review(reviews: List[Dict[str, int]]) -> List[Tuple[str, float]]: pass ``` # Input * `reviews`: A list of dictionaries. Each dictionary represents a user\'s review with items and their ratings. Each rating is an integer between 1 and 5 (inclusive). # Output * Returns a list of tuples, where each tuple contains an item name and its average rating, sorted in descending order by the average rating. # Constraints * The `reviews` list will contain between 1 and 1000 reviews. * Each review dictionary can contain between 1 and 50 items. * Item names are unique strings of lengths between 1 and 50 characters. * Ratings are integers between 1 and 5 (inclusive). # Example ```python reviews = [ {\\"item1\\": 4, \\"item2\\": 5, \\"item3\\": 3}, {\\"item2\\": 4, \\"item3\\": 4, \\"item4\\": 2}, {\\"item1\\": 5, \\"item3\\": 3, \\"item4\\": 5}, {\\"item1\\": 3, \\"item2\\": 2} ] result = rank_items_by_review(reviews) # Expected Output: [(\\"item2\\", 3.67), (\\"item1\\", 4.0), (\\"item3\\", 3.33), (\\"item4\\", 3.5)] ``` # Notes * If items have the same average rating, sort them alphabetically by their item name. * Consider edge cases where some items may have only one rating. * Use appropriate data structures to manage and calculate the average ratings efficiently.","solution":"from typing import List, Dict, Tuple from collections import defaultdict import math def rank_items_by_review(reviews: List[Dict[str, int]]) -> List[Tuple[str, float]]: Calculate the average rating for each unique item from the reviews and return a sorted list of tuples containing each item and its average rating, sorted by the highest average rating. item_ratings = defaultdict(list) # Collect all ratings for each item for review in reviews: for item, rating in review.items(): item_ratings[item].append(rating) # Calculate the average ratings average_ratings = [] for item, ratings in item_ratings.items(): average_rating = sum(ratings) / len(ratings) average_ratings.append((item, round(average_rating, 2))) # Sort the items first by average rating (descending) and then by item name (ascending) average_ratings.sort(key=lambda x: (-x[1], x[0])) return average_ratings"},{"question":"# Directory Size Calculator Scenario: You are developing a utility to calculate the total size of a directory on a file system. This tool will help users manage their storage by identifying directories that consume significant space. Task: Write a Python function `calculate_directory_size(path: str) -> int` that computes the total size (in bytes) of all files within a given directory, including those in its subdirectories. Requirements: 1. Use the `os` and `os.path` libraries to navigate the filesystem. 2. Ensure your function recursively explores all subdirectories and files. 3. Handle edge cases such as symbolic links, non-existent directories, and permission errors gracefully. 4. Return the total size as an integer representing the sum of the sizes of all files. # Function Signature ```python def calculate_directory_size(path: str) -> int: pass ``` Input * `path`: A string representing the absolute or relative path to the directory (e.g., \\"/home/user/documents\\"). Constraints * The provided path is a valid directory string. * The actual size calculation should only include files and not directory metadata. Output * Return an integer that represents the total size of the files in bytes. Notes * You may assume the system runs on a Unix-like file system. * Avoid infinite loops by ensuring that symbolic links to parent directories are not followed. * The solution should be efficient and able to handle directories with a large number of files. Example ```python # Example input: directory_path = \\"/home/user/documents\\" # Expected output: total_size = 204800 # This represents the total size in bytes. # Example function usage: print(calculate_directory_size(directory_path)) ```","solution":"import os def calculate_directory_size(path: str) -> int: total_size = 0 try: for dirpath, dirnames, filenames in os.walk(path): for f in filenames: fp = os.path.join(dirpath, f) # Skip if it is symbolic link if not os.path.islink(fp): total_size += os.path.getsize(fp) except Exception as e: print(f\\"Error accessing {path}: {e}\\") return total_size"},{"question":"# Problem Statement Write a function that takes a string expression of a mathematical equation with one variable (x) and an initial guess to find an approximate root of the equation using the secant method. The function should return the approximate root, the error of the approximation, and optionally the list of approximation steps. # Function Signature ```python def find_root_secant_method( expression: str, initial_guess1: float, initial_guess2: float, max_iterations: int = 100, precision: float = 1e-6, log_steps: bool = False ) -> Tuple[float, float, List[float]]: Applies the secant method to find a root of a given mathematical equation. :param expression: A string representing a mathematical equation in terms of \'x\'. :param initial_guess1: First initial guess for the root. :param initial_guess2: Second initial guess for the root. :param max_iterations: Maximum number of iterations to perform, default is 100. :param precision: Desired precision of the root, default is 1e-6. :param log_steps: If True, return list of all intermediate steps, default is False. :return: A tuple (approximated root, error, intermediate steps). :raises ArithmeticError: If solution is not found within the maximum iterations. :raises ZeroDivisionError: If the method encounters a division by zero. ``` # Inputs 1. `expression`: A string representing a mathematical equation in terms of `x` (e.g., \\"x**2 - 4\\"). 2. `initial_guess1`: The first initial guess for the root. 3. `initial_guess2`: The second initial guess for the root. 4. `max_iterations`: (Optional) Maximum number of iterations (default: 100). 5. `precision`: (Optional) Desired precision of the root (default: 1e-6). 6. `log_steps`: (Optional) Boolean flag to indicate if the function should return intermediate steps (default: False). # Outputs 1. `approximated root`: The estimated root of the function. 2. `error`: The error of the final estimate. 3. `intermediate steps`: List of intermediate root approximations if `log_steps` is `True`, otherwise an empty list. # Constraints 1. The mathematical expression should be a valid single-variable function string that can be evaluated. 2. The number of iterations should not exceed `max_iterations`. # Example ```python # Test case 1: root, error, steps = find_root_secant_method(\\"x**2 - 5*x + 6\\", 0, 3, log_steps=True) # The roots of x^2 - 5x + 6 are 2 and 3; a valid approximation should be close to either of these. assert abs(root - 2) < 1e-6 or abs(root - 3) < 1e-6 assert len(steps) > 0 # Test case 2: root, error, steps = find_root_secant_method(\\"cos(x) - x\\", 0.5, 1.5, precision=1e-10, log_steps=False) # The root of cos(x) - x is approximately 0.739085. assert abs(root - 0.739085) < 1e-10 assert steps == [] ``` # Notes - Use `eval` to evaluate the mathematical expression with each guess. - Ensure robust handling of edge cases, such as division by zero and non-convergence within the iteration limit. - Use appropriate error handling to catch and manage potential issues during evaluation.","solution":"from typing import Tuple, List import math def find_root_secant_method( expression: str, initial_guess1: float, initial_guess2: float, max_iterations: int = 100, precision: float = 1e-6, log_steps: bool = False ) -> Tuple[float, float, List[float]]: def f(x): return eval(expression) x0, x1 = initial_guess1, initial_guess2 steps = [x0, x1] if log_steps else [] for iteration in range(max_iterations): try: f_x0, f_x1 = f(x0), f(x1) if f_x1 - f_x0 == 0: # Avoid division by zero raise ZeroDivisionError(\\"Division by zero encountered in secant method.\\") x2 = x1 - f_x1 * (x1 - x0) / (f_x1 - f_x0) if log_steps: steps.append(x2) if abs(x2 - x1) < precision: error = abs(x2 - x1) return x2, error, steps x0, x1 = x1, x2 except ZeroDivisionError as e: raise e from None raise ArithmeticError(\\"Secant method did not converge within the maximum number of iterations.\\")"},{"question":"# Graph Coloring Problem Solver Background Graph coloring is an assignment of colors to the vertices of a graph such that no two adjacent vertices share the same color. The minimum number of colors needed to color a graph is called the graph\'s chromatic number. This problem has applications in scheduling, register allocation in compilers, and solving puzzles like Sudoku. In this task, you will implement a function that uses the greedy algorithm to find a color assignment for the vertices of a graph. Additionally, you will need to determine the chromatic number for the graph based on the color assignment. Task You need to implement two methods in a class `GraphColoring`: 1. `greedy_coloring`: This method finds the color assignment for each vertex using a greedy algorithm. 2. `find_chromatic_number`: This method finds the chromatic number of the graph. You also need to create a main function to demonstrate the coloring and chromatic number determination for a given graph. Implementation 1. **greedy_coloring**: - **Input**: A 2D list `graph` representing an adjacency matrix of the graph. - **Output**: A list of integers representing the color assigned to each vertex. - **Example**: ```python graph_coloring = GraphColoring() print(graph_coloring.greedy_coloring([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]])) # Output: [0, 1, 0, 1] ``` 2. **find_chromatic_number**: - **Input**: A list of integers `colors` representing the color assignment for each vertex. - **Output**: An integer representing the chromatic number of the graph. - **Example**: ```python graph_coloring = GraphColoring() colors = [0, 1, 0, 1] print(graph_coloring.find_chromatic_number(colors)) # Output: 2 ``` 3. **main**: - Demonstrate coloring with a provided adjacency matrix. - Determine and print the chromatic number based on the color assignment. Constraints - Assume the graph is undirected. - Assume the graph is connected. - The maximum number of vertices (n) is 50. Example Implement the following: ```python class GraphColoring: def greedy_coloring(self, graph): n = len(graph) result = [-1] * n available = [False] * n result[0] = 0 for u in range(1, n): for i in range(n): if graph[u][i] == 1 and result[i] != -1: available[result[i]] = True color = 0 while color < n: if not available[color]: break color += 1 result[u] = color for i in range(n): if graph[u][i] == 1 and result[i] != -1: available[result[i]] = False return result def find_chromatic_number(self, colors): return max(colors) + 1 def main(): graph = [ [0, 1, 0, 0, 1], [1, 0, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 0, 1], [1, 0, 0, 1, 0] ] graph_coloring = GraphColoring() colors = graph_coloring.greedy_coloring(graph) chromatic_number = graph_coloring.find_chromatic_number(colors) print(f\\"Color assignment: {colors}\\") print(f\\"Chromatic number: {chromatic_number}\\") if __name__ == \\"__main__\\": main() ```","solution":"class GraphColoring: def greedy_coloring(self, graph): n = len(graph) result = [-1] * n available = [False] * n result[0] = 0 for u in range(1, n): for i in range(n): if graph[u][i] == 1 and result[i] != -1: available[result[i]] = True color = 0 while color < n: if not available[color]: break color += 1 result[u] = color for i in range(n): if graph[u][i] == 1 and result[i] != -1: available[result[i]] = False return result def find_chromatic_number(self, colors): return max(colors) + 1 def main(): graph = [ [0, 1, 0, 0, 1], [1, 0, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 0, 1], [1, 0, 0, 1, 0] ] graph_coloring = GraphColoring() colors = graph_coloring.greedy_coloring(graph) chromatic_number = graph_coloring.find_chromatic_number(colors) print(f\\"Color assignment: {colors}\\") print(f\\"Chromatic number: {chromatic_number}\\") if __name__ == \\"__main__\\": main()"},{"question":"# Question You are tasked with writing a function that calculates the total water trapped by the walls after a rainfall, given the heights of the walls. This is a classical problem known as the \\"trapping rain water\\" problem. The problem can be visualized by considering the heights of the walls as an array where each element represents the height of a wall. After a rainfall, the amount of water that will be trapped depends on the positioning of the walls. # Function Signature ```python def trapping_water(heights: list) -> int: pass ``` # Input - `heights` (list): A list of integers where each integer represents the height of a wall. The list must contain at least one element, and all elements are non-negative integers. # Output - Returns the total amount of water trapped as an integer. # Constraints - 0 ≤ len(heights) ≤ 10^4 - 0 ≤ heights[i] ≤ 10^5 # Example ```python >>> trapping_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trapping_water([4,2,0,3,2,5]) 9 >>> trapping_water([1]) 0 >>> trapping_water([0,0,0]) 0 >>> trapping_water([1,2,3,4]) 0 ``` # Requirements * Implement your function in a clear and efficient manner. * Ensure your function handles edge cases such as a list with one element or all elements being zero. * Write tests for your function to confirm its correctness.","solution":"def trapping_water(heights: list) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"# Coding Question: Sorting Nearly Sorted Array Problem Statement: Given an array of `n` elements, where each element is at most `k` positions away from its target position in a sorted array, design an efficient algorithm to sort the array. Your task is to implement a function `sort_nearly_sorted(arr: List[int], k: int) -> List[int]` that sorts the given array in ascending order. Write a function `sort_nearly_sorted(arr: List[int], k: int) -> List[int]` where: - **Input**: - `arr` (a list of integers) - the nearly sorted array. - `k` (an integer) - the maximum distance (inclusive) any element is away from its target position. - **Output**: - A list of integers representing the sorted array. Function Signature: `def sort_nearly_sorted(arr: List[int], k: int) -> List[int]` **Examples**: ```python assert sort_nearly_sorted([6, 5, 3, 2, 8, 10, 9], 3) == [2, 3, 5, 6, 8, 9, 10] assert sort_nearly_sorted([10, 9, 8, 7, 4, 70, 60, 50], 4) == [4, 7, 8, 9, 10, 50, 60, 70] ``` Constraints: - The array length `n` will be at least 1 and at most 10^5. - Elements of the array will be integers within the range [-10^9, 10^9]. - `k` will be a positive integer such that `1 <= k <= n`. Performance Requirements: - The solution should leverage the condition that each element is at most `k` positions away from its target position, to achieve better performance than the typical O(n log n) sorting algorithms. **Hint**: Consider using a Min-Heap or another suitable data structure to maintain the order with reduced complexity.","solution":"import heapq from typing import List def sort_nearly_sorted(arr: List[int], k: int) -> List[int]: Sort a nearly sorted array where each element is at most k positions away from its target position. # Initialize a min-heap min_heap = [] # Build the initial heap with the first k+1 elements for i in range(min(k+1,len(arr))): heapq.heappush(min_heap, arr[i]) result = [] # Now for the rest of the elements in the array, remove the smallest element from the heap and add the next element from the array to the heap for i in range(k+1, len(arr)): result.append(heapq.heappop(min_heap)) heapq.heappush(min_heap, arr[i]) # Extract all remaining elements from the heap while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"# Scenario: You are developing an inventory management system for a retail store. One of the functionalities required is to track the stock levels of various products and notify when any product\'s stock falls below a given threshold. Your task is to implement a function to manage and track the addition and removal of stock items efficiently. # Task: Implement a class `Inventory` that allows for tracking stock levels of various products. The class should support adding stock, removing stock, and checking the current stock level of any product. Additionally, the system should notify if the stock of any product falls below a given threshold. # Class Definition: ```python class Inventory: def __init__(self, threshold: int): # Initializes a new inventory system with the specified threshold pass def add_stock(self, product: str, quantity: int) -> None: # Adds the specified quantity of the given product to the inventory pass def remove_stock(self, product: str, quantity: int) -> None: # Removes the specified quantity of the given product from the inventory pass def get_stock(self, product: str) -> int: # Returns the current stock level of the given product pass def check_threshold(self, product: str) -> bool: # Returns True if the stock of the given product is below the threshold pass ``` # Methods: - `__init__(self, threshold: int)`: Initializes a new inventory system with the specified threshold value. - `add_stock(self, product: str, quantity: int) -> None`: Adds the specified quantity of the given product to the inventory. If the product does not exist, it creates a new entry for it. - `remove_stock(self, product: str, quantity: int) -> None`: Removes the specified quantity of the given product from the inventory. If the product\'s quantity falls below 0, return an error. - `get_stock(self, product: str) -> int`: Returns the current stock level of the given product. If the product does not exist, return 0. - `check_threshold(self, product: str) -> bool`: Returns True if the stock level for the product falls below the threshold; otherwise returns False. # Constraints: - Product names will be strings consisting of alphanumeric characters and have a maximum length of 100. - Stock quantities will be non-negative integers. - All methods must handle invalid inputs gracefully. # Examples: ```python inventory = Inventory(threshold=10) inventory.add_stock(\\"apple\\", 20) print(inventory.get_stock(\\"apple\\")) # Output: 20 inventory.remove_stock(\\"apple\\", 5) print(inventory.get_stock(\\"apple\\")) # Output: 15 print(inventory.check_threshold(\\"apple\\")) # Output: False inventory.remove_stock(\\"apple\\", 10) print(inventory.get_stock(\\"apple\\")) # Output: 5 print(inventory.check_threshold(\\"apple\\")) # Output: True inventory.add_stock(\\"banana\\", 50) print(inventory.get_stock(\\"banana\\")) # Output: 50 print(inventory.check_threshold(\\"banana\\")) # Output: False ``` Ensure your class is efficient and handles all specified edge cases. You may use the provided examples to test your implementation.","solution":"class Inventory: def __init__(self, threshold: int): self.threshold = threshold self.stock_levels = {} def add_stock(self, product: str, quantity: int) -> None: if product in self.stock_levels: self.stock_levels[product] += quantity else: self.stock_levels[product] = quantity def remove_stock(self, product: str, quantity: int) -> None: if product not in self.stock_levels: raise ValueError(\\"Product does not exist in inventory\\") if self.stock_levels[product] < quantity: raise ValueError(\\"Insufficient stock to remove\\") self.stock_levels[product] -= quantity def get_stock(self, product: str) -> int: if product in self.stock_levels: return self.stock_levels[product] return 0 def check_threshold(self, product: str) -> bool: if product not in self.stock_levels: return True return self.stock_levels[product] < self.threshold"},{"question":"# Question: Implement a Custom File Organizer You\'re tasked with creating a custom file organizer that takes a list of filenames and categorizes them into different folders based on their extensions. Each file should be moved to a folder that matches its extension name. If a folder for an extension does not exist, it should be created. Steps to Follow: 1. Write a class `FileOrganizer` that contains the following methods: * `__init__(self)`: Initializes an empty dictionary `self.files` to store the categorized files. * `add_file(self, filename: str) -> None`: Adds a filename to the `self.files` dictionary under the appropriate extension category. * `organize(self) -> Dict[str, List[str]]`: Organizes all files in the dictionary into folders based on their extensions and returns the final organization as a dictionary where keys are folder names and values are lists of file names. 2. Write a function `save_organization(structure: Dict[str, List[str]], directory: str) -> None` that takes the organized dictionary and saves the files into corresponding folders within the directory specified. It should: * Create folders if they do not exist. * Print the final structure of files and folders for verification. Input & Output: * **Input**: * `add_file` takes a single string representing the filename (including extension). * `save_organization` takes a dictionary with folder names as keys and lists of filenames as values, and a string for the target directory. * **Output**: * `organize` returns a dictionary where keys are folder names and values are lists of filenames. * `save_organization` prints the final directory structure indicating which files are in which folders. Constraints: * Filenames will always contain an extension. * Directory structure should be created only virtually (do not actually create folders on disk). Examples: ```python >>> organizer = FileOrganizer() >>> organizer.add_file(\\"photo.jpg\\") >>> organizer.add_file(\\"document.pdf\\") >>> organizer.add_file(\\"music.mp3\\") >>> organizer.add_file(\\"photo2.jpg\\") >>> organization_structure = organizer.organize() >>> print(organization_structure) {\'jpg\': [\'photo.jpg\', \'photo2.jpg\'], \'pdf\': [\'document.pdf\'], \'mp3\': [\'music.mp3\']} >>> save_organization(organization_structure, \'/fake_directory/\') Directory \'/fake_directory/\' structure: - jpg: [\'photo.jpg\', \'photo2.jpg\'] - pdf: [\'document.pdf\'] - mp3: [\'music.mp3\'] ``` Implement the `FileOrganizer` class and the `save_organization` function following the above specifications.","solution":"from collections import defaultdict from typing import List, Dict class FileOrganizer: def __init__(self): self.files = defaultdict(list) def add_file(self, filename: str) -> None: extension = filename.split(\'.\')[-1] self.files[extension].append(filename) def organize(self) -> Dict[str, List[str]]: return dict(self.files) def save_organization(structure: Dict[str, List[str]], directory: str) -> None: print(f\\"Directory \'{directory}\' structure:\\") for folder, files in structure.items(): print(f\\"- {folder}: {files}\\")"},{"question":"# Problem Statement: Custom Base64 Decoder You are tasked to write a custom function in Python that decodes a Base64-encoded string back into its original format. Apart from converting valid Base64 strings, the function should also handle specific edge cases and errors gracefully. The function should strip or ignore any leading and trailing whitespace in the input string. # Function Signature ```python def custom_base64_decoder(encoded_string: str) -> str: pass ``` # Input * `encoded_string` - A string representing the Base64-encoded data. Example format: `\\" SGVsbG8gV29ybGQ= \\"`, which after stripping whitespace is `SGVsbG8gV29ybGQ=`. # Output * A string which is the original decoded data. # Constraints * The input string will only contain valid Base64 characters (A-Z, a-z, 0-9, +, /, and = for padding) with potentially some whitespaces around. * Handle invalid Base64 strings by raising a `ValueError`. * Ignore leading and trailing whitespaces but raise an error for internal whitespaces. # Requirements * Raise a `ValueError` with a descriptive error message in case of invalid inputs or conditions. * Your function should be whitespace tolerant as described. # Background Information on Base64 Base64 encoding is a binary-to-text encoding scheme that represents binary data in an ASCII string format by translating it into a radix-64 representation. Each Base64 character represents exactly 6 bits of data. A typical Base64 encoded string will end with one or two `=` symbols for padding purposes. # Example Usage ```python >>> custom_base64_decoder(\\"SGVsbG8gV29ybGQ=\\") \'Hello World\' >>> custom_base64_decoder(\\"V2VsY29tZQ==\\") \'Welcome\' >>> custom_base64_decoder(\\"Tm90SGlkZGVuU3BhY2U=\\") \'NotHiddenSpace\' >>> custom_base64_decoder(\\" U29tZSB0ZXh0IHdpdGggd2hpdGVzcGFjZSB0byB0ZXN0IC0gMTIzNDU= \\") \'Some text with whitespace to test - 12345\' >>> custom_base64_decoder(\\"U29tZSBpbnZhbGlkIHN0cmluZyDpicmpQ==\\") Traceback (most recent call last): ... ValueError: Invalid Base64 string: contains non-base64 character >>> custom_base64_decoder(\\" \\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> custom_base64_decoder(\\" U29tZSBpbnRlcm5hbCB3aGl0ZXNwYWNl === \\") Traceback (most recent call last): ... ValueError: Invalid Base64 string: contains internal whitespace ``` # Additional Notes * You are not allowed to use Python\'s built-in Base64 library for the decoding. * Test the function with various valid and invalid cases to ensure robustness.","solution":"import base64 def custom_base64_decoder(encoded_string: str) -> str: Decodes a Base64-encoded string into its original format. Strips leading/trailing whitespaces and handles specific edge cases. # Strip leading and trailing whitespace trimmed_string = encoded_string.strip() # Check if the string is empty after stripping if not trimmed_string: raise ValueError(\\"Empty string was passed to the function\\") # Check for internal whitespaces if \' \' in trimmed_string or \'n\' in trimmed_string or \'r\' in trimmed_string or \'t\' in trimmed_string: raise ValueError(\\"Invalid Base64 string: contains internal whitespace\\") try: # Decode the base64 encoded string decoded_bytes = base64.b64decode(trimmed_string, validate=True) decoded_string = decoded_bytes.decode(\'utf-8\') except (base64.binascii.Error, UnicodeDecodeError): raise ValueError(\\"Invalid Base64 string: invalid encoding or padding\\") return decoded_string"},{"question":"# Question: Merge K Sorted Lists You are tasked with merging `k` sorted linked lists into one single sorted linked list. Implement a function `merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]` that takes a list of linked lists and returns a single merged sorted linked list. # Function Signature ```python def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: ... ``` # Input - `lists`: A list of `k` linked lists, where each linked list is represented by its head node. # Output - Returns the head node of the merged single sorted linked list. # Constraints - Each linked list is represented by a `ListNode` instance. - A `ListNode` is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` - All values in the linked lists are integers. - The total number of nodes across all `k` linked lists does not exceed (10^4). # Scenario Imagine you are a developer working on a data aggregation system where you need to merge logs from multiple sources. Each source provides logs sorted by timestamp as linked lists, and the goal is to combine these logs into a single, chronologically sorted list: - If there are multiple sources of logs, merge them into one combined log in which logs from all sources appear in the correct order based on timestamps. # Example ```python # Example lists: [[1,4,5], [1,3,4], [2,6]] list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) lists = [list1, list2, list3] merged_list = merge_k_lists(lists) # The output will be the head node of the sorted linked list [1,1,2,3,4,4,5,6] # Helper function to convert linked list to list for easy comparison def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result assert linked_list_to_list(merged_list) == [1, 1, 2, 3, 4, 4, 5, 6] # Edge case: Empty list of lists assert merge_k_lists([]) is None # Edge case: All lists are empty assert merge_k_lists([None, None, None]) is None ``` # Performance Requirements - The function should run efficiently even when dealing with the maximum number of nodes (i.e., (10^4)). - The implementation should ideally run in (O(N log k)) time complexity, where (N) is the total number of nodes and (k) is the number of linked lists. By adding this question, we maintain the stylistic, complexity, and topical alignment with the provided sample question about detecting cycles in a directed graph. This new question continues to explore fundamental data structures (linked lists) and algorithms (merging, heap/priority queue usage) in a contextually relevant and technically consistent manner.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize heap for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode() current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next node = node.next if node: heapq.heappush(min_heap, (node.val, i, node)) return dummy.next"},{"question":"# Problem: Implement a File System with Access Control **Context**: You are requested to implement a simplified filesystem with access control mechanisms. The filesystem allows for the creation of files and directories, as well as operations for inserting, removing, and accessing files with permissions. **Problem Statement**: Implement a class `Filesystem` that supports directory creation, file creation, and access control. The filesystem should support directories and files as nodes. Each node will have permissions associated with it, determining who can read and write to it. # Requirements - **Class Implementation**: `Filesystem` - **Methods**: - `mkdir(path: str, permissions: dict) -> None`: Create a new directory at the given path with specified permissions. - `create_file(path: str, content: str, permissions: dict) -> None`: Create a new file at the given path with specified content and permissions. - `read_file(path: str, user: str) -> str`: Return the content of the file if the user has read permissions. - `write_file(path: str, user: str, content: str) -> None`: Write new content to the file if the user has write permissions. - Permissions should be a dictionary with keys `read` and `write`, each pointing to a list of users who have the respective permissions. - **Constraints**: - Files and directories should be created in a Unix-style path (e.g., `/home/user/docs`). - Ensure appropriate permissions are checked for both reading and writing operations. # Example ```python # Initialize the Filesystem fs = Filesystem() # Create a directory with permissions fs.mkdir(\'/home\', {\'read\': [\'admin\', \'user1\'], \'write\': [\'admin\']}) fs.mkdir(\'/home/user1\', {\'read\': [\'user1\'], \'write\': [\'user1\']}) # Create some files with permissions fs.create_file(\'/home/user1/file.txt\', \'Hello, World!\', {\'read\': [\'user1\'], \'write\': [\'user1\']}) fs.create_file(\'/home/admin.txt\', \'Top secret\', {\'read\': [\'admin\'], \'write\': [\'admin\']}) # Read file contents print(fs.read_file(\'/home/user1/file.txt\', \'user1\')) # \'Hello, World!\' print(fs.read_file(\'/home/admin.txt\', \'user1\')) # PermissionError # Write to files fs.write_file(\'/home/user1/file.txt\', \'user1\', \'New content\') print(fs.read_file(\'/home/user1/file.txt\', \'user1\')) # \'New content\' # Trying to write without permission fs.write_file(\'/home/user1/file.txt\', \'admin\', \'New content\') # PermissionError ``` **Constraints**: - All method calls to `mkdir`, `create_file`, `read_file`, and `write_file` must adhere to a Unix-style path. - Permissions must be strictly enforced according to the input mentioned above. - Invalid paths or permission violations should raise an appropriate exception (e.g., `PermissionError`). --- This problem requires an understanding of data structures, class design, and permissions/authorization mechanisms in programming. It encourages the developer to design and manage a self-contained filesystem structure, a common requirement in many software systems.","solution":"class PermissionError(Exception): pass class Filesystem: def __init__(self): self.root = {} def _traverse(self, path): parts = list(filter(None, path.split(\'/\'))) node = self.root for part in parts: if part not in node: return None node = node[part] return node def mkdir(self, path, permissions): parts = list(filter(None, path.split(\'/\'))) node = self.root for part in parts: if part not in node: node[part] = {\'__permissions__\': permissions, \'__type__\': \'dir\'} node = node.get(part) def create_file(self, path, content, permissions): parts = list(filter(None, path.split(\'/\'))) dir_path = parts[:-1] filename = parts[-1] node = self.root for part in dir_path: if part not in node or node[part][\'__type__\'] != \'dir\': raise FileNotFoundError(f\\"Directory {path} does not exist\\") node = node[part] node[filename] = {\'content\': content, \'__permissions__\': permissions, \'__type__\': \'file\'} def read_file(self, path, user): node = self._traverse(path) if node and node[\'__type__\'] == \'file\': permissions = node[\'__permissions__\'] if user in permissions[\'read\']: return node[\'content\'] else: raise PermissionError(f\\"{user} does not have read permission for {path}\\") else: raise FileNotFoundError(f\\"File {path} does not exist\\") def write_file(self, path, user, content): node = self._traverse(path) if node and node[\'__type__\'] == \'file\': permissions = node[\'__permissions__\'] if user in permissions[\'write\']: node[\'content\'] = content else: raise PermissionError(f\\"{user} does not have write permission for {path}\\") else: raise FileNotFoundError(f\\"File {path} does not exist\\")"},{"question":"# Question: Implement and Optimize Quicksort with Median of Three Pivot Selection **Context:** Quicksort is a widely used efficient sorting algorithm that employs a divide-and-conquer strategy. One optimization to the standard Quicksort algorithm is to use the \\"median of three\\" method to select the pivot, which can improve performance on certain kinds of data. **Objective:** Your task is to implement the Quicksort algorithm, utilizing the median of three elements (the first, middle, and last elements of the current subarray) for pivot selection. Ensure the correct sorting of the array and document the choice of the pivot each time partitioning occurs. **Function Signature:** ```python def quicksort_median_of_three(arr: list) -> list: Sorts the array using Quicksort algorithm with Median of Three pivot selection. Args: arr (list): A list of elements to be sorted. Returns: list: The sorted list. pass ``` **Requirements:** * Implement Quicksort to sort the array in-place using the median of three elements to choose the pivot. * Document the pivot selection for each partitioning step by printing the chosen pivot. * Maintain the original Quicksort properties while implementing the enhancements. **Input:** - A list of comparable elements, e.g., integers, floats. The input list can be of any length, including zero. **Output:** - A sorted list of the same elements. **Constraints:** - The input list can have elements in any order, including sorted or reverse sorted. - Handle median of three calculation efficiently. - Aim to keep the space complexity linearithmic in the average case, typically O(log n). **Examples:** ```python # Example 1: # Input: [4, 3, 2, 1] # Possible pivot print output: # Chosen pivot: 2 # Chosen pivot: 3 # Chosen pivot: 1 # Output: [1, 2, 3, 4] >>> quicksort_median_of_three([4, 3, 2, 1]) [1, 2, 3, 4] # Example 2: # Input: [-4, 20, 0, -50, 100, -1] # Possible pivot print output: # Chosen pivot: -4 # Chosen pivot: 0 # Chosen pivot: -50 # Output: [-50, -4, -1, 0, 20, 100] >>> quicksort_median_of_three([-4, 20, 0, -50, 100, -1]) [-50, -4, -1, 0, 20, 100] # Example 3: # Input: [-0.1, 0.2, 1.3, -0.8] # Possible pivot print output: # Chosen pivot: -0.1 # Chosen pivot: -0.8 # Output: [-0.8, -0.1, 0.2, 1.3] >>> quicksort_median_of_three([-0.1, 0.2, 1.3, -0.8]) [-0.8, -0.1, 0.2, 1.3] # Example 4: # Input: [] # Possible pivot print output: None (no output as the list is empty) # Output: [] >>> quicksort_median_of_three([]) [] ``` **Edge Cases to Consider:** - Empty array `[]` - Arrays with duplicate elements, e.g., `[3, 3, 1, 1]` - Arrays with all identical elements, e.g., `[1, 1, 1, 1]`","solution":"def quicksort_median_of_three(arr): Sorts the array using Quicksort algorithm with Median of Three pivot selection. Args: arr (list): A list of elements to be sorted. Returns: list: The sorted list. def median_of_three(array, low, high): mid = (low + high) // 2 a = array[low] b = array[mid] c = array[high] if a > b: if a < c: return low elif b > c: return mid else: return high else: if a > c: return low elif b < c: return mid else: return high def partition(array, low, high): median_index = median_of_three(array, low, high) pivot = array[median_index] print(f\\"Chosen pivot: {pivot}\\") array[median_index], array[low] = array[low], array[median_index] border = low for i in range(low, high + 1): if array[i] < pivot: border += 1 array[i], array[border] = array[border], array[i] array[low], array[border] = array[border], array[low] return border def quicksort_recursive(array, low, high): if low < high: p = partition(array, low, high) quicksort_recursive(array, low, p - 1) quicksort_recursive(array, p + 1, high) if arr: quicksort_recursive(arr, 0, len(arr) - 1) return arr"},{"question":"# Problem Statement You are provided with a string containing characters including lowercase alphabets and digits. Your task is to determine if the string contains all ten digits (0-9) at least once. # Function Signature ```python def contains_all_digits(s: str) -> bool: pass ``` # Input * A single string `s` (0 ≤ len(s) ≤ 10^4). # Output * Return `True` if the string contains all ten digits (0-9) at least once, otherwise `False`. # Constraints * The string may contain characters other than digits and lowercase alphabets, which should be ignored. # Performance Requirements * Your solution should have a time complexity of O(n), where n is the length of the string. # Examples ```python assert contains_all_digits(\\"abcdefghijklmnopqrstuvwxyz0123456789\\") == True assert contains_all_digits(\\"a1b2c3d4e5f6g7h8i9j0\\") == True assert contains_all_digits(\\"hello12345678world9\\") == False assert contains_all_digits(\\"123456789\\") == False assert contains_all_digits(\\"\\") == False ```","solution":"def contains_all_digits(s: str) -> bool: Determine if the string contains all ten digits (0-9) at least once. Parameters: s (str): Input string Returns: bool: True if the string contains all ten digits, False otherwise digit_set = set(\\"0123456789\\") seen_digits = set() for char in s: if char in digit_set: seen_digits.add(char) if len(seen_digits) == 10: return True return False # Examples assert contains_all_digits(\\"abcdefghijklmnopqrstuvwxyz0123456789\\") == True assert contains_all_digits(\\"a1b2c3d4e5f6g7h8i9j0\\") == True assert contains_all_digits(\\"hello12345678world9\\") == False assert contains_all_digits(\\"123456789\\") == False assert contains_all_digits(\\"\\") == False"},{"question":"# Coding Assessment Question: Chef\'s Balanced Menu Context As a chef, you aim to create a balanced menu by ensuring the total time for preparing a set of dishes doesn\'t exceed a given limit. You have a list of dishes, each with its preparation time, and a maximum total preparation time. You need to determine the optimal combination of dishes to include in the menu such that their total preparation time is as close as possible to the given limit without exceeding it. Task Write a function `optimal_menu(dish_times, max_time)` that takes: * `dish_times` (a list of integers representing the preparation times of dishes) * `max_time` (an integer representing the maximum allowable total preparation time for the menu) The function should return: * A list of integers representing the preparation times of the selected dishes whose total preparation time is closest to but does not exceed `max_time`. Constraints 1. `1 <= len(dish_times) <= 20` 2. `1 <= dish_times[i] <= 1000` 3. `1 <= max_time <= 10000` Requirements 1. If multiple combinations yield the same total preparation time, any one of them can be returned. 2. Ensure the function is efficient given the constraints. 3. Handle edge cases appropriately. Example ```python def optimal_menu(dish_times, max_time): # your implementation here # Example usage print(optimal_menu([120, 90, 150, 100], 300)) # Output: [120, 150] or [90, 100, 120] print(optimal_menu([200, 200, 200], 500)) # Output: [200, 200] print(optimal_menu([50, 30, 90, 45], 100)) # Output: [50, 45] or [30, 45, 20] ``` Implementation Considerations * Use dynamic programming or backtracking to find the optimal combination. * Consider how to handle small and large input sizes efficiently.","solution":"from itertools import combinations def optimal_menu(dish_times, max_time): Returns the combination of dish preparation times that get closest to, but do not exceed, the max_time. best_combination = [] best_time = 0 # Generate all possible combinations of dishes for r in range(1, len(dish_times) + 1): for combo in combinations(dish_times, r): total_time = sum(combo) if total_time <= max_time and total_time > best_time: best_combination = combo best_time = total_time return list(best_combination)"},{"question":"# Scenario As a developer, you are assigned to work on a data analysis application that processes log data from various systems. One of the key features of this application is to identify the most frequently occurring word in given log data while ignoring case and punctuation. # Task Write a Python function `most_frequent_word(log: str) -> str` to find and return the most frequently occurring word in the input log string. In case of a tie, return the lexicographically smallest word. Your function should ignore punctuation and be case-insensitive. # Input/Output Formats * **Input**: A string `log` containing up to 10^6 characters which includes letters, numbers, spaces, and punctuation marks. * **Output**: A single string representing the most frequently occurring word. # Constraints * The input string may contain alphanumeric characters, spaces, punctuation marks, and mixed case. * The words are separated by white spaces. * Punctuation marks should be ignored. # Performance Requirements Your function should handle large strings efficiently within linear time complexity. # Examples ```python >>> most_frequent_word(\\"Hello world! Hello everyone.\\") \'hello\' >>> most_frequent_word(\\"This is a test. This test is only a test.\\") \'test\' >>> most_frequent_word(\\"Data analysis is fun. Data is insightful.\\") \'data\' >>> most_frequent_word(\\"Python, PYTHON, python; PYTHON!\\") \'python\' >>> most_frequent_word(\\"apple a day keeps the doctor away.\\") \'a\' >>> most_frequent_word(\\"@@@@@@ !!!!!\\") \'\' ``` # Edge Cases * If the input string contains no alphanumeric characters or words, the function should return an empty string. * The function should correctly handle mixed cases and ignore punctuation while finding the most frequent word.","solution":"import re from collections import Counter def most_frequent_word(log: str) -> str: Returns the most frequently occurring word in the input log string, ignoring case and punctuation. In case of a tie, returns the lexicographically smallest word. # Remove punctuation using regex and convert to lowercase words = re.findall(r\'bw+b\', log.lower()) if not words: return \'\' # Count the frequency of each word counter = Counter(words) # Find the most frequently occurring word most_common_word, highest_count = min(counter.items(), key=lambda item: (-item[1], item[0])) return most_common_word"},{"question":"# Sum of Prime Digits Context In number theory, a prime digit is a digit that itself is a prime number. The prime digits are 2, 3, 5, and 7. Your task is to write a function that calculates the sum of all prime digits of a given input number. If the input is negative, the function should compute the sum of the prime digits ignoring the sign. Task Write a function `sum_of_prime_digits(x: int) -> int` that takes an integer `x` as input and returns the sum of its prime digits. The function should raise a `TypeError` if the input is not an integer. Function Signature ```python def sum_of_prime_digits(x: int) -> int: ``` Input * An integer `x` where ( |x| leq 10^{18} ). Output * An integer representing the sum of the prime digits in the input number. * Raise `TypeError` if the input is not an integer. Example ```python >>> sum_of_prime_digits(123456) 10 >>> sum_of_prime_digits(-7531) 15 >>> sum_of_prime_digits(0) 0 >>> sum_of_prime_digits(8888) 0 >>> sum_of_prime_digits(12.3) Traceback (most recent call last): ... TypeError: Input value of [number=12.3] must be an integer ``` Constraints * ( |x| leq 10^{18} ) * Function should not take input/output from the user directly; it should be purely functional. Hints * Consider handling both positive and negative inputs uniformly. * Implement efficient digit extraction to handle large numbers.","solution":"def sum_of_prime_digits(x: int) -> int: Returns the sum of the prime digits in the input integer x. Prime digits are 2, 3, 5, and 7. Parameters: x (int): The input number, which can be positive or negative. Returns: int: The sum of the prime digits in x. Raises: TypeError: If the input is not an integer. if not isinstance(x, int): raise TypeError(f\\"Input value of [number={x}] must be an integer\\") prime_digits = {\'2\', \'3\', \'5\', \'7\'} digit_sum = 0 for digit in str(abs(x)): if digit in prime_digits: digit_sum += int(digit) return digit_sum"},{"question":"**Problem Statement**: Write a function that computes the n-th Tribonacci number. The Tribonacci sequence T(n) is defined as follows: - T(0) = 0, - T(1) = 1, - T(2) = 1, - and T(n) = T(n-1) + T(n-2) + T(n-3) for n >= 3. You need to implement both a recursive and an iterative method to compute this sequence. Ensure to handle common edge cases and error conditions properly. # Function Signatures: ```python def tribonacci_recursive(n: int) -> int: pass def tribonacci_iterative(n: int) -> int: pass ``` # Input: The functions `tribonacci_recursive` and `tribonacci_iterative` should accept the following input: - `n` is a non-negative integer. # Output: - Both functions should return an integer, representing the n-th Tribonacci number. - If the input is a non-integer, raise a `ValueError` with the message `\\"<function_name>() only accepts integral values\\"`. - If the input is a negative integer, raise a `ValueError` with the message `\\"<function_name>() not defined for negative values\\"`. # Examples: ```python tribonacci_recursive(4) # Expected output: 4 tribonacci_iterative(4) # Expected output: 4 tribonacci_recursive(25) # Expected output: 1389537 tribonacci_iterative(10) # Expected output: 149 ``` # Constraints: - Both functions must compute the result in ( O(n) ) time complexity for the iterative solution. - The recursive function should use memoization to achieve an optimal time complexity. - Both functions must handle the edge cases and errors as specified.","solution":"def tribonacci_recursive(n: int) -> int: def memo_tribo(n, memo): if n in memo: return memo[n] memo[n] = memo_tribo(n-1, memo) + memo_tribo(n-2, memo) + memo_tribo(n-3, memo) return memo[n] if not isinstance(n, int): raise ValueError(\\"tribonacci_recursive() only accepts integral values\\") if n < 0: raise ValueError(\\"tribonacci_recursive() not defined for negative values\\") memo = {0: 0, 1: 1, 2: 1} return memo_tribo(n, memo) def tribonacci_iterative(n: int) -> int: if not isinstance(n, int): raise ValueError(\\"tribonacci_iterative() only accepts integral values\\") if n < 0: raise ValueError(\\"tribonacci_iterative() not defined for negative values\\") if n == 0: return 0 if n == 1 or n == 2: return 1 t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): t_next = t0 + t1 + t2 t0, t1, t2 = t1, t2, t_next return t2"},{"question":"You are tasked to write a Python function to solve the following problem: # Problem: Write a function `merge_integers(arr1, arr2, descending=False)` that merges two sorted lists of integers into one sorted list. The combined list should be sorted in ascending order by default, but can be sorted in descending order if specified. # Context: Given two sorted arrays of integers `arr1` and `arr2`, merge them into a single sorted array. Use the optional parameter `descending` to control the order of sorting. If `descending` is set to `True`, the merged list should be in descending order; otherwise, it should be in ascending order. # Requirements: 1. Implement a function `merge_integers(arr1, arr2, descending=False)` that merges the two sorted arrays into one sorted array. 2. Ensure the function is efficient, without using built-in sorting methods after merging. # Input: - `arr1`: A list of integers sorted in ascending order. - `arr2`: Another list of integers sorted in ascending order. - `descending`: A boolean flag indicating whether the result should be sorted in descending order (default is `False`). # Output: - A list of integers representing the merged and sorted array according to the specified order. # Example: ```python def merge_integers(arr1, arr2, descending=False): # Implement the function here. pass # Example usage: print(merge_integers([1, 3, 5], [2, 4, 6])) # Output should be [1, 2, 3, 4, 5, 6] print(merge_integers([1, 3, 5], [2, 4, 6], descending=True)) # Output should be [6, 5, 4, 3, 2, 1] ``` # Constraints: - The inputs `arr1` and `arr2` will be provided in sorted order (ascending). - The lengths of `arr1` and `arr2` combined will not exceed 10,000 elements. - Consider cases where one or both arrays might be empty. - Optimize the solution to handle the merging process efficiently. # Note: - A correct implementation should demonstrate an understanding of merging sorted lists and conditional sorting logic without directly invoking built-in sort functions on the combined list post-merge. --- This new question integrates seamlessly with the existing set by maintaining a similar style, complexity, and scope. It explores list merging and conditional sorting, which complements the topic of handling numerical sequences and algorithm optimization.","solution":"def merge_integers(arr1, arr2, descending=False): Merges two sorted lists of integers into one sorted list. Parameters: arr1 (list): A list of integers sorted in ascending order. arr2 (list): Another list of integers sorted in ascending order. descending (bool): A flag indicating whether the result should be sorted in descending order (default is False). Returns: list: A merged and sorted list of integers according to the specified order. merged_list = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_list.append(arr1[i]) i += 1 else: merged_list.append(arr2[j]) j += 1 while i < len(arr1): merged_list.append(arr1[i]) i += 1 while j < len(arr2): merged_list.append(arr2[j]) j += 1 if descending: return merged_list[::-1] return merged_list"},{"question":"# Coding Assessment Question **Problem Statement:** You are given a class `RomanNumeralConverter` which includes methods to convert integers to Roman numerals and vice versa. A Roman numeral represents a number using combinations of letters from the Latin alphabet (I, V, X, L, C, D, M), each with a fixed integer value. **Objective:** Write a function `process_numerals` that takes a list of operations and values and returns the corresponding Roman numeral conversions using the provided `RomanNumeralConverter` class. **Function Signature:** ```python def process_numerals(operations: List[Tuple[str, Union[int, str]]]) -> List[Union[int, str]]: ``` **Input:** * `operations`: A list of tuples where each tuple contains: - A string indicating the operation type: `\\"to_roman\\"` or `\\"from_roman\\"`. - An integer or string which is the value to convert. **Output:** * A list of integers or strings where each element is the result of the corresponding conversion operation. **Constraints:** * Each integer to be converted to a Roman numeral will be between 1 and 3999 inclusive. * Each string representing a Roman numeral will be a valid Roman numeral within the range 1 to 3999. * Invalid operations should be ignored (i.e., operations other than `\\"to_roman\\"` or `\\"from_roman\\"`). **Example:** ```python operations = [(\\"to_roman\\", 1999), (\\"from_roman\\", \\"MMXXI\\"), (\\"to_roman\\", 45), (\\"from_roman\\", \\"XLV\\")] result = process_numerals(operations) print(result) # Output: [\\"MCMXCIX\\", 2021, \\"XLV\\", 45] ``` **Requirements:** 1. Implement the function `process_numerals` by using the `RomanNumeralConverter` class methods. 2. Correct handling of edge cases (e.g., integer and string constraints) as described. 3. Thoroughly test the function with various inputs representing different edge cases.","solution":"class RomanNumeralConverter: This class provides methods to convert integers to Roman numerals and vice versa. @staticmethod def int_to_roman(num: int) -> str: val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num @staticmethod def roman_to_int(s: str) -> int: roman = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000, \'IV\': 4, \'IX\': 9, \'XL\': 40, \'XC\': 90, \'CD\': 400, \'CM\': 900 } i = 0 num = 0 while i < len(s): if i+1 < len(s) and s[i:i+2] in roman: num += roman[s[i:i+2]] i += 2 else: num += roman[s[i]] i += 1 return num def process_numerals(operations): converter = RomanNumeralConverter() results = [] for operation, value in operations: if operation == \\"to_roman\\" and isinstance(value, int): results.append(converter.int_to_roman(value)) elif operation == \\"from_roman\\" and isinstance(value, str): results.append(converter.roman_to_int(value)) return results"},{"question":"# Question: You are tasked with designing a system that allows you to track the movement of various types of vehicles on a highway. You will implement this functionality using object-oriented programming principles to ensure easy addition of new vehicle types in the future. Each vehicle has a unique ID, a type, and a current speed. Requirements: 1. Implement the base class `Vehicle` with the following methods: - `Vehicle.__init__(self, vehicle_id: str, vehicle_type: str, speed: float)`: Initializes a vehicle with a unique ID, type, and speed. - `Vehicle.update_speed(self, new_speed: float)`: Updates the speed of the vehicle. - `Vehicle.get_info(self) -> dict`: Returns the vehicle\'s information as a dictionary with keys `id`, `type`, and `speed`. 2. Implement derived classes for different types of vehicles: - `Car` and `Truck`: These classes should inherit from `Vehicle` and should have specific attributes or methods relevant to the vehicle type if needed. 3. Implement the class `HighwayTracker` to manage the vehicles on the highway with the following methods: - `HighwayTracker.add_vehicle(self, vehicle: Vehicle)`: Adds a vehicle to the highway tracker. - `HighwayTracker.get_vehicle_info(self, vehicle_id: str) -> dict`: Returns the information of a vehicle given its ID. - `HighwayTracker.get_speeds(self) -> list`: Returns a list of speeds of all vehicles currently being tracked. Input: - `vehicle_id`: str (unique identifier for the vehicle) - `vehicle_type`: str (type of the vehicle, e.g., \'Car\', \'Truck\') - `speed`: float (current speed of the vehicle) - `new_speed`: float (new speed to update the vehicle) - `vehicles_list`: list of Vehicle instances (list of vehicles to be added) - `vehicle_ids_list`: list of str (list of vehicle IDs to retrieve information for) Output: - The functionality of the classes and methods as described above. # Example: ```python # Initialize vehicles car1 = Car(vehicle_id=\'C123\', vehicle_type=\'Car\', speed=60) truck1 = Truck(vehicle_id=\'T456\', vehicle_type=\'Truck\', speed=50) # Initialize HighwayTracker and add vehicles tracker = HighwayTracker() tracker.add_vehicle(car1) tracker.add_vehicle(truck1) # Update speed of a vehicle car1.update_speed(65) # Get vehicle information assert tracker.get_vehicle_info(\'C123\') == {\'id\': \'C123\', \'type\': \'Car\', \'speed\': 65} # Get speeds of all vehicles assert tracker.get_speeds() == [65, 50] ``` # Notes: - Ensure proper encapsulation and use of object-oriented principles. - Handle cases where a vehicle ID does not exist in the highway tracker methods appropriately. - The `HighwayTracker` should be able to handle multiple vehicles of different types efficiently. - Do not use any external libraries apart from the Python standard library. # Implementation: Implement the `Vehicle`, `Car`, `Truck`, and `HighwayTracker` classes in Python, ensuring that they correctly follow the specified requirements and demonstrate the listed functionalities.","solution":"class Vehicle: def __init__(self, vehicle_id: str, vehicle_type: str, speed: float): self.vehicle_id = vehicle_id self.vehicle_type = vehicle_type self.speed = speed def update_speed(self, new_speed: float): self.speed = new_speed def get_info(self) -> dict: return {\'id\': self.vehicle_id, \'type\': self.vehicle_type, \'speed\': self.speed} class Car(Vehicle): def __init__(self, vehicle_id: str, vehicle_type: str = \'Car\', speed: float = 0): super().__init__(vehicle_id, vehicle_type, speed) class Truck(Vehicle): def __init__(self, vehicle_id: str, vehicle_type: str = \'Truck\', speed: float = 0): super().__init__(vehicle_id, vehicle_type, speed) class HighwayTracker: def __init__(self): self.vehicles = {} def add_vehicle(self, vehicle: Vehicle): self.vehicles[vehicle.vehicle_id] = vehicle def get_vehicle_info(self, vehicle_id: str) -> dict: vehicle = self.vehicles.get(vehicle_id) if vehicle: return vehicle.get_info() return {} def get_speeds(self) -> list: return [vehicle.speed for vehicle in self.vehicles.values()]"},{"question":"Problem Statement: You are tasked with writing a function to find the k largest elements in a given unsorted array and return them sorted in non-decreasing order. # Function Definition Write a function: ```python def k_largest_elements(arr: list, k: int) -> list: Given an unsorted list \'arr\' of integers and an integer \'k\', find the \'k\' largest elements in the list and return them sorted in non-decreasing order. :param arr: A list of integers :param k: An integer. The number of largest elements to find (1 <= k <= len(arr)) :return: A list of \'k\' largest integers from the original list, sorted in non-decreasing order Example: >>> k_largest_elements([10, 4, 5, 8, 6, 11, 26], 3) [10, 11, 26] >>> k_largest_elements([1, 23, 12, 9, 30, 2, 50], 4) [12, 23, 30, 50] >>> k_largest_elements([3, 2, 1, 5, 6, 4], 2) [5, 6] pass ``` # Input - A list of integers `arr` (1 <= len(arr) <= 10^4, -10^6 <= arr[i] <= 10^6) - An integer `k` (1 <= k <= len(arr)) # Output - A list of `k` largest integers from `arr` sorted in non-decreasing order. # Constraints - The function must handle values efficiently up to the upper limit of the array length. # Scenario You need to extract the k largest elements from an unsorted list and return these values sorted in non-decreasing order. This problem will test your ability to manipulate arrays, understand sorting mechanisms, and manage algorithm efficiency to handle large inputs. # Hints: - Consider using a heap (min-heap) to efficiently find the k largest elements. - The Python `heapq` library may be useful. - Alternatively, you can sort the array and extract the relevant slice if a simpler approach is preferred. **Testing:** Ensure that your solution passes the given examples and consider additional edge cases, for instance: - `k_largest_elements([0], 1) -> [0]` - `k_largest_elements([-1, -2, -3, -4, -5], 3) -> [-3, -2, -1]`","solution":"import heapq def k_largest_elements(arr: list, k: int) -> list: Given an unsorted list \'arr\' of integers and an integer \'k\', find the \'k\' largest elements in the list and return them sorted in non-decreasing order. :param arr: A list of integers :param k: An integer. The number of largest elements to find (1 <= k <= len(arr)) :return: A list of \'k\' largest integers from the original list, sorted in non-decreasing order # Min-heap to keep the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) # Turn list into a heap for num in arr[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) # Sort the min-heap to get the k largest elements in non-decreasing order return sorted(min_heap)"},{"question":"# Problem Statement: Rotate Image (90 Degrees Clockwise) You are provided with an `n x n` matrix representing an image. Perform an in-place rotation of the image by 90 degrees clockwise. Implement an algorithm to achieve this transformation efficiently. # Detailed Requirements: - You are given an `n x n` 2D matrix representing an image. - Rotate the matrix 90 degrees clockwise in-place. **Input**: - A 2D list of integers `matrix` representing the image, where `1 <= n <= 1000`. **Output**: - The input matrix should be modified directly to its rotated form. No return value is needed. # Constraints: - Consider the edge cases, such as minimal values of `n` (1 or 2), and larger values up to 1000. - Focus on in-place transformations to avoid excessive use of extra memory. # Example: ```python def rotate_image(matrix: list[list[int]]) -> None: # Implement this function pass # Example Use Cases: matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(matrix1) # matrix1 should now be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_image(matrix2) # matrix2 should now be: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ``` # Guidelines: - **Transformation Logic**: Consider breaking the problem into two steps: first transpose the matrix, then reverse each row. - **Edge Cases**: Handle matrices with different values and sizes, including smallest and largest valid inputs. - **Efficiency**: Aim for an in-place transformation with O(n^2) time complexity and minimal extra space usage.","solution":"def rotate_image(matrix: list[list[int]]) -> None: Rotates the given n x n 2D matrix by 90 degrees clockwise in place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement: You are given an integer `n` and a list of edges `edges`. Your task is to implement a function `is_tree(n: int, edges: list[tuple[int, int]]) -> bool` that determines whether the given edges form a tree with `n` nodes. A tree is a connected graph with no cycles. # Input Format: * `n` (1 <= n <= 10^4): An integer representing the number of nodes. * `edges` (0 <= len(edges) <= 10^4): A list of tuples where each tuple `(a, b)` represents an undirected edge between nodes `a` and `b` (0 <= a, b < n). # Output Format: * Return `True` if the edges form a tree, otherwise return `False`. # Constraints: * Consider nodes numbered from 0 to n-1. * It is guaranteed that edges are valid and do not repeat. # Example: Example 1: ``` Input: n = 5 edges = [(0, 1), (0, 2), (0, 3), (3, 4)] Output: True Explanation: The graph is connected with no cycles, forming a tree. ``` Example 2: ``` Input: n = 5 edges = [(0, 1), (1, 2), (2, 3), (1, 3), (1, 4)] Output: False Explanation: The graph contains a cycle (1-2-3-1). ``` Example 3: ``` Input: n = 4 edges = [(0, 1), (2, 3)] Output: False Explanation: The graph is disconnected. Node 0 and 1 are in one component, and node 2 and 3 are in another. ``` # Implementation Guidelines: 1. **Input Validation**: Ensure that `n` is a positive integer and `edges` is a list of valid tuples. 2. **Graph Representation**: Use an adjacency list to represent the graph. 3. **Cycle Detection**: Use Depth-First Search (DFS) to detect cycles in the graph. 4. **Connectedness Check**: Ensure all nodes are reachable from any starting node, implying the graph is connected. 5. **Edge-Node Relation**: Check if the number of edges is exactly `n-1` which is a property of trees. Implement the function `is_tree` in Python: ```python def is_tree(n: int, edges: list[tuple[int, int]]) -> bool: # Your code here pass ```","solution":"def is_tree(n: int, edges: list[tuple[int, int]]) -> bool: if n == 0: return False # A tree should have exactly n - 1 edges if len(edges) != n - 1: return False from collections import defaultdict, deque # Create adjacency list representation of the graph adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Use BFS or DFS to ensure the graph is connected and has no cycles visited = set() def bfs(node): queue = deque([node]) while queue: current = queue.popleft() for neighbor in adj_list[current]: if neighbor in visited: continue visited.add(neighbor) queue.append(neighbor) # Start BFS from node 0 visited.add(0) bfs(0) # Check if all nodes are visited return len(visited) == n"},{"question":"# Coding Assessment Question You are working on a system for arranging classroom seating based on students\' heights, ensuring that no shorter student sits directly behind a taller student. You need to implement a function that, given a list of students\' heights, arranges them in non-decreasing order from the back row to the front row. Your task is to implement the function `arrange_seating` which takes a list of students\' heights and returns a new list representing the seating arrangement from back to front in non-decreasing order. The arrangement should start with the tallest student at the back (first in the list) and the shortest student at the front (last in the list). Function Definition **arrange_seating(heights: List[int]) -> List[int]** * **Input**: - `heights` (List[int]): A list of integers representing the heights of the students. * **Output**: - Returns a list of integers representing the seating arrangement from back to front in non-decreasing order. # Example ```python arrange_seating([160, 150, 170, 145, 155]) # should return [170, 160, 155, 150, 145] arrange_seating([120, 110, 130, 125, 115]) # should return [130, 125, 120, 115, 110] ``` # Requirements - The function should handle an empty list by returning an empty list. - The list of heights provided can be assumed to contain only non-negative integers. - The function should maintain an efficient sorting mechanism to ensure optimal performance. Implement the `arrange_seating` function that meets these requirements.","solution":"def arrange_seating(heights): Arranges the list of students\' heights in non-decreasing order from back to front. Parameters: heights (List[int]): A list of students\' heights. Returns: List[int]: A new list representing the seating arrangement from back to front in non-decreasing order. # Sorting the list in descending order to represent from back to front return sorted(heights, reverse=True)"},{"question":"Write a function `validate_and_merge_profiles` that takes two dictionaries representing user profiles and merges them into a single dictionary. Additionally, it enforces validation rules on certain keys in the profiles. # Requirements: 1. The first dictionary represents the base profile and is required. 2. The second dictionary is optional and represents additional profile data. If not provided, the function should return the base profile unchanged. 3. The function should merge the dictionaries. In case of key conflicts, the values from the second dictionary should overwrite those in the first. 4. The keys \\"age\\" and \\"email\\" must be present in the resulting dictionary. 5. Validate: - The \\"age\\" key must map to a positive integer. - The \\"email\\" key must map to a string that contains an \\"@\\" symbol. - If any validation fails, raise a ValueError with an appropriate error message. 6. Update the Docstring and test cases to reflect the expected behavior and edge cases. # Function Signature: ```python def validate_and_merge_profiles( base_profile: dict, additional_profile: dict = {} ) -> dict: Input Parameters ---------------- base_profile : dict A dictionary containing the base user profile. additional_profile : dict, optional A dictionary containing additional user profile data (default is {}). Returns ------- result : dict A dictionary containing the merged user profile. Raises ------ ValueError If \'age\' is not a positive integer, or if \'email\' does not contain an \\"@\\" symbol, or if either \'age\' or \'email\' is missing from the resulting dictionary. Examples -------- >>> validate_and_merge_profiles({\'name\': \'Jane\', \'age\': 25, \'email\': \'jane@example.com\'}) {\'name\': \'Jane\', \'age\': 25, \'email\': \'jane@example.com\'} >>> validate_and_merge_profiles({\'name\': \'Jane\', \'age\': 25, \'email\': \'jane@example.com\'}, {\'age\': 30}) {\'name\': \'Jane\', \'age\': 30, \'email\': \'jane@example.com\'} >>> validate_and_merge_profiles({\'name\': \'Jane\'}, {\'age\': 25, \'email\': \'jane@example.com\'}) {\'name\': \'Jane\', \'age\': 25, \'email\': \'jane@example.com\'} >>> validate_and_merge_profiles({\'name\': \'Jane\', \'age\': \'25\', \'email\': \'jane@example.com\'}) Traceback (most recent call last): ... ValueError: Age must be a positive integer. >>> validate_and_merge_profiles({\'name\': \'Jane\', \'age\': 25, \'email\': \'janeexample.com\'}) Traceback (most recent call last): ... ValueError: Email must contain \'@\' symbol. >>> validate_and_merge_profiles({\'name\': \'Jane\'}, {}) Traceback (most recent call last): ... ValueError: Resulting profile must contain \'age\' and \'email\'. pass ``` # Constraints: * The resulting profile dictionary must contain the keys \'age\' and \'email\' with valid values. * If `additional_profile` is not provided, return the `base_profile` only if it has valid \'age\' and \'email\' keys. * If any validation fails, raise the appropriate ValueError with a clear error message.","solution":"def validate_and_merge_profiles(base_profile: dict, additional_profile: dict = {}) -> dict: Input Parameters ---------------- base_profile : dict A dictionary containing the base user profile. additional_profile : dict, optional A dictionary containing additional user profile data (default is {}). Returns ------- result : dict A dictionary containing the merged user profile. Raises ------ ValueError If \'age\' is not a positive integer, or if \'email\' does not contain an \\"@\\" symbol, or if either \'age\' or \'email\' is missing from the resulting dictionary. Examples -------- >>> validate_and_merge_profiles({\'name\': \'Jane\', \'age\': 25, \'email\': \'jane@example.com\'}) {\'name\': \'Jane\', \'age\': 25, \'email\': \'jane@example.com\'} >>> validate_and_merge_profiles({\'name\': \'Jane\', \'age\': 25, \'email\': \'jane@example.com\'}, {\'age\': 30}) {\'name\': \'Jane\', \'age\': 30, \'email\': \'jane@example.com\'} >>> validate_and_merge_profiles({\'name\': \'Jane\'}, {\'age\': 25, \'email\': \'jane@example.com\'}) {\'name\': \'Jane\', \'age\': 25, \'email\': \'jane@example.com\'} >>> validate_and_merge_profiles({\'name\': \'Jane\', \'age\': \'25\', \'email\': \'jane@example.com\'}) Traceback (most recent call last): ... ValueError: Age must be a positive integer. >>> validate_and_merge_profiles({\'name\': \'Jane\', \'age\': 25, \'email\': \'janeexample.com\'}) Traceback (most recent call last): ... ValueError: Email must contain \'@\' symbol. >>> validate_and_merge_profiles({\'name\': \'Jane\'}, {}) Traceback (most recent call last): ... ValueError: Resulting profile must contain \'age\' and \'email\'. # Merge profiles, additional_profile overwrites base_profile merged_profile = {**base_profile, **additional_profile} # Ensure \'age\' and \'email\' are in the merged profile if \'age\' not in merged_profile or \'email\' not in merged_profile: raise ValueError(\\"Resulting profile must contain \'age\' and \'email\'.\\") # Validate \'age\' key age = merged_profile[\'age\'] if not isinstance(age, int) or age <= 0: raise ValueError(\\"Age must be a positive integer.\\") # Validate \'email\' key email = merged_profile[\'email\'] if not isinstance(email, str) or \'@\' not in email: raise ValueError(\\"Email must contain \'@\' symbol.\\") return merged_profile"},{"question":"# Problem Statement: You are required to implement a version control system for document versions known as `DocumentHistory`. This system will support functionalities to create new versions, fetch a specific version, and check the difference between two versions of the document. # Detailed Requirements: 1. Create a class `DocumentHistory` with the following methods: * `add_version(self, content: str) -> int`: Accepts the content of a new document version and returns the version number of the newly added version. * `get_version(self, version_number: int) -> str`: Accepts a version number and returns the content of that version. * `compare_versions(self, first_version: int, second_version: int) -> List[str]`: Accepts two version numbers and returns a list of differences where each element is either \\"-<text>\\" if a line is deleted in the second version, or \\"+<text>\\" if a line is added in the second version. Unchanged lines should not be included. 2. Constraints: * Assume the input `content` consists of lines of text separated by newline characters. * Versions are numbered starting from 1. * The methods should handle cases where specified version numbers do not exist by raising an appropriate error exception. * The comparison is line-by-line (not character-by-character). 3. Input and Output formats: * The methods will receive and return data as specified above. * Sample input: `add_version(\\"First versionnSecond line\\")` `get_version(1)` `compare_versions(1, 2)` * Sample output: `1` `\\"First versionnSecond line\\"` `[\\"-This is the first version\\", \\"+This is the updated version\\"]` # Performance: * The `add_version` method should have a time complexity of O(m), where m is the number of lines in the new content. * The `get_version` and `compare_versions` methods should operate in linear time complexity O(n), where n is the number of versions or lines involved. # Example: ```python # Sample usage of the DocumentHistory class doc_history = DocumentHistory() # Adding versions version_1 = doc_history.add_version(\'First versionnSecond line\') print(version_1) # Output: 1 version_2 = doc_history.add_version(\'First versionnSecond linenThird line\') print(version_2) # Output: 2 version_3 = doc_history.add_version(\'Updated first linenSecond linenThird line\') print(version_3) # Output: 3 # Fetching a specific version content = doc_history.get_version(1) print(content) # Output: \\"First versionnSecond line\\" # Comparing two versions differences = doc_history.compare_versions(1, 3) print(differences) # Output: [\\"-First version\\", \\"+Updated first line\\", \\"+Third line\\"] ```","solution":"class DocumentHistory: def __init__(self): self.versions = [] def add_version(self, content: str) -> int: self.versions.append(content.split(\'n\')) return len(self.versions) def get_version(self, version_number: int) -> str: if version_number < 1 or version_number > len(self.versions): raise ValueError(\\"Invalid version number\\") return \'n\'.join(self.versions[version_number - 1]) def compare_versions(self, first_version: int, second_version: int) -> list: if first_version < 1 or first_version > len(self.versions) or second_version < 1 or second_version > len(self.versions): raise ValueError(\\"Invalid version number\\") first_content = self.versions[first_version - 1] second_content = self.versions[second_version - 1] max_lines = max(len(first_content), len(second_content)) differences = [] for i in range(max_lines): line1 = first_content[i] if i < len(first_content) else \'\' line2 = second_content[i] if i < len(second_content) else \'\' if line1 != line2: if line1: differences.append(f\\"-{line1}\\") if line2: differences.append(f\\"+{line2}\\") return differences"},{"question":"# Problem Statement Implement a `merge_sorted_arrays` function that takes two sorted arrays of integers and merges them into a single sorted array. Requirements 1. **Function Signature**: ```python def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: ``` 2. **Parameters**: - `arr1` (list of int): The first sorted array. - `arr2` (list of int): The second sorted array. 3. **Output**: - A list of integers containing all the elements from `arr1` and `arr2`, sorted in non-decreasing order. 4. **Constraints and Assumptions**: - Both input arrays are already sorted in non-decreasing order. - Both input arrays can be of different lengths, including zero. 5. **Example**: ```python arr1 = [1, 3, 5, 7] arr2 = [2, 4, 6, 8] merge_sorted_arrays(arr1, arr2) >>> [1, 2, 3, 4, 5, 6, 7, 8] arr1 = [1, 3, 5] arr2 = [] merge_sorted_arrays(arr1, arr2) >>> [1, 3, 5] arr1 = [] arr2 = [2, 4, 6] merge_sorted_arrays(arr1, arr2) >>> [2, 4, 6] ``` Implementation Steps 1. Initialize pointers for both input arrays and an empty list to hold the merged result. 2. Iterate through both arrays, comparing the current elements of each array: - Append the smaller element to the result list and move the pointer of the corresponding array. 3. If one of the arrays is exhausted before the other, append the remaining elements of the non-exhausted array to the result list. 4. Return the merged and sorted list. Performance Considerations - Ensure the function operates efficiently with a linear time complexity of O(n + m), where n and m are the lengths of the input arrays. - Use minimal additional space by leveraging two-pointers technique.","solution":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merges two sorted arrays into a single sorted array. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Append remaining elements from arr1 if any while i < len(arr1): merged.append(arr1[i]) i += 1 # Append remaining elements from arr2 if any while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"# Reverse Words in a String **Scenario**: You\'ve been hired to improve the formatting of user-generated content on a social media platform. One common issue is that users often write sentences with words in reverse order. Your task is to develop a utility that can correct this by reversing the order of words in a given string while preserving the whitespace and initial word order. **Task**: Write a function `reverse_words` that takes a string `s` as input and returns a new string with the words reversed. Function Signature ```python def reverse_words(s: str) -> str: Reverse the order of words in a string while preserving spaces. Parameters ---------- s: str A string which may contain leading, trailing, or multiple spaces between words. Returns ------- str A new string with the words reversed. ``` Input - `s`: A string that may include letters, numbers, punctuation, and spaces. Output - Return a new string with words in reverse order, preserving spaces. Constraints - The input string `s` has at most 10^4 characters. - Words are defined as sequences of non-space characters. - The string may have leading or trailing spaces, which should be preserved in the output. - The input will not contain leading or trailing multiple spaces, but may have multiple spaces between words. Example ```python # Examples: assert reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" assert reverse_words(\\" hello world \\") == \\" world hello \\" assert reverse_words(\\"a good example\\") == \\"example good a\\" assert reverse_words(\\" no spaces\\") == \\"spaces no \\" assert reverse_words(\\"single\\") == \\"single\\" ``` **Note**: Your solution should handle strings with multiple spaces between words and preserve those spaces correctly in the resulting string. Ensure optimal efficiency in cases where the string length approaches the upper constraint.","solution":"def reverse_words(s: str) -> str: Reverse the order of words in a string while preserving spaces. Parameters ---------- s: str A string which may contain leading, trailing, or multiple spaces between words. Returns ------- str A new string with the words reversed. # Split the string into words treating spaces as delimiters words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed words with a single space in between return \' \'.join(reversed_words)"},{"question":"# Scenario You are required to analyze a list of stock transactions to identify the largest stock price change within a given time window. # Task Write a Python function, `find_largest_price_change(transactions: list[dict[str, Any]], window_size: int) -> dict[str, Any]`, which takes a list of stock transactions and a time window size as input. The function should identify the largest price change that occurs within any contiguous sub-list of transactions where the length of the sub-list is equal to the window size. # Requirements 1. **Function Signature**: ```python def find_largest_price_change(transactions: list[dict[str, Any]], window_size: int) -> dict[str, Any]: ``` 2. **Input**: * `transactions` - a list of dictionaries where each dictionary represents a stock transaction containing the following keys: * `timestamp` (str): The timestamp of the transaction in \'YYYY-MM-DD HH:MM:SS\' format. * `price` (float): The price at the time of the transaction. * `window_size` - an integer representing the size of the time window. 3. **Output**: A dictionary containing the following keys and their corresponding values: * `start_time`: The start timestamp of the window with the largest price change. * `end_time`: The end timestamp of the window with the largest price change. * `price_change`: The largest price change detected within the time window. 4. **Constraints**: * The `transactions` list will have at least `window_size` number of elements. * Handle cases where the `transactions` could be provided in any order (i.e., sort the transactions by timestamp). * The `transactions` list contains unique timestamps. # Example ```python transactions = [ {\'timestamp\': \'2023-01-01 10:00:00\', \'price\': 100.0}, {\'timestamp\': \'2023-01-01 10:01:00\', \'price\': 102.0}, {\'timestamp\': \'2023-01-01 10:02:00\', \'price\': 105.0}, {\'timestamp\': \'2023-01-01 10:03:00\', \'price\': 99.0}, {\'timestamp\': \'2023-01-01 10:04:00\', \'price\': 110.0} ] find_largest_price_change(transactions, 3) ``` Expected Output: ```python { \'start_time\': \'2023-01-01 10:00:00\', \'end_time\': \'2023-01-01 10:02:00\', \'price_change\': 5.0 } ``` # Additional Guidelines * You may assume the time between transactions is consistent (1-minute intervals) for simplicity of window calculation. * Ensure your function is optimized to handle large lists of transactions efficiently. * Write a few test cases to validate your implementation.","solution":"from typing import List, Dict, Any from datetime import datetime def find_largest_price_change(transactions: List[Dict[str, Any]], window_size: int) -> Dict[str, Any]: # Sort transactions by timestamp transactions = sorted(transactions, key=lambda x: datetime.strptime(x[\'timestamp\'], \'%Y-%m-%d %H:%M:%S\')) max_change = 0.0 result = { \'start_time\': \'\', \'end_time\': \'\', \'price_change\': 0.0 } for i in range(len(transactions) - window_size + 1): start_time = transactions[i][\'timestamp\'] end_time = transactions[i + window_size - 1][\'timestamp\'] start_price = transactions[i][\'price\'] end_price = transactions[i + window_size - 1][\'price\'] price_change = abs(end_price - start_price) if price_change > max_change: max_change = price_change result[\'start_time\'] = start_time result[\'end_time\'] = end_time result[\'price_change\'] = price_change return result"},{"question":"# Scenario You are developing a news aggregator program that consolidates the titles of news articles from various feeds and needs to handle word frequency analysis. Your task is to create functions to count the frequency of words and identify the most frequent word(s). # Task Write two functions to count the frequency of words in a list of news article titles and find the most frequent word(s). # Function 1: `word_frequency` Input - A list of strings `titles` representing the titles of news articles. Output - A dictionary where keys are words and values are their respective frequencies. Example ```python titles = [ \\"New vaccine shows promise\\", \\"Climate change impacts more severe\\", \\"New species discovered in rainforest\\", \\"Climate change policy adopted\\" ] assert word_frequency(titles) == { \\"new\\": 2, \\"vaccine\\": 1, \\"shows\\": 1, \\"promise\\": 1, \\"climate\\": 2, \\"change\\": 2, \\"impacts\\": 1, \\"more\\": 1, \\"severe\\": 1, \\"species\\": 1, \\"discovered\\": 1, \\"in\\": 1, \\"rainforest\\": 1, \\"policy\\": 1, \\"adopted\\": 1 } ``` # Function 2: `most_frequent_words` Input - A list of strings `titles` representing the titles of news articles. Output - A list of strings representing the most frequent word(s). If there\'s a tie, return all the words with the highest frequency in alphabetical order. Example ```python titles = [ \\"New vaccine shows promise\\", \\"Climate change impacts more severe\\", \\"New species discovered in rainforest\\", \\"Climate change policy adopted\\" ] assert most_frequent_words(titles) == [\\"change\\", \\"climate\\", \\"new\\"] ``` Constraints - Implement error handling for invalid inputs (e.g., non-string elements in the list). - Optimize for readability and performance. # Notes - Consider word case normalization (e.g., treating \\"New\\" and \\"new\\" as the same word). - Ensure that punctuation is handled appropriately (e.g., removing periods, commas).","solution":"import re from collections import defaultdict def word_frequency(titles): Counts the frequency of words in a list of news article titles. :param titles: List of strings representing the titles of news articles :return: Dictionary where keys are words and values are their respective frequencies frequency = defaultdict(int) for title in titles: words = re.findall(r\'bw+b\', title.lower()) for word in words: frequency[word] += 1 return dict(frequency) def most_frequent_words(titles): Finds the most frequent word(s) in a list of news article titles. :param titles: List of strings representing the titles of news articles :return: List of strings representing the most frequent word(s) frequencies = word_frequency(titles) if not frequencies: return [] max_frequency = max(frequencies.values()) most_frequent = [word for word, count in frequencies.items() if count == max_frequency] return sorted(most_frequent)"},{"question":"# Coding Question **Context**: Jordan, a data analyst, has a large collection of strings that need to be cleaned regularly. The cleaning process involves several steps including trimming whitespace, converting to lowercase, and removing special characters, but it should be flexible enough to include or exclude certain steps based on the user\'s needs. **Task**: Write a Python function `clean_strings` that: 1. Takes a list of strings and a dictionary of cleaning options as input. 2. Cleans each string based on the specified options, which can include: - `trim`: If set to True, trim leading and trailing whitespace. - `to_lower`: If set to True, convert the string to lowercase. - `remove_special`: If set to True, remove all non-alphanumeric characters except spaces. **Function Signature**: ```python from typing import List, Dict def clean_strings(strings: List[str], options: Dict[str, bool]) -> List[str]: Cleans a list of strings based on specified options. :param strings: List[str] - the list of strings to clean :param options: Dict[str, bool] - dictionary specifying cleaning options :return: List[str] - the list of cleaned strings pass ``` **Constraints**: * The function should handle empty strings and lists gracefully. * Ensure that only the specified cleaning options are applied. * Raise appropriate exceptions for invalid inputs such as non-boolean values in options or non-string elements in the list. **Example**: When calling `clean_strings([\\" Hello World! \\", \\"Python Programming!!\\"], {\\"trim\\": True, \\"to_lower\\": True, \\"remove_special\\": True})`: ```python [\\"hello world\\", \\"python programming\\"] ``` When calling `clean_strings([\\"#Data#, Analysis@\\", \\" 1234, Coding!\\"], {\\"trim\\": False, \\"to_lower\\": False, \\"remove_special\\": True})`: ```python [\\"Data Analysis\\", \\"1234 Coding\\"] ``` Additionally, ensure your implementation considers performance implications for large lists of strings and handles edge cases appropriately.","solution":"from typing import List, Dict import re def clean_strings(strings: List[str], options: Dict[str, bool]) -> List[str]: Cleans a list of strings based on specified options. :param strings: List[str] - the list of strings to clean :param options: Dict[str, bool] - dictionary specifying cleaning options :return: List[str] - the list of cleaned strings def clean_string(s: str) -> str: if options.get(\'trim\', False): s = s.strip() if options.get(\'to_lower\', False): s = s.lower() if options.get(\'remove_special\', False): s = re.sub(r\'[^a-zA-Z0-9 ]\', \'\', s) return s if not all(isinstance(s, str) for s in strings): raise ValueError(\\"All elements of the input list must be strings\\") if not all(isinstance(v, bool) for v in options.values()): raise ValueError(\\"All values in the options dictionary must be boolean\\") return [clean_string(s) for s in strings]"},{"question":"# Task Removing Consecutive Duplicates in a List You are given a list of integers where some elements may appear consecutively more than once. Your task is to implement a function that removes consecutive duplicates from the list, keeping only the first occurrence of each series of duplicates, and returns the modified list. Function Signature `def remove_consecutive_duplicates(lst: List[int]) -> List[int]:` Input - `lst`: A list of integers where (1 ≤ len(lst) ≤ 10^6) and each integer is in the range [-10^6, 10^6]. Output - Returns a list of integers with consecutive duplicates removed. Constraints - The function should handle lists up to the maximum length within acceptable performance limits. Performance Requirements - Time Complexity should ideally be O(n). - Space Complexity should be O(1) for extra space (excluding input and output). # Example ```python >>> remove_consecutive_duplicates([1, 1, 2, 2, 2, 3, 1, 1, 4]) [1, 2, 3, 1, 4] >>> remove_consecutive_duplicates([4, 4, 4, 4, 4, 5, 5, 6, 6, 6]) [4, 5, 6] >>> remove_consecutive_duplicates([10]) [10] >>> remove_consecutive_duplicates([]) [] ``` # Hints 1. Consider iterating through the list while keeping track of the last seen element. 2. An optimal solution should only require a single pass through the list (O(n)).","solution":"from typing import List def remove_consecutive_duplicates(lst: List[int]) -> List[int]: if not lst: return [] # Initialize an empty list for the result result = [] # Start by adding the first element to the result result.append(lst[0]) # Iterate over the elements, starting from the second one for i in range(1, len(lst)): if lst[i] != lst[i - 1]: result.append(lst[i]) return result"},{"question":"# Question: Implement Depth-First Search with Discovery and Finish Times You are required to extend the DFS implementation such that it records the discovery and finish times of each node. This technique is particularly useful in various applications such as understanding the context in which nodes are visited and identifying the structure of the graph. Requirements 1. Implement a method `dfs_with_times(self) -> dict[int, tuple[int, int]]` inside the `Graph` class. 2. The method should return a dictionary where each key is a node, and the corresponding value is a tuple containing the discovery and finish times of that node. 3. Discovery time is the point at which the node is first visited. 4. Finish time is the point at which the node and all its descendants are completely explored. Example ```python >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 3) >>> result = g.dfs_with_times() >>> sorted(result.items()) [(0, (1, 8)), (1, (2, 7)), (2, (3, 6)), (3, (4, 5))] ``` Constraints 1. The graph does not include any negative weights. 2. The graph is represented using an adjacency list. 3. The vertex identifiers are non-negative integers. Implementation Guide - You may use a helper method to perform the DFS recursively. - Use a time counter that increments each time a node is discovered or finished.","solution":"class Graph: def __init__(self): self.graph = {} self.time = 0 def add_edge(self, u, v): if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) if v not in self.graph: self.graph[v] = [] def dfs_with_times(self): def dfs_visit(node, disc, finish): self.time += 1 disc[node] = self.time for neighbor in self.graph[node]: if neighbor not in disc: dfs_visit(neighbor, disc, finish) self.time += 1 finish[node] = self.time disc = {} finish = {} for node in self.graph: if node not in disc: dfs_visit(node, disc, finish) return {node: (disc[node], finish[node]) for node in self.graph}"},{"question":"# Frequency Counter Function **Objective**: Implement a function that takes a list of integers and returns a dictionary with the frequency count of each unique integer. **Description**: You are required to write a function, `count_frequencies`, which takes a list of integers as input and returns a dictionary where the keys are the unique integers from the input list, and the values are the counts of each integer\'s occurrence. **Function Signature**: ```python def count_frequencies(nums: list) -> dict: ``` # Input Format: - A list of integers, where the number of integers (n) is such that 0 ≤ n ≤ 10^6. # Output Format: - A dictionary with each key representing a unique integer from the input list and each value representing the frequency of that integer in the list. # Constraints: - The function should handle an empty list and return an empty dictionary. - The function should be optimized for both time and space to handle up to a million integers efficiently. # Performance Requirements: - Aim for O(n) time complexity and O(n) space complexity. # Example: ```python # Example 1 assert count_frequencies([1, 2, 2, 3, 3, 3]) == {1: 1, 2: 2, 3: 3} # Example 2 assert count_frequencies([]) == {} # Example 3 assert count_frequencies([7, 7, 7, 7, 7, 7]) == {7: 6} ``` # Additional Context: Consider edge cases such as handling very large lists with high-frequency counts of a small subset of unique integers. The solution should avoid unnecessary computations and ensure it runs efficiently for the upper limits of typical input sizes. The function should demonstrate a solid understanding of dictionary manipulation, iteration through lists, and handling edge cases such as empty input lists effectively.","solution":"def count_frequencies(nums: list) -> dict: Returns a dictionary with the frequency count of each unique integer in the input list. frequency_dict = {} for num in nums: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 return frequency_dict"},{"question":"# Question: Implement the Bisection Method for Root Finding You are required to implement the Bisection Method for finding the root of a continuous function. The Bisection Method is a simple and robust method of finding roots of a function that ensures convergence. Function Signature ```python def bisection_method( func: Callable[[float], float], a: float, b: float, tolerance: float, max_iterations: int ) -> Optional[float]: ``` Parameters: - `func`: A continuous function for which the root is to be found, it takes one argument `x` and returns `f(x)`. - `a`: The start of the interval ([a, b]). - `b`: The end of the interval ([a, b]). - `tolerance`: The precision tolerance for the root. - `max_iterations`: The maximum number of iterations allowed. Returns: - The approximated root value if found within the specified tolerance and maximum iterations. - `None` if no root is found within the given conditions. # Constraints: - `a < b` - `func(a) * func(b) < 0` (The function must have opposite signs at the interval ends to ensure a root exists within the interval) - `tolerance > 0` - `max_iterations > 0` - Function calls to `func` will provide valid floating-point numbers as inputs. # Example: ```python # Define the function def func(x): return x**3 - 5*x - 9 # Interval and parameters a = 2.0 b = 3.0 tolerance = 1e-6 max_iterations = 100 # Compute the root root = bisection_method(func, a, b, tolerance, max_iterations) print(root) # Expected output: A floating-point number representing the root within the tolerance range. ``` # Notes: - The function should repeatedly halve the interval and choose the subinterval in which the root lies. - Ensure the function properly handles the edge cases such as when the root is exactly at `a` or `b`. - Thoroughly test with different continuous functions and intervals to guarantee the correctness of the implementation. - Pay attention to the termination condition based on the given tolerance and maximum number of iterations.","solution":"from typing import Callable, Optional def bisection_method( func: Callable[[float], float], a: float, b: float, tolerance: float, max_iterations: int ) -> Optional[float]: Implements the Bisection Method for finding the root of a continuous function. Parameters: - func: A continuous function for which the root is to be found. - a: The start of the interval [a, b]. - b: The end of the interval [a, b]. - tolerance: The precision tolerance for the root. - max_iterations: The maximum number of iterations allowed. Returns: - The approximated root value if found within the specified tolerance and maximum iterations. - None if no root is found within the given conditions. if a >= b: return None if tolerance <= 0: return None if max_iterations <= 0: return None if func(a) * func(b) >= 0: return None for _ in range(max_iterations): midpoint = (a + b) / 2.0 f_mid = func(midpoint) if abs(f_mid) < tolerance: return midpoint elif func(a) * f_mid < 0: b = midpoint else: a = midpoint return (a + b) / 2.0"},{"question":"Coding Assessment Question Context: You are implementing a feature in a gaming application where an orb moves within a bounded 2D grid. To manage the movement smoothly, you need to compute the next position of the orb based on the current position and a given direction. Problem Statement: Write a function `move_orb` that takes the current position of the orb, a movement direction, and the grid boundaries. The function should return the new position of the orb after moving one step in the given direction. ```python def move_orb(x: int, y: int, direction: str, max_x: int, max_y: int) -> Tuple[int, int]: Compute the new position of an orb on a grid after moving one step in the given direction. pass ``` Input: - `x, y`: Integers representing the current coordinates of the orb. - `direction`: A string representing the movement direction. It can be \'up\', \'down\', \'left\', or \'right\'. - `max_x, max_y`: Integers representing the maximum boundaries of the grid. The grid starts at (0, 0) and extends to (max_x, max_y). Output: - Return a tuple `(new_x, new_y)` representing the new coordinates of the orb after moving one step in the specified direction. Constraints: - Coordinates are integers in the range 0 ≤ x, y ≤ 10000. - 0 ≤ max_x, max_y ≤ 10000. Performance Requirements: - The function should run in constant time, O(1). Examples: 1. `move_orb(5, 5, \'up\', 10, 10)` should return `(5, 4)`. 2. `move_orb(0, 0, \'left\', 10, 10)` should return `(0, 0)`. 3. `move_orb(9, 9, \'down\', 10, 10)` should return `(9, 10)`. 4. `move_orb(10, 10, \'right\', 10, 10)` should return `(10, 10)`. Notes: - The orb cannot move outside the grid boundaries. If a move would result in a position outside the grid, the orb stays in its current position. - Ensure edge cases such as movement at the grid boundaries are handled correctly.","solution":"def move_orb(x: int, y: int, direction: str, max_x: int, max_y: int) -> (int, int): if direction == \'up\': new_y = max(0, y - 1) return (x, new_y) elif direction == \'down\': new_y = min(max_y, y + 1) return (x, new_y) elif direction == \'left\': new_x = max(0, x - 1) return (new_x, y) elif direction == \'right\': new_x = min(max_x, x + 1) return (new_x, y) else: # In case of invalid direction, return the original position return (x, y)"},{"question":"# Coding Assessment Question Problem Statement: Implement a Python function `find_peak_element(nums: List[int]) -> int` that takes a list of integers and returns the index of a \\"peak\\" element using a binary search algorithm. An element is considered a \\"peak\\" if it is greater than or equal to its neighbors. Requirements: * **Input Format**: * `nums` (List[int]): A list of integers. * **Output Format**: * `index` (int): The index of a peak element. * **Constraints**: * The input list must contain at least one element. * Each element can range from `-10^9` to `10^9`. * The list must not contain all duplicate values (there must be at least one peak). * **Performance**: * Your solution should run in O(log n) time complexity. Example: ```python # The peaks in the array [1, 2, 3, 1] are 2 and 3. The function should return 2 (index of peak 3). >>> find_peak_element([1, 2, 3, 1]) 2 # The peaks in the array [1, 2, 1, 3, 5, 6, 4] are 2 and 6. The function could return 1 (index of peak 2) or 5 (index of peak 6). >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) 1 or 5 # The only peak in the array [10] is 10 itself. The function should return 0 (index of peak 10). >>> find_peak_element([10]) 0 # The peak in the array [1, 2, 1] is 2. The function should return 1 (index of peak 2). >>> find_peak_element([1, 2, 1]) 1 ``` Hints: 1. Use binary search to approach the problem more efficiently. 2. If nums[mid] is greater than its neighbors, it is a peak. 3. If nums[mid] is less than nums[mid + 1], then there must be a peak in the right half. 4. If nums[mid] is less than nums[mid - 1], then there must be a peak in the left half. Edge Cases: 1. An array with only one element should return 0. 2. An array where the peak is at one of the ends. Implement your function below: ```python from typing import List def find_peak_element(nums: List[int]) -> int: left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid+1]: right = mid else: left = mid + 1 return left ```","solution":"from typing import List def find_peak_element(nums: List[int]) -> int: left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid+1]: right = mid else: left = mid + 1 return left"},{"question":"# Coding Assessment Question Context Sorting algorithms are fundamental to computer science and have various use cases. One such algorithm is the heap sort, which utilizes a binary heap data structure to sort elements in an array efficiently. Task Implement a function `optimized_heap_sort` in Python that sorts a given list of integers using the heap sort algorithm and optimizes the process for performance. Ensure that the function handles large inputs efficiently and provides the sorted result without altering the original list. Function Signature ```python def optimized_heap_sort(arr: list[int]) -> list[int]: pass ``` Input * **arr**: a list of integers to be sorted. Output * **sorted_arr**: a new list containing the elements of `arr` in ascending order. Constraints * The input list `arr` will have a length in the range [1, 10^5]. * Each integer in `arr` will be in the range [-10^6, 10^6]. Examples ```python >>> optimized_heap_sort([4, 10, 3, 5, 1]) [1, 3, 4, 5, 10] >>> optimized_heap_sort([0, -10, 20, -20, 10]) [-20, -10, 0, 10, 20] >>> optimized_heap_sort([5]) [5] ``` Additional Requirement * Ensure that your function handles edge cases such as an empty list or a list with all identical elements. * Avoid built-in sorting functions and implement the heap sort algorithm from scratch.","solution":"def optimized_heap_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the heap sort algorithm. def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) if n == 0: return [] copied_arr = arr[:] # Copy the original array to not modify it # Build a maxheap for i in range(n//2 - 1, -1, -1): heapify(copied_arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): copied_arr[i], copied_arr[0] = copied_arr[0], copied_arr[i] # swap heapify(copied_arr, i, 0) return copied_arr"},{"question":"# Number to Words Converter Context: Converting numbers to words is a common exercise in programming that enhances understanding of loops and conditional structures. This problem is particularly useful in formatting tasks, such as creating check-writing software or generating human-readable output for numbers. Task: Write a function `number_to_words(num: int) -> str` that converts a number into its English words representation. Specifications: 1. The function should handle numbers from 0 to 999,999 inclusive. 2. The translation should follow the standard English convention. English Number Representation: - Numbers from 0 to 19 should be mapped to their specific words. - Numbers from 20 to 99 should be composed of tens words followed by their ones words (e.g., 42 should be \\"Forty Two\\"). - Numbers from 100 to 999 should be composed of hundreds words, and the rest following the pattern stated above (e.g., 123 should be \\"One Hundred Twenty Three\\"). - Numbers from 1,000 to 999,999 should be handled similarly, with the term thousand included (e.g., 123,456 should be \\"One Hundred Twenty Three Thousand Four Hundred Fifty Six\\"). Input: - A single integer `num` representing the number to be converted to words. Output: - A string representing the number in English words. Constraints: - Input number is guaranteed to be within the range of 0 to 999,999 inclusive. Example: ```python assert number_to_words(123) == \\"One Hundred Twenty Three\\" assert number_to_words(0) == \\"Zero\\" assert number_to_words(5025) == \\"Five Thousand Twenty Five\\" ``` Notes: - Ensure proper handling of edge cases like exact hundred (e.g., 300 should be correctly converted to \\"Three Hundred\\"). - No need to handle negative numbers for this problem. ```python def number_to_words(num: int) -> str: Returns the English words representation of the given number. # Ensure the implementation here ``` # Example Implementation: ```python def number_to_words(num: int) -> str: if num == 0: return \\"Zero\\" def one(num): switcher = { 1: \'One\', 2: \'Two\', 3: \'Three\', 4: \'Four\', 5: \'Five\', 6: \'Six\', 7: \'Seven\', 8: \'Eight\', 9: \'Nine\' } return switcher.get(num, \\"\\") def two_less_20(num): switcher = { 10: \'Ten\', 11: \'Eleven\', 12: \'Twelve\', 13: \'Thirteen\', 14: \'Fourteen\', 15: \'Fifteen\', 16: \'Sixteen\', 17: \'Seventeen\', 18: \'Eighteen\', 19: \'Nineteen\' } return switcher.get(num, \\"\\") def ten(num): switcher = { 2: \'Twenty\', 3: \'Thirty\', 4: \'Forty\', 5: \'Fifty\', 6: \'Sixty\', 7: \'Seventy\', 8: \'Eighty\', 9: \'Ninety\' } return switcher.get(num, \\"\\") def two(num): if not num: return \'\' elif num < 10: return one(num) elif num < 20: return two_less_20(num) else: tenner = num // 10 rest = num - tenner * 10 return ten(tenner) + (\' \' + one(rest) if rest else \'\') def three(num): hundred = num // 100 rest = num - hundred * 100 if hundred and rest: return one(hundred) + \' Hundred \' + two(rest) elif not hundred and rest: return two(rest) elif hundred and not rest: return one(hundred) + \' Hundred\' return \'\' thousands = num // 1000 rest = num - thousands * 1000 result = \'\' if thousands: result += three(thousands) + \' Thousand\' if rest: result += \' \' if result else \'\' result += three(rest) return result.strip() ``` This question complements the existing set by focusing on number and strings manipulation, ensuring the coverage of a different aspect of programming while maintaining the complexity level.","solution":"def number_to_words(num: int) -> str: if num == 0: return \\"Zero\\" def one(num): switcher = { 1: \'One\', 2: \'Two\', 3: \'Three\', 4: \'Four\', 5: \'Five\', 6: \'Six\', 7: \'Seven\', 8: \'Eight\', 9: \'Nine\' } return switcher.get(num, \\"\\") def two_less_20(num): switcher = { 10: \'Ten\', 11: \'Eleven\', 12: \'Twelve\', 13: \'Thirteen\', 14: \'Fourteen\', 15: \'Fifteen\', 16: \'Sixteen\', 17: \'Seventeen\', 18: \'Eighteen\', 19: \'Nineteen\' } return switcher.get(num, \\"\\") def ten(num): switcher = { 2: \'Twenty\', 3: \'Thirty\', 4: \'Forty\', 5: \'Fifty\', 6: \'Sixty\', 7: \'Seventy\', 8: \'Eighty\', 9: \'Ninety\' } return switcher.get(num, \\"\\") def two(num): if not num: return \'\' elif num < 10: return one(num) elif num < 20: return two_less_20(num) else: tenner = num // 10 rest = num - tenner * 10 return ten(tenner) + (\' \' + one(rest) if rest else \'\') def three(num): hundred = num // 100 rest = num - hundred * 100 if hundred and rest: return one(hundred) + \' Hundred \' + two(rest) elif not hundred and rest: return two(rest) elif hundred and not rest: return one(hundred) + \' Hundred\' return \'\' thousands = num // 1000 rest = num - thousands * 1000 result = \'\' if thousands: result += three(thousands) + \' Thousand\' if rest: result += \' \' if result else \'\' result += three(rest) return result.strip()"},{"question":"# Custom Binary Search on Sorted Rotated Array You are required to implement a custom binary search function that works on a sorted array that has been rotated at some pivot unknown to you beforehand. The function should return the index of the target value if found, or -1 if it is not present in the array. # Function Signature ```python def custom_binary_search(arr: List[int], target: int) -> int: pass ``` # Input 1. `arr`: A list of integers representing the sorted rotated array. 2. `target`: An integer, the value to search for in the array. # Output * Returns an integer representing the index of the `target` value in the array; if the target is not found, return -1. # Constraints * The input list `arr` will have at least one element. * Array `arr` will contain unique elements sorted in ascending order, but rotated. * The input array can be of length up to 10^5. # Example ```python arr = [6, 7, 8, 1, 2, 3, 4, 5] target = 3 index = custom_binary_search(arr, target) print(f\\"Index: {index}\\") # Output should be 5 arr = [6, 7, 8, 1, 2, 3, 4, 5] target = 9 index = custom_binary_search(arr, target) print(f\\"Index: {index}\\") # Output should be -1 ``` # Note 1. Ensure the search has a logarithmic time complexity, O(log n). 2. Consider edge cases where the array might not be rotated. 3. Test your function with various arrays and target values to validate correctness and performance.","solution":"def custom_binary_search(arr, target): This function searches for a target value in a sorted array that has been rotated. Parameters: arr (List[int]): The sorted rotated array to search in. target (int): The value to search for. Returns: int: The index of the target value if found, -1 otherwise. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid if arr[low] <= arr[mid]: # Left half is sorted if arr[low] <= target < arr[mid]: high = mid - 1 else: low = mid + 1 else: # Right half is sorted if arr[mid] < target <= arr[high]: low = mid + 1 else: high = mid - 1 return -1"},{"question":"# Question: You are tasked with implementing a function `find_combinations(target: int, numbers: list) -> list` that finds all unique combinations of numbers in a list where the chosen numbers sum to a target value. Each number from the list can be used an unlimited number of times. To solve this problem, follow these instructions: 1. Define a function `combination_sum(target: int, numbers: list, start: int, combination: list, result: list)` which uses backtracking to build the combinations. 2. Utilize the helper function within `find_combinations` to generate the desired combinations. **Function Signature**: ```python def find_combinations(target: int, numbers: list) -> list: pass ``` **Input**: - target (int): The target sum value. - numbers (list): A list of distinct integers. **Output**: - A list of lists, where each inner list is a unique combination of numbers that add up to the target value. **Constraints**: - Numbers in the input list are all positive integers. - The returned combinations can be in any order. - Combination elements should be in non-decreasing order. - If no combination is possible, return an empty list. **Examples**: ```python find_combinations(7, [2, 3, 6, 7]) # Output: [[2, 2, 3], [7]] find_combinations(8, [2, 3, 5]) # Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] find_combinations(5, [2, 4]) # Output: [] ``` Implement the `find_combinations` function in Python. Ensure to handle edge cases such as empty input lists appropriately.","solution":"def combination_sum(target, numbers, start, combination, result): Uses backtracking to find combinations of numbers that add up to the target sum. if target == 0: result.append(list(combination)) return elif target < 0: return for i in range(start, len(numbers)): num = numbers[i] combination.append(num) combination_sum(target - num, numbers, i, combination, result) combination.pop() def find_combinations(target, numbers): Finds all unique combinations of numbers from the list that sum up to the target value. result = [] combination = [] combination_sum(target, numbers, 0, combination, result) return result"},{"question":"# Coding Assessment: Implementing K-Nearest Neighbors (KNN) **Objective**: Implement the K-Nearest Neighbors (KNN) algorithm to classify a set of instances. You will use the provided KNN model and utility functions as a reference to create new components to demonstrate your understanding. # Problem Statement Given a series of steps and predefined functions for KNN, implement additional functionality to classify unknown instances using the trained KNN model. Your task is to complete the KNN process, adhere to a given standard, and manage edge cases appropriately. # Scenario A research lab wants to use KNN to categorize their plant species based on physical measurements. They have historical data with known classifications. Your role is to implement the classification model and use it to predict new plant species given their measurements. # Requirements 1. **Function to Fit KNN Model**: * Input: `features` (2D list of feature values), `labels` (list of corresponding labels), `k` (number of neighbors). * Output: Dictionary containing the features, labels, and the value of k. 2. **Function to Predict Instances**: * Input: `unknown_features` (2D list of feature values of unknown instances), `model` (Fitted model dictionary from step 1). * Output: List of predicted classes for the unknown instances. 3. **Utility Function to Calculate Accuracy**: * Input: `actual_labels` (list of actual classes), `predicted_labels` (list of predicted classes). * Output: Accuracy percentage. # Input and Output Format **Function 1: fit_knn_model** ```python def fit_knn_model(features: list[list[float]], labels: list[int], k: int) -> dict: pass ``` **Function 2: predict_instances** ```python def predict_instances(unknown_features: list[list[float]], model: dict) -> list[int]: pass ``` **Function 3: calculate_accuracy** ```python def calculate_accuracy(actual_labels: list[int], predicted_labels: list[int]) -> float: pass ``` # Constraints * Assume the input features are numeric. * K should be an odd number to avoid ties in voting. * The mix of classes in the training set is representative of the problem. # Example ```python # Example data features = [ [5.1, 3.5], [4.9, 3.0], [7.0, 3.2], [6.4, 3.2], ] labels = [0, 0, 1, 1] k = 3 # Fit the KNN model model = fit_knn_model(features, labels, k) # New instances unknown_features = [ [4.7, 3.2], [6.6, 3.0], ] # Predict using the model predicted = predict_instances(unknown_features, model) print(predicted) # Expected output: [0, 1] # Calculate accuracy (assuming actual labels are provided for testing) actual_labels = [0, 1] accuracy = calculate_accuracy(actual_labels, predicted) print(accuracy) # Expected output: 100.0 ``` * **Edge Cases**: * Handle cases where there are insufficient data points to classify a point. * Ensure the algorithm can manage ties in voting by using k as an odd number. # Submission Complete the missing functions to fit the KNN model, predict classes for unknown instances, and calculate the accuracy of predictions. Ensure your solution passes provided examples and edge cases effectively.","solution":"import math from collections import Counter def fit_knn_model(features, labels, k): Fits a KNN model. :param features: List[List[float]]: The feature vectors. :param labels: List[int]: The corresponding labels. :param k: int: The number of neighbors to consider. :return: dict: The model containing the features, labels, and k value. return { \\"features\\": features, \\"labels\\": labels, \\"k\\": k } def euclidean_distance(point1, point2): Calculates the Euclidean distance between two points. :param point1: List[float]: The first point. :param point2: List[float]: The second point. :return: float: The Euclidean distance between the two points. return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def predict_instances(unknown_features, model): Predicts the labels for unknown instances using the KNN model. :param unknown_features: List[List[float]]: The features of unknown instances. :param model: dict: The fitted model. :return: List[int]: The predicted labels. features = model[\\"features\\"] labels = model[\\"labels\\"] k = model[\\"k\\"] predictions = [] for unknown_feature in unknown_features: # Calculate distances to all known points distances = [(euclidean_distance(unknown_feature, feature), label) for feature, label in zip(features, labels)] # Sort based on distance and get the k nearest neighbors k_nearest_neighbors = sorted(distances, key=lambda x: x[0])[:k] # Get the most common label among the neighbors k_nearest_labels = [label for _, label in k_nearest_neighbors] most_common_label = Counter(k_nearest_labels).most_common(1)[0][0] predictions.append(most_common_label) return predictions def calculate_accuracy(actual_labels, predicted_labels): Calculates accuracy of the predictions. :param actual_labels: List[int]: The actual labels. :param predicted_labels: List[int]: The predicted labels. :return: float: The accuracy percentage. correct_predictions = sum(a == p for a, p in zip(actual_labels, predicted_labels)) return (correct_predictions / len(actual_labels)) * 100"},{"question":"# Question: Implementing a Queue Using Stacks Context: You are required to implement a queue using two stacks. The goal is to understand how data structures can be implemented using other structures and to ensure that the typical queue operations such as enqueueing and dequeueing work efficiently. # Task: Create a class `QueueUsingStacks` that maintains the properties of a queue (FIFO - First In, First Out) but uses two stacks internally to manage the data. The class should support the following operations: 1. **Enqueue**: Method `enqueue(data)` to add an item to the end of the queue. 2. **Dequeue**: Method `dequeue()` to remove and return the item at the front of the queue. 3. **Peek**: Method `peek()` to return the item at the front of the queue without removing it. 4. **Is Empty**: Method `is_empty()` that returns `True` if the queue has no elements, and `False` otherwise. # Requirements: 1. **Input/Output**: - Each method should operate on instances of `QueueUsingStacks` and modify the queue in place. - The `dequeue` and `peek` methods should raise an exception for operations on an empty queue. 2. **Constraints**: - Ensure that the queue operations maintain the correct order (FIFO). - Define each method within efficient time and space complexity considerations. 3. **Performance**: - Achieve amortized O(1) time complexity for the `enqueue` and `dequeue` operations. # Example: ```python # Creating a QueueUsingStacks instance queue = QueueUsingStacks() print(queue.is_empty()) # Expected: True # Enqueueing items queue.enqueue(10) queue.enqueue(20) queue.enqueue(30) print(queue.is_empty()) # Expected: False # Peeking at the front item print(queue.peek()) # Expected: 10 # Dequeueing items print(queue.dequeue()) # Expected: 10 print(queue.dequeue()) # Expected: 20 # Peeking again print(queue.peek()) # Expected: 30 # Dequeueing the last item and checking if empty print(queue.dequeue()) # Expected: 30 print(queue.is_empty()) # Expected: True # Attempting to dequeue from an empty queue (should raise an exception) # queue.dequeue() # Uncommenting this line should raise an exception ```","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, data): self.stack1.append(data) def dequeue(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"dequeue from empty queue\\") return self.stack2.pop() def peek(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"peek from empty queue\\") return self.stack2[-1] def is_empty(self): return not self.stack1 and not self.stack2"},{"question":"# Problem Statement You are required to implement a function that detects the dominant color in an image. The function should analyze the image and return the RGB values of the color that appears most frequently. # Function Signature ```python def detect_dominant_color(img_path: str) -> tuple: Detects the dominant color in an image. Parameters: img_path (str): The path to the input image file. Returns: tuple: A tuple representing the RGB values of the dominant color. (R, G, B) where each value is between 0 and 255. ``` # Input * `img_path` (str): A valid file path to the input image. # Output * Return a tuple containing the RGB values of the dominant color in the image. # Constraints * You may assume that the input image path is valid and the image load operation will succeed. # Performance Requirements * The implementation should efficiently handle images of size up to 4096x4096 pixels. # Example ```python # Detect the dominant color in the image dominant_color = detect_dominant_color(\\"image_data/lena.jpg\\") print(dominant_color) # Output might be something like (220, 180, 140) ``` # Notes * You may use the `numpy` library to manipulate pixel values directly. * You may use the `PIL` (Pillow) library to handle image loading. * Consider converting the image to a smaller color palette to simplify the color detection process. # Hints * Convert the image to a numpy array to perform element-wise operations. * Use a color quantization method to reduce the number of distinct colors, which can help in identifying the most frequent color efficiently. --- This question aligns with the original set in terms of style, complexity, and scope, maintaining consistency in format and presentation.","solution":"from PIL import Image import numpy as np from collections import Counter def detect_dominant_color(img_path: str) -> tuple: Detects the dominant color in an image. Parameters: img_path (str): The path to the input image file. Returns: tuple: A tuple representing the RGB values of the dominant color. (R, G, B) where each value is between 0 and 255. # Open the image using PIL image = Image.open(img_path) # Convert the image to RGB mode (if not already in RGB) image = image.convert(\'RGB\') # Resize the image to speed up the process (optional) image = image.resize((100, 100)) # Convert the image to a numpy array np_image = np.array(image) # Reshape the array to be a list of pixels pixels = np_image.reshape(-1, 3) # Use Counter to find the most common pixel (color) dominant_color = Counter(map(tuple, pixels)).most_common(1)[0][0] return dominant_color"},{"question":"# Fibonacci Sequence Calculation Problem Statement: The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. Starting with 0 and 1, the sequence goes 0, 1, 1, 2, 3, 5, 8, ... and so on. You are required to implement two functions, `fibonacci_term` and `fibonacci_sequence`, in Python, adhering to the following specifications: 1. `fibonacci_term(n: int) -> int`: This function should take an integer `n` as input and return the nth term in the Fibonacci sequence. Raise a `ValueError` if `n` is negative. - Formula: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1 2. `fibonacci_sequence(n: int) -> list`: This function should take an integer `n` as input and return a list containing the first `n` terms of the Fibonacci sequence. Raise a `ValueError` if `n` is negative. Input and Output 1. `fibonacci_term(n: int) -> int` - **Input**: `n` (a non-negative integer representing the position in the Fibonacci sequence) - **Output**: An integer representing the nth term of the Fibonacci sequence. 2. `fibonacci_sequence(n: int) -> list` - **Input**: `n` (a non-negative integer representing the number of terms of the Fibonacci sequence to generate) - **Output**: A list of integers representing the first `n` terms of the Fibonacci sequence. Constraints - Input values for `n` should be non-negative. - The calculations follow the Fibonacci sequence without using more advanced mathematical shortcuts or libraries. Examples: ```python # Example usage: print(fibonacci_term(0)) # Expected output: 0 print(fibonacci_term(1)) # Expected output: 1 print(fibonacci_term(6)) # Expected output: 8 print(fibonacci_term(10)) # Expected output: 55 print(fibonacci_sequence(0)) # Expected output: [] print(fibonacci_sequence(1)) # Expected output: [0] print(fibonacci_sequence(6)) # Expected output: [0, 1, 1, 2, 3, 5] print(fibonacci_sequence(10)) # Expected output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Negative input example: print(fibonacci_term(-5)) # Expected output: ValueError: n can\'t be negative print(fibonacci_sequence(-5)) # Expected output: ValueError: n can\'t be negative ``` ```python # Implementation of functions def fibonacci_term(n: int) -> int: if n < 0: raise ValueError(\\"n can\'t be negative.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_sequence(n: int) -> list: if n < 0: raise ValueError(\\"n can\'t be negative.\\") sequence = [] a, b = 0, 1 for _ in range(n): sequence.append(a) a, b = b, a + b return sequence ```","solution":"def fibonacci_term(n: int) -> int: if n < 0: raise ValueError(\\"n can\'t be negative.\\") if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_sequence(n: int) -> list: if n < 0: raise ValueError(\\"n can\'t be negative.\\") sequence = [] a, b = 0, 1 for _ in range(n): sequence.append(a) a, b = b, a + b return sequence"},{"question":"# Coding Assessment Question Background Array manipulation and optimization of query responses are common tasks in programming. One such application is determining the maximum sum of elements within a specified subarray size. Consider the problem where you need to find the maximum sum of any contiguous subarray of a specified length `k` within a given array. Problem Statement You are required to implement a function that finds the maximum sum of any contiguous subarray of length `k` in the given array `arr`. Implement the function `max_subarray_sum(arr: List[int], k: int) -> int` to compute this sum. Input * An array of integers `arr` of length `n` where `1 ≤ n ≤ 100`. * An integer `k` where `1 ≤ k ≤ n`. Output * The maximum sum of any contiguous subarray of length `k` within `arr`. Constraints * Your solution should handle different types of subarrays within the constraints efficiently. Example ```python >>> max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum([2, 1, 5, 1, 3, 2], 3) 9 >>> max_subarray_sum([-1, -2, -3, -4, -5], 2) -3 ``` *Explanation*: 1. For the first example, the subarray of length 2 with the maximum sum is `[4, 5]` which sums up to `9`. 2. For the second example, the subarray of length 3 with the maximum sum is `[2, 1, 5, 1]` which sums up to `9`. 3. For the third example, despite negative values, the subarray of length 2 with the maximum sum is `[-1, -2]` which sums up to `-3`.","solution":"from typing import List def max_subarray_sum(arr: List[int], k: int) -> int: Finds the maximum sum of any contiguous subarray of length k. :param arr: List of integers. :param k: Length of the subarray. :return: Maximum sum of any contiguous subarray of length k. # Initiate the sum of the first k elements current_sum = sum(arr[:k]) max_sum = current_sum # Slide the window across the array, updating sums and tracking the maximum sum for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Question: Implement a Chessboard Move Validator You are required to implement a function to validate the moves of various pieces in a game of chess. The function will receive the current position and the desired new position of a piece, and it should determine if the move is legal for the given piece. Implement the following function: 1. `is_valid_move(piece: str, start_pos: str, end_pos: str) -> bool` * This function should return `True` if the move is legal for the given piece, and `False` otherwise. * The input `piece` is a string representing a piece type: \\"pawn\\", \\"rook\\", \\"knight\\", \\"bishop\\", \\"queen\\", or \\"king\\". * The input `start_pos` and `end_pos` will be strings representing the positions on the chessboard in algebraic notation. For example, \\"e2\\" for a starting position and \\"e4\\" for an ending position. Consider the standard rules of chess for each piece: - **Pawn** moves one square forward, can move two squares forward if it is its first move, captures diagonally. - **Rook** moves horizontally or vertically any number of squares. - **Knight** moves in an L-shape: two squares in one direction and then one square perpendicular. - **Bishop** moves diagonally any number of squares. - **Queen** combines the moves of a rook and a bishop. - **King** moves one square in any direction. # Constraints: * Valid values for `piece` are \\"pawn\\", \\"rook\\", \\"knight\\", \\"bishop\\", \\"queen\\", and \\"king\\". * Valid positions `start_pos` and `end_pos` are strings of length 2: the first character is in `a-h` and the second character is in `1-8`. * Assume that the moves do not involve captures (other pieces on the board do not affect the move). # Example Usage: ```python >>> is_valid_move(\\"pawn\\", \\"e2\\", \\"e3\\") True >>> is_valid_move(\\"rook\\", \\"a1\\", \\"a8\\") True >>> is_valid_move(\\"knight\\", \\"g1\\", \\"f3\\") True >>> is_valid_move(\\"bishop\\", \\"c1\\", \\"e3\\") False >>> is_valid_move(\\"queen\\", \\"d1\\", \\"h5\\") True >>> is_valid_move(\\"king\\", \\"e1\\", \\"e2\\") True ``` # Notes: - The function should adhere to the rules of chess. - If the move is invalid for reasons such as moving outside the board or not following the movement abilities of the piece, it should return `False`. Implement the function with considerations for clarity and modularity.","solution":"def is_valid_move(piece: str, start_pos: str, end_pos: str) -> bool: Validates if a move for a given piece from start_pos to end_pos is valid according to standard chess rules. start_col, start_row = ord(start_pos[0]), int(start_pos[1]) end_col, end_row = ord(end_pos[0]), int(end_pos[1]) if piece == \\"pawn\\": if start_col == end_col: if start_row == 2 and end_row == 4: return True if end_row == start_row + 1: return True elif abs(start_col - end_col) == 1 and end_row == start_row + 1: return True return False if piece == \\"rook\\": return start_col == end_col or start_row == end_row if piece == \\"knight\\": return (abs(start_col - end_col), abs(start_row - end_row)) in [(2, 1), (1, 2)] if piece == \\"bishop\\": return abs(start_col - end_col) == abs(start_row - end_row) if piece == \\"queen\\": return (start_col == end_col or start_row == end_row or abs(start_col - end_col) == abs(start_row - end_row)) if piece == \\"king\\": return max(abs(start_col - end_col), abs(start_row - end_row)) == 1 return False"},{"question":"# Coding Assessment Question Scenario In this task, you are required to work with a series of numbers and manipulate their mathematical properties. Specifically, you will be exploring properties related to prime numbers and Fibonacci sequences. Problem Statement Implement a function `is_prime_fibonacci(n: int) -> bool` that checks if a given number `n` is both a prime number and a part of the Fibonacci sequence. A prime number is defined as: 1. A natural number greater than 1. 2. Not divisible by any number other than 1 and itself. A Fibonacci sequence is defined as: 1. A series where each number is the sum of the two preceding ones, usually starting with 0 and 1. The first few Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... Input - An integer `n` where (1 leq n leq 10^6). Output - Returns `True` if `n` is both a prime number and a Fibonacci number, else returns `False`. Constraints - The function should efficiently determine both the primality and Fibonacci membership given the bounds of the input. - Ensure the function handles all necessary edge cases (e.g., small bounds, typical scenarios). Example ```python assert is_prime_fibonacci(2) == True # 2 is both prime and Fibonacci (2 is the third Fibonacci number) assert is_prime_fibonacci(5) == True # 5 is both prime and Fibonacci (5 is the fifth Fibonacci number) assert is_prime_fibonacci(10) == False # 10 is neither a prime nor a Fibonacci number assert is_prime_fibonacci(13) == True # 13 is both prime and Fibonacci (13 is the seventh Fibonacci number) ```","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def is_fibonacci(n): Check if a number is in the Fibonacci sequence. if n < 0: return False x1 = 5 * n * n + 4 x2 = 5 * n * n - 4 def is_perfect_square(x): s = int(x**0.5) return s*s == x return is_perfect_square(x1) or is_perfect_square(x2) def is_prime_fibonacci(n): Check if a number is both prime and in the Fibonacci sequence. return is_prime(n) and is_fibonacci(n)"},{"question":"# Question: Unique Character Subsequence Finder Design a function to find the largest subsequence in a given string that contains all unique characters. # Instructions: 1. **Function Signature**: Implement a function `largest_unique_subsequence(s: str) -> str` 2. **Parameters**: - `s`: A string in which we are to find the largest subsequence with all unique characters. 3. **Output**: The function should return the largest subsequence that contains only unique characters. If there are multiple subsequences with the same length, return the one that appears first in the string. 4. **Constraints**: - The length of the input string will be between 0 and 1000. - The string will consist of lowercase alphabetic characters only. - You can use additional data structures like sets to aid in determining uniqueness. 5. **Performance**: Aim for an algorithmic solution with an average time complexity of O(n). # Example: ```python def largest_unique_subsequence(s: str) -> str: # Implementation here # Example Usage s = \\"abacabad\\" print(largest_unique_subsequence(s)) # Expected Output: \\"abcd\\" s = \\"abcabcbb\\" print(largest_unique_subsequence(s)) # Expected Output: \\"abc\\" ``` # Notes: * Focus on finding the simplest logic to iterate over the string to check for unique character subsequences. * Consider edge cases such as an empty string or a string with all characters being the same.","solution":"def largest_unique_subsequence(s: str) -> str: Finds the largest subsequence in a given string that contains all unique characters. unique_chars = set() largest_subsequence = [] for char in s: if char not in unique_chars: unique_chars.add(char) largest_subsequence.append(char) return \'\'.join(largest_subsequence)"},{"question":"**Data Stream Anomaly Detector** # Context: You are tasked with implementing an anomaly detection system for a high-frequency data stream. The system must continuously process incoming numerical data and identify unusual values in real time. It leverages statistical methods to dynamically learn and adapt to the stream characteristics. # Objective: Write a class `AnomalyDetector` that can: 1. Continuously ingest data from a stream. 2. Calculate a moving average and standard deviation. 3. Identify and flag anomalies that deviate beyond a specified number of standard deviations from the moving average. # Constraints: - The data stream consists of floating-point numbers. - The window size `n` for the moving average and standard deviation should be configurable. - An anomaly is defined as a data point that deviates by more than `k` standard deviations from the moving average. - The system should efficiently handle updates in O(1) time complexity per incoming data point. # Specifications: 1. Class Name: `AnomalyDetector` 2. Shall contain the methods: * `add_data_point(value: float) -> None`: Adds a new data point to the stream. * `is_anomaly(value: float) -> bool`: Checks if a given value is an anomaly based on the current moving statistics. * `reset() -> None`: Resets the internal state, clearing all historical data. # Expected input and output formats: - **Input formats**: * `add_data_point(value: float)`: A floating-point number representing a data point. * `is_anomaly(value: float)`: A floating-point number to be checked for anomaly. * `reset()`: No input needed. - **Output formats**: * `is_anomaly(value: float)`: Returns a boolean indicating whether the input value is an anomaly. # Performance Requirements: - Ensure the system maintains O(1) time complexity per data point for both adding a new data point and checking for anomalies. - Efficiently handle high-frequency data streams without performance degradation. # Example Usage: ```python # Initialize the detector with window size 10 and threshold of 3 standard deviations detector = AnomalyDetector(n=10, k=3) # Adding data points detector.add_data_point(10.5) detector.add_data_point(10.7) detector.add_data_point(10.8) # Checking for anomalies print(detector.is_anomaly(15.0)) # False print(detector.is_anomaly(20.0)) # True # Reset the detector detector.reset() ``` # Implementation Tips: - Use a deque or circular buffer to maintain the window of the last `n` data points for efficient updates. - Utilize Welford\'s algorithm for online calculation of mean and variance. - Ensure that the class methods are thread-safe if intended to be used in a multi-threaded environment.","solution":"from collections import deque import math class AnomalyDetector: def __init__(self, n: int, k: float): self.n = n self.k = k self.data = deque(maxlen=n) self.mean = 0 self.S = 0 self.count = 0 def _update_statistics(self, value: float): if self.count < self.n: self.count += 1 if self.count == 1: self.mean = value self.S = 0 else: old_mean = self.mean self.mean += (value - self.mean) / self.count self.S += (value - self.mean) * (value - old_mean) else: old_value = self.data.popleft() old_mean = self.mean self.mean = old_mean + (value - old_value) / self.n self.S = self.S + (value - self.mean + old_value - old_mean) * (value - old_value) def add_data_point(self, value: float) -> None: if self.count >= self.n: old_value = self.data.popleft() old_mean = self.mean self.mean = old_mean + (value - old_value) / self.n self.S = self.S + (value - self.mean + old_value - old_mean) * (value - old_value) self.data.append(value) self._update_statistics(value) def is_anomaly(self, value: float) -> bool: if self.count < self.n: return False stddev = math.sqrt(self.S / (self.n - 1)) return abs(value - self.mean) > self.k * stddev def reset(self) -> None: self.data.clear() self.mean = 0 self.S = 0 self.count = 0"},{"question":"Hash Map Design Design and implement a hash map to store integer keys and integer values. Your implementation should support the following operations with average O(1) time complexity: 1. **Insertion**: - Method: `put(key: int, value: int)` - Inserts the key-value pair into the hash map. If the key already exists, update its corresponding value. 2. **Lookup**: - Method: `get(key: int) -> int` - Returns the value to which the specified key is mapped. If the key does not exist, return `-1`. 3. **Removal**: - Method: `remove(key: int)` - Removes the key and its corresponding value if the key exists. Expected Behavior - **Collision Handling**: Use separate chaining (linked list) to handle collisions. - **Dynamic Resizing**: Implement dynamic resizing of the hash table when the load factor exceeds a certain threshold (e.g., 0.7). Implementation Details - Use a list to store nodes corresponding to each bucket in the hash table. - Each node should contain a key, a value, and a reference to the next node. Example Usage ```python # Initialize hash map hash_map = MyHashMap() # Insert key-value pairs hash_map.put(1, 10) hash_map.put(2, 20) # Retrieve value print(hash_map.get(1)) # Output: 10 # Update value hash_map.put(1, 30) print(hash_map.get(1)) # Output: 30 # Remove key hash_map.remove(2) print(hash_map.get(2)) # Output: -1 ``` Implementation Suggestions - Define a `Node` class to represent each entry in the linked list. - Define the `MyHashMap` class to manage insertion, lookup, and removal operations. - Maintain a count of elements to manage dynamic resizing. ```python class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class MyHashMap: def __init__(self): self.size = 1000 self.table = [None] * self.size self.count = 0 self.load_factor = 0.7 def _hash(self, key): return key % self.size def _rehash(self): # Implement dynamic resizing of the hash table def put(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = Node(key, value) else: current = self.table[index] while current: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) self.count += 1 if self.count / self.size > self.load_factor: self._rehash() def get(self, key): index = self._hash(key) current = self.table[index] while current: if current.key == key: return current.value current = current.next return -1 def remove(self, key): index = self._hash(key) current = self.table[index] if current is None: return if current.key == key: self.table[index] = current.next else: prev = current current = current.next while current: if current.key == key: prev.next = current.next break prev = current current = current.next self.count -= 1 ``` **Note**: Implement the `MyHashMap` class with considerations for collision handling and dynamic resizing without using Python\'s built-in dictionary module.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class MyHashMap: def __init__(self): self.size = 1000 self.table = [None] * self.size self.count = 0 self.load_factor = 0.7 def _hash(self, key): return key % self.size def _rehash(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for node in old_table: while node: self.put(node.key, node.value) node = node.next def put(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = Node(key, value) else: current = self.table[index] while current: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) self.count += 1 if self.count / self.size > self.load_factor: self._rehash() def get(self, key): index = self._hash(key) current = self.table[index] while current: if current.key == key: return current.value current = current.next return -1 def remove(self, key): index = self._hash(key) current = self.table[index] if current is None: return if current.key == key: self.table[index] = current.next else: prev = current current = current.next while current: if current.key == key: prev.next = current.next break prev = current current = current.next self.count -= 1"},{"question":"# Problem Statement You need to implement a function to sort a list of nested dictionaries by a specific key. The dictionaries contain information about different products, and each product has attributes like `id`, `name`, `price`, and `rating`. You are required to sort these products based on the given key in ascending or descending order. Write a function `sort_products(products: List[Dict[str, Union[int, float, str]]], key: str, descending: bool = False) -> List[Dict[str, Union[int, float, str]]]` that takes a list of dictionaries `products`, a string `key` to sort by, and a boolean `descending` which defaults to `False`. The function should return a sorted list of the dictionaries based on the specified key. # Input * `products` (List[Dict[str, Union[int, float, str]]]): A list of dictionaries where each dictionary represents a product and contains the following keys: `id` (int), `name` (str), `price` (float), and `rating` (float). * `key` (str): The key by which to sort the products. This will be one of the dictionary keys (`id`, `name`, `price`, `rating`). * `descending` (bool): If `True`, the list should be sorted in descending order. If `False`, the list should be sorted in ascending order. # Output * A list of dictionaries sorted based on the specified key. # Constraints * The function should be capable of sorting by any given numerical or string key. * The `price` and `rating` fields will always be positive numbers. * The `id` field will always be a unique positive integer. * The `name` field will always be a unique string. # Example ```python >>> products = [ ... {\\"id\\": 3, \\"name\\": \\"Product C\\", \\"price\\": 19.99, \\"rating\\": 4.5}, ... {\\"id\\": 1, \\"name\\": \\"Product A\\", \\"price\\": 14.99, \\"rating\\": 4.0}, ... {\\"id\\": 2, \\"name\\": \\"Product B\\", \\"price\\": 29.99, \\"rating\\": 5.0} ... ] >>> sort_products(products, \\"price\\") [ {\\"id\\": 1, \\"name\\": \\"Product A\\", \\"price\\": 14.99, \\"rating\\": 4.0}, {\\"id\\": 3, \\"name\\": \\"Product C\\", \\"price\\": 19.99, \\"rating\\": 4.5}, {\\"id\\": 2, \\"name\\": \\"Product B\\", \\"price\\": 29.99, \\"rating\\": 5.0} ] >>> sort_products(products, \\"rating\\", True) [ {\\"id\\": 2, \\"name\\": \\"Product B\\", \\"price\\": 29.99, \\"rating\\": 5.0}, {\\"id\\": 3, \\"name\\": \\"Product C\\", \\"price\\": 19.99, \\"rating\\": 4.5}, {\\"id\\": 1, \\"name\\": \\"Product A\\", \\"price\\": 14.99, \\"rating\\": 4.0} ] >>> sort_products(products, \\"name\\") [ {\\"id\\": 1, \\"name\\": \\"Product A\\", \\"price\\": 14.99, \\"rating\\": 4.0}, {\\"id\\": 2, \\"name\\": \\"Product B\\", \\"price\\": 29.99, \\"rating\\": 5.0}, {\\"id\\": 3, \\"name\\": \\"Product C\\", \\"price\\": 19.99, \\"rating\\": 4.5} ] ``` # Notes * Handle sorting in both ascending and descending order based on the `descending` parameter. * Ensure that the solution is efficient and handles lists with up to 1000 products.","solution":"from typing import List, Dict, Union def sort_products(products: List[Dict[str, Union[int, float, str]]], key: str, descending: bool = False) -> List[Dict[str, Union[int, float, str]]]: Sorts a list of dictionaries based on a specific key in ascending or descending order. Args: products (List[Dict[str, Union[int, float, str]]]): List of product dictionaries to be sorted. key (str): The key to sort the products by. descending (bool): If True, sort in descending order. Default is False. Returns: List[Dict[str, Union[int, float, str]]]: Sorted list of product dictionaries. return sorted(products, key=lambda x: x[key], reverse=descending)"},{"question":"# Coding Assessment Question Create a function to generate n rows of a custom triangle sequence. Unlike the classic Pascal\'s triangle where each element is the sum of the two directly above it, this triangle is constructed such that each element is the product of the two directly above it, divided by their greatest common divisor (GCD). ```python import math def custom_triangle(n: int) -> list: Generate n rows of the custom triangle sequence. Each element is determined by the product of the two elements directly above it divided by their GCD. Args: n (int): Number of rows in the sequence (n >= 1) Returns: List[List[int]]: A list of lists representing the rows of the custom triangle sequence. # Your implementation here pass def gcd(a, b): while b: a, b = b, a % b return a ``` # Detailed Specifications and Constraints: 1. **Inputs**: - `n` (int): Number of rows in the sequence. Must be a positive integer (range: n >= 1). 2. **Outputs**: - Returns a list of lists where each inner list represents a row in the custom triangle sequence. - The first row should always start with `[1]`. 3. **Edge Cases**: - For `n = 1`, output should be `[[1]]`. - Larger values of `n` should be handled efficiently. 4. **Performance Requirements**: - Consider the efficiency of the GCD calculation. # Testing: Use the following test cases to validate your implementation: ```python # Base case assert custom_triangle(1) == [[1]] # Two levels triangle assert custom_triangle(2) == [[1], [1, 1]] # Three levels triangle assert custom_triangle(3) == [[1], [1, 1], [1, 1, 1]] # Five levels triangle assert custom_triangle(5) == [[1], [1, 1], [1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1, 1]] ``` Feel free to add more test cases to thoroughly validate edge cases and ensure the accuracy of your implementation.","solution":"import math def custom_triangle(n: int) -> list: Generate n rows of the custom triangle sequence. Each element is determined by the product of the two elements directly above it divided by their GCD. Args: n (int): Number of rows in the sequence (n >= 1) Returns: List[List[int]]: A list of lists representing the rows of the custom triangle sequence. if n < 1: return [] def gcd(a, b): while b: a, b = b, a % b return a triangle = [[1]] for i in range(1, n): prev_row = triangle[-1] new_row = [1] * (i + 1) for j in range(1, i): product = prev_row[j-1] * prev_row[j] new_row[j] = product // gcd(prev_row[j-1], prev_row[j]) triangle.append(new_row) return triangle"},{"question":"# Scenario: You are tasked with developing a utility for parsing and interpreting log files generated by a server. Logs contain multiple entries with timestamps, log levels, and messages. Your goal is to implement a function that extracts and returns only the error messages from a given log file. # Function Requirements: * Implement a function `extract_errors` that takes the file path of a log file and returns a list of error messages. * Each log entry in the file follows the format: `[YYYY-MM-DD HH:MM:SS] [LEVEL] message`, where: - `YYYY-MM-DD HH:MM:SS` is the timestamp. - `LEVEL` is the log level (e.g., INFO, WARN, ERROR). - `message` is the log message. * Only logs with `[ERROR]` level should be extracted. # Constraints: * The log file will contain at least one log entry. * Log file entries are newline-separated and well-formed as per the specified format. # Function Signature: ```python def extract_errors(log_file_path: str) -> list: pass ``` # Example: ```python # log_file.txt content: # [2023-08-01 12:34:56] [INFO] Server started # [2023-08-01 12:35:00] [ERROR] Database connection failed # [2023-08-01 12:36:00] [WARN] High memory usage # [2023-08-01 12:37:10] [ERROR] Timeout while processing request assert extract_errors(\\"log_file.txt\\") == [ \\"Database connection failed\\", \\"Timeout while processing request\\" ] ``` # Input: - `log_file_path` (string): The file path of the log file. # Output: - (list): A list of error messages (strings). **Good luck!**","solution":"def extract_errors(log_file_path: str) -> list: error_messages = [] with open(log_file_path, \'r\') as log_file: for line in log_file: if \'[ERROR]\' in line: # Extract the message part after the third closing bracket \']\' error_message = line.split(\']\', 2)[2].strip() error_messages.append(error_message) return error_messages"},{"question":"# Maximum Depth of a Binary Tree You are given a binary tree and you need to find its maximum depth. The depth of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node. Write a function `max_depth(root: TreeNode) -> int` that calculates and returns the maximum depth of the given binary tree. Input Format The function receives a `TreeNode` object representing the root of the binary tree. Each `TreeNode` has the following structure: ```python @dataclass class TreeNode: data: int left: TreeNode | None = None right: TreeNode | None = None ``` Output Format An integer representing the maximum depth of the binary tree. Constraints * The binary tree will have at most `n` nodes. * It is guaranteed that the binary tree is non-empty (contains at least 1 node). Example ``` 1. Example Tree: 3 / 9 20 / 15 7 Output: 3 Explanation: The depth is 3 along the path [3 -> 20 -> 7]. 2. Example Tree: 1 / 2 3 / 4 5 Output: 3 Explanation: The depth is 3 along the path [1 -> 2 -> 4]. 3. Example Tree: 1 Output: 1 Explanation: The depth is 1 as there is only one node. ``` Performance Requirements * The solution should aim for O(n) time complexity and use O(h) additional space, where `h` is the height of the binary tree (accounting for the recursion stack).","solution":"from dataclasses import dataclass from typing import Optional @dataclass class TreeNode: data: int left: Optional[\'TreeNode\'] = None right: Optional[\'TreeNode\'] = None def max_depth(root: Optional[TreeNode]) -> int: Returns the maximum depth (number of nodes along the longest path) of the binary tree. if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Scenario: You are working for a company that processes large amounts of textual data. One of the primary tasks is to categorize emails based on specific keywords. To automate this process, you need to create a flexible keyword-based email categorization system. # Task: Implement a function named `categorize_email` that takes an email content and a dictionary of categories with associated keywords. The function should classify the email by looking for the presence of keywords in the email\'s text. # Requirements: 1. The function should accept the following parameters: - `email_content` (str): The text of the email that needs to be categorized. - `categories` (dict): A dictionary where keys are category names and values are lists of keywords associated with those categories. 2. The function should return a list of categories the email belongs to. If no keywords from any category are found, return an empty list. 3. Ensure the function is case-insensitive when checking for keywords. # Expected Input and Output: * **Input:** - `email_content` (str): Email text to base the categorization on. - `categories` (dict): Dictionary of categories and their corresponding keywords. * **Output:** - Returns a list of category names (str) the email falls under, based on keyword presence. # Constraints: * Assume the email content is always provided as a non-empty string. * Ensure the function handles edge cases, such as emails that contain keywords from multiple categories. * Use precise string matching to look for keywords within the email content. # Examples: ```python >>> categories = { \\"urgent\\": [\\"urgent\\", \\"asap\\", \\"immediate\\"], \\"finance\\": [\\"invoice\\", \\"bank\\", \\"payment\\"], \\"meeting\\": [\\"schedule\\", \\"appointment\\", \\"meeting\\"] } >>> email_content = \\"Hello team, we have an urgent matter to discuss in our meeting tomorrow.\\" >>> categorize_email(email_content, categories) [\'urgent\', \'meeting\'] >>> email_content = \\"Please review the attached invoice and process it as soon as possible.\\" >>> categorize_email(email_content, categories) [\'finance\', \'urgent\'] >>> email_content = \\"We need to schedule a follow-up appointment.\\" >>> categorize_email(email_content, categories) [\'meeting\'] >>> email_content = \\"Thank you for your attention.\\" >>> categorize_email(email_content, categories) [] ``` # Hint: Consider normalizing the email content and keywords (e.g., converting all text to lowercase) to simplify the keyword matching process.","solution":"def categorize_email(email_content, categories): Categorizes an email based on the presence of keywords. Parameters: email_content (str): The text of the email that needs to be categorized. categories (dict): A dictionary where keys are category names and values are lists of keywords associated with those categories. Returns: list: A list of categories the email belongs to, based on keyword presence. email_content = email_content.lower() categorized = [] for category, keywords in categories.items(): for keyword in keywords: if keyword.lower() in email_content: categorized.append(category) break return categorized"},{"question":"# Problem Statement: You need to create a function that generates all possible permutations of a given length from a list of elements. The function should utilize recursion to achieve this goal. # Function Signature: ```python def permute(elements: list[int], length: int) -> list[tuple]: Generate all possible permutations of specified length from the list elements. Args: elements (list): A list containing elements to generate permutations from. length (int): The length of permutations to generate. Returns: list[tuple]: A list containing tuples, each tuple representing a permutation of the specified length. ``` # Input: - `elements` - A list of elements. The elements can be integers, strings, floats, or any combination of these types. - `length` - An integer specifying the length of each permutation. # Output: - A list of tuples, where each tuple contains a permutation of the specified length. # Constraints: - All elements within the list are unique. - `length` is a non-negative integer. # Requirements: 1. Implement the function `permute` using recursive principles. 2. Handle edge cases effectively: - When `length` is 0, the result is a list containing an empty tuple. - When `length` is greater than the length of the list, return an empty list. 3. Ensure that the function is optimized for both performance and memory usage. # Sample Test Cases: ```python assert permute([1, 2, 3], 2) == [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] assert permute([\'a\', \'b\', \'c\'], 3) == [(\'a\', \'b\', \'c\'), (\'a\', \'c\', \'b\'), (\'b\', \'a\', \'c\'), (\'b\', \'c\', \'a\'), (\'c\', \'a\', \'b\'), (\'c\', \'b\', \'a\')] assert permute([10, 20, 30], 1) == [(10,), (20,), (30,)] assert permute([\'x\', \'y\'], 0) == [()] assert permute([], 2) == [] assert permute([1, 2], 3) == [] assert permute([\'apple\', 3.14, 42], 2) == [(\'apple\', 3.14), (\'apple\', 42), (3.14, \'apple\'), (3.14, 42), (42, \'apple\'), (42, 3.14)] ```","solution":"from typing import List, Tuple def permute(elements: List[int], length: int) -> List[Tuple[int]]: Generate all possible permutations of specified length from the list elements. Args: elements (list): A list containing elements to generate permutations from. length (int): The length of permutations to generate. Returns: list[tuple]: A list containing tuples, each tuple representing a permutation of the specified length. if length == 0: return [()] if length > len(elements): return [] result = [] def helper(current, remaining): if len(current) == length: result.append(tuple(current)) return for i in range(len(remaining)): helper(current + [remaining[i]], remaining[:i] + remaining[i+1:]) helper([], elements) return result"},{"question":"# Array Manipulation Utility **Problem Statement**: Create a utility class `ArrayManipulator` that provides functionalities to manipulate a list of integers. The class should provide methods to perform various operations as described below: **Requirements**: 1. Implement the `ArrayManipulator` class with the following methods: - `__init__(self, array: list)`: Initializes the object with a list of integers. - `reverse(self)`: Reverses the order of the elements in the list. - `max_element(self)`: Returns the maximum element in the list. - `rotate(self, k: int)`: Rotates the list to the right by `k` positions. - `sum_pairs(self)`: Returns a new list of sums of consecutive pairs of elements. If the list has an odd number of elements, the last element is carried over. 2. Apply appropriate exception handling to ensure type and value correctness. **Input Format**: - An integer list for initialization, which can be empty. - Integer `k` for the rotate method that can be 0 or positive. **Output Format**: - The output should return the results of each method as specified: - For `reverse()`, update the list in place. - For `max_element()`, return an integer. - For `rotate(k)`, update the list in place. - For `sum_pairs()`, return a new list. **Constraints**: - The elements of the list are between `-1000` and `1000`. - The length of the array will not exceed `10^5`. - The value of `k` will not exceed `10^5`. **Example**: ```python >>> arr = ArrayManipulator([1, 2, 3, 4, 5]) >>> arr.reverse() >>> print(arr.array) [5, 4, 3, 2, 1] >>> print(arr.max_element()) 5 >>> arr.rotate(2) >>> print(arr.array) [2, 1, 5, 4, 3] >>> print(arr.sum_pairs()) [3, 9, 3] ``` **Notes**: - Ensure methods operate efficiently for large input sizes. - Consider edge cases such as empty lists, single-element lists, or lists where elements are the same.","solution":"class ArrayManipulator: def __init__(self, array: list): self.array = array def reverse(self): self.array.reverse() def max_element(self): if not self.array: raise ValueError(\\"Empty array has no maximum element\\") return max(self.array) def rotate(self, k: int): if len(self.array) == 0: return n = len(self.array) k = k % n self.array = self.array[-k:] + self.array[:-k] def sum_pairs(self): result = [] i = 0 while i < len(self.array): if i + 1 < len(self.array): result.append(self.array[i] + self.array[i + 1]) else: result.append(self.array[i]) i += 2 return result"},{"question":"# Coding Challenge: Roman Numeral Conversion with Error Handling Context: You have been tasked with creating a utility that converts Roman numerals into their corresponding integer values. This utility will be used in various parts of a larger historical documentation project. Key to this utility\'s success is its ability to handle errors and invalid inputs gracefully. Task: Implement a function `roman_to_integer(roman: str) -> int` that: 1. Validates the input to ensure it is a properly formatted Roman numeral. 2. Converts the Roman numeral to its corresponding integer value if valid. 3. Returns -1 if the input is not a valid Roman numeral. Implementation Details: * **Input**: * A string `roman` representing the Roman numeral. * **Output**: * An integer representing the corresponding value of the Roman numeral, or -1 if the input is invalid. * **Roman Numeral Rules**: * Roman numerals consist of seven characters: I, V, X, L, C, D, and M. * They follow specific rules such as I before V and X (to make 4 and 9), and so on. * The maximum value to be handled is 3999, as represented by \\"MMMCMXCIX\\". Examples: ```python >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"MMMCMXCIX\\") 3999 >>> roman_to_integer(\\"IIII\\") -1 >>> roman_to_integer(\\"VX\\") -1 >>> roman_to_integer(\\"MMXVIII\\") 2018 ``` You are expected to implement robust validation to ensure the input string conforms to Roman numeral conventions. Handle various edge cases and assume the input can be any string.","solution":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral to an integer. Returns -1 if the input is invalid. roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } valid_pairs = { \'IV\': 4, \'IX\': 9, \'XL\': 40, \'XC\': 90, \'CD\': 400, \'CM\': 900 } # Check for valid Roman numeral if not roman or any(c not in roman_to_int for c in roman): return -1 # Substitution list for invalid patterns invalid_patterns = [\\"IIII\\", \\"VV\\", \\"XXXX\\", \\"LL\\", \\"CCCC\\", \\"DD\\", \\"MMMM\\", \\"VX\\", \\"IL\\", \\"IC\\", \\"ID\\", \\"IM\\", \\"XD\\", \\"XM\\"] for pattern in invalid_patterns: if pattern in roman: return -1 i = 0 value = 0 length = len(roman) while i < length: # Check for a valid pair if i + 1 < length and roman[i:i+2] in valid_pairs: value += valid_pairs[roman[i:i+2]] i += 2 else: value += roman_to_int.get(roman[i], 0) i += 1 return value"},{"question":"# Task Description Write a function that receives a list of dictionaries, each representing a student, and calculates the average grade for each student. Each dictionary contains the student\'s name and their grades in a list of subjects. # Function Specifications Implement the following function: ```python def calculate_average_grades(students: List[Dict[str, Union[str, List[float]]]]) -> Dict[str, float]: Computes the average grade for each student in the given list. Args: students (List[Dict[str, Union[str, List[float]]]]): A list where each element is a dictionary with \'name\' (str) and \'grades\' (List[float]). Returns: Dict[str, float]: A dictionary where keys are student names and values are their average grades. Example: >>> calculate_average_grades([{\\"name\\": \\"Alice\\", \\"grades\\": [80, 90, 100]}, {\\"name\\": \\"Bob\\", \\"grades\\": [70, 85, 78]}]) {\'Alice\': 90.0, \'Bob\': 77.66666666666667} >>> calculate_average_grades([{\\"name\\": \\"Charlie\\", \\"grades\\": [60, 75, 80]}]) {\'Charlie\': 71.66666666666667} # Your implementation here ``` # Constraints 1. The input list `students` is non-empty. 2. Each student dictionary has exactly two keys: `\'name\'` and `\'grades\'`. 3. The `\'name\'` key maps to a string representing the student\'s name. 4. The `\'grades\'` key maps to a non-empty list of non-negative floats. 5. Assume reasonable floating-point precision for the calculations. # Detailed Example Given the `students` list `[{\\"name\\": \\"Alice\\", \\"grades\\": [80, 90, 100]}, {\\"name\\": \\"Bob\\", \\"grades\\": [70, 85, 78]}]`: 1. For Alice, the average grade is `(80 + 90 + 100) / 3 = 90.0` 2. For Bob, the average grade is `(70 + 85 + 78) / 3 = 77.66666666666667` 3. The resulting dictionary is `{\'Alice\': 90.0, \'Bob\': 77.66666666666667}`","solution":"from typing import List, Dict, Union def calculate_average_grades(students: List[Dict[str, Union[str, List[float]]]]) -> Dict[str, float]: result = {} for student in students: name = student[\'name\'] grades = student[\'grades\'] average = sum(grades) / len(grades) result[name] = average return result"},{"question":"# Coding Challenge: Rock-Paper-Scissors Lizard-Spock Tournament Background: Rock-Paper-Scissors is a classic hand game. There exists an extended version called Rock-Paper-Scissors-Lizard-Spock popularized by the TV show \\"The Big Bang Theory\\". The rules are: - Scissors cuts Paper - Paper covers Rock - Rock crushes Lizard - Lizard poisons Spock - Spock smashes Scissors - Scissors decapitates Lizard - Lizard eats Paper - Paper disproves Spock - Spock vaporizes Rock - Rock crushes Scissors This challenge involves organizing a tournament of multiple players using Rock-Paper-Scissors-Lizard-Spock to determine the winner. Task: Implement a function `rpsls_tournament` that simulates a round-robin tournament and determines the winner. Function Signature: ```python def rpsls_tournament(players: List[str], games: List[Tuple[str, str, str, str]]) -> str: pass ``` Input: * A list of distinct strings `players` (1 <= len(players) <= 50) representing the names of players. * A list of tuples `games` where each tuple contains: - the name of Player 1 - the choice of Player 1 (one of \'Rock\', \'Paper\', \'Scissors\', \'Lizard\', \'Spock\') - the name of Player 2 - the choice of Player 2 (one of \'Rock\', \'Paper\', \'Scissors\', \'Lizard\', \'Spock\') Each game determines the winner between two players according to the rules of Rock-Paper-Scissors-Lizard-Spock. Output: * The name of the player with the most wins. If there\'s a tie, return the player whose name comes first lexicographically. Constraints: * Each player plays at least one game but possibly more. * It is guaranteed that no game will be between the same two players with the same choices. Example: ```python players = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] games = [ (\\"Alice\\", \\"Rock\\", \\"Bob\\", \\"Scissors\\"), # Alice wins (Rock crushes Scissors) (\\"Alice\\", \\"Lizard\\", \\"Charlie\\", \\"Lizard\\"), # Tie (Lizard vs Lizard) (\\"Bob\\", \\"Spock\\", \\"Charlie\\", \\"Scissors\\"), # Bob wins (Spock smashes Scissors) (\\"Charlie\\", \\"Rock\\", \\"Alice\\", \\"Spock\\") # Alice wins (Spock vaporizes Rock) ] assert rpsls_tournament(players, games) == \\"Alice\\" ``` **Note**: In this example, Alice and Bob both win 2 games, but Alice wins overall because her name comes first lexicographically.","solution":"def rpsls_tournament(players, games): Determines the winner of a Rock-Paper-Scissors-Lizard-Spock tournament. :param players: List of player names. :param games: List of games as tuples with player names and their choices. :return: The name of the player with the most wins. # Rules of Rock-Paper-Scissors-Lizard-Spock rules = { \\"Scissors\\": [\\"Paper\\", \\"Lizard\\"], \\"Paper\\": [\\"Rock\\", \\"Spock\\"], \\"Rock\\": [\\"Lizard\\", \\"Scissors\\"], \\"Lizard\\": [\\"Spock\\", \\"Paper\\"], \\"Spock\\": [\\"Scissors\\", \\"Rock\\"] } # Dictionary to keep track of each player\'s wins wins = {player: 0 for player in players} for game in games: player1, choice1, player2, choice2 = game if choice2 in rules[choice1]: # Player 1 wins wins[player1] += 1 elif choice1 in rules[choice2]: # Player 2 wins wins[player2] += 1 # No else needed as tie results in no action # Find the player with the most wins max_wins = max(wins.values()) winners = [player for player, win_count in wins.items() if win_count == max_wins] return min(winners)"},{"question":"# Water Container Volume Calculation Scenario You are working on a module for a gardening application that calculates the volume of water that can be held by a container given its dimensions and shape. The two common shapes are Cylinder and Rectangular Prism. You need to implement functions to compute the volume of water each container can hold based on their respective formulae. Input and Output Requirements You need to implement the following functions: 1. **`cylinder_volume(radius: float, height: float) -> float`**: * **Input**: Radius (positive float) and height (positive float) of the cylindrical container. * **Output**: Volume of the cylinder rounded to 2 decimal places. 2. **`rectangular_prism_volume(length: float, width: float, height: float) -> float`**: * **Input**: Length (positive float), width (positive float), and height (positive float) of the rectangular prism container. * **Output**: Volume of the rectangular prism rounded to 2 decimal places. Each function must validate that all dimensions are positive numbers. If the arguments do not meet these criteria, appropriate exceptions should be thrown. Ensure the functions are optimized for readability and performance. Provide necessary test cases to validate your functions. Example Usage and Expected Results ```python assert cylinder_volume(3, 5) == 141.37 assert rectangular_prism_volume(3, 4, 5) == 60.00 assert cylinder_volume(7.5, 10) == 1767.15 assert rectangular_prism_volume(2.5, 1.5, 4) == 15.00 ``` Constraints * All dimensions must be positive floats. * Floating-point inputs for dimensions are allowable, ensure your validation handles them correctly. This assessment will examine your ability to implement geometric formulas in a programming context, with an emphasis on validation and error handling.","solution":"import math def cylinder_volume(radius: float, height: float) -> float: Calculate the volume of a cylinder given its radius and height. Parameters: radius (float): The radius of the cylinder. height (float): The height of the cylinder. Returns: float: The volume of the cylinder rounded to 2 decimal places. if radius <= 0 or height <= 0: raise ValueError(\\"Both radius and height must be positive numbers.\\") volume = math.pi * (radius ** 2) * height return round(volume, 2) def rectangular_prism_volume(length: float, width: float, height: float) -> float: Calculate the volume of a rectangular prism given its length, width, and height. Parameters: length (float): The length of the rectangular prism. width (float): The width of the rectangular prism. height (float): The height of the rectangular prism. Returns: float: The volume of the rectangular prism rounded to 2 decimal places. if length <= 0 or width <= 0 or height <= 0: raise ValueError(\\"Length, width, and height must all be positive numbers.\\") volume = length * width * height return round(volume, 2)"},{"question":"# Problem Statement You are required to create a simplified version of a calendar application. The primary functionality will be to manage events by adding, deleting, and retrieving them based on certain criteria. # Objectives 1. **Create a class `EventCalendar` to manage the events**. 2. **Implement methods to add, delete, and retrieve events**. # Requirements 1. Implement the class `EventCalendar` with the following methods: * `add_event(event_name, start_time, end_time)`: Adds an event to the calendar with the given `event_name`, `start_time`, and `end_time`. * `delete_event(event_name)`: Deletes the event with the specified `event_name`. * `get_events_on(date)`: Retrieves all events occurring on the given `date`. 2. Validate the input parameters: * Ensure `start_time` and `end_time` are in the correct format (YYYY-MM-DD HH:MM). * Ensure `start_time` is before `end_time`. * Ensure `event_name` is a non-empty string. * Raise appropriate error messages for invalid inputs. 3. Store events in a suitable data structure that allows efficient retrieval and manipulation. 4. Ensure the `get_events_on(date)` method returns a list of tuples (event_name, start_time, end_time) sorted by `start_time`. # Constraints * Dates and times are always in the format \\"YYYY-MM-DD HH:MM\\". * `start_time` and `end_time` are within the same day. * The maximum number of events handled by the calendar is 10^4. * Your solution should efficiently handle the add and delete operations with a maximum time complexity of O(log n). # Example ```python # Initialize the calendar calendar = EventCalendar() # Add events calendar.add_event(\\"Meeting\\", \\"2023-10-01 09:00\\", \\"2023-10-01 10:00\\") calendar.add_event(\\"Lunch\\", \\"2023-10-01 12:00\\", \\"2023-10-01 13:00\\") calendar.add_event(\\"Dinner\\", \\"2023-10-01 19:00\\", \\"2023-10-01 20:00\\") # Get events on a specific date events_on_date = calendar.get_events_on(\\"2023-10-01\\") # Output: [(\\"Meeting\\", \\"2023-10-01 09:00\\", \\"2023-10-01 10:00\\"), # (\\"Lunch\\", \\"2023-10-01 12:00\\", \\"2023-10-01 13:00\\"), # (\\"Dinner\\", \\"2023-10-01 19:00\\", \\"2023-10-01 20:00\\")] # Delete an event calendar.delete_event(\\"Lunch\\") # Get events on a specific date events_on_date = calendar.get_events_on(\\"2023-10-01\\") # Output: [(\\"Meeting\\", \\"2023-10-01 09:00\\", \\"2023-10-01 10:00\\"), # (\\"Dinner\\", \\"2023-10-01 19:00\\", \\"2023-10-01 20:00\\")] ``` # Code Structure ```python class EventCalendar: def __init__(self): # Initialize your data structure def add_event(self, event_name, start_time, end_time): # Implement the logic to add an event def delete_event(self, event_name): # Implement the logic to delete an event def get_events_on(self, date): # Implement the logic to retrieve events on a specific date ``` Feel free to implement the `EventCalendar` class following the given requirements and examples.","solution":"import datetime class EventCalendar: def __init__(self): self.events = {} def _validate_time(self, time_str): try: return datetime.datetime.strptime(time_str, \\"%Y-%m-%d %H:%M\\") except ValueError: raise ValueError(\\"Time format is incorrect, should be YYYY-MM-DD HH:MM\\") def _validate_event_name(self, event_name): if not event_name: raise ValueError(\\"Event name cannot be empty\\") def add_event(self, event_name, start_time, end_time): self._validate_event_name(event_name) start_dt = self._validate_time(start_time) end_dt = self._validate_time(end_time) if start_dt >= end_dt: raise ValueError(\\"Start time must be before end time\\") if start_dt.date() != end_dt.date(): raise ValueError(\\"Start time and end time must be on the same day\\") date_key = start_dt.date().isoformat() if date_key not in self.events: self.events[date_key] = [] self.events[date_key].append((event_name, start_dt, end_dt)) self.events[date_key].sort(key=lambda event: event[1]) def delete_event(self, event_name): for date_key, day_events in self.events.items(): self.events[date_key] = [event for event in day_events if event[0] != event_name] self.events = {k: v for k, v in self.events.items() if v} def get_events_on(self, date): try: date_key = datetime.datetime.strptime(date, \\"%Y-%m-%d\\").date().isoformat() if date_key not in self.events: return [] return [(event[0], event[1].strftime(\\"%Y-%m-%d %H:%M\\"), event[2].strftime(\\"%Y-%m-%d %H:%M\\")) for event in self.events[date_key]] except ValueError: raise ValueError(\\"Date format is incorrect, should be YYYY-MM-DD\\")"},{"question":"# Problem Statement You are working on a data analysis project and need to compute a specific statistical measure called the \\"mode\\". The mode is the number that appears most frequently in a data set. If there is more than one mode, return the smallest one. Your task is to write a function that takes a list of integers and returns the mode of the list. If the list is empty, return `None`. # Task Write a function `find_mode` that takes a list of integers and returns the mode. If there is more than one mode, return the smallest one. If the list is empty, return `None`. # Function Signature ```python def find_mode(nums: List[int]) -> int: ``` # Input - `nums` (0 ≤ len(nums) ≤ 10^5): A list of integers where each integer is between `-10^6` and `10^6`. # Output - Returns an integer representing the mode if the list is not empty, or `None` if the list is empty. # Example ```python find_mode([3, 1, 2, 2, 3, 3]) # Output: 3 find_mode([3, 1, 2, 2, 3, 3, 4, 4, 4, 4]) # Output: 4 find_mode([]) # Output: None ``` # Constraints & Considerations - Make sure the function handles large lists efficiently. - Consider edge cases, such as lists with all unique elements or lists where all elements are the same. - Ensure the function correctly identifies the smallest mode when there are multiple modes. # Scenario Imagine you are working for a customer survey company. You have a large list of survey responses where each response is a rating from `-10^6` to `10^6`. You need to quickly determine the most common rating to identify what most respondents think. Implement your solution to handle large datasets efficiently and correctly.","solution":"from typing import List, Optional from collections import Counter def find_mode(nums: List[int]) -> Optional[int]: Returns the mode of the list of integers. If the list is empty, returns None. If multiple modes exist, returns the smallest one. if not nums: return None # Create a counter for all numbers num_counts = Counter(nums) # Find the maximum frequency max_count = max(num_counts.values()) # Find all elements with the maximum frequency modes = [num for num, count in num_counts.items() if count == max_count] # Return the smallest mode return min(modes)"},{"question":"# Question: Calculating Subarray Sums Using Sliding Window Technique You are required to implement a function that calculates the sum of all subarrays of a given list of integers using the sliding window technique. The function should return a list of sums for subarrays of each length from 1 up to the length of the input list. Function Signature ```python def subarray_sums(arr: list) -> list: pass ``` Input * `arr` (list): A list of integers. The list can contain zero or more elements. Output * Returns a list of lists, where each inner list contains the sums of all subarrays of length `k`, for `k` from 1 to the length of the input list. Constraints * All elements in the input list `arr` are integers. * The length of the input list will not exceed 1000. # Example Usage: ```python assert subarray_sums([]) == [] assert subarray_sums([1]) == [[1]] assert subarray_sums([1, 2]) == [[1, 2], [3]] assert subarray_sums([1, 2, 3]) == [[1, 2, 3], [3, 5], [6]] ``` # Explanation: For input `[1, 2, 3]`: - Subarrays of length 1: `[1]`, `[2]`, `[3]` ⇒ Sums: `[1, 2, 3]` - Subarrays of length 2: `[1, 2]`, `[2, 3]` ⇒ Sums: `[3, 5]` - Subarrays of length 3: `[1, 2, 3]` ⇒ Sums: `[6]` # Notes 1. You must handle edge cases such as an empty list or a single-element list. 2. Ensure your implementation efficiently calculates the sums using a sliding window technique. 3. The output must match the example provided for any other input. # Performance Requirements * Your solution should run efficiently within the constraints provided. * Aim for a time complexity of O(n^2) and a space complexity of O(n^2).","solution":"def subarray_sums(arr: list) -> list: n = len(arr) if n == 0: return [] result = [] for k in range(1, n + 1): subarray_sum = [] current_sum = sum(arr[:k]) subarray_sum.append(current_sum) for i in range(k, n): current_sum += arr[i] - arr[i - k] subarray_sum.append(current_sum) result.append(subarray_sum) return result"},{"question":"# Scenario You are tasked with creating a command-line utility to handle a list of tasks in a to-do application. The utility should be able to add, remove, list, and mark tasks as complete. # Problem Statement Write a class `TodoList` that supports basic task management operations. Each task is a dictionary containing `id`, `description`, and `completed` fields. The `TodoList` class should allow the following operations: 1. `add_task(description: str) -> None`: Adds a new task with the given description. The `id` should be a unique integer, and `completed` should initially be `False`. 2. `remove_task(task_id: int) -> bool`: Removes the task with the given `id`. Returns `True` if the task was found and removed, otherwise `False`. 3. `list_tasks(show_completed: bool = True) -> List[Dict]`: Returns a list of all tasks. If `show_completed` is `False`, only returns tasks that are not completed. 4. `mark_task_complete(task_id: int) -> bool`: Marks the task with the given `id` as complete. Returns `True` if the task was found and marked, otherwise `False`. # Class Signature ```python class TodoList: def __init__(self): # Initialize task list and id counter pass def add_task(self, description: str) -> None: pass def remove_task(self, task_id: int) -> bool: pass def list_tasks(self, show_completed: bool = True) -> List[Dict]: pass def mark_task_complete(self, task_id: int) -> bool: pass ``` # Constraints - Task descriptions are non-empty strings. - Task IDs are unique integers and should start from 1 and increment by 1 with each new task. - Operations should have an average time complexity of O(1) or O(n) where n is the number of tasks. # Example Here is how the `TodoList` class should behave based on a series of operations: ```python todo = TodoList() todo.add_task(\\"Buy groceries\\") todo.add_task(\\"Read a book\\") todo.mark_task_complete(1) print(todo.list_tasks(show_completed=False)) # Expected Output: [{\'id\': 2, \'description\': \'Read a book\', \'completed\': False}] todo.add_task(\\"Go for a run\\") todo.remove_task(2) print(todo.list_tasks()) # Expected Output: [{\'id\': 1, \'description\': \'Buy groceries\', \'completed\': True}, {\'id\': 3, \'description\': \'Go for a run\', \'completed\': False}] ``` Here, task IDs are unique integers, and operations on tasks modify the internal state of the `TodoList` instance accordingly.","solution":"class TodoList: def __init__(self): self.tasks = [] self.next_id = 1 def add_task(self, description: str) -> None: if description: task = { \'id\': self.next_id, \'description\': description, \'completed\': False } self.tasks.append(task) self.next_id += 1 def remove_task(self, task_id: int) -> bool: for task in self.tasks: if task[\'id\'] == task_id: self.tasks.remove(task) return True return False def list_tasks(self, show_completed: bool = True) -> list: if show_completed: return self.tasks[:] return [task for task in self.tasks if not task[\'completed\']] def mark_task_complete(self, task_id: int) -> bool: for task in self.tasks: if task[\'id\'] == task_id: task[\'completed\'] = True return True return False"},{"question":"# Graph Validator Understanding the structure of graphs is critical in many areas of computer science. Your task is to implement functionality that validates whether a given graph is a valid undirected graph. # Problem Statement Create a function `is_valid_graph` that accepts a list of edges and determines if it forms a valid undirected graph. # Function Definition ```python def is_valid_graph(edges: List[Tuple[int, int]]) -> bool: pass ``` # Detailed Requirements 1. **Input**: * A list `edges` consisting of tuples representing edges, where each tuple contains two integers `(u, v)` representing an edge between nodes `u` and `v`. Nodes are 0-indexed. * The list can be empty, representing an empty graph. * Graph can have at most 1000 nodes and 10^5 edges. 2. **Output**: * Return `True` if the given set of edges forms a valid undirected graph. * Return `False` otherwise. # Constraints * An undirected graph must not have any self-loops (edges where `u == v`). * The graph must be connected if it contains more than one node. * The graph must not have multiple edges between the same pair of nodes. # Example ```python edges = [(0, 1), (1, 2), (2, 0)] print(is_valid_graph(edges)) # Expected Output: True edges = [(0, 1), (1, 2), (2, 1), (0, 1)] print(is_valid_graph(edges)) # Expected Output: False (duplicate edges) edges = [(0, 0), (1, 2)] print(is_valid_graph(edges)) # Expected Output: False (self-loop) edges = [(0, 1), (2, 3)] print(is_valid_graph(edges)) # Expected Output: False (disconnected graph) ``` # Performance Requirements Your solution should be efficient and should ideally perform within a time complexity of O(E + V), where E is the number of edges and V is the number of nodes.","solution":"from typing import List, Tuple from collections import defaultdict, deque def is_valid_graph(edges: List[Tuple[int, int]]) -> bool: if not edges: return True graph = defaultdict(list) nodes = set() for u, v in edges: if u == v: return False # check for duplicate edges if v in graph[u] or u in graph[v]: return False graph[u].append(v) graph[v].append(u) nodes.add(u) nodes.add(v) # check if the graph is connected start_node = next(iter(nodes)) visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == len(nodes)"},{"question":"Problem Statement You are asked to implement a method to determine whether a given undirected graph is a bipartite graph. A graph is bipartite if its vertices can be divided into two independent sets, U and V, such that every edge connects a vertex in U to one in V. # Function to Implement ```python def is_bipartite(graph): Determine if the provided graph is bipartite. @param graph: A dictionary where keys are nodes and values are lists of adjacent nodes. @return: A boolean value. True if the graph is bipartite, False otherwise. # Your code here pass ``` # Input and Output Formats Input - `graph`: A dictionary where each key is a node and each value is a list of adjacent nodes. The graph is undirected, so if node A is connected to node B, then node B is also connected to node A. Output - Returns `True` if the graph is bipartite, `False` otherwise. # Constraints - The graph will have no more than 1000 nodes. # Example ```python # Example Input: graph = { 1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3] } # Example Output: print(is_bipartite(graph)) # True # Example Input: graph = { 1: [2, 3, 4], 2: [1, 3], 3: [1, 2, 4], 4: [1, 3] } # Example Output: print(is_bipartite(graph)) # False ``` # Notes - You can assume that the input graph is connected. - The function should be implemented using a Breadth-First Search (BFS) or Depth-First Search (DFS) approach. - Use appropriate data structures to effectively manage the graph traversal and node color assignments.","solution":"from collections import deque def is_bipartite(graph): Determine if the provided graph is bipartite. @param graph: A dictionary where keys are nodes and values are lists of adjacent nodes. @return: A boolean value. True if the graph is bipartite, False otherwise. color = {} for node in graph.keys(): if node not in color: # Node hasn\'t been colored yet queue = deque([node]) color[node] = 0 # Start coloring with color 0 while queue: current = queue.popleft() current_color = color[current] for neighbor in graph[current]: if neighbor not in color: # Color with opposite color color[neighbor] = 1 - current_color queue.append(neighbor) elif color[neighbor] == current_color: # If neighbor has the same color, it\'s not bipartite return False return True"},{"question":"**Passenger Flight Connection** You are given a set of flights (as tuples of direct connections between cities) and a list of passengers who need to travel between different cities. Each passenger has a starting city and a destination city. The task is to determine if each passenger can reach their destination city from their starting city using the given flights. Write a function that, for each passenger, determines whether it\'s possible to travel from the start city to the destination city. If a passenger can complete their travel, output `True`; otherwise, output `False`. # Constraints: - A flight is represented as a tuple of two strings `(city1, city2)`, indicating a direct flight from `city1` to `city2`. - Flights are one-way only. - There may be multiple passengers, each with a different start and end city. - There may be multiple flights between the same pair of cities. - The list of flights and the passengers can be empty. # Example: ```python def can_travel(flights: list[tuple[str, str]], passengers: list[tuple[str, str]]) -> list[bool]: pass # Example 1 flights1 = [(\\"JFK\\", \\"ATL\\"), (\\"ATL\\", \\"SFO\\"), (\\"SFO\\", \\"LAX\\"), (\\"LAX\\", \\"SEA\\")] passengers1 = [(\\"JFK\\", \\"SEA\\"), (\\"JFK\\", \\"SFO\\"), (\\"ATL\\", \\"SEA\\")] print(can_travel(flights1, passengers1)) # Output: [True, True, True] # Example 2 flights2 = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\")] passengers2 = [(\\"A\\", \\"D\\"), (\\"B\\", \\"A\\"), (\\"D\\", \\"A\\")] print(can_travel(flights2, passengers2)) # Output: [True, False, False] # Example 3 flights3 = [(\\"X\\", \\"Y\\"), (\\"Y\\", \\"Z\\"), (\\"Z\\", \\"X\\")] passengers3 = [(\\"X\\", \\"X\\"), (\\"Y\\", \\"X\\"), (\\"Z\\", \\"Y\\")] print(can_travel(flights3, passengers3)) # Output: [True, True, True] # Example 4 flights4 = [] passengers4 = [(\\"A\\", \\"B\\")] print(can_travel(flights4, passengers4)) # Output: [False] # Example 5 flights5 = [(\\"MUC\\", \\"LHR\\"), (\\"LHR\\", \\"SFO\\"), (\\"SFO\\", \\"SIN\\"), (\\"SIN\\", \\"CDG\\")] passengers5 = [(\\"MUC\\", \\"CDG\\"), (\\"LHR\\", \\"MUC\\"), (\\"SFO\\", \\"LHR\\")] print(can_travel(flights5, passengers5)) # Output: [True, False, False] ``` # Notes: - You are expected to implement the `can_travel` function. - Make sure your function is efficient and handles various edge cases. - Consider the connectivity of the graph formed by the flights when designing your solution.","solution":"def can_travel(flights: list[tuple[str, str]], passengers: list[tuple[str, str]]) -> list[bool]: from collections import defaultdict, deque # Build adjacency list for the graph graph = defaultdict(list) for start, end in flights: graph[start].append(end) def bfs(start, end): # Perform BFS to find if there is a path from start to end if start == end: return True visited = set() queue = deque([start]) while queue: current = queue.popleft() if current in visited: continue visited.add(current) for neighbor in graph[current]: if neighbor == end: return True queue.append(neighbor) return False results = [] for start, end in passengers: results.append(bfs(start, end)) return results"},{"question":"# Coding Assessment Question Context In combinatorics, a permutation of a set is a rearrangement of its elements into a different sequence or order. For a given string, there are multiple unique permutations if the string contains duplicate characters. Task Write a function `unique_permutations` that takes one argument: - `s` (str): a string containing the characters to be permuted. The function should return a sorted list of all unique permutations of the string `s`. Ensure there are no duplicate permutations in the result even if the original string contains duplicate characters. Function Signature ```python def unique_permutations(s: str) -> list: pass ``` Input Constraints 1. `s`: a string which may include duplicate characters. The length of the string will be between 1 and 8 characters inclusive. Output Return a list of strings, where each string is a unique permutation of the input string in lexicographic order. Example Usage ```python >>> unique_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> unique_permutations(\\"aab\\") [\'aab\', \'aba\', \'baa\'] >>> unique_permutations(\\"a\\") [\'a\'] >>> unique_permutations(\\"aa\\") [\'aa\'] ``` Performance Requirements Ensure that the function handles up to 40320 permutations efficiently within the constraints provided.","solution":"import itertools def unique_permutations(s: str) -> list: Returns a sorted list of all unique permutations of the string `s`. # Generate all permutations using itertools.permutations all_permutations = set(itertools.permutations(s)) # Convert tuples to strings and sort the list unique_permutations_list = sorted([\'\'.join(p) for p in all_permutations]) return unique_permutations_list"},{"question":"# Question: Trip Planning in a Directed Acyclic Graph (DAG) You are provided with a class `TripPlanner` that represents a directed acyclic graph (DAG) where nodes represent cities and edges represent direct travel routes between them with associated costs. The class initially contains a method `find_routes` to determine all possible routes from a source city to a destination city, but it currently does not support the calculation of the shortest cost route or handling graphs in a dynamic manner. # Task 1. Extend the `TripPlanner` class to not only find all possible routes but also handle the following scenarios: - Compute the shortest cost route from a source city to a destination city. - Support adding new cities and travel routes dynamically. - Handle deletions of existing travel routes and cities efficiently. # Requirements 1. **Implement** the following additional methods in the `TripPlanner` class: - `add_city`: to add a new city to the DAG. - `add_route`: to add a direct travel route between two cities with an associated cost. - `remove_city`: to remove a city and all its connecting routes from the DAG. - `remove_route`: to remove a specific travel route between two cities. - `shortest_cost_route`: to find the route with the least travel cost from a source city to a destination city. # Input: - A directed acyclic graph, represented via an adjacency list or similar structure. - Series of city and route additions or deletions. - Queries to find the shortest cost route between cities. # Output: - Shortest cost route between specified source and destination cities after each graph modification. # Constraints: - Ensure the graph remains acyclic. - Travel costs between cities are non-negative. # Example: ```python trip = TripPlanner() trip.add_city(\\"A\\") trip.add_city(\\"B\\") trip.add_city(\\"C\\") trip.add_city(\\"D\\") trip.add_route(\\"A\\", \\"B\\", 10) trip.add_route(\\"A\\", \\"C\\", 15) trip.add_route(\\"B\\", \\"D\\", 12) trip.add_route(\\"C\\", \\"D\\", 10) # Finding the shortest cost route from city A to city D trip.shortest_cost_route(\\"A\\", \\"D\\") # Output should be [\'A\', \'C\', \'D\'] with cost 25. # Adding a new route and recalculating trip.add_route(\\"A\\", \\"D\\", 40) trip.shortest_cost_route(\\"A\\", \\"D\\") # Output should remain [\'A\', \'C\', \'D\'] with cost 25 due to lower cost. # Removing a route and recalculating trip.remove_route(\\"A\\", \\"C\\") trip.shortest_cost_route(\\"A\\", \\"D\\") # Output should now be [\'A\', \'B\', \'D\'] with cost 22. ``` # Function Signatures: 1. `def add_city(self, city: str) -> None:` 2. `def add_route(self, from_city: str, to_city: str, cost: int) -> None:` 3. `def remove_city(self, city: str) -> None:` 4. `def remove_route(self, from_city: str, to_city: str) -> None:` 5. `def shortest_cost_route(self, from_city: str, to_city: str) -> List[str]:`","solution":"import heapq from collections import defaultdict from typing import Dict, List, Tuple class TripPlanner: def __init__(self): self.graph = defaultdict(dict) def add_city(self, city: str) -> None: if city not in self.graph: self.graph[city] = {} def add_route(self, from_city: str, to_city: str, cost: int) -> None: self.graph[from_city][to_city] = cost def remove_city(self, city: str) -> None: if city in self.graph: del self.graph[city] for cities in self.graph.values(): if city in cities: del cities[city] def remove_route(self, from_city: str, to_city: str) -> None: if to_city in self.graph[from_city]: del self.graph[from_city][to_city] def shortest_cost_route(self, from_city: str, to_city: str) -> List[str]: if from_city not in self.graph or to_city not in self.graph: return [] # Dijkstra\'s algorithm to find the shortest path in a DAG graph queue = [(0, from_city, [])] visited = set() while queue: cost, city, path = heapq.heappop(queue) if city in visited: continue path = path + [city] if city == to_city: return path visited.add(city) for neighbour, travel_cost in self.graph[city].items(): if neighbour not in visited: heapq.heappush(queue, (cost + travel_cost, neighbour, path)) return []"},{"question":"# String Pattern Matching Using KMP Algorithm Problem Statement You are tasked with implementing the Knuth-Morris-Pratt (KMP) algorithm for string pattern matching. The KMP algorithm searches for occurrences of a \\"pattern\\" within a main \\"text\\" by employing the observation that when a mismatch occurs, the next comparison can reuse information from previous comparisons to avoid redundant checks. Function Specifications ```python def kmp_search(pattern: str, text: str) -> list: Implements the KMP algorithm to find all occurrences of a pattern in the given text. :param pattern: The substring pattern to search for. :param text: The main string text where the pattern is to be searched. :return: A list of starting indices where pattern is found in the text pass # To be implemented by the student def build_lps(pattern: str) -> list: Constructs the Longest Prefix Suffix (LPS) array used in the KMP algorithm. :param pattern: The substring pattern for which the LPS array is to be constructed. :return: The LPS array. pass # To be implemented by the student ``` Input and Output * **Input**: Two strings `pattern` and `text` where `pattern` is the substring to find and `text` is the main string. * **Output**: A list of integers indicating the starting indices of where `pattern` is found within `text`. Constraints * The `pattern` and `text` are non-empty strings containing only printable ASCII characters. * The length of `pattern` will not exceed the length of `text`. Example ```python >>> kmp_search(\\"abc\\", \\"abcabcabc\\") [0, 3, 6] >>> kmp_search(\\"aab\\", \\"aaabaaab\\") [1, 5] ``` Edge Cases 1. Pattern longer than text. 2. Pattern not found in text. 3. Empty pattern or text. 4. Repeated patterns within text. Notes 1. Ensure your program correctly constructs the LPS array. 2. Handle edge cases gracefully. 3. You may use helper functions for better organization. 4. Provide appropriate comments in your code. The additional question should challenge the students to understand and implement a classic searching algorithm, adhering to existing guidelines on technical complexity, length, and style. This ensures a seamless integration with the provided sample questions.","solution":"def build_lps(pattern: str) -> list: Constructs the Longest Prefix Suffix (LPS) array used in the KMP algorithm. :param pattern: The substring pattern for which the LPS array is to be constructed. :return: The LPS array. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1 return lps def kmp_search(pattern: str, text: str) -> list: Implements the KMP algorithm to find all occurrences of a pattern in the given text. :param pattern: The substring pattern to search for. :param text: The main string text where the pattern is to be searched. :return: A list of starting indices where pattern is found in the text. if not pattern or not text: return [] lps = build_lps(pattern) i = 0 j = 0 result = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# English to Morse Code Translator As part of a communications upgrade for a historical reenactment group, you are asked to create a tool that translates English text into Morse code. Your task is to write a function that accomplishes the translation. Requirements: 1. The function should take a string of English text as input and return a string of the corresponding Morse code. 2. Letters should be separated by a single space, and words should be separated by a slash (`/`). 3. It should handle both upper and lower case letters by treating them as the same. 4. Characters that do not have representations in Morse code (e.g., punctuation, numbers) should be ignored. Input: * `text` (str): a string containing the English text to be translated. Output: * A string containing the translated Morse code. Function Signature: ```python def english_to_morse(text: str) -> str: pass ``` Example: ```python # Example usage: assert english_to_morse(\\"SOS\\") == \\"... --- ...\\" assert english_to_morse(\\"Hello World\\") == \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" assert english_to_morse(\\"Python Programming\\") == \\".--. -.-- - .... --- -. / .--. .-. --- --. .-. .- -- -- .. -. --.\\" # Note: Solution should only translate letters and spaces, ignoring punctuation and numbers. ``` Constraints: * The input string `text` will have at most length of 1000 characters. * The text will contain printable ASCII characters. Implement the function `english_to_morse` adhering to the above specifications.","solution":"def english_to_morse(text: str) -> str: morse_code_dict = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'a\': \'.-\', \'b\': \'-...\', \'c\': \'-.-.\', \'d\': \'-..\', \'e\': \'.\', \'f\': \'..-.\', \'g\': \'--.\', \'h\': \'....\', \'i\': \'..\', \'j\': \'.---\', \'k\': \'-.-\', \'l\': \'.-..\', \'m\': \'--\', \'n\': \'-.\', \'o\': \'---\', \'p\': \'.--.\', \'q\': \'--.-\', \'r\': \'.-.\', \'s\': \'...\', \'t\': \'-\', \'u\': \'..-\', \'v\': \'...-\', \'w\': \'.--\', \'x\': \'-..-\', \'y\': \'-.--\', \'z\': \'--..\' } words = text.split() translated_words = [] for word in words: translated_letters = [morse_code_dict.get(letter, \'\') for letter in word if letter in morse_code_dict] translated_word = \' \'.join(translated_letters) if translated_word: translated_words.append(translated_word) return \' / \'.join(translated_words)"},{"question":"# Coding Assessment Question Context As part of a coordinate transformation module, you are required to convert a given point in Cartesian coordinates to its corresponding point in polar coordinates. Polar coordinates represent the point in terms of its distance from the origin and the angle from the positive x-axis. Task Write a function `cartesian_to_polar` that converts a given list of Cartesian coordinates to their corresponding polar coordinates. Each coordinate pair is represented by its x and y values. Function Signature ```python def cartesian_to_polar(points: list[Point2D]) -> list[PolarCoord]: ``` Input - `points`: A list of `Point2D` objects where each point is a named tuple with fields `x` and `y`. Output - A list of `PolarCoord` objects representing the coordinates in polar form. Each `PolarCoord` should have fields `r` (distance) and `theta` (angle in radians). Constraints - The list of points must not be empty. - If the list of points is empty, the function should raise a `ValueError` with the message \\"No points provided\\". Examples ```python >>> cartesian_to_polar([ ... Point2D(x=3, y=4), ... Point2D(x=1, y=1), ... Point2D(x=0, y=0) ... ]) [PolarCoord(r=5.0, theta=0.93), PolarCoord(r=1.41, theta=0.79), PolarCoord(r=0.0, theta=0.0)] >>> cartesian_to_polar([]) Traceback (most recent call last): ... ValueError: No points provided ``` Use the provided `Point2D` and `PolarCoord` namedtuple definitions for structuring the input and output data. ```python from collections import namedtuple import math Point2D = namedtuple(\\"Point2D\\", \\"x y\\") PolarCoord = namedtuple(\\"PolarCoord\\", \\"r theta\\") ``` Your task is to implement the `cartesian_to_polar` function to match the above specifications.","solution":"from collections import namedtuple import math Point2D = namedtuple(\\"Point2D\\", \\"x y\\") PolarCoord = namedtuple(\\"PolarCoord\\", \\"r theta\\") def cartesian_to_polar(points): if not points: raise ValueError(\\"No points provided\\") polar_coords = [] for point in points: r = math.sqrt(point.x ** 2 + point.y ** 2) theta = math.atan2(point.y, point.x) polar_coords.append(PolarCoord(r, theta)) return polar_coords"},{"question":"# Coding Assessment Question Context: You need to implement a basic spell checker for a document. The spell checker will use a predefined list of valid words and flag any word in the document that isn\'t found in this list. Task: Write a Python function `spell_checker(file_path: str, valid_words: list[str]) -> list[tuple[int, str]]` that reads a text file and identifies all the misspelled words. The function should return a list of tuples, where each tuple contains the line number and the misspelled word. Implementation Steps: 1. Read the file line by line. 2. Split each line into words, ignoring any punctuation. 3. Check each word against the list of valid words. 4. Collect all misspelled words along with their corresponding line numbers. Input Format: - `file_path`: A string representing the path to the input text file. - `valid_words`: A list of strings representing the valid words. Output Format: - Return a list of tuples, where each tuple contains: - An integer representing the line number. - A string representing the misspelled word. Constraints: - The file contains only alphabetic characters and spaces (no punctuation). - Word matching should be case-insensitive. - Assume the file is non-empty. Performance Requirements: - The solution should efficiently handle files with up to 1000 lines and 100 words per line. Example: Suppose the input file at \\"document.txt\\" contains the text: ``` Thiss is a simple spell checker testt. the quick brown fox jumps over the lazy doggs. ``` And the list of valid words is: ```python valid_words = [\\"this\\", \\"is\\", \\"a\\", \\"simple\\", \\"spell\\", \\"checker\\", \\"test\\", \\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"lazy\\", \\"dog\\"] ``` Calling `spell_checker(\\"document.txt\\", valid_words)` might yield: ```python [(1, \'Thiss\'), (1, \'testt\'), (2, \'doggs\')] ``` Note: - The function should handle case-insensitive matching (e.g., \\"This\\" and \\"this\\" should be treated as the same word). - Line numbers in the output should be 1-based (the first line of the file is line 1).","solution":"def spell_checker(file_path: str, valid_words: list[str]) -> list[tuple[int, str]]: Identifies all the misspelled words in a text file. Args: file_path (str): The path to the input text file. valid_words (list[str]): A list of strings representing the valid words. Returns: list[tuple[int, str]]: List of tuples containing the line number and the misspelled word. misspelled_words = [] lower_valid_words = set(word.lower() for word in valid_words) with open(file_path, \'r\') as file: for line_number, line in enumerate(file, start=1): words = line.split() for word in words: if word.lower() not in lower_valid_words: misspelled_words.append((line_number, word)) return misspelled_words"},{"question":"# Coding Challenge: Stock Price Insights Aggregator Your task is to develop a Python script to aggregate stock price data from two different APIs: Alpha Vantage and IEX Cloud. You are required to implement error handling, optimize data retrieval, and handle different edge cases effectively. Function Signature ```python def get_stock_data(symbol: str) -> dict: Fetch current stock price data from Alpha Vantage and IEX Cloud for a given symbol. Args: symbol (str): The ticker symbol of the stock (e.g., \'AAPL\' for Apple Inc.). Returns: dict: Aggregated stock price data or an error message in case of an issue. ``` # Instructions 1. **API Responses Integration**: - Retrieve stock price data using the provided API keys (assume the keys are defined as constants in the script). - Aggregate the response data into a single dictionary that indicates the source of each data point. 2. **Error Handling**: - Implement error handling to manage scenarios where one or both APIs fail to return data. - Provide detailed error messages for different issues: - Missing API keys. - Invalid ticker symbol. - Network issues / API timeouts. - Partial data retrieval (one API succeeds, another fails). 3. **Optimization**: - Handle API requests in parallel to minimize network latency. - Implement retry logic for transient network issues or API rate-limit errors. 4. **Edge Cases**: - Ensure correct handling when the ticker symbol is invalid or either API returns no data. 5. **Testing**: - Write tests covering various scenarios, including valid and invalid ticker symbols, network failures, and cases where only one API fetches valid data. # Constraints - Assume that you have valid API keys for both Alpha Vantage and IEX Cloud. - Use Python\'s `requests` library for making HTTP GET requests. ```python import requests import concurrent.futures # Put your API key(s) here ALPHA_VANTAGE_API_KEY = \\"your_alpha_vantage_api_key\\" IEX_CLOUD_API_KEY = \\"your_iex_cloud_api_key\\" ALPHA_VANTAGE_URL_BASE = \\"https://www.alphavantage.co/query\\" IEX_CLOUD_URL_BASE = \\"https://cloud.iexapis.com/stable/stock\\" def get_stock_data(symbol: str) -> dict: # Your implementation here pass if __name__ == \\"__main__\\": from pprint import pprint symbol = input(\\"Enter a stock ticker symbol (e.g., \'AAPL\' for Apple Inc.): \\").strip().upper() if symbol: try: stock_data = get_stock_data(symbol) pprint(stock_data) except Exception as e: print(f\\"Error: {e}\\") ``` # Example ```python >>> get_stock_data(\\"AAPL\\") { \\"AlphaVantage\\": { \\"current_price\\": 150.00, \\"volume\\": 1000000, \\"close\\": 149.50 }, \\"IEXCloud\\": { \\"current_price\\": 150.10, \\"volume\\": 1050000, \\"close\\": 149.55 } } ``` Ensure your function adheres to the specified requirements and runs efficiently.","solution":"import requests import concurrent.futures # Put your API key(s) here ALPHA_VANTAGE_API_KEY = \\"your_alpha_vantage_api_key\\" IEX_CLOUD_API_KEY = \\"your_iex_cloud_api_key\\" ALPHA_VANTAGE_URL_BASE = \\"https://www.alphavantage.co/query\\" IEX_CLOUD_URL_BASE = \\"https://cloud.iexapis.com/stable/stock\\" def fetch_alpha_vantage_data(symbol): try: url = f\\"{ALPHA_VANTAGE_URL_BASE}?function=GLOBAL_QUOTE&symbol={symbol}&apikey={ALPHA_VANTAGE_API_KEY}\\" response = requests.get(url) response.raise_for_status() data = response.json() if \\"Global Quote\\" in data: quote = data[\\"Global Quote\\"] return { \\"current_price\\": float(quote[\\"05. price\\"]), \\"volume\\": int(quote[\\"06. volume\\"]), \\"close\\": float(quote[\\"08. previous close\\"]) } else: return {\\"error\\": \\"Invalid response from Alpha Vantage\\"} except requests.RequestException as e: return {\\"error\\": f\\"Request error from Alpha Vantage: {str(e)}\\"} def fetch_iex_cloud_data(symbol): try: url = f\\"{IEX_CLOUD_URL_BASE}/{symbol}/quote?token={IEX_CLOUD_API_KEY}\\" response = requests.get(url) response.raise_for_status() data = response.json() return { \\"current_price\\": float(data[\\"latestPrice\\"]), \\"volume\\": int(data[\\"latestVolume\\"]), \\"close\\": float(data[\\"previousClose\\"]) } except requests.RequestException as e: return {\\"error\\": f\\"Request error from IEX Cloud: {str(e)}\\"} def get_stock_data(symbol: str) -> dict: if not ALPHA_VANTAGE_API_KEY or not IEX_CLOUD_API_KEY: return {\\"error\\": \\"Missing API keys\\"} symbol = symbol.upper() with concurrent.futures.ThreadPoolExecutor() as executor: alpha_future = executor.submit(fetch_alpha_vantage_data, symbol) iex_future = executor.submit(fetch_iex_cloud_data, symbol) alpha_result = alpha_future.result() iex_result = iex_future.result() result = {} if \\"error\\" not in alpha_result: result[\\"AlphaVantage\\"] = alpha_result else: result[\\"AlphaVantage_Error\\"] = alpha_result[\\"error\\"] if \\"error\\" not in iex_result: result[\\"IEXCloud\\"] = iex_result else: result[\\"IEXCloud_Error\\"] = iex_result[\\"error\\"] return result"},{"question":"# Analyzing Large Numbers Context Handling large numbers is a common task in programming, especially when dealing with operations that exceed the native integer limits of some languages. Such problems require you to manipulate numbers using strings or special libraries to ensure precision. Problem Design a function `add_large_numbers(num1: str, num2: str) -> str` that takes two large numbers represented as strings and returns their sum, also as a string. The numbers can be arbitrarily large and may not fit into standard numerical data types. Input and Output Formats * **Input**: Two strings, `num1` and `num2`, each representing a large non-negative integer. * **Output**: A single string representing the sum of the two input numbers. Constraints * Both input strings consist only of digits (0-9) and have no leading zeros. * The input numbers can be very large, potentially thousands of digits long. Example ```python >>> add_large_numbers(\\"123456789123456789\\", \\"987654321987654321\\") \\"1111111111111111110\\" >>> add_large_numbers(\\"999999999999999999\\", \\"1\\") \\"1000000000000000000\\" >>> add_large_numbers(\\"12345\\", \\"67890\\") \\"80235\\" >>> add_large_numbers(\\"0\\", \\"0\\") \\"0\\" ``` # Requirements * The solution must efficiently handle the addition of the two numbers, ensuring accuracy for very large values. * Aim for a linear time complexity in terms of the length of the input strings. By implementing this problem, you demonstrate the ability to work with high-precision arithmetic, an essential skill in various fields like cryptography, scientific computing, and financial applications.","solution":"def add_large_numbers(num1: str, num2: str) -> str: Adds two large numbers represented as strings and returns the sum as a string. # Initializing the result and carry result = [] carry = 0 # Initialize indices for both numbers, starting from the least significant digit i, j = len(num1) - 1, len(num2) - 1 # Loop through both numbers from the end to the beginning while i >= 0 or j >= 0 or carry: digit1 = int(num1[i]) if i >= 0 else 0 digit2 = int(num2[j]) if j >= 0 else 0 # Summing digits and carry total = digit1 + digit2 + carry # Result digit and carry carry = total // 10 result.append(str(total % 10)) # Move to the next digits i -= 1 j -= 1 # Since the digits are added from least significant to most significant, reverse the result return \'\'.join(result[::-1])"},{"question":"Problem Statement You are given an integer array. Your task is to organize the array such that all even integers come before all odd integers while maintaining the relative order of occurrence for both even and odd integers within the array. Implement an efficient algorithm to achieve this. # Function Signature ```python def segregate_even_odd(arr: list) -> list: pass ``` # Input * `arr`: A list of integers with length ranging from 1 to 10^5. # Output * (list): A list of integers with all even integers placed before all odd integers. # Constraints * The array can contain both positive and negative integers. * The relative order of even and odd integers should be maintained as in the original array. # Performance Requirements * Time Complexity should be O(n), where n is the length of the array. * Space Complexity should be O(n). # Examples 1. segregate_even_odd([1, 2, 3, 4, 5]) * Output: `[2, 4, 1, 3, 5]` 2. segregate_even_odd([12, 34, 45, 9, 8, 90]) * Output: `[12, 34, 8, 90, 45, 9]` 3. segregate_even_odd([5, 11, 20, 25, 30, 9]) * Output: `[20, 30, 5, 11, 25, 9]` # Instructions * Implement the function `segregate_even_odd` that meets the above requirements. * Write efficient and clean code. * Do not use any external libraries or functions not built into the language.","solution":"def segregate_even_odd(arr: list) -> list: Organizes the array such that all even integers come before all odd integers, while maintaining the relative order of occurrence for both even and odd integers. :param arr: A list of integers. :return: A list of integers with all even integers placed before all odd integers. even = [] odd = [] for num in arr: if num % 2 == 0: even.append(num) else: odd.append(num) return even + odd"},{"question":"# Problem Statement Your task is to implement a function that simulates a basic banking system for a single customer, which handles deposits, withdrawals, and balance inquiries based on a sequence of transactions provided. # Requirements 1. **Input:** A list of strings where each string represents a transaction. 2. **Output:** A list of final balance amounts after each transaction. # Transaction Types - **Deposit:** Represented as `\\"D <amount>\\"` where `<amount>` is a positive integer. - **Withdrawal:** Represented as `\\"W <amount>\\"` where `<amount>` is a positive integer. - **Balance Inquiry:** Represented as `\\"B\\"` which asks for the current balance. # Processing Rules - The balance starts at 0. - For each deposit, the specified amount is added to the balance. - For each withdrawal, the specified amount is subtracted from the balance. Assume that the balance can go negative. - For each balance inquiry, the current balance is recorded in the output list. # Function Signature ```python def process_transactions(transactions: List[str]) -> List[int]: Processes a list of banking transactions and returns the balance after each inquiry. Args: transactions (List[str]): A list of transaction strings. Each string is either a deposit, withdrawal or balance inquiry. Returns: List[int]: A list of balances after each balance inquiry. pass ``` # Usage Example ```python transactions = [\\"D 100\\", \\"W 50\\", \\"B\\", \\"D 20\\", \\"B\\", \\"W 70\\", \\"B\\"] print(process_transactions(transactions)) # Output: [50, 70, 0] ``` **Note:** The function should efficiently process each transaction and correctly update and record the balance wherever required.","solution":"from typing import List def process_transactions(transactions: List[str]) -> List[int]: Processes a list of banking transactions and returns the balance after each inquiry. Args: transactions (List[str]): A list of transaction strings. Each string is either a deposit, withdrawal, or balance inquiry. Returns: List[int]: A list of balances after each balance inquiry. balance = 0 balances_after_inquiries = [] for transaction in transactions: if transaction.startswith(\\"D\\"): amount = int(transaction.split(\\" \\")[1]) balance += amount elif transaction.startswith(\\"W\\"): amount = int(transaction.split(\\" \\")[1]) balance -= amount elif transaction == \\"B\\": balances_after_inquiries.append(balance) return balances_after_inquiries"},{"question":"# Question You are working on a text manipulation tool that processes strings representing product codes. The product codes follow a specific pattern: 1. They start with two uppercase letters. 2. Followed by three digits. 3. Ends with two lowercase letters. A valid product code should look like \\"AB123cd\\". Your task is to write a function `is_valid_product_code(product_code: str) -> bool:` that takes a string representing the product code and returns `True` if it is a valid product code, otherwise `False`. # Examples ```python >>> is_valid_product_code(\\"AB123cd\\") True >>> is_valid_product_code(\\"XY789ef\\") True >>> is_valid_product_code(\\"ab123CD\\") False >>> is_valid_product_code(\\"XY12ef\\") False >>> is_valid_product_code(\\"A123xy\\") False >>> is_valid_product_code(\\"AB12345cd\\") False >>> is_valid_product_code(\\"WX678GH\\") False ``` # Constraints 1. The product code string must be exactly 7 characters long. 2. The product code string must follow the specific pattern mentioned. # Notes: - Use regular expressions to perform the validation. - Consider edge cases such as incorrect lengths or characters that do not match the specified format.","solution":"import re def is_valid_product_code(product_code: str) -> bool: Checks if the given product code is valid. A valid product code must: 1. Start with two uppercase letters. 2. Followed by three digits. 3. End with two lowercase letters. Args: product_code (str): The product code to check. Returns: bool: True if the product code is valid, False otherwise. pattern = r\'^[A-Z]{2}[0-9]{3}[a-z]{2}\' return bool(re.match(pattern, product_code))"},{"question":"# Context You are designing an e-commerce website and need to implement a feature that calculates the optimal number of discount coupons to apply to an order to maximize the customer\'s savings. Each coupon can only be used once. The goal is to find the combination of coupons that will minimize the total price of the order. # Task Implement the function `apply_coupons` that takes in a list of coupons and an original price, and returns the minimum total price after applying the best combination of coupons. Function Signature ```python def apply_coupons(original_price: int, coupons: List[int]) -> int: pass ``` Input - `original_price` (int): the initial price of the order, 1 ≤ original_price ≤ 10^6 - `coupons` (List[int]): a list of integers representing the discount values of available coupons, 1 ≤ coupons[i] ≤ original_price, and 1 ≤ len(coupons) ≤ 100 Output - Returns the minimum total price after applying the optimal set of coupons, an integer. # Constraints - Each coupon can only be used once. - It is not mandatory to use all coupons. - Applying a coupon can reduce the order price to zero but not below zero. # Performance Requirements - The solution should be efficient enough to handle the given constraints, considering all subsets if necessary. # Example ```python # Example 1 print(apply_coupons(100, [10, 20, 30])) # Output: 40 # Example 2 print(apply_coupons(90, [15, 10, 45])) # Output: 20 ``` # Hints - Consider using a recursive approach with memoization to explore all possible subsets of coupons efficiently. - Dynamic programming can help in reducing redundant calculations by storing intermediate results.","solution":"from typing import List from itertools import combinations def apply_coupons(original_price: int, coupons: List[int]) -> int: Returns the minimum total price after applying the best combination of coupons. n = len(coupons) min_price = original_price # Generate all possible subsets of coupons for i in range(1, n + 1): for subset in combinations(coupons, i): discount = sum(subset) final_price = max(0, original_price - discount) min_price = min(min_price, final_price) return min_price"},{"question":"# Coding Assessment Question: Gear Ratio Calculator Context: In mechanical engineering, the gear ratio helps understand the relationship between the rotational speeds of two interconnected gears. The gear ratio is defined as the ratio of the number of teeth on the output gear to the number of teeth on the input gear, thus: [ text{Gear Ratio} = frac{text{Teeth of Output Gear}}{text{Teeth of Input Gear}} ] Task: Write a Python function `gear_ratio_calculator` that takes two integers: `teeth_input_gear` and `teeth_output_gear`, and returns the gear ratio as a floating-point number. Input: * Two positive integers `teeth_input_gear` and `teeth_output_gear` representing the number of teeth on the input and output gears, respectively. Output: * A floating-point number representing the gear ratio. Constraints: * Both `teeth_input_gear` and `teeth_output_gear` must be positive integers. Raise a `ValueError` if any value is zero or negative. Example: ```python >>> gear_ratio_calculator(25, 50) 2.0 >>> gear_ratio_calculator(40, 30) 0.75 >>> gear_ratio_calculator(100, -50) Traceback (most recent call last): ... ValueError: Number of teeth must be positive integers >>> gear_ratio_calculator(0, 20) Traceback (most recent call last): ... ValueError: Number of teeth must be positive integers ``` Requirements: 1. Ensure your function validates that both gear teeth counts are positive integers. 2. Include error handling to raise a `ValueError` on invalid input. 3. Optimize your code for readability and efficiency. Performance: * The function should run in constant time ( O(1) ). * Memory usage must be constant as well ( O(1) ).","solution":"def gear_ratio_calculator(teeth_input_gear, teeth_output_gear): Calculate the gear ratio between the input and output gears. :param teeth_input_gear: Number of teeth on the input gear (positive integer) :param teeth_output_gear: Number of teeth on the output gear (positive integer) :return: Gear ratio as a floating-point number :raises ValueError: If either teeth_input_gear or teeth_output_gear is non-positive if teeth_input_gear <= 0 or teeth_output_gear <= 0: raise ValueError(\\"Number of teeth must be positive integers\\") return teeth_output_gear / teeth_input_gear"},{"question":"# Single Source Shortest Path in Directed Graph Given a directed graph, write a function `single_source_shortest_path` to find the shortest paths from a given source node to all other nodes using Dijkstra\'s algorithm. # Guidelines 1. **Input**: The graph is provided as an adjacency list where each edge has a non-negative weight. The function should also take the source node as input. 2. **Output**: A dictionary where the keys are the nodes and the values are the shortest path distances from the source node. 3. **Constraints**: * Assume there are no negative weight cycles in the graph. * The graph can be sparse or dense, but it should fit in memory. # Details **Function Signature**: ```python def single_source_shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: ``` **Input Format**: - `graph`: A dictionary where keys are nodes and values are lists of tuples. Each tuple contains a neighbor node and the edge weight `(neighbor, weight)`. - `source`: An integer representing the source node. **Output Format**: - A dictionary where keys are nodes of the graph and values are the shortest path distances from the source node. # Example **Input**: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 ``` **Output**: ```python {0: 0, 1: 3, 2: 1, 3: 4} ``` **Explanation**: - Distance from `0` to `0` is `0`. - Shortest path from `0` to `1` is `0 -> 2 -> 1` with a distance of `3`. - Shortest path from `0` to `2` is `0 -> 2` with a distance of `1`. - Shortest path from `0` to `3` is `0 -> 1 -> 3` with a distance of `4`. # Notes - Ensure your solution scales efficiently for larger graphs. - Consider edge cases such as a graph with no edges, a graph with isolated nodes, and a source node having no outgoing edges. - Utilize a priority queue (min-heap) to optimize the time complexity for selecting the next node with the smallest tentative distance. ```python import heapq from typing import Dict, List, Tuple def single_source_shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: # Implement your solution here # Add test cases to validate your implementation ```","solution":"import heapq from typing import Dict, List, Tuple def single_source_shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: Find the shortest paths from a given source node to all other nodes in a directed graph using Dijkstra\'s algorithm. Parameters: graph (Dict[int, List[Tuple[int, int]]]): The graph represented as an adjacency list. source (int): The source node. Returns: Dict[int, int]: A dictionary where keys are nodes and values are the shortest path distances from the source node. # Priority queue to store (distance, node) pq = [(0, source)] # Dictionary to store the shortest distance from source to each node dist = {source: 0} while pq: current_distance, current_node = heapq.heappop(pq) # If a node\'s distance in the priority queue is not the current shortest distance, skip processing it. if current_distance > dist[current_node]: continue for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if neighbor not in dist or distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # Ensure that nodes not reachable from the source have their distances marked as infinity for node in graph: if node not in dist: dist[node] = float(\'inf\') return dist"},{"question":"# Problem Statement: You are given an array of integers and a target sum. Your task is to determine the total number of distinct pairs of integers within the array that add up to the target sum. Ensure that each pair is only counted once, and the pairs (a, b) and (b, a) are considered the same. # Function Signature: ```python def count_pairs_with_sum(arr: List[int], target: int) -> int: ``` # Input: * `arr` (a list of integers): e.g. [1, 2, 3, 4, 3] * `target` (an integer): e.g. 6 # Output: * Returns an integer representing the number of distinct pairs that add up to the target sum. # Constraints: * All integers in the array are in the range ([-10^6, 10^6]). * The length of the array will be in the range ([1, 10^5]). # Performance Requirements: * The solution should efficiently handle the array size up to (10^5), hence a time complexity better than (O(n^2)) is expected. # Example: ```python assert count_pairs_with_sum([1, 2, 3, 4, 3], 6) == 2 # The pairs are: (2, 4) and (3, 3) assert count_pairs_with_sum([1, 5, 7, -1, 5], 6) == 3 # The pairs are: (1, 5), (7, -1), and (1, 5) (note the second 5 does not form a new pair) ``` # Notes: 1. Focus on using an efficient algorithm that reduces time complexity. 2. You may use additional data structures like dictionaries or sets to store and lookup values efficiently. 3. Remember to handle edge cases, such as arrays with duplicate elements, zero, and negative numbers.","solution":"from typing import List def count_pairs_with_sum(arr: List[int], target: int) -> int: Returns the count of distinct pairs in the array that sum up to the target value. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return len(pairs)"},{"question":"# Question: Create a Dynamic Inventory Management System **Context**: Your task is to develop a dynamic inventory management system for tracking and updating the stock levels of various products in a store. This system needs to handle operations such as adding new products, updating stock levels, and processing sales transactions efficiently. **Objective**: Implement a class `InventoryManager` that manages a store\'s inventory. The class should provide methods to add new products, update the stock of existing products, and handle sales transactions. **Class Definition**: ```python class InventoryManager: def __init__(self): Initializes an empty inventory. pass def add_product(self, product_name: str, initial_stock: int) -> None: Adds a new product to the inventory with the given initial stock. Args: - product_name: A string representing the name of the product. - initial_stock: An integer representing the initial stock level of the product. Returns: - None Constraints: - The product_name is a non-empty string. - The initial_stock is a non-negative integer. pass def update_stock(self, product_name: str, additional_stock: int) -> None: Updates the stock level of an existing product by adding additional stock. Args: - product_name: A string representing the name of the product. - additional_stock: An integer representing the amount of stock to be added. Returns: - None Constraints: - The product_name is a non-empty string. - The additional_stock is a non-negative integer. - The product must already exist in the inventory. pass def process_sale(self, product_name: str, quantity_sold: int) -> bool: Processes a sale transaction, reducing the stock level of the sold product. Args: - product_name: A string representing the name of the product. - quantity_sold: An integer representing the quantity of the product sold. Returns: - A boolean value indicating whether the sale was processed successfully (True) or if there was insufficient stock (False). Constraints: - The product_name is a non-empty string. - The quantity_sold is a positive integer. - The product must already exist in the inventory. pass def get_stock_level(self, product_name: str) -> int: Retrieves the current stock level of a given product. Args: - product_name: A string representing the name of the product. Returns: - An integer representing the current stock level of the product. Constraints: - The product_name is a non-empty string. - The product must already exist in the inventory. pass ``` **Instructions**: 1. Implement the `InventoryManager` class with the specified methods. 2. Ensure the methods correctly handle the given constraints and edge cases. 3. Optimize operations for handling large inventories efficiently. **Example Usage**: ```python >>> inv = InventoryManager() >>> inv.add_product(\'apple\', 50) >>> inv.add_product(\'banana\', 80) >>> inv.update_stock(\'apple\', 20) >>> inv.process_sale(\'banana\', 30) True >>> inv.process_sale(\'apple\', 100) False >>> inv.get_stock_level(\'apple\') 70 >>> inv.get_stock_level(\'banana\') 50 ```","solution":"class InventoryManager: def __init__(self): Initializes an empty inventory. self.inventory = {} def add_product(self, product_name: str, initial_stock: int) -> None: Adds a new product to the inventory with the given initial stock. if product_name and initial_stock >= 0: self.inventory[product_name] = initial_stock def update_stock(self, product_name: str, additional_stock: int) -> None: Updates the stock level of an existing product by adding additional stock. if product_name in self.inventory and additional_stock >= 0: self.inventory[product_name] += additional_stock def process_sale(self, product_name: str, quantity_sold: int) -> bool: Processes a sale transaction, reducing the stock level of the sold product. if product_name in self.inventory and quantity_sold > 0: if self.inventory[product_name] >= quantity_sold: self.inventory[product_name] -= quantity_sold return True else: return False return False def get_stock_level(self, product_name: str) -> int: Retrieves the current stock level of a given product. if product_name in self.inventory: return self.inventory.get(product_name, 0) return 0"},{"question":"# Question: Array Manipulation with Advanced Sorting and Searching **Context:** Enhance your array manipulation skills by implementing a set of functions that involve sorting arrays in various ways, conducting binary searches, and finding the k-th smallest element in an unsorted array. These practical utilities will help to solidify your understanding of array operations and performance considerations. **Objective:** Implement the following functions, ensuring to handle edge cases, optimize performance, and consider input constraints carefully: 1. **Sorted Merge of Two Arrays**: Merge two sorted arrays into one sorted array without using additional space for the result. 2. **Binary Search**: Implement binary search to find an element in a sorted array. 3. **K-th Smallest Element**: Find the k-th smallest element in an unsorted array. **Function Signatures:** ```python def sorted_merge(arr1: List[int], arr2: List[int]) -> None: pass def binary_search(arr: List[int], x: int) -> int: pass def kth_smallest_element(arr: List[int], k: int) -> int: pass ``` **Expected Input and Output**: ```python array1 = [1, 3, 5, 7] array2 = [2, 4, 6, 8] sorted_merge(array1, array2) assert array1 == [1, 2, 3, 4, 5, 6, 7, 8] # Merged into array1 with the remaining elements in array2 assert binary_search([1, 2, 3, 4, 5], 4) == 3 assert binary_search([1, 2, 3, 4, 5], 6) == -1 assert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7 ``` **Constraints:** - The inputs for the functions will be lists of integers and positive integers k. - Performance should be optimal for arrays with size up to 10^5. **Detailed Requirements:** 1. **Sorted Merge of Two Arrays**: - **Input:** Two sorted arrays, arr1 and arr2. - **Output:** None. Modify arr1 so it contains merged elements sorted from both arrays. - Merge in-place without allocating additional space for the result. 2. **Binary Search**: - **Input:** A sorted array, arr, and an integer x. - **Output:** The index of x in arr if present, otherwise -1. - Implement binary search with an O(log n) complexity. 3. **K-th Smallest Element**: - **Input:** An unsorted array, arr, and an integer k. - **Output:** The k-th smallest element in the array. - Use an efficient algorithm that provides a good average-case performance, such as QuickSelect. **Edge Cases to Consider**: - Empty input arrays for all functions. - Minimal input values (e.g., k = 1). - Arrays with duplicate elements. - Arrays with all equal elements. This problem set will help you practice array manipulation, sorting, searching, and element selection techniques, improving your ability to handle common yet essential algorithms efficiently.","solution":"from typing import List def sorted_merge(arr1: List[int], arr2: List[int]) -> None: Merges arr2 into arr1 in-place assuming both are sorted. This approach assumes that arr1 has enough empty space at the end to hold all the elements of arr2. m = len(arr1) n = len(arr2) arr1 += [0] * n # Expanding arr1 to fit the elements of arr2 i, j, k = m - 1, n - 1, m + n - 1 while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[k] = arr1[i] i -= 1 else: arr1[k] = arr2[j] j -= 1 k -= 1 while j >= 0: arr1[k] = arr2[j] j -= 1 k -= 1 def binary_search(arr: List[int], x: int) -> int: Implements binary search algorithm to find an element in a sorted array. Returns the index of x if present, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == x: return mid elif arr[mid] < x: left = mid + 1 else: right = mid - 1 return -1 def kth_smallest_element(arr: List[int], k: int) -> int: Finds the k-th smallest element in an unsorted array. Uses the QuickSelect algorithm. def partition(arr, low, high): pivot = arr[high] i = low for j in range(low, high): if arr[j] <= pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def quickselect(arr, low, high, k): if low < high: pi = partition(arr, low, high) if pi == k: return arr[pi] elif pi < k: return quickselect(arr, pi + 1, high, k) else: return quickselect(arr, low, pi - 1, k) return arr[low] return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"Generating Combinations from a String Write a Python function that generates all possible combinations of a given string\'s characters. The combinations should be output in lexicographical order. Function Signature ```python def string_combinations(input_string: str) -> List[str]: ``` # Input * `input_string` (str): The input string from which to generate combinations. # Output * List[str]: A list containing all possible combinations of the input string\'s characters, sorted lexicographically. Each combination should be a string. # Constraints * The length of `input_string` will not exceed 15 characters. * The input string may contain duplicated characters. * The input string will only contain lowercase alphabetical characters (a-z). # Requirements * Ensure each combination is unique. * The combinations must be sorted lexicographically. * An empty string is considered a valid combination and should be included in the output. # Example Usage ```python assert string_combinations(\\"abc\\") == [\'\', \'a\', \'ab\', \'abc\', \'ac\', \'b\', \'bc\', \'c\'] assert string_combinations(\\"aab\\") == [\'\', \'a\', \'aa\', \'aab\', \'ab\', \'b\'] assert string_combinations(\\"xyz\\") == [\'\', \'x\', \'xy\', \'xyz\', \'xz\', \'y\', \'yz\', \'z\'] assert string_combinations(\\"a\\") == [\'\', \'a\'] ``` # Notes * Utilize libraries like `itertools` for generating combinations efficiently. * The combinations should include the empty string and single characters from the input as valid combinations. * Initial sorting of the input string might help in simplifying the generation of lexicographical combinations.","solution":"from itertools import combinations from typing import List def string_combinations(input_string: str) -> List[str]: Generate all possible unique combinations of the given string\'s characters in lexicographical order. sorted_str = sorted(input_string) comb_list = set() for r in range(len(sorted_str) + 1): for comb in combinations(sorted_str, r): comb_list.add(\'\'.join(comb)) return sorted(comb_list)"},{"question":"# Coding Question: Given a linked list, implement the following two functions for the `ListNode` class provided: 1. **Function to detect a cycle in the linked list**: Implement a method `has_cycle` which returns a boolean indicating whether the linked list contains a cycle. Use Floyd\'s Tortoise and Hare algorithm to detect the cycle. ```python class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(self) -> bool: Determine if the linked list has a cycle. Returns: True if there is a cycle, False otherwise. >>> n1 = ListNode(3) >>> n2 = ListNode(2) >>> n3 = ListNode(0) >>> n4 = ListNode(-4) >>> n1.next = n2 >>> n2.next = n3 >>> n3.next = n4 >>> n4.next = n2 # Cycle here >>> n1.has_cycle() True >>> n1 = ListNode(1) >>> n2 = ListNode(2) >>> n1.next = n2 >>> n2.next = n1 # Cycle here >>> n1.has_cycle() True >>> n1 = ListNode(1) >>> n1.has_cycle() False # Your implementation here ``` 2. **Function to reverse the linked list**: Implement a method `reverse` which returns the head of the linked list after reversing the list. ```python class ListNode: def __init__(self, x): self.val = x self.next = None def reverse(self) -> \'ListNode\': Reverse the linked list. Returns: The head of the reversed linked list. >>> n1 = ListNode(1) >>> n2 = ListNode(2) >>> n3 = ListNode(3) >>> n1.next = n2 >>> n2.next = n3 >>> new_head = n1.reverse() >>> new_head.val 3 >>> new_head.next.val 2 >>> new_head.next.next.val 1 >>> new_head.next.next.next is None True >>> n1 = ListNode(1) >>> new_head = n1.reverse() >>> new_head.val 1 >>> new_head.next is None True # Your implementation here ``` # Constraints: * The linked list node values are integers. * The maximum length of the linked list is not greater than 10000. # Examples: ```python # Example 1 n1 = ListNode(1) n2 = ListNode(2) n3 = ListNode(3) n1.next = n2 n2.next = n3 print(n1.reverse().val) # Output: 3 # Example 2 n1 = ListNode(1) n2 = ListNode(2) n3 = ListNode(3) n4 = ListNode(4) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n2 # Cycle here print(n1.has_cycle()) # Output: True # Example 3 n1 = ListNode(1) print(n1.has_cycle()) # Output: False # Examples (edge case) n1 = ListNode(1) n2 = ListNode(2) n1.next = n2 print(n1.reverse().val) # Output: 2 print(n1.has_cycle()) # Output: False ``` # Additional Notes: * Ensure the methods correctly handle lists with only one node and handle cycles properly. * The algorithm for cycle detection should run in O(n) time complexity and constant space complexity. * The reverse method should also run in O(n) time complexity and constant space complexity.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(self) -> bool: Determine if the linked list has a cycle. slow = self fast = self while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False def reverse(self) -> \'ListNode\': Reverse the linked list. prev = None current = self while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Context You are building an application to help users organize their bookmarks. Each bookmark has a name, a URL, and a date when it was added. You need to implement a system that will allow users to manage their bookmarks, specifically: 1. Add new bookmarks. 2. Retrieve all bookmarks, sorted by the date they were added (most recent first). 3. Search for a bookmark by its name. # Task Implement a class `BookmarkManager` to manage bookmarks with the following methods: ```python class BookmarkManager: def __init__(self): pass def add_bookmark(self, name: str, url: str, date_added: str) -> None: pass def get_all_bookmarks(self) -> list: pass def search_bookmark(self, name: str) -> dict: pass ``` # Requirements 1. The `add_bookmark` method should add a new bookmark with a name, URL, and date. 2. The `get_all_bookmarks` method should retrieve a list of all bookmarks, sorted by the date they were added in descending order (most recent first). Each bookmark should be represented as a dictionary with keys \\"name\\", \\"url\\", and \\"date_added\\". 3. The `search_bookmark` method should return a dictionary representing the bookmark with the given name. If no such bookmark exists, return an empty dictionary. # Constraints * Each name will be unique and not exceed 100 characters. * URLs are valid strings not exceeding 200 characters. * Dates are in ISO 8601 format (YYYY-MM-DD). * The maximum number of bookmarks is 10^5. # Example ```python manager = BookmarkManager() manager.add_bookmark(\\"First Bookmark\\", \\"http://example.com\\", \\"2023-10-01\\") manager.add_bookmark(\\"Second Bookmark\\", \\"http://example.org\\", \\"2023-10-02\\") manager.add_bookmark(\\"Third Bookmark\\", \\"http://example.net\\", \\"2023-09-30\\") print(manager.get_all_bookmarks()) # Output: # [ # {\\"name\\": \\"Second Bookmark\\", \\"url\\": \\"http://example.org\\", \\"date_added\\": \\"2023-10-02\\"}, # {\\"name\\": \\"First Bookmark\\", \\"url\\": \\"http://example.com\\", \\"date_added\\": \\"2023-10-01\\"}, # {\\"name\\": \\"Third Bookmark\\", \\"url\\": \\"http://example.net\\", \\"date_added\\": \\"2023-09-30\\"} # ] print(manager.search_bookmark(\\"First Bookmark\\")) # Output: # {\\"name\\": \\"First Bookmark\\", \\"url\\": \\"http://example.com\\", \\"date_added\\": \\"2023-10-01\\"} print(manager.search_bookmark(\\"Nonexistent Bookmark\\")) # Output: # {} ``` Submission Submit a class `BookmarkManager` implemented in Python, with methods to handle bookmark management tasks as described.","solution":"class BookmarkManager: def __init__(self): self.bookmarks = [] def add_bookmark(self, name: str, url: str, date_added: str) -> None: self.bookmarks.append({\\"name\\": name, \\"url\\": url, \\"date_added\\": date_added}) def get_all_bookmarks(self) -> list: return sorted(self.bookmarks, key=lambda b: b[\\"date_added\\"], reverse=True) def search_bookmark(self, name: str) -> dict: for bookmark in self.bookmarks: if bookmark[\\"name\\"] == name: return bookmark return {}"},{"question":"# Problem Statement You are developing a string manipulation library, and one of the requirements is to create a function that generates all possible permutations of a given string. Considering the potentially large number of permutations and to avoid excessive memory usage, the function should yield permutations one by one. # Requirements Implement a generator function `string_permutations` that generates all possible permutations of the input string. Function Signature: ```python def string_permutations(s: str) -> Generator[str, None, None]: pass ``` Input: * `s` (str): A string of unique characters. Output: * A generator that yields permutations of string `s`, one per iteration. # Constraints: * The input string will have at most 10 characters to prevent excessive computation time and memory usage. * The characters in the input string are unique. # Examples: ```python >>> list(string_permutations(\\"abc\\")) [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> list(string_permutations(\\"ab\\")) [\'ab\', \'ba\'] ``` # Hints: 1. Utilize Python\'s built-in libraries like `itertools` to simplify the permutation generation. 2. Consider how generators can help manage memory by providing one result at a time.","solution":"from typing import Generator import itertools def string_permutations(s: str) -> Generator[str, None, None]: Generates all possible permutations of the input string. Args: - s (str): Input string of unique characters. Yields: - Permutations of the input string, one at a time. for perm in itertools.permutations(s): yield \'\'.join(perm)"},{"question":"# Question: Implement a Stack with Minimum Value Retrieval Context: A common problem in data structures is to implement a stack that supports retrieving the minimum value in constant time. You should create a stack that not only allows standard operations like push and pop but also supports retrieving the minimum element efficiently. # Task: Implement a class `MinStack` that supports the following operations: 1. **Push to stack**: Method `push(data)`. 2. **Pop from stack**: Method `pop()`. 3. **Get the top element**: Method `top()`. 4. **Retrieve the minimum element**: Method `get_min()`. # Requirements: 1. **Input/Output**: - Methods should operate on instances of `MinStack` and modify or retrieve information from the stack as specified. - Each of the operations should work in constant time, O(1). 2. **Constraints**: - Ensure that the class handles edge cases, such as operations on an empty stack. - Use an auxiliary stack or other suitable data structures to maintain the minimum value efficiently. 3. **Design**: - You should only use basic stack operations to implement this class. # Example: ```python # Creating MinStack instance min_stack = MinStack() # Pushing elements to stack min_stack.push(2) min_stack.push(0) min_stack.push(3) min_stack.push(0) print(min_stack.get_min()) # Expected: 0 # Pop elements and get min value min_stack.pop() print(min_stack.get_min()) # Expected: 0 min_stack.pop() print(min_stack.get_min()) # Expected: 0 min_stack.pop() print(min_stack.get_min()) # Expected: 2 # Get the top element print(min_stack.top()) # Expected: 2 # Push a new element and check min value min_stack.push(1) print(min_stack.get_min()) # Expected: 1 ``` # Implementation Skeleton: ```python class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, data): Pushes the data onto the stack. If the min_stack is empty or the data is less than or equal to the current minimum, also push it onto the min_stack. self.stack.append(data) if not self.min_stack or data <= self.min_stack[-1]: self.min_stack.append(data) def pop(self): Pops the top element from the stack. If the popped element is equal to the current minimum, also pop it from the min_stack. if not self.stack: raise IndexError(\\"Pop from an empty stack\\") popped = self.stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() return popped def top(self): Retrieves the top element from the stack without removing it. if not self.stack: raise IndexError(\\"Top from an empty stack\\") return self.stack[-1] def get_min(self): Retrieves the minimum element from the stack without removing it. if not self.min_stack: raise IndexError(\\"Get min from an empty stack\\") return self.min_stack[-1] ``` Ensure you test your implementation with the provided example and consider additional edge cases. The solution should be efficient in terms of both time and space complexity.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, data): Pushes the data onto the stack. If the min_stack is empty or the data is less than or equal to the current minimum, also push it onto the min_stack. self.stack.append(data) if not self.min_stack or data <= self.min_stack[-1]: self.min_stack.append(data) def pop(self): Pops the top element from the stack. If the popped element is equal to the current minimum, also pop it from the min_stack. if not self.stack: raise IndexError(\\"Pop from an empty stack\\") popped = self.stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() return popped def top(self): Retrieves the top element from the stack without removing it. if not self.stack: raise IndexError(\\"Top from an empty stack\\") return self.stack[-1] def get_min(self): Retrieves the minimum element from the stack without removing it. if not self.min_stack: raise IndexError(\\"Get min from an empty stack\\") return self.min_stack[-1]"},{"question":"# Celebrity Identification Challenge You are tasked to implement a system to identify the celebrity at a party. A celebrity is a person who is known by everyone but knows no one. Your task is to identify this celebrity, if they exist, using efficient algorithms. 1. Helper Function First, implement a helper function to determine if one person knows another: ```python def knows(a: int, b: int, matrix: List[List[int]]) -> bool: Parameters: a (int): An integer representing a person. b (int): An integer representing another person. matrix (List[List[int]]): A 2D list where matrix[i][j] is 1 if person i knows person j, else 0. Returns: bool: True if person \'a\' knows person \'b\', otherwise False. return matrix[a][b] == 1 ``` 2. Celebrity Identification Function Next, implement the function to find the celebrity: ```python def find_celebrity(n:int, matrix:List[List[int]]) -> int: Parameters: n (int): The number of people at the party. matrix (List[List[int]]): A 2D list where matrix[i][j] is 1 if person i knows person j, else 0. Returns: int: The index of the celebrity, if present. Otherwise, return -1. celebrity_candidate = 0 # First pass to find the candidate celebrity for i in range(1, n): if knows(celebrity_candidate, i, matrix): celebrity_candidate = i # Second pass to confirm the candidate is indeed a celebrity for i in range(n): if i != celebrity_candidate: if knows(celebrity_candidate, i, matrix) or not knows(i, celebrity_candidate, matrix): return -1 return celebrity_candidate ``` # Constraints * `n` should be a positive integer, representing the number of people. * The matrix should be a `n x n` binary matrix with `matrix[i][j]` being `1` if person `i` knows person `j` and `0` otherwise. # Example ```python n = 4 matrix = [ [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0] ] # Person 3 is the celebrity find_celebrity(n, matrix) # This should return 3 ``` # Additional Rules 1. Ensure that your solution has a time complexity of O(n). 2. Your solution should handle edge cases where no celebrity is present. 3. Use only Python\'s standard library for your solution. **Good luck with your implementation! Ensure your code is clean, well-commented, and tested for various edge cases.**","solution":"from typing import List def knows(a: int, b: int, matrix: List[List[int]]) -> bool: Parameters: a (int): An integer representing a person. b (int): An integer representing another person. matrix (List[List[int]]): A 2D list where matrix[i][j] is 1 if person i knows person j, else 0. Returns: bool: True if person \'a\' knows person \'b\', otherwise False. return matrix[a][b] == 1 def find_celebrity(n: int, matrix: List[List[int]]) -> int: Parameters: n (int): The number of people at the party. matrix (List[List[int]]): A 2D list where matrix[i][j] is 1 if person i knows person j, else 0. Returns: int: The index of the celebrity, if present. Otherwise, return -1. celebrity_candidate = 0 # First pass to find the candidate celebrity for i in range(1, n): if knows(celebrity_candidate, i, matrix): celebrity_candidate = i # Second pass to confirm the candidate is indeed a celebrity for i in range(n): if i != celebrity_candidate: if knows(celebrity_candidate, i, matrix) or not knows(i, celebrity_candidate, matrix): return -1 return celebrity_candidate"},{"question":"# Coding Assessment Question You have been hired as a software developer for a travel booking company. Your task is to enhance the company\'s system to fetch and display real-time flight information. The company wants to switch from their current flight information provider to a new one, ensuring a seamless transition with added functionality. Your tasks are: 1. **Implement a function to fetch and display flight details from an alternative API.** - The flight details should include: airline name, flight number, departure airport, arrival airport, departure time, and arrival time. - Use the same format as the given current API data. - This time, fetch data from an alternative API endpoint, such as \\"https://alternative-api.com/flights\\". 2. **Enhance error handling:** - Implement a robust error handling mechanism to manage scenarios such as network failures, API errors, and unexpected data formats. - Ensure that your implementation logs appropriate error messages and retries failed requests up to a specified limit. 3. **Extend the features:** - Modify the `display_flights` function to include additional data - flight status (on time, delayed, cancelled). - Ensure the table displays this additional data and handles cases where this information might not be available. 4. **Optimize time calculations:** - Improve the `calculate_duration` function to accurately compute and display the flight duration. - Handle edge cases such as flights crossing different timezones, overnight flights, and leap years. **Input:** - An integer representing the retry limit for failed network requests. **Output:** - A formatted table displaying the next 5 flights from the alternative API, including airline name, flight number, departure airport, arrival airport, departure time, arrival time, flight status, and flight duration. **Constraints:** - The alternative API endpoint must return data in a JSON format containing the flight details. - Departure and arrival times will be provided in a standard timestamp format. - Ensure you handle up to 3 retries for failed network requests. **Scenario Context:** Imagine a travel booking company that needs to switch from their current flight information provider to a new one without interrupting the ongoing service to their users. The platform must continue to display accurate and up-to-date information about upcoming flights.","solution":"import requests import datetime import logging logging.basicConfig(level=logging.INFO) def get_flight_details(retry_limit=3): url = \\"https://alternative-api.com/flights\\" retries = 0 while retries < retry_limit: try: response = requests.get(url) response.raise_for_status() return response.json() except requests.exceptions.RequestException as e: retries += 1 logging.error(f\\"Request failed: {str(e)}. Retrying {retries}/{retry_limit}...\\") logging.error(\\"All retry attempts failed.\\") return None def calculate_duration(departure_time, arrival_time): dep_time = datetime.datetime.fromisoformat(departure_time) arr_time = datetime.datetime.fromisoformat(arrival_time) duration = arr_time - dep_time if duration.days < 0: duration = datetime.timedelta(days=0, seconds=duration.seconds, microseconds=duration.microseconds) hours, remainder = divmod(duration.total_seconds(), 3600) minutes, seconds = divmod(remainder, 60) return f\\"{int(hours):02}:{int(minutes):02}\\" def display_flights(flights): table_header = f\\"{\'Airline\':>10} {\'Flight Number\':>15} {\'Departure\':>10} {\'Arrival\':>10} {\'Dep. Time\':>20} {\'Arr. Time\':>20} {\'Status\':>10} {\'Duration\':>10}\\" print(table_header) print(\'-\' * len(table_header)) for flight in flights: airline = flight.get(\'airline\', \'N/A\') flight_number = flight.get(\'flight_number\', \'N/A\') departure_airport = flight.get(\'departure_airport\', \'N/A\') arrival_airport = flight.get(\'arrival_airport\', \'N/A\') departure_time = flight.get(\'departure_time\', \'N/A\') arrival_time = flight.get(\'arrival_time\', \'N/A\') status = flight.get(\'status\', \'N/A\') if departure_time != \'N/A\' and arrival_time != \'N/A\': duration = calculate_duration(departure_time, arrival_time) else: duration = \'N/A\' flight_info = f\\"{airline:>10} {flight_number:>15} {departure_airport:>10} {arrival_airport:>10} {departure_time:>20} {arrival_time:>20} {status:>10} {duration:>10}\\" print(flight_info) def main(retry_limit): flights_data = get_flight_details(retry_limit) if flights_data and \\"flights\\" in flights_data: display_flights(flights_data[\\"flights\\"][:5]) else: logging.error(\\"Failed to retrieve or parse flight data.\\") if __name__ == \\"__main__\\": main(retry_limit=3)"},{"question":"# Array Rotation and Index Management You are tasked with creating a feature for a data visualization tool that requires rotating a list of integers to the right by a specified number of places. This feature should also provide the initial indices of the elements in the rotated list from the original list. Implement the following functions: 1. **rotate_array(array: list[int], k: int) -> list[int]** This function takes in a list of integers and rotates it to the right by `k` positions. The rotation should be performed in-place, without using extra space for storing additional data. 2. **index_mapping(original: list[int], rotated: list[int]) -> list[int]** This function takes the original array and the rotated array and returns a list that maps each element in the rotated array to its original index in the input list. # Input 1. `rotate_array`: - `array`: A list of integers to rotate. - `k`: The number of positions to rotate the array to the right. 2. `index_mapping`: - `original`: The original list of integers before rotation. - `rotated`: The rotated list of integers after applying the `rotate_array` function. # Output 1. `rotate_array`: The rotated list of integers. 2. `index_mapping`: A list representing the original indices of the elements in the rotated array. # Example Usage ```python original = [1, 2, 3, 4, 5] rotated = rotate_array(original, 2) print(rotated) # Output: [4, 5, 1, 2, 3] index_map = index_mapping([1, 2, 3, 4, 5], rotated) print(index_map) # Output: [3, 4, 0, 1, 2] ``` # Debugging Constraints 1. Ensure the correct handling of edge cases, such as when `k` is zero, the array length is zero, or `k` is greater than the length of the array. 2. Validate that no extra space is used for the `rotate_array` function. 3. Confirm the correctness of the index mappings in the `index_mapping` function. # Additional Details - The rotation should be performed efficiently, ensuring optimal time complexity. - Consider potential integer overflow issues with large values of `k`. - Ensure your functions handle various input ranges and edge cases appropriately.","solution":"def rotate_array(array, k): Rotates the array to the right by k positions. n = len(array) if n == 0: return array k = k % n # To handle the case when k > n array[:] = array[-k:] + array[:-k] # Perform in-place rotation return array def index_mapping(original, rotated): Returns a list mapping each element in the rotated array to its original index in the input list. index_map = [] for elem in rotated: index_map.append(original.index(elem)) return index_map"},{"question":"# Question You have been asked to expand the functionality of a basic command-line to-do list application. Implement a class `ToDoList` that supports the following features: 1. **Add a Task**: Add a new task with a description and optional due date. 2. **Remove a Task**: Remove a task by its identifier. 3. **List Tasks**: List all tasks, optionally filtering by due date or completion status. 4. **Mark Task as Completed**: Mark a specific task as completed. 5. **Persist Data**: Save and load tasks from a JSON file to ensure the data persists between program runs. Class Signature ```python import json from datetime import datetime from typing import Optional, List, Dict class ToDoList: def __init__(self, file_path: str): pass def add_task(self, description: str, due_date: Optional[str] = None) -> None: pass def remove_task(self, task_id: int) -> None: pass def list_tasks(self, filter_due_date: Optional[str] = None, filter_completed: Optional[bool] = None) -> List[Dict]: pass def mark_task_completed(self, task_id: int) -> None: pass def save_tasks(self) -> None: pass def load_tasks(self) -> None: pass ``` Input and Output Formats * **Inputs**: * `description`: The text description of the task. * `due_date`: The optional due date for the task in the format \\"YYYY-MM-DD\\". * `task_id`: The unique identifier of the task. * `filter_due_date`: An optional due date filter in the format \\"YYYY-MM-DD\\". * `filter_completed`: An optional filter to list only completed or not completed tasks. * `file_path`: Path to the JSON file used for persisting tasks. * **Output**: * Various methods return different results: * `list_tasks`: Returns a list of dictionaries, each representing a task. Constraints * All dates should be valid and follow the \\"YYYY-MM-DD\\" format. * Each task must have a unique identifier. * The JSON file should properly handle the persistence of task data. Scenario Imagine you are enhancing a simple to-do list application used by a team to manage their daily activities. The application needs to support multiple functionalities to assist with task management and ensure data persistence across sessions. Example ```python # Initialize the to-do list with a specified file path for storing tasks todo = ToDoList(\'tasks.json\') # Add tasks todo.add_task(\\"Complete coding assessment\\", \\"2023-11-01\\") todo.add_task(\\"Review pull requests\\") # List tasks >>> todo.list_tasks() [ {\'id\': 1, \'description\': \'Complete coding assessment\', \'due_date\': \'2023-11-01\', \'completed\': False}, {\'id\': 2, \'description\': \'Review pull requests\', \'due_date\': None, \'completed\': False} ] # Mark a task as completed todo.mark_task_completed(1) # List completed tasks >>> todo.list_tasks(filter_completed=True) [ {\'id\': 1, \'description\': \'Complete coding assessment\', \'due_date\': \'2023-11-01\', \'completed\': True} ] # Save tasks to the file todo.save_tasks() # Load tasks from the file todo.load_tasks() ```","solution":"import json from datetime import datetime from typing import Optional, List, Dict class ToDoList: def __init__(self, file_path: str): self.file_path = file_path self.tasks = [] self.load_tasks() def add_task(self, description: str, due_date: Optional[str] = None) -> None: new_task = { \'id\': len(self.tasks) + 1, \'description\': description, \'due_date\': due_date, \'completed\': False } self.tasks.append(new_task) self.save_tasks() def remove_task(self, task_id: int) -> None: self.tasks = [task for task in self.tasks if task[\'id\'] != task_id] self.save_tasks() def list_tasks(self, filter_due_date: Optional[str] = None, filter_completed: Optional[bool] = None) -> List[Dict]: filtered_tasks = self.tasks if filter_due_date: filtered_tasks = [task for task in filtered_tasks if task[\'due_date\'] == filter_due_date] if filter_completed is not None: filtered_tasks = [task for task in filtered_tasks if task[\'completed\'] == filter_completed] return filtered_tasks def mark_task_completed(self, task_id: int) -> None: for task in self.tasks: if task[\'id\'] == task_id: task[\'completed\'] = True self.save_tasks() def save_tasks(self) -> None: with open(self.file_path, \'w\') as file: json.dump(self.tasks, file) def load_tasks(self) -> None: try: with open(self.file_path, \'r\') as file: self.tasks = json.load(file) except FileNotFoundError: self.tasks = []"},{"question":"# Question Objective Your task is to implement a function that takes a grayscale image represented as a 2D numpy array and applies a threshold transformation to convert it into a binary image. Scenario In image processing, converting a grayscale image to a binary image is a common preprocessing step, where the image consists only of pixels that are either black or white. Given a grayscale image (2D numpy array) and a threshold value, transform the grayscale image into a binary image: - Pixels with values greater than or equal to the threshold are set to 1 (white), - Pixels with values less than the threshold are set to 0 (black). Function Signature ```python def threshold_image(image: np.ndarray, threshold: float) -> np.ndarray: ``` # Input - `image`: A 2D numpy array where each element is a grayscale pixel value ranging from 0 to 255. - `threshold`: A float value used for pixel intensity comparison. # Output - Return a new 2D numpy array where each element is either `0` or `1`, resulting from the threshold operation. # Constraints - The input image can have up to (10^6) pixels. # Examples ```python >>> image = np.array([ ... [120, 200, 50], ... [250, 30, 180], ... [110, 255, 90] ... ]) >>> threshold = 100 >>> threshold_image(image, threshold) array([ [ 1, 1, 0], [ 1, 0, 1], [ 1, 1, 0] ]) ``` # Detailed Breakdown 1. **Image Input**: Evaluate each pixel in the 2D array. 2. **Binary Transformation**: - Set the pixel to `1` if its value is greater than or equal to the threshold. - Set the pixel to `0` if its value is less than the threshold. Implement the function considering efficient processing of potentially large images as per the given constraints.","solution":"import numpy as np def threshold_image(image: np.ndarray, threshold: float) -> np.ndarray: Applies a threshold to a grayscale image to convert it into a binary image. Parameters: - image: 2D numpy array where each element is a grayscale pixel value (0-255). - threshold: float value representing the threshold for binarization. Returns: - 2D numpy array where each element is either 0 or 1. binary_image = (image >= threshold).astype(np.int_) return binary_image"},{"question":"# Python Data Structure Challenge **Context**: You\'ve been hired to develop a simple scheduling algorithm for a company\'s meeting rooms. The company has multiple meeting rooms, and meetings can have different start and end times. The goal is to check if a new meeting can be scheduled without overlapping with any existing meetings in all the rooms. Function Signature: ```python def can_schedule_meeting(existing_meetings: List[List[int]], new_meeting: List[int]) -> bool: ``` Parameters: - `existing_meetings`: a list of lists where each sublist represents a meeting as `[start_time, end_time]`. `start_time` and `end_time` are integers representing the time in hours (0-24). - `new_meeting`: a list `[start_time, end_time]` representing the time interval for the new meeting. Output: - Return `True` if the new meeting can be scheduled without conflicts, `False` otherwise. Constraints: * Meetings are non-overlapping within each list of existing meetings. * The meeting times are within a 24-hour period (0 <= start_time < end_time <= 24). * Efficiently handle up to 10,000 existing meetings. Instructions: 1. Implement a function to check if the `new_meeting` overlaps with any meetings in the `existing_meetings`. 2. If no overlap is found with any existing meeting, return `True`. 3. If there is any overlap, return `False`. Example: ```python existing_meetings = [ [9, 10], [11, 12], [13, 15] ] new_meeting = [10, 11] result = can_schedule_meeting(existing_meetings, new_meeting) print(result) ``` Expected Output: ``` True ``` Note: This problem is designed to test your understanding of data structures, specifically lists and how to implement algorithms to detect overlapping intervals efficiently.","solution":"def can_schedule_meeting(existing_meetings, new_meeting): Check if the new meeting can be scheduled without overlapping any of the existing meetings. Args: existing_meetings: List[List[int]] -- A list of existing meetings with [start_time, end_time] new_meeting: List[int] -- A new meeting with [start_time, end_time] Returns: bool -- True if the new meeting can be scheduled without conflict, False otherwise. new_start, new_end = new_meeting for meeting in existing_meetings: start, end = meeting # Check if there is any overlap if not (new_end <= start or new_start >= end): return False return True"},{"question":"# Problem Description Write a function that simulates a ticket reservation system for a concert. Each ticket is uniquely numbered from 1 to n, where n is the total number of tickets available. Your task is to implement the functionality to reserve tickets for customers, ensuring no double booking occurs. # Requirements 1. Implement a class `TicketSystem` with the following methods: - `__init__(self, n)`: Initializes the system with `n` tickets available for reservation. - `reserve_tickets(self, customer_id, ticket_count)`: Reserves the specified number of tickets for the customer. - `release_tickets(self, customer_id)`: Releases any tickets currently reserved under the given customer ID. - `get_reserved_tickets(self, customer_id)`: Returns a list of ticket numbers reserved by the customer. If the customer has no reservations, return an empty list. # Input and Output * **Input**: * An integer `n` in the `__init__` method representing the total number of tickets. * The methods `reserve_tickets` and `release_tickets` accept a string `customer_id`. * The method `reserve_tickets` also accepts an integer `ticket_count` representing the number of tickets to reserve. * **Output**: * For `reserve_tickets`: None. Reserve the tickets or raise an error if tickets cannot be reserved. * For `release_tickets`: None. Release the tickets reserved by the customer. * For `get_reserved_tickets`: List of integers representing the ticket numbers reserved by the customer. If no tickets are reserved, return an empty list. # Constraints * The system will handle up to 10,000 tickets. * The input `ticket_count` is always a positive integer. * The `reserve_tickets` method should raise a `ValueError` if there are not enough tickets available to satisfy the reservation request. * Each customer can reserve tickets multiple times, but no customer can hold more than the initially available tickets. # Example Scenarios 1. **Example 1**: * `TicketSystem(5)` * `reserve_tickets(\\"Alice\\", 3)` * `get_reserved_tickets(\\"Alice\\")` -> [1, 2, 3] 2. **Example 2**: * `TicketSystem(5)` * `reserve_tickets(\\"Bob\\", 2)` * `release_tickets(\\"Bob\\")` * `get_reserved_tickets(\\"Bob\\")` -> [] 3. **Example 3**: * `TicketSystem(3)` * `reserve_tickets(\\"Charlie\\", 2)` * `reserve_tickets(\\"Diana\\", 2)` -> Raises `ValueError`: Not enough tickets available # Implementation Template ```python class TicketSystem: def __init__(self, n): Initializes the ticket system with n tickets. :param n: Integer representing the total number of tickets. self.total_tickets = n self.available_tickets = list(range(1, n+1)) self.reservations = {} def reserve_tickets(self, customer_id, ticket_count): Reserves the specified number of tickets for the customer. :param customer_id: String representing the customer ID. :param ticket_count: Integer representing the number of tickets to reserve. if ticket_count > len(self.available_tickets): raise ValueError(\\"Not enough tickets available\\") reserved_tickets = self.available_tickets[:ticket_count] self.available_tickets = self.available_tickets[ticket_count:] if customer_id in self.reservations: self.reservations[customer_id].extend(reserved_tickets) else: self.reservations[customer_id] = reserved_tickets def release_tickets(self, customer_id): Releases any tickets currently reserved under the given customer ID. :param customer_id: String representing the customer ID. if customer_id in self.reservations: released_tickets = self.reservations.pop(customer_id) self.available_tickets.extend(released_tickets) self.available_tickets.sort() def get_reserved_tickets(self, customer_id): Returns a list of ticket numbers reserved by the customer. :param customer_id: String representing the customer ID. :return: List of integers representing the reserved ticket numbers. return self.reservations.get(customer_id, []) ``` Implement the methods `reserve_tickets`, `release_tickets`, and `get_reserved_tickets` to meet the requirements specified. Ensure your `TicketSystem` class maintains the consistency and integrity of the ticket reservation process.","solution":"class TicketSystem: def __init__(self, n): Initializes the ticket system with n tickets. :param n: Integer representing the total number of tickets. self.total_tickets = n self.available_tickets = list(range(1, n + 1)) self.reservations = {} def reserve_tickets(self, customer_id, ticket_count): Reserves the specified number of tickets for the customer. :param customer_id: String representing the customer ID. :param ticket_count: Integer representing the number of tickets to reserve. if ticket_count > len(self.available_tickets): raise ValueError(\\"Not enough tickets available\\") reserved_tickets = self.available_tickets[:ticket_count] self.available_tickets = self.available_tickets[ticket_count:] if customer_id in self.reservations: self.reservations[customer_id].extend(reserved_tickets) else: self.reservations[customer_id] = reserved_tickets def release_tickets(self, customer_id): Releases any tickets currently reserved under the given customer ID. :param customer_id: String representing the customer ID. if customer_id in self.reservations: released_tickets = self.reservations.pop(customer_id) self.available_tickets.extend(released_tickets) self.available_tickets.sort() def get_reserved_tickets(self, customer_id): Returns a list of ticket numbers reserved by the customer. :param customer_id: String representing the customer ID. :return: List of integers representing the reserved ticket numbers. return self.reservations.get(customer_id, [])"},{"question":"# Data Conversion and Validation **Description**: You are asked to create a function that converts a given list of mixed type values to a specified data type and provides proper validation and error handling. Your function should be able to handle integer and floating-point conversions. **Objective**: Create a function `convert_data(data: List[str], data_type: str) -> List[Union[int, float, str]]` that: 1. Accepts a list of strings and a target data type - either \\"int\\" or \\"float\\". 2. Attempts to convert each string to the specified data type. 3. If a conversion is successful, the converted value should be included in the output list. 4. If a conversion fails, the original string should be included in the output list, preceded by an error message - for example, \\"Error: cannot convert \'abc\' to int\\". **Input**: * A list of values in string format (e.g., `[\\"123\\", \\"45.67\\", \\"abc\\", \\"3.14xyz\\"]`). * A target data type as a string – \\"int\\" or \\"float\\". **Output**: * A list where each value is converted to the target type if possible, or an error message followed by the original string if the conversion fails (e.g., `[123, \\"Error: cannot convert \'abc\' to int\\", 45]`). **Constraints**: * The input list will contain at most 100 elements. * The target data type will be either \\"int\\" or \\"float\\". * The input list will only contain string elements. **Performance Requirements**: * Ensure the solution handles different conversion scenarios efficiently. * Include necessary exception handling for invalid conversions. # Implementation Complete the function `convert_data(data: List[str], data_type: str) -> List[Union[int, float, str]]`: ```python from typing import List, Union def convert_data(data: List[str], data_type: str) -> List[Union[int, float, str]]: def convert(value: str, target_type: str) -> Union[int, float, str]: try: if target_type == \\"int\\": return int(value) elif target_type == \\"float\\": return float(value) except ValueError: return f\\"Error: cannot convert \'{value}\' to {target_type}\\" return [convert(item, data_type) for item in data] if __name__ == \\"__main__\\": data = [\\"123\\", \\"45.67\\", \\"abc\\", \\"3.14xyz\\"] data_type = \\"int\\" converted_data = convert_data(data, data_type) print(converted_data) data_type = \\"float\\" converted_data = convert_data(data, data_type) print(converted_data) ``` Provide proper exception handling and validation as discussed. Happy coding!","solution":"from typing import List, Union def convert_data(data: List[str], data_type: str) -> List[Union[int, float, str]]: def convert(value: str, target_type: str) -> Union[int, float, str]: try: if target_type == \\"int\\": return int(value) elif target_type == \\"float\\": return float(value) except ValueError: return f\\"Error: cannot convert \'{value}\' to {target_type}\\" return [convert(item, data_type) for item in data]"},{"question":"**Scenario**: You have been hired by a small start-up to improve their internal communication tool. One of the requested features is a simple text compression and decompression mechanism to save bandwidth and storage. To achieve this, you decide to implement a basic Run-Length Encoding (RLE) algorithm, which is particularly effective for compressing simple patterns with repeated characters. **Task**: Write a class implementation that can compress and decompress strings using the Run-Length Encoding (RLE) algorithm. Your class should be named `RunLengthEncoding` and include the following methods: 1. `compress(content: str) -> str` 2. `decompress(content: str) -> str` Each method should: - Take a string `content` as input. - Compress or decompress the string using the RLE algorithm. # Constraints 1. The input string `content` will have a maximum length of 2000 characters. 2. The RLE compressed string should be properly formatted. For example, \\"aaabbc\\" should be compressed to \\"a3b2c1\\". # Requirements 1. Ensure that the implementation handles edge cases, such as empty strings. 2. Provide error handling for potential issues (e.g., invalid compressed string format during decompression). # Expected Input and Output Format * **compress(content: str) -> str** - **Input**: `content = \\"aaabbc\\"` - **Output**: `\\"a3b2c1\\"` * **decompress(content: str) -> str** - **Input**: `content = \\"a3b2c1\\"` - **Output**: `\\"aaabbc\\"` # Performance 1. The solution should be efficient, running in linear time relative to the input string length both for compression and decompression.","solution":"class RunLengthEncoding: @staticmethod def compress(content: str) -> str: if not content: return \\"\\" compressed = [] count = 1 for i in range(1, len(content)): if content[i] == content[i-1]: count += 1 else: compressed.append(content[i-1] + str(count)) count = 1 # To handle the last set of characters compressed.append(content[-1] + str(count)) return \'\'.join(compressed) @staticmethod def decompress(content: str) -> str: if not content: return \\"\\" decompressed = [] i = 0 while i < len(content): char = content[i] count = 0 i += 1 # Extract the count while i < len(content) and content[i].isdigit(): count = count * 10 + int(content[i]) i += 1 decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"# Task: Implementing a File Dependency Resolver You are tasked with developing a file dependency resolver for a project build system. Each file may depend on several other files, meaning it cannot be processed until its dependencies have been processed. Your goal is to determine a valid processing order of the files. If such an order does not exist due to circular dependencies, the system should return `None`. # Problem Description Write a function `resolve_dependencies(num_files: int, dependencies: list[tuple[int, int]]) -> list[int] | None` that returns a list of files in a valid processing order. You will receive the total number of files, which are numbered from 0 to `num_files - 1`, and a list of dependencies. Each dependency is a pair of files where the first element must be processed before the second element. # Input - **num_files**: An integer representing the total number of files. - **dependencies**: A list of pairs `(a, b)` where file `a` must be processed before file `b`. # Output - Return a list of integers representing a valid order of processing files if possible. If no valid order exists, return `None`. # Constraints - Each pair `(a, b)` in dependencies contains two distinct integers. - `0 ≤ num_files ≤ 10^4` - `0 ≤ len(dependencies) ≤ 5 x 10^4` # Example ```python num_files = 5 dependencies = [(0, 1), (1, 2), (3, 4), (4, 2)] resolve_dependencies(num_files, dependencies) # Output: [0, 3, 4, 1, 2] or any valid processing order num_files = 4 dependencies = [(0, 1), (1, 2), (2, 1)] resolve_dependencies(num_files, dependencies) # Output: None (There is a cycle) ``` # Guidelines - Ensure the function is efficient and runs within acceptable time and space complexities. - Handle edge cases such as no dependencies, multiple independent subgraphs, and cycles in dependencies.","solution":"from collections import defaultdict, deque def resolve_dependencies(num_files, dependencies): Determine a valid processing order of files based on dependencies. Return the order as a list of file indices, or None if a valid order does not exist. if num_files == 0: return [] # Adjacency list for the graph and a dictionary to count in-degrees adj_list = defaultdict(list) in_degree = {i: 0 for i in range(num_files)} # Build the graph for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Collect all nodes with in-degree 0 zero_in_degree_queue = deque([node for node in in_degree if in_degree[node] == 0]) processed_order = [] # Process nodes with in-degree 0 while zero_in_degree_queue: current = zero_in_degree_queue.popleft() processed_order.append(current) # Decrease in-degree of each neighbor for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If we processed all nodes, we have a valid order if len(processed_order) == num_files: return processed_order else: return None"},{"question":"# Question: Flatten a Multilevel Doubly Linked List Given a multilevel doubly linked list where nodes have an additional child pointer that might point to a separate doubly linked list, write a Python function to flatten the list so that all nodes appear in a single-level, doubly linked list. Function Signature: ```python def flatten_multilevel_list(head: Node) -> Node: pass ``` Input: - `head`: The head node of the multilevel doubly linked list, which can be `None` for an empty list. Output: - The head node of the flattened doubly linked list. Constraints: - List nodes can have a `next`, `prev` and `child` pointer. - You must flatten the list in place without using extra space for storing nodes. # Example: ```python # Example 1: # Construct the following multilevel doubly linked list # 1 - 2 - 3 - 4 # | # 5 - 6 # | # 7 head = Node(1) head.next = Node(2) head.next.prev = head head.next.next = Node(3) head.next.next.prev = head.next head.next.next.next = Node(4) head.next.next.next.prev = head.next.next head.next.child = Node(5) head.next.child.next = Node(6) head.next.child.next.prev = head.next.child head.next.child.next.child = Node(7) flattened_head = flatten_multilevel_list(head) # The flattened list should be: # 1 - 2 - 5 - 6 - 7 - 3 - 4 assert flattened_head.val == 1 assert flattened_head.next.val == 2 assert flattened_head.next.next.val == 5 assert flattened_head.next.next.next.val == 6 assert flattened_head.next.next.next.next.val == 7 assert flattened_head.next.next.next.next.next.val == 3 assert flattened_head.next.next.next.next.next.next.val == 4 ``` # Notes: - You may define additional helper functions if necessary. - Make sure to handle edge cases like an empty list or lists without any child pointers.","solution":"class Node: def __init__(self, val, next=None, prev=None, child=None): self.val = val self.next = next self.prev = prev self.child = child def flatten_multilevel_list(head: Node) -> Node: if not head: return head stack = [] current = head while current: # If the current node has a child, we need to process the child if current.child: # If current node\'s next is not null, push it to the stack if current.next: stack.append(current.next) current.next.prev = None # Connect the current node to the child current.next = current.child current.child.prev = current current.child = None # If we reach the end of the current level and there\'s something on the stack if not current.next and stack: current.next = stack.pop() current.next.prev = current current = current.next return head"},{"question":"# Problem Statement You are tasked with creating a function `encode_rle` that takes a string as input and returns its Run-Length Encoded (RLE) version. Run-Length Encoding is a simple form of data compression where consecutive occurrences of the same character are replaced by a single character followed by the count of its occurrences. Input - A string that contains only uppercase alphabetical characters (A-Z). Output - A string representing the Run-Length Encoded version of the input string. Constraints - The input string length will not exceed 100,000 characters. Function Signature ```python def encode_rle(s: str) -> str: ``` Example 1. **Input**: `\\"AAAABBBCCDAA\\"` - **Output**: `\\"A4B3C2D1A2\\"` Explanation: - \'A\' occurs 4 times consecutively, so \\"A4\\" - \'B\' occurs 3 times consecutively, so \\"B3\\" - \'C\' occurs 2 times consecutively, so \\"C2\\" - \'D\' occurs 1 time, so \\"D1\\" - \'A\' again occurs 2 times consecutively, so \\"A2\\" Thus, the final encoded string is: `\\"A4B3C2D1A2\\"` 2. **Input**: `\\"ABCD\\"` - **Output**: `\\"A1B1C1D1\\"` 3. **Input**: `\\"AAB\\"` - **Output**: `\\"A2B1\\"` Requirements - Implement the function in Python. - The function should efficiently handle the input length up to the specified constraints. - Ensure the function does not use excessive memory beyond what is needed for the RLE output string.","solution":"def encode_rle(s: str) -> str: Function to perform run-length encoding on the input string. Parameters: s (str): The input string consisting of uppercase alphabetical characters (A-Z). Returns: str: Run-Length Encoded (RLE) version of the input string. if not s: return \\"\\" encoded_string = [] current_char = s[0] current_count = 1 for char in s[1:]: if char == current_char: current_count += 1 else: encoded_string.append(f\\"{current_char}{current_count}\\") current_char = char current_count = 1 # Append the last run-length encoded part encoded_string.append(f\\"{current_char}{current_count}\\") return \'\'.join(encoded_string)"},{"question":"# Question: You are given a 2D matrix filled with integers, where each integer represents the number of apples in a cell. You need to find the maximum number of apples you can collect when moving from the top-left corner of the matrix to the bottom-right corner. You can only move right or down at any point in time. Requirements: 1. Implement the function `max_apples(matrix: List[List[int]])` to compute the maximum number of apples that can be collected. 2. Consider using dynamic programming to optimize the solution. Input: - `matrix`: List[List[int]] (a 2D grid where each cell contains a non-negative integer representing the count of apples) Output: - `int`: The maximum number of apples that can be collected. # Constraints: - 1 <= `len(matrix)`, `len(matrix[i])` <= 100 - 0 <= `matrix[i][j]` <= 100 # Example: ```python matrix = [ [5, 3, 2, 1], [1, 2, 10, 2], [4, 3, 1, 7] ] assert max_apples(matrix) == 29 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_apples(matrix) == 29 ``` # Notes: - The function should handle empty matrices by returning 0. - If the matrix has only one cell, the function should return the value of that cell. - Focus on optimizing the solution to work within the given constraints. # Implementation: Implement the function `max_apples` in Python, ensuring it computes the result efficiently using dynamic programming principles. ```python from typing import List def max_apples(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Initialize a DP table with the same dimensions as the matrix dp = [[0]*cols for _ in range(rows)] # Fill the DP table dp[0][0] = matrix[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1] ```","solution":"from typing import List def max_apples(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Initialize a DP table with the same dimensions as the matrix dp = [[0]*cols for _ in range(rows)] # Fill the DP table dp[0][0] = matrix[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1]"},{"question":"# Context You are developing a software application that analyzes digital signals for noise reduction. One of the methods involves calculating the root mean square (RMS) value of the signal. The RMS value is a statistical measure of the magnitude of a varying signal and is particularly useful in applications involving audio processing, signal analysis, and voltage measurement. # Task Implement a Python function called `calculate_rms` that computes the RMS value of a given list of numbers (representing a signal) and adheres to the following requirements: # Requirements * Define the function as `calculate_rms(signal: list) -> float`. * The function should return the RMS value computed using the formula ( text{RMS} = sqrt{frac{1}{n} sum_{i=1}^n x_i^2} ), where ( x_i ) are the elements of the signal. * Your function should raise a `ValueError` if the `signal` list is empty, with the error message \\"Signal list cannot be empty\\". * Assume that all elements in the list are of type `float` or `int`. # Example Usage ```python >>> calculate_rms([1, 2, 3, 4, 5]) 3.3166247903554 >>> calculate_rms([]) Traceback (most recent call last): ... ValueError: Signal list cannot be empty >>> calculate_rms([0]) 0.0 ``` # Constraints * The signal list will contain at most ( 10^6 ) elements. * The function should focus on both accuracy and performance of the RMS calculation. # Performance Requirements * The function must run in linear time, O(n), where n is the number of elements in the signal list due to the single pass required to compute the sum of squares. * Ensure the implementation is efficient in terms of both time and space complexity, avoiding unnecessary data structures or computations.","solution":"import math def calculate_rms(signal: list) -> float: Computes the RMS value of a given list of numbers (signal). :param signal: List of numbers representing the signal. :raises ValueError: If the signal list is empty. :return: RMS value as a float. if not signal: raise ValueError(\\"Signal list cannot be empty\\") n = len(signal) sum_of_squares = sum(x**2 for x in signal) rms = math.sqrt(sum_of_squares / n) return rms"},{"question":"# Question: Implement an In-Place Array Reversal with Constraints You are developing a function for reversing elements in an array within a specified range. Your task is to implement this function in an **in-place** manner, meaning that the array should be modified directly without using extra space for another array. Additionally, handle edge cases and input validation appropriately. Function Signature `def reverse_subarray(arr: list[int | float], start: int, end: int) -> None` Requirements * The function should reverse the elements in the array from the `start` index to the `end` index (inclusive). * If `start` or `end` indices are out of the array\'s bounds, it should raise an `IndexError`. * Ensure `start` is less than or equal to `end`; otherwise, raise a `ValueError`. * If the `start` index is equal to the `end` index, the array should remain unchanged. * The function should modify the array in place and return `None`. Input * `arr`: A list of integers or floats. Example: `[1, 2, 3, 4, 5]` * `start`: The starting index for the reversal. * `end`: The ending index for the reversal. Output * The function modifies the input array in place and returns `None`. Constraints * The array can contain integers and/or floats. * The array may be empty. * Indices `start` and `end` must be valid; otherwise, raise an appropriate exception. * The reversal should be done using an in-place method. * Implement edge case handling for empty arrays and single-element range reversals. Examples ```python arr = [1, 2, 3, 4, 5] reverse_subarray(arr, 1, 3) assert arr == [1, 4, 3, 2, 5] arr = [-3.4, -1.9, -7.6, 0.0, 2.4] reverse_subarray(arr, 0, 4) assert arr == [2.4, 0.0, -7.6, -1.9, -3.4] arr = [5] reverse_subarray(arr, 0, 0) assert arr == [5] arr = [] try: reverse_subarray(arr, 0, 1) except IndexError: pass # This is expected try: reverse_subarray([1, 2, 3], 1, 0) except ValueError: pass # This is expected try: reverse_subarray([1, 2, 3], 5, 6) except IndexError: pass # This is expected ``` Constraints & Limitations * The function should have a time complexity of O(n), where n is the number of elements to be reversed in the range. * Space complexity should be O(1) since the algorithm should be in-place. * Proper validation for indices and handling different edge cases should be ensured.","solution":"def reverse_subarray(arr: list[int | float], start: int, end: int) -> None: Reverses elements in the array from the start index to the end index inclusive in place. Parameters: - arr (list of int or float): The list to be modified. - start (int): The starting index of the subarray to reverse. - end (int): The ending index of the subarray to reverse. Returns: - None: This function modifies the list in place and returns None. Raises: - IndexError: If start or end are out of the bounds of the list. - ValueError: If start is greater than end. if start < 0 or end >= len(arr): raise IndexError(\\"start or end index is out of bounds\\") if start > end: raise ValueError(\\"start index cannot be greater than end index\\") # Reverse elements in place while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1"},{"question":"# Problem Statement: Sorting Files by Extension and Name You are asked to implement a function that sorts a list of filenames. The list should be sorted primarily by file extension, and for files with the same extension, it should be sorted by filename. **File Naming Rules**: - A valid filename consists of a basename and an extension, separated by a dot (e.g., `file.txt`). - Filenames and extensions are case-insensitive but should be treated as case-sensitive during sorting. **Constraints**: - Do not use external libraries except for string manipulation functions. **Input**: - A list of strings `file_list` representing filenames. **Output**: - Returns a new list of strings with the filenames sorted according to the given rules. # Task: 1. Implement the function `sort_files(file_list: list) -> list` to sort the filenames by extension first and by basename second. 2. Ensure that the sorting maintains the original case of the filenames while performing a case-insensitive comparison. # Example Usages: ```python assert sort_files([\\"file.txt\\", \\"file.TXT\\", \\"analyzer.EXE\\", \\"data.csv\\", \\"Report.docx\\"]) == [\\"data.csv\\", \\"Report.docx\\", \\"analyzer.EXE\\", \\"file.txt\\", \\"file.TXT\\"] assert sort_files([\\"image.jpeg\\", \\"File.TXT\\", \\"image.PNG\\"]) == [\\"image.jpeg\\", \\"image.PNG\\", \\"File.TXT\\"] assert sort_files([\\"a.TXT\\", \\"b.txt\\", \\"C.txt\\", \\"abc.EXE\\"]) == [\\"abc.EXE\\", \\"a.TXT\\", \\"b.txt\\", \\"C.txt\\"] ``` **Additional Notes**: - Filenames with the same basename but different cases should be ordered by the respective cases (e.g., `a.txt` comes before `A.txt` if the extension sorting rule leads to the same result). - Edge case handling, such as filenames without an extension or dots within the basename, is not required. Your implementation should ensure efficient sorting while adhering to the specified sorting criteria.","solution":"def sort_files(file_list): Sort a list of filenames primarily by file extension and secondarily by filename. The sort should be case-insensitive but maintain the original case in the output. return sorted(file_list, key=lambda x: (x.split(\'.\')[-1].lower(), x.lower()))"},{"question":"# List Rotations Problem Statement You are required to implement a function that takes in a list of integers and an integer `k`, and returns a new list that is a rotation of the original list `k` times to the right. The function should handle various edge cases appropriately by raising exceptions when necessary. Function Signature ```python def rotate_list(lst: List[int], k: int) -> List[int]: ``` Input - `lst` (List[int]): a list of integers, where 1 <= len(lst) <= 10^6 and each element in the list is between -10^6 and 10^6. - `k` (int): the number of times to rotate the list to the right, where 1 <= k <= 10^6. Output - A new list that is a rotation of the original list `k` times to the right. Constraints - If the input list is empty, raise a `ValueError` with the message \\"the input list must not be empty\\". - If `k` is not an integer, raise a `TypeError` with the message \\"the number of rotations must be an integer\\". - If `k` is less than 1, raise a `ValueError` with the message \\"the number of rotations must be at least 1\\". Examples ```python >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([10, 20, 30, 40, 50], 3) [30, 40, 50, 10, 20] >>> rotate_list([7, 14, 21], 1) [21, 7, 14] >>> rotate_list([1], 3) [1] >>> rotate_list([], 2) Traceback (most recent call last): ... ValueError: the input list must not be empty >>> rotate_list([1, 2, 3], -1) Traceback (most recent call last): ... ValueError: the number of rotations must be at least 1 >>> rotate_list([1, 2, 3], \'a\') Traceback (most recent call last): ... TypeError: the number of rotations must be an integer ``` Additional Notes You are free to use Python\'s built-in functions and list slicing techniques to achieve the solution. The function should handle large inputs efficiently.","solution":"from typing import List def rotate_list(lst: List[int], k: int) -> List[int]: Returns a new list that is a rotation of the original list k times to the right. Parameters: lst (List[int]): The list to rotate. k (int): The number of times to rotate the list to the right. Returns: List[int]: The rotated list. Raises: ValueError: If the input list is empty or if k is less than 1. TypeError: If k is not an integer. if not isinstance(lst, list): raise ValueError(\\"the input list must be a list\\") if not lst: raise ValueError(\\"the input list must not be empty\\") if not isinstance(k, int): raise TypeError(\\"the number of rotations must be an integer\\") if k < 1: raise ValueError(\\"the number of rotations must be at least 1\\") # To handle cases where k is greater than the length of lst k = k % len(lst) return lst[-k:] + lst[:-k]"},{"question":"# Problem Statement You are tasked with analyzing a large text dataset to identify frequently occurring phrases. One of the steps involves counting the occurrence of each unique phrase (composed of a specific number of words) across the entire dataset. This step is crucial for identifying key phrases that may be of interest for further analysis. You need to write a function that extracts all unique phrases of a given length from the text, counts their occurrences, and returns a dictionary with the phrases as keys and their counts as values. # Function Signature ```python def count_phrases(text: str, phrase_length: int) -> dict: This function counts the occurrences of each unique phrase of a given length in the input text. Args: text: str, the input text. phrase_length: int, the number of words in each phrase. Returns: dict: a dictionary with each unique phrase as keys and their counts as values. ``` # Expected Input and Output - **Input**: - A string representing the input text. - An integer representing the number of words in each phrase. - **Output**: - A dictionary with each unique phrase of the specified length as the keys and their occurrences as the values. # Example ```python text = \\"machine learning is a field of artificial intelligence machine learning techniques are used in many applications machine learning\\" result = count_phrases(text, phrase_length=2) print(result) # { # \'machine learning\': 3, # \'learning is\': 1, # \'is a\': 1, # \'a field\': 1, # \'field of\': 1, # \'of artificial\': 1, # \'artificial intelligence\': 1, # \'learning techniques\': 1, # \'techniques are\': 1, # \'are used\': 1, # \'used in\': 1, # \'in many\': 1, # \'many applications\': 1 # } ``` # Constraints - The input text will be a non-empty string containing words separated by spaces. - The `phrase_length` will be a positive integer less than or equal to the number of words in the text. - Case sensitivity does not need to be handled (consider all words to be in lower case). # Evaluation - **Correctness**: Ensure that your function correctly identifies and counts the phrases of the specified length. - **Efficiency**: Your implementation should efficiently handle large text inputs.","solution":"def count_phrases(text: str, phrase_length: int) -> dict: This function counts the occurrences of each unique phrase of a given length in the input text. Args: text: str, the input text. phrase_length: int, the number of words in each phrase. Returns: dict: a dictionary with each unique phrase as keys and their counts as values. words = text.split() phrase_counts = {} # Iterate through words to create phrases of specified length for i in range(len(words) - phrase_length + 1): phrase = \' \'.join(words[i:i + phrase_length]) if phrase in phrase_counts: phrase_counts[phrase] += 1 else: phrase_counts[phrase] = 1 return phrase_counts"},{"question":"# Problem Statement You are tasked with simulating a simple grocery store inventory system that restocks items based on minimum threshold levels. The goal is to write a function that identifies which items need to be restocked and by how much to reach the maximum stock level. # Function Signature ```python def restock_items(inventory: dict, min_threshold: dict, max_stock: dict) -> dict: ``` # Input - `inventory` (dictionary): The current stock of each item, where the key is the item name (string) and the value is the current stock (integer). Example: `{\\"apples\\": 5, \\"bananas\\": 2, \\"oranges\\": 9}` - `min_threshold` (dictionary): The minimum threshold for each item, below which the item needs to be restocked. The key is the item name (string) and the value is the minimum threshold (integer). Example: `{\\"apples\\": 10, \\"bananas\\": 5, \\"oranges\\": 7}` - `max_stock` (dictionary): The maximum stock level for each item. The key is the item name (string) and the value is the maximum stock (integer). Example: `{\\"apples\\": 20, \\"bananas\\": 15, \\"oranges\\": 12}` # Output - Returns a dictionary where the key is the item name (string) and the value is the quantity to be restocked (integer) so that the inventory reaches the maximum stock level. Only include items that need restocking. # Constraints - All keys in the dictionaries (`inventory`, `min_threshold`, `max_stock`) will match. - All values are non-negative integers. - The function should handle at least 1000 items in the dictionaries efficiently. # Example ```python assert restock_items( inventory={\\"apples\\": 5, \\"bananas\\": 2, \\"oranges\\": 9}, min_threshold={\\"apples\\": 10, \\"bananas\\": 5, \\"oranges\\": 7}, max_stock={\\"apples\\": 20, \\"bananas\\": 15, \\"oranges\\": 12} ) == {\\"apples\\": 15, \\"bananas\\": 13} assert restock_items( inventory={\\"apples\\": 7, \\"bananas\\": 8, \\"oranges\\": 6}, min_threshold={\\"apples\\": 5, \\"bananas\\": 8, \\"oranges\\": 7}, max_stock={\\"apples\\": 20, \\"bananas\\": 15, \\"oranges\\": 10} ) == {\\"oranges\\": 4} ``` # Explanation Given the current stock levels, minimum threshold, and maximum stock level for each item: 1. Identify items whose current stock is below their minimum threshold. 2. For each identified item, calculate the quantity to restock in order to reach the maximum stock level. 3. Return a dictionary of items to be restocked along with the quantities.","solution":"def restock_items(inventory, min_threshold, max_stock): Identifies items that need to be restocked based on the minimum threshold levels and calculates the quantity to restock to reach the maximum stock levels. :param inventory: dict, The current stock of each item. :param min_threshold: dict, The minimum threshold for each item. :param max_stock: dict, The maximum stock level for each item. :return: dict, Items needing restocking with the quantities to be restocked. restock = {} for item in inventory: if inventory[item] < min_threshold[item]: restock[item] = max_stock[item] - inventory[item] return restock"},{"question":"# Problem Statement You are tasked with developing a system to manage and monitor the performance of employees in a company. The system will store the performance rating of each employee for each month. Your goal is to implement functions that can record a performance rating and retrieve the average performance rating for a specific employee over a given time period. # Function Signatures ```python def record_performance(employee_id: str, month: str, rating: float) -> None: Records the performance rating of an employee for a specific month. Parameters: - employee_id (str): The identifier for the employee. - month (str): The month for which the rating is given in the format \\"YYYY-MM\\". - rating (float): The performance rating of the employee (0 ≤ rating ≤ 5). def get_average_performance(employee_id: str, start_month: str, end_month: str) -> float: Returns the average performance rating of an employee over a specified time period. Parameters: - employee_id (str): The identifier for the employee. - start_month (str): The starting month of the period in the format \\"YYYY-MM\\". - end_month (str): The ending month of the period in the format \\"YYYY-MM\\". Returns: float: The average performance rating over the specified period or 0 if no records exist. ``` # Inputs * `employee_id (str)`: A string representing the unique identifier of an employee. * `month (str)`: A string representing the month in the format \\"YYYY-MM\\". * `rating (float)`: A float representing the performance rating of the employee between 0 and 5. * `start_month (str)`: A string representing the starting month in the format \\"YYYY-MM\\". * `end_month (str)`: A string representing the ending month in the format \\"YYYY-MM\\". # Outputs * `None` for the `record_performance` function. * A float representing the average performance rating over the specified period for the `get_average_performance` function. # Constraints * Ratings are always between 0 and 5, inclusive. * The `month`, `start_month`, `end_month` will always be valid and formatted correctly as \\"YYYY-MM\\". * If no ratings exist for the specified period, `get_average_performance` should return 0.0. * The `end_month` will always be greater than or equal to `start_month`. # Example ```python >>> record_performance(\\"emp01\\", \\"2023-01\\", 4.5) >>> record_performance(\\"emp01\\", \\"2023-02\\", 3.8) >>> record_performance(\\"emp01\\", \\"2023-03\\", 4.2) >>> get_average_performance(\\"emp01\\", \\"2023-01\\", \\"2023-03\\") 4.166666666666667 >>> record_performance(\\"emp02\\", \\"2023-01\\", 3.0) >>> get_average_performance(\\"emp02\\", \\"2023-01\\", \\"2023-01\\") 3.0 >>> get_average_performance(\\"emp01\\", \\"2023-04\\", \\"2023-06\\") 0.0 ``` # Explanation 1. For `emp01` from January 2023 to March 2023, the average rating is (4.5 + 3.8 + 4.2) / 3 = 4.166666666666667. 2. For `emp02` in January 2023, the rating is 3.0 as there is only one record. 3. For `emp01` from April 2023 to June 2023, there are no ratings, so the average is 0.0.","solution":"from collections import defaultdict # Dictionary to hold the performance ratings by employee and month employee_ratings = defaultdict(dict) def record_performance(employee_id: str, month: str, rating: float) -> None: Records the performance rating of an employee for a specific month. employee_ratings[employee_id][month] = rating def get_average_performance(employee_id: str, start_month: str, end_month: str) -> float: Returns the average performance rating of an employee over a specified time period. from datetime import datetime # Convert strings to date objects start_date = datetime.strptime(start_month, \\"%Y-%m\\") end_date = datetime.strptime(end_month, \\"%Y-%m\\") ratings = [] # Loop through months and collect ratings for month, rating in employee_ratings[employee_id].items(): month_date = datetime.strptime(month, \\"%Y-%m\\") if start_date <= month_date <= end_date: ratings.append(rating) if not ratings: return 0.0 return sum(ratings) / len(ratings)"},{"question":"# Problem Statement You are tasked with developing a function that simulates a simplified version of a pawn\'s possible moves in a game similar to chess. The function should take the current position of the pawn and the type of pawn move (move forward or capture diagonally). Your function should determine the possible destination positions based on these inputs and ensure that the moves conform to typical chess pawn rules. # Function Signature ```python def pawn_possible_moves(position: str, move_type: str) -> List[str]: ``` # Inputs - `position` (str): A string representing the current position of the pawn on a standard 8x8 chess board (e.g., \'e2\'). - `move_type` (str): A string indicating the type of move (\'move\' or \'capture\'). # Output - A list of strings representing possible new positions the pawn can move to. # Constraints 1. The `position` will always be within the valid range of \'a1\' to \'h8\'. 2. The `move_type` will be either \'move\' or \'capture\'. 3. A pawn cannot move outside the boundaries of the chessboard. # Performance Requirements - The function can assume O(1) time complexity for determining the possible moves. # Scenario Implement a solution to determine the possible positions a pawn could move to based on the given initial position and move type (\'move\' for a normal forward move or \'capture\' for a diagonal capture move). # Example ```python # Input: \'e2\', \'move\' # Output: [\'e3\'] # Input: \'e2\', \'capture\' # Output: [\'d3\', \'f3\'] # Input: \'a7\', \'move\' # Output: [\'a8\'] # Input: \'h7\', \'capture\' # Output: [\'g8\'] ``` # Implementation Guidelines 1. Identify the current position of the pawn and determine the possible moves based on the move type. 2. For the \'move\' type, calculate the position one square forward. 3. For the \'capture\' type, calculate the diagonal squares forward to the left and right. 4. Ensure the resulting positions are within the bounds of the board and valid according to chess rules (i.e., columns \'a\' to \'h\' and rows \'1\' to \'8\'). You may start with basic validations and then proceed to handle different move types while checking for valid board positions.","solution":"from typing import List def pawn_possible_moves(position: str, move_type: str) -> List[str]: Determine the possible positions a pawn could move to based on the given initial position and move type (\'move\' for normal forward move or \'capture\' for diagonal capture move). :param position: A string representing current position of pawn (e.g., \'e2\'). :param move_type: A string indicating the type of move (\'move\' or \'capture\'). :return: A list of strings representing possible new positions. col, row = position[0], int(position[1]) possible_moves = [] if move_type == \'move\': if row < 8: possible_moves.append(f\\"{col}{row + 1}\\") elif move_type == \'capture\': if row < 8: if col > \'a\': possible_moves.append(f\\"{chr(ord(col) - 1)}{row + 1}\\") if col < \'h\': possible_moves.append(f\\"{chr(ord(col) + 1)}{row + 1}\\") return possible_moves"},{"question":"# String Pattern Repetition Detection Context: You are developing a text processing tool that analyzes input text for various patterns and properties. One feature of your tool is to determine if a given string can be constructed by repeating a smaller substring multiple times. This can help identify patterns in the text that might be useful for further analysis or compression. Requirements: 1. Implement the `is_repeated_pattern` function to determine if the input string can be constructed from repeating a smaller substring. 2. The function should return `True` if the input string is made up of one or more repetitions of a smaller substring, and `False` otherwise. 3. Ensure the function is efficient in handling longer strings. Implementation: Implement the `is_repeated_pattern` function using a combination of string manipulation techniques. # Function Signature: ```python def is_repeated_pattern(s: str) -> bool: pass ``` # Input/Output Specifications: * **Input**: * `s` (str): The input string to be analyzed. The string will contain only lowercase alphabetical characters. * **Output**: * (bool): `True` if the string can be constructed by repeating a smaller substring, else `False`. # Constraints: * The input string `s` will have a length between 1 and 10^5. # Examples: ```python assert is_repeated_pattern(\\"abab\\") == True # \\"ab\\" repeated twice assert is_repeated_pattern(\\"aaaa\\") == True # \\"a\\" repeated four times assert is_repeated_pattern(\\"abcabcabc\\") == True # \\"abc\\" repeated three times assert is_repeated_pattern(\\"abcd\\") == False # No repeated pattern assert is_repeated_pattern(\\"xyzxyzxy\\") == False # No repeated pattern ```","solution":"def is_repeated_pattern(s: str) -> bool: Returns True if the string can be constructed by repeating a smaller substring, otherwise returns False. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: substring = s[:i] if substring * (n // i) == s: return True return False"},{"question":"# Coding Assessment Question Background: In this challenge, you need to develop a system that processes temperature readings collected from multiple sensors in different cities. Each sensor sends temperature data every hour, and you are required to compute the average temperature for each city over a provided time range. Task: Implement a function `average_temperature_readings(sensor_data: List[Tuple[str, datetime, float]], start_time: datetime, end_time: datetime) -> Dict[str, float]` that takes a list of tuples representing sensor data, a start time, and an end time, and returns the average temperature for each city recorded within the provided time range. The function should execute the following steps: 1. Filter the sensor data to include only the readings between `start_time` and `end_time` (inclusive). 2. Calculate the average temperature for each city within the filtered data. 3. Return a dictionary where each key is a city\'s name, and the corresponding value is the average temperature of that city. Input: - `sensor_data` (List[Tuple[str, datetime, float]]): a list of tuples, where each tuple contains the city name (str), timestamp (datetime), and temperature reading (float). - `start_time` (datetime): the starting timestamp of the range. - `end_time` (datetime): the ending timestamp of the range. Output: - Returns a dictionary with the city names as keys and their average temperatures as values within the specified time range. Constraints: - The function should handle cases where there are no temperature readings for a city within the specified time range by excluding such cities from the result. - Assume the timestamps are in chronological order. - The function should handle cases where the sensor data could be large efficiently. Performance Requirements: - The function should perform the average calculation efficiently even with a large dataset. Example: Given the following sensor data: ```python sensor_data = [ (\\"New York\\", datetime(2023, 1, 1, 12, 0), 30.5), (\\"Los Angeles\\", datetime(2023, 1, 1, 12, 0), 55.0), (\\"New York\\", datetime(2023, 1, 1, 13, 0), 31.0), (\\"Los Angeles\\", datetime(2023, 1, 1, 13, 0), 54.5), (\\"New York\\", datetime(2023, 1, 1, 14, 0), 32.0), ] ``` and a specified time range from `datetime(2023, 1, 1, 12, 0)` to `datetime(2023, 1, 1, 13, 0)`, the function could return: ```python { \'New York\': 30.75, \'Los Angeles\': 54.75 } ``` Function Signature: ```python def average_temperature_readings(sensor_data: List[Tuple[str, datetime, float]], start_time: datetime, end_time: datetime) -> Dict[str, float]: pass ```","solution":"from datetime import datetime from typing import List, Tuple, Dict def average_temperature_readings(sensor_data: List[Tuple[str, datetime, float]], start_time: datetime, end_time: datetime) -> Dict[str, float]: filtered_data = [data for data in sensor_data if start_time <= data[1] <= end_time] city_temperatures = {} city_counts = {} for city, timestamp, temperature in filtered_data: if city in city_temperatures: city_temperatures[city] += temperature city_counts[city] += 1 else: city_temperatures[city] = temperature city_counts[city] = 1 average_temperatures = {city: city_temperatures[city] / city_counts[city] for city in city_temperatures} return average_temperatures"},{"question":"# Coding Assessment Question You are tasked with creating a class that represents a polynomial and supports various algebraic operations on polynomials. The class should include methods for addition, subtraction, multiplication, evaluation at a given point, degree calculation, and differentiation. **Objective**: Implement the Polynomial class with the following specifications. # Polynomial Class Specifications: 1. **Constructor**: ```python def __init__(self, coefficients: List[float]) -> None ``` - Initializes the polynomial with `coefficients`, where the i-th element represents the coefficient for the x^i term. - Raises `TypeError` if `coefficients` is not a list of floats. 2. **Methods**: - `add(self, other: Polynomial) -> Polynomial` : Adds two polynomials. - `subtract(self, other: Polynomial) -> Polynomial` : Subtracts one polynomial from another. - `multiply(self, other: Polynomial) -> Polynomial` : Multiplies two polynomials. - `evaluate(self, x: float) -> float` : Evaluates the polynomial at the given point `x`. - `degree(self) -> int` : Returns the degree of the polynomial. - `differentiate(self) -> Polynomial` : Returns the derivative of the polynomial. # Input and Output Formats: - Polynomials are represented as lists of floats, where the index of the list represents the power of x. - Methods should return a new Polynomial object where appropriate. - Raise `ValueError` for mismatched dimensions where applicable. - Raise `TypeError` or `ValueError` with descriptive messages for invalid input formats and other error scenarios. # Constraints: - Polynomials will have at most 100 terms for performance considerations. # Example Usage: ```python # Creating polynomials P = Polynomial([2.0, -3.0, 5.0]) # Represents 2 - 3x + 5x^2 Q = Polynomial([1.0, 0.0, 4.0, 1.0]) # Represents 1 + 4x^2 + x^3 # Performing operations R = P.add(Q) # Add polynomials S = P.subtract(Q) # Subtract polynomials T = P.multiply(Q) # Multiply polynomials value_at_2 = P.evaluate(2.0) # Evaluate P at x = 2 deg_P = P.degree() # Degree of polynomial P derivative_P = P.differentiate() # Derivative of polynomial P ``` **Your task**: Implement the `Polynomial` class as per the above specifications.","solution":"from typing import List class Polynomial: def __init__(self, coefficients: List[float]) -> None: if not isinstance(coefficients, list): raise TypeError(\\"Coefficients should be a list.\\") if any(not isinstance(c, (int, float)) for c in coefficients): raise TypeError(\\"All coefficients should be integers or floats.\\") self.coefficients = coefficients def add(self, other: \'Polynomial\') -> \'Polynomial\': max_length = max(len(self.coefficients), len(other.coefficients)) result_coefficients = [0] * max_length for i in range(max_length): if i < len(self.coefficients): result_coefficients[i] += self.coefficients[i] if i < len(other.coefficients): result_coefficients[i] += other.coefficients[i] return Polynomial(result_coefficients) def subtract(self, other: \'Polynomial\') -> \'Polynomial\': max_length = max(len(self.coefficients), len(other.coefficients)) result_coefficients = [0] * max_length for i in range(max_length): if i < len(self.coefficients): result_coefficients[i] += self.coefficients[i] if i < len(other.coefficients): result_coefficients[i] -= other.coefficients[i] return Polynomial(result_coefficients) def multiply(self, other: \'Polynomial\') -> \'Polynomial\': result_coefficients = [0] * (len(self.coefficients) + len(other.coefficients) - 1) for i in range(len(self.coefficients)): for j in range(len(other.coefficients)): result_coefficients[i + j] += self.coefficients[i] * other.coefficients[j] return Polynomial(result_coefficients) def evaluate(self, x: float) -> float: result = 0 for i, coeff in enumerate(self.coefficients): result += coeff * (x ** i) return result def degree(self) -> int: for i in range(len(self.coefficients) - 1, -1, -1): if self.coefficients[i] != 0: return i return 0 def differentiate(self) -> \'Polynomial\': if len(self.coefficients) == 1: return Polynomial([0]) derivative_coefficients = [i * self.coefficients[i] for i in range(1, len(self.coefficients))] return Polynomial(derivative_coefficients)"},{"question":"# Coding Assessment Question **Objective**: Implement a priority queue using a binary heap. **Scenario**: You are developing a task scheduling system that relies heavily on priority queues to manage and execute tasks based on their priorities. Your task is to implement a priority queue using a binary heap data structure to ensure efficient insertion and extraction of the highest-priority tasks. **Heap Description**: A binary heap is a complete binary tree that maintains the heap property: for a max-heap, every parent node is greater than or equal to its child nodes. **Task**: - Implement a `PriorityQueue` class using a binary heap. - The class should support methods for inserting a task with a given priority and extracting the highest-priority task. - Ensure the heap property is maintained after every insertion and extraction. **Class Signature**: ```python class PriorityQueue: def __init__(self): pass def insert(self, task: str, priority: int) -> None: pass def extract_max(self) -> str: pass ``` **Constraints**: - Priorities are represented as integers, with higher values indicating higher priority. - Tasks are represented as strings. - The priority queue should handle an arbitrary number of insertions and extractions. - If `extract_max` is called when the queue is empty, raise an `IndexError` with the message \\"Extract from an empty priority queue.\\" **Expected Behavior**: - On insertion, the task should be added while maintaining the heap property. - On extraction, the task with the highest priority should be removed and returned, again maintaining the heap property. **Examples**: ```python >>> pq = PriorityQueue() >>> pq.insert(\\"Task A\\", 5) >>> pq.insert(\\"Task B\\", 9) >>> pq.insert(\\"Task C\\", 3) >>> pq.extract_max() \'Task B\' >>> pq.extract_max() \'Task A\' >>> pq.extract_max() \'Task C\' >>> pq.extract_max() Traceback (most recent call last): ... IndexError: Extract from an empty priority queue ```","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, task: str, priority: int) -> None: self.heap.append((priority, task)) self._heapify_up(len(self.heap) - 1) def extract_max(self) -> str: if not self.heap: raise IndexError(\\"Extract from an empty priority queue\\") if len(self.heap) == 1: return self.heap.pop()[1] max_task = self.heap[0][1] self.heap[0] = self.heap.pop() self._heapify_down(0) return max_task def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index][0] > self.heap[parent_index][0]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): child_index = 2 * index + 1 if child_index < len(self.heap): if child_index + 1 < len(self.heap) and self.heap[child_index + 1][0] > self.heap[child_index][0]: child_index += 1 if self.heap[index][0] < self.heap[child_index][0]: self.heap[index], self.heap[child_index] = self.heap[child_index], self.heap[index] self._heapify_down(child_index)"},{"question":"# Coding Assessment Question # Scenario In software development, log files are extensively used to track events and errors for debugging purposes. Often, these logs need to be filtered and organized to extract useful information. Your task is to create a system that processes log files, filters entries based on specific criteria, and formats the output in a structured manner. # Task Implement two functions: 1. `filter_logs(logs: List[str], keyword: str) -> List[str]` 2. `format_logs(logs: List[str]) -> str` **Function Details**: 1. **filter_logs**: Filters the given `logs` based on the presence of a specified `keyword`. * **Input**: * `logs` (List[str]): A list of log entries where each entry is a string. * `keyword` (str): The keyword to filter the log entries. * **Output**: * (List[str]): A list of log entries that contain the specified keyword. 2. **format_logs**: Formats the filtered log entries into a single string with each entry on a new line. * **Input**: * `logs` (List[str]): A list of filtered log entries to be formatted. * **Output**: * (str): A single string with each log entry separated by a newline character. # Constraints and Requirements * Logs are non-empty strings and can contain any printable characters. * The keyword is a non-empty string. * Both functions should have a time complexity of O(n) where n is the number of log entries. * The `format_logs` function should handle the case where the log list is empty by returning an empty string. **Example**: ```python filter_logs([\\"Error: Disk full\\", \\"Warning: High memory usage\\", \\"Error: Network failure\\"], \\"Error\\") -> [\\"Error: Disk full\\", \\"Error: Network failure\\"] format_logs([\\"Error: Disk full\\", \\"Error: Network failure\\"]) -> \\"Error: Disk fullnError: Network failure\\" ``` # Additional Requirements 1. Implement error handling for invalid inputs (non-list logs, non-string keyword). 2. Ensure efficient processing to handle large log files. 3. Write at least 3 test cases for both functions to validate correctness.","solution":"from typing import List def filter_logs(logs: List[str], keyword: str) -> List[str]: Filters the given logs based on the presence of a specified keyword. :param logs: List[str], A list of log entries where each entry is a string. :param keyword: str, The keyword to filter the log entries. :return: List[str], A list of log entries that contain the specified keyword. if not isinstance(logs, list) or not isinstance(keyword, str): raise ValueError(\\"Invalid input types.\\") return [log for log in logs if keyword in log] def format_logs(logs: List[str]) -> str: Formats the filtered log entries into a single string with each entry on a new line. :param logs: List[str], A list of filtered log entries to be formatted. :return: str, A single string with each log entry separated by a newline character. if not isinstance(logs, list): raise ValueError(\\"Invalid input type for logs.\\") return \'n\'.join(logs)"},{"question":"# Coding Assessment Question Context: Sorting algorithms are fundamental in computer science, with various applications across data processing, management, and analysis. One basic sorting algorithm is the selection sort, which repeatedly selects the smallest (or largest) element from the unsorted part and swaps it with the first unsorted element. Task: Write a function `selection_sort(arr)` that sorts an array of integers using the selection sort algorithm. Requirements: 1. Implement a function `selection_sort(arr: list) -> list`. 2. The function should: - Raise a `TypeError` if the input is not a list or if the list contains non-integer elements. - Return the sorted list in ascending order. Input: - `arr` (list): The list of integers to be sorted (0 ≤ len(arr) ≤ 10^5). Output: - Returns the sorted list of integers in ascending order. Constraints: - Must handle lists with up to 100,000 integers efficiently. - Ensure that the algorithm and swaps are implemented correctly. Performance Expectations: - Expected time complexity is ( O(n^2) ) where ( n ) is the length of the list, consistent with the selection sort algorithm. Example: ```python >>> selection_sort([64, 25, 12, 22, 11]) [11, 12, 22, 25, 64] >>> selection_sort([5, 3, 8, 6, 2]) [2, 3, 5, 6, 8] >>> selection_sort([]) [] >>> selection_sort([1]) [1] >>> selection_sort([100, 50, -20, 0, 7]) [-20, 0, 7, 50, 100] ``` Edge Cases: - Input with an empty list should return an empty list. - Input with a single-element list should return the same single-element list.","solution":"def selection_sort(arr): Sorts a list of integers using the selection sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers in ascending order. Raises: TypeError: If input is not a list or contains non-integer elements. if not isinstance(arr, list): raise TypeError(\\"Input should be a list.\\") for element in arr: if not isinstance(element, int): raise TypeError(\\"All elements in the list should be integers.\\") n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"# Problem Summary Given a list of words, your task is to create a function that finds and returns the longest word that can be constructed by concatenating other words from the list. If there are multiple possible answers, return the one that appears first in the list. If no such word is found, return an empty string. # Function Definition Write a function `find_longest_concatenated_word(words: List[str]) -> str` that accepts the following parameter: * `words` (List[str]): A list of strings. # Output * The function should return a single string, which is the longest concatenated word, or an empty string if no such word exists. # Constraints * The list will contain at most 10,000 words. * Each word will contain only lowercase English letters. * The total length of all words combined will not exceed 10^6 characters. # Example Suppose you have the following list of words: ``` python words = [\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogcatsdog\\", \\"hippopotamuses\\", \\"rat\\", \\"ratcatdogcat\\"] ``` Calling `find_longest_concatenated_word(words)` should return `\'ratcatdogcat\'`. # Implementation Guidelines * Consider using a set to store the words for quick lookup. * Use a dynamic programming approach to check if a word can be formed by concatenating other words in the list. * Iterate through the list to determine the longest word that meets the criteria. * Ensure the function handles cases where no concatenated word exists efficiently. # Additional Notes Consider edge cases such as: * List containing a single word. * Words that cannot be concatenated from others in the list. * Efficiently managing large lists to optimize time complexity.","solution":"from typing import List def find_longest_concatenated_word(words: List[str]) -> str: def can_form(word, words_set): if word in memo: return memo[word] n = len(word) for i in range(1, n): prefix = word[:i] suffix = word[i:] if prefix in words_set: if suffix in words_set or can_form(suffix, words_set): memo[word] = True return True memo[word] = False return False words_set = set(words) memo = {} longest = \\"\\" for word in words: words_set.remove(word) if can_form(word, words_set): if len(word) > len(longest): longest = word words_set.add(word) return longest"},{"question":"# Question: Implement a Function to Compute the Jaccard Similarity In the field of data science and machine learning, the Jaccard similarity coefficient is a measure of similarity between two sets. It is defined as the size of the intersection divided by the size of the union of the sets. This metric is widely used in various applications, such as text similarity, image recognition, and collaborative filtering. Task You are required to implement a function `jaccard_similarity` that computes the Jaccard similarity between two sets of integers. Function Signature ```python def jaccard_similarity(set_a: set[int], set_b: set[int]) -> float: ``` Input * `set_a` and `set_b`: Sets of integers representing the elements of two sets. Output * Returns a single float, which is the Jaccard similarity coefficient between the provided sets. Constraints * The input sets will always contain integer numbers. * Each element in the sets will be unique. * Each set can have a minimum length of 0 and a maximum length of 1000. Examples ```python >>> jaccard_similarity({1, 2, 3}, {4, 5, 6}) 0.0 >>> jaccard_similarity({1, 2, 3}, {2, 3, 4}) 0.5 >>> jaccard_similarity({1, 2, 3}, {1, 2, 3}) 1.0 >>> jaccard_similarity({1, 2, 3}, {1, 4, 5}) 0.2 ``` Notes * The Jaccard similarity for two sets can be computed as the ratio of the size of their intersection to the size of their union. * Ensure the function handles edge cases where one or both sets are empty correctly. * The function should return 0.0 if both sets are empty, as the similarity is undefined in such a case. Make sure your solution is efficient and can handle large sets up to the specified constraint.","solution":"def jaccard_similarity(set_a: set[int], set_b: set[int]) -> float: Returns the Jaccard similarity coefficient between two sets of integers. if not set_a and not set_b: return 0.0 intersection = set_a & set_b union = set_a | set_b return len(intersection) / len(union)"},{"question":"# Problem Statement You are provided with a task to implement a sorting algorithm that sorts a given list of integers in non-decreasing order. However, instead of implementing a standard known sorting algorithm like quicksort or mergesort, you will be implementing a **Pancake Sorting** algorithm. # Detailed Requirements 1. **Input**: - A list of integers `arr` representing the array to be sorted. 2. **Output**: - A list of integers sorted in non-decreasing order using the Pancake Sorting algorithm. 3. **Constraints**: - `1 ≤ len(arr) ≤ 1000` - `-10^6 ≤ arr[i] ≤ 10^6` # Algorithm Pancake Sorting: Pancake sorting is the process of sorting a disordered stack of pancakes in order of size when a spatula can be inserted at any point in the stack and used to flip all pancakes above it. Your task is to simulate this process to sort the array using the minimum number of flips. Instructions: 1. Implement the `flip(sublist, k)` function that flips the first `k` elements of `sublist`. 2. Use this `flip` function to implement the `pancake_sort(arr)` function, which sorts the list. # Example ```python def pancake_sort(arr: List[int]) -> List[int]: Sorts the array using the pancake sorting algorithm. :param arr: List of integers to be sorted. :return: List of integers sorted in non-decreasing order. pass def flip(sublist: List[int], k: int) -> List[int]: Flip the first k elements of the sublist. :param sublist: List of integers. :param k: Number of elements from the start to flip. :return: Modified sublist after flipping. pass # Example usage print(pancake_sort([3, 2, 4, 1])) # Output should be [1, 2, 3, 4] ``` Test your function with various inputs to ensure accuracy and performance. **Note**: Make sure to implement the function `flip` that flips the first `k` elements of the list before using it in the `pancake_sort` function.","solution":"def flip(sublist, k): Flip the first k elements of the sublist. :param sublist: List of integers. :param k: Number of elements from the start to flip. :return: Modified sublist after flipping. sublist[:k] = sublist[:k][::-1] return sublist def pancake_sort(arr): Sorts the array using the pancake sorting algorithm. :param arr: List of integers to be sorted. :return: List of integers sorted in non-decreasing order. n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in arr[0..size-1] max_index = 0 for i in range(1, size): if arr[i] > arr[max_index]: max_index = i # Bring the maximum element to the front if max_index != 0: flip(arr, max_index + 1) # Bring the maximum element to its final position flip(arr, size) return arr"},{"question":"# Scenario A web developer is designing a Markdown parser that converts Markdown text into HTML. One of the requirements is to process headers correctly. The developer wants to convert headers of different levels (from H1 to H6) from a given Markdown string and replace them with the appropriate HTML header tags. # Task Write a Python function `markdown_to_html(markdown: str) -> str` that takes a Markdown string consisting of multiple lines. The function should convert all the headers from H1 to H6 to their corresponding HTML tags. # Requirements - Recognize headers denoted by one or more `#` symbols followed by a space and the header text. - Ensure your function accommodates up to six levels of headers (`#`, ``, `#`, ``, `#`, ``). - Handle edge cases, such as lines that start with `#` but are not valid headers (e.g., `#Header` without a space). - Other Markdown syntax can be ignored or left unchanged. # Input and Output - **Input**: A single string `markdown` consisting of one or more lines, where each line is separated by a newline character. - **Output**: The string with the headers replaced by the appropriate HTML tags. # Constraints - The input string will contain valid Markdown syntax. - Assume the header levels will be correctly nested (i.e., no `#` header will appear before a `` header). # Examples ```python >>> markdown_to_html(\\"# Header1n Header2n# Header3\\") \'<h1>Header1</h1>n<h2>Header2</h2>n<h3>Header3</h3>\' >>> markdown_to_html(\\"# Header1nSome textn Header2n# Header3\\") \'<h1>Header1</h1>nSome textn<h2>Header2</h2>n<h3>Header3</h3>\' >>> markdown_to_html(\\"Header2n# Header3\\") \'Header2n<h3>Header3</h3>\' ``` **Notes** - Consider using regular expressions to identify and convert header lines. - Ensure the function maintains the original structure of the text, only replacing valid headers with HTML tags. Compose a Python function `markdown_to_html` as described.","solution":"import re def markdown_to_html(markdown: str) -> str: Converts Markdown headers to HTML headers. def convert_line(line): header_match = re.match(r\'^(#{1,6})s+(.+)\', line) if header_match: header_level = len(header_match.group(1)) header_text = header_match.group(2) return f\\"<h{header_level}>{header_text}</h{header_level}>\\" return line lines = markdown.split(\'n\') html_lines = [convert_line(line) for line in lines] return \'n\'.join(html_lines)"},{"question":"# Coding Assessment Question Scenario You are developing a feature for a text processing tool that aids in analyzing and extracting specific details from large paragraphs or text blobs. One essential function of this tool is to find and collect all occurrences of a specified word in the text, ignoring case differences. Task Write a Python function `find_word_occurrences` that searches for a specific target word within a given input text and returns a list of starting indices where the word is found. The search should be case-insensitive. Function Signature ```python def find_word_occurrences(input_text: str, target_word: str) -> list: pass ``` Input * `input_text` (str): A string representing the text to be searched. Length of input_text is between 0 and 10^6 characters. * `target_word` (str): A string representing the word to be found in the input text. Length of target_word is between 1 and 100 characters. Output * List of integers representing the starting indices of each occurrence of the target word in the input text. Constraints * The search should be case-insensitive. * Ensure the function handles empty strings and non-matching cases gracefully. * Avoid using regular expressions for this task to promote algorithmic thinking. Example ```python >>> find_word_occurrences(\\"The quick Brown fox jumps over the brown dog.\\", \\"brown\\") [10, 35] >>> find_word_occurrences(\\"hello world, hello everyone\\", \\"hello\\") [0, 13] >>> find_word_occurrences(\\"Python is fun. python programming is interesting.\\", \\"python\\") [0, 15] >>> find_word_occurrences(\\"Lorem ipsum dolor sit amet.\\", \\"test\\") [] ``` Performance Requirements Ensure that the function performs efficiently, even for the upper limit of the input constraints.","solution":"def find_word_occurrences(input_text: str, target_word: str) -> list: Finds all occurrences of the target word in the input text and returns their starting indices. The search is case-insensitive. input_text_lower = input_text.lower() target_word_lower = target_word.lower() word_length = len(target_word_lower) indices = [] start = 0 while True: start = input_text_lower.find(target_word_lower, start) if start == -1: break indices.append(start) start += word_length return indices"},{"question":"# Question: Create a Plagiarism Detection System using N-grams Scenario You are developing a system that detects plagiarism in textual documents. The system employs an N-gram-based approach to compare documents and identify similarities. Implement a solution that can read multiple text documents, generate N-grams for each, and then compute a similarity score between each pair of documents. Task 1. Implement a class `NgramPlagiarismDetector` with methods to generate N-grams for a given document and compute the similarity scores among a set of documents. 2. Write a function `compute_similarity_score(doc1: str, doc2: str, n: int) -> float` that computes and returns the similarity score between two documents using N-grams. 3. Write a function `detect_plagiarism(docs: List[str], n: int) -> List[Tuple[int, int, float]]` that returns a list of tuples with three elements: the indices of the document pairs and their similarity scores. The function detects and reports pairs of documents with a similarity score above a threshold. Input and Output Formats - **Input**: - Two strings `doc1` and `doc2`, representing the contents of the documents. - An integer `n` representing the N-gram size. - **Output**: - The `compute_similarity_score` function returns a float representing the similarity score between the two documents. - The `detect_plagiarism` function returns a list of tuples `(i, j, similarity_score)`, where `i` and `j` are the indices of the document pairs, and `similarity_score` is their similarity score. Constraints: - The `docs` list has at least two documents. - The documents contain alphanumeric characters and punctuation. - The N-gram size `n` is an integer value between 1 and 10. - The similarity score is a floating-point number between 0 and 1. Implementation Hints: - Consider using set operations to efficiently compute the intersection and union of N-grams. - Normalize the documents (e.g., convert to lowercase, remove punctuation) before generating N-grams. - Use a threshold value of `0.5` for the similarity score above which pairs are considered potentially plagiarized. Requirements: - Ensure your code includes sufficient error-checking and handles edge cases appropriately. - Add brief documentation and comments explaining your key decisions and logic. ```python import re from typing import List, Tuple class NgramPlagiarismDetector: def __init__(self, n: int): self.n = n def generate_ngrams(self, document: str) -> set: # Clean document document = re.sub(r\'W\', \' \', document).lower() tokens = document.split() # Generate N-grams ngrams = set() for i in range(len(tokens) - self.n + 1): ngram = tuple(tokens[i:i + self.n]) ngrams.add(ngram) return ngrams def compute_similarity_score(self, doc1: str, doc2: str) -> float: ngrams1 = self.generate_ngrams(doc1) ngrams2 = self.generate_ngrams(doc2) intersection = ngrams1 & ngrams2 union = ngrams1 | ngrams2 if len(union) == 0: return 0.0 return len(intersection) / len(union) def detect_plagiarism(docs: List[str], n: int, threshold: float = 0.5) -> List[Tuple[int, int, float]]: detector = NgramPlagiarismDetector(n) results = [] for i in range(len(docs)): for j in range(i + 1, len(docs)): score = detector.compute_similarity_score(docs[i], docs[j]) if score >= threshold: results.append((i, j, score)) return results # Sample usage: # documents = [\\"This is a sample document.\\", \\"This document is a sample.\\", \\"Completely different content.\\"] # print(detect_plagiarism(documents, 2)) ```","solution":"import re from typing import List, Tuple class NgramPlagiarismDetector: def __init__(self, n: int): self.n = n def generate_ngrams(self, document: str) -> set: Generates N-grams from the input document. Args: - document: the input text document as a string. Returns: - A set of N-grams represented as tuples of strings. document = re.sub(r\'W\', \' \', document).lower() tokens = document.split() ngrams = set() for i in range(len(tokens) - self.n + 1): ngram = tuple(tokens[i:i + self.n]) ngrams.add(ngram) return ngrams def compute_similarity_score(self, doc1: str, doc2: str) -> float: Computes similarity score between two documents using N-grams. Args: - doc1: first document as a string. - doc2: second document as a string. Returns: - Similarity score as a float. ngrams1 = self.generate_ngrams(doc1) ngrams2 = self.generate_ngrams(doc2) intersection = ngrams1 & ngrams2 union = ngrams1 | ngrams2 if not union: # handling division by zero return 0.0 return len(intersection) / len(union) def detect_plagiarism(docs: List[str], n: int, threshold: float = 0.5) -> List[Tuple[int, int, float]]: Detects pairs of documents with a similarity score above the threshold. Args: - docs: List of documents as strings. - n: The N-gram size. - threshold: Similarity score threshold. Returns: - List of tuples indicating pairs of documents and their similarity scores. detector = NgramPlagiarismDetector(n) results = [] for i in range(len(docs)): for j in range(i + 1, len(docs)): score = detector.compute_similarity_score(docs[i], docs[j]) if score >= threshold: results.append((i, j, score)) return results"},{"question":"# Coding Assessment Question Context: You are tasked with enhancing a Python application that processes a list of customers\' orders for a web-based sales system. Each order contains an `order_id`, `customer_id`, and a `total_price`. The system currently allows you to extract orders based on certain criteria like date range or order status. Task: Implement a new feature within this system that identifies and summarizes the highest spending customers. Specifically, implement a function `top_spenders` that: 1. Takes a list of orders and an integer `n` as input. 2. Returns the top `n` customers based on their total spending. The function should return a list of tuples, each containing a `customer_id` and the total amount spent by that customer, in descending order of total spending. You need to: 1. Parse the input list and aggregate spending per customer. 2. Sort the customers based on total spending. 3. Return the top `n` customers. Expected Input and Output Formats: Function signature: ```python def top_spenders(orders: typing.List[typing.Dict[str, typing.Union[int, float]]], n: int) -> typing.List[typing.Tuple[int, float]]: # your implementation here ``` - **Input**: `orders` (List of dictionaries) - Each dictionary represents an order with keys: `\'order_id\'`, `\'customer_id\'`, and `\'total_price\'`. ```python [ {\\"order_id\\": 1, \\"customer_id\\": 1, \\"total_price\\": 200.0}, {\\"order_id\\": 2, \\"customer_id\\": 2, \\"total_price\\": 150.0}, {\\"order_id\\": 3, \\"customer_id\\": 1, \\"total_price\\": 300.0}, # additional orders ] ``` - **Input**: `n` (int) - Number of top spenders to return. - **Output**: List of tuples containing `customer_id` and their total spending. ```python [ (1, 500.0), # customer_id 1 spent a total of 500.0 (2, 150.0), # customer_id 2 spent a total of 150.0 # additional customers ] ``` Constraints and Assumptions: - Assume there are at least `n` unique customers in the orders list. - Do not use external libraries; rely on Python\'s standard libraries only. Hints: - Use a dictionary to aggregate total spending per customer. - Use sorting methods provided by Python to sort the customers. Example Implementation: ```python def top_spenders(orders: typing.List[typing.Dict[str, typing.Union[int, float]]], n: int) -> typing.List[typing.Tuple[int, float]]: customer_spending = {} # Aggregate spending per customer for order in orders: customer_id = order[\'customer_id\'] total_price = order[\'total_price\'] if customer_id not in customer_spending: customer_spending[customer_id] = 0.0 customer_spending[customer_id] += total_price # Sort customers by total spending in descending order sorted_customers = sorted(customer_spending.items(), key=lambda x: x[1], reverse=True) # Return the top n customers return sorted_customers[:n] # Example usage orders = [ {\\"order_id\\": 1, \\"customer_id\\": 1, \\"total_price\\": 200.0}, {\\"order_id\\": 2, \\"customer_id\\": 2, \\"total_price\\": 150.0}, {\\"order_id\\": 3, \\"customer_id\\": 1, \\"total_price\\": 300.0}, {\\"order_id\\": 4, \\"customer_id\\": 3, \\"total_price\\": 450.0}, {\\"order_id\\": 5, \\"customer_id\\": 4, \\"total_price\\": 100.0}, ] print(top_spenders(orders, 2)) # Output: [(3, 450.0), (1, 500.0)] ``` Ensure your function works efficiently for large input sizes and handles edge cases as necessary.","solution":"from typing import List, Dict, Union, Tuple def top_spenders(orders: List[Dict[str, Union[int, float]]], n: int) -> List[Tuple[int, float]]: customer_spending = {} # Aggregate spending per customer for order in orders: customer_id = order[\'customer_id\'] total_price = order[\'total_price\'] if customer_id not in customer_spending: customer_spending[customer_id] = 0.0 customer_spending[customer_id] += total_price # Sort customers by total spending in descending order sorted_customers = sorted(customer_spending.items(), key=lambda x: x[1], reverse=True) # Return the top n customers return sorted_customers[:n]"},{"question":"# Coding Assessment Question Problem Statement: Given an array `nums` of integers, design an algorithm that will calculate the sum of elements between two indices, `i` and `j` (inclusive), and be able to update the value of an element in the array efficiently. Implement a class `NumArray` that supports the following methods: 1. `__init__(self, nums: List[int])`: Initialize your data structure with the array `nums`. 2. `update(self, index: int, val: int)`: Update the value of `nums[index]` to be `val`. 3. `sumRange(self, left: int, right: int) -> int`: Return the sum of the elements of `nums` between indices `left` and `right` inclusive (i.e., `nums[left] + nums[left + 1] + ... + nums[right]`). Write an efficient solution that allows both update and sumRange operations to be performed quickly. ```python class NumArray: def __init__(self, nums: List[int]): Initialize your data structure here. Args: - nums (List[int]): The list of integers. pass def update(self, index: int, val: int) -> None: Update the value of `nums[index]` to be `val`. Args: - index (int): The index of the array to be updated. - val (int): The new value to be set. pass def sumRange(self, left: int, right: int) -> int: Return the sum of the elements between indices `left` and `right` inclusive. Args: - left (int): The starting index. - right (int): The ending index (inclusive). Returns: - int: The sum of the elements between the specified indices. pass ``` Constraints: * The length of the array `nums` will not exceed 30,000. * The elements of `nums` will be in the range [-10^4, 10^4]. * `update` and `sumRange` operations will be called at most 3 * 10^4 times. Examples: ```python # Example usage nums = [1, 3, 5] obj = NumArray(nums) print(obj.sumRange(0, 2)) # Output: 9 obj.update(1, 2) print(obj.sumRange(0, 2)) # Output: 8 ``` Requirements: * Implement an efficient data structure that supports both update and sumRange operations. * Minimize the time complexity for both types of operations. * Use suitable algorithms and data structures, such as segment trees or binary indexed trees, for fast query and update operations. Good luck, and ensure to focus on both performance and accuracy in your solution.","solution":"from typing import List class NumArray: def __init__(self, nums: List[int]): Initialize your data structure here. Args: - nums (List[int]): The list of integers. self.nums = nums[:] self.n = len(nums) self.tree = [0] * (self.n + 1) for i in range(self.n): self._update_tree(i, nums[i]) def _update_tree(self, idx, val): idx += 1 while idx <= self.n: self.tree[idx] += val idx += idx & -idx def _query_tree(self, idx): idx += 1 sum_val = 0 while idx > 0: sum_val += self.tree[idx] idx -= idx & -idx return sum_val def update(self, index: int, val: int) -> None: Update the value of `nums[index]` to be `val`. Args: - index (int): The index of the array to be updated. - val (int): The new value to be set. diff = val - self.nums[index] self.nums[index] = val self._update_tree(index, diff) def sumRange(self, left: int, right: int) -> int: Return the sum of the elements between indices `left` and `right` inclusive. Args: - left (int): The starting index. - right (int): The ending index (inclusive). Returns: - int: The sum of the elements between the specified indices. return self._query_tree(right) - self._query_tree(left - 1)"},{"question":"# Coding Assessment Question Problem You are tasked with evaluating the efficiency and concurrency handling of a task execution scheduler in a multi-threaded environment. Specifically, you need to implement a function to simulate job processing in a priority queue. **Objective**: * Write a function `priority_scheduler` that processes a series of jobs based on their priority and arrival time. **Function Signature**: ```python def priority_scheduler(jobs: List[Tuple[int, int, int]]) -> List[int]: ``` * **Input**: * `jobs`: A list of tuples, where each tuple contains three integers `(id, priority, arrival_time)` representing: - `id`: The unique identifier of the job. - `priority`: The priority of the job (higher number means higher priority). - `arrival_time`: The time the job arrives in the queue (time is in increasing order). * **Output**: * Returns a list of job IDs in the order they are processed. **Constraints**: * The processing system picks the highest-priority job available at any given time. * If two jobs have the same priority, the job that arrived first is processed first. * The function must handle up to `10^5` jobs efficiently. **Performance Requirements**: * The solution should ensure efficient job scheduling and take advantage of appropriate data structures for priority queue management. Example ```python print(priority_scheduler([(1, 3, 0), (2, 2, 1), (3, 1, 2), (4, 3, 3)])) # Output: [1, 4, 2, 3] print(priority_scheduler([(1, 2, 0), (2, 3, 1), (3, 2, 2), (4, 1, 3)])) # Output: [2, 1, 3, 4] print(priority_scheduler([(1, 1, 0), (2, 1, 1), (3, 1, 2), (4, 1, 3)])) # Output: [1, 2, 3, 4] ``` Additional Information: Think about how you would use a priority queue data structure to handle the jobs efficiently. You can use Python’s `heapq` module to manage the queue operations, ensuring that job scheduling is done in an optimal manner.","solution":"from typing import List, Tuple import heapq def priority_scheduler(jobs: List[Tuple[int, int, int]]) -> List[int]: Process a series of jobs based on their priority and arrival time. Args: jobs: A list of tuples where each tuple contains (id, priority, arrival_time) Returns: A list of job IDs in the order they are processed. pq = [] result = [] for job in jobs: id, priority, arrival_time = job # Using negative priority because heapq is a min-heap by default heapq.heappush(pq, (-priority, arrival_time, id)) while pq: priority, arrival_time, id = heapq.heappop(pq) result.append(id) return result"},{"question":"Sorting Points Based on Distance Problem Description Given a list of points in a 2D plane, sort them based on their distance from the origin (0, 0). If two points have the same distance, maintain their relative order from the input list. **Input**: 1. `points` (List[Tuple[int, int]]): A list of tuples where each tuple represents the coordinates of a point `(x, y)` in a 2D plane. **Output**: * **Sorted Points** (List[Tuple[int, int]]): The list of points sorted based on their distance from the origin. Constraints: 1. `1 <= len(points) <= 100` 2. Each coordinate is an integer where `-10^4 <= x, y <= 10^4`. Objective Implement a function to sort the points based on the Euclidean distance from the origin. Use a stable sorting algorithm to maintain the relative order. Implementation Requirements * **Function Signature**: `def sort_points(points: list) -> list:` * Your solution should handle edge cases such as a single point or multiple points at the same distance. * Use a lambda function to calculate the distance squared (to avoid floating-point arithmetic). Example ```python def sort_points(points: list) -> list: pass # Test Cases print(sort_points([(1, 2), (3, 4), (2, 2)])) # Output: [(1, 2), (2, 2), (3, 4)] print(sort_points([(0, 1), (0, 0), (2, 3)])) # Output: [(0, 0), (0, 1), (2, 3)] print(sort_points([])) # Output: [] print(sort_points([(3, 3), (1, 1), (0, 2)])) # Output: [(1, 1), (0, 2), (3, 3)] ``` Hint: To calculate the distance from the origin for a point `(x, y)`, use the formula `distance = x^2 + y^2` and sort based on this calculated distance.","solution":"def sort_points(points): Sorts a list of points based on their distance from the origin (0, 0). # Sort points based on the distance squared from the origin points_sorted = sorted(points, key=lambda point: point[0]**2 + point[1]**2) return points_sorted # Example usage (can be removed in actual submission) # print(sort_points([(1, 2), (3, 4), (2, 2)])) # Output: [(1, 2), (2, 2), (3, 4)] # print(sort_points([(0, 1), (0, 0), (2, 3)])) # Output: [(0, 0), (0, 1), (2, 3)] # print(sort_points([])) # Output: [] # print(sort_points([(3, 3), (1, 1), (0, 2)]))# Output: [(1, 1), (0, 2), (3, 3)]"},{"question":"**Consecutive Primes Sum** **Problem Statement**: You are tasked with finding the longest sequence of consecutive prime numbers that adds up to a prime less than a given number `n`. Write a function to identify the length of this sequence and the corresponding sum. **Function Signature**: ```python def consecutive_primes_sum(n: int) -> Tuple[int, int]: ``` **Input**: - `n` (int): The upper limit for the prime sum (exclusive). **Output**: - Returns a tuple where the first element is the length of the longest sequence of consecutive primes and the second element is the prime sum. **Constraints**: - `10 <= n <= 1000000` **Example**: ```python consecutive_primes_sum(1000) ``` For this example, the function should identify the longest sequence of consecutive prime numbers that sums to a prime less than 1000. The correct tuple is `(21, 953)` because the sum of 21 consecutive primes (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73) equals 953, which is a prime number. **Notes**: - You might want to write a helper function to generate prime numbers up to n using the Sieve of Eratosthenes. - Use a sliding window approach to find the sequences of consecutive primes and check the sum for primality. - Make sure your function efficiently handles the constraints and edge cases. **Hints**: - First, create a list of primes up to n using an efficient prime generation method. - Traverse through the list to check sums of consecutive primes. - Keep track of the longest sequence and the corresponding prime sum encountered during the traversal.","solution":"from typing import List, Tuple def sieve_of_eratosthenes(limit: int) -> List[int]: is_prime = [True] * limit is_prime[0] = is_prime[1] = False for start in range(2, int(limit**0.5) + 1): if is_prime[start]: for multiple in range(start*start, limit, start): is_prime[multiple] = False return [num for num, prime in enumerate(is_prime) if prime] def consecutive_primes_sum(n: int) -> Tuple[int, int]: primes = sieve_of_eratosthenes(n) max_length = 0 max_prime_sum = 0 for i in range(len(primes)): for j in range(i + max_length, len(primes)): prime_sum = sum(primes[i:j]) if prime_sum >= n: break if prime_sum in primes: max_length = j - i max_prime_sum = prime_sum return (max_length, max_prime_sum)"},{"question":"# Coding Assessment: Calculate Median of Combination Context You are developing data analysis software that requires the calculation of the median from two sorted lists. The challenge is to merge these lists and efficiently compute the median. The lists are of potentially different lengths but each list is already sorted in ascending order. Requirements Implement the following function: 1. **find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float**: * Merges the two sorted lists into one sorted list. * Calculates and returns the median of the merged list. Inputs * Two lists of integers, both sorted in ascending order. * Example: ```python nums1 = [1, 3] nums2 = [2] ``` Output * A single float value representing the median of the merged list. Example ```python # Example provided inputs: nums1 = [1, 3] nums2 = [2] # Expected Output: 2.0 # Another example provided inputs: nums1 = [1, 2] nums2 = [3, 4] # Expected Output: 2.5 ``` Notes * The median is the middle number in an ascending list of numbers. If the list has an even number of elements, the median is the average of the two middle numbers. * You should ensure the solution handles different lengths of the input lists and works efficiently even for larger lists. Implement the function with optimal performance in mind, especially for larger datasets.","solution":"def find_median_sorted_arrays(nums1, nums2): Merges two sorted lists and finds the median of the merged sorted list. # Combined length of the two arrays n = len(nums1) + len(nums2) # Pointers for nums1 and nums2 i, j = 0, 0 merged = [] # Merge the two sorted lists while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: merged.append(nums1[i]) i += 1 else: merged.append(nums2[j]) j += 1 # If any elements are left in nums1 or nums2, add them to merged while i < len(nums1): merged.append(nums1[i]) i += 1 while j < len(nums2): merged.append(nums2[j]) j += 1 # Find the median if n % 2 == 1: # Odd length, return the middle element return float(merged[n // 2]) else: # Even length, return the average of the two middle elements return (merged[(n // 2) - 1] + merged[n // 2]) / 2.0"},{"question":"# Reverse Polish Notation Calculator You are tasked with implementing a calculator that evaluates expressions written in Reverse Polish Notation (RPN). RPN is a mathematical notation in which every operator follows all of its operands. It is also referred to as postfix notation. Function Signature: ```python def evaluate_rpn(expression: str) -> float: ``` Input: * `expression`: A string representing a valid RPN expression, where tokens are separated by spaces. (1 ≤ len(expression) ≤ 1000) Output: * A float representing the result of the RPN expression. Constraints: * The expression contains only integers and the operators `+`, `-`, `*`, `/`. * The operators should use standard integer division behavior (`//`) if using older Python versions (before Python 3.5 the `/` operator in function signatures). * You must handle erroneous expressions by raising appropriate exceptions (e.g., ValueError for incorrect tokens). Examples: ```python >>> evaluate_rpn(\\"3 4 +\\") 7.0 >>> evaluate_rpn(\\"10 2 8 * + 3 -\\") 23.0 >>> evaluate_rpn(\\"2 5 + 3 *\\") 21.0 >>> evaluate_rpn(\\"7 2 - 4 * 2 /\\") 10.0 >>> evaluate_rpn(\\"7 2\\") Traceback (most recent call last): ... ValueError: The input RPN expression is not valid. >>> evaluate_rpn(\\"7 2 + x\\") Traceback (most recent call last): ... ValueError: Invalid token \'x\' found in the expression. ``` Performance Requirements: * The implementation should efficiently handle valid RPN expressions up to 1000 characters. * Appropriate error handling for invalid tokens and incorrect expression formats should be included.","solution":"def evaluate_rpn(expression: str) -> float: Evaluates an expression in Reverse Polish Notation (RPN) and returns the result as a float. :param expression: A string representing a valid RPN expression :return: The result of the RPN expression as a float if not expression: raise ValueError(\\"The input RPN expression is empty.\\") tokens = expression.split() stack = [] for token in tokens: if token.lstrip(\'-\').isdigit(): # Check if the token is an integer stack.append(float(token)) elif token in (\'+\', \'-\', \'*\', \'/\'): if len(stack) < 2: raise ValueError(\\"The input RPN expression is not valid.\\") b = stack.pop() # Second operand a = stack.pop() # First operand if token == \'+\': result = a + b elif token == \'-\': result = a - b elif token == \'*\': result = a * b elif token == \'/\': if b == 0: raise ZeroDivisionError(\\"Division by zero.\\") result = a / b stack.append(result) else: raise ValueError(f\\"Invalid token \'{token}\' found in the expression.\\") if len(stack) != 1: raise ValueError(\\"The input RPN expression is not valid.\\") return stack[0]"},{"question":"**Question**: Distance Between Nodes in a Binary Tree **Context**: Given a binary tree, determine the distance between two nodes in the tree. The distance between two nodes is defined as the number of edges in the shortest path between them. **Details**: 1. Implement a function `find_distance(root: TreeNode, node1: int, node2: int) -> int` that: - Takes the root node of the binary tree and the values of two nodes. - Returns the distance between the two nodes. 2. You need to implement the helper function `find_lca(root: TreeNode, node1: int, node2: int) -> TreeNode` to find the Lowest Common Ancestor (LCA) of the given nodes. The LCA of two nodes `node1` and `node2` in a binary tree is the lowest (i.e., deepest) node that has both `node1` and `node2` as descendants. 3. A `TreeNode` class is provided, defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Input Format**: - `root` : The root node of the binary tree, an instance of `TreeNode`. - `node1` : The value of the first node (an integer). - `node2` : The value of the second node (an integer). **Output Format**: - An integer representing the distance between the two nodes. **Constraints**: - The values `node1` and `node2` are guaranteed to be in the binary tree. - The number of nodes in the tree is at most 10^4. **Examples**: ```python def find_distance(root: TreeNode, node1: int, node2: int) -> int: # Your implementation here def find_lca(root: TreeNode, node1: int, node2: int) -> TreeNode: # Your implementation here # Example usage: # Constructing the following binary tree: # 1 # / # 2 3 # / # 4 5 node1 = TreeNode(4) node2 = TreeNode(5) node3 = TreeNode(2, node1, node2) node4 = TreeNode(3) root = TreeNode(1, node3, node4) print(find_distance(root, 4, 5)) # Output: 2 print(find_distance(root, 4, 3)) # Output: 3 print(find_distance(root, 2, 5)) # Output: 1 ``` Ensure your implementation handles the tree structure and manages to identify and calculate the distances correctly in a binary tree context.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_lca(root: TreeNode, node1: int, node2: int) -> TreeNode: if not root or root.val == node1 or root.val == node2: return root left_lca = find_lca(root.left, node1, node2) right_lca = find_lca(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca else right_lca def find_distance(root: TreeNode, node1: int, node2: int) -> int: def distance_from_lca(lca: TreeNode, target: int, depth: int) -> int: if not lca: return -1 if lca.val == target: return depth left_distance = distance_from_lca(lca.left, target, depth + 1) if left_distance != -1: return left_distance return distance_from_lca(lca.right, target, depth + 1) lca = find_lca(root, node1, node2) dist1 = distance_from_lca(lca, node1, 0) dist2 = distance_from_lca(lca, node2, 0) return dist1 + dist2"},{"question":"# Array Difference Function You are tasked with writing a function that takes two lists of integers and returns a list of integers that are present in the first list but not in the second. Function Signature ```python def array_diff(list1: list[int], list2: list[int]) -> list[int]: ``` Inputs - `list1` (list of int): The first list of integers. - `list2` (list of int): The second list of integers from which integers in `list1` should be excluded. Output - (list of int): A list containing integers from `list1` that are not present in `list2`. Constraints - The lists can be empty. - The lists may contain duplicate integers. - The output list should maintain the order of elements as found in `list1`. Example Usage ```python >>> array_diff([1, 2, 2, 3], [2]) [1, 3] >>> array_diff([1, 2, 2, 3], [1, 3]) [2, 2] >>> array_diff([1, 2, 3], []) [1, 2, 3] >>> array_diff([], [1, 2, 3]) [] >>> array_diff([1, 2, 3], [4, 5, 6]) [1, 2, 3] >>> array_diff([1, 2, 2], [2]) [1] ``` Explanation Write a function that: 1. Reads in the two lists of integers. 2. Iterates through the first list and collects elements that are not found in the second list. 3. Returns the resulting list with the required elements maintaining the original order. Ensure your solution handles all specified edge cases, including empty lists and lists with duplicate values.","solution":"def array_diff(list1: list[int], list2: list[int]) -> list[int]: Returns a list of integers that are in list1 but not in list2. Parameters: list1 (list of int): The first list of integers. list2 (list of int): The second list of integers. Returns: list of int: A list of integers from list1 that are not present in list2. return [x for x in list1 if x not in list2]"},{"question":"# Sparse Matrix Multiplication **Problem Statement:** You are tasked with developing software for scientific computing applications where dealing with large sparse matrices is common. To improve efficiency in such applications, you need to implement sparse matrix-matrix multiplication. **Requirements:** 1. Implement a function `sparse_matrix_multiplication` that multiplies two sparse matrices. 2. Use the Compressed Sparse Row (CSR) format to store the sparse matrices which is efficient for arithmetic operations, row slicing, and matrix-vector products. 3. The function should return the result of multiplying two sparse matrices. **Function Signature:** ```python from scipy.sparse import csr_matrix def sparse_matrix_multiplication(A: csr_matrix, B: csr_matrix) -> csr_matrix: ... ``` **Input:** - `A`: (M x K) CSR matrix. - `B`: (K x N) CSR matrix. **Output:** - `C`: (M x N) CSR matrix which is the product of `A` and `B`. **Constraints:** - The number of columns in matrix `A` will match the number of rows in matrix `B`. - The matrices `A` and `B` will be large and sparse. **Example:** ```python from scipy.sparse import csr_matrix import numpy as np # Example sparse matrices in CSR format A = csr_matrix(np.array([ [0, 0, 3, 0], [0, 5, 0, 0], [0, 0, 0, 7] ])) B = csr_matrix(np.array([ [0, 2, 0], [1, 0, 0], [0, 0, 6], [0, 3, 0] ])) result = sparse_matrix_multiplication(A, B) print(result.toarray()) # Expected output: # [[0 0 18] # [5 0 0] # [0 21 0]] ``` **Performance Requirements:** 1. The implementation should handle large sparse matrices efficiently. 2. Ensure the solution employs CSR format operations to achieve optimal multiplication performance. **Note:** - Use the `scipy.sparse.csr_matrix` class for the CSR format. - You may assume the input matrices are already in CSR format and do not need conversion.","solution":"from scipy.sparse import csr_matrix def sparse_matrix_multiplication(A: csr_matrix, B: csr_matrix) -> csr_matrix: Multiplies two sparse matrices A and B using CSR format. Args: A (csr_matrix): First sparse matrix in CSR format. B (csr_matrix): Second sparse matrix in CSR format. Returns: csr_matrix: The product of A and B. return A.dot(B)"},{"question":"# Shortest Path in a Directed Graph **Context**: You are tasked with implementing a function to find the shortest path in a weighted directed graph using the Dijkstra\'s algorithm. The graph is represented as an adjacency list. # Task: Write a function to compute the shortest path from a given source node to all other nodes in the graph. # Method: 1. **Dijkstra\'s Algorithm** # Requirements: 1. **Shortest Path Calculation**: - Implement Dijkstra\'s algorithm to calculate the shortest path from the source node to all other nodes in the graph. - **Input**: - `graph`: Dictionary where keys are node ids and values are lists of tuples representing the connected nodes and edge weights. - `source`: Integer representing the source node id. - **Output**: - Dictionary where keys are node ids and values are the shortest distance from the source node. # Constraints: 1. Nodes are identified by unique integers. 2. The graph is a non-negative, weighted, directed graph. 3. The graph will have at least one node. # Example: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 # Output: # {0: 0, 1: 3, 2: 1, 3: 4} ``` # Guidelines: 1. Use a priority queue to select the next node with the smallest tentative distance. 2. Initialize distances from the source to all nodes as infinite except the source itself which should be zero. 3. Update distances when shorter paths are found. 4. Ensure the algorithm completes within a reasonable time frame for large inputs. # Implementation: ```python import heapq def dijkstra(graph, source): # Step 1: Initialize distances and priority queue distances = {node: float(\'infinity\') for node in graph} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Step 2: Skip if we found a better path before if current_distance > distances[current_node]: continue # Step 3: Update distances to neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Example usage graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 print(dijkstra(graph, source)) # Output should be: {0: 0, 1: 3, 2: 1, 3: 4} ``` In the provided example code, the shortest path from the source node to all other nodes in the graph has been calculated using Dijkstra\'s algorithm. Ensure your function passes this test scenario and handles all edge cases mentioned in the guidelines.","solution":"import heapq def dijkstra(graph, source): Finds the shortest paths from a given source node to all other nodes in a weighted directed graph. Args: graph (dict): Dictionary where keys are node ids and values are lists of tuples representing the connected nodes and edge weights. source (int): Integer representing the source node id. Returns: dict: Dictionary where keys are node ids and values are the shortest distance from the source node. # Step 1: Initialize distances and priority queue distances = {node: float(\'infinity\') for node in graph} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Step 2: Skip if we found a better path before if current_distance > distances[current_node]: continue # Step 3: Update distances to neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Reverse Words in a String You are tasked with implementing a function that takes a string as input and returns a new string where the words are in reverse order. The function should handle cases such as leading or trailing whitespace and multiple spaces between words. Function Signature ```python def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string. :return: String with the words in reverse order. # Your code here ``` # Input * `s`: A string containing words separated by spaces. # Output * A string with the words in reverse order. # Constraints * Words are defined as sequences of non-space characters. * Leading and trailing whitespace should be trimmed. * All words should be separated by a single space in the output. # Example 1. **Input**: s = \\" This is an example \\" **Output**: \\"example an is This\\" 2. **Input**: s = \\"Hello World\\" **Output**: \\"World Hello\\" 3. **Input**: s = \\"Python Programming Language\\" **Output**: \\"Language Programming Python\\" # Implementation Note * Utilize string manipulation methods to achieve the desired result. * Ensure that the function handles edge cases like a single word or empty input string correctly. ```python def reverse_words(s: str) -> str: # Split the string into words after stripping leading/trailing whitespace words = s.strip().split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a single string separated by spaces return \' \'.join(reversed_words) ```","solution":"def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string. :return: String with the words in reverse order. # Split the string into words after stripping leading/trailing whitespace words = s.strip().split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a single string separated by spaces return \' \'.join(reversed_words)"},{"question":"# Matrix Inversion using Gauss-Jordan Elimination Given a square matrix `A` of dimension n x n as a numpy array, your task is to find the inverse of `A` using the Gauss-Jordan elimination method. The goal is to compute a matrix `A_inv` such that `A @ A_inv` is approximately the identity matrix. Function Signature ```python def inverse_gauss_jordan(a: np.ndarray) -> np.ndarray: Compute the inverse of matrix A using Gauss-Jordan elimination. Arguments: a -- a numpy.ndarray of shape (n, n) Returns: A_inv -- a numpy.ndarray of shape (n, n) representing the inverse of A ``` Input - `a`: a numpy array of shape (n, n). Output - Returns `A_inv`, a numpy array of shape (n, n). Constraints - 1 ≤ n ≤ 500 - The elements of the matrix will be in the range [-10^9, 10^9]. - The matrix will be non-singular, meaning it will always have an inverse. Example ```python import numpy as np A = np.array([ [4, 7], [2, 6] ], dtype=float) A_inv = inverse_gauss_jordan(A) # Verify the results I = np.eye(A.shape[0]) print(np.allclose(A @ A_inv, I)) # Output: True print(np.allclose(A_inv @ A, I)) # Output: True ``` Detailed Requirements 1. Implement the Gauss-Jordan elimination algorithm to find the inverse of the matrix. 2. Ensure that the product of `A` and `A_inv` is approximately the identity matrix. 3. Handle the precision issues by using suitable comparisons (e.g., `np.allclose`). 4. Avoid using built-in functions specifically for matrix inversion to demonstrate understanding of the underlying algorithm. 5. Ensure the implementation is efficient enough to handle the upper constraint of the matrix size.","solution":"import numpy as np def inverse_gauss_jordan(a: np.ndarray) -> np.ndarray: Compute the inverse of matrix A using Gauss-Jordan elimination. Arguments: a -- a numpy.ndarray of shape (n, n) Returns: A_inv -- a numpy.ndarray of shape (n, n) representing the inverse of A n = a.shape[0] # Create an augmented matrix [A | I] aug = np.hstack((a, np.eye(n))) for i in range(n): # Make the diagonal contain all 1\'s diag = aug[i, i] aug[i] = aug[i] / diag # Make the other rows contain 0\'s for j in range(n): if i != j: row_factor = aug[j, i] aug[j] -= row_factor * aug[i] # Extract the inverse matrix return aug[:, n:]"},{"question":"# Huffman Coding Tree Construction and Encoding **Scenario**: Given a set of characters and their corresponding frequencies, you need to construct a Huffman coding tree. Your task is to implement a function that generates the Huffman codes for each character and returns a dictionary with characters as keys and their Huffman codes as values. # Function Signature ```python def build_huffman_tree(frequencies: Dict[str, int]) -> Dict[str, str]: pass ``` # Input 1. `frequencies` (Dict[str, int]): A dictionary where the key is a character (a string of length 1) and the value is its frequency in a given text. # Output - `Dict[str, str]`: A dictionary with characters as keys and their corresponding Huffman codes as values. # Constraints - The input dictionary will have at least 2 different characters. - All frequencies are positive integers. # Performance Requirements - The solution should be efficient, taking into consideration the usual performance characteristics of constructing a Huffman tree. # Examples ```python # Example 1: frequencies = { \'a\': 5, \'b\': 9, \'c\': 12, \'d\': 13, \'e\': 16, \'f\': 45 } huffman_codes = build_huffman_tree(frequencies) # Expected Output: { # \'a\': \'1100\', # \'b\': \'1101\', # \'c\': \'100\', # \'d\': \'101\', # \'e\': \'111\', # \'f\': \'0\' # } # Note: Exact codes might differ but should have the proper prefix-free Huffman property. # Example 2: frequencies = { \'A\': 2, \'B\': 3, \'C\': 7, \'D\': 1, \'E\': 1, \'F\': 5 } huffman_codes = build_huffman_tree(frequencies) # Expected Output: { # \'A\': \'110\', # \'B\': \'111\', # \'C\': \'10\', # \'D\': \'0110\', # \'E\': \'0111\', # \'F\': \'0\' # } # Again, exact codes can differ but should be valid Huffman codes. # You are expected to provide a valid Huffman tree construction. import heapq from collections import defaultdict def build_huffman_tree(frequencies): class HeapNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def merge_nodes(left: HeapNode, right: HeapNode): new_node = HeapNode(None, left.freq + right.freq) new_node.left = left new_node.right = right return new_node def build_codes(root: HeapNode, current_code: str, codes: Dict[str, str]): if root is None: return if root.char is not None: codes[root.char] = current_code return build_codes(root.left, current_code + \\"0\\", codes) build_codes(root.right, current_code + \\"1\\", codes) priority_queue = [HeapNode(char, freq) for char, freq in frequencies.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: left = heapq.heappop(priority_queue) right = heapq.heappop(priority_queue) merged_node = merge_nodes(left, right) heapq.heappush(priority_queue, merged_node) root = priority_queue[0] codes = defaultdict(str) build_codes(root, \\"\\", codes) return dict(codes) # Example usage: frequencies = { \'a\': 5, \'b\': 9, \'c\': 12, \'d\': 13, \'e\': 16, \'f\': 45 } print(build_huffman_tree(frequencies)) ``` Write a function `build_huffman_tree` following the provided function signature and satisfy the requirements outlined.","solution":"import heapq from collections import defaultdict from typing import Dict class HeapNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def merge_nodes(left: HeapNode, right: HeapNode): new_node = HeapNode(None, left.freq + right.freq) new_node.left = left new_node.right = right return new_node def build_codes(root: HeapNode, current_code: str, codes: Dict[str, str]): if root is None: return if root.char is not None: codes[root.char] = current_code return build_codes(root.left, current_code + \\"0\\", codes) build_codes(root.right, current_code + \\"1\\", codes) def build_huffman_tree(frequencies: Dict[str, int]) -> Dict[str, str]: priority_queue = [HeapNode(char, freq) for char, freq in frequencies.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: left = heapq.heappop(priority_queue) right = heapq.heappop(priority_queue) merged_node = merge_nodes(left, right) heapq.heappush(priority_queue, merged_node) root = priority_queue[0] codes = defaultdict(str) build_codes(root, \\"\\", codes) return dict(codes)"},{"question":"# Coding Assessment Question: Efficient String Rotation **Context**: You are a software engineer working on a text-processing library. One of the common operations is rotating strings, where you take a string and move its characters around. Your task is to implement a function to determine if one string is a rotation of another string efficiently. **Problem Statement**: Write a function named `is_rotation` that checks if a given string is a rotation of another string. **Function Signature**: ```python def is_rotation(A: str, B: str) -> bool: :param A: A string which we suspect might be a rotation of string B. :param B: A string to be checked against string A. :returns: True if A is a rotation of B, False otherwise. ``` **Input**: - `A`: a string of characters. - `B`: a string of characters. **Output**: - A boolean value: `True` if string `A` is a rotation of string `B`, otherwise `False`. **Constraints**: - 0 ≤ len(A) ≤ 1000 - 0 ≤ len(B) ≤ 1000 - The input strings consist of ASCII characters. **Explanation**: Two strings `A` and `B` are considered rotations of each other if and only if they can be obtained by \\"rotating\\" the other string around any point. For example, \\"abcde\\" and \\"cdeab\\" are rotations of each other since \\"abcde\\" can be rotated around to become \\"cdeab\\". **Performance Requirements**: - The implementation should be optimal with respect to both time and space complexity. - Ensure that the solution can handle the upper limit of input sizes efficiently. **Example**: ```python A = \\"waterbottle\\" B = \\"erbottlewat\\" print(is_rotation(A, B)) # Expected Output: True A = \\"hello\\" B = \\"elloh\\" print(is_rotation(A, B)) # Expected Output: True A = \\"hello\\" B = \\"llohe\\" print(is_rotation(A, B)) # Expected Output: True A = \\"hello\\" B = \\"helloo\\" print(is_rotation(A, B)) # Expected Output: False A = \\"hello\\" B = \\"world\\" print(is_rotation(A, B)) # Expected Output: False A = \\"abc\\" B = \\"cab\\" print(is_rotation(A, B)) # Expected Output: True ```","solution":"def is_rotation(A: str, B: str) -> bool: Returns True if A is a rotation of B. if len(A) != len(B): return False return B in A + A"},{"question":"# Temperature Conversion Background: Temperature conversion is a common task in various scientific and everyday applications. It involves converting temperature measurements from one unit to another, typically between Celsius, Fahrenheit, and Kelvin. Task: You are required to implement the function `convert_temperature` to convert a given temperature from one unit to another. Your function should handle edge cases and raise errors for any invalid inputs or conversions. Function Signature: ```python def convert_temperature(temperature: float, from_unit: str, to_unit: str) -> float: Convert the temperature from one unit to another. Input Parameters: temperature (float): The input temperature value. from_unit (str): The unit of the input temperature. It must be one of: \'Celsius\', \'Fahrenheit\', \'Kelvin\'. to_unit (str): The unit of the output temperature. It must be one of: \'Celsius\', \'Fahrenheit\', \'Kelvin\'. Returns: float: The converted temperature. Raises: ValueError: If the input temperature is below absolute zero in the provided unit. ValueError: If `from_unit` or `to_unit` are not valid temperature units. ``` Example Tests: ```python >>> convert_temperature(100, \'Celsius\', \'Fahrenheit\') # boiling point of water 212.0 >>> convert_temperature(32, \'Fahrenheit\', \'Celsius\') # freezing point of water 0.0 >>> convert_temperature(0, \'Celsius\', \'Kelvin\') # absolute zero in Celsius 273.15 >>> convert_temperature(255.37, \'Kelvin\', \'Celsius\') # conversion to Celsius -17.78 >>> convert_temperature(-273.15, \'Celsius\', \'Kelvin\') # absolute zero in Kelvin Traceback (most recent call last): ... ValueError: Temperature below absolute zero. >>> convert_temperature(32, \'Celsius\', \'Kelvin\') # positive conversion to Kelvin 305.15 >>> convert_temperature(100, \'Kelvin\', \'Fahrenheit\') # converting low Kelvin value -279.67 >>> convert_temperature(100, \'Kelvin\', \'Unknown\') # invalid unit for conversion Traceback (most recent call last): ... ValueError: Invalid temperature unit \'Unknown\'. ``` Constraints: * The valid temperature units are strictly \'Celsius\', \'Fahrenheit\', and \'Kelvin\'. * Temperatures should be realistic and physically meaningful: - Celsius: must be greater than or equal to -273.15 - Kelvin: must be greater than or equal to 0 - Fahrenheit: must be greater than or equal to -459.67","solution":"def convert_temperature(temperature, from_unit, to_unit): valid_units = [\'Celsius\', \'Fahrenheit\', \'Kelvin\'] # Check if the units are valid if from_unit not in valid_units: raise ValueError(f\\"Invalid temperature unit \'{from_unit}\'.\\") if to_unit not in valid_units: raise ValueError(f\\"Invalid temperature unit \'{to_unit}\'.\\") # Check if the temperature is above absolute zero for the given unit if from_unit == \'Celsius\' and temperature < -273.15: raise ValueError(\\"Temperature below absolute zero.\\") if from_unit == \'Kelvin\' and temperature < 0: raise ValueError(\\"Temperature below absolute zero.\\") if from_unit == \'Fahrenheit\' and temperature < -459.67: raise ValueError(\\"Temperature below absolute zero.\\") # Convert the temperature to Celsius first if from_unit == \'Celsius\': temp_celsius = temperature elif from_unit == \'Fahrenheit\': temp_celsius = (temperature - 32) * 5.0/9.0 elif from_unit == \'Kelvin\': temp_celsius = temperature - 273.15 # Now convert from Celsius to the target unit if to_unit == \'Celsius\': return temp_celsius elif to_unit == \'Fahrenheit\': return temp_celsius * 9.0/5.0 + 32 elif to_unit == \'Kelvin\': return temp_celsius + 273.15"},{"question":"# Problem Statement - Sort a List Based on Another List Given two lists, `A` and `B`, implement a function called `relative_sort` that sorts the elements of list `A` based on the ordering defined by list `B`. If an element in `A` does not appear in `B`, it should be placed at the end of list `A` in ascending order. Function Signature ```python def relative_sort(A: list[int], B: list[int]) -> list[int]: pass ``` # Input Format: - A list of integers `A` (0-indexed) with values to be sorted. - A list of integers `B` (0-indexed) defining the relative order. # Output Format: - A list of integers, which is the sorted version of `A`. # Constraints: - 0 <= len(A) <= 1000 - 0 <= len(B) <= 1000 - All elements in `B` are unique. - Elements in `A` and `B` are integers and may repeat in `A`. # Example ```python # Example 1 A = [5, 3, 1, 7, 3, 2, 6] B = [3, 6, 7] print(relative_sort(A, B)) # Output: [3, 3, 6, 7, 1, 2, 5] # Example 2 A = [2, 5, 8, 9, 7] B = [2, 8, 5] print(relative_sort(A, B)) # Output: [2, 8, 5, 7, 9] ``` # Notes 1. In the output, elements of `A` should appear in the order specified by `B` first. 2. The remaining elements of `A` that are not in `B` should be sorted in ascending order and placed at the end of the output list. 3. Handle edge cases such as empty lists and elements that do not overlap between `A` and `B`. This problem is designed to test your ability to manipulate lists and implement custom sorting logic, ensuring you take into account elements that may not originally fit into the preferred order.","solution":"def relative_sort(A: list[int], B: list[int]) -> list[int]: # Create a dictionary to store the position of each element in B position_map = {value: index for index, value in enumerate(B)} # Separate elements of A that are in B and those that are not in B in_B = [x for x in A if x in position_map] not_in_B = [x for x in A if x not in position_map] # Sort in_B based on their position in B in_B.sort(key=lambda x: position_map[x]) # Sort not_in_B in ascending order not_in_B.sort() # Combine the two lists return in_B + not_in_B"},{"question":"Simple Calculator for Complex Numbers Design a simple calculator to perform basic arithmetic operations (+, -, *, /) on complex numbers. A complex number is a number that can be expressed in the form `a + bi`, where `a` and `b` are real numbers, and `i` is the imaginary unit. Implement the function `complex_calculator` that accepts two complex numbers and an operator, and returns the result of the operation as a complex number. Input: * `num1` (complex): First complex number * `num2` (complex): Second complex number * `operator` (string): One of the operators \'+\', \'-\', \'*\', \'/\' Output: * Complex: Result of the operation as a complex number Constraints: * Assume valid complex numbers and operator as input * The division operation should handle division by zero by raising an appropriate exception Example: ```python >>> complex_calculator(1 + 2j, 3 + 4j, \'+\') (4+6j) >>> complex_calculator(1 + 2j, 3 + 4j, \'-\') (-2-2j) >>> complex_calculator(1 + 2j, 3 + 4j, \'*\') (-5+10j) >>> complex_calculator(1 + 2j, 3 + 4j, \'/\') (0.44+0.08j) ``` Guidelines: * Use Python\'s built-in complex number support for operations. * Ensure your function raises an appropriate exception for division by zero. * Strive for clear and concise code that handles edge cases effectively.","solution":"def complex_calculator(num1, num2, operator): Returns the result of the arithmetic operation on two complex numbers. Parameters: - num1 (complex): First complex number - num2 (complex): Second complex number - operator (str): Operator, can be one of \'+\', \'-\', \'*\', \'/\' Returns: - complex: Result of the operation as a complex number if operator == \'+\': return num1 + num2 elif operator == \'-\': return num1 - num2 elif operator == \'*\': return num1 * num2 elif operator == \'/\': if num2 == 0: raise ValueError(\\"Division by zero is not allowed\\") return num1 / num2 else: raise ValueError(\\"Invalid operator\\")"},{"question":"# Maze Path Finder You are implementing a function to determine the number of distinct paths from the top-left corner to the bottom-right corner of an `m x n` maze. The maze is represented by a grid where each cell contains either `0` (open path) or `1` (obstacle), meaning you cannot move through a cell with a `1`. Your function should return the total number of distinct paths that traverse only through `0`s, moving either right or down at each step. # Function Signature ```python def maze_paths(maze: List[List[int]]) -> int: pass ``` # Input - `maze`: A two-dimensional list (i.e., list of lists) with `m` rows and `n` columns representing the maze grid, where `1 <= m, n <= 100`. # Output - An integer representing the total count of distinct paths from the top-left corner to the bottom-right corner. # Examples ```python maze1 = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] print(maze_paths(maze1)) # Expected output: 2 maze2 = [ [0, 1], [0, 0] ] print(maze_paths(maze2)) # Expected output: 1 ``` # Constraints - The given maze will always have valid dimensions. - There may not always be a valid path if the starting or ending cell is `1`. - Ensure your solution is optimized to run within reasonable time limits for the given constraints. # Notes - Use dynamic programming to efficiently calculate the number of paths, storing intermediate results to avoid recomputation. - Consider edge cases where the maze dimensions are minimal (e.g., 1x1 grid), or the path is completely blocked. - Ensure your implementation appropriately handles grids with no valid paths and returns `0` in such cases.","solution":"from typing import List def maze_paths(maze: List[List[int]]) -> int: m = len(maze) n = len(maze[0]) if maze[0][0] == 1 or maze[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if maze[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Maximum Path Sum in Binary Tree Scenario You are tasked with developing a feature for a tree visualization application that computes the maximum path sum in a binary tree. A path in the binary tree is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Task Implement a function `max_path_sum(root)` that: - Takes the root node of a binary tree as input. - Returns an integer representing the maximum path sum. Your solution should leverage depth-first search (DFS) to traverse the tree and determine the maximum path sum. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: pass ``` Input Constraints * The number of nodes in the tree is in the range `[1, 3 * 10^4]`. * `-1000 <= Node.val <= 1000`. Example ```python # Example 1 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) # The maximum path is 2 -> 1 -> 3 with a sum of 6 assert max_path_sum(root1) == 6 # Example 2 root2 = TreeNode(-10) root2.left = TreeNode(9) root2.right = TreeNode(20) root2.right.left = TreeNode(15) root2.right.right = TreeNode(7) # The maximum path sum is 15 -> 20 -> 7 with a sum of 42 assert max_path_sum(root2) == 42 ``` Requirements 1. The solution must efficiently handle the upper constraint of nodes. 2. Properly consider negative values, as they may affect the path sum calculations. Hint You might find it useful to create a helper function that returns two values: - The maximum path sum including and starting from the current node. - The global maximum path sum found so far across all nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: def dfs(node): nonlocal max_sum if not node: return 0 # Compute the maximum path sum passing through the left and right child left_gain = max(dfs(node.left), 0) # max(0, left_gain) to discard negative paths right_gain = max(dfs(node.right), 0) # max(0, right_gain) to discard negative paths # Current path sum including this node current_path_sum = node.val + left_gain + right_gain # Update the global maximum path sum max_sum = max(max_sum, current_path_sum) # Return the maximum gain if the current node is treated as the end point return node.val + max(left_gain, right_gain) max_sum = float(\'-inf\') dfs(root) return max_sum"},{"question":"# Problem Statement You are given a text file that contains multiple lines of words. Write a function that reads the file, counts the frequency of each word, and then writes these frequencies to a new file sorted by word in alphabetical order. Function Signature: ```python def word_frequency(input_file: str, output_file: str) -> None: pass ``` # Inputs: 1. **input_file (str):** The path to the input text file containing multiple lines of words. 2. **output_file (str):** The path to the output file where the word frequencies should be written. # Outputs: - **Writes to the output file:** Each line in the output file should contain a word followed by its frequency. The words should be sorted in alphabetical order. # Constraints: - The words in the input file are case-insensitive, i.e., \\"Word\\" and \\"word\\" should be considered the same. - Punctuation marks are to be ignored. Only consider alphabetic characters for words. - The output file should have one word per line followed by a space and its count. # Example: Input (example.txt): ``` Hello world! This is a test. This test is only a test. Hello again, world. ``` Output (output.txt): ``` a 2 again 1 hello 2 is 2 only 1 test 3 this 2 world 2 ``` # Instructions: 1. Read the content of the input file. 2. Normalize the words (convert to lowercase and remove punctuation). 3. Count the frequency of each word. 4. Write the results to the output file, with each word and its frequency on a new line, sorted alphabetically.","solution":"import re from collections import Counter def word_frequency(input_file: str, output_file: str) -> None: # Read the content of the input file with open(input_file, \'r\') as infile: text = infile.read() # Normalize the words (convert to lowercase and remove punctuation) text = text.lower() words = re.findall(r\'b[a-z]+b\', text) # Count the frequency of each word word_counts = Counter(words) # Write the results to the output file with open(output_file, \'w\') as outfile: for word in sorted(word_counts): outfile.write(f\\"{word} {word_counts[word]}n\\")"},{"question":"# Problem Statement You are tasked with decoding a string that has been encoded using a Caesar Cipher. The Caesar Cipher is a basic encryption technique where each letter in the plaintext is shifted a fixed number of positions down the alphabet. For this task, you must create a function to encode and another to decode a string using the Caesar Cipher. # Function Signatures - Implement the function `caesar_encode(s: str, shift: int) -> str`. This function will: - Take a plaintext string `s` and an integer `shift`. - Return the encoded string. ```python def caesar_encode(s: str, shift: int) -> str: pass ``` - Implement the function `caesar_decode(encoded_s: str, shift: int) -> str`. This function will: - Take an encoded string `encoded_s` and an integer `shift`. - Return the original decoded string. ```python def caesar_decode(encoded_s: str, shift: int) -> str: pass ``` # Input and Output Input 1. `s` (str): A string to encode. Constraints: `1 ≤ len(s) ≤ 1000`. 2. `shift` (int): The number of positions each letter is shifted. Constraints: `0 ≤ shift ≤ 25`. 3. `encoded_s` (str): A string encoded using the Caesar Cipher. Constraints: `1 ≤ len(encoded_s) ≤ 1000`. Output 1. `caesar_encode(s, shift)` returns a string representing the encoded version of the input string. 2. `caesar_decode(encoded_s, shift)` returns a string representing the original decoded version of the encoded string. # Example 1. `caesar_encode(\\"hello\\", 3)` - Returns: `\\"khoor\\"` 2. `caesar_decode(\\"khoor\\", 3)` - Returns: `\\"hello\\"` # Constraints - Only lowercase alphabetic characters (`a-z`) will be used for encoding and decoding. Spaces and punctuation are not included in the scope of this problem. - Ensure that your implementation correctly wraps around from `z` to `a`. # Notes - Practice handling character shifts and wraparounds accurately. - Consider both positive and negative shifts, ensuring a seamless decoding and encoding process. - Ensure your solution is efficient and handles edge cases.","solution":"def caesar_encode(s: str, shift: int) -> str: encoded = [] for char in s: encoded_char = chr(((ord(char) - ord(\'a\') + shift) % 26) + ord(\'a\')) encoded.append(encoded_char) return \'\'.join(encoded) def caesar_decode(encoded_s: str, shift: int) -> str: decoded = [] for char in encoded_s: decoded_char = chr(((ord(char) - ord(\'a\') - shift) % 26) + ord(\'a\')) decoded.append(decoded_char) return \'\'.join(decoded)"},{"question":"# Context You have been assigned to work on a logging system for a multi-threaded application. The system involves recording events from different threads into a central log file in a thread-safe manner. Each event consists of a timestamp, a thread ID, and a message. # Task Your task is to implement the `LogManager` class that can safely record events from multiple threads. The class must support the following functionalities: * Initializing a new log file. * Adding new events to the log in a thread-safe manner. * Retrieving the list of all recorded events in chronological order. # Requirements 1. Implement the `LogManager` class. 2. Ensure that `add_event` method is thread-safe. 3. The `get_log` method should return all the recorded events sorted by their timestamps. # Input No direct input since this involves class methods without parameters. # Output Different class methods returning specific outputs: - `add_event`: This method doesn\'t return anything. - `get_log`: List of all recorded events sorted by their timestamps. # Class Signature ```python import threading from typing import List, Tuple class LogManager: def __init__(self): self.lock = threading.Lock() self.log = [] def add_event(self, timestamp: float, thread_id: int, message: str) -> None: Adds a new event to the log. Args: timestamp (float): The time the event occurred. thread_id (int): The ID of the thread that generated the event. message (str): The log message. # TODO: Implement this method in a thread-safe manner. def get_log(self) -> List[Tuple[float, int, str]]: Retrieves the list of all recorded events, sorted by timestamp. Returns: List[Tuple[float, int, str]]: The sorted list of log entries. # TODO: Implement this method to return all log entries sorted by timestamp. ``` # Example Usage ```python >>> import time >>> import threading >>> log_manager = LogManager() >>> def log_event(manager, thread_id, message): ... timestamp = time.time() ... manager.add_event(timestamp, thread_id, message) >>> threads = [] >>> for i in range(5): ... t = threading.Thread(target=log_event, args=(log_manager, i, f\\"Event from thread {i}\\")) ... threads.append(t) ... t.start() >>> for t in threads: ... t.join() >>> log_entries = log_manager.get_log() >>> for entry in log_entries: ... print(entry) (1693465199.123456, 0, \'Event from thread 0\') (1693465199.123457, 1, \'Event from thread 1\') (1693465199.123458, 2, \'Event from thread 2\') (1693465199.123459, 3, \'Event from thread 3\') (1693465199.123460, 4, \'Event from thread 4\') ```","solution":"import threading from typing import List, Tuple class LogManager: def __init__(self): self.lock = threading.Lock() self.log = [] def add_event(self, timestamp: float, thread_id: int, message: str) -> None: Adds a new event to the log. Args: timestamp (float): The time the event occurred. thread_id (int): The ID of the thread that generated the event. message (str): The log message. with self.lock: self.log.append((timestamp, thread_id, message)) def get_log(self) -> List[Tuple[float, int, str]]: Retrieves the list of all recorded events, sorted by timestamp. Returns: List[Tuple[float, int, str]]: The sorted list of log entries. with self.lock: return sorted(self.log, key=lambda x: x[0])"},{"question":"**Problem Statement**: Given a list of integers, write a function that partitions the list into two sublists such that the difference in their sums is minimized. You need to implement both a recursive and a dynamic programming method to solve the problem. Ensure to handle common edge cases and error conditions properly. # Function Signatures: ```python def partition_recursive(nums: List[int]) -> int: pass def partition_dynamic(nums: List[int]) -> int: pass ``` # Input: The function `partition_recursive` and `partition_dynamic` should accept the following input: - `nums` is a list of integers, which can be empty or contain both positive and negative integers. # Output: - Both functions should return an integer, representing the minimal difference in sums of two sublists. - If the input list is empty, return `0`. # Examples: ```python partition_recursive([1, 6, 11, 5]) # Expected output: 1 (Partition: [1, 5, 6] and [11], sums: 12 and 11) partition_dynamic([1, 6, 11, 5]) # Expected output: 1 partition_recursive([1, 2, 3, 9]) # Expected output: 3 (Partition: [1, 2, 3] and [9], sums: 6 and 9) partition_dynamic([1, 2, 3, 9]) # Expected output: 3 partition_recursive([]) # Expected output: 0 partition_dynamic([]) # Expected output: 0 ``` # Constraints: - Both functions must compute the result efficiently. Aim for ( O(n cdot text{sum}(nums)) ) where ( n ) is the length of `nums`. - Handle edge cases such as an empty list and lists with negative numbers appropriately.","solution":"from typing import List def partition_recursive(nums: List[int]) -> int: Partitions the list into two sublists such that the difference in their sums is minimized using recursion. Returns the minimal difference in sums of two sublists. def helper(i, current_sum, total_sum): if i == len(nums): return abs((total_sum - current_sum) - current_sum) include = helper(i + 1, current_sum + nums[i], total_sum) exclude = helper(i + 1, current_sum, total_sum) return min(include, exclude) total_sum = sum(nums) return helper(0, 0, total_sum) def partition_dynamic(nums: List[int]) -> int: Partitions the list into two sublists such that the difference in their sums is minimized using dynamic programming. Returns the minimal difference in sums of two sublists. total_sum = sum(nums) n = len(nums) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(n + 1)] # Initialize dp table for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): dp[i][j] = dp[i-1][j] if j >= nums[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-nums[i-1]] for j in range(target, -1, -1): if dp[n][j]: return total_sum - 2 * j return 0"},{"question":"# ASCII to Base64 Conversion Context: Base64 is a group of similar binary-to-text encoding schemes that represent binary data (more specifically, a sequence of 8-bit bytes) in an ASCII string format by translating it into a radix-64 representation. You are asked to implement two functions that convert ASCII strings to Base64 encoded strings and vice versa. # Function 1: ASCII to Base64 Encoding Write a function `base64_encode(data: str) -> str` that takes an ASCII string and returns a Base64 encoded string. Use the Base64 alphabet `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/` for encoding, and end the encoded string with \'=\' to pad if its length is not a multiple of 4. Example: ```python >>> base64_encode(\'Hello\') \'SGVsbG8=\' >>> base64_encode(\'world!\') \'d29ybGQh\' >>> base64_encode(\'\') \'\' ``` # Function 2: Base64 to ASCII Decoding Write a function `base64_decode(data: str) -> str` that takes a Base64 encoded string and converts it back to an ASCII string. The function should raise a `ValueError` if the input is not a valid Base64 encoded string. Example: ```python >>> base64_decode(\'SGVsbG8=\') \'Hello\' >>> base64_decode(\'d29ybGQh\') \'world!\' >>> base64_decode(\'\') \'\' >>> base64_decode(\'SGVsbG8\') Traceback (most recent call last): ... ValueError: Base64 encoded data is invalid: Data length is not a multiple of 4. >>> base64_decode(\'SGV@sbG8=\') Traceback (most recent call last): ... ValueError: Base64 encoded data is invalid: Data contains invalid characters. ``` # Constraints: 1. The input to the encoding function must be an ASCII string. 2. The Base64 encoded output should always use padding \'=\' to make the output length a multiple of 4. 3. While decoding, the function should handle and strip away the padding characters. 4. If the input data to be decoded contains characters outside of the Base64 alphabet, or if the length of the data is not a multiple of 4, the function should raise a `ValueError`.","solution":"import base64 def base64_encode(data: str) -> str: Encodes an ASCII string to Base64 encoded string. :param data: ASCII string :return: Base64 encoded string encoded_bytes = base64.b64encode(data.encode(\'ascii\')) encoded_str = encoded_bytes.decode(\'ascii\') return encoded_str def base64_decode(data: str) -> str: Decodes a Base64 encoded string back to an ASCII string. :param data: Base64 encoded string :return: ASCII string :raises ValueError: If input is not a valid Base64 encoded string try: decoded_bytes = base64.b64decode(data, validate=True) decoded_str = decoded_bytes.decode(\'ascii\') return decoded_str except (base64.binascii.Error, ValueError) as e: raise ValueError(f\\"Base64 encoded data is invalid: {e}\\")"},{"question":"# Binary Tree Maximum Path Sum Given a binary tree, write a program to find the maximum path sum. The path may start and end at any node in the tree. The path must contain at least one node and does not need to go through the root. Requirements: 1. Implement the function `max_path_sum` to compute the maximum path sum. 2. You can define any helper functions as needed. 3. Ensure the solution handles both positive and negative values in the binary tree nodes. # Input and Output Formats: 1. **Input**: - `root` (TreeNode): The root node of the binary tree. 2. **Output**: - `int`: The maximum path sum of the tree. Example: ``` Input: 1 / 2 3 Output: 6 Explanation: The path 2 -> 1 -> 3 yields the maximum sum 6. ``` # Constraints: - The number of nodes in the tree is in the range `[0, 1000]`. - `-10^4 <= Node.val <= 10^4` # Testing and Performance: - Create various test cases with balanced, unbalanced, complete, and skewed binary trees. - Ensure the function performs efficiently for the upper limit of nodes. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def max_path_sum(self, root: TreeNode) -> int: Computes the maximum path sum in the binary tree. Parameters: - root (TreeNode): The root node of the binary tree. Returns: - int: The maximum path sum. self.max_sum = float(\'-inf\') def helper(node): if not node: return 0 left_gain = max(helper(node.left), 0) right_gain = max(helper(node.right), 0) current_sum = node.val + left_gain + right_gain self.max_sum = max(self.max_sum, current_sum) return node.val + max(left_gain, right_gain) helper(root) return self.max_sum if __name__ == \\"__main__\\": # Example usage: root = TreeNode(1, TreeNode(2), TreeNode(3)) sol = Solution() print(sol.max_path_sum(root)) # Output: 6 # Additional test cases root2 = TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) print(sol.max_path_sum(root2)) # Output: 42 root3 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) print(sol.max_path_sum(root3)) # Output: 11 root4 = TreeNode(-3) print(sol.max_path_sum(root4)) # Output: -3 root5 = None # Edge case: empty tree print(sol.max_path_sum(root5)) # Output: 0 (or should handle as specific case required) ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def max_path_sum(self, root: TreeNode) -> int: Computes the maximum path sum in the binary tree. Parameters: - root (TreeNode): The root node of the binary tree. Returns: - int: The maximum path sum. self.max_sum = float(\'-inf\') def helper(node): if not node: return 0 left_gain = max(helper(node.left), 0) right_gain = max(helper(node.right), 0) current_sum = node.val + left_gain + right_gain self.max_sum = max(self.max_sum, current_sum) return node.val + max(left_gain, right_gain) helper(root) return self.max_sum"},{"question":"Question: Implement a Run-Length Encoding Compression Function Your task is to implement a function that performs run-length encoding (RLE) compression on a given string. Run-length encoding is a simple form of lossless data compression in which successive runs of the same character are stored as a single character and a count of the number of times it appears. # Function Signature ```python def run_length_encoding(s: str) -> str: Given a string, returns its run-length encoded version. Args: s: str - The input string to be compressed using run-length encoding. Returns: str - The run-length encoded string. ``` # Input * A string `s` containing only uppercase alphabetic characters (\'A\' - \'Z\'). # Output * A string representing the run-length encoded version of the input string. # Constraints * 0 <= len(s) <= 10^6 * The string `s` will only contain uppercase alphabetic characters (\'A\' - \'Z\'). # Example ```python >>> run_length_encoding(\\"AAABBBCCDAA\\") \\"A3B3C2D1A2\\" >>> run_length_encoding(\\"A\\") \\"A1\\" >>> run_length_encoding(\\"\\") \\"\\" ``` # Performance Requirements * The solution should have a time complexity of O(n), where n is the length of the input string, and a space complexity of O(n). # Notes * Ensure to handle edge cases, such as an empty string. * The function should be able to process strings efficiently even for large input sizes. # Additional Context Imagine you\'re developing a feature for a text editor that needs to compress and store long repetitive strings efficiently to save space. Run-length encoding is a suitable method for this, as it reduces the size of strings with many repeated characters. Implement a function that can perform this compression efficiently.","solution":"def run_length_encoding(s: str) -> str: if not s: # If the string is empty return \\"\\" encoded = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 encoded.append(f\\"{prev_char}{count}\\") # Append the last sequence return \'\'.join(encoded)"},{"question":"# Problem Statement You are tasked with creating a scheduling system for a university. The aim is to optimize the assignment of lectures to classrooms to minimize overlap. You need to implement functions for: 1. **Parsing the Input Schedule** to create an event list. 2. **Sorting Events** to facilitate overlap checks. 3. **Determining Classroom Allocations** based on sorted events. # Functions to Implement You need to implement the following three functions: 1. `parse_schedule(schedule: List[Tuple[int, int]]) -> List[Tuple[int, str, int]]`: - **Input**: - `schedule`: A list of tuples, where each tuple contains two integers representing the start and end times of a lecture. - **Output**: A list of tuples, where each tuple contains three elements — the time of the event, a string indicating whether it\'s a `start` or `end` event, and the original index of the lecture. 2. `sort_events(events: List[Tuple[int, str, int]]) -> List[Tuple[int, str, int]]`: - **Input**: - `events`: A list of tuples containing the parsed schedule events. - **Output**: A list of sorted tuples based on event time. If two events have the same time, `end` events should come before `start` events. 3. `allocate_classrooms(events: List[Tuple[int, str, int]], num_lectures: int) -> List[int]`: - **Input**: - `events`: The list of sorted events. - `num_lectures`: An integer representing the total number of lectures. - **Output**: A list of integers where each element is the assigned classroom number for corresponding lectures from the input schedule. # Example ```python schedule = [(30, 75), (0, 50), (60, 150)] events = parse_schedule(schedule) sorted_events = sort_events(events) classroom_allocations = allocate_classrooms(sorted_events, len(schedule)) print(\\"Classroom allocations:\\", classroom_allocations) ``` # Constraints - Ensure there are no overlaps by allocating additional classrooms as necessary. - The scheduling must handle up to 10^5 lectures. # Solution Explanation 1. **Parsing the Input Schedule** will create an event list where each event is either the start or end of a lecture. 2. **Sorting Events** will ensure the smallest times are processed first, and within the same time, `end` events precede `start` events to free up classrooms before allocating new ones. 3. **Determining Classroom Allocations** will use a greedy algorithm to assign classrooms efficiently by keeping track of free classrooms and allocating them as new lectures start. ```python def parse_schedule(schedule): events = [] for index, (start, end) in enumerate(schedule): events.append((start, \'start\', index)) events.append((end, \'end\', index)) return events def sort_events(events): return sorted(events, key=lambda x: (x[0], x[1] == \'start\')) def allocate_classrooms(events, num_lectures): classrooms = {} available_rooms = set() result = [-1] * num_lectures next_room = 0 for time, event, index in events: if event == \'start\': if available_rooms: room = available_rooms.pop() else: room = next_room next_room += 1 result[index] = room classrooms[room] = index elif event == \'end\': room = result[index] available_rooms.add(room) del classrooms[room] return result # Example usage schedule = [(30, 75), (0, 50), (60, 150)] events = parse_schedule(schedule) sorted_events = sort_events(events) classroom_allocations = allocate_classrooms(sorted_events, len(schedule)) print(\\"Classroom allocations:\\", classroom_allocations) ``` This example illustrates the process of handling lecture scheduling while ensuring no overlaps by allocating classrooms optimally.","solution":"from typing import List, Tuple def parse_schedule(schedule: List[Tuple[int, int]]) -> List[Tuple[int, str, int]]: events = [] for index, (start, end) in enumerate(schedule): events.append((start, \'start\', index)) events.append((end, \'end\', index)) return events def sort_events(events: List[Tuple[int, str, int]]) -> List[Tuple[int, str, int]]: return sorted(events, key=lambda x: (x[0], x[1] == \'start\')) def allocate_classrooms(events: List[Tuple[int, str, int]], num_lectures: int) -> List[int]: classrooms = {} available_rooms = set() result = [-1] * num_lectures next_room = 0 for time, event, index in events: if event == \'start\': if available_rooms: room = available_rooms.pop() else: room = next_room next_room += 1 result[index] = room classrooms[room] = index elif event == \'end\': room = result[index] available_rooms.add(room) del classrooms[room] return result # Example usage schedule = [(30, 75), (0, 50), (60, 150)] events = parse_schedule(schedule) sorted_events = sort_events(events) classroom_allocations = allocate_classrooms(sorted_events, len(schedule)) print(\\"Classroom allocations:\\", classroom_allocations)"},{"question":"# Longest Increasing Subsequence # Problem Statement You are given a sequence of integers. Your task is to find the length of the longest increasing subsequence. An increasing subsequence is a subset of the sequence where each element is larger than the previous one and all elements are in their original order from the sequence. For this task, implement the `LIS` class with the following methods: - `__init__(self, sequence: List[int])`: Initializes the object with the given sequence of integers. - `compute_lis(self) -> int`: Returns the length of the longest increasing subsequence. Input - A list of integers `sequence` representing the elements of the sequence. Output - Returns an integer representing the length of the longest increasing subsequence. # Example ```python sequence = [10, 9, 2, 5, 3, 7, 101, 18] lis_finder = LIS(sequence) assert lis_finder.compute_lis() == 4 # The LIS is [2, 3, 7, 101] sequence = [0, 1, 0, 3, 2, 3] lis_finder = LIS(sequence) assert lis_finder.compute_lis() == 4 # The LIS is [0, 1, 2, 3] sequence = [7, 7, 7, 7, 7, 7, 7] lis_finder = LIS(sequence) assert lis_finder.compute_lis() == 1 # The LIS is [7] ``` You need to complete the class `LIS` as per the specified requirements: ```python class LIS: def __init__(self, sequence: List[int]): # Initialize your data structures here self.sequence = sequence def compute_lis(self) -> int: # Implement the longest increasing subsequence algorithm pass ``` # Constraints - `1 <= len(sequence) <= 10^4` - `-10^9 <= sequence[i] <= 10^9` for any valid index `i` # Notes - Ensure your solution handles edge cases, such as sequences with all identical elements and sequences in descending order. - Optimize for both time and space, adhering to the constraints and expected complexity (preferably O(n log n) solution).","solution":"from typing import List import bisect class LIS: def __init__(self, sequence: List[int]): self.sequence = sequence def compute_lis(self) -> int: if not self.sequence: return 0 lis = [] for num in self.sequence: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Coding Assessment Question **Context**: You are given a directed graph represented as an adjacency list using a dictionary. The keys are the node values, and the values are lists containing the vertices that are directly reachable from the key vertex. Your goal is to perform a Depth-First Search (DFS) traversal starting from the given node. **Objective**: Implement a function that returns the order of nodes visited during a DFS traversal starting from the given start node. **Function Signature**: ```python def depth_first_search(graph: dict, start: int) -> list: ``` **Input**: * `graph` (dict): A dictionary where each key is a node value, and its value is a list of nodes directly reachable from the key node. * `start` (int): An integer specifying the start node for the traversal. **Output**: * `list`: A list of integers representing the order of nodes visited during the DFS traversal. **Constraints**: * The graph can have zero or more nodes. * Nodes are indexed with unique integers. **Requirements**: 1. If `graph` is empty, your function should raise a `ValueError` with the message `\\"graph cannot be empty\\"`. 2. If the `start` node is not present in the `graph`, raise a `ValueError` with the message `f\\"start node {start} is not present in the graph\\"`. **Examples**: ```python depth_first_search({1: [2, 3], 2: [4], 3: [5], 4: [], 5: []}, 1) # Output: [1, 2, 4, 3, 5] depth_first_search({1: [2, 3], 2: [4], 3: [5], 4: [6], 5: [], 6: []}, 1) # Output: [1, 2, 4, 6, 3, 5] depth_first_search({1: [2, 3], 2: [4], 3: [5], 4: [6], 5: [], 6: []}, 5) # Output: [5] depth_first_search({}, 1) # Raises ValueError: graph cannot be empty depth_first_search({1: [2, 3], 2: [4], 3: [5], 4: [6], 5: [], 6: []}, 7) # Raises ValueError: start node 7 is not present in the graph ```","solution":"def depth_first_search(graph: dict, start: int) -> list: if not graph: raise ValueError(\\"graph cannot be empty\\") if start not in graph: raise ValueError(f\\"start node {start} is not present in the graph\\") visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph[node])) # Push neighbors in reverse order to maintain correct order return visited"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},R={class:"card-container"},F={key:0,class:"empty-state"},O=["disabled"],P={key:0},z={key:1};function D(r,e,l,m,s,a){const p=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):d("",!0)]),t("div",R,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+u(s.searchQuery)+'". ',1)):d("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",z,"Loading...")):(n(),i("span",P,"See more"))],8,O)):d("",!0)])}const Y=h(N,[["render",D],["__scopeId","data-v-a3280491"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/11.md","filePath":"drive/11.md"}'),j={name:"drive/11.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{M as __pageData,V as default};
