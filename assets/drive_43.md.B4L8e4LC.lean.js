import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=c(k,[["render",E],["__scopeId","data-v-53f9535c"]]),O=JSON.parse('[{"question":"# Question: **AVL Tree Implementation** **Objective:** Write a class to manage an AVL Tree (Adelson-Velsky and Landis Tree). The class should support the insertion of nodes, re-balancing, and in-order traversal. **Function Specifications:** 1. `__init__(self)`: Initialize an empty AVL Tree. 2. `insert(self, key: int) -> None`: Insert a new `key` into the AVL Tree while maintaining the AVL balance property. 3. `in_order_traverse(self) -> List[int]`: Perform an in-order traversal of the AVL Tree and return the keys in a sorted list. **Input:** * The `insert` method will take an integer, `key`, which is to be inserted into the AVL Tree. **Output:** * The `in_order_traverse` method should return a list of keys in the tree in sorted order. **Constraints:** * Implement the AVL tree considering it will handle integers ranging from -10^5 to +10^5. * Trees can contain a maximum of 10^4 nodes. **Example:** ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(5) avl.insert(4) avl.insert(15) assert avl.in_order_traverse() == [4, 5, 10, 15, 20] ``` **Notes:** * Ensure the tree remains balanced by performing the necessary rotations during insertions. * Pay attention to the height and balance factor updates. * Avoid duplicate values in the tree by not performing any insertion if a key already exists in the tree. **What you need to do:** * Implement the AVL Tree with appropriate methods. * Test with different insertion orders to make sure the tree remains balanced and the in-order traversal produces sorted results.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node node.height = 1 + max(self._height(node.left), self._height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def in_order_traverse(self): res = [] self._in_order_traverse(self.root, res) return res def _in_order_traverse(self, node, res): if not node: return self._in_order_traverse(node.left, res) res.append(node.key) self._in_order_traverse(node.right, res)"},{"question":"**Shortest Path Analysis with Bellman-Ford Algorithm** Context: You are a software engineer working on a sophisticated navigation system which requires determining shortest paths on a graph representing a city road network. However, some roads have special conditions resulting in negative tolls at certain times. Problem: Implement the **Bellman-Ford algorithm** to not only find the shortest paths from a single source node to all other nodes but also to detect if any negative weight cycle exists in the graph. Function Definition: Write a function `bellman_ford(graph, source)` that: - Takes a dictionary representation of the graph where keys are node identifiers and values are dictionaries of adjacent nodes with edge weights. - Takes a string parameter `source` representing the starting node. - Returns: - A dictionary with the shortest path distances from the source to each node if no negative weight cycle is detected. - An empty dictionary if a negative weight cycle reachable from the source, making shortest path calculation infeasible. Expected Input: - `graph`: A dictionary representing a weighted, directed graph. ``` graph = { \'A\': {\'B\': 4, \'C\': 2}, \'B\': {\'C\': 3, \'D\': 2}, \'C\': {\'B\': 1, \'D\': 4, \'E\': 5}, \'D\': {\'E\': 1}, \'E\': {} } ``` - `source`: A string that represents the starting node (e.g., \'A\'). Expected Output: - A dictionary showing the shortest path from the source to every other node. ``` output = { \'A\': 0, \'B\': 3, \'C\': 2, \'D\': 5, \'E\': 6 } ``` Constraints: - Assume valid, non-null inputs. - The graph may contain negative weights but no negative weight cycles. Performance Requirements: - Complete within a reasonable time for graphs with up to 1000 vertices and 10,000 edges. ```python def bellman_ford(graph, source): # Your implementation here # Test Case graph = { \'A\': {\'B\': 4, \'C\': 2}, \'B\': {\'C\': 3, \'D\': 2}, \'C\': {\'B\': 1, \'D\': 4, \'E\': 5}, \'D\': {\'E\': 1}, \'E\': {} } source = \'A\' print(bellman_ford(graph, source)) # Expected Output: {\'A\': 0, \'B\': 3, \'C\': 2, \'D\': 5, \'E\': 6} ```","solution":"def bellman_ford(graph, source): # Step 1: Initialize distances from source to all other nodes as infinity # and distance to source itself as 0. distances = {node: float(\'inf\') for node in graph} distances[source] = 0 # Step 2: Relax all edges |V| - 1 times. for i in range(len(graph) - 1): for node in graph: for neighbor in graph[node]: if distances[node] + graph[node][neighbor] < distances[neighbor]: distances[neighbor] = distances[node] + graph[node][neighbor] # Step 3: Check for negative-weight cycles. for node in graph: for neighbor in graph[node]: if distances[node] + graph[node][neighbor] < distances[neighbor]: return {} return distances"},{"question":"# Question: You are given an array of integers and an integer k. Your task is to rotate the array to the right by k steps efficiently. You need to implement a function that modifies the array in place without using additional space for another array. Function Signature: ```python def rotate_array(array: List[int], k: int) -> None: ``` Input - `array`: A list of n integers (1 ≤ n ≤ 10^5). - `k`: An integer representing the number of steps to rotate the array (0 ≤ k ≤ 10^9). Output - The function should not return anything. It should modify the input array in-place. Constraints - Aim to achieve an optimal time complexity of O(n) and space complexity of O(1). - Handle edge cases such as k being larger than the length of the array, or when array is empty. Example ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7] rotate_array(arr, 3) print(arr) # Expected output: [5, 6, 7, 1, 2, 3, 4] # Example 2 arr = [-1, -100, 3, 99] rotate_array(arr, 2) print(arr) # Expected output: [3, 99, -1, -100] # Example 3 arr = [] rotate_array(arr, 1) print(arr) # Expected output: [] # Example 4 arr = [1] rotate_array(arr, 10) print(arr) # Expected output: [1] ``` Note: Use an in-place algorithm to avoid utilizing extra space. Focus on optimizing your solution for scalability and efficiency.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> None: Rotates the array to the right by k steps in-place. if not array: return n = len(array) k %= n # In case k is larger than array length # Function to reverse the elements of the array from start to end indices inclusive def reverse(arr: List[int], start: int, end: int): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the whole array reverse(array, 0, n - 1) # Reverse the first k elements reverse(array, 0, k - 1) # Reverse the remaining elements reverse(array, k, n - 1)"},{"question":"# Combination Sum Problem **Objective:** Write a function `combination_sum_unique` to find all unique combinations in a given list `candidates` where the candidate numbers sum to a given target. **Function Signature:** ```python def combination_sum_unique(candidates: List[int], target: int) -> List[List[int]]: ``` **Input:** * `candidates`: A list of positive integers `[c1, c2, ... , cn]` with no duplicates. 1 <= n <= 30 * `target`: A positive integer representing the target sum. 1 <= target <= 500 **Output:** * A list of lists containing unique combinations of numbers that sum to the target. Each combination should be in a non-decreasing order. **Constraints:** * The same number may be chosen from the candidates an unlimited number of times. * The solution set must not contain duplicate combinations. * All input numbers will be positive integers. **Example:** ```python candidates = [2, 3, 6, 7] target = 7 # Expected output # [ # [7], # [2, 2, 3] # ] ``` **Performance Requirements:** - Ensure your solution efficiently handles the worst-case scenarios within reasonable time and space limits. **Scenario:** You are an event organizer planning a fundraising event where people donate money in fixed denominations. You want to know all the possible ways in which the donations could sum up to a target amount to anticipate different scenarios. Write a function to help you plan these combinations.","solution":"from typing import List def combination_sum_unique(candidates: List[int], target: int) -> List[List[int]]: def backtrack(remain, combo, start): if remain == 0: ans.append(list(combo)) return elif remain < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remain - candidates[i], combo, i) combo.pop() candidates.sort() ans = [] backtrack(target, [], 0) return ans"},{"question":"**Question**: Implement a function that finds the first occurrence of a target value in a sorted array using binary search algorithm. If the value is not found, return -1. # Function Signature ```python def find_first_occurrence(array: List[int], target: int) -> int: ``` # Input 1. `array` (List[int]): A list of integers sorted in ascending order. 2. `target` (int): The target value to search for. # Output - Returns the index of the first occurrence of `target` in `array`. If `target` is not found, returns -1. # Constraints - The array length will not exceed (10^6). - The elements of the array will be within the range of -(10^9) to (10^9). # Example ```python assert find_first_occurrence([1, 2, 3, 4, 4, 4, 5, 6], 4) == 3 assert find_first_occurrence([1, 2, 3, 4, 4, 4, 5, 6], 7) == -1 assert find_first_occurrence([], 5) == -1 assert find_first_occurrence([1, 1, 1, 1], 1) == 0 ``` # Scenario Imagine you are building a book search function for an online library database. Users can search for a book by ISBN, and the database returns the books sorted by publication year in ascending order. Implementing this algorithm allows you to efficiently locate the first entry of a book published in a specific year. # Constraints - Consider the edge case where the array is empty. - Ensure boundary conditions are handled, e.g., when the target is at the start or end of the array. - Handle scenarios where the target is repeated multiple times, and only the first occurrence\'s index is returned. # Hints - You may modify the binary search approach to keep track of the first occurrence index during the search process.","solution":"def find_first_occurrence(array, target): Returns the index of the first occurrence of target in array. If target is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: result = mid right = mid - 1 # Continue to search on the left side elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"You are given an array of integers which you need to sort in increasing order using the Quick Sort algorithm. Implement a function `quick_sort(arr: List[int]) -> List[int]` that performs this task. # Function Signature ```python def quick_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers, where 1 <= len(arr) <= 10^5 and -10^6 <= arr[i] <= 10^6. # Output * Returns a list of integers sorted in ascending order. # Requirements - The algorithm should have an average-case time complexity of O(n log(n)). - You must implement the Quick Sort algorithm as described, ensuring it is in-place and handles edge cases appropriately. # Constraints - You are not allowed to use built-in sorting functions (like Python’s `sorted()`). - You must ensure that your solution avoids the worst-case time complexity as much as possible through efficient pivot selection. # Example ```python # Example 1 arr = [3, 6, 8, 10, 1, 2, 1] print(quick_sort(arr)) # Output: [1, 1, 2, 3, 6, 8, 10] # Example 2 arr = [1, 2, 3, 4, 5] print(quick_sort(arr)) # Output: [1, 2, 3, 4, 5] # Example 3 arr = [10, 7, 8, 9, 1, 5] print(quick_sort(arr)) # Output: [1, 5, 7, 8, 9, 10] ``` # Notes - You should handle edge cases such as an empty array or an array with identical elements. - Consider adding debug print statements to help trace the algorithm\'s execution during testing.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts the array in place using the Quick Sort algorithm and returns it. def _quick_sort(arr: List[int], low: int, high: int): if low < high: pivot_index = _partition(arr, low, high) _quick_sort(arr, low, pivot_index - 1) _quick_sort(arr, pivot_index + 1, high) def _partition(arr: List[int], low: int, high: int) -> int: # Select middle element as pivot to reduce chances of worst-case complexity mid = (low + high) // 2 pivot = arr[mid] arr[mid], arr[high] = arr[high], arr[mid] # Move pivot to end i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 _quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Coding Challenge: Improved Ternary Search Implementation Problem Statement Implement an efficient function to find a given key in a sorted array using an improved version of the ternary search algorithm. Your implementation must handle typical edge cases efficiently and include error handling for invalid inputs. Function Signature ```python def improved_ternary_search(arr: list[int], key: int) -> int: Improved Ternary Search to find the index of a key in a sorted array. Returns the index if the key is found, otherwise -1. :param arr: List[int] - A list of integers sorted in ascending order. :param key: int - An integer key to search for. :return: int - Index of key if found, otherwise -1. pass ``` Input - `arr`: A sorted list of integers. The length of the list `n` will be such that `0 <= n <= 10^6`. - `key`: An integer to be searched within the array. Output - An integer index of the `key` in the list if found, otherwise -1. Constraints & Considerations - The list `arr` may be empty. - The list `arr` may contain duplicate elements. - The algorithm must handle large input sizes efficiently. - Consider and handle edge cases (e.g., empty list, single-element list). Example ```python assert improved_ternary_search([1, 2, 3, 4, 5, 6], 4) == 3 assert improved_ternary_search([10, 15, 20, 25, 30, 35, 40], 15) == 1 assert improved_ternary_search([10, 15, 20, 25, 30, 35, 40], 100) == -1 assert improved_ternary_search([], 10) == -1 ``` Notes - Make sure your function handles edge cases properly. - Ensure that your solution has a time complexity of O(log₃(N)). - Take care to optimize any possible performance bottlenecks.","solution":"def improved_ternary_search(arr: list[int], key: int) -> int: Improved Ternary Search to find the index of a key in a sorted array. Returns the index if the key is found, otherwise -1. :param arr: List[int] - A list of integers sorted in ascending order. :param key: int - An integer key to search for. :return: int - Index of key if found, otherwise -1. def ternary_search(l, r): if l > r: return -1 third = (r - l) // 3 mid1 = l + third mid2 = r - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(l, mid1 - 1) elif key > arr[mid2]: return ternary_search(mid2 + 1, r) else: return ternary_search(mid1 + 1, mid2 - 1) if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise ValueError(\\"The input array must be a list of integers.\\") if not isinstance(key, int): raise ValueError(\\"The key must be an integer.\\") return ternary_search(0, len(arr) - 1)"},{"question":"Selection Sort Visualization and Verbose Mode As a software developer, you are assigned to implement an enhanced version of the selection sort algorithm. Your task is to write a function, `selection_sort`, which not only sorts an array but also provides a step-by-step trace of the algorithm’s execution for educational purposes. Function Signature: ```python def selection_sort(arr: List[int], simulation: bool=False) -> List[int]: ``` Input: * `arr` - A list of integers to be sorted. * `simulation` - A boolean flag that, when set to `True`, will print the array state at each iteration of outer loop processing. Output: * Return a list of integers sorted in ascending order. Constraints: * The array can have up to 10^4 elements. * The elements of the array will be integers in the range of -10^9 to 10^9. * With `simulation` set to `True`, ensure that each iteration\'s state is printed in the format: `iteration {iteration_number}: {array_state}`. Example: ```python input_arr = [64, 25, 12, 22, 11] sorted_arr = selection_sort(input_arr, simulation=True) ``` Expected Output: ```shell iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 ``` Additionally, the sorted array to return should be: ```python [11, 12, 22, 25, 64] ``` Your solution should be efficient enough to handle the given constraints effectively.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool=False) -> List[int]: n = len(arr) for i in range(n): if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Question: Reversing a String with Various Methods Scenario You are tasked with implementing a set of utility functions to reverse strings using different methodologies. Your solutions should demonstrate an understanding of various algorithmic approaches and their trade-offs. Task Implement the following string reversal functions: 1. `recursive_reverse(s)`: Uses recursion to reverse the string. - **Input**: A string `s`. - **Output**: The reversed string. - **Constraints**: - Avoid excessive slicing for very large inputs. - **Edge Cases**: Handle empty strings and single-character strings. 2. `iterative_reverse(s)`: Uses an iterative two-pointer technique to reverse the string in place. - **Input**: A string `s`. - **Output**: The reversed string. 3. `pythonic_reverse(s)`: Utilizes Python’s built-in features to reverse the string. - **Input**: A string `s`. - **Output**: The reversed string. 4. `ultra_pythonic_reverse(s)`: Uses Python’s slicing mechanism to reverse the string. - **Input**: A string `s`. - **Output**: The reversed string. # Function Signatures ```python def recursive_reverse(s: str) -> str: pass def iterative_reverse(s: str) -> str: pass def pythonic_reverse(s: str) -> str: pass def ultra_pythonic_reverse(s: str) -> str: pass ``` # Constraints - The input string `s` will have a length up to `10^6` characters. - Optimize for performance and handle edge cases such as empty strings and single-character strings. # Examples ```python # Example usage print(recursive_reverse(\\"hello\\")) # Output: \\"olleh\\" print(iterative_reverse(\\"world\\")) # Output: \\"dlrow\\" print(pythonic_reverse(\\"Python\\")) # Output: \\"nohtyP\\" print(ultra_pythonic_reverse(\\"reverse\\")) # Output: \\"esrever\\" ``` Provide implementations for all four functions.","solution":"def recursive_reverse(s: str) -> str: Recursively reverses a string. if len(s) <= 1: return s return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: Uses an iterative two-pointer technique to reverse the string. s_list = list(s) left, right = 0, len(s_list) - 1 while left < right: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \'\'.join(s_list) def pythonic_reverse(s: str) -> str: Utilizes Python built-in reversed() and join(). return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s: str) -> str: Uses Python slicing to reverse the string. return s[::-1]"},{"question":"- Bogo Sort Enhancement Context You have been provided with the highly inefficient Bogo Sort algorithm. Despite its impracticality in real-world applications, it serves as a good exercise to understand brute-force methods and randomness in algorithms. Task Write a function to implement a modified version of Bogo Sort that includes a mechanism to cap the number of shuffles to prevent infinite loops. If the maximum number of allowed shuffles is reached and the array is still not sorted, the function should return `None`. Function Signature ```python def bogo_sort_with_cap(arr, max_shuffles): Sort the array using a capped Bogo Sort. Parameters: arr (list): A list of sortable elements. max_shuffles (int): The maximum number of shuffles to perform if not sorted. Returns: list or None: A sorted list if sorting is successful within the shuffle limit, otherwise None. ``` Input * `arr`: A list of elements to be sorted. * `max_shuffles`: An integer representing the maximum number of times the array can be shuffled. Output * Returns the sorted list if sorted within the given shuffle limit. * Returns `None` if the array could not be sorted within the shuffle limit. Constraints * You may assume the elements in the array are comparable. * `max_shuffles` will be a non-negative integer. Examples ```python # Example 1 print(bogo_sort_with_cap([4, 3, 2, 1], 10000)) # Output: [1, 2, 3, 4] # Example 2 print(bogo_sort_with_cap([3, 1, 4, 2], 5)) # Output: None (with a high probability) ``` Notes - Consider edge cases such as empty arrays, arrays with one element, and arrays already sorted.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort_with_cap(arr, max_shuffles): Sort the array using a capped Bogo Sort. Parameters: arr (list): A list of sortable elements. max_shuffles (int): The maximum number of shuffles to perform if not sorted. Returns: list or None: A sorted list if sorting is successful within the shuffle limit, otherwise None. attempts = 0 while attempts < max_shuffles: if is_sorted(arr): return arr random.shuffle(arr) attempts += 1 return None"},{"question":"You are provided with two functions designed to convert integers to different base representations and vice versa. Your task is to extend and optimize these functions to handle a wider range of scenarios, while maintaining or improving their current performance. # Task 1. **Enhance the `int_to_base` function** to handle bases higher than 36 and negative bases. 2. **Enhance the `base_to_int` function** to handle bases higher than 36 and negative bases. # Function Signatures ```python def int_to_base(num, base): Convert an integer to a string in the specified base. :param num: int - The number to convert. :param base: int - The base to use for the conversion (can be negative or > 36). :return: str - The base representation of the number as a string. pass def base_to_int(str_to_convert, base): Convert a string in the specified base to an integer. :param str_to_convert: str - The string representation of the number in the specified base. :param base: int - The base used in the string representation (can be negative or > 36). :return: int - The converted integer. pass ``` # Input and Output Format * Input for `int_to_base(num, base)`: - `num` (int): The integer number to be converted. - `base` (int): The base to convert the number into. Can be a negative integer or larger than 36. * Output for `int_to_base(num, base)`: - A string representing the number in the specified base. * Input for `base_to_int(str_to_convert, base)`: - `str_to_convert` (str): The string representation of the number in the given base. - `base` (int): The base of the string representation. Can be a negative integer or larger than 36. * Output for `base_to_int(str_to_convert, base)`: - An integer representing the converted base-10 number. # Constraints - Base should always be an integer and not equal to 0 or 1. - The input number and base can be both positive and negative. - For bases higher than 36, you may use any combination of characters for representation. - Handle invalid inputs and edge cases gracefully. # Example ```python # Examples for int_to_base print(int_to_base(255, 16)) # Output: \'FF\' print(int_to_base(-255, 16)) # Output: \'-FF\' print(int_to_base(31, 2)) # Output: \'11111\' print(int_to_base(100, -10)) # Custom scenario with negative base # Examples for base_to_int print(base_to_int(\'FF\', 16)) # Output: 255 print(base_to_int(\'-FF\', 16)) # Output: -255 print(base_to_int(\'11111\', 2)) # Output: 31 print(base_to_int(\'custom_string\', -10)) # Custom scenario with negative base ``` Good luck, and ensure to test your functions thoroughly!","solution":"def int_to_base(num, base): Convert an integer to a string in the specified base. if num == 0: return \\"0\\" is_negative = num < 0 num = abs(num) digits = [] while num: num, remainder = divmod(num, abs(base)) if remainder < 10: digits.append(chr(48 + remainder)) # 48 is ASCII \'0\' else: digits.append(chr(55 + remainder)) # 55 + 10 = 65 is ASCII \'A\' if len(digits) == 0: digits.append(\\"0\\") if is_negative: if base < 0: digits.append(\'-\') else: digits.append(\'-\') return \'\'.join(reversed(digits)) def base_to_int(str_to_convert, base): Convert a string in the specified base to an integer. str_to_convert = str_to_convert.strip().upper() is_negative = str_to_convert.startswith(\'-\') if is_negative: str_to_convert = str_to_convert[1:] num = 0 power = 1 for char in reversed(str_to_convert): if \'0\' <= char <= \'9\': num += (ord(char) - 48) * power # 48 is ASCII \'0\' elif \'A\' <= char <= \'Z\': num += (ord(char) - 55) * power # 55 + 10 = 65 is ASCII \'A\' power *= abs(base) return -num if is_negative else num"},{"question":"Suppose you are building a validation tool for a communication protocol where messages must have a specific bit structure. You need to check if a given integer has an alternating bit pattern (i.e., no two adjacent bits are the same). Write a function `check_alternating_bits` that accepts a positive integer and returns `True` if its binary representation has alternating bits, and `False` otherwise. # Function Signature ```python def check_alternating_bits(n: int) -> bool: pass ``` # Input - `n`: (1 ≤ n ≤ 2^31 - 1) - a positive integer. # Output - Returns a boolean: `True` if the integer has alternating bits, `False` otherwise. # Constraints - Time complexity should be efficient enough to handle up to the maximum 32-bit integer. # Example ```python print(check_alternating_bits(5)) # True, binary representation: 101 print(check_alternating_bits(7)) # False, binary representation: 111 print(check_alternating_bits(11)) # False, binary representation: 1011 print(check_alternating_bits(10)) # True, binary representation: 1010 ``` # Notes You need to design your solution considering: - Edge cases such as the smallest and largest possible values. - Efficient handling and performance of the solution. - Clear and concise code implementation.","solution":"def check_alternating_bits(n: int) -> bool: This function checks if a given integer has an alternating bit pattern. Parameters: n (int): A positive integer (1 ≤ n ≤ 2^31 - 1) Returns: bool: True if the integer has alternating bits, False otherwise # Generate a bitmask by shifting n right by 1 bit and XOR it with the original number n xor = n ^ (n >> 1) # If the result contains only 1s, then it should be a sequence of consecutive 1s # (e.g., 1111... for which all bits are alternating). # Check if this result & (result + 1) is zero, meaning it\'s in the form of 1111... return (xor & (xor + 1)) == 0"},{"question":"# Priority Queue Challenge You are tasked with enhancing the functionality of a priority queue implemented using a linear array. The provided Priority Queue class supports basic operations such as push and pop, aligning elements based on their priority values. To further test your understanding and ability to work with algorithms and data structures, you\'ll need to implement additional functionality for the priority queue. Specifically, you will implement a method to directly change the priority value of an existing item and ensure that the queue maintains its properties. Function Signature ```python def change_priority(self, item, new_priority): Change the priority of an existing item. :param item: The item whose priority needs to be changed. :param new_priority: The new priority value. ``` Requirements 1. The target item must first be located within the priority queue. 2. Upon locating the item, its priority should be updated and the queue should be reordered to maintain the correct priority order. 3. This operation should ideally maintain efficient time complexity principles, aiming not to exceed O(n) in overall complexity. Constraints * The item to be changed will always exist in the priority queue. Input / Output Examples: ```python pq = PriorityQueue([4, 3, 5], [2, 6, 1]) pq.change_priority(4, 7) print(pq) # Output should reflect the updated order according to modified priorities ``` Additional Notes * If `change_priority` is called with an empty queue, ensure it doesn\'t break the program. * Aim for a clear, efficient, and correct implementation that demonstrates sound understanding of the priority queue mechanism and its properties.","solution":"class PriorityQueue: def __init__(self, items=[], priorities=[]): Initialize a priority queue with items and their corresponding priorities. self.queue = list(zip(items, priorities)) self.queue.sort(key=lambda x: x[1]) def push(self, item, priority): Insert an item with the given priority into the queue. self.queue.append((item, priority)) self.queue.sort(key=lambda x: x[1]) def pop(self): Remove and return the item with the highest priority (lowest priority number). return self.queue.pop(0) def change_priority(self, item, new_priority): Change the priority of an existing item. Args: item: The item whose priority needs to be changed. new_priority: The new priority value. for index, (current_item, current_priority) in enumerate(self.queue): if current_item == item: self.queue[index] = (item, new_priority) break self.queue.sort(key=lambda x: x[1]) def __str__(self): Return a string representation of the priority queue. return str(self.queue)"},{"question":"Anagram Checker with Optimization An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. Your task is to implement an optimized version of the anagram checker. # Function Signature ```python def is_anagram_optimized(s: str, t: str) -> bool: ``` # Input - `s` and `t`, two strings containing only lowercase alphabets (`1 <= len(s), len(t) <= 10^5`). # Output - Returns `True` if `t` is an anagram of `s`, otherwise `False`. # Constraints - The strings contain only lowercase English letters (\'a\' to \'z\'). - Your solution should consider edge cases such as: - Empty strings. - Strings of different lengths. - Very long strings (up to (10^5) characters). # Performance Requirements - The solution should have a time complexity of (O(n)), where (n) is the length of the strings. - The solution should utilize (O(1)) additional space beyond the input constraints. # Example ```python # Example 1 s = \\"anagram\\" t = \\"nagaram\\" print(is_anagram_optimized(s, t)) # Output: True # Example 2 s = \\"rat\\" t = \\"car\\" print(is_anagram_optimized(s, t)) # Output: False # Example 3 s = \\"\\" t = \\"\\" print(is_anagram_optimized(s, t)) # Output: True ``` # Explanation - **Example 1**: \\"anagram\\" and \\"nagaram\\" have the same character counts for each letter. - **Example 2**: \\"rat\\" and \\"car\\" do not have the same character counts. - **Example 3**: Two empty strings are considered anagrams as they contain the same characters (none). # Implementation Note You should implement the function `is_anagram_optimized` without using dictionaries for counting frequencies to ensure (O(1)) additional space for the frequency count. Instead, utilize fixed-size arrays considering the constraint of lowercase English letters.","solution":"def is_anagram_optimized(s: str, t: str) -> bool: if len(s) != len(t): return False # Initialize frequency counters for both strings freq_s = [0] * 26 freq_t = [0] * 26 # Populate the frequency counters for char in s: freq_s[ord(char) - ord(\'a\')] += 1 for char in t: freq_t[ord(char) - ord(\'a\')] += 1 # Compare the frequency counters return freq_s == freq_t"},{"question":"# Pigeonhole Sorting Algorithm Given an array of integers, implement the pigeonhole sort algorithm to sort the array. Ensure your implementation is efficient and handles edge cases effectively. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input * An unsorted list of integers `arr` with values ranging from Min to Max. * `1 <= len(arr) <= 1000` * `-1000 <= arr[i] <= 1000` Output * A sorted list of integers. Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([1, 4, 1, 2, 7, 5, 2]) == [1, 1, 2, 2, 4, 5, 7] assert pigeonhole_sort([-2, -6, -3, -8, -4]) == [-8, -6, -4, -3, -2] assert pigeonhole_sort([42, 42, 42]) == [42, 42, 42] ``` Constraints * Use an auxiliary array for the pigeonholes. * Your solution should run in O(n + Range) time complexity, where `n` is the number of elements in the input list and `Range` is the difference between the maximum and minimum values. * Handle negative integers appropriately.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 # Create holes list of empty lists holes = [[] for _ in range(size)] # Populate the holes for num in arr: holes[num - min_val].append(num) # Collect sorted elements from holes sorted_arr = [] for hole in holes: sorted_arr.extend(hole) return sorted_arr"},{"question":"# RSA Key Generation and Message Encryption/Decryption As a software developer, you are asked to implement a secure messaging protocol using RSA encryption. Your tasks are to generate RSA keys, encrypt messages, and decrypt messages. Each task is divided into function implementations with specific requirements. Tasks: 1. **Generate RSA Keys** Implement the function `generate_key(k: int, seed: int = None) -> (int, int, int)`: - Input: `k` - number of bits for the modulus (n). `seed` - optional random seed for reproducibility. - Output: A tuple (n, e, d) - RSA modulus, encryption exponent, and decryption exponent respectively. 2. **Encrypt a Message** Implement the function `encrypt(data: int, e: int, n: int) -> int`: - Input: `data` - the message to be encrypted as an integer. `e` - the encryption exponent. `n` - the RSA modulus. - Output: Encrypted message as an integer. 3. **Decrypt a Message** Implement the function `decrypt(data: int, d: int, n: int) -> int`: - Input: `data` - the encrypted message as an integer. `d` - the decryption exponent. `n` - the RSA modulus. - Output: Decrypted message as an integer. Use the following guidelines: - Ensure that your key generation algorithm follows the RSA protocol described above. - The encryption and decryption should correctly use the provided exponents and modulus. - Consider edge cases where the prime generation might fail due to identical or unsuitable primes. Constraints: - The bit size `k` will typically be in the range 16 to 2048. - Ensure the prime numbers generated are indeed prime and not the same. - You may use Python\'s `random` module for generating prime numbers. The solution should demonstrate the student\'s understanding of RSA encryption, key generation, and basic error handling for encrypting and decrypting messages.","solution":"import random from sympy import isprime def generate_key(k: int, seed: int = None) -> (int, int, int): if seed is not None: random.seed(seed) # Function to generate a k-bit prime number def generate_prime(bits): while True: prime_candidate = random.getrandbits(bits) if isprime(prime_candidate): return prime_candidate # Ensure we have different primes p and q p = generate_prime(k // 2) q = generate_prime(k // 2) while p == q: q = generate_prime(k // 2) # Compute n and phi(n) n = p * q phi = (p - 1) * (q - 1) # Choose an encryption exponent e e = 65537 # Common choice for e # Ensure that e and phi(n) are coprime def gcd(a, b): while b != 0: a, b = b, a % b return a while gcd(e, phi) != 1: e = random.randrange(2, phi) # Compute the decryption exponent d def modinv(a, m): m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 d = modinv(e, phi) return n, e, d def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Simplifying Unix-style Paths Scenario: You are tasked with designing a function to process filesystem paths as entered by a user in a Unix-like operating system. The objective is to return the simplest form (canonical path) of the input path. Task: Implement the following function: ```python def simplify_path(path: str) -> str: Given an absolute path for a file (Unix-style), simplify it. :param path: An absolute Unix-style file path. :type path: str :return: The simplified canonical path. :rtype: str ``` Expected Input and Output Formats: **Input**: - `path`: a string representing an absolute path (e.g., \\"/home/\\", \\"/a/./b/../../c/\\"). **Output**: - A string representing the simplified canonical path. Constraints: - The input string will always start with a \'/\'. - The path only contains lowercase letters, \'/\', \'.\' and \'..\'. - The length of the path will be in the range [1, 3000]. Performance Requirements: - The solution should efficiently handle input paths of up to 3000 characters in linear time. Examples: ```python assert simplify_path(\\"/home/\\") == \\"/home\\" assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" assert simplify_path(\\"/../\\") == \\"/\\" assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" assert simplify_path(\\"/a/../../b/../c//.//\\") == \\"/c\\" assert simplify_path(\\"/a//b////c/d//././/..\\") == \\"/a/b/c\\" ```","solution":"def simplify_path(path: str) -> str: Given an absolute path for a file (Unix-style), simplify it. :param path: An absolute Unix-style file path. :type path: str :return: The simplified canonical path. :rtype: str path_components = path.split(\'/\') stack = [] for component in path_components: if component == \'..\': if stack: stack.pop() elif component and component != \'.\': stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"# Coding Assessment: Circular Queue Implementation **Scenario**: Consider you are tasked with implementing a circular queue for a library’s cataloging system. A circular queue uses a fixed-size array and wraps around when it reaches the end to maximize space utilization. **Objective**: Implement a circular queue using an array with the following operations: 1. `enqueue(value)`: Add an item to the rear of the queue. 2. `dequeue()`: Remove the front item from the queue and return it. 3. `peek()`: Return the front item without removing it. 4. `is_empty()`: Return `True` if the queue is empty, else `False`. 5. `is_full()`: Return `True` if the queue is full, else `False`. 6. `size()`: Return the number of items in the queue. **Requirements**: * An array with a fixed capacity. * Circular behavior should be implemented: once the end of the array is reached, wrap around to the beginning. * Efficient handling of all operations. **Constraints**: * The maximum capacity of the queue is 1000. * All operations should have O(1) time complexity. **Function Definitions**: The class `CircularQueue` should be defined with the following methods: * `def __init__(self, capacity: int)` * `def enqueue(self, value: int) -> None` * `def dequeue(self) -> int` * `def peek(self) -> int` * `def is_empty(self) -> bool` * `def is_full(self) -> bool` * `def size(self) -> int` **Example**: ```python cq = CircularQueue(5) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.dequeue() # returns 1 cq.peek() # returns 2 cq.size() # returns 2 cq.is_empty() # returns False cq.is_full() # returns False ``` **Performance Requirements**: All operations should be efficient, providing constant-time complexity. **Hint**: Use modulo operation to handle the circular behavior of the queue.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.head = -1 self.tail = -1 self.count = 0 def enqueue(self, value: int) -> None: if self.is_full(): raise OverflowError(\\"Queue is full\\") if self.is_empty(): self.head = 0 self.tail = (self.tail + 1) % self.capacity self.queue[self.tail] = value self.count += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.head] self.queue[self.head] = None if self.head == self.tail: self.head = self.tail = -1 else: self.head = (self.head + 1) % self.capacity self.count -= 1 return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.head] def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.capacity def size(self) -> int: return self.count"},{"question":"# Question: Linked List Operations You are provided with the skeleton of a doubly linked list and a singly linked list. Implement the following operations for both types of linked lists: 1. `insert_at_head(value)`: Insert a new node with the given value at the head of the list. 2. `insert_at_tail(value)`: Insert a new node with the given value at the tail of the list. 3. `delete(value)`: Delete the first node with the specified value from the list. 4. `find(value) -> bool`: Return `True` if a node with the given value exists in the list, otherwise return `False`. # Constraints - **Input**: Your functions will receive integer values within the range -10^6 to 10^6. - **Output**: Ensure your functions match the expected outputs as described in their purpose. - **Performance Requirements**: * Efficient handling of insertion and deletion. * Minimized traversal time where possible. ```python class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): # Implement this method pass def insert_at_tail(self, value): # Implement this method pass def delete(self, value): # Implement this method pass def find(self, value) -> bool: # Implement this method pass class SinglyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value): # Implement this method pass def insert_at_tail(self, value): # Implement this method pass def delete(self, value): # Implement this method pass def find(self, value) -> bool: # Implement this method pass ``` # Example: ```python dll = DoublyLinkedList() dll.insert_at_head(5) dll.insert_at_tail(10) assert dll.find(5) == True dll.delete(5) assert dll.find(5) == False sll = SinglyLinkedList() sll.insert_at_head(1) sll.insert_at_tail(2) assert sll.find(1) == True sll.delete(1) assert sll.find(1) == False ``` Ensure your implementations handle all edge cases and optimize for performance where possible.","solution":"class DoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = self.Node(value) if not self.head: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = self.Node(value) if not self.tail: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def find(self, value) -> bool: current = self.head while current: if current.value == value: return True current = current.next return False class SinglyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def insert_at_head(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def insert_at_tail(self, value): new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete(self, value): current = self.head if current and current.value == value: self.head = current.next return prev = None while current and current.value != value: prev = current current = current.next if current: prev.next = current.next def find(self, value) -> bool: current = self.head while current: if current.value == value: return True current = current.next return False"},{"question":"Merge String Verification **Background**: You are given a string `s` and two other strings `part1` and `part2`. You need to determine if `s` can be formed by interleaving `part1` and `part2` such that the characters in `part1` and `part2` remain in order in `s`. **Objective**: Implement a function `is_merge_dp(s, part1, part2)` that efficiently determines if `s` can be formed by merging `part1` and `part2` while maintaining their character order. Function Signature: ```python def is_merge_dp(s: str, part1: str, part2: str) -> bool: pass ``` Input: - `s` (string): The target string to be formed. - `part1` (string): The first part of the string. - `part2` (string): The second part of the string. Output: - Return `True` if `s` can be formed by interleaving `part1` and `part2`, otherwise return `False`. Constraints: - `0 <= len(s), len(part1), len(part2) <= 100`. - All string inputs will consist only of lowercase English letters. Example: ```python assert is_merge_dp(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert is_merge_dp(\\"abcd\\", \\"abc\\", \\"d\\") == True assert is_merge_dp(\\"abcde\\", \\"aec\\", \\"bd\\") == False ``` **Performance Requirement**: - The implementation should be efficient, ideally O(m * n) where m and n are the lengths of `part1` and `part2` respectively. **Scenario**: Consider you are a software engineer at a company developing a text editor, and you are tasked to implement a feature that checks whether a document can be created by merging content from two source documents without altering the order of characters within each document.","solution":"def is_merge_dp(s, part1, part2): len_s = len(s) len_p1 = len(part1) len_p2 = len(part2) if len_s != len_p1 + len_p2: return False dp = [[False] * (len_p2 + 1) for _ in range(len_p1 + 1)] dp[0][0] = True for i in range(1, len_p1 + 1): dp[i][0] = dp[i - 1][0] and part1[i - 1] == s[i - 1] for j in range(1, len_p2 + 1): dp[0][j] = dp[0][j - 1] and part2[j - 1] == s[j - 1] for i in range(1, len_p1 + 1): for j in range(1, len_p2 + 1): dp[i][j] = (dp[i - 1][j] and part1[i - 1] == s[i + j - 1]) or (dp[i][j - 1] and part2[j - 1] == s[i + j - 1]) return dp[len_p1][len_p2]"},{"question":"# Linked List k-th to Last Element Problem Statement: You are given a singly linked list and an integer `k`. Implement a function that returns the k-th to the last element of the linked list. A singly linked list is a data structure consisting of nodes where each node contains a piece of data and a pointer/reference to the next node in the sequence. Identify and return the k-th to the last node\'s value. If `k` is out of bounds of the list, your function should return `None`. Expected Function Signature: ```python def kth_to_last_optimized(head: \\"Node\\", k: int) -> \\"Node\\": pass ``` Inputs: - `head`: The head node of the singly linked list. - `k`: Represents which element from the end to return (0-based index). Output: - Return the value of the k-th to last node if found, otherwise return `None`. Constraints: - The linked list contains between 0 and 10^5 nodes. - `k` is a non-negative integer. Example: ```python class Node(): def __init__(self, val=None): self.val = val self.next = None # Creating a linked list: A -> B -> C -> D -> E a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e assert kth_to_last_optimized(a, 0).val == \\"E\\" # E is the 1st from the last assert kth_to_last_optimized(a, 1).val == \\"D\\" # D is the 2nd from the last assert kth_to_last_optimized(a, 4).val == \\"A\\" # A is the 5th from the last assert kth_to_last_optimized(a, 5) == None # Out of bounds ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last_optimized(head: \\"Node\\", k: int) -> \\"Node\\": if head is None: return None fast = head slow = head # Move fast k nodes ahead for _ in range(k): if fast.next is None: return None fast = fast.next # Move both fast and slow pointers until fast reaches the end while fast.next: fast = fast.next slow = slow.next return slow if fast else None"},{"question":"# Problem Description You are given a binary tree, and your task is to write a function that returns a list of the tree\'s nodes\' values in in-order traversal order. # Function Signature ```python def inorder_traversal(root: Node) -> List[int]: pass ``` # Input - `root`: A `Node` object representing the root of the binary tree. Each node has the following properties: - `val` (int): The value of the node. - `left` (Node or None): The left child of the node. - `right` (Node or None): The right child of the node. # Output - Return a list of integers representing the node values in in-order traversal order. # Constraints 1. The number of nodes in the tree will be in the range `[0, 10^4]`. 2. Node values will be unique integers. # Examples Example 1: ```python # Input: # The tree is: # 1 # # 2 # / # 3 root = Node(1, None, Node(2, Node(3))) # Output: [1, 3, 2] assert inorder_traversal(root) == [1, 3, 2] ``` Example 2: ```python # Input: # The tree is: # 5 # / # 3 7 # / # 2 4 8 root = Node(5, Node(3, Node(2), Node(4)), Node(7, None, Node(8))) # Output: [2, 3, 4, 5, 7, 8] assert inorder_traversal(root) == [2, 3, 4, 5, 7, 8] ``` # Note - You can choose to implement the traversal either iteratively or recursively. - Make sure to handle edge cases such as empty trees properly.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[Node]) -> List[int]: Returns the inorder traversal of the binary tree\'s nodes values. def helper(node: Optional[Node], result: List[int]): if node is not None: helper(node.left, result) result.append(node.val) helper(node.right, result) result = [] helper(root, result) return result"},{"question":"# String Multiplication with Constraints Given two non-negative integers num1 and num2 represented as strings, write a function `multiply(num1: str, num2: str) -> str` to return the product of `num1` and `num2` as a string. **Constraints**: * The length of both `num1` and `num2` is less than 110. * Both `num1` and `num2` contain only digits 0-9. * Both `num1` and `num2` do not contain any leading zeros (except for the number \\"0\\"). **Detailed Requirements**: 1. You must not use any built-in BigInteger library or convert the inputs directly to an integer. 2. Handle edge cases such as multiplication of long numbers, and numbers that could produce zeros as results (e.g., multiplication by zero). **Function Signature**: ```python def multiply(num1: str, num2: str) -> str: pass ``` # Example: ```python # Example 1: multiply(\\"2\\", \\"3\\") -> \\"6\\" # Example 2: multiply(\\"123\\", \\"456\\") -> \\"56088\\" ``` **Implementation Details**: 1. Treat each character in num1 and num2 as digits and perform multiplication similar to the manual method. 2. Consider implementing the solution by iterating through each combination of digits from the two strings, calculate partial results with correct positional weights, and sum them up. 3. Ensure to handle carrying over digits during partial summations.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" n1, n2 = len(num1), len(num2) result = [0] * (n1 + n2) for i in range(n1 - 1, -1, -1): for j in range(n2 - 1, -1, -1): mul = (ord(num1[i]) - ord(\'0\')) * (ord(num2[j]) - ord(\'0\')) sum_ = mul + result[i + j + 1] result[i + j + 1] = sum_ % 10 result[i + j] += sum_ // 10 while result[0] == 0: result.pop(0) return \'\'.join(map(str, result))"},{"question":"# Coding Assignment Question **Scenario**: You are required to implement a function that evaluates a mathematical expression provided in postfix notation using a stack. Postfix notation (also known as Reverse Polish Notation) is a mathematical notation where every operator follows all of its operands. **Function Implementation Details**: 1. **Function Name**: `evaluate_postfix_expression` 2. **Inputs**: - A single list of strings representing the postfix expression. Each string can be either an operand (integer) or an operator (`+`, `-`, `*`, `/`). 3. **Output**: - An integer representing the result of the postfix expression. 4. **Constraints**: - The expression is guaranteed to be valid. - Divisions are integer divisions and should truncate toward zero. - The stack should be implemented using the `ArrayStack` or `LinkedListStack` class provided in the code snippets. You are free to choose which implementation to use. - You must handle edge cases like division by zero appropriately by raising an `ArithmeticError`. **Example**: ```python # Example Input: expression = [\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"] # Example Output: 9 # Explanation: # The input \\"2 1 + 3 *\\" translates to \\"(2 + 1) * 3\\" => 3 * 3 = 9 ``` **Requirements**: - Use the stack ADT provided in the snippets. - Ensure your solution handles all standard arithmetic operations and edge cases.","solution":"class ArrayStack: Stack implementation using a Python list (array). def __init__(self): self._data = [] def is_empty(self): return len(self._data) == 0 def push(self, item): self._data.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self._data.pop() def top(self): if self.is_empty(): raise IndexError(\\"top from empty stack\\") return self._data[-1] def evaluate_postfix_expression(expression): Evaluate a mathematical expression in postfix notation. Args: expression (list of str): The postfix expression. Returns: int: The result of the expression. stack = ArrayStack() for token in expression: if token in (\'+\', \'-\', \'*\', \'/\'): right = stack.pop() left = stack.pop() if token == \'+\': result = left + right elif token == \'-\': result = left - right elif token == \'*\': result = left * right elif token == \'/\': if right == 0: raise ArithmeticError(\\"division by zero\\") result = int(left / right) # Integer division stack.push(result) else: stack.push(int(token)) return stack.pop()"},{"question":"# Insertion Sort Implementation Challenge Imagine you are a software engineer tasked with enhancing a sorting module within a data processing system. Your goal is to implement a function using the Insertion Sort algorithm. It should be capable of sorting an array or list efficiently under certain constraints. Function Specification Create a function `insertion_sort` that takes in two parameters: 1. `arr` (List[int]): A list of integers to be sorted. 2. `simulation` (bool): A boolean flag indicating if the function should print the array at each iteration of the sorting process. The function should sort the list in-place and return the sorted list. If the `simulation` flag is `True`, the function should print the state of the list after each insertion operation. Input and Output - **Input**: - `arr`: A list of integers that may be in any order, e.g., `[4, 3, 2, 1]` - `simulation`: A boolean value `True` or `False` - **Output**: - A sorted list in ascending order Constraints - `1 <= len(arr) <= 1000` - `-10^5 <= arr[i] <= 10^5` Examples ```python # Example 1 input_array = [4, 3, 2, 1] print(insertion_sort(input_array, simulation=False)) # Output: [1, 2, 3, 4] # Example 2 input_array = [10, -1, 2, 5, 0] print(insertion_sort(input_array, simulation=True)) # Simulation output: # iteration 0 : [10, -1, 2, 5, 0] # iteration 1 : [-1, 10, 2, 5, 0] # iteration 2 : [-1, 2, 10, 5, 0] # iteration 3 : [-1, 2, 5, 10, 0] # iteration 4 : [-1, 2, 5, 10, 0] # Final output: [-1, 0, 2, 5, 10] ``` Note: Ensure to handle edge cases where the array might be empty or already sorted effectively. Implement the function `insertion_sort` that adheres to the above specification.","solution":"def insertion_sort(arr, simulation): Sorts an array in place using the insertion sort algorithm. Prints the array at each iteration if simulation is True. Parameters: - arr (List[int]): List of integers to sort. - simulation (bool): Flag to print the array at each iteration. Returns: - List[int]: Sorted list. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\'iteration {i} : {arr}\') return arr"},{"question":"Minimum Spanning Tree with Kruskal\'s Algorithm As a network architect, you are given the responsibility of designing a new connected network for a small town. The town can be represented by a connected, undirected graph with nodes representing locations and weighted edges representing the cost of laying optical fiber between locations. You need to implement Kruskal\'s algorithm to find the Minimum Spanning Tree (MST) and minimize the cost of laying the fibers. **Function Signature**: ```python def kruskal(vertex_count: int, edges: List[Edge]) -> int: pass ``` # Requirements Write a function `kruskal` that: 1. Takes an integer `vertex_count` representing the number of vertices. 2. Takes a list `edges` of `Edge` objects, where each `Edge` is defined as: ```python class Edge: def __init__(self, source: int, target: int, weight: int): self.source = source self.target = target self.weight = weight ``` 3. Returns an integer representing the sum of the weights in the Minimum Spanning Tree. # Input - `vertex_count` (2 ≤ vertex_count ≤ 10^4): An integer representing the number of vertices. - `edges` (1 ≤ |edges| ≤ 5 * 10^4): A list of edges where each edge is represented by the `Edge` class. # Output - Return an integer which is the sum of the weights of the edges in the Minimum Spanning Tree (MST). # Example ```python edges = [ Edge(1, 2, 3), Edge(1, 3, 8), Edge(2, 4, 5), Edge(3, 4, 2), Edge(3, 5, 4), Edge(4, 5, 6) ] vertex_count = 5 print(kruskal(vertex_count, edges)) # Output should be 14 ``` # Constraints 1. The graph is connected. 2. The graph is undirected. 3. Edge weights are positive integers. # Notes - Ensure to implement the Disjoint Set (Union-Find) data structure to manage the connected components. - Handle edge cases such as graphs with repetitive edge weights effectively. - Performance is critical; ensure the sorting of edges and the Union-Find operations are optimized. You may assume that the provided list of edges is valid unless stated otherwise.","solution":"from typing import List class Edge: def __init__(self, source: int, target: int, weight: int): self.source = source self.target = target self.weight = weight def kruskal(vertex_count: int, edges: List[Edge]) -> int: # Helper functions for Union-Find parent = list(range(vertex_count)) rank = [0] * vertex_count def find(v): if parent[v] != v: parent[v] = find(parent[v]) return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 # Sort edges by weight edges.sort(key=lambda edge: edge.weight) mst_weight = 0 mst_edges = 0 for edge in edges: if find(edge.source) != find(edge.target): union(edge.source, edge.target) mst_weight += edge.weight mst_edges += 1 if mst_edges == vertex_count - 1: break return mst_weight"},{"question":"# Problem: Find k-th to Last Element in a Singly Linked List Context You are given the task to implement a function that finds the k-th to last element of a singly linked list. This is a common problem in interview questions that assesses your understanding of linked lists and pointers. Task Given a singly linked list, implement a function `kth_to_last_optimized(head: Node, k: int) -> Node` which returns the k-th to last node. You should use an optimal method without additional storage apart from a few pointers. Specifications * The function should: 1. Take a head node of a singly linked list and an integer k as inputs. 2. Return the k-th to last node. 3. Raise an `IndexError` if k is not valid (e.g., k is greater than the length of the list). ```python class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last_optimized(head: Node, k: int) -> Node: # Implementation here pass ``` Input * `head`: Head node of the singly linked list. * `k`: An integer representing the k-th to last position. Output * Returns the k-th to last node in the list. Constraints * The list size is n (1 ≤ n ≤ 10^5). * 0 ≤ k < n Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1) Example Consider the linked list A -> B -> C -> D -> E and k = 2 The output should be the node with value \'D\'. ```python a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e result = kth_to_last_optimized(a, 2) print(result.val) # Output should be \\"D\\" ``` # Note - Ensure that you handle edge cases gracefully. - Do not use additional storage structures like lists or dictionaries; focus on using pointers efficiently.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last_optimized(head: Node, k: int) -> Node: if not head: raise IndexError(\\"The list is empty\\") fast = head slow = head # Move fast k steps ahead for _ in range(k): if not fast: raise IndexError(\\"k is greater than the length of the list\\") fast = fast.next # Move both fast and slow until fast reaches the end while fast and fast.next: fast = fast.next slow = slow.next # If fast moves k steps (k < n) and reaches the end if not fast: raise IndexError(\\"k is greater than the length of the list\\") # slow is now pointing to the k-th to last element return slow"},{"question":"# Problem: Implement an Efficient Sorting Algorithm You are required to write an efficient function `improved_cycle_sort(arr)` that enhances the provided Cycle Sort implementation to handle specific practical constraints and includes necessary improvements. Function Signature: ```python def improved_cycle_sort(arr: List[int]) -> List[int]: pass ``` Input: - The function takes a list of integers `arr` (0 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6). Output: - The function should return a list of integers sorted in ascending order. Constraints: - Minimize the number of writing operations to the array. Performance Requirements: - Even though Cycle Sort generally operates in O(N^2) time, try to optimize and handle small datasets efficiently. Example Usage: ```python arr = [3, 1, 2, 4, 6, 5] print(improved_cycle_sort(arr)) # Output: [1, 2, 3, 4, 5, 6] arr = [40, 30, 20, 10] print(improved_cycle_sort(arr)) # Output: [10, 20, 30, 40] arr = [1, 1, 1, 1, 1] print(improved_cycle_sort(arr)) # Output: [1, 1, 1, 1, 1] arr = [] print(improved_cycle_sort(arr)) # Output: [] ``` Requirements: 1. Ensure the function is efficient for small datasets. 2. Handle edge cases and duplicates effectively. 3. Avoid unnecessary memory allocation and stick to in-place sorting as much as possible. Background Context: Cycle Sort is chosen here due to its minimal write operations feature. Consider the nature of the input array and enhance the cycle sort to optimize performance effectively while maintaining minimal writes to the array.","solution":"def improved_cycle_sort(arr): Sorts the array using an optimized version of cycle sort. writes = 0 for cycleStart in range(0, len(arr) - 1): item = arr[cycleStart] # Find where to put the item. pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycleStart: continue # Otherwise, put the item there or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycleStart: pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Sorting Algorithm: Selection Sort **Context**: You are given an array of integers which you need to sort in ascending order using the Selection Sort algorithm. Your task is to implement the function to sort the array and, optionally, print the state of the array after each iteration. **Function Signature**: ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` **Input**: * `arr`: A list of integers, e.g., `[64, 25, 12, 22, 11]` * `simulation` (optional, default is `False`): A boolean flag indicating whether to print the state of the array after each iteration. **Output**: * The function should return the list sorted in ascending order. **Constraints**: * The array `arr` can contain up to `10^3` integers. * Each integer in `arr` can range from `-10^3` to `10^3`. **Additional Notes**: * You should print the iteration number followed by the state of the array, if `simulation` is `True`. * The initial state (considered before any sorting starts) should be printed as iteration `0`. **Example**: ```python arr = [64, 25, 12, 22, 11] print(selection_sort(arr, simulation=True)) ``` Output should be: ``` iteration 0: 64 25 12 22 11 iteration 1: 11 25 12 22 64 iteration 2: 11 12 25 22 64 iteration 3: 11 12 22 25 64 iteration 4: 11 12 22 25 64 [11, 12, 22, 25, 64] ```","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) if simulation: print(f\\"iteration 0: {\' \'.join(map(str, arr))}\\") for i in range(n): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"iteration {i + 1}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Problem: Enhanced Hash Table with Quadratic Probing The provided code implements a hash table that uses linear probing for collision resolution and resizes when it becomes too full. Your task is to extend this hash table implementation to use quadratic probing instead of linear probing to resolve collisions. Quadratic probing helps in dispersing the clustering effect that linear probing can cause. Core Requirements: 1. Implement quadratic probing instead of linear probing for collision handling. 2. Ensure that the resizing mechanism is maintained and functions correctly with quadratic probing. Quadratic Probing: The hash table should probe the index in the following sequence when resolving collisions: ``` i = 0, 1, 2, 3, ..., k hash(key, i) = (hash(key) + i^2) % size ``` where `i` is the number of attempts to find an empty slot. Your implementation should maintain efficient insertion, deletion, and lookup operations. # Function Signature ```python class QuadraticProbingHashTable(HashTable): def _rehash(self, old_hash, attempt): # Implement quadratic probing here def put(self, key, value): # Override to use _rehash method with quadratic probing def get(self, key): # Override to use _rehash method with quadratic probing # Ensure other inherited methods work correctly with quadratic probing ``` # Input 1. Your class implementation. 2. Normal hash table operations to insert, delete, and retrieve key-value pairs. # Output 1. Implemented class with the necessary method overrides and enhancements. # Constraints - Initially, the hash table will have a size of 11. - Resize the hash table when it reaches 2/3 of its current capacity. - Each key in the hash table will be a non-negative integer. # Example Usage ```python qht = QuadraticProbingHashTable() qht.put(1, \\"one\\") qht.put(12, \\"twelve\\") # This should cause a collision and be resolved through quadratic probing assert qht.get(1) == \\"one\\" assert qht.get(12) == \\"twelve\\" qht.del_(12) assert qht.get(12) is None ``` # Performance Requirements - Average O(1) time complexity for insert, get, and delete operations, assuming minimal collisions. - Handle edge cases where multiple collisions could occur.","solution":"class QuadraticProbingHashTable: def __init__(self, initial_capacity=11): self.size = initial_capacity self.table = [None] * self.size self.count = 0 def _hash(self, key): return key % self.size def _rehash(self, old_hash, attempt): return (old_hash + attempt ** 2) % self.size def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: key, value = item self.put(key, value) def put(self, key, value): if self.count > (2 / 3) * self.size: self._resize() hash_value = self._hash(key) attempt = 0 while self.table[hash_value] is not None and self.table[hash_value][0] != key: attempt += 1 hash_value = self._rehash(self._hash(key), attempt) if self.table[hash_value] is None: self.count += 1 self.table[hash_value] = (key, value) def get(self, key): hash_value = self._hash(key) attempt = 0 while self.table[hash_value] is not None: if self.table[hash_value][0] == key: return self.table[hash_value][1] attempt += 1 hash_value = self._rehash(self._hash(key), attempt) return None def del_(self, key): hash_value = self._hash(key) attempt = 0 while self.table[hash_value] is not None: if self.table[hash_value][0] == key: self.table[hash_value] = None self.count -= 1 return attempt += 1 hash_value = self._rehash(self._hash(key), attempt)"},{"question":"# Question: Removing Specific Values from a Linked List Given a singly linked list, implement a function to remove all nodes containing a specific value. Function Signature ```python def remove_value(head, value): Removes all nodes containing \'value\' from the given linked list. Parameters: head (Node): Head node of the singly linked list. value (int/str): The value to be removed from the linked list. Returns: Node: The head node of the modified linked list. ``` Requirements 1. **Input**: * `head`: The head node of a singly linked list (guarantee: non-empty linked list). * `value`: The value of the nodes that need to be removed (int or str). 2. **Output**: * Returns the head node of the modified linked list without any nodes containing the specified value. 3. **Constraints**: * The function should handle lists of arbitrary length. * The function should work efficiently, aiming to minimize the number of traversals and additional space usage. 4. **Performance**: * Aim for (O(N)) time complexity. * Strive for (O(1)) space complexity beyond the input list. Context Removing specific values efficiently can help in numerous data clean-up and preprocessing tasks. This is particularly important in systems where memory constraint is critical. Example ```python # Define the linked list: 1 -> 2 -> 2 -> 3 -> 4 -> 2 head = Node(1) head.next = Node(2) head.next.next = Node(2) head.next.next.next = Node(3) head.next.next.next.next = Node(4) head.next.next.next.next.next = Node(2) # Remove value \'2\' new_head = remove_value(head, 2) # Expected linked list: 1 -> 3 -> 4 print_linked_list(new_head) # Should print: 1 -> 3 -> 4 ```","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_value(head, value): Removes all nodes containing \'value\' from the given linked list. Parameters: head (Node): Head node of the singly linked list. value (int/str): The value to be removed from the linked list. Returns: Node: The head node of the modified linked list. # Create a dummy node that points to the head, to handle deletions at the head dummy = Node(0) dummy.next = head current = dummy # Traverse the list while current.next is not None: if current.next.value == value: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"# Question You are tasked with implementing an advanced stack data structure that always maintains its elements in descending order. The goal is for the top of the stack to always hold the largest value, while the bottom holds the smallest. The primary operations include: - **push**: Adds an element such that the stack maintains its descending order. - **pop**: Removes and returns the top element (the largest). - **peek**: Returns the top element without removing it. - **size**: Returns the number of elements in the stack. - **is_empty**: Checks if the stack has no elements. Implement the class `OrderedStack`: ```python class OrderedStack: def __init__(self): Initializes an empty stack. pass def is_empty(self): Returns True if the stack is empty, False otherwise. pass def push(self, item): Pushes an item onto the stack, maintaining descending order. If the stack is empty or the item is larger than the top, simply push the item. Otherwise, use a temporary stack to find the correct position for the new item. pass def pop(self): Removes and returns the top item from the stack. Raises IndexError if the stack is empty. pass def peek(self): Returns the top item from the stack without removing it. Raises IndexError if the stack is empty. pass def size(self): Returns the number of items currently in the stack. pass ``` **Constraints**: - Do not use any libraries or built-in Python data structures like `heapq` for maintaining order. - Your implementation should aim for clarity and conciseness. - Consider edge cases when the stack is empty. **Example**: ```python s = OrderedStack() s.push(5) s.push(2) s.push(8) print(s.peek()) # should print 8 print(s.pop()) # should return 8 print(s.pop()) # should return 5 print(s.size()) # should return 1 print(s.is_empty()) # should return False ``` Complete the `OrderedStack` class so that it meets these requirements.","solution":"class OrderedStack: def __init__(self): Initializes an empty stack. self.stack = [] def is_empty(self): Returns True if the stack is empty, False otherwise. return len(self.stack) == 0 def push(self, item): Pushes an item onto the stack, maintaining descending order. If the stack is empty or the item is larger than the top, simply push the item. Otherwise, use a temporary stack to find the correct position for the new item. if self.is_empty() or item >= self.peek(): self.stack.append(item) else: temp_stack = [] while not self.is_empty() and self.peek() > item: temp_stack.append(self.pop()) self.stack.append(item) while temp_stack: self.stack.append(temp_stack.pop()) def pop(self): Removes and returns the top item from the stack. Raises IndexError if the stack is empty. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): Returns the top item from the stack without removing it. Raises IndexError if the stack is empty. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): Returns the number of items currently in the stack. return len(self.stack)"},{"question":"# Matrix Inversion Problem Context In linear algebra, matrix inversion is a crucial operation for solving systems of linear equations, computing pseudoinverses, and performing various transformations. You are required to implement a function that takes an invertible ( n times n ) matrix and returns its inverse. Task Write a function `invert_matrix(m: List[List[float]]) -> List[List[float]]` that accepts a square matrix and returns its inverse. Your implementation must utilize the provided algorithm that combines calculations of the matrix of minors, cofactors, adjugate, and scaling by the determinant. # Function Signature ```python def invert_matrix(m: List[List[float]]) -> List[List[float]]: ``` # Input - `m`: A list of lists representing a square matrix ( n times n ), where ( 2 leq n leq 10 ). - Each element in `m` is a float or integer. # Output - A list of lists representing the inverted matrix. - Return `[[ -1 ]]` for non-square matrices or invalid inputs. - Return `[[ -2 ]]` for singular matrices. # Constraints - Do not use external libraries like NumPy. - The matrix will only contain valid numbers (no NaN or infinities). # Example ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Output # [[0.6, -0.7],[-0.2, 0.4]] matrix_invalid = [ [1, 2, 3], [4, 5, 6] ] print(invert_matrix(matrix_invalid)) # Output # [[-2]] ``` # Notes 1. You MUST handle the determinant and matrix properties as per the above code snippet. 2. Ensure your implementation does not exceed acceptable time and space limits. 3. Proper input validation and error handling are crucial to avoid invalid calculations.","solution":"from typing import List def determinant(matrix: List[List[float]], n: int) -> float: if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): minor = [[matrix[i][j] for j in range(n) if j != c] for i in range(1, n)] det += ((-1) ** c) * matrix[0][c] * determinant(minor, n - 1) return det def get_matrix_of_minors(matrix: List[List[float]], n: int) -> List[List[float]]: minors = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): minor = [[matrix[x][y] for y in range(n) if y != j] for x in range(n) if x != i] minors[i][j] = determinant(minor, n - 1) return minors def get_cofactor_matrix(matrix: List[List[float]], n: int) -> List[List[float]]: minors = get_matrix_of_minors(matrix, n) cofactors = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): cofactors[i][j] = minors[i][j] * ((-1) ** (i + j)) return cofactors def transpose(matrix: List[List[float]], n: int) -> List[List[float]]: return [[matrix[j][i] for j in range(n)] for i in range(n)] def invert_matrix(m: List[List[float]]) -> List[List[float]]: if not all(len(row) == len(m) for row in m) or len(m) == 0: return [[-1]] n = len(m) det = determinant(m, n) if det == 0: return [[-2]] cofactor_matrix = get_cofactor_matrix(m, n) adjugate = transpose(cofactor_matrix, n) inverse = [[adjugate[i][j] / det for j in range(n)] for i in range(n)] return inverse"},{"question":"# Min Heap Operations: Insertion and Deletion **Context**: You are tasked with implementing a min heap data structure that efficiently supports dynamic data management, allowing for quick insertion of elements and removal of the smallest element. **Problem Statement**: Complete the implementation of a `BinaryHeap` class that provides the following methods: 1. `insert(val)`: Inserts a new value `val` into the heap. 2. `remove_min()`: Removes and returns the smallest element from the heap. **Requirements**: - The heap should maintain its properties after any insertion or deletion. - The input will be a series of operations to be performed on the heap. **Input Format**: ```plaintext - The first line will contain a single integer `n`, the number of operations. - The next `n` lines will contain one of two types of operations: - \\"insert <value>\\" to insert a new integer into the heap. - \\"remove_min\\" to remove and return the smallest element. ``` **Output Format**: - For each \\"remove_min\\" operation, output the smallest element. **Constraints**: - The number of operations `n` will be at most 10^5. - The values inserted into the heap will be integers between -10^9 and 10^9. **Example**: ```plaintext Input: 7 insert 5 insert 3 insert 17 insert 10 remove_min remove_min remove_min Output: 3 5 10 ``` **Explanation**: - The heap starts empty. - After `insert 5`, the heap is: [5] - After `insert 3`, the heap is: [3, 5] - After `insert 17`, the heap is: [3, 5, 17] - After `insert 10`, the heap is: [3, 5, 17, 10] - After the first `remove_min`, the heap becomes [5, 10, 17] and the output is 3. - After the second `remove_min`, the heap becomes [10, 17] and the output is 5. - After the third `remove_min`, the heap becomes [17] and the output is 10. Implement the `BinaryHeap` class as described and ensure the heap maintains its properties throughout the operations.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val): heapq.heappush(self.heap, val) def remove_min(self): if len(self.heap) == 0: return None return heapq.heappop(self.heap)"},{"question":"You are given a sorted array of integers and a target value. Your task is to write a function `improved_jump_search(arr, target)` that implements an optimized version of the Jump Search algorithm to find the index of the `target` in the array. If the target does not exist, return -1. # Input * `arr`: A list of integers `[a1, a2, ..., an]` (1 ≤ |arr| ≤ 10^6 ; -10^9 ≤ ai ≤ 10^9) * `target`: An integer `x` to search for in the array (-10^9 ≤ target ≤ 10^9) # Output * An integer representing the index of the target element in the array or -1 if the target is not present. # Constraints 1. The array is sorted in non-decreasing order. 2. You must optimize the block size based on the length of the array and analyze its performance. # Example ```python def improved_jump_search(arr, target): # Your code here # Example 1 arr1 = [1, 3, 4, 7, 9, 10] target1 = 4 print(improved_jump_search(arr1, target1)) # Output: 2 # Example 2 arr2 = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] target2 = 15 print(improved_jump_search(arr2, target2)) # Output: -1 ``` # Performance Requirements * The function should efficiently handle the maximum constraints. * The time complexity of your solution should be O(√n) and space complexity should remain O(1). # Hints 1. Use the square root of the array\'s length as the initial step size for jumps. 2. Ensure edge cases are handled, such as when the target is outside the bounds of the array.","solution":"import math def improved_jump_search(arr, target): Performs an improved jump search on the sorted array to find the target element. Parameters: arr (list): A sorted list of integers. target (int): The target integer to search for. Returns: int: The index of the target if found, else -1. n = len(arr) step = int(math.sqrt(n)) # Optimal step size prev = 0 # Finding the block where element is present (if it is present) while prev < n and arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in the block beginning with prev while prev < min(step, n): if arr[prev] == target: return prev prev += 1 return -1"},{"question":"# Context: You are working on a networking project where data packets need to be transmitted from one server to another along the maximum possible data routes. The network is represented as a directed graph, where the nodes are servers and edges represent bandwidth capacities. You need to compute the maximum data transmission capacity from the main server (source) to the target server (sink). # Problem: Write a function `maximum_flow_bfs(adjacency_matrix)` that, given an n*n adjacency matrix representation of a directed graph, computes the maximum possible flow from the first node (source) to the last node (sink). # Input: - `adjacency_matrix: List[List[int]]`: An n*n adjacency matrix where `adjacency_matrix[i][j]` is the capacity of the edge from node `i` to node `j`. The capacity will be a non-negative integer. # Output: - Return an integer representing the maximum flow from the source node (first node) to the sink node (last node). # Constraints: - ( 1 leq n leq 500 ): the number of vertices in the graph. - All capacities (elements in the adjacency matrix) are non-negative integers. # Example: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] # maximum flow: 23 print(maximum_flow_bfs(graph)) # Output: 23 ``` # Notes: - You may assume that there is a path from the source to the sink in the given graph. - Implement the solution using a Breadth-First Search (BFS) strategy to find augmenting paths. - Focus on edge cases such as non-existent paths, zero capacity edges, and the graph with minimum and maximum capacities. Write an efficient and clean solution to assure its execution within constraints.","solution":"from collections import deque def bfs(residual_graph, source, sink, parent): visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_graph[u]): if visited[v] == False and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(adjacency_matrix): source = 0 sink = len(adjacency_matrix) - 1 parent = [-1] * len(adjacency_matrix) max_flow = 0 residual_graph = [row[:] for row in adjacency_matrix] while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are given a collection of distinct integers. Your task is to write a function that computes all possible permutations of these numbers. Furthermore, implement a function that provides these permutations in an iterative manner to control memory usage better. # Function Signature: ```python def generate_permutations(elements: List[int]) -> List[List[int]]: Function to return all permutations of the input list of distinct integers. def generate_permutations_iter(elements: List[int]) -> Iterator[List[int]]: Function to return an iterator that yields each permutation of the input list of distinct integers. ``` # Input: * A list of distinct integers `elements` with length `n`. (1 <= n <= 9 to avoid factorial explosion). # Output: * For `generate_permutations`: A list of lists, where each inner list is a unique permutation of the input list. * For `generate_permutations_iter`: An iterator that yields each permutation as a list. # Constraints: * You must use a recursive approach for `generate_permutations`. * You must use an iterative approach for `generate_permutations_iter`. # Examples: ```python generate_permutations([1, 2, 3]) # Output: [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] perm_iterator = generate_permutations_iter([1, 2]) next(perm_iterator) # Output: [1, 2] next(perm_iterator) # Output: [2, 1] ``` # Additional Information: 1. Make sure to handle edge cases, such as empty input lists and single-element lists, correctly. 2. Aim for clean and readable code with comments explaining the logic.","solution":"from typing import List, Iterator def generate_permutations(elements: List[int]) -> List[List[int]]: Function to return all permutations of the input list of distinct integers. if len(elements) <= 1: return [elements] perms = [] for i, elem in enumerate(elements): rest_elements = elements[:i] + elements[i+1:] for p in generate_permutations(rest_elements): perms.append([elem] + p) return perms def generate_permutations_iter(elements: List[int]) -> Iterator[List[int]]: Function to return an iterator that yields each permutation of the input list of distinct integers. stack = [(elements[:], [])] while stack: elements, path = stack.pop() if not elements: yield path else: for i in range(len(elements)): stack.append((elements[:i]+elements[i+1:], path+[elements[i]]))"},{"question":"# Challenging Coding Assessment **Objective:** Implement a function to add one to a numeric value represented as an array of its digits efficiently. **Problem Statement:** You are given a non-negative integer represented as a list of digits, with the most significant digit at the head of the list. Write a function `plus_one` that adds one to the number and returns the result as a list of digits. The list does not contain any leading zero, except the number 0 itself. **Input Format:** ```plaintext A list of integers `digits` where 1 <= len(digits) <= 10^5 and 0 <= digits[i] <= 9. ``` **Output Format:** ```plaintext A list of integers representing the number after adding one. ``` **Function Signature:** ```python def plus_one(digits: List[int]) -> List[int]: ``` **Constraints:** * Your solution should run in O(n) time complexity where n is the length of the digits list. * Optimize for an in-place solution with O(1) space complexity if possible. **Example:** ```python 1. Input: [1, 2, 3] Output: [1, 2, 4] 2. Input: [4, 3, 2, 1] Output: [4, 3, 2, 2] 3. Input: [9, 9, 9] Output: [1, 0, 0, 0] ``` **Explanation:** * In the first example, 123 + 1 becomes 124. * In the second example, 4321 + 1 becomes 4322. * In the third example, 999 + 1 becomes 1000. # Instructions: * Handle possible carry-over when adding one to the last digit. * Ensure the implementation is efficient and optimally handles edge cases. * Avoid making unnecessary copies of the list to adhere to performance constraints.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Returns the list of digits representing the number after adding one. n = len(digits) # Traverse the list from the end to the start for i in range(n-1, -1, -1): # If the digit is less than 9, just add 1 and return the list if digits[i] < 9: digits[i] += 1 return digits # Otherwise, we set the digit to 0 and carry over the 1 to next digit digits[i] = 0 # If all digits are 9\'s, the result would be 1000...00 (n+1 digits) return [1] + [0] * n"},{"question":"# **Coding Assessment: Single Number Finding** Background You are given an array of integers where each element appears exactly three times, except for one element which appears exactly once. Your task is to find and return that single element. This problem can be optimally solved using bit manipulation techniques to ensure a linear runtime and constant space complexity. Requirements * Your algorithm should have a linear runtime complexity (O(n)). * You should not use additional memory (i.e., no extra space other than a few integer variables). Function Signature ```python def find_single_number(nums: List[int]) -> int: pass ``` Input * **nums**: A list of integers where every integer appears exactly three times except for one. Output * An integer that appears only once in the list. Constraints * The length of the list is at least 1. * Each element in the list is an integer fitting within the standard 32-bit signed integer range. Example ```python # Example 1 nums = [2, 2, 3, 2] assert find_single_number(nums) == 3 # Example 2 nums = [0, 1, 0, 1, 0, 1, 99] assert find_single_number(nums) == 99 # Example 3 nums = [30000, 500, 100, 30000, 100, 30000, 100] assert find_single_number(nums) == 500 ``` Explanation The provided input list `nums` is guaranteed to have just one number that appears once, and all other numbers appear exactly three times. Your task is to leverage bitwise operations efficiently to determine that single number.","solution":"def find_single_number(nums): Returns the element that appears only once in the input list where every other element appears exactly three times. ones, twos = 0, 0 for num in nums: # When num comes: # Update \'twos\' with bits that occur twice twos |= ones & num # XOR operation to \'ones\' to get bits that occur once ones ^= num # common_bit_mask has bits which appear three times common_bit_mask = ~(ones & twos) # Remove bits from \'ones\' and \'twos\' which appear three times ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# Scenario You are working on a library management system and need an efficient way to organize books based on their unique IDs, which are large non-negative integers. Since the volume of books is immense, a high-performance sorting algorithm is required that can handle large datasets effectively. # Objective Write a function `library_sort(book_ids: List[int]) -> List[int]` that sorts a given list of book IDs using the Radix Sort algorithm. # Input and Output Formats: - **Input**: A list of non-negative integers `book_ids` representing the IDs of the books. - **Output**: A new list of non-negative integers sorted in ascending order. # Constraints: - 1 <= len(book_ids) <= 10^6 - 0 <= book_ids[i] <= 10^9 # Notes: - Ensure your implementation handles very large numbers and large datasets efficiently. - Make sure that any zero-padding issue for numbers with different digit lengths is managed correctly. - Consider the stability of your sorting approach to maintain the relative order of book IDs with the same value. # Example: ```python from typing import List def library_sort(book_ids: List[int]) -> List[int]: # Your implementation here using radix sort pass # Example usage book_ids = [170, 45, 75, 90, 802, 24, 2, 66] sorted_book_ids = library_sort(book_ids) print(sorted_book_ids) # Output should be [2, 24, 45, 66, 75, 90, 170, 802] ``` # Test Cases: ```python assert library_sort([3, 1, 2]) == [1, 2, 3] assert library_sort([432, 432, 432, 432]) == [432, 432, 432, 432] assert library_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert library_sort([]) == [] ``` # Performance: - Ensure that your algorithm efficiently sorts lists up to 10^6 elements, each with values up to 10^9. - Maintain a balance between execution time and memory usage to handle large datasets effectively.","solution":"from typing import List def counting_sort_for_radix(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(len(arr)): arr[i] = output[i] def library_sort(book_ids: List[int]) -> List[int]: if len(book_ids) == 0: return book_ids max_val = max(book_ids) exp = 1 while max_val // exp > 0: counting_sort_for_radix(book_ids, exp) exp *= 10 return book_ids"},{"question":"# Question: Frequency Counter Implementation You are tasked with finding the frequency of each unique element in a list of integers. This will help you in statistical analysis and data processing where counting elements is crucial. Write a function `frequency_counter` that takes a list of integers and returns a dictionary where the keys are the unique integers from the list and the values are their respective frequencies. Function Signature: ```python def frequency_counter(input_list: list) -> dict: ``` Input: * `input_list`: A list of integers, where each integer can occur multiple times. Output: * A dictionary with each unique integer from the list as keys and their counts as values. Constraints: * The elements in the list can be negative or positive integers. * The input list can have up to 10^6 elements. * The elements in the list can range between -10^9 to 10^9. Example: ```python assert frequency_counter([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert frequency_counter([5, 4, 5, 6, 7, 6, 5, 4, 8, 9, 8]) == {4: 2, 5: 3, 6: 2, 7: 1, 8: 2, 9: 1} assert frequency_counter([]) == {} assert frequency_counter([1, 1, 1, 1, 1]) == {1: 5} ``` Make sure your implementation can handle edge cases and performs efficiently for large inputs.","solution":"def frequency_counter(input_list: list) -> dict: Returns a dictionary with the frequency of each unique element in the input list. frequency_dict = {} for elem in input_list: if elem in frequency_dict: frequency_dict[elem] += 1 else: frequency_dict[elem] = 1 return frequency_dict"},{"question":"# Question: **Comb Sort Implementation and Analysis** Context: Comb Sort is a relatively straightforward sorting algorithm designed to improve upon Bubble Sort by starting with larger gaps between compared elements. This allows the algorithm to eliminate large amounts of data more quickly. By the time the gap is reduced to 1, many elements should already be in their correct place, making a final pass similar to Bubble Sort more efficient. Task: Write a function `enhanced_comb_sort(arr: List[int]) -> List[int]` that implements the Comb Sort algorithm to sort an array of integers in ascending order. Additionally, ensure the function is optimized with a variable shrink factor and gracefully handles edge cases. Requirements: 1. Your function should work for arrays of various sizes, including empty arrays and arrays with a single element. 2. Apply a variable shrink factor that can be tuned to test different values. For example, try values from 1.2 to 1.5. 3. Implement checks to optimize performance when the array is nearly sorted. 4. Don\'t use any built-in sorting functions. Input: - A list of integers: `[arr]` where `1 <= len(arr) <= 10^6` and `-10^9 <= arr[i] <= 10^9`. Output: - A list of integers sorted in ascending order. Constraints: - Optimize for the best possible time complexity. - Ensure the function runs within a reasonable time frame for large inputs. Example: ```python def enhanced_comb_sort(arr: List[int]) -> List[int]: # Your implementation here. pass # Example: arr = [4, 1, 3, 9, 7] print(enhanced_comb_sort(arr)) # Output: [1, 3, 4, 7, 9] ``` Explanation: - The function should take in the unsorted array `[4, 1, 3, 9, 7]` and return the sorted array `[1, 3, 4, 7, 9]` following the Comb Sort algorithm and its optimizations. Testing: You should test your implementation on various inputs to ensure it\'s handling edge cases effectively and performing optimally on larger inputs.","solution":"from typing import List def enhanced_comb_sort(arr: List[int], shrink_factor: float = 1.3) -> List[int]: Perform Comb Sort on the input list and return the sorted list. n = len(arr) gap = n sorted = False while not sorted: # Shrink the gap for the next comb gap = int(gap // shrink_factor) if gap <= 1: gap = 1 sorted = True # Assuming array is sorted, but will verify by comparing elements for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Question: Two Sum with Multiple Methods You are given a list of integers `numbers` sorted in ascending order, and a target integer `target`. Your task is to write a function `find_indices` that returns the list of indices of two numbers such that they add up to the `target`. There are three methods you should implement within `find_indices`: 1. **find_indices_binary_search**: Using binary search, implement a method to find the indices of two numbers that sum up to the target. 2. **find_indices_hash_table**: Using a hash table, implement a method to find the indices of two numbers that sum up to the target. 3. **find_indices_two_pointers**: Using two pointers, implement a method to find the indices of two numbers that sum up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Note that your returned answers (both index1 and index2) are not zero-based. **Function Signature**: ```python def find_indices(numbers: List[int], target: int) -> List[int]: pass ``` **Input**: * `numbers` - A list of integers, sorted in ascending order. * `target` - An integer target number to be achieved by summing two distinct numbers from the list. **Output**: * Return a list with two integers: `[index1, index2]` where `numbers[index1-1] + numbers[index2-1] == target`. **Constraints**: * Length of the list `numbers` is within [2, 10^4]. * Each element in `numbers` is within the range [-10^9, 10^9]. * The input list `numbers` is sorted in non-decreasing order. * There is exactly one solution. **Example**: ```python numbers = [2, 7, 11, 15] target = 9 Output: [1, 2] # because numbers[0] + numbers[1] = 2 + 7 = 9 ``` **Notes**: * Implement all three methods within the main function `find_indices`. * Ensure each method is tested for performance and correctness. * Handle all edge cases mentioned in the task description.","solution":"from typing import List, Tuple def find_indices_binary_search(numbers: List[int], target: int) -> List[int]: import bisect for i in range(len(numbers)): complement = target - numbers[i] idx = bisect.bisect_left(numbers, complement, i + 1) if idx < len(numbers) and numbers[idx] == complement: return [i + 1, idx + 1] return [] def find_indices_hash_table(numbers: List[int], target: int) -> List[int]: num_to_index = {} for i, num in enumerate(numbers): complement = target - num if complement in num_to_index: return [num_to_index[complement] + 1, i + 1] num_to_index[num] = i return [] def find_indices_two_pointers(numbers: List[int], target: int) -> List[int]: left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return [] def find_indices(numbers: List[int], target: int) -> List[int]: # Uncomment one of the following lines to use the desired method: # return find_indices_binary_search(numbers, target) # return find_indices_hash_table(numbers, target) return find_indices_two_pointers(numbers, target)"},{"question":"# Integer Partitioning Problem You are given a positive integer `decompose`. Your task is to write a function `int_divide` which will return the number of distinct ways the integer `decompose` can be decomposed into sums of positive integers. Requirements: 1. The function should be implemented using a dynamic programming approach. 2. The function should return an integer count of the possible decompositions. 3. Ensure your code handles edge cases gracefully, returning 1 for `decompose = 0` and an error or handle gracefully for negative inputs. Input and Output: * Input: A single positive integer `decompose`. * Output: An integer representing the number of ways to decompose `decompose`. Constraints: * The input integer `decompose` is positive and less than 10^2. Example: ```python def int_divide(decompose): Implement your solution here. # Example 1: input_value = 4 output_value = int_divide(input_value) print(output_value) # Output should be: 5 # Example 2: input_value = 7 output_value = int_divide(input_value) print(output_value) # Output should be: 15 ``` **Good Luck!**","solution":"def int_divide(decompose): Returns the number of distinct ways to decompose the given integer into sums of positive integers. # Ensure decompose is a non-negative integer if decompose < 0: return 0 # Initialize the DP table with (decompose+1) x (decompose+1) with all entries as 0 dp = [[0 for _ in range(decompose + 1)] for _ in range(decompose + 1)] # Base case: There is one way to decompose 0, by using no parts for i in range(decompose + 1): dp[0][i] = 1 # Fill the table for i in range(1, decompose + 1): for j in range(1, decompose + 1): dp[i][j] = dp[i][j - 1] if i >= j: dp[i][j] += dp[i - j][j] return dp[decompose][decompose]"},{"question":"As a programmer, you are tasked with implementing a function to find efficient paths within a given graph. For this task, you will design a function that finds the shortest path from a starting node to an ending node in an unweighted graph. Your implementation should avoid using recursion due to concerns about stack overflow on large graphs. Instead, use an iterative approach. # Function Signature ```python def find_iterative_shortest_path(graph, start, end): pass ``` # Input: - `graph`: Dictionary representing the adjacency list of the graph. `graph[node]` is a list of nodes directly connected to `node`. - `start`: The starting node. - `end`: The ending node. # Output: - Returns a list representing the shortest path from the `start` node to the `end` node. If no path exists, return `None`. # Constraints: - The graph will have at most 10,000 nodes. - Nodes will be represented by unique integer IDs (`0` to `n-1`). # Example ```text Input: graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 4], 4: [3]} start = 0 end = 4 Output: [0, 2, 3, 4] Input: graph = {0: [1], 1: [2], 2: [3], 3: []} start = 0 end = 3 Output: [0, 1, 2, 3] Input: graph = {0: [1], 1: [2], 2: [], 3: []} start = 0 end = 3 Output: None ``` # Performance Requirement Your algorithm should run in O(V + E) time complexity, where V is the number of vertices and E is the number of edges.","solution":"from collections import deque def find_iterative_shortest_path(graph, start, end): Finds the shortest path in an unweighted graph from start to end node using BFS Parameters: graph (dict): Adjacency list representation of the graph start (int): Starting node end (int): Ending node Returns: list: The shortest path from start to end nodes, or None if no path exists if start == end: return [start] # Queue to store the nodes along with the path taken queue = deque([(start, [start])]) visited = set() while queue: node, path = queue.popleft() if node in visited: continue visited.add(node) for neighbor in graph.get(node, []): if neighbor == end: return path + [neighbor] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Coding Problem: Extended Euclidean Algorithm and Modular Arithmetic Solver Objective: Your task is to write a Python function that takes two integers and returns their GCD, as well as coefficients that satisfy Bézout\'s identity. Additionally, you will implement a function that computes a modular inverse using the Extended Euclidean Algorithm. Function Signatures: ```python def extended_gcd(a: int, b: int) -> [int, int, int]: pass def modular_inverse(a: int, m: int) -> int: pass ``` Requirements: 1. **Extended GCD**: - Inputs: Two integers `a` and `b`. - Outputs: A tuple `(s, t, g)` where: * `s` and `t` are the Bézout coefficients, * `g` is the greatest common divisor (GCD) of `a` and `b`. 2. **Modular Inverse**: - Inputs: Two integers `a` and `m`. - Outputs: An integer `x` such that ( (a * x) % m = 1 ). - Conditions: Function should raise a `ValueError` if `a` and `m` are not coprime. Example: ```python # Example usage: s, t, gcd = extended_gcd(30, 20) print(s, t, gcd) # Output: (1, -1, 10) -- i.e., 30*1 + 20*(-1) = 10 inverse = modular_inverse(3, 11) print(inverse) # Output: 4 -- i.e., (3 * 4) % 11 = 1 # Handling edge cases try: inverse = modular_inverse(6, 9) except ValueError as e: print(e) # Output: a and m must be coprime ``` Constraints: * `1 <= a, b <= 10^12` * `1 <= m <= 10^12` Notes: * Ensure your code efficiently handles very large integers. * Consider necessary validations and error messages.","solution":"def extended_gcd(a: int, b: int) -> (int, int, int): Applies the Extended Euclidean Algorithm to find the coefficients x and y such that: a*x + b*y = gcd(a, b) Returns a tuple (x, y, gcd). if b == 0: return (1, 0, a) else: x1, y1, gcd = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return (x, y, gcd) def modular_inverse(a: int, m: int) -> int: Finds the modular inverse of a under module m. The modular inverse of \'a\' under modulo \'m\' is a number \'x\' such that (a * x) % m = 1. Raises ValueError if a and m are not coprime. x, y, gcd = extended_gcd(a, m) if gcd != 1: raise ValueError(\\"a and m must be coprime to have an inverse.\\") else: # ensuring the result is positive return x % m"},{"question":"You are given a binary tree, and you\'re tasked with writing a function to determine the minimum depth of the tree using recursion. Additionally, you must implement a function to print the tree in pre-order traversal. Function Specifications 1. `min_depth(root: Optional[TreeNode]) -> int` - **Input**: `root` - Root node of the binary tree or `None`. - **Output**: Return the minimum depth of the tree. 2. `print_tree(root: Optional[TreeNode]) -> None` - **Input**: `root` - Root node of the binary tree or `None`. - **Output**: Print values of the tree following a pre-order traversal. Constraints and Assumptions - Nodes in the tree are represented by `TreeNode` with attributes `.val` (int), `.left` (TreeNode/None), and `.right` (TreeNode/None). Example Execution Using the following binary tree: ``` 1 / 2 3 / 4 ``` - Binary Tree Representation: - Root Node: 1 - Left Subtree: Root Node 2 (Left Child: 4) - Right Subtree: Root Node 3 ```python tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) print(min_depth(tree)) # Output: 2 print_tree(tree) # Output: 1 2 4 3 ``` Instructions - Implement the `min_depth` function correctly while maintaining proper recursive logic. - Ensure `print_tree` function performs pre-order traversal efficiently.","solution":"from typing import Optional class TreeNode: def __init__(self, val: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def min_depth(root: Optional[TreeNode]) -> int: Determine the minimum depth of the binary tree. if root is None: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth(root.right) + 1 if not root.right: return min_depth(root.left) + 1 return min(min_depth(root.left), min_depth(root.right)) + 1 def print_tree(root: Optional[TreeNode]) -> None: Print values of the tree in pre-order traversal. if root: print(root.val, end=\\" \\") print_tree(root.left) print_tree(root.right)"},{"question":"# Ternary Search Implementation Objective Implement a function using the Ternary Search Algorithm to find an element in a sorted array. Your implementation should demonstrate understanding of the divide-and-conquer principle unique to ternary search and effectively handle edge cases and boundary conditions. Problem Statement Given a sorted array of integers `arr` and an integer `key`, implement a function `ternary_search(left, right, key, arr)` that returns the index of `key` in `arr`. If `key` is not found in the array, return -1. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass ``` Input Constraints - `arr` is a sorted list containing integers. - `0 <= left <= right < len(arr)` (initial call with `left = 0`, `right = len(arr) - 1`). - `key` is an integer. - The length of `arr` (`n`) will be such that `1 <= n <= 10^6`. Output - Return the index of `key` if it is present in `arr`. - Return -1 if `key` is not in `arr`. Example ```python # Example 1: arr = [1, 3, 5, 7, 9, 11, 13, 15] key = 5 assert ternary_search(0, len(arr) - 1, key, arr) == 2 # Example 2: arr = [2, 4, 6, 8, 10, 12, 14] key = 8 assert ternary_search(0, len(arr) - 1, key, arr) == 3 # Example 3: arr = [1, 4, 7, 10, 13, 16, 19] key = 5 assert ternary_search(0, len(arr) - 1, key, arr) == -1 ``` Performance Requirements - Must run in O(log3(N)) time complexity. - Should use O(1) additional space for the iterative approach.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Given two strings `s` and `t`, write a function to determine if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Implement the function `is_isomorphic(s: str, t: str) -> bool` that returns a boolean indicating whether the strings `s` and `t` are isomorphic. # Input: - Two strings `s` and `t`. # Output: - A boolean `True` if `s` and `t` are isomorphic, else `False`. # Constraints: - `1 <= len(s), len(t) <= 10^4` - `s` and `t` consist of any printable ASCII characters. # Performance Requirements: - The solution should run in linear time, O(n). # Example: 1. **Input**: `s = \\"egg\\", t = \\"add\\"` **Output**: `True` 2. **Input**: `s = \\"foo\\", t = \\"bar\\"` **Output**: `False` 3. **Input**: `s = \\"paper\\", t = \\"title\\"` **Output**: `True` # Scenario Consider a text-transform system that needs to standardize text formats by replacing characters in one set with another in a consistent manner. This function can ensure that the transformations are one-to-one and consistent, preventing transform conflicts. # Additional Information for Students: - Pay close attention to edge cases, such as strings of different lengths. - Ensure to manage your mappings efficiently to meet the space complexity requirements.","solution":"def is_isomorphic(s: str, t: str) -> bool: Determines if two strings s and t are isomorphic. Parameters: s (str): The first string. t (str): The second string. Returns: bool: True if the strings are isomorphic, False otherwise. if len(s) != len(t): return False s_to_t = {} t_to_s = {} for char_s, char_t in zip(s, t): if char_s in s_to_t: if s_to_t[char_s] != char_t: return False else: s_to_t[char_s] = char_t if char_t in t_to_s: if t_to_s[char_t] != char_s: return False else: t_to_s[char_t] = char_s return True"},{"question":"**Question: Pattern Matching with Backtracking** # Scenario You are a part of a software development team working on an advanced text parsing tool. Your next task is to implement a function that determines if a given string `str` follows a specified pattern `pattern`. The pattern and string must follow a one-to-one and onto relationship. For instance, each character in the pattern is mapped to a unique substring in the string and vice versa. # Function Implementation **Function Signature:** ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` # Input - `pattern` (a string): The pattern to match, containing only lowercase letters. - `string` (a string): The string to which the pattern is to be matched, containing only lowercase letters. # Output - Returns `True` if the string follows the pattern. - Returns `False` otherwise. # Constraints - Both `pattern` and `string` are non-empty. - Length of the input strings `pattern` and `string` do not exceed 1000 characters. # Example ```python assert pattern_match(\\"abab\\", \\"redblueredblue\\") == True assert pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") == True assert pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") == False ``` # Requirements 1. The function must utilize a **Backtracking algorithm** to explore all possible ways of mapping characters from `pattern` to substrings of `string`. 2. Add appropriate checks to avoid incorrect recursive calls and manage edge cases efficiently. 3. Provide clear and efficient code with appropriate comments.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_idx, s_idx, p_map, used): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False pattern_char = pattern[p_idx] for end in range(s_idx + 1, len(string) + 1): candidate_substr = string[s_idx:end] if pattern_char in p_map: if p_map[pattern_char] == candidate_substr: if backtrack(p_idx + 1, end, p_map, used): return True else: if candidate_substr in used: continue p_map[pattern_char] = candidate_substr used.add(candidate_substr) if backtrack(p_idx + 1, end, p_map, used): return True del p_map[pattern_char] used.remove(candidate_substr) return False return backtrack(0, 0, {}, set())"},{"question":"Design a class `MultiZigZagIterator` that iteratively yields elements from `k` input lists in a \\"zigzag\\" pattern. With multiple lists, the iterator should take one element from each list in a round-robin fashion until all lists are exhausted. # Input - The class constructor takes `k` lists `v1` through `vk`, where each is a list of integers. # Output - `next()`: Returns the next integer in the zigzag order. - `has_next()`: Returns a boolean indicating if there are more integers to iterate over. # Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = MultiZigZagIterator(l1, l2, l3) result = [] while it.has_next(): result.append(it.next()) # Expected result: [1, 3, 7, 2, 4, 8, 5, 9, 6] print(result) ``` # Constraints * 0 ≤ length of each input list ≤ 1000 * All elements of input lists are integers from -10^6 to 10^6. * The `next` and `has_next` functions should each run in constant time O(1). # Requirements * Implement the `MultiZigZagIterator` class with the following methods: * `__init__(*vectors)`: Initialize the iterator with multiple input lists. * `next() -> int`: Retrieve the next element in the zigzag order. * `has_next() -> bool`: Check if the iterator has more elements.","solution":"from collections import deque class MultiZigZagIterator: def __init__(self, *vectors): self.queue = deque([deque(vec) for vec in vectors if vec]) def next(self): if self.has_next(): vec = self.queue.popleft() value = vec.popleft() if vec: self.queue.append(vec) return value raise StopIteration(\\"No more elements\\") def has_next(self): return len(self.queue) > 0"},{"question":"Context Given a matrix sorted in non-decreasing order both row-wise and column-wise, your task is to locate a specified key within this matrix. This problem is essential in understanding search algorithms and efficient data access patterns in matrix data structures. Problem Statement Implement a function `search_key_in_sorted_matrix(matrix, key)` that takes a 2D list `matrix` and an integer `key` as input and returns a tuple representing the zero-based indices of the key in the matrix. If the key is not found, return `(-1, -1)`. Function Signature ```python def search_key_in_sorted_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: pass ``` Input * `matrix`: A 2D list of integers where each row and each column is sorted in non-decreasing order. * `key`: An integer to search for within the matrix. Output * A tuple of two integers representing the zero-based row and column index of the `key` if found. If the `key` is not found, return `(-1, -1)`. Constraints * The number of rows `m` and the number of columns `n` of the matrix are such that `1 <= m, n <= 10^3`. * The elements of the matrix are such that `-10^6 <= matrix[i][j] <= 10^6`. * `-10^6 <= key <= 10^6`. Requirements * Ensure an efficient implementation with an expected time complexity of O(m + n). Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert search_key_in_sorted_matrix(matrix, key) == (1, 2) key = 6 assert search_key_in_sorted_matrix(matrix, key) == (-1, -1) ``` Implement the function meeting the above specifications and constraints.","solution":"from typing import List, Tuple def search_key_in_sorted_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: Search for the given key in a matrix sorted in non-decreasing order both row-wise and column-wise. Returns the tuple of indices of the key if found, otherwise returns (-1, -1). if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] < key: row += 1 else: col -= 1 return (-1, -1)"},{"question":"# Matrix Transformation: 90-degree Rotation and Reflection You are given a 2D matrix of integers, and you are required to implement functions to: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Reflect the matrix over its main diagonal (top-left to bottom-right). 4. Reflect the matrix over its anti-diagonal (bottom-left to top-right). # Function Signatures Here are the function signatures and their descriptions: 1. **rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]** Takes a square matrix and returns a new matrix that is rotated 90 degrees clockwise. 2. **rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]** Takes a square matrix and returns a new matrix that is rotated 90 degrees counterclockwise. 3. **top_left_invert(matrix: List[List[int]]) -> List[List[int]]** Takes a square matrix and returns a new matrix that is reflected over its main diagonal. 4. **bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]** Takes a square matrix and returns a new matrix that is reflected over its anti-diagonal. # Input Format - The input `matrix` for each function is a list of lists of integers representing an NxN matrix. # Output Format - Each function should return a new transformed NxN matrix as described above. # Constraints - You may assume that the input matrix is always a valid NxN matrix, where 1 <= N <= 1000. - The elements of the matrix are integers ranging from -1000 to 1000. # Example Given the initial matrix: ``` matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` * **rotate_clockwise(matrix)** should return: ``` [ [7, 4, 1], [8, 5, 2], [9, 3, 0] ] ``` * **rotate_counterclockwise(matrix)** should return: ``` [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` * **top_left_invert(matrix)** should return: ``` [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` * **bottom_left_invert(matrix)** should return: ``` [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ```","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - 1 - i] for j in range(n)] for i in range(n)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Reflects the given NxN matrix over its main diagonal (top-left to bottom-right). n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Reflects the given NxN matrix over its anti-diagonal (bottom-left to top-right). n = len(matrix) return [[matrix[n - 1 - j][n - 1 - i] for j in range(n)] for i in range(n)]"},{"question":"You have been given an unsorted array of integers. Your task is to implement the insertion sort algorithm without using any built-in sort functions. Below is the function signature you need to follow: ```python def insertion_sort(arr): Sorts an array of integers using the insertion sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list of integers. ``` # Detailed Requirements: 1. **Functionality**: - The function should sort the provided list of integers in ascending order using the insertion sort technique. 2. **Input**: - A list of integers with lengths from 0 to 1000. - The values may include negative integers. 3. **Output**: - A new list of integers sorted in ascending order. 4. **Constraints**: - Use O(1) additional space. - The time complexity should be O(n^2) in the average and worst cases, and O(n) in the best case. 5. **Performance Considerations**: - Ensure the implementation is efficient for small and nearly sorted data sets. 6. **Edge Cases to Handle**: - Empty input list. - List containing one integer. - List where all elements are the same. - List already sorted in ascending or descending order. # Example: ```python assert insertion_sort([3, 1, 2, -5, -1, 7, 4]) == [-5, -1, 1, 2, 3, 4, 7] assert insertion_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert insertion_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert insertion_sort([]) == [] assert insertion_sort([10]) == [10] ```","solution":"def insertion_sort(arr): Sorts an array of integers using the insertion sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Matrix Noise Reduction Using Cholesky Decomposition You have been hired by a research lab working on signal processing. They have provided data that can be represented as a noisy Hermitian positive-definite matrix and asked you to implement a cleaner version of the data that can be further processed. Your task is to write a function `reduce_noise(A: List[List[float]]) -> List[List[float]]` which utilizes Cholesky Decomposition to reduce the noise from the matrix. The output should be a \\"cleaned\\" matrix derived from the lower triangular matrix of the Cholesky Decomposition. Input * A: A 2D list of floats representing an n x n Hermitian positive-definite matrix. Output * A 2D list of floats representing the cleaned version of the matrix from the lower triangular part of the Cholesky Decomposition of A. Constraints * 1 <= n <= 1000 * The matrix `A` will always be a valid Hermitian positive-definite matrix as input. Example ```python A = [ [4.0, 12.0, -16.0], [12.0, 37.0, -43.0], [-16.0, -43.0, 98.0] ] reduce_noise(A) ``` Expected Output: ```python [ [2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0] ] ``` > **Note**: Assume that the given matrix is always Hermitian positive-definite, and therefore a valid solution exists.","solution":"import numpy as np def reduce_noise(A): Reduces noise from a Hermitian positive-definite matrix using Cholesky decomposition. Args: A (List[List[float]]): A 2D list representing a Hermitian positive-definite matrix. Returns: List[List[float]]: A \\"cleaned\\" version of the input matrix using the lower triangular matrix from the Cholesky decomposition. A = np.array(A) L = np.linalg.cholesky(A) return L.tolist()"},{"question":"Counting Bits Context You have been hired by a company that specializes in developing low-level embedded systems. They need a highly efficient function to count the number of 1-bits (also known as the Hamming weight or population count) in the binary representation of an integer. This is a critical function for optimizing memory usage. Task Implement the function `count_bits(num)` which takes an integer `num` as its input and returns the number of 1-bits in its binary representation. Function Signature ```python def count_bits(num: int) -> int: # Your code here ``` Input * `num`: An integer (0 ≤ num ≤ 10^9). Output * An integer representing the number of 1-bits in the binary representation of `num`. Example ```python assert count_bits(0) == 0 assert count_bits(5) == 2 # 5 in binary is 101 assert count_bits(15) == 4 # 15 in binary is 1111 ``` Constraints * Your solution should run in O(log N), where N is the value of `num`. Hints * You may use the fundamental bit operations for efficiency. * Consider different strategies for counting bits, such as shifting bits and using bit masks.","solution":"def count_bits(num: int) -> int: Returns the number of 1-bits in the binary representation of num. count = 0 while num: count += num & 1 num >>= 1 return count"},{"question":"Scenario You are developing a network diagnostic tool. One of the features of this tool is to detect cycles in communication paths represented as a linked list structure. Each node in the linked list represents a device, and the `next` pointer represents a direct connection to another device. Your task is to implement an algorithm that detects if there is a cycle in the network and returns the first device (node) involved in this cycle. If no cycle is present, the function should return `None`. Function Signature ```python def first_cyclic_node(head): :type head: Node :rtype: Node ``` Input - `head`: The head node of a linked list representing the starting device in the network. Output - The first node in the cycle if there is a cycle, otherwise `None`. Constraints - The number of nodes in the linked list is between `0` and `10^5`. - Each node has a unique value that is hashable for comparison purposes. Example # Example 1: ```python # A -> B -> C -> D -> E -> C (cycle starts at C) head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node print(first_cyclic_node(head).val) # Output: \'C\' ``` # Example 2: ```python # 1 -> 2 -> 3 -> 4 -> 5 (no cycle) head = Node(1) curr = head for i in range(2, 6): curr.next = Node(i) curr = curr.next print(first_cyclic_node(head)) # Output: None ``` Notes 1. **Edge Cases**: Handle the scenarios where the linked list is empty or contains no cycles. 2. **Efficiency**: Ensure your implementation handles the upper limits efficiently. 3. **Testing**: Ensure your code passes various test cases, including those with cycles and without cycles.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def first_cyclic_node(head): Detects the first node in a cycle (if any) in a linked list. :type head: Node :rtype: Node if head is None or head.next is None: return None slow = head fast = head # First step: determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break if not fast or not fast.next: # No cycle return None # Second step: find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Question Scenario You are given a Binary Search Tree (BST) and asked to perform an in-order traversal using an iterator pattern. The in-order traversal visits nodes in non-decreasing order. Your task is to implement methods to initialize the iterator, check if there are more nodes to traverse, and fetch the next smallest node in the BST. Problem Statement Design the class `BSTIterator` that simulates an in-order iterator over a BST. Implement the following methods: 1. `__init__(self, root)`: The constructor takes the root of the BST as input and initializes the iterator. 2. `has_next(self) -> bool`: Returns `True` if there are more nodes to iterate, otherwise `False`. 3. `next(self) -> int`: Returns the next smallest value in the BST. It should return the value of the node and move the iterator forward. Constraints * The total number of nodes in the BST is at most `10^4`. * You can assume no duplicate values in the BST. * The tree node class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Example ```python # Constructing the following BST: # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) iterator.next() # return 3 iterator.next() # return 7 iterator.has_next() # return True iterator.next() # return 9 iterator.has_next() # return True iterator.next() # return 15 iterator.has_next() # return True iterator.next() # return 20 iterator.has_next() # return False ``` Notes * Ensure your code handles edge cases such as an empty tree. * Remember to maintain an optimized order of traversal using the iterator.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: In-order iterator for a Binary Search Tree (BST). def __init__(self, root): Initialize the iterator with the root of the BST. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to add the leftmost nodes of the tree to the stack. while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Returns whether there is a next smallest number in the BST. return len(self.stack) > 0 def next(self) -> int: Returns the next smallest number in the BST and advances the iterator. # Node at the top of the stack is the next node to be visited. topmost_node = self.stack.pop() # If the node has a right child, add all the leftmost nodes starting from the right child. if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"Context: You have been given a series of transformation functions that manipulate matrices by rotating or inverting them. However, these functions currently assume that the matrices are square, and they also create new matrices rather than modifying the given ones in place. Task: Your task is to implement a single function, `transform_matrix(matrix, operation)`, that performs different types of transformations in-place on a given matrix based on the specified operation. Here’s a breakdown of the required transformations: 1. **Rotate Clockwise (90 degrees)**: Rotate the matrix by 90 degrees clockwise. 2. **Rotate Counterclockwise (90 degrees)**: Rotate the matrix by 90 degrees counterclockwise. 3. **Invert Top-Left to Bottom-Right**: Invert the matrix over its main diagonal (left-top to right-bottom). 4. **Invert Bottom-Left to Top-Right**: Invert the matrix over its anti-diagonal (left-bottom to right-top). Function Signature: ```python def transform_matrix(matrix, operation): Transforms the given matrix in place based on the specified operation. Parameters: matrix (List[List[int]]): The matrix to be transformed. operation (str): The transformation operation. Can be one of \'rotate_clockwise\', \'rotate_counterclockwise\', \'invert_tl_br\', \'invert_bl_tr\'. Returns: None pass ``` Input & Output: * **Input**: * `matrix`: A list of lists where each sublist represents a row in the matrix. * `operation`: A string specifying the operation to perform. Valid operations are `\'rotate_clockwise\'`, `\'rotate_counterclockwise\'`, `\'invert_tl_br\'`, and `\'invert_bl_tr\'`. * **Output**: * The function returns nothing. The input matrix should be modified in place. Constraints: * The matrix may not necessarily be square. * It is guaranteed that the matrix will contain at least one element. Examples: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transform_matrix(matrix, \'rotate_clockwise\') # matrix should be transformed to # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transform_matrix(matrix, \'invert_tl_br\') # matrix should be transformed to # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` Notes: * Ensure to handle both square and non-square matrices. * Optimize the function to avoid excess memory usage outside of the matrix itself.","solution":"def transform_matrix(matrix, operation): Transforms the given matrix in place based on the specified operation. Parameters: matrix (List[List[int]]): The matrix to be transformed. operation (str): The transformation operation. Can be one of \'rotate_clockwise\', \'rotate_counterclockwise\', \'invert_tl_br\', \'invert_bl_tr\'. Returns: None def rotate_clockwise(): n, m = len(matrix), len(matrix[0]) matrix[:] = [[matrix[n - j - 1][i] for j in range(n)] for i in range(m)] def rotate_counterclockwise(): n, m = len(matrix), len(matrix[0]) matrix[:] = [[matrix[j][m - i - 1] for j in range(n)] for i in range(m)] def invert_tl_br(): n, m = len(matrix), len(matrix[0]) for i in range(min(n, m)): for j in range(i + 1, min(n, m)): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] def invert_bl_tr(): n, m = len(matrix), len(matrix[0]) for i in range(n): for j in range(m): if i + j < min(n, m) - 1: matrix[i][j], matrix[n - j - 1][m - i - 1] = matrix[n - j - 1][m - i - 1], matrix[i][j] operations = { \'rotate_clockwise\': rotate_clockwise, \'rotate_counterclockwise\': rotate_counterclockwise, \'invert_tl_br\': invert_tl_br, \'invert_bl_tr\': invert_bl_tr, } if operation in operations: operations[operation]()"},{"question":"# Parse Domain Name from URL You are working on a web analytics tool that needs to extract the primary domain name from given URLs. Implement a function `get_domain` that extracts and returns just the domain name as a string from a full URL string. Requirements: 1. The input will be a URL in the form of a string. 2. You may not use any built-in libraries such as `re` (regular expression) or `urlparse` except for the `split` function. 3. The function should handle URLs starting with `http://`, `https://`, or having `www`. Input: - A single string representing a URL, e.g., `\\"http://github.com/SaadBenn\\"` Output: - A single string representing the primary domain name, e.g., `\\"github\\"` Constraints: - URLs will be up to 1000 characters in length. - URLs will follow general conventions but may vary slightly in structure. Example Cases: 1. `get_domain(\\"http://github.com/SaadBenn\\")` should return `\\"github\\"`. 2. `get_domain(\\"http://www.zombie-bites.com\\")` should return `\\"zombie-bites\\"`. 3. `get_domain(\\"https://www.cnet.com\\")` should return `\\"cnet\\"`. 4. `get_domain(\\"https://google.com\\")` should return `\\"google\\"`. 5. `get_domain(\\"www.example.org/page\\")` should return `\\"example\\"`. Performance Note: Your solution should efficiently handle strings within the given constraint. ```python def get_domain(url: str) -> str: # Implement the function here pass # Example usage: # print(get_domain(\\"http://github.com/SaadBenn\\")) # Expected output: \\"github\\" ```","solution":"def get_domain(url: str) -> str: Extracts the primary domain name from a given URL. Args: - url (str): The input URL string. Returns: - str: The primary domain name. # Remove the protocol part if present if \\"://\\" in url: url = url.split(\\"://\\")[1] # Remove the \'www\' part if it initiates the domain if url.startswith(\\"www.\\"): url = url.split(\\"www.\\")[1] # Split the remaining part to get the domain and return the primary domain name domain_part = url.split(\\"/\\")[0] primary_domain = domain_part.split(\\".\\")[0] return primary_domain"},{"question":"You are tasked with implementing a `SegmentTree` class for efficient range queries and updates. The class shall support initializing with an array of integers and a function (like sum, min, or max). It should allow performing range queries and point updates in logarithmic time complexity. # Input and Output Formats - **Initialization**: * The constructor `__init__(self, arr, function)` takes two arguments: * `arr`: A list of integers. * `function`: A binary function that will be used to generate segment tree values. - **Methods**: * `query(self, L, R)`: This method should return the result of applying the function to the segment of the array from index `L` to `R` inclusive. * Input: Two integers `L` and `R` representing the range. * Output: The result of the function applied to the range. * `update(self, index, value)`: This method should update the element at `index` to `value`. * Input: Integer `index` and integer `value`. * Output: None # Constraints * 1 ≤ len(arr) ≤ 10^5 * -10^9 ≤ arr[i], value ≤ 10^9 * 0 ≤ L ≤ R < len(arr) * 0 ≤ index < len(arr) # Example ```python # Create Segment Tree with sum function segment_tree = SegmentTree([1, 2, 3, 4, 5], sum) print(segment_tree.query(0, 2)) # Output should be 1+2+3 = 6 segment_tree.update(1, 10) # Update index 1 to 10 print(segment_tree.query(0, 2)) # Output should be 1+10+3 = 14 # Create Segment Tree with max function segment_tree = SegmentTree([1, 2, 3, 4, 5], max) print(segment_tree.query(1, 3)) # Output should be max(2, 3, 4) = 4 segment_tree.update(2, 8) # Update index 2 to 8 print(segment_tree.query(1, 3)) # Output should be max(2, 8, 4) = 8 ``` # Implementation Requirements - Ensure the segment tree is built efficiently. - Handle edge cases where the range may include boundaries of the array. - Maintain optimal time complexity for updates and queries.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.func = function self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i << 1], self.tree[i << 1 | 1]) def update(self, index, value): # Set value at position index pos = index + self.n self.tree[pos] = value while pos > 1: pos >>= 1 self.tree[pos] = self.func(self.tree[pos << 1], self.tree[pos << 1 | 1]) def query(self, L, R): # Query for the function result over range [L, R) result = None L += self.n R += self.n + 1 while L < R: if L & 1: result = self.tree[L] if result is None else self.func(result, self.tree[L]) L += 1 if R & 1: R -= 1 result = self.tree[R] if result is None else self.func(result, self.tree[R]) L >>= 1 R >>= 1 return result"},{"question":"# Simplify Unix File Path Problem Description: You are given an absolute path for a file (Unix-style), and your task is to simplify it. An absolute path is a path always starting with a slash (\'/\') and goes through multiple directories or up one level using \'..\'. You need to simplify the path such that it equates to the shortest possible string corresponding to the same location. Input: - A string `path` representing an absolute path. Output: - A string representing the simplified canonical path. Constraints: - The input path is always a valid Unix path. - The length of `path` will be in the range [1, 3000]. Performance Requirements: - Your solution should have a time complexity of O(n) where n is the length of the `path`. - Space complexity should be O(n) as well. Examples: 1. ```python simplify_path(\\"/home/\\") -> \\"/home\\" ``` 2. ```python simplify_path(\\"/a/./b/../../c/\\") -> \\"/c\\" ``` 3. ```python simplify_path(\\"/../\\") -> \\"/\\" ``` 4. ```python simplify_path(\\"/home//foo/\\") -> \\"/home/foo\\" ``` Detailed Requirements: 1. You must split the input path by \'/\'. 2. Use a stack to handle the directory traversal: - Push directory names onto the stack. - Pop from the stack if encountering \'..\' (moving up one level). - Ignore \'.\' (referring to the current directory) and empty strings (multiple slashes). 3. Reconstruct the path from the stack to produce the simplified path. Implementation: Implement the function `simplify_path(path: str) -> str` that performs the above steps to simplify the given Unix-style path.","solution":"def simplify_path(path: str) -> str: Simplifies a given Unix-style path. Parameters: - path (str): The Unix-style absolute path to simplify. Returns: - str: The simplified canonical Unix-style path. # Split the input path by \'/\' parts = path.split(\'/\') # Initialize a stack to manage the traversed directories stack = [] # Process each part of the split path for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) # Reconstruct the simplified path from the stack return \'/\' + \'/\'.join(stack)"},{"question":"# Matrix Multiplication Context You are working on a scientific computation project that requires performing multiple matrix operations. One of the fundamental operations you need to implement is matrix multiplication. Given two matrices, your task is to write a function to compute their product. Function Specification **Function Name**: `multiply` **Input**: * `multiplicand` (List[List[int]]): A 2D list representing the first matrix. * `multiplier` (List[List[int]]): A 2D list representing the second matrix. **Output**: * Returns a 2D list (List[List[int]]) representing the product of the two matrices. **Constraints**: 1. The number of columns in the multiplicand matrix must be equal to the number of rows in the multiplier matrix. 2. Each element in input matrices will be an integer within the range [-1,000, 1,000]. 3. The dimensions of the matrices will not exceed 100x100. If the matrices are not compatible for multiplication, the function should raise an exception with a clear error message. Performance Requirements: * The algorithm should be efficient enough to handle matrices up to size 100x100 within a reasonable time frame. **Example**: ```python >>> multiplicand = [ ... [1, 2], ... [3, 4] ... ] >>> multiplier = [ ... [2, 0], ... [1, 2] ... ] >>> multiply(multiplicand, multiplier) [[4, 4], [10, 8]] ``` Notes: - Pay attention to edge cases such as incompatible matrix dimensions. - Aim to write clean, efficient, and readable code.","solution":"def multiply(multiplicand, multiplier): Multiplies two matrices together. Parameters: multiplicand (List[List[int]]): The first matrix. multiplier (List[List[int]]): The second matrix. Returns: List[List[int]]: The product of the two matrices. # Number of rows and columns in the input matrices rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) # Check if the matrices can be multiplied if cols_multiplicand != rows_multiplier: raise ValueError(\\"The number of columns in the multiplicand matrix must be equal to the number of rows in the multiplier matrix.\\") # Resultant matrix of size (rows_multiplicand x cols_multiplier) product = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): product[i][j] += multiplicand[i][k] * multiplier[k][j] return product"},{"question":"# Anagram Checker Problem Statement: Given two strings `s` and `t`, write a function `are_anagrams(s: str, t: str) -> bool` to determine if `t` is an anagram of `s`. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Input: - Two strings `s` and `t`. Output: - A boolean value: `True` if `t` is an anagram of `s`, `False` otherwise. Example: ``` Input: s = \\"listen\\", t = \\"silent\\" Output: True Input: s = \\"hello\\", t = \\"billion\\" Output: False ``` Constraints: - You may assume the string contains only lowercase alphabets. - The function should perform efficiently for strings up to length 10^5. Requirements: - The implementation should be efficient in terms of both time and space complexity. - Consider edge cases such as empty strings and strings of different lengths. - Avoid using built-in sorting or any library functions that might trivialize the problem. Scenario: Imagine you are working on a text processing task where you need to quickly match or group words that are anagrams of each other. This function `are_anagrams` will be a key part of your toolset for performing this operation. Implement the `are_anagrams` function according to the specifications above.","solution":"def are_anagrams(s: str, t: str) -> bool: Returns True if t is an anagram of s, False otherwise. if len(s) != len(t): return False # Create frequency dictionaries frequency_s = {} frequency_t = {} for char in s: frequency_s[char] = frequency_s.get(char, 0) + 1 for char in t: frequency_t[char] = frequency_t.get(char, 0) + 1 return frequency_s == frequency_t"},{"question":"# Question **Problem Statement**: You are given a collection of integers that might contain duplicates, `nums`. Write a function `subsets_unique` that returns all possible subsets (the power set) ensuring that the solution set does not contain duplicate subsets. The returned subsets can be in any order. **Function Signature**: ```python def subsets_unique(nums: List[int]) -> List[List[int]]: ``` **Input**: - `nums` (List[int]): A list of integers that may include duplicates. **Output**: - Returns a list of lists, where each list represents a unique subset of the input list. **Constraints**: - The number of elements in `nums` will be in the range [0, 10]. - The elements in `nums` will be in the range [-10, 10]. **Example**: ```python nums = [1, 2, 2] result = subsets_unique(nums) print(result) # Possible outputs can be in any order but must include: # [ # [], # [1], # [2], # [1, 2], # [2, 2], # [1, 2, 2] # ] ``` **Performance Requirements**: - Your solution should ensure that no duplicate subsets are present in the final output. - Aim for an efficient solution given the constraints, keeping in mind both time and space complexities. **Scenario**: Imagine you are cataloging possible combinations of ingredients in a recipe where some ingredients may be used more than once. However, you want to ensure that each combination is recorded only once regardless of order or repetition.","solution":"from typing import List def subsets_unique(nums: List[int]) -> List[List[int]]: def backtrack(start, path): res.append(path[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() res = [] backtrack(0, []) return res"},{"question":"You are tasked with creating two functions, `serialize(root)` and `deserialize(data)`, to serialize and deserialize a binary tree. Your goal is to verify the correctness of this process through a series of test cases. # Detailed Description Implement the following functions: 1. `serialize(root)`: Converts the given binary tree to a string representation. * **Input**: The root node of a binary tree. * **Output**: A single string representing the tree. 2. `deserialize(data)`: Converts the given string back into the corresponding binary tree. * **Input**: A string representing a serialized binary tree. * **Output**: The root node of the rebuilt binary tree. # Constraints 1. The number of nodes in the tree is in the range [0, 10^4]. 2. The node values are between -1000 and 1000. # Requirements * Your solution should efficiently handle trees with up to 10^4 nodes. * The deserialization should correctly rebuild the original tree from its serialized form. # Function Signatures ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): # Your code here def deserialize(data): # Your code here ``` # Example ```python # Example usage: # Construct the tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) ser = serialize(root) print(ser) # Expected Output: \\"1 2 # # 3 4 # # 5 # #\\" deser = deserialize(ser) print(deserialize(ser).val) # Expected Output: 1 print(deserialize(ser).left.val) # Expected Output: 2 print(deserialize(ser).right.val) # Expected Output: 3 print(deserialize(ser).right.left.val) # Expected Output: 4 print(deserialize(ser).right.right.val) # Expected Output: 5 ```","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): Encodes a tree to a single string. def helper(node): if node is None: result.append(\\"#\\") else: result.append(str(node.val)) helper(node.left) helper(node.right) result = [] helper(root) return \' \'.join(result) def deserialize(data): Decodes your encoded data to tree. def helper(): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node vals = iter(data.split()) return helper()"},{"question":"Scenario You are implementing a search utility for a library management system. The system keeps track of books in a database represented as an array of book titles. Due to the dynamic addition and removal of books, the list is unsorted. You need to find the position of a specific book title based on user queries. Task Write a function `find_book` that uses a linear search to find the index of a given book title within the array. If the book is not found, the function should return -1. Function Signature ```python def find_book(titles: list, query: str) -> int: ``` Input * `titles` (List of strings): An array of book titles. - Example: `[\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"]` * `query` (String): The book title to search for. - Example: `\\"1984\\"` Output * An integer: The index of the book title in the array or -1 if the book title is not found. - Example: `1` Constraints * The number of book titles will not exceed 10^5. * Each title is a non-empty string with a maximum length of 100 characters. Example ```python assert find_book([\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"], \\"1984\\") == 1 assert find_book([\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"], \\"Moby Dick\\") == -1 assert find_book([], \\"The Great Gatsby\\") == -1 ```","solution":"def find_book(titles: list, query: str) -> int: This function takes a list of book titles and a query string. It returns the index of the book title in the list, or -1 if the book is not found. for index, title in enumerate(titles): if title == query: return index return -1"},{"question":"Question # Context You are working on a tree comparison module for a software that deals with organizational structures. You need to compare two hierarchical tree-like structures (binary trees in this case) to check if they are identical both in structure and values at each node. # Task Write a function `check_identical_trees(tree1, tree2)` that accepts the roots of two binary trees and returns a boolean indicating whether they are identical or not. # Important Points - Two binary trees are considered identical if they are structurally the same and nodes have the same value. - The function must be efficient in both time and space, considering it might be used in real-time checks for large trees. # Input - `tree1`: The root of the first binary tree. - `tree2`: The root of the second binary tree. - Both nodes are defined using a class `TreeNode` as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output - Return `True` if both trees are identical, otherwise return `False`. # Constraints - Node values are integers. - Consider performance for large trees, so aim for O(min(N, M)) time complexity and O(min(height1, height2)) space complexity. # Examples ```python tree1 = TreeNode(1) tree1.left = TreeNode(2) tree1.right = TreeNode(3) tree2 = TreeNode(1) tree2.left = TreeNode(2) tree2.right = TreeNode(3) assert check_identical_trees(tree1, tree2) == True tree3 = TreeNode(1) tree3.left = TreeNode(2) tree4 = TreeNode(1) tree4.right = TreeNode(2) assert check_identical_trees(tree3, tree4) == False ``` # Additional Notes - Ensure that your implementation handles edge cases, such as one or both trees being `None`. - Consider iterative approaches to avoid potential recursion stack overflow issues for very deep trees.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def check_identical_trees(tree1, tree2): if tree1 is None and tree2 is None: return True if tree1 is None or tree2 is None: return False if tree1.val != tree2.val: return False return check_identical_trees(tree1.left, tree2.left) and check_identical_trees(tree1.right, tree2.right)"},{"question":"# Binary Search Tree Validation Challenge Design a function to validate if a given binary tree is a binary search tree (BST). Your task is to implement the method `is_valid_bst()` which checks whether a given tree is a valid BST. Function Signature ```python def is_valid_bst(root: Node) -> bool: pass ``` Input: * **root (Node)**: The root node of the binary tree. Output: * **Return Type**: `bool` - Returns `True` if the tree is a valid BST, otherwise `False`. Constraints: * Node values are in the range `[-1e9, 1e9]`. * The number of nodes in the tree will not exceed `10^4`. Performance Requirements: * The solution should have a time complexity of O(N) where N is the number of nodes in the tree. * Space complexity should be O(H) where H is the height of the tree (due to the recursive call stack). Example: ```python class Node: def __init__(self, data): self.data = data self.left = None self.right = None # Example Tree that is a valid BST: # 10 # / # 5 15 # / / # 3 7 12 20 root = Node(10) root.left = Node(5) root.right = Node(15) root.left.left = Node(3) root.left.right = Node(7) root.right.left = Node(12) root.right.right = Node(20) assert is_valid_bst(root) == True # Should return True # Example Tree that is not a valid BST: # 10 # / # 5 15 # / / # 3 12 7 20 root = Node(10) root.left = Node(5) root.right = Node(15) root.left.left = Node(3) root.left.right = Node(12) root.right.left = Node(7) root.right.right = Node(20) assert is_valid_bst(root) == False # Should return False ``` Notes: * Ensure to handle edge cases like an empty tree, a tree with one node, and a skewed tree. * The function must correctly validate the BST property, comparing all nodes\' values appropriately.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None def is_valid_bst(root: Node) -> bool: def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if node.data <= low or node.data >= high: return False return validate(node.left, low, node.data) and validate(node.right, node.data, high) return validate(root)"},{"question":"# Question You are given an array of integers where every integer appears exactly twice except for one integer that appears only once. Your task is to write a function `find_single_number` to determine the integer that appears only once. Your solution must run in O(n) time and use O(1) extra space. **Function Signature:** ```python def find_single_number(nums: List[int]) -> int: ``` # Input * `nums`: A list of integers, where every integer except one appears exactly twice. - Example: [4, 1, 2, 1, 2] # Output * Return a single integer which is the one that appears only once in the array. - Example: 4 # Constraints * The list is non-empty. * There will always be exactly one integer that appears only once and all other integers will appear exactly twice. # Performance Requirements * The algorithm should run with a time complexity of O(n). * Use constant extra space, i.e., O(1). # Example ```python assert find_single_number([2, 2, 1]) == 1 assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([1]) == 1 ``` # Notes - You should not use any extra memory or built-in library functions to achieve the desired time and space complexity. - Think about how you can leverage bitwise operations to solve this problem efficiently.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: This function finds the integer that appears only once in the given list using bitwise XOR operator. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Minimum Edit Distance Challenge You are tasked with creating a function that calculates the minimum edit distance between two given words. The minimum edit distance is defined as the minimum number of operations (insertions, deletions, and substitutions) needed to convert one string into another. Function Signature ```python def minimum_edit_distance(word1: str, word2: str) -> int: ``` Input: * `word1` (String): The first word. * `word2` (String): The second word. Output: * An integer representing the minimum number of operations needed to transform `word1` into `word2`. Constraints: * Both strings consist of lowercase English letters only. * Strings can be of size up to (10^3). Examples: ```python assert minimum_edit_distance(\\"intention\\", \\"execution\\") == 5 assert minimum_edit_distance(\\"horse\\", \\"ros\\") == 3 assert minimum_edit_distance(\\"kitten\\", \\"sitting\\") == 3 ``` Notes: * Ensure your solution is efficient and handles the given constraints. * Think about edge cases such as one or both strings being empty. Context: In computational linguistics and related fields, edit distance is used to measure the similarity between two sequences. Implementing an efficient solution for calculating edit distances between words can be crucial in applications such as spelling correction and DNA sequencing. Good luck and ensure your implementation is both correct and optimal!","solution":"def minimum_edit_distance(word1: str, word2: str) -> int: Calculates the minimum edit distance between two words. # Create a 2D array to store the edit distances m = len(word1) n = len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the minimum edit distance using a bottom-up approach for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[m][n]"},{"question":"# Problem: Summarize Ranges in a Sorted Integer Array You are provided with a sorted list of distinct integers. Your task is to write a function `summarize_ranges` that returns a summary of its contiguous ranges. A range is defined as a sequence of consecutive integers. For example, in the list `[0, 1, 2, 4, 5, 7]`, the ranges are `(0, 2)`, `(4, 5)`, and `(7, 7)`. Your function should return a list of ranges formatted as strings whereby: - For a single number `x`, it should be represented as `\\"x\\"`. - For a range `a` to `b` where `a != b`, it should be represented as `\\"a-b\\"`. Function Signature: ```python def summarize_ranges(array: List[int]) -> List[str]: # Your code here ``` Input: * `array`: A sorted list of distinct integers (0 <= len(array) <= 10^4). Output: * A list of strings where each string represents a range or a single number. Example: ```python # Input array = [0, 1, 2, 4, 5, 7] # Output output = [\\"0-2\\", \\"4-5\\", \\"7\\"] ``` Your implementation should aim to maintain a time complexity of O(n), where n is the number of elements in the input array.","solution":"def summarize_ranges(array): Summarizes contiguous ranges in a sorted list of distinct integers. Args: array: List[int] - A sorted list of distinct integers. Returns: List[str] - A list of strings where each string represents a range or a single number. if not array: return [] ranges = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num # Append the last range if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"**Problem Statement:** You are working on a grid-based game where certain cells represent walls, gates, and empty rooms. Your task is to fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the cell should remain with its initial value. # Instructions: 1. You\'re provided with a m x n grid where: * `-1` represents a wall or an obstacle. * `0` represents a gate. * `INF` (2^31 - 1) represents an empty room. Each empty room needs to be filled with the distance to the nearest gate. If it is impossible to reach a gate, it should remain as `INF`. # Input: - A 2D list `rooms`, where `rooms[i][j]` indicates the value of the cell at the i-th row and j-th column. # Output: - Modify the input list in place so that each empty room contains the distance to its nearest gate. # Constraints: - The dimensions of the grid (m and n) are at most 300. - It is guaranteed that the distance to a gate will never exceed 2147483647. # Example: Given the grid: ``` INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF ``` The output should be: ``` 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 ``` # Additional Criteria: - **Consider the use of BFS instead of DFS**: Implement the function using BFS for optimal path finding. - Provide rigorous testing on edge cases such as grids without gates, grids full of walls, and large grids nearing limit bounds. Implement the function: ```python from collections import deque def walls_and_gates(rooms): if not rooms: return m, n = len(rooms), len(rooms[0]) queue = deque() for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) while queue: x, y = queue.popleft() for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny)) ```","solution":"from collections import deque def walls_and_gates(rooms): Fill each empty room (INF) in a grid with the distance to its nearest gate (0). If it is impossible to reach a gate, the cell should remain as INF. if not rooms: return m, n = len(rooms), len(rooms[0]) queue = deque() INF = 2**31 - 1 for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) while queue: x, y = queue.popleft() for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"# Question: Flexibly Finding Unique Combinations You are asked to implement an algorithm that finds all unique combinations of n elements from a given list of numbers (or tuples of numbers) that sum up to a given target. The function should also accept optional customizable functions for summation, comparison, and checking equality of elements to allow flexibility in the handling of different data types. Function Signature ```python def n_sum(n, nums, target, **kv) -> list[list[object]]: n: int nums: list[object] target: object sum_closure: function, optional Given two elements of nums, return sum of both. compare_closure: function, optional Given one object of nums and target, return -1, 1, or 0. same_closure: function, optional Given two objects of nums, return bool. return: list[list[object]] ``` # Requirements 1. You need to identify all possible unique combinations of `n` elements from `nums` that sum up to the `target`. 2. You must return a list of lists that contain these combinations. 3. The function should allow for optional `sum_closure`, `compare_closure`, and `same_closure` functions to handle non-traditional summing, comparing, and equality-checking logic. 4. Ensure your solution is efficient to handle larger inputs reasonably. # Input 1. An integer `n` representing the number of elements in each combination. 2. A list `nums` of integers (or tuple of integers). 3. A target sum `target`. 4. (Optional) sum_closure: Function for summing two elements from nums. 5. (Optional) compare_closure: Function for comparing the sum result to the target. 6. (Optional) same_closure: Function for checking if two elements are the same. # Output A list of lists, where each inner list is a combination of `n` elements from `nums` that sum to `target`. # Constraints 1. All elements in the `nums` array are integers. 2. The length of `nums` is at most 10^4. 3. Custom closure functions must be considered appropriately to avoid runtime errors. # Examples 1. **Basic Usage**: ```python n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 # Expected output should be: # [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` 2. **Advanced Usage with Custom Closures**: ```python n = 2 nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]] target = -5 sum_closure = lambda a, b: [a[0] + b[1], a[1] + b[0]] compare_closure = lambda num, target: -1 if num[0] < target else (1 if num[0] > target else 0) # Expected output should be: # [[[-9, 5], [8, 4]]] ```","solution":"from itertools import combinations def n_sum(n, nums, target, sum_closure=None, compare_closure=None, same_closure=None): def default_sum(a, b): return a + b def default_compare(a, b): if a < b: return -1 elif a > b: return 1 else: return 0 def default_same(a, b): return a == b sum_closure = sum_closure or default_sum compare_closure = compare_closure or default_compare same_closure = same_closure or default_same result = [] def check_combination(comb): total = comb[0] for elem in comb[1:]: total = sum_closure(total, elem) return compare_closure(total, target) == 0 for comb in combinations(nums, n): comb = sorted(comb) if comb not in result and check_combination(comb): result.append(comb) return result"},{"question":"# Task You are required to implement a function that can compute the frequency of each unique element in an integer array. This will help in the statistical analysis by presenting how frequent each element appears within the array. # Function Signature ```python def compute_frequency(input_list: List[int]) -> Dict[int, int]: ``` # Input - `input_list (List[int])`: A list of integers that you need to analyze. Constraints: The list can contain integers from -1000 to 1000. The length of the list is at most 10^5. # Output - A dictionary (`Dict[int, int]`) where the keys are the unique integers from the input list and values are their respective frequencies. # Example ```python assert compute_frequency([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert compute_frequency([2, 3, 5, 5, 5, 6, 4, 3, 7]) == {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} assert compute_frequency([]) == {} assert compute_frequency([1, 1, 1, 1]) == {1: 4} assert compute_frequency([1]) == {1: 1} ``` # Constraints - You need to implement this function without using any external libraries other than standard Python collections if required. # Notes - Think about edge cases such as an empty list or lists with duplicate values. - Consider the time complexity as the list length can be very large.","solution":"def compute_frequency(input_list): Computes the frequency of each unique element in an integer array. :param input_list: List[int] - A list of integers to analyze :return: Dict[int, int] - A dictionary where keys are unique integers and values are their frequencies frequency_dict = {} for element in input_list: if element in frequency_dict: frequency_dict[element] += 1 else: frequency_dict[element] = 1 return frequency_dict"},{"question":"Linked List Node Deletion You are given a singly linked list, and you are provided a reference to a node to be deleted in this list. Your task is to delete the node, without having access to the head of the list. Input - A reference to the node to be deleted. - You can assume this is a non-null reference, and the node to be deleted is not the tail node. Output - The linked list should be modified in-place, and no return value is necessary. # Constraints 1. The node given is not the last node in the list. 2. The node to be deleted is valid (it is not `None`). # Example Suppose the linked list is `1 -> 2 -> 3 -> 4 -> 5` and you are given the reference to the node with value `3`. After deleting the node, the linked list should become `1 -> 2 -> 4 -> 5`. # Implementation Write a function `delete_node(node_to_delete: Node)` that would modify the linked list as described. ```python class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node_to_delete): Delete a node from a singly linked list given only access to this node. :param node_to_delete: Node # Your code goes here ``` # Testing You are provided with the following testing scaffold. Make sure all tests pass before submitting your solution. ```python import unittest class TestDeleteNode(unittest.TestCase): def setUp(self): # Helper function to create a linked list and return the head and a particular node def create_linked_list(values, node_to_delete_index): head = Node(values[0]) current = head node_to_delete = None for i in range(1, len(values)): current.next = Node(values[i]) current = current.next if i == node_to_delete_index: node_to_delete = current return head, node_to_delete self.create_linked_list = create_linked_list def test_delete_node_from_middle(self): head, node_to_delete = self.create_linked_list([1, 2, 3, 4, 5], 2) delete_node(node_to_delete) self.assertEqual(self.linked_list_to_list(head), [1, 2, 4, 5]) def linked_list_to_list(self, head): result = [] while head: result.append(head.val) head = head.next return result if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node_to_delete): Delete a node from a singly linked list given only access to this node. :param node_to_delete: Node # Copy the data from the next node to the current node node_to_delete.val = node_to_delete.next.val # Bypass the next node node_to_delete.next = node_to_delete.next.next"},{"question":"Panagram Checker for Custom Alphabets Context: You are assigned to develop a feature in a multilingual natural language processing (NLP) tool. The tool needs to check whether a given sentence is a panagram for a dynamically defined set of alphabets. This is important for analyzing texts in different languages. Problem Statement: Write a function `is_panagram(sentence: str, alphabet: str) -> bool` that checks whether a given input string `sentence` is a panagram for the characters included in the `alphabet`. Function Signature: ```python def is_panagram(sentence: str, alphabet: str) -> bool: pass ``` Input: 1. `sentence` (str): A sentence in the form of a string. 2. `alphabet` (str): A string containing all characters that must appear at least once in the sentence. Output: - (bool) : A boolean indicating whether the input sentence uses every character in the alphabet at least once. Constraints: - The length of `sentence` will be between 0 and 10^6 characters. - The length of `alphabet` will be between 1 and 100 characters. - The `alphabet` string will not contain duplicate characters. Example: 1. is_panagram(\\"abcd efgh ijkl mnop qrstu vwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\") -> True 2. is_panagram(\\"The quick brown fox jumps over the lazy dog\\", \\"abcdefghijklmnopqrstuvwxyz\\") -> True 3. is_panagram(\\"Sphinx of black quartz, judge my vow.\\", \\"abcdefghijklmnopqrstuvwxyz\\") -> True 4. is_panagram(\\"Hello, World!\\", \\"helo wrd\\") -> True 5. is_panagram(\\"Hello, World!\\", \\"xyz\\") -> False Notes: - The function should be case-insensitive. - Characters not in the `alphabet` can be safely ignored.","solution":"def is_panagram(sentence: str, alphabet: str) -> bool: Checks if the sentence is a panagram for the given alphabet. Args: - sentence (str): The sentence to check. - alphabet (str): The alphabet set that must be present in the sentence. Returns: - bool: True if the sentence contains every character in the alphabet at least once, False otherwise. # Normalize both sentence and alphabet to lower case to handle case-insensitivity sentence = sentence.lower() alphabet = alphabet.lower() # Convert alphabet to set for faster membership testing alphabet_set = set(alphabet) # Iterate through the sentence and remove characters found in alphabet_set for char in sentence: if char in alphabet_set: alphabet_set.remove(char) # If alphabet_set is empty, every required character is found in the sentence if not alphabet_set: return True # If we exit loop with non-empty alphabet_set, some characters are missing return not bool(alphabet_set)"},{"question":"# Quick Sort Implementation with Iteration Logging Scenario You are asked to implement a version of the **Quick Sort** algorithm that not only sorts an array of integers but also logs the state of the array after each recursive iteration for debugging purposes. This will help in understanding how the algorithm progresses through its steps. # Task Write a function `quick_sort(arr, simulation=False)` that sorts the array `arr` in-place using the Quick Sort algorithm and returns the sorted array. Additionally, if the `simulation` parameter is set to `True`, the function should print the intermediate state of the array after each iteration of the recursion. # Input Format - **arr** (list of integers): The array of integers to be sorted. - **simulation** (bool): A flag indicating whether or not to print the array\'s intermediate states. # Output Format - The function should return the sorted list of integers. # Constraints - The array will have at most (10^5) elements. - Each element in the array will be an integer in the range ([-10^9, 10^9]). # Example ```python arr = [3, 6, 8, 10, 1, 2, 1] print(quick_sort(arr, simulation=True)) ``` Output (the exact output may vary depending on the implementation of the partition): ``` iteration 0 : [3, 1, 2, 1, 6, 8, 10] iteration 1 : [1, 1, 2, 3, 6, 8, 10] iteration 2 : [1, 1, 2, 3, 6, 8, 10] iteration 3 : [1, 1, 2, 3, 6, 8, 10] [1, 1, 2, 3, 6, 8, 10] ``` Note Ensure your function handles edge cases gracefully, such as empty arrays or arrays with identical elements. Additionally, your implementation should efficiently handle large arrays up to the constraint limit. # Implementation Hints You may use helper functions such as `quick_sort_recur` and `partition` as presented in the code snippet provided above.","solution":"def quick_sort(arr, simulation=False): Sorts the array arr in-place using the Quick Sort algorithm. If simulation is True, prints the state of the array after each recursive iteration. def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recur(low, high, iteration): if low < high: pi = partition(low, high) if simulation: print(f\\"iteration {iteration} : {arr}\\") quick_sort_recur(low, pi - 1, iteration + 1) quick_sort_recur(pi + 1, high, iteration + 1) quick_sort_recur(0, len(arr) - 1, 0) return arr"},{"question":"# Question: Compute the Binomial Coefficient **Context**: You are working on implementing combinatorial algorithms, and one such important algorithm is the recursive computation of the binomial coefficient ( C(n, k) ), also known as \\"n choose k\\". This is crucial in fields like probability theory and combinatorics. **Function Definition**: Implement a function `recursive_binomial_coefficient(n, k)` that computes ( C(n, k) ) recursively. **Parameters**: * `n` (int): The total number of items. * `k` (int): The number of items to choose. **Returns**: * (int): The binomial coefficient ( C(n, k) ). **Constraints**: * ( 0 leq k leq n ) * Any violation of the constraint should raise a `ValueError`. **Performance Requirement**: * The function should be efficient, leveraging properties of binomial coefficients to reduce the number of recursive calls. **Examples**: ```python >>> recursive_binomial_coefficient(5, 0) 1 >>> recursive_binomial_coefficient(8, 2) 28 >>> recursive_binomial_coefficient(500, 300) 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` **Scenario**: In a combinatorial problem, you often need to calculate ( C(n, k) ) to determine the number of ways of selecting ( k ) items from ( n ) items. For example, in a lottery system where you need to choose 5 numbers out of 50, you can calculate ( C(50, 5) ) using your function. Implement the function ensuring it satisfies all the constraints and is optimized as described above.","solution":"def recursive_binomial_coefficient(n, k): Computes the binomial coefficient C(n, k) recursively. Parameters: n (int): The total number of items. k (int): The number of items to choose. Returns: int: The binomial coefficient C(n, k). # Constraint validation if k < 0 or k > n: raise ValueError(\\"k must be in the range 0 <= k <= n\\") # Base cases if k == 0 or k == n: return 1 # Recursive case return recursive_binomial_coefficient(n - 1, k - 1) + recursive_binomial_coefficient(n - 1, k)"},{"question":"# Scenario You are part of a data science team working on analyzing survey responses. One of the tasks requires identifying the most popular choices for a particular question. Given an array of responses, you need to determine the value(s) that appear the most frequently. Write a function that will handle this requirement efficiently. # Question Implement a Python function called `most_frequent_values` that takes a list of integers as input and returns a list of the integer(s) that appear most frequently in the input list. If there are multiple values with the highest frequency, the function should return all such values in ascending order. # Function Signature ```python def most_frequent_values(arr: list[int]) -> list[int]: ``` # Input * `arr`: A list of integers (`1 <= len(arr) <= 10^6`, `-10^9 <= arr[i] <= 10^9` for all `0 <= i < len(arr)`). # Output * A list of integer(s) that appears the most frequently in the input list. # Constraints * If the input list is empty, return an empty list. * The output list should be sorted in ascending order. # Example Example 1 ```python most_frequent_values([1, 1, 2, 2, 3, 4]) ``` *Output*: `[1, 2]` Example 2 ```python most_frequent_values([4, 4, 4, 6, 6, 7, 8]) ``` *Output*: `[4]` Example 3 ```python most_frequent_values([-1, -1, -2, -2, -3]) ``` *Output*: `[-1, -2]` Example 4 ```python most_frequent_values([]) ``` *Output*: `[]` # Performance Requirements * Ensure the solution handles large input sizes efficiently within reasonable time limits (preferably O(n) time complexity).","solution":"from collections import Counter def most_frequent_values(arr: list[int]) -> list[int]: if not arr: # If the list is empty, return an empty list return [] # Create a Counter object to count the frequency of each element in the input list count = Counter(arr) # Determine the maximum frequency max_freq = max(count.values()) # Collect all elements that have the maximum frequency most_frequent = [num for num, freq in count.items() if freq == max_freq] # Return the list of most frequent elements sorted in ascending order return sorted(most_frequent)"},{"question":"# Question: Graph Similarity Check using Traversal You are given two graphs represented as adjacency lists. Implement a function to determine whether the two graphs are structurally identical, i.e., they have the same shape irrespective of the node labels and traversal order. Implement the function: ```python def are_graphs_identical(graph1, graph2, start1, start2): Determine if `graph1` and `graph2` are structurally identical starting from `start1` and `start2`. :param graph1: dict, an adjacency list representing the first graph :param graph2: dict, an adjacency list representing the second graph :param start1: starting node in the first graph :param start2: starting node in the second graph :return: True if the graphs are structurally identical, False otherwise pass ``` # Input - `graph1` and `graph2` are dictionaries where keys are node identifiers and values are lists of identifiers of adjacent nodes. - `start1` and `start2` are the starting nodes for traversal in `graph1` and `graph2` respectively. # Output - Return `True` if both graphs are structurally identical when traversed, `False` otherwise. # Constraints - The graphs can have cycles. - It is guaranteed that both start nodes exist in their respective graphs. # Example ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'E\'], \'D\': [], \'E\': [] } graph2 = { \'1\': [\'2\', \'3\'], \'2\': [\'4\'], \'3\': [\'5\'], \'4\': [], \'5\': [] } print(are_graphs_identical(graph1, graph2, \'A\', \'1\')) # Output: True graph3 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } graph4 = { \'1\': [\'2\', \'3\'], \'2\': [], \'3\': [] } print(are_graphs_identical(graph3, graph4, \'A\', \'1\')) # Output: False ``` # Hints - Consider adding depth or level information to the nodes during traversal. - Employ iterative traversal algorithms (DFS or BFS) to avoid stack overflow in case of deep recursion.","solution":"def are_graphs_identical(graph1, graph2, start1, start2): Determine if `graph1` and `graph2` are structurally identical starting from `start1` and `start2`. :param graph1: dict, an adjacency list representing the first graph :param graph2: dict, an adjacency list representing the second graph :param start1: starting node in the first graph :param start2: starting node in the second graph :return: True if the graphs are structurally identical, False otherwise def bfs_structure(graph, start): visited = set() queue = [(start, 0)] structure = [] while queue: node, level = queue.pop(0) if node not in visited: visited.add(node) structure.append((level, len(graph[node]))) for neighbor in graph[node]: queue.append((neighbor, level + 1)) return structure structure1 = bfs_structure(graph1, start1) structure2 = bfs_structure(graph2, start2) return structure1 == structure2"},{"question":"# Dijkstra\'s Shortest Path Problem for a Dense Graph You are provided with a class definition `Dijkstra` which implements the Dijkstra\'s single-source shortest path algorithm using an adjacency matrix for representing a fully connected directed graph with non-negative edge weights. The goal of this task is to complete the `dijkstra` method to return the shortest distance from the provided source node to all other nodes. Function Signature ```python def dijkstra(self, src: int) -> List[int]: # Complete this method to return the list of shortest distances from the source vertex `src` to all other vertices. ``` Input * `src`: An integer representing the source vertex from which to calculate shortest paths (0 ≤ src < vertex_count). * The graph is represented as an adjacency matrix `self.graph` within the `Dijkstra` class. Output * Returns a list of integers where the ith element represents the shortest distance from the source `src` to vertex `i`. Constraints * The number of vertices (V) (given by `vertex_count`) will be in the range [2, 1000]. * All edges have non-negative weights. Example Assume an instance `d` of class `Dijkstra` initialized with 5 vertices. The graph is modified to: ```python d.graph = [ [0, 10, 0, 0, 5], [0, 0, 1, 0, 2], [0, 0, 0, 4, 0], [7, 0, 6, 0, 0], [0, 3, 9, 2, 0] ] ``` * Input: `src = 0` * Expected Output: `[0, 8, 9, 7, 5]` # Instructions 1. Complete the `dijkstra` method in the `Dijkstra` class. 2. Validate functionality and edge cases in your code. You have been provided a code snippet of the `Dijkstra` class with a skeleton of the `dijkstra` method. Implement the method to solve the problem.","solution":"import sys from typing import List class Dijkstra: def __init__(self, vertex_count: int): self.vertex_count = vertex_count self.graph = [[0] * vertex_count for _ in range(vertex_count)] def min_distance(self, dist: List[int], spt_set: List[bool]) -> int: min_val = sys.maxsize min_index = -1 for v in range(self.vertex_count): if dist[v] < min_val and not spt_set[v]: min_val = dist[v] min_index = v return min_index def dijkstra(self, src: int) -> List[int]: dist = [sys.maxsize] * self.vertex_count dist[src] = 0 spt_set = [False] * self.vertex_count for _ in range(self.vertex_count): u = self.min_distance(dist, spt_set) spt_set[u] = True for v in range(self.vertex_count): if (self.graph[u][v] > 0 and not spt_set[v] and dist[u] != sys.maxsize and dist[u] + self.graph[u][v] < dist[v]): dist[v] = dist[u] + self.graph[u][v] return dist"},{"question":"# Question You have been tasked with determining if one string is a rotation of another. This classic problem involves checking whether two strings are cyclic permutations of one another. A rotational version means we can shift characters in the string cyclically (moving characters from end to start) to match another string. Implement a function `is_rotated` that achieves this task efficiently: Function Signature: ```python def is_rotated(s1: str, s2: str) -> bool: pass ``` Input: - `s1` (str): The original string. - `s2` (str): The string which might be a rotated version of `s1`. Output: - Return `True` if `s2` is a rotated version of `s1`, otherwise `False`. Constraints: - Both input strings will have a length between 0 and 1000. - Both strings consist of lowercase English letters only. Performance Requirements: - The implementation should aim for an O(N) time complexity where N is the length of the input strings. - The space complexity should be O(N). Example: 1. `is_rotated(\\"hello\\", \\"llohe\\")` should return `True`. 2. `is_rotated(\\"hello\\", \\"helol\\")` should return `False`. 3. `is_rotated(\\"\\", \\"\\")` should return `True`. Edge Cases to Consider: - Strings of different lengths should return `False`. - Empty strings should be handled appropriately. **Note**: Avoid using any library functions that directly solve this problem (e.g., function that checks all rotations). Write a robust and optimized function to solve this problem.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determines if s2 is a rotation of s1. Args: s1: str - The original string. s2: str - The string which might be a rotated version of s1. Returns: bool - True if s2 is a rotated version of s1, otherwise False. if len(s1) != len(s2): return False if not s1: return True concatenated = s1 + s1 return s2 in concatenated"},{"question":"You are given an array of integers and a target value. Your task is to implement a function that finds two unique indices in the array where the values at these indices sum up to the target value. You can assume there will always be one unique solution, and each input will not use the same element twice for the result. Function Signature: ```python def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: ``` Parameters: - `nums` (List[int]): A list of integers. - `target` (int): The target sum value. Returns: - A tuple containing two integers, the indices of the two numbers that add up to the target. Constraints: - Each input will have exactly one solution. - You may not use the same element twice. Example: ```python nums = [2, 7, 11, 15] target = 9 assert find_two_sum_indices(nums, target) == (0, 1) ``` Performance Requirements: - The solution should run in linear time complexity O(n) with respect to the size of the input list. - Space complexity should also be O(n) due to the use of supporting data structures. Your implementation needs to handle edge cases, such as: - An array of minimal size that still meets the problem constraints. - Ensure proper handling if no valid pair exists, albeit according to constraints, this won\'t occur.","solution":"from typing import List, Tuple def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: Finds two unique indices such that the numbers at these indices sum up to the target value. :param nums: List of integers :param target: Target sum value :return: A tuple containing two integers, the indices of the two numbers that add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i # This line should never be reached because the problem guarantees a unique solution. raise ValueError(\\"No two sum solution found\\")"},{"question":"You have been tasked to implement a different, but related sorting algorithm, named Selection Sort, and modify it to return both the sorted array as well as information similar to Insertion Sort\'s intermediate states. # **Description** Selection Sort is another basic sorting algorithm that divides the input list into two parts: a sorted sublist of items which is built up from left to right at the front of the list, and a sublist of the remaining unsorted items. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest) element in the unsorted sublist, swapping it with the leftmost unsorted element, and moving the sublist boundaries one element to the right. # **Task** Write a function `selection_sort(arr, simulation=False)` that: - Sorts the input list `arr` using the Selection Sort algorithm. - If the `simulation` parameter is set to `True`, prints the state of the list after each iteration of the outer loop. The output should be in the format: `\\"iteration x: [current state of list]\\"` where `x` starts from 0. - Returns the sorted list. # **Function Signature** ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # **Input** - `arr`: List of integers to be sorted. - `simulation`: A boolean flag indicating whether to print the intermediate states. # **Output** - The sorted list of integers. # **Constraints** - The list can be empty or contain up to 10^4 elements. - Each element can be between -10^6 and 10^6. # **Example** ```python # Example 1: arr = [64, 25, 12, 22, 11] selection_sort(arr, simulation=True) # Should output: # iteration 0 : [11, 25, 12, 22, 64] # iteration 1 : [11, 12, 25, 22, 64] # iteration 2 : [11, 12, 22, 25, 64] # iteration 3 : [11, 12, 22, 25, 64] # Example 2: arr = [5, 3, 8, 4, 2] selection_sort(arr, simulation=True) # Should output: # iteration 0 : [2, 3, 8, 4, 5] # iteration 1 : [2, 3, 8, 4, 5] # iteration 2 : [2, 3, 4, 8, 5] # iteration 3 : [2, 3, 4, 5, 8] ``` Write appropriate test cases to validate your solution.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] if simulation: print(f\\"iteration {i} : {arr}\\") return arr"},{"question":"# Red-Black Tree Deletion **Scenario**: You are working on a database system that uses a Red-Black tree to index its records. Implementing efficient deletion to maintain the balanced nature of the tree is crucial for optimizing query performance. You are required to complete the Red-Black tree deletion process while ensuring that the tree properties remain intact. **Task**: Write a function `delete_value(self, value)` that deletes a node with the given value from the Red-Black Tree. Your function should preserve all properties of the Red-Black Tree. **Input/Output**: - **Input**: - `self`: A reference to the RBTree instance. - `value` (int): The value to be deleted from the tree. - **Output**: - None. (The function should directly modify the tree structure.) **Constraints**: - The value to be deleted will always be present in the tree. - Ensure that after deletion, the tree maintains its Red-Black properties. **Function Signature**: ```python class RBTree: ... def delete_value(self, value: int) -> None: # Implement the function here. pass ``` **Example**: ```python rb = RBTree() nodes = [20, 15, 25, 10, 17, 22, 30] for value in nodes: rb.insert(RBNode(value, is_red=True)) rb.delete_value(17) print(rb.inorder()) # The output should show the tree in sorted order without the value 17 rb.delete_value(15) print(rb.inorder()) # The output should show the tree in sorted order without the value 15 ``` **Performance Requirements**: - Ensure that the deletion operation runs in O(log n) time complexity.","solution":"class RBNode: def __init__(self, value, is_red=True): self.value = value self.left = None self.right = None self.parent = None self.is_red = is_red class RBTree: def __init__(self): self.nil = RBNode(value=None, is_red=False) # Sentinel nil node, which is black self.root = self.nil def insert(self, node): current = self.root parent = None while current != self.nil: parent = current if node.value < current.value: current = current.left else: current = current.right node.parent = parent if parent is None: # New tree self.root = node elif node.value < parent.value: parent.left = node else: parent.right = node node.left = self.nil node.right = self.nil node.is_red = True self._insert_fixup(node) def _insert_fixup(self, node): while node != self.root and node.parent.is_red: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.is_red: node.parent.is_red = False uncle.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.right: node = node.parent self._left_rotate(node) node.parent.is_red = False node.parent.parent.is_red = True self._right_rotate(node.parent.parent) else: uncle = node.parent.parent.left if uncle.is_red: node.parent.is_red = False uncle.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.left: node = node.parent self._right_rotate(node) node.parent.is_red = False node.parent.parent.is_red = True self._left_rotate(node.parent.parent) self.root.is_red = False def _left_rotate(self, x): y = x.right x.right = y.left if y.left != self.nil: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def _right_rotate(self, y): x = y.left y.left = x.right if x.right != self.nil: x.right.parent = y x.parent = y.parent if y.parent is None: self.root = x elif y == y.parent.left: y.parent.left = x else: y.parent.right = x x.right = y y.parent = x def delete_value(self, value): z = self.root while z != self.nil: if z.value == value: break elif z.value < value: z = z.right else: z = z.left if z == self.nil: return # Node to be deleted not found y = z y_original_color = y.is_red if z.left == self.nil: x = z.right self._transplant(z, z.right) elif z.right == self.nil: x = z.left self._transplant(z, z.left) else: y = self._minimum(z.right) y_original_color = y.is_red x = y.right if y.parent == z: x.parent = y else: self._transplant(y, y.right) y.right = z.right y.right.parent = y self._transplant(z, y) y.left = z.left y.left.parent = y y.is_red = z.is_red if y_original_color == False: self._delete_fixup(x) def _delete_fixup(self, x): while x != self.root and x.is_red == False: if x == x.parent.left: w = x.parent.right if w.is_red: w.is_red = False x.parent.is_red = True self._left_rotate(x.parent) w = x.parent.right if w.left.is_red == False and w.right.is_red == False: w.is_red = True x = x.parent else: if w.right.is_red == False: w.left.is_red = False w.is_red = True self._right_rotate(w) w = x.parent.right w.is_red = x.parent.is_red x.parent.is_red = False w.right.is_red = False self._left_rotate(x.parent) x = self.root else: w = x.parent.left if w.is_red: w.is_red = False x.parent.is_red = True self._right_rotate(x.parent) w = x.parent.left if w.left.is_red == False and w.right.is_red == False: w.is_red = True x = x.parent else: if w.left.is_red == False: w.right.is_red = False w.is_red = True self._left_rotate(w) w = x.parent.left w.is_red = x.parent.is_red x.parent.is_red = False w.left.is_red = False self._right_rotate(x.parent) x = self.root x.is_red = False def _transplant(self, u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _minimum(self, node): while node.left != self.nil: node = node.left return node def inorder(self): def inorder_helper(node): return inorder_helper(node.left) + [node.value] + inorder_helper(node.right) if node != self.nil else [] return inorder_helper(self.root)"},{"question":"# Question: You are required to enhance the `RBTree` class which implements a Red-Black Tree. Specifically, you need to add functionality to count the number of black nodes on any path from the root to a leaf. Additionally, you need to verify that this count remains consistent across all such paths in the tree, adhering to the properties of a Red-Black Tree. Task Implement the following function in the `RBTree` class: ```python def validate_black_node_count(self) -> bool: Validate that all paths from the root to leaves have the same number of black nodes. Returns: bool: True if the tree is valid, False otherwise. ``` Input There is no specific input for this function; it operates on the tree instance. Output * `bool`: Return `True` if all paths from the root to leaves have the same number of black nodes. Return `False` otherwise. Constraints * The function must be implemented as a method within the `RBTree` class. * The tree can have any number of nodes. * Assume the rest of the Red-Black Tree implementation (as provided) works correctly. Example Consider the Red-Black Tree created by the following sequence of insertions: ```python rb = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] for val in nodes: node = RBNode(val, 1) rb.insert(node) ``` The tree should be validated for the same number of black nodes on all root-to-leaf paths: ```python print(rb.validate_black_node_count()) # Expected: True, as the tree maintains Red-Black properties. ``` Note Ensure you thoroughly test your function with diverse tree structures to cover various edge cases, such as trees with only one node, trees with multiple rebalancing operations, and trees with varying depths.","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # 0 for black, 1 for red self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def insert(self, key): # Standard RBTree insert logic pass def __validate_black_node_count(self, node): if node is None or node == self.TNULL: return 1 left_count = self.__validate_black_node_count(node.left) right_count = self.__validate_black_node_count(node.right) if left_count == 0 or right_count == 0 or left_count != right_count: return 0 # Count this node if it is black if node.color == 0: return left_count + 1 else: return left_count def validate_black_node_count(self) -> bool: Validate that all paths from the root to leaves have the same number of black nodes. black_count = self.__validate_black_node_count(self.root) return black_count > 0"},{"question":"# Context You have been given a binary tree and tasked with implementing a function to perform postorder traversal on it. Postorder traversal visits nodes of a binary tree following the order: left subtree, right subtree, and then the root node. You need to implement both iterative and recursive approaches to this traversal. # Problem Statement Implement the following functions in Python: 1. `postorder_iterative(root)`: Perform postorder traversal iteratively using a stack. 2. `postorder_recursive(root)`: Perform postorder traversal recursively. # Input - A binary tree represented as a series of `Node` objects. Each `Node` has the following attributes: - `val`: Integer value of the node. - `left`: Left child Node or None. - `right`: Right child Node or None. # Output - The functions should return a list of integers representing the postorder traversal of the binary tree. # Constraints - The number of nodes in the tree will be at most 1000. - The values of the nodes will be within the range of -1000 to 1000. # Example ```python # Creating a tree # 1 # / # 2 3 # / # 4 5 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) assert postorder_iterative(root) == [4, 5, 2, 3, 1] assert postorder_recursive(root) == [4, 5, 2, 3, 1] ``` # Function Signatures ```python def postorder_iterative(root: Node) -> List[int]: # Implement the iterative postorder traversal pass def postorder_recursive(root: Node) -> List[int]: # Implement the recursive postorder traversal pass ```","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def postorder_iterative(root: Optional[Node]) -> List[int]: if not root: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recursive(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node], result: List[int]): if not node: return helper(node.left, result) helper(node.right, result) result.append(node.val) result = [] helper(root, result) return result"},{"question":"You are given an array of integers and a function that must be commutative (i.e., f(a, b) = f(b, a)) and associative. Implement a `SegmentTree` class which supports the following operations: * **Initialization**: Creates the segment tree from the given array and function. * **Update**: Updates a particular index with a new value. * **Query**: Returns the result of the function applied over a specified range of indices [l, r]. Your task is to implement this `SegmentTree` class in Python. # Function Specification `__init__(self, arr: List[int], function: Callable[[int, int], int]) -> None` * **Arguments**: * `arr`: List of integers representing the initial array. * `function`: A commutative function (e.g., sum, min, max) that takes two arguments of the same type as the elements of the array. * **Returns**: None `update(self, index: int, value: int) -> None` * **Arguments**: * `index`: The index of the element to update. * `value`: The new value for the element at the given index. * **Returns**: None `query(self, left: int, right: int) -> int` * **Arguments**: * `left`: The left index of the range (inclusive). * `right`: The right index of the range (inclusive). * **Returns**: The result of the function applied to the elements in the range [left, right]. # Constraints * `1 <= len(arr) <= 10^5` * `0 <= arr[i], value <= 10^6` * `0 <= index < len(arr)` * `0 <= left <= right < len(arr)` # Example ```python # Initialize array and function for Segment Tree arr = [4, 5, 2, 3, 4, 43, 3] seg_tree = SegmentTree(arr, lambda a, b: a + b) # Query range sum from index 0 to 6 print(seg_tree.query(0, 6)) # Output: 64 # Update element at index 2 to -10 seg_tree.update(2, -10) # Query range sum from index 0 to 6 again print(seg_tree.query(0, 6)) # Output: 52 ``` # Solution Requirements * Implement the `SegmentTree` class based on the provided specifications. * Ensure your solution handles the edge cases. * Aim for both correct and efficient implementation, considering the constraints.","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: int) -> None: # Update the value at the leaf node pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left: int, right: int) -> int: # Perform the query on range [left, right] left += self.n right += self.n result = self.tree[left] if left != right: result = self.function(result, self.tree[right]) while left < right - 1: if left % 2 == 0: result = self.function(result, self.tree[left + 1]) if right % 2 == 1: result = self.function(result, self.tree[right - 1]) left //= 2 right //= 2 return result"},{"question":"You are required to extend the functionality of the given `ResizableHashTable` class. Specifically, implement an additional method `keys_starting_with_vowel` that returns a list of all keys starting with a vowel (a, e, i, o, u). # Task Implement the method `keys_starting_with_vowel` in the `ResizableHashTable` class which returns a list of all keys that start with a vowel. # Function Signature ```python class ResizableHashTable(HashTable): ... def keys_starting_with_vowel(self) -> list: pass ``` # Input Format - The method does not take any parameters. # Output Format - Return a list of keys starting with a vowel. # Constraints - Keys are assumed to be non-negative integers up to 10^6. - Assume that the initial size of the hashtable is as defined in the `ResizableHashTable` class. # Example ```python # Example usage rht = ResizableHashTable() rht.put(0, \'zero\') rht.put(1, \'one\') rht.put(5, \'five\') rht.put(10, \'ten\') print(rht.keys_starting_with_vowel()) # Output might be [1] assuming the keys themselves are considered as \\"string\\" representation for the condition of starting with a vowel. ``` # Implementation Details - Ensure your method is efficient and handles the resizing property of the hashtable correctly. - Do not utilize additional data structures or libraries for filtering the keys.","solution":"class HashTable: def __init__(self): self.table = {} def put(self, key, value): self.table[key] = value def get(self, key): return self.table.get(key) class ResizableHashTable(HashTable): def __init__(self): super().__init__() def keys_starting_with_vowel(self) -> list: vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} result = [key for key in self.table.keys() if str(key)[0].lower() in vowels] return result"},{"question":"# Problem Description You are given a list of integers that is initially empty. Implement a class `OrderedStream` that supports two main operations: 1. **insert(value)**: Insert a value into the stream while maintaining the order of the elements. 2. **search_insert_position(value)**: Return the index at which `value` should be inserted to maintain the sorted order. Implement the `OrderedStream` class with the following methods: Method: `insert` - **Description**: Inserts a value into the ordered stream. - **Input**: A single integer value. - **Output**: None. Method: `search_insert_position` - **Description**: Searches and returns the index where the given value should be inserted to maintain sorted order. - **Input**: A single integer value. - **Output**: An integer index. Constraints - You can assume that all integer values are within the range of -10^4 to 10^4. - No duplicates will be inserted. # Example ```python os = OrderedStream() print(os.search_insert_position(3)) # Output: 0 os.insert(3) print(os.search_insert_position(1)) # Output: 0 os.insert(1) print(os.search_insert_position(2)) # Output: 1 os.insert(2) print(os.search_insert_position(5)) # Output: 3 os.insert(5) ``` # Additional Notes You are encouraged to use the provided `search_insert` method for the `search_insert_position` within your class implementation.","solution":"class OrderedStream: def __init__(self): self.stream = [] def insert(self, value): pos = self.search_insert_position(value) self.stream.insert(pos, value) def search_insert_position(self, value): # Since the stream is ordered, we can perform binary search to find the correct position low, high = 0, len(self.stream) while low < high: mid = (low + high) // 2 if self.stream[mid] < value: low = mid + 1 else: high = mid return low"},{"question":"# Challenge: Delete Node in a Singly Linked List Given a node (excluding the tail) in a singly linked list, write a function `delete_node(node: Node) -> None` that deletes the node from the list. The node to be deleted will always be a valid node and not the tail node. Input - A single `Node` instance representing the node to be deleted. The node is guaranteed to be neither `None` nor the tail of the list. Output - Do not return anything. Modify the list in place by removing the `node`. Example Suppose the linked list is `1 -> 2 -> 3 -> 4` and you are given the third node (value 3). Calling your function should result in the list `1 -> 2 -> 4`. ```python # Example Testing Function def test_delete_node(): head = Node(1) head.next = Node(2) node3 = head.next.next = Node(3) head.next.next.next = Node(4) delete_node(node3) # Expected linked list is 1 -> 2 -> 4 assert head.val == 1 assert head.next.val == 2 assert head.next.next.val == 4 assert head.next.next.next is None test_delete_node() ``` Constraints - The node provided is always valid (not `None`) and is never the tail node of the list. Notes - Implement robust error checking to avoid mishandling node deletions outside the constraints.","solution":"class Node: def __init__(self, val: int, next=None): self.val = val self.next = next def delete_node(node: Node) -> None: Function to delete a non-tail node from a singly linked list. This is achieved by copying the value of the next node into the provided node and then skipping the next node in the list. if node is None or node.next is None: raise ValueError(\\"Node must be valid and cannot be the tail node\\") node.val = node.next.val node.next = node.next.next"},{"question":"# Ternary Search in Extended Use Consider an array of integers sorted in ascending order. You need to write a function that uses the ternary search algorithm to find the index of the first occurrence of a given key. Additionally, we will extend the usability of the ternary search algorithm by incorporating a secondary functionality: finding the last occurrence of the given key in the array. **Function Signature**: ```python def ternary_search_extended(arr, key): Finds the first and the last occurrence of the given key in the sorted array. :param arr: List[int] - A list of sorted integers. :param key: int - The integer to be searched in the array. :return: Tuple[int, int] - A tuple containing the indices of the first and last occurrence of the key in the array. If the key is not found, return (-1, -1). ``` **Input**: - `arr`: A list of sorted integers [e.g., [1, 2, 2, 3, 4, 4, 5]] - `key`: An integer to search in the array [e.g., 4] **Output**: - Return a tuple with two integers: - The index of the first occurrence of `key` (e.g., 4). - The index of the last occurrence of `key` (e.g., 5). - If `key` is not found in the array, return `(-1, -1)`. **Constraints**: - The input array `arr` will have a maximum length of 10^6. - The elements in the array are integers in the range [-10^9, 10^9]. - For optimal performance, avoid using in-built search utilities. **Example**: ```python assert ternary_search_extended([1, 2, 2, 3, 4, 4, 5], 4) == (4, 5) assert ternary_search_extended([1, 2, 2, 3, 4, 4, 5], 6) == (-1, -1) assert ternary_search_extended([1, 1, 1, 1, 1, 1, 1], 1) == (0, 6) ``` **Explanation**: - You are required to implement the ternary search algorithm to find both the first and last occurrence of a `key`. - Handle cases where the key does not exist in the array. - Consider edge cases such as arrays with repeated elements, empty arrays, and single-element arrays.","solution":"def ternary_search_extended(arr, key): Finds the first and the last occurrence of the given key in the sorted array. :param arr: List[int] - A list of sorted integers. :param key: int - The integer to be searched in the array. :return: Tuple[int, int] - A tuple containing the indices of the first and last occurrence of the key in the array. If the key is not found, return (-1, -1). def find_first_occurrence(arr, key): low, high = 0, len(arr) - 1 while low <= high: third = (high - low) // 3 mid1 = low + third mid2 = high - third if arr[mid1] == key: high = mid1 - 1 elif arr[mid1] < key: low = mid1 + 1 else: high = mid1 - 1 return low if low < len(arr) and arr[low] == key else -1 def find_last_occurrence(arr, key): low, high = 0, len(arr) - 1 while low <= high: third = (high - low) // 3 mid1 = low + third mid2 = high - third if arr[mid2] == key: low = mid2 + 1 elif arr[mid2] > key: high = mid2 - 1 else: low = mid2 + 1 return high if high >= 0 and arr[high] == key else -1 first_occ = find_first_occurrence(arr, key) last_occ = find_last_occurrence(arr, key) return (first_occ, last_occ)"},{"question":"# Problem: Next Lexicographical Permutation Given an integer, write a function `next_bigger` that rearranges its digits to create the next lexicographically larger permutation. If no such permutation exists, return -1. # Requirements - Input format: - A single integer, `num`. - Output format: - An integer representing the next lexicographical permutation of `num`. Return -1 if no such permutation exists. - Constraints: - The input integer is guaranteed to be positive. - The length of the input integer will not exceed 10 digits. # Performance Expectations - The function should exhibit a time complexity of O(n) where n is the number of digits in the input number. - The function should exhibit a space complexity of O(n). # Function Signature ```python def next_bigger(num: int) -> int: # Your implementation here ``` # Examples Example 1 - Input: `38276` - Output: `38627` Example 2 - Input: `12345` - Output: `12354` Example 3 - Input: `54321` - Output: `-1` Example 4 - Input: `999` - Output: `-1` Example 5 - Input: `4175` - Output: `4517` # Implementation Steps 1. Convert the number to a list of its digits. 2. Traverse the list from the end to find the first pair of digits that are in increasing order. 3. Swap this digit with the smallest digit larger than it to its right. 4. Reverse the order of digits to the right of the swapped position to get the smallest possible sequence. 5. Convert the list back to an integer. 6. Return the result, or -1 if no greater permutation exists.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the first pair of digits that are in increasing order from the end. i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: return -1 # If no such pair exists, the number is the highest permutation. # Step 2: Find the smallest digit on the right side of (i) which is larger than digits[i]. j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the above-found pair of digits. digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the order of digits after position i. digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\'\'.join(digits))"},{"question":"Find the Nth Digit **Context**: You have a long sequence made by concatenating positive integers in order: \\"123456789101112131415...\\". Given an integer `n`, you need to find the nth digit in this infinite sequence. **Function Signature**: ```python def find_nth_digit(n: int) -> int: pass ``` **Input**: - `n` (1 ≤ n ≤ 2^31 - 1) **Output**: - An integer representing the nth digit in the sequence. **Constraints**: - You must find the digit without constructing the entire sequence. **Examples**: 1. `find_nth_digit(3)` should return `3`. 2. `find_nth_digit(11)` should return `0`. **Explanation**: 1. The sequence is \\"123456789101112...\\". The 3rd digit is \\"3\\". 2. The sequence is \\"123456789101112...\\". The 11th digit is \\"0\\" from \\"10\\". **Performance Requirement**: - Your solution should run efficiently with logarithmic time complexity O(log(n)).","solution":"def find_nth_digit(n: int) -> int: # Initial range (1-9: 9 digits, 10-99: 180 digits, 100-999: 2700 digits, etc.) digit_length = 1 count = 9 start = 1 # Find the range in which the nth digit is located while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Determine the actual number that contains the desired digit start += (n - 1) // digit_length # Get the digit within the number digit_index = (n - 1) % digit_length return int(str(start)[digit_index])"},{"question":"You are given a positive integer `n` and need to implement a function that calculates how many different ways `n` can be partitioned into sums of positive integers. Consider that the order of addends does not matter (e.g., `1+2` is considered the same partition as `2+1`). # Function Signature ```python def count_partitions(n: int) -> int: pass ``` # Input * `n` (1 <= n <= 100): A positive integer to partition into sums of other integers. # Output * Returns an integer representing the count of distinct partitions of `n`. # Constraints * Ensure that your solution is efficient and can handle the upper limit within reasonable time and space requirements. # Example ```python assert count_partitions(4) == 5 assert count_partitions(7) == 15 ``` # Explanation For `n = 4`: - `4` - `3+1` - `2+2` - `2+1+1` - `1+1+1+1` Total = 5 partitions For `n = 7`: - `7` - `6+1` - `5+2` - `5+1+1` - `4+3` - And many more, totaling 15 partitions. # Hints * Use a dynamic programming approach similar to the provided example. Create a 2D array to store intermediate results. * The general formula for the problem can be derived by considering smaller subpartitions and using them to build up to the final count for `n`.","solution":"def count_partitions(n: int) -> int: # Initialize a table to store the results of subproblems dp = [[0] * (n + 1) for _ in range(n + 1)] # Base case: There\'s exactly one way to partition 0, which is not to use any number for i in range(n + 1): dp[i][0] = 1 # Fill the table in a bottom-up manner for i in range(1, n + 1): for j in range(1, n + 1): if j >= i: dp[i][j] = dp[i - 1][j] + dp[i][j - i] else: dp[i][j] = dp[i - 1][j] # The result is in dp[n][n], which is the number of partitions of n using numbers up to n return dp[n][n]"},{"question":"# Question: Detect Cycles in a Friend Recommendation System In a social network\'s friend recommendation system, you are to determine if the suggested friends form any cyclic group relationships. The network\'s friend relations are represented as a directed graph, where each user points to others they are recommending. **Task**: Write a function `detect_cyclic_friendships(friend_recommendations: Dict[str, List[str]]) -> bool` that determines if there is a cycle in the friend recommendation graph. **Input**: - A dictionary `friend_recommendations` where the key is a user\'s name (string), and the value is a list of names (strings) that the user recommends. ```python { \\"Alice\\": [\\"Bob\\", \\"Charlie\\"], \\"Bob\\": [\\"Diana\\"], \\"Charlie\\": [\\"Eve\\"], \\"Diana\\": [\\"Charlie\\", \\"Eve\\"], \\"Eve\\": [\\"Frank\\"], \\"Frank\\": [] } ``` **Output**: - A boolean value `True` if there is at least one cycle in the friend recommendation graph, else `False`. **Constraints**: - The number of users and recommendations can be up to 10^4. - All users\' names are unique strings. **Performance**: - Your solution must efficiently handle the graph size within the constraints, especially in terms of time complexity. # Examples ```python friend_recommendations = { \\"Alice\\": [\\"Bob\\", \\"Charlie\\"], \\"Bob\\": [\\"Diana\\"], \\"Charlie\\": [\\"Eve\\"], \\"Diana\\": [\\"Charlie\\", \\"Eve\\"], \\"Eve\\": [\\"Frank\\"], \\"Frank\\": [] } print(detect_cyclic_friendships(friend_recommendations)) # Output: True friend_recommendations = { \\"Alice\\": [\\"Bob\\", \\"Charlie\\"], \\"Bob\\": [\\"Diana\\"], \\"Charlie\\": [\\"Eve\\"], \\"Diana\\": [\\"Eve\\"], \\"Eve\\": [\\"Frank\\"], \\"Frank\\": [] } print(detect_cyclic_friendships(friend_recommendations)) # Output: False ``` # Solution Template ```python from enum import Enum from typing import Dict, List class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def detect_cyclic_friendships(friend_recommendations: Dict[str, List[str]]) -> bool: def is_in_cycle(graph, traversal_states, vertex): if traversal_states[vertex] == TraversalState.GRAY: return True traversal_states[vertex] = TraversalState.GRAY for neighbor in graph[vertex]: if traversal_states[neighbor] != TraversalState.BLACK: if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False traversal_states = {vertex: TraversalState.WHITE for vertex in friend_recommendations} for vertex in traversal_states: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(friend_recommendations, traversal_states, vertex): return True return False ```","solution":"from enum import Enum from typing import Dict, List class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def detect_cyclic_friendships(friend_recommendations: Dict[str, List[str]]) -> bool: def is_in_cycle(graph, traversal_states, vertex): if traversal_states[vertex] == TraversalState.GRAY: return True traversal_states[vertex] = TraversalState.GRAY for neighbor in graph[vertex]: if traversal_states[neighbor] != TraversalState.BLACK: if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False traversal_states = {vertex: TraversalState.WHITE for vertex in friend_recommendations} for vertex in traversal_states: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(friend_recommendations, traversal_states, vertex): return True return False"},{"question":"Problem: Linear Search Enhancements You are tasked with enhancing the basic linear search algorithm provided to handle some additional functionalities and edge cases more efficiently. Specifically, you need to implement a function that performs a linear search but returns multiple relevant results and also handles some specific constraints. # Function Signature ```python def enhanced_linear_search(array, queries): Enhanced linear search function. Parameters: array (list): Non-empty list of integers. queries (list): List of integers to search for. Returns: dict: A dictionary where each key is a query from the queries list and its value is a list of indices where the query is found in the array. If a query is not found, the value should be an empty list. ``` # Input * `array` is a non-empty list of integers, where the length of the array (n) is at most 1000. * `queries` is a list of integers, where the length of the queries list (m) is at most 100. # Output * Return a dictionary where each query in `queries` is a key, and its value is a list of integers representing the indices in the array where the query is found. If a query is not found in the array, its value should be an empty list. # Example ```python assert enhanced_linear_search([10, 20, 30, 10, 40], [10, 40, 50]) == {10:[0, 3], 40:[4], 50:[]} assert enhanced_linear_search([1, 2, 3, 4, 5], [5, 1]) == {5: [4], 1: [0]} assert enhanced_linear_search([0, 0, 0, 0], [0, 1]) == {0: [0, 1, 2, 3], 1: []} ``` # Constraints * The algorithm should maintain a time complexity of O(n * m), where n is the length of the array and m is the length of the queries list. * The input array will always contain integers, and the integers in the queries list might or might not be present in the array. # Notes * Ensure your implementation is efficient and handles edge cases such as empty query results. * Any invalid inputs (such as non-integer array elements or non-list inputs) can be ignored for the purpose of this exercise.","solution":"def enhanced_linear_search(array, queries): Enhanced linear search function. Parameters: array (list): Non-empty list of integers. queries (list): List of integers to search for. Returns: dict: A dictionary where each key is a query from the queries list and its value is a list of indices where the query is found in the array. If a query is not found, the value should be an empty list. result = {query: [] for query in queries} for query in queries: for index, value in enumerate(array): if value == query: result[query].append(index) return result"},{"question":"# Bitonic Sort Implementation and Usage You have learned about the bitonic sort algorithm, which is used primarily in parallel processing but can also be implemented non-parallelly with certain limitations. Now, it\'s your turn to apply this algorithm in a specific context. Problem Statement You are given an array of integers and a boolean flag `reverse`, which indicates whether to sort the array in ascending (`reverse=False`) or in descending order (`reverse=True`). Your task is to sort the array using the bitonic sort algorithm. However, to simulate a more realistic scenario, let\'s add some constraints and edge cases to handle: 1. If the array size is not a power of two, you must raise a `ValueError` with the message \\"The size of input should be a power of two\\". 2. The function should be able to handle arrays of size 0 or 1 efficiently. 3. Sorting must adhere precisely to the bitonic sort mechanism and properties. Input * An array `arr` of integers. * A boolean `reverse`. Output * The sorted array according to the `reverse` flag. Constraints 1. The input array `arr` shall only contain integers. 2. If the size of the array is not a power of two, raise a `ValueError`. 3. You are required to use the bitonic sort algorithm. Sample Input/Output ```python # Input 1 arr = [3, 7, 4, 8, 6, 2, 1, 5] reverse = False # Output 1 [1, 2, 3, 4, 5, 6, 7, 8] # Input 2 arr = [10, 30, 20, 40, 60, 50, 70, 80] reverse = True # Output 2 [80, 70, 60, 50, 40, 30, 20, 10] # Input 3 arr = [3, 1] reverse = False # Output 3 [1, 3] # Input 4 arr = [5] reverse = True # Output 4 [5] # Input 5 arr = [3, 7, 4] reverse = True # Output 5 ValueError: The size of input should be a power of two ``` Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` Note Ensure that your implementation correctly handles all the above constraints and edge cases, sticking firmly to the bitonic sort principles. You can use helper functions if needed to keep your main function clean and readable.","solution":"def bitonic_sort(arr, reverse=False): Perform bitonic sort on the given array. Args: arr (list): List of integers to be sorted. reverse (bool): Boolean flag to indicate ascending or descending order. Returns: list: Sorted list in the specified order. Raises: ValueError: If the size of input is not a power of two. if len(arr) == 0 or (len(arr) & (len(arr) - 1)) != 0: raise ValueError(\\"The size of input should be a power of two\\") def compare_and_swap(a, i, j, dir): if dir == (a[i] > a[j]): a[i], a[j] = a[j], a[i] def bitonic_merge(a, low, cnt, dir): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(a, i, i + k, dir) bitonic_merge(a, low, k, dir) bitonic_merge(a, low + k, k, dir) def bitonic_sort_recursive(a, low, cnt, dir): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(a, low, k, True) # Ascending order bitonic_sort_recursive(a, low + k, k, False) # Descending order bitonic_merge(a, low, cnt, dir) bitonic_sort_recursive(arr, 0, len(arr), not reverse) return arr"},{"question":"# Array Rotation Challenge Objectives: Given an array of integers and a non-negative integer k, rotate the array to the right by k steps. Implement the function `rotate_array(array, k)` using different approaches: 1. Simple shift method. 2. Reverse segment method. 3. Slicing concatenation method. Requirements: 1. You must provide the implementation for the three methods as described: - `rotate_simple(array, k)` - `rotate_reverse(array, k)` - `rotate_slice(array, k)` 2. The main function `rotate_array` should accept the array and k, and return a list containing results of each method in the specified order. Input: - A list of integers (`array`). - A non-negative integer (`k`). Output: - A list of lists (`result`). Each inner list represents the rotation result from one of the three methods. Example: ```python array = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate_array(array, k) ``` Expected output: ```python [[5, 6, 7, 1, 2, 3, 4], [5, 6, 7, 1, 2, 3, 4], [5, 6, 7, 1, 2, 3, 4]] ``` Constraints: - `1 <= len(array) <= 10^5` - `0 <= k <= 10^9` - You should aim to achieve O(n) time complexity. - Methods should be robust against edge cases. ```python def rotate_array(array, k): def rotate_simple(array, k): n = len(array) k %= n for i in range(k): temp = array[n - 1] for j in range(n - 1, 0, -1): array[j] = array[j - 1] array[0] = temp return array def rotate_reverse(array, k): def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 n = len(array) k %= n reverse(array, 0, n - 1) reverse(array, 0, k - 1) reverse(array, k, n - 1) return array def rotate_slice(array, k): n = len(array) k %= n return array[n - k:] + array[:n - k] result = [] result.append(rotate_simple(array[:], k)) # Using array[:] to avoid in-place modification result.append(rotate_reverse(array[:], k)) result.append(rotate_slice(array, k)) return result ```","solution":"def rotate_simple(array, k): n = len(array) k %= n for _ in range(k): temp = array[n - 1] for j in range(n - 1, 0, -1): array[j] = array[j - 1] array[0] = temp return array def rotate_reverse(array, k): def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 n = len(array) k %= n reverse(array, 0, n - 1) reverse(array, 0, k - 1) reverse(array, k, n - 1) return array def rotate_slice(array, k): n = len(array) k %= n return array[-k:] + array[:-k] def rotate_array(array, k): return [ rotate_simple(array[:], k), rotate_reverse(array[:], k), rotate_slice(array[:], k) ]"},{"question":"# Coding Task: Symbol Replacement in Words Objective Implement a function that replaces substrings in a list of words with the longest match from a list of symbols, wrapping the match in square brackets. Detailed Description You are given: * A list of words. * A list of symbols. You need to create a function `replace_symbols(words: List[str], symbols: List[str]) -> List[str]` that processes each word and replaces the matching symbol with the longest match from symbols wrapped in square brackets. If a word contains multiple symbols, only the longest match should be considered. If no match is found within a given word, the word should remain unchanged. Input and Output Formats * **Input**: - `words`: A list of non-empty strings representing the words. - `symbols`: A list of non-empty strings representing the symbols. * **Output**: - A list of strings where each word has the symbols replaced by the longest match in square brackets. Constraints * Each word and each symbol only consists of lowercase and/or uppercase English letters. * No symbol is an empty string. * Length of `words` array does not exceed 1000. * Length of `symbols` array does not exceed 1000. * No word or symbol exceeds 100 characters in length. Performance Requirements * Aim to implement your function such that it minimizes the number of operations and efficiently handles the search and replacement operations. Example Input: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` Output: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Task Write the implementation of the function `replace_symbols(words: List[str], symbols: List[str]) -> List[str]` based on the description and constraints provided.","solution":"from typing import List def replace_symbols(words: List[str], symbols: List[str]) -> List[str]: Replaces substrings in a list of words with the longest match from a list of symbols, wrapping the match in square brackets. :param words: List of words to process. :param symbols: List of symbols to search for replacements. :return: List of words with symbols replaced by the longest match. result = [] for word in words: longest_match = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest_match): longest_match = symbol if longest_match: word = word.replace(longest_match, f\\"[{longest_match}]\\") result.append(word) return result"},{"question":"**Problem Statement**: You are tasked with implementing the in-place sorting algorithm, Quick Sort, to help in organizing arrays of integers more efficiently. Your implementation should aim for average-case time complexity of O(n log(n)) and handle edge cases explicitly. **Requirements**: 1. Develop a function `quick_sort(arr)` that sorts the array `arr` in-place using the Quick Sort algorithm. 2. Avoid common pitfalls such as poor pivot choice and recursion depth issues. To achieve this: - Implement a median-of-three pivot selection strategy. - Switch to insertion sort for small sub-arrays of size less than 10 to minimize recursion overhead. 3. Your solution should handle large arrays efficiently and have an average-case time complexity of O(n log(n)). **Function Signature**: ```python def quick_sort(arr: List[int]) -> List[int]: pass ``` **Example**: ```python input_array = [3, 6, 8, 10, 1, 2, 1] print(quick_sort(input_array)) # Output should be [1, 1, 2, 3, 6, 8, 10] ``` **Constraints**: - The input array `arr` can have a length up to 10,000 elements. - The elements of `arr` are integers between -10,000 and 10,000. **Performance Notes**: - Make sure the recursion depth does not exceed Python\'s maximum recursion limit. - Optimize pivot selection to avoid the worst-case scenario as much as possible. - Include checks for edge cases such as empty arrays, arrays with all identical elements, and already sorted arrays. Test your implementation thoroughly to make sure it handles all edge cases and performance requirements.","solution":"from typing import List def insertion_sort(arr: List[int], low: int, high: int) -> None: for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr: List[int], low: int, high: int) -> int: mid = (low + high) // 2 a, b, c = arr[low], arr[mid], arr[high] if a > b: if a < c: return low elif b > c: return mid else: return high else: if a > c: return low elif b < c: return mid else: return high def partition(arr: List[int], low: int, high: int) -> int: pivot_index = median_of_three(arr, low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(arr: List[int], low: int, high: int) -> None: if low < high: if high - low < 10: # Threshold for switching to insertion sort insertion_sort(arr, low, high) else: pi = partition(arr, low, high) quick_sort_recursive(arr, low, pi - 1) quick_sort_recursive(arr, pi + 1, high) def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr quick_sort_recursive(arr, 0, len(arr) - 1) return arr"},{"question":"Find the k-th to Last Element of a Linked List Objective Implement a function to return the k-th to last element of a singly linked list efficiently, handling edge cases properly. Function Signature: ```python def kth_to_last(head: Node, k: int) -> Node: pass ``` Input: - `head`: The head node of a singly linked list. - `k`: An integer representing the k-th position from the end of the list. Output: - A node representing the k-th to last element of the list. Constraints: - Do not use `eval()` function. - You cannot use extra space proportional to the size of the linked list (i.e., no arrays, dictionaries, etc.). - Must handle edge cases (e.g., k being larger than the length of the list, k being negative, empty list). Example: Let\'s define a linked list as follows: ``` A -> B -> C -> D -> E ``` When calling `kth_to_last(head, 2)`, the function should return the node containing the value `D`. Scenario: You are developing a feature for a social media platform where you need to retrieve the k-th most recent post by a user, represented as a singly linked list of posts. Each post is a node, and you need to efficiently find and return the k-th to last post. Implementation Details: 1. Use a two-pointer technique to keep the space complexity minimal and the implementation efficient. 2. Ensure to check for edge cases such as when k is out of valid range. ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: # Initial edge case handling if k < 0 or not head: return None p1 = head p2 = head # Move p1 k steps ahead for _ in range(k): if p1 is None: return None # k is larger than the number of elements p1 = p1.next # Move p1 to the end, maintaining the gap while p1: p1 = p1.next p2 = p2.next return p2 # Example usage: # Define your node instances and link them a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e # Retrieve k-th to last element result = kth_to_last(a, 2) print(result.val) # Output: D ```","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: # Initial edge case handling if k < 0 or not head: return None p1 = head p2 = head # Move p1 k steps ahead for _ in range(k): if p1 is None: return None # k is larger than the number of elements p1 = p1.next # Move p1 to the end, maintaining the gap while p1: p1 = p1.next p2 = p2.next return p2"},{"question":"# Question Context You are given a tree-like structure representing the allocation of different items to various individuals. The tree is implemented as a dictionary where each key is a primary node, and the corresponding value is a list containing secondary nodes or integer values representing item counts. For example: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` Task Write a function `optimized_tree_print(tree)` that prints the input tree in a readable format. Ensure you minimize redundant operations to improve efficiency. Each primary node\'s data should be printed on a new line, with proper indenting to reflect the hierarchical nature. Input * `tree`: A dictionary representing the tree. Output * Print the tree structure in a readable format without redundant dictionary lookups. Constraints 1. The tree dictionary will have at most 1000 primary nodes. 2. Each primary node will have a list with a length of at most 20 elements. 3. The list will contain strings and integers only. Example ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } optimized_tree_print(tree) ``` Expected Output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ```","solution":"def optimized_tree_print(tree): Prints the tree structure in a readable format. Args: tree (dict): The tree to be printed. # Iterate through each primary node in the dictionary for key, value_list in tree.items(): print(f\\"{key} -> {value_list[0]}\\", end=\\"\\") for item in value_list[1:]: if isinstance(item, str): print(f\\" -> {item}\\", end=\\"\\") else: print(f\\" -> {item}\\", end=\\"\\") print() # Newline at the end of each primary node\'s data"},{"question":"You have been provided with a class `Fenwick_Tree` which supports efficient prefix sum queries and updates in an array. Implement the following function inside the class: ```python class Fenwick_Tree(object): def __init__(self, freq): # Initialization code is provided. def get_sum(self, bit_tree, i): # Implementation is provided. def update_bit(self, bit_tree, i, v): # Implementation is provided. def construct(self): # Implementation is provided. def range_sum(self, bit_tree, l, r): Computes the sum of elements in the range [l, r] inclusively in the original array. Args: bit_tree (list): The binary indexed tree. l (int): The starting index of the range. r (int): The ending index of the range. Returns: int: The sum of the elements in the specified range. # Your implementation here ``` # Input: - **bit_tree**: A list representing the binary indexed tree. - **l**: Integer, the starting index of the range (0-based index). - **r**: Integer, the ending index of the range (0-based index). # Output: - Returns an integer, the sum of elements in the range [l, r] inclusively. # Constraints: - (0 le l le r < n) - (1 le n le 10^5) - All elements of the array are integers in the range ([-10^9, 10^9]). # Example: ```python freq = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2] fenwick_tree = Fenwick_Tree(freq) bit_tree = fenwick_tree.construct() result = fenwick_tree.range_sum(bit_tree, 2, 5) print(result) # Output: 18 (sum of elements at indices 2, 3, 4, 5 -> 3 + 0 + 7 + 8) ``` # Notes: - You can utilize the `get_sum` function to help in calculating the range sum. - Make sure to handle edge cases where the indices are at the boundary of the array.","solution":"class Fenwick_Tree(object): def __init__(self, freq): self.n = len(freq) self.freq = freq def get_sum(self, bit_tree, i): sum = 0 i += 1 while i > 0: sum += bit_tree[i] i -= i & (-i) return sum def update_bit(self, bit_tree, i, v): i += 1 while i <= self.n: bit_tree[i] += v i += i & (-i) def construct(self): bit_tree = [0] * (self.n + 1) for i in range(self.n): self.update_bit(bit_tree, i, self.freq[i]) return bit_tree def range_sum(self, bit_tree, l, r): if l == 0: return self.get_sum(bit_tree, r) else: return self.get_sum(bit_tree, r) - self.get_sum(bit_tree, l - 1)"},{"question":"# Bogo Sort Enhancement and Comparative Analysis You are tasked with enhancing the Bogo Sort algorithm provided above, and writing a comparative function to demonstrate the impracticality of Bogo Sort against another efficient sorting algorithm (e.g., Quick Sort). Task 1. **Enhanced Bogo Sort**: Write a function, `enhanced_bogo_sort(arr, max_iterations)`, that adds a limit to the number of iterations for shuffling. If the array is not sorted within the given number of iterations, it should return `None`. 2. **Comparative Sort Function**: Write a function, `comparative_sort(arr)`, that sorts the array using a more efficient sorting algorithm (e.g., Quick Sort). 3. **Main Execution**: * Write a main execution function, `compare_sorts(test_arr, max_iterations)`, which: - Runs both the `enhanced_bogo_sort` and `comparative_sort` on the same input array. - Prints the results for both sorts. - Highlights the number of iterations taken if `enhanced_bogo_sort` is successful, or notes it failed. Input Format * `test_arr`: List of integers to be sorted. * `max_iterations`: Maximum number of iterations for the `enhanced_bogo_sort`. Output Format * `enhanced_bogo_sort` should return the sorted array or `None` if it exceeds the maximum iterations. * `comparative_sort` should return the sorted array. * The main function should print results in the format: ``` Enhanced Bogo Sort Result: [...] Comparative Sort Result: [...] Bogo Sort Iterations: X or Bogo Sort Failed ``` Constraints * Array size should be manageable (e.g., `1 <= len(arr) <= 10` for demonstration purposes). * Integer elements should fit within standard sorting constraints. Example ```python test_arr = [3, 1, 2] max_iterations = 100 compare_sorts(test_arr, max_iterations) ``` Expected Output: ``` Enhanced Bogo Sort Result: [1, 2, 3] Comparative Sort Result: [1, 2, 3] Bogo Sort Iterations: X ``` or ``` Enhanced Bogo Sort Result: None Comparative Sort Result: [1, 2, 3] Bogo Sort Failed ``` Happy coding!","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def enhanced_bogo_sort(arr, max_iterations): Enhanced Bogo Sort that adds a limit to the number of iterations. If the array is not sorted within the given iterations, returns None. iterations = 0 while not is_sorted(arr) and iterations < max_iterations: random.shuffle(arr) iterations += 1 if is_sorted(arr): return arr, iterations else: return None, iterations def quick_sort(arr): Quick Sort implementation. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def compare_sorts(test_arr, max_iterations): Main execution function to compare Enhanced Bogo Sort and Quick Sort. Prints the results and highlights the number of iterations for Enhanced Bogo Sort. bogo_sort_result, bogo_iterations = enhanced_bogo_sort(test_arr[:], max_iterations) comparative_sort_result = quick_sort(test_arr[:]) print(\\"Enhanced Bogo Sort Result:\\", bogo_sort_result) print(\\"Comparative Sort Result:\\", comparative_sort_result) if bogo_sort_result is not None: print(\\"Bogo Sort Iterations:\\", bogo_iterations) else: print(\\"Bogo Sort Failed\\") return bogo_sort_result, comparative_sort_result, bogo_iterations if bogo_sort_result is not None else None"},{"question":"# Matrix Chain Multiplication with Detailed Steps Problem Statement You are given a sequence of matrices, and you need to determine the most efficient way to multiply these matrices together. The goal is to minimize the number of scalar multiplications. You need to implement the matrix chain multiplication algorithm using dynamic programming and print the optimal order of multiplication. Input - An array `p` of length `n+1` where `n` is the number of matrices. The dimensions of the i-th matrix are given by `p[i-1] x p[i]`. Output - An integer representing the minimum number of scalar multiplications needed. - The optimal order of matrix multiplication in a readable format. Constraints - `1 <= n <= 100` - `1 <= p[i] <= 500` Example Input: ``` p = [30, 35, 15, 5, 10, 20, 25] ``` Output: ``` Minimum number of multiplications is 15125 Optimal order is: ((A1(A2A3))((A4A5)A6)) ``` Implementation Requirements 1. Implement the function `matrix_chain_order(p: List[int]) -> Tuple[int, List[List[int]]]` to compute the minimum number of scalar multiplications and the table for optimal splits. 2. Implement the function `print_optimal_solution(sol: List[List[int]], i: int, j: int) -> None` to print the optimal order of matrices. 3. Write a `main()` function to parse input, compute the result, and output the required values.","solution":"from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[int, List[List[int]]]: n = len(p) - 1 # Number of matrices m = [[0] * n for _ in range(n)] # Minimum multiplications table s = [[0] * n for _ in range(n)] # Optimal split table for length in range(2, n + 1): # length is the chain length for i in range(n - length + 1): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[0][n - 1], s def print_optimal_solution(sol: List[List[int]], i: int, j: int) -> str: if i == j: return f\\"A{i + 1}\\" else: k = sol[i][j] left_order = print_optimal_solution(sol, i, k) right_order = print_optimal_solution(sol, k + 1, j) return f\\"({left_order}{right_order})\\" def main(): p = [30, 35, 15, 5, 10, 20, 25] min_mults, sol = matrix_chain_order(p) optimal_order = print_optimal_solution(sol, 0, len(p) - 2) print(f\\"Minimum number of multiplications is {min_mults}\\") print(f\\"Optimal order is: {optimal_order}\\") if __name__ == \\"__main__\\": main()"},{"question":"You are given a list of integers representing the stock prices of a company over consecutive days. Your task is to find the maximum profit that can be earned by buying and selling stocks once. The goal is to write a function that utilizes Kadane\'s Algorithm to determine the most profitable buy-sell pair. # Function Signature: ```python def max_stock_profit(prices: List[int]) -> int: pass ``` # Input: * `prices` (List[int]): A list of integers where each integer represents the stock price on a given day. # Output: * Returns the maximum profit that can be earned. If no positive profit can be made, return 0. # Constraints: * The list `prices` will have at most `10^5` elements. * Each element in `prices` will be an integer in the range `[-10^5, 10^5]`. # Example: ```python # Example 1 prices = [7, 1, 5, 3, 6, 4] # Expected output: 5 # Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5. # Example 2 prices = [7, 6, 4, 3, 1] # Expected output: 0 # Explanation: If you cannot achieve any positive profit, return 0. # Example 3 prices = [1, 5, 3, 8, 12] # Expected output: 11 # Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 12), profit = 12 - 1 = 11 ``` # Notes: * Remember that buying the stock before selling it is necessary. * The algorithm needs to work efficiently, even for the upper limits of the constraints.","solution":"from typing import List def max_stock_profit(prices: List[int]) -> int: Returns the maximum profit that can be earned by buying and selling stocks once. Utilizes Kadane\'s Algorithm to find the most profitable buy-sell pair. if not prices or len(prices) < 2: return 0 max_profit = 0 min_price = prices[0] for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"Scenario You are working as a developer in a digital signal processing firm and you need to validate binary signals. Specifically, you need to ensure that certain integer signals have alternating bit patterns to meet a protocol requirement. Task Write a function that determines if a given positive integer has alternating bits. Implement both the traditional bit-wise approach and the optimized constant time approach. Validate both methods to ensure their correctness. Function Signature ```python def has_alternative_bit(n: int) -> bool: pass def has_alternative_bit_fast(n: int) -> bool: pass ``` Inputs - `n (int)`: A positive integer to be checked. Outputs - `bool`: Return `True` if `n` has alternating bits, otherwise `False`. Examples ```python assert has_alternative_bit(5) == True # binary: 101 assert has_alternative_bit(7) == False # binary: 111 assert has_alternative_bit(11) == False # binary: 1011 assert has_alternative_bit(10) == True # binary: 1010 assert has_alternative_bit_fast(5) == True # binary: 101 assert has_alternative_bit_fast(7) == False # binary: 111 assert has_alternative_bit_fast(11) == False # binary: 1011 assert has_alternative_bit_fast(10) == True # binary: 1010 ``` Constraints - The input integer `n` will always be a positive integer. - Handle integer inputs up to the standard 32-bit integer range. Your function should run efficiently, with the optimized version adhering to a constant time complexity.","solution":"def has_alternative_bit(n: int) -> bool: Determines if the integer n has alternating bits (bit-wise approach). previous_bit = n & 1 n = n >> 1 while n > 0: current_bit = n & 1 if current_bit == previous_bit: return False previous_bit = current_bit n = n >> 1 return True def has_alternative_bit_fast(n: int) -> bool: Determines if the integer n has alternating bits (optimized constant time approach). # Create a mask to check the alternate pattern. # Example: For n = 5 (binary 101), the created pattern mask is 010 + 1 = 011 # If n has alternating bits, then n ^ (n >> 1) should be all 1\'s alternating_check = n ^ (n >> 1) # This alternates_check should be a number consisting of consecutive 1\'s. # If (alternating_check & (alternating_check + 1)) == 0, then it means that the number # is all 1\'s in binary representation. return (alternating_check & (alternating_check + 1)) == 0"},{"question":"User-Configured Path Resolution Scenario You are building a command-line utility that interacts with the file system. One important feature is to handle file paths efficiently. To ensure users can provide various forms of file paths (absolute, relative, involving user directories), you\'ll need a function that standardizes these paths uniformly. Task Write a Python function `resolve_path(file: str) -> str` that takes a string representing a file path and returns its absolute path, expanding any user directory reference (like `~`) as well. Input - One string, `file`, representing a file path. Path may be relative, absolute, or use user directory shortcut (`~`). Output - One string representing the absolute path of the input `file`. Constraints - Input path will be a valid string. - Do not optimize for paths with symbolic links. Performance Requirements - Function should efficiently handle normal file directory depths typical on a user\'s system (e.g., 5-10 nested levels). # Example ```python assert resolve_path(\\"~/documents/myfile.txt\\") == \\"/home/username/documents/myfile.txt\\" # Example on a Unix system ```","solution":"import os def resolve_path(file: str) -> str: Returns the absolute path of the given file path, expanding user directory references. Parameters: file (str): The file path to resolve. Returns: str: The absolute path of the file. return os.path.abspath(os.path.expanduser(file))"},{"question":"# Coding Challenge: Calculate the Height of a Binary Search Tree **Problem Statement**: You are given a `Node` class that represents the nodes of a Binary Search Tree (BST) and a `bst` class to manage the BST. Your task is to write a function `height` that calculates the height of the BST. The height is defined as the number of levels in the tree. The height of an empty tree is 0, a tree with a single node has a height of 1, a root node with two levels of children has a height of 2, and so forth. **Function Signature**: ```python def height(root: Node) -> int: ``` **Input**: - The function takes the root node of a BST as input. **Output**: - The function returns an integer representing the height of the BST. **Constraints**: - The number of nodes (`n`) of the BST is at most (10^4). - Node values are unique integers. - You can assume the tree fits in memory. **Example**: Given the following BST: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The height of the tree is 4. **Scenario**: You are building an application to manage and visualize file directory structures, which often resemble tree-like hierarchies (parent-child relationships). The algorithm to calculate the height of BST will help determine the depth of the directory structure. **Testing**: You are provided with a testing class `TestSuite` to validate your solution. Please ensure your implementation passes all the test cases defined in the `TestSuite` class.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def height(root): if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Sliding Window Maximum **Context**: Imagine you are given a large dataset of temperature readings taken every minute. You need to process this data to find the highest temperatures over consecutive periods for efficient monitoring and analysis. **Task**: Write a function `max_temperature_window(temperatures, k)` that computes the maximum temperature of each sub-array of length (k). Ensure that your solution is optimal, leveraging appropriate data structures to achieve efficient time complexity. **Function Signature**: ```python def max_temperature_window(temperatures: List[int], k: int) -> List[int]: pass ``` **Input**: - `temperatures`: A list of integers where each integer represents the temperature reading at a minute. - `k`: An integer representing the length of the sliding window. **Output**: - A list of integers where each integer is the maximum temperature in the corresponding sliding window. **Constraints**: - (1 leq k leq len(temperatures)) - (0 leq temperatures[i] leq 10^5) - The length of `temperatures` will be at most (10^5). **Example**: ```python temperatures = [1, 3, 1, 2, 0, 5] k = 3 print(max_temperature_window(temperatures, k)) # Output: [3, 3, 2, 5] temperatures = [4, 2, 12, 11, -5, 0, 5, 6, 7, 8] k = 4 print(max_temperature_window(temperatures, k)) # Output: [12, 12, 12, 11, 6, 7, 8] ``` **Note**: - Consider edge cases where the window size (k) is equal to the length of the list, or where the list contains identical elements.","solution":"from collections import deque def max_temperature_window(temperatures, k): Returns a list of the maximum temperatures in each sliding window of size k. if not temperatures or k == 0: return [] n = len(temperatures) if k == 1: return temperatures result = [] deq = deque() for i in range(n): # Remove elements not within the window if deq and deq[0] < i - k + 1: deq.popleft() # Remove elements which are less than the current element since they # will not be needed for a window with the current element while deq and temperatures[deq[-1]] < temperatures[i]: deq.pop() deq.append(i) # Start adding maximums to result from the k-1th element if i >= k - 1: result.append(temperatures[deq[0]]) return result"},{"question":"# Objective You are given a complex undirected graph where each node contains a unique label and a list of its neighboring nodes. Your task is to clone this graph while preserving the structure and the connections of the original graph. # Function Signature ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Input * `node`: A reference to a node in an undirected graph (may be None). # Output * Returns a reference to a node in the cloned undirected graph. # Constraints * Nodes are labeled uniquely. * The graph may contain self-loops and disconnected components. * The input graph can be empty (None). # Example ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] # Example usage: # Creating a graph {0,1,2#1,2#2,2} which visually looks like: # 1 # / # / # 0 --- 2 # / # _/ node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node0.neighbors = [node1, node2] node1.neighbors = [node2] node2.neighbors = [node2] cloned_node = clone_graph(node0) # The cloned graph should have the same structure with newly created nodes. ``` # Performance Requirements Ensure your algorithm is efficient with time complexity of O(N + E) where N is the number of nodes and E is the number of edges. The space complexity should also be O(N). # Notes - You are allowed to use either BFS or DFS (iterative or recursive). - Avoid modifying the original graph during cloning. - Think about edge cases like graphs with self-loops and disconnected components. Good luck!","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if node is None: return None def clone(node, clones): if node in clones: return clones[node] copy = UndirectedGraphNode(node.label) clones[node] = copy for neighbor in node.neighbors: copy.neighbors.append(clone(neighbor, clones)) return copy return clone(node, {})"},{"question":"# Topological Sorting with Additional Constraints You are tasked with implementing a function that performs topological sorting on a given directed acyclic graph (DAG). Your implementation should handle large graphs efficiently and detect cycles to ensure the graph is indeed acyclic. Required Function ```python def topological_sort(graph): Perform topological sorting on a given DAG. Args: graph (dict): A dictionary representing an adjacency list of the graph where keys are the vertices and values are lists of vertices that the key vertex has directed edges to. Returns: List: A list of vertices in topologically sorted order. Raises: ValueError: If the input graph contains a cycle. pass ``` Input Format: - `graph`: A dictionary representing a directed graph, where the keys are vertices and the values are lists of vertices that the key vertex has directed edges to. Output Format: - A list of vertices in topologically sorted order. Constraints: - The graph is guaranteed to have no duplicate edges. - You must detect and handle cycles by raising a `ValueError` if a cycle is detected. - The graph can have up to (10^5) vertices and (10^6) edges. Example: ```python # Example 1: Simple DAG graph1 = { \'A\': [\'C\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } assert topological_sort(graph1) == [\'A\', \'B\', \'C\', \'D\'] or topological_sort(graph1) == [\'B\', \'A\', \'C\', \'D\'] # Example 2: Detect Cycle graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } try: topological_sort(graph2) except ValueError: print(\\"Cycle Detected\\") # This should be printed for graph2 ``` Notes: - The provided graph representation allows parallel edges. - Your solution should be efficient in terms of time and space complexity, adhering to the constraints. - Ensure your function handles edge cases, such as an empty graph or a graph with disconnected components, correctly.","solution":"def topological_sort(graph): Perform topological sorting on a given DAG. Args: graph (dict): A dictionary representing an adjacency list of the graph where keys are the vertices and values are lists of vertices that the key vertex has directed edges to. Returns: List: A list of vertices in topologically sorted order. Raises: ValueError: If the input graph contains a cycle. from collections import defaultdict, deque # Initialize the in-degree dictionary in_degree = {node: 0 for node in graph} # Calculate in-degrees of all nodes for node in graph: for neighbor in graph[node]: in_degree[neighbor] += 1 # Initialize a queue and add all nodes with in-degree 0 queue = deque([node for node in graph if in_degree[node] == 0]) topo_sort = [] while queue: node = queue.popleft() topo_sort.append(node) # For all the neighboring nodes, reduce their in-degree by 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if in_degree[neighbor] == 0: queue.append(neighbor) # If topo_sort doesn\'t contain all nodes, it means there was a cycle if len(topo_sort) != len(graph): raise ValueError(\\"The graph contains a cycle\\") return topo_sort"},{"question":"Partition a Linked List around a Value **Scenario**: You are working on a data processing system that must reorder linked lists based on a threshold value for optimization purposes. Your task is to implement a function that partitions the elements of a linked list such that all nodes with values less than a given integer `x` come before nodes with values greater than or equal to `x`. **Task**: Write a function `partition_linked_list(head: Node, x: int) -> Node` where `head` is the head of a singly linked list and `x` is the partitioning value. **Input**: * `head` - The head node of a singly linked list. Each node contains an integer value and a link to the next node. * `x` - An integer value to partition the linked list around. **Output**: * Returns the head of the modified linked list after reordering the nodes. **Constraints**: * The linked list may contain between 0 and 10,000 nodes. * Node values are all integers within the range of -1,000,000 to 1,000,000. * You must perform the partitioning in-place without using additional memory structures. **Example**: ```python class Node(): def __init__(self, val=None): self.val = int(val) self.next = None def partition_linked_list(head: Node, x: int) -> Node: # Your implementation # Sample Usage a = Node(3) b = Node(5) c = Node(8) d = Node(5) e = Node(10) f = Node(2) g = Node(1) a.next = b b.next = c c.next = d d.next = e e.next = f f.next = g new_head = partition_linked_list(a, 5) print_linked_list(new_head) # Expected Output: 3 -> 2 -> 1 -> 8 -> 5 -> 5 -> 10 ``` **Notes**: * Keep track of edge cases like an empty list, a list with a single node, and lists where all nodes are either less than or greater than `x`. * Ensure to maintain the relative order of nodes with equal values as much as possible.","solution":"class Node(): def __init__(self, val=None): self.val = int(val) self.next = None def partition_linked_list(head: Node, x: int) -> Node: if head is None: return None less_head = less_tail = Node(0) greater_head = greater_tail = Node(0) current = head while current: if current.val < x: less_tail.next = current less_tail = less_tail.next else: greater_tail.next = current greater_tail = greater_tail.next current = current.next # Connect the two partitions less_tail.next = greater_head.next greater_tail.next = None return less_head.next"},{"question":"Task: Flatten Nested Arrays # Context In data preprocessing and transformation tasks, you often encounter hierarchically nested data structures, such as lists within lists. Handling these structures can be challenging, especially if you need to turn them into a flat, one-dimensional array for uniform processing. # Objective Write a function `flatten_list` that takes a potentially nested list of elements and returns a single, flat list containing all the elements from the nested structure. Your implementation should recursively handle any level of nesting and ensure that all elements appear in the resulting list in their original order. # Function Signature ```python def flatten_list(input_list: list) -> list: pass ``` # Input - `input_list`: A list that may contain nested lists (e.g., `[1, [2, 3, [4, [5, 6]]], 7, [8, 9]]`). # Output - A single flat list containing all elements from the input list in their original sequence (e.g., `[1, 2, 3, 4, 5, 6, 7, 8, 9]`). # Constraints - Do not use any built-in methods for flattening (e.g., `itertools.chain`). # Performance Requirements - The algorithm must minimize the use of stack space and handle recursion efficiently. - Aim for a linear time complexity, O(n), where n is the total number of elements in the nested structures. # Example ```python assert flatten_list([1, [2, 3, [4, [5, 6]]], 7, [8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert flatten_list([[1, 2], [3, [4, 5]], 6, [7, [8, 9]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert flatten_list([[], [[]], [1, [2, [3]]]]) == [1, 2, 3] ``` Consider edge cases such as empty nested lists and mixed data types within the lists. Ensure that your solution gracefully handles these scenarios.","solution":"def flatten_list(input_list: list) -> list: Takes a nested list and returns a flat list containing all the elements from the input list in their original sequence. def _flatten(lst): for item in lst: if isinstance(item, list): yield from _flatten(item) else: yield item return list(_flatten(input_list))"},{"question":"# Binary Tree Mirroring (Inversion) Challenge Objective You are tasked with writing a function to invert (mirror) a binary tree. Inverting a binary tree means swapping the left and right children of each node in the tree. Context Given a binary tree, you need to create its mirror image. This is a common operation that can help in various tree manipulation problems or visual tasks such as rendering tree-based diagrams. Function Signature ```python def invert_binary_tree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping the left and right children of each node. Parameters: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the inverted (mirrored) binary tree. ``` Input * `root`: The root node of the binary tree to be inverted. It is guaranteed to be either a `TreeNode` instance or `None`. Output * `TreeNode`: The root node of the binary tree after it has been inverted. Example Consider the following binary tree: ``` 4 / 2 7 / / 1 3 6 9 ``` The mirrored binary tree would be: ``` 4 / 7 2 / / 9 6 3 1 ``` Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - The values of the nodes are arbitrarily chosen integers and do not affect the inversion process. Edge Cases - An empty tree (root is `None`) should return `None`. - A single-node tree should remain unchanged after inversion. Performance Requirements - Your algorithm should run in linear time with respect to the number of nodes in the tree, i.e., O(n). - The space complexity should be proportional to the height of the tree due to the recursion stack, i.e., O(h). Write your implementation in Python.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping the left and right children of each node. Parameters: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the inverted (mirrored) binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_binary_tree(root.left) invert_binary_tree(root.right) return root"},{"question":"You are given an unsorted array of integers, `arr`, and an integer `target`. Your task is to implement the linear search algorithm to find the index of the `target` in the array. # Input - An integer array `arr` of length `n` (1 ≤ n ≤ 10^5), where -10^9 ≤ arr[i] ≤ 10^9. - An integer `target`, where -10^9 ≤ target ≤ 10^9. # Output - Return the index of the `target` if it exists in the array; otherwise, return -1. # Constraints - The array can contain negative numbers and duplicate values. - The target may or may not be present in the array. - The array length should not exceed 10^5. # Example ```python # Example 1 arr = [4, 2, 1, 5, 3] target = 5 # Output: 3 # Example 2 arr = [4, 2, 1, 5, 3] target = 6 # Output: -1 # Example 3 arr = [-1, -2, -3, -4, -5] target = -3 # Output: 2 ``` # Function Signature ```python def linear_search(arr: List[int], target: int) -> int: pass ``` # Notes - Ensure your solution is optimized for the given constraints. - Focus on handling edge cases effectively, such as when the array is empty or the target appears multiple times.","solution":"from typing import List def linear_search(arr: List[int], target: int) -> int: Perform a linear search to find the target in the array. Parameters: arr (List[int]): The array of integers to search within. target (int): The integer to search for. Returns: int: The index of the target in the array if found, otherwise -1. for index, value in enumerate(arr): if value == target: return index return -1"},{"question":"# Single Unique Number in a Thrice-Repeated Array Objective: You are given an array of integers where every element appears exactly three times except for one element, which appears exactly once. Write a function to find that single element. Input: * A list of integers `nums` where: - `1 <= len(nums) <= 3 * 10^4` - Every element in `nums` appears exactly three times except for one element which appears exactly once. - Integers consist of positive, negative, and zero values. Output: * Return a single integer representing the element that does not appear three times in the array. Constraints: * Your algorithm should have a linear runtime complexity O(n). * Do not use extra memory beyond a few variables to store state information. Example: ```python # Example 1: nums = [2, 2, 2, 3] # Output: 3 # Example 2: nums = [0, 1, 0, 1, 0, 1, 99] # Output: 99 ``` Function Signature: ```python def single_number(nums: List[int]) -> int: # Your code here ``` Notes: * You are expected to utilize bitwise operations to achieve the task effectively. * Consider edge cases in your implementation to ensure robustness. Good luck!","solution":"from typing import List def single_number(nums: List[int]) -> int: Returns the number that appears exactly once in an otherwise thrice-repeated array. ones, twos = 0, 0 for num in nums: twos |= ones & num ones ^= num common_bit_mask = ~(ones & twos) ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"Context You are working for a tech company that designs gaming algorithms. One of the challenges in your current game involves determining the fewest number of perfect square \\"coins\\" that sum to a specific score. To validate the correctness and efficiency of your algorithm, you need to implement a function that solves this mathematically guaranteed problem using efficient computations. Problem Description Write a function `num_perfect_squares(number)` that takes in a single integer `number` and returns the minimum number of perfect squares that sum to this number. Your function must be efficient and handle large inputs appropriately. You should ensure the use of Lagrange\'s Four-Square Theorem and relevant reductions to achieve an optimized solution. Function Signature ```python def num_perfect_squares(number: int) -> int: ``` Input - `number`: a positive integer (1 ≤ number ≤ 10^9). Output - Return the smallest number of perfect squares that sum to the given number. Examples - `num_perfect_squares(9)` should return `1` (9 = 3^2). - `num_perfect_squares(10)` should return `2` (10 = 3^2 + 1^2). - `num_perfect_squares(12)` should return `3` (12 = 2^2 + 2^2 + 2^2). - `num_perfect_squares(31)` should return `4` (31 = 5^2 + 2^2 + 1^2 + 1^2). Constraints - Your solution should have a time complexity of O(√n). - Space complexity should be O(1). Notes - Consider edge cases such as when the number is itself a perfect square. - Handle large inputs efficiently to prevent performance bottlenecks. - Ensure correct handling of floating-point calculations involved in square roots.","solution":"import math def num_perfect_squares(number: int) -> int: Returns the minimum number of perfect squares that sum to the given number. # Check if the number itself is a perfect square if int(math.sqrt(number)) ** 2 == number: return 1 # According to Lagrange\'s Four Square Theorem, every number can be represented as the sum of four squares # Consider reducing number by checking if the minimum number of squares is less than four # Check if the result can be two squares for i in range(1, int(math.sqrt(number)) + 1): remaining = number - i * i if int(math.sqrt(remaining)) ** 2 == remaining: return 2 # Legendre\'s three-square theorem # If a number is not of the form 4^a*(8b+7), then it can be written as the sum of three squares while number % 4 == 0: number //= 4 if number % 8 == 7: return 4 return 3"},{"question":"# Title: Implement Rabin-Karp Algorithm for Pattern Matching # Context In bioinformatics, finding specific sequences in a genomic database is a common task. You are tasked to write a function that searches for a specific DNA sequence (pattern) in a much larger DNA sequence (text) using the Rabin-Karp algorithm. # Problem Statement Implement a function `rabin_karp_dna(pattern: str, text: str) -> List[int]` that finds all starting positions of substring `pattern` in the given `text`. If the pattern occurs more than once, return all starting indices. If the pattern is not found, return an empty list. # Input Format * `pattern` : A string representing the DNA sequence to search for. * `text` : A string representing the larger DNA sequence where search is to be performed. # Output Format Return a list of integer indices where each index is a position where the pattern starts in the text. # Constraints * The inputs consist only of uppercase characters \'A\', \'C\', \'G\', \'T\'. * `1 <= len(pattern) <= 500` * `1 <= len(text) <= 10000` # Example Input ```python pattern = \\"ACG\\" text = \\"ACGTACGAC\\" ``` # Example Output ```python [0, 4] ``` # Function Signature ```python def rabin_karp_dna(pattern: str, text: str) -> List[int]: pass ``` # Notes 1. Use a rolling hash technique to efficiently compute the hashes of the text\'s substrings. 2. Ensure to manage any potential hashing collisions by checking the actual text segment whenever a hash match is found. 3. Consider the edge cases discussed in the algorithm analysis.","solution":"def rabin_karp_dna(pattern: str, text: str) -> list: Function to implement Rabin-Karp algorithm to find all starting positions of substring `pattern` in the given `text`. from typing import List def hash_function(s: str) -> int: return sum(ord(c) - ord(\'A\') + 1 for c in s) pattern_length = len(pattern) text_length = len(text) if pattern_length > text_length: return [] pattern_hash = hash_function(pattern) current_hash = hash_function(text[:pattern_length]) result = [] for i in range(text_length - pattern_length + 1): if current_hash == pattern_hash and text[i:i + pattern_length] == pattern: result.append(i) if i < text_length - pattern_length: current_hash = current_hash - (ord(text[i]) - ord(\'A\') + 1) + (ord(text[i + pattern_length]) - ord(\'A\') + 1) return result"},{"question":"You are provided a Graph class that computes the transitive closure of a directed graph using Depth-First Search (DFS). Implement the modified version of this Graph class to optimize it using the Floyd-Warshall algorithm instead of DFS, to compute the transitive closure of the given directed graph. # Requirements: 1. Implement an optimized `transitive_closure` function using the Floyd-Warshall algorithm within the Graph class. 2. Ensure that the code effectively computes the transitive closure of the graph. 3. The `transitive_closure` method should return a 2D matrix where element `(i, j)` is `\'1\'` if there is a path from vertex `i` to vertex `j`, otherwise \'0\'. # Input: - `n` (int): Number of vertices in the graph. - A sequence of edge pairs representing directed edges in the graph. # Output: - A 2D list, representing the reachability matrix of the graph. # Constraints: - `1 <= n <= 100` (You may assume this in your design). - The graph can have a maximum of `n*(n-1)` directed edges. - Self-loops and multiple edges between same vertices are possible but counted as one for reachability purposes. # Example: Input: ```python n = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 1)] ``` Output: ```python [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1] ] ``` # Task: Modify the `Graph` class to implement the `transitive_closure` method as described using the Floyd-Warshall algorithm.","solution":"class Graph: def __init__(self, n, edges): Initializes the graph. Parameters: - n (int): Number of vertices. - edges (list of tuple): List of edges where each edge is represented as a tuple (u, v) self.n = n self.edges = edges def transitive_closure(self): Computes the transitive closure using the Floyd-Warshall algorithm. Returns a 2D list representing the reachability matrix. # Initialize the reachability matrix with 0\'s reach = [[0 for _ in range(self.n)] for _ in range(self.n)] # Fill the reachability matrix with given edges for u, v in self.edges: reach[u][v] = 1 # Every vertex is reachable from itself for i in range(self.n): reach[i][i] = 1 # Floyd-Warshall algorithm to compute transitive closure for k in range(self.n): for i in range(self.n): for j in range(self.n): if not reach[i][j]: reach[i][j] = reach[i][k] and reach[k][j] return reach"},{"question":"# Minimum Spanning Tree Analysis and Implementation **Scenario**: You are tasked with implementing a minimum spanning tree algorithm for an infrastructure project where you must connect several cities with the least possible cost of roads. # Problem Description Implement a function `prims_minimum_spanning(graph: Dict[Any, List[Tuple[int, Any]]]) -> int` that computes the weight of the minimum spanning tree of a connected, undirected graph using Prim\'s algorithm. # Input - `graph`: A dictionary representing the undirected connected graph. Key-value pairs are nodes and a list of tuples, where each tuple contains `(cost, adjacent_node)`, representing the edge weight and the adjacent node. # Output - An integer representing the total weight of the minimum spanning tree. # Constraints - The graph is guaranteed to be connected. - Node identifiers can be any hashable type (e.g., strings, integers). - Every edge has a positive integer weight. # Requirements - Use Prim\'s algorithm with a priority queue (min-heap) to find the minimum spanning tree. - Handle all possible edge cases such as graphs having cycles or multiple edges between nodes. - Ensure the implementation\'s time complexity is efficient (target (O(E log V))). # Example ```python graph = { \'a\': [(3, \'b\'), (8, \'c\')], \'b\': [(3, \'a\'), (5, \'d\')], \'c\': [(8, \'a\'), (2, \'d\'), (4, \'e\')], \'d\': [(5, \'b\'), (2, \'c\'), (6, \'e\')], \'e\': [(4, \'c\'), (6, \'d\')] } assert prims_minimum_spanning(graph) == 14 ```","solution":"import heapq from typing import Any, Dict, List, Tuple def prims_minimum_spanning(graph: Dict[Any, List[Tuple[int, Any]]]) -> int: Computes the weight of the minimum spanning tree of a connected, undirected graph using Prim\'s algorithm. :param graph: A dictionary representing the undirected connected graph. Key-value pairs are nodes and a list of tuples, where each tuple contains (cost, adjacent_node). :return: An integer representing the total weight of the minimum spanning tree. if not graph: return 0 start_node = next(iter(graph)) # Get an arbitrary starting node visited = set() min_heap = [(0, start_node)] # Initialize with (0, start_node) to start Prim\'s total_weight = 0 while min_heap: weight, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_weight += weight for edge_weight, adjacent in graph[node]: if adjacent not in visited: heapq.heappush(min_heap, (edge_weight, adjacent)) return total_weight"},{"question":"# ZigZag Iterator from Multiple Lists **Problem Statement:** You are tasked with designing an iterator that interleaves elements from multiple lists in a round-robin fashion. Specifically, you need to generalize the existing `ZigZagIterator` to handle an arbitrary number of input lists. The `ZigZagIterator` should: 1. Accept multiple lists on initialization. 2. Implement a method `next()` that returns the next element in the sequence. 3. Implement a method `has_next()` that returns `True` if there are still elements to be returned. **Function Signatures:** ```python class ZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize the ZigZagIterator with a list of lists. :type lists: List[List[int]] pass def next(self) -> int: Return the next element in the interleaved iteration. :rtype: int pass def has_next(self) -> bool: Return True if there are still elements to iterate over. :rtype: bool pass ``` **Constraints:** - Lists can be of varying lengths. - If a list is empty, it should be skipped in the interleaving process. - The iterator should not use more space than necessary. **Example:** ```python l1 = [1, 2, 3] l2 = [4, 5, 6, 7, 8] l3 = [9, 10] it = ZigZagIterator([l1, l2, l3]) while it.has_next(): print(it.next()) ``` **Expected Output:** ``` 1 4 9 2 5 10 3 6 7 8 ```","solution":"from collections import deque class ZigZagIterator: def __init__(self, lists): Initialize the ZigZagIterator with a list of lists. :type lists: List[List[int]] self.deque = deque([(lst, 0) for lst in lists if lst]) def next(self) -> int: Return the next element in the interleaved iteration. :rtype: int lst, index = self.deque.popleft() result = lst[index] if index + 1 < len(lst): self.deque.append((lst, index + 1)) return result def has_next(self) -> bool: Return True if there are still elements to iterate over. :rtype: bool return bool(self.deque)"},{"question":"# Context You are working with a data analytics team and need to constantly sort different small datasets. Although you\'re aware of faster sorting algorithms, your team has requested a simple, educational sorting approach to help junior team members understand the fundamental sorting mechanisms. Two aspects are important: sorting simplicity and visualizing each step of the sorting process. # Task Implement a function that performs selection sort on an array of integers and outputs the result after each iteration. # Function Signature ```python def traceable_selection_sort(arr): pass ``` # Input * `arr` (List[int]): A list of integers to be sorted. # Output * List[Tuple[int, List[int]]]: A list of tuples, where each tuple contains two elements: 1. The iteration number (starting from 1). 2. The array\'s state after the iteration. # Constraints * `0 <= len(arr) <= 1000` * `-10^6 <= arr[i] <= 10^6` for any element `arr[i]` # Example ```python arr = [64, 25, 12, 22, 11] output = traceable_selection_sort(arr) print(output) ``` Output ```python [(1, [11, 25, 12, 22, 64]), (2, [11, 12, 25, 22, 64]), (3, [11, 12, 22, 25, 64]), (4, [11, 12, 22, 25, 64]), (5, [11, 12, 22, 25, 64])] ``` # Notes 1. The function needs to simulate the entire sorting process and must return the list of tuples showing the array\'s state at each step. 2. Ensure the list is being sorted in ascending order. 3. Consider edge cases such as an empty list or a single element list.","solution":"def traceable_selection_sort(arr): Performs a selection sort on the input list and returns the list of tuples, where each tuple contains the iteration number and the state of the list after each iteration. n = len(arr) trace = [] for i in range(n): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] trace.append((i + 1, arr[:])) return trace"},{"question":"# Bogo Sort with Detailed Simulation Context You are working on a simulation to demonstrate the randomness and inefficiency of certain algorithms for educational purposes. One of the algorithms to be demonstrated is Bogo Sort. Bogo Sort is an intentionally inefficient sorting algorithm based on random shuffling until the array becomes sorted. Requirements Your task is to implement the Bogo Sort algorithm with detailed logging for each shuffle step. This is intended to visually show the process and inefficiency of the sort. # Function signature ```python def detailed_bogo_sort(arr: list[int], simulation: bool = False) -> list[int]: ``` # Input * `arr` (list[int]): A list of integers to be sorted. * `simulation` (bool): If set to `True`, the function prints the array at each shuffle iteration. # Output * Returns a sorted list of the input integers. # Constraints * The input list can contain 0 to 50 integers. * Values of the integers are between -10^6 to 10^6. * You must not use any built-in sorting functions. # Example ```python >>> detailed_bogo_sort([3, 2, 1], True) iteration 0: 3 2 1 iteration 1: 1 3 2 iteration 2: 2 1 3 ... iteration 5: 1 2 3 [1, 2, 3] ``` # Notes * The primary goal is to show the steps of the Bogo Sort, so make sure the implementation includes extensive iteration logs when `simulation` is set to `True`. * Consider edge cases such as an empty list or a list that is already sorted. * Ensure your code handles the infinite loop by random shuffling appropriate to check for sorting. # Grading Criteria * Correct implementation of sorting. * Accurate logging of each step when `simulation` is `True`. * Efficient checking of the sorted state of the array. * Handling edge cases properly.","solution":"import random def detailed_bogo_sort(arr: list[int], simulation: bool = False) -> list[int]: def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True iteration = 0 while not is_sorted(arr): if simulation: print(f\\"iteration {iteration}: {\' \'.join(map(str, arr))}\\") random.shuffle(arr) iteration += 1 if simulation: print(f\\"iteration {iteration}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# **Assessing Your Understanding of Diffie-Hellman Key Exchange** You are given the following task to implement a function to securely exchange a secret key between two parties (Alice and Bob) using the steps of the Diffie-Hellman key exchange protocol. Given a prime number ( p ) and its primitive root ( a ), Alice and Bob will first agree on these numbers, and then follow a series of steps to securely compute a shared secret. Function Signature ```python def diffie_hellman_key_exchange(a: int, p: int, option: Optional[int]=None) -> bool: ``` Parameters - **a** (int): The primitive root modulo ( p ). - **p** (int): A large prime number. - **option** (Optional[int]): When provided, the function should print the intermediate results for educational purposes. Returns - **bool**: Return `True` if both parties share the same secret key, otherwise return `False`. Constraints 1. `2 <= a < p` 2. ` ( p ) ` should be a prime number. 3. ` ( a ) ` should be a primitive root modulo ( p ). Performance Requirements 1. The time complexity for the key exchange should be kept within ( O(log n) ) due to modular exponentiation steps. 2. Space complexity should be constant, ( O(1) ). Additional Implementation Details: 1. Utilize helper functions where necessary to ensure the correctness of `prime_check`, `find_primitive_root`, and any modular arithmetic operations. 2. Implement exception handling for invalid inputs. Evaluation Criteria: 1. Correct implementation of the Diffie-Hellman key exchange. 2. Proper handling of edge cases and validation of inputs. 3. Clear and correct print statements if the optional parameter is provided. 4. Efficiency in both time and space. Example ```python print(diffie_hellman_key_exchange(5, 23)) # Expected: True or False depending on the implementation of internal functions ``` Implement the function considering all aspects discussed and ensuring optimal performance and security.","solution":"import random from typing import Optional def mod_exp(base: int, exp: int, mod: int) -> int: Helper function to perform modular exponentiation. result = 1 base = base % mod while exp > 0: if exp % 2: result = (result * base) % mod exp = exp >> 1 base = (base * base) % mod return result def diffie_hellman_key_exchange(a: int, p: int, option: Optional[int] = None) -> bool: Implementation of the Diffie-Hellman key exchange protocol. if a < 2 or a >= p: raise ValueError(\\"Primitive root a must satisfy 2 <= a < p\\") # Step 1: Alice and Bob agree on prime number p and primitive root a if option: print(f\\"Agreed upon prime number p: {p}\\") print(f\\"Agreed upon primitive root a: {a}\\") # Step 2: Alice chooses a private random number alice_private = random.randint(1, p-2) alice_public = mod_exp(a, alice_private, p) if option: print(f\\"Alice\'s private number: {alice_private}\\") print(f\\"Alice\'s public number: {alice_public}\\") # Step 3: Bob chooses a private random number bob_private = random.randint(1, p-2) bob_public = mod_exp(a, bob_private, p) if option: print(f\\"Bob\'s private number: {bob_private}\\") print(f\\"Bob\'s public number: {bob_public}\\") # Step 4: Exchange public numbers and compute the shared secret alice_shared_secret = mod_exp(bob_public, alice_private, p) bob_shared_secret = mod_exp(alice_public, bob_private, p) if option: print(f\\"Alice\'s shared secret: {alice_shared_secret}\\") print(f\\"Bob\'s shared secret: {bob_shared_secret}\\") return alice_shared_secret == bob_shared_secret"},{"question":"# Trie Implementation and Substring Matching You are given a data structure `Trie` which supports insertion of words and querying whether a word or prefix exists in the Trie. Now, extend the `Trie` class to include a new method `get_words_with_prefix` that returns all words in the Trie that start with a given prefix. # Function Signature ```python def get_words_with_prefix(self, prefix: str) -> List[str]: ``` # Input - `prefix`: A string representing the prefix to search in the Trie. # Output - Return a list of strings, where each string is a word from the Trie that starts with the given prefix. # Constraints - All words consist of lowercase letters (a-z). - There may be up to `10^4` words in the Trie, and each word\'s length is at most 20. - The prefix will be a non-empty string of lowercase letters. - You may assume that the Trie has no duplicate words. # Example ```python # Example usage: trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"applications\\") # Should return [\\"app\\", \\"apple\\", \\"applications\\"] print(trie.get_words_with_prefix(\\"app\\")) # Should return [\\"applications\\"] print(trie.get_words_with_prefix(\\"appli\\")) # Should return [] print(trie.get_words_with_prefix(\\"banana\\")) ``` # Task Extend the `Trie` class with the method `get_words_with_prefix` to meet the above requirements.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self._find_node(word) return node is not None and node.is_end_of_word def starts_with(self, prefix): return self._find_node(prefix) is not None def _find_node(self, prefix): node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node def get_words_with_prefix(self, prefix): words = [] node = self._find_node(prefix) if node: self._dfs(node, prefix, words) return words def _dfs(self, node, prefix, words): if node.is_end_of_word: words.append(prefix) for char in node.children: self._dfs(node.children[char], prefix + char, words)"},{"question":"You are tasked with developing a function that operates on polynomials represented using the `Monomial` and `Polynomial` classes provided. The function should take an algebraic polynomial and a set of assignments for its variables, and output the evaluated result. To achieve this, implement a method that substitutes the given values for the variables and then evaluates the simplified polynomial. Assume the algebraic polynomial will use variable identifiers in the same format as the provided classes. # Function Signature: ```python def evaluate_polynomial(expression: Polynomial, values: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: Evaluate a polynomial expression for the given variable assignments. Args: expression (Polynomial): The polynomial to be evaluated. values (Dict[int, Union[int, float, Fraction]]): A dictionary mapping variable identifiers to their values. Returns: Union[int, float, Fraction]: The evaluated polynomial result. ``` # Input: - `expression`: An instance of the `Polynomial` class representing the polynomial to evaluate. - `values`: A dictionary where keys are variable indices (integers) and values are the numeric (integer, float, or Fraction) values to substitute for the respective variables in the polynomial. # Output: - The result of evaluating the polynomial after substituting the given values for the variables. # Constraints: - Each variable identifier in the polynomial will have a corresponding entry in the `values` dictionary. - Polynomials to be evaluated will not exceed 10 variables. - The substitution values provided in the dictionary will be valid numbers. # Example: ```python # Example 1 expression = Polynomial([Monomial({1: 2}, 2), Monomial({2: 1, 1: -1}, -1)]) values = {1: 3, 2: 0.5} # Evaluating should be: 2*(3^2) + (-1)*(0.5)*(3^-1) # Result: 2*9 + (-1)*(0.5)*(1/3) = 18 - 1/6 = 107/6 = 17.8333 print(evaluate_polynomial(expression, values)) # Output: 17.8333... # Example 2 expression = Polynomial([Monomial({1: 1}, 1), Monomial({}, -1)]) values = {1: 1} # Evaluating should be: (1*1) + (-1) # Result: 1 - 1 = 0 print(evaluate_polynomial(expression, values)) # Output: 0 ``` # Notes: - Make sure you handle fractional values correctly. - Leverage the `substitute` method in the existing `Monomial` and `Polynomial` classes as necessary. Good luck!","solution":"from typing import Dict, Union from fractions import Fraction class Monomial: def __init__(self, variables: Dict[int, int], coefficient: float): self.vars = variables self.coeff = coefficient def substitute(self, values: Dict[int, Union[int, float, Fraction]]) -> float: result = self.coeff for var, power in self.vars.items(): if var in values: result *= values[var] ** power return result class Polynomial: def __init__(self, monomials: list): self.monomials = monomials def substitute(self, values: Dict[int, Union[int, float, Fraction]]) -> float: total = 0 for monomial in self.monomials: total += monomial.substitute(values) return total def evaluate_polynomial(expression: Polynomial, values: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: return expression.substitute(values)"},{"question":"# Cycle Detection with Floyd’s Cycle-Finding Algorithm Given a singly linked list, detect if there is a cycle in it. If there is a cycle, return the first node of the cycle. If there isn\'t a cycle, return `None`. Implement the following function: ```python def first_cyclic_node(head): :type head: Node :rtype: Node ``` # Input * `head`: The head node of the singly linked list. Each node has a `val` and `next` attribute. # Output * Return the node where the cycle begins, or `None` if there is no cycle. # Constraints * The number of nodes in the list is in the range `[0, 10^4]`. * Nodes\' values are arbitrary. * Assume the linked list may or may not have a cycle. # Example ```python class Node: def __init__(self, x): self.val = x self.next = None # Example 1: # Input: A -> B -> C -> D -> E -> C (cycle) # Output: C head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node print(first_cyclic_node(head).val) # Output: C # Example 2: # Input: 1 -> 2 -> 3 -> 4 -> None (no cycle) # Output: None head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) print(first_cyclic_node(head)) # Output: None ``` # Note: You may utilize helper classes and functions if needed to test your implementation. Make sure your solution is efficient and handles all edge cases properly.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head): Detects the first node in a cycle in a singly linked list. If there is no cycle, returns None. :type head: Node :rtype: Node if not head or not head.next: return None slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"# Problem: Flatten a Nested Array You are given an array that can contain both integers and other arrays (which can also contain integers or other arrays). Your task is to implement a function that flattens this array into a single list of integers. Function Signature ```python def flatten_array(nested_array: List[Union[int, List]]) -> List[int]: ``` Input: * `nested_array` (List[Union[int, List]]): A list where elements can either be integers or lists (which can also contain integers or lists, to arbitrary depth). Output: * Returns a list of integers that are the elements of the input lists, flattened into a single list. Constraints: * Do not use any built-in functions that explicitly perform the flattening (e.g., `itertools.chain`). * Handle arrays with up to 10^4 elements in total. * Handle nesting up to depth of 500. Example: ```python flatten_array([1, [2, [3, 4], 5], 6]) # Output: [1, 2, 3, 4, 5, 6] flatten_array([1, [2, [ [ 3 ] ] , 4], [5, 6, [7, 8]], 9]) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] flatten_array([[], [1, [], [2, 3]], []]) # Output: [1, 2, 3] ``` You need to implement the `flatten_array` function based on the provided requirements.","solution":"from typing import List, Union def flatten_array(nested_array: List[Union[int, List]]) -> List[int]: Flattens a nested array into a single list of integers. Args: nested_array (List[Union[int, List]]): The nested array to be flattened. Returns: List[int]: The flattened array containing only integers. flattened = [] def _flatten(sub_array): for element in sub_array: if isinstance(element, list): _flatten(element) else: flattened.append(element) _flatten(nested_array) return flattened"},{"question":"# Array Rotation Challenge Problem Description You are tasked with writing a function that rotates an array of integers to the right by `k` steps. You are not allowed to use slicing for this implementation. Instead, you must manipulate the array in place using efficient algorithms that minimize time and space complexity. Function Signature ```python def rotate_array(arr: List[int], k: int) -> None: ``` Input - `arr`: A list of integers which can be either empty or non-empty. The list is mutable and you need to rotate it in place. - `k`: An integer representing the number of steps to rotate the array to the right. It can be positive, zero, or greater than the length of the array. Output - The function should not return anything. Instead, it should modify the input list `arr` in place to achieve the correct rotation. Constraints - The space complexity of your solution must be O(1), meaning you cannot use additional lists or significant extra space. - Your solution should aim for O(n) time complexity. Example ```python arr = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate_array(arr, k) print(arr) # Output should be [5, 6, 7, 1, 2, 3, 4] ``` Edge Cases to Consider - When `arr` is empty. - When `k` is zero. - When `k` is greater than the length of the array. - When `arr` contains only one element. Hints - Consider using the reversal algorithm to achieve an in-place rotation efficiently. - Think about how you can leverage modular arithmetic to simplify the problem when `k` is greater than the length of the array.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps in-place. def reverse(sub_arr, start, end): while start < end: sub_arr[start], sub_arr[end] = sub_arr[end], sub_arr[start] start, end = start + 1, end - 1 n = len(arr) if n == 0: return # Normalize k if k is larger than the array length k = k % n # Reverse the whole array reverse(arr, 0, n - 1) # Reverse the first k elements reverse(arr, 0, k - 1) # Reverse the remaining n - k elements reverse(arr, k, n - 1)"},{"question":"# Scenario You are working on a new feature for a game where a robot moves on a grid. The robot starts at the origin (0, 0) and moves based on a sequence of commands given in a string. Each command indicates a move in one of four directions: right (\'R\'), left (\'L\'), up (\'U\'), and down (\'D\'). Your task is to determine if the robot returns to the origin after completing the sequence of moves. # Task Implement a function `judge_circle(moves: str) -> bool` that checks if the robot returns to the origin (0, 0) after executing the sequence of moves provided. # Input - `moves` (str): A string representing the move sequence (e.g., \\"UDLR\\"). # Output - Return `True` if the robot returns to the origin after all moves, otherwise return `False`. # Constraints 1. The move string will only contain characters from the set {\'R\', \'L\', \'U\', \'D\'}. # Examples ```python def judge_circle(moves: str) -> bool: # Your implementation here # Example 1: moves = \\"UD\\" print(judge_circle(moves)) # Output: True # Example 2: moves = \\"LL\\" print(judge_circle(moves)) # Output: False # Example 3: moves = \\"UDLR\\" print(judge_circle(moves)) # Output: True # Example 4: moves = \\"UUDDLRLR\\" print(judge_circle(moves)) # Output: True # Example 5: moves = \\"R\\" print(judge_circle(moves)) # Output: False ``` # Performance Requirements Ensure that your implementation runs efficiently, given the move sequence can be of a reasonable length within typical constraints for competitive programming (e.g., up to 10^4 characters). # Additional Notes * Make sure to consider edge cases such as an empty move sequence, which should return `True` since the robot doesn\'t move. * Focus on correctly updating the robot’s position based on the moves and checking the final position.","solution":"def judge_circle(moves: str) -> bool: Determine if the robot returns to the origin (0, 0) after completing the sequence of moves. x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"# Graph Path-Finding Challenge You are given a directed graph represented as an adjacency list, where each node points to a list of its connected nodes. Implement a function `optimized_find_shortest_path` that finds the shortest path between two nodes using an iterative BFS approach. This will help avoid issues with recursion depth and improve efficiency on unweighted graphs. Function Signature ```python def optimized_find_shortest_path(graph: dict, start: str, end: str) -> list: ``` Input - `graph`: A dictionary where keys are nodes and values are lists of connected nodes. E.g., `{\'A\': [\'B\', \'C\'], \'B\': [\'D\'], ...}` - `start`: A string representing the start node. - `end`: A string representing the end node. Output - Returns a list representing the shortest path from `start` to `end` including both nodes. - If no path exists, return an empty list. Constraints - The graph is a directed graph. - Node names are unique strings. - It is guaranteed that the start and end nodes are different. Performance Requirements - The solution should handle graphs with up to 10^3 nodes and edges efficiently. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [\'E\'], \'E\': [\'F\'], \'F\': [] } assert optimized_find_shortest_path(graph, \'A\', \'F\') == [\'A\', \'C\', \'F\'] assert optimized_find_shortest_path(graph, \'A\', \'E\') == [\'A\', \'B\', \'E\'] assert optimized_find_shortest_path(graph, \'A\', \'G\') == [] ``` In this implementation, perform BFS to ensure shortest path identification efficiently, while avoiding pitfalls of recursive depth limits.","solution":"from collections import deque def optimized_find_shortest_path(graph, start, end): Implements an iterative BFS to find the shortest path in a directed graph. if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: if neighbor == end: return path + [neighbor] queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return []"},{"question":"# Background A queue is a fundamental data structure used to handle a collection of elements in a FIFO (First-In-First-Out) manner. In this task, you are given abstract implementations and specific implementations of a queue using both arrays and linked lists. You are to complete the implementation and ensure it performs efficiently under various conditions. # Task Using the provided code skeleton, implement the following two additional operations for both `ArrayQueue` and `LinkedListQueue` classes: 1. **reverse()**: Reverses the order of elements in the queue. 2. **delete_middle()**: Deletes the middle element in the queue (if the size is even, remove the n/2th element where n is the number of elements). # Requirements - **Operation 1**: `reverse()` - This should alter the order of elements in the queue such that the first becomes last, second becomes second last, and so on. - **Operation 2**: `delete_middle()` - This should remove the middle element from the queue. - If the size is even, consider the element at position n/2 (0-based). # Constraints - Input queue size (`n`) can be up to 10^5. - Expected average time complexity for `reverse` and `delete_middle` algorithms must not exceed O(n). # Input/Output - `reverse`: - Input: None. - Output: None. It modifies the queue in place. - `delete_middle`: - Input: None. - Output: None. It modifies the queue in place. # Example Given a queue with elements in the order: [10, 20, 30, 40, 50] 1. After `reverse()`, the queue should be: [50, 40, 30, 20, 10] 2. After `delete_middle()`, the queue should be: [10, 20, 40, 50] (removes 30) # Implementation Complete the `reverse` and `delete_middle` methods for both `ArrayQueue` and `LinkedListQueue` classes in the code skeleton below: ```python # Assumed class definitions from above are already present here with incomplete new methods. class ArrayQueue(AbstractQueue): # ... previous code ... def reverse(self): Reverses the order of elements in the queue. Time Complexity: O(n) # Implement reverse logic here def delete_middle(self): Deletes the middle element of the queue. Time Complexity: O(n) # Implement delete_middle logic here class LinkedListQueue(AbstractQueue): # ... previous code ... def reverse(self): Reverses the order of elements in the queue. Time Complexity: O(n) # Implement reverse logic here def delete_middle(self): Deletes the middle element of the queue. Time Complexity: O(n) # Implement delete_middle logic here ```","solution":"class AbstractQueue: def __init__(self): self.size = 0 def enqueue(self, value): raise NotImplementedError def dequeue(self): raise NotImplementedError def is_empty(self): return self.size == 0 def get_size(self): return self.size class ArrayQueue(AbstractQueue): def __init__(self): super().__init__() self.queue = [] def enqueue(self, value): self.queue.append(value) self.size += 1 def dequeue(self): if self.is_empty(): return None self.size -= 1 return self.queue.pop(0) def reverse(self): self.queue = self.queue[::-1] def delete_middle(self): if self.size == 0: return middle_index = self.size // 2 del self.queue[middle_index] self.size -= 1 class ListNode: def __init__(self, value=None): self.value = value self.next = None class LinkedListQueue(AbstractQueue): def __init__(self): super().__init__() self.front = None self.rear = None def enqueue(self, value): new_node = ListNode(value) if self.is_empty(): self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node self.size += 1 def dequeue(self): if self.is_empty(): return None value = self.front.value self.front = self.front.next if self.front is None: self.rear = None self.size -= 1 return value def reverse(self): prev = None current = self.front while current: next_node = current.next current.next = prev prev = current current = next_node self.front, self.rear = self.rear, self.front def delete_middle(self): if self.size == 0: return middle_index = self.size // 2 if middle_index == 0: self.dequeue() return current = self.front for _ in range(middle_index - 1): current = current.next current.next = current.next.next if middle_index == self.size - 1: self.rear = current self.size -= 1"},{"question":"# Question: Implement a B-Tree to Manage Items # Scenario You are a software engineer working on a large-scale database management system. The system is required to manage a massive number of keys efficiently. You have been tasked to implement a B-Tree from scratch to handle `insert`, `search`, and `delete` operations. # Objective Implement a B-Tree data structure that supports the following operations: 1. **Insert**: Insert a key into the B-Tree. 2. **Search**: Search for a specific key in the B-Tree. 3. **Delete**: Remove a key from the B-Tree. 4. **Traverse**: Traverse the B-Tree and print keys in sorted order. # Specification Function Signature ```python class BTree: def __init__(self, t_val=2): pass def insert_key(self, key): pass def find(self, key) -> bool: pass def remove_key(self, key): pass def traverse_tree(self): pass ``` Input and Output - **InsertKey**: `BTree.insert_key(key: int)` - Input: An integer key to be inserted. - Output: None - **Find**: `BTree.find(key: int) -> bool` - Input: An integer key to be searched. - Output: Boolean value indicating if the key exists. - **RemoveKey**: `BTree.remove_key(key: int)` - Input: An integer key to be removed. - Output: None - **TraverseTree**: `BTree.traverse_tree()` - Input: No input. - Output: Prints keys in sorted order. Constraints - Degree of B-Tree `t` (minimum degree) is a positive integer (t ≥ 2). - Keys are distinct integers. # Performance Requirements - Time Complexity: O(log n) for insert, search, and delete operations where n is the number of keys. - Space Complexity: O(n). # Example ```python # Initialize the BTree with a degree of 3 btree = BTree(t_val=3) # Insert keys btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Perform Search print(btree.find(6)) # Output: True print(btree.find(15)) # Output: False # Traverse and print B-Tree btree.traverse_tree() # Output: 5 6 7 10 12 17 20 30 # Remove key btree.remove_key(6) btree.traverse_tree() # Output: 5 7 10 12 17 20 30 ``` Implement these operations ensuring the tree remains balanced and adhering to B-Tree properties during insertion, search, and deletion operations.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for the number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys in the node self.children = [] # List of child BTreeNodes class BTree: def __init__(self, t_val=2): self.t = t_val # Minimum degree self.root = BTreeNode(t_val, True) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t, False) temp.children.insert(0, self.root) self._split_child(temp, 0) self._insert_non_full(temp, key) self.root = temp else: self._insert_non_full(root, key) def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def _split_child(self, node, i): t = self.t y = node.children[i] z = BTreeNode(y.t, y.leaf) node.children.insert(i + 1, z) node.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t) - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def find(self, key) -> bool: return self._find(self.root, key) def _find(self, node, key) -> bool: i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.leaf: return False else: return self._find(node.children[i], key) def remove_key(self, key): self._remove(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = BTreeNode(self.t, True) def _remove(self, node, key): t = self.t idx = self._find_key(node, key) if idx < len(node.keys) and node.keys[idx] == key: if node.leaf: node.keys.pop(idx) else: self._remove_from_non_leaf(node, idx) else: if node.leaf: return flag = idx == len(node.keys) if len(node.children[idx].keys) < t: self._fill(node, idx) if flag and idx > len(node.keys): self._remove(node.children[idx - 1], key) else: self._remove(node.children[idx], key) def _remove_from_non_leaf(self, node, idx): key = node.keys[idx] t = self.t if len(node.children[idx].keys) >= t: pred = self._get_predecessor(node, idx) node.keys[idx] = pred self._remove(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = self._get_successor(node, idx) node.keys[idx] = succ self._remove(node.children[idx + 1], succ) else: self._merge(node, idx) self._remove(node.children[idx], key) def _get_predecessor(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_successor(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _merge(self, node, idx): t = self.t child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.keys.pop(idx) node.children.pop(idx + 1) def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _find_key(self, node, key): idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 return idx def traverse_tree(self): self._traverse(self.root) print() def _traverse(self, node): for i in range(len(node.keys)): if not node.leaf: self._traverse(node.children[i]) print(node.keys[i], end=\' \') if not node.leaf: self._traverse(node.children[len(node.keys)])"},{"question":"# Problem: Cycle Detection in a Directed Graph Context In a system represented as a directed graph, each process can be thought of as a vertex, and a directed edge from one vertex to another indicates that the first process is waiting for the second. This often mirrors the scenario of resource allocation and dependencies in operating systems, where detecting cycles is critical for identifying deadlocks. Task Implement a function called `detect_cycle` which determines whether a cycle exists in a given directed graph. A cycle in the graph indicates potential deadlocks or unresolvable dependencies. Function Signature ```python def detect_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` Input - A `graph` represented as a dictionary where the key is a string representing a vertex and the value is a list of strings representing the vertices that the key has directed edges toward. Output - Return `True` if there\'s a cycle in the graph, otherwise `False`. Constraints - The graph can consist of up to 10^4 vertices and 10^5 edges. - Graph vertices are represented as uppercase alphabetical letters. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle(graph)) # Output: True graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } print(detect_cycle(graph2)) # Output: False ``` Notes - Consider handling graphs that are disconnected, have no edges, or contain self-loops.","solution":"def detect_cycle(graph): Detects if there is a cycle in the directed graph. :param graph: A dictionary where the key is a vertex and the value is a list of vertices with directed edges from the key vertex. :return: True if there is a cycle, otherwise False. def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbour in graph.get(node, []): if visit(neighbour): return True visiting.remove(node) visited.add(node) return False visiting = set() visited = set() for node in graph: if visit(node): return True return False"},{"question":"# ZigZag Iterator Implementation & Extension You are given the implementation of a `ZigZagIterator` that takes two lists and outputs their elements in an alternating fashion. Your task is to extend this implementation to allow for multiple (more than two) input lists and ensure that elements from all lists are iterated over in a round-robin manner. Task Implement a class `MultiZigZagIterator` that: 1. Initializes with a list of lists. 2. Implements the `next()` method to return the next element in zigzag order. 3. Implements the `has_next()` method to check if there are more elements. Requirements * **Input**: * The initializer method takes a list of lists of integers. * **Output**: * `next()`: Returns an integer. * `has_next()`: Returns a boolean indicating whether the iterator has more elements. * **Constraints**: * All integers are non-negative. * You must handle any number of lists, not just two. * Each call to `next()` and `has_next()` must be O(1) on average. Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = MultiZigZagIterator([l1, l2, l3]) output = [] while it.has_next(): output.append(it.next()) # output should be: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Implementation Implement the class `MultiZigZagIterator` below: ```python class MultiZigZagIterator: def __init__(self, lists): self.queue = [lst for lst in lists if lst] def next(self): if not self.queue: return None v = self.queue.pop(0) ret = v.pop(0) if v: self.queue.append(v) return ret def has_next(self): return bool(self.queue) ``` *Note:* Ensure to handle edge cases such as empty lists within the input lists.","solution":"class MultiZigZagIterator: def __init__(self, lists): Initialize the iterator with a list of lists. :param lists: List[List[int]] self.queue = [lst for lst in lists if lst] def next(self): Returns the next element in zigzag order. :rtype: int if not self.queue: return None # Get the first list in the queue current_list = self.queue.pop(0) # Take the first element from this list next_value = current_list.pop(0) # If the list is not empty, put it back to the end of the queue if current_list: self.queue.append(current_list) return next_value def has_next(self): Check if there are more elements to iterate over. :rtype: bool return bool(self.queue)"},{"question":"Climbing a Staircase You are required to implement a function that calculates the number of distinct ways to climb a staircase consisting of `steps` steps. Each time you can either climb 1 or 2 steps. The function should aim to be efficient both in terms of time and space. Function Signature ```python def climb_stairs_optimized(steps: int) -> int: :param steps: int - The total number of steps in the staircase. :return: int - The number of distinct ways to reach the top. ``` # Input - An integer `steps` (1 ≤ steps ≤ 10,000), representing the number of steps to the top of the staircase. # Output - An integer representing the number of distinct ways to reach the top of the staircase. # Constraints - You can only take 1 or 2 steps at a time. # Scenario Imagine you are a coach training an athlete on a staircase workout routine. The athlete can either take one step or jump two steps to move to the top. With a given staircase size, you need to determine how many unique ways the athlete can complete their workout by reaching the topmost step. # Examples ```python assert climb_stairs_optimized(3) == 3 # (1+1+1, 1+2, 2+1) assert climb_stairs_optimized(4) == 5 # (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2) assert climb_stairs_optimized(5) == 8 # (1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1) ``` # Additional Considerations - Think about the edge cases such as the smallest possible number of steps (i.e., 1 or 2). - Ensure your function is optimized for larger values up to 10,000 steps.","solution":"def climb_stairs_optimized(steps: int) -> int: Calculate the number of distinct ways to climb a staircase consisting of `steps` steps, where each time you can either climb 1 or 2 steps. :param steps: int - The total number of steps in the staircase. :return: int - The number of distinct ways to reach the top. if steps == 1: return 1 elif steps == 2: return 2 prev2 = 1 prev1 = 2 for i in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"**Context**: You are a developer at a company where you often need to sort large datasets efficiently. Your task is to implement the merge sort algorithm, ensuring it works correctly for all possible inputs. **Task**: Implement the `merge_sort` function provided. The function should sort an array of integers in ascending order. Review the function definitions and complete the given functions to ensure it handles all scenarios correctly. # Requirements: - Implement the `merge_sort` function using a recursive approach. - Ensure the `merge` function correctly merges two halves. - Return the sorted array as the output. # Constraints: - The input array can contain up to 10^5 elements. - The integers will be in the range of -10^6 to 10^6. # Input Format: - A list of integers, `arr`. # Output Format: - A sorted list of integers in ascending order. ```python def merge_sort(arr): Merge Sort algorithm to sort an array. :param arr: List[int] - The input array of integers to be sorted :return: List[int] - The sorted array # Base case if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merge helper function to combine two sorted lists. :param left: List[int] - The left half of the sorted data :param right: List[int] - The right half of the sorted data :return: List[int] - The merged sorted list merged = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged.append(left[left_cursor]) left_cursor += 1 else: merged.append(right[right_cursor]) right_cursor += 1 # Add the left overs if there\'s any left to the result merged.extend(left[left_cursor:]) merged.extend(right[right_cursor:]) return merged ``` Ensure to test your implementation thoroughly including edge cases such as empty arrays, arrays with a single element, and arrays with repeated elements.","solution":"def merge_sort(arr): Merge Sort algorithm to sort an array. :param arr: List[int] - The input array of integers to be sorted :return: List[int] - The sorted array # Base case if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merge helper function to combine two sorted lists. :param left: List[int] - The left half of the sorted data :param right: List[int] - The right half of the sorted data :return: List[int] - The merged sorted list merged = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged.append(left[left_cursor]) left_cursor += 1 else: merged.append(right[right_cursor]) right_cursor += 1 # Add the left overs if there\'s any left to the result merged.extend(left[left_cursor:]) merged.extend(right[right_cursor:]) return merged"},{"question":"# Question: Valid Sudoku Board Given a Sudoku board, determine if it is valid. The board is partially filled, where empty cells are represented by the character \'.\'. A valid Sudoku board (partially filled) must satisfy these conditions: 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the nine 3x3 sub-boxes must contain the digits 1-9 without repetition. Input: * A 2D list `board` of size 9x9. ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` Output: * Return `True` if the board is valid, otherwise `False`. Constraints: * The board must be of size 9x9. * Each cell contains only the characters \'1\'-\'9\' or \'.\'. # Function Signature ```python def is_valid_sudoku(board: List[List[str]]) -> bool: # Your code here pass ``` # Example: ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] print(is_valid_sudoku(board)) # Output: True ``` Note: * Be sure to handle all edge cases such as empty or completely filled boards. Optimize for efficiency in both time and space considerations.","solution":"from typing import List def is_valid_sudoku(board: List[List[str]]) -> bool: def is_valid_block(block): block = [x for x in block if x != \'.\'] return len(block) == len(set(block)) # Check rows for row in board: if not is_valid_block(row): return False # Check columns for col in range(9): if not is_valid_block([board[row][col] for row in range(9)]): return False # Check 3x3 sub-boxes for box_row in range(3): for box_col in range(3): block = [board[row][col] for row in range(box_row*3, box_row*3 + 3) for col in range(box_col*3, box_col*3 + 3)] if not is_valid_block(block): return False return True"},{"question":"You are given an undirected, unweighted graph represented as an adjacency list. Your task is to implement the following functions to perform graph traversals: 1. **depth_first_search(graph, start)**: Perform a depth-first search (DFS) traversal iteratively. 2. **breadth_first_search(graph, start)**: Perform a breadth-first search (BFS) traversal. 3. **depth_first_search_recursive(graph, start)**: Perform a depth-first search (DFS) traversal recursively. The traversals should return the list of nodes in the order they were first visited. Assume the start node is always present in the graph. # Input Format - `graph` (dict): A dictionary representing the adjacency list of the graph. Keys are node identifiers, and values are lists of adjacent nodes. - `start` (str/int): The starting node for the traversal. # Output Format - Return a list of nodes in the order they were first visited. # Constraints - The graph is undirected and unweighted. - There are no self-loops or multiple edges between any pair of nodes. - Each node in the graph is connected to at least one other node (excluding isolated starting node). - The number of nodes V is such that 1 ≤ V ≤ 10^4. - The number of edges E is such that 0 ≤ E ≤ 10^4. # Example Consider the graph represented as: ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4] } start = 0 ``` **Expected Output**: - **depth_first_search(graph, start)**: [0, 2, 1, 4, 5, 3] - **breadth_first_search(graph, start)**: [0, 1, 2, 3, 4, 5] - **depth_first_search_recursive(graph, start)**: [0, 1, 3, 4, 5, 2] # Note - The order of traversal for DFS could vary if the adjacency list order of the neighbors changes. - BFS should always follow the same level-order traversal regardless of adjacency list order.","solution":"def depth_first_search(graph, start): Perform a depth-first search (DFS) traversal iteratively. :param graph: the adjacency list of the graph :param start: the starting node for the traversal :return: a list of nodes in the order they were first visited visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) # Add neighbors to stack in reverse order to maintain the input order\'s DFS behavior stack.extend(reversed(graph[node])) return visited def breadth_first_search(graph, start): Perform a breadth-first search (BFS) traversal. :param graph: the adjacency list of the graph :param start: the starting node for the traversal :return: a list of nodes in the order they were first visited visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph[node]) return visited def depth_first_search_recursive(graph, start, visited=None): Perform a depth-first search (DFS) traversal recursively. :param graph: the adjacency list of the graph :param start: the starting node for the traversal :param visited: list to keep track of visited nodes :return: a list of nodes in the order they were first visited if visited is None: visited = [] if start not in visited: visited.append(start) for neighbor in graph[start]: depth_first_search_recursive(graph, neighbor, visited) return visited"},{"question":"# Shell Sort Enhancement Shell Sort is an improved insertion sort that allows the exchange of items that are far apart. The idea is to arrange the list of elements so that, starting anywhere, taking every `h`th element (where `h` is an integer variable constantly decreasing) yields a sorted list. Initially, the gap `h` is set to `n/2` and it is decreased by some factor in each iteration. **Objective**: Modify the given Shell Sort algorithm to use Sedgewick\'s gap sequence for improved performance. **Sedgewick\'s Gap Sequence**: Use the sequence of gaps starting at: 1, 5, 19, 41, 109, 209, 505, 929,... The elements of this sequence can be generated using two parts: 1. The \'shell\' portion with gaps generated by `4^i + 3*2^(i-1) + 1` (i starting from 0) 2. The \'hibbard\' portion with gaps generated by `2^i + 1` (i starting from 0) **Constraints**: * Input `arr` will be a list containing integers. * Implement the function within `O(n^2)` time complexity. **Function Signature**: ```python def enhanced_shell_sort(arr: List[int]) -> List[int]: pass ``` **Example**: ```python # Example 1 input: [12, 34, 54, 2, 3] output: [2, 3, 12, 34, 54] # Example 2 input: [7, 4, 1, 8, 5, 2] output: [1, 2, 4, 5, 7, 8] ``` # Implementation Details: 1. Generate Sedgewick’s sequence up to necessary gap. 2. Implement the shell sort using this gap sequence. 3. Ensure the final gap is 1 for completing the sort. Good luck and happy coding!","solution":"def generate_sedgewick_gaps(n): Generates the Sedgewick gap sequence up to the largest gap less than n. gaps = [] index = 0 gap = 0 while True: if index % 2 == 0: gap = 9 * (4**index - 2**index) + 1 else: gap = 8 * (2**(index + 1) - 1) + 1 if gap > n: break gaps.append(gap) index += 1 return gaps[::-1] def enhanced_shell_sort(arr): n = len(arr) gaps = generate_sedgewick_gaps(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Implement a function `remove_kth_bit(num: int, k: int) -> int` that removes the k-th bit from the binary representation of a given number. The index k is 0-based from the right (least significant bit). # Input * `num` (an integer `0 ≤ num ≤ 10^9`): The number from which to remove the bit. * `k` (an integer `0 ≤ k < number_of_bits_in_num`): The index of the bit to be removed, where `0` denotes the least significant bit. # Output * Returns the new integer obtained by removing the k-th bit from the binary representation of `num`. # Examples ```python remove_kth_bit(21, 2) # Output: 9 (21 in binary is 10101, remove bit at index 2 -> 1001) remove_kth_bit(21, 4) # Output: 5 (21 in binary is 10101, remove bit at index 4 -> 101) remove_kth_bit(21, 0) # Output: 10 (21 in binary is 10101, remove bit at index 0 -> 1010) ``` # Constraints * The function should handle the input constraints efficiently. * Avoid using strings or list operations to manipulate the binary representation. # Hints * Consider using bitwise operations (shift, mask) to isolate and exclude the desired bit. * Be careful with the indices for the bit positions to accurately remove the specific bit.","solution":"def remove_kth_bit(num: int, k: int) -> int: Removes the k-th bit from the binary representation of a given number. Parameters: num (int): The number from which to remove the bit. k (int): The index of the bit to be removed, 0-based from the right (least significant bit). Returns: int: The new integer obtained by removing the k-th bit. higher_bits = num >> (k + 1) lower_bits = num & ((1 << k) - 1) return (higher_bits << k) | lower_bits"},{"question":"# Factor Combinations Finder In this problem, you need to implement a function that, given an integer `n`, returns all possible combinations of its factors. The factors must be strictly greater than 1 and less than `n`. Input: - A single integer `n` with `1 <= n <= 10^5`. Output: - A list of lists: Each sublist contains a combination of factors whose product equals `n`. Constraints: - Factors should be greater than 1 and less than `n`. - Combinations should not have repeated sets, and the order of factors within each combination does not matter. - The output list does not need to be in any specific order. Performance Requirements: - The solution should handle large inputs efficiently, avoiding unnecessary computations and limiting memory usage. Example Scenarios: **Example 1**: ```text Input: 1 Output: [] Explanation: 1 has no factors other than itself. ``` **Example 2**: ```text Input: 37 Output: [] Explanation: 37 is a prime number, so it has no factors other than 1 and 37. ``` **Example 3**: ```text Input: 12 Output: [[2, 6], [2, 2, 3], [3, 4]] Explanation: 12 can be factorized as 2*6, 2*2*3, and 3*4. ``` **Example 4**: ```text Input: 32 Output: [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]] Explanation: 32 can be factorized in multiple ways as shown above. ``` # Instructions: - Implement the function in Python. - Ensure that your function adheres to performance constraints. - Validate the input appropriately. # Function Signature: ```python def factor_combinations(n: int) -> List[List[int]]: # Your implementation here ```","solution":"from typing import List def factor_combinations(n: int) -> List[List[int]]: def get_factors(x): factors = [] for i in range(2, int(x**0.5) + 1): if x % i == 0: factors.append(i) if i != x // i: factors.append(x // i) return factors def backtrack(start, product, current): if product == n: result.append(current[:]) return for i in range(start, len(factors)): next_factor = factors[i] if product * next_factor > n: continue current.append(next_factor) backtrack(i, product * next_factor, current) current.pop() if n <= 1: return [] factors = sorted(get_factors(n)) result = [] backtrack(0, 1, []) return result"},{"question":"Objective You are tasked with implementing a function to find and return the nth digit in the sequence of natural numbers (starting from 1). This assessment will evaluate your understanding of arithmetic manipulations and iterative computations. Problem Statement Implement a function `find_nth_digit(n: int) -> int` that finds the nth digit (1-indexed) in the infinite sequence of concatenated natural numbers. Input Format - **n**: An integer (1 <= n <= 10^9) representing the position in the sequence for which the digit is to be found. Output Format - An integer: The nth digit in the sequence. Examples - **Example 1:** - Input: `n = 3` - Output: `3` - **Example 2:** - Input: `n = 15` - Output: `2` - **Example 3:** - Input: `n = 1000` - Output: `3` Constraints - Consider both efficiency and correctness. The solution must handle all edge cases within the provided input constraints. - Aim for an algorithm that operates within the allowable time and space complexity. Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Additional Notes 1. Be mindful of integer conversion and large numbers. 2. Thoroughly test edge cases, such as transitions between digit lengths (e.g., from 9 to 10, from 99 to 100). 3. Optimize for performance where possible, ensuring the solution can handle the upper limit of n efficiently.","solution":"def find_nth_digit(n: int) -> int: # Define various constraints and initial variables digit_length = 1 count = 9 start = 1 # Identify the range where the nth digit is located while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Locate the exact number where nth digit is found start += (n - 1) // digit_length digit_str = str(start) # Determine the specific digit within the number return int(digit_str[(n - 1) % digit_length])"},{"question":"You are tasked to write a function that demonstrates your understanding of stack-based operations and the use of auxiliary structures for manipulating data. Specifically, you need to switch successive pairs of elements in a given stack data structure. # Task Implement a function `switch_pairs(stack)` that performs pair switching of elements in the stack. The stack should be manipulated in place and should handle both even and odd numbers of elements accordingly. You may choose to use an auxiliary stack or queue. # Function Signature ```python def switch_pairs(stack: List[int]) -> List[int]: # Your code here ``` # Input Format - `stack`: A list of integers representing a stack (the last element of the list is the top of the stack) # Output Format - Returns the modified stack with successive pairs switched. # Constraints - 0 <= len(stack) <= 10^5 - The elements of the stack are integers. # Example ```python # Example 1 print(switch_pairs([3, 8, 17, 9, 1, 10])) # Output: [8, 3, 9, 17, 10, 1] # Example 2 print(switch_pairs([3, 8, 17, 9, 1])) # Output: [8, 3, 9, 17, 1] # Example 3 print(switch_pairs([])) # Output: [] ``` # Notes - Ensure the function handles edge cases such as empty stacks and stacks with odd numbers of elements. - Aim for a solution with optimal time and space complexity.","solution":"def switch_pairs(stack): Switch successive pairs of elements in a given stack. :param stack: List of integers representing the stack (last element is top of stack) :return: Modified stack with successive pairs switched n = len(stack) # Process pairs for i in range(1, n, 2): stack[i], stack[i-1] = stack[i-1], stack[i] return stack"},{"question":"# Range Maximum Query Using Segment Tree Segment trees are a powerful data structure used to solve range queries efficiently. In this task, you will implement a segment tree and use it to handle range maximum queries over a given list. Problem Statement You are given a list of integers. Your task is to construct a segment tree from the list to answer multiple range maximum queries efficiently. A range maximum query asks for the maximum value within a specific subarray of the list. Function Signatures Your solution should implement the following functions: * `SegmentTree.__init__(self, arr: List[int]) -> None`: Constructor that initializes the segment tree with the given `arr`. * `SegmentTree.query(self, L: int, R: int) -> int`: Method that returns the maximum value in the subarray ranging from index `L` to `R` (inclusive). Input * `arr`: A list of integers. (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9) * `L`, `R`: Indices for the range query. (0 ≤ L ≤ R < len(arr)) Constraints * Multiple queries will be performed, potentially up to `10^4` queries. Example ```python arr = [2, 4, 5, 3, 4] segment_tree = SegmentTree(arr) assert segment_tree.query(2, 4) == 5 assert segment_tree.query(0, 3) == 5 arr2 = [1, 3, -2, 8, -7, 10, 14, 7] segment_tree2 = SegmentTree(arr2) assert segment_tree2.query(1, 5) == 10 assert segment_tree2.query(3, 6) == 14 assert segment_tree2.query(4, 7) == 14 ``` # Notes * Ensure efficient construction and query performance. * Handle edge cases gracefully. * Provide thorough test cases to validate your implementation.","solution":"class SegmentTree: def __init__(self, arr): n = len(arr) self.n = n self.tree = [0] * (2 * n) self.build(arr) def build(self, arr): # Initialize leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, L, R): # Query the range [L, R] L += self.n R += self.n max_val = float(\'-inf\') while L <= R: if L % 2 == 1: max_val = max(max_val, self.tree[L]) L += 1 if R % 2 == 0: max_val = max(max_val, self.tree[R]) R -= 1 L //= 2 R //= 2 return max_val"},{"question":"# Path Normalization and File Validation In many applications, file paths provided by users or other parts of the system need to be validated and standardized to absolute paths before use. Building upon this, implement a function that, apart from resolving the absolute path, also checks whether the file exists and is readable. Task: Write a function `normalize_and_validate_path(file)` that takes a file path as a string, resolves it to an absolute path, and checks if the file exists and is readable. Return the absolute path if the file passes these checks, else return `None`. Function Signature: ```python def normalize_and_validate_path(file: str) -> str: pass ``` Input: * `file` - a string representing the file path. Output: * Return the absolute path of the file if it exists and is readable. * Return `None` otherwise. Constraints: * The input string can be empty or improperly formatted, handle these gracefully. * The function should handle tilde (`~`) indicating the home directory. * Assume the operating system is Unix-like for user directory expansion. Example: ```python assert normalize_and_validate_path(\\"~/testfile.txt\\") == \\"/home/user/testfile.txt\\" assert normalize_and_validate_path(\\"~/non_existing_file.txt\\") == None ``` Explanation: 1. For the input \\"~/testfile.txt\\", if \\"testfile.txt\\" exists in the user\'s home directory and is readable, the function will return its absolute path \\"/home/user/testfile.txt\\". 2. For an input that points to a non-existing or unreadable file, the function will return `None`.","solution":"import os def normalize_and_validate_path(file: str) -> str: Resolves the file path to an absolute path, checking if the file exists and is readable. Returns the absolute path if valid, else returns None. if not file: return None try: # Expand user home directory (~) and get absolute path abs_path = os.path.abspath(os.path.expanduser(file)) # Check if the file exists and is readable if os.path.isfile(abs_path) and os.access(abs_path, os.R_OK): return abs_path else: return None except Exception: return None"},{"question":"# Context Quick Sort is a highly efficient sorting algorithm, but it can suffer from poor performance with certain types of input. To mitigate this, advanced versions of Quick Sort use techniques like median-of-three pivot selection or hybrid approaches. These methods are designed to optimize the pivot selection and handle smaller partitions more effectively. # Task You are required to implement an improved version of Quick Sort: `optimized_quick_sort`. This version must: 1. Use the median-of-three method to select the pivot. 2. Switch to Insertion Sort for partitions smaller than a given threshold to optimize the performance. # Specifications * **Function**: `def optimized_quick_sort(arr, threshold=10):` * **Input**: `arr`: List of integers, `threshold`: Integer (optional, default=10) - the partition size below which Insertion Sort should be used. * **Output**: Sorted list of integers. # Detailed Requirements 1. **Median-of-Three Pivot Selection**: The pivot element should be the median of the first, middle, and last elements of the current partition. 2. **Insertion Sort**: If the size of a partition is less than or equal to `threshold`, use Insertion Sort instead of Quick Sort. 3. Avoid altering the original array (perform operations on a copy). # Example ```python arr = [23, 45, 12, 56, 1, 34, 22, 76, 64, 43] sorted_arr = optimized_quick_sort(arr, threshold=5) print(sorted_arr) # Output should be the sorted version of `arr`. ``` # Constraints * The input list `arr` will have at most `10^5` elements. * Elements of `arr` will be integers within the range `-10^9` to `10^9`. * The threshold will be a positive integer and reasonably small (<= 100). # Performance Requirements * Ensure the algorithm performs efficiently for large input sizes. * Avoid excessive memory usage and recursion depth issues.","solution":"def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, left, right): mid = (left + right) // 2 if arr[left] > arr[mid]: arr[left], arr[mid] = arr[mid], arr[left] if arr[left] > arr[right]: arr[left], arr[right] = arr[right], arr[left] if arr[mid] > arr[right]: arr[mid], arr[right] = arr[right], arr[mid] return mid def partition(arr, left, right): pivot_index = median_of_three(arr, left, right) arr[pivot_index], arr[right] = arr[right], arr[pivot_index] pivot = arr[right] i = left for j in range(left, right): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[right] = arr[right], arr[i] return i def quick_sort_recursive(arr, left, right, threshold): if right - left + 1 <= threshold: insertion_sort(arr, left, right) else: if left < right: pivot_index = partition(arr, left, right) quick_sort_recursive(arr, left, pivot_index - 1, threshold) quick_sort_recursive(arr, pivot_index + 1, right, threshold) def optimized_quick_sort(arr, threshold=10): arr_copy = arr[:] quick_sort_recursive(arr_copy, 0, len(arr_copy) - 1, threshold) return arr_copy"},{"question":"# Context You are working on a project that involves searching for elements within a large dataset represented as a matrix. The matrix is sorted in non-decreasing order both row-wise and column-wise. Given such a matrix and a key, you must determine whether the key exists in the matrix. If the key is present, you should return its position; otherwise, you should indicate that the key is not found. # Problem Write a function `search_in_a_sorted_matrix(matrix, key)` that takes a matrix and a key as input and searches for the key within the matrix. The function should return a tuple containing the row and column indices (1-based) if the key is found, or a message indicating that the key is not found. # Input Format - `matrix`: A list of lists, representing the sorted matrix. Each row and column of the matrix is sorted in non-decreasing order. - `key`: An integer representing the key to search for. # Output Format - If the key is found, return a tuple `(row_index, column_index)` where both indices are 1-based. - If the key is not found, return the string `\\"Key not found\\"`. # Constraints - The number of rows `m` and the number of columns `n` of the matrix are positive integers. - The elements of the matrix and the key will be integers. # Examples Example 1: ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 search_in_a_sorted_matrix(matrix, key) ``` *Output:* `(2, 3)` (Key 13 found at row 2, column 3) Example 2: ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 10 search_in_a_sorted_matrix(matrix, key) ``` *Output:* `\\"Key not found\\"` # Implementation Implement the function using the following signature: ```python def search_in_a_sorted_matrix(matrix, key): # Your code here ``` You may assume the provided matrix always meets the constraints.","solution":"def search_in_a_sorted_matrix(matrix, key): Searches for a key in a sorted matrix and returns the position if found. Args: matrix (list of lists): 2D list of integers sorted row-wise and column-wise. key (int): The key to search for. Returns: tuple: (row_index, column_index) if key is found (1-based index). str: \\"Key not found\\" if key is not in the matrix. if not matrix or not matrix[0]: return \\"Key not found\\" # Number of rows and columns rows = len(matrix) cols = len(matrix[0]) # Start searching from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row + 1, col + 1) elif matrix[row][col] > key: col -= 1 else: row += 1 return \\"Key not found\\""},{"question":"Context You are given a dataset tracking the daily temperature changes over a month. As a meteorologist, you are interested in finding the period during which the temperature change was maximized. For this purpose, you need to implement an algorithm to find the maximum sum of a contiguous subarray within the given array of daily temperature changes. Task Write a function `max_temperature_change` which implements Kadane\'s Algorithm to find the maximum sum of a contiguous subarray within a given array of integers representing daily temperature changes. Function Signature ```python def max_temperature_change(changes: List[int]) -> int: ``` Input * A list of integers `changes` representing daily temperature changes for a month. Constraints: * The input list will have at least one integer and at most 10,000 integers. * Each integer in the array can be between -100 and 100 inclusive. Output * Return an integer representing the maximum sum of a contiguous subarray. Example ```python changes = [1, 2, -3, 4, 5, -7, 23] print(max_temperature_change(changes)) # Output should be 25 ``` Constraints * Ensure the function runs in O(n) time complexity and uses O(1) additional space. * Handle edge cases like arrays with a single element or all negative values.","solution":"from typing import List def max_temperature_change(changes: List[int]) -> int: Implements Kadane\'s Algorithm to find the maximum sum of a contiguous subarray. Parameters: changes (List[int]): A list of integers representing daily temperature changes. Returns: int: The maximum sum of a contiguous subarray. max_ending_here = max_so_far = changes[0] for x in changes[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Ternary Search Implementation Challenge Context You have to implement a search algorithm for a software system that deals with sorted datasets. Given the constraints and to differentiate from the typical binary search, you opt to implement a Ternary Search algorithm. The implementation should be robust enough to handle various edge cases and should aim for efficiency given the problem constraints. Problem Statement Write a function `ternary_search` that takes a sorted list of integers, a key to search for, and returns the index of the key if found. If the key is not found in the list, it should return -1. Function Signature ```python def ternary_search(arr: List[int], left: int, right: int, key: int) -> int: ``` Input - `arr` (List[int]): A list of integers sorted in ascending order. - `left` (int): The starting index of the search range. - `right` (int): The ending index of the search range. - `key` (int): The integer value to search for in the list. Output - (int): The index of the key in the list if found, else -1. Constraints - All elements in `arr` are distinct. - The list `arr` length will not exceed 10^6. - The search range `left` to `right` will always be valid within the bounds of the list. Example ```python assert ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 8, 4) == 3 assert ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 8, 10) == -1 assert ternary_search([10, 20, 30, 40, 50, 60, 70], 0, 6, 40) == 3 assert ternary_search([10, 20, 30, 40, 50, 60, 70], 0, 6, 35) == -1 ``` Notes - Ensure your implementation follows as closely to the given pseudocode for consistent result verification. - Be cautious about integer division and ensure indices do not go out of range during calculations.","solution":"from typing import List def ternary_search(arr: List[int], left: int, right: int, key: int) -> int: while left <= right: one_third = left + (right - left) // 3 two_third = right - (right - left) // 3 if arr[one_third] == key: return one_third if arr[two_third] == key: return two_third if key < arr[one_third]: right = one_third - 1 elif key > arr[two_third]: left = two_third + 1 else: left = one_third + 1 right = two_third - 1 return -1"},{"question":"Min Heap Enhancements A binary min heap is a fundamental data structure where each parent node is smaller than or equal to its children. This heap supports efficient insertions and deletions, making it essential for various applications like priority queues and graph algorithms. You are required to enhance the provided BinaryHeap class by implementing an additional functionality: 1. `find_kth_smallest(k)`: Finds the k-th smallest element in the min heap without disrupting the heap properties. You should use an efficient method that leverages heap operations. Function Signature ```python def find_kth_smallest(self, k: int) -> int: ``` # Input * An integer k (1 <= k <= current_size of the heap). # Output * The k-th smallest element in the heap. # Constraints * The function should handle large heaps efficiently. * Minimize the number of heap operations. # Example Suppose our min heap is represented as: [0, 1, 3, 6, 5, 9, 8]. The resulting binary tree is: ``` 1 / 3 6 / / 5 9 8 ``` Sample Usage ```python heap = BinaryHeap() for num in [5, 9, 1, 3, 6, 8]: heap.insert(num) print(heap.find_kth_smallest(3)) # Output should be 5 ``` # Hints * Consider using a temporary heap or similar data structure to extract elements one by one until the k-th smallest is found. * Ensure your function runs efficiently and does not alter the original heap order.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] self.current_size = 0 def insert(self, k): heapq.heappush(self.heap, k) self.current_size += 1 def find_kth_smallest(self, k: int) -> int: if k < 1 or k > self.current_size: raise IndexError(\\"k is out of bounds\\") # Create a copy of the heap to avoid modifying the original heap temp_heap = list(self.heap) # Extract the k smallest elements for _ in range(k - 1): heapq.heappop(temp_heap) # The k-th smallest element now resides at the root of the temp heap return temp_heap[0]"},{"question":"Context: FizzBuzz is a common problem used to test basic programming skills. You are required to implement a function that generates a list of values based on the FizzBuzz rules. Task: Write a function `customFizzBuzz(n: int, replacements: dict) -> List[Union[str, int]]` that returns a list containing numbers from 1 to N, where N is the input parameter. However, for multiples of certain numbers, you should replace the number with a specified string from the replacements dictionary. Rules: * The replacements dictionary will contain (key, value) pairs where the key is an integer and the value is the string to replace multiples of that integer. * If a number falls under multiple replacement rules, concatenate the corresponding replacement strings in the order they appear in the dictionary. * If there are no replacement rules matching a number, retain the number itself. Function Signature: ```python def customFizzBuzz(n: int, replacements: dict) -> List[Union[str, int]]: pass ``` Input: * `n`: An integer (1 ≤ n ≤ 10^4) * `replacements`: A dictionary with integer keys and string values, where each key is greater than 0. Output: * A list of integers and/or strings as described in the rules. Example: ```python input: n = 15, replacements = {3: \'Fizz\', 5: \'Buzz\'} output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] input: n = 10, replacements = {2: \'Foo\', 3: \'Bar\'} output: [1, \'Foo\', \'Bar\', \'Foo\', 5, \'FooBar\', 7, \'Foo\', \'Bar\', \'Foo\'] ``` Constraints: 1. Ensure the function handles the replacements in the order they are provided in the dictionary. 2. The function should be optimized for performance, considering the constraints. Additional Information - Your function should handle any possible edge cases such as when `n` is at the lowest or highest bounds. - Proper error handling for invalid input is required.","solution":"from typing import List, Union def customFizzBuzz(n: int, replacements: dict) -> List[Union[str, int]]: Generate a list of integers from 1 to n with specific replacements for multiples of given numbers. Args: n: The upper limit of the range (inclusive). replacements: A dictionary where keys are integers and values are strings to replace multiples of those integers. Returns: A list where multiples of the keys in the replacements dict are replaced with the corresponding values. result = [] for num in range(1, n + 1): replace_str = \'\' for key in replacements: if num % key == 0: replace_str += replacements[key] if replace_str: result.append(replace_str) else: result.append(num) return result"},{"question":"# Scenario You are developing a text editor\'s autocorrect feature, which aims to prompt users with words that are almost similar to their input words, allowing up to one edit distance. To achieve this, you need to implement a function that determines if two given strings are just one edit distance apart (i.e., by inserting, deleting, or replacing exactly one character). # Task Write a function `one_edit_apart` that takes in two strings and returns whether they are one edit distance apart. # Function Signature ```python def one_edit_apart(s: str, t: str) -> bool: pass ``` # Input * `s` (a non-empty string): First string to compare, length `1 <= len(s) <= 10^4`. * `t` (a non-empty string): Second string to compare, length `1 <= len(t) <= 10^4`. # Output * Return `True` if the string `s` is one edit distance apart from `t`, otherwise return `False`. # Constraints * Only one edit is allowed (insert, delete, or replace one character). * A single recall on similar strings or different lengths beyond one character difference should return `False`. # Examples 1. `one_edit_apart(\\"abcd\\", \\"abxd\\")` should return `True` (replace \'c\' with \'x\'). 2. `one_edit_apart(\\"abc\\", \\"ab\\")` should return `True` (delete \'c\'). 3. `one_edit_apart(\\"ab\\", \\"abcd\\")` should return `False` (more than one edit). 4. `one_edit_apart(\\"\\", \\"\\")` should return `False` (no edit). # Notes * Consider all edge cases, such as both strings being empty or one being significantly longer than the other. * Aim for an efficient solution with minimal additional space usage.","solution":"def one_edit_apart(s, t): Returns whether the strings s and t are one edit distance apart. len_s, len_t = len(s), len(t) # If the length difference is more than 1, they can\'t be one edit apart if abs(len_s - len_t) > 1: return False # Make sure s is the shorter string or they are the same length. if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s found_difference = False i = j = 0 while i < len_s and j < len_t: if s[i] != t[j]: # If a difference is found and it\'s not the first one, return False if found_difference: return False found_difference = True # If lengths are different, move the pointer of the longer string if len_s != len_t: j += 1 continue i += 1 j += 1 # If we have gone through the full length of the shorter string and # no or one discrepancy was found, the strings are one edit apart. # The case where we have an extra character at the end of the longer string # is handled by this final check. return True if found_difference or len_s != len_t else False"},{"question":"# Question: n-Sum Problem Solver Problem Statement: You are given an integer `n`, a list of integers `nums`, and an integer `target`. Write a Python function `n_sum` that finds all unique n-tuples in `nums` which sum up to the `target`. Function Signature: ```python def n_sum(n: int, nums: List[int], target: int) -> List[List[int]]: pass ``` Input: - `n` (int): The size of the subsets to find (n >= 2). - `nums` (List[int]): The list of integers. - `target` (int): The target sum for the subsets. Output: - A list of lists (List[List[int]]), where each inner list contains `n` integers from `nums` that sum up to `target`. Each n-tuple should be unique, and the order of elements within the tuples and the order of tuples themselves do not matter. Constraints: 1. All numbers in `nums` are within the range ([-10^9, 10^9]). 2. The length of `nums` is at most (10^4). 3. `target` is within the range ([-10^9, 10^9]). 4. `n >= 2`. Example: ```python # Example 1 n = 3 nums = [1, 0, -1, 0, -2, 2] target = 0 # Possible output: [ # [-1, 0, 1], # [-2, 0, 2] # ] # Example 2 n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 # Possible output: [ # [-2, -1, 1, 2], # [-2, 0, 0, 2], # [-1, 0, 0, 1] # ] ``` Notes: - Ensure that the solution is efficient and handles edge cases. - Avoid using global variables. - You may use helper functions to modularize your solution.","solution":"from typing import List def n_sum(n: int, nums: List[int], target: int) -> List[List[int]]: def k_sum(nums, target, k): res = [] if not nums: return res avg_value = target // k if avg_value < nums[0] or avg_value > nums[-1]: return res if k == 2: return two_sum(nums, target) for i in range(len(nums)): if i == 0 or nums[i - 1] != nums[i]: for subset in k_sum(nums[i + 1:], target - nums[i], k - 1): res.append([nums[i]] + subset) return res def two_sum(nums, target): res = [] lo, hi = 0, len(nums) - 1 while lo < hi: curr_sum = nums[lo] + nums[hi] if curr_sum < target or (lo > 0 and nums[lo] == nums[lo - 1]): lo += 1 elif curr_sum > target or (hi < len(nums) - 1 and nums[hi] == nums[hi + 1]): hi -= 1 else: res.append([nums[lo], nums[hi]]) lo += 1 hi -= 1 return res nums.sort() return k_sum(nums, target, n)"},{"question":"# Comb Sort Implementation Challenge **Objective**: Implement a function to sort a list using the Comb Sort algorithm. # Problem Description You are given an array of integers. Your task is to write a function `custom_comb_sort` that sorts the array using the Comb Sort algorithm. The function should follow the principles of the Comb Sort as specified. # Function Signature ```python def custom_comb_sort(arr: List[int]) -> List[int]: # Your code goes here ``` # Input * A single list of integers, `arr` (1 ≤ len(arr) ≤ 10^6, -10^9 ≤ arr[i] ≤ 10^9). # Output * A sorted list of integers. # Constraints * The list may contain integers from -10^9 to 10^9. * Length of the list can be up to 1,000,000. * Time and space complexity should be considered, aim for an in-place sorting approach. # Performance Requirements * Aim to provide a solution that handles the given constraints efficiently. * The solution should not use additional data structures that exceed O(1) space complexity. # Example ```python >>> custom_comb_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] >>> custom_comb_sort([3, 0, -1, 8, -2]) [-2, -1, 0, 3, 8] ``` # Instructions 1. Implement the `custom_comb_sort` function. 2. Ensure to handle edge cases such as empty arrays or single-element arrays. 3. Write clean, efficient, and well-commented code. Good luck!","solution":"from typing import List def custom_comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): # Shrink gap by the shrink factor gap = (gap * 10) // 13 # Using the shrink factor 1.3 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Scenario You are working as a software developer in a data processing company. Your team is tasked with cleaning large datasets in the form of singly linked lists. The datasets often contain duplicate entries which must be removed to ensure data consistency for subsequent analysis. Task Implement a Python function `remove_duplicates` that removes all duplicate elements from a singly linked list using constant space complexity. # Function Signature ```python def remove_duplicates(head): Args: head (Node): The head node of a singly linked list. Returns: Node: The head node of the modified linked list with duplicates removed. pass ``` # Requirements * **Input**: * `head`: the head of the singly linked list. * **Output**: * Returns the head node of the modified linked list with duplicates removed. * **Constraints**: * Use constant space (O(1)). * Minimize time complexity as much as possible under the space constraint. * **Performance**: * Your solution must handle lists with up to 100,000 nodes efficiently within memory constraints. # Notes * You are not allowed to use any auxiliary data structures (like sets or dictionaries) that require additional space proportional to the input size. * The elements in the linked list are assumed to have a consistent and comparable data type. # Example 1. Given linked list: `1 -> 3 -> 2 -> 1 -> 2 -> 1`, the function should return: `1 -> 3 -> 2`. 2. Given linked list: `4 -> 5 -> 6 -> 6 -> 5 -> 4`, the function should return: `4 -> 5 -> 6`. # Constraints * Node values are integer numbers within the range of -10^6 to 10^6. * Duplicate values should maintain the first occurrence while removing subsequent ones.","solution":"class Node: def __init__(self, data): self.data = data self.next = None def remove_duplicates(head): if not head: return head current = head while current: runner = current while runner.next: if runner.next.data == current.data: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"You are tasked with determining if a string follows a specified pattern. The pattern consists of lowercase alphabets and represents mapping characters to non-empty substrings of the string in a bijective way (each character maps to one distinct substring and vice versa). Write a function called `pattern_match` that takes in two parameters: - `pattern` (str): A pattern represented as a string of lowercase letters. - `string` (str): The string we need to check against the pattern. Your function should return a boolean value indicating whether the string follows the given pattern. # Constraints: - Assume both `pattern` and `string` contain only lowercase letters. - `1 <= len(pattern) <= 15` - `1 <= len(string) <= 100` # Examples: ```python pattern = \\"abab\\" string = \\"redblueredblue\\" output: True pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" output: True pattern = \\"aabb\\" string = \\"xyzabcxzyabc\\" output: False ``` # Instructions: 1. Define the function `pattern_match(pattern, string)`. 2. Implement a helper function for the recursive backtracking mechanism. 3. Ensure that the solutions are efficient, considering the constraints. 4. Handle edge cases appropriately. # Note: * You may use additional helper functions or classes if necessary. * Consider explaining the recursive steps and how the backtracking mechanism ensures all possibilities are checked.","solution":"def pattern_match(pattern, string): def is_match(pattern, string, pattern_map, string_set): if not pattern: return not string char = pattern[0] if char in pattern_map: word = pattern_map[char] if not string.startswith(word): return False return is_match(pattern[1:], string[len(word):], pattern_map, string_set) for i in range(1, len(string) - len(pattern) + 2): word = string[:i] if word in string_set: continue pattern_map[char] = word string_set.add(word) if is_match(pattern[1:], string[i:], pattern_map, string_set): return True del pattern_map[char] string_set.remove(word) return False return is_match(pattern, string, {}, set())"},{"question":"**Scenario**: Imagine you are tasked with implementing a data manipulation function for a new data processing library. The function you need to implement should be able to rotate a list of data elements efficiently. **Problem Statement**: Write a function `rotate_right(head, k)` that rotates a given singly linked list to the right by `k` places. The linked list is represented by `ListNode` objects, where each node has an integer value and a reference to the next node. **Function Signature**: ```python def rotate_right(head, k): :type head: ListNode :type k: int :rtype: ListNode ``` # Input: - `head`: A ListNode object representing the head of the singly linked list. - `k`: An integer (0 <= k <= 10^9) representing the number of positions to rotate the list to the right. # Output: - Returns the head of the rotated singly linked list. # Constraints: - The number of nodes in the list is in the range [0, 500]. - The values of the nodes in the given list are integers. # Example: ```python # Given: 1->2->3->4->5->NULL and k = 2 # Output: 4->5->1->2->3->NULL ``` # Instructions: 1. Compute the length of the linked list. 2. Link the last node to the head to form a circular list. 3. Use `k % length` to handle cases where k is larger than the list length. 4. Identify the new tail and new head by traversing the list. 5. Break the circular link to form the rotated singly linked list. **Considerations**: - Handle edge cases such as an empty list, a single node list, or k being zero carefully. - Your solution should aim to minimize extra memory usage. Good luck, and happy coding!","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head, k): if not head or not head.next or k == 0: return head # Compute the length of the list length = 1 current = head while current.next: current = current.next length += 1 # Link the last node to the head to form a circular list current.next = head # Use k % length k = k % length # Find the new tail and the new head steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circular link new_tail.next = None return new_head"},{"question":"# Summarize Ranges in a Sorted Array Given a sorted integer array without duplicates, implement a function that returns the summary of its ranges. A range [i, j] where `j > i` is represented as \\"i-j\\", while a single number `k` is represented as \\"k\\". The function should return a list of strings summarizing the intervals. Input * `array`: A list of sorted integers without duplicates. Example: `[0, 1, 2, 4, 5, 7]` Output * A list of strings summarizing the contiguous ranges. Example: [\\"0-2\\", \\"4-5\\", \\"7\\"] Performance Requirements * The implementation should run in O(n) time complexity. Constraints * The given array is always sorted in ascending order. * There are no duplicate elements in the array. * The array length is between 1 and 10^4. # Function Signature ```python from typing import List def summarize_ranges(array: List[int]) -> List[str]: pass ``` # Example Example 1: ```python summarize_ranges([0, 1, 2, 4, 5, 7]) # Expected: [\'0-2\', \'4-5\', \'7\'] ``` Example 2: ```python summarize_ranges([1, 3, 4, 5, 7, 9, 10]) # Expected: [\'1\', \'3-5\', \'7\', \'9-10\'] ``` Example 3: ```python summarize_ranges([-5, -4, -3, -1, 0, 1, 3]) # Expected: [\'-5--3\', \'-1-1\', \'3\'] ``` Example 4: ```python summarize_ranges([2]) # Expected: [\'2\'] ``` Implement the function `summarize_ranges` accordingly.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] result = [] start = array[0] for i in range(1, len(array)): if array[i] != array[i - 1] + 1: if start == array[i - 1]: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{array[i - 1]}\\") start = array[i] if start == array[-1]: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{array[-1]}\\") return result"},{"question":"# Question: Implement Caesar Cipher with Enhanced Functionality Given the Caesar Cipher algorithm, improve and extend the function to handle additional cases effectively. Implement the function `enhanced_caesar_cipher(s: str, k: int) -> str` with the following requirements: 1. The function should ignore non-alphabetic characters and leave them unchanged in the output. 2. The function should consider both uppercase and lowercase letters for encryption while maintaining case integrity. 3. Support an enhanced feature where an optional third parameter `decrypt: bool` can be provided: - If `decrypt` is `True`, the function should reverse the shift, effectively decrypting the input string. - If `decrypt` is not provided or `False`, the function should encrypt the input string as usual. Input Format - `s`: A string of any length containing the text to be encrypted or decrypted. It can include letters, numbers, punctuation, and whitespace. - `k`: An integer representing the number of positions to shift each letter. - `decrypt`: An optional boolean indicating whether the function should perform decryption (default value is `False`). Output Format - Return the processed string after applying the Caesar Cipher algorithm with the specified shift and optional decryption. Example: 1. Input: `enhanced_caesar_cipher(\\"Hello, World!\\", 3)` Output: `\\"Khoor, Zruog!\\"` 2. Input: `enhanced_caesar_cipher(\\"Khoor, Zruog!\\", 3, decrypt=True)` Output: `\\"Hello, World!\\"` Note: Ensure the function is efficient and handles edge cases properly.","solution":"def enhanced_caesar_cipher(s: str, k: int, decrypt: bool = False) -> str: def shift_char(c, shift): if \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) elif \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) else: return c # If decrypt is True, we reverse the shift if decrypt: k = -k result = \'\'.join(shift_char(c, k) for c in s) return result"},{"question":"# Scenario You are working on a system to provide efficient statistical insights over user activity logs. You need to support multiple queries that can dynamically update the activity log and efficiently compute statistics like the maximum number of activities in a given time range. # Task Implement a `SegmentTree` class that supports custom statistical operations as required by the user function. Also, implement a specific function that uses this Segment Tree to process a series of queries and updates. # Function Signature ```python class SegmentTree: def __init__(self, arr, function): pass def build_tree(self): pass def update(self, p, v): pass def query(self, l, r): pass def process_activity_log(activities, func, operations): pass ``` # Input 1. `activities`: List of integers, representing activity counts in a sequence that initializes the Segment Tree. 2. `func`: A commutative function used to combine two elements during Segment Tree operations. 3. `operations`: A list of `tuples`, where each tuple is either: - (`\\"query\\"`, `l`, `r`): Request to compute the statistic over the range `[l, r]`. - (`\\"update\\"`, `index`, `new_value`): Request to update the `activity` at `index` to `new_value`. # Output A list of results from all the queries in the order they were applied. # Constraints 1. `1 <= len(activities) <= 10^5` 2. `0 <= activities[i] <= 10^6` 3. For `query` operations, `0 <= l <= r < len(activities)` 4. For `update` operations, `0 <= index < len(activities)` # Example ```python activities = [3, 2, 4, 5, 1, 1, 5] func = max operations = [(\\"query\\", 1, 5), (\\"update\\", 3, 6), (\\"query\\", 2, 6)] print(process_activity_log(activities, func, operations)) # Output: [5, 6] activities = [2, 1, 3] func = lambda a, b: a + b operations = [(\\"query\\", 0, 1), (\\"update\\", 0, 6), (\\"query\\", 0, 2)] print(process_activity_log(activities, func, operations)) # Output: [3, 10] ``` # Detailed Breakdown 1. **SegmentTree class**: - `__init__` to initialize the tree. - `build_tree` to construct the tree using the input array. - `update` to modify an element and update the tree. - `query` to compute the required statistic over a range. 2. **process_activity_log**: - Initialize a `SegmentTree` object. - Process each operation by calling `update` or `query` accordingly. - Collect and return the results of all the queries. Make sure to handle boundary conditions such as single-element ranges and making efficient use of memory. # Explanation The `process_activity_log` function should interact with the `SegmentTree` class to manage the series of range queries and updates efficiently. Consider edge cases and ensure optimal performance as per given constraints.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.func = function self.tree = [None] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = arr[i] self.build_tree() def build_tree(self): for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, idx, value): pos = idx + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l, r): l += self.n r += self.n result = None while l <= r: if l % 2 == 1: result = self.tree[l] if result is None else self.func(result, self.tree[l]) l += 1 if r % 2 == 0: result = self.tree[r] if result is None else self.func(result, self.tree[r]) r -= 1 l //= 2 r //= 2 return result def process_activity_log(activities, func, operations): seg_tree = SegmentTree(activities, func) results = [] for op in operations: if op[0] == \\"query\\": _, l, r = op results.append(seg_tree.query(l, r)) elif op[0] == \\"update\\": _, idx, value = op seg_tree.update(idx, value) return results"},{"question":"# Radix Sort Enhancement and Analysis You are tasked with enhancing the provided radix sort implementation and analyzing its performance with various datasets. Here, you need to: 1. **Improve the Function**: Modify the given radix sort function to handle potential edge cases such as empty arrays and arrays containing non-integer values gracefully. 2. **Performance Analysis**: Write additional helper functions to evaluate the performance of the algorithm. Function Implementation Requirements: - **Function 1**: `enhanced_radix_sort(arr: List[int]) -> List[int]` - **Input**: A list of integers. - **Output**: Sorted list of integers. - **Constraints**: Must handle empty arrays and non-integer data by raising appropriate exceptions. - **Function 2**: `measure_performance(arr: List[int]) -> Tuple[float, List[int]]` - **Input**: A list of integers. - **Output**: A tuple containing the execution time in seconds and the sorted list of integers. Additional Requirements: - The context assumes data sets with a significant number of random and varying size arrays. Your implementations should efficiently handle these scenarios. - Provide a brief summary of the performance trends observed during your measurements. Example: ```python try: result = enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) print(result) # Output: [2, 24, 45, 66, 75, 90, 170, 802] except ValueError as e: print(e) time, sorted_arr = measure_performance([170, 45, 75, 90, 802, 24, 2, 66]) print(f\\"Sorted Array: {sorted_arr}, Time Taken: {time:.6f} seconds\\") ``` Provide your implementations and performance results below.","solution":"from typing import List, Tuple import time def enhanced_radix_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the radix sort algorithm. Raises ValueError for empty lists and lists containing non-integer values. if not arr: raise ValueError(\\"Input array is empty\\") if any(not isinstance(x, int) for x in arr): raise ValueError(\\"All elements in the input list must be integers\\") def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] max_val = max(arr) exp = 1 while max_val // exp > 0: counting_sort(arr, exp) exp *= 10 return arr def measure_performance(arr: List[int]) -> Tuple[float, List[int]]: Measures the execution time of enhanced_radix_sort on the given list of integers. Returns a tuple of execution time in seconds and the sorted list of integers. start_time = time.time() result = enhanced_radix_sort(arr) end_time = time.time() return (end_time - start_time, result)"},{"question":"You are given a collection of integers that might contain duplicates (`nums`). Your task is to write a function `unique_subsets(nums)` that returns all possible unique subsets. A subset is defined as any selection of elements from the given list, including the empty subset and the list itself. The solution set must not contain duplicate subsets. # Function Signature ```python def unique_subsets(nums: List[int]) -> List[List[int]]: ``` # Input * `nums`: A list of integers. The list may contain duplicates. Length is at most 10. # Output * A list of lists, where each list is a unique subset of the input list `nums`. # Constraints * Your solution must avoid producing duplicate subsets. * The solution should handle cases where the input list is empty. # Scenario Consider you are working on a feature in a recommendation system where you need to generate all possible unique subsets of a user\'s past interactions to understand potential interests and preferences. Your function will help in generating all possible combinations of past interactions without any repetitions. # Examples 1. Input: `nums = [1, 2, 2]` Output: `[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]` 2. Input: `nums = [0]` Output: `[[], [0]]` 3. Input: `nums = []` Output: `[[]]` **Note**: The order of the subsets in the output list does not matter. # Additional Requirements * Your function should have a time complexity of O(2^n) due to the nature of the problem. * Make sure you handle duplicate subsets by using appropriate data structures.","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Generates unique subsets of the given list of integers, including subsets with duplicates. nums.sort() result = [] subset = [] def backtrack(start): result.append(subset[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue subset.append(nums[i]) backtrack(i + 1) subset.pop() backtrack(0) return result"},{"question":"As a financial analyst, you are tasked with selecting projects from a list to maximize the total profit within a given budget. Each project has a specific cost and expected profit. You need to write a function that selects the projects to maximize the profit without exceeding the budget. # Function Signature ```python def select_projects(projects: List[Tuple[int, int]], budget: int) -> int: Calculate the maximum profit that can be achieved within the given budget. :param projects: A list of tuples where each tuple represents a project (profit, cost). :param budget: An integer representing the total budget available for projects. :return: The maximum profit that can be achieved within the given budget. ``` # Input - `projects`: List of tuples, where each tuple is of the form (profit, cost). - `profit`: An integer representing the profit of the project. - `cost`: An integer representing the cost of the project. - `budget`: An integer representing the maximum budget. # Output - Return an integer representing the maximum profit achievable within the given budget. # Constraints - 1 <= len(projects) <= 100 - 1 <= profit, cost, budget <= 10^3 # Example ```python projects = [(60, 5), (50, 3), (70, 4), (30, 2)] budget = 5 # Maximum profit: 80 (projects with profit 50 and 30 can be included) assert select_projects(projects, budget) == 80 ``` # Notes - Edge cases such as a budget of 0 or projects with higher costs than the budget should be handled appropriately. - You are expected to use the dynamic programming approach demonstrated in the provided code snippet.","solution":"from typing import List, Tuple def select_projects(projects: List[Tuple[int, int]], budget: int) -> int: Calculate the maximum profit that can be achieved within the given budget. :param projects: A list of tuples where each tuple represents a project (profit, cost). :param budget: An integer representing the total budget available for projects. :return: The maximum profit that can be achieved within the given budget. dp = [0] * (budget + 1) for profit, cost in projects: for j in range(budget, cost - 1, -1): dp[j] = max(dp[j], dp[j - cost] + profit) return dp[budget]"},{"question":"Scenario You are tasked with enhancing a user engagement system to track the longest engagement streak of users within a given hierarchy of tasks. You will represent this hierarchy with a binary tree and will measure the longest sequence of consecutive tasks completed. Task Write a function `longest_consecutive(root)` that takes the root of a binary tree and returns the length of the longest consecutive sequence path. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path needs to be from parent to child, and each step must increase the node value by 1. # Input and Output Format * **Input**: The function will receive a `TreeNode` object representing the root of the binary tree. * **TreeNode Class Definition**: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` * **Output**: Return an integer, which is the length of the longest consecutive sequence path. # Constraints * Tree nodes will have integer values. * The function should consider edge cases like empty trees, single-node trees, and trees with no consecutive sequences. # Example ```python # Example Input Tree # 1 # # 3 # / # 2 4 # # 5 root = TreeNode(1) root.right = TreeNode(3) root.right.left = TreeNode(2) root.right.right = TreeNode(4) root.right.right.right = TreeNode(5) print(longest_consecutive(root)) # Output: 3 (Sequence: 3-4-5) ``` *Note*: In this example, the longest consecutive path is 3 -> 4 -> 5, hence the function should return 3. Guidelines 1. You may assume that all the node values are unique. 2. The length of the consecutive sequence should be counted based on the number of nodes in the sequence, not the difference in values. 3. You must handle empty nodes (i.e., `None`).","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longest_consecutive(root): Returns the length of the longest consecutive sequence path in the binary tree. if not root: return 0 def helper(node, parent_val, length): if not node: return length if node.val == parent_val + 1: length += 1 else: length = 1 left_length = helper(node.left, node.val, length) right_length = helper(node.right, node.val, length) return max(length, left_length, right_length) return helper(root, root.val - 1, 0)"},{"question":"# Zigzag Iterator Implementation You are given two lists of integers, `v1` and `v2`. Write a `ZigzagIterator` class to iterate through these lists in a zigzag manner, i.e., alternating between elements from `v1` and `v2`. # Example: Given: * `v1 = [1, 2]` * `v2 = [3, 4, 5, 6]` The zigzag order would be: `1, 3, 2, 4, 5, 6`. Your `ZigzagIterator` class should support the following methods: - `__init__(self, v1: List[int], v2: List[int])`: Initializes the iterator with two lists. - `next(self) -> int`: Returns the next element in the zigzag order. - `has_next(self) -> bool`: Returns `True` if there are more elements in the iterator, `False` otherwise. # Implementation Constraints 1. `v1` and `v2` will have lengths between 0 and 1000. 2. Elements in `v1` and `v2` will be non-negative integers. 3. You may assume that all integers fit within the 32-bit signed integer range. # Input and Output: Input: - Two lists `v1` and `v2`. Output: - The next element in the zigzag order when `next` is called. - A boolean value from `has_next` indicating the presence of additional elements. # Example Usage: ```python v1 = [1, 2] v2 = [3, 4, 5, 6] it = ZigzagIterator(v1, v2) results = [] while it.has_next(): results.append(it.next()) print(results) # should output [1, 3, 2, 4, 5, 6] ``` # Performance Requirements Make sure your implementation is efficient in terms of both time and space. The iterator should be able to handle the maximum constraints smoothly.","solution":"class ZigzagIterator: def __init__(self, v1, v2): self.v1 = v1 self.v2 = v2 self.index1 = 0 self.index2 = 0 self.turn = 0 # 0 for v1\'s turn, 1 for v2\'s turn def next(self): if not self.has_next(): raise StopIteration # Determine whose turn it is, and fetch the element accordingly. if (self.turn == 0 and self.index1 < len(self.v1)) or self.index2 >= len(self.v2): result = self.v1[self.index1] self.index1 += 1 self.turn = 1 # Switch to v2 else: result = self.v2[self.index2] self.index2 += 1 self.turn = 0 # Switch to v1 return result def has_next(self): return self.index1 < len(self.v1) or self.index2 < len(self.v2)"},{"question":"# Question Scenario In a contest of competitive coding, you\'re tasked with helping a team develop an efficient function to solve a classic problem: the Two Sum Problem. This problem involves finding two numbers in an array that add up to a given target sum. You are to design this function with constraints ensuring it solves the problem efficiently for large datasets. Problem Statement Write a function `two_sum(array, target)` that takes an array of integers `array` and an integer `target`. Your function should return a tuple of two indices of the array elements such that the elements at those indices add up to `target`. It is guaranteed that there is exactly one solution in each input. You are not allowed to use the same element twice. Input - `array` (List[int]): A list of integers with length n (2 <= n <= 10^4). - `target` (int): An integer target sum (-10^9 <= target <= 10^9). Output - Returns a tuple of two integers representing the indices of the elements in the array that sum to the target. The indices should be returned in ascending order. - If no solution exists, return None (though this scenario will not occur per problem guarantees). Constraints - The input array will contain at least two integers. - Each input array will have exactly one solution. - You must not use the same element of the array twice. Example ```python array = [2, 7, 11, 15] target = 9 print(two_sum(array, target)) # Output: (0, 1) ``` Performance Requirements - Time Complexity: O(n) - Space Complexity: O(n)","solution":"def two_sum(array, target): Finds two indices of elements in `array` that add up to `target`. Args: array (List[int]): The list of integers. target (int): The target sum. Returns: Tuple[int, int]: A tuple containing the indices of the two elements that add up to `target`. num_to_index = {} for index, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None # This will never be reached due to constraint guarantees."},{"question":"In this problem, you need to implement a more efficient and optimized variation of Comb Sort. The goal is to understand the fundamental concepts of the Comb Sort and apply them to solve the following problem. # Task Write a function named `optimized_comb_sort(arr)` that sorts an array of integers `arr` in non-decreasing order using an optimized version of the Comb Sort algorithm. # Input Format - A list of integers `arr`. # Output Format - A list of integers sorted in non-decreasing order. # Constraints - The input array size, `arr.length`, is constrained to (1 leq |arr| leq 10^6). - The values of array elements, `arr[i]`, range from (-10^6 leq arr[i] leq 10^6). # Performance Requirements - Time Complexity: Should aim for an average case of O(N log N). - Space Complexity: O(1) as it must sort the list in-place. # Implementation Tip - Consider experimenting with different shrink factors and gap sequences. - Ensure the algorithm handles edge cases, such as empty arrays and arrays with all identical elements. # Example ```python assert optimized_comb_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert optimized_comb_sort([10, 7, 3, -1]) == [-1, 3, 7, 10] assert optimized_comb_sort([]) == [] assert optimized_comb_sort([1]) == [1] assert optimized_comb_sort([2, 1, 3, 2]) == [1, 2, 2, 3] ``` Provide your solution below: ```python def optimized_comb_sort(arr): # Write your optimized Comb Sort solution here pass ```","solution":"def optimized_comb_sort(arr): Sorts an array of integers in non-decreasing order using Comb Sort. n = len(arr) gap = n shrink_factor = 1.3 sorted = False while not sorted: # Update the gap for the next comb gap = int(gap / shrink_factor) if gap <= 1: gap = 1 sorted = True # If there\'s no more gap to shrink, we assume the array is sorted # Perform the combing with the current gap i = 0 while i + gap < n: if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False # If we make a swap, the array wasn\'t sorted i += 1 return arr"},{"question":"# Path Splitter Function Implementation Scenario You are developing a utility for a web server that needs to manage resource paths efficiently. One common task is to split given resource paths into their directory and resource components. Develop a function that accomplishes this efficiently, ensuring it handles various edge cases correctly. Task Write a function `split_path(path: str) -> list` that takes a single string argument representing a URL or file path and returns a list with two elements: 1. The directory part of the path. 2. The last file or directory component of the path. **Input Format**: * A single string `path` containing the URL or file path. * The string will always use forward slashes (`\'/\'`) as separators. **Output Format**: * A list of two strings. **Constraints**: * The input path will have a maximum length of 10,000 characters. * Handle the following edge cases: * When there are no slashes in the path. * When the path is empty. * When the path consists entirely of slashes. **Performance Requirements**: * The solution should fit within the time complexity of O(n) and space complexity of O(n), where n is the length of the input string. Examples Example 1: ``` Input: \'https://example.com/resource\' Output: [\'https://example.com\', \'resource\'] ``` Example 2: ``` Input: \'folder/subfolder/file.txt\' Output: [\'folder/subfolder\', \'file.txt\'] ``` Example 3: ``` Input: \'file\' Output: [\'\', \'file\'] ``` Example 4: ``` Input: \'/\' Output: [\'\', \'\'] ``` Example 5: ``` Input: \'\' Output: [\'\', \'\'] ``` Function Signature ```python def split_path(path: str) -> list: pass ```","solution":"def split_path(path: str) -> list: Splits the given path into directory and resource components. Parameters: - path (str): The URL or file path to split. Returns: - list: A list containing the directory and the last file or directory component. if path == \\"\\": return [\\"\\", \\"\\"] if path == \\"/\\": return [\\"\\", \\"\\"] last_slash_index = path.rfind(\'/\') if last_slash_index == -1: return [\\"\\", path] directory = path[:last_slash_index] resource = path[last_slash_index + 1:] return [directory, resource]"},{"question":"You are given a string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and you need to determine if the string is a well-formed bracket expression. A string is considered valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. Your task is to implement a function `is_valid_expression` that takes a string input and returns a boolean indicating whether the string is a valid bracket expression. # Input Format: * A single string `s` containing the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. # Output Format: * A single boolean value: `True` if the string is valid; otherwise, `False`. # Constraints: * The input string will have a maximum length of 10^4 characters. # Examples: ```python is_valid_expression(\\"()\\") # Should return True is_valid_expression(\\"()[]{}\\") # Should return True is_valid_expression(\\"(]\\") # Should return False is_valid_expression(\\"([)]\\") # Should return False is_valid_expression(\\"{[]}\\") # Should return True ``` # Additional Tests: * Test with empty string `is_valid_expression(\\"\\")` should return `True`. * Test with non-matching pairs `is_valid_expression(\\"([[)\\")` should return `False`. * Test with nested matching pairs `is_valid_expression(\\"{[()]}\\")` should return `True`. Implement the function `is_valid_expression(s: str) -> bool`: ```python def is_valid_expression(s: str) -> bool: # Your implementation here pass ```","solution":"def is_valid_expression(s: str) -> bool: Returns True if the input string is a valid bracket expression, otherwise False. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Question: You are given an undirected graph represented by an adjacency list and the number of nodes. Your task is to write a Python function `count_connected_components(nodes, edges)` that takes in the number of nodes and a list of edges and returns the number of connected components in the graph. Function Signature: ```python def count_connected_components(nodes: int, edges: List[Tuple[int, int]]) -> int: ``` Input: * `nodes` (int): The number of nodes in the graph. * `edges` (List[Tuple[int, int]]): A list of tuples where each tuple represents an edge between two nodes (1 <= nodes <= 10^5). Output: * Return the number of connected components in the graph. Constraints: * Nodes are labeled from 1 to `nodes`. * `0 <= nodes <= 100000`. * `0 <= len(edges) <= 200000`. Example: ```python assert count_connected_components(7, [(1, 2), (2, 4), (2, 6), (4, 5), (3, 7)]) == 2 assert count_connected_components(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 1 assert count_connected_components(5, []) == 5 assert count_connected_components(0, []) == 0 ``` Description: 1. **Graph Representation**: Create an adjacency list from the given edges. 2. **Traversal and Counting**: Using DFS, traverse the graph to count and return the number of connected components. 3. **Edge Handling**: Ensure to handle cases with no edges and isolated nodes properly. Hints: * Initialize an adjacency list for the graph. * Use a visited array to keep track of visited nodes during DFS traversal. * Loop through each node and initiate a DFS when an unvisited node is found, incrementing the count of components.","solution":"from typing import List, Tuple def count_connected_components(nodes: int, edges: List[Tuple[int, int]]) -> int: if nodes == 0: return 0 # Create adjacency list adj_list = {i: [] for i in range(1, nodes + 1)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (nodes + 1) # To keep track of visited nodes def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) connected_components = 0 # Count connected components using DFS for node in range(1, nodes + 1): if not visited[node]: connected_components += 1 visited[node] = True dfs(node) return connected_components"},{"question":"Sorting Colors **Scenario**: You are given an array containing `n` integers, representing `n` objects colored red, white, or blue. You need to sort these objects in-place so that the objects of the same color are adjacent, with the colors ordered as red, white, and blue. Here, we use the integers `0`, `1`, and `2` to represent the colors red, white, and blue, respectively. As a skilled programmer, you are asked to accomplish this without using the library\'s sort function. **Input and Output Formats**: * **Input**: A list of integers `nums` where each integer is either `0`, `1`, or `2`. * **Output**: The same list `nums`, but sorted in-place such that all `0`s come first, followed by all `1`s, and all `2`s at the end. **Constraints**: * The input list will have a length between `0` and `10^5`. * Each element in the input list is guaranteed to be either `0`, `1`, or `2`. **Performance Requirements**: * The algorithm should run in linear time, O(n). * The sorting should be done in-place, using constant space, O(1). **Example**: ```python Input: nums = [2, 0, 2, 1, 1, 0] Output: nums = [0, 0, 1, 1, 2, 2] ``` **Coding Task**: Implement the function `sort_colors(nums)` that sorts the given list as described. ```python def sort_colors(nums): # Your implementation goes here pass # Example usage if __name__ == \\"__main__\\": nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output should be [0, 0, 1, 1, 2, 2] ``` **Notes**: * You should not use built-in sort functions. * Ensure to test the implementation with edge cases and larger input sizes to verify its efficiency.","solution":"def sort_colors(nums): Sorts the list nums in-place such that all 0s come first, followed by all 1s, and all 2s at the end. Uses the Dutch National Flag algorithm to achieve this in O(n) time and O(1) space. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Question You are given a non-negative integer represented as a non-empty array of digits. Write a function `increment_digits` that increments the number by one. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. Input Format: * An array of integers `digits` where each digit ranges from 0 to 9. Output Format: * An array of integers representing the incremented number. Constraints: * The given array is non-empty and contains only non-negative digits. * The array does not contain leading zeros except when the number itself is 0. Performance Requirements: * The function should have a time complexity of O(n). * The space complexity should be O(1), aside from the input and output array itself. # Example ```python # Example 1 Input: digits = [1, 2, 3] Output: [1, 2, 4] Explanation: Incrementing 123 by one gives 124. # Example 2 Input: digits = [9, 9, 9] Output: [1, 0, 0, 0] Explanation: Incrementing 999 by one gives 1000. ``` Function Signature ```python def increment_digits(digits): pass ``` Implement the `increment_digits` function according to the described requirements.","solution":"def increment_digits(digits): Increment the number represented by the list of digits by one. :param digits: List[int] -- a list of non-negative integers where each integer is a digit (0-9) :return: List[int] -- a list representing the incremented number n = len(digits) for i in range(n-1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If we are here, all the digits were 9 return [1] + [0] * n"},{"question":"# Maximum Flow Network Optimization Challenge Context: A telecommunications company needs to route data between their headquarters (source) and a remote data center (sink) through multiple intermediate relay stations. Due to varying bandwidth capacities between these stations, your task is to determine the maximum possible data flow rate from the headquarters to the data center. Problem Description: You are provided with an (n times n) adjacency matrix representing a weighted directed graph. Each element in the matrix describes the bandwidth capacity between stations. Your objective is to compute the maximum flow from the source (node 0) to the sink (node (n-1)) using the Depth-First Search enhanced Ford-Fulkerson method. Function Signature ```python def maximum_flow_dfs(adjacency_matrix: List[List[int]]) -> int: pass ``` Input: * `adjacency_matrix`: A 2D list of integers representing the bandwidth capacities between stations. * (n times n) matrix. * (0 leq text{adjacency_matrix}[i][j] leq 1000) * (0 < n leq 100) Output: * Return the integer value representing the maximum possible flow from source to sink. Constraints: * The graph does not contain self-loops, i.e., `adjacency_matrix[i][i] = 0` * All the capacities are non-negative integers. Example: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_flow_dfs(graph) == 23 ``` Task: Complete the function `maximum_flow_dfs` to determine the maximum data flow rate possible from source to sink given the constraints.","solution":"from typing import List def maximum_flow_dfs(adjacency_matrix: List[List[int]]) -> int: def dfs_flow(u, t, flow): visited[u] = True if u == t: return flow for v in range(len(adjacency_matrix)): capacity = adjacency_matrix[u][v] if not visited[v] and capacity > 0: min_flow = min(flow, capacity) result = dfs_flow(v, t, min_flow) if result > 0: adjacency_matrix[u][v] -= result adjacency_matrix[v][u] += result return result return 0 source, sink = 0, len(adjacency_matrix) - 1 total_flow = 0 while True: visited = [False] * len(adjacency_matrix) flow = dfs_flow(source, sink, float(\'Inf\')) if flow == 0: break total_flow += flow return total_flow"},{"question":"Implement a **Min Binary Heap** with detailed methods for insertion and removal of the minimum element. You are to implement the missing methods in the `BinaryHeap` class that manages a collection of integers to ensure it maintains the heap property. # Requirements 1. **Method 1: `insert(val: int) -> None`** - Inserts an integer `val` into the heap. - Should maintain the heap property after insertion. 2. **Method 2: `remove_min() -> int`** - Removes and returns the minimum element from the heap. - Should maintain the heap property after removal. 3. **Method 3: `perc_up(i: int) -> None`** - Moves the node at index `i` up to maintain the heap property. 4. **Method 4: `perc_down(i: int) -> None`** - Moves the node at index `i` down to maintain the heap property. 5. **Method 5: `min_child(i: int) -> int`** - Returns the index of the smaller child of the node at index `i`. # Input & Output Format - **insert** - **Input**: An integer `val`. - **Output**: None. - **remove_min** - **Output**: The minimum integer from the heap. # Constraints - The heap is implemented using a list. - The methods should work efficiently within the mentioned complexities. # Example ```python heap = BinaryHeap() heap.insert(10) heap.insert(4) heap.insert(15) heap.insert(2) print(heap.remove_min()) # Output: 2 print(heap.remove_min()) # Output: 4 print(heap.remove_min()) # Output: 10 print(heap.remove_min()) # Output: 15 ``` # Note Your implementation should handle edge cases such as inserting into an empty heap and removing from a heap with a single element. Additionally, ensure the `perc_up` and `perc_down` methods are optimally implemented to maintain the heap\'s structural integrity after insertions and removals.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] # Initialize with a placeholder to facilitate integer division def insert(self, val: int) -> None: self.heap.append(val) self.perc_up(len(self.heap) - 1) def remove_min(self) -> int: if len(self.heap) == 1: raise IndexError(\\"remove_min() called on empty heap\\") min_val = self.heap[1] self.heap[1] = self.heap[-1] self.heap.pop() if len(self.heap) > 1: self.perc_down(1) return min_val def perc_up(self, i: int) -> None: while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def perc_down(self, i: int) -> None: while (i * 2) <= len(self.heap) - 1: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def min_child(self, i: int) -> int: if (i * 2 + 1) > len(self.heap) - 1: return i * 2 if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 return i * 2 + 1"},{"question":"**Scenario**: You have been hired by a software company that specializes in combinatorial design tools. One of the common features in their applications is generating all possible subsets from a given set of distinct integers. You are tasked with designing this feature to be efficient and robust. **Task**: Implement a function `generate_subsets(nums)` that takes a list of distinct integers `nums` and returns all possible subsets of the given set. The result must not contain duplicate subsets and the subsets can be in any order. **Input**: * `nums` : List[int] - a list of distinct integers (1 <= len(nums) <= 20). **Output**: * List[List[int]] - a list containing all possible subsets of `nums`. **Constraints**: * The solution should be efficient enough to handle the upper limit of `nums` length within a reasonable time. **Examples**: 1. Input: `nums = [1, 2, 3]` Output: `[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]` 2. Input: `nums = [4, 5]` Output: `[[], [4], [5], [4, 5]]` 3. Input: `nums = []` Output: `[[]]` **Performance Requirements**: * The solution should ideally use O(n * 2^n) time complexity. * Space complexity should be managed efficiently. **Additional Notes**: * The order of subsets in the output does not matter. * An empty set `[]` should be included in the output as a valid subset.","solution":"def generate_subsets(nums): Returns all possible subsets of a given set of distinct integers. :param nums: List[int] - a list of distinct integers :return: List[List[int]] - a list containing all possible subsets of nums subsets = [[]] for num in nums: subsets += [current + [num] for current in subsets] return subsets"},{"question":"You are given a Red-Black Tree (RBT) class that implements several essential operations (insertion, deletion, rotation). Your task is to implement additional functionality to enhance the usability of this data structure: the `find_kth_smallest` function. Function Specification: Implement the function `find_kth_smallest(self, k)` within the `RBTree` class. # Function signature: ```python def find_kth_smallest(self, k: int) -> int: ``` # Input: - An integer `k` representing the k-th smallest element in the Red-Black Tree. # Output: - An integer which is the k-th smallest element in the Red-Black Tree. # Constraints: - `1 <= k <= n` where `n` is the number of elements in the Red-Black Tree. - The tree can contain any integer values. # Example: Given the tree with elements inserted as: 11, 2, 14, 1, 7, 15, 5, 8, 4 - **Find 3rd Smallest Element**: Should return 4 - **Find 5th Smallest Element**: Should return 7 # Additional Information: This function should efficiently traverse the tree to find the kth smallest element. You should not attempt to sort the entire tree. # Implementation Tips: 1. Perform an in-order traversal to visit nodes in ascending order. 2. Keep track of the nodes visited to determine the k-th smallest. 3. Use helper functions if necessary to break down the task.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None self.parent = None self.color = 1 # 1 represents Red, 0 represents Black class RBTree: def __init__(self): self.TNULL = Node(0) # Sentinel node, representing NIL self.TNULL.color = 0 self.root = self.TNULL # Function to do inorder traversal def inorder_helper(self, node, result): if node != self.TNULL: self.inorder_helper(node.left, result) result.append(node.data) self.inorder_helper(node.right, result) # Function to implement finding k-th smallest def find_kth_smallest(self, k: int) -> int: def in_order_kth(node): if node == self.TNULL: return [] # recur on the left subtree left = in_order_kth(node.left) # if k elements are found in the left subtree, return the left subtree result if len(left) >= k: return left # current node if len(left) + 1 == k: return left + [node.data] # recur on the right subtree right = in_order_kth(node.right) return left + [node.data] + right result = in_order_kth(self.root) if len(result) < k: return -1 # handle k being larger than the number of elements return result[k-1] # Helper function to add a node to the Red-Black tree def insert(self, key): # Ordinary Binary Search Insertion node = Node(key) node.parent = None node.data = key node.left = self.TNULL node.right = self.TNULL node.color = 1 # New node must be red y = None x = self.root while x != self.TNULL: y = x if node.data < x.data: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.data < y.data: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.fix_insert(node) # Fix after insertion def fix_insert(self, k): pass # Assume the fix_insert method is correctly implemented # Note: Other methods of the RBTree like deletion, rotations are assumed to be implemented"},{"question":"# Matrix Transformation Challenge As part of a software that processes images, you need to implement various matrix transformations. You are provided with a 2D matrix where each element represents a pixel\'s value. Write a function that performs a specified matrix transformation. Function Signature ```python def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: \'\'\' Transforms the input matrix based on the operation specified. Parameters: matrix (List[List[int]]): A 2D list of integers representing the matrix. operation (str): A string specifying the transformation. It can be one of the following: - \\"rotate_clockwise\\": Rotate the matrix 90 degrees clockwise. - \\"rotate_counterclockwise\\": Rotate the matrix 90 degrees counter-clockwise. - \\"top_left_invert\\": Reflect the matrix along the diagonal from top-left to bottom-right. - \\"bottom_left_invert\\": Reflect the matrix along the diagonal from bottom-left to top-right. Returns: List[List[int]]: A new 2D list representing the transformed matrix. \'\'\' ``` Input * `matrix`: A 2D list of integers with size `n x m` (0 ≤ n, m ≤ 100). * `operation`: A string specifying the matrix operation (`\\"rotate_clockwise\\"`, `\\"rotate_counterclockwise\\"`, `\\"top_left_invert\\"`, `\\"bottom_left_invert\\"`). Output * Returns a new 2D list of integers representing the transformed matrix. Constraints 1. The input matrix can have dimensions of any size, including non-square matrices. 2. If `matrix` is empty or the operation is invalid, return an empty list. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(transform_matrix(matrix, \\"rotate_clockwise\\")) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(transform_matrix(matrix, \\"rotate_counterclockwise\\")) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(transform_matrix(matrix, \\"top_left_invert\\")) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(transform_matrix(matrix, \\"bottom_left_invert\\")) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ```","solution":"def transform_matrix(matrix, operation): def rotate_clockwise(matrix): return [list(reversed(col)) for col in zip(*matrix)] def rotate_counterclockwise(matrix): return list(reversed([list(col) for col in zip(*matrix)])) def top_left_invert(matrix): return [list(row) for row in zip(*matrix)] def bottom_left_invert(matrix): return [list(row)[::-1] for row in zip(*matrix)][::-1] if not matrix or not isinstance(matrix, list): return [] operation_to_func = { \\"rotate_clockwise\\": rotate_clockwise, \\"rotate_counterclockwise\\": rotate_counterclockwise, \\"top_left_invert\\": top_left_invert, \\"bottom_left_invert\\": bottom_left_invert, } if operation not in operation_to_func: return [] return operation_to_func[operation](matrix)"},{"question":"# Context: In network protocols, determining the maximum level of nested packets can give insights into protocol efficiency and potential bottlenecks. Suppose you need to design a function that calculates the maximum depth of nested packets represented in a binary tree where each node represents a packet. # Problem: Given a binary tree, implement a function to find its maximum depth. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. # Function Signature: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: pass ``` # Input: - `root` (TreeNode): The root node of the binary tree. It can be `None` (representing an empty tree). # Output: - `int`: The maximum depth of the tree. # Constraints: - The number of nodes in the tree is in the range `[0, 10^4]`. - Node values are arbitrary and do not affect the depth calculation. # Example: ```python # Example 1: # Input: root = [3, 9, 20, None, None, 15, 7] # The binary tree: # 3 # / # 9 20 # / # 15 7 # Output: 3 # Example 2: # Input: root = [] # Output: 0 # Example 3: # Input: root = [1, None, 2] # The binary tree: # 1 # # 2 # Output: 2 ``` # Notes: - Your implementation should handle edge cases such as empty tree and single node tree effectively. - Aim to optimize for both time and space complexity where possible. - You are encouraged to write tests to verify your function against edge cases and large inputs.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"**Scenario**: You are designing a digital display system where certain numbers should maintain their appearance when viewed upside down. Your task is to validate such numbers, known as strobogrammatic numbers, ensuring they retain their visual representation under a 180-degree rotation. **Problem Statement**: You need to determine whether a given number (represented as a string) is strobogrammatic. A strobogrammatic number is one that looks the same when rotated 180 degrees. For example, \\"69\\", \\"88\\", and \\"818\\" are strobogrammatic, while \\"962\\" and \\"123\\" are not. **Function Definition**: Implement the function `is_strobogrammatic(num: str) -> bool`. **Inputs**: - `num`: a string representing the number to be checked. `1 <= len(num) <= 10^4`. **Outputs**: - `True` if the number is strobogrammatic, `False` otherwise. **Constraints**: - The input string `num` will only contain numeric characters. **Example**: ```python assert is_strobogrammatic(\\"69\\") == True assert is_strobogrammatic(\\"88\\") == True assert is_strobogrammatic(\\"962\\") == False assert is_strobogrammatic(\\"818\\") == True assert is_strobogrammatic(\\"1\\") == True assert is_strobogrammatic(\\"2\\") == False ``` **Guidelines**: 1. Ensure that the function passes all provided test cases. 2. Optimize for both time and space complexity. 3. Consider additional edge cases such as very long strings and strings with minimal length. 4. Do not assume any characters outside the numeric range (0-9) are included.","solution":"def is_strobogrammatic(num: str) -> bool: Checks if a given number (represented as a string) is strobogrammatic, i.e., it looks the same when rotated 180 degrees. # Mapping of strobogrammatic digit pairs strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_pairs or num[right] not in strobogrammatic_pairs: return False if strobogrammatic_pairs[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"# Scenario You are part of a robot programming team. Your robot can only take 1-step or 2-step moves to climb stairs. You need to program the robot\'s movement to efficiently find out all possible distinct ways to reach a given number of stairs, given it always starts from the ground (step 0). # Problem Statement Design a function `robot_climb_stairs` that calculates the number of distinct ways the robot can reach the top of a staircase with `n` steps. The robot can take either 1 or 2 steps at each move. # Function Signature ```python def robot_climb_stairs(n: int) -> int: :param n: An integer representing the number of steps. :return: An integer representing the number of distinct ways to reach the top. ``` # Input - `n`: a positive integer (1 <= n <= 10^5) representing the total number of steps. # Output - An integer representing the number of distinct ways to reach the nth step. # Constraints - The solution must run in O(n) time complexity. - The solution must run in O(1) space complexity. # Examples ```python assert robot_climb_stairs(2) == 2 # Explanation: Two ways -> (1 step + 1 step) or (2 steps) assert robot_climb_stairs(3) == 3 # Explanation: Three ways -> (1+1+1), (1+2), or (2+1) assert robot_climb_stairs(5) == 8 # Explanation: Eight ways as per the Fibonacci sequence shifted by one ``` # Notes Consider that `n` will be a positive integer always (no need to handle zero or negative steps scenarios). The robot should always be able to climb to the top given these constraints.","solution":"def robot_climb_stairs(n: int) -> int: Returns the number of distinct ways the robot can climb to the nth step, where it can take either 1-step or 2-step moves. if n <= 0: return 0 elif n == 1: return 1 elif n == 2: return 2 first, second = 1, 2 for _ in range(3, n + 1): first, second = second, first + second return second"},{"question":"You are given a sequence of integers starting from 1, concatenated together (e.g., \\"123456789101112...\\"). Write a Python function to find the nth digit in this infinite numerical sequence. # Input Format - An integer `n` representing the position in the numerical sequence (1-based index). # Output Format - An integer representing the nth digit in the sequence. # Constraints - (1 leq n leq 10^9) # Examples 1. Input: `3` Output: `3` 2. Input: `11` Output: `0` (in \\"12345678910\\", the 11th digit is 0) # Function Signature ```python def find_nth_digit(n): pass ``` # Requirements 1. Your solution should handle inputs efficiently, up to the maximum constraint. 2. The function should return the correct digit for all valid inputs within the constraints. # Notes - Be mindful of possible edge cases such as positions at the boundaries of the numerical lengths (e.g., transitioning from 9 to 10). - Avoid floating-point arithmetic for index calculations to maintain precision.","solution":"def find_nth_digit(n): Returns the nth digit in the infinite sequence of concatenated integers starting from 1. digit_length = 1 count = 9 start = 1 while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 number = start + (n - 1) // digit_length digit_index = (n - 1) % digit_length return int(str(number)[digit_index])"},{"question":"As a new software engineer, you have been tasked to implement a numerical algorithm that can decompose any given n x n matrix into its lower and upper triangular components using Crout\'s method. This decomposition helps in solving linear systems efficiently. # Problem Statement Write a function `crout_matrix_decomposition` that takes a square matrix ( A ) as input and returns two matrices ( L ) and ( U ). The matrix ( L ) is a lower triangular matrix and the matrix ( U ) is an upper triangular matrix such that ( A = L times U ). # Function Signature ```python def crout_matrix_decomposition(A): pass ``` # Input - ( A ): A list of lists of floats representing an ( n times n ) matrix, where ( 1 leq n leq 100 ). # Output - Tuple: A tuple containing two ( n times n ) matrices ( L ) and ( U ). # Constraints - The matrix ( A ) will always be a square matrix. - Elements of ( A ) will be floating point numbers. - Assume that ( A ) is non-singular. # Examples Example 1: Input: ```python A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] ``` Output: ```python L = [ [1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0] ] U = [ [1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0] ] ``` Example 2: Input: ```python A = [ [4, 3], [6, 3] ] ``` Output: ```python L = [ [4.0, 0.0], [6.0, -1.5] ] U = [ [1.0, 0.75], [0.0, 1.0] ] ``` # Notes - Ensure your implementation avoids division by zero by handling zero entries in the diagonal of ( L ). - You may assume that the input matrix ( A ) will not lead to singular ( L ) or ( U ).","solution":"def crout_matrix_decomposition(A): Decomposes a given square matrix A into lower (L) and upper (U) triangular matrices using Crout\'s method such that A = L * U. Parameters: A (list of list of floats): An n x n matrix. Returns: tuple: Two matrices L and U such that A = L * U. n = len(A) # Initialize L and U as zero matrices L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] # Decompose matrix A using Crout\'s method for i in range(n): # Upper Triangular Matrix U[i][i] = 1 # Diagonal as 1 for j in range(i, n): sum = 0.0 for k in range(i): sum += L[j][k] * U[k][i] L[j][i] = A[j][i] - sum for j in range(i + 1, n): sum = 0.0 for k in range(i): sum += L[i][k] * U[k][j] U[i][j] = (A[i][j] - sum) / L[i][i] return L, U"},{"question":"# Coding Challenge: Implement a Custom Sort Algorithm # Objective Design and implement a sorting algorithm that is more efficient than Bogo Sort. You can choose any deterministic sorting algorithm (e.g., Quick Sort, Merge Sort, etc.) and explain why it is an improvement over Bogo Sort. # Problem Statement Implement a sorting function named `efficient_sort` that sorts an array of integers in non-decreasing order. # Input Format - A list `arr` containing `n` integers, where `1 <= n <= 1000`. - Input values will be between `-10^6` and `10^6`. # Output Format - A sorted list of integers in non-decreasing order. # Constraints - The implementation should be efficient, ideally with a time complexity better than O(n^2). # Performance Requirements - The implementation should handle edge cases like empty arrays and arrays with repeated elements. - Ensure the function does not run indefinitely and handles all inputs within a reasonable time frame. # Example **Input:** ```python arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] ``` **Output:** ```python [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Implementation Note - You are free to use any efficient sorting algorithm and justify your choice in comments. # Additional Information In your implementation, provide comments explaining: 1. The choice of sorting algorithm. 2. How its time complexity compares to that of Bogo Sort. 3. Potential edge cases and how your code handles them. # Solution Template ```python def efficient_sort(arr): # Implement your chosen sorting algorithm here. pass # Example usage: arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_arr = efficient_sort(arr) print(sorted_arr) # Expected output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ```","solution":"def efficient_sort(arr): This function uses the Merge Sort algorithm to sort an array in non-decreasing order. Merge Sort has a time complexity of O(n log n), which is significantly better than Bogo Sort, which has an average time complexity of O((n*n!)). Merge Sort is chosen due to its stable sort nature and it\'s relatively easier to implement compared to other O(n log n) sorts, such as Quick Sort. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = efficient_sort(arr[:mid]) right_half = efficient_sort(arr[mid:]) return _merge(left_half, right_half) def _merge(left, right): Merge two sorted lists into a single sorted list. result = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: result.append(left[left_index]) left_index += 1 else: result.append(right[right_index]) right_index += 1 result.extend(left[left_index:]) result.extend(right[right_index:]) return result"},{"question":"# Scenario Imagine you are working on a large-scale hierarchical data processing system, such as a file system or an organizational chart. Given the dynamic nature of such systems, you often need to verify if a particular structure is a subset of a larger structure. # Task Write a function to determine if one binary tree is a subtree of another binary tree. Implement a robust and efficient solution considering the possible size and complexity of the trees involved. # Function Signature ```python def is_subtree(big: TreeNode, small: TreeNode) -> bool: ``` # Input - `big`: A reference to the root node of the larger binary tree. - `small`: A reference to the root node of the smaller binary tree. # Output - A boolean value indicating whether `small` is a subtree of `big`. # Constraints - The number of nodes in `big` can range from 1 to 10^4. - The number of nodes in `small` can range from 1 to 10^3. - Node values are integers and can be positive or negative. - Tree nodes are defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Performance Requirements - Your solution should handle cases where the larger tree has significantly more nodes than the smaller tree efficiently. - Aim for a time complexity better than O(n * m) in practical scenarios. # Additional Information Test for cases where: - The smaller tree is an exact match of the root of the larger tree. - The smaller tree is a subtree deep within the larger tree. - Both trees are identical. - The smaller tree is not a subtree of the larger tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) def is_subtree(big: TreeNode, small: TreeNode) -> bool: if not small: return True if not big: return False if is_same_tree(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small)"},{"question":"Longest Path in a Directed Acyclic Graph (DAG) Context: You are tasked to work with a Directed Acyclic Graph (DAG) representing a series of tasks and dependencies between them. Each node represents a task, and a directed edge from node A to node B signifies that task A must be completed before task B can start. Given such a graph, you need to find the longest path, in terms of number of edges, from any starting node to any ending node. Task: Implement a function `find_longest_path(dag: DirectedGraph) -> List[Node]:` which takes a DirectedGraph object representing a DAG and returns a list of nodes representing the longest path in the graph. If there are multiple paths with the same maximum length, return any of them. Requirements: 1. The input graph will be guaranteed to be acyclic. 2. You should use Depth-First Search (DFS) to explore the graph. 3. The function should be efficient with a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. ```python class Node: # Implementation details class DirectedEdge: # Implementation details class DirectedGraph: # Implementation details def find_longest_path(dag: DirectedGraph) -> List[Node]: # Your implementation here pass # Sample Usage: load_dict = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } dag = DirectedGraph(load_dict) longest_path = find_longest_path(dag) print([node.name for node in longest_path]) # Output: [\'A\', \'B\', \'D\'] or [\'A\', \'C\', \'D\'] ``` Input: * `dag`: A DirectedGraph object. Output: * A list of nodes representing the longest path in the given DAG. # Constraints: * Each node name is a unique string, and there will be at most 1000 nodes and 5000 edges in the given graph. # Performance Requirements: * Time complexity: O(V + E) * Space complexity: O(V + E) Good luck!","solution":"class Node: def __init__(self, name): self.name = name self.edges = [] class DirectedEdge: def __init__(self, source, destination): self.source = source self.destination = destination class DirectedGraph: def __init__(self, adj_list): self.nodes = {} for node, neighbors in adj_list.items(): if node not in self.nodes: self.nodes[node] = Node(node) for neighbor in neighbors: if neighbor not in self.nodes: self.nodes[neighbor] = Node(neighbor) self.nodes[node].edges.append(DirectedEdge(self.nodes[node], self.nodes[neighbor])) def find_longest_path(dag): def dfs(node, visited, dp, path): if node in visited: return dp[node] visited.add(node) max_length = 0 max_path = [] for edge in node.edges: current_length, current_path = dfs(edge.destination, visited, dp, path) if current_length > max_length: max_length = current_length max_path = current_path visited.remove(node) dp[node] = (max_length + 1, [node] + max_path) return dp[node] visited = set() dp = {} longest_path = [] max_length = 0 for node in dag.nodes.values(): current_length, current_path = dfs(node, visited, dp, []) if current_length > max_length: max_length = current_length longest_path = current_path return [node.name for node in longest_path]"},{"question":"Remove K-th Node from the End of a Singly Linked List **Context**: In several applications like network packet delivery or file system operations, we may need to remove n-th items from the end to manage memory or data in a specific sequence. This operation can be efficiently carried out using a linked list structure. **Task**: - Implement a function to remove the k-th node from the end of a singly linked list. **Function Signature**: ```python def remove_kth_from_end(head: SinglyLinkedListNode, k: int) -> SinglyLinkedListNode: ``` **Input**: - A `SinglyLinkedListNode` object named `head` representing the head of the singly linked list. - An integer `k` representing the position from the end of the list. **Output**: - Return the head of the modified linked list after removing the k-th node from the end. **Constraints**: - k is guaranteed to be valid (1 ≤ k ≤ linked list length). - The linked list will have at least one node. - The list can have a maximum of 10^4 nodes. **Example**: ```python # Given the singly linked list: 1 -> 2 -> 3 -> 4 -> 5 # And k=2 (which means removing the second node from the end) # The expected output is: 1 -> 2 -> 3 -> 5 # Define the list nodes node1 = SinglyLinkedListNode(1) node2 = SinglyLinkedListNode(2) node3 = SinglyLinkedListNode(3) node4 = SinglyLinkedListNode(4) node5 = SinglyLinkedListNode(5) # Link the nodes node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 # Perform the operation modified_head = remove_kth_from_end(node1, 2) # Verify the output # The output linked list should be: 1 -> 2 -> 3 -> 5 ``` **Performance Requirements**: - The function should have a time complexity of O(n), where n is the number of nodes in the linked list. **Hints**: - You may use a two-pointer technique or an auxiliary array to find the k-th node from the end efficiently.","solution":"class SinglyLinkedListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_kth_from_end(head: SinglyLinkedListNode, k: int) -> SinglyLinkedListNode: Removes the k-th node from the end of the singly linked list. dummy = SinglyLinkedListNode(0, head) first = dummy second = dummy # Move first k+1 steps ahead to maintain a gap of k between first and second for _ in range(k + 1): first = first.next # Move both first and second until first reaches the end of the list while first: first = first.next second = second.next # Remove the k-th node from the end second.next = second.next.next return dummy.next"},{"question":"# Postorder Traversal Coding Challenge Context Postorder traversal is an important tree traversal technique, where you first visit the left subtree, then the right subtree, and finally the root node. It is commonly used in scenarios where you need to delete tree nodes or evaluate expressions represented by binary trees. Problem Statement Given the root of a binary tree, implement both iterative and recursive functions to perform postorder traversal on the tree and return the list of values in postorder. Implementation Details 1. **Iterative Implementation**: * Implement an iterative function named `postorder_iter` that takes the root node of a binary tree and returns a list containing the tree\'s nodes in postorder. 2. **Recursive Implementation**: * Implement a recursive function named `postorder_rec` that takes the root node of a binary tree and returns a list containing the tree\'s nodes in postorder. # Function Signatures ```python def postorder_iter(root: Node) -> list: pass def postorder_rec(root: Node, res: list) -> list: pass ``` * **Input**: - `root`: The root node of a binary tree, which may be None for empty trees. * **Output**: - A list of node values in postorder. # Constraints * The number of nodes in the binary tree is between `0` and `10^4`. * The value of each node is an integer. # Example Suppose you have the following binary tree: ``` 1 / 2 3 / 4 5 ``` For this tree: * The postorder traversal should return: `[4, 5, 2, 3, 1]`. # Notes * Ensure your implementations handle edge cases such as empty trees. * Aim for efficient solutions both in terms of time and space complexity.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iter(root: Node) -> list: if root is None: return [] stack, output = [(root, False)], [] while stack: node, visited = stack.pop() if node: if visited: output.append(node.val) else: stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return output def postorder_rec(root: Node, res=None) -> list: if res is None: res = [] if root: postorder_rec(root.left, res) postorder_rec(root.right, res) res.append(root.val) return res"},{"question":"# String Reversal with Constraints Problem Statement You are given a string containing a sentence. You need to reverse the order of words while preserving the words\' internal order. However, the solution should be efficient even for very long strings, hence you must minimize additional space usage. Function Signature ```python def reverse_words_efficiently(s: str) -> str: pass ``` Input and Output Format - **Input**: A single string `s` which represents the sentence. The string may contain leading or trailing spaces and multiple consecutive spaces. - **Output**: A new string with words in reversed order. The internal order of each word should be preserved, and there should be exactly one space separating words with no leading or trailing spaces. Constraints - You cannot use the built-in `split()` and `join()` methods from Python. - The length of the string `s` will not exceed 10^5. Example ```python s = \\" hello world \\" result = reverse_words_efficiently(s) print(result) # Expected: \\"world hello\\" ``` Assumptions - The string `s` may contain alphabetic characters and spaces without any punctuation. - All words are separated by one or more spaces in the input. Notes - You should focus on optimizing both time and space complexity. - Ensure handling of edge cases such as empty string, strings with only spaces, and strings with leading/trailing or multiple consecutive spaces.","solution":"def reverse_words_efficiently(s: str) -> str: Reverse the order of words in the given string efficiently without using split() and join(). Preserves internal order of words and maintains exactly one space between words. Removes leading and trailing spaces. Args: s (str): Input string Returns: str: A new string with words in reversed order. def reverse_in_place(array, start, end): while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1 # Convert the string to a list of characters for in-place modifications chars = list(s) length = len(chars) # Reverse entire string reverse_in_place(chars, 0, length - 1) # Reverse each word in the reversed string start = 0 while start < length: while start < length and chars[start] == \' \': start += 1 end = start while end < length and chars[end] != \' \': end += 1 reverse_in_place(chars, start, end - 1) start = end # Convert the list of characters back to a string and remove extra spaces result = [] i = 0 while i < length: if chars[i] != \' \': if result and result[-1] != \' \': # Add a single space between words result.append(\' \') while i < length and chars[i] != \' \': result.append(chars[i]) i += 1 else: i += 1 return \'\'.join(result)"},{"question":"# Queue Implementation Challenge # Problem Statement: You are required to implement a queue using both array and linked list methods to understand their internal workings and performance implications. Implement the `ArrayQueue` and `LinkedListQueue` classes that extend an abstract base class `AbstractQueue`. Each class must support the following operations: 1. **enqueue(item)**: Adds a new item to the rear of the queue. 2. **dequeue()**: Removes and returns the front item from the queue. 3. **peek()**: Returns the front item without removing it from the queue. 4. **is_empty()**: Returns True if the queue is empty, otherwise False. 5. **size()**: Returns the number of elements in the queue. Instructions: 1. Implement the `ArrayQueue` class with the following methods: * `__init__(self)`: Initialize the queue with a default capacity. * `enqueue(self, value)`: Add a value to the end of the queue. * `dequeue(self)`: Remove and return the value from the front of the queue. * `peek(self)`: Return the value from the front without removing it. * `is_empty(self)`: Return whether the queue is empty or not. * `size(self)`: Return the number of elements in the queue. * Implement a private method `_expand(self)` for handling dynamic array resizing. 2. Implement the `LinkedListQueue` class with the following methods: * `__init__(self)`: Initialize an empty list for the queue. * `enqueue(self, value)`: Add a value to the end of the queue. * `dequeue(self)`: Remove and return the value from the front of the queue. * `peek(self)`: Return the value from the front without removing it. * `is_empty(self)`: Return whether the queue is empty or not. * `size(self)`: Return the number of elements in the queue. # Input: * Your methods will accept values to add to the queue through `enqueue`. # Output: * `enqueue` method: Does not return any value. * `dequeue` method: Returns the value of the front element. * `peek` method: Returns the value of the front element. * `is_empty` method: Returns True or False. * `size` method: Returns an integer. # Example: ```python # Initialize the ArrayQueue aq = ArrayQueue() aq.enqueue(10) aq.enqueue(20) assert aq.peek() == 10 assert aq.dequeue() == 10 assert aq.size() == 1 assert not aq.is_empty() # Initialize the LinkedListQueue llq = LinkedListQueue() llq.enqueue(10) llq.enqueue(20) assert llq.peek() == 10 assert llq.dequeue() == 10 assert llq.size() == 1 assert not llq.is_empty() ``` # Constraints: * Ensure that both implementations handle edge cases like operations on an empty queue. * Optimize the `ArrayQueue` structure for dynamic resizing.","solution":"class AbstractQueue: def enqueue(self, item): raise NotImplementedError def dequeue(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError def size(self): raise NotImplementedError class ArrayQueue(AbstractQueue): def __init__(self): self.queue = [] self.front_idx = 0 def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") item = self.queue[self.front_idx] self.front_idx += 1 if self.front_idx > len(self.queue) // 2: self.queue = self.queue[self.front_idx:] self.front_idx = 0 return item def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.queue[self.front_idx] def is_empty(self): return self.front_idx >= len(self.queue) def size(self): return len(self.queue) - self.front_idx class Node: def __init__(self, value=None, next_node=None): self.value = value self.next = next_node class LinkedListQueue(AbstractQueue): def __init__(self): self.front = None self.rear = None self._size = 0 def enqueue(self, item): new_node = Node(item) if self.rear is None: self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") item = self.front.value self.front = self.front.next if self.front is None: self.rear = None self._size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.front.value def is_empty(self): return self.front is None def size(self): return self._size"},{"question":"Enhanced GCD and LCM Functions As an experienced programmer, you are tasked with enhancing the existing GCD and LCM functions provided. Your task includes improving error handling, optimizing performance, and extending functionality. Task 1. **Enhanced GCD Function (`enhanced_gcd`)**: - This function should compute the greatest common divisor (GCD) of two integers, handling both negative and zero inputs gracefully. - If both inputs are zero, return `None`. 2. **Least Common Multiple Function (`enhanced_lcm`)**: - Utilize your enhanced GCD function to compute the least common multiple (LCM) of two integers. - If either of the inputs is zero, return `None` since LCM is not defined for zero. 3. **Quotient Operations**: - Implement functions for addition, subtraction, multiplication, and division of results from the enhanced GCD and LCM functions. - Functions should be named `add_results`, `sub_results`, `mul_results`, and `div_results`. - These should handle cases when either input is zero or `None`, returning appropriate results. Requirements - Implement each function in Python. - Consider edge cases and optimize for performance. - Ensure your code is well-documented and follows best practices. Constraints - Inputs will be integers in the range of [-10^18, 10^18]. Example ```python # Example usage print(enhanced_gcd(-12, 15)) # Output: 3 print(enhanced_lcm(-12, 15)) # Output: 60 print(add_results(3, 60)) # Output: 63 print(sub_results(3, 60)) # Output: -57 print(mul_results(3, 60)) # Output: 180 print(div_results(60, 3)) # Output: 20.0 print(enhanced_gcd(0, 0)) # Output: None print(enhanced_lcm(0, 15)) # Output: None ```","solution":"def enhanced_gcd(a, b): Compute the greatest common divisor (GCD) of two integers, handling both negative and zero inputs gracefully. If both inputs are zero, return None. if a == 0 and b == 0: return None while b: a, b = b, a % b return abs(a) def enhanced_lcm(a, b): Compute the least common multiple (LCM) of two integers using the enhanced GCD function. If either of the inputs is zero, return None. if a == 0 or b == 0: return None return abs(a * b) // enhanced_gcd(a, b) def add_results(a, b): Add two results together, handling cases when either input is None. If either input is None, treat it as 0. a = a or 0 b = b or 0 return a + b def sub_results(a, b): Subtract the second result from the first, handling cases when either input is None. If either input is None, treat it as 0. a = a or 0 b = b or 0 return a - b def mul_results(a, b): Multiply two results together, handling cases when either input is None. If either input is None, treat it as 0. a = a or 0 b = b or 0 return a * b def div_results(a, b): Divide the first result by the second, handling cases when either input is None or the second input is zero. If either input is None, treat it as 0. If the second input is zero, return None. if b == 0 or b is None: return None a = a or 0 return a / b"},{"question":"# Scenario Suppose you are given an array of stock prices for consecutive days. To efficiently manage the stock trading strategy, you need to frequently retrieve the maximum stock price in any given range of days and later update the prices as new information arrives. # Problem Statement Implement a `SegmentTree` class to maintain the stock prices and allow efficient range maximum queries and updates. Requirements: 1. **Initialization**: ```python def __init__(self, arr: List[int], fn: Callable[[int, int], int]): ``` - Initializes the segment tree with an array `arr`, using a function `fn` (e.g., `max`). 2. **Range Query**: ```python def query(self, L: int, R: int) -> int: ``` - Returns the result of the function `fn` for the elements in the range [L, R]. 3. **Update Value**: ```python def update(self, index: int, value: int) -> None: ``` - Updates the element at a specific index to a new value and maintains the segment tree\'s integrity. # Input & Output Format: * Input: - `SegmentTree` class instance initialization with a list `arr` - Method `query(L, R)` queries the range [L, R] - Method `update(index, value)` updates the element at `index` to `value` * Output: - `query(L, R)` method returns the maximum value in the subarray `[L, R]` for the current state of the array # Constraints: * The array length does not exceed (10^5). * Updates and queries should be performed in logarithmic time complexity. # Example: ```python # Initialize with Array [3, 8, 7, 9, 1, 5] tree = SegmentTree([3, 8, 7, 9, 1, 5], max) # Query maximum in range [1, 3] assert tree.query(1, 3) == 9 # Update index 2 to value 10 tree.update(2, 10) # Query again maximum in range [1, 3] assert tree.query(1, 3) == 10 ```","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], fn: Callable[[int, int], int]): self.n = len(arr) self.tree = [0] * (2 * self.n) self.fn = fn # Initialize the segment tree # Fill the leaves of the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Fill the internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, L: int, R: int) -> int: # Query operation L += self.n R += self.n + 1 result = None while L < R: if L % 2 == 1: result = self.tree[L] if result is None else self.fn(result, self.tree[L]) L += 1 if R % 2 == 1: R -= 1 result = self.tree[R] if result is None else self.fn(result, self.tree[R]) L //= 2 R //= 2 return result def update(self, index: int, value: int) -> None: # Update operation pos = index + self.n self.tree[pos] = value while pos > 1: left = pos right = pos if pos % 2 == 0: right = pos + 1 else: left = pos - 1 pos //= 2 self.tree[pos] = self.fn(self.tree[left], self.tree[right])"},{"question":"Coding Assessment Question **Context**: You have been tasked to analyze data from satellite images represented as 2D matrices. For a given `n x n` matrix, you need to find and calculate the sum of all possible sub-squares of size `k x k`. **Description**: Write a function `sum_sub_squares(matrix: List[List[int]], k: int) -> List[List[int]]` which takes an `n x n` matrix (a list of lists of integers) and an integer `k` and returns a list of lists containing the sums of all `k x k` sub-squares. **Input**: - `matrix`: a 2D list of integers, representing the `n x n` matrix where `n >= 1`. - `k`: an integer `k` representing the size of the sub-squares where `1 <= k <= n`. **Output**: - A 2D list containing the sums of all `k x k` sub-squares. If `k` > `n`, return an empty list. **Constraints**: - The function should return sums in the same order as they appear in the original matrix in a row-wise manner, starting from the top-left corner. - Expected to handle matrices up to size `1000 x 1000`. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 Expected Output: [ [12, 16], [24, 28] ] ``` The sub-squares and their sums are as follows: - `[[1, 2], [4, 5]]` -> sum is 12. - `[[2, 3], [5, 6]]` -> sum is 16. - `[[4, 5], [7, 8]]` -> sum is 24. - `[[5, 6], [8, 9]]` -> sum is 28. **Performance Requirement**: - Optimize the function as much as possible. Consider using prefix sums or any other optimization techniques to improve efficiency. **Edge Cases**: 1. If `k > n`, return an empty list. 2. Handle the cases where `n` or `k` are at their minimum value cleanly.","solution":"from typing import List def sum_sub_squares(matrix: List[List[int]], k: int) -> List[List[int]]: n = len(matrix) if k > n: return [] # Initialize prefix sums array prefix_sums = [[0] * (n + 1) for _ in range(n + 1)] # Compute prefix sums for i in range(n): for j in range(n): prefix_sums[i + 1][j + 1] = (matrix[i][j] + prefix_sums[i][j + 1] + prefix_sums[i + 1][j] - prefix_sums[i][j]) result = [] for i in range(n - k + 1): row_result = [] for j in range(n - k + 1): sum_kxk = (prefix_sums[i + k][j + k] - prefix_sums[i + k][j] - prefix_sums[i][j + k] + prefix_sums[i][j]) row_result.append(sum_kxk) result.append(row_result) return result"},{"question":"You are given a positive integer represented by `num`. Your task is to write a function `next_bigger(num)` that returns the next higher number using the exact same set of digits as the given integer. If no such number exists, return -1. # Input Format * A positive integer `num` (1 ≤ num ≤ 10^9). # Output Format * Return the next higher number formed by the same set of digits. * If no such number exists, return -1. # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` # Constraints * You may assume integer overflow is not an issue for the given input constraints. * The implementation should have a time complexity of O(n) where n is the number of digits in `num`. # Context Suppose you are developing a feature for a custom numeric keypad that assists users in entering the next combination of numbers. Given a number on the display, you need to compute and display the next sequence accurately. The most efficient algorithm ensures users get real-time feedback without noticeable delays.","solution":"def next_bigger(num: int) -> int: Finds the next bigger number using the same digits, if possible. If not, returns -1. digits = list(str(num)) length = len(digits) # Step 1: Find the rightmost digit that is smaller than its next digit for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # Step 2: Find the smallest digit on the right side of (i-th digit) which is larger than digits[i] for j in range(length - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap the found digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence after the (i-th digit) to get the smallest possible number digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\'\'.join(digits))"},{"question":"Enhanced Selection Sort with Early Termination Selection Sort is a simple and intuitive sorting algorithm. However, its quadratic time complexity makes it inefficient for large arrays. One possible improvement is to add an early termination condition to stop the algorithm if it detects that the array is already sorted after any given pass. **Task:** Implement an enhanced version of the Selection Sort algorithm. Your implementation should include an early termination feature that identifies if the list is already sorted after completing any pass through the outer loop. If the list is sorted, the function should terminate immediately to save unnecessary operations. # Function Signature ```python def enhanced_selection_sort(arr): Enhanced Selection Sort with Early Termination Args: - arr: List[int], the list of integers to sort Returns: - List[int], the sorted list ``` # Input * A list of integers `arr`, where 0 <= len(arr) <= 10^4, and each element in the list is in the range [-10^6, 10^6]. # Output * Return the sorted list of integers. # Example ```python assert enhanced_selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert enhanced_selection_sort([4, 3, 2, 1, 0]) == [0, 1, 2, 3, 4] assert enhanced_selection_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_selection_sort([]) == [] ``` # Constraints * You must add an early termination condition based on whether the list is detected as sorted after any outer loop pass. * Ensure your solution is efficient in terms of both time and space complexity. * Make sure to handle all edge cases properly. # Performance Requirements * The function should handle both small and large lists efficiently, particularly in cases where the list might already be mostly sorted.","solution":"def enhanced_selection_sort(arr): Enhanced Selection Sort with Early Termination Args: - arr: List[int], the list of integers to sort Returns: - List[int], the sorted list n = len(arr) for i in range(n): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] # Early termination check already_sorted = True for k in range(1, n): if arr[k - 1] > arr[k]: already_sorted = False break if already_sorted: break return arr"},{"question":"# Question Heap Sort is a comparison-based sorting technique based on a Binary Heap data structure. In this exercise, students are required to implement Heap Sort with the option to visualize each step of the sorting process for better understanding of the internals of the heap sort mechanism. Problem Statement You are required to implement the max heap sort algorithm in Python that sorts an array in ascending order. Your implementation should allow an optional visualization of each step of the heapification and sorting process. **Function Signature** ```python def max_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input - `arr`: A list of integers which can contain both positive and negative values. - `simulation`: An optional boolean argument (default is False). If set to True, print the array\'s state after each iteration. Output - Returns the sorted list of integers in ascending order. Constraints - The array can have up to (10^4) elements. - The array\'s elements can be within the range of ([-10^6, 10^6]). Requirements - The implementation should be in-place and should not use any additional data structures that significantly affect space complexity. - Time complexity should be O(n log n). Example ```python arr = [3, -1, 2, 8, 4, -3, 5] print(max_heap_sort(arr, simulation=True)) # Output: # iteration 0 : 3 -1 2 8 4 -3 5 # iteration 1 : 3 -1 2 8 4 -3 5 # iteration 2 : 3 -1 2 8 4 -3 5 # ... # iteration x : -3 -1 2 4 5 8 3 # Resulting array: [-3, -1, 2, 3, 4, 5, 8] ```","solution":"from typing import List def max_heapify(arr: List[int], n: int, i: int, simulation: bool) -> None: largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest, simulation) def max_heap_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) if simulation: print(f\\"Build max-heap iteration {i}: {arr}\\") for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0, simulation) if simulation: print(f\\"Heap sort iteration {n - i}: {arr}\\") return arr"},{"question":"Given two singly linked lists, determine the node at which the two lists intersect. The intersection is defined based on node reference, not node value. # Input: - Two singly linked lists\' heads: `headA` and `headB` of class `Node`. # Output: - The node at which the intersection of the two linked lists begins, or None if there is no intersection. # Class Definition: ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Function Signature: ```python def getIntersectionNode(headA: Node, headB: Node) -> Node: ``` # Constraints: - The number of nodes in each linked list is in the range `[0, 30,000]`. - `Node.val` is an integer. # Example: **Test Case 1**: ``` List A: 1 -> 3 -> 5 7 -> 9 -> 11 / List B: 2 -> 4 -> 6 ``` **Input**: ```python headA = Node(1) node_a_1 = Node(3) node_a_2 = Node(5) intersection = Node(7) node_b_1 = Node(9) node_b_2 = Node(11) headA.next = node_a_1 node_a_1.next = node_a_2 node_a_2.next = intersection headB = Node(2) node_b_3 = Node(4) node_b_4 = Node(6) headB.next = node_b_3 node_b_3.next = node_b_4 node_b_4.next = intersection intersection.next = node_b_1 node_b_1.next = node_b_2 ``` **Output**: ```python print(getIntersectionNode(headA, headB).val) # Output: 7 ``` **Test Case 2**: ``` List A: 1 -> 2 -> 3 -> 4 List B: 5 -> 6 -> 7 ``` **Input**: ```python headA = Node(1) node_a_1 = Node(2) node_a_2 = Node(3) node_a_3 = Node(4) headA.next = node_a_1 node_a_1.next = node_a_2 node_a_2.next = node_a_3 headB = Node(5) node_b_1 = Node(6) node_b_2 = Node(7) headB.next = node_b_1 node_b_1.next = node_b_2 ``` **Output**: ```python print(getIntersectionNode(headA, headB)) # Output: None ``` # Additional Instructions: - Implement the function that meets the requirements. - Ensure the function handles all edge cases efficiently. - Write unit test cases to validate the functionality.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def getIntersectionNode(headA: Node, headB: Node) -> Node: This function returns the node at which the intersection of two singly linked lists begins. If no intersection exists, it returns None. # Create two pointers which will traverse the lists pointerA, pointerB = headA, headB # Traverse both lists, resetting each pointer to the head of the other list upon reaching the end while pointerA != pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA # Either they meet at the intersection or both reach the end (None) return pointerA"},{"question":"# Question **Problem Statement:** You are given two strings `s1` and `s2`. Write a function to determine the minimum number of deletions required to make the two strings identical. You need to solve this problem by implementing an efficient dynamic programming solution. **Function Signature**: ```python def min_deletions_to_make_identical(s1: str, s2: str) -> int: pass ``` **Input**: * `s1` (string): The first string, 0 <= len(s1) <= 1000. * `s2` (string): The second string, 0 <= len(s2) <= 1000. **Output**: * An integer representing the minimum number of deletions required to make the two strings identical. **Examples**: 1. `Input`: s1 = \\"sea\\", s2 = \\"eat\\" `Output`: 2 Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". 2. `Input`: s1 = \\"abc\\", s2 = \\"def\\" `Output`: 6 Explanation: Both strings have no common subsequence. Thus all characters need to be deleted. **Constraints**: * The function should have time complexity O(m*n) and space complexity O(m*n), where m and n are the lengths of the two input strings. **Hint**: * Use dynamic programming to find the longest common subsequence and calculate the minimum deletions.","solution":"def min_deletions_to_make_identical(s1: str, s2: str) -> int: This function calculates the minimum number of deletions required to make two given strings identical by using dynamic programming. m, n = len(s1), len(s2) # Create a DP table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp table with LCS lengths for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of longest common subsequence lcs_length = dp[m][n] # Minimum deletions to make both strings identical return (m - lcs_length) + (n - lcs_length)"},{"question":"**Scenario**: You are tasked with implementing a function using the Shell Sort algorithm to help a logistics company sort a list of packages based on their weights. While the company often deals with small to moderately sized batches of packages, efficiency and accuracy are paramount. **Task**: Implement a function `optimal_shell_sort` that uses the Shell Sort algorithm to sort an array of integers (weights of packages). You are required to use the Hibbard sequence for the gaps. Ensure your function handles edge cases effectively. **Function Signature**: ```python def optimal_shell_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers representing the weights of packages. - (1 leq text{len(arr)} leq 10^4) - Elements in the array (1 leq text{element} leq 10^6) **Output**: - A sorted list of integers in ascending order. **Constraints**: - You must use Hibbard\'s sequence for the gap sequence: (2^k - 1). - Consider edge cases such as empty arrays, single-element arrays, and fully sorted arrays. **Example**: ```python assert optimal_shell_sort([5, 2, 9, 7, 1]) == [1, 2, 5, 7, 9] assert optimal_shell_sort([1]) == [1] assert optimal_shell_sort([]) == [] ```","solution":"def optimal_shell_sort(arr): Sorts an array of integers using Shell Sort with Hibbard\'s gap sequence. n = len(arr) if n == 0: return arr # Generate Hibbard\'s sequence for gaps k = 1 gaps = [] while (gap := 2**k - 1) < n: gaps.append(gap) k += 1 # Perform Shell Sort for gap in reversed(gaps): for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Question: Island Counter Function Context In the realm of geographic information systems, satellite imagery is used to detect islands in the ocean. Each image is represented as a two-dimensional grid where `1` represents land and `0` represents water. Your task is to count how many distinct islands are present in the given grid. Problem Statement Write a function `num_islands(grid: List[List[int]]) -> int` that takes a 2D grid map of \'1\'s (land) and \'0\'s (water) and returns the number of distinct islands. An island is formed by connecting adjacent lands horizontally or vertically, and it is surrounded by water. Input * `grid`: A list of lists of integers representing the grid, e.g., `[[1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1]]`. * The grid dimensions are at most 300x300. * Elements in the grid are either `0` or `1`. Output * Return an integer representing the number of distinct islands. Constraints * You may assume all four edges of the grid are all surrounded by water. * Optimize for both time complexity and memory usage. Example ```python assert num_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 1, 1] ]) == 2 assert num_islands([ [1, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 1, 0, 0], [1, 0, 1, 0, 1] ]) == 5 ``` Note Consider the implementation using Depth-First Search (DFS) to traverse and mark the visited islands.","solution":"def num_islands(grid): if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() if (row, col) not in visited and 0 <= row < rows and 0 <= col < cols and grid[row][col] == 1: visited.add((row, col)) stack.append((row + 1, col)) stack.append((row - 1, col)) stack.append((row, col + 1)) stack.append((row, col - 1)) islands = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r, c) not in visited: dfs(r, c) islands += 1 return islands"},{"question":"You are required to implement the RSA key generation, encryption, and decryption process as described in the RSA algorithm. This entails generating a pair of keys (public and private) and using these keys to encrypt and decrypt data. Your task is to write three functions: `rsa_generate_key`, `rsa_encrypt`, and `rsa_decrypt`. # Specifications 1. **Function `rsa_generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]`** - **Input**: - `k`: A positive integer representing the number of bits for the modulus `n`. - `seed` (optional): An integer seed for the random number generator (useful for testing). - **Output**: A tuple `(n, e, d)` where: - `n` is the modulus. - `e` is the public exponent. - `d` is the private exponent. 2. **Function `rsa_encrypt(data: int, e: int, n: int) -> int`** - **Input**: - `data`: The plaintext data to encrypt. - `e`: The public exponent. - `n`: The modulus. - **Output**: The encrypted data as an integer. 3. **Function `rsa_decrypt(data: int, d: int, n: int) -> int`** - **Input**: - `data`: The encrypted data. - `d`: The private exponent. - `n`: The modulus. - **Output**: The decrypted data as an integer. # Constraints 1. For encryption and decryption functions, assume that `data`, `e`, `d`, and `n` are all valid integers within appropriate ranges. 2. You may assume that valid `k` values will be supplied for key generation. 3. Performance should be considered, and the solution should handle typical edge cases appropriately. # Example ```python n, e, d = rsa_generate_key(16) data = 42 encrypted = rsa_encrypt(data, e, n) assert encrypted != data decrypted = rsa_decrypt(encrypted, d, n) assert decrypted == data ``` # Notes - Ensure your prime generation method is efficient. - Validate that `p` and `q` are distinct. - The `modinv` function must correctly compute the modular inverse. Good luck!","solution":"import random from typing import Optional, Tuple from sympy import isprime, mod_inverse def generate_prime_candidate(bits: int) -> int: Generate an odd integer randomly p = random.getrandbits(bits) # Apply a mask to set MSB and LSB to 1 p |= (1 << bits - 1) | 1 return p def generate_prime(bits: int) -> int: Generate a prime number of given bits p = 4 while not isprime(p): p = generate_prime_candidate(bits) return p def rsa_generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: if seed is not None: random.seed(seed) # Step 1: Generate two distinct prime numbers p and q p = generate_prime(k // 2) q = generate_prime(k // 2) while q == p: q = generate_prime(k // 2) # Step 2: Compute n = p*q n = p * q # Step 3: Compute the Euler\'s Totient function phi(n) phi_n = (p - 1) * (q - 1) # Step 4-5: Select an integer e such that 1 < e < phi(n) and gcd(e, phi(n)) = 1 e = 3 while True: if isprime(e) and phi_n % e != 0: break e += 2 # Step 6: Compute d as the modular multiplicative inverse of e mod phi(n) d = mod_inverse(e, phi_n) return (n, e, d) def rsa_encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def rsa_decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"You are provided with two functions, `encode` and `decode`, that deal with converting a list of strings into a single encoded string and then decoding it back to the list of strings. Your task is to implement these functions effectively, ensuring that the encoded string can be exactly decoded back into the original list. # Function Details Implement the following functions: `encode` ```python def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - A list of strings to encode. :return: str - A single encoded string. ``` - **Input**: A list of strings, `strs` (0 ≤ len(strs) ≤ 10^4). - **Output**: A single string that is the encoded version of the input list. `decode` ```python def decode(s): Decodes a single string to a list of strings. :param s: str - A single encoded string. :return: List[str] - A list of decoded strings. ``` - **Input**: A single string, `s` (0 ≤ len(s) ≤ 10^4), which is the encoded version of a list of strings. - **Output**: The original list of strings that were encoded into this string. # Constraints - You must handle special cases where the list might have: - Empty strings. - Strings containing special characters, including `\':\'`. - Ensure that your solution is efficient and scalable for the provided constraints. # Example ```python # Example input strs = [\\"hello\\", \\"world\\", \\"foobar\\"] encoded_str = encode(strs) # \\"5:hello5:world6:foobar\\" decoded_list = decode(encoded_str) # [\\"hello\\", \\"world\\", \\"foobar\\"] # Example input with special characters strs = [\\"\\", \\":\\", \\"::\\"] encoded_str = encode(strs) # \\"0:1::2:::\\" decoded_list = decode(encoded_str) # [\\"\\", \\":\\", \\"::\\"] ``` # Hints - For `encode`, pay attention to handling the string lengths accurately and consistently. - For `decode`, ensure your indexing logic correctly interprets the lengths and extracts the substrings.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - A list of strings to encode. :return: str - A single encoded string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :param s: str - A single encoded string. :return: List[str] - A list of decoded strings. strs = [] i = 0 while i < len(s): # Locate the separator j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length # Move index past the length of the current string and the \':\' strs.append(s[j+1:i]) return strs"},{"question":"**Scenario**: You’re working on a data processing pipeline where certain types of events are often logged in bursts. To avoid overwhelming the downstream systems, you need to cap the repetition of each event. This restriction ensures no event type floods the logs more than a predetermined number of times. **Task**: Write a function `capped_repetition(lst, n)` that receives a list of integers `lst` and a positive integer `n`. The function should return a new list where each number appears at most `n` times while preserving the order of first occurrences from the original list. **Function Signature**: ```python def capped_repetition(lst: List[int], n: int) -> List[int]: ``` **Input**: - `lst`: A List of integers where the length of the list is between 0 and 10000. - `n`: An integer (1 ≤ n ≤ 1000) representing the maximum allowed occurrences for each number. **Output**: - A List of integers, the same as the input list but capped so that each number appears at most `n` times. **Constraints**: - The solution should have a time complexity of O(n). - The order of elements in the output list should match their first appearance in the input list as long as they conform to the repetition cap. **Examples**: ```python # Example 1 lst = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 # Output: [1, 2, 3, 1, 2, 3] # Example 2 lst = [4, 5, 5, 5, 4, 4, 7, 7, 7, 7] n = 1 # Output: [4, 5, 7] # Example 3 lst = [] n = 3 # Output: [] # Example 4 lst = [10, 20, 10, 30, 10, 20, 20, 30, 30, 40] n = 2 # Output: [10, 20, 10, 30, 20, 30, 40] ``` **Notes**: - Ensure to handle edge cases such as empty lists and lists with all unique elements or all identical elements. - Factor in both time and space complexity for an efficient solution.","solution":"from typing import List def capped_repetition(lst: List[int], n: int) -> List[int]: Returns a new list where each number appears at most n times while preserving the order of first occurrences from the original list. count = {} result = [] for num in lst: if num not in count: count[num] = 0 if count[num] < n: count[num] += 1 result.append(num) return result"},{"question":"# Question: Implement an RLE Encoder-Decoder You are tasked with implementing a run-length encoding and decoding system. This will allow compression of repeated characters in a string and then the ability to decompress the encoded string back to its original form. **Requirements**: 1. Implement the function `encode_rle(input)`: - **Input**: A string containing the data to be encoded. - **Output**: The RLE encoded string. 2. Implement the function `decode_rle(input)`: - **Input**: A string containing the RLE encoded data. - **Output**: The original decoded string. **Constraints**: - All characters in the input are guaranteed to be printable ASCII characters. - The input strings for both functions will not exceed 10^5 characters. **Example Input/Output**: - Example 1: - Input: \\"AAAABBBCCDAA\\" - Encoded Output: \\"4A3B2C1D2A\\" - Decoded Output: \\"AAAABBBCCDAA\\" - Example 2: - Input: \\"XYZ\\" - Encoded Output: \\"1X1Y1Z\\" - Decoded Output: \\"XYZ\\" - Example 3: - Input: \\"\\" - Encoded Output: \\"\\" - Decoded Output: \\"\\" - Example 4: - Input: \\"AAAAAAAAAAAA\\" - Encoded Output: \\"12A\\" - Decoded Output: \\"AAAAAAAAAAAA\\" Please ensure that your code: - Handles edge cases, such as empty strings or strings with no repetitive characters. - Maintains the performance requirements even for the maximum input size.","solution":"def encode_rle(input_str): Encodes the input string using Run-Length Encoding (RLE). Parameters: input_str (str): The string to be encoded. Returns: str: The RLE encoded string. if not input_str: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: encoded_str += str(count) + input_str[i - 1] count = 1 encoded_str += str(count) + input_str[-1] return encoded_str def decode_rle(input_str): Decodes the input string from Run-Length Encoding (RLE). Parameters: input_str (str): The RLE encoded string to be decoded. Returns: str: The original decoded string. if not input_str: return \\"\\" decoded_str = \\"\\" count = \\"\\" for char in input_str: if char.isdigit(): count += char else: decoded_str += char * int(count) count = \\"\\" return decoded_str"},{"question":"# Question: Implement Kruskal\'s Algorithm for Minimum Spanning Tree You are tasked with implementing the Kruskal\'s Minimum Spanning Tree algorithm. Given the structure and input format of a graph, your implementation should read the input graph and compute the sum of weights of the minimum spanning tree. Input * **vertex_count**: An integer `n`, the number of vertices in the graph (1-based indexing). * **edge_count**: An integer `m`, the number of edges in the graph. * **edges**: A list of tuples representing edges, where each tuple `(u, v, w)` denotes an edge between vertices `u` and `v` with weight `w`. Output * A single integer representing the sum of the weights of the minimum spanning tree. # Specifications * The graph is connected and undirected. * Vertices are numbered from 1 to `n`. * The algorithm should have a time complexity of O(E log E) where E is the number of edges. # Examples Example 1: Input: ``` vertex_count = 5 edge_count = 6 edges = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] ``` Output: ``` 14 ``` Example 2: Input: ``` vertex_count = 3 edge_count = 3 edges = [ (2, 1, 20), (3, 1, 20), (2, 3, 100) ] ``` Output: ``` 40 ``` # Requirements 1. Implement class `Edge` with properties `source`, `target`, `weight`. 2. Implement class `DisjointSet` supporting union by rank and path compression. 3. Implement function `kruskal(vertex_count, edges)` returning the total weight of the MST. # Constraints * 1 ≤ vertex_count ≤ 1000 * 0 ≤ edge_count ≤ 100000 * 1 ≤ weight ≤ 10000 # Implementation ```python class Edge: def __init__(self, source, target, weight): self.source = source self.target = target self.weight = weight class DisjointSet: def __init__(self, size): self.parent = [i for i in range(size)] self.rank = [0] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1, node2): root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def kruskal(vertex_count, edges): edges.sort(key=lambda edge: edge.weight) disjoint_set = DisjointSet(vertex_count) mst_weight_sum = 0 for edge in edges: if disjoint_set.find(edge.source) != disjoint_set.find(edge.target): disjoint_set.union(edge.source, edge.target) mst_weight_sum += edge.weight return mst_weight_sum # Example usage: vertex_count = 5 edge_count = 6 edges = [ Edge(0, 1, 3), Edge(0, 2, 8), Edge(1, 3, 5), Edge(2, 3, 2), Edge(2, 4, 4), Edge(3, 4, 6) ] print(kruskal(vertex_count, edges)) # Output: 14 ```","solution":"class Edge: def __init__(self, source, target, weight): self.source = source self.target = target self.weight = weight class DisjointSet: def __init__(self, size): self.parent = [i for i in range(size)] self.rank = [0] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1, node2): root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def kruskal(vertex_count, edges): edges.sort(key=lambda edge: edge.weight) disjoint_set = DisjointSet(vertex_count + 1) # vertex_count is 1-based, so we need vertex_count + 1 size mst_weight_sum = 0 edge_count_in_mst = 0 for edge in edges: if disjoint_set.find(edge.source) != disjoint_set.find(edge.target): disjoint_set.union(edge.source, edge.target) mst_weight_sum += edge.weight edge_count_in_mst += 1 if edge_count_in_mst == vertex_count - 1: break return mst_weight_sum"},{"question":"You are given a binary tree class `TreeNode` with integer values and two utility functions, `serialize` and `deserialize`, that convert a binary tree to a string and back to a binary tree respectively. Your task is to implement a new function `find_deepest_node`, which should find the deepest node in a given binary tree. The deepest node is defined as the node that is farthest from the root (i.e., has the largest depth). If multiple nodes have the same maximum depth, return any one of them. # Function Signature: ```python def find_deepest_node(root: TreeNode) -> int: pass ``` # Input: - `root`: A `TreeNode` representing the root of the binary tree. # Output: - An integer value representing the value of the deepest node. # Constraints: - The tree might be empty (i.e., `root` could be `None`). - The tree contains integer values that can be either positive or negative. # Example: ```python # Example tree: # 1 # / # 2 3 # / # 4 # In this tree, the deepest node is 4. root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) print(find_deepest_node(root)) # Output: 4 ``` # Note: * Solve the problem efficiently to handle trees with a large number of nodes. * Utilize a breadth-first search (BFS) or depth-first search (DFS) strategy to find the deepest node.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_node(root: TreeNode) -> int: if not root: return None queue = deque([root]) deepest_node_value = root.val while queue: current_node = queue.popleft() deepest_node_value = current_node.val if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return deepest_node_value"},{"question":"# Question: Gap Detection and Range Merging in Sorted Integer Lists You are given a sorted list of unique integers. Your task is to write a function `summarize_ranges` that returns a summary of the contiguous ranges present in the list. Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input - A list of unique integers, `array`, where `1 <= len(array) <= 10^5` and `-10^9 <= array[i] <= 10^9`. Output - A list of strings representing the contiguous ranges. Each range should be represented as \\"start-end\\" if `start` is not equal to `end`, otherwise just \\"start\\". Examples ```python assert summarize_ranges([0, 1, 2, 4, 5, 7]) == [\\"0-2\\", \\"4-5\\", \\"7\\"] assert summarize_ranges([-1, 0, 1, 2, 4, 5, 7]) == [\\"-1-2\\", \\"4-5\\", \\"7\\"] assert summarize_ranges([1,2,3,4,5]) == [\\"1-5\\"] assert summarize_ranges([]) == [] assert summarize_ranges([10]) == [\\"10\\"] ``` Constraints 1. The input list is sorted in ascending order and contains no duplicates. 2. The solution should efficiently handle large input sizes up to 100,000 elements. 3. Consider edge cases where the list can be empty or only contain one element. Notes 1. Utilize Python\'s iterator and list comprehension features for efficient iteration and construction of the result list. 2. Ensure edge cases are thoroughly tested and cover scenarios like single element lists and all unique, non-contiguous elements. This function is expected to demonstrate a solid understanding of list traversal, range merging, and edge case management.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Question You are given an array of positive integers without duplicates (`nums`) and a positive integer target (`target`). Your task is to write a function that returns the number of possible combinations of elements in `nums` that add up to `target`. Different sequences are considered as different combinations. Function Signature ```python def combination_sum_with_constraint(nums: List[int], target: int) -> int: ... ``` Input - `nums`: List of positive integers without duplicates ((1 leq |nums| leq 100)). - `target`: Positive integer ((1 leq target leq 1000)). Output - `int`: Number of possible combinations that add up to `target`. Constraints - The function should run efficiently within the constraints. Aim for (O(n times target)) complexity. Example ```python nums = [1, 2, 3] target = 4 combination_sum_with_constraint(nums, target) # Output should be 7 ``` Edge Cases 1. `nums` being an empty list. 2. `target` being 0, which should return 1 (since only one way exists by choosing nothing). 3. Large values of `target` closer to the upper limit. Follow-up 1. If negative numbers are allowed in the array `nums`: - How does this change the problem? - Identify any additional limitations required to correctly handle negative numbers.","solution":"from typing import List def combination_sum_with_constraint(nums: List[int], target: int) -> int: This function returns the number of possible combinations of elements in nums that add up to the target. Different sequences are considered as different combinations. dp = [0] * (target + 1) dp[0] = 1 # There\'s one way to achieve a sum of 0, by choosing nothing. for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# **Encoding and Decoding a List of Strings** You are to implement two functions, `encode` and `decode`, that encode a list of strings into a single string and decode a single string back into a list of strings, respectively. Functions: * `encode(strs: List[str]) -> str`: Encode a list of strings to a single string. * `decode(s: str) -> List[str]`: Decode a single string into a list of original strings. Input: * For `encode`: * `strs`: List of strings where each string could be empty or contain any printable characters. * For `decode`: * `s`: A single encoded string. Output: * For `encode`: An encoded string that combines all input strings. * For `decode`: A list of strings that were originally encoded. Constraints: 1. `0 <= len(strs) <= 10^4` 2. `0 <= len(str) <= 10^4` for each string in `strs` Example: ```python # Example encoding and decoding strs = [\\"hello\\", \\"world\\"] encoded_string = encode(strs) # Possible encoded_string: \\"5:hello5:world\\" decoded_list = decode(encoded_string) # decoded_list should be [\\"hello\\", \\"world\\"] ``` Notes: 1. The strings should be properly encoded and decoded such that no characters are lost or corrupted. 2. Consider special characters and make sure the delimiter used does not conflict with any character in the strings. Implement `encode` and `decode` such that: * They efficiently handle the maximum constraints. * Properly manage any special cases.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs (List[str]): List of strings to be encoded. Returns: str: Encoded single string. encoded_string = \\"\\" for s in strs: encoded_string += f\\"{len(s)}:{s}\\" return encoded_string def decode(s): Decodes a single string to a list of strings. Args: s (str): Encoded single string. Returns: List[str]: List of decoded strings. decoded_list = [] i = 0 while i < len(s): # Find the position of the delimiter j = i while s[j] != \':\': j += 1 # Get the length of the next string length = int(s[i:j]) # Extract the string length from after the delimiter decoded_list.append(s[j+1:j+1+length]) # Move the index past the extracted string i = j + 1 + length return decoded_list"},{"question":"# Coding Challenge: Switch Successive Pairs in a Stack Problem Statement: Given a stack, implement a function `switch_pairs(stack: List[int]) -> List[int]` that switches successive pairs of numbers starting at the bottom of the stack. For example, if the stack initially stores these values: ``` bottom [3, 8, 17, 9, 1, 10] top ``` Your function should switch the first pair (3, 8), the second pair (17, 9), etc.: ``` bottom [8, 3, 9, 17, 10, 1] top ``` If there are an odd number of values in the stack, the value at the top of the stack is not moved. For example: ``` bottom [3, 8, 17, 9, 1] top ``` Would become: ``` bottom [8, 3, 9, 17, 1] top ``` Requirements: * **Function Signature**: `def switch_pairs(stack: List[int]) -> List[int]` * **Input**: Single list representing a stack with `n` integers where `0 <= n <= 1000`. * **Output**: List representing the stack after each pairs of elements are swapped. Constraints: * Do not use built-in Python stack methods directly. * Your function should handle edge cases like empty stack or single-element stack gracefully. * Ensure your implementation operates within acceptable time and space complexity (`O(n)` for both). Example: ```python assert(switch_pairs([3, 8, 17, 9, 1, 10])) == [8, 3, 9, 17, 10, 1] assert(switch_pairs([3, 8, 17, 9, 1])) == [8, 3, 9, 17, 1] ``` If provided stack is empty or single element, it should return as it is: ```python assert(switch_pairs([])) == [] assert(switch_pairs([5])) == [5] ```","solution":"from typing import List def switch_pairs(stack: List[int]) -> List[int]: Switch successive pairs of numbers starting at the bottom of the stack. for i in range(0, len(stack) - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"You are given a binary tree and a target sum. Your task is to determine if the tree has a root-to-leaf path such that the sum of the node values along the path equals the given target sum. You need to implement an efficient solution using iterative DFS with a stack. # Specifications - Function Signature: `def has_path_sum_dfs_stack(root, target_sum):` - Input: * `root` (TreeNode): The root of the binary tree. - You can assume the TreeNode class is defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` * `target_sum` (int): The target sum to check for a root-to-leaf path. - Output: * Return a boolean value, True if such a path exists, otherwise False. # Constraints 1. The number of nodes in the tree will be between 0 and 10^4. 2. Node values are integers and may include negative values. 3. The target_sum will be an integer. # Examples 1. Given the binary tree: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` And `target_sum = 22`, the function should return `True`, since there exists a root-to-leaf path 5->4->11->2 which sums to 22. 2. Given the binary tree: ``` 1 / 2 3 ``` And `target_sum = 5`, the function should return `False` since there is no root-to-leaf path with sum 5. # Note Use an iterative DFS approach with a stack to implement the solution.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def has_path_sum_dfs_stack(root, target_sum): if not root: return False stack = [(root, root.val)] while stack: node, current_sum = stack.pop() # Check if it\'s a leaf node and the path sum equals target_sum if not node.left and not node.right and current_sum == target_sum: return True if node.right: stack.append((node.right, current_sum + node.right.val)) if node.left: stack.append((node.left, current_sum + node.left.val)) return False"},{"question":"Optimized Separate Chaining Hash Table Scenario You are working on a database management system where fast access to records through unique IDs is crucial. You decide to use a hash table with separate chaining to store and manage these records. The current implementation has some inefficiencies with handling collisions and managing the load factor. Task Implement an optimized version of the Separate Chaining Hash Table that dynamically resizes when the load factor exceeds a certain threshold to ensure that operations remain efficient even as the number of records grows. Requirements * The hash table should start with an initial size of 11. * When the load factor exceeds 0.75, the table should resize to double its current size plus one. * Implement the following methods: * `put(key, value)`: Insert or update the key-value pair. * `get(key)`: Retrieve value by key. * `del_(key)`: Delete key-value pair by key. * `__len__()`: Return the number of key-value pairs in the table. * `resize()`: Double the size of the hash table and rehash all keys. Constraints * Keys are unique and hashable. * Values can be any type. * Implement appropriate error handling for accessing or deleting non-existent keys. Input/Output * The `put` method takes two parameters `key` and `value`. It returns nothing. * The `get` method takes one parameter `key` and returns the associated value or `None` if the key does not exist. * The `del_` method takes one parameter `key` and returns nothing. * The `__len__()` method takes no parameters and returns the number of key-value pairs in the table. Example Usage ```python table = SeparateChainingHashTable() table.put(\'A\', 1) table.put(\'B\', 2) print(len(table)) # Output: 2 print(table.get(\'A\')) # Output: 1 table.del_(\'A\') print(table.get(\'A\')) # Output: None ``` Performance Requirement * Ensure that all operations maintain an average time complexity of O(1). * Handle resizing efficiently to avoid downtime during operations.","solution":"class SeparateChainingHashTable: def __init__(self): self.initial_size = 11 self.table = [[] for _ in range(self.initial_size)] self.size = 0 self.load_factor_threshold = 0.75 def hash(self, key): return hash(key) % len(self.table) def put(self, key, value): idx = self.hash(key) bucket = self.table[idx] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 if self.size / len(self.table) > self.load_factor_threshold: self.resize() def get(self, key): idx = self.hash(key) bucket = self.table[idx] for k, v in bucket: if k == key: return v return None def del_(self, key): idx = self.hash(key) bucket = self.table[idx] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return raise KeyError(f\\"Key: {key} not found\\") def __len__(self): return self.size def resize(self): new_table_size = len(self.table) * 2 + 1 new_table = [[] for _ in range(new_table_size)] for bucket in self.table: for key, value in bucket: new_idx = hash(key) % new_table_size new_table[new_idx].append((key, value)) self.table = new_table"},{"question":"# Question Context: In a large 2D grid, you are tasked with implementing a system that simulates the formation of islands. All initial cells in the grid are water. When a new land cell is added, it can form a new island or merge with existing land cells to form larger islands. Problem: Implement a function `num_islands(positions, n, m)` that takes a list of positions (`positions`) where each position is a tuple `(i, j)` representing a cell in an `n x m` grid. The function should return a list of integers, where each integer represents the number of islands after each respective addLand operation. Input: - `positions`: List of tuples, where each tuple `(i, j)` represents the coordinates of a land cell in the grid. - `n`: Integer, number of rows in the grid. - `m`: Integer, number of columns in the grid. Output: - List of integers representing the number of islands after each addLand operation. Constraints: - `0 <= i < n` - `0 <= j < m` - Initially, all cells are water. - New land cells are added one by one. Example: ```python n = 3 m = 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] # Add land at (0,0): # 1 0 0 # 0 0 0 --> Number of islands: 1 # 0 0 0 # Add land at (0,1): # 1 1 0 # 0 0 0 --> Number of islands: 1 # 0 0 0 # Add land at (1,2): # 1 1 0 # 0 0 1 --> Number of islands: 2 # 0 0 0 # Add land at (2,1): # 1 1 0 # 0 0 1 --> Number of islands: 3 # 0 1 0 assert num_islands(positions, n, m) == [1, 1, 2, 3] ``` Implementation: Implement the `num_islands` function using the Union-Find data structure with path compression and union by size.","solution":"class UnionFind: def __init__(self, size): self.parent = [-1] * size self.rank = [0] * size self.count = 0 # Number of distinct sets def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def add_land(self, p): if self.parent[p] == -1: self.parent[p] = p self.count += 1 def num_islands(positions, n, m): def get_id(x, y): return x * m + y union_find = UnionFind(n * m) result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for x, y in positions: index = get_id(x, y) union_find.add_land(index) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: neighbour_index = get_id(nx, ny) if union_find.parent[neighbour_index] != -1: union_find.union(index, neighbour_index) result.append(union_find.count) return result"},{"question":"# Context: You are given an array of integers that you need to sort using a modified version of the Quick Sort algorithm. Quick Sort is one of the fastest known sorting algorithms under average conditions but can degrade in performance due to poor pivot choices. To tackle this, we aim to implement an optimized version with an improved pivot selection and in-place sorting. # Task: Implement the `optimized_quick_sort` function that sorts an array using quicksort with a median-of-three pivot selection technique. The function should also ensure no unnecessary array recompositions take place. # Function Signature: ```python def optimized_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Expected Input and Output Formats: - **Input**: `arr` - A list of integers, `simulation` - A boolean flag to print each step (default is `False`). - **Output**: A sorted list of integers. # Constraints: 1. The list can be of size `n` where `0 <= n <= 10^6`. 2. Elements in the list are integers within the range `-10^6` to `10^6`. # Example: ```python arr = [10, 7, 8, 9, 1, 5] print(optimized_quick_sort(arr)) # Output: [1, 5, 7, 8, 9, 10] long_arr = [int(x) for x in range(1000000, 0, -1)] print(optimized_quick_sort(long_arr)) # Output: [1, 2, 3, ..., 999998, 999999, 1000000] ``` # Requirements: 1. **Median-of-Three Pivot Selection**: Select the median of the first, middle, and last elements of the partition as the pivot. 2. **In-place Sorting**: Implement in-place sorting and avoid using extra space for another array. 3. **Simulation Mode**: If `simulation` is `True`, print the array state at each partitioning step with a preceding step count. # Note: Consider edge cases such as already sorted arrays, arrays with all identical elements, and arrays containing extreme values within the given range. # Hint: - Include helper functions if necessary for partitioning and pivot selection. - Ensure recursive calls follow the divide-and-conquer approach while maintaining in-place operations.","solution":"from typing import List def median_of_three(arr: List[int], low: int, high: int) -> int: mid = (low + high) // 2 a = arr[low] b = arr[mid] c = arr[high] if a > b: if a < c: median = low elif b > c: median = mid else: median = high else: if a > c: median = low elif b < c: median = mid else: median = high return median def partition(arr: List[int], low: int, high: int, simulation: bool, step: int) -> int: pivot_index = median_of_three(arr, low, high) pivot = arr[pivot_index] arr[pivot_index], arr[low] = arr[low], arr[pivot_index] i = low + 1 j = high while True: while i <= j and arr[i] <= pivot: i += 1 while i <= j and arr[j] >= pivot: j -= 1 if i <= j: arr[i], arr[j] = arr[j], arr[i] else: break arr[low], arr[j] = arr[j], arr[low] if simulation: print(f\\"Step {step}: {arr}\\") return j def quick_sort_recursive(arr: List[int], low: int, high: int, simulation: bool, step: int) -> None: if low < high: p = partition(arr, low, high, simulation, step) quick_sort_recursive(arr, low, p - 1, simulation, step + 1) quick_sort_recursive(arr, p + 1, high, simulation, step + 1) def optimized_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) <= 1: return arr quick_sort_recursive(arr, 0, len(arr) - 1, simulation, 1) return arr"},{"question":"# Question: Binary Tree Maximum Depth Given a binary tree, write a function to determine its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the furthest leaf node. Function Signature ```python def max_depth(root: TreeNode) -> int: ``` Input - `root`: A `TreeNode` object representing the root of the binary tree. The value at this node can be any integer. Output - An integer representing the maximum depth of the tree. Constraints - The number of nodes in the tree is in the range [0, 10^4]. - The value of each node is in the range [-1000, 1000]. Example ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(max_depth(root)) # Output: 3 ``` Explanation - The input tree is: ``` 1 / 2 3 / 4 5 ``` - The maximum depth is 3, corresponding to the path: 1 -> 2 -> 4. Scenario Consider a scenario where you need to determine the stability of a binary tree in accessing its deepest elements. Understanding the depth of the tree can help in optimizing the search operations. Implement the `max_depth` function efficiently to derive the maximum depth of the given binary tree. *Take into account edge cases where the tree might be empty or highly unbalanced. Ensure your solution is optimal and handles the constraints effectively.*","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth of the binary tree. if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Context You are hired to develop a module for an application that deals with cryptographic operations. One essential part is to compute coefficients for Bézout\'s identity to assist in RSA key generation and modular inverses. # Problem Statement Write a function `modular_inverse(a, m)` that uses the Extended Euclidean Algorithm to compute the modular inverse of an integer `a` modulo `m`. The modular inverse is an integer (x) such that: [ (a cdot x) mod m = 1 ] If the modular inverse does not exist, the function should return `None`. The function should follow the constraints and handle edge cases appropriately. # Input - An integer `a` where (0 leq a < 10^9). - An integer `m` where (1 leq m < 10^9). # Output - An integer representing the modular inverse of `a` modulo `m`, or `None` if the inverse does not exist. # Constraints - Ensure the function performs efficiently with a time complexity of (O(log(m))). # Function Signature ```python def modular_inverse(a: int, m: int) -> Optional[int]: pass ``` # Example ```python # Example 1 a = 3 m = 11 # The modular inverse of 3 modulo 11 is 4 because (3 * 4) % 11 = 1 print(modular_inverse(3, 11)) # Output: 4 # Example 2 a = 10 m = 17 # The modular inverse of 10 modulo 17 is 12 because (10 * 12) % 17 = 1 print(modular_inverse(10, 17)) # Output: 12 # Example 3 a = 6 m = 9 # No modular inverse exists because GCD(6, 9) != 1 print(modular_inverse(6, 9)) # Output: None ```","solution":"from typing import Optional def modular_inverse(a: int, m: int) -> Optional[int]: Compute the modular inverse of a modulo m using the Extended Euclidean Algorithm. :param a: Integer whose modular inverse is to be found. :param m: Modulo value. :return: Modular inverse of a modulo m if exists, otherwise None. def extended_gcd(a: int, b: int): Extended Euclidean Algorithm to find the GCD of a and b and the coefficients (x, y) such that ax + by = gcd(a, b). if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y gcd, x, _ = extended_gcd(a, m) if gcd != 1: return None # Modular inverse does not exist if a and m are not coprime # Ensuring the result is positive return x % m"},{"question":"You are working on a system that processes large sets of binary data and requires efficient computation of bitwise operations. To facilitate this, you need to implement a function to count the number of \'1\' bits in the binary representation of an unsigned integer. Write a function `count_hamming_weight(n: int) -> int` that takes an unsigned integer `n` and returns the number of \'1\' bits it has (also known as the Hamming weight). # Requirements - You should use the iterative approach of Brian Kernighan\'s Algorithm. - Your implementation should be efficient in terms of time complexity, achieving a time complexity of O(k), where k is the number of \'1\' bits in the binary representation of the integer. # Constraints - The given integer `n` can range from `0` to `2^32 - 1`. # Example ```python assert count_hamming_weight(11) == 3 assert count_hamming_weight(128) == 1 assert count_hamming_weight(15) == 4 assert count_hamming_weight(0) == 0 assert count_hamming_weight(7) == 3 ``` # Guidance - Ensure you return an integer representing the number of \'1\' bits. - Consider all edge cases, including the smallest and largest values the input can take.","solution":"def count_hamming_weight(n: int) -> int: Returns the number of \'1\' bits in the binary representation of an unsigned integer n. This function uses Brian Kernighan\'s algorithm for efficient computation. count = 0 while n: n &= (n - 1) # Drops the lowest set bit count += 1 return count"},{"question":"# Quick Sort Implementation **Objective**: You are given a list of integers that you need to sort using Quick Sort. Implement the function `quick_sort` which sorts the list in ascending order using the Quick Sort algorithm. The focus is on ensuring you understand the partitioning strategy and recursive nature of the algorithm. **Function Signature**: ```python def quick_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers `arr` where 1 <= len(arr) <= 10^5 and -10^6 <= arr[i] <= 10^6. **Output**: - A list of integers sorted in ascending order. **Constraints**: - Expected time complexity: O(n log(n)) on average. - Expected auxiliary space complexity: O(log(n)) due to recursion stack. **Example**: ```python assert quick_sort([3,6,8,10,1,2,1]) == [1,1,2,3,6,8,10] assert quick_sort([1, 4, 3, 2]) == [1, 2, 3, 4] assert quick_sort([]) == [] ``` **Edge Cases to Consider**: - The input list is empty. - The input list contains a single element. - The input list has all identical elements. - The input list is already sorted or is in reverse order. You must implement the core Quick Sort algorithm without using any additional sorting functionality provided by libraries (e.g., no using Python\'s built-in sorted() function, etc.). **Optional Challenge**: - Modify the quick_sort function to include an optional parameter `simulation` which, when set to `True`, prints the steps of sorting after each partition iteration.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Matrix Transformation Challenge You are provided with a 2D matrix. Write a function that performs specific operations on the matrix based on provided instructions. Your solution should be efficient in both time and space and handle potential edge cases gracefully. Function Signature ```python def transform_matrix(matrix, operation): pass ``` Parameters - **matrix (List[List[int]])**: A 2D list representing the matrix. It may not always be square. - **operation (str)**: A string indicating the type of operation. `operation` can be one of the following: - `\\"rotate_clockwise\\"`: Rotate the matrix 90 degrees clockwise. - `\\"rotate_counterclockwise\\"`: Rotate the matrix 90 degrees counterclockwise. - `\\"top_left_invert\\"`: Reflect the matrix over its top-left to bottom-right diagonal (transpose). - `\\"bottom_left_invert\\"`: Reflect the matrix over its bottom-left to top-right diagonal. Return - **List[List[int]]**: The transformed matrix. Constraints - The matrix will contain integers and have dimensions m x n where 1 <= m, n <= 100. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operation = \\"rotate_clockwise\\" # Expected Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(transform_matrix(matrix, operation)) ``` Note You should address possible edge cases such as empty matrices or non-rectangular matrices (rows with different lengths). Your function should be efficient and avoid repetitive operations.","solution":"def transform_matrix(matrix, operation): Perform transformations on a matrix based on the given operation. Parameters: - matrix (List[List[int]]): A 2D list representing the matrix. - operation (str): A string indicating the type of operation. Returns: - List[List[int]]: The transformed matrix. if not matrix: return [] if operation == \\"rotate_clockwise\\": return [list(row) for row in zip(*matrix[::-1])] elif operation == \\"rotate_counterclockwise\\": return [list(row) for row in zip(*matrix)][::-1] elif operation == \\"top_left_invert\\": return [list(row) for row in zip(*matrix)] elif operation == \\"bottom_left_invert\\": m, n = len(matrix), len(matrix[0]) inverted = [[0] * m for _ in range(n)] for i in range(m): for j in range(n): inverted[j][i] = matrix[i][n - j - 1] return inverted else: raise ValueError(\\"Unsupported operation\\") # Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operation = \\"rotate_clockwise\\" print(transform_matrix(matrix, operation)) # Expected Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ]"},{"question":"You are tasked with extracting a specific digit from a sequence of all concatenated positive integers. For example, if we look at the concatenated sequence of numbers \\"123456789101112...\\", the 11th digit is \'0\'. Write a function `find_nth_digit(n)` that returns the nth digit in this infinite sequence. # Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Input * An integer `n` (1 ≤ n ≤ 2^31 - 1), representing the position in the concatenated sequence of all positive integers. # Output * An integer representing the nth digit in the sequence. # Constraints * Your solution should be efficient enough to handle large values of `n` within a reasonable time frame. * Do not generate the concatenated sequence explicitly due to its potentially enormous size. # Example ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 ``` # Explanation The function should accurately determine the nth digit by calculating: 1. The length of the number where the nth digit resides. 2. The actual number in the series containing the nth digit. 3. Finally, the exact digit from that number corresponding to the nth position in the series. # Notes - Handle edge cases such as very large values of `n` while ensuring precision. - Optimize to avoid unnecessary computations wherever possible.","solution":"def find_nth_digit(n: int) -> int: # Initialize variables digit_length = 1 count = 9 # Determine the length of the numbers where the nth digit is located while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 # Find the actual number where the nth digit is located start_number = 10 ** (digit_length - 1) number = start_number + (n - 1) // digit_length # Find the digit in the number at the nth position digit_index = (n - 1) % digit_length return int(str(number)[digit_index])"},{"question":"Binary Search Tree Insertion Suppose you are managing a dynamic dataset where quick insertions and sorted order retrievals are essential. To achieve this, you want to use a Binary Search Tree (BST). Your task is to implement an insert function for a BST. You need to add a method to the TreeNode class that inserts a new value into the BST, maintaining the BST properties. If the tree is empty, the first value should create the root node. Function Signature: ```python def insert(self, val: int) -> None: ``` # Input: - `val` (int): The value to be inserted into the BST. # Output: - The function does not return anything. It must modify the BST in place. # Constraints: - You can assume all values are integers. - Duplicate values should be inserted to the right subtree if they occur. # Performance Requirements: - The solution should maintain average O(log n) performance. - Consider edge cases like inserting into an empty tree or inserting duplicates. # Example Scenario: ```python root = TreeNode(10) root.insert(5) root.insert(15) root.insert(5) # Testing inserting of duplicate which should go to the right of the initial 5 # Post-insertions, in-order traversal of the tree should result in [5, 5, 10, 15] ``` # Notes: - Ensure the tree structure remains valid after each insertion. - You may add helper methods if necessary.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert(self, val: int) -> None: Inserts a value into the BST maintaining its properties. if val < self.val: # Insert into left subtree if self.left is None: self.left = TreeNode(val) else: self.left.insert(val) else: # Insert into right subtree (including handling of duplicates) if self.right is None: self.right = TreeNode(val) else: self.right.insert(val) def in_order_traversal(self): Helper function to perform in-order traversal and collect values in a list. elements = [] if self.left: elements += self.left.in_order_traversal() elements.append(self.val) if self.right: elements += self.right.in_order_traversal() return elements"},{"question":"# Array Rotation Coding Challenge Problem Description You are provided with an integer array `nums` and an integer `k`. You need to rotate the array to the right by `k` steps, where `k` is non-negative. Function Signature ```python def rotate_array(nums: List[int], k: int) -> None: :param nums: List[int] - a list of integers representing the array to rotate. :param k: int - the number of steps to rotate the array to the right. :return: None - modify the array in place without using extra space. ``` Inputs - `nums`: a list of integers where the length of the list is `n` (0 <= n <= 10^5). - `k`: a non-negative integer (0 <= k <= 10^9) representing the number of steps to rotate. Expected Output - The function should modify `nums` in place, rotating the array elements to the right by `k` steps. Constraints - The function must perform the rotation in-place without using extra space for another array. Examples 1. Given `nums = [1, 2, 3, 4, 5, 6, 7]` and `k = 3`, the array should be modified to `[5, 6, 7, 1, 2, 3, 4]`. 2. Given `nums = [-1, -100, 3, 99]` and `k = 2`, the array should be modified to `[3, 99, -1, -100]`. 3. Given `nums = [1]` and `k = 0`, the array should remain `[1]`. Hints - Consider how to handle the case where `k` is greater than the length of the array. - Efficient solutions will aim for O(n) time complexity and O(1) space complexity.","solution":"def rotate_array(nums, k): Rotates the array nums to the right by k steps in-place. :param nums: List[int] - a list of integers representing the array to rotate. :param k: int - the number of steps to rotate the array to the right. :return: None - modify the array in place without using extra space. n = len(nums) if n == 0: return k = k % n # In case k is greater than the length of nums nums[:] = nums[-k:] + nums[:-k]"},{"question":"# Stack Duplicator Algorithm Scenario: You are tasked with building an algorithm that duplicates each element in a stack, maintaining the original order. This is useful when certain operations must consider each element twice without altering the initial sequence. You are to use only an auxiliary stack or an auxiliary queue for the task. Task: Write a function, `duplicate_stack_elements`, that takes a stack (list) as an argument and modifies it so that each element appears twice in the original order. Implement this function with the following constraints: Constraints: 1. **Input**: A stack represented as a list of integers, `stack`. The top element of the stack is the last element of the list. 2. **Output**: The function should return the modified stack `stack` where each element has been duplicated. 3. You may only use an auxiliary stack or queue (one of them, not both). 4. The space complexity should be kept at O(n), where n is the number of elements in the stack. Example Input and Output: * **Example 1**: * Input: `[3, 7, 1, 14, 9]` * Output: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` * **Example 2**: * Input: `[5]` * Output: `[5, 5]` * **Example 3**: * Input: `[]` * Output: `[]` Python Function Signature: ```python def duplicate_stack_elements(stack: list) -> list: pass ```","solution":"def duplicate_stack_elements(stack: list) -> list: Duplicates each element in the stack, maintaining the original order. Args: - stack (list): The stack represented as a list with the top being the last element. Returns: - list: The modified stack with each element duplicated. # Use auxiliary stack to hold the duplicated elements aux_stack = [] # Pop each element from the input stack and push twice into the auxiliary stack while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) # Reverse the elements in the auxiliary stack back into the original stack to maintain order while aux_stack: stack.append(aux_stack.pop()) return stack"},{"question":"You are required to implement the `counting_sort` function which sorts a given list of integers using the counting sort algorithm. The function should handle arrays that may contain negative values and produce a sorted list in ascending order. # Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers which may contain negative numbers. The length of the list (n) will be at most 10^5. # Output - Returns a new list of integers sorted in ascending order. # Constraints - The maximum absolute value of integers in the array will not exceed 10^5. # Performance Requirements - Your algorithm should run in O(n + k) time complexity where k is the range of input numbers. - Space complexity should be minimized as much as possible. # Example ```python assert counting_sort([4, 3, -2, 1, 0, -1, 3]) == [-2, -1, 0, 1, 3, 3, 4] assert counting_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert counting_sort([50, -50, 0]) == [-50, 0, 50] assert counting_sort([]) == [] assert counting_sort([0, 100000, -100000]) == [-100000, 0, 100000] ``` # Notes 1. Handle negative integers appropriately. 2. Ensure the solution is stable (i.e., equal elements appear in the same order they were in the input). 3. Aim for optimal time and space complexity based on the constraints provided.","solution":"def counting_sort(arr): Sorts a list of integers using the counting sort algorithm, specifically handling negative values. if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 # Initialize count array count = [0] * range_of_elements # Store the count of each element in count array for num in arr: count[num - min_val] += 1 # Accumulate the count array for i in range(1, len(count)): count[i] += count[i - 1] # Place the elements in sorted order output = [0] * len(arr) for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Question: Implement a Custom Sorting Algorithm Write a function called `custom_sort` that implements the Stooge Sort algorithm. Given a list of integers, your task is to sort the list using Stooge Sort principles. Function Signature: ```python def custom_sort(arr: List[int]) -> List[int]: pass ``` Input: - A list of integers `arr` (0 ≤ len(arr) ≤ 1000, -10^3 ≤ arr[i] ≤ 10^3 for each integer arr[i]) Output: - The function should return a new list of integers sorted in ascending order. Constraints: - You must use the Stooge Sort algorithm (not any other sorting method). - The function should handle both positive and negative integers. Performance Requirements: - The implementation should handle the worst-case scenario within reasonable execution time for the given input size. Example: ```python assert custom_sort([5, 2, 9, 1, 6]) == [1, 2, 5, 6, 9] assert custom_sort([]) == [] assert custom_sort([-1, -5, -3]) == [-5, -3, -1] ``` Note: - Recursion depth might vary; ensure that your function correctly sorts the array without exceeding typical recursion depth limits in your environment.","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: def stooge_sort(sub_arr, l, h): if l >= h: return if sub_arr[l] > sub_arr[h]: sub_arr[l], sub_arr[h] = sub_arr[h], sub_arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(sub_arr, l, h - t) stooge_sort(sub_arr, l + t, h) stooge_sort(sub_arr, l, h - t) if arr: array_copy = arr[:] stooge_sort(array_copy, 0, len(array_copy) - 1) return array_copy return [] # Example usage: # sorted_arr = custom_sort([5, 2, 9, 1, 6]) # print(sorted_arr) # [1, 2, 5, 6, 9]"},{"question":"# Problem Description You are tasked to implement a modified version of the Comb Sort algorithm that also keeps track of the number of iterations made during the sorting process. This will help in analyzing the efficiency of the sorting process on different datasets. # Function Signature ```python def comb_sort_with_iterations(arr: List[int]) -> Tuple[List[int], int]: ``` # Input * **arr**: A list of integers that needs to be sorted. # Output * A tuple with two elements: * **sorted_arr**: A list of integers sorted in non-decreasing order. * **iterations**: An integer representing the number of iterations made during the sorting process. # Constraints * `0 <= len(arr) <= 10^5` * Elements of the array can be negative or positive integers within the range of `[-10^6, 10^6]`. # Example ```python arr = [34, 8, 64, 51, 32, 21] sorted_arr, iterations = comb_sort_with_iterations(arr) print(sorted_arr) # Output: [8, 21, 32, 34, 51, 64] print(iterations) # Output: Number of iterations required to sort the array ``` # Notes * The function should handle edge cases like empty arrays and single-element arrays. * Keep the function optimized to handle large input sizes.","solution":"from typing import List, Tuple def comb_sort_with_iterations(arr: List[int]) -> Tuple[List[int], int]: Comb Sort algorithm that sorts an array and returns the sorted array along with the number of iterations made during sorting. def get_next_gap(gap: int) -> int: # Shrinks the gap by the shrink factor of 1.3 # Minimum gap is 1 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True iterations = 0 while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True iterations += 1 return arr, iterations"},{"question":"# Question You are given an **ascendingly sorted array of integers** and an integer `target`. Your task is to implement a function `ternary_search` that returns the index of the `target` if it is present in the array. If the `target` is not found, the function should return `-1`. # Function Signature ```python def ternary_search(arr: List[int], target: int) -> int: ``` # Input * The function takes in two parameters: * `arr`: A list of integers in ascending order, where `0 <= len(arr) <= 10^6`. * `target`: An integer to search for within `arr`. # Output * The function should return a single integer, which is the index of `target` in `arr`. If `target` is not within `arr`, return `-1`. # Constraint * `arr` is guaranteed to be sorted in ascending order. * Implement the solution to run with a time complexity of O(log3(N)). # Example ```python print(ternary_search([1, 2, 3, 5, 9, 12, 15], 5)) # should return 3 print(ternary_search([2, 4, 6, 8, 10, 12], 7)) # should return -1 print(ternary_search([], 1)) # should return -1 ``` # Notes * Ensure your function handles arrays of varying lengths, including empty arrays. * Consider edge cases like arrays with a single element and scenarios where the `target` is the first or last element in the array. Good Luck!","solution":"from typing import List def ternary_search(arr: List[int], target: int) -> int: def search(l, r): if l > r: return -1 third_len = (r - l) // 3 mid1 = l + third_len mid2 = r - third_len if arr[mid1] == target: return mid1 if arr[mid2] == target: return mid2 if target < arr[mid1]: return search(l, mid1 - 1) elif target > arr[mid2]: return search(mid2 + 1, r) else: return search(mid1 + 1, mid2 - 1) return search(0, len(arr) - 1)"},{"question":"You have been tasked with implementing a text searching function to find the first occurrence of a substring within a given string. Your function should return the index where the substring starts, or -1 if it is not found. # Function Signature ```python def find_substring_index(haystack: str, needle: str) -> int: pass ``` # Input * `haystack` (string): The string in which to search for the `needle`. * `needle` (string): The substring to search for within the `haystack`. # Output * **int**: The 0-based index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints * 1 <= len(haystack) <= 10^5 * 0 <= len(needle) <= 10^5 # Example Example 1 * Input: `haystack = \\"hello\\"`, `needle = \\"ll\\"` * Output: `2` Example 2 * Input: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` * Output: `-1` Example 3 * Input: `haystack = \\"abc\\"`, `needle = \\"\\"` * Output: `0` # Scenario Suppose you\'re developing a text editor and you need a function to implement the \\"Find\\" feature. Users should be able to search for a substring within the document, and your function should efficiently locate and return the starting index of the first occurrence of the given substring. If the substring is not found, the function should return -1. # Additional Notes * Ensure your implementation handles empty `needle` properly by returning 0. * Consider the performance impacts of your approach and optimize where possible.","solution":"def find_substring_index(haystack: str, needle: str) -> int: if needle == \\"\\": return 0 return haystack.find(needle)"},{"question":"# Task: Your task is to implement the functions for generating RSA keys (`generate_key`), encrypting data (`encrypt`), and decrypting data (`decrypt`), provided a given bit-length for the keys. # Details: Implement three functions in Python: 1. `generate_key(k, seed=None)`: Generates an RSA key pair. - **Input**: An integer `k` (must be greater than 1), representing the bit-length of the modulus, and an optional integer `seed`, for reproducibility. - **Output**: A tuple `(n, e, d)` representing the RSA modulus, public exponent, and private exponent. 2. `encrypt(data, e, n)`: Encrypts the provided data using the public key. - **Input**: An integer `data` representing the plaintext, and two integers `(e, n)` representing the public key. - **Output**: An integer representing the encrypted data. 3. `decrypt(data, d, n)`: Decrypts the provided encrypted data using the private key. - **Input**: An integer `data` representing the ciphertext, and two integers `(d, n)` representing the private key. - **Output**: An integer representing the original plaintext. # Constraints: 1. ( 1 leq k leq 4096 ) 2. ( 0 leq text{data} < n ) 3. Ensure the algorithm follows appropriate time complexity suitable for handling large prime numbers. # Example: ```python import random # Example usage based on previous analysis: n, e, d = generate_key(16, seed=42) data = 123 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data print(\\"Encryption and decryption working correctly.\\") ``` # Notes: 1. Make sure to handle edge cases and potential error scenarios mentioned in the analysis. 2. Ensure the solution adheres to performance guidelines suitable for the given constraints.","solution":"import random from sympy import isprime, gcd, mod_inverse def generate_large_prime(k): while True: # Generate a random prime of bit length k num = random.getrandbits(k) if isprime(num): return num def generate_key(k, seed=None): if k <= 1: raise ValueError(\\"Bit length must be greater than 1.\\") if seed is not None: random.seed(seed) # Generate two large primes p and q p = generate_large_prime(k // 2) q = generate_large_prime(k // 2) # Calculate n n = p * q # Calculate Euler\'s Totient function phi(n) phi = (p - 1) * (q - 1) # Choose an integer e such that 1 < e < phi(n) and gcd(e, phi(n)) = 1 e = 65537 if gcd(e, phi) != 1: raise ValueError(\\"Chosen e is not coprime with φ(n).\\") # Calculate the modular inverse d of e modulo phi(n) d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): if data < 0 or data >= n: raise ValueError(\\"Data must be in the range 0 <= data < n.\\") # Encrypt the data using the formula c = data^e mod n encrypted_data = pow(data, e, n) return encrypted_data def decrypt(data, d, n): if data < 0 or data >= n: raise ValueError(\\"Data must be in the range 0 <= data < n.\\") # Decrypt the data using the formula m = data^d mod n decrypted_data = pow(data, d, n) return decrypted_data"},{"question":"# Problem: 1-Sparse Stream Validation You are given a stream of tuples, where each tuple consists of a non-negative integer and a sign (\'+\' or \'-\'). The stream represents incremental updates on a set of integers, where the \'+\' sign adds the number to the set and the \'-\' sign removes the number from the set. You need to determine if the stream results in a 1-sparse set - meaning a set where there\'s only one unique remaining element and all others cancel out. Function Signature ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: pass ``` # Input - `array`: a list of tuples [(number1, sign1), (number2, sign2), ...], where each tuple contains: * `number` (int): non-negative integer. * `sign` (str): either \'+\' or \'-\'. # Output - Returns the unique remaining number if the stream is 1-sparse. - Returns `None` if the stream is not 1-sparse. # Constraints - The stream can have up to `10^5` tuples. - Each number is a non-negative integer less than `10^9`. - The sign is either \'+\' or \'-\'. # Example ```python # Example 1 array = [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] assert one_sparse(array) == 4 # Example 2 array = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] assert one_sparse(array) == 2 # Example 3 array = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] assert one_sparse(array) == None ``` # Requirements - Focus on achieving optimal time complexity to handle large inputs efficiently. - Consider edge cases and validate all given conditions are met.","solution":"from typing import List, Tuple, Optional def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: Determines if the stream results in a 1-sparse set. Parameters: - array (List[Tuple[int, str]]): The stream of tuples with each tuple containing an integer and a sign (\'+\' or \'-\') Returns: - Optional[int]: The unique remaining number if the stream is 1-sparse, otherwise None elements = {} for number, sign in array: if sign == \'+\': elements[number] = elements.get(number, 0) + 1 elif sign == \'-\': elements[number] = elements.get(number, 0) - 1 unique_elements = {k for k, v in elements.items() if v != 0} if len(unique_elements) == 1: return unique_elements.pop() else: return None"},{"question":"**Context**: You are tasked with implementing a function for a data-cleaning application. Your task is to move all zeros within an array to the end while keeping the order of non-zero elements intact. Zeros are defined strictly as integer 0, excluding booleans, empty lists, etc. **Function Signature**: ```python def move_zeros(arr: List[Any]) -> List[Any]: ``` # Input * An array `arr` of length n containing arbitrary elements (e.g., integers, strings, booleans, etc.) * `arr` can include multiple types and special Python values (False, [], {}), but zeros are strictly the integer 0. # Output * A list with zeros moved to the end, preserving the order of non-zero elements. # Constraints * The processing should be done in linear time O(n). * Minimize additional space usage. # Performance Requirements * Handle edge cases such as all elements being zeros or where no element is zero. * Ensure that performance remains efficient for large input sizes. # Example ```python assert move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] assert move_zeros([0, 0, 0, 1]) == [1, 0, 0, 0] assert move_zeros([\\"zero\\", True, 0, False, [], 0, {}]) == [\\"zero\\", True, False, [], {}, 0, 0] ``` # Notes * Boolean values and other falsy values (except zero) should be considered as non-zeros in the context of this problem. * Function should be implemented without using additional libraries.","solution":"from typing import List, Any def move_zeros(arr: List[Any]) -> List[Any]: This function takes a list of arbitrary elements and returns a new list with all integer zeros moved to the end while preserving the order of the non-zero elements. non_zeros = [x for x in arr if x != 0 or isinstance(x, bool)] zeros = [x for x in arr if x == 0 and not isinstance(x, bool)] return non_zeros + zeros"},{"question":"# Scenario: You are monitoring binary sequences that are critical for error detection in data streams. To maximize the reliability of these sequences, you need to identify the ideal position to potentially flip a \'0\' to a \'1\'. The goal is to achieve the longest possible contiguous sequence of \'1\'s by flipping exactly one \'0\' to \'1\'. If there are no zeros, the function should return -1 to indicate no replacement is needed. # Function Signature: ```python def max_ones_index(arr:list[int]) -> int: ``` # Input: - `arr (list[int])`: A list of integers containing only `0`s and `1`s representing the binary sequence. The length of the list is `1 <= len(arr) <= 10^6`. # Output: - `int`: The index of the `0` that when replaced with `1` results in the longest contiguous sequence of `1`s. If no zeros are in the input list, return `-1`. # Constraints: - You must achieve this with a time complexity of `O(n)` and space complexity of `O(1)`. # Example: ```python # Example 1 arr = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1] print(max_ones_index(arr)) # Output: 3 # Example 2 arr = [1, 1, 1, 1] print(max_ones_index(arr)) # Output: -1 ``` # Additional Notes: - Ensure your function is robust and handles edge cases such as arrays with all `1`s or multiple contiguous zeros efficiently. - Document your approach and any assumptions you make explicitly.","solution":"def max_ones_index(arr): Find the index of the \'0\' that when replaced with \'1\' gives the longest contiguous sequence of \'1\'s. If no zeros are in the input list, return -1. max_count = 0 # Maximum length of sequence of 1\'s that can be obtained max_index = -1 # Index of \'0\' to replace to get the max_count current_count = 0 # Current sequence length of 1\'s prev_zero_index = -1 # Previous \'0\' index, needed for sequence check second_last_zero_index = -1 # Second last \'0\' index, needed for sequence calculation for i in range(len(arr)): if arr[i] == 1: current_count += 1 else: # Calculate the sequence of 1\'s if we change this \'0\' to \'1\' if i - second_last_zero_index > max_count: max_count = current_count + 1 # Current count + changing one \'0\' max_index = prev_zero_index # The zero to be replaced to get max seq # Update for the next computation current_count = i - prev_zero_index second_last_zero_index = prev_zero_index prev_zero_index = i # Final check in case the best option is the last 0 or no 0 existed if len(arr) - second_last_zero_index > max_count: max_index = prev_zero_index # Check if there was no \'0\' in the list if prev_zero_index == -1: return -1 return max_index"},{"question":"**Question**: Implement a function to calculate the minimum depth of a given binary tree. # Function Signature ```python def calculate_min_depth(root: TreeNode) -> int: :type root: TreeNode :rtype: int ``` # Input - `root`: The root node of the binary tree (`TreeNode`). # Output - Returns an integer representing the minimum depth of the binary tree. # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - -1000 <= Node.val <= 1000 # Requirements - The function should run in `O(n)` time complexity. - The function should handle `None` inputs gracefully and return 0 in such cases. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree Construction root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.left.left.left = TreeNode(7) print(calculate_min_depth(root)) # Output: 3 ``` # Additional Context You are given the basic definition of a `TreeNode` class with initialization of `val`, `left`, and `right` parameters. Implement the function using either a recursive or an iterative method for determining the minimum depth of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_min_depth(root: TreeNode) -> int: if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"Context: You are tasked with refining a linked list by removing any duplicate values. This task often arises in data cleaning or preprocessing steps where ensuring the uniqueness of sequential data is paramount. Objective: Write a function to remove all duplicate values from a singly linked list. You need to implement a solution that removes duplicate node values using: 1. A hashset for an efficient removal with additional space. 2. Without using any extra space beyond the linked list itself (i.e., without any auxiliary data structures like hashsets). Function Signatures: ```python def remove_dups(head: Node) -> None: Removes duplicates from a linked list using an auxiliary hashset. Args: head -> Node: The head node of the linked list. pass def remove_dups_without_set(head: Node) -> None: Removes duplicates from a linked list without using any extra space. Args: head -> Node: The head node of the linked list. pass ``` Expected Input and Output Formats: - The input is the `head` node of a singly linked list. - The linked list has nodes with alphanumeric values (strings). - The function does not return any value, but it should modify the linked list in place. Example: ```python # Before: # head -> [\\"A\\"] -> [\\"A\\"] -> [\\"B\\"] -> [\\"C\\"] -> [\\"D\\"] -> [\\"C\\"] -> [\\"F\\"] -> [\\"G\\"] a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) # After remove_dups, expect: # head -> [\\"A\\"] -> [\\"B\\"] -> [\\"C\\"] -> [\\"D\\"] -> [\\"F\\"] -> [\\"G\\"] remove_dups_without_set(a1) # After remove_dups_without_set, expect (assuming no changes): # head -> [\\"A\\"] -> [\\"B\\"] -> [\\"C\\"] -> [\\"D\\"] -> [\\"F\\"] -> [\\"G\\"] ``` **Constraints**: - The given linked list contains between 0 and 10,000 nodes. - The node values are non-null strings.","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next def remove_dups(head: Node) -> None: Removes duplicates from a linked list using an auxiliary hashset. Args: head -> Node: The head node of the linked list. if not head: return current = head seen = set() previous = None while current: if current.value in seen: previous.next = current.next else: seen.add(current.value) previous = current current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from a linked list without using any extra space. Args: head -> Node: The head node of the linked list. current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"Sum Without the \'+\' Operator # Problem Statement Given two non-negative integers `a` and `b`, write a Python function `add_without_plus(a: int, b: int) -> int` that computes the sum of the two numbers without using the `+` operator. Your task is to use bitwise operations to achieve this. # Input - Two non-negative integers `a` and `b` where (0 <= a, b <= 10^9). # Output - A single integer representing the sum of `a` and `b`. # Function Signature ```python def add_without_plus(a: int, b: int) -> int: ``` # Constraints - Do not use the `+` operator in your implementation. - You may assume that the integers are within the range and will not cause an overflow beyond typical 32-bit integer limits. # Example Input: ```python a = 2 b = 3 ``` Output: ```python 5 ``` # Additional Notes - Validate your function with edge cases including when one of the numbers is zero. - Ensure your solution handles maximum constraints efficiently.","solution":"def add_without_plus(a: int, b: int) -> int: Returns the sum of two integers a and b without using the + operator. Uses bitwise operations to achieve the result. while b != 0: # Carry now contains common set bits of a and b carry = a & b # Sum of bits of a and b where at least one of the bits is not set a = a ^ b # Carry is shifted by one so that adding it to a gives the required sum b = carry << 1 return a"},{"question":"**Scenario**: You are part of a team developing a cryptographic software that implements RSA encryption. One fundamental step involves calculating the modular inverse, which requires the Bézout coefficients. Given the importance of this calculation, you need to write a function that efficiently implements the Extended Euclidean Algorithm. **Task**: You need to write a function `extended_gcd` that takes two positive integers, `num1` and `num2`, and returns a tuple `(s, t, g)` such that: [ num1 times s + num2 times t = g ] where (g) is the GCD of `num1` and `num2`, and `s` and `t` are the Bézout coefficients. Ensure that your implementation does not use floating-point arithmetic to avoid precision issues. **Function Signature**: ```python def extended_gcd(num1: int, num2: int) -> tuple: ``` **Input Format**: - `num1`: A positive integer (1 ≤ num1 ≤ 10^9) - `num2`: A positive integer (1 ≤ num2 ≤ 10^9) **Output Format**: - A tuple `(s, t, g)` where `s` and `t` are integers and `g` is the GCD of `num1` and `num2`. **Constraints**: - Use integer arithmetic only to avoid precision issues. **Example**: ```python # Example 1 num1 = 30 num2 = 20 # The GCD is 10, and possible coefficients (s, t) are (1, -1) assert extended_gcd(num1, num2) == (1, -1, 10) # Example 2 num1 = 101 num2 = 103 # The GCD is 1, and possible coefficients (s, t) are (-51, 50) assert extended_gcd(num1, num2) == (-51, 50, 1) ``` **Notes**: - Ensure integer division (/) is replaced with floored (or //) division in your implementation to avoid incorrect results due to floating-point imprecision.","solution":"def extended_gcd(num1: int, num2: int) -> tuple: Uses the Extended Euclidean Algorithm to find the GCD of num1 and num2 and the coefficients (s, t) such that num1 * s + num2 * t = GCD(num1, num2). if num1 == 0: return (0, 1, num2) else: s, t, g = extended_gcd(num2 % num1, num1) return (t - (num2 // num1) * s, s, g)"},{"question":"# Problem: Efficient Sorting Challenge Context Given the analysis of the highly inefficient Bogo Sort algorithm, you are tasked to implement a more efficient sorting algorithm. Instead of relying on random shuffles, you will use the Quick Sort algorithm which has a better performance profile for sorting arrays. Task Implement the Quick Sort algorithm in Python. Specifications 1. **Function Name**: `quick_sort` 2. **Input**: - `arr` - a list of integers to be sorted. 3. **Output**: - The function should return a new list that is the sorted version of `arr`. 4. **Constraints**: - The input list `arr` can have up to 10^6 elements. - All elements of `arr` are integers in the range -10^9 to 10^9. Requirements - Your solution must have an average case time complexity of O(n log n) and a worst-case time complexity of O(n^2). - Avoid sorting the list in-place to prevent side effects. Example ```python def quick_sort(arr): # Your implementation here # Example Usage input_array = [3, 6, 8, 10, 1, 2, 1] sorted_array = quick_sort(input_array) print(sorted_array) # Output: [1, 1, 2, 3, 6, 8, 10] ``` Notes - Ensure your function has no side effects, meaning it should not alter the input list itself. - Pay attention to edge cases like arrays with duplicate elements and pre-sorted arrays.","solution":"def quick_sort(arr): Returns a new list that is a sorted version of the input list \'arr\' using the Quick Sort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Remove Duplicates from a Singly Linked List You are given a singly linked list where each node contains an integer value. The task is to write a function that removes duplicate elements from the linked list. Implement two versions of this function as described below. Function 1: Using Extra Space Implement the function `remove_dups(head: Node) -> Node` that removes duplicates using additional space. This function should run in O(N) time complexity and O(N) space complexity. Function 2: Without Using Extra Space Implement the function `remove_dups_without_set(head: Node) -> Node` that removes duplicates without using extra space. This function should run in O(N^2) time complexity and O(1) space complexity. # Input Format - The function `remove_dups` and `remove_dups_without_set` take the head of a singly linked list. - The node class is defined as: ```python class Node: def __init__(self, val: int): self.val = val self.next = None ``` # Output Format - Both functions should return the head of the modified linked list. # Example Given the linked list: `1 -> 2 -> 2 -> 3 -> 3 -> 4` - After calling `remove_dups(head)`, the linked list should be: `1 -> 2 -> 3 -> 4` - After calling `remove_dups_without_set(head)`, starting from the original linked list, the result should be: `1 -> 2 -> 3 -> 4` # Constraints - The linked list can have up to 10^4 nodes. - Each node has an integer value between -10^5 and 10^5 inclusive. Make sure to handle edge cases effectively and ensure that your implementation is efficient for the given constraints.","solution":"class Node: def __init__(self, val: int): self.val = val self.next = None def remove_dups(head: Node) -> Node: if not head: return head current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_dups_without_set(head: Node) -> Node: if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Scenario You are a project manager overseeing multiple projects, each with a defined start and end time, as well as an associated profit. Your goal is to determine the maximum profit that can be achieved by selecting non-overlapping projects. # Task Write a function `max_profit_schedule` that takes a list of jobs, each represented as a tuple with a start time, finish time, and profit, and returns the maximum profit achievable. # Function Signature ```python def max_profit_schedule(jobs: [(int, int, int)]) -> int: ``` # Input - `jobs`: A list of tuples, where each tuple consists of three integers representing the start time, finish time, and profit of a job respectively. - Example: `[(1, 3, 5), (2, 5, 6), (4, 6, 5), (6, 7, 4), (5, 8, 11), (7, 9, 2)]` # Output - Returns an integer representing the maximum profit that can be achieved by scheduling non-overlapping jobs. # Constraints - 1 ≤ |jobs| ≤ 10^5 - 1 ≤ Start time, Finish time, Profit ≤ 10^4 - Start time < Finish time for each job # Requirements - Your implementation should have a time complexity of O(n log n) and a space complexity of O(n). # Example ```python jobs = [(1, 3, 5), (2, 5, 6), (4, 6, 5), (6, 7, 4), (5, 8, 11), (7, 9, 2)] print(max_profit_schedule(jobs)) # Output: 17 ``` # Explanation In the provided example, the maximum profit sequence includes jobs (1, 3, 5), (4, 6, 5), and (5, 8, 11) resulting in a total profit of 5 + 5 + 11 = 21.","solution":"from bisect import bisect_right def max_profit_schedule(jobs): Returns the maximum profit achieved by scheduling non-overlapping jobs. :param jobs: List of tuples (start, finish, profit) for each job. :return: Maximum profit. # Sort jobs by finish time jobs.sort(key=lambda x: x[1]) # Initialize dp array where dp[i] will store the maximum profit by including jobs[i] n = len(jobs) dp = [0] * n dp[0] = jobs[0][2] for i in range(1, n): # Profit including the current job incl_prof = jobs[i][2] # Find the latest job that doesn\'t conflict with jobs[i] l = bisect_right(jobs, jobs[i][0], 0, i, key=lambda x: x[1]) if l > 0: incl_prof += dp[l-1] # Store the maximum of including and excluding the current job dp[i] = max(incl_prof, dp[i-1]) return dp[-1]"},{"question":"You are required to implement a sorting function using the bucket sort algorithm that sorts a list of non-negative integers. Your implementation should address common edge cases and aim for efficiency. Note that the provided dummy `next_sort` uses insertion sort, but you are free to use a different and more efficient sorting algorithm within the bucket if desired. # Function Signature: ```python def bucket_sort(arr: List[int]) -> List[int]: # Implementation here ``` # Input: - A list of non-negative integers `arr` where `0 <= len(arr) <= 10^6` and all elements are within the range `0 <= arr[i] <= 10^6`. # Output: - A list of non-negative integers sorted in non-decreasing order. # Constraints: - Aim for O(n + k) average time complexity and O(n + k) space complexity, where `k` is the number of buckets. - Ensure your solution handles edge cases efficiently, including empty lists, lists with one element, and lists with a large range of values. # Example: ```python >>> bucket_sort([37, 45, 29, 8, 12, 88, 55]) [8, 12, 29, 37, 45, 55, 88] >>> bucket_sort([1, 4, 1, 2, 7, 5, 2]) [1, 1, 2, 2, 4, 5, 7] >>> bucket_sort([]) [] ``` # Notes: 1. Utilize an efficient sorting algorithm within each bucket if warranted. 2. Carefully plan your bucket indexing to minimize collisions and ensure even distribution. 3. Consider optimizations that can help perform well across a variety of input scenarios.","solution":"from typing import List def insertion_sort(arr: List[int]) -> List[int]: # Simple insertion sort used within the bucket for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr # Find maximum value in the array to determine the range of the buckets max_val = max(arr) bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Distribute the elements into buckets for num in arr: index = (num * bucket_count) // (max_val + 1) buckets[index].append(num) # Sort individual buckets and concatenate the result sorted_arr = [] for bucket in buckets: if bucket: sorted_arr.extend(insertion_sort(bucket)) return sorted_arr"},{"question":"# Integer and Byte Array Conversions using Endianess Given the integer-to-byte conversion and byte-to-integer conversion methods in both big-endian and little-endian formats, extend the implementations to handle negative integers using two\'s complement representation for negative values. This means you need to properly interpret and encode integers, transforming them into their byte representations and back, while respecting the endianess. # Function Definitions 1. `int_to_bytes_big_endian(num: int) -> bytes` 2. `int_to_bytes_little_endian(num: int) -> bytes` 3. `bytes_big_endian_to_int(bytestr: bytes) -> int` 4. `bytes_little_endian_to_int(bytestr: bytes) -> int` # Input and Output Formats * The `int_to_bytes_*_endian` functions will take a single integer `num`, which may be negative, and return its byte representation as specified by the endian format. * The `bytes_*_endian_to_int` functions will take a byte sequence `bytestr` and convert it back to the corresponding integer, accommodating the appropriate endian format. * The integer can be within the bounds of a 32-bit signed integer: - `-2^31 ≤ num < 2^31` * The output bytes should represent the integer in the minimum required bytes: - For example, the integer `256` should yield two bytes in little-endian: `b\'x00x01\'`. # Constraints - Optimize for both time and space efficiency. - Ensure correct handling of both positive and negative integers. # Example ```python assert int_to_bytes_big_endian(-1) == b\'xffxffxffxff\' assert int_to_bytes_little_endian(-1) == b\'xffxffxffxff\' assert bytes_big_endian_to_int(b\'xffxffxffxff\') == -1 assert bytes_little_endian_to_int(b\'xffxffxffxff\') == -1 assert int_to_bytes_big_endian(305419896) == b\'x12x34x56x78\' assert bytes_big_endian_to_int(b\'x12x34x56x78\') == 305419896 ``` # Additional Notes - Be careful with sign extension during the transition from bytes back to integer, especially when dealing with negative numbers. - Ensure that the conversion handles the smallest negative integer `-2^31` and the largest positive `2^31-1`.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts a 32-bit integer to its big-endian byte representation. return num.to_bytes(4, byteorder=\'big\', signed=True) def int_to_bytes_little_endian(num: int) -> bytes: Converts a 32-bit integer to its little-endian byte representation. return num.to_bytes(4, byteorder=\'little\', signed=True) def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte array to a 32-bit integer. return int.from_bytes(bytestr, byteorder=\'big\', signed=True) def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte array to a 32-bit integer. return int.from_bytes(bytestr, byteorder=\'little\', signed=True)"},{"question":"# Permutations Problem Context Permutations are fundamental in combinatorial problems, where the order of elements is important. They are used in various fields including computer science, statistics, and mathematics for tasks such as generating test cases, exploring all combinations of a set, and solving puzzles. Task You are required to implement a function that generates all possible permutations of a given list of distinct integers using an iterative approach. Function Signature ```python def iterative_permutations(nums: List[int]) -> List[List[int]]: pass ``` Input * `nums` (List[int]): A list of distinct integers (Length N, 1 ≤ N ≤ 9). Output * Returns a list of lists, where each sublist represents a unique permutation of the input list. Constraints * Your solution should be implemented iteratively. Performance Requirements * Your solution should efficiently handle the input size within the given constraints. Example ```python # Input: [1, 2, 3] # Output: [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] # Input: [0, 1] # Output: [ # [0, 1], # [1, 0] # ] # Input: [1] # Output: [ # [1] # ] ```","solution":"from typing import List def iterative_permutations(nums: List[int]) -> List[List[int]]: Generate all possible permutations of a list of distinct integers iteratively. :param nums: List[int] -- a list of distinct integers :return: List[List[int]] -- a list of all permutations result = [[]] for num in nums: new_result = [] for perm in result: for i in range(len(perm) + 1): new_result.append(perm[:i] + [num] + perm[i:]) result = new_result return result"},{"question":"# Finding Two Unique Numbers in an Array **Problem Statement**: You are given an array of integers `nums`, where exactly two elements appear only once, and all other elements appear exactly twice. Your task is to identify the two elements that appear only once. **Constraints**: - Your solution must run in O(N) time. - It must use O(1) extra space. **Function Signature**: ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` **Input**: - A list of integers `nums` containing `2n + 2` elements, where only two elements appear exactly once, and all other elements appear exactly twice. **Output**: - A list of two integers that are the unique elements in the input list. **Example**: ```python assert find_unique_numbers([1, 2, 1, 3, 2, 5]) in [[3, 5], [5, 3]] assert find_unique_numbers([4, 3, 4, 2, 5, 2]) in [[3, 5], [5, 3]] ``` **Explanation**: 1. In the example `[1, 2, 1, 3, 2, 5]`, the numbers `3` and `5` appear only once, while all other numbers appear exactly twice. 2. The output can be in any order. `[3, 5]` and `[5, 3]` are both correct.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: xor_all = 0 # Step 1: XOR all the numbers. The result will be the XOR of the two unique numbers. for num in nums: xor_all ^= num # Step 2: Find a bit that is set in xor_all (it means the corresponding bit in # the two unique numbers are different). differing_bit = xor_all & -xor_all unique1, unique2 = 0, 0 # Step 3: Divide the numbers into two groups and XOR them separately. for num in nums: if num & differing_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Pythagorean Theorem Computation Background The Pythagorean theorem is pivotal in geometry, allowing the computation of the unknown side of a right-angled triangle given two of its sides. To cement your understanding of this fundamental theorem, we\'ll craft a function to automate the side calculations. Task Write a function called `calculate_third_side` that computes the length of the missing side of a right-angled triangle. The function will receive three arguments representing the lengths of the opposite, adjacent, and hypotenuse sides. One of these arguments will be a string `\\"?\\"` indicating the unknown side to be calculated. Function Signature ```python def calculate_third_side(opposite: str, adjacent: str, hypotenuse: str) -> str: pass ``` Input Parameters * `opposite` (string): Length of the opposite side. `\\"?\\"` if unknown. * `adjacent` (string): Length of the adjacent side. `\\"?\\"` if unknown. * `hypotenuse` (string): Length of the hypotenuse. `\\"?\\"` if unknown. Output * A string describing the calculated side in the format `\\"Side = length\\"`, where `Side` is one of `Opposite`, `Adjacent`, `Hypotenuse`, and `length` is the calculated numerical value. Examples Input: ```python calculate_third_side(\\"?\\", \\"3\\", \\"5\\") ``` Output: ```python \\"Opposite = 4.0\\" ``` Input: ```python calculate_third_side(\\"4\\", \\"?\\", \\"5\\") ``` Output: ```python \\"Adjacent = 3.0\\" ``` Input: ```python calculate_third_side(\\"3\\", \\"4\\", \\"?\\") ``` Output: ```python \\"Hypotenuse = 5.0\\" ``` Constraints * Only one side will be unknown. * Input values representing known sides will be positive integers or floating-point numbers. * Inputs will always represent a valid right-angled triangle.","solution":"import math def calculate_third_side(opposite: str, adjacent: str, hypotenuse: str) -> str: Calculate the missing side of a right-angled triangle using the Pythagorean theorem. if opposite == \\"?\\": # opposite^2 + adjacent^2 = hypotenuse^2 adjacent_value = float(adjacent) hypotenuse_value = float(hypotenuse) opposite_value = math.sqrt(hypotenuse_value**2 - adjacent_value**2) return f\\"Opposite = {opposite_value}\\" elif adjacent == \\"?\\": # opposite^2 + adjacent^2 = hypotenuse^2 opposite_value = float(opposite) hypotenuse_value = float(hypotenuse) adjacent_value = math.sqrt(hypotenuse_value**2 - opposite_value**2) return f\\"Adjacent = {adjacent_value}\\" elif hypotenuse == \\"?\\": # hypotenuse^2 = opposite^2 + adjacent^2 opposite_value = float(opposite) adjacent_value = float(adjacent) hypotenuse_value = math.sqrt(opposite_value**2 + adjacent_value**2) return f\\"Hypotenuse = {hypotenuse_value}\\" else: return \\"No side to calculate\\""},{"question":"# Question: Implement a class `OptimizedSeparateChainingHashTable` based on the given `SeparateChainingHashTable` class that includes the following enhancements: 1. Implement dynamic resizing and rehashing: * When the number of key-value pairs exceeds 75% of the table size, double the table size and rehash all entries. * When the number of key-value pairs drops below 25% of the table size, halve the table size (but not smaller than the initial size) and rehash all entries. 2. Optimize the deletion process to avoid leaving empty buckets in chains. Additionally, write a function `measure_load_factor(hash_table)` that returns the current load factor of the hash table. # Constraints: * Assume keys are strings and values are integers. * Initial table size should be 11. * Use the hash function provided: `hash(key) % table size`. # Input and Output: * **Input**: Series of operations (`put`, `get`, `del`) and expected outputs. * **Output**: The result of `get` operations and the final load factor. # Example: ```python def measure_load_factor(hash_table): # Implement this function to return the current load factor. pass class OptimizedSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size=size) def put(self, key, value): # Enhanced put method to handle resizing and rehashing. pass def del_(self, key): # Enhanced delete method to handle resizing and rehashing. pass # Example usage: hash_table = OptimizedSeparateChainingHashTable() hash_table.put(\\"apple\\", 1) hash_table.put(\\"banana\\", 2) hash_table.put(\\"cranberry\\", 3) assert hash_table.get(\\"banana\\") == 2 assert measure_load_factor(hash_table) == 0.2727 hash_table.del_(\\"banana\\") assert hash_table.get(\\"banana\\") is None assert measure_load_factor(hash_table) == 0.1818 ``` # Testing: * Implement at least 5 test cases to verify the correctness and efficiency of your implementation.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(size)] self.count = 0 def hash_function(self, key): return hash(key) % self.size def put(self, key, value): hashed_key = self.hash_function(key) for i, (k, v) in enumerate(self.table[hashed_key]): if k == key: self.table[hashed_key][i] = (key, value) return self.table[hashed_key].append((key, value)) self.count += 1 def get(self, key): hashed_key = self.hash_function(key) for k, v in self.table[hashed_key]: if k == key: return v return None def del_(self, key): hashed_key = self.hash_function(key) for i, (k, v) in enumerate(self.table[hashed_key]): if k == key: del self.table[hashed_key][i] self.count -= 1 return def measure_load_factor(hash_table): return hash_table.count / hash_table.size class OptimizedSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size=size) self.initial_size = size def _resize(self, new_size): old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def put(self, key, value): super().put(key, value) if self.count > 0.75 * self.size: self._resize(2 * self.size) def del_(self, key): super().del_(key) if self.count < 0.25 * self.size and self.size > self.initial_size: self._resize(max(self.initial_size, self.size // 2))"},{"question":"# Tree Traversal and Print You have been given a tree data structure using dictionaries to organize its nodes. Each key in the dictionary represents a node, and its associated value is a list that may include other nodes or simple data elements. Write a function `tree_traversal_and_print` that takes such a tree structure and prints its contents following a specific formatted style. Each line of output should start with a key followed by all its sub-elements. If a sub-element is not a string (meaning it\'s another node), it should start a new line with a space indent: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` **Function Signature**: ```python def tree_traversal_and_print(tree: dict) -> None: ``` **Input**: - `tree`: A dictionary where each key is a node and each value is a list of sub-elements which could be strings or sub-nodes. **Output**: - None, but the function should print the tree structure. **Constraints**: - The input dictionary will not necessarily be a well-balanced tree and may contain deeper hierarchical structures. **Hints**: - Use indentation appropriately when printing sub-nodes. - Ensure each level\'s nodes/elements appear on a new line when required. **Example**: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', [\'Computer\', 5], [\'TV\', 6], [\'Jill\', [\'Sports\', 1]]], \'c\': [\'Bill\', [\'Sports\', 3]], \'d\': [\'Adam\', [\'Computer\', 3], [\'Quin\', [\'Computer\', 3]]], \'e\': [\'Quin\', [\'Book\', 5], [\'TV\', 2]], \'f\': [\'Adam\', [\'Computer\', 7]] } tree_traversal_and_print(tree) ``` The above code should produce the output as shown in the format earlier.","solution":"def tree_traversal_and_print(tree, indent=\\"\\"): def helper(node, indent): if isinstance(node, list): for item in node: helper(item, indent + \\" \\" if isinstance(item, list) else indent) else: print(indent + \\"-> \\" + str(node)) for key, value in tree.items(): print(f\\"{key}\\", end=\\" \\") helper(value, \\"\\")"},{"question":"# Minimum Perfect Squares Challenge Context: Given an integer, your task is to write a function to compute the minimum number of perfect squares that sum to the specified number. According to Lagrange\'s four-square theorem, every natural number can be represented as the sum of four integer squares or fewer. Function Specifications: * **Function Name**: `find_minimum_perfect_squares` * **Input**: A single integer `n` (1 ≤ n ≤ 10^4). * **Output**: An integer representing the minimum number of perfect squares summing up to `n`. Constraints: * Input will always be a positive integer within the given range. * The output must be an integer between 1 and 4. Example: 1. Input: n = 9 - Output: 1 (since 9 = 3^2) 2. Input: n = 10 - Output: 2 (since 10 = 3^2 + 1^2) 3. Input: n = 12 - Output: 3 (since 12 = 2^2 + 2^2 + 2^2) 4. Input: n = 31 - Output: 4 (since 31 = 5^2 + 2^2 + 1^2 + 1^2) Requirements: 1. You must handle the possible reduction by factor of 4. 2. You should implement checks consistent with Legendre\'s three-square theorem. 3. Ensure optimized performance to cope with the upper constraint limit. Submission: Your function will be tested against several cases to verify correctness, performance, and edge-case handling.","solution":"import math def find_minimum_perfect_squares(n): Compute the minimum number of perfect squares that sum to the specified number n. # Basic list to hold the dp values dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # Compute all perfect squares less than or equal to n for i in range(1, int(math.sqrt(n)) + 1): square = i * i for j in range(square, n + 1): dp[j] = min(dp[j], dp[j - square] + 1) return dp[n]"},{"question":"**Context**: Imagine you are developing a system to handle frequent updates and queries on a list of numerical or other data types. One effective solution to this is using a Segment Tree, a data structure that supports fast range queries and updates. **Objective**: Implement a **Segment Tree** to support the following operations: 1. **Initialize the tree** with an array of data. 2. Perform **range queries** to compute a function over a subarray. 3. **Update** an element in the array. **Functionality Requirements**: 1. **Initialization**: - Input: `arr` list of values, `function` a commutative function. - Output: Constructed Segment Tree that supports the given function. 2. **Update Operation**: - Input: `p` index, `v` new value. - Output: Update the element at index `p` with value `v` and adjust the Segment Tree. 3. **Range Query Operation**: - Input: `l` start index, `r` end index. - Output: Result of applying the function to the subarray ranging from index `l` to `r`. # Requirements: 1. Your solution must handle edge cases such as invalid indices. 2. Consider both time and space complexity and aim to minimize them. 3. Ensure that your implementation correctly reflects the Segment Tree operations as defined. # Constraints: - The array elements and the results of the function application will fit within a standard 32-bit integer or tuple constraints. - The `function` will always be commutative. # Example Scenario: ```python # Initialize a Segment Tree with max function. segment_tree = SegmentTree([2, 4, 5, 3, 4], max) print(segment_tree.query(2, 4)) # Output: 5 segment_tree.update(3, 6) print(segment_tree.query(0, 3)) # Output: 6 # Initialize a Segment Tree with sum function. segment_tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(segment_tree.query(0, 6)) # Output: 64 segment_tree.update(2, -10) print(segment_tree.query(0, 6)) # Output: 52 ```","solution":"class SegmentTree: def __init__(self, arr, func): Initializes the Segment Tree :param arr: The initial list of values :param func: The commutative function used for range queries self.n = len(arr) self.func = func self.tree = [0] * (2 * self.n) # Build the tree self.build(arr) def build(self, arr): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, value): Update the value at index p to value :param p: index to be updated :param value: new value p += self.n self.tree[p] = value # then move up and update the parents while p > 1: self.tree[p >> 1] = self.func(self.tree[p], self.tree[p ^ 1]) p >>= 1 def query(self, l, r): Compute the result of applying `func` to the range [l, r) :param l: start index of range :param r: end index of range (exclusive) :return: result of func on the specified range res = None l += self.n r += self.n while l < r: if l & 1: res = self.tree[l] if res is None else self.func(res, self.tree[l]) l += 1 if r & 1: r -= 1 res = self.tree[r] if res is None else self.func(res, self.tree[r]) l >>= 1 r >>= 1 return res"},{"question":"Objective Implement a function that calculates the length of the missing side in a right-angled triangle using the Pythagorean Theorem. Task Write a function `pythagorean_triangle` that takes three sides of a right-angled triangle: `opposite`, `adjacent`, and `hypotenuse`. One of these sides will be unknown, represented by the string \\"?\\". The function should return the length of the unknown side, rounded to two decimal places. # Input - `opposite` (float or str): Length of the side opposite to the right angle, or \\"?\\" if unknown. - `adjacent` (float or str): Length of the side adjacent to the right angle, or \\"?\\" if unknown. - `hypotenuse` (float or str): Length of the hypotenuse, or \\"?\\" if unknown. # Output - A string indicating the unknown side and its length, formatted to two decimal places. # Constraints - Exactly one of `opposite`, `adjacent`, or `hypotenuse` will be \\"?\\". - The provided numeric values for the sides will always form a valid right-angled triangle if they were actual measurements. # Examples ```python print(pythagorean_triangle(\\"?\\", 3, 5)) # Output: \\"Opposite = 4.00\\" print(pythagorean_triangle(5, \\"?\\", 13)) # Output: \\"Adjacent = 12.00\\" print(pythagorean_triangle(6, 8, \\"?\\")) # Output: \\"Hypotenuse = 10.00\\" ``` Performance Requirements - The solution should run in constant time, O(1).","solution":"import math def pythagorean_triangle(opposite, adjacent, hypotenuse): Returns the length of the missing side in a right-angled triangle, rounded to two decimal places. if opposite == \\"?\\": # Using the formula: hypotenuse^2 - adjacent^2 = opposite^2 adjacent = float(adjacent) hypotenuse = float(hypotenuse) opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.2f}\\" elif adjacent == \\"?\\": # Using the formula: hypotenuse^2 - opposite^2 = adjacent^2 opposite = float(opposite) hypotenuse = float(hypotenuse) adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.2f}\\" elif hypotenuse == \\"?\\": # Using the formula: opposite^2 + adjacent^2 = hypotenuse^2 opposite = float(opposite) adjacent = float(adjacent) hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.2f}\\""},{"question":"# Missing Number Finder You are given a sequence of unique integers from the range [0..n], where one number in the sequence is missing. The difference between consecutive integers cannot be more than 1. If the sequence is already complete, return the next integer in the sequence. Write a function that efficiently finds the missing number in the sequence. You must implement both of the following approaches: 1. **XOR-based approach**: Using bit manipulation. 2. **Sum-based approach**: Using arithmetic properties. Input - `nums`: A list of unique integers in the range [0..n] (0 ≤ len(nums) ≤ 10^6). Output - An integer representing the missing number in the sequence. If no number is missing, return the next integer in the sequence. Constraints - All integers in the list are unique. - The difference between consecutive integers cannot be more than 1. - The sequence includes at least one number. Examples ``` Input: nums = [4, 1, 3, 0, 6, 5, 2] Output: 7 Input: nums = [0, 1, 2, 3, 4, 5, 7] Output: 6 ``` # Implementation Your solution should include the function definitions. You do not need to handle input/output operations, just the function implementations. Here is the skeleton to get you started: ```python def find_missing_number(nums): missing = 0 for i, num in enumerate(nums): missing ^= num missing ^= i + 1 return missing def find_missing_number2(nums): num_sum = sum(nums) n = len(nums) total_sum = n*(n + 1) // 2 missing = total_sum - num_sum return missing ```","solution":"def find_missing_number(nums): Finds the missing number in the sequence using XOR-based approach. n = len(nums) xor_all_numbers = 0 xor_array_numbers = 0 # XOR all numbers from 0 to n inclusive for i in range(n + 1): xor_all_numbers ^= i # XOR all numbers in the array for num in nums: xor_array_numbers ^= num # The missing number will be the difference in xor values missing = xor_all_numbers ^ xor_array_numbers return missing def find_missing_number2(nums): Finds the missing number in the sequence using sum-based approach. n = len(nums) total_sum = (n * (n + 1)) // 2 array_sum = sum(nums) # The missing number is the difference between expected sum and actual sum missing = total_sum - array_sum return missing"},{"question":"# Decoding Encoded Strings Background In certain applications, strings may be encoded to save space or to obscure their content. An encoded string is formatted according to the rule: k[encoded_string], where the `encoded_string` inside the square brackets is repeated exactly `k` times. Your task is to implement a function to decode such strings. Task Write a function `decode_string(s)` that takes a string `s` as input and returns its decoded version. Input Format * A single string `s`, where `s` contains well-formed encoded patterns. Output Format * A single string representing the fully decoded string. Constraints * The input string `s` is guaranteed to be non-empty and well-formed. * Digits in the string are only used to represent repeat counts for the encoded patterns. * No extra white spaces are present in the string. Examples ```python # Example 1: # Input: \\"3[a]2[bc]\\" # Output: \\"aaabcbc\\" # Example 2: # Input: \\"3[a2[c]]\\" # Output: \\"accaccacc\\" # Example 3: # Input: \\"2[abc]3[cd]ef\\" # Output: \\"abcabccdcdcdef\\" ``` Requirements * Implement your solution using a stack-based approach to handle nested encodings effectively. * Ensure that your solution is efficient both in terms of time and space complexity.","solution":"def decode_string(s): Decodes the encoded string following the pattern k[encoded_string], where the `encoded_string` inside the square brackets is repeated exactly `k` times. stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: # it\'s a letter current_string += char return current_string"},{"question":"Sort 0s, 1s, and 2s Problem Statement You are provided with an array containing integers 0, 1, and 2, representing the colors red, white, and blue, respectively. Your task is to write a function that sorts the array so that all 0s come before all 1s, which come before all 2s. The sorting must be performed in-place without using any library\'s sort function. Function Signature ```python def sort_colors(nums: List[int]) -> None: Sort the input list so that all 0s are followed by 1s and then by 2s. Args: nums (List[int]): The list of integers where each integer is either 0, 1, or 2. Returns: None: The function should modify the list in-place. ``` Input/Output Format - **Input**: A list `nums` of `n` integers where each integer is either 0, 1, or 2. - Example: `[2, 0, 2, 1, 1, 0]` - **Output**: The input list should be sorted in-place. - Example: `[0, 0, 1, 1, 2, 2]` Constraints - The array should consist of only integers 0, 1, and 2. - The solution should use O(n) time and O(1) extra space. Performance Requirements - The algorithm should execute in linear time O(n) and use constant extra space O(1). Requirements - You must modify the list in-place. - You must not use the built-in sort function. Example ```python # Example Input nums = [2, 0, 2, 1, 1, 0] # Expected Output # After calling sort_colors(nums): [0, 0, 1, 1, 2, 2] ``` Hints - Consider using a three-pointer approach, often referred to as the Dutch National Flag problem solution.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sort the input list so that all 0s are followed by 1s and then by 2s. Args: nums (List[int]): The list of integers where each integer is either 0, 1, or 2. Returns: None: The function should modify the list in-place. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"**Context**: You are tasked with comparing the performance of various sorting algorithms on a new dataset. To begin, ensure that you thoroughly understand and can implement the Exchange Sort algorithm. # Task Implement the `exchange_sort` function that takes an unsorted array of integers and returns a sorted array using the Exchange Sort algorithm. # Requirements: - Your implementation must sort the array **in-place**. - You must handle edge cases such as an empty array and arrays with a single element. - The function should work efficiently for small to medium-sized arrays. - Include a check to terminate early if the array becomes sorted before completing all iterations. # Function Signature: ```python def exchange_sort(arr: list[int]) -> list[int]: pass ``` # Input: - An unsorted array of integers `arr` where `1 <= len(arr) <= 1000`. # Output: - The sorted array `arr` in ascending order. # Constraints: - The array will contain integers in the range -10⁶ to 10⁶. # Example: ```python assert exchange_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert exchange_sort([9, 3, 6, 2, 1]) == [1, 2, 3, 6, 9] assert exchange_sort([]) == [] assert exchange_sort([42]) == [42] ``` # Note: - Though Exchange Sort is not efficient for large arrays, focus on understanding the mechanics and ensuring your implementation handles all specified cases and constraints correctly.","solution":"def exchange_sort(arr: list[int]) -> list[int]: Sorts the array in ascending order using Exchange Sort algorithm. n = len(arr) for i in range(n - 1): swapped = False for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: break return arr"},{"question":"Scenario You are tasked with developing a train route optimization software for a new transit system. Your goal is to calculate the minimum cost to travel from the first station to the last station based on predefined transit costs provided by the transport authority. Direct connections between certain stations have predefined costs, while others are non-existent and denoted by `-1` or infinity. Problem Statement Given a cost matrix `cost`, where `cost[i][j]` represents the cost of traveling directly from station `i` to station `j` (and is defined only for `i < j`), write a function: ```python def minimum_cost(cost: List[List[int]]) -> int: pass ``` **Input Format**: * A matrix `cost` of size `n x n`, where `cost[i][j]` is the cost of traveling from station `i` to station `j` for `i < j`. For `i > j`, `cost[i][j]` will be -1 or infinity. **Output Format**: * A single integer representing the minimum cost to travel from station `0` to station `n-1`. **Constraints**: * `1 <= n <= 100` * All costs `cost[i][j]` will be between `1` and `100` or use `-1` or a large value to denote non-existent paths. **Example**: ```python costs = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert minimum_cost(costs) == 65 # Path: 0 -> 1 -> 3 costs = [ [0, 10, 75, 94], [-1, 0, 35, 50], [-1, -1, 0, 80], [-1, -1, -1, 0] ] assert minimum_cost(costs) == 60 # Path: 0 -> 1 -> 3 ``` Good luck!","solution":"from typing import List def minimum_cost(cost: List[List[int]]) -> int: n = len(cost) min_cost = [float(\'inf\')] * n min_cost[0] = 0 for i in range(n): for j in range(i + 1, n): if cost[i][j] != -1: min_cost[j] = min(min_cost[j], min_cost[i] + cost[i][j]) return min_cost[-1]"},{"question":"# Hash Table Implementation with Separate Chaining - Enhanced You\'ve been provided with a simplified implementation of a hash table with separate chaining using linked lists. Your task is to enhance this implementation by adding the following functionalities: 1. **Resizing Mechanism**: * Automatically resize the hash table when the load factor exceeds 0.75. The new size should be twice the current size. * Rehash all existing elements into the new table after resizing. 2. **Contains Method**: * Implement a method `contains(key)` to check if a key is present in the hash table. 3. **Clear Method**: * Implement a method `clear()` to remove all elements from the hash table. # Function Definitions and Constraints 1. **Resizing Mechanism**: - Function: `_resize()` - When invoked, it doubles the size of the hash table and rehashes all the existing elements. 2. **Contains Method**: - Function: `contains(key)` - Input: `key`: An immutable object (e.g., a string, number). - Output: `True` if the key exists in the hash table, `False` otherwise. 3. **Clear Method**: - Function: `clear()` - Removes all elements from the hash table and resets its size. Example: ```python table = SeparateChainingHashTable() table.put(\'key1\', \'value1\') table.put(\'key2\', \'value2\') assert table.contains(\'key1\') == True assert table.contains(\'key3\') == False assert len(table) == 2 table.clear() assert len(table) == 0 assert table.contains(\'key1\') == False ``` Note: - Ensure rehashing properly maintains all key-value pairs after resizing. - You are not allowed to use any external libraries for the hash table except built-in Python data types.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self): self.size = 8 self.buckets = [None] * self.size self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): idx = self._hash(key) if self.buckets[idx] is None: self.buckets[idx] = Node(key, value) else: current = self.buckets[idx] while True: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) self.count += 1 if self.load_factor() > 0.75: self._resize() def get(self, key): idx = self._hash(key) current = self.buckets[idx] while current: if current.key == key: return current.value current = current.next return None def remove(self, key): idx = self._hash(key) current = self.buckets[idx] prev = None while current: if current.key == key: if prev: prev.next = current.next else: self.buckets[idx] = current.next self.count -= 1 return current.value prev = current current = current.next return None def load_factor(self): return self.count / self.size def _resize(self): old_buckets = self.buckets self.size *= 2 self.buckets = [None] * self.size self.count = 0 for head in old_buckets: while head: self.put(head.key, head.value) head = head.next def contains(self, key): idx = self._hash(key) current = self.buckets[idx] while current: if current.key == key: return True current = current.next return False def clear(self): self.size = 8 self.buckets = [None] * self.size self.count = 0 def __len__(self): return self.count"},{"question":"# Markov Chain Sequence Generation Problem Statement You are provided with an implementation of a Markov chain, a mathematical system that transitions between states based on a given set of probabilistic rules. The implementation includes functions for choosing the next state and iterating through states based on a Markov chain defined by a dictionary. Extend this implementation to include a function `generate_sequence(chain, initial_state, length)` that generates a sequence of states starting from an initial state, following the transition rules, and yields a sequence of a specified length. Function Signature ```python def generate_sequence(chain: dict, initial_state: str, length: int) -> list: Generates a sequence of states from a Markov chain. Parameters: chain (dict): A dictionary representing the Markov chain. initial_state (str): The initial state to start the sequence from. length (int): The number of states in the generated sequence. Returns: list: A list of length `length` containing the sequence of states. pass ``` Input - `chain` (dict): A dictionary where each key represents a state, and the value is another dictionary with possible states and their transition probabilities. - `initial_state` (str): A string indicating the state to start from. - `length` (int): An integer representing the number of states to generate in the sequence. Output - Returns a list containing the sequence of states, with each state following the Markov chain\'s transition probabilities. Constraints - The probabilities in each state\'s transition map sum up to 1. - The Markov chain will contain at least one state. - The length of the sequence will be at least 1. - Transition maps are non-empty dictionaries containing at least one state. Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' length = 5 result = generate_sequence(chain, initial_state, length) print(result) # Example output: [\'E\', \'A\', \'E\', \'A\', \'A\'] (exact output can vary) ``` Implementation Requirements - Use the provided helper functions (`next_state` and `__choose_state`) where appropriate. - Ensure the function works efficiently and handles edge cases gracefully.","solution":"import random def __choose_state(transition_map): Helper function to choose the next state based on transition probabilities. Parameters: transition_map (dict): A dictionary where keys are states and values are the probabilities of transitioning to those states. Returns: str: The next state chosen based on the transition probabilities. states = list(transition_map.keys()) probabilities = list(transition_map.values()) return random.choices(states, weights=probabilities, k=1)[0] def next_state(current_state, chain): Chooses the next state based on the current state using the Markov chain. Parameters: current_state (str): The current state. chain (dict): A dictionary representing the Markov chain. Returns: str: The next state. return __choose_state(chain[current_state]) def generate_sequence(chain, initial_state, length): Generates a sequence of states from a Markov chain. Parameters: chain (dict): A dictionary representing the Markov chain. initial_state (str): The initial state to start the sequence from. length (int): The number of states in the generated sequence. Returns: list: A list of length `length` containing the sequence of states. sequence = [initial_state] current_state = initial_state for _ in range(length - 1): current_state = next_state(current_state, chain) sequence.append(current_state) return sequence"},{"question":"Find Two Sum Indices You are tasked to implement a function that finds two distinct indices in an array of integers such that the numbers at those indices add up to a specific target. # Function Signature ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: ``` # Input 1. `array` (List[int]): A list of integers. 2. `target` (int): The target sum. # Output * A tuple of two integers representing the indices of the two numbers that add up to the `target`. # Constraints * Each input will have exactly one solution, and you may not use the same element twice. * The input list will contain at least two integers. * Python 3.x is used for implementation. # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(n) # Example ```python nums = [2, 7, 11, 15] target = 9 assert two_sum(nums, target) == (0, 1) # Because nums[0] + nums[1] = 2 + 7 = 9 ``` # Edge Cases to Consider 1. The array has very large numbers. 2. The array contains negative numbers. 3. The target is a negative number. Your task is to complete the function `two_sum` that meets the above criteria.","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers in the array that add up to the target. num_to_index = {} for index, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index"},{"question":"Scenario You are a software engineer tasked with transforming a binary search tree (BST) into a doubly linked list maintaining the in-order traversal of the tree. Your solution must ensure the linked list is properly interconnected and bidirectional (i.e., each node points to its predecessor and successor). Problem Statement Write a function `convert_bst_to_dll(root)` that takes the root of a Binary Search Tree and converts it into a doubly linked list, maintaining the in-order traversal order of the tree. Function Signature ```python def convert_bst_to_dll(root: TreeNode) -> TreeNode: pass ``` Input: - `root`: The root node of the binary search tree (`TreeNode`). Each node contains an integer value, and left and right children pointers. Output: - Returns the head of the doubly linked list (`TreeNode`). Constraints: - The number of nodes in the tree is in the range [0, 10^4]. - `-10^5 <= Node.val <= 10^5`. Performance Requirements: - Your solution must have a time complexity of O(n) and space complexity of O(h), where n is the number of nodes and h is the height of the tree. Example: Let\'s illustrate with an example binary search tree: ``` 4 / 2 5 / 1 3 ``` After the transformation, the doubly linked list should be: `1 <-> 2 <-> 3 <-> 4 <-> 5` Each node has a `left` pointer to the previous node and a `right` pointer to the next node in the list. Implementation: You are required to implement the `convert_bst_to_dll` function and ensure it handles: - Empty trees. - Trees with only one node. - Trees with larger depths efficiently. Notes: 1. You may define an auxiliary function to assist with the conversion if necessary. 2. Ensure to test with various tree configurations to validate correctness.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def convert_bst_to_dll(root): This function converts a binary search tree to a doubly linked list using in-order traversal. :param root: TreeNode, the root of the binary search tree :return: TreeNode, the head of the resulting doubly linked list if not root: return None def inorder(node): nonlocal last, first if node: # Left inorder(node.left) # Node if last: last.right = node node.left = last else: first = node last = node # Right inorder(node.right) first, last = None, None inorder(root) return first"},{"question":"# Problem Scenario You are given an array of integers that may contain duplicates and need to sort them in non-decreasing order. Implement a sorting function using Cocktail Shaker Sort to accomplish this. # Function Description **Function Signature**: ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: A list of integers. The list will have a size of at most 10^4 elements. **Output**: * A sorted list of integers in non-decreasing order. **Constraints**: * You have to implement the sorting in-place, without using any additional data structures that change the overall space complexity (i.e., use O(1) auxiliary space apart from the input array). # Examples ```python # Example 1 input_arr = [5, 1, 4, 2, 8, 0, 2] output_arr = cocktail_shaker_sort(input_arr) # Expected output: [0, 1, 2, 2, 4, 5, 8] # Example 2 input_arr = [3, 0, -1, 5, 3, 3] output_arr = cocktail_shaker_sort(input_arr) # Expected output: [-1, 0, 3, 3, 3, 5] # Example 3 input_arr = [3, 2, 1] output_arr = cocktail_shaker_sort(input_arr) # Expected output: [1, 2, 3] ``` # Notes Consider edge cases such as: * An already sorted array. * An array sorted in reverse order. * Arrays containing multiple duplicate elements. * Empty arrays or arrays containing a single element. Ensure that your implementation is efficient and adheres to the required constraints.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts the array in non-decreasing order using Cocktail Shaker Sort. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 while start <= end: is_swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_swapped = True # If nothing was swapped, the array is sorted if not is_swapped: break is_swapped = False end -= 1 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] is_swapped = True # If nothing was swapped, the array is sorted if not is_swapped: break start += 1 return arr"},{"question":"You are tasked with implementing a resizable version of the Separate Chaining Hash Table (SCHT) that maintains an optimal load factor to optimize performance. # Requirements: 1. **Implement ResizableSeparateChainingHashTable**: Extend the provided SeparateChainingHashTable to support resizing. 2. **Load Factor**: Implement logic to resize the hash table when the load factor exceeds 0.75 or drops below 0.25. 3. **Rehashing**: Ensure all elements are correctly rehashed into the new table when resizing. 4. **Update all operations**: Ensure `put`, `get`, and `del_` operations work seamlessly with resizing. # Constraints: - Keys: Strings. - Values: Any data type. - Initial size: 11. - Resize multiplier: On an increase, double the table size; on a decrease, halve it but never drop below the initial size. # Function Signatures: ```python class ResizableSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) def put(self, key, value): # Implement resizing logic in addition to the base put implementation. pass def get(self, key): # Simply call base implementation. pass def del_(self, key): # Implement resizing logic in addition to the base del_ implementation. pass def resize(self, new_size): # Implement resize and rehash logic. pass ``` # Example Usage: ```python # Create the resizable hash table table = ResizableSeparateChainingHashTable() # Add elements table.put(\'alpha\', 1) table.put(\'beta\', 2) # Verify load factor-based resizing assert len(table) == 2 # Retrieve elements assert table.get(\'alpha\') == 1 # Delete elements and resize table.del_(\'alpha\') # Ensure the table works correctly post-resize assert len(table) == 1 assert table.get(\'alpha\') is None ``` # Notes: - Thoroughly test your implementation with edge cases, particularly around load factor thresholds and structure resizing. - Ensure hash table operations maintain expected time complexities after resizing.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(size)] self.count = 0 # Keep track of the number of elements in the hash table def _hash(self, key): # Simple hash function based on sum of ASCII values of characters in key return sum(ord(c) for c in key) % self.size def put(self, key, value): hash_index = self._hash(key) for entry in self.table[hash_index]: if entry[0] == key: entry[1] = value return self.table[hash_index].append([key, value]) self.count += 1 def get(self, key): hash_index = self._hash(key) for entry in self.table[hash_index]: if entry[0] == key: return entry[1] return None def del_(self, key): hash_index = self._hash(key) for entry in self.table[hash_index]: if entry[0] == key: self.table[hash_index].remove(entry) self.count -= 1 return class ResizableSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) self.initial_size = size self.load_factor_upper_threshold = 0.75 self.load_factor_lower_threshold = 0.25 def put(self, key, value): super().put(key, value) if self.count / self.size > self.load_factor_upper_threshold: self.resize(self.size * 2) def del_(self, key): super().del_(key) if self.count / self.size < self.load_factor_lower_threshold and self.size > self.initial_size: new_size = max(self.initial_size, self.size // 2) self.resize(new_size) def resize(self, new_size): old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def __len__(self): return self.count"},{"question":"# Coding Task: You are given a nested dictionary representing a tree structure where the hierarchy is denoted by nested lists. The task is to write a function `print_tree_structure(tree)` that prints the tree structure in a formatted way, representing the hierarchical relationships. Function Signature: ```python def print_tree_structure(tree: Dict[str, List[Dict[str, Any]]]) -> None: ``` Input: - A dictionary `tree` where keys are strings, and values are lists of dictionaries. Each dictionary represents a node, and the corresponding list contains its child nodes. Output: - The function should print the hierarchical structure as per the given tree format. # Example: For the input tree: ```python tree = { \\"a\\": [ {\\"Adam\\": [ {\\"Book\\": []}, {\\"Book\\": []}, {\\"Book\\": []}, ]}, {\\"Bill\\": [ {\\"Computer\\": [ {\\"Bill\\": [ {\\"Sports\\": []}, ]}, {\\"TV\\": []}, ]} ]}, {\\"Bill\\": [ {\\"Sports\\": []}, ]} ], \\"b\\": [ {\\"Adam\\": [ {\\"Computer\\": [ {\\"Quin\\": [ {\\"Computer\\": []} ]} ]}, {\\"Quin\\": [ {\\"TV\\": []} ]} ]}, {\\"Quin\\": [ {\\"Book\\": []} ]} ] } ``` The function should print: ``` a -> Adam -> Book -> Book -> Book -> Bill -> Computer -> Bill -> Sports -> TV -> Sports b -> Adam -> Computer -> Quin -> Computer -> Quin -> TV -> Quin -> Book ``` Constraints: - Assume no cyclic references in the tree. - Node labels are case-sensitive. Write the function `print_tree_structure` to accomplish this task.","solution":"def print_tree_structure(tree, indent=\\"\\"): def _print_tree(node, current_indent): for key, children in node.items(): print(f\\"{current_indent}{key}\\") new_indent = current_indent + \\" \\" for child in children: _print_tree(child, new_indent) for key, children in tree.items(): print(f\\"{indent}{key}\\") new_indent = indent + \\" \\" for child in children: _print_tree(child, new_indent)"},{"question":"**Scenario**: You are given a list of integers where each integer in the list appears exactly twice except for one integer that appears only once. Your task is to design a function to identify and return the integer that appears only once. Your solution should have a linear runtime complexity (O(n)) and use constant extra space (O(1)). **Function Signature**: ```python def single_number(nums: List[int]) -> int: ``` **Input**: - `nums`: A list of integers where every element appears exactly twice except for one element that appears only once. The list will have at least one element. **Output**: - The integer that appears only once in the list. **Example**: ```python single_number([4,1,2,1,2]) # Output: 4 single_number([2,2,1]) # Output: 1 single_number([1]) # Output: 1 ``` **Constraints**: 1. Your solution must run in O(n) time. 2. Your solution must use O(1) extra space. 3. The length of the list will be at most (10^5). 4. The elements of the list will be within the range ([-3 times 10^4, 3 times 10^4]). Write the function `single_number` to solve the problem.","solution":"from typing import List def single_number(nums: List[int]) -> int: Given a list of integers where each integer appears exactly twice except for one integer that appears only once, identify and return the integer that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"# Question Given the following OrderedStack class implementation that maintains elements in sorted order within a stack, implement an additional method called `merge` that merges another `OrderedStack` into the current instance. The result should be a single OrderedStack containing all elements from both stacks in sorted order. Implement this method while maintaining time complexity as efficient as possible. Method ```python def merge(self, other_stack): # Your code here ``` Expected Input and Output - **Input Format**: The method receives a single parameter called `other_stack` which is an instance of `OrderedStack` containing the elements to be merged. - **Output**: The merged `OrderedStack` should retain all elements in sorted order from both the original and the other stacks. Constraints - You are not allowed to use any additional external data structures. - You must maintain the sorted order without converting the stacks to different data structures like lists or arrays. Example ```python stack1 = OrderedStack() stack1.push(3) stack1.push(5) stack1.push(9) stack2 = OrderedStack() stack2.push(2) stack2.push(4) stack2.push(10) stack1.merge(stack2) # After merging, elements should be: 2, 3, 4, 5, 9, 10, where 10 is the top element print(stack1.items) # Output should be: [2, 3, 4, 5, 9, 10] ``` Performance Requirements - The solution should minimize the number of stacking and unstacking operations.","solution":"class OrderedStack: def __init__(self): self.items = [] def push(self, item): if self.is_empty() or item >= self.items[-1]: self.items.append(item) else: temp_stack = [] while self.items and self.items[-1] > item: temp_stack.append(self.items.pop()) self.items.append(item) while temp_stack: self.items.append(temp_stack.pop()) def pop(self): return self.items.pop() if not self.is_empty() else None def peek(self): return self.items[-1] if not self.is_empty() else None def is_empty(self): return len(self.items) == 0 def merge(self, other_stack): temp_stack = [] while not self.is_empty() or not other_stack.is_empty(): if self.is_empty(): while not other_stack.is_empty(): temp_stack.append(other_stack.pop()) elif other_stack.is_empty(): while not self.is_empty(): temp_stack.append(self.pop()) else: if self.peek() <= other_stack.peek(): temp_stack.append(self.pop()) else: temp_stack.append(other_stack.pop()) while temp_stack: self.push(temp_stack.pop())"},{"question":"# RSA Encryption As a part of a secure communication system, you are tasked to implement a function to generate RSA keys, encrypt, and decrypt messages. The RSA system relies on the difficulty of factoring a large integer formed by the product of two large prime numbers. Task Implement the RSA key generation, encryption, and decryption in Python. Specifications: * **Function**: `generate_key(k, seed=None)` * **Input**: - `k` (int): Number of bits for modulus `n`. - `seed` (int, optional): Seed for random number generator to enable reproducibility in testing. * **Output**: - (tuple): A tuple containing three integers `n`, `e`, and `d`. * **Function**: `encrypt(data, e, n)` * **Input**: - `data` (int): The plaintext number to encrypt. - `e` (int): Public exponent for encryption. - `n` (int): Modulus. * **Output**: - (int): The encrypted data. * **Function**: `decrypt(data, d, n)` * **Input**: - `data` (int): The encrypted data to decrypt. - `d` (int): Private exponent for decryption. - `n` (int): Modulus. * **Output**: - (int): The decrypted original data. Constraints * ( 2^{15} le n le 2^{1024} ) * ( 2 < e, d, data < n ) Example ```python # Example n, e, d = generate_key(16, seed=42) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data # The decrypted message should match the original ``` Your task is to implement the key generation, encryption, and decryption functions such that given a plaintext number, its encrypted form can be decrypted back to the original number.","solution":"import random from sympy import isprime, mod_inverse def generate_prime(bits, seed=None): if seed is not None: random.seed(seed) while True: prime_candidate = random.getrandbits(bits) if isprime(prime_candidate): return prime_candidate def generate_key(k, seed=None): assert k >= 16, \\"Key size should be at least 16 bits.\\" half_k = k // 2 p = generate_prime(half_k, seed) q = generate_prime(half_k, seed + 1 if seed is not None else None) n = p * q phi_n = (p - 1) * (q - 1) e = 65537 # Common choice for e d = mod_inverse(e, phi_n) return n, e, d def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# B-Tree Range Query **Context**: You are working on a database system that uses a B-Tree for indexing. Your current task is to implement a functionality to retrieve all keys within a given range from the B-Tree. This is a common requirement for executing range queries in database systems. # Objective: Write a function `range_query(self, min_key: int, max_key: int) -> List[int]` inside the `BTree` class that returns all keys within the specified inclusive range `[min_key, max_key]`. # Input: - `min_key` (int): The lower bound of the range. - `max_key` (int): The upper bound of the range. # Output: - A list of integers representing all keys within the range `[min_key, max_key]` in ascending order. # Constraints: - Assume the B-Tree is already constructed and contains integer keys. - You can use the existing methods and structure of the B-Tree for this implementation. - The function should operate within O(k * log n) time complexity, where `k` is the number of keys in the resulting range, and `n` is the total number of keys in the tree. # Example: Consider a B-Tree with the following keys: ``` [10, 20] / | [1, 5] [15] [25, 30, 35] ``` If `min_key = 5` and `max_key = 30`, the output should be: ``` [5, 10, 15, 20, 25, 30] ``` # Implementation Challenges: 1. Efficiently traverse the B-Tree to find keys in the specified range. 2. Avoid unnecessary traversal of nodes not within the desired range. Implement the `range_query` method in the `BTree` class using the following template: ```python class BTree: ... # Keep rest of the existing class unchanged def range_query(self, min_key: int, max_key: int) -> List[int]: result = [] self._range_query(self.root, min_key, max_key, result) return result def _range_query(self, node: Node, min_key: int, max_key: int, result: List[int]): if node is None: return i = 0 while i < len(node.keys) and node.keys[i] < min_key: i += 1 while i < len(node.keys) and node.keys[i] <= max_key: if not node.is_leaf: self._range_query(node.children[i], min_key, max_key, result) result.append(node.keys[i]) i += 1 if not node.is_leaf: self._range_query(node.children[i], min_key, max_key, result) ```","solution":"class BTree: class Node: def __init__(self, t, is_leaf=True): self.t = t # Minimum degree self.keys = [] # Keys in the node self.children = [] # Children pointers self.is_leaf = is_leaf # True if leaf node def __init__(self, t): self.root = self.Node(t) self.t = t # Insert and other B-Tree methods would be here... def range_query(self, min_key: int, max_key: int) -> list[int]: Perform a range query on the B-Tree to get all keys within [min_key, max_key]. result = [] self._range_query(self.root, min_key, max_key, result) return result def _range_query(self, node, min_key: int, max_key: int, result: list[int]): Helper function to perform the range query. if node is None: return i = 0 # Find the first key greater than or equal to min_key while i < len(node.keys) and node.keys[i] < min_key: i += 1 # Traverse the subtree rooted with this node while i < len(node.keys) and node.keys[i] <= max_key: # If this is not a leaf node, traverse the subtree before the key if not node.is_leaf: self._range_query(node.children[i], min_key, max_key, result) # Append the key if it lies within the range result.append(node.keys[i]) i += 1 # Traverse the subtree after the last key if this is not a leaf node if not node.is_leaf and i < len(node.children): self._range_query(node.children[i], min_key, max_key, result)"},{"question":"# Coding Scenario You are tasked with writing a function to find the contiguous subarray within a 1D array of numbers which has the largest product. To demonstrate your understanding of the dynamic programming approach presented, your implementation should efficiently handle any array of numbers, including negative and zero values. # Function Signature ```python def max_product(nums: List[int]) -> int: :type nums: List[int] :rtype: int pass ``` # Input - A list of integers `nums` where `1 <= len(nums) <= 10^4` and `-10^4 <= nums[i] <= 10^4`. # Output - An integer representing the largest product of any contiguous subarray. # Constraints - You must achieve a solution with ( O(n) ) time complexity. - Your function should handle zero values and negative numbers efficiently. # Examples 1. **Example 1**: ```python max_product([2,3,-2,4]) ``` *Output*: `6` (The subarray `[2, 3]` has the largest product). 2. **Example 2**: ```python max_product([-2,0,-1]) ``` *Output*: `0` (The subarray `[0]` has the largest product). 3. **Example 3**: ```python max_product([-3,-1,-1]) ``` *Output*: `3` (The subarray `[-3, -1]` has the largest product). # Instructions 1. Implement the `max_product` function as per the provided signature. 2. Ensure your solution is optimized for time and space complexity. 3. Consider edge cases such as arrays of length 1, arrays with all negative numbers, arrays containing zero, etc.","solution":"from typing import List def max_product(nums: List[int]) -> int: Returns the largest product of any contiguous subarray. if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"# Scenario Imagine you are developing a system for sorting scores of a large-scale competitive programming event. The scores are integers that can be both positive and negative. To efficiently manage this task, particularly for large datasets and considering the specific nature of score values, a specialized algorithm like Counting Sort needs to be implemented. # Task Write a Python function `sort_scores(scores: List[int]) -> List[int]` that sorts the given list of scores using the Counting Sort algorithm. # Function Signature ```python def sort_scores(scores: List[int]) -> List[int]: ``` # Input - `scores`: A list of integers that represent scores which might include negative values. # Output - Returns a sorted list of integers. # Constraints - The range of scores will be reasonably small, i.e., the maximum difference between the highest and lowest score will not exceed 10^5. - The list length, `n`, will be at most 10^6. # Example ```python assert sort_scores([4, 2, -1, 6, 0, -3, 5]) == [-3, -1, 0, 2, 4, 5, 6] assert sort_scores([1, 4, 1, 2, 7, 5, 2]) == [1, 1, 2, 2, 4, 5, 7] ``` # Requirements - The solution must use Counting Sort as the underlying algorithm. - Handle negative values correctly by adjusting the temporary array accordingly. - Ensure that the function is optimized for both time and space complexity, maintaining a balance based on the given constraints.","solution":"def sort_scores(scores): if not scores: return [] # Find the maximum and minimum values max_score = max(scores) min_score = min(scores) # Calculate the range of scores score_range = max_score - min_score + 1 # Initialize the count array count = [0] * score_range # Offset for counting negative scores offset = -min_score # Fill the count array for score in scores: count[score + offset] += 1 # Build the sorted list sorted_scores = [] for i in range(score_range): sorted_scores.extend([i - offset] * count[i]) return sorted_scores"},{"question":"# Task You have been hired by a game development company to assist with algorithm problems that will influence the gameplay\'s puzzle mechanics. One of the game characters needs to climb a stairwell to reach the next level, but the character can either move up one step or two steps at a time. The total number of steps varies between levels. Your task is to implement a function that calculates the number of distinct ways the character can reach the top of the stairwell. # Function Signature ```python def distinct_ways_to_climb(steps: int) -> int: pass ``` # Input * `steps` (int): The total number of steps the character must climb, 1 ≤ steps ≤ 10^5. # Output * (int): The number of distinct ways to reach the top of the stairs. # Constraints * Minimum value for `steps` is 1. * Maximum value for `steps` will be 10^5. # Performance Requirements * Your solution should have a time complexity of O(n). * Your solution should have a space complexity of O(1). # Example ```python assert distinct_ways_to_climb(2) == 2 assert distinct_ways_to_climb(3) == 3 assert distinct_ways_to_climb(5) == 8 ``` # Explanation 1. For `steps = 2`: There are 2 ways: (1+1) or (2). 2. For `steps = 3`: There are 3 ways: (1+1+1), (1+2), or (2+1). 3. For `steps = 5`: There are 8 ways: (1+1+1+1+1), (1+1+1+2), (1+1+2+1), (1+2+1+1), (2+1+1+1), (1+2+2), (2+1+2), or (2+2+1).","solution":"def distinct_ways_to_climb(steps: int) -> int: if steps == 1: return 1 elif steps == 2: return 2 # Initialize base values one_step_before = 2 two_steps_before = 1 # Calculate distinct ways for each step from 3 to steps for i in range(3, steps + 1): current_step = one_step_before + two_steps_before two_steps_before = one_step_before one_step_before = current_step return one_step_before"},{"question":"Scenario You are developing a text analysis tool that categorizes words based on the row of the American keyboard they can be typed on. To ensure that the words are categorized correctly, you need to write a function that identifies and returns the words which can be typed using letters from only one row of the keyboard. Question Write a function `find_keyboard_row(words)` that takes a list of words and returns the list of words that can be typed using letters from only one row on the American keyboard. Specifications - **Input**: A list of strings `words`, where each string represents a word. * Example: `[\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]` - **Output**: A list of strings, representing words that can be typed using letters from only one row on the keyboard. * Example: `[\\"Alaska\\", \\"Dad\\"]` - **Constraints**: The input words consist of alphabetical characters only. Case-insensitivity should be maintained (i.e., \'a\' and \'A\' should be treated the same). Performance Requirements - Optimize your function to minimize unnecessary checks. - Ensure the solution is efficient with respect to both time and space complexity. Additional Requirements - You are encouraged to handle edge cases, such as: * Words with characters not fitting any row (though per constraints alphabets are guaranteed) * Handling mixed-case inputs correctly. Function Signature ```python def find_keyboard_row(words): :type words: List[str] :rtype: List[str] ```","solution":"def find_keyboard_row(words): Returns the list of words that can be typed using letters from only one row of the keyboard. :param words: List of strings where each string represents a word :return: List of words that can be typed using letters from only one row of the keyboard rows = [ set(\'qwertyuiop\'), # Top row set(\'asdfghjkl\'), # Home row set(\'zxcvbnm\') # Bottom row ] result = [] for word in words: lower_word = word.lower() for row in rows: if all(char in row for char in lower_word): result.append(word) break return result"},{"question":"String Reversal Background Given different approaches to reverse a string, implement a specific method to demonstrate your understanding of string manipulation, recursion, and iterative loops. Task Implement the function `reverse_string(s: str) -> str` that takes a string `s` and returns the reversed string. You are required to use an iterative approach to avoid recursion limits and optimize space usage. Input * A string `s` where `0 <= len(s) <= 1000`. Output * A string that is the reverse of `s`. Function Signature ```python def reverse_string(s: str) -> str: # Your code here ``` Constraints * Do not use built-in functions like `reversed` or slicing (`[::-1]`). Example ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"world\\") == \\"dlrow\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"a\\") == \\"a\\" ``` Notes Consider edge cases such as empty strings and single character strings. Ensure your solution is optimized for both performance and readability. **Hint**: You can use a list to facilitate character swapping as strings in Python are immutable.","solution":"def reverse_string(s: str) -> str: Reverses the given string using an iterative approach. Parameters: s (str): The string to reverse. Returns: str: The reversed string. # Convert the string to a list to facilitate character swaps char_list = list(s) left, right = 0, len(char_list) - 1 # Swap characters until left index is less than right index while left < right: char_list[left], char_list[right] = char_list[right], char_list[left] left += 1 right -= 1 # Convert the list back to a string and return it return \'\'.join(char_list)"},{"question":"# **Bitwise Addition Simulator** **Objective:** Implement a function that adds two positive integers using bitwise operations, similar to how the underlying hardware might perform addition without using the \'+\' operator. **Input Format:** - Two positive integers, a and b. **Output Format:** - A single integer representing the sum of a and b. **Constraints:** - 1 <= a, b <= 10^9 **Performance Requirements:** - The solution should be efficient in terms of both time and space, leveraging bitwise operations to achieve the addition. **Function Signature:** ```python def add_bitwise_operator(x: int, y: int) -> int: pass ``` **Example Scenario:** Imagine you are working on an embedded system that does not support direct addition operation. Instead, you need to use bitwise operations which are supported by hardware. Your task is to implement an adding function using these operations. **Example:** ```python assert add_bitwise_operator(2, 3) == 5 assert add_bitwise_operator(10, 22) == 32 assert add_bitwise_operator(0, 0) == 0 ``` **Hints:** 1. Use the XOR operation to sum the bits without carry. 2. Use the AND operation and left shift to calculate the carry.","solution":"def add_bitwise_operator(x: int, y: int) -> int: while y != 0: carry = x & y x = x ^ y y = carry << 1 return x"},{"question":"# RSA Encryption and Decryption Implementation You have been provided with an implementation of the key generation algorithm for the RSA encryption system. Your task is to write two functions `encrypt_message` and `decrypt_message` that utilize the provided RSA system to encrypt and decrypt textual data. Additionally, implement a function `generate_keys` to generate the required RSA keys. # Problem Statement Implement the following functions: 1. `generate_keys(k: int) -> (int, int, int)`: - Input: an integer `k` representing the bit-length of the RSA modulus `n`. - Output: a tuple containing three integers `(n, e, d)` representing the RSA modulus, encryption exponent, and decryption exponent respectively. 2. `encrypt_message(message: str, e: int, n: int) -> list`: - Input: a string `message` to be encrypted, and the public key components `e` and `n`. - Output: a list of encrypted integers representing the encrypted message. 3. `decrypt_message(encrypted_message: list, d: int, n: int) -> str`: - Input: a list of integers `encrypted_message` representing the encrypted message, and the private key components `d` and `n`. - Output: the decrypted original string message. # Constraints - The function `generate_keys` should be able to handle `k` up to 1024 bits effectively. - The message text will consist of ASCII characters with byte values between 0 and 255. - The encryption and decryption should work correctly for messages of arbitrary length. # Performance Requirements - The encryption and decryption functions must make use of the RSA properties efficiently. - Make sure to handle conversion of text to integer representation and vice versa properly to ensure data integrity during encryption and decryption. # Example ```python # Generating RSA keys n, e, d = generate_keys(16) # Encrypting message message = \\"hello\\" encrypted_message = encrypt_message(message, e, n) print(encrypted_message) # Decrypting message decrypted_message = decrypt_message(encrypted_message, d, n) print(decrypted_message) # Output should be \\"hello\\" ```","solution":"import random from sympy import randprime, mod_inverse def generate_keys(k: int): Generate RSA keys of bit-length k. Returns: tuple: (n, e, d) where n: modulus e: public exponent d: private exponent # Generate two distinct prime numbers p and q p = randprime(2**(k//2-1), 2**(k//2)) q = randprime(2**(k//2-1), 2**(k//2)) while p == q: q = randprime(2**(k//2-1), 2**(k//2)) n = p * q phi = (p - 1) * (q - 1) # Choose e e = random.randint(2, phi - 1) while gcd(e, phi) != 1: e = random.randint(2, phi - 1) # Compute d d = mod_inverse(e, phi) return (n, e, d) def encrypt_message(message: str, e: int, n: int) -> list: Encrypt the message using public key components. message_bytes = message.encode(\'utf-8\') encrypted_message = [pow(byte, e, n) for byte in message_bytes] return encrypted_message def decrypt_message(encrypted_message: list, d: int, n: int) -> str: Decrypt the message using private key components. decrypted_bytes = [pow(byte, d, n) for byte in encrypted_message] decrypted_message = bytes(decrypted_bytes).decode(\'utf-8\') return decrypted_message def gcd(a, b): while b != 0: a, b = b, a % b return a"},{"question":"# Problem Description You are given a list of unique integers ranging from 0 to n (inclusive). The list contains n unique numbers in random order from the range 0 to n+1 (inclusive) missing exactly one number. Your task is to write a function that returns the missing number in the sequence. If the list has all numbers in the range, return the next number in the sequence. Implement a function `find_missing_number(nums: List[int]) -> int` to solve this problem. # Input * A list of integers `nums` of unique integers ranging from 0 to n+1 including both bounds. # Output * Return the missing integer from the sequence. If all numbers are present, return the next integer in the sequence. # Constraints * The length of the input list will be in the range [0, 10^6]. * Every integer in the list is unique and lies in the range [0, n+1], where n is the length of the list. # Example 1. **Input**: `nums = [4, 1, 3, 0, 6, 5, 2]` - **Output**: `7` 2. **Input**: `nums = [0, 1, 2, 3, 4, 5]` - **Output**: `6` 3. **Input**: `nums = []` - **Output**: `0` 4. **Input**: `nums = [6, 2, 4, 3, 0, 1, 5]` - **Output**: `7` Write a solution considering two methods shown in the given code snippets ensuring you handle all edge cases and provide valid and efficient implementations.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds and returns the missing number in the sequence. If all numbers are present, return the next number in the sequence. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Context: You are working on a data validation tool that can quickly detect discrepancies in transmitted data. Specifically, you need to find the additional character that was accidentally inserted in the transmission process. # Question: Write a function `find_difference(s, t)` that takes in two strings, `s` and `t`, where `t` is generated by shuffling the characters of `s` and adding one additional character at a random position. Your task is to determine and return the character that was added to `t`. Input: - `s` (string): A string consisting of lowercase letters. - `t` (string): A string consisting of lowercase letters, which is a result of shuffling `s` and adding one extra character. Output: - A character (string of length 1) that represents the added extra character in `t`. Constraints: - Both strings `s` and `t` consist of only lowercase English letters. - The length of `t` is `len(s) + 1`. Examples: Example 1: ```python s = \\"abcd\\" t = \\"abecd\\" Output: \'e\' ``` Example 2: ```python s = \\"\\" t = \\"y\\" Output: \'y\' ``` Example 3: ```python s = \\"a\\" t = \\"ab\\" Output: \'b\' ``` # Explanation: - Use the XOR operation to solve this problem efficiently. - Iterate through the concatenated string of `s` and `t`. - XOR each character\'s ASCII value, resulting in the ASCII value of the added character after processing all characters.","solution":"def find_difference(s, t): Returns the character that was added to t, which is s with one additional character. result = 0 for char in s + t: result ^= ord(char) return chr(result)"},{"question":"# Binary Exponentiation Objective You are required to implement the binary exponentiation algorithm both iteratively and recursively. Your solution should compute `a` raised to the power of `n`, optionally taken modulo `mod`. The main objective of this problem is to assess your understanding of efficient power computation techniques. Problem Statement You need to implement two functions, `power_iter(a: int, n: int, mod: int = None)` and `power_recur(a: int, n: int, mod: int = None)`, that compute the expression `a^n`: 1. If `mod` is provided, return the result as `(a^n) % mod`. 2. Without `mod`, just return `a^n`. **Function Signatures**: ```python def power_iter(a: int, n: int, mod: int = None) -> int: pass def power_recur(a: int, n: int, mod: int = None) -> int: pass ``` Input/Output Examples 1. **Input**: `a = 2, n = 10, mod = None` **Output**: `1024` 2. **Input**: `a = 2, n = 10, mod = 1000` **Output**: `24` 3. **Input**: `a = 3, n = 5, mod = None` **Output**: `243` 4. **Input**: `a = 3, n = 5, mod = 100` **Output**: `43` 5. **Input**: `a = 0, n = 5, mod = 1000` **Output**: `0` 6. **Input**: `a = 5, n = 0, mod = 1000` **Output**: `1` Constraints: 1. `0 <= a <= 10^5` 2. `0 <= n <= 10^9` 3. `1 <= mod <= 10^9` (if applicable) Notes: - Assume inputs will always be integers. - Consider potential edge cases and opt for efficient solutions.","solution":"def power_iter(a: int, n: int, mod: int = None) -> int: Computes a^n (mod mod) using iterative binary exponentiation. result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 return result def power_recur(a: int, n: int, mod: int = None) -> int: Computes a^n (mod mod) using recursive binary exponentiation. if n == 0: return 1 half_power = power_recur(a, n // 2, mod) half_power = half_power * half_power if mod is None else (half_power * half_power) % mod if n % 2 == 0: return half_power else: return half_power * a if mod is None else (half_power * a) % mod"},{"question":"**Question**: You are working on software that processes arithmetic operations on large non-negative integers represented as arrays of digits. You are required to implement a function that increments such an integer by one. Implement a function `plus_one` that takes a list of integers `digits` where each element in the list represents a single digit of a larger integer. The digits are stored in big-endian order, i.e., the most significant digit is at the head of the list. # Input * `digits`: A list of single-digit integers, representing a non-negative number in big-endian order. # Output * A list of single-digit integers representing the incremented number. # Constraints * The list `digits` will not be empty. * Each element in the list will be a single digit, i.e., between 0 and 9 inclusive. * You must handle large numbers that may require carry-over beyond the most significant digit. # Example ```python # Example 1: # Input: [1, 2, 3] # Output: [1, 2, 4] # Explanation: The initial number is 123. After adding one, it becomes 124. # Example 2: # Input: [9, 9, 9] # Output: [1, 0, 0, 0] # Explanation: The initial number is 999. After adding one, it becomes 1000. ``` # Function Signature ```python def plus_one(digits: List[int]) -> List[int]: pass ``` # Restrictions * You may not use libraries or functions that directly support arbitrary-precision arithmetic for this task. * Try to optimize for both time and space complexity as much as possible.","solution":"def plus_one(digits): Increments the number represented by the list of digits by one. Args: digits (list of int): A list of single-digit integers representing a non-negative number in big-endian order. Returns: list of int: A list of single-digit integers representing the incremented number. n = len(digits) # Traverse the list from the last element to the first for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all digits are 9, the result becomes a number with one more digit, a `1` followed by n `0`s. return [1] + [0] * n"},{"question":"You are developing a software system that handles a variety of numerical operations. One of the functionalities you need to implement is to determine the number of digits in an integer, which is often needed for data validation and processing purposes. Task Write a function `num_digits(n: int) -> int` that calculates the number of digits in an integer `n`. Input & Output - **Input**: An integer `n` where ( -10^{18} leq n leq 10^{18} ). - **Output**: An integer representing the number of digits in `n`. Constraints - The function should handle negative numbers by considering their absolute values. - Ensure correct output for the integer zero. Example Here are a few examples to illustrate the expected output: ```python assert num_digits(12345) == 5 assert num_digits(-123) == 3 assert num_digits(0) == 1 assert num_digits(1000000000) == 10 assert num_digits(-999999999999999999) == 18 ``` Performance Requirements - The implemented function should run in constant time, O(1), as the asymptotic time complexity. - Space complexity should also be O(1). Context Consider the scenario where you need to validate numerical inputs for correctness in a financial application, and exact digit count influences transaction processing rules. Implement this core utility function that ensures efficiency and accuracy under all defined constraints.","solution":"def num_digits(n: int) -> int: Returns the number of digits in an integer n. Args: n: An integer whose number of digits is to be calculated. Returns: An integer representing the number of digits in n. if n == 0: return 1 return len(str(abs(n)))"},{"question":"Two Sum Problem Overview You are given an array of integers and a target integer. Your task is to find the two indices of the array such that the corresponding values add up to the target. Each input will have exactly one solution, and the same element cannot be used twice. Function Signature ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: pass ``` Input * **array**: A list of integers, where 2 <= len(array) <= 10^4 and -10^9 <= array[i] <= 10^9. * **target**: An integer, -10^9 <= target <= 10^9. Output * A tuple (i, j) where array[i] + array[j] == target and 0 <= i < j < len(array). Constraints * Each input will have exactly one solution. * Indices i and j must be distinct. Performance Requirements The solution should aim for a time complexity of O(n) and space complexity of O(n). Example ```python # Example 1: array = [2, 7, 11, 15] target = 9 # Explanation: because array[0] + array[1] = 2 + 7 = 9, the function should return (0, 1). # Example 2: array = [3, 2, 4] target = 6 # Explanation: because array[1] + array[2] = 2 + 4 = 6, the function should return (1, 2). # Example 3: array = [3, 3] target = 6 # Explanation: because array[0] + array[1] = 3 + 3 = 6, the function should return (0, 1). ``` Notes Remember to handle the edge cases, particularly: * Arrays with negative numbers. * Minimal array lengths (e.g., arrays with 2 elements). * Ensure your function does not use the same element twice. Write your own implementation to find the solution, ensuring it meets the constraints and performance requirements.","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers in the array that add up to the target. Each input will have exactly one solution, and the same element cannot be used twice. Parameters: array (List[int]): The list of integers. target (int): The target integer. Returns: Tuple[int, int]: A tuple of two indices such that array[i] + array[j] == target. nums_map = {} for i, num in enumerate(array): complement = target - num if complement in nums_map: return (nums_map[complement], i) nums_map[num] = i # Example usage # array = [2, 7, 11, 15] # target = 9 # print(two_sum(array, target)) # Expected output: (0, 1)"},{"question":"# Task Write a function named `delete_reoccurring_characters` that takes a string as input and returns a new string with all the reoccurring characters removed while retaining the order of first occurrences of each character. # Function Signature ```python def delete_reoccurring_characters(string: str) -> str: ``` # Input * A string `string` consists of lowercase English letters (1 ≤ len(string) ≤ 10^5). # Output * A string with all reoccurring characters removed, preserving the order of their first occurrences. # Example ```python assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"bookkeeper\\") == \\"bokepr\\" assert delete_reoccurring_characters(\\"abcabcabc\\") == \\"abc\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" ``` # Constraints * The input string length will not exceed 100,000 characters. * The function should aim for a time complexity of O(n) and a space complexity of O(n). **Scenario**: You are preparing the unique identifier sequence for a list of users based on their names. To ensure no duplicate characters while keeping the initial order, you decide to remove all reoccurring characters. Implement the function to automate this process.","solution":"def delete_reoccurring_characters(string: str) -> str: Returns a new string with all reoccurring characters removed, keeping only the first occurrence of each character. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Programming Assessment Question Context and Task You have been given the task to implement a Bucket Sort algorithm to sort an array of floating point numbers efficiently. You are required to distribute the elements of the array into a suitable number of buckets, sort the individual buckets, and finally merge them to produce the sorted array. Function Signature ```python def bucket_sort(arr: List[float]) -> List[float]: ``` Input * `arr`: A list of floating point numbers `arr` (0 <= len(arr) <= 10^5, 0.0 <= arr[i] <= 1.0 for each `i`) Output * A list of the input numbers sorted in ascending order. Constraints and Requirements * You must use bucket sort as the primary sorting method. * You may assume that the floating point numbers are in the range [0.0, 1.0). * You must write and use an insertion sort for sorting individual buckets. * The final time complexity should be better than O(n log n) for average case scenarios. Example ```python assert bucket_sort([0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]) == [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ``` Your implementation will be evaluated on: * Correctness: Sorting the array accurately. * Efficiency: Handling large arrays within reasonable time limits. * Code quality: Clarity and organization of code.","solution":"from typing import List def insertion_sort(bucket: List[float]) -> List[float]: Function to perform insertion sort on the bucket. for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and bucket[j] > key: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket def bucket_sort(arr: List[float]) -> List[float]: Function to sort an array of floating point numbers using Bucket Sort. if len(arr) == 0: return arr # Create n empty buckets where n is the length of the input list n = len(arr) buckets = [[] for _ in range(n)] # Put array elements in different buckets for num in arr: index = int(n * num) # Index in bucket buckets[index].append(num) # Sort individual buckets for bucket in buckets: bucket = insertion_sort(bucket) # Concatenate all sorted buckets sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"Enhanced Insertion Sort with Early Exit **Context**: You\'ve just learned about the Insertion Sort algorithm. While it\'s effective for small and nearly sorted datasets, its quadratic time complexity makes it less suitable for larger or completely unsorted datasets. One optimization is to add an early exit if the array becomes sorted before the algorithm completes all iterations. # Task: Write a function `enhanced_insertion_sort(arr)` that sorts an array of integers using an optimized version of the Insertion Sort algorithm. The function should exit early if it detects that the array is already sorted during the sorting process. # Requirements: - Function name: `enhanced_insertion_sort` - Input: A list of integers, e.g., `arr = [4, 3, 2, 10, 12, 1, 5, 6]` - Output: A sorted list of integers, e.g., `[1, 2, 3, 4, 5, 6, 10, 12]` - If the input is an empty list, return an empty list. - Implement the early exit optimization to improve performance when possible. - Ensure the algorithm remains stable and in-place. # Constraints: - The input array can contain 0 to 1000 integers. - Each integer in the array can be between -10^6 and 10^6. # Performance Requirements: - The optimized function should have a better average performance for nearly sorted arrays compared to the standard O(n^2) Insertion Sort. # Example: ```python def enhanced_insertion_sort(arr): # Your implementation here # Test case print(enhanced_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6])) # Output: [1, 2, 3, 4, 5, 6, 10, 12] ``` # Edge Cases to Consider: 1. Empty list 2. Single-element list 3. List with all elements the same 4. Already sorted list 5. Reverse sorted list *Note*: Focus on the early exit strategy to optimize the Insertion Sort without compromising its in-place and stable properties.","solution":"def enhanced_insertion_sort(arr): Sorts a list of integers using an optimized version of the Insertion Sort algorithm. The optimization involves an early exit if the array is already sorted. :param arr: List of integers to be sorted :return: Sorted list of integers n = len(arr) if n == 0: return arr for i in range(1, n): key = arr[i] j = i - 1 # Insert arr[i] into the sorted sequence arr[0...i-1] while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Early exit check: if no elements were moved, array is already sorted if arr[i] >= arr[i - 1]: continue return arr"},{"question":"# Matrix Chain Multiplication Optimization Context Given a sequence of matrices, find the most efficient way to multiply these matrices together. The problem is to determine the order of matrix multiplications to minimize the total number of scalar multiplications. The `matrix_chain_order` function provided computes this optimal order using a dynamic programming approach, but we need a more efficient output representation. Task 1. Implement a function `optimal_matrix_chain_order` that takes a list of matrix dimensions and returns the minimal number of scalar multiplications needed. 2. Implement a function `optimal_parenthesization` that takes the solution matrix from `matrix_chain_order` and returns the optimal parenthesization of matrix multiplications as a string. Function Signatures ```python def optimal_matrix_chain_order(dimensions: List[int]) -> int: pass def optimal_parenthesization(optimal_solution: List[List[int]], i: int, j: int) -> str: pass ``` Input - **optimal_matrix_chain_order**: A list `dimensions` of integers where the dimensions[i] represents the number of rows in the ith matrix and dimensions[i+1] represents the number of columns in the ith matrix. - **optimal_parenthesization**: A 2D list `optimal_solution` representing the solution matrix from `matrix_chain_order`, and integers `i` and `j` indicating the matrix indices. Output - **optimal_matrix_chain_order**: An integer representing the minimal number of scalar multiplications. - **optimal_parenthesization**: A string representing the optimal parenthesization of the matrix multiplications. Constraints - 2 <= len(dimensions) <= 100 - Dimensions are positive integers. Example ```python from typing import List def optimal_matrix_chain_order(dimensions: List[int]) -> int: n = len(dimensions) matrix = [[0 for x in range(n)] for x in range(n)] sol = [[0 for x in range(n)] for x in range(n)] INF = float(\\"inf\\") for chain_length in range(2, n): for a in range(1, n-chain_length+1): b = a + chain_length - 1 matrix[a][b] = INF for c in range(a, b): cost = (matrix[a][c] + matrix[c + 1][b] + dimensions[a-1] * dimensions[c] * dimensions[b]) if cost < matrix[a][b]: matrix[a][b] = cost sol[a][b] = c return matrix[1][n-1] def optimal_parenthesization(optimal_solution: List[List[int]], i: int, j: int) -> str: if i == j: return f\\"A{i}\\" else: return f\\"({optimal_parenthesization(optimal_solution, i, optimal_solution[i][j])} * {optimal_parenthesization(optimal_solution, optimal_solution[i][j]+1, j)})\\" # Example Dimensions dimensions = [30, 35, 15, 5, 10, 20, 25] print(\\"Minimum number of operations:\\", optimal_matrix_chain_order(dimensions)) matrix, sol = [[0 for x in range(len(dimensions))] for x in range(len(dimensions))], [[0 for x in range(len(dimensions))] for x in range(len(dimensions))] # Placeholder for solution optimal_matrix_chain_order(dimensions) # this function also fills the sol matrix correctly print(\\"Optimal Parenthesization:\\", optimal_parenthesization(sol, 1, len(dimensions)-1)) # Expected Output: # Minimum number of operations: 15125 # Optimal Parenthesization: ((A1 * (A2 * A3)) * ((A4 * A5) * A6)) ```","solution":"from typing import List def optimal_matrix_chain_order(dimensions: List[int]) -> int: n = len(dimensions) - 1 matrix = [[0 for _ in range(n)] for _ in range(n)] sol = [[0 for _ in range(n)] for _ in range(n)] for chain_length in range(2, n+1): for i in range(n - chain_length + 1): j = i + chain_length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): cost = matrix[i][k] + matrix[k + 1][j] + dimensions[i] * dimensions[k + 1] * dimensions[j + 1] if cost < matrix[i][j]: matrix[i][j] = cost sol[i][j] = k return matrix, sol def optimal_parenthesization(optimal_solution: List[List[int]], i: int, j: int) -> str: if i == j: return f\\"A{i+1}\\" else: return f\\"({optimal_parenthesization(optimal_solution, i, optimal_solution[i][j])} * {optimal_parenthesization(optimal_solution, optimal_solution[i][j] + 1, j)})\\" def minimal_scalar_multiplications_and_order(dimensions: List[int]) -> (int, str): cost_matrix, solution_matrix = optimal_matrix_chain_order(dimensions) minimal_cost = cost_matrix[0][len(dimensions) - 2] optimal_order = optimal_parenthesization(solution_matrix, 0, len(dimensions) - 2) return minimal_cost, optimal_order"},{"question":"# Scenario You are working on a text processing tool that can decode strings encoded in a specific format. The encoding rule is represented as `k[encoded_string]`, where `encoded_string` within the square brackets is repeated exactly `k` times. You need to write a function that decodes such a string efficiently. # Task Implement a function `decode_string(s)` that takes a string `s` in the described encoding format and returns its decoded version. # Input - A single string `s` (1 ≤ |s| ≤ 30,000) composed of: - Lowercase English letters - Non-negative integers - Square brackets \'[\' and \']\' - The input is always properly formatted with square brackets well-formed, and non-numeric parts are only within brackets. # Output - Returns the decoded string following the described encoding rule. # Examples 1. `decode_string(\\"3[a]2[bc]\\")` should return `\\"aaabcbc\\"`. 2. `decode_string(\\"3[a2[c]]\\")` should return `\\"accaccacc\\"`. 3. `decode_string(\\"2[abc]3[cd]ef\\")` should return `\\"abcabccdcdcdef\\"`. # Performance Requirements - Your solution should efficiently handle the maximum input size. - Aim to achieve O(n) time complexity and O(n) space complexity where `n` is the length of the input string.","solution":"def decode_string(s): Decodes a string encoded in the k[encoded_string] format. stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str = \'\' current_num = 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"# Context A software engineer is building a text editor with an undo feature. To manage the changes efficiently, she decides to use a doubly linked list for the document\'s content. The text editor needs to support operations like appending text, deleting text at both the head and tail, and undoing recent changes. # Problem Implement a class `TextEditor` that uses a doubly linked list to manage the text. The class should support the following operations: 1. `append(string)`: Appends the string to the end of the document. 2. `delete(k)`: Deletes the last `k` characters from the document. 3. `undo()`: Undoes the last append or delete operation. # Constraints * The `append` and `delete` operations should have an average time complexity of O(1). * The text can only be appended as whole strings, and deletions can only occur from the end of the document. * Undo should revert only the most recent operation, whether it was an append or a delete. # Input and Output Formats 1. **append(string)** * **Input**: A string `string`. * **Output**: None 2. **delete(k)** * **Input**: An integer `k`. * **Output**: None. 3. **undo()** * **Input**: None. * **Output**: None. # Example ```python editor = TextEditor() editor.append(\\"hello\\") editor.append(\\" world\\") editor.delete(5) editor.undo() ``` After these operations, the content of the text editor should be \\"hello world\\".","solution":"class Node: def __init__(self, value=\'\'): self.value = value self.next = None self.prev = None class TextEditor: def __init__(self): self.head = Node() self.tail = self.head self.operations_stack = [] def append(self, string): new_node = Node(string) self.tail.next = new_node new_node.prev = self.tail self.tail = new_node # Save the operation to the stack self.operations_stack.append((\'append\', string)) def delete(self, k): if k <= 0: return deleted = \\"\\" current = self.tail while k > 0 and current != self.head: if len(current.value) <= k: deleted = current.value + deleted k -= len(current.value) current = current.prev current.next = None else: deleted = current.value[-k:] + deleted current.value = current.value[:-k] k = 0 self.tail = current self.operations_stack.append((\'delete\', deleted)) def undo(self): if not self.operations_stack: return last_action, last_value = self.operations_stack.pop() if last_action == \'append\': self.delete(len(last_value)) elif last_action == \'delete\': self.append(last_value) def get_content(self): content = \\"\\" current = self.head.next while current: content += current.value current = current.next return content"},{"question":"# Separate Chaining Hash Table Enhancement Objective Enhance the given `SeparateChainingHashTable` data structure to support dynamic resizing when the load factor (i.e., number of elements in the table divided by the number of buckets) exceeds a certain threshold. Dynamic resizing involves creating a larger table and rehashing all existing elements to the new table. Task 1. Implement a **resize** method in the `SeparateChainingHashTable` class that: * Doubles the size of the internal storage. * Rehashes all existing keys to the new internal storage. 2. Modify the `put` method to trigger resizing when the load factor exceeds 0.75. Inputs and Outputs * **Input**: Various key-value pairs for insertion using the `put` method. * **Output**: Must transparently handle insertions, adapting the internal structure as needed without user intervention. Function Signature ```python class SeparateChainingHashTable: def resize(self): # Your implementation here def put(self, key, value): # Modify this method to include the resize check ``` Constraints * Assume keys are hashable and values are any valid Python objects. * The hash table should dynamically resize upon exceeding the load factor threshold to maintain efficient performance. Performance Requirements * Aim to maintain average-case O(1) time complexity for insertion, deletion, and lookup even after resizing. Example ```python table = SeparateChainingHashTable(size=2) table.put(\'Apple\', 1) table.put(\'Banana\', 2) table.put(\'Orange\', 3) # Should trigger resize print(table.get(\'Apple\')) # Output: 1 print(table.get(\'Banana\')) # Output: 2 print(table.get(\'Orange\')) # Output: 3 ```","solution":"class SeparateChainingHashTable: def __init__(self, size=4): self.size = size self.buckets = [[] for _ in range(self.size)] self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.count += 1 if self.count / self.size > 0.75: self._resize() def get(self, key): index = self._hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def _resize(self): old_buckets = self.buckets self.size *= 2 self.buckets = [[] for _ in range(self.size)] self.count = 0 for bucket in old_buckets: for key, value in bucket: self.put(key, value)"},{"question":"You have been tasked to design a function that effectively calculates combinations (nCr) using memoization techniques. This function should be able to handle relatively large inputs with optimal performance. # Problem Statement You need to implement a function `optimized_combination(n, r)` which returns the number of ways to choose \'r\' items from \'n\' items using memoization. Additionally, provide an iterative version of the function `iterative_combination(n, r)`. # Function Signatures ```python def optimized_combination(n: int, r: int) -> int: Calculates nCr using a memoized recursive approach. Parameters: n (int): The total number of items. r (int): The number of items to choose. Returns: int: The number of combinations. def iterative_combination(n: int, r: int) -> int: Calculates nCr using an iterative approach. Parameters: n (int): The total number of items. r (int): The number of items to choose. Returns: int: The number of combinations. ``` # Constraints - (0 <= r <= n <= 1000) - Inputs will be non-negative integers. # Requirements 1. **Performance**: Each function must run efficiently given the constraint (0 <= n <= 1000). 2. Consider edge cases where (r = 0) or (r = n). 3. Ensure that the functions handle possible invalid inputs gracefully. # Example ```python assert optimized_combination(5, 2) == 10 assert optimized_combination(10, 5) == 252 assert iterative_combination(5, 2) == 10 assert iterative_combination(10, 5) == 252 ```","solution":"def optimized_combination(n, r): memo = {} def nCr(n, r): if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = nCr(n-1, r-1) + nCr(n-1, r) return memo[(n, r)] if r > n or n < 0 or r < 0: return 0 return nCr(n, r) def iterative_combination(n, r): if r > n or n < 0 or r < 0: return 0 r = min(r, n - r) # because C(n, r) == C(n, n - r) if r == 0: return 1 numerator = 1 denominator = 1 for i in range(1, r + 1): numerator *= (n - (i - 1)) denominator *= i return numerator // denominator"},{"question":"# Caesar Cipher Decoder The Caesar cipher is a classic encryption algorithm where each letter in the plaintext is shifted a certain number of places down the alphabet. In this exercise, you are required to implement a function that decrypts a string encoded using the Caesar cipher. Function Signature ```python def caesar_decode(s: str, k: int) -> str: ``` Input - `s` (str): The encoded string using a Caesar cipher (1 ≤ len(s) ≤ 10^4). - `k` (int): The shift used in the Caesar cipher (0 ≤ k ≤ 25). Output - Returns a decoded string that represents the original plaintext. Constraints - The string `s` contains only ASCII alphabetic characters and whitespace. - Whitespace and non-alphabetic characters should remain unchanged in the decoded output string. Example ```python assert caesar_decode(\\"Khoor Zruog\\", 3) == \\"Hello World\\" assert caesar_decode(\\"Defghijklmnopqrstuvwxyzabc\\", 3) == \\"Abcdefghijklmnopqrstuvwxyz\\" assert caesar_decode(\\"Bzdrzq Bhogdq\\", 25) == \\"Caesar Cipher\\" ``` Performance Requirements - The function should run efficiently within the given constraints. Implementation Details - Correctly handle upper and lower case letters. - Ensure non-alphabetic characters remain as they are in the input string. - Use modular arithmetic to achieve wrap-around effect for characters beyond \'a\' and \'z\'.","solution":"def caesar_decode(s: str, k: int) -> str: def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') - shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') - shift) % 26 + ord(\'A\')) else: return c decoded_str = \'\'.join(shift_char(c, k) for c in s) return decoded_str"},{"question":"Problem Statement You need to implement a function that finds the first occurrence of a target number in a sorted array of integers (arranged in increasing order) using an efficient algorithm. # Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: ``` # Input - `array`: A list of integers sorted in increasing order. - `query`: An integer value that needs to be searched in the array. # Output - Returns the index of the first occurrence of `query` in `array`. If the element is not present, return `-1`. # Constraints - The length of the array will be in the range [0, 10^5]. - The values of the elements in the array and the query will be integer values in the range [-10^9, 10^9]. # Example ```python assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 5) == 6 assert first_occurrence([1, 3, 5, 7], 4) == -1 ``` # Explanation - In the first example, the first occurrence of `2` in the array is at index `1`. - In the second example, the first occurrence of `5` in the array is at index `6`. - In the third example, `4` is not present in the array, so the function should return `-1`. # Note Ensure that the algorithm you implement is efficient and operates within the logarithmic time complexity.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Returns the index of the first occurrence of \'query\' in the sorted \'array\'. If \'query\' is not in the array, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid right = mid - 1 # look for earlier occurrence on the left side elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Word Search II You are given a 2D board of characters and a list of words. Write a function that returns a list of all words from the list that are present in the board. The words can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Function Signature ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: ``` Input - `board`: A 2D board represented as a list of lists of characters, `m x n` where `1 <= m, n <= 12`. - `words`: A list of strings representing the words to be searched, where all words have lengths between `1` and `10`. Output - A list of strings. Each string in the output list is a word from the input list that can be found in the board. The order of the returned words does not matter. Example ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] # Expected output: [\\"oath\\", \\"eat\\"] ``` Constraints - The characters in the board and words are all lowercase English letters. Guidelines - Utilize the trie data structure to manage the search space efficiently. - Implement a backtracking search to explore the board. - Ensure proper handling of edge cases, including empty inputs and non-matching word scenarios.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.word = None class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True node.word = word def find_words(board: List[List[str]], words: List[str]) -> List[str]: def dfs(node, i, j): char = board[i][j] if char not in node.children: return board[i][j] = \\"#\\" node = node.children[char] if node.is_end_of_word: result.add(node.word) for x, y in [(0,1), (1,0), (0,-1), (-1,0)]: ni, nj = i + x, j + y if 0 <= ni < len(board) and 0 <= nj < len(board[0]) and board[ni][nj] != \\"#\\": dfs(node, ni, nj) board[i][j] = char result = set() trie = Trie() for word in words: trie.insert(word) for i in range(len(board)): for j in range(len(board[0])): dfs(trie.root, i, j) return list(result)"},{"question":"# Rotating Matrix Problem You are working as a developer for a graphics software company. One of the tasks at hand is to rotate images efficiently. Each image is represented by an n x n matrix of integers, where each integer corresponds to the pixel value. Write a function **rotate_matrix(image: List[List[int]]) -> None** that takes an n x n matrix \'image\' and rotates it 90 degrees in-place (clockwise). # Function Signature ```python def rotate_matrix(image: List[List[int]]) -> None: ``` # Input - **image**: A list of n lists, each containing n integers (a square matrix). # Output - **None**. The function should modify the input matrix in place. # Constraints 1. 1 <= n <= 1000 2. -1000 <= image[i][j] <= 1000 # Examples Example 1: - **Input**: ```python image = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` - **Output**: ```python image = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Example 2: - **Input**: ```python image = [ [1] ] ``` - **Output**: ```python image = [ [1] ] ``` # Scenario In a high-paced game, the game board, represented by an n x n matrix, needs to be rotated 90 degrees for a particular game effect. Implement a solution that performs this rotation efficiently in real-time without using additional memory. # Performance Requirement Your solution should run in O(n^2) time complexity with O(1) additional space complexity.","solution":"from typing import List def rotate_matrix(image: List[List[int]]) -> None: Rotates the given n x n image matrix 90 degrees clockwise in-place. n = len(image) # Step 1: Transpose the matrix for i in range(n): for j in range(i + 1, n): image[i][j], image[j][i] = image[j][i], image[i][j] # Step 2: Reverse each row for i in range(n): image[i].reverse()"},{"question":"# In-order Traversal Iterator for Binary Search Tree **Context**: Imagine you have a Binary Search Tree (BST), and you need to traverse the elements in ascending order efficiently. Instead of using a recursive or iterative approach that visits all nodes at once, you want to employ an iterator that allows you to fetch the next smallest element when needed, using minimal extra space. **Task**: Implement the class `InOrderBSTIterator` that works as an iterator for the BST. This class should provide methods to check if there are more elements to visit and to get the next smallest element in the BST. # Requirements: 1. Implement the class `InOrderBSTIterator` with two methods `has_next()` and `next()`. 2. The `__init__` method should initialize the iterator with a given root of the BST. 3. The `has_next()` method should return a boolean indicating whether there are more elements to visit. 4. The `next()` method should return the next smallest element in the BST. # Input and Output Specifications: - **Input**: A `TreeNode` representing the root of the BST (definition provided below). - **Output**: The next smallest value in the BST as an integer. # Constraints: - The number of nodes in the tree will be in the range [0, (10^4)]. - The value of the nodes will be in the range [(-10^5), (10^5)]. # Performance: - The average time complexity for retrieving the next element should be (O(1)). - The space complexity should be (O(h)), where (h) is the height of the tree. # Example: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: # Construct a BST # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15, TreeNode(9), TreeNode(20)) # Initialize iterator iterator = InOrderBSTIterator(root) # Output print(iterator.next()) # returns 3 print(iterator.next()) # returns 7 print(iterator.has_next()) # returns True print(iterator.next()) # returns 9 ``` # Implementation: ```python class InOrderBSTIterator: def __init__(self, root): self.stack = [] while root: self.stack.append(root) root = root.left def has_next(self): return bool(self.stack) def next(self): node = self.stack.pop() val = node.val if node.right: node = node.right while node: self.stack.append(node) node = node.left return val ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class InOrderBSTIterator: def __init__(self, root): self.stack = [] self._push_left_branch(root) def _push_left_branch(self, node): while node: self.stack.append(node) node = node.left def has_next(self): return len(self.stack) > 0 def next(self): node = self.stack.pop() val = node.val if node.right: self._push_left_branch(node.right) return val"},{"question":"# Question: Implementing a Binary Search Tree Implement a `BinarySearchTree` class with the following functionalities: 1. **Insert a value** into the BST: If the value already exists, ignore the insertion. 2. **Search for a value** in the BST: Return `True` if the value exists, otherwise `False`. 3. **Delete a value** in the BST: Maintain the BST properties post-deletion. 4. **In-order traversal** of the BST: Return a list of values in ascending order. # Input Format: - A series of operations to be performed on the BST. Each operation is one of the following: * `insert value` * `search value` * `delete value` * `in_order` # Output Format: - For `search value` operation, output `True` or `False`. - For `in_order` operation, output a list of values in ascending order. # Constraints: - `value` is a non-negative integer. - Operations are provided as a list of strings. # Example: ``` bst = BinarySearchTree() operations = [\\"insert 5\\", \\"insert 3\\", \\"insert 7\\", \\"search 3\\", \\"search 8\\", \\"delete 3\\", \\"insert 6\\", \\"in_order\\"] # Perform the operations for operation in operations: op = operation.split() if op[0] == \\"insert\\": bst.insert(int(op[1])) elif op[0] == \\"search\\": print(bst.search(int(op[1]))) elif op[0] == \\"delete\\": bst.delete(int(op[1])) elif op[0] == \\"in_order\\": print(bst.in_order()) ``` # Expected Output: ``` True False [5, 6, 7] ``` # Implementation ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): self.root = self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if node is None: return TreeNode(val) if val < node.val: node.left = self._insert_recursive(node.left, val) elif val > node.val: node.right = self._insert_recursive(node.right, val) return node def search(self, val): return self._search_recursive(self.root, val) def _search_recursive(self, node, val): if node is None: return False if node.val == val: return True elif val < node.val: return self._search_recursive(node.left, val) else: return self._search_recursive(node.right, val) def delete(self, val): self.root = self._delete_recursive(self.root, val) def _delete_recursive(self, node, val): if node is None: return node if val < node.val: node.left = self._delete_recursive(node.left, val) elif val > node.val: node.right = self._delete_recursive(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete_recursive(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def in_order(self): result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node, result): if node: self._in_order_recursive(node.left, result) result.append(node.val) self._in_order_recursive(node.right, result) ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): self.root = self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if node is None: return TreeNode(val) if val < node.val: node.left = self._insert_recursive(node.left, val) elif val > node.val: node.right = self._insert_recursive(node.right, val) return node def search(self, val): return self._search_recursive(self.root, val) def _search_recursive(self, node, val): if node is None: return False if node.val == val: return True elif val < node.val: return self._search_recursive(node.left, val) else: return self._search_recursive(node.right, val) def delete(self, val): self.root = self._delete_recursive(self.root, val) def _delete_recursive(self, node, val): if node is None: return node if val < node.val: node.left = self._delete_recursive(node.left, val) elif val > node.val: node.right = self._delete_recursive(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete_recursive(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def in_order(self): result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node, result): if node: self._in_order_recursive(node.left, result) result.append(node.val) self._in_order_recursive(node.right, result)"},{"question":"# Question: Convert a Binary Search Tree to a Doubly Linked List Given a binary search tree, write a function to convert it into a doubly linked list in-place. The nodes in the doubly linked list should follow the in-order traversal sequence of the tree. Your implementation should not create new nodes but should reconfigure the existing node pointers to form the list. Function Signature ```python def bin_tree_to_list(root: TreeNode) -> TreeNode: pass ``` Input * `root` (TreeNode): The root node of a binary search tree. Each node has the properties: * `val` (int): The value of the node. * `left` (TreeNode): Pointer to the left child node. * `right` (TreeNode): Pointer to the right child node. * Additional pointers for doubly linked list management will also be used (`prev`, `next`). Output * The function should return the head node (the smallest element) of the converted doubly linked list. Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * `-10^6 <= Node.val <= 10^6` Example ```python # Example Tree structure: # 4 # / # 2 5 # / # 1 3 # Expected Doubly Linked List: # 1 <-> 2 <-> 3 <-> 4 <-> 5 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(5) head = bin_tree_to_list(root) while head: print(head.val, end=\\" <-> \\") head = head.right # Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> ``` You are to design an efficient and correct solution for converting a given binary search tree to a doubly linked list. The solution should maintain the inherent sorted order of elements in the BST. Good luck!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.prev = None # For DLL self.next = None # For DLL def bin_tree_to_list(root): Converts a binary search tree to a doubly linked list in place. Nodes in the doubly linked list follow in-order traversal sequence of the tree. def inorder(node): nonlocal last, head if not node: return # Traverse the left subtree inorder(node.left) if last: # Adjust the pointers for \'prev\' and \'next\' last.right = node node.left = last else: head = node # This node is the head of the DLL last = node # Update the last visited node # Traverse the right subtree inorder(node.right) last = None head = None inorder(root) return head"},{"question":"# Context You are working as an optimization engineer for a logistics company. Your task is to devise an optimal packing strategy for transporting valuable items with a weight limit constraint. You are given a set of items, each with a specified value and weight, and you need to determine the maximum value your knapsack can carry without exceeding the weight limit. # Task Implement a function `get_maximum_value` that calculates the maximum value of items that can fit into the knapsack without exceeding the capacity. # Input and Output - **Input**: - `items`: a list of `Item` objects, where each `Item` has `value` and `weight` attributes. - `capacity`: an integer representing the knapsack\'s weight capacity. - **Output**: - Return an integer representing the maximum value that can be achieved with the given items and capacity. # Constraints - `1 <= len(items) <= 1000` - `1 <= capacity <= 1000` - `1 <= item.value, item.weight <= 1000` # Example ```python class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items, capacity): dp = [0] * (capacity + 1) for item in items: for cur_weight in reversed(range(item.weight, capacity+1)): dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight]) return dp[capacity] # Example usage: # Capacity of the knapsack capacity = 5 # List of items with (value, weight) items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] print(get_maximum_value(items, capacity)) # Output: 80 ``` # Notes - Ensure that you consider edge cases such as an empty list of items or a knapsack with zero capacity. - Your solution should efficiently handle the provided constraints to avoid performance issues.","solution":"class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items, capacity): dp = [0] * (capacity + 1) for item in items: for cur_weight in reversed(range(item.weight, capacity + 1)): dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight]) return dp[capacity]"},{"question":"**Context**: You are tasked with developing a software component that processes a dataset containing words and symbols. Each word is to be searched for the presence of any symbols and the matched symbols must be enclosed within square brackets. If a word matches multiple symbols, use the symbol with the longest length. **Objective**: Write a function `process_words_with_symbols(words: List[str], symbols: List[str]) -> List[str]` that performs the described task. **Input**: - `words`: A list of strings, each string is a word (1 ≤ length of word ≤ 10^3). - `symbols`: A list of strings, each string is a symbol (1 ≤ length of symbol ≤ 100). **Output**: - A list of strings where each word has the longest matched symbol enclosed within square brackets. **Constraints**: - If a word matches multiple symbols, enclose the longest symbol in square brackets. - If no symbols match a word, return the word as is. - Performance should be efficient with respect to both time and space. **Performance Requirements**: - Optimize for both time and space complexity, considering large inputs. **Examples**: **Input**: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` **Output**: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` **Implementation**: Your solution should build a Trie with the symbols for efficient prefix matching and traverse through each word to find and replace the matching symbol. ```python class TreeNode: def __init__(self): self.children = {} self.symbol = None def process_words_with_symbols(words, symbols): # Building the Trie from symbols root = TreeNode() for symbol in symbols: node = root for char in symbol: if char not in node.children: node.children[char] = TreeNode() node = node.children[char] node.symbol = symbol results = [] for word in words: node = root longest_match = [0, 0, None] # [start, end exclusive, symbol] i = 0 while i < len(word): j = i temp_node = node while j < len(word) and word[j] in temp_node.children: temp_node = temp_node.children[word[j]] if temp_node.symbol: # Found a match, check if it\'s the longest match if j + 1 - i > longest_match[1] - longest_match[0]: longest_match = [i, j+1, temp_node.symbol] j += 1 i += 1 if longest_match[2]: start, end, symbol = longest_match word = word[:start] + \'[\' + symbol + \']\' + word[end:] results.append(word) return results ``` Ensure thorough testing of edge cases in your implementation and consider time-complexity for scalability.","solution":"class TreeNode: def __init__(self): self.children = {} self.symbol = None def process_words_with_symbols(words, symbols): Encloses the longest matching symbols within square brackets in each word. Args: words: List of strings, each string is a word. symbols: List of strings, each string is a symbol. Returns: List of strings where each word has the longest matched symbol enclosed within square brackets. # Build a Trie from the symbols root = TreeNode() for symbol in symbols: node = root for char in symbol: if char not in node.children: node.children[char] = TreeNode() node = node.children[char] node.symbol = symbol results = [] for word in words: longest_match = (None, None, None) # (start_index, end_index, symbol) for i in range(len(word)): node = root j = i while j < len(word) and word[j] in node.children: node = node.children[word[j]] if node.symbol and (longest_match[2] is None or len(node.symbol) > len(longest_match[2])): longest_match = (i, j + 1, node.symbol) j += 1 if longest_match[2]: start, end, symbol = longest_match word = word[:start] + \'[\' + symbol + \']\' + word[end:] results.append(word) return results"},{"question":"# Word Segmentation Problem You are provided with a non-empty string `text` and a set `wordDict` containing a list of non-empty words. Implement a function `word_break(text, wordDict)` that returns `True` if the string `text` can be segmented into a space-separated sequence of one or more dictionary words from `wordDict`. Otherwise, return `False`. # Input * `text`: A non-empty string containing one or more lowercase characters (1 <= len(text) <= 300). * `wordDict`: A set of lowercase non-empty dictionary words (1 <= len(wordDict) <= 1000). # Output * Return a boolean `True` or `False`. # Examples ```python assert word_break(\\"leetcode\\", {\\"leet\\", \\"code\\"}) == True assert word_break(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) == True assert word_break(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) == False ``` # Constraints * All the characters in `text` and `wordDict` will be lowercase English letters. * The dictionary will not contain duplicate words. * Do not modify the input before processing. # Detailed Requirements 1. Use dynamic programming to solve the problem. 2. The DP array should be initialized with `False` except for the first element which should be `True`. 3. Ensure time complexity is at most O(N^2). 4. The solution should handle edge cases such as empty dictionaries or strings that contain characters not in the dictionary. # Additional Information The function `word_break` should be implemented in Python and adhere to the following signature: ```python def word_break(text: str, wordDict: Set[str]) -> bool: # Implement the function here ``` **Tip**: Focus on an optimal usage of dynamic programming and ensure that your implementation can handle up to the upper limits of constraints efficiently.","solution":"def word_break(text, wordDict): Determine if the text can be segmented into a space-separated sequence of one or more dictionary words. dp = [False] * (len(text) + 1) dp[0] = True # An empty string can always be segmented for i in range(1, len(text) + 1): for j in range(i): if dp[j] and text[j:i] in wordDict: dp[i] = True break return dp[len(text)]"},{"question":"# Rotate Linked List You are given the head of a singly linked list and an integer `k`. Your task is to rotate the list to the right by `k` places. Input - The function `rotate_right(head, k)` where: - `head` is a ListNode representing the head of a singly linked list. - `k` is a non-negative integer representing the number of places to rotate the list to the right. Output - The function should return the head of the rotated list. Constraints - The number of nodes in the list is in the range `[0, 500]`. - `0 <= k <= 2 * 10^9`. # Requirements - Implement the `rotate_right` function that meets the provided signature. - Make sure to handle edge cases appropriately (e.g., empty list, single node list, no rotation needed). Example ``` Example 1: Input: head = [1, 2, 3, 4, 5], k = 2 Output: [4, 5, 1, 2, 3] Example 2: Input: head = [0, 1, 2], k = 4 Output: [2, 0, 1] ``` # Notes 1. Each ListNode has an integer value and a pointer to the next node. 2. To facilitate testing, you might want to write helper functions to easily construct a list from an array and to convert a list back to an array for result validation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head, k): Rotates the linked list to the right by k places. if not head or not head.next or k == 0: return head # Find the length of the list length = 1 current = head while current.next: current = current.next length += 1 # Make the list circular current.next = head # Find the point of rotation k = k % length if k == 0: current.next = None return head steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head # Helper function to create linked list from list def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): lst = [] while head: lst.append(head.val) head = head.next return lst"},{"question":"# Scenario You are working on a software project for a scientific computation module that heavily relies on matrix operations. As part of the project, you need to implement a feature that determines the state of a system after a series of transformations, each described by a transformation matrix. The order of transformations is given by a power of the transformation matrix. # Problem Statement Write a function `matrix_power(mat: list, power: int) -> list` that computes the power of a given square matrix `mat` raised to `power`. You should use the method of matrix exponentiation by squaring to ensure the solution is efficient. # Function Signature ```python def matrix_power(mat: list, power: int) -> list: pass ``` # Input * `mat`: A list of lists where each inner list represents a row of an n x n matrix. Each integer in the matrix will be within the range of -100 to 100. * `power`: A non-negative integer. # Output * Return the n x n matrix resulting from raising `mat` to the given `power`. # Constraints * The matrix `mat` will always be a square matrix with dimensions of at most 30 x 30. * The exponent `power` will be a non-negative integer, where `0 <= power <= 1000`. # Example ```python mat = [ [2, 0], [0, 2] ] power = 3 print(matrix_power(mat, power)) # Output: # [ # [8, 0], # [0, 8] # ] ``` # Notes * You can implement and use any helper functions (like matrix multiplication or identity matrix generation) as needed. * Consider edge cases such as power being 0 (the result should be the identity matrix) or non-square matrices (should raise an error).","solution":"def matrix_multiply(mat1, mat2): n = len(mat1) res = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): res[i][j] += mat1[i][k] * mat2[k][j] return res def identity_matrix(n): return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_power(mat, power): n = len(mat) if len(mat) != len(mat[0]): raise ValueError(\\"Input must be a square matrix.\\") result = identity_matrix(n) base = mat while power: if power % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) power //= 2 return result"},{"question":"You are working on a project that involves generating and analyzing binary search trees (BSTs). One of the tasks is to determine how many structurally unique BSTs can be formed using `n` distinct integers. Your goal is to implement a function that, given an integer `n`, calculates the number of structurally unique BSTs that can be constructed with integers from `1` to `n`. # Function Signature ```python def num_trees(n: int) -> int: pass ``` # Input - `n`: an integer (0 ≤ n ≤ 1000), representing the number of nodes in the BST. # Output - Returns an integer, the number of structurally unique BSTs. # Examples Example 1: ```python num_trees(3) ``` Output: ```plaintext 5 ``` Example 2: ```python num_trees(1) ``` Output: ```plaintext 1 ``` # Constraints 1. You must ensure that the solution runs efficiently within O(n^2) time complexity and O(n) space complexity. 2. Your implementation should handle edge cases like `n = 0` and return the correct results as specified above. # Notes 1. Remember that for `n = 0`, there is exactly one structural configuration, an empty tree. Hence, `num_trees(0)` should return 1. # Requirements Implement the `num_trees` function to compute the number of unique BST configurations using dynamic programming based on the Catalan number formula.","solution":"def num_trees(n: int) -> int: if n == 0: return 1 # dp[i] represents the number of unique BSTs that can be formed with i nodes dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for nodes in range(2, n + 1): total = 0 for root in range(1, nodes + 1): left = root - 1 right = nodes - root total += dp[left] * dp[right] dp[nodes] = total return dp[n]"},{"question":"# Coding Exercise **Objective**: You are tasked with writing a function that processes an input array by moving all zeros to the end while preserving the order of other elements. The function should modify the input array in place to conserve memory. **Function Signature**: ```python def move_zeros_in_place(array: list) -> None: Modify the input array in place to move all zeros to the end while maintaining the order of non-zero elements. ``` **Requirements**: - Modify the input array directly without using extra space proportional to the array size. - Ensure that False values and zero-like values (`[]`, `\\"\\"`, `()` etc.) are not treated as zeros. **Input and Output Format**: - **Input**: A list `array` of elements which can be of any type (e.g., `array=[False, 1, 0, \'a\']`). - **Output**: Modify the list in place with no return value (e.g., `array` should become `[False, 1, \'a\', 0]`). **Examples**: ```python array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_in_place(array) assert array == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] array = [0, 0, 0] move_zeros_in_place(array) assert array == [0, 0, 0] array = [1, 2, 3] move_zeros_in_place(array) assert array == [1, 2, 3] ``` **Constraints**: 1. Do not use a secondary list with the same length as input. 2. Aim for a time complexity of O(n).","solution":"def move_zeros_in_place(array: list) -> None: Modify the input array in place to move all zeros to the end while maintaining the order of non-zero elements. non_zero_index = 0 for i in range(len(array)): if array[i] != 0 or (array[i] is False): array[non_zero_index] = array[i] non_zero_index += 1 for i in range(non_zero_index, len(array)): array[i] = 0"},{"question":"You are given a non-negative large number represented as an array of digits. Each element in the array contains a single digit, and the array is ordered such that the most significant digit is at the head of the list. Write a function named `increment_digits` that takes a list of integers representing digits of this large number and returns a new list of integers where this number is incremented by one. Implement the function conforming to the specifications below: Function Signature ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` Input * A list of integers `digits` where each element is a single digit (0 <= digit <= 9). * The list `digits` will have at least one element and will not have any leading zeros unless the number is zero itself. Output * A list of integers representing the incremented number. Constraints * The size of the input list can be as large as your language\'s memory can handle practically. Performance Requirements * Your solution should handle the problem in linear time O(n) with minimal space overhead. # Examples 1. Example 1: ```python # Input digits = [4, 3, 2, 1] # Output print(increment_digits(digits)) # [4, 3, 2, 2] ``` 2. Example 2: ```python # Input digits = [9, 9, 9] # Output print(increment_digits(digits)) # [1, 0, 0, 0] ``` 3. Example 3: ```python # Input digits = [0] # Output print(increment_digits(digits)) # [1] ``` # Additional Context The goal of this problem is to assess your understanding of handling carry operations efficiently and manipulating large digit arrays without using built-in large number facilities. Focus on the correctness and efficiency of your implementation.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: Increment the large number represented as a list of digits by one. Args: digits (List[int]): The list of digits representing the number. Returns: List[int]: The incremented number represented as a list of digits. n = len(digits) # Start from the last digit and move towards the most significant digit for i in range(n-1, -1, -1): # If the current digit is less than 9, increment it and return the result if digits[i] < 9: digits[i] += 1 return digits # If the current digit is 9, set it to 0 digits[i] = 0 # If all the digits were 9, we need an extra digit at the beginning return [1] + digits"},{"question":"# Scenario You are a software engineer working on a digital signal processing library. One essential function that you need to optimize is the FFT (Fast Fourier Transform) algorithm. You\'ve decided to implement the Cooley-Tukey FFT algorithm due to its performance benefits when dealing with large datasets. # Task Implement an in-place (iterative) version of the FFT algorithm. Your function should handle arrays of complex numbers whose lengths are power of 2. The goal is to improve the space efficiency without compromising the time complexity. # Function to Implement ```python def in_place_fft(arr): Perform an in-place iterative Fast Fourier Transform on a list of complex numbers whose size is a power of 2. Args: arr (list): A list of complex numbers with length N (where N is a power of 2) Returns: None (the input list should be modified in place with its FFT transformation) pass ``` # Input: * A list `arr` of complex numbers, where the length of the list ( N ) is a power of 2 (( 1 leq N leq 1024 )). # Output: * The function modifies the input list `arr` in-place, so there is no need for it to return anything. After completion, `arr` should contain the FFT transformation of the input. # Example: ```python arr = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] in_place_fft(arr) # Now arr should be approximately [8+8j, 2j, 2-2j, -2+0j] ``` # Constraints: * The input list length will always be a power of 2. * You can assume the complex number arithmetic works as expected. # Performance Requirements: * The solution should maintain the time complexity of O(N log N). * The space complexity should be optimized by implementing in-place transformations.","solution":"from cmath import exp, pi def in_place_fft(arr): Perform an in-place iterative Fast Fourier Transform on a list of complex numbers whose size is a power of 2. Args: arr (list): A list of complex numbers with length N (where N is a power of 2) Returns: None (the input list should be modified in place with its FFT transformation) N = len(arr) if N <= 1: return # Bit-reversal permutation y = [0] * N for i in range(N): j = 0 for k in range(int(len(bin(N))-3)): j = (j << 1) | ((i >> k) & 1) y[j] = arr[i] for i in range(N): arr[i] = y[i] # Cooley-Tukey FFT step = 2 while step <= N: half_step = step // 2 exp_coeff = exp(-2j * pi / step) for k in range(0, N, step): coeff = 1 for j in range(half_step): u = arr[k + j] t = coeff * arr[k + j + half_step] arr[k + j] = u + t arr[k + j + half_step] = u - t coeff *= exp_coeff step *= 2"},{"question":"# Bucket Sort Implementation Background Context Bucket sort is a sorting algorithm that distributes the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or recursively applying the bucket sort itself. Finally, the sorted buckets are concatenated to form the final sorted array. This method can provide faster results than other sorting algorithms, depending on the distribution of the array elements. Problem Statement You are tasked to implement the `bucket_sort` function using the following specifications: 1. **Input**: A list of non-negative integers. 2. **Output**: A sorted list of integers in ascending order. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: # Your implementation here ``` Constraints * The input list can contain up to (10^5) elements. * Each element ( arr[i] ) is a non-negative integer and ( 0 leq arr[i] leq 10000 ). * Utilize the `next_sort` function provided, which uses Insertion Sort, to sort the elements within each bucket. # Implementation Requirements 1. Create a number of buckets proportional to the size of the input list. 2. Distribute elements from the input list into appropriate buckets. 3. Sort each bucket individually using the provided `next_sort` function. 4. Concatenate the sorted buckets to generate the output list. 5. Ensure efficient handling of edge cases such as empty input list or lists with identical elements. # Example ```python arr = [42, 32, 33, 52, 37, 47, 51] print(bucket_sort(arr)) # Output: [32, 33, 37, 42, 47, 51, 52] arr = [3, 6, 2, 1, 9] print(bucket_sort(arr)) # Output: [1, 2, 3, 6, 9] ``` # Notes - Carefully consider handling the distribution of elements especially when elements have a wide range or are clustered. - The provided `next_sort` function is crucial for bucket sorting; ensure accurate use. - Aim to optimize the bucket sorting approach without unnecessary overhead to handle large arrays.","solution":"from typing import List def next_sort(arr): A sample sorting function (insertion sort) for sorting each bucket. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[int]) -> List[int]: Sorts an array of non-negative integers using bucket sort algorithm. if not arr: return [] max_value = max(arr) size = len(arr) buckets = [[] for _ in range(size)] for i in range(size): index = int(arr[i] * size / (max_value + 1)) buckets[index].append(arr[i]) sorted_arr = [] for bucket in buckets: next_sort(bucket) sorted_arr.extend(bucket) return sorted_arr"},{"question":"You are provided with a data structure to store sparse vectors efficiently and a method to compute their dot product. Your task is to implement a function that converts a dense vector to a sparse representation and another function to compute the dot product of two sparse vectors. # Function Signatures ```python def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Convert dense vector to sparse representation. :param vector: List of floats representing the dense vector. :return: List of tuples (index, value) representing the sparse vector. def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Compute the dot product of two sparse vectors. :param iv_list1: List of tuples (index, value) representing the first sparse vector. :param iv_list2: List of tuples (index, value) representing the second sparse vector. :return: The dot product as a float. ``` # Input and Output * **Input**: - `vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]` * `vector`: A list of floats representing the dense vector. Length of the vector is `n` (1 <= n <= 10^6). - `dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float` * `iv_list1`: A list of tuples where each tuple contains an index and a value of the first sparse vector. * `iv_list2`: A list of tuples where each tuple contains an index and a value of the second sparse vector. * **Output**: - `vector_to_index_value_list()`: A list of tuples where each tuple represents the index and value of the non-zero elements from the input vector. - `dot_product()`: A float representing the dot product of two sparse vectors. # Constraints * The input vector for `vector_to_index_value_list` function can be very large with a majority of zero elements. * The dot product calculation should be efficient, iterating only over the non-zero elements. * Both functions should handle edge cases like empty vectors or vectors with all zero elements gracefully. # Example ```python # Example for vector_to_index_value_list print(vector_to_index_value_list([0.0, 1.0, 0.0, 0.0, 2.0])) # Output: [(1, 1.0), (4, 2.0)] # Example for dot_product iv_list1 = [(1, 1.0), (4, 2.0)] iv_list2 = [(1, 1.0), (4, 3.0)] print(dot_product(iv_list1, iv_list2)) # Output: 7.0 ``` # Performance Requirements * Your implementation should be efficient with respect to both time and space. * Aim to achieve a time complexity of O(k1 + k2) for the dot product and O(n) for sparse conversion, where k1 and k2 are the respective numbers of non-zero elements in the two vectors, and n is the length of the input dense vector. # Additional Notes * Handle the case where the input vectors have different lengths by aligning the index-value pairs correctly. * Edge cases such as vectors filled with zeroes or very large vectors should be considered.","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Convert dense vector to sparse representation. :param vector: List of floats representing the dense vector. :return: List of tuples (index, value) representing the sparse vector. sparse_vector = [(index, value) for index, value in enumerate(vector) if value != 0.0] return sparse_vector def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Compute the dot product of two sparse vectors. :param iv_list1: List of tuples (index, value) representing the first sparse vector. :param iv_list2: List of tuples (index, value) representing the second sparse vector. :return: The dot product as a float. index_value_map2 = {index: value for index, value in iv_list2} product_sum = sum(value * index_value_map2.get(index, 0.0) for index, value in iv_list1) return product_sum"},{"question":"You are tasked to design a function that helps in efficiently sorting a list of numbers using a modified version of insertion sort. The function `binary_search_insert` provided finds the right position for any given element in a sorted list. Using this helper function, implement a full insertion sort algorithm. # Function Signature ```python def insertion_sort(arr: list) -> list: pass ``` # Input * A list of integers `arr` (1 ≤ len(arr) ≤ 10^4). # Output * A list of integers sorted in non-decreasing order (ascending order). # Constraints 1. The list may contain duplicate values. 2. You are required to use the provided `search_insert` method within your sorting algorithm. 3. Aim for an efficient implementation considering the provided constraints. # Example Example 1 ``` Input: [4, 2, 7, 1, 3] Output: [1, 2, 3, 4, 7] ``` Example 2 ``` Input: [10, -1, 2, 5, 0] Output: [-1, 0, 2, 5, 10] ``` # Detailed Description * Use the `search_insert` helper function to determine the correct position for each new element in the list as you iterate through it. * For each element in the list, starting from the second, insert it into its correct position in the already sorted part of the list. * Ensure that the overall function maintains an O(n^2) time complexity for sorting, leveraging the O(log n) efficiency within inner operations. # Testing Make sure to test your function against various edge cases: 1. Empty array 2. Single-element array 3. Arrays with duplicates 4. Arrays sorted in reverse order Note: Your solution should not use any built-in sorting algorithms.","solution":"def binary_search_insert(sorted_list, value): A helper function that uses binary search to find the correct insert position for `value` within `sorted_list`. left, right = 0, len(sorted_list) while left < right: mid = (left + right) // 2 if sorted_list[mid] < value: left = mid + 1 else: right = mid return left def insertion_sort(arr: list) -> list: Sorts the input list `arr` using a modified version of insertion sort that utilizes binary search for finding the correct insert position. for i in range(1, len(arr)): value = arr[i] # Find the location to insert the element pos = binary_search_insert(arr[:i], value) # Move the elements to make room for the new element arr = arr[:pos] + [value] + arr[pos:i] + arr[i+1:] return arr"},{"question":"# Coding Task: Enhanced Interpolation Search with Error Handling You are given a sorted array of integers and a search key. Implement an enhanced version of the Interpolation Search algorithm that correctly handles edge cases and improves performance in certain scenarios. Additionally, your function should intelligently fallback to binary search when detecting poor performance. Your function should follow this signature: ```python from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. # Your code here ``` # Constraints 1. The array is sorted in ascending order. 2. The array length is (1 leq length leq 10^6). 3. The elements in the array are integers. 4. The search key is an integer. # Performance Requirements * Target time complexity: ( O(log log n) ) for uniformly distributed data. * Handle non-uniform data efficiently by falling back to binary search when necessary. * Ensure robust handling of edge cases and error scenarios. # Implementation Details * Start with Interpolation Search. * Evaluate if the search key lies within the minimum and maximum bounds of the array. * Implement a fallback mechanism to Binary Search in cases where the estimator position deviates significantly repeatedly. # Examples ```python >>> enhanced_interpolation_search([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 40) 3 >>> enhanced_interpolation_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 15) 7 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 25, 30, 35], 100) -1 >>> enhanced_interpolation_search([10, 10, 10, 10, 10], 10) 0 >>> enhanced_interpolation_search([5, 10, 12, 14, 17], 18) -1 ```","solution":"from typing import List def binary_search(array: List[int], search_key: int, low: int, high: int) -> int: while low <= high: mid = low + (high - low) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1 def enhanced_interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 if array[low] == array[high]: # If array[low] equals array[high], division by zero can occur if array[low] == search_key: return low return -1 # Probing the position with keeping uniform distribution in mind. pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Fallback to binary search if pos goes out of bounds if pos < low or pos > high: return binary_search(array, search_key, low, high) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Scenario: You are developing a pathfinding feature for a game. The game map is represented as a 2D grid where: - `-1` represents walls or obstacles. - `0` represents gates. - `INF` (2147483647) represents empty rooms. Your task is to fill each empty room with the distance to the nearest gate on the game map. If it is impossible to reach a gate from an empty room, it should remain as INF. Requirements: Implement the function `walls_and_gates(rooms)` which modifies the `rooms` grid in-place. Use BFS (Breadth-First Search) to ensure more efficient traversal and updating of distances. Input Format: ```python def walls_and_gates(rooms: List[List[int]]) -> None: :param rooms: List[List[int]] - m x n 2D list representing the grid. :return: None - modifies the grid in-place. ``` * **Rooms**: A 2D list of integers representing the grid cells. Output: The grid should be modified in place. No value is returned. Constraints: * The number of rows and columns in the grid will not exceed 200. * Initially, you can assume there is at least one gate. Example: ```python INF = 2147483647 rooms = [ [INF, -1, 0, INF], [INF, INF, INF, -1], [INF, -1, INF, -1], [0, -1, INF, INF] ] walls_and_gates(rooms) # Expected modified grid: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` Constraints: * **m**, **n** ≤ 200 * If all entries are walls or there are no gates, the grid remains unchanged. * Performance is important; consider avoiding large recursion depths. * Include error handling for edge cases such as no gates or fully blocked grids.","solution":"from collections import deque from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) INF = 2147483647 gates = deque() # Collect all gates positions for i in range(m): for j in range(n): if rooms[i][j] == 0: gates.append((i, j)) # Perform BFS from all gates directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while gates: x, y = gates.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 gates.append((nx, ny))"},{"question":"# Scenario You are tasked with creating a utility that can manage and iterate over alternating elements from two different lists. This utility can be particularly useful in load balancing tasks where tasks need to be evenly distributed between two services. # Task Implement the ZigZag Iterator class. This class will manage the iteration over two input lists in a zigzag fashion. # Function Signature ```python class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): # initialize the iterator with two lists def next(self) -> int: # return the next element in zigzag order def has_next(self) -> bool: # return True if there are more elements to iterate over, else False ``` # Input * You initialize the ZigZagIterator with two lists, `v1` and `v2`, each containing integers. * The lists may be of different lengths and could be empty. # Output * The `next()` method should return the next element in zigzag order. * The `has_next()` method should return a boolean indicating whether there are more elements to iterate over. # Constraints * Elements in the lists are integers. * At least one of the lists will contain elements. # Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) output = [] while it.has_next(): output.append(it.next()) print(output) # Output should be [1, 3, 2, 4, 5, 6] ``` # Explanation 1. The first element is taken from the first list, then from the second list, and so forth. 2. Elements are alternated until one list is exhausted, after which remaining elements from the longer list continue to be returned. # Performance Requirements * The implementation should efficiently handle lists with up to `10^5` elements each.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): self.v1 = v1 self.v2 = v2 self.index1 = 0 self.index2 = 0 self.turn = 0 # 0 indicates v1\'s turn, 1 indicates v2\'s turn def next(self) -> int: if not self.has_next(): raise StopIteration if self.turn == 0 and self.index1 < len(self.v1): result = self.v1[self.index1] self.index1 += 1 self.turn = 1 elif self.index2 < len(self.v2): result = self.v2[self.index2] self.index2 += 1 self.turn = 0 else: result = self.v1[self.index1] self.index1 += 1 return result def has_next(self) -> bool: return self.index1 < len(self.v1) or self.index2 < len(self.v2)"},{"question":"# RandomizedSet Implementation and Extension Background You are tasked with implementing a class `RandomizedSet` that supports `insert`, `remove`, and `get_random` operations in average O(1) time. This is useful in situations where you need quick insertions, deletions, and random access to elements. Objective - Implement the `RandomizedSet` as described. - Extend its functionality to include additional features. Requirements 1. **Insert Operation**: * Method Signature: `def insert(self, val: int) -> bool` * Inserts a value into the set if it\'s not already present. * Returns `True` if the element was successfully inserted, `False` otherwise. 2. **Remove Operation**: * Method Signature: `def remove(self, val: int) -> bool` * Removes a value from the set if it\'s present. * Returns `True` if the element was successfully removed, `False` otherwise. 3. **Get Random Operation**: * Method Signature: `def get_random(self) -> int` * Returns a random element from the current set of elements. * Each element must have the same probability of being returned. * Raises an exception if the set is empty. 4. **New Requirement - Get K Random Unique Elements**: * Method Signature: `def get_k_random(self, k: int) -> List[int]` * Returns a list of `k` unique random elements from the current set of elements. * Each element must have the same probability of being selected. * If `k` is greater than the number of elements in the set, return all elements in random order. # Implementation Constraints * You may assume that all input values are provided as integers. * The class should be implemented in Python and should be named `RandomizedSet`. * Consider edge cases such as empty set scenarios. # Example Usage ```python rs = RandomizedSet() print(rs.insert(1)) # True print(rs.insert(2)) # True print(rs.insert(3)) # True print(rs.remove(1)) # True print(rs.get_random()) # 2 or 3 print(rs.get_k_random(2)) # [2, 3] or [3, 2] print(rs.get_k_random(5)) # [2, 3] or [3, 2] ``` # Additional Notes - Focus on maintaining the O(1) average time complexity for the core operations. - Use Python\'s built-in libraries efficiently to achieve the desired functionality and performance.","solution":"import random class RandomizedSet: def __init__(self): self.data = [] self.index_map = {} def insert(self, val: int) -> bool: if val in self.index_map: return False self.index_map[val] = len(self.data) self.data.append(val) return True def remove(self, val: int) -> bool: if val not in self.index_map: return False last_element = self.data[-1] idx = self.index_map[val] self.data[idx] = last_element self.index_map[last_element] = idx self.data.pop() del self.index_map[val] return True def get_random(self) -> int: if not self.data: raise Exception(\\"Set is empty\\") return random.choice(self.data) def get_k_random(self, k: int) -> list: if k >= len(self.data): return random.sample(self.data, len(self.data)) return random.sample(self.data, k)"},{"question":"Given a binary tree and a sum, write a function `has_path_sum(root, sum)` that determines if the tree has a root-to-leaf path such that the sum of all values along the path equals the given sum. # Input * `root`: The root of the binary tree, where each node contains an integer value. * `sum`: An integer representing the target sum. # Output * Return `True` if there exists a root-to-leaf path with the given sum, otherwise return `False`. # Constraints * The number of nodes in the binary tree is in the range [0, 1000]. * -1000 <= Node.val <= 1000 * -1000 <= sum <= 1000 # Example Given the binary tree and sum = 22, 5 / 4 8 / / 11 13 4 / 7 2 1 Your function should return `True`, as there exists a root-to-leaf path 5->4->11->2 which sum is 22. # Implementation Please write the function `has_path_sum` using any of the three methods provided: 1. Recursive Approach 2. DFS with stack 3. BFS with queue Make sure to handle edge cases, performance concerns, and provide the most efficient solution based on the constraints.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.val = value self.left = left self.right = right def has_path_sum(root, sum): Determines if the tree has a root-to-leaf path such that the sum of all values along the path equals the given sum. Parameters: root (TreeNode): The root of the binary tree. sum (int): The target sum. Returns: bool: True if there exists a root-to-leaf path with the given sum, otherwise False. if not root: return False # Check if it is a leaf node if not root.left and not root.right: return root.val == sum # Recursive case for left and right sub-trees return has_path_sum(root.left, sum - root.val) or has_path_sum(root.right, sum - root.val)"},{"question":"# Question: Enhanced Run-Length Encoding Create a function that performs enhanced run-length encoding on a string, where instead of merely counting consecutive characters, you must also count sequences of characters, treating runs of 3 or more identical characters as a single run even if they occur among different sections of the string. You must also provide a decoding function specifically for this encoding scheme. Consider efficiency, paying attention to edge cases and performance bottlenecks. Function Signature: ```python def enhanced_encode_rle(input: str) -> str: pass def enhanced_decode_rle(input: str) -> str: pass ``` Input: 1. A string `input` containing alphanumeric characters for the encoding function. 2. A string `input` containing the encoded data for the decoding function. Output: 1. A string representing the enhanced run-length encoded data. 2. A string representing the original data when given the enhanced encoded string. Example: ```python assert enhanced_encode_rle(\\"aabcccaa\\") == \\"2a1b3c2a\\" assert enhanced_decode_rle(\\"2a1b3c2a\\") == \\"aabcccaa\\" ``` Constraints: - Only alphanumeric characters will be present in the input strings. - The length of `input` will not exceed 10^5 characters. **Note**: Organize and test your code thoroughly, ensuring it handles all potential edge cases efficiently.","solution":"def enhanced_encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] i = 0 while i < len(input): count = 1 while i + 1 < len(input) and input[i] == input[i + 1]: count += 1 i += 1 encoded.append(f\\"{count}{input[i]}\\") i += 1 return \'\'.join(encoded) def enhanced_decode_rle(input: str) -> str: decoded = [] i = 0 while i < len(input): count = 0 while i < len(input) and input[i].isdigit(): count = count * 10 + int(input[i]) i += 1 if i < len(input): decoded.append(input[i] * count) i += 1 return \'\'.join(decoded)"},{"question":"# Scenario You are developing a feature for an educational application that teaches ancient numeral systems. A crucial part of this feature is the ability to convert positive integers into their corresponding Roman numeral representations, specifically for values within the range of 1 to 3999. # Problem Statement Write a function `int_to_roman(num)` that converts a given integer (within the range from 1 to 3999) into its corresponding Roman numeral representation. # Input * An integer `num` within the range `[1, 3999]`. # Output * A string representing the Roman numeral of the input integer. # Constraints * `1 <= num <= 3999` # Example ```python # Example 1 input: 58 output: \\"LVIII\\" # Example 2 input: 1994 output: \\"MCMXCIV\\" ``` # Additional Requirements * Ensure the function works efficiently with the given constraints. * Focus on the correctness and performance of your implementation.","solution":"def int_to_roman(num): Converts a given integer within the range [1, 3999] to its corresponding Roman numeral representation. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"# Scenario You are tasked with implementing a data structure that not only supports efficient insertions and deletions but also allows retrieving a random element from the set. This data structure is particularly useful in scenarios where real-time systems need to handle dynamic datasets with uniform random access. # Problem Statement Implement a class `RandomizedSet` with the following functionalities: 1. **insert(val)**: Inserts an item `val` to the set if not already present. 2. **remove(val)**: Removes an item `val` from the set if present. 3. **getRandom()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. # Function Signature ```python class RandomizedSet: def __init__(self): # Initialize your data structure here. def insert(self, val: int) -> bool: Inserts an item val to the set if not already present. Returns True if the item was inserted, False otherwise. def remove(self, val: int) -> bool: Removes an item val from the set if present. Returns True if the item was removed, False if it did not exist. def getRandom(self) -> int: Returns a random element from the current set of elements. ``` # Constraints * All values are integers. * Function `getRandom` should not be called on an empty set. # Example ```python rs = RandomizedSet() print(rs.insert(1)) # True (Inserted) print(rs.insert(2)) # True (Inserted) print(rs.insert(1)) # False (Already Exists) print(rs.remove(1)) # True (Removed) print(rs.remove(3)) # False (Does not exist) print(rs.getRandom()) # Random element from the set [2] print(rs.getRandom()) # Random element from the set [2] ``` # Notes - Ensure `insert`, `remove`, and `getRandom` operations are optimal with average O(1) time. - Handle edge cases such as attempts to remove non-existent elements or retrieving random elements when the set is not empty but has minimal elements.","solution":"import random class RandomizedSet: def __init__(self): # Initialize the data structure with a list and a dictionary self.data_list = [] self.data_dict = {} def insert(self, val: int) -> bool: if val in self.data_dict: return False self.data_dict[val] = len(self.data_list) self.data_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.data_dict: return False # Move the last element to the place of the element to delete last_element = self.data_list[-1] idx = self.data_dict[val] self.data_list[idx] = last_element self.data_dict[last_element] = idx self.data_list.pop() del self.data_dict[val] return True def getRandom(self) -> int: return random.choice(self.data_list)"},{"question":"# Predicting Text with a Markov Chain You have been given a text corpus, and you need to build a Markov Chain that can generate sentences based on the corpus. You will implement the Markov Chain and use it to provide predictive text input. Function Specifications: 1. **build_markov_chain(corpus: str, order: int) -> Dict[str, Dict[str, float]]**: * **Input**: * `corpus`: A single string containing the text to analyze. * `order`: An integer representing the number of previous characters (or words) to consider for the Markov Chain (e.g., order = 1 for single character, order = 2 for bigrams, etc.). * **Output**: A dictionary representing the Markov Chain. The keys are the states (character substrings or word tuples), and the values are dictionaries mapping next states to their probabilities. 2. **generate_text(chain: Dict[str, Dict[str, float]], initial_state: str, length: int) -> str**: * **Input**: * `chain`: The Markov Chain dictionary created by `build_markov_chain`. * `initial_state`: The initial state string or word to start the text generation from. * `length`: An integer representing the desired length of the generated text. * **Output**: A string of generated text of the specified length. # Constraints: * For the purpose of simplicity, use whitespace to separate words. * Assume that the corpus will have a sufficient length for meaningful text generation. * Handle punctuations and special characters as part of words. Example: ```python corpus = \\"the quick brown fox jumps over the lazy dog\\" order = 1 chain = build_markov_chain(corpus, order) initial_state = \\"the\\" length = 20 print(generate_text(chain, initial_state, length)) # Possible Output: \\"the quick brown fox jumps over the lazy dog the quick brown\\" ```","solution":"import random from collections import defaultdict def build_markov_chain(corpus: str, order: int): Builds a Markov Chain from the given text corpus and order. words = corpus.split() chain = defaultdict(lambda: defaultdict(int)) for i in range(len(words) - order): state = tuple(words[i:i+order]) next_state = words[i + order] chain[state][next_state] += 1 # Normalize frequencies to probabilities markov_chain = {} for state, transitions in chain.items(): total = sum(transitions.values()) markov_chain[state] = {word: count / total for word, count in transitions.items()} return markov_chain def generate_text(chain, initial_state, length): Generates text using the given Markov Chain starting from the initial state. current_state = tuple(initial_state.split()) generated_words = list(current_state) for _ in range(length - len(current_state)): next_word = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] generated_words.append(next_word) current_state = tuple(generated_words[-len(current_state):]) return \\" \\".join(generated_words)"},{"question":"**Scenario**: You are working on a project that requires merging streams of data from different sources. Each source provides its data in a list, and you need to process these lists in an interleaved manner, ensuring each source contributes one element at a time in a round-robin fashion until all elements are exhausted. **Task**: Implement a class `KZigZagIterator` that can iterate over `k` lists in a zigzag manner. Extend the given `ZigZagIterator` class to support multiple lists instead of just two. # Specification: * **Class Name**: `KZigZagIterator` * **Methods**: * `__init__(self, lists: List[List[int]])`: Initializes the iterator with `k` lists. * `next(self) -> int`: Returns the next element in the zigzag order. * `has_next(self) -> bool`: Returns `True` if there are more elements to iterate, `False` otherwise. # Input: * `lists`: A list of `k` lists, each containing `n` integers `[l1, l2, ..., lk]`. # Output: * Your iterator should alternately return elements from each list in a round-robin fashion until all lists are exhausted. # Example: ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] iterator = KZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Should print: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Constraints: * 1 <= len(lists) <= 1000 * 0 <= len(lists[i]) <= 1000 * Elements in lists are integers and can be negative. **Performance Requirements**: * Each call to `next` and `has_next` should be O(1).","solution":"from collections import deque from typing import List class KZigZagIterator: def __init__(self, lists: List[List[int]]): self.queue = deque() for idx, lst in enumerate(lists): if lst: self.queue.append((lst, 0)) def next(self) -> int: if self.has_next(): lst, idx = self.queue.popleft() value = lst[idx] if idx + 1 < len(lst): self.queue.append((lst, idx + 1)) return value else: raise Exception(\\"No more elements\\") def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"Scenario You are tasked with developing a low-level arithmetic library that provides basic arithmetic operations without using the conventional arithmetic operators. Your first task is to implement the addition operation using bitwise operations only. Task Write a Python function `bitwise_add` that takes two non-negative integers and returns their sum using bitwise operations. Function Signature ```python def bitwise_add(x: int, y: int) -> int: pass ``` Input - `x` (int): A non-negative integer. - `y` (int): A non-negative integer. Output - (int): The sum of `x` and `y`. Constraints 1. Both `x` and `y` are non-negative integers. 2. You cannot use the \'+\' operator or any arithmetic operations like -, *, / or %. Performance Requirements - The solution must handle large numbers efficiently within a reasonable time frame. Example ```python assert bitwise_add(2, 3) == 5 assert bitwise_add(0, 0) == 0 assert bitwise_add(1234, 5678) == 6912 ```","solution":"def bitwise_add(x: int, y: int) -> int: Adds two non-negative integers using bitwise operations. while y != 0: carry = x & y x = x ^ y y = carry << 1 return x"},{"question":"# Transitive Closure of a Directed Graph Background: You are given a directed graph represented as an adjacency list. The graph may have nodes with self-loops and can be disconnected. Your task is to compute the transitive closure of this graph using a depth-first search (DFS) based approach. Problem Statement: Implement a function `find_transitive_closure(graph: Dict[int, List[int]], vertex_count: int) -> List[List[int]]` that computes the transitive closure of the graph. Input: - `graph`: A dictionary where keys are source vertices and values are lists of destination vertices. - `vertex_count`: An integer representing the number of vertices in the graph. Output: - A 2D list `closure_matrix` that represents the transitive closure of the graph. `closure_matrix[i][j]` should be 1 if there is a path from vertex `i` to vertex `j`, otherwise 0. Constraints: - The number of vertices `vertex_count` will be between 1 and 100 inclusive. - Self-loops are allowed. Example: **Input:** ```python graph = {0: [1], 1: [2], 2: [0, 3], 3: []} vertex_count = 4 ``` **Output:** ```python closure_matrix = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 1] ] ``` Explanation: - There is a path from 0 to 1, from 1 to 2, and from 2 to 0 and 3. Thus, every vertex is reachable from vertex 0, 1, 2. - Vertex 3 has no outgoing edges, so it\'s only reachable from itself. Implement the function keeping in mind the guidelines provided above. ```python def find_transitive_closure(graph, vertex_count): # Your code here pass ```","solution":"def find_transitive_closure(graph, vertex_count): Computes the transitive closure of a directed graph using DFS. :param graph: Dictionary where keys are vertices and values are lists of destination vertices. :param vertex_count: Number of vertices in the graph. :return: A 2D list representing the transitive closure matrix. # Initialize the closure matrix with 0s closure_matrix = [[0] * vertex_count for _ in range(vertex_count)] # Helper function to perform DFS def dfs(start, current): closure_matrix[start][current] = 1 for neighbor in graph.get(current, []): if closure_matrix[start][neighbor] == 0: dfs(start, neighbor) # Perform DFS for each vertex for i in range(vertex_count): dfs(i, i) return closure_matrix"},{"question":"Problem Statement You are given a string that needs to be compressed or decompressed using Run-Length Encoding (RLE). Implement functions that: * Encode a given string into its RLE representation. * Decode an RLE string back to its original form. # Function Definitions 1. `encode_rle(input: str) -> str` - **Input**: A string `input` containing the data to be encoded. - **Output**: A string representing the run-length encoded version of the input. 2. `decode_rle(input: str) -> str` - **Input**: A string `input` containing the data to be decoded in the RLE format. - **Output**: A string representing the decoded version of the input. # Constraints * The input string will only contain alphanumeric characters. * You can assume that the encoded RLE string provided for decoding is valid. # Example Encoding Input: ``` \\"aaabccccdd\\" ``` Output: ``` \\"3a1b4c2d\\" ``` Decoding Input: ``` \\"3a1b4c2d\\" ``` Output: ``` \\"aaabccccdd\\" ``` # Notes 1. Be sure to handle edge cases such as empty input, single character strings, and strings with no repetitions. 2. Optimize your function for both time and space efficiency.","solution":"def encode_rle(input: str) -> str: Encode the given string using Run-Length Encoding (RLE). if not input: return \\"\\" encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded.append(f\\"{count}{input[i - 1]}\\") count = 1 # Append the last group encoded.append(f\\"{count}{input[-1]}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: Decode the given Run-Length Encoded (RLE) string. decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) # handle multiple digits else: decoded.append(char * count) count = 0 return \\"\\".join(decoded)"},{"question":"Maximum Flow Problem with Modified Constraints # Background In network optimization problems, finding the maximum possible flow from a source to a sink in a flow network is crucial. The three widely used algorithms for this are Ford-Fulkerson, Edmonds-Karp, and Dinic\'s algorithm. Each has its strengths and complexity characteristics. # Task Your task is to implement a modified version of the maximum flow problem in a network graph. You need to choose an algorithm—Ford-Fulkerson, Edmonds-Karp, or Dinic—and incorporate additional constraints to balance the flow distribution between the outgoing edges of a given node. # Constraints 1. The graph is directed and may contain cycles. 2. The capacities are represented by a 2D matrix, `capacity[v][v]`, where `capacity[i][j]` indicates the capacity of the edge from node `i` to node `j`. 3. The graph also contains a balancing node `B`. The outgoing flow from this node `B` should be evenly distributed among its outgoing edges, meaning no outgoing edge from `B` should have more than twice the flow of another outgoing edge from `B`. # Input Format * `capacity`: A 2D list of integers where `capacity[i][j]` is the capacity from node `i` to node `j`. * `source`: An integer representing the source node. * `sink`: An integer representing the sink node. * `balancing_node`: An integer representing the node from which outgoing edge flows need to be balanced. # Output Format * An integer representing the maximum flow satisfying the graph constraints and balancing condition. # Requirements * Ensure your solution handles large graphs efficiently. * Think about edge cases such as disconnected nodes or zero-capacity edges. # Example Given the following input: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 balancing_node = 3 ``` The output should provide the maximum flow while ensuring the balancing node\'s outgoing flows are evenly balanced. # Implementation Choose and implement one of the three algorithms (Ford-Fulkerson, Edmonds-Karp, Dinic) and modify it to incorporate the balancing constraint.","solution":"from collections import deque def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v in range(len(capacity)): if not visited[v] and capacity[u][v] > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def distribute_flows(balance_node, flow): total_outflow = sum(flow[balance_node]) num_edges = len([f for f in flow[balance_node] if f > 0]) if num_edges == 0: return flow minimum_outflow = total_outflow / (2 * num_edges) for i in range(len(flow[balance_node])): if flow[balance_node][i] > 0: flow[balance_node][i] = max(flow[balance_node][i], minimum_outflow) return flow def edmonds_karp(capacity, source, sink, balance_node): parent = [-1] * len(capacity) max_flow = 0 residual_capacity = [row[:] for row in capacity] while bfs(residual_capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow flow = [[0] * len(capacity) for _ in range(len(capacity))] for u in range(len(capacity)): for v in range(len(capacity)): if capacity[u][v] > 0: flow[u][v] = capacity[u][v] - residual_capacity[u][v] flow = distribute_flows(balance_node, flow) return max_flow def max_flow_with_balanced_node(capacity, source, sink, balance_node): return edmonds_karp(capacity, source, sink, balance_node)"},{"question":"# Coding Challenge: Implementing Linked List Sorting Check Description You are given a singly linked list and you are required to implement a function that determines whether this linked list is sorted in non-decreasing order. A linked list is represented by a series of nodes where each node contains a value and a reference to the next node in the list. The function will return `True` if the linked list is sorted in non-decreasing order and `False` otherwise. An empty list is considered to be sorted. Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def is_sorted(head: ListNode) -> bool: pass ``` Input * `head` (ListNode): The head node of the singly linked list. `head` is either a ListNode or `None` indicating an empty list. Output * `bool`: Return `True` if the linked list is sorted in non-decreasing order, otherwise return `False`. Constraints * The number of nodes in the linked list can be up to 10^5. * Each node value `val` will be an integer (can be positive or negative and fits within the limits of a 32-bit integer). Example ```python # Constructing linked list: 1 -> 2 -> 3 -> 4 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) print(is_sorted(head)) # Output: True # Constructing linked list: 1 -> 2 -> -1 -> 3 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(-1) head.next.next.next = ListNode(3) print(is_sorted(head)) # Output: False ``` Make sure your implementation handles empty lists and is efficient enough to work on larger lists within the given constraints.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def is_sorted(head: ListNode) -> bool: if not head or not head.next: return True current = head while current and current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Queue Data Structure Implementation You are tasked to implement a queue using two different structures: Array and Linked List. Your implementations should adhere to the provided behaviors and constraints. Requirements 1. **ArrayQueue:** - Use a fixed-size array. - Implement wrap-around using modular arithmetic to efficiently manage queue elements without frequently resizing. 2. **LinkedListQueue:** - Use a singly linked list. - Ensure efficient enqueue and dequeue operations. Implement the following methods: - `enqueue(item)` - Add an item to the rear of the queue. - `dequeue()` - Remove and return the front item of the queue. - `peek()` - Return the front item of the queue without removing it. - `isEmpty()` - Return whether the queue is empty. - `size()` - Return the number of items in the queue. Function Signature and Input/Output Formats ```python class ArrayQueue(AbstractQueue): def __init__(self, capacity=10): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass def size(self): pass class LinkedListQueue(AbstractQueue): def __init__(self): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass def size(self): pass ``` Constraints * The `capacity` for `ArrayQueue` is initially set to 10 but will increase if needed. * Ensure that all operations work efficiently within the given data structures. * Handle edge cases like trying to dequeue or peek from an empty queue gracefully by raising an appropriate exception. Example ```python # Example usage of ArrayQueue aq = ArrayQueue() aq.enqueue(1) aq.enqueue(2) print(aq.peek()) # Output: 1 print(aq.dequeue()) # Output: 1 print(aq.is_empty()) # Output: False print(aq.size()) # Output: 1 # Example usage of LinkedListQueue llq = LinkedListQueue() llq.enqueue(1) llq.enqueue(2) print(llq.peek()) # Output: 1 print(llq.dequeue()) # Output: 1 print(llq.is_empty()) # Output: False print(llq.size()) # Output: 1 ``` Ensure to run your code through various test cases to validate its correctness and efficiency.","solution":"class AbstractQueue: def enqueue(self, value): raise NotImplementedError def dequeue(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError def size(self): raise NotImplementedError class ArrayQueue(AbstractQueue): def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value): if self.count == self.capacity: self._resize() self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.count == 0 def size(self): return self.count def _resize(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.count): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.front = 0 self.rear = self.count self.capacity = new_capacity class LinkedListQueue(AbstractQueue): class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.front = None self.rear = None self.count = 0 def enqueue(self, value): new_node = self.Node(value) if self.is_empty(): self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.front.value self.front = self.front.next self.count -= 1 if self.is_empty(): self.rear = None return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.front.value def is_empty(self): return self.count == 0 def size(self): return self.count"},{"question":"Design a function to limit the occurrence of each element in a list to at most a given number (N), while maintaining the original order of elements. # Function Signature ```python def limit_occurrences(lst: List[int], N: int) -> List[int]: pass ``` # Input - A list of integers `lst` (0 ≤ length ≤ 10^6). - An integer `N` (0 ≤ N ≤ length of the list). # Output - A list of integers which contains each element from `lst` at most `N` times, preserving their order. # Constraints - The solution should be efficient with a time complexity of O(n). - Elements should appear in the output in the same order as they appear in the input list. # Example ```python assert limit_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert limit_occurrences([1, 2, 3], 0) == [] assert limit_occurrences([1, 1, 1, 1], 1) == [1] ```","solution":"from typing import List def limit_occurrences(lst: List[int], N: int) -> List[int]: Limits the occurrence of each element in lst to at most N times, while maintaining the original order of elements. if N == 0: return [] counts = {} result = [] for number in lst: if counts.get(number, 0) < N: result.append(number) counts[number] = counts.get(number, 0) + 1 return result"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: This is a rotation algorithm for a singly-linked list, specifically rotating the list to the right by `k` positions. * **Complexity**: * **Time Complexity**: O(n), where n is the number of nodes in the list. This is because we traverse the list twice, once to count the length and once to find the new head. * **Space Complexity**: O(1), as it uses a constant amount of extra space irrespective of the input size. * **Principles**: 1. Calculate the length of the linked list. 2. Connect the tail to the head to create a circular linked list. 3. Determine the effective number of rotations needed using modulo operation. 4. Traverse to the new head and break the circle to form the rotated list. # Characteristics & Applications * **Properties**: The algorithm handles the transformation directly in place without requiring additional list structures. * **Common Use Cases**: * Systems that require cyclic shifting of elements. * Time-based scheduling where tasks need to be rotated after certain intervals. * **Strengths/Limitations**: * **Strengths**: Efficient with an O(n) linear time complexity and O(1) space complexity. * **Limitations**: Performance might degrade for extremely large lists due to linear traversal. # Implementation Challenges * **Edge Cases**: * When the list is empty. * When the list has only one node. * When `k` is zero or a multiple of the list\'s length. * **Performance Bottlenecks**: Traversing the list twice might be a bottleneck for very large lists. * **Error Scenarios**: Incorrect handling of the modulo operation when `k` is greater than the list\'s length. * **Optimization Points**: We could optimize the traversal steps by immediately returning the head if `k % length == 0`. <|Analysis End|> <|Question Begin|> # Problem Statement You are given a singly-linked list and a non-negative integer `k`. Your task is to write a function to rotate the linked list to the right by `k` places. # Function Signature ```python def rotate_right(head: ListNode, k: int) -> ListNode: ``` # Input * `head` (ListNode): The head of a singly-linked list. * `k` (int): The number of positions to rotate the list to the right. (`0 <= k <= 10^9`) # Output * Returns the head of the rotated linked list. # Example Given a linked list `1 -> 2 -> 3 -> 4 -> 5 -> NULL` and `k = 2`, * The new linked list should be `4 -> 5 -> 1 -> 2 -> 3 -> NULL`. # Constraints 1. The number of nodes in the linked list is in the range `[0, 500]`. # Performance Requirements The algorithm should run in linear time, O(n), and use constant space, O(1). # Scenario You are working on a project that involves cyclic shifting of elements within a period. Imagine you are implementing a feature that rotates customer IDs in a round-robin fashion after every defined interval. This function is a core part of the system, ensuring that a rotation operation is performed efficiently before dispatching the next sequence of tasks.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Calculate the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Connect tail to head to make it circular tail.next = head # Calculate the effective rotations needed k %= length steps_to_new_head = length - k # Find the new head and tail new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"You are tasked with designing a flexible job scheduling system based on priorities. Each job has a unique identifier and a priority value. Jobs with the lowest priority values should be executed first. Implement a Job Scheduler using a Binary Min Heap capable of inserting jobs and removing the job with the highest priority (lowest priority value). # Function Specifications **Class**: `JobScheduler` Methods * `insert_job(job_id: str, priority: int) -> None`: - Inserts a new job with the given job identifier and priority into the scheduler. - `job_id` is a string representing the unique identifier of the job. - `priority` is an integer representing the job\'s priority. * `remove_highest_priority() -> str`: - Removes and returns the identifier of the job with the highest priority (smallest priority value). - If the scheduler is empty, return an empty string. * `peek_highest_priority() -> str`: - Returns the identifier of the job with the highest priority without removing it. - If the scheduler is empty, return an empty string. # Constraints: 1. Job identifiers are unique. 2. There will be at most 10^5 job insertions and removals. 3. Priority values will be integers in the range from -10^6 to 10^6. 4. Method `insert_job` and `remove_highest_priority` should have O(log N) time complexity, where N is the number of jobs in the scheduler at any given time. 5. Method `peek_highest_priority` should have O(1) time complexity. # Example ```python scheduler = JobScheduler() scheduler.insert_job(\\"job1\\", 5) scheduler.insert_job(\\"job2\\", 3) scheduler.insert_job(\\"job3\\", 9) print(scheduler.peek_highest_priority()) # Output: \\"job2\\" print(scheduler.remove_highest_priority()) # Output: \\"job2\\" print(scheduler.peek_highest_priority()) # Output: \\"job1\\" ``` # Implementation ```python class JobScheduler(AbstractHeap): Job Scheduler using Min Heap def __init__(self): self.current_size = 0 self.heap = [(0, \\"\\")] # Use tuple to store (priority, job_id) def perc_up(self, i): while i // 2 > 0: if self.heap[i][0] < self.heap[i // 2][0]: # Swap value of child with value of its parent self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert_job(self, job_id, priority): self.heap.append((priority, job_id)) self.current_size = self.current_size + 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: # No right child return 2 * i if self.heap[2 * i][0] > self.heap[2 * i + 1][0]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[min_child][0] < self.heap[i][0]: self.heap[min_child], self.heap[i] = self.heap[i], self.heap[min_child] i = min_child def remove_highest_priority(self): if self.current_size == 0: return \\"\\" ret_job = self.heap[1][1] self.heap[1] = self.heap[self.current_size] self.current_size = self.current_size - 1 self.heap.pop() if self.current_size > 0: self.perc_down(1) return ret_job def peek_highest_priority(self): if self.current_size == 0: return \\"\\" return self.heap[1][1] ```","solution":"import heapq class JobScheduler: def __init__(self): self.heap = [] self.entry_finder = {} self.REMOVED = \'<removed-job>\' def insert_job(self, job_id: str, priority: int) -> None: if job_id in self.entry_finder: self.remove_job(job_id) entry = [priority, job_id] self.entry_finder[job_id] = entry heapq.heappush(self.heap, entry) def remove_job(self, job_id: str): entry = self.entry_finder.pop(job_id) entry[-1] = self.REMOVED def remove_highest_priority(self) -> str: while self.heap: priority, job_id = heapq.heappop(self.heap) if job_id != self.REMOVED: del self.entry_finder[job_id] return job_id return \\"\\" def peek_highest_priority(self) -> str: while self.heap: priority, job_id = self.heap[0] if job_id == self.REMOVED: heapq.heappop(self.heap) else: return job_id return \\"\\""},{"question":"In the field of text processing, calculating the edit distance (or Levenshtein distance) between two words is an essential task. The edit distance is the minimum number of operations required to transform one word into another, using only insertions, deletions, or substitutions of single characters. **Your Task:** Implement a function `enhanced_edit_distance(word_a: str, word_b: str) -> int` that calculates the edit distance between two input strings `word_a` and `word_b`. Input Format - Two non-empty strings `word_a` and `word_b` with lengths (n) and (m) respectively. Output Format - Return a single integer, representing the edit distance between the two input strings. Constraints - (1 leq text{len}(word_a), text{len}(word_b) leq 1000) Performance Requirements - Your solution should run in (O(n times m)) time complexity. - Aim to reduce the space complexity to (O(min(n,m))) if possible. How to Approach Take the existing implementation, analyze its space consumption, and improve it by using a rolling array to minimize the memory footprint. Example ```python assert enhanced_edit_distance(\\"food\\", \\"money\\") == 4 assert enhanced_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert enhanced_edit_distance(\\"horse\\", \\"ros\\") == 3 assert enhanced_edit_distance(\\"intention\\", \\"execution\\") == 5 assert enhanced_edit_distance(\\"hello\\", \\"hello\\") == 0 ``` In these examples: - Transform \\"food\\" to \\"money\\" requires 4 operations. - \\"kitten\\" to \\"sitting\\" requires 3 operations - kitten -> sitten -> sittin -> sitting. - \\"horse\\" to \\"ros\\" requires 3 operations - horse -> rorse -> rose -> ros. - \\"intention\\" to \\"execution\\" requires 5 operations. - \\"hello\\" to \\"hello\\" requires 0 operations since they are identical. You should ensure your function is efficient and handles edge cases effectively.","solution":"def enhanced_edit_distance(word_a: str, word_b: str) -> int: Calculates the Levenshtein distance between two input strings word_a and word_b. n, m = len(word_a), len(word_b) if n < m: word_a, word_b = word_b, word_a n, m = m, n previous_row = list(range(m + 1)) current_row = [0] * (m + 1) for i in range(1, n + 1): current_row[0] = i for j in range(1, m + 1): insert_cost = current_row[j - 1] + 1 delete_cost = previous_row[j] + 1 if word_a[i - 1] == word_b[j - 1]: replace_cost = previous_row[j - 1] else: replace_cost = previous_row[j - 1] + 1 current_row[j] = min(insert_cost, delete_cost, replace_cost) previous_row, current_row = current_row, previous_row return previous_row[m]"},{"question":"# Matrix Multiplication Error Handling and Optimization You are tasked with enhancing the given matrix multiplication algorithm. The original algorithm has size and compatibility checks but lacks robustness against several edge cases and performance bottlenecks. Your goal is to improve its efficiency and error handling capabilities. **Task**: Write a function named `optimized_multiply` that: 1. **Enhances Error Handling**: * Ensure both input matrices are non-empty and rectangular (all rows must have the same length). * Raise an error if matrices are not compatible for multiplication. 2. **Optimizes Performance**: * Utilize NumPy for matrix multiplication to leverage its optimized backend, reducing time complexity. **Function Specifications**: * **Input**: * `multiplicand` (List[List[int]]): A two-dimensional list of integers representing the multiplicand matrix. * `multiplier` (List[List[int]]): A two-dimensional list of integers representing the multiplier matrix. * **Output**: * List[List[int]]: A two-dimensional list of integers representing the product matrix. * **Constraints**: * The number of columns in `multiplicand` should be equal to the number of rows in `multiplier`. * Matrices should be non-empty and rectangular. * Use NumPy for computations. **Performance Requirements**: * The solution must handle matrices of size up to 1000 x 1000 efficiently. **Examples**: ```python >>> multiplicand = [ [1, 2], [3, 4] ] >>> multiplier = [ [5, 6], [7, 8] ] >>> optimized_multiply(multiplicand, multiplier) [[19, 22], [43, 50]] >>> multiplicand = [ [1, 2, 3], [4, 5, 6] ] >>> multiplier = [ [7, 8], [9, 10], [11, 12] ] >>> optimized_multiply(multiplicand, multiplier) [[58, 64], [139, 154]] >>> multiplicand = [ [1, 2], [3, 4] ] >>> multiplier = [ [5, 6, 7], [8, 9, 10] ] >>> optimized_multiply(multiplicand, multiplier) [[21, 24, 27], [47, 54, 61]] ```","solution":"import numpy as np def optimized_multiply(multiplicand, multiplier): Returns the product of two matrices multiplicand and multiplier using numpy for efficiency. Parameters: multiplicand (List[List[int]]): The first matrix to be multiplied. multiplier (List[List[int]]): The second matrix to be multiplied. Returns: List[List[int]]: The product matrix. # Check if matrices are non-empty if not multiplicand or not multiplier: raise ValueError(\\"Matrices should be non-empty\\") # Check if matrices are rectangular if any(len(row) != len(multiplicand[0]) for row in multiplicand) or any(len(row) != len(multiplier[0]) for row in multiplier): raise ValueError(\\"All rows in matrices must have the same length\\") # Check if the number of columns in multiplicand equals to the number of rows in multiplier if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Number of columns in multiplicand must equal number of rows in multiplier\\") # Convert to numpy arrays for efficient multiplication multiplicand_np = np.array(multiplicand) multiplier_np = np.array(multiplier) # Perform matrix multiplication product_np = np.matmul(multiplicand_np, multiplier_np) # Convert numpy array back to list of lists and return return product_np.tolist()"},{"question":"# Input: You are provided with two arrays: `preorder` and `postorder` representing the preorder and postorder traversal sequences of a full binary tree (each node has 0 or 2 children). # Objective: Write a Python function to construct the binary tree from the given traversals and return the inorder traversal of the constructed tree. # Function Signature: ```python def construct_tree_from_pre_post(preorder: List[int], postorder: List[int]) -> List[int]: ``` # Constraints: 1. The number of nodes `n` in the tree is such that `1 <= n <= 1000`. 2. Duplicate values are not allowed in the binary tree (all values are unique). 3. The provided traversal arrays are guaranteed to be valid and consistent with a full binary tree. # Example: ```python preorder = [1, 2, 4, 5, 3, 6, 7] postorder = [4, 5, 2, 6, 7, 3, 1] result = construct_tree_from_pre_post(preorder, postorder) # The expected output should be: # [4, 2, 5, 1, 6, 3, 7] ``` # Explanation: - The first element in `preorder` is the root. - The same element is the last one in `postorder`. - Find the next root from `preorder`, divide the `postorder` array and recursively construct left and right subtrees. # Notes: - Ensure your solution is efficient given the constraints. - Handle edge cases such as minimal input sizes for preorder and postorder arrays.","solution":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def construct_tree_from_pre_post(preorder: List[int], postorder: List[int]) -> List[int]: if not preorder or not postorder: return [] def construct(pre_left, pre_right, post_left, post_right): if pre_left > pre_right or post_left > post_right: return None root_value = preorder[pre_left] root = TreeNode(root_value) if pre_left + 1 <= pre_right: left_root_value = preorder[pre_left + 1] left_root_index = postorder_index_map[left_root_value] left_size = left_root_index - post_left + 1 root.left = construct(pre_left + 1, pre_left + left_size, post_left, left_root_index) root.right = construct(pre_left + left_size + 1, pre_right, left_root_index + 1, post_right - 1) return root def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] postorder_index_map = {value: index for index, value in enumerate(postorder)} preorder_index_map = {value: index for index, value in enumerate(preorder)} n = len(preorder) root = construct(0, n - 1, 0, n - 1) return inorder_traversal(root)"},{"question":"You are implementing a ZigZag Iterator which alternates between elements of two lists, returning elements from each list in a round-robin fashion. You need to write the implementations of the `ZigZagIterator` class that supports the following two methods: - `next()`: Returns the next element in the iteration. - `has_next()`: Returns `True` if there are still elements to be iterated; otherwise, returns `False`. # Detailed Specification 1. **Initialization**: You will be passed two lists of integers `v1` and `v2`. 2. **next()**: * Inputs: None. * Outputs: An integer which is the next element in the iteration. 3. **has_next()**: * Inputs: None. * Outputs: A boolean indicating if there are more elements to iterate. # Constraints * Both input lists are non-null and may have different lengths. * All integer elements in the lists are non-negative. # Performance Requirements * Your implementation should aim for O(1) time complexity on average for `next()` and `has_next()` operations. * Minimize memory usage to O(N+M), where N and M are the lengths of the input lists. # Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) results = [] while it.has_next(): results.append(it.next()) print(results) # Output should be [1, 3, 2, 4, 5, 6] ``` # Edge Cases * Both lists are empty: `l1 = [], l2 = []` * One list is empty: `l1 = [1, 2, 3], l2 = []` * Lists with one element each: `l1 = [1], l2 = [2]` * Lists of different lengths: `l1 = [1, 2], l2 = [3, 4, 5, 6]` # Implementation Complete the class `ZigZagIterator` as described.","solution":"from collections import deque class ZigZagIterator: def __init__(self, v1, v2): Initialize the ZigZag Iterator with two lists. self.queue = deque([(v1, 0), (v2, 0)]) # Store lists with their current index def next(self): Returns the next element in the iteration. # Get the list and its current index while self.queue: v, idx = self.queue.popleft() if idx < len(v): # Check if there are remaining elements in the list if idx + 1 < len(v): self.queue.append((v, idx + 1)) return v[idx] def has_next(self): Returns True if there are more elements to iterate; otherwise, returns False. while self.queue: v, idx = self.queue[0] # Peek at the front of the queue if idx < len(v): # There are still elements to iterate return True else: self.queue.popleft() # Remove empty lists from the queue return False"},{"question":"Implement a function `efficient_bogo_sort` that uses a more efficient strategy than classic Bogo Sort to sort an array. The function should avoid random shuffling each time but still rely on some \'probabilistic\' approach reminiscent of the original Bogo Sort. # Requirements: 1. Complete the function `efficient_bogo_sort(arr: List[int]) -> List[int]`. 2. The function should: * Take a list of integers as input. * Output a list of integers sorted in ascending order. 3. Constraints: * Input list size should be within the range of [1, 10], inclusive. * Elements of the list are integers within the range [-100, 100], inclusive. # Hints: 1. As Bogo Sort is excessively inefficient, think of improving it by incorporating some elements ensuring quicker convergence to the result. 2. You might reuse some concepts from linear probing for collision resolution in hash tables or scheduling algorithms. # Example: ```python >>> efficient_bogo_sort([3, 2, 1]) [1, 2, 3] >>> efficient_bogo_sort([1, 1, 1, 1]) [1, 1, 1, 1] ```","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Check if the given list is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def efficient_bogo_sort(arr: List[int]) -> List[int]: An improved version of Bogo Sort that checks random pairs and swaps to sort the array. while not is_sorted(arr): # Choose two different random indices i, j = random.sample(range(len(arr)), 2) # Swap elements if they are out of order if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Bubble Sort Visualization You are given an unsorted list of integers. Your task is to implement a bubble sort algorithm with the addition of a debugging feature that logs the iterations of the list as it gets sorted. This will help in visualizing each step of the sorting process. Function Signature ```python def bubble_sort_visualized(arr: list) -> list: ``` Input 1. A list of integers: `arr` (0 ≤ len(arr) ≤ 1000, -10^6 ≤ arr[i] ≤ 10^6) Output 1. A sorted list in ascending order. Constraints 1. Use the bubble sort approach to solve this problem. 2. Your implementation should log the iteration number and the state of the list after every swap operation. Example ```python arr = [5, 3, 8, 4, 2] bubble_sort_visualized(arr) ``` # Expected Output ``` iteration 1 : 3 5 8 4 2 iteration 2 : 3 5 4 8 2 iteration 3 : 3 5 4 2 8 iteration 4 : 3 4 5 2 8 iteration 5 : 3 4 2 5 8 iteration 6 : 3 2 4 5 8 iteration 7 : 2 3 4 5 8 ``` Note: The example represents logging every intermediate list state after each swap until the list is completely sorted. Explanation - Create a function `bubble_sort_visualized` that takes an array of integers as input. - Implement the bubble sort algorithm within this function. - Add a print statement within the inner loop to log the current iteration of the sort and the state of the array after each swap. - Return the sorted array as the output. Testing Consider edge cases such as: - An empty array - A single-element array - Arrays already sorted, both in ascending and descending order. - Arrays with all elements the same","solution":"def bubble_sort_visualized(arr): Sorts the list using the bubble sort algorithm and logs each iteration. n = len(arr) if n <= 1: return arr iteration = 1 for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True print(f\'iteration {iteration} : {\\" \\".join(map(str, arr))}\') iteration += 1 if not swapped: break return arr"},{"question":"# Task: Implement an optimized version of Prim\'s Algorithm to find the weight of the Minimum Spanning Tree (MST) for a given undirected, connected graph. # Problem Statement: You are provided a connected, undirected graph. Your task is to implement a function `prime_minimum_spanning_optimized()` to determine the weight of its Minimum Spanning Tree (MST). # Function Signature: ```python def prime_minimum_spanning_optimized(graph: Dict[str, List[Tuple[int, str]]]) -> int: ``` # Input: - `graph`: A dictionary representing the adjacency list of the graph, where each key is a node, and its value is a list of tuples. Each tuple contains two elements: - An integer representing the edge weight. - A string representing the adjacent node. # Output: - Returns an integer which is the total weight of the MST. # Constraints: - The graph is guaranteed to be connected. - Weights of the edges are non-negative integers. - The graph does not have duplicate edges between any two nodes. # Example ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } print(prime_minimum_spanning_optimized(graph)) # Output: 14 ``` # Additional Notes: - Ensure that your implementation efficiently handles the priority queue operations to achieve optimal performance. - Consider edge cases and test against disconnected graphs and graphs with non-standard node names.","solution":"import heapq def prime_minimum_spanning_optimized(graph): if not graph: return 0 # Start from an arbitrary node, here we choose the first node from the dictionary. start_node = next(iter(graph)) visited = set([start_node]) min_heap = [(weight, start_node, to) for weight, to in graph[start_node]] heapq.heapify(min_heap) mst_weight = 0 while min_heap: weight, frm, to = heapq.heappop(min_heap) if to not in visited: visited.add(to) mst_weight += weight for next_weight, neighbor in graph[to]: if neighbor not in visited: heapq.heappush(min_heap, (next_weight, to, neighbor)) return mst_weight"},{"question":"# Valid Anagram Check with Optimized Constraints Question You are given two strings `s` and `t`. Write a function `optimized_is_anagram` to determine if `t` is an anagram of `s` by optimizing space usage. Assume the strings only contain lowercase alphabets. Implementation Details 1. **Function Signature**: `def optimized_is_anagram(s: str, t: str) -> bool:` 2. **Input**: Two strings `s` and `t`. 3. **Output**: A boolean value indicating if `t` is an anagram of `s`. Constraints 1. Both input strings will have at most 100,000 characters. 2. Only lowercase alphabetical characters (\'a\' to \'z\') are allowed. 3. You are not allowed to use more than O(1) additional space in terms of character storage. Performance Requirements - **Time Complexity**: Your solution should run in O(n) time where n is the length of the string `s`. - **Space Complexity**: Use O(1) additional space for auxiliary purposes. Example ```python s = \\"anagram\\" t = \\"nagaram\\" output = True s = \\"rat\\" t = \\"car\\" output = False ``` Hint Consider how you can maintain character counts with a single data structure and constraints around additional space usage. # Solution Template ```python def optimized_is_anagram(s: str, t: str) -> bool: if len(s) != len(t): return False # Initialize count array for 26 lowercase letters count = [0] * 26 # Update counts based on characters in both s and t for char in s: count[ord(char) - ord(\'a\')] += 1 for char in t: count[ord(char) - ord(\'a\')] -= 1 # Check if all counts are zero for c in count: if c != 0: return False return True ```","solution":"def optimized_is_anagram(s: str, t: str) -> bool: if len(s) != len(t): return False # Initialize count array for 26 lowercase letters count = [0] * 26 # Update counts based on characters in both s and t for char in s: count[ord(char) - ord(\'a\')] += 1 for char in t: count[ord(char) - ord(\'a\')] -= 1 # Check if all counts are zero for c in count: if c != 0: return False return True"},{"question":"# Question As part of managing a library of book references, you need to frequently find the predecessor book based on an ordering attribute (e.g., ID or Publish Date). Given a Binary Search Tree (BST) structure where each node represents a book, write a function to find the predecessor of a given book node within the tree. Function Signature ```python def predecessor(root, node): pass ``` Input * `root`: The root node of the BST. It can be `None`. * `node`: The node whose predecessor needs to be found. Output * Return the predecessor node if it exists; otherwise, return `None`. Constraints * Each node in the tree has a unique value. * The tree may be unbalanced. * The given `node` will always be in the tree. Example Consider the BST below: ``` 20 / 10 30 / 5 15 35 17 ``` Suppose the given `node` is the node with value 15: * The expected output would be the node with value 10. Notes - Your solution should efficiently find the predecessor by leveraging BST properties. - Handle edge cases such as when the node is the smallest element or when the input tree is empty. - Aim for a solution with O(h) time complexity, where h is the height of the tree, and constant space complexity O(1).","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def predecessor(root, node): Find the in-order predecessor of the given node in the BST. if not root or not node: return None # Step 1: If there is a left subtree, find the maximum node in that subtree if node.left: pred = node.left while pred.right: pred = pred.right return pred # Step 2: Traverse from the root to find the predecessor from ancestor nodes pred = None current = root while current: if node.value > current.value: pred = current current = current.right elif node.value < current.value: current = current.left else: break return pred"},{"question":"# Question Context You are tasked with building a component of a real-time analytics system that processes a continuous stream of integer data. Your component should compute the moving average of the last \'n\' elements every time a new number is added to the stream. Requirements Implement a class `MovingAverage` that supports the following operations: 1. **Initialization**: Initialize an instance of `MovingAverage` with a specified window size. 2. **Next Value**: Add a new integer into the stream and return the moving average of the last \'n\' elements. Function Specifications 1. **__init__(self, size: int) -> None**: - **Input**: `size` (int) - The size of the sliding window. - **Output**: None. 2. **next(self, val: int) -> float**: - **Input**: `val` (int) - The new integer value to add to the stream. - **Output**: Returns the moving average of the last \'n\' values (float). Constraints - The sliding window size will be a positive integer. - The integer stream will consist of valid integer values. Example ```python # Example Usage: moving_average = MovingAverage(3) print(moving_average.next(1)) # Output: 1.0 print(moving_average.next(10)) # Output: 5.5 print(moving_average.next(3)) # Output: 4.67 (approximately) print(moving_average.next(5)) # Output: 6.0 ``` You are required to handle edge cases where the stream initially contains fewer elements than the window size. The initial average should be calculated using all the elements present until the window size is reached.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int) -> None: self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: self.window.append(val) self.window_sum += val if len(self.window) > self.size: self.window_sum -= self.window.popleft() return self.window_sum / len(self.window)"},{"question":"Scenario Imagine you are developing a text editing tool that allows users to transform one document into another by only deleting characters. You need to create a function that computes the minimum number of deletions required to make two given strings identical. Problem Statement Given two words `word1` and `word2`, write a function `min_distance_dp(word1, word2)` that finds the minimum number of steps required to make `word1` and `word2` the same by deleting characters. Implementation Details - **Function Signature**: `def min_distance_dp(word1: str, word2: str) -> int` - **Input**: - `word1`: a string with length `m` (1 <= m <= 1000) - `word2`: a string with length `n` (1 <= n <= 1000) - **Output**: An integer representing the minimum number of deletion steps. - **Constraints**: - Both `word1` and `word2` consist of only lowercase English letters. - Your algorithm should run within a time complexity of `O(m * n)`. Example ```python # Example 1 word1 = \\"sea\\" word2 = \\"eat\\" print(min_distance_dp(word1, word2)) # Output: 2 # Explanation: One step to delete \'s\' from \\"sea\\", another step to delete \'t\' from \\"eat\\" to make both strings \\"ea\\". # Example 2 word1 = \\"leetcode\\" word2 = \\"etco\\" print(min_distance_dp(word1, word2)) # Output: 4 # Explanation: Delete \'l\', \'e\', \'d\' and another \'e\' from \\"leetcode\\" to make both strings \\"etco\\". ``` Requirements 1. Implement the `min_distance_dp` function using dynamic programming to find the minimum number of deletions. 2. Make sure to detail any assumptions and edge cases you handle in the function.","solution":"def min_distance_dp(word1: str, word2: str) -> int: Returns the minimum number of deletions required to make both words identical. m, n = len(word1), len(word2) # Create a DP table with (m+1) x (n+1) dimensions dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If word1 is empty, remove all characters from word2 elif j == 0: dp[i][j] = i # If word2 is empty, remove all characters from word1 elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no deletion needed else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) # Min deletion from either word1 or word2 return dp[m][n]"},{"question":"**Question: Validate Stack Sorting Using Functions** A software system maintains a stack when processing data. For an efficient operation, it\'s crucial to ensure that the stack is sorted in ascending order from bottom to top. Implement a function `validate_sorting` that validates the order in an optimal manner. # Function Signature ```python def validate_sorting(stack: List[int]) -> bool: ``` # Input - **stack**: A list of integers representing the stack, where the last element of the list is the top of the stack. # Output - Returns a boolean value: - `True` if the stack is sorted in ascending order from bottom to top. - `False` otherwise. # Constraints - The stack can be of an arbitrary size, including empty stacks. - Elements are integers within a reasonable bound (e.g., -10^6 to 10^6). # Performance Requirements - The solution should operate with O(n) time complexity and aim to use O(1) additional space complexity if possible. # Example ```python # Example 1 stack = [1, 2, 3, 4, 5, 6] print(validate_sorting(stack)) # Output: True # Example 2 stack = [6, 3, 5, 1, 2, 4] print(validate_sorting(stack)) # Output: False # Example 3 stack = [] print(validate_sorting(stack)) # Output: True # Example 4 stack = [42] print(validate_sorting(stack)) # Output: True ``` # Hints 1. Handle edge cases such as an empty stack or a single element stack directly. 2. Consider more efficient ways to validate the sorting order without using auxiliary space. Implement this function to demonstrate your understanding of stack validation and optimal algorithmic implementation.","solution":"def validate_sorting(stack): Validates if the stack is sorted in ascending order from bottom to top. Parameters: - stack (List[int]): List of integers representing the stack. Returns: - bool: True if sorted, False otherwise. # If the stack is empty or has one element, it is trivially sorted if len(stack) <= 1: return True # Iterate through the stack and check if each element is less than or equal to the next element for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"# Permutation Algorithm: Generating Permutations of a List You\'ve learned about recursively generating permutations of a list of distinct numbers. Now it\'s your turn to implement it using an iterative approach. Task Description: Write a function `permute_iterative(elements)` that returns a list of all possible permutations of the given list using an iterative method. Function Signature: ```python def permute_iterative(elements: List[int]) -> List[List[int]]: ``` Input: - `elements` (List[int]): A list of distinct integers, where 1 <= len(elements) <= 10. Output: - List[List[int]]: A list of lists, where each inner list represents a distinct permutation of the input list. Constraints: - All elements in the input list are distinct. - The implementation should avoid using recursion. Example: ```python permute_iterative([1, 2, 3]) # Expected Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ``` Performance: Ensure the function performs efficiently within the given constraints. Additional Context (if any): You may use auxiliary data structures such as queues or stacks to help achieve the iterative permutation generation.","solution":"from typing import List def permute_iterative(elements: List[int]) -> List[List[int]]: Returns all possible permutations of the input list using an iterative approach. results = [[]] for element in elements: new_results = [] for permutation in results: for i in range(len(permutation) + 1): new_results.append(permutation[:i] + [element] + permutation[i:]) results = new_results return results"},{"question":"You are given a 2D grid of size `m x n` initialized with these three possible values: - `-1`: Represents a wall or an obstacle. - `0`: Represents a gate (the starting point for distance measurement). - `INF`: Represents an empty room (use the value (2^{31} - 1 = 2147483647) to denote INF). The task is to write a function that fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the cell should be left as `INF`. You are required to implement this function without using Depth-First Search (DFS) due to its inefficiency in this context. Instead, use Breadth-First Search (BFS) for a more efficient solution. # Requirements * **Input Format**: - `rooms`: A list of lists of size `m x n`, where each entry is one of `-1`, `0`, or `INF`. * **Output Format**: - The function should modify the `rooms` grid in place to update the distances. It should not return anything. * **Constraints**: - All the interior cells in the grid are initialized with `-1`, `0`, or `INF`. - There will be at least one gate in the grid. # Example ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) # After running your function, the 2D grid should be: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` # Function Signature ```python def walls_and_gates(rooms): # Your code goes here ``` # Notes * Ensure the grid is updated in place. * Consider using a queue to implement BFS for optimal performance. * Handle edge cases like isolated cells or grids fully filled with walls properly.","solution":"from collections import deque def walls_and_gates(rooms): Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the room should remain at its initial INF value. if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) INF = 2147483647 # Using 2^31 - 1 to denote INF queue = deque() # Start by adding all gates to the queue for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Directions for moving in the grid (up, down, left, right) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"Scenario: A popular social media platform uses linked lists to model relationships between user posts. However, sometimes due to system glitches or incorrect user inputs, some posts form cycles (i.e., a post links back to one of its predecessors creating an infinite loop). Your task is to develop an algorithm using Floyd\'s Tortoise and Hare algorithm to detect these cycles and identify the starting post of the cycle. Implement the function `detect_cycle_start(head: Node) -> Optional[Node]` to return the node where the cycle begins. If no cycle exists, return `None`. Expected Input and Output: * **Input**: The function receives the head node of a singly linked list. * **Output**: The function returns the node where the cycle begins or `None` if no cycle is present. Constraints: * The linked list may contain up to ( 10^5 ) nodes. * Node values are unique. Example: ```python class Node: def __init__(self, x): self.val = x self.next = None head = Node(1) head.next = Node(2) cyclic_node = Node(3) head.next.next = cyclic_node head.next.next.next = Node(4) head.next.next.next.next = cyclic_node assert detect_cycle_start(head).val == 3 ``` Implementation Requirements: * Implement the `detect_cycle_start` function. * Consider edge cases such as the linked list with no nodes, a single node cycle, or a large list with no cycle. * Ensure the code handles performance requirements within the constraint limits.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def detect_cycle_start(head: Node) -> Node: # Step 1: Detect the cycle using Floyd\'s Tortoise and Hare algorithm slow, fast = head, head cycle_detected = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break # Step 2: If no cycle is detected, return None if not cycle_detected: return None # Step 3: Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Roman Numeral to Integer Conversion Enhancement Given the existing implementation for converting Roman numerals to integers, improve this function to handle invalid input scenarios. Specifically, ensure the function only processes valid Roman numeral representations and raise appropriate errors for invalid ones. Input A string `s` representing the Roman numeral. It is guaranteed to contain only upper case letters but may or may not represent a valid Roman numeral. Output An integer representing the value of the Roman numeral if valid, otherwise raise a `ValueError` with the message \\"Invalid Roman numeral\\". Constraints 1. The input string contains only uppercase alphabetical characters. 2. The Roman numeral should be within the range from 1 to 3999 inclusive. Requirements: 1. Handle invalid numerals that do not conform to standard Roman numeral rules. 2. Maintain linear time complexity of O(n). 3. Preserve the space complexity of O(1). # Performance Expectations: Your implementation should ensure the average runtime is efficient for long input strings (e.g., up to 15 characters). # Example ```python def roman_to_int(s: str) -> int: # Your enhanced implementation here pass # Testing assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 # Edge and error cases try: roman_to_int(\\"IIII\\") except ValueError as e: assert str(e) == \\"Invalid Roman numeral\\" try: roman_to_int(\\"IC\\") except ValueError as e: assert str(e) == \\"Invalid Roman numeral\\" ```","solution":"def roman_to_int(s: str) -> int: Converts a valid Roman numeral string to an integer. Raises ValueError for invalid input. roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } valid_subtractives = {\'IV\', \'IX\', \'XL\', \'XC\', \'CD\', \'CM\'} n = len(s) total = 0 i = 0 while i < n: if i + 1 < n and s[i:i+2] in valid_subtractives: total += roman_values[s[i+1]] - roman_values[s[i]] i += 2 elif s[i] in roman_values: total += roman_values[s[i]] i += 1 else: raise ValueError(\\"Invalid Roman numeral\\") # Validate final value by converting back and comparing if int_to_roman(total) != s: raise ValueError(\\"Invalid Roman numeral\\") return total def int_to_roman(number: int) -> str: Helper function to convert an integer to a Roman numeral string. Used to validate the converted integer back to its string form. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while number > 0: for _ in range(number // val[i]): roman_num += syb[i] number -= val[i] i += 1 return roman_num"},{"question":"# Question: Bitwise Fibonacci Sequence You are working on optimizing algorithms for a low-level embedded system where memory and performance are critical. You need to implement a function that calculates the Fibonacci number but only using bitwise operations for performance efficiency. Given an integer `n`, your task is to write the most optimized version of a function, `bitwise_fibonacci(n)`, that computes the `n`th Fibonacci number. Use the bit manipulation functions (`get_bit`, `set_bit`, `clear_bit`, `update_bit`) provided above to achieve the result. **Function Signature**: ```python def bitwise_fibonacci(n: int) -> int: pass ``` # Constraints - (0 leq n leq 30) - You must utilize the provided bitwise utility functions. - You can\'t use multiplication, division, or modulus operators. # Input - `n` (integer): the position in the Fibonacci sequence. # Output - Returns the `n`th Fibonacci number (integer). # Examples - `bitwise_fibonacci(0)` should return `0`. - `bitwise_fibonacci(1)` should return `1`. - `bitwise_fibonacci(5)` should return `5`. - `bitwise_fibonacci(10)` should return `55`. **Note**: The Fibonacci sequence is defined as: - (F(0) = 0) - (F(1) = 1) - (F(n) = F(n-1) + F(n-2)) for (n geq 2) **Hint**: Consider how you can use the basic bitwise operations to add numbers together, as addition without using the plus operator is the key challenge here.","solution":"def bitwise_add(a, b): while b != 0: carry = a & b a = a ^ b b = carry << 1 return a def bitwise_fibonacci(n): if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for i in range(2, n + 1): next_value = bitwise_add(prev, curr) prev = curr curr = next_value return curr"},{"question":"**Question**: Implement a function that uses a modified version of the Bogo Sort algorithm. In this version, stop the algorithm after a specific number of maximum iterations even if the array is not sorted, and return the array along with the number of iterations performed. The function should also handle edge cases such as empty arrays and arrays with one element. # Function Signature: ```python def limited_bogo_sort(arr: List[int], max_iterations: int) -> Tuple[List[int], int]: pass ``` # Input: * `arr` - A list of integers that needs to be sorted. * `max_iterations` - An integer defining the maximum number of iterations to stop the algorithm. # Output: * Return a tuple containing: 1. The (possibly sorted or partially sorted) array. 2. The number of iterations performed until termination. # Constraints: * 0 ≤ len(arr) ≤ 10 * 1 ≤ max_iterations ≤ 10000 # Example: 1. Given `arr = [3, 1, 2]`, `max_iterations = 100`, the function might return `([1, 2, 3], 5)` indicating that it took 5 iterations to sort the array. 2. Given `arr = [4, 3, 2, 1]`, `max_iterations = 2`, the function might return `([2, 1, 3, 4], 2)` indicating that after two shuffles, the array is still not sorted. # Implementation Notes: * Use the `random.shuffle` method to randomly permute the elements of `arr`. * Include a helper function that checks if the array is sorted. * Efficiently handle edge cases such as empty arrays in your solution.","solution":"import random from typing import List, Tuple def is_sorted(arr: List[int]) -> bool: Helper function that checks if the given array is sorted. return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) def limited_bogo_sort(arr: List[int], max_iterations: int) -> Tuple[List[int], int]: Uses a modified version of the Bogo Sort algorithm that stops after a specific number of maximum iterations. iterations = 0 while not is_sorted(arr) and iterations < max_iterations: random.shuffle(arr) iterations += 1 return arr, iterations"},{"question":"Detecting Cycles in an Undirected Graph Given an undirected graph represented as an adjacency list, write a function `has_cycle(graph)` that checks whether the graph contains a cycle. You may use either Depth-First Search (DFS) or Breadth-First Search (BFS) to implement this. Function Signature: ```python def has_cycle(graph: dict) -> bool: # your code here ``` Input: * `graph`: A dictionary representing an undirected graph, where the keys are node identifiers and the values are lists of adjacent nodes. Each node is an integer. Output: * Return `True` if the graph contains a cycle, otherwise return `False`. Examples: ```python graph1 = {0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2]} assert has_cycle(graph1) == True graph2 = {0: [1], 1: [0, 2], 2: [1, 3], 3: [2]} assert has_cycle(graph2) == False ``` Constraints: * Each node identifier in the graph is a unique integer. * All edges are undirected. * The graph can have between 1 and 500 nodes. Guidance: 1. Implement a cycle detection algorithm using either DFS or BFS. 2. During traversal, keep track of visited nodes. 3. For DFS, ensure that you do not count the path to the parent node as a cycle.","solution":"def has_cycle(graph): def dfs(node, parent): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, node): return True elif neighbor != parent: return True return False visited = {node: False for node in graph} for node in graph: if not visited[node]: if dfs(node, -1): return True return False"},{"question":"You are tasked to implement a highly efficient function to compute the Greatest Common Divisor (GCD) of two positive integers using bitwise operations. This method should leverage bitwise shifts and basic arithmetic to maintain performance. Additionally, you are to handle edge cases where inputs might be zero correctly. # Constraints 1. Inputs will be non-negative integers within the range 1 ≤ a, b ≤ 10^9. 2. Handle edge cases where one or both of the inputs might be zero (return zero GCD in these cases). # Input - Two non-negative integers `a` and `b`. # Output - A single integer which is the GCD of `a` and `b`. # Function Signature ```python def gcd_bitwise(a: int, b: int) -> int: pass ``` # Example ```python # Example 1 a = 15 b = 25 print(gcd_bitwise(a, b)) # Output: 5 # Example 2 a = 0 b = 20 print(gcd_bitwise(a, b)) # Output: 20 # Example 3 a = 50 b = 0 print(gcd_bitwise(a, b)) # Output: 50 ``` # Hints 1. Use bitwise operations such as shifting and subtraction instead of division and multiplication. 2. Consider the number of trailing zeros in the binary representation of the numbers.","solution":"def gcd_bitwise(a: int, b: int) -> int: Compute the greatest common divisor (GCD) of two non-negative integers using bitwise operations. If either a or b is 0, the GCD is the other number. if a == 0: return b if b == 0: return a # Count the number of trailing zeros in both a and b shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 # Remove all factors of 2 in a while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a # Restore common factors of 2 return a << shift"},{"question":"**Scenario**: You are given a partially filled 9x9 Sudoku board. Your task is to complete the board by filling in the missing numbers such that each row, each column, and each of the nine 3x3 sub-grids contains all the digits from 1 to 9. **Challenge**: Implement a class called `SudokuSolver` with methods to solve the Sudoku puzzle as described above. Your implementation should use constraint propagation and backtracking. **Function to Implement**: - **Class**: `SudokuSolver` - **Method 1**: `__init__(self, board: List[List[str]])`: Initializes the Sudoku board and possible values. - **Method 2**: `solve(self) -> bool`: Attempts to solve the Sudoku puzzle in place and returns `True` if solved. - **Method 3**: `valid_one(self, num: str, pos: tuple, update: dict) -> bool`: Validates the placement of a number and updates constraints. - **Method 4**: `undo(self, pos: tuple, update: dict)`: Reverts updates when backtracking. - **Method 5**: `possible_values(self) -> dict`: Generates a dictionary with possible values for each empty cell. **Input**: - `board`: A 9x9 list of lists representing the Sudoku board, where empty cells are denoted by \\".\\" **Output**: - `solve` method should return `True` if the puzzle is successfully solved, otherwise `False`. **Example**: ```python from typing import List class SudokuSolver: def __init__(self, board: List[List[str]]): # your implementation def solve(self) -> bool: # your implementation def valid_one(self, num: str, pos: tuple, update: dict) -> bool: # your implementation def undo(self, pos: tuple, update: dict): # your implementation def possible_values(self) -> dict: # your implementation # Example Usage: board = [ [ \'5\', \'3\', \'.\', \'.\', \'7\', \'.\', \'.\', \'.\', \'.\' ], [ \'6\', \'.\', \'.\', \'1\', \'9\', \'5\', \'.\', \'.\', \'.\' ], [ \'.\', \'9\', \'8\', \'.\', \'.\', \'.\', \'.\', \'6\', \'.\' ], [ \'8\', \'.\', \'.\', \'.\', \'6\', \'.\', \'.\', \'.\', \'3\' ], [ \'4\', \'.\', \'.\', \'8\', \'.\', \'3\', \'.\', \'.\', \'1\' ], [ \'7\', \'.\', \'.\', \'.\', \'2\', \'.\', \'.\', \'.\', \'6\' ], [ \'.\', \'6\', \'.\', \'.\', \'.\', \'.\', \'2\', \'8\', \'.\' ], [ \'.\', \'.\', \'.\', \'4\', \'1\', \'9\', \'.\', \'.\', \'5\' ], [ \'.\', \'.\', \'.\', \'.\', \'8\', \'.\', \'.\', \'7\', \'9\' ] ] solver = SudokuSolver(board) solved = solver.solve() print(solved) # Output: True or False depending on if the puzzle was solved # The board should be filled in place if solved ``` **Constraints**: - The board is always a 9x9 grid. - Each cell contains either a digit from \'1\' to \'9\' or a \'.\' indicating an empty cell.","solution":"from typing import List, Tuple, Dict class SudokuSolver: def __init__(self, board: List[List[str]]): self.board = board def solve(self) -> bool: empty = self.find_empty() if not empty: return True row, col = empty for num in map(str, range(1, 10)): if self.valid_one(num, (row, col)): self.board[row][col] = num if self.solve(): return True self.board[row][col] = \'.\' return False def valid_one(self, num: str, pos: Tuple[int, int]) -> bool: row, col = pos # Check the row for c in range(9): if self.board[row][c] == num and c != col: return False # Check the column for r in range(9): if self.board[r][col] == num and r != row: return False # Check the box box_x, box_y = row // 3, col // 3 for r in range(box_x * 3, box_x * 3 + 3): for c in range(box_y * 3, box_y * 3 + 3): if self.board[r][c] == num and (r, c) != pos: return False return True def find_empty(self) -> Tuple[int, int]: for r in range(9): for c in range(9): if self.board[r][c] == \'.\': return (r, c) return None"},{"question":"`is_sorted_linked_list()` You are provided with a `LinkedList` class that supports basic stack operations (`push` and `pop`). Write a function `is_sorted_linked_list()` that checks whether the elements in this linked list (acting as a stack) are in ascending order from the bottom to the top. # Requirements - Input: A `LinkedList` object. - Output: A boolean value—`True` if the linked list is sorted in ascending order from bottom to top, and `False` otherwise. # Constraints - You may use O(n) extra space for auxiliary purposes. - Do not modify the original linked list permanently. Restore it to the original state after checking. - Ensure your function handles empty lists and single-element lists correctly. # Performance Requirements - Ensure the time complexity of your solution is O(n). # Example ```python # Using LinkedList class class Node: def __init__(self, value=None): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def push(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def pop(self): if self.head is None: return None value = self.head.value self.head = self.head.next return value # Example usage ll = LinkedList() ll.push(6) ll.push(5) ll.push(3) ll.push(2) ll.push(1) print(is_sorted_linked_list(ll)) # Output: True ll.push(0) print(is_sorted_linked_list(ll)) # Output: False ``` # Scenarios and Context Imagine you are preparing a stack (implemented as a linked list) of orders to be processed. Each order has a priority, and before processing, you would like to ensure all orders are stored in ascending priority from bottom to top. Implement `is_sorted_linked_list()` to facilitate this check.","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def push(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def pop(self): if self.head is None: return None value = self.head.value self.head = self.head.next return value def is_sorted_linked_list(ll): Check if the linked list (acting as a stack) is sorted in ascending order from bottom to top. if ll.head is None or ll.head.next is None: return True # Temp list to store the stack values to verify ordering elements = [] current = ll.head while current is not None: elements.append(current.value) current = current.next # Check if the extracted elements list is sorted in ascending order for i in range(len(elements) - 1): if elements[i] > elements[i + 1]: return False return True"},{"question":"You are given a string `s` as input. Your task is to remove any recurring characters in the string and return a new string containing only the first occurrence of each character. The order of characters in the new string should be the same as their first appearance in the input string. # Requirements - **Function signature**: `def delete_recurring_characters(s: str) -> str:` - **Input**: A single string `s` (0 <= len(s) <= 10^6). - **Output**: A new string with recurring characters removed. # Constraints - The input string `s` may contain any printable ASCII characters. - The function should be optimized for both time and space efficiency. # Examples 1. Input: \\"swiss\\" Output: \\"swi\\" 2. Input: \\"programming\\" Output: \\"progamin\\" 3. Input: \\"aabbcc\\" Output: \\"abc\\" 4. Input: \\"\\" Output: \\"\\" 5. Input: \\"abcdef\\" Output: \\"abcdef\\" # Notes - **Edge Cases**: Ensure your solution handles inputs like empty strings or strings with all same characters efficiently. - **Performance**: The solution should run efficiently even for the maximum input size. Implement the function based on these requirements.","solution":"def delete_recurring_characters(s: str) -> str: Removes recurring characters and returns a string with only the first occurrence of each character. Parameters: s (str): The input string. Returns: str: A new string with recurring characters removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Question You are tasked with implementing a function that determines whether a given string follows a specific pattern. This scenario is common when ensuring that strings conform to template constraints, like validating formatted data input. Write a function `word_pattern(pattern: str, input_string: str) -> bool` that checks if the provided `input_string` follows the given `pattern`. There must be a bijection (one-to-one and onto mapping) between characters in the `pattern` and words in the `input_string`. Function Signature ```python def word_pattern(pattern: str, input_string: str) -> bool: # Your code here ``` Input - `pattern`: A non-empty string containing only lowercase letters. - `input_string`: A non-empty string containing lowercase words separated by a single space. Output - Returns a boolean value `True` if `input_string` follows the `pattern`, otherwise returns `False`. Constraints - The length of `pattern` and the number of words in `input_string` must be the same. - There is a bijection between a letter in `pattern` and a non-empty word in `input_string`. Examples 1. Input: `pattern = \\"abba\\"`, `input_string = \\"dog cat cat dog\\"` Output: `True` Explanation: There is a one-to-one mapping between pattern characters and words in the input string. 2. Input: `pattern = \\"abba\\"`, `input_string = \\"dog cat cat fish\\"` Output: `False` Explanation: `dog` and `fish` map to `a` but they are assigned different characters in the pattern. 3. Input: `pattern = \\"aaaa\\"`, `input_string = \\"dog cat cat dog\\"` Output: `False` Explanation: Single pattern character can\'t map to different words. 4. Input: `pattern = \\"abba\\"`, `input_string = \\"dog dog dog dog\\"` Output: `False` Explanation: Distinct characters in pattern should map to distinct words.","solution":"def word_pattern(pattern: str, input_string: str) -> bool: words = input_string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word and char_to_word[p] != w: return False if w in word_to_char and word_to_char[w] != p: return False char_to_word[p] = w word_to_char[w] = p return True"},{"question":"Two Sum with Edge Cases and Space Consideration Objective Implement a function `two_sum_with_edge_cases` that returns the indices of the two numbers such that they add up to a specific target. Enhance the original implementation by addressing edge cases and providing an efficient solution even for memory-constrained environments. Requirements * **Input**: - `array`: A list of integers, denoting the array of numbers. - `target`: An integer, denoting the target sum of two numbers from the array. * **Output**: - A tuple of two integers representing the indices of the two numbers that add up to the target sum. If no such pair exists, return `None`. * **Constraints**: - Each input will have exactly one solution, but it should be verified. - You may not use the same element twice. - Aim to optimize both time and space complexity. Function Signature ```python def two_sum_with_edge_cases(array: List[int], target: int) -> Optional[Tuple[int, int]]: pass ``` Example ```python assert two_sum_with_edge_cases([2, 7, 11, 15], 9) == (0, 1) assert two_sum_with_edge_cases([3, 2, 4], 6) == (1, 2) assert two_sum_with_edge_cases([3, 3], 6) == (0, 1) assert two_sum_with_edge_cases([1], 2) == None assert two_sum_with_edge_cases([], 2) == None ``` Additional Constraints 1. You must handle the cases where the array is empty or has only one element. 2. Ensure that the algorithm\'s space complexity remains as low as possible while maintaining O(n) time complexity.","solution":"from typing import List, Tuple, Optional def two_sum_with_edge_cases(array: List[int], target: int) -> Optional[Tuple[int, int]]: Returns the indices of the two numbers such that they add up to the target. If no such pair exists, return None. if len(array) < 2: return None num_to_index = {} for i, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"As a part of your cryptography course, you are required to implement an Atbash cipher. An Atbash cipher is a simple substitution cipher where each letter of the alphabet is mapped to its reverse. For example, \'A\' is mapped to \'Z\', \'B\' to \'Y\', and so on. The case of the letters must be preserved, and any non-alphabet character should remain unchanged. Write a function `atbash_cipher(s: str) -> str` that takes a single string input and returns the Atbash cipher of that string. # Input * `s` (a string): The string to be encoded using the Atbash cipher. The string may contain any printable characters including spaces, punctuation, numbers, etc. # Output * Returns the encoded string where every alphabet character is replaced by its reverse in alphabetical order based on the Atbash cipher, maintaining the original case and preserving non-alphabet characters as is. # Examples 1. **Input**: `s = \\"Attack at dawn\\"` **Output**: `\\"Zggzxp zg wzdm\\"` 2. **Input**: `s = \\"hello, WORLD!\\"` **Output**: `\\"svool, DLIOW!\\"` 3. **Input**: `s = \\"123 @#&\\"` **Output**: `\\"123 @#&\\"` # Constraints * The input string `s` can be any valid printable string up to length 10^6. * Ensure your function runs in O(n) time complexity and uses O(n) additional space, where n is the length of the input string. # Hints * Consider using `ord()` and `chr()` functions to find the alphabetic positions and convert them back. * Keep track of both upper and lower case letters separately.","solution":"def atbash_cipher(s: str) -> str: def map_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) else: return c return \'\'.join(map(map_char, s))"},{"question":"Objective You are tasked with implementing a function to find the k-th to last element in a singly linked list using an efficient algorithm. This will test your understanding of linked list traversal, handling edge cases, and optimizing for space and time complexity. Problem Statement Given a singly linked list and an integer `k`, write a function `find_kth_to_last(head, k)` that returns the value of the k-th to last node. If `k` is invalid (less than 1 or greater than the length of the list), return `None`. Expected Input Format - `head` (Node): The head node of a singly linked list. - `k` (int): The position from the end of the list (1-based index). Expected Output Format - Return the value of the k-th to last node if it exists; otherwise return `None`. Constraints - The length of the linked list will not exceed (10^6). - Node values are strings consisting of alphabetical characters (both upper and lower case). - Do not use any Python built-in functions like `eval` or additional data structures like dictionaries or lists for solving this problem. Performance Requirements - The solution should run in (O(n)) time complexity. - The solution should use (O(1)) additional space. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> str: pass ``` # Example ```python # Example Linked List: # A -> B -> C -> D -> E a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e # Example 1: result = find_kth_to_last(a, 2) print(result) # Output: \\"D\\" # Example 2: result = find_kth_to_last(a, 5) print(result) # Output: \\"A\\" # Example 3: result = find_kth_to_last(a, 6) print(result) # Output: None ``` Notes - Use two pointers technique for optimal performance. - Consider edge cases such as `k` being outside the valid range or the list being empty. - Ensure proper handling of input values and provide meaningful output based on the constraints.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> str: if k < 1 or head is None: return None fast = head slow = head # Move fast pointer k steps ahead for _ in range(k): if fast is None: return None fast = fast.next # Move both pointers until fast reaches the end while fast is not None: slow = slow.next fast = fast.next return slow.val"},{"question":"# Matrix Chain Multiplication Optimization You are given a sequence of matrices, and you need to find the most efficient way to multiply these matrices together. The problem is to minimize the number of scalar multiplications needed to multiply the chain of matrices. The dimensions of the matrices are given in an array `P` such that matrix `A[i]` has dimensions `P[i-1] x P[i]` for `i = 1, 2, ..., n`. Write a function `matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]` that computes: 1. The minimum number of scalar multiplications needed. 2. The optimal sequence of matrix multiplications. You also need to write a function `print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None` that prints the optimal order of multiplications. Function Signature ```python from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: # Function implementation here def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: # Function implementation here ``` Input * `array`: A list of positive integers where `len(array) >= 2`. For an array of length `n`, it represents the dimensions of `n-1` matrices such that matrix `A[i]` has dimensions `array[i-1] x array[i]`. Output * `matrix_chain_order` returns a tuple containing: 1. A 2D list representing the minimum number of scalar multiplications needed. 2. A 2D list representing the optimal sequence of matrix multiplications. * `print_optimal_solution` prints the optimal order in which to multiply the matrices. Constraints * 2 ≤ len(array) ≤ 100 (To ensure performance within acceptable limits) Example ```python array = [30, 35, 15, 5, 10, 20, 25] #Size of matrix created from above array will be # 30*35, 35*15, 15*5, 5*10, 10*20, 20*25 matrix, optimal_solution = matrix_chain_order(array) # Should print the minimum number of operations required print(matrix[1][len(array)-1]) # Output: 15125 # Should print the optimal parenthesization of the product sequence print_optimal_solution(optimal_solution, 1, len(array)-1) # Output: ((A1 (A2 A3)) ((A4 A5) A6)) ``` Notes * Do not use any built-in libraries for matrix chain multiplication. * Ensure your code is efficient and handles the maximum constraints gracefully.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) - 1 # Since array has length n+1 for n matrices m = [[0] * (n + 1) for _ in range(n + 1)] s = [[0] * (n + 1) for _ in range(n + 1)] for l in range(2, n + 1): # l is the chain length for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + array[i-1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"You are given a square matrix represented as a 2D list. Your task is to implement a function that rotates the matrix 180 degrees (both clockwise and counterclockwise produce the same result). The function should modify the matrix in place without requiring additional space for another matrix. # Function Specification **Function Name**: `rotate_180(matrix)` **Input**: - A square matrix `matrix` of size NxN (2D list) where `2 <= N <= 1000`. **Output**: - The function does not return anything. Instead, it modifies the input matrix in place to represent the 180-degree rotation. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_180(matrix) # The modified matrix should be: # [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] ``` # Constraints * The input matrix is guaranteed to be non-empty and square. * You must perform the rotation in place to have an optimal space complexity of O(1). # Additional Challenge - Optimize your solution to handle very large matrices efficiently, considering both time and space complexity.","solution":"def rotate_180(matrix): Rotates the given matrix 180 degrees in place. n = len(matrix) for i in range(n // 2): for j in range(n): matrix[i][j], matrix[n-i-1][n-j-1] = matrix[n-i-1][n-j-1], matrix[i][j] if n % 2 == 1: mid = n // 2 for j in range(n // 2): matrix[mid][j], matrix[mid][n-j-1] = matrix[mid][n-j-1], matrix[mid][j]"},{"question":"# Matrix Manipulation Challenge Context You are tasked with developing an advanced graphical editor that allows users to rotate and invert images represented as 2D matrices. Your job is to implement functions that will: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Invert the matrix diagonally from the top-left corner to the bottom-right. 4. Invert the matrix diagonally from the bottom-left corner to the top-right. Each transformation should handle matrices of any size, including edge cases such as non-square matrices or empty matrices. Task Implement the following matrix manipulation functions. Ensure your functions handle the given constraints and edge cases effectively. **Function 1**: `rotate_clockwise(matrix)` - **Input**: A 2D list of integers representing the matrix. - **Output**: A new matrix that is the original matrix rotated 90 degrees clockwise. **Function 2**: `rotate_counterclockwise(matrix)` - **Input**: A 2D list of integers representing the matrix. - **Output**: A new matrix that is the original matrix rotated 90 degrees counterclockwise. **Function 3**: `top_left_invert(matrix)` - **Input**: A 2D list of integers representing the matrix. - **Output**: A new matrix that is the original matrix inverted along the diagonal from the top-left corner. **Function 4**: `bottom_left_invert(matrix)` - **Input**: A 2D list of integers representing the matrix. - **Output**: A new matrix that is the original matrix inverted along the diagonal from the bottom-left corner. Examples ```python # Example Matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Example Outputs # rotate_clockwise(matrix) should return: # [ # [7, 4, 1], # [8, 5, 2], # [9, 3, 0], # ] # rotate_counterclockwise(matrix) should return: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7], # ] # top_left_invert(matrix) should return: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9], # ] # bottom_left_invert(matrix) should return: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1], # ] ``` **Note**: Ensure to handle any edge cases, such as non-square matrices, empty matrices, or single row/column matrices, appropriately.","solution":"def rotate_clockwise(matrix): Rotates the matrix 90 degrees clockwise. if not matrix or not matrix[0]: return matrix return [list(reversed(col)) for col in zip(*matrix)] def rotate_counterclockwise(matrix): Rotates the matrix 90 degrees counterclockwise. if not matrix or not matrix[0]: return matrix return [list(col) for col in reversed(list(zip(*matrix)))] def top_left_invert(matrix): Inverts the matrix along the diagonal from the top-left to the bottom-right. n = len(matrix) if n == 0: return matrix m = len(matrix[0]) result = [[matrix[j][i] for j in range(n)] for i in range(m)] return result def bottom_left_invert(matrix): Inverts the matrix along the diagonal from the bottom-left to the top-right. n = len(matrix) if n == 0: return matrix m = len(matrix[0]) result = [[matrix[n-j-1][m-i-1] for j in range(n)] for i in range(m)] return result"},{"question":"# Question: Implement a Word Search Engine with Trie You are tasked with implementing a class for a word search engine that can efficiently add words and search for them, including patterns with wildcards, using a Trie (Prefix Tree). Your class should support the following functionalities: 1. **Add a Word**: Adds a word to the search engine. 2. **Search a Word**: Searches for a word or pattern, where `.` represents any character. Function Signatures: ```python class WordSearchEngine: def __init__(self): pass def add_word(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ``` Expected Input and Output: - `add_word(word: str)`: Adds the `word` string into the internal data structure. - `search(word: str) -> bool`: Determines if there is any word in the data structure that matches the `word`, with `.` representing any character. Returns `True` if the word or pattern is found, otherwise `False`. Constraints: 1. Input strings will consist of lowercase letters from \'a\' to \'z\' and the dot character \'.\'. 2. The length of the input strings will not exceed 100. Example Usage: ```python engine = WordSearchEngine() engine.add_word(\\"bad\\") engine.add_word(\\"dad\\") engine.add_word(\\"mad\\") print(engine.search(\\"pad\\")) # Output: False print(engine.search(\\"bad\\")) # Output: True print(engine.search(\\".ad\\")) # Output: True print(engine.search(\\"b..\\")) # Output: True ``` Notes: - Ensure efficient handling of large datasets and frequent operations. - Consider edge cases such as adding and searching for empty strings. - Validate that the search logic correctly handles patterns with multiple wildcards.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordSearchEngine: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_recursive(self.root, word, 0) def _search_recursive(self, node, word, index) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(child, word, index + 1): return True return False else: if char in node.children: return self._search_recursive(node.children[char], word, index + 1) else: return False"},{"question":"# Flatten a Nested Dictionary Use the principles of flattening nested structures to implement a function that can flatten a nested dictionary. # Function Signature ```python def flatten_dictionary(input_dict, parent_key=\'\', sep=\'_\'): Flattens a nested dictionary. Keys in the resultant dictionary should be composed of concatenated keys from nested dictionaries, separated by `sep`. Parameters: - input_dict (dict): The dictionary to be flattened. - parent_key (str, optional): The base key prefixed to nested keys in the result. - sep (str): Specifies the separator used in concatenated keys. Returns: - dict: The flattened dictionary with concatenated keys. ``` # Expected Input and Output Formats * **Input**: - A single dictionary, which may contain keys mapped to other dictionaries (nested) or iterable values. - Optional `sep` parameter to define custom separator for concatenating keys (default is \'_\'). * **Output**: - A flattened dictionary with keys composed by combining all nested keys using specified separator. # Constraints and Limitations * Handle dictionaries with any depth of nesting. * Avoid using mutable parameters for default arguments. * Ensure proper handling of non-dict iterable elements inside dictionaries (e.g., lists). * Strings should not be split during flattening. # Examples ```python input_dict = { \'a\': { \'b\': { \'c\': 1, \'d\': [2, 3] } }, \'e\': { \'f\': 4 } } result = flatten_dictionary(input_dict) print(result) # Expected Output: # { # \'a_b_c\': 1, # \'a_b_d\': [2, 3], # \'e_f\': 4 # } ``` # Performance Requirements The function should demonstrate an efficient approach to flatten nested dictionaries. Aim for O(n) time and O(m) space complexity, where n is the number of elements and m the depth of nesting.","solution":"def flatten_dictionary(input_dict, parent_key=\'\', sep=\'_\'): def _flatten(obj, key_prefix): if isinstance(obj, dict): items = {} for k, v in obj.items(): new_key = f\\"{key_prefix}{sep}{k}\\" if key_prefix else k items.update(_flatten(v, new_key)) return items else: return {key_prefix: obj} return _flatten(input_dict, parent_key)"},{"question":"# Matrix Transformation Challenge **Context**: As a junior software developer at a tech company, you are working on an image processing module. The module requires you to implement a series of matrix transformations that enhance the images by manipulating pixel arrangements. Your task is to write efficient, correct functions that perform these transformations. **Problem Statement**: Implement a function `rotate_clockwise(matrix)` that rotates an n x m matrix 90 degrees clockwise. # Function Signature ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: ``` # Input: - A 2D list `matrix` composed of integers. It can be rectangular, but not empty. # Output: - Returns a new matrix that is rotated 90 degrees clockwise. # Constraints: - You should not use any external libraries. - Optimize for readability and efficiency. - Handle edge cases gracefully. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Performance Requirements: - The time complexity should be O(n*m), where `n` is the number of rows and `m` is the number of columns. - The space complexity should be O(n*m). # Hint: Consider how rows and columns relate to each other after a 90-degree rotation, and how to rearrange elements to achieve this transformation effectively.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given n x m matrix 90 degrees clockwise. Params: - matrix (List[List[int]]): A 2D list representing the matrix. Returns: - List[List[int]]: A new matrix rotated 90 degrees clockwise. if not matrix or not matrix[0]: return [] n, m = len(matrix), len(matrix[0]) rotated_matrix = [] for j in range(m): new_row = [] for i in range(n-1, -1, -1): new_row.append(matrix[i][j]) rotated_matrix.append(new_row) return rotated_matrix"},{"question":"You are given a list of integers and two optional integer values, `min_lim` and `max_lim`, that represent the minimum and maximum limits for filtering the list. Your task is to implement a function that returns a new list containing elements that fall within the specified range (inclusive). If `min_lim` is None, use the smallest value in the list as the minimum limit. If `max_lim` is None, use the largest value in the list as the maximum limit. Function Signature ```python def filter_list(arr: list, min_lim: int = None, max_lim: int = None) -> list: ``` Input * `arr` (list): A list of integers. (0 <= len(arr) <= 10^6) * `min_lim` (int, optional): Minimum inclusive limit. Defaults to None. * `max_lim` (int, optional): Maximum inclusive limit. Defaults to None. Output * A new list containing elements from `arr` that fall within the specified range `[min_lim, max_lim]`. Constraints * You can assume all elements in `arr` are integers. * If `len(arr) == 0`, return an empty list. * It is guaranteed that if provided, `min_lim <= max_lim`. Examples ```python filter_list([1,2,3,4,5], min_lim=None, max_lim=3) # Output: [1, 2, 3] filter_list([7, 5, 9, 12, 4], min_lim=6, max_lim=10) # Output: [7, 9] filter_list([10, 20, 30], min_lim=15, max_lim=None) # Output: [20, 30] filter_list([], min_lim=None, max_lim=None) # Output: [] filter_list([5, 3, 8, 1], min_lim=7, max_lim=8) # Output: [8] ``` Note: * Handle cases where both `min_lim` and `max_lim` are None by using the smallest and largest values in `arr` respectively. * Consider the performance when `arr` contains up to one million elements.","solution":"def filter_list(arr: list, min_lim: int = None, max_lim: int = None) -> list: Returns a list of integers from \'arr\' that fall within the range [min_lim, max_lim]. If min_lim is None, the smallest value in \'arr\' is used as the minimum limit. If max_lim is None, the largest value in \'arr\' is used as the maximum limit. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Matrix Multiplication Implementation Given two matrices, implement a function `matrix_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]` that returns the product matrix if the matrices are compatible for multiplication, and raises an Exception if they are not. # Function Signature ```python def matrix_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: ``` # Input 1. `mat1` - a 2D list representing the first matrix with dimensions R1 x C1 where 1 <= R1, C1 <= 100. 2. `mat2` - a 2D list representing the second matrix with dimensions R2 x C2 where 1 <= R2, C2 <= 100. # Output A 2D list representing the product matrix with dimensions R1 x C2 if mat1 and mat2 are compatible for multiplication. # Constraints - The number of columns in the first matrix (C1) should be equal to the number of rows in the second matrix (R2). - If the matrices are not compatible, raise an Exception with the message \\"Incompatible matrices for multiplication.\\" # Examples 1. Matrix Multiplication Example ```python mat1 = [ [1, 2, 3], [4, 5, 6] ] mat2 = [ [7, 8], [9, 10], [11, 12] ] output = [ [58, 64], [139, 154] ] assert matrix_multiplication(mat1, mat2) == output ``` 2. Incompatible Matrices Example ```python mat1 = [ [1, 2], [3, 4] ] mat2 = [ [1, 2, 3], [4, 5, 6] ] try: matrix_multiplication(mat1, mat2) except Exception as e: assert str(e) == \\"Incompatible matrices for multiplication\\" ``` The solution should handle edge cases, such as: * Empty matrices. * Matrices with non-uniform inner list lengths. * Large matrices close to the constraint limits. * Ensure exceptions are raised correctly for invalid inputs. # Performance Requirements Maintain a time complexity of O(R1 * C1 * C2) and space complexity of O(R1 * C2). Ensure the solution is optimized given the constraints.","solution":"from typing import List def matrix_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: # Get the dimensions of the matrices R1, C1 = len(mat1), len(mat1[0]) R2, C2 = len(mat2), len(mat2[0]) # Check if matrices can be multiplied if C1 != R2: raise Exception(\\"Incompatible matrices for multiplication\\") # Initialize the product matrix with zeros product_matrix = [[0 for _ in range(C2)] for _ in range(R1)] # Multiply mat1 and mat2 for i in range(R1): for j in range(C2): for k in range(C1): product_matrix[i][j] += mat1[i][k] * mat2[k][j] return product_matrix"},{"question":"# Preorder Traversal Coding Challenge Scenario You are working on a project involving binary trees where you need to traverse the trees in preorder fashion frequently. You are required to implement two functions: one iterative and one recursive, to perform preorder traversal of a given binary tree. Task Implement two functions, `preorder_iterative` and `preorder_recursive`, that perform preorder traversal of a given binary tree. Function Signatures: ```python def preorder_iterative(root: Node) -> List[int]: def preorder_recursive(root: Node) -> List[int]: ``` Input: - `root`: The root node of the binary tree. The `Node` class is defined as: ```python class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right ``` Output: - Both functions should return a list of integers representing the preorder traversal of the binary tree. Examples: ```python # Example 1 root = Node(1, Node(2), Node(3)) assert preorder_iterative(root) == [1, 2, 3] assert preorder_recursive(root) == [1, 2, 3] # Example 2 root = None assert preorder_iterative(root) == [] assert preorder_recursive(root) == [] # Example 3 root = Node(1, Node(2, Node(4, Node(8)), Node(5, None, Node(9))), Node(3)) assert preorder_iterative(root) == [1, 2, 4, 8, 5, 9, 3] assert preorder_recursive(root) == [1, 2, 4, 8, 5, 9, 3] ``` Constraints: - The number of nodes in the tree will be in the range [0, 10^4]. - Node values are integers in the range [-10^9, 10^9]. Good luck, and happy coding!","solution":"class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def preorder_iterative(root: Node) -> list: Perform an iterative preorder traversal of a binary tree. if root is None: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return output def preorder_recursive(root: Node) -> list: Perform a recursive preorder traversal of a binary tree. if root is None: return [] output = [root.val] if root.left: output.extend(preorder_recursive(root.left)) if root.right: output.extend(preorder_recursive(root.right)) return output"},{"question":"You are working on a text processing application where you need to highlight specific parts of words with predefined symbols. Your task is to implement a function that finds and replaces the longest symbols found within each word from a given list, marking them with square brackets (`[]`). Function Signature ```python def highlight_symbols_in_words(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Input and Output Formats **Input:** - `words`: List of strings (1 leq text{len(words)} leq 10^5), each word containing (1 leq text{len(word)} leq 100) characters. - `symbols`: List of strings (1 leq text{len(symbols)} leq 10^2), each symbol containing (1 leq text{len(symbol)} leq 20) characters. **Output:** - Return a list of words where each word has its longest matching symbol surrounded by square brackets. If no symbol matches, return the word as it is. # Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] **Sample Output:** [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Constraints 1. If a word contains multiple matching symbols, choose the one with the longest length. 2. If a word contains no matching symbols, it should be returned unchanged. 3. Symbols may overlap; in such cases, ensure the correct symbol is chosen based on length priority. # Note - Avoid using brute force search due to potential inefficiency. - Utilize Trie (Prefix Tree) for efficient symbol matching. # Hints 1. Start by constructing a Trie with all the symbols. 2. For each word, search through the Trie to find all possible matching symbols. 3. Replace the longest matching symbol with the symbol surrounded by brackets and return the modified list of words. Good luck!","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False def build_trie(symbols): root = TrieNode() for symbol in symbols: current = root for char in symbol: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.end_of_word = True return root def find_longest_symbol(word, root): longest_symbol = \'\' for i in range(len(word)): current = root j = i current_symbol = \'\' while j < len(word) and word[j] in current.children: current = current.children[word[j]] current_symbol += word[j] j += 1 if current.end_of_word and len(current_symbol) > len(longest_symbol): longest_symbol = current_symbol return longest_symbol def highlight_symbols_in_words(words, symbols): root = build_trie(symbols) highlighted_words = [] for word in words: longest_symbol = find_longest_symbol(word, root) if longest_symbol: start_index = word.index(longest_symbol) end_index = start_index + len(longest_symbol) highlighted_word = word[:start_index] + \'[\' + longest_symbol + \']\' + word[end_index:] highlighted_words.append(highlighted_word) else: highlighted_words.append(word) return highlighted_words"},{"question":"You are required to implement a **Min Binary Heap** to manage a collection of integer values. Specifically, you need to complete a class that supports the following operations: 1. `insert(val)`: Insert an integer value into the heap. Ensure the min-heap property is maintained after insertion. 2. `remove_min()`: Remove and return the minimum element in the binary heap. Ensure the min-heap property is maintained after removal. # Implementation Details: - You are provided with a `BinaryHeap` class skeleton. Your task is to implement the `insert`, `remove_min`, and helper methods (`perc_up`, `perc_down`, `min_child`) to ensure the proper functioning of the heap. - The heap should be implemented using an array, with the first index (0) reserved (to make calculations easier). # Input/Output Format: ```python class BinaryHeap: def __init__(self): Initialize the heap. pass def insert(self, val): Insert value into the heap. pass def remove_min(self): Remove and return the minimum element from the heap. pass # Example Usage: bh = BinaryHeap() bh.insert(4) bh.insert(50) bh.insert(7) bh.insert(55) bh.insert(90) bh.insert(87) bh.insert(2) print(bh.remove_min()) # should print 2 print(bh.remove_min()) # should print 4 ``` # Constraints: - The elements inserted will be integer values. - Maximum number of elements in the heap will be 10^5. # Performance Requirements: - All operations must maintain their optimal time complexities. - Ensure that the class works efficiently for large inputs, keeping space complexity in mind.","solution":"class BinaryHeap: def __init__(self): Initialize the heap. self.heap_list = [0] self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap_list[i] < self.heap_list[i // 2]: # Swap the elements if child is less than parent self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i] i = i // 2 def insert(self, val): Insert value into the heap. self.heap_list.append(val) self.current_size += 1 self.perc_up(self.current_size) def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap_list[i] > self.heap_list[mc]: # Swap the elements if parent is greater than the smaller child self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i] i = mc def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap_list[i * 2] < self.heap_list[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def remove_min(self): Remove and return the minimum element from the heap. retval = self.heap_list[1] self.heap_list[1] = self.heap_list[self.current_size] self.heap_list.pop() self.current_size -= 1 self.perc_down(1) return retval"},{"question":"**Matrix Chain Multiplication** You are given an array `p` of size `n` where `p[i]` represents the number of rows in the ith matrix, and `p[m]` represents the number of columns in the (m-1)th matrix. The goal is to determine the minimum number of scalar multiplications needed to multiply the given sequence of matrices. Write a function `matrix_chain_min_mult` which returns this minimum number of scalar multiplications. # Function Signature ```python def matrix_chain_min_mult(p: List[int]) -> Tuple[int, List[List[int]]]: pass ``` # Input - `p`: List of integers representing the chain of matrices where `p[i]` and `p[i+1]` are dimensions of the ith matrix. # Output - Returns a tuple of: - An integer, the minimum number of scalar multiplications required. - A 2D list denoting the splits at different stages for optimal multiplication. # Constraints - `2 <= len(p) <= 100` - `1 <= p[i] <= 500` # Examples ```python from typing import List, Tuple def matrix_chain_min_mult(p: List[int]) -> Tuple[int, List[List[int]]]: INF = float(\\"inf\\") n = len(p) matrix = [[0 for x in range(n)] for x in range(n)] sol = [[0 for x in range(n)] for x in range(n)] for chain_length in range(2, n): for a in range(1, n - chain_length + 1): b = a + chain_length - 1 matrix[a][b] = INF for c in range(a, b): cost = matrix[a][c] + matrix[c + 1][b] + p[a - 1] * p[c] * p[b] if cost < matrix[a][b]: matrix[a][b] = cost sol[a][b] = c return matrix[1][n-1], sol # Example Test Case p = [30, 35, 15, 5, 10, 20, 25] result, solution = matrix_chain_min_mult(p) print(result) # Output: Minimum number of multiplications is 15125 ``` **Note**: 1. The function should handle edge cases gracefully. 2. Ensure you use dynamic programming principles optimally. 3. Add comments or docstrings where necessary to explain logic.","solution":"from typing import List, Tuple def matrix_chain_min_mult(p: List[int]) -> Tuple[int, List[List[int]]]: Function to compute the minimum number of scalar multiplications required to multiply a sequence of matrices. :param p: List of integers where p[i] is the number of rows of the i-th matrix and p[i+1] is the number of columns of the i-th matrix. :return: Tuple containing the minimum number of multiplications and the split points n = len(p) # Create a 2D list `matrix` initialized to 0 matrix = [[0 for _ in range(n)] for _ in range(n)] # 2D list to store the split points sol = [[0 for _ in range(n)] for _ in range(n)] # `matrix[i][j]` will hold the minimum number of multiplications needed for A[i]A[i+1]...A[j] for length in range(2, n): # length is the current length of the chain for i in range(1, n - length + 1): j = i + length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): cost = matrix[i][k] + matrix[k + 1][j] + p[i - 1] * p[k] * p[j] if cost < matrix[i][j]: matrix[i][j] = cost sol[i][j] = k return matrix[1][n - 1], sol"},{"question":"# Problem Description You are building a system that requires frequent prefix sum queries and updates on a list of sales data. Efficiency is critical due to the high volume of updates and queries. # Task Implement a Fenwick Tree data structure to achieve efficient prefix sum queries and updates. Your implementation should handle the following operations: 1. **construct**: Takes a list of integers and builds the Fenwick Tree. 2. **update**: Updates the Fenwick Tree at a specific index with a new value. 3. **prefix_sum**: Returns the sum of the first `i` elements (0-based index). # Input and Output - **Input**: 1. `construct(freq: List[int]) -> None` - `freq` is a list of integers representing initial data. 2. `update(index: int, value: int) -> None` - `index` specifies the element to update, and `value` is the new value. 3. `prefix_sum(index: int) -> int` - `index` specifies the range from the start to `index` (inclusive). - **Output**: 1. `construct` does not return any value. 2. `update` does not return any value. 3. `prefix_sum` returns an integer representing the sum from start to `index`. # Constraints - 0 <= `index` < len(freq) - `value` is an integer. # Function Signatures ```python class FenwickTree: def __init__(self, freq: List[int]): self.construct(freq) def construct(self, freq: List[int]) -> None: Creates and initializes a Fenwick Tree for the given list of integers. pass def update(self, index: int, value: int) -> None: Updates the Fenwick Tree at the given index with the new value. pass def prefix_sum(self, index: int) -> int: Returns the sum of elements from the start to the given index. pass ``` # Example ```python # Example Usage freq = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2] fenwick_tree = FenwickTree(freq) fenwick_tree.update(3, 5) # update index 3 to value 5 assert fenwick_tree.prefix_sum(5) == 31 # sum of elements 1 to 5 inclusive ``` # Notes - Your implementation should use the provided class structure. - Ensure that your methods handle indexing correctly, considering 0-based indexing of `freq`. - Optimize for time complexity to ensure both `prefix_sum` and `update` operations are O(log n).","solution":"class FenwickTree: def __init__(self, freq): Initializes and builds the Fenwick Tree using the provided frequency list. self.n = len(freq) self.tree = [0] * (self.n + 1) self.freq = freq[:] self.construct(freq) def construct(self, freq): Creates and initializes a Fenwick Tree for the given list of integers. for i in range(self.n): self._update_internal(i, freq[i]) def _update_internal(self, index, value): Helper method to update the Fenwick Tree at the given index with the new value. index += 1 while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): Updates the Fenwick Tree at the given index with the new value. delta = value - self.freq[index] self.freq[index] = value self._update_internal(index, delta) def prefix_sum(self, index): Returns the sum of elements from the start to the given index. index += 1 total = 0 while index > 0: total += self.tree[index] index -= index & -index return total"},{"question":"# Context: You are tasked with developing a navigation system for a new city that is being built. As part of the system, you need to implement an algorithm to find the shortest paths between different locations in the city. The city is represented as a graph where intersections are nodes and roads are the weighted edges between these nodes. # Task: Implement Dijkstra\'s algorithm to find the shortest paths from a given source intersection to all other intersections in the city. # Function Signature: ```python def dijkstra_shortest_paths(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: Finds the shortest path distances from the source node to all other nodes in a graph. Parameters: vertex_count (int): the number of vertices in the graph. edges (List[Tuple[int, int, int]]): a list of tuples where each tuple represents an edge in the format (u, v, w), u is the start node, v is the end node, and w is the weight of the edge. src (int): the source node. Returns: List[int]: shortest distance from src to each node. pass ``` # Input: - `vertex_count`: An integer representing the number of intersections (nodes) in the city. - `edges`: A list of tuples, where each tuple (u, v, w) represents a road going from intersection u to intersection v with weight w, representing travel time. - `src`: An integer representing the starting intersection. # Output: - A list of distances where the ith element is the shortest distance from the source intersection to intersection i. If an intersection is not reachable, the distance should be represented as infinity (`float(\'inf\')`). # Constraints: - `1 <= vertex_count <= 1000` - `0 <= edge weights <= 1000` # Performance Requirements: - The solution should be efficient, aiming for O(V^2) or better time complexity. # Example: ```python vertex_count = 5 edges = [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3), (3, 4, 1)] src = 0 print(dijkstra_shortest_paths(vertex_count, edges, src)) # Output: [0, 2, 3, 9, 6] ``` # Additional Notes: - The function should be implemented without using any specific library functions outside of basic data structures. - Consider potential optimizations for reducing time complexity, such as using priority queues.","solution":"import heapq from typing import List, Tuple def dijkstra_shortest_paths(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: Finds the shortest path distances from the source node to all other nodes in a graph. Parameters: vertex_count (int): the number of vertices in the graph. edges (List[Tuple[int, int, int]]): a list of tuples where each tuple represents an edge in the format (u, v, w), u is the start node, v is the end node, and w is the weight of the edge. src (int): the source node. Returns: List[int]: shortest distance from src to each node. # Create adjacency list from edges adj_list = [[] for _ in range(vertex_count)] for u, v, w in edges: adj_list[u].append((v, w)) # Initialize distances and priority queue distances = [float(\'inf\')] * vertex_count distances[src] = 0 priority_queue = [(0, src)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the current distance is already greater than the recorded shortest distance, skip processing if current_distance > distances[current_node]: continue # Expand the neighbors for neighbor, weight in adj_list[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Linked List Intersection Problem Objective Write a function `intersection` which takes the heads of two singly linked lists and returns the node at which the two linked lists intersect. If the lists don\'t intersect, return `None`. The intersection is determined based on the node references, not their values. Node Class A Node class is defined as: ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None ``` Function Signature ```python def intersection(h1: Node, h2: Node) -> Node: # Write your code here ``` Input Format * `h1` and `h2` are the heads of two singly linked lists. Output Format * Return the intersecting node (Node object) if the lists intersect, otherwise return `None`. Constraints * The linked list lengths can be from 0 to 10^5 nodes. * The values within each node are not unique and cannot be used to determine the intersection point. Example Consider the linked lists formed as: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` * Input: `h1` starting at `Node(1)` and `h2` starting at `Node(2)` * Output: Node with value `7` Performance Requirements Achieve an average case time complexity of O(N + M) and constant space complexity. Scenario Two linked lists may represent sequences of events in different paths, where paths converge at a certain point. Your task requires identifying the intersection node to ascertain the merging of these paths accurately.","solution":"class Node(object): def __init__(self, val=None): self.val = val self.next = None def get_length_and_tail(node): length = 0 while node: length += 1 if not node.next: return length, node node = node.next return length, node def intersection(h1: Node, h2: Node) -> Node: if not h1 or not h2: return None len1, tail1 = get_length_and_tail(h1) len2, tail2 = get_length_and_tail(h2) if tail1 is not tail2: return None longer, shorter = (h1, h2) if len1 > len2 else (h2, h1) for _ in range(abs(len1 - len2)): longer = longer.next while longer and shorter: if longer is shorter: return longer longer = longer.next shorter = shorter.next return None"},{"question":"Given a sorted list of lowercase letters `letters` and a target lowercase letter `target`, write a function `next_greatest_letter` to find the smallest element in the list that is larger than the given target. If no such element exists, it should return the first element in the list (wrapping around). Input - `letters`: A sorted list of lowercase letters. - `target`: A lowercase letter. Output - Return the smallest element in the list that is larger than the target letter. Example ```python letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" print(next_greatest_letter(letters, target)) # Output: \\"c\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" print(next_greatest_letter(letters, target)) # Output: \\"f\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" print(next_greatest_letter(letters, target)) # Output: \\"f\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"j\\" print(next_greatest_letter(letters, target)) # Output: \\"c\\" ``` # Constraints - The list `letters` will always be sorted in ascending order. - The list `letters` will have at least 2 characters. - All elements of `letters` are lowercase letters. - The target letter `target` is a lowercase letter. # Requirements - Implement the function using binary search to ensure efficient performance. - Ensure that your function handles edge cases properly (e.g., wrapping around the list). # Function Signature ```python def next_greatest_letter(letters: List[str], target: str) -> str: pass ```","solution":"from typing import List def next_greatest_letter(letters: List[str], target: str) -> str: Returns the smallest element in the sorted list `letters` that is larger than `target`. Wraps around to the beginning of the list if no such element exists. start, end = 0, len(letters) - 1 # If the target is greater than or equal to the last element, # return the first element (wrap around) if target >= letters[-1]: return letters[0] while start <= end: mid = (start + end) // 2 if letters[mid] > target: end = mid - 1 else: start = mid + 1 return letters[start]"},{"question":"# Problem Context You have been given a Markov Chain that models state transitions of a simple probabilistic system. Your task is to implement a function that generates a sequence of future states from a given initial state using this Markov Chain. # Task Implement a function `generate_state_sequence(chain, initial_state, num_steps)` that generates a sequence of states for a given number of steps in the Markov Chain. # Input * `chain`: A dictionary representing the Markov chain. Each key is a state, and its associated value is another dictionary. This inner dictionary maps possible next states to their transition probabilities. * `initial_state`: A string representing the initial state of the system. * `num_steps`: An integer representing the number of future states to generate. # Output * A list of strings where each string is a state in the sequence generated from the Markov Chain, starting from the `initial_state` and generating `num_steps` transitions. # Constraints * Transition probabilities are valid (i.e., they sum to 1 for each state). * The chain dictionary keys are valid state names used as strings. * There is at least one state and all states have at least one outgoing transition. # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' num_steps = 5 result = generate_state_sequence(chain, initial_state, num_steps) print(result) # Output may look like: [\'E\', \'A\', \'A\', \'E\', \'A\'] ``` Write the following function: ```python def generate_state_sequence(chain, initial_state, num_steps): # Your code here pass ``` # Additional Notes * Ensure your code handles edge cases like states with probabilities summing to less than or more than 1. * Optimize where possible to ensure efficiency for a large number of states and transitions.","solution":"import random def generate_state_sequence(chain, initial_state, num_steps): Generate a sequence of states for a given number of steps in the Markov Chain. Parameters: - chain: Dictionary representing the Markov chain. - initial_state: Starting state of the Markov chain. - num_steps: Number of steps (transitions) to generate. Returns: - List of states generated by the sequence. current_state = initial_state state_sequence = [] for _ in range(num_steps): next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] state_sequence.append(next_state) current_state = next_state return state_sequence"},{"question":"Problem: Enhanced Linear Search with Constraints You are given an unsorted array of integers and a target value. Your task is to implement an enhanced version of the linear search algorithm that meets the following specifications: 1. **Positive Integer Target**: The function will only search for positive integers. 2. **Early Stopping**: If the target value is found, the function should print \\"Found\\" and return immediately without continuing the search. 3. **Even Position Search**: Only search and compare elements at even indices (0, 2, 4, ...). 4. **Output Message**: If the target is not found after searching all even indices, print \\"Not Found\\" and return -1. # Function Signature ```python def enhanced_linear_search(array, target): pass ``` # Input - `array` (list of int): An unsorted list of integers where the search is to be performed. - `target` (int): The positive integer value to search for in the array. # Output - Returns the index of the target if found at an even index, or -1 if not found. It should also print \\"Found\\" if the target is found and \\"Not Found\\" otherwise. # Constraints - The length of the array will be between 1 and 10^5. - The integers in the array can be negative, zero, or positive. - The target value will be a positive integer. # Example ```python # Example 1 array = [5, 3, 8, 4, 9, 1, 7, 6, 2] target = 7 # Output: Should print \\"Found\\" and return 6 # Example 2 array = [2, 7, 5, 1, 6, 3, 8, 4] target = 9 # Output: Should print \\"Not Found\\" and return -1 ``` # Notes - Ensure that the function efficiently checks only even indices and immediately stops if the target is found. - Properly handle edge cases such as empty arrays or arrays without any even indices.","solution":"def enhanced_linear_search(array, target): Searches for the target in the given array by only checking even indices. Prints \\"Found\\" and returns the index if the target is found. Prints \\"Not Found\\" and returns -1 if the target is not found. if target <= 0: return -1 for i in range(0, len(array), 2): if array[i] == target: print(\\"Found\\") return i print(\\"Not Found\\") return -1"},{"question":"Advanced Combinatorial Subsets Generation Problem Statement You\'re given a list of distinct integers, `nums`. Your task is to write a function that generates all possible subsets of the given list. Given the nature of the problem, the solution set must not contain any duplicate subsets. Requirements * **Function Signature**: ```python def advanced_subsets(nums: List[int]) -> Set[Tuple[int, ...]]: ``` * **Input**: * `nums` is a list of distinct integers with length in range `[0, 20]`. * Example: `[1, 2, 3]` * **Output**: * A set of tuples, where each tuple represents a possible subset of `nums`. * Example: `{(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)}` * **Constraints**: * The input `nums` will have no more than 20 elements. * Subsets must be unique and sorted within each subset to maintain consistent output formats. Instructions 1. Write the `advanced_subsets` function that takes a list of distinct integers as its parameter and returns a set of all possible subsets. 2. Use bit manipulation to generate subsets efficiently to handle the upper constraints effectively. 3. Make sure to account for: * An empty list (should return a set with the empty tuple). * Proper handling of each integer inclusion/exclusion using bitwise operations. 4. **Performance Requirements**: * Your solution should be optimized to handle the upper limit of the input size, as it can grow exponentially in terms of the number of subsets. Example ```python # Example 1 input = [1, 2, 3] output = {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} # Example 2 input = [] output = {()} ```","solution":"from typing import List, Set, Tuple def advanced_subsets(nums: List[int]) -> Set[Tuple[int, ...]]: Generate all possible subsets of the given list of distinct integers. n = len(nums) result = set() # Iterate over all possible combinations using bitwise representation for i in range(1 << n): subset = [] for j in range(n): if i & (1 << j): subset.append(nums[j]) result.add(tuple(sorted(subset))) return result"},{"question":"**Scenario**: You are working on a combinatorics module for an advanced mathematics toolkit. One of the functionalities you require is calculating binomial coefficients, which are essential in various statistical models and probability calculations. **Problem**: Write an implementation that calculates the binomial coefficient `C(n, k)` using a recursive approach. Ensure that the function handles edge cases effectively and provide a way to optimize the calculation for large inputs. **Function Signature**: ```python def recursive_binomial_coefficient(n: int, k: int) -> int: Calculates the binomial coefficient, C(n, k), with n >= k using recursion. Parameters: - n (int): The total number of items. - k (int): The number of chosen items. Returns: int: The binomial coefficient for the given values of n and k. Raises: - ValueError: If n < k. Constraints: - 0 <= k <= n <= 1000 - The function should handle large values efficiently. Examples: >>> recursive_binomial_coefficient(5, 0) 1 >>> recursive_binomial_coefficient(8, 2) 28 >>> recursive_binomial_coefficient(10, 3) 120 ``` **Input**: * Two non-negative integers `n` and `k` such that `0 <= k <= n <= 1000`. **Output**: * An integer representing the binomial coefficient `C(n, k)`. **Requirements**: * Raise a `ValueError` if `n < k`. * Apply the symmetry property to optimize recursive calls. * Handle edge cases, such as `k = 0`, `k = n`, and `k > n/2`, adequately.","solution":"def recursive_binomial_coefficient(n: int, k: int) -> int: Calculates the binomial coefficient, C(n, k), with n >= k using recursion. Parameters: - n (int): The total number of items. - k (int): The number of chosen items. Returns: int: The binomial coefficient for the given values of n and k. Raises: - ValueError: If n < k. Constraints: - 0 <= k <= n <= 1000 - The function should handle large values efficiently. Examples: >>> recursive_binomial_coefficient(5, 0) 1 >>> recursive_binomial_coefficient(8, 2) 28 >>> recursive_binomial_coefficient(10, 3) 120 if k > n: raise ValueError(\\"k cannot be greater than n\\") # Using the symmetry property: C(n, k) == C(n, n-k) k = min(k, n - k) if k == 0 or k == n: return 1 if k == 1: return n # Using memoization to optimize the recursive solution cache = {} def compute(n, k): if (n, k) in cache: return cache[(n, k)] if k == 0 or k == n: return 1 result = compute(n - 1, k - 1) + compute(n - 1, k) cache[(n, k)] = result return result return compute(n, k)"},{"question":"Context Suppose you are working on a text processing feature for an application that needs to reverse the words in a given sentence. Your task is to implement a function that can efficiently reverse the order of words in a sentence, while handling edge cases like leading/trailing spaces and continuous spaces between words. Task Write a function `reverse_sentence(sentence: str) -> str` that takes a string `sentence` as input and returns a new string where the words (delimited by spaces) are reversed in order. Ensure that there are no leading, trailing, or multiple intermediate spaces in the returned string. Input Format * A single string `sentence` (0 <= len(sentence) <= 10^6) containing words delimited by spaces. Output Format * A single string where the words in the input sentence are reversed. Constraints * Do not use additional data structures to store intermediate results other than what is necessary for the result string. * The function should handle edge cases efficiently while maintaining optimal performance. * The manual operations on lists (like the in-place reversal) will be evaluated for efficiency. Example ```python def reverse_sentence(sentence: str) -> str: # Write your code here # Example test cases: assert reverse_sentence(\\"I am keon kim and I like pizza\\") == \\"pizza like I and kim keon am I\\" assert reverse_sentence(\\" Hello World \\") == \\"World Hello\\" assert reverse_sentence(\\"\\") == \\"\\" assert reverse_sentence(\\"Python\\") == \\"Python\\" print(\\"All test cases pass\\") ```","solution":"def reverse_sentence(sentence: str) -> str: Returns a string where the words in the input sentence are reversed. Handles leading, trailing, and multiple intermediate spaces. # Split the sentence by spaces words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a single string reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"You are given an unsorted array of integers. Implement the Cocktail Shaker Sort algorithm to sort the array in ascending order. Your implementation should handle edge cases efficiently and ensure the output is a sorted version of the input array. # Input * An unsorted list `arr` of integers where `1 <= len(arr) <= 10^3`. # Output * The sorted list in ascending order. # Constraints * You are required to implement the Cocktail Shaker Sort algorithm. * You should make sure that your function has O(n) space complexity. # Example ```python def cocktail_shaker_sort(arr): # Your implementation here # Example usage print(cocktail_shaker_sort([4, 3, 2, 1])) # Output should be [1, 2, 3, 4] print(cocktail_shaker_sort([1, 2, 3, 4])) # Output should be [1, 2, 3, 4] print(cocktail_shaker_sort([5, 1, 4, 2, 8, 0])) # Output should be [0, 1, 2, 4, 5, 8] ``` # Performance Requirements * Your function should be efficient enough to handle the average case within a reasonable time frame (less than a second for arrays of size up to 1000).","solution":"def cocktail_shaker_sort(arr): Implements the Cocktail Shaker Sort algorithm to sort the input array in ascending order. n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing moved, then array is sorted if not swapped: break # Reset the swapped flag so we can use it in the next stage swapped = False # Move the end point back by one end -= 1 # Traverse the array from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Increase the starting point start += 1 return arr"},{"question":"**Problem Description**: You are tasked with writing a function that computes the maximum elements of each sub-array of length `k` from a given array of integers `arr`. **Function Signature**: ```python def max_sliding_window(arr: List[int], k: int) -> List[int]: ``` **Input**: - `arr` (List[int]): A list of integers where the length is denoted by `n`. - `k` (int): An integer defining the size of the sliding window. **Output**: - Returns a list of integers, where each integer is the maximum of the corresponding sub-array of length `k`. **Constraints**: - 1 ≤ `n` ≤ 10^5 - 1 ≤ `k` ≤ `n` - `arr[i]` (where 0 ≤ i < n) is an integer such that -10^4 ≤ `arr[i]` ≤ 10^4 **Example**: ```python assert max_sliding_window([1,3,-1,-3,5,3,6,7], 3) == [3, 3, 5, 5, 6, 7] assert max_sliding_window([1], 1) == [1] ``` **Scenario**: In a scenario where you are constantly monitoring an array of temperature readings, you want to know the maximum temperature recorded over every consecutive `k` hours. This would help in analyzing peak temperature trends efficiently.","solution":"from collections import deque from typing import List def max_sliding_window(arr: List[int], k: int) -> List[int]: Returns the maximum of each sub-array of length k from the given array. if not arr or k == 0: return [] n = len(arr) if k == 1: return arr result = [] deq = deque() for i in range(n): # remove indexes of elements not from the sliding window if deq and deq[0] == i - k: deq.popleft() # remove indexes of all elements which are less than the current element arr[i] while deq and arr[deq[-1]] < arr[i]: deq.pop() deq.append(i) # the first element in the deque is the largest element in the window if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"# Question: Pairwise Stack Swap with Auxiliary Storage You are given a stack that contains integer elements. Implement a function that switches successive pairs of numbers in the stack starting from the bottom. If the stack has an odd number of elements, the element at the top remains in its position. Your task is to implement two different functions to achieve this using different auxiliary storage methods: 1. `switch_pairs_with_stack(stack)`: Use an auxiliary stack to switch pairs. 2. `switch_pairs_with_queue(stack)`: Use an auxiliary queue to switch pairs. Input and Output Formats * **Input**: A list representing a stack of integers. The top of the stack is represented by the last element in the list. * **Output**: The modified list representing the stack after switching successive pairs of elements. Constraints * The input list should have a length of at most (10^5). * The elements in the list will be integers between (-10^9) and (10^9). Examples 1. Input: `stack = [3, 8, 17, 9, 1, 10]` Output: `[8, 3, 9, 17, 10, 1]` 2. Input: `stack = [3, 8, 17, 9, 1]` Output: `[8, 3, 9, 17, 1]` 3. Input: `stack = [5]` Output: `[5]` 4. Input: `stack = []` Output: `[]` # Function Signatures ```python def switch_pairs_with_stack(stack): # implement your code here pass def switch_pairs_with_queue(stack): # implement your code here pass ``` Implement both functions to pass the example cases and handle potentially large inputs within reasonable performance limits.","solution":"def switch_pairs_with_stack(stack): Switch successive pairs of numbers in the stack using an auxiliary stack. aux_stack = [] while stack: aux_stack.append(stack.pop()) while aux_stack: first = aux_stack.pop() if aux_stack: second = aux_stack.pop() stack.append(second) stack.append(first) return stack def switch_pairs_with_queue(stack): Switch successive pairs of numbers in the stack using an auxiliary queue. from collections import deque aux_queue = deque() while stack: aux_queue.appendleft(stack.pop()) while aux_queue: first = aux_queue.popleft() if aux_queue: second = aux_queue.popleft() stack.append(second) stack.append(first) return stack # Define helpers to be used in tests def list_to_stack(lst): Converts a list to a stack (the last element is at the top, the first at the bottom). return lst def stack_to_list(stack): Converts a stack to a list (the first element of the stack (bottom) is the first element of the list). return stack"},{"question":"You are given a list of intervals where each interval is represented as a pair of integers `[start, end]`. The `start` represents the starting point of the interval, and `end` represents the end point of the interval. Your task is to merge all overlapping intervals and return the resulting list of intervals in a non-overlapping manner sorted on their start times. # Input and Output * **Input**: A list of intervals `[[start1, end1], [start2, end2], ..., [startN, endN]]`, where `start1, start2, ..., startN` are integers representing the start points and `end1, end2, ..., endN` are integers representing the end points. * **Output**: A list of merged intervals sorted according to their starting points. # Constraints * A starting interval should always be less than or equal to its ending interval. * All intervals are valid on the real number line and should be managed accordingly. # Examples Example 1: * **Input**: `[[1, 3], [2, 6], [8, 10], [15, 18]]` * **Output**: `[[1, 6], [8, 10], [15, 18]]` * **Explanation**: Intervals `[1, 3]` and `[2, 6]` merge into `[1, 6]`. Example 2: * **Input**: `[[1, 4], [4, 5]]` * **Output**: `[[1, 5]]` * **Explanation**: Intervals `[1, 4]` and `[4, 5]` merge into `[1, 5]`. # Performance Requirements * The algorithm should have a time complexity of `O(n log n)` where `n` is the number of intervals due to the sorting step. * Space complexity should be kept minimal. # Task Implement the function `merge_intervals(intervals: List[List[int]]) -> List[List[int]]` that takes a list of intervals and returns a list of merged intervals. # Function Signature ```python from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: # Your code here ``` # Notes 1. Handle edge cases like empty list or single interval appropriately. 2. Ensure the intervals are merged based on their overlap and sorted accordingly.","solution":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges overlapping intervals and returns the resulting list of intervals sorted by start time. if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_interval = intervals[0] for interval in intervals[1:]: # Check if intervals overlap if interval[0] <= current_interval[1]: # Merge the intervals current_interval[1] = max(current_interval[1], interval[1]) else: # No overlap, add the current interval to the list and start a new interval merged_intervals.append(current_interval) current_interval = interval # Add the last interval merged_intervals.append(current_interval) return merged_intervals"},{"question":"# Problem: Implement an Enhanced Trie Data Structure You are tasked with implementing an enhanced version of the Trie data structure that supports the following operations: 1. insert(word): Insert a word into the Trie. 2. search(word): Returns True if the word is in the Trie, else returns False. 3. starts_with(prefix): Returns True if there is any word in the Trie that starts with the given prefix. 4. delete(word): Delete a word from the Trie. # Input Specifications: * You may assume that all inputs are lowercase letters a-z. * The `insert`, `search`, `starts_with`, and `delete` methods will be called multiple times. # Output Specifications: * The `search` and `starts_with` methods should return a boolean value indicating the result. * The `delete` method should ensure that the specified word is removed from the Trie. # Constraints: * You may assume that words will contain only lowercase English letters. * You should optimize the implementation to handle large datasets efficiently. # Performance Requirements: * All operations should aim for an average time complexity of O(m), where m is the length of the word or prefix. * Space complexity should be managed to avoid excessive use of memory, preferably through optimizing against common prefixes. # Example: ```python trie = EnhancedTrie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns False print(trie.starts_with(\\"app\\")) # Returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Returns True trie.delete(\\"apple\\") print(trie.search(\\"apple\\")) # Returns False print(trie.starts_with(\\"app\\")) # Returns True ``` Implement the class `EnhancedTrie` with the required methods.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class EnhancedTrie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def delete(self, word): def _delete(node, word, depth): if not node: return False if depth == len(word): if node.is_end_of_word: node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char in node.children: should_delete_child = _delete(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return not node.is_end_of_word and len(node.children) == 0 return False _delete(self.root, word, 0)"},{"question":"# Permutation Generator Context: You\'ve developed a basic permutation generator that works well for small sets of elements. However, as the number of elements grows, the time and space required escalate drastically due to the large number of permutations (n!). Your task is to implement a more efficient permutation generator using an iterative approach and optimize memory usage. Problem Statement: Write a function `optimized_permute_iter(elements)` that generates all permutations of a given list of distinct numbers using an efficient iterative method. Input: - `elements` (List[int]): A list of distinct integers. Output: - `Iterator[List[int]]`: An iterator that yields each permutation one at a time. Constraints: - The length of the list `elements` will be between 1 and 9, inclusive. Performance Requirements: - Avoid recursive depth errors. - Minimize memory usage. Example Usage: ```python def optimized_permute_iter(elements): # Your implementation here # Example usage: elements = [1, 2, 3] for permutation in optimized_permute_iter(elements): print(permutation) ``` Expected Example Output: ``` [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1] ``` **Note**: You should employ an iterative approach for the generation logic rather than recursion.","solution":"def optimized_permute_iter(elements): Generates all permutations of the list of elements using an iterative approach. if len(elements) <= 1: yield elements return # Sort elements to start with the lowest lexicographic permutation elements.sort() yield list(elements) while True: # Step 1: Find the largest index i such that elements[i] < elements[i + 1]. # If no such index exists, we\'re already at the last permutation. for i in range(len(elements) - 2, -1, -1): if elements[i] < elements[i + 1]: break else: return # Step 2: Find the largest index j such that elements[i] < elements[j]. # We know j will exist because we just found i. for j in range(len(elements) - 1, i, -1): if elements[i] < elements[j]: break # Step 3: Swap the value of elements[i] with that of elements[j]. elements[i], elements[j] = elements[j], elements[i] # Step 4: Reverse the sequence from elements[i + 1] up to and including the final element. elements[i + 1:] = reversed(elements[i + 1:]) yield list(elements)"},{"question":"# Scenario A startup company is developing a new text-based application and requires a highly efficient and scalable way to manage a large set of words. You have been assigned to implement the core part of this feature using a Trie data structure. # Task Implement the Trie data structure with three main operations: `insert`, `search`, and `starts_with`. Properly handle edge cases and optimize for performance and memory usage. # Requirements Implement the following class methods: - `insert(word: str) -> None`: Inserts a word into the Trie. - `search(word: str) -> bool`: Returns True if the word is in the Trie, otherwise returns False. - `starts_with(prefix: str) -> bool`: Returns True if there is any word in the Trie that starts with the given prefix, otherwise returns False. Input/Output Formats * **Input**: * For `insert`: A single word in lowercase letters (a-z). * For `search`: A single word in lowercase letters (a-z). * For `starts_with`: A single prefix in lowercase letters (a-z). * **Output**: * For `insert`: None. * For `search`: Boolean. * For `starts_with`: Boolean. # Constraints * Words are composed of lowercase English letters only. * Words and prefixes are not empty and are at most 100 characters long. # Example ``` # Initialize the Trie object trie = Trie() # Insert a few words trie.insert(\\"apple\\") trie.insert(\\"app\\") # Search for a word print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns True print(trie.search(\\"apricot\\")) # Returns False # Check if there is a word starting with a specific prefix print(trie.starts_with(\\"ap\\")) # Returns True print(trie.starts_with(\\"appl\\")) # Returns True print(trie.starts_with(\\"b\\")) # Returns False ``` # Performance Ensure that your implementation is efficient in both time and space given the constraints potential large input size.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Euler\'s Totient Function Challenge: **Context**: Euler\'s Totient function, ϕ(n), counts the positive integers up to a given integer n that are relatively prime to n. For example, ϕ(9) is 6 because there are 6 integers less than 9 that are relatively prime to 9, namely: 1, 2, 4, 5, 7, and 8. **Task**: Write a Python function `custom_euler_totient(n)` that calculates and returns the totient of n. Your implementation should leverage the understanding of prime factorization and efficiently reduce the count based on the prime factors. Ensure that your function works within the time complexity of O(sqrt(n)). **Input**: * An integer `n` (1 <= n <= 10^6) **Output**: * An integer representing the result of the Euler\'s Totient function for the given n. **Function Signature**: ```python def custom_euler_totient(n: int) -> int: pass ``` # Constraints: 1. Your solution should handle small and large values of n effectively. 2. The function should run within reasonable time limits considering the constraint of 1 <= n <= 10^6. # Examples: ```python assert custom_euler_totient(1) == 1 assert custom_euler_totient(9) == 6 assert custom_euler_totient(25) == 20 assert custom_euler_totient(36) == 12 assert custom_euler_totient(100) == 40 ``` **Notes**: * Consider edge cases such as n = 1 or very large prime numbers. * Properly handle multiple prime factors.","solution":"def custom_euler_totient(n: int) -> int: Calculates the Euler\'s Totient function for a given integer n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"# Validate Sudoku Solution Background: Sudoku is a logic-based, combinatorial number-placement puzzle. The objective is to fill a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 sub-grids that compose the grid (also called \\"boxes\\", \\"blocks\\", \\"regions\\", or \\"subsquares\\") contain all of the digits from 1 to 9. The puzzle setter provides a partially completed grid, which for a well-posed puzzle has a single solution. Problem: You are given a 2D array representing a Sudoku board. Your task is to implement the function `valid_solution(board)` that returns `True` if the Sudoku board is a valid solution according to the Sudoku rules without any zeroes indicating empty cells, and `False` otherwise. Function Signature: ```python def valid_solution(board: List[List[int]]) -> bool: pass ``` Inputs: - `board`: A 9x9 2D list (list of lists) containing integers from 0 to 9. Outputs: - Returns `True` if the Sudoku board is a valid solution. - Returns `False` if the Sudoku board is not a valid solution or contains empty cells (0\'s). Constraints: - The input board will always have size 9x9. - Each cell of the board will contain an integer from 0 to 9. Performance Requirements: - The solution should be efficient with time complexity O(N^2) and minimal additional space complexity. Example: ```python valid_solution([ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]) # Returns: True valid_solution([ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 0, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]) # Returns: False ```","solution":"def valid_solution(board): Returns True if the board is a valid Sudoku solution, False otherwise. # Check if a row is valid def is_valid_row(row): return sorted(row) == list(range(1, 10)) # Check if a column is valid def is_valid_column(board, col_idx): col = [board[row_idx][col_idx] for row_idx in range(9)] return sorted(col) == list(range(1, 10)) # Check if a 3x3 sub-grid is valid def is_valid_subgrid(board, row_start, col_start): subgrid = [board[row_start + i][col_start + j] for i in range(3) for j in range(3)] return sorted(subgrid) == list(range(1, 10)) # Check all rows for row in board: if not is_valid_row(row): return False # Check all columns for col_idx in range(9): if not is_valid_column(board, col_idx): return False # Check all 3x3 sub-grids for row_start in range(0, 9, 3): for col_start in range(0, 9, 3): if not is_valid_subgrid(board, row_start, col_start): return False return True"},{"question":"# Automated Code Verification with DFA Scenario: You are asked to create an automated verification system for recognizing valid input strings based on predetermined rules defined by a DFA. This system will help in various applications like syntactic validation, pattern matching, and more. **Question**: Implement a function to determine if a given string is accepted by a deterministic finite automaton (DFA). You need to return `True` if the string is accepted and `False` otherwise. Function Signature ```python def is_string_accepted(transitions: dict, start_state: str, final_states: list, input_string: str) -> bool: ``` Input - `transitions`: A dictionary where keys are state names and values are dictionaries mapping input symbols to resulting states (e.g., `{ \'q0\': { \'a\': \'q1\', \'b\': \'q2\' }, \'q1\': { \'a\': \'q0\' }, ...}`). - `start_state`: A string representing the starting state. - `final_states`: A list of strings representing the accepting states. - `input_string`: A string to be verified by the DFA. Output - `bool`: `True` if the DFA accepts the string, `False` otherwise. Constraints - Each state has a transition defined for each symbol in the input alphabet. - The input string consists only of characters that exist in the alphabet used by the DFA. Example ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q0\'}, \'q1\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q2\': {\'a\': \'q1\', \'b\': \'q0\'}, } start_state = \'q0\' final_states = [\'q1\'] input_string = \'ababa\' result = is_string_accepted(transitions, start_state, final_states, input_string) print(result) # Output: True ``` Notes 1. Make sure your function handles edge cases like symbols not defined in the transition table gracefully. 2. Consider the performance and memory usage when dealing with large state spaces and input strings.","solution":"def is_string_accepted(transitions: dict, start_state: str, final_states: list, input_string: str) -> bool: current_state = start_state for char in input_string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False return current_state in final_states"},{"question":"# Question: You are tasked with writing a function `kth_smallest_element` that finds the k-th smallest element in an unsorted list using Cycle Sort, an in-place sorting algorithm. The function should accept a list of integers and an integer k (1-based index), and return the k-th smallest element in the list. Function Signature ```python def kth_smallest_element(arr: List[int], k: int) -> int: ``` Input - **arr**: A list of integers (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9). - **k**: An integer (1 ≤ k ≤ len(arr)) representing the k-th position (1-based). Output - Return the k-th smallest element in the list. Constraints - Implement the solution using the Cycle Sort algorithm or a related approach that leverages Cycle Sort principles. - Ensure the function handles edge cases such as: - Lists with duplicate values. - The smallest or largest possible values within given constraints. # Example ```python assert kth_smallest_element([3, 2, 1, 5, 4], 2) == 2 assert kth_smallest_element([10, 20, 30, 40, 50], 4) == 40 assert kth_smallest_element([-1, -2, -3, -4], 3) == -2 ``` Your implementation should focus on: - Using Cycle Sort principles to sort the list in-place. - Efficiently finding and returning the k-th smallest element after sorting without using extra space beyond the list itself. **Note:** Writing efficient, correct code with appropriate handling of edge cases and minimum performance bottlenecks is crucial.","solution":"def kth_smallest_element(arr, k): Finds the k-th smallest element in an unsorted list using Cycle Sort for sorting. n = len(arr) # Cycle Sort to sort the array in-place for cycle_start in range(n - 1): item = arr[cycle_start] # Find where to place the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Place the item in its correct position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Return the k-th smallest element return arr[k-1]"},{"question":"Given two strings (s) and (t) which consist of only lowercase letters, string (t) is generated by randomly shuffling the string (s) and then adding one more letter at a random position. Write a function `find_added_character(s, t)` that finds and returns the extra letter added to string (t). Input - `s`: A string containing only lowercase letters with a length of (n) (1 ≤ (n) ≤ 10^5). - `t`: A string containing only lowercase letters with a length of (n+1). Output - A single character which is the extra letter added to (t). Constraints - The input strings contain only lowercase English letters (\'a\' to \'z\'). - String (t) is a permutation of string (s) with one additional character. Example ```python s = \\"abcd\\" t = \\"abced\\" # Output: \'e\' ``` Explanation The added letter \'e\' can be identified by applying XOR operations as shown in the code below. This takes linear time and constant space, making it optimal for large inputs. Testing & Performance Your solution should handle edge cases and ensure optimal performance for the given constraints, with a time complexity of O(n) and a constant space complexity. Implementation Implement the function `find_added_character(s, t)` accordingly. Be mindful of any edge cases provided in the scenarios. ```python def find_added_character(s, t): ret = 0 for ch in s + t: ret = ret ^ ord(ch) return chr(ret) # Example usage: # s = \\"abcd\\" # t = \\"abced\\" # print(find_added_character(s, t)) # Output: \'e\' ```","solution":"def find_added_character(s, t): Given two strings s and t, where t is generated by shuffling s and adding one extra character, this function finds and returns that extra character. ret = 0 for ch in s + t: ret ^= ord(ch) return chr(ret) # Example usage: # s = \\"abcd\\" # t = \\"abced\\" # print(find_added_character(s, t)) # Output: \'e\'"},{"question":"# Pattern Matching with Backtracking Given a pattern and a string, write a function `pattern_match(pattern, string)` that determines if the string follows the same pattern. The string follows the pattern if there is a bijection (one-to-one correspondences) between a character in the pattern and a non-empty substring in the string. **Function Signature:** ```python def pattern_match(pattern: str, string: str) -> bool: ``` **Input:** - `pattern` (str): A string containing only lowercase letters (`a-z`). - `string` (str): A string containing only lowercase letters (`a-z`). **Output:** - Returns `True` if the string follows the pattern, otherwise returns `False`. **Example 1:** ```python pattern = \\"abab\\" string = \\"redblueredblue\\" pattern_match(pattern, string) ``` **Expected Output:** ``` True ``` **Example 2:** ```python pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" pattern_match(pattern, string) ``` **Expected Output:** ``` True ``` **Example 3:** ```python pattern = \\"aabb\\" string = \\"xyzabcxyabc\\" pattern_match(pattern, string) ``` **Expected Output:** ``` False ``` **Constraints:** - Both `pattern` and `string` only contain lowercase English letters. - Use a backtracking approach to solve the pattern matching.","solution":"def pattern_match(pattern, string): def backtrack(pattern, string, pattern_map, used): if not pattern: return not string pattern_char = pattern[0] if pattern_char in pattern_map: pattern_str = pattern_map[pattern_char] if not string.startswith(pattern_str): return False return backtrack(pattern[1:], string[len(pattern_str):], pattern_map, used) for i in range(1, len(string) - len(pattern) + 2): pattern_str = string[:i] if pattern_str in used: continue pattern_map[pattern_char] = pattern_str used.add(pattern_str) if backtrack(pattern[1:], string[i:], pattern_map, used): return True del pattern_map[pattern_char] used.remove(pattern_str) return False return backtrack(pattern, string, {}, set())"},{"question":"Write a Python function named `is_prime` which checks if a given integer ( x ) is a prime number or not. Using the Sieve of Eratosthenes as a helper, ensure that the function is optimized for checking the primality of multiple integers. # Requirements: 1. **Input**: An integer ( x ) where ( 1 leq x leq 10^6 ). 2. **Output**: A boolean value `True` if ( x ) is a prime number, `False` otherwise. 3. **Function Signature**: `def is_prime(x: int) -> bool:` # Constraints: * You can precompute prime numbers up to ( 10^6 ) using an optimized version of the Sieve of Eratosthenes and utilize this information for prime checking. * The function should handle edge cases such as very small values of ( x ) smoothly. # Example: ```python # Example usage print(is_prime(31)) # Output: True print(is_prime(50)) # Output: False ``` # Submission: * Submit the `is_prime` function implementation. * Ensure that your implementation handles edge cases and provides correct results within the specified constraints.","solution":"from typing import List # Global variable to store the sieve _is_prime_list: List[bool] = [] def sieve_of_eratosthenes(limit: int) -> List[bool]: is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes for start in range(2, int(limit**0.5) + 1): if is_prime[start]: for multiple in range(start*start, limit + 1, start): is_prime[multiple] = False return is_prime # Precompute primes up to 10^6 _is_prime_list = sieve_of_eratosthenes(10**6) def is_prime(x: int) -> bool: Returns True if x is a prime number, False otherwise. return _is_prime_list[x]"},{"question":"# Question A historical mathematician has discovered an ancient tablet containing the decomposition of numbers using non-negative integers. You are required to design a function that returns the number of ways to decompose a given positive integer using smaller non-negative integers, including itself. # Input * A single integer `n` where `1 <= n <= 100`. # Output * An integer representing the number of decompositions. # Function Signature ```python def integer_decompositions(n: int) -> int: pass ``` # Constraints * `1 <= n <= 100` * You should use a dynamic programming approach to solve this problem efficiently. # Example(s) Example 1: ```python assert integer_decompositions(4) == 5 # Explanation: # 4=4 # 4=3+1 # 4=2+2 # 4=2+1+1 # 4=1+1+1+1 ``` Example 2: ```python assert integer_decompositions(7) == 15 # Explanation: # 7=7 # 7=6+1 # 7=5+2 # 7=5+1+1 # 7=4+3 # 7=4+2+1 # 7=4+1+1+1 # 7=3+3+1 # 7=3+2+2 # 7=3+2+1+1 # 7=3+1+1+1+1 # 7=2+2+2+1 # 7=2+2+1+1+1 # 7=2+1+1+1+1+1 # 7=1+1+1+1+1+1+1 ``` # Notes * Be sure to handle all edge cases, such as the smallest input value. * Your algorithm should be efficient and follow dynamic programming principles.","solution":"def integer_decompositions(n: int) -> int: Returns the number of ways to decompose `n` using smaller non-negative integers, including itself. # dp[i] will be storing the number of decompositions for value i # Initializing the array with zeros dp = [0] * (n + 1) dp[0] = 1 # Base case: There\'s one way to decompose 0 (using no parts) # Fill the dp array using the dynamic programming approach for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Heap Sort Implementation and Analysis With Constraints Context You\'re responsible for implementing the Heap Sort algorithm and analyzing its efficiency based on specific constraints. You will write two functions: one for ascending sort using a max heap and another for descending sort using a min heap. You must also handle edge cases effectively and ensure your solution is efficient. Problem Statement Implement two functions, `max_heap_sort` and `min_heap_sort`, that will sort an input list of integers in ascending and descending order, respectively. You must follow the heap sort method using max heap for the ascending order and min heap for the descending order. ```python def max_heap_sort(arr): Function to sort an array in ascending order using max heap sort. :param arr: List[int] - Input list of integers. :return: List[int] - Sorted list in ascending order. pass def min_heap_sort(arr): Function to sort an array in descending order using min heap sort. :param arr: List[int] - Input list of integers. :return: List[int] - Sorted list in descending order. pass ``` # Instructions 1. Design and implement the `max_heap_sort` function. This function should return the input list sorted in ascending order by using the max-heap sort algorithm. 2. Design and implement the `min_heap_sort` function. This function should return the input list sorted in descending order by using the min-heap sort algorithm. 3. Optimize your functions for both time and space complexity. 4. Consider edge cases such as: * An empty list. * A list with one element. * A list that is already sorted. * A list with all identical elements. # Constraints * The input list `arr` will have a maximum length of 10^5 elements. * Each element in the list will be an integer within the range -10^9 to 10^9. # Example ```python arr = [4, 10, 3, 5, 1] print(max_heap_sort(arr)) # Output: [1, 3, 4, 5, 10] print(min_heap_sort(arr)) # Output: [10, 5, 4, 3, 1] ``` # Notes * You must not use any built-in sorting functions. * Ensure that your implementation has a time complexity of O(n log n) and a space complexity of O(1). Good luck!","solution":"def max_heap_sort(arr): def heapify(arr, n, i): largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap heapify(arr, n, largest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr def min_heap_sort(arr): def min_heapify(arr, n, i): smallest = i # Initialize smallest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 if left < n and arr[i] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] # swap min_heapify(arr, n, smallest) n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap min_heapify(arr, i, 0) return arr"},{"question":"# Context You have been given a singly linked list where some of the elements may be duplicates. Your task is to write two functions to remove these duplicates, each with different constraints. # Implementation 1. Implement the function `remove_dups(head: Node) -> None` that removes duplicates using extra space for tracking values (e.g., a hash set). - **Input**: `head` - The head node of the singly linked list. - **Output**: The linked list should be modified in place to remove duplicate elements. 2. Implement the function `remove_dups_without_set(head: Node) -> None` that removes duplicates without using additional space for tracking values. - **Input**: `head` - The head node of the singly linked list. - **Output**: The linked list should be modified in place to remove duplicate elements. # Constraints 1. The Node class is defined as follows: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` 2. The list may contain any data type as node values. 3. Optimize for time complexity in `remove_dups`. 4. Optimize for space complexity in `remove_dups_without_set`. # Example Consider the linked list: `A -> A -> B -> C -> D -> C -> F -> G`. - After `remove_dups(head)`: `A -> B -> C -> D -> F -> G` - After `remove_dups_without_set(head)`: The output will be the same, but achieved without using extra storage. # Requirements 1. Write the two functions `remove_dups` and `remove_dups_without_set`. 2. Ensure the functions are efficient and handle all the edge cases effectively. 3. Implement a helper function `print_linked_list(head: Node) -> None` to verify the results by printing the linked list.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from the list using extra space for tracking values. if not head: return current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from the list without using extra space for tracking values. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head: Node) -> None: Helper function to print the linked list. current = head while current: print(current.val, end=\\" -> \\" if current.next else \\"n\\") current = current.next"},{"question":"# Problem: Unique Morse Code Words The International Morse Code encodes letters of the English alphabet using combinations of dots \'.\' and dashes \'-\'. The Morse code mappings for the 26 letters are provided below: ``` \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" ``` Given a list of words, each word can be transformed into a Morse code string by concatenating the Morse code symbols of its individual letters. For example, the word \\"cab\\" can be transformed into \\"-.-.-....-\\". We aim to find the number of unique Morse code transformations among a given list of words. Your task is to write a function `unique_morse(words: List[str]) -> int` that takes a list of words and returns the number of different Morse code transformations. # Example Input: ``` words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] ``` Output: ``` 2 ``` Explanation: ``` The transformations are: \\"gin\\" -> \\"--...-.\\" \\"zen\\" -> \\"--...-.\\" \\"gig\\" -> \\"--...--.\\" \\"msg\\" -> \\"--...--.\\" There are 2 unique transformations: \\"--...-.\\" and \\"--...--.\\" ``` # Function Signature ```python def unique_morse(words: List[str]) -> int: ``` # Constraints * All characters in the words are lowercase English letters. * 1 <= words.length <= 100 * 1 <= words[i].length <= 12 # Performance Requirements * The solution should have a time complexity of O(n * m) where \'n\' is the length of the words list and \'m\' is the average length of the words. * Space complexity should be O(n * k) where \'k\' is the average length of the Morse code transformation. # Instructions 1. Implement the provided function signature. 2. Handle edge cases like empty input list and varying word lengths. 3. Ensure the solution is optimized for performance.","solution":"def unique_morse(words): morse_dict = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } transformed_words = set() for word in words: morse_word = \'\'.join(morse_dict[char] for char in word) transformed_words.add(morse_word) return len(transformed_words)"},{"question":"Problem Statement You are provided with an array of integers that need to be sorted in ascending order. Your task is to write a function `custom_exchange_sort` that implements the exchange sort algorithm. The function should work efficiently for small arrays, but keep in mind it may be inefficient for larger ones due to the nature of the algorithm. Function Signature ```python def custom_exchange_sort(arr: list) -> list: pass ``` Input Format - A list of integers `arr` where `1 <= len(arr) <= 1000`. Output Format - A list of integers sorted in ascending order. Example ```python assert custom_exchange_sort([4, 5, 3, 1, 2]) == [1, 2, 3, 4, 5] assert custom_exchange_sort([]) == [] assert custom_exchange_sort([1]) == [1] assert custom_exchange_sort([5, 1, 2, 1]) == [1, 1, 2, 5] ``` Constraints - Consider edge cases where the array might be already sorted or contains duplicates. Performance Requirements - Ensure your function handles arrays up to 1000 elements within a reasonable time frame even though the complexity is O(n^2). Scenario You are working on a small embedded systems project where simplicity and clarity of the code are more critical than performance. You decide to use the exchange sort algorithm for its straightforward implementation. Good luck and happy coding!","solution":"def custom_exchange_sort(arr: list) -> list: Implement the exchange sort algorithm to sort an array in ascending order. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"You are tasked with implementing a function to decrypt a message encrypted using the Caesar Cipher. The encryption was performed by shifting each letter in the plaintext by a certain number of positions down the alphabet. Given an encrypted string and the shift key, write a function to decrypt the message back to its original form. # Function Specification **Function Name**: `decrypt_caesar_cipher` **Input**: - `s` (string): The encrypted string where every alphabetical character is shifted. - `k` (integer): The number of positions each letter in the original message was shifted. **Output**: - Return the decrypted string as the original message. **Constraints**: - The string `s` contains only printable ASCII characters. - `0 <= k <= 26`. # Examples 1. `decrypt_caesar_cipher(\\"def\\", 3)` should return `\\"abc\\"`. 2. `decrypt_caesar_cipher(\\"zab\\", 3)` should return `\\"wxy\\"`. 3. `decrypt_caesar_cipher(\\"Khoor, Zruog!\\", 3)` should return `\\"Hello, World!\\"`. # Notes - The decryption process involves shifting the characters in the opposite direction by `k` positions. - Non-alphabet characters should not be altered. # Your Task Implement the function `decrypt_caesar_cipher` such that it correctly decrypts the message. Ensure the implementation efficiently handles the given constraints and edge cases.","solution":"def decrypt_caesar_cipher(s, k): def shift_char(c, shift): Shift character c by shift positions in the alphabet. if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') - shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') - shift) % 26 + ord(\'A\')) else: return c return \'\'.join(shift_char(c, k) for c in s)"},{"question":"Scenario You are given a string and a dictionary of words. Your task is to write a function to count how many distinct sentences can be formed by splitting the given string into parts such that every part is a word from the dictionary. Function Signature ```python def count_sentences(s: str, dictionary: set) -> int: ``` Input - `s`: A non-empty string `s` of length `n` (1 <= n <= 20). - `dictionary`: A set of words, each word is a non-empty string. The total number of words in the dictionary is at most 100. Output - An integer count representing the number of distinct sentences that can be formed. Constraints - All characters in `s` and in the dictionary are lowercase English letters. - A word from the dictionary can be reused multiple times in forming a sentence. Example ```python # Example 1 s = \\"appletablet\\" dictionary = {\\"apple\\", \\"tablet\\", \\"app\\", \\"let\\", \\"able\\", \\"t\\"} # Expected output: 3 # Example 2 s = \\"thing\\" dictionary = {\\"thing\\"} # Expected output: 1 # Example 3 s = \\"appletable\\" dictionary = {\\"apple\\", \\"table\\"} # Expected output: 1 ``` Constraints - You must not use any global variables. - The solution should be efficient and handle edge cases, such as no possible sentences can be formed.","solution":"def count_sentences(s: str, dictionary: set) -> int: Counts the number of distinct sentences that can be formed by splitting the given string into words that are present in the dictionary. :param s: str - The input string to be segmented :param dictionary: set - The set of valid words :return: int - The number of distinct ways to segment the string n = len(s) # Memoization dictionary to store solutions of subproblems memo = {} def helper(index): # If we reach the end of the string if index == n: return 1 # Check if result is already in memo if index in memo: return memo[index] # Initialize ways to 0 ways = 0 # Try all possible end indices for current position for end in range(index + 1, n + 1): word = s[index:end] if word in dictionary: ways += helper(end) # Save computed value in memo memo[index] = ways return ways return helper(0)"},{"question":"# Problem: Manual Multiplication of Large Strings **Context**: You are working on a financial software system where transactions are logged with large numbers many times exceeding typical integer limits of standard programming languages. To ensure precision and handle extremely large transactions, you are required to multiply numbers represented as strings. **Task**: Given two non-negative integers `num1` and `num2` represented as strings, return their product as a string. You must not use any built-in BigInteger library or convert the inputs to integers directly. **Function Signature**: ```python def multiply(num1: str, num2: str) -> str: ``` **Input**: - `num1`: A string representing the first non-negative integer (1 ≤ len(num1) < 110) - `num2`: A string representing the second non-negative integer (1 ≤ len(num2) < 110) **Output**: - A string representing the product of `num1` and `num2`. **Constraints**: - The input numbers do not contain any leading zeros. **Performance Requirement**: - The time complexity should be O(m * n) where `m` and `n` are the lengths of `num1` and `num2` respectively. - The space complexity should be O(m + n). **Example**: ```python assert multiply(\\"2\\", \\"3\\") == \\"6\\" assert multiply(\\"123\\", \\"456\\") == \\"56088\\" assert multiply(\\"999\\", \\"999\\") == \\"998001\\" ``` **Note**: 1. Handle intermediate calculations carefully to accommodate positional values of digits. 2. Ensure that the result does not have leading zeros.","solution":"def multiply(num1: str, num2: str) -> str: # If either number is zero, the product is zero if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize the result result = [0] * (len(num1) + len(num2)) # Reverse both numbers to facilitate the multiplication process num1, num2 = num1[::-1], num2[::-1] # Perform multiplication on each digit and add the results to the result array for i in range(len(num1)): for j in range(len(num2)): digit_mul = int(num1[i]) * int(num2[j]) result[i + j] += digit_mul result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # The result array is in reverse order, so we need to reverse it back result = result[::-1] # Remove leading zeros while result[0] == 0: result.pop(0) # Convert result array to a string return \'\'.join(map(str, result))"},{"question":"# Question: Implement a Binary Min Heap Suppose you are working on the back-end of an online booking system where requests need to be managed based on priority. To manage the requests efficiently, we want to use a Binary Min Heap to always process the highest priority (smallest value) request first. Implement a Binary Min Heap class with the following core functionalities: 1. **Insert**: Insert a request (an integer value) into the heap. 2. **Remove Min**: Remove and return the minimum request from the heap. 3. **Peek Min**: Return the minimum request without removing it from the heap. 4. **Size**: Return the current number of elements in the heap. Specifications 1. Implement a class `BinaryMinHeap`: * `def __init__(self)`: Initialize an empty heap. * `def insert(self, val: int)`: Insert the integer value `val` into the heap. * `def remove_min(self) -> int`: Remove and return the minimum value from the heap. * `def peek_min(self) -> int`: Return the minimum value without removing it from the heap. * `def size(self) -> int`: Return the current size of the heap. 2. The heap should maintain the min-heap property (root node is the smallest element). 3. You may assume all inputs to `insert` are integers and are unique. Example Operations ```python heap = BinaryMinHeap() heap.insert(10) heap.insert(5) heap.insert(17) heap.insert(1) print(heap.peek_min()) # Output: 1 print(heap.remove_min()) # Output: 1 print(heap.remove_min()) # Output: 5 print(heap.size()) # Output: 2 ``` Constraints 1. The operations `insert` and `remove_min` should have a time complexity of O(log N). 2. All integers added to the heap will be within the range [-10^9, 10^9].","solution":"class BinaryMinHeap: def __init__(self): self.heap = [] def insert(self, val: int): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def remove_min(self) -> int: if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() min_val = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_val def peek_min(self) -> int: return self.heap[0] if self.heap else None def size(self) -> int: return len(self.heap) def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Integer Base Conversion Utility You are tasked with implementing two utility functions for converting integers between different bases. This functionality is crucial for applications that require numeral system manipulations, often found in computing environments. # Problem Statement 1. **Function: `int_to_base`** * Convert a given integer to a string representation in the specified base. * **Input**: * `num` (int): The integer number to convert. Can be positive or negative. * `base` (int): The base to convert the number to. Must be between 2 and 36 inclusive. * **Output**: A string representing the number in the given base. 2. **Function: `base_to_int`** * Convert a given string representation of a number in a specified base back to an integer. * **Input**: * `str_to_convert` (str): The string representation of the number in the given base. * `base` (int): The base of the given string. Must be between 2 and 36 inclusive. * **Output**: An integer representing the number. # Example ```python assert int_to_base(5, 2) == \'101\' assert base_to_int(\'101\', 2) == 5 assert int_to_base(-255, 16) == \'-FF\' assert base_to_int(\'FF\', 16) == 255 assert int_to_base(0, 10) == \'0\' assert base_to_int(\'0\', 10) == 0 ``` # Constraints 1. The base must be between 2 and 36 inclusive. 2. The input for `int_to_base` will be a valid integer. 3. The input for `base_to_int` will be a valid string representation for the given base. # Performance Requirements These implementations should be efficient in both time and space, handling up to at least standard 32-bit integers in reasonable time. # Implementation Guidelines * Ensure thorough handling of edge cases: * Zero should be consistently represented and parsed. * Negative values should correctly reflect sign. * Optimize your solution for readability and performance. * Avoid using Python built-in conversion functions as the objective is to implement these conversions manually.","solution":"def int_to_base(num, base): Converts an integer to a string representation in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if is_negative: result.append(\\"-\\") return \\"\\".join(result[::-1]) def base_to_int(str_to_convert, base): Converts a string representation of a number in a specified base back to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") str_to_convert = str_to_convert.strip().upper() if not str_to_convert: raise ValueError(\\"Input string cannot be empty.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value = 0 is_negative = str_to_convert[0] == \\"-\\" if is_negative: str_to_convert = str_to_convert[1:] for char in str_to_convert: if char not in digits[:base]: raise ValueError(f\\"Character \'{char}\' not valid for base {base}.\\") value = value * base + digits.index(char) return -value if is_negative else value"},{"question":"# Matrix Exponentiation with Optimization Context Matrix exponentiation is a useful technique in various computational tasks. Your goal is to improve upon a basic matrix exponentiation algorithm by incorporating memory and computational optimizations. Specifically, you need to implement matrix exponentiation and ensure it handles large matrices and powers efficiently. Task You are provided with three functions for matrix operations: 1. `multiply`: Multiplies two square matrices. 2. `identity`: Generates an identity matrix. 3. `matrix_exponentiation`: Performs matrix exponentiation using repeated squaring. Enhance the given `matrix_exponentiation` function by: 1. Optimizing for cases where the matrix contains a significant number of zeros. 2. Ensuring the function operates efficiently for very large power values. Function Signature ```python def optimized_matrix_exponentiation(mat: list, n: int) -> list: Optimizes matrix_exponentiation with enhancements for large n and sparse matrices. :param mat: list[list[int]]: The matrix to be raised to the power n. :param n: int: The power to which the matrix is raised. :return: list[list[int]]: The resulting matrix after exponentiation. pass ``` Input - `mat`: A non-empty, square matrix represented as a list of lists of integers. - `n`: A non-negative integer representing the power to which the matrix is raised. Output - Return the matrix `mat` raised to the power of `n` as a list of lists of integers. Constraints - The matrix size will not exceed 100 x 100. - The power n will not exceed `10^9`. Example ```python mat = [ [2, 0], [0, 2] ] n = 10 result = optimized_matrix_exponentiation(mat, n) print(result) # Output: [[1024, 0], [0, 1024]] ``` Notes - Consider employing additional caching or storing intermediate results to minimize redundant computations. - Assess the matrix for sparsity and take advantage of any potential optimizations. - You may assume matrix multiplication and identity matrix creation remain unchanged and can be utilized from the provided snippets.","solution":"def multiply(mat1, mat2): Multiplies two square matrices. size = len(mat1) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += mat1[i][k] * mat2[k][j] return result def identity(size): Generates an identity matrix of given size. result = [[0] * size for _ in range(size)] for i in range(size): result[i][i] = 1 return result def optimized_matrix_exponentiation(mat, n): Optimizes matrix_exponentiation with enhancements for large n and sparse matrices. size = len(mat) def is_sparse(matrix): zero_count = sum([1 for row in matrix for element in row if element == 0]) return zero_count > (size * size) // 2 if n == 0: return identity(size) if n == 1: return mat if is_sparse(mat): import numpy as np mat = np.array(mat) result = np.identity(size, dtype=int) power = mat while n > 0: if n % 2 == 1: result = np.dot(result, power) power = np.dot(power, power) n //= 2 return result.tolist() else: result = identity(size) power = mat while n > 0: if n % 2 == 1: result = multiply(result, power) power = multiply(power, power) n //= 2 return result"},{"question":"**Context** Run-Length Encoding (RLE) is used as a basic lossless data compression technique that compresses consecutive repeated characters by storing the character followed by the number of repeats. Consider you have a text that you\'d like to compress and later decompress while ensuring that the original content is fully recovered. # Problem Statement You are provided functions to compress and decompress a string using Run-Length Encoding (RLE). Enhance the given RLE algorithm by also adding error checking and optimizing for large datasets without sacrificing correctness. You will need to write a new function `compress_and_decompress` which takes input, compresses it using enhance encoding, and then decompresses to validate correctness. # Function Signature ```python def compress_and_decompress(input: str) -> str: ``` # Inputs * `input`: A string containing the text data to be compressed and decompressed. The string will comprise of printable ASCII characters. # Outputs * Returns the decompressed string which should be identical to the original input string. # Constraints * The input string can be empty. * `1 <= len(input) <= 10^6` * The input string may contain characters that do not repeat. # Performance Requirements * The solution must run efficiently on large inputs (up to 1 million characters). * Ensure the space and time complexity remains reasonable to handle edge cases as well as typical scenarios. # Example Input ```python \\"aaabbccccdaa\\" ``` Output ```python \\"aaabbccccdaa\\" # Decompressed string matches the original input ``` # Hints * Use the provided RLE encoding and decoding functions as a starting point. * Think about scenarios where the encoding or decoding might fail and handle such cases. * Optimize your implementation to handle large inputs efficiently.","solution":"def run_length_encode(input_string): Compresses a string using Run-Length Encoding (RLE). if not input_string: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i-1]: count += 1 else: encoded_string.append(input_string[i-1] + str(count)) count = 1 encoded_string.append(input_string[-1] + str(count)) return \'\'.join(encoded_string) def run_length_decode(encoded_string): Decompresses a string using Run-Length Encoding (RLE). import re decoded_string = [] for char, count in re.findall(r\'(D)(d+)\', encoded_string): decoded_string.append(char * int(count)) return \'\'.join(decoded_string) def compress_and_decompress(input_string): Compresses using RLE and then decompresses to check correctness. encoded = run_length_encode(input_string) decoded = run_length_decode(encoded) return decoded"},{"question":"**Scenario**: You are tasked with sorting an array using an unconventional and educational sorting algorithm known as Stooge Sort. Despite its inefficiency, understanding the algorithm will deepen your comprehension of recursion and sorting mechanisms. **Task**: Implement the Stooge Sort algorithm in Python, which should sort an input array of integers in non-decreasing order. **Input**: - An array `arr` of length `n` where ( 0 leq n leq 100 ). - The array can contain any integer values. **Output**: - The sorted array in non-decreasing order. **Function Signature**: ```python def stoogesort(arr: List[int], l: int, h: int) -> None: ``` **Constraints**: - The input array should be sorted in place. - Time complexity is not a primary concern for this scenario. **Examples**: ```python # Example 1 arr = [6, 5, 4, 3, 2, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5, 6] # Example 2 arr = [1, 3, 2, 5, 4] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5] ``` Your solution should directly modify the array `arr` by rearranging it into sorted order.","solution":"def stoogesort(arr, l, h): Sorts the array arr[l...h] using Stooge Sort algorithm. if l >= h: return # If the element at the start is greater than the element at the end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 elements stoogesort(arr, l, h - t) # Recursively sort last 2/3 elements stoogesort(arr, l + t, h) # Again sort first 2/3 elements to confirm stoogesort(arr, l, h - t)"},{"question":"# Minimum Spanning Tree Calculation You need to build a program that calculates the minimum spanning tree (MST) of a given connected, undirected graph using Kruskal’s algorithm. # Overview Kruskal’s algorithm is a common algorithm used for finding the MST of a connected graph. The MST is a subset of the edges that connects all vertices in the graph without creating cycles and with the minimum possible total edge weight. # Problem Given a number of vertices `V` and a series of edges defined by pairs of vertices and their corresponding weights, implement Kruskal’s algorithm to find the sum of the weights of the MST. # Input * The first line contains two integers `V` (number of vertices) and `E` (number of edges). * The next `E` lines each contain three integers `u`, `v`, and `w` (1-indexed, where `u` and `v` are the indices of the vertices connected by an edge, and `w` is the weight of the edge). # Output * A single line containing a single integer, the sum of the weights of the edges in the MST. # Constraints * 1 ≤ V ≤ 10^4 * 1 ≤ E ≤ 2 * 10^4 * 1 ≤ w ≤ 10^5 # Example Input: ``` 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 ``` Output: ``` 14 ``` # Explanation In this example, the MST includes edges with weights `3`, `5`, `2`, and `4`, totaling `14`. # Instructions * Implement the function `kruskal(vertex_count, edges, forest)` leveraging the provided pseudo-code and disjoint set operations. * Ensure proper handling of edge cases, such as multiple equal weight edges. * Optimize to manage sorting and union-find operations efficiently. # Function Signature ```python def kruskal(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: # Your implementation here ``` # Additional Notes * The implementation should use the DisjointSet class to manage sets of vertices.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, vertex_count): self.parent = list(range(vertex_count + 1)) self.rank = [0] * (vertex_count + 1) def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: edges.sort(key=lambda edge: edge[2]) mst_weight = 0 ds = DisjointSet(vertex_count) for u, v, weight in edges: if ds.find(u) != ds.find(v): ds.union(u, v) mst_weight += weight return mst_weight"},{"question":"# Coding Problem: Sorting a Custom Data List with Stooge Sort Context: After learning about various sorting algorithms, you have now been introduced to Stooge Sort, which is an unusual, inefficient sorting technique. The goal of this exercise is to implement Stooge Sort to sort a custom list of data. This will test your understanding of recursion and sorting techniques. Specification: Implement the function `stoogesort(arr: List[int]) -> List[int]` that sorts a list using the Stooge Sort algorithm. Function Signature: ```python def stoogesort(arr: List[int]) -> List[int]: # Your code here ``` Input: - A list of integers `arr` with a length `n` (1 ≤ n ≤ 10^3) representing the input data that needs to be sorted. Output: - A new list of integers representing the sorted data. Constraints: 1. You must implement Stooge Sort as described. 2. Do not use built-in sort functions. 3. The implementation should handle all edge cases effectively, including: - Lists that are already sorted. - Lists containing all identical elements. - Empty lists (if constraints allow n=0). Example: **Input**: `arr = [3, 1, 4, 1, 5, 9, 2]` **Output**: `[1, 1, 2, 3, 4, 5, 9]` Additional Information - We do not expect optimized performance due to the nature of Stooge Sort. - Focus on the correctness of the implementation and proper handling of edge cases. - Simulate necessary recursion steps carefully to avoid exceeding recursion limits for very large inputs.","solution":"from typing import List def stoogesort(arr: List[int]) -> List[int]: def stoogesort_recursive(a, l, h): if l >= h: return if a[l] > a[h]: a[l], a[h] = a[h], a[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort_recursive(a, l, h - t) stoogesort_recursive(a, l + t, h) stoogesort_recursive(a, l, h - t) arr_copy = arr[:] stoogesort_recursive(arr_copy, 0, len(arr_copy) - 1) return arr_copy"},{"question":"You are tasked with implementing a function that resolves a user-provided file path into an absolute path. This function should handle relative paths and user home shortcuts (`~`). Additionally, you should write a function that verifies whether the resolved path actually exists on the file system. # Function Specifications: 1. **Function Name**: `resolve_and_check_path` 2. **Input**: A single string `file_path`. 3. **Output**: A string representing the absolute path if the file exists; otherwise, return `\\"Path does not exist\\"`. # Constraints: * Input string `file_path` can contain the user shorthand (`~`) for home directories. * The function should handle paths across different operating systems (Windows, Linux, macOS). * Ensure that the function has an efficient implementation with respect to time and space. # Example: ```python Input: \'~/Documents/myfile.txt\' Output: \'/home/username/Documents/myfile.txt\' # if the file exists Input: \'./relative/path/to/file\' Output: \'/current/absolute/path/to/file\' # if the file exists Input: \'~/nonexistentfile.txt\' Output: \'Path does not exist\' # You are expected to use Python\'s os and os.path modules to implement this functionality. ``` # Additional Advice: Consider edge cases like: * Empty strings * Paths with multiple leading or trailing slashes * Arbitrary relative paths Implement the following function: ```python def resolve_and_check_path(file_path: str) -> str: # Your implementation here pass ```","solution":"import os def resolve_and_check_path(file_path: str) -> str: Resolves a user-provided file path into an absolute path. Checks if the resolved path exists on the file system. Args: - file_path (str): A file path, which may be relative or use the user home shortcut (~) Returns: - str: The absolute path if the file exists; otherwise, \\"Path does not exist\\". if not file_path: return \\"Path does not exist\\" # Expand user home shortcut and relative paths absolute_path = os.path.abspath(os.path.expanduser(file_path)) # Check if the path exists if os.path.exists(absolute_path): return absolute_path return \\"Path does not exist\\""},{"question":"Given an array of integers where every element appears three times except for one, which appears exactly once, write a function to find that single one. Your algorithm should have a linear runtime complexity and use constant extra space. # Function Signature ```python def find_unique(nums: List[int]) -> int: pass ``` # Input - `nums` (List[int]): A list of integers where every element appears exactly three times except for one. # Output - (int): The integer that appears exactly once. # Constraints - All elements of `nums` are integers. - The array size will be between 1 and 10^4. - Every element in the array except for one appears exactly three times. - The solution must run in O(n) time complexity. - The solution must use O(1) extra space. # Example ```python assert find_unique([2, 2, 3, 2]) == 3 assert find_unique([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique([-1, -1, -1, -4]) == -4 ``` # Explanation In the first example, `2` appears three times and `3` appears once, so `3` is the unique element. In the second example, `0` and `1` each appear three times, while `99` appears once, so `99` is the unique element. In the third example, `-1` appears three times, and `-4` appears once, so `-4` is the unique element. # Implementation Notes You may use the approach involving bitwise operations to track the occurrences of bits in the array. # Edge Cases 1. Arrays with only one element which is the unique one, e.g., `[1]`. 2. Arrays where the unique element is the smallest or largest integer value. Write and optimize your solution based on the principles and constraints stated above.","solution":"from typing import List def find_unique(nums: List[int]) -> int: Returns the single element that appears exactly once in the list, while all other elements appear exactly three times. # Initialize variables to store the bits appearing once and twice. once, twice = 0, 0 for num in nums: # Compute `once` by XORing the current number with `once`, # while clearing out the bits that appear in `twice`. once = (once ^ num) & ~twice # Compute `twice` by XORing the current number with `twice`, # while clearing out the bits that appear in `once`. twice = (twice ^ num) & ~once return once"},{"question":"You are tasked with implementing and demonstrating an understanding of binary tree traversal. Specifically, you need to implement a verified in-order traversal for a given Binary Tree. # Objective: Implement two functions, `iterative_inorder(root)` and `recursive_inorder(root)`, that perform in-order traversal of a binary tree iteratively and recursively, respectively. # Input: * Root node of a binary tree where each node contains an integer value. # Output: * A list of integers representing the values of the nodes in in-order traversal. # Constraints: * You may assume no two nodes have the same value (no duplicates). * The number of nodes (`n`) will be in the range [0, 10^4]. # Function Signature: ```python def iterative_inorder(root: Node) -> List[int]: pass def recursive_inorder(root: Node) -> List[int]: pass ``` # Example: ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Constructing the binary tree as follows: # 1 # / # 2 3 # / # 4 5 n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 assert iterative_inorder(n1) == [4, 2, 5, 1, 3] assert recursive_inorder(n1) == [4, 2, 5, 1, 3] ``` # Additional Notes: * Ensure your solution handles edge cases effectively, such as an empty tree or a single node tree. * Validation against the example is part of confirming the solution\'s correctness.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def iterative_inorder(root: Optional[Node]) -> List[int]: stack = [] result = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def recursive_inorder(root: Optional[Node]) -> List[int]: def inorder(node: Optional[Node], result: List[int]): if not node: return inorder(node.left, result) result.append(node.val) inorder(node.right, result) result = [] inorder(root, result) return result"},{"question":"You are given the task to implement an extended version of the Run-Length Encoding (RLE) compression algorithm, but instead of compressing characters, your program should compress words. The encoded string should replace each repeated word in the input string with the count of occurrences followed by the word. # Specifications: Input: - A single string `input` containing words separated by spaces. Output: - A single string representing the encoded result where consecutive repeated words are compressed. # Constraints: - Words are separated by single spaces. - The input string will only contain alphabets and spaces. - The input string length will be at most 1000 characters. - Words are case-sensitive (\\"Word\\" is different from \\"word\\"). # Function Signature: ```python def encode_word_rle(input: str) -> str: pass ``` # Examples: Example 1: **Input**: `a a a b b c c c c` **Output**: `3a 2b 4c` Example 2: **Input**: `hello hello world world world` **Output**: `2hello 3world` Example 3: **Input**: `foo bar foo bar bar bar` **Output**: `1foo 1bar 1foo 3bar` # Implementation Notes: - Implement RLE for words instead of characters. - Consider edge cases such as empty strings and single words.","solution":"def encode_word_rle(input: str) -> str: if not input: return \\"\\" words = input.split() encoded = [] i = 0 while i < len(words): count = 1 while i + 1 < len(words) and words[i] == words[i + 1]: count += 1 i += 1 encoded.append(f\\"{count}{words[i]}\\") i += 1 return \' \'.join(encoded)"},{"question":"You are given a `DirectedGraph` class along with `Node` and `DirectedEdge` classes to represent a directed graph, its nodes, and edges respectively. Although your current implementation supports adding nodes and edges, you need to extend its functionality. # Task Implement the following methods in the `DirectedGraph` class: 1. **detect_cycle**: This method should detect if there is a cycle in the directed graph. A cycle exists if you can traverse from a node back to itself via one or more directed edges. 2. **find_paths**: This method should find all possible paths between two given nodes. Each path is represented as a list of nodes. ```python def detect_cycle(self): Returns: bool: True if there is a cycle in the graph, False otherwise. # Implement your cycle detection logic here def find_paths(self, start_node, end_node): Args: start_node (Node/str): The starting node. end_node (Node/str): The ending node. Returns: List[List[Node]]: A list of all possible paths, where each path is represented as a list of nodes. # Implement your path-finding logic here ``` # Constraints - Nodes can be identified by their unique names (str). - For `find_paths`, return an empty list if there are no paths between the two nodes. # Input and Output Formats - **detect_cycle**: - **Input**: No input parameters. - **Output**: A boolean indicating the presence of a cycle. - **find_paths**: - **Input**: Two nodes (either `Node` objects or strings). - **Output**: A list of lists, where each inner list represents a path from the start node to the end node. # Examples ```python graph_data = { \'A\': [\'B\'], \'B\': [\'C\', \'D\'], \'C\': [\'A\'], # This edge creates a cycle: A -> B -> C -> A \'D\': [] } graph = DirectedGraph(graph_data) assert graph.detect_cycle() == True assert graph.find_paths(\'A\', \'D\') == [[\'A\', \'B\', \'D\']] assert graph.find_paths(\'B\', \'C\') == [[\'B\', \'C\']] assert graph.find_paths(\'D\', \'A\') == [] ``` Implement and test these methods to ensure your graph can detect cycles and find paths between nodes.","solution":"class Node: def __init__(self, name): self.name = name self.edges = [] def add_edge(self, node): self.edges.append(node) class DirectedGraph: def __init__(self, graph_data=None): self.nodes = {} if graph_data: self.add_graph_data(graph_data) def add_graph_data(self, graph_data): for node, edges in graph_data.items(): if node not in self.nodes: self.nodes[node] = Node(node) for edge in edges: if edge not in self.nodes: self.nodes[edge] = Node(edge) self.nodes[node].add_edge(self.nodes[edge]) def detect_cycle(self): visited = set() stack = set() def visit(node): if node.name in stack: return True if node.name in visited: return False stack.add(node.name) visited.add(node.name) for neighbor in node.edges: if visit(neighbor): return True stack.remove(node.name) return False for node in self.nodes.values(): if visit(node): return True return False def find_paths(self, start_node, end_node): if isinstance(start_node, str): start_node = self.nodes.get(start_node) if isinstance(end_node, str): end_node = self.nodes.get(end_node) if not start_node or not end_node: return [] result = [] path = [] def dfs(current): path.append(current) if current == end_node: result.append(list(node.name for node in path)) else: for neighbour in current.edges: if neighbour not in path: dfs(neighbour) path.pop() dfs(start_node) return result"},{"question":"**Context**: You are working on cleaning up a linked list by removing any duplicate entries. Maintaining the order of nodes is crucial, but you want to try an alternative method for efficiency in removing duplicates without using extra space. **Problem Statement**: Implement a function `remove_dups_efficient(head: Node) -> None` that removes duplicates from an unsorted linked list without using additional data structures such as sets or arrays. Your implementation should modify the linked list in place and strive to improve efficiency over the provided O(N^2) solution while maintaining O(1) additional space complexity. **Input/Output Specification**: 1. **Input**: - A linked list represented by its head node `head` where each node contains: - `head.val`: an integer value. - `head.next`: a reference to the next node in the list, or `None` if it is the end of the list. 2. **Output**: - The function modifies the linked list in place and does not return anything. **Constraints**: - The linked list can contain up to `10^5` nodes. - Node values are within the range of integer values. **Example**: ```python # Define Node class class Node(): def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head and head.next: string += str(head.val) + \\" -> \\" head = head.next if head: string += str(head.val) print(string) # Create linked list: 1 -> 2 -> 3 -> 2 -> 1 -> 4 n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(2) n5 = Node(1) n6 = Node(4) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5 n5.next = n6 # Remove duplicates remove_dups_efficient(n1) # You need to implement this function # Expected output: 1 -> 2 -> 3 -> 4 print_linked_list(n1) ``` **Performance Requirements**: - Minimize the time complexity as much as possible while keeping the space complexity O(1).","solution":"class Node(): def __init__(self, val = None): self.val = val self.next = None def remove_dups_efficient(head: Node) -> None: Removes duplicate values from an unsorted linked list. if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Combination Sum Challenge Given a list of positive integers `candidates` and a positive integer `target`, write a Python function `optimized_combination_sum` that finds all unique combinations in `candidates` that sum up to `target`. The same repeated number may be chosen from `candidates` an unlimited number of times. # Input - `candidates`: List of unique positive integers. - `target`: A positive integer. # Output - Return a list of lists, where each list represents a unique combination of numbers that add up to the target. # Constraints - All numbers (including `target`) will be positive integers. - The solution set must not contain duplicate combinations. - The candidates can appear in any order in the input list but should be sorted within the function. # Performance Requirements - Aim for an efficient solution that minimizes redundant processing. # Example ```python candidates = [2, 3, 6, 7] target = 7 print(optimized_combination_sum(candidates, target)) # Expected output: # [ # [7], # [2, 2, 3] # ] ``` # Edge Cases - An empty list of candidates. - A target value smaller than any candidate. # Hint Use Depth-First Search (DFS) with Backtracking to explore potential combinations and make sure to handle duplicate scenarios efficiently.","solution":"def optimized_combination_sum(candidates, target): def backtrack(start, path, remaining): if remaining == 0: result.append(list(path)) return for i in range(start, len(candidates)): if candidates[i] > remaining: break path.append(candidates[i]) backtrack(i, path, remaining - candidates[i]) path.pop() candidates.sort() result = [] backtrack(0, [], target) return result"},{"question":"# Right-Angled Triangle Side Calculator You are given the lengths of two sides of a right-angled triangle, and you need to determine the length of the third side. You should implement a function `calculate_third_side` which utilizes the Pythagorean Theorem. The function should handle cases where the input values are either integers or floating-point numbers. One of the inputs will be marked with a \\"?\\" to indicate the unknown side. **Function Signature:** ```python def calculate_third_side(opposite: Union[int, float, str], adjacent: Union[int, float, str], hypotenuse: Union[int, float, str]) -> Union[str, float]: ``` **Input:** - `opposite` : Length of the opposite side or \\"?\\" (unknown side). - `adjacent` : Length of the adjacent side or \\"?\\" (unknown side). - `hypotenuse`: Length of the hypotenuse or \\"?\\" (unknown side). **Output:** - Returns a string formatted as `\\"Side = Value\\"` indicating the length of the side rounded to 2 decimal places, where `Side` is the name of the unknown side (Opposite/Adjacent/Hypotenuse). - If the inputs are invalid, return `\\"Invalid input\\"`. **Constraints:** - Only one of the inputs will be \\"?\\". - Positive numeric values will be used for known sides. - The hypotenuse is always the longest side. **Example:** ```python assert calculate_third_side(\\"?\\", 4, 5) == \\"Opposite = 3.0\\" assert calculate_third_side(3, \\"?\\", 5) == \\"Adjacent = 4.0\\" assert calculate_third_side(3, 4, \\"?\\") == \\"Hypotenuse = 5.0\\" assert calculate_third_side(3, 4, 5) == \\"You already know the answer!\\" assert calculate_third_side(3, -4, \\"?\\") == \\"Invalid input\\" assert calculate_third_side(3, 4, 2) == \\"Invalid input\\" ```","solution":"from typing import Union def calculate_third_side(opposite: Union[int, float, str], adjacent: Union[int, float, str], hypotenuse: Union[int, float, str]) -> Union[str, float]: # Validate inputs try: if isinstance(opposite, str) and opposite != \\"?\\": return \\"Invalid input\\" if isinstance(adjacent, str) and adjacent != \\"?\\": return \\"Invalid input\\" if isinstance(hypotenuse, str) and hypotenuse != \\"?\\": return \\"Invalid input\\" known_opposite = float(opposite) if opposite != \\"?\\" else None known_adjacent = float(adjacent) if adjacent != \\"?\\" else None known_hypotenuse = float(hypotenuse) if hypotenuse != \\"?\\" else None except ValueError: return \\"Invalid input\\" if known_opposite is not None and known_opposite <= 0: return \\"Invalid input\\" if known_adjacent is not None and known_adjacent <= 0: return \\"Invalid input\\" if known_hypotenuse is not None and (known_hypotenuse <= 0 or (known_opposite and known_hypotenuse <= known_opposite) or (known_adjacent and known_hypotenuse <= known_adjacent)): return \\"Invalid input\\" if opposite == \\"?\\": # opposite side is unknown return f\\"Opposite = {round((known_hypotenuse**2 - known_adjacent**2)**0.5, 2)}\\" elif adjacent == \\"?\\": # adjacent side is unknown return f\\"Adjacent = {round((known_hypotenuse**2 - known_opposite**2)**0.5, 2)}\\" elif hypotenuse == \\"?\\": # hypotenuse side is unknown return f\\"Hypotenuse = {round((known_opposite**2 + known_adjacent**2)**0.5, 2)}\\" return \\"You already know the answer!\\""},{"question":"Scenario You are working on a project for a logistics company that needs to load valuable items into a delivery truck. Each item has a specific value and weight, and the truck can only carry a certain maximum weight. Your task is to determine the maximum total value of items that can be loaded into the truck without exceeding the weight capacity. Problem Write a function that determines the maximum value achievable with a given weight capacity and a list of items. Each item is represented by a `Item` class with `value` and `weight`. Function Signature ```python def get_maximum_value(items: List[Item], capacity: int) -> int: pass ``` Input * `items`: A list of `Item` objects, each having `value` (int) and `weight` (int). * `capacity`: An integer representing the maximum weight that the knapsack (truck) can carry. Output Return an integer representing the maximum total value of items that can be loaded without exceeding the weight capacity. Constraints * All values and weights will be non-negative integers. * Capacity will be a non-negative integer. * There will be at most 1000 items. * The maximum capacity of the knapsack is 10000. Example Input: ```python items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] capacity = 5 ``` Output: ```python 80 ``` Notes * The function should handle edge cases gracefully, such as an empty list of items or a capacity of zero.","solution":"from typing import List class Item: def __init__(self, value: int, weight: int): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: n = len(items) # Initialize DP table with all zeros dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if items[i-1].weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-items[i-1].weight] + items[i-1].value) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"You are tasked with extending the functionality of the given `DirectedGraph` class to include a method for finding the shortest path between two nodes using Dijkstra\'s Algorithm. # Implement the Following Function ```python def find_shortest_path(graph, start_node, end_node): Finds the shortest path between start_node and end_node in the provided directed graph using Dijkstra\'s Algorithm. Parameters: graph (DirectedGraph): Directed graph instance. start_node (str): The name of the starting node. end_node (str): The name of the ending node. Returns: Tuple: - List of node names (str) representing the shortest path from start_node to end_node. - Integer indicating the total path weight. Raises: ValueError: If either start_node or end_node is not present in the graph. pass ``` # Input * `graph`: An instance of `DirectedGraph`. * `start_node`: A string representing the starting node name. * `end_node`: A string representing the ending node name. # Output * A tuple containing: * A list of strings representing the names of nodes in the shortest path. * An integer indicating the total weight of the shortest path. # Constraints * The nodes and edges do not contain weights; assume the weight of each edge is 1. * The graph may contain cycles. * The nodes `start_node` and `end_node` will be actual nodes in the graph. * There may be no valid path between `start_node` and `end_node`. In this case, return an empty list and the integer 0. # Example Given the following graph: ```plaintext A -> B A -> C B -> C B -> D C -> D ``` ```python graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } graph = DirectedGraph(graph_dict) shortest_path, total_weight = find_shortest_path(graph, \'A\', \'D\') print(shortest_path) # Output: [\'A\', \'B\', \'D\'] print(total_weight) # Output: 2 ``` **Note**: Implement and handle edge cases including non-existent paths and ensure optimized performance using heuristic-guided techniques if applicable.","solution":"import heapq class DirectedGraph: def __init__(self, graph): Initializes a directed graph. :param graph: A dictionary where keys are node names and values are lists of adjacent node names. self.graph = graph def get_neighbors(self, node): Returns the neighbors of a node. :param node: The node for which neighbors should be returned. :return: A list of neighbors of the node. return self.graph.get(node, []) def find_shortest_path(graph, start_node, end_node): Finds the shortest path between start_node and end_node in the provided directed graph using Dijkstra\'s Algorithm. Parameters: graph (DirectedGraph): Directed graph instance. start_node (str): The name of the starting node. end_node (str): The name of the ending node. Returns: Tuple: - List of node names (str) representing the shortest path from start_node to end_node. - Integer indicating the total path weight. Raises: ValueError: If either start_node or end_node is not present in the graph. # Check if start_node and end_node exists in the graph if start_node not in graph.graph or end_node not in graph.graph: raise ValueError(\\"Both start_node and end_node must be present in the graph.\\") # Priority queue for Dijkstra\'s algorithm priority_queue = [(0, start_node, [])] # Dictionary to store the minimal distance to each node distances = {start_node: 0} while priority_queue: # Get the node with the lowest distance current_distance, current_node, path = heapq.heappop(priority_queue) # Append current node to the path path = path + [current_node] # If we reached the end_node, return the path and its total weight if current_node == end_node: return path, current_distance # Get neighbors of the current node for neighbor in graph.get_neighbors(current_node): distance = current_distance + 1 # All edges have the same weight of 1 # If a shorter path to the neighbor exists, update the distance and push to priority queue if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path)) # If there is no path from start_node to end_node return [], 0"},{"question":"You are given a sorted array of distinct integers and a target value. Your task is to implement an efficient function that determines the index at which the target value should be inserted into the array to maintain its sorted order. Function Signature ```python def search_insert(array: List[int], val: int) -> int: ``` Input * `array` (List[int]): A list of distinct integers sorted in ascending order. * `val` (int): An integer value to be inserted in the `array`. Output * Returns an integer representing the index position at which `val` should be inserted. Constraints * The length of `array` will be in the range [0, 10^6]. * The integer values of `array` and `val` will be in the range [-10^6, 10^6]. Performance Requirements * The algorithm should have a time complexity of O(log n). * Space complexity should be O(1). Examples ```python # Example 1 array = [1, 3, 5, 6] val = 5 # Output: 2 # Example 2 array = [1, 3, 5, 6] val = 2 # Output: 1 # Example 3 array = [1, 3, 5, 6] val = 7 # Output: 4 # Example 4 array = [1, 3, 5, 6] val = 0 # Output: 0 # Example 5 array = [] val = 3 # Output: 0 ```","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Returns the index at which the target value should be inserted in the sorted array. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"You are tasked with the implementation of a function that finds and returns the nth digit in a concatenated sequence of positive integers (1, 2, 3, 4, ...). The sequence is infinite, and for example, the first few digits are \\"123456789101112...\\". Your solution should be efficient and consider edge cases and performance. # Function Signature ```python def find_nth_digit(n: int) -> int: Find the nth digit in the concatenated sequence of positive integers. Parameters: ----------- n : int The position of the digit to retrieve, where 1 <= n <= 10^9 Returns: -------- int The nth digit in the sequence ``` # Input - **n**: An integer representing the position of the digit to be retrieved from the sequence. ( 1 leq n leq 10^9 ). # Output - Return a single integer representing the digit at the nth position in the concatenated sequence of positive integers. # Constraints 1. The function must efficiently handle very large values of `n` up to ( 10^9 ). 2. Ensure correct handling of digit transitions between different lengths of concatenated numbers (e.g., from single-digit to double-digit numbers). # Example ```python # Example 1: input: n = 3 output: 3 # Example 2: input: n = 11 output: 0 # Example 3: input: n = 12 output: 1 # Example 4: input: n = 15 output: 2 ``` # Context and Additional Notes The problem is relevant in scenarios where digit patterns need to be analyzed or specific positional information needs to be extracted from dynamically generated sequences. The primary challenge is ensuring the algorithm scales well with extreme values of `n` while maintaining accurate results.","solution":"def find_nth_digit(n: int) -> int: Find the nth digit in the concatenated sequence of positive integers. Parameters: ----------- n : int The position of the digit to retrieve, where 1 <= n <= 10^9 Returns: -------- int The nth digit in the sequence # Initialize length of the number part, starting length of sequence and base number for calculation length = 1 count = 9 start = 1 # Reduce n within the scope of the number parts of increasing length while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Identify the actual number where the nth digit will fall start += (n - 1) // length # Identify the specific digit within that number s = str(start) return int(s[(n - 1) % length])"},{"question":"You are provided with an implementation of a Binary Search Tree (BST) in Python, which supports insertion, search, size calculation, and tree traversal operations (preorder, inorder, and postorder traversals). Your task is to enhance the `BST` class by implementing two additional functionalities: 1. **Find Minimum**: A method to find the minimum value in the BST. 2. **Find Maximum**: A method to find the maximum value in the BST. # Method Details 1. **Method Name**: `find_min()` * **Input**: None * **Output**: Returns the minimum value present in the BST. 2. **Method Name**: `find_max()` * **Input**: None * **Output**: Returns the maximum value present in the BST. # Constraints - You can assume that the BST will not be empty when these methods are called. - The elements in the BST are unique integers. # Performance Requirements - Both methods should have an average time complexity of O(log N). - Both methods should have a space complexity of O(1) excluding the stack space for recursion. # Example ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) assert tree.find_min() == 6 assert tree.find_max() == 15 ``` # Guidelines * Implement the new methods within the existing `BST` class. * Do not modify the existing method implementations within the `BST` class. * Write Python unit tests to verify the correctness of your implementation, similar to those provided in the code snippets.","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = BSTNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = BSTNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = BSTNode(value) else: self._insert_recursive(node.right, value) def find_min(self): if self.root is None: return None current = self.root while current.left is not None: current = current.left return current.value def find_max(self): if self.root is None: return None current = self.root while current.right is not None: current = current.right return current.value"},{"question":"Determine One Edit Distance Apart Problem Statement: Write a Python function, `is_one_edit_distance(s, t)`, that determines if two input strings `s` and `t` are exactly one edit distance apart. An edit is defined as an insertion, deletion, or substitution of a single character. Input: * `s` (str): The first input string. * `t` (str): The second input string. Output: * Return `True` if strings `s` and `t` are exactly one edit distance apart. * Otherwise, return `False`. Constraints: * The strings will contain only lowercase English letters (`a-z`). * The length of the input strings will be between 0 and 10^4 inclusive. Examples: ```python # Example 1 s = \\"ab\\" t = \\"abc\\" print(is_one_edit_distance(s, t)) # Expected output: True # Example 2 s = \\"cat\\" t = \\"bat\\" print(is_one_edit_distance(s, t)) # Expected output: True # Example 3 s = \\"cat\\" t = \\"dog\\" print(is_one_edit_distance(s, t)) # Expected output: False # Example 4 s = \\"cat\\" t = \\"cats\\" print(is_one_edit_distance(s, t)) # Expected output: True # Example 5 s = \\"cat\\" t = \\"cut\\" print(is_one_edit_distance(s, t)) # Expected output: True ``` Notes: 1. Think about the different possible edits (insertion, deletion, substitution) and how to handle them within the context of the function. 2. Focus on minimizing time and space complexity given the constraints. ```python def is_one_edit_distance(s, t): # Your implementation here pass ```","solution":"def is_one_edit_distance(s, t): Determines if two input strings s and t are exactly one edit distance apart. An edit is defined as an insertion, deletion, or substitution of a single character. len_s, len_t = len(s), len(t) # If lengths differ by more than 1, they cannot be one edit distance apart if abs(len_s - len_t) > 1: return False # If lengths are equal, check substitution if len_s == len_t: count_diff = sum(1 for a, b in zip(s, t) if a != b) return count_diff == 1 # If lengths differ, check insertion/deletion if len_s > len_t: s, t = t, s # Ensure s is always the shorter string # Now try to find the first difference for i in range(len(s)): if s[i] != t[i]: return s[i:] == t[i+1:] # If no difference found, ensure the extra char is at the end of the longer string return True"},{"question":"Context You\'re tasked with enhancing the performance of an existing sorting algorithm within a data processing application. The current implementation uses Shell Sort with a naive gap sequence (halving the size of the list each time). You recognize that alternative gap sequences could potentially improve performance, especially for larger arrays. Task Implement an optimized version of Shell Sort that uses a specific gap sequence known for its efficiency: Sedgewick\'s gap sequence (1, 5, 19, 41, 109, ...), which is more advanced than the simple halving sequence. Requirements - **Function Signature**: `def optimized_shell_sort(arr: List[int]) -> List[int]:` - **Input**: - `arr`: A list of integers (`1 <= len(arr) <= 10^5`, `-10^9 <= arr[i] <= 10^9`). - **Output**: - Should return the list sorted in increasing order. - **Constraints**: - Your implementation should work efficiently even for the upper limit of input size. - **Performance**: - Expected to improve upon the naive gap sequence in terms of runtime performance. Example ```python optimized_shell_sort([12, 34, 54, 2, 3]) # Output: [2, 3, 12, 34, 54] optimized_shell_sort([5, 2, 9, 1, 5, 6]) # Output: [1, 2, 5, 5, 6, 9] ```","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Perform Shell Sort using Sedgewick\'s gap sequence. Parameters: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list. n = len(arr) # Sedgewick\'s gap sequence: (4^i + 3*2^(i-1) + 1) and (4^i - 3*2^(i-1) + 1) gaps = [] k = 0 while True: gap1 = 4**k + 3 * 2**(k - 1) + 1 if k > 0 else 1 if gap1 > n: break gaps.append(gap1) k += 1 gaps = gaps[::-1] for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Flatten Nested Arrays You are given a nested array that can contain other arrays or elements of any other data type. Your task is to implement two functions that flatten this nested array into a single-level array. Function 1: Flatten List Write a function `flatten_list(input_arr)` that takes in a nested array `input_arr` and returns a single-level list containing all the elements in the nested structure. **Input Format** - A list named `input_arr` which can contain nested lists as well as individual elements. **Output Format** - A single-level list containing all elements from the `input_arr`. Function 2: Flatten Iterator Write a function `flatten_iter(input_arr)` that takes in a nested array `input_arr` and returns an iterator which yields each element of the nested structure one by one. **Input Format** - A list named `input_arr` which can contain nested lists as well as individual elements. **Output Format** - An iterator that yields each element in the `input_arr` from the nested structure sequentially. # Constraints * Elements can be of various data types. * The nested depth of `input_arr` is not limited manually, but assume reasonable nesting for competitive programming scenarios. * Do not use additional libraries like NumPy—standard library only. # Examples Example 1: Flatten List ```python input_arr = [1, [2, [3, 4], 5], 6] Output: [1, 2, 3, 4, 5, 6] ``` Example 2: Flatten Iterator ```python input_arr = [1, [2, [3, 4], 5], 6] Output: 1 2 3 4 5 6 # Using a loop to print elements ``` # Notes - Focus on handling edge cases such as empty arrays or arrays with non-iterable objects. - Ensure your solution efficiently handles deeply nested arrays without causing stack overflow or memory issues.","solution":"def flatten_list(input_arr): Flattens a nested list into a single-level list. result = [] def _flatten(nested): for element in nested: if isinstance(element, list): _flatten(element) else: result.append(element) _flatten(input_arr) return result def flatten_iter(input_arr): Flattens a nested list into a single-level iterator. def _flatten(nested): for element in nested: if isinstance(element, list): yield from _flatten(element) else: yield element return _flatten(input_arr)"},{"question":"# Context and Scenario You are tasked with developing software for scientific computing applications where sparse matrices are often used to represent large systems with many zero elements. Efficient computation on these matrices can result in significant performance improvements. # Problem Write a function to multiply two sparse matrices A and B. # Function Signature ```python def multiply_sparse_matrices(a: List[List[int]], b: List[List[int]]) -> List[List[int]]: ``` # Input * `a` (List[List[int]]): A matrix represented as a list of lists where `a[i][j]` is the element of the matrix at the (i)-th row and (j)-th column. * `b` (List[List[int]]): A matrix represented as a list of lists where `b[i][j]` is the element of the matrix at the (i)-th row and (j)-th column. You may assume that the number of columns in A is equal to the number of rows in B. # Output * Returns a matrix (C) which is the result of matrix multiplication of A and B. # Constraints * ( text{Matrix dimensions are such that } 1 leq m, n, l leq 1000 ) * Elements in matrices can be zero or non-zero integers within the range [-100, 100] # Example ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ] C = multiply_sparse_matrices(A, B) # C should be: # [ # [7, 0, 0], # [-7, 0, 3] # ] ``` # Additional Notes * Ensure your solution is optimized for sparse matrices. * Handle edge cases such as matrices with all zero elements, and different sparsity levels efficiently.","solution":"def multiply_sparse_matrices(a, b): Multiplies two sparse matrices a and b. Parameters: a (List[List[int]]): Matrix A. b (List[List[int]]): Matrix B. Returns: List[List[int]]: Resultant matrix after multiplication. if not a or not b: return [] # dimensions of matrices m, n = len(a), len(a[0]) p = len(b[0]) # result matrix with zeros result = [[0] * p for _ in range(m)] for i in range(m): for k in range(n): if a[i][k] != 0: # proceed if a[i][k] is non-zero for j in range(p): if b[k][j] != 0: result[i][j] += a[i][k] * b[k][j] return result"},{"question":"# Question: Implement Enhanced Radix Sort to Handle Extended Case **Context**: Radix Sort is an efficient sorting algorithm for numerical data which sorts numbers based on the digits from the least significant to the most significant. In this task, you are required to implement an enhanced version that can handle arrays with a mix of negative and positive integers, while maintaining its linearithmic complexity. **Function Definition**: Implement a function `enhanced_radix_sort(arr: List[int]) -> List[int]` that sorts an array containing both positive and negative integers. **Input**: * A list of integers `arr` with possible negative and positive values. (1 <= length of arr <= 10^5) **Output**: * A sorted list of integers in non-decreasing order. **Constraints**: * The integers can be large, so consider the digit length appropriately. * Your implementation should maintain a linearithmic time complexity of O(nk), and avoid excessive additional space usage. **Examples**: ```python assert enhanced_radix_sort([170, 45, 75, -90, 802, 24, 2, 66, -23]) == [-90, -23, 2, 24, 45, 66, 75, 170, 802] assert enhanced_radix_sort([-5, -1, 3, 0, -2, 2, -3, 1, 4, -4]) == [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4] assert enhanced_radix_sort([]) == [] assert enhanced_radix_sort([500, -500]) == [-500, 500] ``` **Implementation Details**: 1. Handle negative and positive numbers separately. 2. Sort negative and positive numbers using radix sort and combine results for final sorted output. 3. Ensure efficiency and handle edge cases where input array is empty or contains identical elements.","solution":"from typing import List def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr): if not arr: return [] max_val = max(arr) exp = 1 while max_val // exp > 0: counting_sort(arr, exp) exp *= 10 def enhanced_radix_sort(arr: List[int]) -> List[int]: if not arr: return [] positive_numbers = [num for num in arr if num >= 0] negative_numbers = [-num for num in arr if num < 0] radix_sort(positive_numbers) radix_sort(negative_numbers) negative_numbers = [-num for num in reversed(negative_numbers)] return negative_numbers + positive_numbers"},{"question":"You are tasked with developing a function to calculate the longest path lengths between two nodes in a directed graph, ensuring that each node can only be visited once in any given path. This function will build on the understanding of the path-finding functions provided below. The resulting path does not necessarily have to visit all nodes but must ensure the longest traversable path from the given start to the given end node. # Description Implement a function `find_longest_path(graph, start, end)` that calculates the longest path in terms of the number of edges between the `start` and `end` nodes in the graph. Function Signature ```python def find_longest_path(graph: dict, start: str, end: str) -> List[str]: pass ``` Parameters - `graph`: A dictionary representation of a directed graph where the keys are node identifiers and the values are lists of neighboring node identifiers. - `start`: The starting node identifier. - `end`: The ending node identifier. Returns - A list of node identifiers representing the longest path from `start` to `end`. # Constraints - The graph will have at most 20 nodes. - There will be no negative edge weights. - All node identifiers will be unique strings. - The input graph is acyclic to simplify the solution space. # Example ```python # A sample graph represented as an adjacency list graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } # Example function call print(find_longest_path(graph, \'A\', \'D\')) # Expected output: [\'A\', \'C\', \'D\'] or [\'A\', \'B\', \'D\'] (both are valid longest paths with length 2 from \'A\' to \'D\') ``` # Performance Requirements You need to ensure your solution can handle graphs with up to 20 nodes efficiently.","solution":"def find_longest_path(graph, start, end): Finds the longest path from `start` to `end` in a directed acyclic graph. Parameters: - graph (dict): The directed graph where keys are node identifiers and values are lists of neighboring node identifiers. - start (str): The starting node identifier. - end (str): The ending node identifier. Returns: - List[str]: A list of node identifiers representing the longest path from `start` to `end`. def dfs(node, end, visited, path, longest_path): path.append(node) visited.add(node) if node == end: if len(path) > len(longest_path[0]): longest_path[0] = list(path) else: for neighbour in graph.get(node, []): if neighbour not in visited: dfs(neighbour, end, visited, path, longest_path) path.pop() visited.remove(node) longest_path = [[]] dfs(start, end, set(), [], longest_path) return longest_path[0]"},{"question":"# Task Implement a function that efficiently compresses a given input string using Run-Length Encoding (RLE) and another function that decompresses an RLE encoded string back to its original form. Ensure the encoding and decoding process maintain the integrity of the data. # Function Signatures ```python def encode_rle(input: str) -> str: # Your code here def decode_rle(input: str) -> str: # Your code here ``` # Input and Output Formats * **encode_rle**: * **Input**: A string `input` containing the data to be encoded. * Example: `aaabbcdddd` * **Output**: A string representing the RLE encoded data. * Example: `3a2b1c4d` * **decode_rle**: * **Input**: A RLE encoded string `input`. * Example: `3a2b1c4d` * **Output**: The original string before encoding. * Example: `aaabbcdddd` # Constraints 1. The encoding should preserve the exact count of characters. 2. The decoding should perfectly reconstruct the original data from the encoded string. 3. The input consists of only lowercase alphabetic characters without any special characters or digits. 4. You should handle empty strings gracefully. 5. Performance requirements are feasible within typical computational limits for medium-sized strings (up to 10,000 characters). # Example ```python encoded = encode_rle(\'aaabbcdddd\') print(encoded) # Output: \'3a2b1c4d\' decoded = decode_rle(\'3a2b1c4d\') print(decoded) # Output: \'aaabbcdddd\' ``` # Notes * Take care to properly handle edge cases such as empty input and inputs with no repeated characters. * The functions should not rely on any external libraries and should be written in pure Python.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = [] last_char = input[0] count = 1 for char in input[1:]: if char == last_char: count += 1 else: encoded_str.append(f\\"{count}{last_char}\\") last_char = char count = 1 encoded_str.append(f\\"{count}{last_char}\\") return \'\'.join(encoded_str) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_str = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 return \'\'.join(decoded_str)"},{"question":"# Question: Counting Digits in Large Numbers You have been hired as a software developer at a financial analytics company. One of your tasks is to develop a function to analyze large numeric data efficiently. One step in this analysis involves quickly computing the number of digits in various numbers, potentially large, to facilitate further processing. Your task is to write a Python function `count_digits(n: int) -> int` that computes the number of digits in a given integer `n`. # Function Signature ```python def count_digits(n: int) -> int: pass ``` # Input * `n` (int): An integer which may be positive, negative, or zero. The value of `n` can range from `-10^18` to `10^18`. # Output * Returns an integer representing the number of digits in the absolute value of `n`. # Constraints * Zero should be considered to have 1 digit. * The function should operate in constant time, O(1). # Examples # Example 1: * Input: `n = 12345` * Output: `5` # Example 2: * Input: `n = -9876` * Output: `4` # Example 3: * Input: `n = 0` * Output: `1` # Performance Requirements Your solution should have a time complexity of O(1) and a space complexity of O(1).","solution":"def count_digits(n: int) -> int: Returns the number of digits in the absolute value of the given integer n. return len(str(abs(n)))"},{"question":"# Question: Implement an Optimized Sorting Algorithm You have been tasked with optimizing the sorting process for a given array of integers. Instead of using the inefficient Exchange Sort algorithm, you should implement the Quick Sort algorithm. Quick Sort is a more advanced sorting algorithm that provides much better performance on random datasets compared to the Exchange Sort. Function Signature ```python def quick_sort(arr: List[int]) -> List[int]: pass ``` Input - A list of integers `arr` with length `n` where ( 0 leq n leq 10^6 ) Output - A sorted list of integers. Constraints - The function should have an average time complexity of O(n log n). - The function should be implemented in-place, requiring only O(log n) additional space. Example ```python assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert quick_sort([]) == [] assert quick_sort([1, 1, 1, 1]) == [1, 1, 1, 1] ``` Additional Requirements - You should implement the Quick Sort function without utilizing any built-in sorting functions. - Aim for clean and readable code with comments explaining your logic. Context Comparing the inefficient Exchange Sort to a more advanced Quick Sort will help demonstrate the clear performance benefits of using the right algorithm for the right scenario.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Quick Sort algorithm. def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_rec(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort_rec(arr, low, pi - 1) quick_sort_rec(arr, pi + 1, high) quick_sort_rec(arr, 0, len(arr) - 1) return arr"},{"question":"# Graph Path Finder You are given a graph represented as an adjacency list. Design and implement python functions that perform the following operations: 1. Find any path from a start node to an end node. 2. Find all paths from a start node to an end node. 3. Find the shortest path from a start node to an end node. Function Signatures: - `def find_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]:` - `def find_all_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]:` - `def find_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]:` Input: * `graph`: A dictionary where keys are node names and values are lists of names of nodes that are neighbors of the key node. * `start`: The starting node name as a string. * `end`: The destination node name as a string. Output: * `find_path` should return a list of node names representing a found path from `start` to `end`. If no path exists, return `None`. * `find_all_paths` should return a list of lists, where each list is a path from `start` to `end`. * `find_shortest_path` should return a list of node names representing the shortest path from `start` to `end`. If no path exists, return `None`. Constraints: * Assume no duplicate edges or self-loops in the graph. * Graph is directed. Performance Requirements: * The functions should handle graphs with up to 20 nodes efficiently. Example: ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"C\\"], \\"E\\": [\\"F\\"], \\"F\\": [\\"C\\"] } print(find_path(graph, \\"A\\", \\"D\\")) # Output: [\'A\', \'B\', \'C\', \'D\'] print(find_all_paths(graph, \\"A\\", \\"D\\")) # Output: [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] print(find_shortest_path(graph, \\"A\\", \\"D\\")) # Output: [\'A\', \'B\', \'D\'] ``` Implement these three functions ensuring that they work according to the specified behavior and constraints. Keep recursion depth in mind for large graphs and optimize where needed.","solution":"from typing import List, Dict, Optional def find_path(graph: Dict[str, List[str]], start: str, end: str) -> Optional[List[str]]: Finds any path from start to end using depth-first search. stack = [(start, [start])] while stack: (vertex, path) = stack.pop() for next in set(graph.get(vertex, [])) - set(path): if next == end: return path + [next] else: stack.append((next, path + [next])) return None def find_all_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]: Finds all paths from start to end using depth-first search. def dfs(current, end, path, paths): path = path + [current] if current == end: paths.append(path) else: for next in graph.get(current, []): if next not in path: dfs(next, end, path, paths) paths = [] dfs(start, end, [], paths) return paths def find_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> Optional[List[str]]: Finds the shortest path from start to end using breadth-first search. from collections import deque queue = deque([(start, [start])]) while queue: (vertex, path) = queue.popleft() for next in graph.get(vertex, []): if next not in path: if next == end: return path + [next] else: queue.append((next, path + [next])) return None"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Binary Search Tree (BST) * **Complexity**: - Insert/Search/Delete operations: Average case O(log n), Worst-case O(n) - Space complexity: O(n) where n is the number of nodes in the tree * **Principles**: - BST is a binary tree where each node has at most two children. - For any given node, the left child\'s value is less than the node\'s value and the right child\'s value is greater than the node\'s value. # Characteristics & Applications * **Properties**: - Efficient search, insertion, and deletion operations. - In-order traversal yields nodes in ascending order. * **Common Use Cases**: - Used in scenarios requiring dynamic set operations (e.g., dynamic lists with quick search). * **Strengths/Limitations**: - **Strengths**: Fast search, insertion, and deletion in average cases. Memory efficient, only needs space proportional to the number of elements stored. - **Limitations**: Performance can degrade to O(n) in the worst case (e.g., if the tree becomes skewed). # Implementation Challenges * **Edge Cases**: - Empty tree where the root is None. - Trees with only one node. - Trees that are skewed either left or right. * **Performance Bottlenecks**: - Skewed trees resulting in O(n) complexity for operations instead of O(log n). * **Error Scenarios**: - If nodes are not inserted properly maintaining BST properties, it would invalidate the tree structure. * **Optimization Points**: - Use of self-balancing trees (e.g., AVL tree, Red-Black tree) to ensure the tree remains balanced. <|Analysis End|> <|Question Begin|> # Coding Question **Problem Statement:** You are given a Binary Search Tree (BST) and you need to implement a function that calculates the number of empty branches in the tree. An \\"empty branch\\" is defined as a `None` child of any node. A leaf node (a node with no children) has two empty branches. Implement the function `count_empty_branches` which takes the root node of a BST and returns the total number of empty branches in the tree. **Function Signature:** ```python def count_empty_branches(root: Node) -> int: ``` **Input:** * A `Node` object representing the root of the Binary Search Tree or `None` if the tree is empty. **Output:** * An integer representing the total number of empty branches. **Constraints:** * The tree can have up to `10^5` nodes. * Each node of the tree contains a distinct integer value. **Examples:** 1. For the tree given below: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` Function call: `count_empty_branches(root)` should return `10`. 2. If the root is `None`: Function call: `count_empty_branches(root)` should return `1`. **Function Explanation:** You are required to traverse the given tree and count the number of `None` (empty) branches. This can be done by recursively visiting each node and counting the `None` children at each level of the tree. **Additional Notes:** - Make sure to handle edge cases like an empty tree or a tree with only a single node. - Optimize for both time and space complexity since the node count can be large (up to `10^5`). Good luck!","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def count_empty_branches(root: Node) -> int: Function to count the number of empty branches in a binary search tree. An empty branch is defined as a `None` child of any node. if root is None: # An empty tree has one empty branch (the root itself is None) return 1 # Initialize empty branch count empty_branches = 0 # Define a helper function to use recursion def count_helper(node): nonlocal empty_branches if node.left is None: # Left child is empty empty_branches += 1 else: count_helper(node.left) if node.right is None: # Right child is empty empty_branches += 1 else: count_helper(node.right) # Start the recursive counting from the root node count_helper(root) return empty_branches"},{"question":"You are tasked with designing functions to encode a list of strings to a single string representation and decode it back to the original list. This is particularly useful in scenarios where data needs to be serialized for network transmission. # Function Specifications 1. **encode(strs: List[str]) -> str**: - **Input**: A list of strings `strs` (0 ≤ len(strs) ≤ 10^5 and each string has length 0 ≤ len(string) ≤ 1000). - **Output**: A single string representing the encoded list of strings. 2. **decode(s: str) -> List[str]**: - **Input**: A single string `s`, the encoded representation of a list of strings. - **Output**: A list of strings that were originally encoded in `s`. # Example ```python # Example usage strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) print(encoded_str) # Output: \\"5:hello5:world\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` # Constraints 1. The encoded string should be a valid concatenation of the input strings with their lengths and delimiter. 2. The decode method should handle any well-formed encoded string according to the specified encoding process. # Implementation Details You are required to handle edge cases, such as: - Empty input list. - Strings that include \':\' character. - Verify lengths during decoding to avoid malformed input issues.","solution":"def encode(strs): Encode a list of strings to a single string. encoded_string = \'\' for s in strs: encoded_string += f\'{len(s)}:{s}\' return encoded_string def decode(s): Decode a single string to a list of strings. decoded_list = [] i = 0 while i < len(s): # Find the position of the next \':\' separator j = s.find(\':\', i) # Parse the length of the upcoming string length = int(s[i:j]) # Extract the string of the given length string = s[j+1:j+1+length] # Append the extracted string to the result list decoded_list.append(string) # Move the index to the next encoded string i = j + 1 + length return decoded_list"},{"question":"**Scenario**: A software company is developing a text analysis tool that detects repetitive patterns in user-submitted strings. As part of the development process, you are tasked with implementing a function that checks if a given string can be constructed by repeating a smaller substring. This functionality is crucial for optimizing storage by identifying and compressing repeating patterns. **Problem**: Write a function `find_repeated_substring` that determines if a given string `s` can be formed by repeating a shorter substring multiple times. The function should return `True` if it is possible, and `False` otherwise. # Function Signature ```python def find_repeated_substring(s: str) -> bool: :param s: input string :type s: str :return: return True if the string is a repeated substring pattern, else False ``` # Input - A single string `s` consisting of lowercase letters. # Output - Return a boolean value indicating whether `s` can be constructed from repeating a substring. # Constraints - The length of `s` will be between 1 and 10^4. - The input string consists of lowercase English letters only. # Examples Example 1 Input: ```python s = \\"abab\\" ``` Output: ```python True ``` Explanation: The string \\"abab\\" is a repetition of the substring \\"ab\\". Example 2 Input: ```python s = \\"aba\\" ``` Output: ```python False ``` Explanation: The string \\"aba\\" cannot be formed by repeating any substring. Example 3 Input: ```python s = \\"abcabcabcabc\\" ``` Output: ```python True ``` Explanation: The string \\"abcabcabcabc\\" is a repetition of the substring \\"abc\\". # Additional Information 1. An empty string should return `False`. 2. Consider edge cases such as single character strings or very high lengths of strings. # Performance Requirements - The implementation should be efficient with an emphasis on linear time complexity and reasonable space complexity, to handle input strings up to a length of 10^4. # Note - Avoid excessive use of intermediate data structures to optimize space usage. Provide a comprehensive implementation considering edge cases and the outlined performance requirements.","solution":"def find_repeated_substring(s: str) -> bool: Determines if the string s can be formed by repeating a smaller substring. :param s: input string :type s: str :return: return True if the string is a repeated substring pattern, else False if not s: return False n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"# String Rotation Checker You are tasked with implementing a function that determines if one string is a rotation of another string. This is a common problem in string manipulation where you need to check if a given string can be recomposed by rotating another string. Function Signature ```python def is_rotation(s1: str, s2: str) -> bool: ``` Input - Two strings `s1` and `s2`. Output - A boolean value: `True` if `s2` is a rotation of `s1`, `False` otherwise. Constraints - Consider edge cases such as empty strings. - Assume that both input strings consist of lowercase alphabetic characters and are case-sensitive. Performance Requirements - Your solution should aim for a linear time complexity O(N). # Example Case ```python assert is_rotation(\\"hello\\", \\"llohe\\") == True assert is_rotation(\\"hello\\", \\"helol\\") == False assert is_rotation(\\"hello\\", \\"hellohello\\") == False assert is_rotation(\\"\\", \\"\\") == True ``` # Scenarios or Context Imagine you are working on a text-related project involving cyclic permutations. You need a function to quickly determine if two sequences of text are rotations of each other to validate cyclic dependencies in texts. # Constraints - Lengths of `s1` and `s2` are at most 1000 characters. Implement the function in Python and validate your solution using the example cases and edge cases outlined above. # Notes - Focus on optimizing for performance and clarity. - Avoid brute-force solutions and aim for the most efficient approach discussed in the analysis.","solution":"def is_rotation(s1: str, s2: str) -> bool: Determines if one string is a rotation of another string. :param s1: The original string. :param s2: The string to check if it is a rotation of s1. :return: True if s2 is a rotation of s1, False otherwise. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"# Matrix Inversion Challenge Context Matrix inversion is a critical operation in various fields such as computer graphics, linear algebra, and engineering applications. Inverting a matrix is computationally intensive but necessary for solving linear systems and performing other matrix manipulations. Problem Statement You are required to implement a function that inverts an n x n matrix using the provided cofactor method description. Your implementation should handle edge cases and ensure the input is a valid matrix before proceeding with the inversion. Function Signature ```python def invert_matrix(m: List[List[float]]) -> List[List[float]]: pass ``` Input - A two-dimensional list `m` representing an n x n matrix. - Constraints: - `2 <= len(m) <= 10` - All rows in the matrix have an equal number of elements. - Each element of the matrix is a float, and the determinant of `m` is not zero. Output - A two-dimensional list representing the inverted matrix. - If the matrix is not a valid square matrix or any other error condition, return the matrix [[-1]]. Example Input: ```python m = [ [4, 7], [2, 6] ] ``` Output: ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` Additional Details - Avoid using numpy or other external libraries for this problem. - Ensure proper validation for inputs as described in the constraints. - Optimize where possible, keeping in mind that factorial complexity is inherent to the problem. **Note**: Provide intermediate utility functions if needed, but only the main function `invert_matrix` will be assessed.","solution":"from typing import List def invert_matrix(m: List[List[float]]) -> List[List[float]]: def get_matrix_minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def get_matrix_determinant(matrix): # Base case for 2x2 matrix: if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1) ** c) * matrix[0][c] * get_matrix_determinant(get_matrix_minor(matrix, 0, c)) return determinant def get_matrix_inverse(matrix): determinant = get_matrix_determinant(matrix) # Special case for 2x2 matrix: if len(matrix) == 2: return [ [matrix[1][1] / determinant, -1 * matrix[0][1] / determinant], [-1 * matrix[1][0] / determinant, matrix[0][0] / determinant] ] # Find matrix of cofactors cofactors = [] for r in range(len(matrix)): cofactor_row = [] for c in range(len(matrix)): minor = get_matrix_minor(matrix, r, c) cofactor_row.append(((-1) ** (r + c)) * get_matrix_determinant(minor)) cofactors.append(cofactor_row) cofactors = list(map(list, zip(*cofactors))) # Transpose for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / determinant return cofactors # Validate input n = len(m) if any(len(row) != n for row in m): return [[-1]] try: return get_matrix_inverse(m) except: return [[-1]]"},{"question":"You are tasked with implementing a more efficient substrings search algorithm that makes use of preprocessing to reduce the number of comparisons. Implement the Knuth-Morris-Pratt (KMP) algorithm to perform substring search. Objective: Write a function `find_needle_in_haystack(haystack: str, needle: str) -> int` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Input: - `haystack` (a string of length `n`, where 1 <= n <= 10^5) - `needle` (a string of length `m`, where 0 <= m <= 10^5) Output: - An integer index representing the start position of the first match of `needle` in `haystack`, or -1 if no match is found. Constraints: - The function should handle large inputs efficiently, hence utilize the KMP algorithm. - Handle edge cases including empty strings. Example: ```python # Example 1 Input: haystack = \\"hello\\", needle = \\"ll\\" Output: 2 # Example 2 Input: haystack = \\"aaaaa\\", needle = \\"bba\\" Output: -1 ``` Performance Requirements: - Time Complexity should be O(n + m). - Space Complexity should be O(m), primarily used for the prefix array. Hints: - Implement the preprocessing step to create the longest prefix which is also a suffix (LPS) array for the needle. - Use the LPS array to minimize the number of character comparisons.","solution":"def find_needle_in_haystack(haystack: str, needle: str) -> int: Implements the KMP algorithm to find the first occurrence of \'needle\' in \'haystack\'. Returns the starting index of \'needle\' in \'haystack\' or -1 if \'needle\' is not found. if not needle: return 0 # If the needle is an empty string, we return 0. n, m = len(haystack), len(needle) # Preprocess the needle to create the LPS array lps = [0] * m j = 0 # length of the previous longest prefix suffix i = 1 while i < m: if needle[i] == needle[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j-1] else: lps[i] = 0 i += 1 # Start searching using the LPS array i = j = 0 # index for haystack and needle respectively while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j # match found elif i < n and needle[j] != haystack[i]: if j != 0: j = lps[j-1] else: i += 1 return -1 # no match found"},{"question":"# Scenario You are working on a messaging application that needs to send and receive text messages efficiently. The messages, grouped as a list of strings, need to be encoded into a single string to be transmitted over the network and then decoded at the receiving end. Your job is to implement the functions `encode` and `decode` to handle the encoding and decoding of these messages. # Requirements 1. **Function `encode`**: - **Input**: A list of strings `strs` (List[str]). - **Output**: A single encoded string (str). - **Constraints**: - Strings in the list can contain any printable ASCII character. - Ensure the encoding scheme can handle any valid string that does not contain the delimiter. 2. **Function `decode`**: - **Input**: An encoded single string (str). - **Output**: The original list of strings (List[str]). - **Constraints**: - The encoded string format must conform to the encoding scheme. # Example ```python strs = [\\"hello\\", \\"world\\"] encoded_string = encode(strs) print(encoded_string) # Expected output: \\"5:hello5:world\\" decoded_list = decode(encoded_string) print(decoded_list) # Expected output: [\\"hello\\", \\"world\\"] ``` # Edge Cases - The input list of strings being empty. - Strings in the list containing numbers and delimiter characters. # Implementation Signature ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str pass def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] pass ``` Implement the `encode` and `decode` functions based on the above specification.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_str = \\"\\" for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) strs.append(s[j+1:j+1+length]) i = j + 1 + length return strs"},{"question":"# Linked List Deduplication Challenge Context: You are given the task to clean up a linked list by removing duplicate elements. Two algorithms have been outlined for reference, highlighting different approaches with their own advantages and challenges. Task: Implement a function in Python that removes duplicate values from a linked list. You must choose the approach you think is most efficient while ensuring correctness and handling edge cases. Your solution will be tested with various linked list configurations for accuracy and performance. Define the function `remove_duplicates(head: Node) -> None` that will modify the linked list in place to remove any duplicate nodes. Input: - `head`: The head node of the singly linked list. Output: - The function returns `None`. The linked list is modified in place. Constraints: - The length of the linked list will not exceed 10^5. - Each node contains a string value. Example: **Input**: ``` A -> A -> B -> C -> D -> C -> F -> G ``` **Output**: ``` A -> B -> C -> D -> F -> G ``` Requirements: 1. The solution must handle an empty linked list. 2. Efficiency and correctness will be evaluated. 3. Space complexity should be O(N) at maximum to account for large linked lists. 4. Handle edge cases where the linked list has all unique elements or all elements are the same. **Example code structure**: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> None: # Implement your solution here pass def print_linked_list(head: Node) -> None: # Provided utility to print the linked list for testing string = \\"\\" while head and head.next: string += head.val + \\" -> \\" head = head.next if head: string += head.val print(string) # Example linked list setup and test a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates(a1) print_linked_list(a1) ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> None: if head is None: return current = head seen_values = set() seen_values.add(current.val) while current.next is not None: if current.next.val in seen_values: current.next = current.next.next else: seen_values.add(current.next.val) current = current.next"},{"question":"B-Tree Balanced Tree Operations **Context**: A B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. It is mostly used in databases and file systems. # Problem Statement Implement a method to perform a range query on a B-tree. A range query retrieves all elements within a specified range [min_val, max_val]. The provided BTree class contains insertion, search, and deletion methods. You need to implement a method `range_query` that efficiently retrieves all keys between `min_val` and `max_val`. # Function Signature: ```python def range_query(btree: BTree, min_val: int, max_val: int) -> List[int]: pass ``` # Input - `btree` (BTree): An instance of a BTree. - `min_val` (int): The lower bound of the range. - `max_val` (int): The upper bound of the range. # Output - A list of integers representing the keys within the specified range [min_val, max_val] inclusive, sorted in ascending order. # Constraints - min_val <= max_val - The B-tree contains unique integer keys. # Example ```python # Example Usage btree = BTree(t_val=3) keys_to_insert = [20, 50, 70, 90, 30, 10, 60, 80, 40, 100] for key in keys_to_insert: btree.insert_key(key) # Performing range query assert range_query(btree, 30, 70) == [30, 40, 50, 60, 70] # Another range query assert range_query(btree, 15, 55) == [20, 30, 40, 50] ``` # Explanation Given the B-tree, the `range_query` function must traverse the tree and collect all the keys that fall within the specified range efficiently. Consider optimizing for both time and space complexity. **Hints**: 1. Use a depth-first traversal to visit nodes. 2. Skip entire subtrees that do not intersect with the range. 3. Ensure the method is called in a way that respects the B-tree properties.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = BTreeNode(t, leaf=True) self.t = t def traverse(self, node, result): for i in range(len(node.keys)): if not node.leaf: self.traverse(node.children[i], result) result.append(node.keys[i]) if not node.leaf: self.traverse(node.children[len(node.keys)], result) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t) self.root = temp temp.children.append(root) self.split_child(temp, 0) self.insert_non_full(temp, key) else: self.insert_non_full(root, key) def insert_non_full(self, node, key): if node.leaf: index = len(node.keys) - 1 node.keys.append(None) while index >= 0 and key < node.keys[index]: node.keys[index + 1] = node.keys[index] index -= 1 node.keys[index + 1] = key else: index = len(node.keys) - 1 while index >= 0 and key < node.keys[index]: index -= 1 index += 1 if len(node.children[index].keys) == 2 * self.t - 1: self.split_child(node, index) if key > node.keys[index]: index += 1 self.insert_non_full(node.children[index], key) def split_child(self, parent, i): t = self.t node = parent.children[i] new_node = BTreeNode(node.t, node.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node.keys[t - 1]) new_node.keys = node.keys[t:(2 * t - 1)] node.keys = node.keys[0:(t - 1)] if not node.leaf: new_node.children = node.children[t:(2 * t)] node.children = node.children[0:(t)] def range_query(btree, min_val, max_val): result = [] def traverse(node): for i in range(len(node.keys)): if node.keys[i] >= min_val: if not node.leaf: traverse(node.children[i]) if min_val <= node.keys[i] <= max_val: result.append(node.keys[i]) if node.keys[i] > max_val: return if not node.leaf: traverse(node.children[len(node.keys)]) traverse(btree.root) return result"},{"question":"# Flatten Nested Lists In many programming applications, data is often stored in deeply nested structures. To facilitate certain types of processing, it might be necessary to flatten these structures. Task: Implement a function to flatten an arbitrarily deeply nested list into a single list of elements. Write a function `flatten_list` with the following signature: ```python def flatten_list(input_arr): ``` Input: - `input_arr` (list): Arbitrarily nested list of elements. The elements could also be iterables but are not nested to arbitrary depth (for example: `[1, [2, [3, 4]], 5, 6]`). Output: - (list): A list containing all the elements from all levels of nesting in the same order as they appeared in the nested lists. Constraints: - The input will not contain cyclic references. - Elements inside the list can be of any type, including other iterables. - Nested levels will not exceed Python\'s recursion limit for standard input sizes. Example: ```python # Example 1: input_arr = [1, [2, [3, 4]], 5, 6] output = flatten_list(input_arr) print(output) # Expected Output: [1, 2, 3, 4, 5, 6] # Example 2: input_arr = [[[1, 2], [3, 4]], [5, 6], 7, [8, [9, 10]]] output = flatten_list(input_arr) print(output) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` Performance Expectations: - Expected to handle reasonably large and deeply nested lists within standard recursion limits of Python. - Aim for a time complexity of O(N), where N is the total number of elements in all nested arrays. Use the above understanding to ensure that your implementation is efficient and handles edge cases appropriately. **Note**: Refrain from using any libraries or functions that explicitly perform flattening.","solution":"def flatten_list(input_arr): flattened = [] def _flatten(x): if isinstance(x, list): for item in x: _flatten(item) else: flattened.append(x) _flatten(input_arr) return flattened"},{"question":"# Question: Design a function `merge_two_sorted_lists` that merges two sorted linked lists and returns a single sorted linked list. Your task is to implement this function both iteratively and recursively. Function Signature ```python def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: pass def merge_two_sorted_lists_recursive(l1: ListNode, l2: ListNode) -> ListNode: pass ``` # Input Format: - Two parameters `l1` and `l2`, where each is a pointer/reference to the head of a sorted linked list. - Each linked list node is represented by a class `ListNode`. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Output Format: - Return a pointer/reference to the head of the merged sorted linked list. # Constraints: - The number of nodes in both linked lists is in the range `[0, 50]`. - `-100 <= Node.val <= 100` - The input lists are sorted in non-decreasing order. # Performance Requirements: - The solution should run in linear time, O(n+m), where n and m are the lengths of the input lists. # Examples: Example 1: ```python Input: l1 = [1,2,4], l2 = [1,3,4] Output: [1,1,2,3,4,4] ``` Example 2: ```python Input: l1 = [], l2 = [] Output: [] ``` Example 3: ```python Input: l1 = [], l2 = [0] Output: [0] ``` # Notes: 1. Do not modify the nodes of list instances, create new nodes instead. 2. Implement proper error handling for any potential edge cases, such as when one or both input lists are empty.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 else: tail.next = l2 return dummy.next def merge_two_sorted_lists_recursive(l1: ListNode, l2: ListNode) -> ListNode: if not l1: return l2 if not l2: return l1 if l1.val < l2.val: l1.next = merge_two_sorted_lists_recursive(l1.next, l2) return l1 else: l2.next = merge_two_sorted_lists_recursive(l1, l2.next) return l2"},{"question":"# Scenario You are working on a web crawler that deals with numerous URLs containing query parameters. To optimize storage and prevent redundant queries, you need a function that will clean up these URLs by removing duplicate parameters and optionally stripping specified ones. # Task Write a Python function named `clean_url` that takes a URL string and an optional list of query string parameters to strip. The function should return a cleaned-up URL string with the following properties: 1. All duplicate query parameters should be removed; only the first occurrence should be kept. 2. Any parameters specified in the list to strip should be removed entirely. 3. Ensure preserved parameters are sorted for consistent output. # Function Signature ```python def clean_url(url: str, params_to_strip: list = []) -> str: pass ``` # Input - `url` (str): A string containing the full URL. - `params_to_strip` (list): A list of strings representing parameters to remove. Default is an empty list. # Output - The cleaned URL string with duplicate parameters removed and specific parameters stripped. # Constraints - URLs will be valid ASCII strings containing alphanumeric characters and standard URL punctuation. - No need to handle URLs exceeding 2048 characters. # Examples - `clean_url(\\"www.saadbenn.com?a=1&b=2&a=2\\")` should return `\\"www.saadbenn.com?a=1&b=2\\"`. - `clean_url(\\"www.saadbenn.com?a=1&b=2&a=2&c=3\\", [\\"a\\"])` should return `\\"www.saadbenn.com?b=2&c=3\\"`. # Notes - Include appropriate error handling for edge cases. - Provide tests for each edge case within your submission.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def clean_url(url: str, params_to_strip: list = []) -> str: Cleans-up the URL by removing duplicate query parameters and optionally stripping specified ones. Ensures preserved parameters are sorted for consistent output. :param url: The full URL string. :param params_to_strip: An optional list of query string parameters to remove. :return: Cleaned URL string. parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query, keep_blank_values=True) seen_params = set() cleaned_params = [] for key, value in query_params: if key not in seen_params and key not in params_to_strip: cleaned_params.append((key, value)) seen_params.add(key) sorted_params = sorted(cleaned_params, key=lambda x: x[0]) encoded_params = urlencode(sorted_params) cleaned_url = urlunparse(( parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, encoded_params, parsed_url.fragment )) return cleaned_url"},{"question":"# Segment Tree Range Minimum Query You have been provided a `SegmentTree` class that can efficiently perform range queries on an array using a specified function like sum, max, or min. Your task is to extend this class to support efficient range minimum queries (RMQ) and write additional code for a new function `update` which updates an index in the array to a new value and modifies the segment tree accordingly. Function Signature: ```python class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): # Initialize Segment Tree (already provided) def query(self, L: int, R: int) -> int: # Query the range [L, R] (already provided) def update(self, idx: int, val: int) -> None: # Update the element at index `idx` to `val` and modify the segment tree # Example Usage: # st = SegmentTree([1, 3, 2, 7, 9, 11], min) # assert st.query(1, 4) == 2 # st.update(2, 5) # assert st.query(1, 4) == 3 ``` Constraints: - The array size will be up to `10^5` elements. - Each element in the array will be an integer within the range of `[-10^6, 10^6]`. - There will be up to `10^4` queries and updates. Requirements: 1. Extend the `SegmentTree` class to include an `update` method. 2. Ensure the functionality supports range minimum queries using the `min` function. 3. The `update` function should efficiently update the segment tree in O(logN) time.","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): self.n = len(arr) self.tree = [0] * (2 * self.n) self.function = function # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L: int, R: int) -> int: L += self.n R += self.n res = float(\'inf\') if self.function == min else 0 while L < R: if L % 2: res = self.function(res, self.tree[L]) L += 1 if R % 2: R -= 1 res = self.function(res, self.tree[R]) L //= 2 R //= 2 return res def update(self, idx: int, val: int) -> None: idx += self.n self.tree[idx] = val while idx > 1: idx //= 2 self.tree[idx] = self.function(self.tree[2 * idx], self.tree[2 * idx + 1])"},{"question":"You are given an array of integers and two optional boundary values (`min_lim` and `max_lim`). Your task is to create a function that filters the array, returning a new array that contains only elements within the specified range, inclusive of boundary values. # Function Signature ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` # Input - `arr`: A list of integers, e.g., `[1, 2, 3, 4, 5]` - `min_lim`: An integer or `None` (default is `None`), specifying the lower bound. - `max_lim`: An integer or `None` (default is `None`), specifying the upper bound. # Output - Returns a list of integers, filtered such that each element `x` in the resulting list satisfies `min_lim <= x <= max_lim`. # Constraints - The input list can have up to (10^6) elements. - Elements within the array will be in the range [-10^6, 10^6]. - Both `min_lim` and `max_lim`, if provided, will be within the range [-10^6, 10^6]. - If `min_lim` is `None`, apply no lower bound. - If `max_lim` is `None`, apply no upper bound. # Examples 1. `limit([1, 2, 3, 4, 5], None, 3)` should return `[1, 2, 3]` 2. `limit([10, 20, 30, 40, 50], 15, 45)` should return `[20, 30, 40]` 3. `limit([4, 6, 7, 1, 9, 3], 5, None)` should return `[6, 7, 9]` 4. `limit([], 5, 10)` should return `[]` # Notes - Assume `arr` will only contain integers. - You may not assume `min_lim` or `max_lim` are always provided; handle cases where they are missing (i.e., `None`). Implement the function `limit` accordingly and ensure it handles all specified edge cases and constraints efficiently.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters the given array based on the specified boundary values (min_lim and max_lim). Parameters: - arr: List of integers to be filtered. - min_lim: Optional integer, the lower bound for filtering. - max_lim: Optional integer, the upper bound for filtering. Returns: A list of integers with elements within the specified range [min_lim, max_lim]. return [x for x in arr if (min_lim is None or x >= min_lim) and (max_lim is None or x <= max_lim)]"},{"question":"# Question: You are tasked with implementing a dynamic connectivity algorithm to track the number of islands in a 2D grid after each \\"add land\\" operation. An island is formed by connecting adjacent lands horizontally or vertically, and initially, the grid is filled with water (represented by 0). Task: Write a function `num_islands(m: int, n: int, positions: List[Tuple[int, int]]) -> List[int]` to determine the number of islands after each land addition. Input: - `m` (int): Number of rows in the grid - `n` (int): Number of columns in the grid - `positions` (List[Tuple[int, int]]): A list of positions where each position contains a pair of integers representing the grid coordinates to add land. Output: - Return a list of integers where each integer represents the number of islands after each respective land addition. Constraints: - 1 <= m, n <= 1000 - 1 <= len(positions) <= min(1000, m*n) - positions contain tuples (r, c) such that 0 <= r < m and 0 <= c < n Example: ```python m, n = 3, 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(num_islands(m, n, positions)) # Output: [1, 1, 2, 3] ``` Explanation: - Initially, the grid is filled with water: ``` 0 0 0 0 0 0 0 0 0 ``` - After adding land at (0,0): ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1 - After adding land at (0,1): ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1 - After adding land at (1,2): ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2 - After adding land at (2,1): ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3 Implement the function keeping an optimal time and space complexity in mind.","solution":"from typing import List, Tuple def num_islands(m: int, n: int, positions: List[Tuple[int, int]]) -> List[int]: def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False parent = {} rank = {} grid = [[0] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] num_islands_result = [] count = 0 for r, c in positions: if grid[r][c] == 1: num_islands_result.append(count) continue grid[r][c] = 1 idx = r * n + c parent[idx] = idx rank[idx] = 0 count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1: neighbor_idx = nr * n + nc if union(idx, neighbor_idx): count -= 1 num_islands_result.append(count) return num_islands_result"},{"question":"# Question: Flatten Multi-Dimensional Arrays You are tasked with implementing a function to flatten multi-dimensional arrays (which can contain other arrays) into a single-dimensional list or a generator that yields elements in a flattened manner. Your function should handle arbitrary levels of nesting and be optimized for both performance and correctness. Task Implement two functions: 1. `flatten(input_arr: Iterable) -> List` 2. `flatten_iter(iterable: Iterable) -> Generator` Specifications 1. **Flatten Function (List Output)** * **Input**: A possible multi-dimensional array `input_arr` (array can contain other arrays or any other types). * **Output**: A single-dimensional list containing all elements from the multi-dimensional array in their original order. * **Constraints**: * Assume the array does not contain any cyclical references. * The array can contain any iterable type, e.g., lists, tuples, sets, except for strings which should not be further iterated. 2. **Flatten Iter Function (Generator Output)** * **Input**: A possible multi-dimensional iterable `iterable`. * **Output**: A generator that yields elements one by one from the multi-dimensional iterable in their original order. * **Constraints**: * Similar to the first function regarding input types. Example of Usage ```python # List Output print(flatten([1, [2, [3, 4]], 5])) # Output: [1, 2, 3, 4, 5] print(flatten([[], [[[], []]], []])) # Output: [] # Generator Output print(list(flatten_iter([1, [2, [3, 4]], 5]))) # Output: [1, 2, 3, 4, 5] print(list(flatten_iter([[], [[[], []]], []]))) # Output: [] ``` Your implementation should handle various edge cases and should be tested for efficiency against deeply nested structures.","solution":"from collections.abc import Iterable def flatten(input_arr): Flatten a multi-dimensional array into a single-dimensional list. :param input_arr: A possible multi-dimensional array :return: A single-dimensional list containing all elements from the multi-dimensional array result = [] for element in input_arr: if isinstance(element, Iterable) and not isinstance(element, (str, bytes)): result.extend(flatten(element)) else: result.append(element) return result def flatten_iter(iterable): Flatten a multi-dimensional iterable into a generator. :param iterable: A possible multi-dimensional iterable :yield: Elements from the multi-dimensional iterable in their original order for element in iterable: if isinstance(element, Iterable) and not isinstance(element, (str, bytes)): yield from flatten_iter(element) else: yield element"},{"question":"Context: You have a sorted list of unique integers. Your task is to write a function that summarizes the continuous ranges found within this list. Each continuous range should be represented by the smallest and largest numbers in that range, and single numbers should stand alone. Function Signature: ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input: - A list of integers `array` which is sorted in non-decreasing order and contains no duplicates. Output: - A list of strings, where each string represents a range in the following format: - \\"start-end\\" for ranges of two or more numbers. - \\"start\\" for single numbers. Constraints: - The input list can be empty. - The length of the list `n` is in the range [0, 10^4]. Performance Requirements: - The solution must have a time complexity of O(n) and space complexity of O(1) (excluding the space required to store the output). Example: ```python array = [0, 1, 2, 4, 5, 7] # The function should return: # [\\"0-2\\", \\"4-5\\", \\"7\\"] ``` Notes: - Ensure proper handling of different edge cases, such as: - An empty input list. - Input lists with one element. - Input lists with no continuous ranges (i.e., all elements are isolated). Write a function `summarize_ranges` according to the above description.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Context You are building a low-level data manipulation tool that needs to calculate the difference between data represented in binary format. One critical task is to determine the number of bits that differ between two binary data strings which represent integer values. This is important for tasks such as error detection in data transmission or comparing different versions of binary data. # Problem Statement Write a function `count_flips_to_convert(a: int, b: int) -> int` that calculates the minimal number of bits required to convert integer `a` to integer `b`. Input * `a` (0 <= a <= 2^31 - 1): A non-negative integer. * `b` (0 <= b <= 2^31 - 1): A non-negative integer. Output * An integer representing the number of bits that need to be flipped to convert `a` to `b`. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: pass ``` # Constraints * The function must run efficiently within O(n) time complexity, where n is the number of bits in the integer values. * Use minimal additional memory (O(1) space complexity). # Examples 1. **Example 1**: * Input: `a = 29`, `b = 15` * Output: `2` * Explanation: The binary representation of `29` is `11101`, and `15` is `01111`. Differing bits are: ``` 11101 01111 ----- 10010 (Two 1\'s signify two different bits) ``` 2. **Example 2**: * Input: `a = 8`, `b = 7` * Output: `4` * Explanation: The binary representation of `8` is `1000`, and `7` is `0111`. Differing bits are: ``` 1000 0111 ----- 1111 (Four 1\'s signify four different bits) ``` # Requirements - The function should not use any library that directly solves the problem such as `bin()` or libraries with high-level bit operations not covered in this algorithm description.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Calculate the number of bits required to change integer a to integer b. # XOR operation will give a number with bits set where a and b differ xor_result = a ^ b # Count the number of set bits in the xor_result count = 0 while xor_result: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"# Scenario You\'ve been assigned to implement functionality for a new game system where elements can be quickly added or removed, and during gameplay, a random element from the current set of elements is needed frequently. Performance is crucial as the system runs real-time and should handle these operations efficiently. # Task Design a data structure named `CustomRandomSet` that supports the following operations: 1. `add(value: int) -> bool`: Adds a value to the set if it is not already present. Returns `True` if the element was added, and `False` if the element was already present. 2. `delete(value: int) -> bool`: Removes a value from the set if it is present. Returns `True` if the element was removed, and `False` if the element was not in the set. 3. `get_random() -> int`: Returns a random element from the current set, with each element having the same probability of being returned. # Implementation Requirements 1. The operations `add`, `delete`, and `get_random` must all run in average O(1) time. 2. You should not use any built-in libraries that directly provide this functionality. 3. Your solution should handle adding and deleting up to 100,000 elements efficiently. # Example ```python # Example use case if __name__ == \\"__main__\\": custom_set = CustomRandomSet() print(custom_set.add(1)) # True print(custom_set.add(2)) # True print(custom_set.add(1)) # False print(custom_set.delete(2)) # True print(custom_set.delete(2)) # False print(custom_set.get_random()) # 1 or some existing element ``` # Constraints - Elements to be handled are integers within the range `-10^6` to `10^6`. - Calls to `add`, `delete`, and `get_random` can be in any sequence.","solution":"import random class CustomRandomSet: def __init__(self): self.element_list = [] self.element_map = {} def add(self, value: int) -> bool: if value in self.element_map: return False self.element_map[value] = len(self.element_list) self.element_list.append(value) return True def delete(self, value: int) -> bool: if value not in self.element_map: return False index = self.element_map[value] last_element = self.element_list[-1] self.element_list[index] = last_element self.element_map[last_element] = index self.element_list.pop() del self.element_map[value] return True def get_random(self) -> int: return random.choice(self.element_list)"},{"question":"You are working on enhancements to a scientific computing library. One of its functions needs to perform matrix exponentiation efficiently for large dimensions and exponents. Task Implement a function `matrix_exponentiation(mat: list, n: int) -> list` that computes the n-th power of a given square matrix `mat` using the principles of repeated squaring. # Function Signature ```python def matrix_exponentiation(mat: list, n: int) -> list: ``` # Input * `mat` (list of lists): A square matrix of dimension `d x d` where `2 <= d <= 100`. * `n` (int): A non-negative integer representing the exponent (0 <= n <= 10^9). # Output * Returns a list of lists representing the matrix raised to the power `n`. # Example ```python >>> mat = [ ... [1, 1], ... [1, 0] ... ] >>> n = 5 >>> matrix_exponentiation(mat, n) [[8, 5], [5, 3]] ``` # Constraints * Your solution should handle large values of `n` efficiently (in O(d^3 log(n)) time complexity). Additional Notes * You can implement auxiliary functions like `multiply` and `identity` if needed. * Python handles large integers natively, so you do not need to worry about integer overflow. Good luck, and remember to test your implementation with various edge cases, such as n = 0 and large values of n.","solution":"def matrix_exponentiation(mat, n): def multiply(mat1, mat2): # Function to multiply two matrices size = len(mat1) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += mat1[i][k] * mat2[k][j] return result def identity(size): # Function to create identity matrix of given size result = [[0] * size for _ in range(size)] for i in range(size): result[i][i] = 1 return result def power(mat, exp): # Function to perform matrix exponentiation using repeated squaring size = len(mat) result = identity(size) base = mat while exp > 0: if exp % 2 == 1: result = multiply(result, base) base = multiply(base, base) exp //= 2 return result return power(mat, n)"},{"question":"# Question: Implement Graph Cloning with Preprocessing Given an undirected graph represented via its adjacency list, write a function `clone_preprocessed_graph` to produce a deep copy of the graph. To enhance the function, preprocess the graph to eliminate any self-loops before performing the cloning. # Function Signature ```python def clone_preprocessed_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Input - `node`: An instance of `UndirectedGraphNode`, the entry point to the undirected graph. # Output - Returns a new `UndirectedGraphNode` instance, which is the entry point to the cloned graph where all self-loops are removed. # Constraints 1. Node labels are unique across the graph. 2. The graph may contain cycles and disconnected components. 3. Graph nodes are instances of `UndirectedGraphNode` provided in the starter code. # Example Given original graph as: ``` 1 / / 0 --- 2 / _/ ``` Graph serialized as: `{0,1,2#1,2#2,2}` After removing self-loops: ``` 1 / / 0 --- 2 ``` Serialized as: `{0,1,2#1,2#2}` # Requirements 1. Implement the preprocessing to remove self-loops. 2. Clone the graph using either BFS, iterative DFS, or recursive DFS. # Notes - You may use the code snippets provided in the starter code for the cloning operation. - Ensure your function handles both preprocessing and graph cloning efficiently.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_preprocessed_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None def remove_self_loops(node: \'UndirectedGraphNode\'): visited = set() stack = [node] while stack: current = stack.pop() if current.label in visited: continue visited.add(current.label) new_neighbors = [neighbor for neighbor in current.neighbors if neighbor.label != current.label] current.neighbors = new_neighbors for neighbor in current.neighbors: if neighbor.label not in visited: stack.append(neighbor) def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': visited = {} def dfs(node): if node.label in visited: return visited[node.label] clone = UndirectedGraphNode(node.label) visited[node.label] = clone for neighbor in node.neighbors: clone.neighbors.append(dfs(neighbor)) return clone return dfs(node) # Remove self-loops from the provided graph remove_self_loops(node) # Clone the graph return clone_graph(node)"},{"question":"# Matrix Multiplication Challenge Context In linear algebra and various computational fields, the operation of multiplying two matrices is a fundamental task. Matrix multiplication involves taking two matrices and producing a third matrix, which represents the composite transformation of the two input matrices. Problem Statement Write a function `multiply_matrices` that takes two matrices represented as lists of lists and returns their product. Function Signature ```python def multiply_matrices(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: pass ``` Input * `multiplicand` (List[List[int]]): A matrix represented as a list of lists with dimensions (m times n). * `multiplier` (List[List[int]]): A matrix represented as a list of lists with dimensions (n times p). Output * Returns a matrix (List[List[int]]) with dimensions (m times p) representing the product of `multiplicand` and `multiplier`. Constraints * The number of columns in `multiplicand` must equal the number of rows in `multiplier`. * The elements in the matrices are integers. * You may assume both matrices are well-formed (all rows have the same number of columns). Examples ```python # Example 1 m1 = [[1, 2], [3, 4]] m2 = [[2, 0], [1, 2]] result = multiply_matrices(m1, m2) # Expected output: [[4, 4], [10, 8]] # Example 2 m1 = [[1, 0, 2], [-1, 3, 1]] m2 = [[3, 1], [2, 1], [1, 0]] result = multiply_matrices(m1, m2) # Expected output: [[5, 1], [4, 2]] ``` Note - Take special care to handle edge cases where the matrices might be empty or contain zero dimensions. - Optimal performance is not the primary goal, but ensuring correct and efficient multiplication within reasonable input sizes is expected.","solution":"def multiply_matrices(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You are given an integer array representing stock prices for each day in a period. To strategize your investments, you want to know the maximum profit (or minimum loss) you could achieve if you buy and sell within any contiguous subarray of stock prices. Implement a function `max_profit_subarray(prices)` that returns the maximum profit (or minimum loss) achievable from any contiguous subarray of the input list. # Function Signature ```python def max_profit_subarray(prices: list[int]) -> int: pass ``` # Input Format * A list `prices` of integers where each element represents the stock price on a particular day. * The list is non-empty and can contain both positive and negative values. # Output Format * Return a single integer which is the maximum profit (or minimum loss) achievable. # Constraints * The length of `prices` array will not exceed (10^5). * The integer values in the list will be in the range ([-10^4, 10^4]). # Examples Example 1 ```python prices = [1, -3, 2, 1, -1] print(max_profit_subarray(prices)) # Output: 3 Explanation: The subarray [2, 1] yields the maximum profit of 3. ``` Example 2 ```python prices = [-2,1,-3,4,-1,2,1,-5,4] print(max_profit_subarray(prices)) # Output: 6 Explanation: The subarray [4,-1,2,1] yields the maximum profit of 6. ``` # Scenarios to consider 1. Single element arrays. 2. Arrays with all negative values. 3. Arrays with the maximum value at the start or end of the array. 4. Mixed positive and negative values. Ensure your function handles these edge cases efficiently.","solution":"def max_profit_subarray(prices): Returns the maximum profit (or minimum loss) achievable from any contiguous subarray. Uses Kadane\'s Algorithm to find the maximum sum of a contiguous subarray. max_current = max_global = prices[0] for price in prices[1:]: max_current = max(price, max_current + price) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Knapsack Problem with Constraints Given a list of `Item`s, each with a `value` and a `weight`, and a maximum `capacity` of a knapsack, write a function `get_maximum_value` that returns the maximum value that can be achieved by selecting a subset of the items without exceeding the given capacity. Input * `items` (list of `Item` objects): Each item i has two properties: - `value` (int): The value of the item. - `weight` (int): The weight of the item. * `capacity` (int): The maximum weight capacity of the knapsack. Output * Returns an integer representing the maximum value that can be achieved within the given capacity. Constraints * All values are non-negative integers. * The number of items (n) and the capacity (m) are under reasonable limits (e.g., n <= 1000, m <= 1000). * Assumes items weights and knapsack capacity are integer values. Example ```python class Item: def __init__(self, value, weight): self.value = value self.weight = weight items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] capacity = 5 print(get_maximum_value(items, capacity)) # Output should be 80 ``` Edge Cases to Consider * An empty list of items or zero capacity knapsack. * Items with zero value and/or weight. * Items with value greater than knapsack\'s initial capacity. Write a function to solve this problem using dynamic programming principles: ```python def get_maximum_value(items, capacity): # Your implementation here ```","solution":"class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items, capacity): n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if items[i - 1].weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - items[i - 1].weight] + items[i - 1].value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# AVL Tree Implementation and Enhancement Problem Statement You are tasked with implementing and enhancing the AVL Tree, a self-balancing binary search tree. The AVL Tree maintains its balance by performing rotations during insertions and deletions. Your goal is to complete the provided implementation by adding a deletion method and ensuring all methods work correctly. Requirements 1. **Add Deletion Method**: Implement the `delete` method to remove nodes from the tree while maintaining the AVL balance. 2. **Handling Edge Cases**: Ensure your implementation correctly handles edge cases, such as deleting leaf nodes, nodes with one child, and nodes with two children. 3. **Validate Balance**: After each insertion or deletion, verify if the tree is balanced and perform rotations if necessary. 4. **Unit Tests**: Write unit tests to validate the correctness of your AVL Tree implementation, covering various scenarios including: - Inserting and deleting nodes in random order. - Deleting root node. - Checking if the tree remains balanced after operations. Implementation Details - **Input Format**: - `insert(self, key: int) -> None`: Inserts a key into the AVL Tree. - `delete(self, key: int) -> None`: Deletes a key from the AVL Tree. - `in_order_traverse(self) -> List[int]`: Returns an in-order traversal of the AVL Tree. - **Output Format**: - `insert` and `delete` methods do not return any value. - `in_order_traverse` returns a list of integers representing the in-order traversal of the tree. - **Constraints**: - Inserted keys are unique and within the range of -10^5 to 10^5. - Your implementation should maintain O(log n) time complexity for insertion, deletion, and search. Example ```python tree = AvlTree() tree.insert(15) tree.insert(20) tree.insert(24) tree.insert(10) tree.insert(13) tree.insert(7) tree.insert(30) print(tree.in_order_traverse()) # Output: [7, 10, 13, 15, 20, 24, 30] tree.delete(24) print(tree.in_order_traverse()) # Output: [7, 10, 13, 15, 20, 30] tree.delete(10) print(tree.in_order_traverse()) # Output: [7, 13, 15, 20, 30] ``` Notes - Use the provided stub code as a starting point. - Ensure your `delete` method also maintains the AVL properties. - Test your implementation thoroughly to cover all scenarios to validate the AVL Tree functionality.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def _get_height(self, node): if not node: return 0 return node.height def _update_height(self, node): node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self._update_height(y) self._update_height(x) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self._update_height(x) self._update_height(y) return y def _balance(self, node): if not node: return node self._update_height(node) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._rotate_right(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._rotate_left(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def insert(self, key): def _insert(node, key): if not node: return TreeNode(key) elif key < node.key: node.left = _insert(node.left, key) else: node.right = _insert(node.right, key) return self._balance(node) self.root = _insert(self.root, key) def delete(self, key): def _min_value_node(node): current = node while current.left is not None: current = current.left return current def _delete(node, key): if not node: return node if key < node.key: node.left = _delete(node.left, key) elif key > node.key: node.right = _delete(node.right, key) else: if not node.left: temp = node.right node = None return temp elif not node.right: temp = node.left node = None return temp temp = _min_value_node(node.right) node.key = temp.key node.right = _delete(node.right, temp.key) return self._balance(node) self.root = _delete(self.root, key) def in_order_traverse(self): result = [] def _in_order(node): if node: _in_order(node.left) result.append(node.key) _in_order(node.right) _in_order(self.root) return result def __init__(self): self.root = None"},{"question":"Context You are tasked with implementing a function to search for multiple words in a 2D board of characters. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once for a particular word search. Given A 2D matrix `board` and a list of `words`. Requirements Write a function `find_words(board, words)` that returns a list of all the words found on the board. Input Format: * `board` is a list of lists of characters (characters are lowercase English letters). * `words` is a list of strings (each string is a lowercase English word). Output Format: * Returns a list of strings (words found in the board). Constraints: * `1 <= len(board), len(board[0]) <= 12` * `1 <= len(words) <= 3 * 10^4` * `1 <= len(words[i]) <= 10` * All characters in `board` and words are lowercase English letters. Example ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] # Expected output: [\\"oath\\", \\"eat\\"] print(find_words(board, words)) ``` Additional Info: * Implement the Trie data structure as a means to store all the words efficiently. * Use a DFS approach to explore possible paths for forming words in the board. * Ensure that each letter in the board can be used only once per word search.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True def find_words(board, words): def dfs(node, r, c, path, visited): if (r < 0 or r >= len(board) or c < 0 or c >= len(board[0]) or (r, c) in visited or board[r][c] not in node.children): return next_node = node.children[board[r][c]] visited.add((r, c)) path += board[r][c] if next_node.is_end_of_word: found_words.add(path) for row_offset, col_offset in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(next_node, r + row_offset, c + col_offset, path, visited) visited.remove((r, c)) trie = Trie() for word in words: trie.insert(word) found_words = set() for r in range(len(board)): for c in range(len(board[0])): dfs(trie.root, r, c, \\"\\", set()) return list(found_words)"},{"question":"# Question Scenario: You are given the task of implementing a binomial coefficient calculator using recursion. Binomial coefficients are essential in combinatorial calculations, statistical modeling, and various areas of math. The program must efficiently handle larger inputs by applying certain optimizations. Task: Write a function `binomial_coefficient(n, k)` that returns the binomial coefficient C(n, k) using recursion. Your function should include necessary checks for valid inputs and utilize techniques to optimize recursive calculations. Expected Input and Output: - **Input**: Two non-negative integers `n` and `k` such that `n >= k`. - **Output**: Integer representing C(n, k). Constraints: - Ensure that `n >= k`. If not, raise a `ValueError`. - Optimize your function to handle large values of n and k efficiently. - Avoid using built-in combinatorial functions or libraries. Examples: ```python assert binomial_coefficient(5, 0) == 1 assert binomial_coefficient(8, 2) == 28 assert binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 assert binomial_coefficient(8, 5) == binomial_coefficient(8, 3) == 56 ``` Performance Requirements: - Ensure your solution has a time complexity close to O(k) and is efficient in terms of space usage. Happy coding!","solution":"def binomial_coefficient(n, k): Calculate the binomial coefficient C(n, k) using recursion with memoization to optimize performance. if n < 0 or k < 0 or n < k: raise ValueError(\\"Invalid input, n should be >= k and both should be non-negative.\\") memo = {} def helper(n, k): if k == 0 or k == n: return 1 if (n, k) in memo: return memo[(n, k)] # Use the property C(n, k) == C(n-1, k-1) + C(n-1, k) memo[(n, k)] = helper(n - 1, k - 1) + helper(n - 1, k) return memo[(n, k)] return helper(n, k)"},{"question":"# Question You are working on a system that writes data into an EEPROM where each write operation shortens the lifetime of the memory. To optimize the lifespan of the EEPROM, you need a sorting algorithm that minimizes write operations. Implement the function `cycle_sort` which sorts a list of integers in ascending order by placing elements directly into their correct positions. The function should have the signature: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` **Input**: - A list of integers `arr` (0 <= len(arr) <= 10^3). **Output**: - A list of integers sorted in ascending order. **Constraints**: - Do not use built-in sorting functions. - Minimize the number of write operations as much as possible. - Your implementation should work in-place (i.e., do not use additional arrays or other large data structures). **Performance Requirements**: - Time complexity: O(N^2) - Space complexity: O(1) # Example ```python # Example 1 arr = [4, 3, 2, 1] print(cycle_sort(arr)) # Output: [1, 2, 3, 4] # Example 2 arr = [2, 4, 5, 3, 1] print(cycle_sort(arr)) # Output: [1, 2, 3, 4, 5] # Example 3 arr = [1, 1, 1, 1] print(cycle_sort(arr)) # Output: [1, 1, 1, 1] ``` Test your implementation with additional edge cases to ensure its correctness.","solution":"def cycle_sort(arr): Sorts the array using cycle sort to minimize the number of write operations. n = len(arr) writes = 0 for cycle_start in range(n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 if pos != cycle_start: arr[pos], item = item, arr[pos] writes += 1 while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Scenario You are developing a real-time data streaming system and one requirement is to compute the maximum value in a sliding window over the received data points. Your task is to implement this functionality efficiently. Implement a function `max_sliding_window` that takes a list of integers `arr` and a window size `k`, and returns a list of the maximum values in each sliding window of size `k`. Input - `arr`: A list of integers where `1 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. - `k`: An integer where `1 <= k <= len(arr)`. Output - A list of integers representing the maximum values in each sliding window of size `k`. Constraints - The function should operate in O(n) time complexity. - Ensure the solution efficiently uses space. Example ```python arr = [1,3,-1,-3,5,3,6,7] k = 3 # Expected output: [3, 3, 5, 5, 6, 7] ``` Additional Information - Consider edge cases such as window size `k` equals to one or the length of the array. - Consider large inputs and ensure performance is as expected.","solution":"from collections import deque def max_sliding_window(arr, k): This function takes a list of integers and a window size k and returns a list of the maximum values in each sliding window of size k. if not arr or k <= 0: return [] n = len(arr) result = [] deq = deque() for i in range(n): # Remove elements not within the sliding window if deq and deq[0] < i - k + 1: deq.popleft() # Remove elements smaller than the current element from the deque while deq and arr[deq[-1]] < arr[i]: deq.pop() deq.append(i) # If the first element is at least the start of the window offset, add to the results if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"Word Segmentation Problem You are tasked with implementing a function that determines if a given string can be segmented into a sequence of one or more words from a given dictionary. The dictionary is an input list of non-empty words, and you can assume it does not contain duplicates. Your function should follow the dynamic programming approach and should satisfy the following requirements: Function Signature ```python def can_segment_string(s: str, word_dict: List[str]) -> bool: Determines if the input string \'s\' can be segmented into one or more words from the input \'word_dict\'. Parameters: - s (str): The non-empty input string to be segmented. - word_dict (List[str]): List of non-empty words representing the dictionary. Returns: - bool: Returns True if the string can be segmented, otherwise returns False. ``` Input and Output Formats * **Input**: * `s`: A non-empty string (1 <= len(s) <= 300). * `word_dict`: A list of unique, non-empty strings where each string length is between 1 and 20, inclusive. * **Output**: * Return a boolean indicating whether the string `s` can be segmented into a space-separated sequence of one or more dictionary words. Constraints * All characters in the string `s` and the words in `word_dict` are lowercase English letters. * The dictionary will not contain duplicate words. Example 1. Example 1: * Input: `s = \\"leetcode\\"`, `word_dict = [\\"leet\\", \\"code\\"]` * Output: True * Explanation: \\"leetcode\\" can be segmented as \\"leet code\\". 2. Example 2: * Input: `s = \\"applepenapple\\"`, `word_dict = [\\"apple\\", \\"pen\\"]` * Output: True * Explanation: \\"applepenapple\\" can be segmented as \\"apple pen apple\\". 3. Example 3: * Input: `s = \\"catsandog\\"`, `word_dict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]` * Output: False * Explanation: \\"catsandog\\" cannot be segmented into a space-separated sequence of dictionary words. Implementation: Implement the `can_segment_string` function using the described dynamic programming approach.","solution":"from typing import List def can_segment_string(s: str, word_dict: List[str]) -> bool: word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"# Scenario You are working on a networking tool that requires frequent conversion of dotted-decimal IP addresses to their binary representations to manage subnets effectively. Your task is to create utility functions that will take a valid IP address in dotted-decimal notation and produce its 32-bit binary form. # Task Develop a function `decimal_to_binary_ip(ip: str) -> str` which converts an IP address like \\"192.168.0.1\\" into its binary form \\"11000000.10101000.00000000.00000001\\". # Specification 1. **Function Input**: - A string `ip` representing an IP address (e.g., \\"192.168.0.1\\"). 2. **Function Output**: - A string with the IP address in binary form (e.g., \\"11000000.10101000.00000000.00000001\\"). 3. **Constraints**: - Each octet of the IP address must be a decimal number between 0 and 255. - The input string should exactly contain 4 octets separated by dots. 4. **Validation**: - If the input string is not a valid IP address, your function should raise a `ValueError`. # Example ```python decimal_to_binary_ip(\\"192.168.0.1\\") # Output should be: \\"11000000.10101000.00000000.00000001\\" ``` **Note**: 1. You can assume the standard IPv4 format (four 8-bit octets). 2. Use the helper function `decimal_to_binary_util` provided to facilitate the conversion of each octet. Helper Function The helper function converts an 8-bit decimal number to its binary representation, padded to 8 bits. ```python def decimal_to_binary_util(val): # Provided code should be used as is bits = [128, 64, 32, 16, 8, 4, 2, 1] val = int(val) binary_rep = \'\' for bit in bits: if val >= bit: binary_rep += str(1) val -= bit else: binary_rep += str(0) return binary_rep ``` # Detailed Steps 1. Split the input IP address into its four parts. 2. Validate the input IP structure. 3. Convert each octet using the helper function. 4. Join the converted binary strings with dots.","solution":"def decimal_to_binary_util(val): Converts an 8-bit decimal number to its 8-bit binary representation. bits = [128, 64, 32, 16, 8, 4, 2, 1] val = int(val) binary_rep = \'\' for bit in bits: if val >= bit: binary_rep += str(1) val -= bit else: binary_rep += str(0) return binary_rep def decimal_to_binary_ip(ip: str) -> str: Convert a dotted-decimal IP address to its 32-bit binary representation. # Validate the input octets = ip.split(\'.\') if len(octets) != 4: raise ValueError(\\"Invalid IP address format\\") binary_octets = [] for octet in octets: if not octet.isdigit() or not (0 <= int(octet) <= 255): raise ValueError(\\"Invalid IP address format\\") binary_octets.append(decimal_to_binary_util(octet)) return \'.\'.join(binary_octets)"},{"question":"# Graph Traversal Challenge Scenario You are working on a navigation system that must efficiently analyze and process the layout of various cities represented as graphs. Each city (graph) consists of intersections (nodes) connected by streets (edges). Task Implement both depth-first search (DFS) and breadth-first search (BFS) traversal functions for a given graph. The functions should be able to handle both connected and disconnected graphs, including any potential cycles within the graph. Function Specifications 1. **DFS Traversal**: - **Function Name**: `dfs_traverse` - **Input**: - `graph` (dictionary representation of the graph where keys are node labels and values are lists of adjacent nodes). - `start` (starting node for traversal). - **Output**: - List of nodes in the order they were visited. 2. **BFS Traversal**: - **Function Name**: `bfs_traverse` - **Input**: - `graph` (dictionary representation of the graph where keys are node labels and values are lists of adjacent nodes). - `start` (starting node for traversal). - **Output**: - List of nodes in the order they were visited. Constraints - The graph is a dictionary where each key points to a list of its adjacent nodes. - Nodes are represented as integers or strings. - There can be up to 10,000 nodes and 50,000 edges. - The start node is guaranteed to be a key in the graph. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } start_node = \'A\' # Expected output: # For DFS (one possible output): [\'A\', \'C\', \'F\', \'B\', \'E\', \'D\'] # For BFS: [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] def dfs_traverse(graph, start): # Your code here pass def bfs_traverse(graph, start): # Your code here pass ``` Performance Requirements Your solution should efficiently handle both dense and sparse graphs and avoid unnecessary recomputation or redundant data storage.","solution":"def dfs_traverse(graph, start): Perform Depth-First Search traversal on a graph. Parameters: graph (dict): Dictionary representation of the graph. start (str): Starting node for the traversal. Returns: list: List of nodes in the order they were visited. visited = set() traversal = [] def dfs(node): if node not in visited: visited.add(node) traversal.append(node) for neighbor in graph[node]: dfs(neighbor) dfs(start) return traversal def bfs_traverse(graph, start): Perform Breadth-First Search traversal on a graph. Parameters: graph (dict): Dictionary representation of the graph. start (str): Starting node for the traversal. Returns: list: List of nodes in the order they were visited. visited = set() traversal = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) traversal.append(node) queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return traversal"},{"question":"# Matrix Multiplication Given two matrices `A` and `B`, implement a function `matrix_multiply` that returns the product of these two matrices. **Function Signature**: ```python def matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: ``` # Input: * `multiplicand`: A list of lists of integers representing the first matrix `A` of dimensions `m x n`. * `multiplier`: A list of lists of integers representing the second matrix `B` of dimensions `n x p`. # Output: * A list of lists of integers representing the resultant matrix of dimensions `m x p`. # Constraints: * The number of columns in the multiplicand must match the number of rows in the multiplier. * Both multiplicand and multiplier matrices contain integer elements. * The matrices will be non-empty and contain at least one element. * Elements of the matrices could be negative, zero, or positive integers. # Example: ```python # Example 1 multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] assert matrix_multiply(multiplicand, multiplier) == [ [58, 64], [139, 154] ] # Example 2 multiplicand = [ [1, 0], [0, 1] ] multiplier = [ [4, 5], [7, 8] ] assert matrix_multiply(multiplicand, multiplier) == [ [4, 5], [7, 8] ] ``` # Implementation Notes: * Ensure to handle the case where the matrices are not compatible for multiplication by raising an appropriate exception. * The algorithm should be efficient enough to handle reasonably large matrices up to at least 100 x 100.","solution":"from typing import List def matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: Multiplies two matrices (multiplicand and multiplier) and returns the result. m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) if n != len(multiplier): raise ValueError(\\"Number of columns in multiplicand must match number of rows in multiplier.\\") # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Given a set of integers, create a Binary Search Tree (BST) with the following operations: * Insert an element. * Search for an element. * Calculate the size of the tree (number of elements). * Preorder, Inorder, and Postorder traversals of the tree. # Requirements 1. Implement the Binary Search Tree with the following methods: * `insert(data: int) -> bool`: Inserts a data element into the BST and returns `True` if successful and `False` if the element already exists. * `search(data: int) -> bool`: Searches for a data element in the BST and returns `True` if found, `False` otherwise. * `size() -> int`: Returns the number of elements in the BST. * `preorder(root: Node) -> List[int]`: Returns a list of elements of the tree visited in preorder. * `inorder(root: Node) -> List[int]`: Returns a list of elements of the tree visited in inorder. * `postorder(root: Node) -> List[int]`: Returns a list of elements of the tree visited in postorder. # Input * No direct input method is specified; you should interact with the BST via method calls. # Output * Corresponding outputs for the method defined above. # Constraints * All data elements are unique integers. * The tree can have at most `10^4` elements. # Example Usage ``` # Create BST instance bst = BST() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(15) bst.insert(25) # Search print(bst.search(15)) # Output: True print(bst.search(30)) # Output: False # Size print(bst.size()) # Output: 5 # Traversals root = bst.get_root() print(bst.preorder(root)) # Output: [10, 5, 20, 15, 25] print(bst.inorder(root)) # Output: [5, 10, 15, 20, 25] print(bst.postorder(root)) # Output: [5, 15, 25, 20, 10] ``` # Testing Validate your solution with multiple scenarios including: * Inserting elements. * Searching both present and absent elements. * Checking tree size. * Validating traversal orders for correctness.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self.element_count = 0 def insert(self, data): if self.root is None: self.root = Node(data) self.element_count += 1 return True else: return self._insert_rec(self.root, data) def _insert_rec(self, node, data): if data == node.data: return False elif data < node.data: if node.left is None: node.left = Node(data) self.element_count += 1 return True else: return self._insert_rec(node.left, data) else: if node.right is None: node.right = Node(data) self.element_count += 1 return True else: return self._insert_rec(node.right, data) def search(self, data): return self._search_rec(self.root, data) def _search_rec(self, node, data): if node is None: return False elif data == node.data: return True elif data < node.data: return self._search_rec(node.left, data) else: return self._search_rec(node.right, data) def size(self): return self.element_count def preorder(self, node): if node is None: return [] return [node.data] + self.preorder(node.left) + self.preorder(node.right) def inorder(self, node): if node is None: return [] return self.inorder(node.left) + [node.data] + self.inorder(node.right) def postorder(self, node): if node is None: return [] return self.postorder(node.left) + self.postorder(node.right) + [node.data] def get_root(self): return self.root"},{"question":"# Question You are provided with an array of integers that need to be sorted. Your task is to implement the Shell Sort algorithm to sort this array. You are required to use an optimized gap sequence provided below for better performance. **Optimized Gap Sequence**: [121, 40, 13, 4, 1] (These are part of Sedgewick\'s sequence, which is known to perform well in practice). # Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` # Input * An integer array `arr` with length ( n leq 10^5 ) * It can contain positive, negative numbers, and also zeros. # Output * Return the sorted version of the array in ascending order. # Constraints * Each element in the array lies in the range ([-10^9, 10^9]). # Example ```python assert optimized_shell_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert optimized_shell_sort([12, 4, 5, 6, 9, 1, 0, 3, -1, -10]) == [-10, -1, 0, 1, 3, 4, 5, 6, 9, 12] assert optimized_shell_sort([]) == [] assert optimized_shell_sort([1, 1, 1, 1]) == [1, 1, 1, 1] ``` # Requirements * Ensure the algorithm runs efficiently for lists of up to (10^5) elements. * Handle all edge cases and input constraints. **Note**: You are not allowed to use in-built sorting functions.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: n = len(arr) gaps = [121, 40, 13, 4, 1] for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Next Permutation of Digits Context: You\'re helping to design a digital combination lock that can permanently cycle to the next permissible combination. You need to write the code that determines the next valid combination based on the current one. Task: Write a function `next_bigger(num: int) -> int` to find the next higher permutation of digits of an input number. If no such permutation is possible, return -1. Input Format: - A single integer `num` (1 ≤ num ≤ 10^9). Output Format: - A single integer representing the next permutation. If no higher permutation is possible, return -1. Constraints: - Consider only the digits of the given number (0-9). - The input number will be positive, but may include multiple digits. - You cannot return permutations involving digits not in the original number. Examples: - `next_bigger(38276)` should return `38627`. - `next_bigger(12345)` should return `12354`. - `next_bigger(54321)` should return `-1` (no higher permutation possible). Performance Requirements: - The function should run in linear time, O(n), proportional to the number of digits in the input number. Function Signature: ```python def next_bigger(num: int) -> int: pass ``` Ensure to consider edge cases like when `num` is a single digit or when all digits are the same. **Note**: Convert the number to a list of digits for easier manipulation.","solution":"def next_bigger(num: int) -> int: Finds the next permutation of the digits of the given integer num. If no higher permutation is possible, returns -1. num = list(str(num)) n = len(num) # Step 1: Find the rightmost digit that is smaller than the digit next to it i = n - 2 while i >= 0 and num[i] >= num[i + 1]: i -= 1 if i == -1: return -1 # Step 2: Find the smallest digit on right side of (i\'th digit) that is larger than num[i] j = n - 1 while num[j] <= num[i]: j -= 1 # Step 3: Swap the found smallest digit with num[i] num[i], num[j] = num[j], num[i] # Step 4: Reverse the digits after (i+1) to get the next permutation num = num[:i + 1] + num[i + 1:][::-1] return int(\\"\\".join(num))"},{"question":"# Binary Search Tree Validation Background: Binary Search Trees (BST) enforce a crucial ordering property, where for every node ( n ): - All values in the left subtree of ( n ) are less than the value of ( n ). - All values in the right subtree of ( n ) are greater than the value of ( n ). A common operation in many applications is to validate whether a given binary tree complies with the structure of a BST. Task: Write a function `is_valid_bst(node: Optional[Node]) -> bool` that verifies if a given binary tree is a valid Binary Search Tree (BST). The function should return `True` if the tree is a valid BST and `False` otherwise. Requirements: - **Input**: The function takes a single argument, `node`, which represents the root of a binary tree. - **Output**: The function should return a boolean value indicating whether the tree is a valid BST. Constraints: 1. You may assume all values in the tree are unique. 2. The tree can be empty (`None`), and in such a case, it should be considered a valid BST. Example: ```python # Define Nodes manually root = Node(10) root.left = Node(5) root.right = Node(15) root.left.left = Node(2) root.left.right = Node(7) root.right.right = Node(20) # Check if the above tree is a valid BST print(is_valid_bst(root)) # Output: True # Modify the tree to violate BST property root.right.left = Node(12) root.right.right = Node(5) # Check if the modified tree is a valid BST print(is_valid_bst(root)) # Output: False ``` Implementation Notes - Consider edge cases like an empty tree or a tree with a single node. - Ensure your function handles nested levels of the tree correctly. - Minimize additional space usage and avoid excessive recursion depth.","solution":"from typing import Optional class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None def is_valid_bst(node: Optional[Node], left_bound: Optional[int] = None, right_bound: Optional[int] = None) -> bool: if not node: return True if left_bound is not None and node.value <= left_bound: return False if right_bound is not None and node.value >= right_bound: return False return is_valid_bst(node.left, left_bound, node.value) and is_valid_bst(node.right, node.value, right_bound)"},{"question":"Context You are part of a software development team that needs to manage tasks in a sequential order. You are required to implement a queue data structure using either an array or a linked list based on the requirements of different applications. Problem Statement Implement a Circular Queue using an array, which overcomes the limitations of the dynamic array used in the provided `ArrayQueue` implementation. The Circular Queue should efficiently handle enqueue and dequeue operations without needing to expand the array frequently. Function Signatures Implement the following methods in the `CircularQueue` class: * `__init__(self, capacity)`: Initializes the queue with a given capacity. * `enqueue(self, value)`: Adds `value` to the rear of the queue. * `dequeue(self)`: Removes and returns the front element of the queue. * `peek(self)`: Returns the front element without removing it. * `is_empty(self)`: Returns `True` if the queue is empty, `False` otherwise. * `is_full(self)`: Returns `True` if the queue is full, `False` otherwise. * `size(self)`: Returns the number of elements in the queue. Constraints * Ensure that enqueue and dequeue operations should be O(1). * Handle edge cases like attempting to dequeue from an empty queue or enqueue to a full queue by raising appropriate exceptions. * The initial capacity of the queue will be a positive integer less than or equal to 1000. Example Usage ```python cq = CircularQueue(5) cq.enqueue(10) cq.enqueue(20) cq.enqueue(30) print(cq.dequeue()) # Output: 10 print(cq.peek()) # Output: 20 print(cq.size()) # Output: 2 print(cq.is_empty()) # Output: False print(cq.is_full()) # Output: False cq.enqueue(40) cq.enqueue(50) cq.enqueue(60) # This should raise an exception as the queue is full. ``` Additional Notes * Document your code rigorously, noting assumptions and edge-case handling. * Ensure your implementation is efficient and adheres to the specified constraints.","solution":"class CircularQueue: def __init__(self, capacity): Initializes the queue with a given capacity. :param capacity: The maximum number of elements the queue can hold. self.capacity = capacity self.queue = [None] * capacity self.front = -1 self.rear = -1 self.count = 0 def enqueue(self, value): Adds value to the rear of the queue. :param value: The value to add to the queue. :raises: Exception if the queue is full. if self.is_full(): raise Exception(\\"Queue is full\\") if self.is_empty(): self.front = 0 self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.count += 1 def dequeue(self): Removes and returns the front element of the queue. :returns: The element removed from the front of the queue. :raises: Exception if the queue is empty. if self.is_empty(): raise Exception(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 if self.count == 0: self.front = -1 self.rear = -1 return value def peek(self): Returns the front element without removing it. :returns: The front element of the queue. :raises: Exception if the queue is empty. if self.is_empty(): raise Exception(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): Returns True if the queue is empty, False otherwise. :returns: A boolean indicating if the queue is empty. return self.count == 0 def is_full(self): Returns True if the queue is full, False otherwise. :returns: A boolean indicating if the queue is full. return self.count == self.capacity def size(self): Returns the number of elements in the queue. :returns: The number of elements in the queue. return self.count"},{"question":"# Binary Search Implementation to Find Closest Element Context You are given a sorted array of integers. Your task is to write a function that takes this sorted array and a target integer as input and returns the index of the element in the array that is closest to the target. If there are multiple closest elements, return the smallest index among them. Function Signature ```python def find_closest_element(array: List[int], target: int) -> int: Find the index of the element closest to the target in the sorted array Parameters: array : List[int] => List of integers (sorted in ascending order) target : int => Target integer to find the closest element Returns: int => Index of the closest element to the target ``` Input * A sorted list of integers in ascending order `array` (1 <= len(array) <= 10^4, -10^6 <= array[i] <= 10^6). * An integer `target`. Output * Return an integer which is the index of the element that is closest to the target. Constraints * You should solve this problem with a time complexity of O(log n). Example ```python assert find_closest_element([1, 2, 5, 8, 12], 6) == 2 # Closest to 6 is 5, index 2 assert find_closest_element([1, 3, 8, 10, 15], 12) == 3 # Closest to 12 is 10 assert find_closest_element([1], 0) == 0 # Closest to 0 is 1, index 0 ``` Guidelines 1. Perform a binary search to identify the potential range where the closest element could be located. 2. Compare the target against the values in the potential range to determine the closest element. 3. Ensure proper handling of edge cases, such as when the array is empty or when the target is outside the bounds of the array values.","solution":"from typing import List def find_closest_element(array: List[int], target: int) -> int: left, right = 0, len(array) - 1 closest_index = -1 min_diff = float(\'inf\') while left <= right: mid = (left + right) // 2 diff = abs(array[mid] - target) if diff < min_diff: min_diff = diff closest_index = mid elif diff == min_diff: # If the difference is the same, take the smaller index closest_index = min(closest_index, mid) if array[mid] < target: left = mid + 1 else: right = mid - 1 return closest_index"},{"question":"**Scenario:** You are working on a data processing pipeline where you need to filter duplicate entries in a way that each entry only appears up to a specified number of times. This is crucial for ensuring data quality for downstream analytics tasks. **Task:** Write a function `delete_nth(array, n)` that takes an input list `array` and a non-negative integer `n`, and returns a new list where each element in the input list appears at most `n` times, while retaining the original order of elements. **Function Signature:** `def delete_nth(array: list, n: int) -> list:` **Input:** * `array` (list of integers): The input list of integers that may contain duplicates. * `n` (int): The maximum number of times an element can appear in the output list. **Output:** * (list of integers): A list where each element in the input array appears at most `n` times. **Constraints:** * The length of `array` is between 0 and 10^5. * The elements in `array` are integers in the range -10^9 to 10^9. * `n` is a non-negative integer. **Example:** ```python array = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 # Output: [1, 2, 3, 1, 2, 3] array = [1, 1, 1, 1] n = 2 # Output: [1, 1] array = [20, 37, 20, 21] n = 1 # Output: [20, 37, 21] ``` **Hint:** Consider using a dictionary to keep track of how many times each element has appeared.","solution":"def delete_nth(array: list, n: int) -> list: Returns a list where each element in the input array appears at most n times. Parameters: array (list): The input list of integers. n (int): The maximum number of times an element can appear in the output list. Returns: list: A list where each element in the input array appears at most n times. result = [] counts = {} for item in array: if counts.get(item, 0) < n: result.append(item) counts[item] = counts.get(item, 0) + 1 return result"},{"question":"# Question: Count the Number of Digits in an Integer Objective You are required to implement a function that counts the number of digits in a given integer. This function should work efficiently for both positive and negative numbers, as well as for zero. Input and Output Formats * **Input**: A single integer `n` (-10^9 < n < 10^9) * **Output**: An integer representing the number of digits in the input number. Function Signature ```python def num_digits(n: int) -> int: ``` Constraints 1. The input number, `n`, can be negative. 2. The input number, `n`, will not exceed the range `-10^9 < n < 10^9`. 3. The function should run in O(1) time complexity. Example 1. Input: `12345` Output: `5` 2. Input: `-12345` Output: `5` 3. Input: `0` Output: `1` Notes * You need to handle the edge case when the number is `0`. * You should convert negative numbers to positive before performing the operation. Implement your function in the space provided below: ```python import math def num_digits(n: int) -> int: n = abs(n) if n == 0: return 1 return int(math.log10(n)) + 1 # Example usage: # print(num_digits(12345)) # Output: 5 # print(num_digits(-12345)) # Output: 5 # print(num_digits(0)) # Output: 1 ```","solution":"def num_digits(n: int) -> int: Returns the number of digits in the given integer n. Handles both positive and negative numbers, as well as zero. n = abs(n) if n == 0: return 1 return len(str(n))"},{"question":"# Problem Description You are working for a toy company that produces toys in three distinct colors represented by integers 0, 1, and 2. The company needs a system to sort these toys efficiently so that toys of the same color are grouped together in the order red (0), white (1), and blue (2). Write a function `sort_colors(nums)` that sorts an array of integers where each integer is either 0, 1, or 2. The function should modify the array in place, without using any library sort function, to arrange the integers in the sequence of 0s, then 1s, and finally 2s. # Function Signature ```python def sort_colors(nums: List[int]) -> None: pass ``` # Input * `nums`: A list of integers where each integer is either 0, 1, or 2. The size of the list can be up to 1000. # Output The function should sort the list in place and return nothing (`None`). # Constraints * You should not use any library\'s sort function. * Aim for a time complexity of O(n) and space complexity of O(1). # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output should be [0, 0, 1, 1, 2, 2] nums = [2, 0, 1] sort_colors(nums) print(nums) # Output should be [0, 1, 2] nums = [0] sort_colors(nums) print(nums) # Output should be [0] nums = [1, 2, 0] sort_colors(nums) print(nums) # Output should be [0, 1, 2] ``` # Notes 1. Consider edge cases such as an empty array, an array with only one element, and arrays that are already sorted. 2. The implementation should handle arrays of varying lengths up to the given constraint efficiently.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts an array of integers where each integer is either 0, 1, or 2 in place so that all 0s come first, followed by all 1s, and then all 2s. :param nums: List of integers containing only 0, 1, and 2 low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"# Pythagorean Theorem Solver Objective You are required to implement a function that computes the length of the unknown side of a right-angled triangle. The function takes three arguments, corresponding to the sides: `opposite`, `adjacent`, and `hypotenuse`. One of these sides will be the unknown side, denoted by the string `?`. Core Requirements - Implement a function `find_missing_side(opposite, adjacent, hypotenuse)` that calculates and returns the length of the missing side. - Each argument will be either a positive float indicating the length of the side or a string \\"?\\" indicating the unknown side which you need to compute. - Ensure proper handling of invalid inputs and raise appropriate errors. Input - `opposite`: A float or a string \\"?\\". - `adjacent`: A float or a string \\"?\\". - `hypotenuse`: A float or a string \\"?\\". Output - A string in the format \\"UnknownSide = value\\" where `UnknownSide` is either \\"Opposite\\", \\"Adjacent\\", or \\"Hypotenuse\\". Constraints - Only one of the sides will be passed as \\"?\\". - Valid inputs guarantee that with two of the sides provided, the Pythagorean theorem holds true. # Examples 1. Given `opposite = 3`, `adjacent = \\"?\\"`, `hypotenuse = 5`: - Output: `\\"Adjacent = 4.0\\"` 2. Given `opposite = \\"?\\"`, `adjacent = 4`, `hypotenuse = 5`: - Output: `\\"Opposite = 3.0\\"` 3. Given `opposite = 3`, `adjacent = 4`, `hypotenuse = \\"?\\"`: - Output: `\\"Hypotenuse = 5.0\\"` # Function Signature ```python def find_missing_side(opposite, adjacent, hypotenuse): # Your code here ```","solution":"import math def find_missing_side(opposite, adjacent, hypotenuse): Calculates and returns the length of the missing side of a right-angled triangle. Parameters: opposite (float or str): Length of the opposite side or \\"?\\". adjacent (float or str): Length of the adjacent side or \\"?\\". hypotenuse (float or str): Length of the hypotenuse or \\"?\\". Returns: str: A string in the format \\"UnknownSide = value\\" if opposite == \\"?\\": adjacent = float(adjacent) hypotenuse = float(hypotenuse) opposite_value = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite_value}\\" elif adjacent == \\"?\\": opposite = float(opposite) hypotenuse = float(hypotenuse) adjacent_value = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent_value}\\" elif hypotenuse == \\"?\\": opposite = float(opposite) adjacent = float(adjacent) hypotenuse_value = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse_value}\\" else: raise ValueError(\\"One side should be marked as \'?\' to find the missing side.\\")"},{"question":"**Scenario**: You are a software engineer at a company that handles hierarchical data stored in binary trees. Your team requires a function to verify if one tree is a subtree of another. This is essential for validating data integrity and structure consistency within your datasets. **Problem Statement**: Implement a function `is_subtree(big, small)` that takes in two binary trees `big` and `small`, and returns `True` if `small` is a subtree of `big`, otherwise returns `False`. # Input: * `big` - A binary tree node representing the root of the larger tree. * `small` - A binary tree node representing the root of the smaller tree. # Output: * A boolean `True` or `False` indicating whether `small` is a subtree of `big`. # Constraints: 1. The `TreeNode` structure is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` 2. Both `big` and `small` are binary trees with values that can be assumed to be integers. 3. The function should handle edge cases gracefully, such as either tree being `None`. 4. Ideally, optimize the function for cases where `big` is significantly larger than `small`. # Implementation Requirements: 1. Your function should use breadth-first search (BFS) to find potential subtree roots. 2. A helper function should compare potential subtrees for exact structure and value match. 3. Consider performance implications and optimize where feasible. ```python def is_subtree(big: TreeNode, small: TreeNode) -> bool: # Implement the function as per the provided specification pass ``` # Example: ```python # Example 1 big = TreeNode(3) big.left = TreeNode(4) big.right = TreeNode(5) big.left.left = TreeNode(1) big.left.right = TreeNode(2) small = TreeNode(4) small.left = TreeNode(1) small.right = TreeNode(2) assert is_subtree(big, small) == True # Example 2 big.left.right.left = TreeNode(0) small = TreeNode(3) small.left = TreeNode(4) small.right = TreeNode(5) small.left.left = TreeNode(1) small.left.right = TreeNode(2) assert is_subtree(big, small) == False ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(big: TreeNode, small: TreeNode) -> bool: def are_identical(root1: TreeNode, root2: TreeNode) -> bool: if not root1 and not root2: return True if not root1 or not root2: return False return (root1.val == root2.val and are_identical(root1.left, root2.left) and are_identical(root1.right, root2.right)) if not small: return True if not big: return False if are_identical(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small)"},{"question":"# RLE Compression and Decompression Scenario Run-Length Encoding (RLE) is a simple form of lossless data compression in which runs of data (that is, sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count. Implement the RLE algorithm to compress and decompress a given string effectively. Task You need to create a function `compress_and_expand` that can both compress and decompress input data based on a command. ```python def compress_and_expand(command: str, data: str) -> str: Compresses or expands the input data based on the given command. :param command: A string that is either \'compress\' or \'expand\' :param data: The input data string to compress or expand :return: The resulting compressed or expanded string # Your implementation here ``` Specifications 1. **Command**: The function will receive a `command` which is a string, either `\\"compress\\"` or `\\"expand\\"`. 2. **Data**: The second parameter, `data`, will be the input string: * For `\\"compress\\"`, it is the original string that should be compressed. * For `\\"expand\\"`, it is the RLE-encoded string that needs to be decompressed. 3. **Output**: * For the `\\"compress\\"` command, return the RLE-compressed string. * For the `\\"expand\\"` command, return the decompressed original string. 4. **Constraints**: * Input strings will only contain alphanumeric characters (a-z, A-Z, 0-9). * The function should handle edge cases such as empty strings. Examples ```python compress_and_expand(\\"compress\\", \\"AAABBBCCDAA\\") # Output: \\"3A3B2C1D2A\\" compress_and_expand(\\"compress\\", \\"AABBCCDDEE\\") # Output: \\"2A2B2C2D2E\\" compress_and_expand(\\"expand\\", \\"3A3B2C1D2A\\") # Output: \\"AAABBBCCDAA\\" compress_and_expand(\\"expand\\", \\"2A2B2C2D2E\\") # Output: \\"AABBCCDDEE\\" compress_and_expand(\\"compress\\", \\"\\") # Output: \\"\\" compress_and_expand(\\"expand\\", \\"\\") # Output: \\"\\" ``` Note * Ensure that the function is optimized and handles various edge cases.","solution":"def compress_and_expand(command: str, data: str) -> str: Compresses or expands the input data based on the given command. :param command: A string that is either \'compress\' or \'expand\' :param data: The input data string to compress or expand :return: The resulting compressed or expanded string if command == \\"compress\\": if not data: return \\"\\" compressed = [] count = 1 current_char = data[0] for char in data[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{count}{current_char}\\") current_char = char count = 1 compressed.append(f\\"{count}{current_char}\\") return \\"\\".join(compressed) elif command == \\"expand\\": if not data: return \\"\\" expanded = [] count = \\"\\" for char in data: if char.isdigit(): count += char else: expanded.append(char * int(count)) count = \\"\\" return \\"\\".join(expanded) else: raise ValueError(\\"Invalid command. Use \'compress\' or \'expand\' only.\\")"},{"question":"You are provided with an unsorted list of integers. Your task is to implement a function that returns the histogram representation of the input list, where the histogram is defined as a dictionary with keys as the unique elements of the list and values as their respective frequencies. # Function Signature ```python def get_histogram(input_list: list) -> dict: Computes the histogram representation of an input list. :param input_list: List of integers (may include duplicates) :return: Dictionary representing histogram (element: frequency) ``` # Input * A list of integers, `input_list` (0 <= len(input_list) <= 1000) * Each integer, `n`, in the list will be in the range of -10^6 to 10^6. # Output * A dictionary (histogram) with each unique integer from the list as keys and their counts as values. # Constraints * The input list can be empty, in which case the function should return an empty dictionary. * The integers in the input list could be any valid integer values. # Examples ```python # Example 1 input_list = [3, 3, 2, 1] expected_output = {1: 1, 2: 1, 3: 2} assert get_histogram(input_list) == expected_output # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] expected_output = {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} assert get_histogram(input_list) == expected_output # Example 3 input_list = [] expected_output = {} assert get_histogram(input_list) == expected_output ``` # Notes * Ensure your code handles edge cases properly, such as empty lists and lists with repeated values. * Aim for an optimal and readable solution.","solution":"def get_histogram(input_list: list) -> dict: Computes the histogram representation of an input list. :param input_list: List of integers (may include duplicates) :return: Dictionary representing histogram (element: frequency) histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"# Question: Designing a Predictive Text Model with Markov Chains Given a corpus of text, your task is to build a predictive text model using a Markov Chain. Implement a function that predicts the next word given a current word based on a Markov Chain derived from the corpus. Input - A string `corpus`: The text used to train the Markov Chain. Assume it is a large corpus comprising several sentences. - An integer `n`: The number of predictions to generate. - A string `starting_word`: The initial word from which predictions will begin. Output - A list of strings representing the sequence of predicted words, including the `starting_word` and `n` predicted words. Constraints 1. You may assume that every word in the `corpus` is separated by a single whitespace. 2. Words should be treated case-insensitively (i.e., \\"The\\" and \\"the\\" should be considered the same). 3. If a word has no outgoing transitions, the prediction should end there. Example ```python corpus = \\"The cat sat on the mat. The cat saw the rat. The rat ran.\\" predictive_text(corpus, 4, \\"the\\") ``` Expected Output ```python [\\"the\\", \\"cat\\", \\"sat\\", \\"on\\", \\"the\\"] ``` *Note: The exact output might vary due to the probabilistic nature of the prediction.* Function Signature ```python def predictive_text(corpus: str, n: int, starting_word: str) -> List[str]: pass ``` Notes 1. This task will evaluate your understanding of Markov Chains, probability distributions, and generating sequences based on a trained model.","solution":"import random from collections import defaultdict from typing import List def build_markov_chain(corpus: str): words = corpus.lower().split() markov_chain = defaultdict(list) for i in range(len(words) - 1): markov_chain[words[i]].append(words[i + 1]) return markov_chain def predictive_text(corpus: str, n: int, starting_word: str) -> List[str]: markov_chain = build_markov_chain(corpus) current_word = starting_word.lower() result = [starting_word] for _ in range(n): if current_word in markov_chain and markov_chain[current_word]: next_word = random.choice(markov_chain[current_word]) result.append(next_word) current_word = next_word else: break return result"},{"question":"# Decode Ways - Dynamic Programming Challenge Given an encoded message containing digits from \'0\' to \'9\', implement a function to determine the total number of ways to decode it. The mapping is defined as follows: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` **Input**: * A string `encoded_message` consisting of only digits. **Output**: * An integer representing the total number of ways to decode the given encoded message. **Constraints**: * The input string will always be non-empty and will not contain invalid characters. * Consecutive \'0\'s not forming a valid two-digit number should be handled. * Consider performance implications for long strings. # Function Signature ```python def decode_ways(encoded_message: str) -> int: pass ``` # Examples 1. **Example 1**: ```python decode_ways(\\"12\\") # Output: 2 ``` Explanation: It could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. **Example 2**: ```python decode_ways(\\"226\\") # Output: 3 ``` Explanation: It could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). 3. **Example 3**: ```python decode_ways(\\"0\\") # Output: 0 ``` Explanation: \\"0\\" cannot be decoded. 4. **Example 4**: ```python decode_ways(\\"06\\") # Output: 0 ``` Explanation: \\"06\\" is invalid since it starts with an invalid zero. # Hints: 1. Use dynamic programming to store the number of ways to decode up to each character. 2. Ensure handling of edge cases like strings with leading zeros and non-decodable subsections.","solution":"def decode_ways(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): single_digit = int(encoded_message[i-1:i]) double_digit = int(encoded_message[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i - 1] if 10 <= double_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Binary Tree Postorder Traversal Coding Challenge **Context**: In various scenarios, such as expression evaluation and memory deallocation tasks, it is essential to traverse a binary tree in postorder. This traversal visits each node\'s left subtree, right subtree, and then the node itself. Your task is to implement a function that performs a postorder traversal on a binary tree. **Problem Description**: You are given the definition of a binary tree node and a binary tree structure. Implement the `postorder` function, which returns a list of node values in postorder. **Function Signature**: ```python def postorder(root: Node) -> List[int]: ``` **Input**: * `root`: The root node of the binary tree (or None if the tree is empty). **Output**: * A list of integers representing the postorder traversal of the tree. **Constraints**: * The tree may have up to 10^4 nodes. * The node values are integers. **Example**: ```python # Example Binary Tree: # 1 # / # 2 3 # / # 4 5 # Given the binary tree above, a call to postorder(root) should return: # Output: [4, 5, 2, 3, 1] class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Creating the tree root = Node(1) root.left = Node(2, Node(4), Node(5)) root.right = Node(3) print(postorder(root)) # Output: [4, 5, 2, 3, 1] ``` **Note**: * Edge cases like empty trees or trees with a single node should be handled. * Optimize your implementation to handle large trees efficiently.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def postorder(root: Optional[Node]) -> List[int]: Perform postorder traversal on a binary tree and return the list of values. result = [] def traverse(node: Optional[Node]): if node is None: return traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"You are given a framework for a directed graph. Using this framework, your task is to implement a function that can detect cycles within the graph. This is a fundamental question in understanding graph theory and data structures related to graphs. # Function Signature ```python def detect_cycle(graph: DirectedGraph) -> bool: Determines if there is a cycle in the provided directed graph. Parameters: graph (DirectedGraph): The directed graph to be analyzed. Returns: bool: True if the graph contains a cycle, False otherwise. ``` # Input - A `DirectedGraph` object has been instantiated from the given class code. - The graph object could be sparse or dense, small or large, with varying topologies. # Output - Return `True` if there is a cycle detected in the graph. - Return `False` otherwise. # Constraints - The graph can have up to 10,000 nodes and 25,000 edges. - Each node name is a non-empty string. - Consider the graph to be directed and edges can form cycles. # Example Given a directed graph as follows: ``` { \'a\': [\'b\', \'c\'], \'b\': [\'d\'], \'c\': [\'d\'], \'d\': [\'a\'] # introduces a cycle } ``` The graph has a cycle because the path `a -> b -> d -> a` forms a loop. Therefore, the function should return `True`. # Notes 1. Use Depth First Search (DFS) or Kahn\'s Algorithm for detecting cycles in the directed graph. 2. Think about the edge cases where the graph might be disconnected (i.e., multiple subgraphs), and ensure that cycles within any subgraph are detected. 3. Consider the time and space complexity of your solution, and ensure it is optimized for the constraint limits provided.","solution":"class DirectedGraph: def __init__(self): self.adj_list = {} def add_edge(self, src, dest): if src not in self.adj_list: self.adj_list[src] = [] self.adj_list[src].append(dest) def detect_cycle(graph: DirectedGraph) -> bool: Determines if there is a cycle in the provided directed graph. Parameters: graph (DirectedGraph): The directed graph to be analyzed. Returns: bool: True if the graph contains a cycle, False otherwise. visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in graph.adj_list.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in graph.adj_list: if dfs(node): return True return False"},{"question":"**Fundamentals: Bitwise Manipulation** **Context**: You are working on developing utility functions for a low-level firmware in an embedded system. Manipulating individual bits efficiently and correctly is crucial for controlling hardware flags and settings. As such, you are tasked to demonstrate thorough understanding and implementation of fundamental bitwise manipulation functions. **Problem**: Implement four fundamental bitwise functions in Python. Given an integer `num`, perform the following operations: 1. **get_bit(num, i)**: Return `True` if the bit at position `i` is set (1), otherwise return `False`. 2. **set_bit(num, i)**: Set the bit at position `i` in `num` to 1 and return the new `num`. 3. **clear_bit(num, i)**: Clear the bit at position `i`, setting it to 0, and return the new `num`. 4. **update_bit(num, i, bit)**: Update the bit at position `i` to the value of `bit` (0 or 1) and return the new `num`. **Input/Output Formats**: * Input: * `num` : an integer (within the 32-bit signed integer range, from -2^31 to 2^31-1) * `i`: an integer (0 ≤ `i` < 32) * `bit` (for `update_bit` function): an integer (either 0 or 1) * Output: * For `get_bit`: Boolean value (`True` or `False`) * For `set_bit`, `clear_bit`, `update_bit`: Modified integer `num` with the specified bit operation performed. **Constraints**: * Smaller or invalid index values for `i` should be considered as out of scope. * Assume inputs are valid and are within specified bounds. ```python def get_bit(num, i): # Implementation here pass def set_bit(num, i): # Implementation here pass def clear_bit(num, i): # Implementation here pass def update_bit(num, i, bit): # Implementation here pass # Example Usage: # num = 10 (binary: 1010) # get_bit(num, 1) should return True # set_bit(num, 0) should return 11 (binary: 1011) # clear_bit(num, 3) should return 2 (binary: 0010) # update_bit(num, 1, 0) should return 8 (binary: 1000) ``` **Performance Note**: Your implementations should be efficient, optimized for O(1) time complexity.","solution":"def get_bit(num, i): Returns True if the bit at index i is set to 1, otherwise False. return (num & (1 << i)) != 0 def set_bit(num, i): Sets the bit at index i to 1 and returns the new number. return num | (1 << i) def clear_bit(num, i): Clears the bit at index i (sets to 0) and returns the new number. return num & ~(1 << i) def update_bit(num, i, bit): Updates the bit at index i to the value of bit and returns the new number. mask = ~(1 << i) num_cleared = num & mask return num_cleared | (bit << i)"},{"question":"You are given a `m x n` matrix where each row and each column is sorted in ascending order. Your task is to write a function `searchMatrix(matrix, key)` that searches for a given integer `key` in the matrix. If the key exists, return the list `[row_index, col_index]` where the key is found. Otherwise, return `[-1, -1]`. Assume there is exactly one key or no key in the matrix. Input - `matrix`: A 2D list of integers representing the matrix. - `key`: An integer representing the key to search for. Output - A list `[row_index, col_index]` representing the location (1-based indices) of the key in the matrix, or `[-1, -1]` if the key is not found. Constraints - `1 <= m, n <= 1000` - `-10^9 <= matrix[i][j], key <= 10^9` Example ```python # Example input matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 # Expected output [2, 3] ``` # Function Signature ```python def searchMatrix(matrix, key): # Your code here ``` # Additional Requirements - Your solution should have a time complexity of O(m + n). - Each list index should be converted to 1-based in the return statement. - Handle edge cases such as an empty matrix or the key being outside the possible range of matrix values.","solution":"def searchMatrix(matrix, key): Searches for the key in the sorted matrix and returns its position as [row_index, col_index] in 1-based indices. If the key is not found, returns [-1, -1]. if not matrix or not matrix[0]: return [-1, -1] m, n = len(matrix), len(matrix[0]) row, col = 0, n - 1 while row < m and col >= 0: if matrix[row][col] == key: return [row + 1, col + 1] elif matrix[row][col] > key: col -= 1 else: row += 1 return [-1, -1]"},{"question":"You are part of a software development team working on an auto-complete feature. The goal is to help users by suggesting words based on the longest common prefix of previously entered words. Write a function `find_longest_common_prefix` that takes a list of strings as input and returns the longest common prefix from those strings. If there is no common prefix, the function should return an empty string. # Function Signature ```python def find_longest_common_prefix(strs: List[str]) -> str: # Your code here ``` # Input - `strs`: A list of strings `[s1, s2, ..., sn]` where `0 ≤ n ≤ 200`, and `0 ≤ len(si) ≤ 200` for each string `si`. # Output - A single string representing the longest common prefix. # Constraints - All strings consist of only lowercase English letters (a-z). # Examples ```python # Example 1: print(find_longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"])) # Expected Output: \\"fl\\" # Example 2: print(find_longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"])) # Expected Output: \\"\\" # Example 3: print(find_longest_common_prefix([\\"abracadabra\\", \\"abracadaver\\", \\"abracana\\"])) # Expected Output: \\"abraca\\" ``` # Considerations - Think about edge cases, such as an array of one string, all strings being identical, or having no common prefix at all. - Aim to implement a solution with efficient time and space complexity suitable for the given input constraints.","solution":"from typing import List def find_longest_common_prefix(strs: List[str]) -> str: Finds the longest common prefix among a list of strings. If no common prefix exists, returns an empty string. if not strs: return \\"\\" # Start with the first word as the minimum possible common prefix prefix = strs[0] # Iterate through all strings in the list for string in strs[1:]: while string[:len(prefix)] != prefix and prefix: # Decrease the prefix by the last character until there\'s a match prefix = prefix[:-1] return prefix"},{"question":"Recursive Generation of Strobogrammatic Numbers Problem Statement: Strobogrammatic numbers are numbers that look the same when rotated 180 degrees. For this task, you need to write a function `gen_strobogrammatic(n)` that generates all strobogrammatic numbers of a given length `n`. Input * `n` (integer): Length of the numbers to generate, where 0 ≤ n ≤ 14. Output * A list of strings where each string represents a strobogrammatic number of length `n`. Constraints * The output list should only contain unique strobogrammatic numbers. * Numbers should not have leading zeros except if the number is `0`. * The numbers in the list should be all possible strobogrammatic numbers, but the order does not matter. Example ```python gen_strobogrammatic(2) # Example Output: [\'88\', \'11\', \'69\', \'96\'] gen_strobogrammatic(3) # Example Output: [\'818\', \'101\', \'609\', \'906\', \'808\', ...] ``` Task Implement the function `gen_strobogrammatic(n)` based on the recursive generation principles provided. # Additional Requirements Your implementation should: 1. Use a recursive helper function to generate the strobogrammatic numbers. 2. Ensure it handles all edge cases effectively. 3. Avoid performance bottlenecks where possible but the primary focus is correctness. Good luck, and think carefully about each step of the recursive generation process!","solution":"def gen_strobogrammatic(n): Generates all strobogrammatic numbers of length n. def helper(m, n): if m == 0: return [\\"\\"] if m == 1: return [\\"0\\", \\"1\\", \\"8\\"] prev = helper(m - 2, n) result = [] for number in prev: if m != n: result.append(\\"0\\" + number + \\"0\\") result.append(\\"1\\" + number + \\"1\\") result.append(\\"6\\" + number + \\"9\\") result.append(\\"8\\" + number + \\"8\\") result.append(\\"9\\" + number + \\"6\\") return result return helper(n, n)"},{"question":"# Special Sum of Digits Evaluation Given an integer range, write a function that returns a list of numbers within the range [low, high] (inclusive) where each number equals the sum of its digits raised to the power of their positional order. For example, 89 is valid because 8^1 + 9^2 equals 89. Another example is 135 as 1^1 + 3^2 + 5^3 equals 135. # Function Signature ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` # Input * `low`: an integer (1 ≤ low ≤ 1,000,000). * `high`: an integer (low ≤ high ≤ 1,000,000). # Output * A list of integers that meet the special sum of digits property in increasing order. # Constraints * Ranges and low/high values will always be valid integers. * The function should efficiently handle ranges up to the maximum constraints. # Example Test Cases ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] assert sum_dig_pow(10, 88) == [] ``` # Notes Consider optimizing the function to handle larger ranges within reasonable time constraints.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: def is_special(n: int) -> bool: digits = list(map(int, str(n))) return n == sum(digit ** (index + 1) for index, digit in enumerate(digits)) result = [] for number in range(low, high + 1): if is_special(number): result.append(number) return result"},{"question":"**Problem Statement: Unique Pair Finder** You are given an array of integers `nums`, where exactly two elements appear only once, and all the other elements appear exactly twice. Your task is to find the two elements that appear only once. You need to implement an efficient algorithm with a time complexity of O(N) and space complexity of O(1). # Input - A list of integers `nums` where 2 ≤ len(nums) ≤ 3 * 10^4 and each element is an integer in the range [-3 * 10^4, 3 * 10^4]. # Output - A list containing the two unique elements. The order of the result does not matter. # Constraints - The input array will always contain exactly two elements that appear only once, and all other elements will appear exactly twice. # Example ```python Input: [1, 2, 1, 3, 2, 5] Output: [3, 5] ``` # Function Signature ```python def find_unique_pair(nums: List[int]) -> List[int]: pass ``` **Notes**: 1. The solution should efficiently identify the two unique numbers using bitwise operations. 2. Consider edge cases where the array is at its minimal limit. 3. The order of the output list does not affect the correctness.","solution":"from typing import List def find_unique_pair(nums: List[int]) -> List[int]: # Step 1: XOR all elements. The result will be the XOR of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find a set bit in the result (We\'ll use the rightmost set bit) rightmost_set_bit = xor_all & -xor_all num1 = 0 num2 = 0 # Step 3: Separate all numbers into two groups based on the set bit found in step 2 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Nearest Neighbor Classification Challenge You are given a set of labeled points representing a training set and a function that computes the Euclidean distance between two points. Your task is to implement a function that classifies a new point by finding the label of its nearest neighbor in the training set. To accomplish this, follow these steps: 1. Calculate the Euclidean distance between the new point and each point in the training set. 2. Identify the point in the training set that is the closest to the new point. 3. Return the label of the nearest point. **Function Signature**: ```python def classify_point(query_point, training_set): # Your code here ``` # Input Format: * `query_point`: A tuple of numbers representing the coordinates of the query point. * `training_set`: A dictionary where keys are tuples representing coordinates of training points and values are the labels for those points. # Output Format: * Returns the label associated with the nearest point in the training set. # Constraints: * The training set dictionary is non-empty. * All points (keys in the dictionary and the query point) have the same number of dimensions. # Example: ```python query_point = (1.5, 2.5) training_set = { (1, 2): \'A\', (3, 3): \'B\', (5, 5): \'C\' } # Expected output: \'A\' because the point (1, 2) is the closest to (1.5, 2.5) assert classify_point(query_point, training_set) == \'A\' ``` **Note**: - Use the provided `distance` function to calculate Euclidean distances. - Ensure your code has appropriate error handling for edge cases. Good luck!","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points. return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def classify_point(query_point, training_set): Classifies a new point by finding the label of its nearest neighbor in the training set. Parameters: - query_point: tuple of numbers representing the coordinates of the query point. - training_set: dictionary where keys are tuples representing coordinates of training points and values are the labels for those points. Returns: - Label of the nearest point in the training set. nearest_label = None nearest_distance = float(\'inf\') for point, label in training_set.items(): distance = euclidean_distance(query_point, point) if distance < nearest_distance: nearest_distance = distance nearest_label = label return nearest_label"},{"question":"You are working on optimizing the resource allocation for a delivery service. Given a truck with a fixed weight capacity and a list of items, each with a specified weight and value, your task is to maximize the total value of items that can be loaded into the truck. # Function Specification Implement the function `get_maximum_value(items: List[Item], capacity: int) -> int` to find the maximum total value that fits within the given capacity. # Input - `items`: a list of `Item` objects, where each object has two attributes: - `value` (int): the value of the item. - `weight` (int): the weight of the item. - `capacity` (int): the total weight capacity of the truck. # Output - `int`: The maximum value of the items that can be fit into the truck. # Constraints - All item weights and values are non-negative integers. - 1 ≤ len(items) ≤ 1000 - 1 ≤ capacity ≤ 10000 - If no items can be fit within the capacity, return 0. # Example ```python capacity = 5 items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] assert get_maximum_value(items, capacity) == 80 # Items valued 50 and 30 can both be fit in the knapsack. ``` # Edge Cases to Consider * When `capacity` is 0, the function should return 0. * When `items` list is empty, the function should return 0. # Guidelines - Ensure your solution efficiently handles the provided constraints. - Test for edge cases to validate your implementation. - Avoid using additional unnecessary space to keep the optimal space complexity.","solution":"from typing import List class Item: def __init__(self, value: int, weight: int): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: Returns the maximum value that can be packed into a truck with given capacity using the items provided. n = len(items) dp = [0] * (capacity + 1) for i in range(n): for w in range(capacity, items[i].weight - 1, -1): dp[w] = max(dp[w], dp[w - items[i].weight] + items[i].value) return dp[capacity]"},{"question":"# Scenario We\'re given a binary tree, and your task is to implement a function that returns the inorder traversal of its nodes\' values using an iterative approach. # Question Implement the function `custom_inorder` that visits each node in a binary tree using iterative inorder traversal and returns the values in a list. # Input / Output Format - **Input**: The input to the function will be the root node of a binary tree. - **Output**: The function should return a list of node values in inorder. # Constraints - The binary tree can contain at most 10^4 nodes. - Each node\'s value will be an integer. # Function Signature ```python def custom_inorder(root: \'Node\') -> List[int]: pass ``` # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree # 1 # # 2 # / # 3 root = Node(1) root.right = Node(2) root.right.left = Node(3) assert custom_inorder(root) == [1, 3, 2] ``` # Notes - Ensure to handle edge cases such as an empty tree. - Focus on devising an efficient solution as the input size can be large.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def custom_inorder(root: Optional[Node]) -> List[int]: Returns the inorder traversal of a binary tree\'s nodes\' values using iterative approach. stack = [] current = root inorder_list = [] while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() inorder_list.append(current.val) current = current.right return inorder_list"},{"question":"# Task You are asked to implement Run-Length Encoding (RLE) and decoding functions from scratch based on the provided description. # Problem Statement Create two functions: 1. `encode_rle(input: str) -> str`: that takes a string as input and returns its RLE encoded version. 2. `decode_rle(input: str) -> str`: that takes an RLE encoded string as input and returns the original uncompressed version. # Detailed Specifications - **encode_rle(input: str) -> str** * **Input**: * A single string `input` (1 ≤ len(input) ≤ 10^5): the input string may contain lowercase letters only. * **Output**: * A single encoded string representing the RLE compression of the input. - **decode_rle(input: str) -> str** * **Input**: * A single string `input` (1 ≤ len(input) ≤ 10^5): the encoded string is a valid RLE encoded format. * **Output**: * A single decoded string representing the original uncompressed data. # Constraints Your solution should efficiently handle input strings of length up to 100,000 characters. # Examples Example 1 - **encode_rle(\'aaaabbbcc\')** should return **\'4a3b2c\'**. - **decode_rle(\'4a3b2c\')** should return **\'aaaabbbcc\'**. Example 2 - **encode_rle(\'aabbcc\')** should return **\'2a2b2c\'**. - **decode_rle(\'2a2b2c\')** should return **\'aabbcc\'**. Example 3 - **encode_rle(\'a\')** should return **\'1a\'**. - **decode_rle(\'1a\')** should return **\'a\'**. # Notes * It’s essential that your implementation handles edge cases such as empty strings and strings without any repeated characters effectively. * Ensure your solution is optimized for both time and space complexity.","solution":"def encode_rle(input: str) -> str: Encode a string using Run-Length Encoding (RLE). Parameters: input (str): The input string to be encoded. Returns: str: The RLE encoded string. if not input: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(input)): if input[i] == input[i-1]: count += 1 else: encoded_str.append(f\\"{count}{input[i-1]}\\") count = 1 # Append the last character and count encoded_str.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded_str) def decode_rle(input: str) -> str: Decode a Run-Length Encoded (RLE) string. Parameters: input (str): The RLE encoded string to be decoded. Returns: str: The decoded string. if not input: return \\"\\" decoded_str = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) # handle multi-digit counts else: decoded_str.append(char * count) count = 0 return \'\'.join(decoded_str)"},{"question":"Problem Statement You are given two strings, `haystack` and `needle`. Your task is to implement a function `find_needle(haystack: str, needle: str) -> int` that returns the index of the first occurrence of `needle` in `haystack`, or returns -1 if `needle` is not part of `haystack`. # Input: * `haystack`: A non-empty string (1 ≤ len(haystack) ≤ 10^4). * `needle`: A string which may be empty (0 ≤ len(needle) ≤ 10^4). # Output: * An integer representing the index of the first occurrence of `needle` in `haystack` if it is a substring, otherwise -1. # Constraints: * You should handle edge cases like empty `needle` and the scenario where `needle` is longer than `haystack`. * If `needle` is an empty string, return 0. # Performance Requirements: * Aim for an optimized solution if possible, but ensure correctness first. # Examples: 1. Input: `haystack = \\"hello\\"`, `needle = \\"ll\\"` Output: `2` 2. Input: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` Output: `-1` 3. Input: `haystack = \\"abcdef\\"`, `needle = \\"\\"` Output: `0` # Additional Context: Imagine this problem is a part of a larger text-search system where efficiency and correctness are both critical. It might be used to implement the \\"find\\" feature in a text editor or a web search function. Implementation Notes: * Consider the impact of the problem scale. For large `haystack` and `needle`, naive implementations might not be efficient. * Look for opportunities to optimize your algorithm without sacrificing readability or correctness.","solution":"def find_needle(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not a part of haystack. if needle == \\"\\": return 0 return haystack.find(needle)"},{"question":"# Scenario You are tasked with implementing a more advanced stack data structure that not only follows the traditional Last-In-First-Out (LIFO) principle but also maintains its elements in sorted order. This specialized stack should efficiently manage ordered insertions and allow standard stack operations. # Task Implement the `OrderedStack` class such that it adheres to the following requirements: 1. **Initialization**: The stack starts empty. 2. **Push Operation**: When an element is pushed onto the stack, it should be placed in such a way that the stack remains sorted in ascending order. 3. **Pop Operation**: Removes and returns the top element of the stack. 4. **Peek Operation**: Returns the top element of the stack without removing it. 5. **Size Operation**: Returns the number of elements in the stack. 6. **Empty Check**: Returns whether the stack is empty. # Constraints - The space complexity should not exceed O(n), where n is the total number of elements pushed onto the stack. - The time complexity for the `push` operation should be optimized as much as possible. - Operations `pop`, `peek`, `size`, and `is_empty` should be constant time, O(1). # Input and Output Formats - `OrderedStack`: Initialize with no parameters. - `push(item)`: Push an integer `item` onto the stack. - `pop()`: Returns and removes the topmost element. Raises an exception if the stack is empty. - `peek()`: Returns the topmost element without removing it. Raises an exception if the stack is empty. - `size()`: Returns the number of elements in the stack. - `is_empty()`: Returns `True` if the stack is empty, otherwise `False`. # Function Signature ```python class OrderedStack: def __init__(self): pass def push(self, item): pass def pop(self): pass def peek(self): pass def size(self): pass def is_empty(self): pass ``` # Example Usage ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) stack.push(5) stack.push(4) assert stack.pop() == 5 # Pops the highest element assert stack.size() == 4 assert stack.pop() == 4 # Pops the next highest element assert stack.peek() == 3 # Peeks at the current top element assert not stack.is_empty() # Checks if the stack is not empty assert stack.size() == 3 ```","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): index = 0 while index < len(self.stack) and self.stack[index] < item: index += 1 self.stack.insert(index, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): return len(self.stack) def is_empty(self): return len(self.stack) == 0"},{"question":"You have been tasked with designing a method to encode a list of strings into a single string such that it can be easily transmitted over a network and then decoded back into the original list of strings. This task simulates a common problem in data transmission and storage where you need to serialize and deserialize structures. **Encoding Method**: - Given a list of strings, concatenate each string with its length, followed by a delimiter `\\":\\"`, and the string itself. - Example: For the list `[\\"hello\\", \\"world\\"]`, the encoded string should be `\\"5:hello5:world\\"`. **Decoding Method**: - Given an encoded string, parse it to reconstruct the original list of strings by reading each length and its associated string. - Example: For the encoded string `\\"5:hello5:world\\"`, the decoded list should be `[\\"hello\\", \\"world\\"]`. # Instructions: 1. Implement two functions, `encode` and `decode`: - `encode(strs: List[str]) -> str`: Encodes a list of strings to a single string. - `decode(s: str) -> List[str]`: Decodes a single string to a list of strings. 2. Ensure that your solution handles all edge cases including empty lists and special characters within the strings. 3. Optimize your solution for efficiency in time and space complexity. ```python def encode(strs): Encodes a list of strings to a single string. Parameters: strs (List[str]): List of strings to be encoded. Returns: str: Encoded string. # Write your code here def decode(s): Decodes a single string to a list of strings. Parameters: s (str): Encoded string. Returns: List[str]: Decoded list of strings. # Write your code here ``` # Constraints: - The length of each string in the input list will be in the range `[0, 10^3]`. - The length of the encoded string will not exceed `10^6`. Feel free to add helper functions if needed.","solution":"def encode(strs): Encodes a list of strings to a single string. Parameters: strs (List[str]): List of strings to be encoded. Returns: str: Encoded string. encoded_string = \'\' for string in strs: encoded_string += f\'{len(string)}:{string}\' return encoded_string def decode(s): Decodes a single string to a list of strings. Parameters: s (str): Encoded string. Returns: List[str]: Decoded list of strings. decoded_list = [] i = 0 while i < len(s): # locate the delimiter to find the end of the length prefix delimiter_index = s.find(\':\', i) # retrieve the length of the substring length = int(s[i:delimiter_index]) # extract the substring starting right after the delimiter start = delimiter_index + 1 decoded_list.append(s[start:start + length]) # move the pointer to the next part of the string i = start + length return decoded_list"},{"question":"# Question: You are tasked with writing a function that filters elements from an array based on minimum and maximum values. Your function should handle edge cases and adhere to the specified constraints. Function Signature: ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` Input: * `arr` (List[int]): A list of integers to be filtered. * `min_lim` (Optional[int]): An integer representing the minimum limit. If `None`, do not apply a minimum limit. * `max_lim` (Optional[int]): An integer representing the maximum limit. If `None`, do not apply a maximum limit. Output: * (List[int]): A list of integers that are greater than or equal to `min_lim` and less than or equal to `max_lim`. Constraints: * The input array can be empty. * If both `min_lim` and `max_lim` are `None`, return the original array. * You may assume all array elements are integers. Examples: ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([10, 20, 30, 40], 15, 35) == [20, 30] assert limit([], 1, 10) == [] assert limit([7, 8, 5, 3, 2], None, None) == [7, 8, 5, 3, 2] assert limit([100, 200, 300], 150, None) == [200, 300] ``` Explanation: 1. `limit([1, 2, 3, 4, 5], None, 3)` should return `[1, 2, 3]` because only the elements <= 3 are included. 2. `limit([10, 20, 30, 40], 15, 35)` should return `[20, 30]` because the elements are between 15 and 35. 3. `limit([], 1, 10)` should return `[]` as the input array is empty. 4. `limit([7, 8, 5, 3, 2], None, None)` should return `[7, 8, 5, 3, 2]` as no limits are applied. 5. `limit([100, 200, 300], 150, None)` should return `[200, 300]` as the elements are >= 150.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters elements from an array based on minimum and maximum values. if min_lim is None and max_lim is None: return arr if min_lim is not None and max_lim is not None: return [x for x in arr if min_lim <= x <= max_lim] elif min_lim is not None: return [x for x in arr if x >= min_lim] elif max_lim is not None: return [x for x in arr if x <= max_lim] # Examples to test assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([10, 20, 30, 40], 15, 35) == [20, 30] assert limit([], 1, 10) == [] assert limit([7, 8, 5, 3, 2], None, None) == [7, 8, 5, 3, 2] assert limit([100, 200, 300], 150, None) == [200, 300]"},{"question":"# Question: Implement Base Conversion Functions Context You are tasked with writing two functions to convert integers between base 10 and any other base (between 2 and 36), and vice versa. This conversion is crucial in many areas of computing, such as data encoding, digital communication, and efficient data representation. Requirements Implement the following two functions: 1. **Function**: `int_to_base(num, base)` - Converts a base 10 integer to a specified base. - **Inputs**: - `num` (int): The integer to convert. It may be negative. - `base` (int): The base to convert to, ranging from 2 to 36. - **Output**: - A string representing the number in the specified base. - **Example**: ```python int_to_base(47, 16) # Should return \'2F\' int_to_base(-15, 2) # Should return \'-1111\' ``` 2. **Function**: `base_to_int(str_to_convert, base)` - Converts a string representation of a number in a specified base to a base 10 integer. - **Inputs**: - `str_to_convert` (str): The string representation of the number in the given base. It may represent a negative number. - `base` (int): The base of the given number, ranging from 2 to 36. - **Output**: - An integer in base 10. - **Example**: ```python base_to_int(\'2F\', 16) # Should return 47 base_to_int(\'-1111\', 2) # Should return -15 ``` Constraints - You should not use Python\'s built-in `int` function for conversion in `base_to_int`. - Only characters from `0-9` and `A-Z` should be used for bases above 10. - You may assume the input strings are valid representations for the given base. Performance Requirements - Aim for efficient implementation with minimal time and space overhead. Edge Cases - Consider the cases where the input number is zero. - Handle the conversion of negative numbers appropriately. - Be cautious of invalid base values.","solution":"def int_to_base(num, base): Converts a base 10 integer to a specified base. Args: num (int): The integer to convert. It may be negative. base (int): The base to convert to, ranging from 2 to 36. Returns: str: A string representing the number in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \\"0\\" alphabets = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num > 0: result.append(alphabets[num % base]) num //= base if is_negative: result.append(\\"-\\") result.reverse() return \'\'.join(result) def base_to_int(str_to_convert, base): Converts a string representation of a number in a specified base to a base 10 integer. Args: str_to_convert (str): The string representation of the number in the given base. base (int): The base of the given number, ranging from 2 to 36. Returns: int: An integer in base 10. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") alphabets = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" num_map = {alphabets[i]: i for i in range(base)} is_negative = str_to_convert[0] == \\"-\\" if is_negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: if char not in num_map: raise ValueError(f\\"Character {char} is not valid for base {base}\\") num = num * base + num_map[char] if is_negative: num = -num return num"},{"question":"**Objective**: Write a function to compute large exponentiations efficiently using binary exponentiation, ensuring both iterative and recursive approaches. # Problem Statement Implement two functions to perform exponentiation: 1. `iterative_pow` for iterative binary exponentiation. 2. `recursive_pow` for recursive binary exponentiation. Both functions should: - Compute the power `a^n`. - If a third argument `mod` is provided, compute the result modulo `mod`. # Function Signature ```python def iterative_pow(a: int, n: int, mod: int = None) -> int: # Implementation here def recursive_pow(a: int, n: int, mod: int = None) -> int: # Implementation here ``` # Input 1. `a`: Integer base (0 <= a <= 10^9) 2. `n`: Integer exponent (0 <= n <= 10^9) 3. `mod`: (Optional) Integer modulus (1 <= mod <= 10^9) # Output - Return the result of `a^n`, or `(a^n) % mod` if the modulus is provided. # Constraints - Ensure your solution handles large values efficiently. - The result must be computed using binary exponentiation to achieve a time complexity of O(log(n)). - Care must be taken to handle large intermediate values to avoid overflow. # Example ```python assert iterative_pow(3, 5) == 243 assert iterative_pow(2, 10, 1000) == 24 assert iterative_pow(10, 0) == 1 assert recursive_pow(3, 5) == 243 assert recursive_pow(2, 10, 1000) == 24 assert recursive_pow(10, 0) == 1 ``` # Note: - You can assume the input values are within the given ranges and constraints. - Consider edge cases such as the base being 0 or the exponent being 0.","solution":"def iterative_pow(a: int, n: int, mod: int = None) -> int: Compute a^n iteratively using binary exponentiation. If mod is provided, compute (a^n) % mod. result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: # If n is odd result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 # Divide n by 2 return result def recursive_pow(a: int, n: int, mod: int = None) -> int: Compute a^n recursively using binary exponentiation. If mod is provided, compute (a^n) % mod. if n == 0: return 1 if n % 2 == 1: # If n is odd if mod is None: return a * recursive_pow(a, n - 1, mod) else: return (a * recursive_pow(a, n - 1, mod)) % mod else: # If n is even half_pow = recursive_pow(a, n // 2, mod) if mod is None: return half_pow * half_pow else: return (half_pow * half_pow) % mod"},{"question":"# Question Title: Efficient Pair Sum Finder # Description: You are tasked with implementing a function that finds a pair of indices in an array such that their corresponding values add up to a specific target. Your solution must be efficient in terms of both time and space complexity. # Problem Statement: Write a function `find_pair_indices(array, target)` that takes an array of integers `array` and an integer `target`, and returns a tuple (i, j) of the indices of the two elements whose sum is equal to `target`. Each input will have exactly one solution, and you may not use the same element twice. # Input: - `array`: A list of integers. - `target`: An integer representing the target sum. # Output: - A tuple `(i, j)` where `i` and `j` are the indices of the two elements in the array that sum to the target. # Constraints: - The input list will have at least two integers. - The input list will always have exactly one solution. - You may not use the same array element twice. # Example: ```python array = [2, 7, 11, 15] target = 9 # Because array[0] + array[1] = 2 + 7 = 9 # You should return (0, 1) array = [3, 2, 4] target = 6 # Because array[1] + array[2] = 2 + 4 = 6 # You should return (1, 2) ``` # Function Signature: ```python def find_pair_indices(array, target): pass ``` # Assumptions: - Any valid solution (in terms of indices order) is acceptable, if there are multiple valid pairs (though the problem guarantees exactly one solution). # Notes: - The problem ensures that there is exactly one solution. - Ensure your solution is optimized for time complexity.","solution":"def find_pair_indices(array, target): Finds a pair of indices in an array such that their corresponding values add up to a specific target. Parameters: array (list of int): The list of integers to search. target (int): The target sum. Returns: tuple of int: A tuple (i, j) of indices whose values sum up to the target. value_to_index = {} for i, num in enumerate(array): complement = target - num if complement in value_to_index: return (value_to_index[complement], i) value_to_index[num] = i return None # The problem guarantees there is exactly one solution, so this line should never be reached."},{"question":"You are given an array of integers sorted in ascending order and a target sum. Your task is to write a function that returns the indices of the two numbers in the array that add up to the target sum. The returned indices should be 1-based (not 0-based). It is guaranteed that each input will have exactly one solution. # Requirements: 1. Implement three different functions `binary_search_two_sum`, `hash_table_two_sum`, and `two_pointer_two_sum` using the following algorithms: - `binary_search_two_sum`: Solve the problem using a binary search approach. - `hash_table_two_sum`: Solve the problem using a hash table/dictionary. - `two_pointer_two_sum`: Solve the problem using a two-pointer technique. # Input Format: - An array of integers `numbers` sorted in ascending order. - An integer `target`. # Output Format: - A list of two integers representing the 1-based indices of the two numbers that add up to the target sum. # Constraints: - The length of the given array is at least 2 and at most 10^5. - The array elements can be any integers (both negative and positive). - Each input will have exactly one solution. # Example: ```python numbers = [2, 7, 11, 15] target = 9 ``` - Output: `[1, 2]` (since `numbers[0] + numbers[1] = 2 + 7 = 9`) # Note: - You may not use the same element twice in the sum. - Your submitted solution should include the implementations for all three functions.","solution":"def binary_search_two_sum(numbers, target): Solves the two sum problem using a binary search approach. def binary_search(left, right, value): while left <= right: mid = (left + right) // 2 if numbers[mid] == value: return mid elif numbers[mid] < value: left = mid + 1 else: right = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(i + 1, len(numbers) - 1, complement) if j != -1: return [i + 1, j + 1] def hash_table_two_sum(numbers, target): Solves the two sum problem using a hash table approach. num_dict = {} for i, num in enumerate(numbers): complement = target - num if complement in num_dict: return [num_dict[complement] + 1, i + 1] num_dict[num] = i def two_pointer_two_sum(numbers, target): Solves the two sum problem using a two-pointer technique. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1"},{"question":"# Question: Implement Advanced Operations on a Min Heap Given a Min Heap implementation as shown in the provided class `BinaryHeap`, extend the functionality to include two new operations: `heapify` and `replace_min`. 1. **heapify**: This function will take an unsorted array and convert it into a min heap. 2. **replace_min**: This function will replace the minimum element (root) with a new value and ensure the heap property is maintained. Function Signatures: * `heapify(self, arr: List[int]) -> None` * `replace_min(self, new_value: int) -> int` Input and Output: 1. `heapify`: * **Input**: An unsorted list `arr` of integers. * **Output**: No output. The method should modify the heap in place to reflect the min heap structure. 2. `replace_min`: * **Input**: An integer `new_value`. * **Output**: The old minimum value that was replaced by `new_value`. Integrate these operations into the `BinaryHeap` class. # Constraints: - Ensure that all heap properties are preserved after the operations. - Aim for time complexity `O(N)` for `heapify` and `O(log N)` for `replace_min`. Here\'s the start of the implementation framework to complete: ```python class BinaryHeap(AbstractHeap): # Existing methods ... def heapify(self, arr): # Insert code here def replace_min(self, new_value): # Insert code here ``` # Example: ```python heap = BinaryHeap() # Using heapify arr = [9, 4, 7, 1, -2, 6, 5] heap.heapify(arr) print(heap.heap) # Output should reflect the min heap structure # Using replace_min old_min = heap.replace_min(3) print(old_min) # Should print the old minimum value print(heap.heap) # Output should reflect the new heap structure with 3 replacing the old minimum ```","solution":"class BinaryHeap: def __init__(self): self.heap = [] def insert(self, k): self.heap.append(k) self._heapify_up(len(self.heap) - 1) def extract_min(self): if len(self.heap) == 0: return None root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def heapify(self, arr): self.heap = arr n = len(self.heap) for i in range(n // 2 - 1, -1, -1): self._heapify_down(i) def replace_min(self, new_value): if len(self.heap) == 0: return None old_min = self.heap[0] self.heap[0] = new_value self._heapify_down(0) return old_min"},{"question":"# Longest Common Prefix Implementation Context Your task is to implement a function that computes the longest common prefix (LCP) among an array of strings. This is a common problem in text processing applications and is useful for autocomplete systems, search engines, and other string matching problems. Problem Statement Write a function `longest_common_prefix` that takes in an array of strings `strs` and returns the longest common prefix string amongst those strings. If no common prefix exists, return an empty string \\"\\". Input - An array of strings `strs` of length `N` where `0 <= N <= 10^5`. - Each string consists of lowercase English letters and has a length of at most `100`. Output - A single string representing the longest common prefix. Constraints - You must ensure the solution operates efficiently within the given constraints. - Consider edge cases such as empty arrays, arrays with only one string, or no common prefix among the strings. Performance Requirements - Aim for a time complexity of O(S) where S is the sum of all characters in all strings. Example **Example 1:** ```python Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" ``` **Example 2:** ```python Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" Explanation: There is no common prefix among the input strings. ``` Additional Notes - Be mindful of edge cases such as empty arrays or arrays that contain empty strings. - Try to avoid redundant or unnecessary computations to keep your code efficient. Implement the function below: ```python def longest_common_prefix(strs): # Your code here ```","solution":"def longest_common_prefix(strs): Returns the longest common prefix string amongst the array of strings. If there is no common prefix, returns an empty string \\"\\". if not strs: return \\"\\" # Find the minimum-length string in strs min_len = min(len(s) for s in strs) # Starting with the first string (taking the prefix of that length) prefix = strs[0][:min_len] for i in range(min_len): char = prefix[i] for string in strs: if string[i] != char: return prefix[:i] return prefix"},{"question":"# Context: Given a sorted array of integers in increasing order, you are asked to find the index of the last occurrence of a specific number using an efficient search algorithm. This problem tests your understanding of binary search and edge case handling. # Task: Write a function `last_occurrence(array, query)` that performs a binary search to find the index of the last occurrence of `query` in `array`. # Input: * `array` (List[int]): A list of integers sorted in increasing order. * `query` (int): The integer whose last occurrence index needs to be determined. # Output: * Return the integer index of the last occurrence of `query` in `array`. If the `query` is not present in `array`, return -1. # Constraints: * Elements in `array` are within integer range. * The length of `array` will not exceed 10^6 elements. * Handling edge cases such as empty arrays and arrays with a single element. **Performance Requirements**: * Your solution should have a time complexity of O(log n). # Example: ```python print(last_occurrence([1, 2, 2, 2, 3, 4, 5], 2)) # Output: 3 print(last_occurrence([1, 2, 3, 4, 5, 6, 7], 4)) # Output: 3 print(last_occurrence([1, 1, 2, 3, 3, 3, 3], 3)) # Output: 6 print(last_occurrence([1, 1, 1, 1, 1, 1, 1], 1)) # Output: 6 print(last_occurrence([], 1)) # Output: -1 print(last_occurrence([1], 1)) # Output: 0 print(last_occurrence([1, 2, 3], 4)) # Output: -1 ``` # Requirements: * Implement the `last_occurrence` function and ensure it handles all specified edge cases. * Use binary search to achieve optimal time complexity. * Test your function with different input scenarios to ensure correctness.","solution":"def last_occurrence(array, query): Returns the index of the last occurrence of query in the sorted array. If query is not in the array, returns -1. low = 0 high = len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid low = mid + 1 elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"Two Sum Algorithm Given an array of integers, your task is to write a Python function to return indices of the two numbers such that they add up to a specific target. You must assume that each input has exactly one solution, and you may not use the same element twice. # Function Signature ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: # Your code here ``` # Input - An array of integers `array` of length `n` where (2 ≤ n ≤ 10^4). - An integer `target`. # Output - A tuple of two integers representing the indices of the two numbers that add up to the target. # Constraints - Each input has exactly one solution. - You may not use the same element twice. - The function should run in `O(n)` time complexity. # Example ```python # Example 1 array = [2, 7, 11, 15] target = 9 assert two_sum(array, target) == (0, 1) # Example 2 array = [3, 2, 4] target = 6 assert two_sum(array, target) == (1, 2) ``` # Hints - Utilize a dictionary to track the indices of visited elements. - Think about what you need to store in the dictionary and how to decide when you\'ve found a valid pair.","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers such that they add up to the target. num_to_index = {} for i, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None # This line should never be reached if the input guarantees exactly one solution."},{"question":"You are given two singly linked lists that intersect at some node. Write a function `find_intersection(head1, head2)` to identify the node at which these two linked lists intersect. The node of intersection itself (rather than its value) is the key identifier. If the lists do not intersect, return `None`. **Input**: * `head1`, `head2`: Head nodes of two singly linked lists. **Output**: * The node where the two linked lists intersect, or `None` if no intersection exists. **Constraints**: 1. The lists are non-cyclic. 2. Intersection is determined by node identity, not node value. # Example: ```python # Given Linked Lists: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d1 = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e1 = Node(9) f1 = Node(11) a1.next = b1 b1.next = c1 c1.next = d1 a2.next = b2 b2.next = c2 c2.next = d1 d1.next = e1 e1.next = f1 assert find_intersection(a1, a2).val == 7 # Returns the node with value `7` since that is where the intersection starts. ``` # Function Signature: ```python def find_intersection(head1: Node, head2: Node) -> Optional[Node]: # Your code here ``` # Implementation Requirements: 1. Ensure that your solution is optimized for both time and space complexity. 2. Handle edgy and boundary cases effectively. 3. The function should return the intersecting node, or `None` if no intersection exists.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def get_length(head): length = 0 while head: length += 1 head = head.next return length def find_intersection(head1, head2): len1 = get_length(head1) len2 = get_length(head2) # Align both lists to the same starting point in terms of length while len1 > len2: head1 = head1.next len1 -= 1 while len2 > len1: head2 = head2.next len2 -= 1 # Traverse both lists together to find the intersection point while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"# Question: Find the nth Digit in Concatenated Natural Numbers You are given an integer `n` representing the position of a digit in the infinite sequence of concatenated natural numbers (e.g., 123456789101112...). Write a function `find_nth_digit(n)` that returns the nth digit of this sequence. Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` # Example: ```python find_nth_digit(3) # returns 3, since the sequence starts with 123... find_nth_digit(11) # returns 0, since the sequence reads 1234567891011... find_nth_digit(15) # returns 2, with sequence being 123456789101112... ``` # Constraints: - `1 <= n <= 10^9` (ensuring the function can handle large numbers within a reasonable time frame) # Detailed Requirements: 1. The function should efficiently compute which digit at position `n` in the concatenated sequence of natural numbers. 2. Must handle transitions between number lengths (e.g., from single digits to double digits). 3. Ensure accurate calculations, specifically for large values of `n`. **Notes**: 1. Assume the function will be tested with a large set of numbers. Pay close attention to ensure that the solution is optimized and performs well within reasonable limits. 2. Consider integer division and modulus operations to extract digits accurately.","solution":"def find_nth_digit(n): # Length of digits we are currently considering (Starting with 1 digit numbers) length = 1 count = 9 start = 1 # Find the range block where the nth digit lies while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number within the block num = start + (n - 1) // length # Find the specific digit within that number return int(str(num)[(n - 1) % length])"},{"question":"Design a function that checks if a robot returns to its starting position after a series of moves. The robot starts at coordinate (0, 0) and can move in four directions: \'U\' (Up), \'D\' (Down), \'L\' (Left), and \'R\' (Right). Requirements * Write a function `has_robot_returned_to_origin(moves: str) -> bool` that takes a string of moves and returns a boolean indicating whether the robot returns to the starting point. * The function should consider an empty string as valid input and return `true`. * The function should be efficient with a time complexity of O(n) and a space complexity of O(1). Constraints * The moves string will consist solely of characters \'U\', \'D\', \'L\', and \'R\'. * The moves string can range in length from 0 to 10,000. Function Signature ```python def has_robot_returned_to_origin(moves: str) -> bool: # Implement the function here pass ``` Example ```python assert has_robot_returned_to_origin(\\"UD\\") == True assert has_robot_returned_to_origin(\\"LL\\") == False assert has_robot_returned_to_origin(\\"\\") == True assert has_robot_returned_to_origin(\\"URDL\\") == True ``` Additional Context The problem simulates a simple navigational algorithm where the robot makes a sequence of moves on a 2D grid. The goal is to determine if the movements counteract each other such that the robot ends up at the original position after completing all the moves.","solution":"def has_robot_returned_to_origin(moves: str) -> bool: Checks if a robot returns to its starting position after a series of moves. Parameters: moves (str): A string of moves consisting of characters \'U\', \'D\', \'L\', and \'R\'. Returns: bool: True if the robot returns to the starting point, False otherwise. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Problem Context Consider a singly linked list where each node contains a single character. # Task Implement a function that finds the k-th to last element in such a linked list. Your function should use an optimal approach both in terms of time and space complexities. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: pass ``` # Input - `head`: The head node of the singly linked list. It is guaranteed to contain at least one node. - `k`: An integer representing the 1-based index from the end of the linked list. # Output - A node representing the k-th to last element in the linked list. If k is larger than the actual length of the list, raise an `IndexError`. # Constraints - The linked list will have a maximum length of `1000`. - The k value will always be a non-negative integer. # Example ```python # Define nodes a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") # Link nodes a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Testing the function result = kth_to_last(a1, 4) assert result.val == \\"D\\", \\"Error in the function output\\" ``` # Performance Expectations Your solution should run efficiently with a linear time complexity O(n) and use constant space O(1).","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: Finds the k-th to last element in a singly linked list. :param head: The head node of the singly linked list. :param k: An integer representing the 1-based index from the end of the list. :return: Node representing the k-th to last element. :raises IndexError: If k is larger than the length of the list. # Step 1: Find the length of the linked list length = 0 current = head while current: length += 1 current = current.next # Step 2: Check if k is within the length of the list if k > length: raise IndexError(\\"k is larger than the length of the linked list\\") # Step 3: Find the (length - k)th node from the start (0-based index) target_index = length - k current = head for _ in range(target_index): current = current.next return current"},{"question":"# Question: You are given a string and a set of words (i.e., a dictionary). Your task is to count how many different sentences can be formed from the given string, such that each word in the sentence is contained in the dictionary. Write a function `count_sentences` that takes two parameters: 1. `string` (a non-empty string). 2. `dictionary` (a set of non-empty words). The function should return an integer representing the number of possible sentences that can be formed. # Input: * `string` - A non-empty string consisting of lowercase alphabetical characters (1 <= len(string) <= 100). * `dictionary` - A set of non-empty words where each word consists of lowercase alphabetical characters. # Output: * An integer representing the number of sentences that can be formed from splitting the string into dictionary words. # Constraints: * Each character in the string and each word in the dictionary is a lowercase letter. * The length of the string and the number of words in the dictionary can be reasonably small but should be taken into consideration for efficiency. # Example: Example 1: ```python string = \\"appletablet\\" dictionary = {\\"apple\\", \\"tablet\\", \\"tables\\", \\"applet\\", \\"app\\", \\"table\\", \\"t\\", \\"able\\"} count_sentences(string, dictionary) ``` **Output:** 4 Example 2: ```python string = \\"thing\\" dictionary = {\\"thing\\"} count_sentences(string, dictionary) ``` **Output:** 1 # Explanation: In the first example, the possible sentences are: 1. \\"apple\\" + \\"tablet\\" 2. \\"applet\\" + \\"able\\" + \\"t\\" 3. \\"apple\\" + \\"table\\" + \\"t\\" 4. \\"app\\" + \\"let\\" + \\"able\\" + \\"t\\" In the second example, the only valid segmentation is \\"thing\\". # Note: - You must handle cases where segmenting the string into valid dictionary words isn’t possible. - Consider edge cases like empty strings or dictionaries, and very small or very large strings. Your implementation should aim for efficiency, especially in handling potential redundant computations.","solution":"def count_sentences(string, dictionary): Counts the number of possible sentences that can be formed by splitting the string into words from the dictionary. Parameters: string (str): The input string to be split. dictionary (set): A set of valid words. Returns: int: The number of possible sentences. n = len(string) memo = [0] * (n + 1) memo[0] = 1 for i in range(1, n + 1): for j in range(i): if string[j:i] in dictionary: memo[i] += memo[j] return memo[n]"},{"question":"# Question: Implement a Medial Selection Sort **Background**: You are tasked with implementing a modified version of the Selection Sort algorithm that places elements in a way such that the middle part of the array is sorted and balances the smaller and larger halves. # Problem Statement: Write a function `medial_selection_sort(arr: list) -> list:` that incrementally places the median element in its correct position in the array, distributing elements around it. The initial median is the middle element when considering the array as zero-indexed. # Implementation Details: * **Input**: * `arr` (List[int]) - A list of integers to be sorted. * The list can be empty or contain one or more elements. * **Output**: * A list of integers with the middle element in its correct sorted position and elements distributed on either side. # Constraints: * You must achieve it using a version of the Selection Sort algorithm. * Your implementation should handle edge cases such as empty arrays or single-element arrays. * The running time should remain O(n^2). # Example: ```python def medial_selection_sort(arr: list) -> list: # Your code here # Given the list [10, 2, 7, 4, 3] # Example Output: [2, 3, 4, 10, 7] medial_selection_sort([10, 2, 7, 4, 3]) ``` # Hints: * Identify the middle element\'s index and work your selection sort around ensuring the central element is correctly placed. * Ensure your implementation maintains the properties of selection sort but modified to meet the medial requirement.","solution":"def medial_selection_sort(arr: list) -> list: n = len(arr) if n == 0: return arr mid = n // 2 for i in range(mid + 1): # only iterate until the middle min_idx = i # find the minimum element\'s index in the unsorted portion for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum with the first unsorted element arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"# Question You are given a list of distinct integers `nums`. Your task is to write a function `generate_subsets(nums)` that returns a set of tuples, where each tuple represents a unique subset of the given list. Each element in the subset should be sorted in ascending order. Input * `nums`: A list of distinct integers. `1 <= len(nums) <= 10` Output * A set of tuples, where each tuple represents a unique subset of `nums`. Constraints * Each subset in the output must be unique. * Subsets must be in ascending order. Scenario You are developing a feature selection module in a machine learning model. Instead of trying every possible combination manually, you decide to generate all possible subsets of the features automatically for evaluation. Example ```python # Example 1 input: [1, 2, 3] output: { (), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3) } # Example 2 input: [4, 1, 7] output: { (), (1,), (4,), (7,), (1, 4), (1, 7), (4, 7), (1, 4, 7) } ``` Implement the function with the provided specifications. ```python def generate_subsets(nums): :param nums: List[int] :return: Set[tuple] # Your code goes here ```","solution":"from itertools import combinations def generate_subsets(nums): Generate all unique subsets of a given list of distinct integers. Parameters: nums (list): List of distinct integers. Returns: set: A set of tuples, each representing a unique subset of the input list. nums.sort() subsets = set() for r in range(len(nums) + 1): for subset in combinations(nums, r): subsets.add(subset) return subsets"},{"question":"# Question In-order Traversal of a Binary Tree Given a binary tree, implement functions to perform an in-order traversal both recursively and iteratively. The output should be a list containing the values from the traversal in order. Function Signatures * `def inorder_recursive(root: Node) -> List[int]:` * `def inorder_iterative(root: Node) -> List[int]:` Input * `root` is the root node of the binary tree. The tree can be empty. Output * Return a list of integers representing the in-order traversal of the binary tree. Constraints * The number of nodes in the tree is in the range [0, 10^4]. * Node values are integers and can be negative or positive. Example Given the binary tree, ``` 1 / 2 3 / 4 5 ``` The in-order traversal would be: `[4, 2, 5, 1, 3]` Tasks 1. Implement the function `inorder_recursive` to perform the in-order traversal recursively. 2. Implement the function `inorder_iterative` to perform the in-order traversal iteratively.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def inorder_recursive(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node], res: List[int]) -> None: if not node: return helper(node.left, res) res.append(node.val) helper(node.right, res) result = [] helper(root, result) return result def inorder_iterative(root: Optional[Node]) -> List[int]: result, stack = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Missing Number Finder You are given a list of unique integers within the range `0` to `n` inclusive, where `n` is the length of the list. The integers are in a sequence but one number is missing. Your task is to write a function that finds this missing number. The function should be implemented using two different approaches: 1. Using bitwise XOR operation. 2. Using sum-based calculation method. # Function Signatures: ```python def find_missing_number(nums: List[int]) -> int: pass def find_missing_number2(nums: List[int]) -> int: pass ``` # Input: - `nums`: List of unique integers of length `n` in the range `[0, n]`. # Output: - Returns the missing integer from the given list. # Constraints: - The input list `nums` will always contain unique integers. - The range `[0, n]` ensures that each number within this range appears exactly once except one missing number. - The sum of integers in the input list does not overflow the integer limits. # Example: ```python # Example 1: nums = [4, 1, 3, 0, 5, 2] assert find_missing_number(nums) == 6 assert find_missing_number2(nums) == 6 # Example 2: nums = [3, 7, 1, 2, 8, 4, 5, 0, 6] assert find_missing_number(nums) == 9 assert find_missing_number2(nums) == 9 # Example 3: nums = [] assert find_missing_number(nums) == 0 assert find_missing_number2(nums) == 0 # Example 4: nums = [0, 1, 2, 3, 4] assert find_missing_number(nums) == 5 assert find_missing_number2(nums) == 5 ``` # Note: - In cases where there are no missing integers within the range, both functions should return the next integer in the sequence. - Ensure to handle empty list case where the output should be `0`.","solution":"from typing import List # Approach 1: Using bitwise XOR operation def find_missing_number(nums: List[int]) -> int: n = len(nums) xor_sum = n for i in range(n): xor_sum ^= i xor_sum ^= nums[i] return xor_sum # Approach 2: Using sum-based calculation method def find_missing_number2(nums: List[int]) -> int: n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"Implement a Modified Rabin-Karp Algorithm You are tasked with implementing a variation of the Rabin-Karp algorithm that can find all occurrences of a pattern in a given text. This will require handling multiple matches, not just the first one, and ensuring efficiency even in the presence of hash collisions. Objective: Write a function `rabin_karp_multiple_occurrences(pattern, text)` that returns a list of all starting indices where the `pattern` is found within the `text`. Function Signature: ```python def rabin_karp_multiple_occurrences(pattern: str, text: str) -> List[int]: ``` Input: - `pattern` (str): A non-empty string representing the pattern to be searched in the text. - `text` (str): A non-empty string representing the larger text in which the pattern is to be searched. Output: - `List[int]`: A list of starting indices where the pattern is found within the text. If the pattern is not found, return an empty list. Constraints: - The length of the `pattern` will always be less than or equal to the length of the `text`. - Assume the text and pattern consists of lowercase alphabets only. Examples: ```python assert rabin_karp_multiple_occurrences(\\"abc\\", \\"abcabcabc\\") == [0, 3, 6] assert rabin_karp_multiple_occurrences(\\"abc\\", \\"aabbcc\\") == [] assert rabin_karp_multiple_occurrences(\\"a\\", \\"aaaaa\\") == [0, 1, 2, 3, 4] assert rabin_karp_multiple_occurrences(\\"aa\\", \\"aaa\\") == [0, 1] assert rabin_karp_multiple_occurrences(\\"xyz\\", \\"abcdefg\\") == [] ``` Hints: - Implement and utilize a `RollingHash` class similar to the one provided in the code snippet. - Be cautious of hash collisions and ensure proper string comparisons to confirm matches. - Consider edge cases such as patterns appearing consecutively. Good luck, and happy coding!","solution":"from typing import List class RollingHash: def __init__(self, base: int, mod: int): self.base = base self.mod = mod self.hash = 0 self.base_power = 1 def append(self, char: str): self.hash = (self.hash * self.base + ord(char)) % self.mod def skip(self, char: str): self.hash = (self.hash - ord(char) * self.base_power % self.mod + self.mod) % self.mod def compute_base_power(self, length: int): self.base_power = pow(self.base, length - 1, self.mod) def rabin_karp_multiple_occurrences(pattern: str, text: str) -> List[int]: if not pattern or not text: return [] base = 256 mod = 101 pattern_len = len(pattern) text_len = len(text) rolling_hash = RollingHash(base, mod) pattern_hash = RollingHash(base, mod) result = [] for i in range(pattern_len): rolling_hash.append(text[i]) pattern_hash.append(pattern[i]) rolling_hash.compute_base_power(pattern_len) for i in range(text_len - pattern_len + 1): if i > 0: rolling_hash.skip(text[i - 1]) rolling_hash.append(text[i + pattern_len - 1]) if rolling_hash.hash == pattern_hash.hash: if text[i:i + pattern_len] == pattern: result.append(i) return result"},{"question":"Consider a scenario where you are developing a system that cycles through a set of unique and sorted alarm times (represented by lowercase letters) and needs to find the next available alarm time after a specific target time. Given a list of sorted characters `letters`, containing only lowercase letters, and a target letter `target`, you need to find the smallest element in the list that is larger than the given target. The list `letters` also wraps around. For example, if the target is `target = \'z\'` and `letters = [\'a\', \'b\']`, then the answer should be `\'a\'`. Function Signature ```python def next_greatest_letter(letters: List[str], target: str) -> str: ``` Input - `letters`: A list of sorted lowercase letters (`1 <= len(letters) <= 10^4`), with no duplicates. - `target`: A single lowercase letter. Output - Returns the smallest element in the list that is greater than the given `target`. Examples ```python assert next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"a\\") == \\"c\\" assert next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"c\\") == \\"f\\" assert next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"d\\") == \\"f\\" assert next_greatest_letter([\\"a\\", \\"b\\", \\"c\\", \\"f\\"], \\"c\\") == \\"f\\" assert next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"j\\") == \\"c\\" ``` Constraints - Your solution should efficiently handle large inputs (up to len(letters) = 10^4). Notes - Consider optimal performance using binary search when implementing your solution. - Think about edge cases involving circular wrapping, especially when the target is near the end of the alphabet range.","solution":"from typing import List def next_greatest_letter(letters: List[str], target: str) -> str: Finds the next greatest letter that is greater than the target letter. Letters list is sorted and may wrap around. left, right = 0, len(letters) while left < right: mid = (left + right) // 2 if letters[mid] > target: right = mid else: left = mid + 1 return letters[left % len(letters)]"},{"question":"# Question: Implement and Enhance Separate Chaining Hash Table You are required to implement a separate chaining hash table with dynamic resizing and enhanced collision resolution. The current implementation needs improvements to better manage high load factors and ensure efficient operation. Your task is to: 1. Implement dynamic resizing: - Automatically resize the hash table when the load factor exceeds 0.75. - Upon resizing, rehash all elements to the new size. 2. Optimize collision resolution: - Replace linked list buckets with balanced binary search trees (BST) for better performance under high collision scenarios. 3. Implement a method to retrieve all keys in sorted order due to the enhanced collision resolution using BST. Function Signature ```python class SeparateChainingHashTable: def __init__(self, size=11): # Constructor def put(self, key, value): # Method to add or update a key-value pair def get(self, key): # Method to retrieve a value by key def del_(self, key): # Method to delete a key-value pair def keys_sorted(self): # Method to retrieve all keys in sorted order ``` Input Format * `put(key: Any, value: Any)`: takes a key-value pair. Key and value can be of any hashable data type. * `get(key: Any) -> Any`: takes a key and returns the corresponding value, or `None` if the key is not present. * `del_(key: Any)`: takes a key and deletes the corresponding key-value pair. * `keys_sorted() -> List[Any]`: returns a list of all keys in sorted order. Output Format * The `get` method should output the value associated with the input key or `None`. * The `del_` method does not produce output. * The `keys_sorted` method should return a list of keys sorted in ascending order. Constraints * Keys should be unique. * Handle generic hashable data types for keys and values. * Maintain optimal average time complexity for operations O(1) and ensure graceful degradation. Example: ```python table = SeparateChainingHashTable() table.put(\\"apple\\", 1) assert table.get(\\"apple\\") == 1 table.put(\\"banana\\", 2) table.put(\\"cherry\\", 3) assert table.keys_sorted() == [\\"apple\\", \\"banana\\", \\"cherry\\"] table.del_(\\"banana\\") assert table.keys_sorted() == [\\"apple\\", \\"cherry\\"] ``` Enhance the existing code to meet these requirements and ensure proper handling of edge cases, performance bottlenecks, and error scenarios. Provide unit tests to validate your implementation.","solution":"class TreeNode: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def put(self, key, value): if self.root is None: self.root = TreeNode(key, value) else: self._put(self.root, key, value) def _put(self, node, key, value): if key < node.key: if node.left: self._put(node.left, key, value) else: node.left = TreeNode(key, value) elif key > node.key: if node.right: self._put(node.right, key, value) else: node.right = TreeNode(key, value) else: node.value = value def get(self, key): return self._get(self.root, key) def _get(self, node, key): if node is None: return None if key < node.key: return self._get(node.left, key) elif key > node.key: return self._get(node.right, key) else: return node.value def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key, node.value = temp.key, temp.value node.right = self._delete(node.right, temp.key) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def keys_inorder(self): keys = [] self._inorder(self.root, keys) return keys def _inorder(self, node, keys): if node: self._inorder(node.left, keys) keys.append(node.key) self._inorder(node.right, keys) class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.count = 0 self.buckets = [BST() for _ in range(size)] def _hash(self, key): return hash(key) % self.size def _resize(self, new_size): old_buckets = self.buckets self.buckets = [BST() for _ in range(new_size)] self.size = new_size self.count = 0 for bst in old_buckets: for key in bst.keys_inorder(): self.put(key, bst.get(key)) def _check_load_factor(self): if self.count / self.size > 0.75: self._resize(self.size * 2) def put(self, key, value): index = self._hash(key) bst = self.buckets[index] if bst.get(key) is None: self.count += 1 bst.put(key, value) self._check_load_factor() def get(self, key): index = self._hash(key) return self.buckets[index].get(key) def del_(self, key): index = self._hash(key) bst = self.buckets[index] if bst.get(key) is not None: bst.delete(key) self.count -= 1 def keys_sorted(self): keys = [] for bst in self.buckets: keys.extend(bst.keys_inorder()) return sorted(keys)"},{"question":"# Preorder Traversal of a Binary Tree You are given a binary tree represented by its root node. Implement and compare two methods for performing a preorder traversal of this tree: one iterative and one recursive. Your task is to return a list of node values in preorder sequence for both methods. Implement the following functions: 1. `preorder(root)` for the iterative approach. 2. `preorder_rec(root, res=None)` for the recursive approach. Input: - `root`: A `Node` object representing the root of the binary tree. Output: - Return a list of integers representing the node values in preorder sequence for both approaches. Constraints: - The number of nodes in the tree will be between 0 and 10^4. - Nodes will have unique integer values. Example: ```python class Node: This is a class of Node. def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder(root): Function for iterative preorder traversal. # [Your Implementation Here] def preorder_rec(root, res=None): Function for recursive preorder traversal. # [Your Implementation Here] # Example usage: # Construct the binary tree # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) print(preorder(root)) # Output: [1, 2, 4, 5, 3] print(preorder_rec(root)) # Output: [1, 2, 4, 5, 3] ``` Make sure to handle edge cases such as an empty tree or a tree with only one node.","solution":"class Node: This is a class for Node. def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder(root): Function for iterative preorder traversal. if root is None: return [] result = [] stack = [root] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_rec(root, res=None): Function for recursive preorder traversal. if res is None: res = [] if root: res.append(root.val) preorder_rec(root.left, res) preorder_rec(root.right, res) return res"},{"question":"# Magic Number Sequence Problem # Context: A \\"Magic Number\\" is defined as a number which, when summing its digits repeatedly until a single-digit number results, yields 1. We want to generate a sequence of such magic numbers starting from a given number up to a certain limit. # Problem Statement: Write a function `find_magic_numbers(start: int, limit: int) -> list` that finds all the magic numbers starting from `start` to `limit` (inclusive). # Function Signature ```python def find_magic_numbers(start: int, limit: int) -> list: ``` # Input: - `start` (int): The starting number of the range (inclusive). - `limit` (int): The ending number of the range (inclusive). # Output: - Returns a list of integers which are magic numbers in the specified range. # Constraints: - `0 <= start <= limit <= 10^6` # Performance Requirements: - The function should be optimized to handle large ranges efficiently. # Example: ```python find_magic_numbers(1, 20) ``` should return: ```python [1, 10, 19] ``` # Further Guidance: To check if a number is a magic number, you could leverage the previously discussed `magic_number` function. Consider iterating through the range and checking each number if it fits the criteria.","solution":"def sum_digits(n): Sums the digits of a number. return sum(int(digit) for digit in str(n)) def is_magic_number(n): Returns True if the number is a magic number. while n >= 10: n = sum_digits(n) return n == 1 def find_magic_numbers(start: int, limit: int) -> list: Finds all magic numbers between start and limit (inclusive). return [num for num in range(start, limit + 1) if is_magic_number(num)]"},{"question":"As a programming challenge, you are required to write a function to find the predecessor of a given node in a Binary Search Tree (BST). You are given a BST and a target node. Your task is to implement a function `predecessor` that returns the predecessor of the given node. # Function Signature ```python def predecessor(root, node): # Your code here ``` # Input - `root`: The root node of a Binary Search Tree (BST), where each node has attributes `val`, `left`, and `right`. - `node`: The target node whose predecessor you need to find. # Output - The predecessor node of the given target node. # Constraints - The BST can have at most (10^4) nodes. - All node values are unique. - The tree does not contain duplicate values. - The input node is guaranteed to be a node in the BST. # Example Consider the following BST: ``` 20 / 10 30 / / 5 15 25 35 17 ``` - If the target node is `15`, the predecessor is `10`. - If the target node is `17`, the predecessor is `15`. - If the target node is `30`, the predecessor is `25`. # Edge Cases to Consider - Target node being the smallest node in the BST. - Target node being the largest node in the BST. - Tree with only one node. # Performance Requirement - The solution must be efficient, ideally with a time complexity of O(h), where h is the height of the BST. # Implementation Guidelines - Implement the function solely based on the structure and properties of a BST. - Do not use extra space for traversal (i.e., avoid using additional data structures like lists or stacks). ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def predecessor(root, node): # Your code here ``` # Scenario You are tasked to optimize the search query performance of a music database where each song and artist information is managed using BSTs. Each node represents a song or artist, and their relationships follow the BST properties. Efficiently finding a predecessor node helps in suggesting the previous song or artist in lexicographical order.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def predecessor(root, node): Finds the predecessor of a given node in a BST. :param root: The root node of the BST. :param node: The node whose predecessor is to be found. :return: The predecessor node of the given target node. if node.left: # The predecessor is the maximum value node in the left subtree pred = node.left while pred.right: pred = pred.right return pred # Otherwise, search the predecessor from root pred = None current = root while current: if node.val > current.val: pred = current current = current.right elif node.val < current.val: current = current.left else: break return pred # Helper function to insert a node into the BST def insert(root, val): if not root: return TreeNode(val) if val < root.val: root.left = insert(root.left, val) else: root.right = insert(root.right, val) return root"},{"question":"**Segment Tree for Custom Range Queries and Updates** You are required to implement a Segment Tree to support efficient range queries and point updates. The Segment Tree should be able to handle various types of aggregation functions as specified by the user. Function Signatures 1. **Create a Segment Tree:** ```python class SegmentTree: def __init__(self, arr, function): pass ``` 2. **Update an Element:** ```python def update(self, p, v): pass ``` 3. **Query a Range:** ```python def query(self, l, r): pass ``` Input and Output Formats * **Initialization:** * **Input:** An array `arr` of elements and a commutative function `function` to be used for aggregation. * **Output:** None (the tree is internally initialized and built). * **Update:** * **Input:** Integer index `p` and new value `v` to update the array element at index `p`. * **Output:** None (updates the internal structure and propagates changes). * **Query:** * **Input:** Integer range `[l, r]` to query the aggregation from index `l` to `r` inclusive. * **Output:** The result of applying the aggregation function to the specified range. Constraints * The array has at least one element. * Index and range queries are zero-based. * Parameters passed to the functions should be valid within the given context. Example ```python # Example of a Segment Tree with sum aggregation function arr = [4, 5, 2, 3, 4, 43, 3] segment_tree = SegmentTree(arr, lambda a, b: a + b) # Querying sum of range [0, 6] print(segment_tree.query(0, 6)) # Output should be 64 (sum of all elements) # Updating element at index 2 to -10 segment_tree.update(2, -10) # Querying sum of range [0, 6] after update print(segment_tree.query(0, 6)) # Output should be 52 (updated sum) ``` **Note:** You must handle all edge cases where the input array contains minimum, maximum values and cover diverse types of commutative aggregation functions.","solution":"class SegmentTree: def __init__(self, arr, function): Initializes the Segment Tree with a given array and a function for aggregation. :param arr: List[int] initial array of elements :param function: function to be used for range aggregation (e.g., sum, min, max) self.n = len(arr) self.arr = arr self.function = function self.tree = [0] * (2 * self.n) self.build() def build(self): # Building the tree, start by placing the array in the leaves of the tree for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Calculating the parents as a result of applying the function to children for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, v): Update the value at index p to v. :param p: index to be updated :param v: new value # Update the leaf node pos = p + self.n self.tree[pos] = v # Update the parent nodes while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l, r): Query the function in the range [l, r] inclusive. :param l: left index of the range :param r: right index of the range :return: the result of the function applied in the range l += self.n r += self.n result = None while l <= r: if l % 2 == 1: result = self.tree[l] if result is None else self.function(result, self.tree[l]) l += 1 if r % 2 == 0: result = self.tree[r] if result is None else self.function(result, self.tree[r]) r -= 1 l //= 2 r //= 2 return result"},{"question":"**Question: Implement Enhanced Counting Sort** You are required to implement an enhanced version of Counting Sort which must account for negative integers and optimize memory usage. Given an array of integers, your task is to: 1. Sort the array considering both positive and negative integers. 2. Ensure the algorithm uses space efficiently. # Function Signature ```python def enhanced_counting_sort(arr: List[int]) -> List[int]: pass ``` # Input * The input is a single list of integers `arr` where: * ( -10^6 leq arr[i] leq 10^6 ) * ( 1 leq len(arr) leq 10^5 ) # Output * The function should return a list of integers sorted in non-decreasing order. # Example ```python assert enhanced_counting_sort([4, -1, 0, 3, 2]) == [-1, 0, 2, 3, 4] assert enhanced_counting_sort([1, -2, -2, 2, 0]) == [-2, -2, 0, 1, 2] ``` # Constraints 1. You must use an approach based on counting sort. 2. Your solution should be efficient given the provided constraints. # Notes - Consider performance and memory requirements while devising your solution. - Ensure that your code handles edge cases, such as arrays with all negative or all positive integers, as well as arrays with a mix of positive and negative integers.","solution":"def enhanced_counting_sort(arr): if not arr: return arr # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Initialize the counting array count_range = max_val - min_val + 1 count_array = [0] * count_range # Fill the counting array for num in arr: count_array[num - min_val] += 1 # Build the sorted array sorted_index = 0 for i in range(count_range): while count_array[i] > 0: arr[sorted_index] = i + min_val sorted_index += 1 count_array[i] -= 1 return arr"},{"question":"# Integer Decomposition Challenge Objective Write a function to count the number of ways a positive integer `n` can be decomposed into sum of positive integers (including single number itself as a way). Problem Statement You are given a positive integer `n`. Write a function `int_decompose(n)` that returns the count of all unique decompositions of the number `n`. Function Signature ```python def int_decompose(n: int) -> int: ``` Input * `n`: a positive integer (1 ≤ n ≤ 200) Output * Return an integer representing the number of ways to decompose `n` into a sum of positive integers. Examples 1. **Example 1**: * Input: `n = 4` * Output: `5` * Explanation: * The possible decompositions of 4 are: [4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1] 2. **Example 2**: * Input: `n = 7` * Output: `15` * Explanation: * The possible decompositions of 7 are mentioned in the example of provided snippet. Constraints * Ensure your solution handles both small and reasonably large integers up to 200 efficiently. * Consider edge cases like the smallest integers (1) and ensure the function runs within expected time boundaries even for the largest number within given constraints. Hint Dynamic programming can be used effectively for this problem. You may want to reuse results from previously computed subproblems to create an efficient solution.","solution":"def int_decompose(n: int) -> int: # Dynamic programming table dp = [0] * (n + 1) # There is one way to partition the number 0 dp[0] = 1 # Iterate over each number from 1 to n to build the dp table for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Context You are given a `HashTable` class that implements a basic hash map with linear probing collision resolution. This class also allows dynamic resizing through its subclass `ResizableHashTable`. Your task is to extend this functionality by adding support for a different probing method called **quadratic probing**. # Task Implement a new subclass `QuadraticProbingHashTable` that inherits from `HashTable`. Modify the collision resolution strategy to use quadratic probing instead of linear probing. Quadratic Probing In quadratic probing, the interval between probes is increased by adding the successive outputs of a quadratic polynomial to the starting value given by the original hash function. For example: - If the initial hash is ( h ), - The next slots probed would be ( (h+1^2) % text{size}, (h+2^2) % text{size}, (h+3^2) % text{size}, ldots ) # Function Input & Output * No explicit input, as this modifies the methods internally within the class. * Your `QuadraticProbingHashTable` should override methods from `HashTable` to implement the new collision strategy. # Constraints * Assume the quadratic probing formula does not overstep the size range. * The maximum load factor before resizing is ( frac{2}{3} ). # Performance Requirements * Maintain average O(1) time complexity for basic operations within the bounds of the new probing method. * Carefully manage resizing to ensure performance remains optimal under high load. # Code Skeleton Here is a starting point: ```python class QuadraticProbingHashTable(HashTable): def _rehash(self, old_hash, attempt): Quadratic probing strategy for collision resolution return (old_hash + attempt ** 2) % self.size def put(self, key, value): attempt = 0 initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] is self._empty or self._keys[hash_] is self._deleted: self._keys[hash_] = key self._values[hash_] = value self._len += 1 return elif self._keys[hash_] == key: self._keys[hash_] = key self._values[hash_] = value return attempt += 1 hash_ = self._rehash(initial_hash, attempt) if attempt >= self.size: raise ValueError(\\"Table is full\\") def get(self, key): attempt = 0 initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] is self._empty: return None elif self._keys[hash_] == key: return self._values[hash_] attempt += 1 hash_ = self._rehash(initial_hash, attempt) if attempt >= self.size: return None def del_(self, key): attempt = 0 initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] == self._empty: return None elif self._keys[hash_] == key: self._keys[hash_] = self._deleted self._values[hash_] = self._deleted self._len -= 1 return attempt += 1 hash_ = self._rehash(initial_hash, attempt) if attempt >= self.size: return None ```","solution":"class HashTable: _empty = object() _deleted = object() def __init__(self, size=11): self.size = size self._keys = [self._empty] * self.size self._values = [self._empty] * self.size self._len = 0 self.load_factor_threshold = 2 / 3 def hash(self, key): return hash(key) % self.size def resize(self): old_keys = self._keys old_values = self._values new_size = self.size * 2 self.size = new_size self._keys = [self._empty] * self.size self._values = [self._empty] * self.size self._len = 0 for key, value in zip(old_keys, old_values): if key is not self._empty and key is not self._deleted: self.put(key, value) class QuadraticProbingHashTable(HashTable): def _rehash(self, old_hash, attempt): Quadratic probing strategy for collision resolution return (old_hash + attempt ** 2) % self.size def put(self, key, value): if self._len / self.size > self.load_factor_threshold: self.resize() attempt = 0 initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] is self._empty or self._keys[hash_] is self._deleted: self._keys[hash_] = key self._values[hash_] = value self._len += 1 return elif self._keys[hash_] == key: self._keys[hash_] = key self._values[hash_] = value return attempt += 1 hash_ = self._rehash(initial_hash, attempt) if attempt >= self.size: raise ValueError(\\"Table is full\\") def get(self, key): attempt = 0 initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] is self._empty: return None elif self._keys[hash_] == key: return self._values[hash_] attempt += 1 hash_ = self._rehash(initial_hash, attempt) if attempt >= self.size: return None def del_(self, key): attempt = 0 initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] == self._empty: return None elif self._keys[hash_] == key: self._keys[hash_] = self._deleted self._values[hash_] = self._deleted self._len -= 1 return attempt += 1 hash_ = self._rehash(initial_hash, attempt) if attempt >= self.size: return None"},{"question":"# Challenge: Verify List of Prime Numbers You are tasked with implementing a function that will verify if all the numbers in a list are prime numbers. Given the nature of prime number verification, you will use the provided `prime_check` function as part of your solution. # Task Implement a function `verify_prime_list(numbers: List[int]) -> bool` which takes a list of integers and returns `True` if all the numbers in the list are prime. If any number in the list is not prime, the function should return `False`. # Input - A list of integers `numbers` where 1 <= len(numbers) <= 10^4 and each integer `n` satisfies 1 <= n <= 10^6. # Output - `True` if all integers in the list are prime. - `False` if at least one integer in the list is not prime. # Constraints - The function should aim for efficiency, given the potentially large size of the list and the range of integer values. # Example ```python assert verify_prime_list([2, 3, 5, 7]) == True assert verify_prime_list([2, 4, 5, 7]) == False assert verify_prime_list([17, 19, 23, 29]) == True assert verify_prime_list([10, 11, 12, 13]) == False ``` # Notes You can utilize the provided `prime_check` function within your solution to verify if an individual number is prime. Your task is to iterate through the list and use this function appropriately. ```python def prime_check(n): if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False j = 5 while j * j <= n: if n % j == 0 or n % (j + 2) == 0: return False j += 6 return True def verify_prime_list(numbers): # Your implementation here ```","solution":"from typing import List def prime_check(n): if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False j = 5 while j * j <= n: if n % j == 0 or n % (j + 2) == 0: return False j += 6 return True def verify_prime_list(numbers: List[int]) -> bool: for number in numbers: if not prime_check(number): return False return True"},{"question":"Context Given a certain set of operations useful for numerical computations, you are to implement functions that not only calculate greatest common divisors (GCD), least common multiples (LCM), and trailing zero counts of binary representations but also optimize these calculations using bitwise operations. As a software developer, mastering these low-level operations can be crucial for writing efficient, high-performance code. Task Write the following three functions: 1. **`gcd(a, b)`**: Computes the greatest common divisor of two integers `a` and `b` using Euclid\'s algorithm. 2. **`trailing_zero(x)`**: Calculates the number of trailing zeroes in the binary representation of a given positive integer `x`. 3. **`gcd_bit(a, b)`**: Computes the greatest common divisor using bitwise operations. Your functions should handle various edge cases and ensure efficient performance even with larger integers. Requirements - **Function gcd(a, b)**: - **Input**: Two integers `a` and `b` where both `a` and `b` are non-zero. - **Output**: An integer representing their greatest common divisor. - **Constraints**: Handles positive and negative integers. - **Function trailing_zero(x)**: - **Input**: One positive integer `x`. - **Output**: An integer representing the number of trailing zeros in the binary representation of `x`. - **Function gcd_bit(a, b)**: - **Input**: Two non-negative integers `a` and `b`. - **Output**: An integer representing their greatest common divisor calculated using bitwise operations. - **Constraints**: `a` and `b` are non-negative integers (zero allowed). Example ```python assert gcd(270, 192) == 6 assert trailing_zero(40) == 3 assert gcd_bit(270, 192) == 6 ``` Implementation Notes - Ensure that the functions raise appropriate errors for invalid inputs. - Optimize the bitwise GCD function to handle large numbers efficiently. - Include inline comments explaining the core operational steps.","solution":"def gcd(a, b): Computes the greatest common divisor of two integers a and b using Euclid\'s algorithm. while b: a, b = b, a % b return abs(a) def trailing_zero(x): Calculates the number of trailing zeros in the binary representation of a given positive integer x. if x == 0: raise ValueError(\\"Input must be a positive integer.\\") count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def gcd_bit(a, b): Computes the greatest common divisor using bitwise operations. if a == 0: return b if b == 0: return a shift = trailing_zero(a | b) a >>= trailing_zero(a) while b != 0: b >>= trailing_zero(b) if a > b: a, b = b, a b -= a return a << shift"},{"question":"# Scenario: You are working on implementing a secure communication system using the RSA algorithm. After studying the key generation and encryption process, your task is to complete and optimize a simplified RSA encryption system. Specifically, you have to handle encryption, decryption functionalities, and improve the prime-checking method for performance. # Task: 1. Implement a function `is_prime_optimized(num)` to efficiently check if a number is prime. 2. Use this function to replace the existing `is_prime` function within the `gen_prime` function. 3. Ensure that the whole RSA algorithm works correctly with your modifications. # Requirements: - Your implementation should handle prime numbers up to at least 16-bits efficiently. - Ensure the overall RSA system passes the provided test cases. # Input: - No direct input from users. RSA functions will be tested using pre-defined test cases. # Output: - Your `is_prime_optimized(num)` function should return a boolean indicating whether `num` is a prime number. - The RSA system should correctly encrypt and decrypt integers. # Constraints: - `n` and `e` must be product of two primes as specified. - `is_prime_optimized(num)` should be more efficient than the straightforward trial division method. # Performance Requirements: - Aim to reduce the prime-checking time complexity to (O(sqrt{k})) or better using advanced techniques such as Miller-Rabin primality test. # Example: You might test your implementation with: ```python assert is_prime_optimized(29) == True assert is_prime_optimized(15) == False n, e, d = generate_key(16) data = 123 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Provided Code: ```python # Prime-checking function that needs optimization def is_prime(num): if num == 2: return True for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True # Use this improved prime check in key generation # RSA Key Generation and Encryption Functions (already provided) import random def generate_key(k, seed=None): def modinv(a, m): b = 1 while not (a * b) % m == 1: b += 1 return b def gen_prime(k, seed=None): random.seed(seed) while True: key = random.randrange(int(2 ** (k - 1)), int(2 ** k)) if is_prime(key): return key p_size = k // 2 q_size = k - p_size e = gen_prime(p_size, seed) # e is often chosen to be a constant while True: p = gen_prime(p_size, seed) if p % e != 1: break while True: q = gen_prime(q_size, seed) if q % e != 1: break n = p * q l = (p - 1) * (q - 1) # Euler\'s totient function d = modinv(e, l) return int(n), int(e), int(d) def encrypt(data, e, n): return pow(int(data), int(e), int(n)) def decrypt(data, d, n): return pow(int(data), int(d), int(n)) # Implement is_prime_optimized function and incorporate it ```","solution":"def is_prime_optimized(num): Checks if a number is prime using a more efficient method. Implements the Miller-Rabin primality test. if num in (2, 3): return True if num <= 1 or num % 2 == 0: return False def miller_rabin_test(d, num): a = random.randint(2, num - 2) x = pow(a, d, num) if x == 1 or x == num - 1: return True while d != num - 1: x = (x * x) % num d *= 2 if x == 1: return False if x == num - 1: return True return False # Write num as d*2^r + 1 d = num - 1 while d % 2 == 0: d //= 2 k = 5 # number of test rounds for _ in range(k): if not miller_rabin_test(d, num): return False return True import random def generate_key(k, seed=None): def modinv(a, m): m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def gen_prime(k, seed=None): random.seed(seed) while True: key = random.randint(int(2 ** (k - 1)), int(2 ** k) - 1) if is_prime_optimized(key): return key p_size = k // 2 q_size = k - p_size e = gen_prime(p_size, seed) # e is often chosen to be a constant while True: p = gen_prime(p_size, seed) if p % e != 1: break while True: q = gen_prime(q_size, seed) if q % e != 1: break n = p * q l = (p - 1) * (q - 1) # Euler\'s totient function d = modinv(e, l) return int(n), int(e), int(d) def encrypt(data, e, n): return pow(int(data), int(e), int(n)) def decrypt(data, d, n): return pow(int(data), int(d), int(n))"},{"question":"# Question: Implement and Extend Base Conversion Functions You are tasked with implementing and extending two base conversion functions, `int_to_base` and `base_to_int`, to handle additional edge cases and improve performance. These functions will convert numbers from decimal to a specified base and vice versa. Functions to Implement: 1. `extended_int_to_base(num, base)` 2. `extended_base_to_int(str_to_convert, base)` Detailed Requirements: 1. **Function**: `extended_int_to_base(num, base)` * **Input**: * `num`: An integer that may be negative (1 <= |num| <= 10^9). * `base`: An integer (2 <= base <= 36). * **Output**: * A string representing `num` in the specified `base`. * **Constraints**: * Must handle zero appropriately. * Must handle negative numbers. * Ensure efficient handling for the given range of `num`. 2. **Function**: `extended_base_to_int(str_to_convert, base)` * **Input**: * `str_to_convert`: A string representing a number in a specified base. * `base`: An integer (2 <= base <= 36). * **Output**: * An integer represented by `str_to_convert` in the given `base`. * **Constraints**: * Handle invalid characters by raising appropriate exceptions. * Ensure robust error handling for out-of-range bases and non-numeric characters. * Ensure efficient conversion for the string representation given the usual constraints. Example ```python assert extended_int_to_base(5, 2) == \'101\' assert extended_base_to_int(\'F\', 16) == 15 assert extended_int_to_base(-255, 16) == \'-FF\' assert extended_base_to_int(\'-FF\', 16) == -255 ``` **Note**: * Be cautious of reversing string manipulations to ensure minimal overhead. * Handle edge cases efficiently, focusing on zero and negatives. * Utilize built-in Python capabilities where suitable for optimization.","solution":"def extended_int_to_base(num, base): Converts an integer to a string representation in the specified base. :param num: Integer to be converted. Can be negative. :param base: Base to convert the integer to. Must be between 2 and 36. :return: String representation of the number in the specified base. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") if num == 0: return \\"0\\" is_negative = num < 0 num = abs(num) digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = [] while num > 0: result.append(digits[num % base]) num //= base if is_negative: result.append(\'-\') return \'\'.join(reversed(result)) def extended_base_to_int(str_to_convert, base): Converts a string representation of a number in a specified base to an integer. :param str_to_convert: String to be converted. :param base: Base of the number in the string. Must be between 2 and 36. :return: Integer representation of the string in the specified base. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") if not str_to_convert: raise ValueError(\\"Input string cannot be empty.\\") str_to_convert = str_to_convert.strip() is_negative = str_to_convert[0] == \'-\' if is_negative: str_to_convert = str_to_convert[1:] digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {ch: i for i, ch in enumerate(digits)} num = 0 for char in str_to_convert: if char.upper() not in value_map or value_map[char.upper()] >= base: raise ValueError(f\\"Invalid character \'{char}\' for base {base}.\\") num = num * base + value_map[char.upper()] return -num if is_negative else num"},{"question":"# Context: You are working as a software engineer tasked with improving the performance of an e-commerce website\'s product sorting functionality. One of the algorithms under consideration is the Cocktail Shaker Sort, due to its simplicity and stability. # Question: Implement the `cocktail_shaker_sort` function which sorts an array of integers in ascending order. Your implementation should be efficient and correctly handle various input scenarios. # Requirements: - Your function should accept a list of integers as input and return a list of integers sorted in ascending order. - Your function must modify the input list in-place and should not use extra space for another list. - Avoid using built-in sorting functions. # Constraints: - The input list can have up to 10^4 elements. - Each element in the list can range from -10^9 to 10^9. Private Test Cases: 1. Input: `[3, 0, 2, 5, -1, 4, 1]` Output: `[-1, 0, 1, 2, 3, 4, 5]` 2. Input: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` Output: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` 3. Input: `[]` Output: `[]` 4. Input: `[1]` Output: `[1]` 5. Input: `[987, -897, 654, -321, 0, 123]` Output: `[-897, -321, 0, 123, 654, 987]` Implement the `cocktail_shaker_sort` function based on the requirements specified.","solution":"def cocktail_shaker_sort(arr): Performs cocktail shaker sort on a list of integers. n = len(arr) if n <= 1: return arr is_sorted = False start = 0 end = n - 1 while not is_sorted: is_sorted = True # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False # If there were no swaps in the forward pass, the array is sorted if is_sorted: break # Otherwise, reset the flag for the backward pass is_sorted = True # Decrease the \'end\' since we know the largest element is at the end end -= 1 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] is_sorted = False # Increase the \'start\' since we know the smallest element is at the start start += 1 return arr"},{"question":"# Question: Robot\'s Path to Origin Suppose you are controlling a robot that always starts at the coordinate (0, 0) on a 2D grid. You can send it commands through a string where each character in the string represents a move: - \'U\' for Up to (x, y+1) - \'D\' for Down to (x, y-1) - \'L\' for Left to (x-1, y) - \'R\' for Right to (x+1, y) Your task is to determine if the sequence of commands will cause the robot to return to its starting point (0, 0). Function Signature ```python def judge_circle(moves: str) -> bool: pass ``` Input and Output Format * **Input**: * A single string `moves` containing only characters `U`, `D`, `L`, `R`. * Length of `moves` ranges from 1 to 10^4. * **Output**: * Return `True` if the sequence of moves brings the robot back to the origin, otherwise `False`. Constraints * The robot moves on an infinite grid. * The characters in `moves` are always from `{‘U’, ‘D’, ‘L’, ‘R’}`. Example *Example 1:* ```plaintext Input: \\"UD\\" Output: True Explanation: The robot moves up once and down once. No net movement - it returns back to (0, 0). ``` *Example 2:* ```plaintext Input: \\"LL\\" Output: False Explanation: The robot moves left twice and does not return to origin. ``` Requirements * Ensure the implemented function handles edge cases, e.g., when the input is an empty string, or has large sequences with balance and imbalance. * Consider performance and write an efficient solution given the constraints.","solution":"def judge_circle(moves: str) -> bool: Determines if a sequence of moves will cause the robot to return to its starting point (0, 0). Parameters: moves (str): A string containing the sequence of moves, which can only be characters \'U\', \'D\', \'L\', \'R\'. Returns: bool: True if the sequence of moves brings the robot back to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Palindrome Check with Custom Constraint Given a string, determine if it is a \\"conditional palindrome\\". A \\"conditional palindrome\\" is defined as a string where ignoring cases, spaces, and special characters, the string reads the same forwards and backwards. Additionally, you should be able to ignore a custom set of characters (`ignored_chars`). Empty strings should be considered valid palindromes. Input - A string `s` containing alphanumeric characters and potential spaces or special characters. - A string `ignored_chars` which lists the characters to be ignored apart from spaces and special characters. Output - Return `True` if the string `s` is a \\"conditional palindrome\\", otherwise return `False`. Constraints - The length of `s` will be at most `10^5`. - The length of `ignored_chars` will be at most `10`. Example ```python >>> is_conditional_palindrome(\\"A-man, a plan, a canal: Panama\\", \\"mP:\\") True >>> is_conditional_palindrome(\\"race a car\\", \\"\\") False >>> is_conditional_palindrome(\\"No lemon, no melon\\", \\"lN\\") True ``` Function Signature ```python def is_conditional_palindrome(s: str, ignored_chars: str) -> bool: # your code here ```","solution":"def is_conditional_palindrome(s: str, ignored_chars: str) -> bool: Returns True if the string s is a conditional palindrome considering ignored_chars. ignored_chars_set = set(ignored_chars.lower() + ignored_chars.upper()) cleaned_chars = [char.lower() for char in s if char.isalnum() and char not in ignored_chars_set] return cleaned_chars == cleaned_chars[::-1]"},{"question":"You have been tasked with enhancing the efficiency of a cryptographic module in a software package, which includes calculating the Euler\'s Totient function for various values of n. Given the critical role of this function in cryptographic algorithms, it is essential to compute it correctly and efficiently. # Task: Write a Python function `improved_euler_totient_list` that, given an integer input `max_num`, returns a list where the element at index i represents ϕ(i), the value of Euler\'s Totient function for i. The function should leverage efficient calculations to handle large values up to 10^6. # Function Signature: ```python def improved_euler_totient_list(max_num: int) -> List[int]: ``` # Input: - `max_num`: An integer (1 ≤ max_num ≤ 10^6). # Output: - List of integers: The list where the i-th element is the value of ϕ(i). # Example: ```python print(improved_euler_totient_list(10)) ``` Output: ```python [0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4] ``` # Constraints: - Your solution should efficiently handle the upper limit of 1,000,000. - Avoid recomputing from scratch for every query. # Expectations: - **Efficiency**: Given the upper constraint, your solution must be optimized. - **Correctness**: Ensure that the implementation correctly computes values based on Euler\'s Totient function properties. - **Edge Cases**: Handle cases such as small values of max_num and large prime values.","solution":"def improved_euler_totient_list(max_num: int): Returns a list where the element at index i represents ϕ(i), the value of Euler\'s Totient function for i, for all i from 0 to max_num. # Initialize the list with the value of each index initially being itself phi = list(range(max_num + 1)) for i in range(2, max_num + 1): # Check if i is a prime number if phi[i] == i: # i is a prime number, apply the formula to all multiples of i for j in range(i, max_num + 1, i): phi[j] = phi[j] * (i - 1) // i return phi"},{"question":"You are given two sparse matrices `A` and `B`, and you need to multiply them to return the result as matrix `C`. The matrix `A` is of dimension `m x l` and matrix `B` is of dimension `l x n`. Your task is to efficiently calculate and return the matrix `C` which is the result of the multiplication of matrices `A` and `B`. Constraints: - `1 <= m, n, l <= 100` - Values in matrices are non-negative integers (including zero). - `A[i][j]` and `B[i][j]` can be particularly sparse. Input: - List of lists `A` representing matrix A. - List of lists `B` representing matrix B. Output: - List of lists `C` representing the resulting matrix of their multiplication. # Function Signature ```python def multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` # Example ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] # The result of \'A\' multiplied by \'B\' (AB) should be: # [ # [7, 0, 0], # [-7, 0, 3] # ] result = multiply(A, B) print(result) # Expected output: [[7, 0, 0], [-7, 0, 3]] ``` Detailed Description - Ensure you only perform multiplications when both elements are non-zero to optimize the performance. - Handle exceptions where the number of columns in A doesn\'t match the number of rows in B. - You can use dictionaries to store non-zero values for faster access during multiplication. # Additional Notes - Consider edge cases where either matrix is completely zero. - Remember to return the resulting matrix in the correct dimensions.","solution":"from typing import List def multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: m, l = len(A), len(A[0]) l_b, n = len(B), len(B[0]) if l != l_b: raise ValueError(\\"Number of columns in A must be equal to number of rows in B\\") # Resultant matrix C C = [[0] * n for _ in range(m)] # Optimized multiplication leveraging sparsity for i in range(m): for k in range(l): if A[i][k] != 0: for j in range(n): if B[k][j] != 0: C[i][j] += A[i][k] * B[k][j] return C"},{"question":"**Scenario**: You are tasked with developing a module for a data processing tool that filters data based on frequency constraints. Given a list of items, you need to ensure each item appears at most `N` times. This operation needs to be performant even for large datasets. **Task**: Implement a function `filter_list` that processes an input list `lst` and an integer `n`, returning a new list where each element appears at most `n` times, maintaining the original order of elements in `lst`. **Function Signature**: ```python def filter_list(lst: List[int], n: int) -> List[int]: ``` **Input**: * A list of integers `lst` where each integer is between -1000 and 1000 inclusive. * An integer `n` which indicates the maximum allowable occurrences for any element; `1 <= n <= len(lst)`. **Output**: * A new list of integers with each integer appearing at most `n` times in the order they appear in `lst`. **Constraints and Limitations**: * The original order of `lst` must be maintained. * The function should be optimized to handle large lists and minimize execution time. **Performance Requirement**: * The function should run in O(n) time complexity and O(n) space complexity. **Example**: ```python # Example 1: lst = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 # Expected output: [1, 2, 3, 1, 2, 3] # Example 2: lst = [20, 37, 20, 21] n = 1 # Expected output: [20, 37, 21] ``` **Hint**: Consider using a hash table (dictionary) to keep track of the counts of each element as you iterate through the list.","solution":"from typing import List def filter_list(lst: List[int], n: int) -> List[int]: Returns a new list where each element appears at most \'n\' times, maintaining the original order of elements in \'lst\'. count_dict = {} filtered_lst = [] for item in lst: if item in count_dict: if count_dict[item] < n: count_dict[item] += 1 filtered_lst.append(item) else: count_dict[item] = 1 filtered_lst.append(item) return filtered_lst"},{"question":"# Question: Implement a Red-Black Tree Deletion Operation As an experienced software developer, you need to ensure that your data structure implementations can handle various edge cases and remain efficient. One of the crucial functionalities in a Red-Black Tree is ensuring that the tree remains balanced after deletions. Your task is to implement the `delete` function in the `RBTree` class. This function should be able to remove the specified node from the tree while maintaining all Red-Black Tree properties. You should also consider potential edge cases, such as deleting the root node or nodes with no children. Function Signature ```python def delete(self, node: RBNode) -> None: ``` Input - `node`: The node (instance of `RBNode`) to be deleted from the Red-Black Tree. Output - This function should modify the tree in place and return nothing. Constraints - All values of nodes in the Red-Black Tree are unique. - You are provided with methods `transplant`, `minimum`, and `delete_fixup` for handling internal operations post-deletion. - You must write this function within the class `RBTree`. Example Given a Red-Black Tree and a node with value 4, calling `delete(node_4)` should remove the node with value 4 and maintain the Red-Black Tree properties. ```python if __name__ == \\"__main__\\": rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) # Assume you have a method to find the node with a specific value node_to_delete = find_node_with_value(rb, 4) rb.delete(node_to_delete) print(rb.inorder()) # The tree should remain balanced and valid Red-Black Tree properties should hold after deletion. ``` You are expected to implement the `delete` method effectively, ensuring performance and reliability. Performance Requirements The deletion operation should maintain O(log n) time complexity. Good Luck!","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # 0 for black, 1 for red self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def delete(self, node): z = node y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self._rb_transplant(z, z.right) elif (z.right == self.TNULL): x = z.left self._rb_transplant(z, z.left) else: y = self._minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self._rb_transplant(y, y.right) y.right = z.right y.right.parent = y self._rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self._delete_fixup(x) def _delete_fixup(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self._left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self._right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self._left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self._right_rotate(x.parent) s = x.parent.left if s.right.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self._left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self._right_rotate(x.parent) x = self.root x.color = 0 def _rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _minimum(self, node): while node.left != self.TNULL: node = node.left return node # Additional methods like insert, inorder for the RBTree class # Assuming you have methods implemented to insert nodes and display the tree"},{"question":"You need to implement an optimized version of the Sieve of Eratosthenes which excludes even numbers. The function should provide a list of all prime numbers less than a given integer `n`. # Function Signature ```python def get_primes(n: int) -> List[int]: Computes a list of all primes less than the given integer n using an optimized Sieve of Eratosthenes which does not consider even numbers. Args: n (int): The upper limit (exclusive) for which to find all prime numbers. Returns: List[int]: A list of all prime numbers less than n. Raises: ValueError: If n is less than or equal to zero. ``` # Input * An integer `n` (1 <= n <= 10^6). # Output * A list of all prime numbers less than `n`. # Example ```python assert get_primes(10) == [2, 3, 5, 7] assert get_primes(11) == [2, 3, 5, 7] assert get_primes(2) == [2] assert get_primes(1) == [] ``` # Constraints * The value of `n` will always be within the range from 1 to one million inclusive. * The function must be optimized to handle the upper limit efficiently. # Notes * Ensure that you handle edge cases, such as n = 1, n = 2, and larger values efficiently. * Consider both the time and space complexity when implementing your solution. # Performance Requirements * Your solution should run in O(n log log n) time complexity. * The space complexity should be optimized, ideally slightly more than O(n/2).","solution":"from typing import List def get_primes(n: int) -> List[int]: Computes a list of all primes less than the given integer n using an optimized Sieve of Eratosthenes which does not consider even numbers. Args: n (int): The upper limit (exclusive) for which to find all prime numbers. Returns: List[int]: A list of all prime numbers less than n. Raises: ValueError: If n is less than or equal to zero. if n <= 1: return [] if n == 2: return [2] # Initializing the sieve array sieve = [True] * (n//2) prime_list = [2] # Adding 2 manually since we are skipping even numbers # Only considering odd numbers starting from 3 for i in range(1, (int(n**0.5) + 1)//2): # (int(n**0.5) + 1)//2 helps to reduce the range if sieve[i]: prime = 2*i + 1 # Convert index to the actual number for j in range(prime*prime//2, n//2, prime): sieve[j] = False prime_list.extend([2*i + 1 for i in range(1, n//2) if sieve[i]]) return prime_list"},{"question":"# Matrix Exponentiation Enhancement You are tasked to develop a function that enhances matrix exponentiation by adding memoization. The goal is to minimize redundant calculations for exponentiation by caching intermediate results. Write a function `optimized_matrix_exponentiation(mat: list, n: int, memo=None) -> list` that computes the matrix `mat` raised to the power of `n` using memoization for optimization. The function should operate as follows: - Compute `mat^n` using a method similar to the `matrix_exponentiation` but with memoization to cache results of previous exponents. # Function Signature ```python def optimized_matrix_exponentiation(mat: list, n: int, memo=None) -> list: # Function to implement ``` # Input - `mat`: A list of lists (2D array) representing a square matrix of size `d x d` with integer elements - `n`: A non-negative integer representing the power to which the matrix is to be raised. - `memo`: A dictionary to cache the results (defaulted to None for initial call) # Output - Returns a 2D list representing the matrix raised to the `n`th power. # Constraints - Matrices will be of size at most `10 x 10`. # Performance Requirement - Your implementation should efficiently handle repeated calculations by using memoization. # Example ```python mat = [ [1, 2], [3, 4] ] n = 3 result = optimized_matrix_exponentiation(mat, n) print(result) # Expected Output: [[37, 54], [81, 118]] ``` Make sure the function optimally uses memoization and returns correct results for edge cases like `n = 0` and `n = 1`.","solution":"def mat_mult(A, B): Multiples two square matrices A and B. size = len(A) C = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): C[i][j] += A[i][k] * B[k][j] return C def optimized_matrix_exponentiation(mat, n, memo=None): Computes mat^n using memoization to cache intermediate results. if n == 0: size = len(mat) return [[1 if i == j else 0 for j in range(size)] for i in range(size)] if n == 1: return mat if memo is None: memo = {} if n in memo: return memo[n] if n % 2 == 0: half_power = optimized_matrix_exponentiation(mat, n // 2, memo) result = mat_mult(half_power, half_power) else: half_power = optimized_matrix_exponentiation(mat, n // 2, memo) result = mat_mult(mat_mult(half_power, half_power), mat) memo[n] = result return result"},{"question":"# ZigZag Iterator for Multiple Lists You have been tasked to implement an iterator that cycles through multiple lists in a circular way, picking one element from each list before moving to the next list. This is a generalization of the ZigZag iterator for more than two lists. Function Definition: ```python class MultiZigZagIterator: def __init__(self, vecs: List[List[int]]): Initialize your data structure here. :param vecs: List of Lists. Each list contains integers. pass def next(self) -> int: :return: Integer element from the next list in the cycle. pass def has_next(self) -> bool: :return: Boolean value indicating whether there are any remaining elements. pass ``` Input: - `vecs`: A list of lists, where each list `vecs[i]` contains integers and 1 <= len(vecs) <= 1000. - Each list might be of any length from 0 to 1000. Output: - `next()`: Returns the next integer in the cycle. - `has_next()`: Returns `True` if there are any remaining elements; otherwise, `False`. Implementation Constraints: - Maintain the time complexity of the operations `next()` and `has_next()` as O(1). - Ensure the space complexity is O(N) where N is the total number of elements across all lists. Example Scenario: ```python vecs = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] it = MultiZigZagIterator(vecs) results = [] while it.has_next(): results.append(it.next()) print(results) # Output should be: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` Ensure your solution correctly cycles through all the lists, even if they are unevenly sized, and can handle edge cases such as one or more empty lists.","solution":"from collections import deque from typing import List class MultiZigZagIterator: def __init__(self, vecs: List[List[int]]): Initialize your data structure here. :param vecs: List of Lists. Each list contains integers. self.queue = deque() for i, vec in enumerate(vecs): if vec: self.queue.append((i, 0)) # Store the index of the list and the next index to be returned self.vecs = vecs def next(self) -> int: :return: Integer element from the next list in the cycle. if not self.queue: raise Exception(\\"No more elements\\") i, j = self.queue.popleft() val = self.vecs[i][j] if j+1 < len(self.vecs[i]): self.queue.append((i, j+1)) return val def has_next(self) -> bool: :return: Boolean value indicating whether there are any remaining elements. return bool(self.queue)"},{"question":"# Context You have been hired by an e-commerce company to optimize their product sorting algorithm. The company currently uses a basic bubble sort algorithm which is inefficient for their rapidly growing product database. Given below is an improvement, a Cocktail Shaker Sort algorithm, which is a bidirectional variant of bubble sort. # Task Write a function `cocktail_shaker_sort` in Python that sorts a given list of products by their prices in ascending order using the Cocktail Shaker Sort algorithm. # Function signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers `arr` where 1 ≤ len(arr) ≤ 1000 and each element is a non-negative integer representing the price of a product. # Output - Return a new list with the prices sorted in ascending order. # Constraints - Use the Cocktail Shaker Sort algorithm. - Ensure stable sorting. - Aim to minimize unnecessary comparisons and swaps when possible. # Example ```python >> cocktail_shaker_sort([5, 3, 8, 6, 7, 2]) [2, 3, 5, 6, 7, 8] >> cocktail_shaker_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >> cocktail_shaker_sort([10, 20, 20, 10]) [10, 10, 20, 20] ``` # Notes - You must implement the function without using the built-in sorted function. - The algorithm should handle edge cases effectively (e.g., empty list, single element list, already sorted list).","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers representing product prices in ascending order using the Cocktail Shaker Sort algorithm. if len(arr) <= 1: return arr # Lists of length 0 or 1 are already sorted n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, the list is sorted if not swapped: break # Otherwise, reset the swapped flag to check again swapped = False # Move the end point back by one, since the last element is now in place end -= 1 # Traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Move the start point forward by one, since the first element is now in place start += 1 return arr"},{"question":"You have a group of people standing in a circle. Starting with a given person, you count around the circle a fixed number of people, removing every third person in the count and continuing the process with the next person in the sequence. This continues until there is no one left. Implement a function `josephus(people: List[int], skip: int) -> List[int]` that accepts two parameters: 1. A list of integers `people` representing the individuals in the group. 2. An integer `skip` representing the number of skips (every skip-th person is removed). The function should return a list of integers representing the order in which the individuals are removed. # Input * `people`: A list of integers (1 ≤ len(people) ≤ 10^5). * `skip`: An integer (1 ≤ skip ≤ len(people)). # Output * A list of integers representing the order of removal. # Example ```python people = [1, 2, 3, 4, 5, 6, 7, 8, 9] skip = 3 # Expected output: [3, 6, 9, 4, 8, 5, 2, 7, 1] ``` # Constraints * The list may contain up to 100,000 elements. * Efficient handling of pop operations and correct index wrapping are critical for performance. # Requirements 1. Implement the logic to simulate the Josephus problem considering circular removal. 2. Ensure the function runs efficiently for large inputs. Implement the `josephus` function by following the constraints and requirements provided. # Optimized Approach (Optional) * Discuss how you might improve the implementation using a more efficient data structure such as a circular linked list. * Consider edge cases such as minimal and maximal input sizes.","solution":"from typing import List def josephus(people: List[int], skip: int) -> List[int]: Returns the order in which people are removed in the Josephus problem. result = [] index = 0 while people: index = (index + skip - 1) % len(people) result.append(people.pop(index)) return result"},{"question":"You are tasked with implementing a function that extracts the domain name from a given URL. The function needs to handle different URL structures, including those with or without protocols and \'www\'. # Function Signature: ```python def domain_name(url: str) -> str: pass ``` # Input: - `url` (str): A string representing the URL. The URL can be of various forms: - Including HTTP/HTTPS protocols (e.g., `http://`, `https://`) - With or without \'www.\' - With additional paths or query parameters after the domain. # Output: - `domain` (str): A string representing the domain name extracted from the URL. # Constraints: - The input will always be a non-empty string. - The URL will be well-formed. # Examples: ```python assert domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" assert domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" assert domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" assert domain_name(\\"https://es.wikipedia.org/wiki/Enciclopedia\\") == \\"wikipedia\\" assert domain_name(\\"http://127.0.0.1/path\\") == \\"127.0.0.1\\" assert domain_name(\\"www.example.com\\") == \\"example\\" ``` # Additional Information: - Do not use built-in libraries such as `re` (regular expressions) or `urlparse`. You can use the `.split()` built-in function for assistance. - Focus on accurately extracting the domain part under various common URL structures.","solution":"def domain_name(url: str) -> str: Extracts the domain name from a given URL. # Remove protocol if present if \\"://\\" in url: url = url.split(\\"://\\")[1] # Remove \'www.\' if present if url.startswith(\\"www.\\"): url = url[4:] # Split by \'/\' and take the first part (domain) domain = url.split(\'/\')[0] # Split by \'.\' and return the second part if it is a standard domain, otherwise return the full part domain_parts = domain.split(\'.\') # If the URL is an IP address or \'localhost\' return directly if domain_parts[0].isdigit() or \\"localhost\\" in domain: return domain return domain_parts[1] if len(domain_parts) > 2 else domain_parts[0]"},{"question":"# Interpolation Search Problem **Scenario**: You are working on a search module for a massive dataset where search operations need to be executed very quickly. The data stored is sorted and follows a roughly uniform distribution, making traditional binary searches suboptimal for expected frequent searches. **Task**: Implement an enhanced interpolation search function, `enhanced_interpolation_search`, which handles potential efficiency drawbacks more robustly. Your function should perform a fallback to binary search if the calculated position seems non-optimal based on certain heuristics you define. # Function Signature ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: pass ``` # Input - `array` (List[int]): A sorted list of integers. - `search_key` (int): The integer value to be searched within the array. # Output - Returns the index of `search_key` in `array` if found. Otherwise, returns `-1`. # Constraints - The array can contain up to (10^5) elements. - All elements in the array are integers in the range ([-10^9, 10^9]). - The search_key is also an integer in the range ([-10^9, 10^9]). # Performance Requirements - The solution must handle the average scenario efficiently, ideally performing close to O(log log n). - The solution should prevent performance degradation for non-uniformly distributed data. # Example ```python array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] search_key = 70 result = enhanced_interpolation_search(array, search_key) print(result) # Output should be 6 search_key = 25 result = enhanced_interpolation_search(array, search_key) print(result) # Output should be -1 ``` # Hints 1. Implement a hybrid approach—start with interpolation search; if the calculated position is not making progress, switch to binary search. 2. Consider edge cases like uniform arrays or arrays where interpolation search fails to make progress.","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: lo, hi = 0, len(array) - 1 while lo <= hi and search_key >= array[lo] and search_key <= array[hi]: if lo == hi: if array[lo] == search_key: return lo return -1 # Probing position using interpolation formula pos = lo + ((hi - lo) // (array[hi] - array[lo]) * (search_key - array[lo])) # If position is out of bounds, fallback to binary search if pos < lo or pos > hi: mid = (lo + hi) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: lo = mid + 1 else: hi = mid - 1 continue if array[pos] == search_key: return pos elif array[pos] < search_key: lo = pos + 1 else: hi = pos - 1 return -1"},{"question":"# Matrix Multiplication Challenge You are given a task to implement a function that performs matrix multiplication. The input consists of two matrices, and the output should be their product. Function Signature ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: pass ``` Input - `multiplicand`: A list of lists containing integers, representing the first matrix. - `multiplier`: A list of lists containing integers, representing the second matrix. Both matrices are guaranteed to be well-formed, meaning that all inner lists (rows) have the same length. Output - A list of lists containing integers, representing the product of the two matrices. Constraints - The number of columns in the `multiplicand` matrix must equal the number of rows in the `multiplier` matrix. - Matrices can be of dimensions up to 50x50. - You must handle the case where the matrices cannot be multiplied due to incompatible dimensions. Example ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] output = matrix_multiply(multiplicand, multiplier) print(output) # should print [[58, 64], [139, 154]] ``` Detailed Steps: 1. Check that the number of columns in the `multiplicand` is equal to the number of rows in the `multiplier`. If not, raise an exception. 2. Initialize a result matrix with appropriate dimensions and filled with zeros. 3. Use triple nested loops to compute the product matrix. - Iterate over each row of the `multiplicand`. - For each row, iterate over each column of the `multiplier`. - Compute the dot product and store it in the result matrix. 4. Return the resulting product matrix.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices and returns the product. Parameters: multiplicand (list of lists): The first matrix. multiplier (list of lists): The second matrix. Returns: list of lists: The product of the two matrices. # Get the dimensions of the multiplicand and multiplier rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) # Check if multiplication is possible if cols_multiplicand != rows_multiplier: raise ValueError(\\"Incompatible matrix dimensions for multiplication\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Perform the matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Question: Minimum Cost Path in a Transportation Network **Scenario**: You are working for a transportation company that needs to compute the minimum cost to travel between stations. You are given a cost matrix where the element at row ( i ) and column ( j ) represents the cost of traveling from station ( i ) to station ( j ). Note that elements where ( i > j ) are either represented by ( -1 ) or infinity as these moves are invalid (you cannot move backward). Implement a function `min_cost_path(cost)` that calculates the minimum cost to travel from station 0 to station ( N-1 ), where ( N ) is the number of stations. **Input Format**: - `cost`: a list of lists where `cost[i][j]` is the cost of traveling from station `i` to station `j`. For all `i > j`, the value can be either `-1` or infinity. **Output Format**: - Return an integer representing the minimum cost to reach the last station from the first station. If there is no valid path, return infinity or an appropriate indication. **Constraints**: - The given matrix will always have at least size 2x2. - All valid costs will be non-negative integers. - For invalid moves, the cost will be represented as ( -1 ) or `float(\'inf\')`. **Performance Requirements**: - Time complexity: ( O(n^2) ) - Space complexity: ( O(n) ) **Edge Cases to Consider**: - Ensure the function gracefully handles cases where no path exists. - Handle the smallest possible input sizes. - Ensure invalid moves (i > j) are properly ignored. # Example: ```python cost_matrix = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert min_cost_path(cost_matrix) == 65 # Output should be 65 ``` Write your function `min_cost_path(cost)` below:","solution":"def min_cost_path(cost): Returns the minimum cost to travel from station 0 to station N-1. n = len(cost) min_cost = [float(\'inf\')] * n min_cost[0] = 0 # Calculate minimum cost for each station from station 0 for i in range(n): for j in range(i + 1, n): if cost[i][j] != -1 and cost[i][j] != float(\'inf\'): if min_cost[j] > min_cost[i] + cost[i][j]: min_cost[j] = min_cost[i] + cost[i][j] return min_cost[-1]"},{"question":"# Doubly Linked List Manipulation You are tasked with implementing a set of operations on a doubly linked list. Your implementation should support the following functions: 1. `insert_head(value)`: Insert a new node with the given value at the head of the list. 2. `insert_tail(value)`: Insert a new node with the given value at the tail of the list. 3. `delete_value(value)`: Remove the first occurrence of a node with the given value. 4. `reverse()`: Reverse the entire linked list. 5. `display()`: Return a list of all values from head to tail. # Function Signature ```python class DoublyLinkedList: def __init__(self): # Initialize this linked list pass def insert_head(self, value: int): # Insert value at the head pass def insert_tail(self, value: int): # Insert value at the tail pass def delete_value(self, value: int): # Delete first occurrence of value in list pass def reverse(self): # Reverse the linked list pass def display(self) -> list: # Display the list from head to tail pass ``` # Constraints * `value` will be an integer in the range `-10^9` to `10^9`. * Multiple insertions and deletions are allowed. * Operate efficiently within reasonable memory limits and handle edge cases like an empty list. # Example ```python dll = DoublyLinkedList() dll.insert_head(10) dll.insert_tail(20) dll.insert_tail(30) print(dll.display()) # Output: [10, 20, 30] dll.delete_value(20) print(dll.display()) # Output: [10, 30] dll.reverse() print(dll.display()) # Output: [30, 10] dll.delete_value(30) dll.delete_value(10) print(dll.display()) # Output: [] ``` Your task is to complete the `DoublyLinkedList` class with the required methods, ensuring proper handling of all edge cases and efficient performance of all operations.","solution":"class Node: def __init__(self, value=None): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_head(self, value: int): new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_tail(self, value: int): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_value(self, value: int): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def reverse(self): current = self.head self.tail = current prev = None while current: next_node = current.next current.next = prev current.prev = next_node prev = current current = next_node self.head = prev def display(self) -> list: values = [] current = self.head while current: values.append(current.value) current = current.next return values"},{"question":"You are tasked with implementing a data structure that operates like a stack but maintains its elements in ascending order. The goal is to enable efficient access to the largest element at any time while preserving the stack\'s sorted state. # Task Implement the `OrderedStack` class with the following methods: 1. **`__init__()`**: Initializes an empty ordered stack. 2. **`is_empty()`**: Returns `True` if the stack is empty, otherwise `False`. 3. **`push(item: int)`**: Inserts the given `item` into the stack while maintaining ordering. 4. **`pop()`**: Removes and returns the top element of the stack. Raises `IndexError` if the stack is empty. 5. **`peek()`**: Returns the top element of the stack without removing it. Should raise `IndexError` if the stack is empty. 6. **`size()`**: Returns the number of elements in the stack. Constraints * The elements pushed into the `OrderedStack` will be integers. * The stack should handle up to `10^5` elements efficiently. Example ```python stack = OrderedStack() stack.push(5) stack.push(3) stack.push(8) stack.push(1) print(stack.pop()) # 8 print(stack.peek()) # 5 print(stack.size()) # 3 print(stack.is_empty()) # False stack.pop() stack.pop() stack.pop() print(stack.is_empty()) # True ``` Implementation Notes 1. Ensure that the `push()` operation maintains the ordering of elements using a temporary stack for displacement. 2. Handle edge cases where elements are pushed in ascending, descending, or arbitrary order.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item: int): temp_stack = [] while self.stack and self.stack[-1] > item: temp_stack.append(self.stack.pop()) self.stack.append(item) while temp_stack: self.stack.append(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): return len(self.stack)"},{"question":"You are asked to write an efficient function `next_prime` that finds the smallest prime number greater than a given integer ( n ). # Function Signature ```python def next_prime(n: int) -> int: ... ``` # Input - ( n ) (1 ≤ ( n ) ≤ ( 10^6 )): An integer ( n ) # Output - Return the smallest prime number greater than ( n ). # Constraints - Your solution should be optimized to handle the upper limit efficiently. - Consider edge cases such as when ( n ) is at the upper edge of the range, or when ( n ) is a large even number. # Example ```python assert next_prime(7) == 11 assert next_prime(10) == 11 assert next_prime(20) == 23 assert next_prime(0) == 2 assert next_prime(1) == 2 assert next_prime(1000000) == 1000003 ``` # Notes * Your implementation should utilize the `prime_check` function provided. * Optimize your search for the next prime to minimize the number of calls to `prime_check`.","solution":"def is_prime(num): Returns True if the given number is prime, else returns False. if num < 2: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def next_prime(n): Returns the smallest prime number greater than n. next_num = n + 1 while not is_prime(next_num): next_num += 1 return next_num"},{"question":"# Coding Challenge: Find the Next Higher Permutation Objective: Write a function `next_higher_number` that takes a number as input and returns the next higher number that has the exact same set of digits. If no such number exists, return `-1`. Function Signature: ```python def next_higher_number(num: int) -> int: ``` Input: * `num`: An integer (`1 <= num <= 10^9`). The number for which the next higher permutation needs to be found. Output: * An integer which is the next higher permutation of the given number if it exists, otherwise `-1`. Example: ```python assert next_higher_number(38276) == 38627 assert next_higher_number(12345) == 12354 assert next_higher_number(54321) == -1 assert next_higher_number(999) == -1 ``` Constraints: * The input number will always be positive and can have up to 9 digits. Optimization Considerations: * Aim to achieve an O(n) time complexity where n is the number of digits in the input number. * Minimize additional space usage by in-place updates where possible. Implementation Steps: 1. Convert the number to a list of its digits. 2. Find the rightmost pivot where the digit is less than its next digit. 3. If no pivot exists, return `-1` as the number is the highest permutation possible. 4. Find the rightmost successor to the pivot digit that is larger and swap them. 5. Reverse the suffix of the digits starting from the pivot point. 6. Convert the list of digits back to the integer and return.","solution":"def next_higher_number(num: int) -> int: # Convert number to list of digits digits = list(map(int, str(num))) length = len(digits) # Step 1: Find the largest index \'i\' such that digits[i] < digits[i + 1] i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such \'i\' exists, the digits are in descending order if i == -1: return -1 # Step 2: Find the largest index \'j\' such that digits[j] > digits[i] j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence from digits[i + 1] to the end digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert list of digits back to integer next_num = int(\'\'.join(map(str, digits))) return next_num"},{"question":"You are provided with an array of integers `arr`, and two optional integer limits `min_lim` and `max_lim`. Write a function to filter this array so that only elements between `min_lim` and `max_lim` (inclusive) are retained. If either limit is not provided, replace it with the minimum or maximum value present in the array respectively. Your task is to implement the function `filter_within_limits(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]`. # Input and Output Format - **Input**: - `arr`: A list of integers. - `min_lim` (optional): An integer that sets the lower threshold (inclusive). - `max_lim` (optional): An integer that sets the upper threshold (inclusive). - **Output**: A list of integers that are within the specified bounds. # Constraints - The elements of the array can be any integers, and the array can be of length 0 to 10^6. - `min_lim` and `max_lim` are optional and can be `None`. # Example ```python assert filter_within_limits([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filter_within_limits([10, 20, 30, 40, 50], 15, None) == [20, 30, 40, 50] assert filter_within_limits([1, 2, 3, 4, 5], 2, 4) == [2, 3, 4] assert filter_within_limits([1, 2, 3], None, None) == [1, 2, 3] assert filter_within_limits([], 2, 4) == [] ``` # Description of the function - You need to handle empty arrays by returning them immediately. - Use the minimum or maximum values of the array for `min_lim` or `max_lim`, respectively, if they are `None`. - Perform a single scan through the array to filter values within the limits. # Performance Requirement - Your implementation should run in O(n) time complexity, where n is the length of the array.","solution":"from typing import List, Optional def filter_within_limits(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if not arr: return [] # Assign default limits if None if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) # Filter the array return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"Scenario You are working on a geospatial analysis project where you need to analyze the sum of rainfall data over different regions of a geographical grid. The grid is represented by a square matrix, where each cell contains the rainfall measurement for that region. Given this matrix, you need to calculate the sum of rainfall for all possible sub-regions of a specified size ( k times k ). Task Write a function `sum_sub_squares(matrix, k)` that processes the given square matrix and returns a new matrix containing the sums of all ( k times k ) sub-squares. Function Signature ```python def sum_sub_squares(matrix, k): pass ``` Input 1. `matrix` (list of list of int): A 2D square matrix representing the rainfall data. ( 1 leq n leq 100 ) where `n` is the number of rows and columns in the matrix. 2. `k` (int): The size of the sub-squares to be summed. ( 1 leq k leq n ). Output - (list of list of int): A 2D matrix of size ( (n-k+1) times (n-k+1) ) containing the sums of all ( k times k ) sub-squares. Constraints - The input matrix will always be a square matrix. - If ( k > n ), return an empty list. - The elements in the matrix are all integers within the range ([-1000, 1000]). Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 # Expected Output: [ # [12, 16], # [24, 28] #] ``` Notes - Ensure that your code is efficient and can handle the upper constraint limits effectively. - Consider edge cases where ( k ) equals ( n ) or is very close to ( n ).","solution":"def sum_sub_squares(matrix, k): n = len(matrix) if k > n: return [] result = [[0] * (n - k + 1) for _ in range(n - k + 1)] for r in range(n - k + 1): for c in range(n - k + 1): sub_sum = 0 for i in range(k): for j in range(k): sub_sum += matrix[r + i][c + j] result[r][c] = sub_sum return result"},{"question":"# Pangram Checker for Extended Alphabets # Problem Statement Implement a function `is_pangram(input_string, alphabet)` that checks if the given `input_string` contains every character in the specified `alphabet` at least once. This extends the standard pangram concept to any arbitrary set of characters. Function Signature ```python def is_pangram(input_string: str, alphabet: str) -> bool: # Your code here ``` Input and Output Formats * **Input**: - `input_string` (str): A string containing the text to be checked. - `alphabet` (str): A string representing the set of characters that must be present in `input_string`. * **Output**: - (bool): Returns `True` if all characters in `alphabet` are found in `input_string`, otherwise `False`. Constraints * `1 <= len(input_string) <= 10^6` * `1 <= len(alphabet) <= 100` * Input strings can include spaces, punctuation, and other characters, which should be ignored during the check. Only the characters in `alphabet` matter. * The function must be case-insensitive. # Example ```python print(is_pangram(\\"The quick brown fox jumps over the lazy dog\\", \\"abcdefghijklmnopqrstuvwxyz\\")) # True print(is_pangram(\\"Hello World!\\", \\"helwor\\")) # True print(is_pangram(\\"Hello World!\\", \\"abcdefghijklmno\\")) # False print(is_pangram(\\"Synthetic biology is amazing!\\", \\"syntheticbio\\")) # True ``` # Performance Requirements * The function should have O(len(input_string) + len(alphabet)) time complexity and use O(len(alphabet)) additional space. * Ensure efficient processing of large `input_string` values, potentially up to 1,000,000 characters. # Edge Cases * An empty `input_string` against any non-empty `alphabet` will always return `False`. * An `alphabet` containing characters not typical in standard text (e.g., punctuation). **Note**: Consider edge cases and optimize the function for performance, ensuring that it handles large inputs gracefully.","solution":"def is_pangram(input_string: str, alphabet: str) -> bool: # Normalize the input to lower case input_string = input_string.lower() alphabet = alphabet.lower() # Create a set of all unique characters needed needed_chars = set(alphabet) # Check each character in the input string for char in input_string: if char in needed_chars: needed_chars.remove(char) if not needed_chars: return True return not needed_chars"},{"question":"# Insertion Sort with Early Termination Objective In this task, you are required to implement a function that performs an insertion sort with early termination. Early termination refers to stopping the sorting process as soon as the array is detected to be sorted. This enhancement helps reduce unnecessary operations, especially in cases where the array is nearly sorted. Instructions 1. Implement the function `insertion_sort_with_early_termination(arr, simulation=False)`: * `arr`: List of integers to sort. * `simulation` (optional): Boolean flag to print array at each iteration, for educational purposes. 2. The function should sort the array in ascending order using the insertion sort algorithm, but should stop early once it detects the array is sorted. 3. The function should return the sorted list. Additionally, if `simulation` is set to `True`, the function should print the array after each complete pass through the list. Constraints 1. The input array length `n` can be any non-negative integer. 2. Values of the elements in the array can be any integers (both positive and negative). Performance Requirement The function should attempt to minimize the number of operations by halting early if the array is already sorted during any of the passes. Input and Output Format 1. **Example Input**: `[5, 3, 1, 4, 6]` 2. **Example Output**: `[1, 3, 4, 5, 6]` Function Signature ```python def insertion_sort_with_early_termination(arr, simulation=False): pass ``` Examples: ```python # Example 1: sorted_array = insertion_sort_with_early_termination([5, 3, 1, 4, 6]) print(sorted_array) # Output: [1, 3, 4, 5, 6] # Example 2: sorted_array = insertion_sort_with_early_termination([1, 2, 3, 4, 5, 6], simulation=True) # Should print intermediate steps and finally return [1, 2, 3, 4, 5, 6] ``` Notes 1. Ensure to add necessary print statements if `simulation` is set to `True`. 2. Include early termination to improve the algorithm efficiency.","solution":"def insertion_sort_with_early_termination(arr, simulation=False): Perform an insertion sort with early termination. :param arr: List[int] - the array to be sorted :param simulation: bool - if True, print the array after each full pass :return: List[int] - the sorted array n = len(arr) for i in range(1, n): current_value = arr[i] position = i while position > 0 and arr[position - 1] > current_value: arr[position] = arr[position - 1] position -= 1 arr[position] = current_value if simulation: print(arr) # Early termination check sorted_flag = True for k in range(1, n): if arr[k - 1] > arr[k]: sorted_flag = False break if sorted_flag: break return arr"},{"question":"# Preorder Traversal Implementation **Scenario**: You are a software engineer working on a software library for tree data structures, and you need to provide functionality for traversing binary trees. One of the required functions is to return the preorder traversal of a given binary tree. **Problem Statement**: Implement a function `preorder_traversal(root: Node) -> List[int]` that performs a preorder traversal on a binary tree. **Function Signature**: ```python def preorder_traversal(root: Node) -> List[int]: pass ``` **Input**: - `root`: The root node of the binary tree, where `Node` is defined as: ```python class Node: def __init__(self, val: int, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output**: - Return a list of integers representing the preorder traversal of the binary tree. **Constraints**: - The number of nodes in the tree can be up to (10^4). - The values of the nodes are integer values and can be negative. **Example**: ```python # Example Tree: # 1 # / # 2 3 # / # 4 5 # Preorder traversal result: [1, 2, 4, 5, 3] root = Node(1, Node(2, Node(4), Node(5)), Node(3)) assert preorder_traversal(root) == [1, 2, 4, 5, 3] ``` **Considerations**: - Ensure the function works efficiently with both small and large trees. - Consider handling trees that are extremely deep to avoid exceeding maximum recursion depth.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root: Optional[Node]) -> List[int]: Performs a preorder traversal (root, left, right) of a binary tree and returns a list of the visited node values. Parameters: root (Node): The root node of the binary tree. Returns: List[int]: The list of node values in preorder traversal order. result = [] def dfs(node): if node: result.append(node.val) # Visit the root node dfs(node.left) # Traverse the left subtree dfs(node.right) # Traverse the right subtree dfs(root) return result"},{"question":"# Problem Title: Detecting Cycle in a Singly Linked List Problem Description You are given a singly linked list. Write a function to determine if the linked list has a cycle in it. Follow up: Can you solve it without using extra space? Function Signature ```python def detect_cycle(head: Node) -> bool: :param head: The head node of the singly linked list. :return: True if there is a cycle in the linked list, False otherwise. ``` Input * `head`: The head of the singly linked list. It is either a Node object or None. Output * A boolean value: `True` if there is a cycle in the linked list, `False` otherwise. Constraints * Do not use extra space beyond what is required for the linked list nodes. * The number of nodes in the list can range from 0 to (10^5). * The values of the nodes can be any integer. Example Given the following linked list: ```python 1 -> 2 -> 3 -> 4 -> 5 ^ | |_________| ``` The function `detect_cycle(head)` should return `True` because it has a cycle. Given the following linked list: ```python 1 -> 2 -> 3 -> 4 -> 5 ``` The function `detect_cycle(head)` should return `False` because it does not have a cycle. Requirements - Implement the function `detect_cycle(head)` using the Floyd\'s Tortoise and Hare algorithm. - Ensure the function handles edge cases, including empty lists and lists with single nodes.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head: Node) -> bool: Returns True if there is a cycle in the linked list, False otherwise. :param head: The head node of the singly linked list. :return: True if there is a cycle in the linked list, False otherwise. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Question You are provided with an array of integers and an integer `k`. Your task is to write a function that rotates the array to the right by `k` steps. Implement your solution using three different approaches and analyze their efficiencies. Make sure to handle edge cases effectively. Signature ```python def rotate_array_v1(array: List[int], k: int) -> List[int]: # Implement manually shifting elements k times pass def rotate_array_v2(array: List[int], k: int) -> List[int]: # Implement using reversal of segments pass def rotate_array_v3(array: List[int], k: int) -> List[int]: # Implement using slicing pass ``` Input - `array`: A list of integers, where 0 ≤ length of the array ≤ 10^5. - `k`: An integer (0 ≤ k ≤ 10^5). Output - Returns the array rotated to the right by `k` steps. Constraints - Ensure the rotation is done correctly even when `k` is larger than the length of the array. - Do not use built-in functions that perform rotation directly. Examples ```python assert rotate_array_v1([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array_v2([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array_v3([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array_v1([1, 2], 5) == [2, 1] assert rotate_array_v2([1, 2], 5) == [2, 1] assert rotate_array_v3([1, 2], 5) == [2, 1] assert rotate_array_v1([], 3) == [] assert rotate_array_v2([], 3) == [] assert rotate_array_v3([], 3) == [] ```","solution":"from typing import List def rotate_array_v1(array: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. This approach manually shifts elements k times. if not array: return array n = len(array) k %= n for _ in range(k): last = array[-1] for i in range(n-1, 0, -1): array[i] = array[i-1] array[0] = last return array def rotate_array_v2(array: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. This approach uses the reversal of segments. def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 if not array: return array n = len(array) k %= n reverse(array, 0, n-1) reverse(array, 0, k-1) reverse(array, k, n-1) return array def rotate_array_v3(array: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. This approach uses slicing. if not array: return array n = len(array) k %= n return array[-k:] + array[:-k]"},{"question":"You are tasked with implementing the integer partitioning algorithm using dynamic programming. Specifically, your role is to write a function that computes the number of ways a given positive integer can be decomposed into sums of non-negative integers. Implement the function `int_divide(decompose)` that takes a single integer parameter `decompose` and returns the count of its possible decompositions. Function Signature: ```python def int_divide(decompose: int) -> int: # Your code goes here ``` Input: - An integer `decompose` where `1 <= decompose <= 500`. Output: - An integer representing the number of ways to decompose `decompose` into sums of non-negative integers. Example: ```python int_divide(4) # Output: 5 int_divide(7) # Output: 15 ``` Explanation: For `int_divide(4)`, the decompositions are: - 4=4 - 4=3+1 - 4=2+2 - 4=2+1+1 - 4=1+1+1+1 For `int_divide(7)`, the decompositions include: - 7 = 7 - 7 = 6 + 1 - 7 = 5 + 2 - 7 = 5 + 1 + 1 - 7 = 4 + 3 - 7 = 4 + 2 + 1 - 7 = 4 + 1 + 1 + 1 - 7 = 3 + 3 + 1 - 7 = 3 + 2 + 2 - 7 = 3 + 2 + 1 + 1 - 7 = 3 + 1 + 1 + 1 + 1 - 7 = 2 + 2 + 2 + 1 - 7 = 2 + 2 + 1 + 1 + 1 - 7 = 2 + 1 + 1 + 1 + 1 + 1 - 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 Your solution should be efficient in terms of both time and space.","solution":"def int_divide(decompose: int) -> int: Returns the number of ways to partition the given integer into sums of non-negative integers using dynamic programming. dp = [0] * (decompose + 1) dp[0] = 1 for i in range(1, decompose + 1): for j in range(i, decompose + 1): dp[j] += dp[j - i] return dp[decompose]"},{"question":"# Scenario You are working on a text processing application that requires modifying the order of words in a sentence. Given a string that represents a sentence, you need to write a function to reverse the order of words. # Task Implement a function `reverse_sentence(sentence: str) -> str` that takes a sentence as input and returns the sentence with the words in reverse order. The words in the output should be separated by a single space. Ensure your function handles leading/trailing/multiple spaces effectively. # Input * `sentence` (1 ≤ |sentence| ≤ 10^4): A string of ASCII characters representing a sentence. It may contain multiple spaces. # Output * A string with the words reversed, containing exactly one space between words and no leading or trailing spaces. # Constraints 1. Maintain the words\' order as they appear in the original sentence but reversed. 2. Handle cases with multiple spaces appropriately. # Examples 1. Input: `\\"I am keon kim and I like pizza\\"` Output: `\\"pizza like I and kim keon am I\\"` 2. Input: `\\" Hello World \\"` Output: `\\"World Hello\\"` 3. Input: `\\"singleword\\"` Output: `\\"singleword\\"` 4. Input: `\\"\\"` Output: `\\"\\"` # Function Signature ```python def reverse_sentence(sentence: str) -> str: pass ``` # Performance Requirements The implementation should handle sentences efficiently within the provided constraints, minimizing additional space usage and ensuring an overall time complexity of O(n).","solution":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): The input sentence. Returns: str: The sentence with words reversed in order. # Split the sentence into words, filter out any empty strings caused by multiple spaces words = [word for word in sentence.split(\' \') if word] # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space and return the result return \' \'.join(reversed_words)"},{"question":"# Linked List Duplicate Removal You are tasked with implementing a function to remove duplicates from an unsorted linked list. Provided below are two algorithms with different time and space complexities. # Problem Description Implement two functions to remove duplicates from an unsorted singly linked list: 1. `remove_dups(head: Node) -> None`: Removes duplicates using extra storage. 2. `remove_dups_without_set(head: Node) -> None`: Removes duplicates without using extra storage. # Function Specifications 1. `remove_dups(head: Node) -> None` * **Input**: The head node of a singly linked list. * **Output**: The function should perform in-place removal of duplicates and return nothing. * **Constraints**: - The linked list contains non-null string values. - Function should run in O(N) time complexity and use O(N) additional space. 2. `remove_dups_without_set(head: Node) -> None` * **Input**: The head node of a singly linked list. * **Output**: The function performs in-place removal of duplicates and returns nothing. * **Constraints**: - The linked list contains non-null string values. - Function should run in O(N^2) time complexity but only use O(1) additional space. # Additional Requirements * Edge cases such as an empty list, a list where all nodes have the same value, and a list with no duplicates should be handled properly. * Class `Node` and `print_linked_list` helper function are already implemented and provided. # Example Usage ```python # Create linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates using extra space method remove_dups(a1) print_linked_list(a1) # Output should be: A -> B -> C -> D -> F -> G # Remove duplicates using in-place method remove_dups_without_set(a1) print_linked_list(a1) # Output should be: A -> B -> C -> D -> F -> G ``` # Notes * You should use the provided `Node` class and its structure. * Ensure your implementation efficiently handles the constraints and edge cases.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates using extra storage (set) from an unsorted linked list. if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates without using extra storage from an unsorted linked list. if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head: Node) -> None: Helper function to print the linked list values. current = head while current: print(current.val, end=\\" -> \\" if current.next else \\"n\\") current = current.next"},{"question":"# Two Unique Numbers Finder You are given an array `nums` of even length, where exactly two elements appear only once, and all the other elements appear exactly twice. Your task is to implement a function that finds these two elements that appear only once. Implement the function `find_unique_numbers(nums)` that follows the given constraints and meets the performance requirements. # Example: Suppose you are given the following array: ```python nums = [4, 1, 2, 1, 2, 6] ``` The function should return the two unique numbers: ```python [4, 6] # or [6, 4] ``` # Constraints: - The length of `nums` is even and at least 2. - The array will always contain exactly two unique numbers and all other numbers will appear exactly twice. # Implementation Requirements: 1. The function should have a time complexity of O(N). 2. The function should have a space complexity of O(1). # Function Signature: ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` # Notes: * The order of the returned result is not important, so `[unique1, unique2]` is considered the same as `[unique2, unique1]`. * You must use bitwise operations to achieve the required complexity. # Hints: 1. XOR all the elements in the list. The result will be the XOR of the two unique numbers. 2. Choose a bit that is different between the two unique numbers and use it to partition the list into two groups. 3. XOR each group separately to get the individual unique numbers.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: # Step 1: XOR all elements to get xor of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find a bit that is set in xor_all (this bit must be different between the two unique numbers) differing_bit = 1 while (xor_all & differing_bit) == 0: differing_bit <<= 1 # Step 3: Partition the elements into two groups and XOR each group to find the unique numbers unique1 = 0 unique2 = 0 for num in nums: if num & differing_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Question: Path Finding in a Directed Graph Given the classes `Node`, `DirectedEdge`, and `DirectedGraph`, write a function `find_path` that takes in a `DirectedGraph` object and two node names (start and end). This function should determine if there exists a path from the start node to the end node using Depth-First Search (DFS). If such a path exists, return the list of nodes representing the path. If no path exists, return an empty list. Function Signature: ```python def find_path(graph: DirectedGraph, start: str, end: str) -> list: pass ``` # Input * **graph**: An instance of `DirectedGraph` with nodes and edges. * **start**: A string representing the name of the start node. * **end**: A string representing the name of the end node. # Output * A list of node names representing the path from `start` to `end` if such a path exists. * An empty list if no path exists. # Constraints * The graph will contain at most 1000 nodes. * The graph can have cycles. # Example Suppose we initialize a graph as follows: ```python graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [], \'D\': [\'E\'], \'E\': [\'A\'] } graph = DirectedGraph(graph_data) ``` Given this graph: - `find_path(graph, \'A\', \'E\')` should return `[\'A\', \'B\', \'D\', \'E\']`. - `find_path(graph, \'C\', \'A\')` should return `[]`. # Implementation Notes * Consider edge cases where either start or end nodes do not exist in the graph. * Ensure the path returned is feasible within graph structure and direction of edges.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def get_neighbors(self, node): return self.adjacency_list.get(node, []) def find_path(graph: DirectedGraph, start: str, end: str) -> list: def dfs(current, goal, visited): if current in visited: return [] visited.add(current) if current == goal: return [current] for neighbor in graph.get_neighbors(current): path = dfs(neighbor, goal, visited) if path: return [current] + path visited.remove(current) return [] if start not in graph.adjacency_list or end not in graph.adjacency_list: return [] return dfs(start, end, set())"},{"question":"# Queue Implementation and Performance Testing Context You are required to implement a Queue class in two different ways: using a dynamic array and using a linked list. Both classes should follow the AbstractQueue interface. Task 1. **Implement the CircularArrayQueue class** which uses a circular array to manage the queue elements. This implementation should wrap around the array and reuse spaces freed by dequeued elements. 2. **Implement the performance testing function** that will simulate enqueue and dequeue operations to compare the performance of CircularArrayQueue, ArrayQueue, and LinkedListQueue. Detailed Instructions 1. **CircularArrayQueue Implementation** - Utilize a circular array where the enqueue and dequeue operations efficiently wrap around the array bounds. - Handle scenarios where the array needs to expand in size. - Ensure all methods (`enqueue`, `dequeue`, `peek`, `is_empty`, `size`, and `__iter__`) are correctly implemented. 2. **Performance Testing Function** - Write a function `performance_test` that does the following: * Receives a list of enqueue operations and a list of dequeue operations. * Runs these operations on instances of CircularArrayQueue, ArrayQueue, and LinkedListQueue. * Times how long it takes to complete each group of operations. * Returns the time taken for each queue implementation. Function Signatures ```python class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): # Initialize the CircularArrayQueue pass def enqueue(self, value): # Add an element to the rear of the queue pass def dequeue(self): # Remove and return the front element of the queue pass def peek(self): # Return the front element without removing it pass def __iter__(self): # Iterate elements from front to rear pass def performance_test(enqueue_operations: list, dequeue_operations: list) -> dict: # Perform timing tests on CircularArrayQueue, ArrayQueue, and LinkedListQueue pass ``` Input Constraints * `enqueue_operations` and `dequeue_operations` are lists of items to be enqueued and dequeued respectively. * The length of `dequeue_operations` does not exceed the length of `enqueue_operations` at any moment. Expected Output * The `performance_test` function should return a dictionary with the names of the queue implementations as keys and the time taken to perform the operations as values. Example Usage ```python enqueue_ops = [1, 2, 3, 4, 5] dequeue_ops = [None, None, None] # Representing calls to dequeue results = performance_test(enqueue_ops, dequeue_ops) print(results) # Output might be: # { # \'CircularArrayQueue\': 0.0001, # \'ArrayQueue\': 0.00015, # \'LinkedListQueue\': 0.00012 # } ``` Ensure your implementations are optimized for performance and handle edge cases effectively.","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * self.capacity self.size = 0 self.front = 0 self.rear = 0 def enqueue(self, value): if self.size == self.capacity: self._resize() self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") result = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return result def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def _resize(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.front = 0 self.rear = self.size def __iter__(self): index = self.front num_elements_retrieved = 0 while num_elements_retrieved < self.size: yield self.queue[index] index = (index + 1) % self.capacity num_elements_retrieved += 1 def performance_test(enqueue_operations, dequeue_operations): import time from collections import deque timings = {} # CircularArrayQueue Performance Test caq = CircularArrayQueue() start_caq = time.time() for op in enqueue_operations: caq.enqueue(op) for _ in dequeue_operations: caq.dequeue() end_caq = time.time() timings[\'CircularArrayQueue\'] = end_caq - start_caq # Simple ArrayQueue (just for comparison) class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, value): self.queue.append(value) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") return self.queue.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 aq = ArrayQueue() start_aq = time.time() for op in enqueue_operations: aq.enqueue(op) for _ in dequeue_operations: aq.dequeue() end_aq = time.time() timings[\'ArrayQueue\'] = end_aq - start_aq # LinkedListQueue Performance Test using deque from collections lq = deque() start_lq = time.time() for op in enqueue_operations: lq.append(op) for _ in dequeue_operations: lq.popleft() end_lq = time.time() timings[\'LinkedListQueue\'] = end_lq - start_lq return timings"},{"question":"# Cycle Sort Implementation and Application Introduction Cycle Sort is a comparison sorting algorithm that aims to minimize the number of write operations. This is particularly useful in scenarios where writing to memory is a costly operation. Task You are required to implement the Cycle Sort algorithm. Given an unsorted array of integers, you must return the sorted array using Cycle Sort. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr` (List[int]): An unsorted list of integers (1 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6). Output - The function should return a new list of integers sorted in ascending order. Constraints - Minimize the number of writes to the array. - Optimize the function to handle up to 100,000 integers efficiently (consider alternative algorithms if Cycle Sort proves too slow in simpler problems). Example ```python # Example 1 input: [3, 1, 5, 2, 4] output: [1, 2, 3, 4, 5] # Example 2 input: [40, 20, 50, 10, 30] output: [10, 20, 30, 40, 50] # Example 3 input: [100, 90, 80, 70, 60] output: [60, 70, 80, 90, 100] ``` Notes 1. Pay attention to edge cases where the array might be empty, already sorted, or contain duplicate values. 2. Consider performance implications on large datasets. 3. Aim for correct implementation first, then consider optimizations or alternatives if necessary.","solution":"def cycle_sort(arr): Sorts the array using Cycle Sort algorithm and returns the sorted array. writes = 0 for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item to the right position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Coding Challenge: Valid Anagram Checker **Objective**: Implement a function to determine if one string is an anagram of another. Your function should be efficient and handle edge cases appropriately. **Scenario**: You are developing a word game app. A crucial feature of the app is to check if one word is an anagram of another. An anagram is a word formed by rearranging the letters of another, such as \\"nagaram\\" from \\"anagram\\". To ensure the game works correctly, you need to implement this feature effectively. **Task**: Write a function `is_anagram(s: str, t: str) -> bool` that checks if `t` is an anagram of `s`. **Input Format**: - Two strings, `s` and `t` (1 <= len(s), len(t) <= 10^5), containing only lowercase English letters. **Output Format**: - Return `True` if `t` is an anagram of `s`, otherwise return `False`. **Constraints**: - Both strings contain only lowercase English letters. **Example**: - Example 1: - Input: `s = \\"listen\\", t = \\"silent\\"` - Output: `True` - Example 2: - Input: `s = \\"hello\\", t = \\"bello\\"` - Output: `False` **Edge Cases to Consider**: - Both strings are empty. - Both strings have different lengths. - The presence of non-alphabet characters (although this is constrained by the problem). **Requirements**: - Time Complexity: O(n), where n is the length of strings `s` and `t`. - Space Complexity: O(1) concerning the dictionary used. **Function Signature**: ```python def is_anagram(s: str, t: str) -> bool: ```","solution":"def is_anagram(s: str, t: str) -> bool: Returns True if t is an anagram of s, otherwise False. :param s: The first string. :param t: The second string. :return: Boolean indicating if t is an anagram of s. if len(s) != len(t): return False count_s = {} count_t = {} for char in s: count_s[char] = count_s.get(char, 0) + 1 for char in t: count_t[char] = count_t.get(char, 0) + 1 return count_s == count_t"},{"question":"Implement Iterative Cooley-Tukey FFT Scenario You are part of a team developing a software for real-time signal processing, which requires frequent computation of the Discrete Fourier Transform (DFT) of input signals. Due to real-time constraints, efficiency in time and space utilization is critical. The current recursive implementation of Cooley-Tukey FFT is consuming significant memory resources and you are tasked to convert this into an iterative version to improve performance. Task Write a function `iterative_fft` that computes the Discrete Fourier Transform (DFT) using the Cooley-Tukey algorithm in an iterative manner. Your implementation should avoid using recursion to optimize space complexity and should handle inputs efficiently. ```python from cmath import exp, pi def iterative_fft(x): Perform the FFT using an iterative approach. Parameters: x (list of complex): Input array of length N, where N is a power of 2. Returns: list of complex: Output DFT of the input. # Your code here # Example input and expected output example_input = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] expected_output = iterative_fft(example_input) print(expected_output) # Add other test cases to properly validate your solution ``` Input and Output Format * **Input**: A list of complex numbers with a size ( N ), where ( N ) is a power of 2 (e.g., 2, 4, 8, ...). * **Output**: The DFT of the input as a list of complex numbers. Constraints * The input size ( N ) will always be a power of 2. * Efficient use of memory is critical due to real-time system constraints. * Make sure to handle complex arithmetic accurately. Performance Requirements Your solution should ideally have a time complexity of ( O(N log N) ) and a space complexity of ( O(N) ).","solution":"from cmath import exp, pi def iterative_fft(x): Perform the FFT using an iterative approach. Parameters: x (list of complex): Input array of length N, where N is a power of 2. Returns: list of complex: Output DFT of the input. N = len(x) levels = N.bit_length() - 1 # Bit-reverse the input array indices = list(range(N)) j = 0 for i in range(1, N): bit = N >> 1 while j & bit: j ^= bit bit >>= 1 j ^= bit if i < j: indices[i], indices[j] = indices[j], indices[i] # Rearrange the input array in bit-reversed order x = [x[i] for i in indices] size = 2 while size <= N: halfsize = size >> 1 tablestep = N // size for i in range(0, N, size): k = 0 for j in range(halfsize): t = exp(-2j * pi * k / N) * x[i + j + halfsize] u = x[i + j] x[i + j] = u + t x[i + j + halfsize] = u - t k += tablestep size <<= 1 return x"},{"question":"# Question: Minimum Spanning Tree Finder You are provided with an undirected, connected graph represented as a dictionary. Each key is a node, and its value is a list of pairs (where each pair represents an adjacency list with the distance to the adjacent node and the adjacent node itself). Your task is to implement a function using Prim\'s algorithm to find the total weight of the minimum spanning tree (MST) of the graph. Write a function `prims_minimum_spanning(graph)` that takes in the following arguments: * `graph`: A dictionary where each key is a node and its value is a list of [distance, adjacent_node] pairs representing the connected nodes and the respective distances. # Input Format - `graph`: A dictionary where each key is a node identifier (string or integer), and the value is a list of lists. Each inner list contains two elements: the first is the edge weight (integer) and the second is the adjacent node identifier (string or integer). # Output Format - A single integer that represents the total weight of the minimum spanning tree. # Constraints - The graph is guaranteed to be connected. - The graph will have at least 2 nodes and at most 1000 nodes. - Edge weights will be non-negative integers. # Example *Input*: ```python graph = { \'a\': [[3, \'b\'], [8, \'c\']], \'b\': [[3, \'a\'], [5, \'d\']], \'c\': [[8, \'a\'], [2, \'d\'], [4, \'e\']], \'d\': [[5, \'b\'], [2, \'c\'], [6, \'e\']], \'e\': [[4, \'c\'], [6, \'d\']] } ``` *Output*: ```python 14 # The weight of the minimum spanning tree ``` # Notes 1. Nodes in the graph can be represented as strings or integers. 2. Handle the graph data carefully to maintain the modularity and reusability of the function.","solution":"import heapq def prims_minimum_spanning(graph): Prim\'s algorithm to find the total weight of the minimum spanning tree. Parameters: graph (dict): A dictionary where each key is a node identifier, and the value is a list of lists [edge weight, adjacent node]. Returns: int: The total weight of the minimum spanning tree. if not graph: return 0 # Start with an arbitrary node, say the first key in the dictionary start_node = next(iter(graph)) # Priority queue to select the edge with the minimum weight min_heap = [(0, start_node)] # (edge weight, vertex) total_weight = 0 visited = set() while min_heap: weight, current_node = heapq.heappop(min_heap) if current_node in visited: continue total_weight += weight visited.add(current_node) for edge_weight, neighbor in graph[current_node]: if neighbor not in visited: heapq.heappush(min_heap, (edge_weight, neighbor)) return total_weight"},{"question":"# Single Number Identification You are given an array of integers where every element appears twice except for one. Your task is to find that single unique element. Note that this also works if the unique element appears an odd number of times, while all other elements appear an even number of times. **Function Signature:** ```python def single_number(nums: List[int]) -> int: Returns the single number that appears only once. If all numbers appear twice, it should return 0. ``` **Input:** * `nums` (List[int]): A list of integers where every number except one appears twice. **Output:** * `int`: The element which appears only once in the array. If all elements appear an even number of times, return `0`. **Constraints:** 1. The list must have at least one element. 2. You may not use extra memory. 3. Your algorithm should run in linear time. **Example:** ```python assert single_number([2, 2, 1]) == 1 assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([1, 1, 2, 2]) == 0 ``` **Note:** - Ensure that your solution runs in (O(n)) time complexity and uses (O(1)) space complexity.","solution":"from typing import List def single_number(nums: List[int]) -> int: Returns the single number that appears only once. If all numbers appear an even number of times, it should return 0. # Initialize result to 0 (since XOR with 0 returns the number itself) result = 0 # XOR all numbers together for num in nums: result ^= num # Check if the result is 0, if so return 0 return result if result != 0 else 0"},{"question":"**Context**: Binary trees are widely used in various applications like expression trees, syntax trees, decision trees, and more. Preorder traversal is a method of visiting all nodes in a binary tree by visiting the root node first, followed by the left subtree, and then the right subtree. **Problem**: You are provided with the definition of a binary tree and two implementations of a binary tree preorder traversal - one iterative and one recursive. Write a function that, given the root of the binary tree, returns a list of node values in preorder traversal. # Function Signature ```python def preorder_traversal(root: Node) -> List[int]: pass ``` # Input - `root` (Node): The root node of a binary tree. Each node contains an integer value and pointers to its left and right children. # Output - `List[int]`: A list of integer values representing the preorder traversal of the binary tree. # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - -10^5 <= Node.val <= 10^5 # Example ```python # Example of binary tree construction # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) print(preorder_traversal(root)) # Output: [1, 2, 4, 5, 3] ``` **Hint**: You can use either the iterative or recursive approach. Ensure to handle the edge cases where the binary tree might be empty.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def preorder_traversal(root: Optional[Node]) -> List[int]: Perform a preorder traversal of the binary tree. root: Node - the root node of the binary tree. Returns a list of integers representing the node values in preorder traversal. if root is None: return [] result = [] stack = [root] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"# Scenario You have been hired by a software company that specializes in data validation tools. They use a variety of data structures to store and retrieve information efficiently. One of their stack-based data structures needs to be verified to ensure its elements are sorted in ascending order (from the bottom of the stack to the top). Your task is to implement a function that checks this condition without permanently altering the stack content or order. # Task Write a function `is_ascending_sorted(stack: list) -> bool` that determines if the given stack\'s elements are in ascending order from the bottom to the top. Note: The function must return the stack to its original state after performing the checks. # Input/Output Formats **Input**: A list of integers `stack` representing the stack, with the last element being the top of the stack. **Output**: A boolean value `True` if the elements are sorted in ascending order; otherwise, `False`. # Constraints - Do not use any additional libraries. - The stack contains `0 <= len(stack) <= 10^6` integers. - The integers in the stack can be in the range `-10^9` to `10^9`. # Example Example 1 **Input**: `[1, 2, 3, 4, 5, 6]` **Output**: `True` Example 2 **Input**: `[6, 3, 5, 1, 2, 4]` **Output**: `False` Example 3 **Input**: `[5]` **Output**: `True` Example 4 **Input**: `[]` **Output**: `True` Example 5 **Input**: `[1, 2, 2, 3, 4, 5]` **Output**: `True` # Implementation Requirements - Ensure your solution has a time complexity of O(n) and a space complexity of O(n). - The stack must be restored to its original order and content after the function execution.","solution":"def is_ascending_sorted(stack: list) -> bool: Returns True if the elements in the stack are sorted in ascending order from the bottom to the top. Otherwise, returns False. if not stack: # An empty stack is considered sorted return True n = len(stack) is_sorted = True for i in range(n - 1): if stack[i] > stack[i + 1]: is_sorted = False break return is_sorted"},{"question":"# Longest Palindromic Substring Problem Objective: To assess your understanding of advanced string processing algorithms, including the ability to handle preprocessing and symmetry in strings. Task: Implement a function `longest_palindromic_substring(s)` that takes a string `s` and returns the longest palindromic substring in `s`. Input: - A single string `s` where `1 <= len(s) <= 1000`. The string only contains lowercase English alphabets. Output: - A single string representing the longest palindromic substring in `s`. If there are multiple results with the same length, return the one that appears first. Constraints: - The algorithm should run in linear time, O(n). - Space complexity should be optimized to O(n). Example: ```python print(longest_palindromic_substring(\\"dasdasdasdasdasdadsa\\")) # Output: \\"asdadsa\\" print(longest_palindromic_substring(\\"acdbbdaa\\")) # Output: \\"dbbd\\" ``` Note: - Pay attention to preprocessing the input string to handle both even and odd-length palindromes. - Utilize space efficiently and avoid unnecessary computations to achieve optimal performance.","solution":"def longest_palindromic_substring(s): def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s: return \\"\\" longest = \\"\\" for i in range(len(s)): # Odd length palindrome tmp = expand_around_center(i, i) if len(tmp) > len(longest): longest = tmp # Even length palindrome tmp = expand_around_center(i, i + 1) if len(tmp) > len(longest): longest = tmp return longest"},{"question":"# Primitive Roots Finder **Objective**: Implement the function `find_primitive_root(n)` that returns a list of all primitive roots of a given positive integer n. Function Signature ```python def find_primitive_root(n: int) -> list: pass ``` Input * An integer `n` where `1 <= n <= 10^5`. Output * A list of integers representing all the primitive roots of `n`. If there are no primitive roots, the list should be empty. If `n = 1`, the list should contain the single element 0. Function Description 1. **Euler\'s Totient Function (`euler_totient(n)`)**: - This function calculates and returns the number of integers up to `n` that are coprime with `n`. ```python def euler_totient(n: int) -> int: pass ``` 2. **Order Finding Function (`find_order(a, n)`)**: - For a positive integer `n` and given integer `a` that satisfies `gcd(a, n) = 1`, find the smallest positive integer `k` such that `(a^k) % n = 1`. ```python def find_order(a: int, n: int) -> int: pass ``` 3. **Primitive Root Finding Function (`find_primitive_root(n)`)**: - Use the above two helper functions to find and return all primitive roots of `n`. **Example**: ```python assert find_primitive_root(1) == [0] assert find_primitive_root(7) == [3, 5] assert find_primitive_root(7) != [2, 4, 6] assert find_primitive_root(15) == [] assert find_primitive_root(9) == [2, 5] ``` **Constraints**: * Ensure efficiency for `n` up to `10^5`. **Performance Tips**: * Precompute and store gcd values where necessary. * Optimize the loops to minimize redundant calculations.","solution":"import math def euler_totient(n: int) -> int: Computes Euler\'s Totient Function for a given integer n. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_order(a: int, n: int) -> int: Finds the order of a modulo n. Order is the smallest integer k such that (a^k) % n == 1 if math.gcd(a, n) != 1: return -1 k = 1 current = a % n while current != 1: current = (current * a) % n k += 1 return k def find_primitive_root(n: int) -> list: Finds all primitive roots of a given positive integer n. if n == 1: return [0] phi_n = euler_totient(n) primitive_roots = [] for a in range(1, n): if math.gcd(a, n) == 1: if find_order(a, n) == phi_n: primitive_roots.append(a) return primitive_roots"},{"question":"Scenario You are developing a network analysis tool that checks if an entire network of systems (represented as nodes) is mutually reachable (i.e., from any node in the network, you can reach every other node). This task translates to determining if the given directed graph is **strongly connected**. Task Implement the `is_strongly_connected` function for the given `Graph` class. Your function should determine if the directed graph is strongly connected using Kosaraju\'s Algorithm. You are provided with a partially implemented `Graph` class. Complete the `is_strongly_connected` method according to the specifications. Input Format - A directed graph represented using the `Graph` class. - Vertices are represented as integers starting from 0 up to `vertex_count - 1`. Output Format - Return `True` if the graph is strongly connected. - Return `False` otherwise. Constraints - The number of vertices (vertex_count) is between 1 and 1000. - The number of edges is between 0 and 10000. - The graph edges are given as pairs (source, target) indicating a directed edge from source to target. Sample Input ```python g = Graph(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(0, 3) g.add_edge(3, 4) g.add_edge(4, 0) output = g.is_strongly_connected() print(output) # Expected: True ``` Sample Output ```python True ``` Detailed Explanation 1. A graph containing 5 nodes and edges such that every node is reachable from any other node. 2. The DFS traversal ensures all nodes can be reached, and reversing the graph and performing another DFS confirms the mutual reachability. Complete the `is_strongly_connected` method within the provided `Graph` class.","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.adj_list = [[] for _ in range(vertex_count)] def add_edge(self, source, target): self.adj_list[source].append(target) def _dfs(self, start_vertex, visited): Depth-First Search (DFS) to mark all reachable vertices from start_vertex stack = [start_vertex] while stack: vertex = stack.pop() if not visited[vertex]: visited[vertex] = True for neighbor in self.adj_list[vertex]: if not visited[neighbor]: stack.append(neighbor) def _transpose(self): Returns the transpose of the current graph (all edges reversed) transposed_graph = Graph(self.vertex_count) for vertex in range(self.vertex_count): for neighbor in self.adj_list[vertex]: transposed_graph.add_edge(neighbor, vertex) return transposed_graph def is_strongly_connected(self): Determines if the graph is strongly connected using Kosaraju\'s Algorithm. # Step 1: Perform DFS from any vertex (we use vertex 0 here) visited = [False] * self.vertex_count self._dfs(0, visited) # If DFS doesn\'t visit all vertices then the graph isn\'t strongly connected if not all(visited): return False # Step 2: Reverse all edges (create the transpose graph) transposed_graph = self._transpose() # Step 3: Perform DFS on the transposed graph from the same start vertex visited = [False] * transposed_graph.vertex_count transposed_graph._dfs(0, visited) # If DFS on the transposed graph doesn\'t visit all vertices then it\'s not strongly connected if not all(visited): return False return True"},{"question":"# Full Absolute Path Resolution You are required to solve a problem involving filesystem paths. Given a string representing a file path, implement a function that returns the fully resolved absolute path. This function should handle user home directory shortcuts and relative paths, converting them to a consistent, absolute format. Function Signature ```python def resolve_full_path(file_path: str) -> str: pass ``` Input - `file_path` (str): The path to be resolved. It can contain `~` for the user’s home directory and relative path components. Output - (str): The fully resolved absolute path. Constraints - The `file_path` is a valid string representation of a path on the local filesystem. - The function must handle typical edge cases like paths solely containing `~`, empty paths, or paths with multiple nested relative references like `./../`. Example ```python # Example 1 input_path = \\"~/folder/file.txt\\" output_path = \\"/Users/username/folder/file.txt\\" # Assuming the user\'s name is \'username\' assert resolve_full_path(input_path) == output_path # Example 2 input_path = \\"../folder/file.txt\\" output_path = \\"/absolute/path/to/current/working/directory/folder/file.txt\\" # Based on the current working directory assert resolve_full_path(input_path) == output_path # Example 3 input_path = \\"./file.txt\\" output_path = \\"/absolute/path/to/current/working/directory/file.txt\\" # Based on the current working directory assert resolve_full_path(input_path) == output_path # Example 4 input_path = \\"\\" output_path = \\"/absolute/path/to/current/working/directory\\" assert resolve_full_path(input_path) == output_path ``` Notes - Do not worry about validating the existence of the file at the resolved path. - Ensure proper handling of edge cases and system-specific path separators.","solution":"import os def resolve_full_path(file_path: str) -> str: Given a file path, this function returns the fully resolved absolute path. It handles `~` for the home directory and relative paths. # Expand the ~ to the full path of the home directory expanded_path = os.path.expanduser(file_path) # Get the absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Question: Implement and Optimize Binary Search with Edge Case Handling Objective Implement the binary search algorithm in both iterative and recursive forms with additional functionality to handle arrays with non-distinct (repeated) values. Ensure your implementation also properly addresses common edge cases. Prompt Given a sorted array (which can contain repeated elements) and a target value, write two functions: `binary_search_iterative` and `binary_search_recursive` that return the index of the first occurrence of the target value. If the target value isn\'t found, return `-1`. Additionally, handle edge cases like empty arrays. Function Signatures ```python def binary_search_iterative(array: List[int], target: int) -> int: # Your code here def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: # Your code here ``` Input * `array` (List[int]): A sorted list of integers (may contain duplicates). * `target` (int): The integer value to search for in the list. Output * Returns the index (int) of the first occurrence of the target value if found. Otherwise, returns `-1`. Constraints * 0 <= len(array) <= 10^5 * -10^9 <= array[i], target <= 10^9 Examples ```python array = [1, 2, 4, 4, 4, 5, 6] target = 4 # Expected Outputs print(binary_search_iterative(array, target)) # Output: 2 print(binary_search_recursive(array, 0, len(array) - 1, target)) # Output: 2 # Edge cases print(binary_search_iterative([], target)) # Output: -1 print(binary_search_recursive([], 0, -1, target)) # Output: -1 ``` # Solution Requirements * Efficiently handle the edge cases mentioned above. * Ensure the solution has logarithmic time complexity. * Handle arrays with repeated values and return the first occurrence of the target value.","solution":"from typing import List def binary_search_iterative(array: List[int], target: int) -> int: low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: result = mid high = mid - 1 elif array[mid] < target: low = mid + 1 else: high = mid - 1 return result def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: result_left = binary_search_recursive(array, low, mid - 1, target) return mid if result_left == -1 else result_left elif array[mid] < target: return binary_search_recursive(array, mid + 1, high, target) else: return binary_search_recursive(array, low, mid - 1, target)"},{"question":"You are tasked with implementing a key functionality for a DirectedGraph class which includes the ability to find all strongly connected components (SCCs) in the graph. A strongly connected component is a maximal subgraph in which every node is reachable from every other node in the subgraph. # Task Implement a method in the `DirectedGraph` class named `find_strongly_connected_components` that returns a list of SCCs. Each SCC should be represented as a list of node names. ```python class DirectedGraph: # Existing implementation def find_strongly_connected_components(self): Finds and returns all strongly connected components (SCCs) in the graph. :return: List of SCCs, where each SCC is represented as a list of node names. # Your implementation here ``` # Input Format * There is no direct input format as you will work within the `find_strongly_connected_components` method of the `DirectedGraph` class. # Output Format * The method should return a list of lists. Each inner list represents a strongly connected component and contains the names of the nodes in that component. # Constraints * The graph can have at most 10^3 nodes. * The nodes are named with unique strings. * The graph may contain cycles and self-loops. # Performance Requirements * The implementation should aim for an O(V + E) time complexity using Kosaraju\'s algorithm or Tarjan\'s algorithm for finding SCCs. # Example Consider that the graph is given as: ```python load_dict = { \'A\': [\'B\'], \'B\': [\'C\', \'E\', \'F\'], \'C\': [\'D\', \'G\'], \'D\': [\'C\', \'H\'], \'E\': [\'A\', \'F\'], \'F\': [\'G\'], \'G\': [\'F\'], \'H\': [\'D\', \'G\'] } graph = DirectedGraph(load_dict) # Invoking the method sccs = graph.find_strongly_connected_components() # Expected Output # sccs should contain lists of node names that form strongly connected components. # Possible output: [[\'A\', \'B\', \'E\'], [\'C\', \'D\', \'H\'], [\'F\', \'G\']] ``` # Note * The nodes within each SCC can be in any order. * The method should handle all edge cases discussed in the analysis.","solution":"class DirectedGraph: def __init__(self, graph_dict=None): if graph_dict is None: graph_dict = {} self.graph = graph_dict def find_strongly_connected_components(self): Finds and returns all strongly connected components (SCCs) in the graph. :return: List of SCCs, where each SCC is represented as a list of node names. stack = [] low = {} indices = {} on_stack = {} sccs = [] index = 0 def strongconnect(node): nonlocal index indices[node] = index low[node] = index index += 1 stack.append(node) on_stack[node] = True # Consider successors of \'node\' for successor in self.graph.get(node, []): if successor not in indices: # successor has not yet been visited; recurse on it strongconnect(successor) low[node] = min(low[node], low[successor]) elif on_stack[successor]: # successor is in stack and hence in the current SCC low[node] = min(low[node], indices[successor]) # If \'node\' is a root node, pop the stack and generate an SCC if low[node] == indices[node]: scc = [] while True: successor = stack.pop() on_stack[successor] = False scc.append(successor) if successor == node: break sccs.append(scc) # Start with every node for node in self.graph: if node not in indices: strongconnect(node) return sccs"},{"question":"You are tasked with implementing a function to sort a list using the Selection Sort algorithm. Additionally, to help with debugging and understanding the sorting process, your implementation should optionally print the array at each iteration as it gets sorted. # Requirements - Implement a function `selection_sort(arr, simulation=False)` that performs the Selection Sort on the list `arr`. - The function should accept a boolean parameter `simulation`. If `simulation` is `True`, the function should print the state of the list after each iteration. # Input - `arr`: A list of integers. - `simulation`: A boolean value (`True` or `False`). # Output - The function should not return anything. It should sort the list in-place. # Constraints - The elements of the array are integers. - The length of the array can be 0 ≤ len(arr) ≤ 1000. - The values in the array are within the range of -10^6 to 10^6. # Example ```python arr = [64, 25, 12, 22, 11] selection_sort(arr, simulation=True) ``` Output: ``` iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 ``` # Task Write the function `selection_sort(arr, simulation=False)` as described above.","solution":"def selection_sort(arr, simulation=False): Performs the Selection Sort on the list `arr`. Parameters: arr (list of int): The list to be sorted. simulation (bool): Whether to print the list after each iteration. n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] # Print the array at each iteration if simulation is True if simulation: print(f\\"iteration {i} :\\", \\" \\".join(map(str, arr)))"},{"question":"Given a string `s` and two other strings, `part1` and `part2`, write a function `validate_interleave(s, part1, part2)` that will return `True` if `s` can be formed by interleaving `part1` and `part2` while preserving the relative order of characters in `part1` and `part2`, otherwise return `False`. # Function Signature ```python def validate_interleave(s: str, part1: str, part2: str) -> bool: ``` # Input * `s` (1 <= len(s) <= 100): The target string to form by interleaving. * `part1` (0 <= len(part1) <= 100): First part of the string. * `part2` (0 <= len(part2) <= 100): Second part of the string. # Output * Return `True` if `s` can be formed by interleaving `part1` and `part2` as described, otherwise `False`. # Constraints * All strings will contain only lowercase English letters. # Examples ```python assert validate_interleave(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert validate_interleave(\\"abcde\\", \\"abc\\", \\"de\\") == True assert validate_interleave(\\"abc\\", \\"abc\\", \\"\\") == True assert validate_interleave(\\"abc\\", \\"\\", \\"abc\\") == True assert validate_interleave(\\"abcd\\", \\"ab\\", \\"bc\\") == False ``` # Explanation 1. The function must check if `s` can be an interleaving of `part1` and `part2` with the characters in `part1` and `part2` preserving their order. 2. For example, to record `s` = \\"codewars\\" using \\"cdw\\" and \\"oears\\": * \\"cdw\\" contributes \'c\', \'d\', and \'w\'. * \\"oears\\" interleaves to provide \'o\', \'e\', \'a\', \'r\', and \'s\'. 3. Incorporate an efficient method (e.g., dynamic programming) within provided constraints to ensure the solution is both time and space effective. # Task Implement the function `validate_interleave` following the specified requirements and constraints.","solution":"def validate_interleave(s: str, part1: str, part2: str) -> bool: Check if s can be formed by interleaving part1 and part2 while preserving the relative order of characters. m, n = len(part1), len(part2) if len(s) != m + n: return False dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for i in range(1, m + 1): dp[i][0] = dp[i - 1][0] and part1[i - 1] == s[i - 1] for j in range(1, n + 1): dp[0][j] = dp[0][j - 1] and part2[j - 1] == s[j - 1] for i in range(1, m + 1): for j in range(1, n + 1): dp[i][j] = (dp[i - 1][j] and part1[i - 1] == s[i + j - 1]) or (dp[i][j - 1] and part2[j - 1] == s[i + j - 1]) return dp[m][n]"},{"question":"# Question: Problem Statement: You are given a non-negative number represented as an array of digits. The digits are stored in big-endian format, such that the most significant digit is at the head of the list. Write a function `plus_one(digits)` which adds one to the number and returns the resulting list of digits. Input: * `digits` (List[int]): A list of integers where each integer represents a digit of the number. The list has at least one element, and all elements are in the range 0 to 9. Output: * List[int]: The resulting list of digits after adding one to the number. Constraints: * Do not use the any built-in big integer libraries or functions. * You must handle the carry propagation correctly. * The input list should remain unchanged for the function to be considered correct (i.e., the function should return a new list). Example: ```python plus_one([1, 2, 3]) # Output: [1, 2, 4] plus_one([9, 9, 9]) # Output: [1, 0, 0, 0] plus_one([0]) # Output: [1] ``` Performance Requirements: * The time complexity should be O(n), where n is the length of the input list. * The space complexity should preferably be O(n) to create a new list. Implement the function below in Python: ```python def plus_one(digits): # Your code here pass ```","solution":"def plus_one(digits): Adds one to the number represented by the list of digits. Args: digits (List[int]): List of digits representing a non-negative number. Returns: List[int]: List of digits after adding one to the number. n = len(digits) result = digits[:] for i in range(n-1, -1, -1): if result[i] < 9: result[i] += 1 return result result[i] = 0 return [1] + result"},{"question":"# Question You are required to implement the Counting Sort algorithm for an array of integers. Counting Sort is efficient for sorting arrays when the range of the integers (difference between the maximum and minimum) is not significantly larger than the number of elements. Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: ``` Input - **arr**: A list of integers (at least one element). The list can contain both negative and positive integers. Output - Returns a new list containing the elements of `arr` sorted in non-decreasing order. Constraints - The length of `arr` ( leq 10^5 ). - The elements of `arr` can range from (-10^6) to (10^6). Example ```python print(counting_sort([4, 2, -3, 6, -2, 1])) # Output: [-3, -2, 1, 2, 4, 6] print(counting_sort([1, 4, 1, 2, 7, 5, 2])) # Output: [1, 1, 2, 2, 4, 5, 7] print(counting_sort([-5, -1, -2, -2, 3, 6])) # Output: [-5, -2, -2, -1, 3, 6] ``` Detailed Requirements 1. **Edge Cases**: Consider scenarios with very small (including empty after stipulated minimum one) or very large input size, single-element lists, and arrays with all identical elements. 2. **Performance**: Ensure the algorithm runs efficiently within the given constraints. Hint 1. Use a temporary array (i.e., count array) to save the counts of unique elements. 2. Adjust the index to handle negative numbers correctly.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the counting sort algorithm. if not arr: return arr # Find the minimum and maximum the elements in the array min_elem = min(arr) max_elem = max(arr) # Create the count array count_range = max_elem - min_elem + 1 count_array = [0] * count_range # Populate the count array for num in arr: count_array[num - min_elem] += 1 # Reconstruct the sorted array sorted_arr = [] for i, count in enumerate(count_array): sorted_arr.extend([i + min_elem] * count) return sorted_arr"},{"question":"# Question: Find the First Occurrence with Linear Search You are provided with an unsorted array of integers. Your task is to implement a function using the linear search algorithm to find the first occurrence of a given integer in this array. Function Signature ```python def find_first_occurrence(array, query): Find the index of the first occurrence of the given integer in the array. Parameters: array (list of int): An unsorted array of integers. query (int): The integer you need to find in the array. Returns: int: The index of the first occurrence of the given integer in the array. If the integer is not in the array, return -1. ``` # Input * `array`: A list of integers. (0 <= len(array) <= 10^6) * `query`: An integer which needs to be searched in the array. # Output * Return the index of the first occurrence of the query integer in the array. * If the query integer is not found, return -1. # Constraints * You may assume every integer within the array and the query fits within the bounds of a standard 32-bit signed integer. * The array can be empty, containing zero integers. # Examples ```python assert find_first_occurrence([10, 20, 10, 30, 40], 10) == 0 assert find_first_occurrence([10, 20, 10, 30, 40], 30) == 3 assert find_first_occurrence([10, 20, 10, 30, 40], 50) == -1 assert find_first_occurrence([], 10) == -1 assert find_first_occurrence([1, 2, 3, 4, 5], 5) == 4 assert find_first_occurrence([1, 1, 1, 1, 1], 1) == 0 ``` # Performance Requirements Your solution should efficiently handle arrays up to the size of 1,000,000 elements within an acceptable time frame.","solution":"def find_first_occurrence(array, query): Find the index of the first occurrence of the given integer in the array. Parameters: array (list of int): An unsorted array of integers. query (int): The integer you need to find in the array. Returns: int: The index of the first occurrence of the given integer in the array. If the integer is not in the array, return -1. for index, value in enumerate(array): if value == query: return index return -1"},{"question":"# Question: Modular Extended Factorial Sum You are given an array of non-negative integers. Your task is to write a function `modular_factorial_sum(arr, mod=None)` that calculates the sum of the factorial of each element in the array. If a modulo `mod` is provided, it should return the sum modulo `mod`. The function should use an iterative approach for calculating factorials to avoid stack overflow issues with large arrays. # Input * `arr`: List of non-negative integers. * `mod`: An optional positive integer for modulo operation (default is None). # Output * Returns an integer representing the sum of factorials of the elements in the array. If `mod` is specified, returns the sum modulo `mod`. # Constraints * Each element in `arr` is a non-negative integer (`0 <= arr[i] <= 10000`) * Length of array `arr` is between `1` and `1000` inclusive. * If `mod` is specified, `mod` is a positive integer. # Requirements * Solution should handle large values efficiently. * Raise a `ValueError` if input constraints are violated. # Example ```python >>> modular_factorial_sum([3, 4, 5]) 152 # 3! + 4! + 5! = 6 + 24 + 120 = 150 >>> modular_factorial_sum([3, 4, 5], 10) 2 # (3! + 4! + 5!) % 10 = 150 % 10 = 0 ``` Write the function `modular_factorial_sum`: ```python def modular_factorial_sum(arr, mod=None): # Your implementation here pass ```","solution":"def modular_factorial_sum(arr, mod=None): Calculate the sum of the factorial of each element in the array. If a modulo `mod` is provided, return the sum modulo `mod`. # Check input constraints if not isinstance(arr, list) or len(arr) < 1 or len(arr) > 1000: raise ValueError(\\"Array length must be between 1 and 1000 inclusive.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer.\\") # Helper function to calculate factorial iteratively def factorial(n): if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result # Calculate the sum of factorials factorial_sum = sum(factorial(x) for x in arr) # Apply modulo operation if provided if mod is not None: factorial_sum %= mod return factorial_sum"},{"question":"You are given a string which may contain multiple words separated by spaces. Your goal is to reverse the order of words in the given string while maintaining the spaces between them. Write a function `reverse_words_with_spaces` that takes a string as input and returns the string with the words in reversed order but preserving the spaces exactly as they appeared in the original string. # Function Signature ```python def reverse_words_with_spaces(string: str) -> str: # Your implementation here ``` # Input and Output Formats * **Input**: A string `string` of length ( n ) which may include multiple spaces between words and/or leading/trailing spaces. * **Output**: A new string which has the words in reversed order with the original spaces preserved. # Constraints * The input string may contain uppercase and lowercase English letters, spaces, and punctuation. * The input string length will be in the range of ([1, 10^5]). # Examples Example 1: ```python input_string = \\" Hello World \\" output_string = \\" World Hello \\" assert reverse_words_with_spaces(input_string) == output_string ``` Example 2: ```python input_string = \\"I am programming\\" output_string = \\"programming am I\\" assert reverse_words_with_spaces(input_string) == output_string ``` Example 3: ```python input_string = \\" SingleWord\\" output_string = \\" SingleWord\\" assert reverse_words_with_spaces(input_string) == output_string ``` # Performance Requirements * The function should have a time complexity of O(n). * The function should have a space complexity of O(n).","solution":"def reverse_words_with_spaces(string: str) -> str: Reverses the words in the input string while preserving the spaces. Args: - string (str): Input string containing words and spaces. Returns: - str: String with words in reversed order preserving the spaces. # Split the string by spaces to get words words = string.split() # Join the words in reversed order while using \'split\' which ignores extra spaces reversed_words = \' \'.join(words[::-1]) # Traverse the original string and construct the final result by maintaining spaces result = [] word_index = 0 ri = 0 # reversed_words index i = 0 while i < len(string): if string[i] == \' \': result.append(\' \') i += 1 else: start = i while i < len(string) and string[i] != \' \': i += 1 if word_index < len(words): word = words[word_index] result.append(words[::-1][word_index]) word_index += 1 ri += len(word) return \'\'.join(result)"},{"question":"You are given an array of integers and two optional boundary values, `min_lim` and `max_lim`. Your task is to write a function `filtered_array(arr, min_lim=None, max_lim=None)` that returns a list of integers from the input array that fall between the given boundary values, inclusive. If a boundary value is not provided (i.e., it is None), it should act as unbounded from that side. # Function Signature ```python def filtered_array(arr: list[int], min_lim: int=None, max_lim: int=None) -> list[int]: pass ``` # Input - `arr`: A list of integers. - `min_lim`: An optional integer representing the minimum boundary limit. - `max_lim`: An optional integer representing the maximum boundary limit. # Output - A list of integers from the input array that are between `min_lim` and `max_lim`, inclusive of the boundaries. # Example ```python assert filtered_array([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filtered_array([10, 15, 20, 25, 30], 20, None) == [20, 25, 30] assert filtered_array([5, 8, 12, 14, 18], 10, 15) == [12, 14] assert filtered_array([], 1, 10) == [] assert filtered_array([1, 2, 3, 4, 5], 6, 10) == [] ``` # Constraints - The input array will contain integers in the range from -1000 to 1000. - Size of the array can be between 0 to 10^6 elements. # Note - If both `min_lim` and `max_lim` are `None`, the function should return the input array as is. - Ensure that your solution efficiently handles large input sizes up to 10^6 elements. Implement this function and ensure it returns the correct results as described in the examples and notes.","solution":"def filtered_array(arr, min_lim=None, max_lim=None): Filters the array based on optional minimum and maximum limits. Parameters: arr (list[int]): The input array of integers. min_lim (int, optional): The minimum boundary limit. max_lim (int, optional): The maximum boundary limit. Returns: list[int]: A list of integers from the input array that are between min_lim and max_lim, inclusive. if min_lim is None and max_lim is None: return arr elif min_lim is None: return [x for x in arr if x <= max_lim] elif max_lim is None: return [x for x in arr if x >= min_lim] else: return [x for x in arr if min_lim <= x <= max_lim]"}]'),S={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},L={class:"card-container"},F={key:0,class:"empty-state"},z=["disabled"],R={key:0},j={key:1};function Y(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",j,"Loading...")):(n(),i("span",R,"See more"))],8,z)):u("",!0)])}const P=c(S,[["render",Y],["__scopeId","data-v-69a032bb"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/43.md","filePath":"drive/43.md"}'),D={name:"drive/43.md"},U=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
