import{_ as c,o as s,c as n,a as t,m,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as w,q as v}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},N={class:"review-title"},L={class:"review-content"};function A(r,e,u,_,i,a){return s(),n("div",k,[t("div",T,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const S=c(q,[["render",A],["__scopeId","data-v-5025fd23"]]),R=JSON.parse(`[{"question":"def maximalRectangle(matrix): Find the largest rectangle containing only 1s in a grid. :param matrix: List of list of integers representing the grid :return: Integer representing the area of the largest rectangle containing only 1s >>> maximalRectangle([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) 6 >>> maximalRectangle([[0, 1], [1, 1]]) 2 >>> maximalRectangle([[0, 0], [0, 0]]) 0 >>> maximalRectangle([[1, 1, 1, 0], [1, 1, 1, 1]]) 6 >>> maximalRectangle([[1]]) 1 >>> maximalRectangle([[0]]) 0","solution":"def maximalRectangle(matrix): Find the largest rectangle containing only 1s in a grid. :param matrix: List of list of integers representing the grid :return: Integer representing the area of the largest rectangle containing only 1s if not matrix: return 0 # Preparation step: getting the dimensions of the matrix nrows = len(matrix) ncols = len(matrix[0]) # Initialize heights array to keep track of heights of '1's heights = [0] * ncols max_area = 0 for row in matrix: for col in range(ncols): if row[col] == 0: heights[col] = 0 else: heights[col] += 1 max_area = max(max_area, max_histogram_area(heights)) return max_area def max_histogram_area(heights): Finds the maximum rectangular area under given histogram heights. :param heights: List of integers representing the histogram heights :return: Integer representing the maximum rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class MovieRental: def __init__(self): Initialize the rental system. def addMovie(self, userId, movieId): Add a movie to the user's cart. :param userId: the ID of the user :param movieId: the ID of the movie def rentMovies(self, userId): Rent all the movies currently in the user's cart. :param userId: the ID of the user def getRentalHistory(self, userId): Retrieve the list of movies rented by the user in the past. :param userId: the ID of the user :return: a list of movie IDs from solution import MovieRental def test_add_movie(): rental = MovieRental() rental.addMovie(1, 101) assert rental.carts == {1: [101]} rental.addMovie(1, 102) assert rental.carts == {1: [101, 102]} def test_rent_movies(): rental = MovieRental() rental.addMovie(1, 101) rental.addMovie(1, 102) rental.rentMovies(1) assert rental.carts == {1: []} assert rental.history == {1: [101, 102]} def test_get_rental_history(): rental = MovieRental() rental.addMovie(1, 101) rental.addMovie(1, 102) rental.rentMovies(1) assert rental.getRentalHistory(1) == [101, 102] rental.addMovie(1, 103) assert rental.getRentalHistory(1) == [101, 102] rental.rentMovies(1) assert rental.getRentalHistory(1) == [101, 102, 103] def test_empty_cart(): rental = MovieRental() rental.rentMovies(1) # Renting without adding any movie assert rental.carts == {} def test_no_rental_history(): rental = MovieRental() assert rental.getRentalHistory(1) == []","solution":"class MovieRental: def __init__(self): self.carts = {} self.history = {} def addMovie(self, userId, movieId): if userId not in self.carts: self.carts[userId] = [] self.carts[userId].append(movieId) def rentMovies(self, userId): if userId in self.carts and self.carts[userId]: if userId not in self.history: self.history[userId] = [] self.history[userId].extend(self.carts[userId]) self.carts[userId] = [] def getRentalHistory(self, userId): return self.history.get(userId, [])"},{"question":"def xor_cipher(string, keys): Encodes and decodes a string using XOR with the given keys in a round-robin fashion. Args: string: The string to be encoded/decoded. keys: The list of keys (integers) to use for XOR operation. Returns: The encoded/decoded string. ... def main(encoding_string, keys): Encodes and decodes the given string using the Xor Cipher with the specified keys. Args: encoding_string: The string to be encoded/decoded. keys: The list of keys (integers) to use for XOR operation. Returns: A tuple (encoded_string, decoded_string), where encoded_string is the result of encoding the original string and decoded_string is the result of decoding the encoded string. ... # Example usage if __name__ == \\"__main__\\": n = 3 keys = [4, 5, 6] encoding_string = \\"hello\\" encoded_string, decoded_string = main(encoding_string, keys) print(f\\"Encoded String: {encoded_string}\\") print(f\\"Decoded String: {decoded_string}\\")","solution":"def xor_cipher(string, keys): Encodes and decodes a string using XOR with the given keys in a round-robin fashion. Args: string: The string to be encoded/decoded. keys: The list of keys (integers) to use for XOR operation. Returns: The encoded/decoded string. result = [] key_length = len(keys) for i, char in enumerate(string): xor_value = ord(char) ^ keys[i % key_length] result.append(chr(xor_value)) return ''.join(result) def main(encoding_string, keys): # Encoding the string encoded_string = xor_cipher(encoding_string, keys) # Decoding the string (decoding is the same as encoding with XOR) decoded_string = xor_cipher(encoded_string, keys) return encoded_string, decoded_string # Example usage if __name__ == \\"__main__\\": n = 3 keys = [4, 5, 6] encoding_string = \\"hello\\" encoded_string, decoded_string = main(encoding_string, keys) print(f\\"Encoded String: {encoded_string}\\") print(f\\"Decoded String: {decoded_string}\\")"},{"question":"def smallestNumberAfterDeletingOneDigit(S: str) -> str: Finds the smallest number that can be obtained by deleting exactly one digit from the given string S. :param S: A string consisting of digits 0-9 :return: The smallest number as a string after deleting one digit >>> smallestNumberAfterDeletingOneDigit(\\"132\\") == \\"12\\" >>> smallestNumberAfterDeletingOneDigit(\\"1001\\") == \\"001\\" # Returns '1' after leading zeros handling >>> smallestNumberAfterDeletingOneDigit(\\"10\\") == \\"0\\" >>> smallestNumberAfterDeletingOneDigit(\\"1234\\") == \\"123\\" >>> smallestNumberAfterDeletingOneDigit(\\"22222\\") == \\"2222\\" >>> smallestNumberAfterDeletingOneDigit(\\"10987654321\\") == \\"0987654321\\" >>> smallestNumberAfterDeletingOneDigit(\\"9876543210\\") == \\"876543210\\" >>> smallestNumberAfterDeletingOneDigit(\\"300\\") == \\"00\\" # Which is effectively '0' after removing leading zeros >>> smallestNumberAfterDeletingOneDigit(\\"110\\") == \\"10\\" >>> smallestNumberAfterDeletingOneDigit(\\"210\\") == \\"10\\"","solution":"def smallestNumberAfterDeletingOneDigit(S): Finds the smallest number that can be obtained by deleting exactly one digit from the given string S. :param S: A string consisting of digits 0-9 :return: The smallest number as a string after deleting one digit smallest_number = S[:-1] # Initialize with removing the last digit for i in range(len(S)): candidate = S[:i] + S[i+1:] if candidate < smallest_number: smallest_number = candidate return smallest_number"},{"question":"def areUnique(registration_numbers): Returns True if all registration numbers are unique, otherwise False. Args: registration_numbers (list of int): List of registration numbers. Returns: bool: True if all registration numbers are unique, False otherwise.","solution":"def areUnique(registration_numbers): Returns True if all registration numbers are unique, otherwise False. Args: registration_numbers (list of int): List of registration numbers. Returns: bool: True if all registration numbers are unique, False otherwise. return len(registration_numbers) == len(set(registration_numbers))"},{"question":"def moderate_chat(n:int, inappropriate_words:List[str], m:int, messages:List[str]) -> List[str]: Moderates chat messages by replacing inappropriate words with asterisks. :param n: int, the number of inappropriate words :param inappropriate_words: list of inappropriate words :param m: int, the number of messages :param messages: list of messages :return: list of moderated messages >>> moderate_chat(3, [\\"bad\\", \\"ugly\\", \\"nasty\\"], 5, [\\"This is a bad word!\\", \\"Such an ugly behavior.\\", \\"This message is clean.\\", \\"Another nasty comment.\\", \\"Nothing inappropriate here.\\"]) [\\"This is a *** word!\\", \\"Such an **** behavior.\\", \\"This message is clean.\\", \\"Another ***** comment.\\", \\"Nothing inappropriate here.\\"] >>> moderate_chat(2, [\\"bad\\", \\"nasty\\"], 3, [\\"This BAD word is inappropriate.\\", \\"The nasty comment.\\", \\"Clean message.\\"]) [\\"This *** word is inappropriate.\\", \\"The ***** comment.\\", \\"Clean message.\\"] >>> moderate_chat(1, [\\"blip\\"], 2, [\\"This message is clean.\\", \\"Nothing to remove here.\\"]) [\\"This message is clean.\\", \\"Nothing to remove here.\\"] from typing import List def test_moderate_chat(): n = 3 inappropriate_words = [\\"bad\\", \\"ugly\\", \\"nasty\\"] m = 5 messages = [ \\"This is a bad word!\\", \\"Such an ugly behavior.\\", \\"This message is clean.\\", \\"Another nasty comment.\\", \\"Nothing inappropriate here.\\" ] expected_output = [ \\"This is a *** word!\\", \\"Such an **** behavior.\\", \\"This message is clean.\\", \\"Another ***** comment.\\", \\"Nothing inappropriate here.\\" ] assert moderate_chat(n, inappropriate_words, m, messages) == expected_output def test_moderate_chat_with_case_insensitivity(): n = 2 inappropriate_words = [\\"bad\\", \\"nasty\\"] m = 3 messages = [ \\"This BAD word is inappropriate.\\", \\"The nasty comment.\\", \\"Clean message.\\" ] expected_output = [ \\"This *** word is inappropriate.\\", \\"The ***** comment.\\", \\"Clean message.\\" ] assert moderate_chat(n, inappropriate_words, m, messages) == expected_output def test_moderate_chat_no_inappropriate_words(): n = 1 inappropriate_words = [\\"blip\\"] m = 2 messages = [ \\"This message is clean.\\", \\"Nothing to remove here.\\" ] expected_output = [ \\"This message is clean.\\", \\"Nothing to remove here.\\" ] assert moderate_chat(n, inappropriate_words, m, messages) == expected_output","solution":"def moderate_chat(n, inappropriate_words, m, messages): Moderates chat messages by replacing inappropriate words with asterisks. :param n: int, the number of inappropriate words :param inappropriate_words: list of inappropriate words :param m: int, the number of messages :param messages: list of messages :return: list of moderated messages def replace_inappropriate_words(message, inappropriate_words): words = message.split() for i, word in enumerate(words): if word.lower() in inappropriate_words: words[i] = '*' * len(word) return ' '.join(words) inappropriate_words_set = set(inappropriate_words) moderated_messages = [replace_inappropriate_words(message, inappropriate_words_set) for message in messages] return moderated_messages # Example usage n = 3 inappropriate_words = [\\"bad\\", \\"ugly\\", \\"nasty\\"] m = 5 messages = [ \\"This is a bad word!\\", \\"Such an ugly behavior.\\", \\"This message is clean.\\", \\"Another nasty comment.\\", \\"Nothing inappropriate here.\\" ] result = moderate_chat(n, inappropriate_words, m, messages) for line in result: print(line)"},{"question":"def minPathSum(grid): Returns the minimum sum of all numbers along its path from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. Example: >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathSum([ ... [1, 2, 3], ... [4, 5, 6] ... ]) 12","solution":"def minPathSum(grid): Returns the minimum sum of all numbers along its path from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row and the first column of the grid. for i in range(1, m): grid[i][0] += grid[i-1][0] for j in range(1, n): grid[0][j] += grid[0][j-1] # Populate the rest of the grid with the minimum path sum values. for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) # The bottom-right corner contains the result. return grid[m-1][n-1]"},{"question":"def is_self_dividing(num: int) -> bool: Check if a number is self-dividing. :param num: int - input number to be checked :return: bool - True if the number is self-dividing, False otherwise pass def self_dividing_numbers(lower: int, upper: int) -> list[int]: Returns a list of self-dividing numbers between the given bounds. :param lower: int - lower bound (inclusive) :param upper: int - upper bound (inclusive) :return: list[int] - list of self-dividing numbers >>> self_dividing_numbers(1, 22) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] >>> self_dividing_numbers(10, 12) [11, 12] pass","solution":"def is_self_dividing(num): Check if a number is self-dividing. :param num: int - input number to be checked :return: bool - True if the number is self-dividing, False otherwise original_num = num while num > 0: digit = num % 10 # If the digit is 0 or the digit does not divide the original number if digit == 0 or original_num % digit != 0: return False num //= 10 return True def self_dividing_numbers(lower, upper): Returns a list of self-dividing numbers between the given bounds. :param lower: int - lower bound (inclusive) :param upper: int - upper bound (inclusive) :return: list[int] - list of self-dividing numbers result = [] for num in range(lower, upper + 1): if is_self_dividing(num): result.append(num) return result"},{"question":"def min_abs_difference(n: int, q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the minimum absolute difference between any two distinct elements in the subarray for each query. Parameters: n (int): The length of the array. q (int): The number of queries. A (list): A list of integers representing the array elements. queries (list): A list of tuples representing the queries, each tuple (l, r). Returns: list: A list of minimum absolute differences for each query. If the subarray contains less than 2 elements, return -1. >>> min_abs_difference(6, 3, [3, 8, 2, 5, 7, 1], [(1, 4), (2, 5), (3, 6)]) [1, 1, 1] >>> min_abs_difference(4, 1, [5, 3, 8, 2], [(2, 2)]) [-1] >>> min_abs_difference(5, 2, [12, 15, 18, 5, 11], [(1, 2), (3, 4)]) [3, 13] >>> min_abs_difference(5, 1, [1000000000, 999999999, 999999998, 999999997, 999999996], [(1, 5)]) [1] >>> min_abs_difference(4, 1, [1, 2, 3, 4], [(1, 4)]) [1]","solution":"def min_abs_difference(n, q, A, queries): Returns the minimum absolute difference between any two distinct elements in the subarray for each query. Parameters: n (int): The length of the array. q (int): The number of queries. A (list): A list of integers representing the array elements. queries (list): A list of tuples representing the queries, each tuple (l, r). Returns: list: A list of minimum absolute differences for each query. If the subarray contains less than 2 elements, return -1. results = [] for l, r in queries: if r - l + 1 < 2: results.append(-1) continue subarray = sorted(A[l-1:r]) min_diff = float('inf') for i in range(len(subarray) - 1): min_diff = min(min_diff, abs(subarray[i+1] - subarray[i])) results.append(min_diff) return results"},{"question":"def uniqueCompletionCodes(n: int, projects: List[List[int]]) -> bool: Returns True if it's possible to assign unique completion codes to each project, otherwise returns False. >>> uniqueCompletionCodes(4, [[1, 2, 3], [3, 4], [1, 2, 4]]) == False >>> uniqueCompletionCodes(3, [[1, 2], [2, 3], [1, 3]]) == True >>> uniqueCompletionCodes(5, [[1, 2], [3, 4], [5]]) == True >>> uniqueCompletionCodes(3, [[1, 2, 3]]) == True >>> uniqueCompletionCodes(5, [[1, 2], [3, 4], [2, 1], [4, 3]]) == False","solution":"def uniqueCompletionCodes(n, projects): Returns True if it's possible to assign unique completion codes to each project, otherwise returns False. completion_codes = set() for project in projects: code = 0 for emp_id in project: code ^= emp_id if code in completion_codes: return False completion_codes.add(code) return True"},{"question":"def library_sort(input_list): Sort books based on titles and serial numbers. Args: input_list (List[str]): A list of strings containing the number of books followed by each book's serial number and title. Returns: List[str]: A list of strings with the sorted books in the format \\"serial_number title\\". >>> library_sort(['3', '123 Hamlet', '456 RomeoAndJuliet', '789 Hamlet', '0']) ['123 Hamlet', '789 Hamlet', '456 RomeoAndJuliet'] >>> library_sort(['2', '245 Macbeth', '136 Othello', '0']) ['245 Macbeth', '136 Othello'] >>> library_sort(['3', '123 Hamlet', '456 RomeoAndJuliet', '789 Hamlet', '2', '245 Macbeth', '136 Othello', '0']) ['123 Hamlet', '789 Hamlet', '456 RomeoAndJuliet', '245 Macbeth', '136 Othello'] >>> library_sort(['0']) [] >>> library_sort(['1', '101 TheGreatGatsby', '0']) ['101 TheGreatGatsby']","solution":"def sort_books(datasets): sorted_books = [] for books in datasets: books.sort(key=lambda x: (x[1], x[0])) sorted_books.extend(books) return sorted_books def parse_input(input_list): datasets = [] current_dataset = [] for line in input_list: if line == '0': if current_dataset: datasets.append(current_dataset) break elif line.isdigit(): if current_dataset: datasets.append(current_dataset) current_dataset = [] else: serial_number, title = line.split(' ', 1) current_dataset.append((int(serial_number), title)) return datasets def format_output(sorted_books): return [f\\"{serial_num} {title}\\" for serial_num, title in sorted_books] def library_sort(input_list): datasets = parse_input(input_list) sorted_books = sort_books(datasets) return format_output(sorted_books)"},{"question":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the missing number in a list of consecutive integers. Args: nums (List[int]): A list of consecutive integers with one missing integer. Returns: int: The missing integer. Examples: >>> find_missing_number([1, 2, 4, 5]) 3 >>> find_missing_number([10, 11, 13, 14, 15]) 12 >>> find_missing_number([21, 22, 23, 25, 26]) 24","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the missing number in a list of consecutive integers. Args: nums (List[int]): A list of consecutive integers with one missing integer. Returns: int: The missing integer. # Calculate the expected sum of the range of numbers expected_sum = (nums[0] + nums[-1]) * (len(nums) + 1) // 2 # Calculate the actual sum of the provided list actual_sum = sum(nums) # The missing number is the difference between the expected sum and the actual sum return expected_sum - actual_sum"},{"question":"def min_fence_segments(w: int, h: int, b: int) -> int: Calculate the minimum number of fence segments needed to cover the perimeter of the flower bed. Parameters: w (int): The width of the flower bed. h (int): The height of the flower bed. b (int): The length of each fence segment. Returns: int: Minimum number of fence segments needed. Examples: >>> min_fence_segments(5, 3, 2) 8 >>> min_fence_segments(4, 2, 2) 6 >>> min_fence_segments(1, 1, 10) 1 >>> min_fence_segments(7, 5, 4) 6 >>> min_fence_segments(1000000000, 1000000000, 1) 4000000000","solution":"def min_fence_segments(w, h, b): Calculate the minimum number of fence segments needed to cover the perimeter of the flower bed. Parameters: w (int): The width of the flower bed. h (int): The height of the flower bed. b (int): The length of each fence segment. Returns: int: Minimum number of fence segments needed. # Calculate the perimeter of the flower bed perimeter = 2 * (w + h) # Calculate the minimum number of segments required number_of_segments = (perimeter + b - 1) // b return number_of_segments"},{"question":"def champa_max_gems(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the maximum sum of non-adjacent gem values for each test case. :param T: Number of test cases :param test_cases: List of tuples where each tuple contains (N, values) :return: List of results for each test case >>> champa_max_gems(2, [(4, [3, 2, 5, 10]), (5, [2, 10, 3, 5, 7])]) [13, 17] >>> champa_max_gems(1, [(1, [5])]) [5] >>> champa_max_gems(1, [(0, [])]) [0] >>> champa_max_gems(1, [(4, [4, 1, 1, 4])]) [8] >>> champa_max_gems(1, [(5, [1, 1, 1, 1, 1])]) [3] >>> champa_max_gems(1, [(5, [100, 1, 100, 1, 100])]) [300] pass","solution":"def max_non_adjacent_sum(values): Returns the maximum sum of non-adjacent elements in the list values. if not values: return 0 if len(values) == 1: return values[0] prev1 = 0 prev2 = 0 for value in values: current = max(prev1, prev2 + value) prev2 = prev1 prev1 = current return prev1 def champa_max_gems(T, test_cases): Determines the maximum sum of non-adjacent gem values for each test case. :param T: Number of test cases :param test_cases: List of tuples where each tuple contains (N, values) :return: List of results for each test case results = [] for N, values in test_cases: result = max_non_adjacent_sum(values) results.append(result) return results"},{"question":"def list_to_bst(nums): Converts a sorted list of integers to a balanced binary search tree. Args: nums (List[int]): A sorted list of integers. Returns: dict: The root of the balanced BST. Examples: >>> list_to_bst([1, 2, 3]) { 'value': 2, 'left': {'value': 1, 'left': None, 'right': None}, 'right': {'value': 3, 'left': None, 'right': None} } >>> list_to_bst([-10, -3, 0, 5, 9]) { 'value': 0, 'left': {'value': -10, 'left': None, 'right': {'value': -3, 'left': None, 'right': None}}, 'right': {'value': 5, 'left': None, 'right': {'value': 9, 'left': None, 'right': None}} } >>> list_to_bst([]) # returns None","solution":"def list_to_bst(nums): Converts a sorted list of integers to a balanced binary search tree. Args: nums (List[int]): A sorted list of integers. Returns: dict: The root of the balanced BST. if not nums: return None def helper(start, end): if start > end: return None mid = (start + end) // 2 node = { 'value': nums[mid], 'left': helper(start, mid - 1), 'right': helper(mid + 1, end) } return node return helper(0, len(nums) - 1)"},{"question":"def group_anagrams(words: List[str]) -> List[List[str]]: This function takes a list of words and groups them into sets of anagrams. It treats words in a case-insensitive manner. from collections import defaultdict def process_input(T: int, cases: List[List[Union[int, str]]]) -> List[List[str]]: This function processes the input for multiple test cases and returns the results. Each result contains words grouped by sets of anagrams. # Test cases for \`group_anagrams\` def test_group_anagrams(): assert group_anagrams([\\"Listen\\", \\"Silent\\", \\"Enlist\\"]) == [['Listen', 'Silent', 'Enlist']] assert group_anagrams([\\"evil\\", \\"live\\", \\"vile\\", \\"veil\\"]) == [['evil', 'live', 'vile', 'veil']] assert group_anagrams([\\"bad\\", \\"dab\\", \\"tab\\"]) == [['bad', 'dab'], ['tab']] assert group_anagrams([\\"\\"]) == [['']] assert group_anagrams([\\"a\\", \\"A\\"]) == [['a', 'A']] # Test cases for \`process_input\` def test_process_input(): assert process_input(2, [ [3, \\"Listen\\", \\"Silent\\", \\"Enlist\\"], [4, \\"evil\\", \\"live\\", \\"vile\\", \\"veil\\"] ]) == [ [\\"Listen Silent Enlist\\"], [\\"evil live vile veil\\"] ] assert process_input(1, [ [3, \\"pears\\", \\"spear\\", \\"parse\\"] ]) == [ [\\"pears spear parse\\"] ] assert process_input(1, [ [5, \\"cat\\", \\"tac\\", \\"act\\", \\"dog\\", \\"god\\"] ]) == [ [\\"cat tac act\\", \\"dog god\\"] ]","solution":"def group_anagrams(words): This function takes a list of words and groups them into sets of anagrams. It treats words in a case-insensitive manner. from collections import defaultdict anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word.lower())) anagram_dict[sorted_word].append(word) return list(anagram_dict.values()) def process_input(T, cases): results = [] for i in range(T): N = cases[i][0] words = cases[i][1:] grouped_anagrams = group_anagrams(words) results.append([' '.join(group) for group in grouped_anagrams]) return results"},{"question":"def count_palindromic_substrings(s: str) -> int: Counts the number of palindromic substrings in a given string. Parameters: s (str): The input string consisting of lowercase alphabetic characters. Returns: int: The number of palindromic substrings within the string. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"\\") 0 >>> count_palindromic_substrings(\\"aaaa\\") 10","solution":"def count_palindromic_substrings(s): Counts and returns the number of palindromic substrings in a given string. n = len(s) count = 0 for i in range(n): # Count odd length palindromes with center at i count += count_palindromes_around_center(s, i, i) # Count even length palindromes with centers at i and i+1 count += count_palindromes_around_center(s, i, i + 1) return count def count_palindromes_around_center(s, left, right): Expand around center to count palindromes. count = 0 while left >= 0 and right < len(s) and s[left] == s[right]: count += 1 left -= 1 right += 1 return count"},{"question":"def count_distinct_characters(N, S, queries): Given a string S and a list of queries, return the number of distinct characters in each queried substring Parameters: N (int): The length of the string S S (str): The string of length N queries (list of tuples): Each tuple contains two integers, L and R Returns: list: A list containing the number of distinct characters for each query pass from count_distinct_characters import count_distinct_characters def test_example_cases(): assert count_distinct_characters(7, \\"ABCADEA\\", [(1, 3), (2, 5), (4, 7)]) == [3, 4, 3] def test_single_character_queries(): assert count_distinct_characters(5, \\"ABCDE\\", [(1, 1), (2, 2), (3, 3)]) == [1, 1, 1] def test_entire_string_query(): assert count_distinct_characters(4, \\"ABCD\\", [(1, 4)]) == [4] assert count_distinct_characters(4, \\"AAAA\\", [(1, 4)]) == [1] def test_repeated_characters(): assert count_distinct_characters(6, \\"AABCCD\\", [(1, 3), (2, 5), (3, 6)]) == [2, 3, 3] def test_minimum_size_input(): assert count_distinct_characters(1, \\"A\\", [(1, 1)]) == [1] def test_large_input_case(): S = \\"A\\" * (10**5) queries = [(1, 10**5), (250, 99000), (1, 2), (99999, 100000)] expected_results = [1, 1, 1, 1] assert count_distinct_characters(10**5, S, queries) == expected_results","solution":"def count_distinct_characters(N, S, queries): Given a string S and a list of queries, return the number of distinct characters in each queried substring Parameters: N (int): The length of the string S S (str): The string of length N queries (list of tuples): Each tuple contains two integers, L and R Returns: list: A list containing the number of distinct characters for each query results = [] for L, R in queries: substring = S[L-1:R] distinct_characters = set(substring) results.append(len(distinct_characters)) return results"},{"question":"def compute_final_coordinates(n: int, commands: List[str]) -> Tuple[int, int]: Compute the final coordinates of the player after executing a series of movement commands. Parameters: n (int): Number of commands commands (list): List of movement commands (strings) Returns: tuple: Final coordinates of the player >>> compute_final_coordinates(3, [\\"up 5\\", \\"left 3\\", \\"down 2\\"]) (-3, 3) >>> compute_final_coordinates(4, [\\"up 10\\", \\"down 10\\", \\"left 10\\", \\"right 10\\"]) (0, 0) pass def test_compute_final_coordinates_sample_1(): result = compute_final_coordinates(3, [\\"up 5\\", \\"left 3\\", \\"down 2\\"]) assert result == (-3, 3) def test_compute_final_coordinates_sample_2(): result = compute_final_coordinates(4, [\\"up 10\\", \\"down 10\\", \\"left 10\\", \\"right 10\\"]) assert result == (0, 0) def test_compute_final_coordinates_single_command(): result = compute_final_coordinates(1, [\\"up 5\\"]) assert result == (0, 5) def test_compute_final_coordinates_multiple_up_commands(): result = compute_final_coordinates(3, [\\"up 1\\", \\"up 2\\", \\"up 3\\"]) assert result == (0, 6) def test_compute_final_coordinates_mixed_commands(): result = compute_final_coordinates(5, [\\"right 2\\", \\"down 3\\", \\"left 1\\", \\"up 4\\", \\"right 6\\"]) assert result == (7, 1) def test_compute_final_coordinates_no_movement(): result = compute_final_coordinates(2, [\\"up 0\\", \\"right 0\\"]) assert result == (0, 0)","solution":"def compute_final_coordinates(n, commands): Returns the final coordinates of the player after executing a series of movement commands. Parameters: n (int): Number of commands commands (list): List of movement commands (strings) Returns: tuple: Final coordinates of the player x, y = 0, 0 for command in commands: direction, units = command.split() units = int(units) if direction == 'up': y += units elif direction == 'down': y -= units elif direction == 'left': x -= units elif direction == 'right': x += units return (x, y)"},{"question":"def countWaves(arr: List[int]) -> int: Given an array of integers representing heights of people in a line, return the minimum number of waves needed where each wave is defined as a contiguous subarray satisfying the rule: the person at the start of the wave should be taller than all subsequent people in the wave. >>> countWaves([3, 1, 2, 3, 1]) 3 >>> countWaves([1, 2, 1]) 2 >>> countWaves([3, 2, 1]) 1 >>> countWaves([1, 3, 2, 4, 1, 5]) 4 >>> countWaves([1, 2, 3, 4, 5]) 5 >>> countWaves([2, 2, 2, 2]) 4 >>> countWaves(list(range(100000))) 100000","solution":"def countWaves(arr): Given an array of integers representing heights of people in a line, return the minimum number of waves needed where each wave is defined as a contiguous subarray satisfying the rule: the person at the start of the wave should be taller than all subsequent people in the wave. if not arr: return 0 waves = 1 max_height = arr[0] for height in arr[1:]: if height >= max_height: waves += 1 max_height = height else: max_height = height return waves"},{"question":"def max_profit(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: Determine the maximum possible profit the company can achieve without exceeding the total available budget. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], List[int]]]): A list of test cases where each test case is a tuple containing: - N (int): The number of projects. - B (int): The total available budget. - List[int]: The budgets required for each project. - List[int]: The expected profits from each project. Returns: List[int]: A list of maximum possible profits for each test case. Example: >>> max_profit(2, [(3, 50, [20, 30, 40], [30, 40, 50]), (4, 60, [10, 20, 30, 40], [40, 30, 20, 50])]) [70, 90] >>> max_profit(1, [(4, 5, [5, 5, 5, 5], [10, 20, 30, 40])]) [40]","solution":"def knapsack(budget, costs, profits, n): dp = [[0 for x in range(budget + 1)] for x in range(n + 1)] for i in range(n + 1): for w in range(budget + 1): if i == 0 or w == 0: dp[i][w] = 0 elif costs[i-1] <= w: dp[i][w] = max(profits[i-1] + dp[i-1][w-costs[i-1]], dp[i-1][w]) else: dp[i][w] = dp[i-1][w] return dp[n][budget] def max_profit(T, test_cases): results = [] for i in range(T): N, B = test_cases[i][:2] costs = test_cases[i][2] profits = test_cases[i][3] results.append(knapsack(B, costs, profits, N)) return results"},{"question":"def reverse_strings(strings: List[str]) -> List[str]: Takes in a list of strings and returns a new list where each string is reversed. Args: strings (list): A list of strings. Returns: list: A list where each string is reversed. >>> reverse_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) [\\"elppa\\", \\"ananab\\", \\"yrrehc\\"] >>> reverse_strings([\\"abc\\", \\"123\\", \\"\\", \\"xyz\\"]) [\\"cba\\", \\"321\\", \\"\\", \\"zyx\\"] >>> reverse_strings([]) [] >>> reverse_strings([\\"\\", \\"\\", \\"\\"]) [\\"\\", \\"\\", \\"\\"] >>> reverse_strings([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> reverse_strings([\\"racecar\\", \\"level\\", \\"radar\\"]) [\\"racecar\\", \\"level\\", \\"radar\\"]","solution":"def reverse_strings(strings): Takes in a list of strings and returns a new list where each string is reversed. Args: strings (list): A list of strings. Returns: list: A list where each string is reversed. return [s[::-1] for s in strings]"},{"question":"class PathSumII: def __init__(self, grid): Initialize the object with the given grid. def countDistinctIslands(self): Return the number of distinct islands in the grid. >>> grid = [ ... [1, 1, 0, 0], ... [1, 1, 0, 1], ... [0, 0, 0, 1], ... [1, 0, 0, 1] ... ] >>> pathSumII = PathSumII(grid) >>> pathSumII.countDistinctIslands() 3 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> pathSumII = PathSumII(grid) >>> pathSumII.countDistinctIslands() 0 >>> grid = [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0] ... ] >>> pathSumII = PathSumII(grid) >>> pathSumII.countDistinctIslands() 1 >>> grid = [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ] >>> pathSumII = PathSumII(grid) >>> pathSumII.countDistinctIslands() 1 >>> grid = [ ... [1, 1, 0], ... [1, 0, 0], ... [0, 0, 1] ... ] >>> pathSumII = PathSumII(grid) >>> pathSumII.countDistinctIslands() 2","solution":"class PathSumII: def __init__(self, grid): self.grid = grid self.n = len(grid) self.visited = [[False] * self.n for _ in range(self.n)] def dfs(self, i, j, base_i, base_j, shape): if (i < 0 or i >= self.n or j < 0 or j >= self.n or self.visited[i][j] or self.grid[i][j] == 0): return self.visited[i][j] = True shape.append((i - base_i, j - base_j)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for d in directions: new_i, new_j = i + d[0], j + d[1] self.dfs(new_i, new_j, base_i, base_j, shape) def normalize(self, shape): normalized_shapes = [] for x, y in shape: normalized_shapes.append((x, y)) normalized_shapes.append((-x, y)) normalized_shapes.append((x, -y)) normalized_shapes.append((-x, -y)) normalized_shapes.append((y, x)) normalized_shapes.append((-y, x)) normalized_shapes.append((y, -x)) normalized_shapes.append((-y, -x)) normalized_shapes = sorted(normalized_shapes) min_shape = normalized_shapes[0] translated_shape = [(x - min_shape[0], y - min_shape[1]) for x, y in normalized_shapes] return translated_shape def countDistinctIslands(self): distinct_islands = set() for i in range(self.n): for j in range(self.n): if self.grid[i][j] == 1 and not self.visited[i][j]: shape = [] self.dfs(i, j, i, j, shape) normalized_shape = self.normalize(shape) distinct_islands.add(tuple(normalized_shape)) return len(distinct_islands)"},{"question":"def count_paths(grid: List[List[int]]) -> int: This function returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding blocked cells. >>> count_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> count_paths([[0, 1], [0, 0]]) 1 >>> count_paths([[0, 0], [1, 0]]) 1 >>> count_paths([[1, 1], [1, 1]]) 0 >>> count_paths([[0]]) 1 >>> count_paths([[1, 0], [0, 0]]) 0 >>> count_paths([[0, 0], [0, 1]]) 0","solution":"def count_paths(grid): This function returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding blocked cells. m = len(grid) n = len(grid[0]) # If starting or ending cell is blocked, return 0 as no paths are possible. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0]*n for _ in range(m)] dp[0][0] = 1 # Starting point for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def smaller_numbers_than_current(nums): Given an integer array nums representing player scores, returns an array where result[i] is the number of players whose score is less than nums[i]. >>> smaller_numbers_than_current([8, 1, 2, 2, 3]) == [4, 0, 1, 1, 3] >>> smaller_numbers_than_current([5, 5, 5, 5]) == [0, 0, 0, 0] >>> smaller_numbers_than_current([2, 5]) == [0, 1] >>> smaller_numbers_than_current([0, 0, 0, 0]) == [0, 0, 0, 0] >>> smaller_numbers_than_current([5, 4, 3, 2, 1]) == [4, 3, 2, 1, 0] >>> smaller_numbers_than_current([3, -1, 2, 0]) == [3, 0, 2, 1]","solution":"def smaller_numbers_than_current(nums): Given an integer array nums representing player scores, returns an array where result[i] is the number of players whose score is less than nums[i]. result = [] for i in range(len(nums)): count = sum(1 for num in nums if num < nums[i]) result.append(count) return result"},{"question":"def fill_missing_data(test_cases: List[str]) -> List[List[int]]: Fill missing electricity usage data in various cities based on the given rules. >>> fill_missing_data([\\"5 10 NA 30 40 50\\", \\"4 NA 20 30 NA\\"]) [[10, 20, 30, 40, 50], [20, 20, 30, 30]] >>> fill_missing_data([\\"3 10 20 30\\"]) [[10, 20, 30]] >>> fill_missing_data([\\"4 NA NA NA NA\\"]) [[0, 0, 0, 0]] >>> fill_missing_data([\\"3 NA 20 30\\"]) [[20, 20, 30]] >>> fill_missing_data([\\"4 10 NA 10 NA 10\\"]) [[10, 10, 10, 10, 10]] >>> fill_missing_data([\\"4 1000000 NA 1000000 NA\\"]) [[1000000, 1000000, 1000000, 1000000]] # Helper function to handle input and output in a readable format def process_input_output(input_data: str) -> List[str]: Process the input data to generate filled data output in required format. # Return the processed output return []","solution":"def fill_missing_data(test_cases): def fill_single_case(data): n = len(data) filled_data = [] for i in range(n): if data[i] != 'NA': filled_data.append(int(data[i])) else: left = right = None # Find nearest non-'NA' to the left for j in range(i - 1, -1, -1): if data[j] != 'NA': left = int(data[j]) break # Find nearest non-'NA' to the right for j in range(i + 1, n): if data[j] != 'NA': right = int(data[j]) break if left is not None and right is not None: filled_data.append((left + right) // 2) elif left is not None: filled_data.append(left) elif right is not None: filled_data.append(right) else: filled_data.append(0) # Fallback in case there's no valid left or right, though this is unlikely. return filled_data result = [] for case in test_cases: _, *data = case.split() result.append(fill_single_case(data)) return result # Helper function to handle input and output in a readable format def process_input_output(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = input_lines[1:T + 1] filled_data = fill_missing_data(test_cases) output_lines = [] for data in filled_data: output_lines.append(\\" \\".join(map(str, data))) return output_lines"},{"question":"def minimum_absolute_differences(k: int, categories: List[List[int]]) -> List[int]: Calculate the minimum possible sum of absolute differences between successive book IDs for each category. >>> minimum_absolute_differences(2, [[3, 10, 20, 30], [4, 7, 1, 3, 10]]) [20, 9] >>> minimum_absolute_differences(1, [[5, 5, 3, 9, 1, 4]]) [8] >>> minimum_absolute_differences(3, [[1, 100], [1, 200], [1, 300]]) [0, 0, 0] >>> minimum_absolute_differences(1, [[4, 2, 2, 2, 2]]) [0] >>> minimum_absolute_differences(1, [[3, 1000000, 500000, 1]]) [999999] pass","solution":"def minimum_absolute_differences(k, categories): results = [] for category in categories: ids = category[1:] ids.sort() min_diff = sum(abs(ids[i] - ids[i-1]) for i in range(1, len(ids))) results.append(min_diff) return results"},{"question":"def manage_inventory(transactions: List[str]) -> List[str]: Manage a list of ISBN numbers, allowing for adding and removing books while maintaining the state of the inventory. Args: transactions (List[str]): List of transaction strings where each transaction is in the format: \\"add ISBN\\" or \\"remove ISBN\\". Returns: List[str]: For each remove transaction that involves a non-existent book, returns \\"error\\". Examples: >>> manage_inventory([\\"add 9783161484100\\", \\"add 9781234567897\\", \\"remove 9783161484100\\", \\"remove 9783161484100\\", \\"remove 9783161484101\\", \\"add 9783161484100\\"]) ['error', 'error'] >>> manage_inventory([\\"add 9783161484100\\", \\"remove 9783161484100\\", \\"remove 9783161484100\\"]) ['error'] >>> manage_inventory([\\"add 9783161484100\\", \\"add 9783161484100\\", \\"remove 9783161484100\\", \\"remove 9783161484100\\"]) ['error'] >>> manage_inventory([\\"add 9783161484100\\", \\"add 9781234567897\\", \\"remove 9781234567897\\", \\"remove 9783161484100\\"]) [] >>> manage_inventory([\\"remove 9783161484100\\", \\"remove 9781234567897\\", \\"remove 9783161484101\\"]) ['error', 'error', 'error']","solution":"def manage_inventory(transactions): inventory = set() result = [] for transaction in transactions: action, isbn = transaction.split() if action == \\"add\\": inventory.add(isbn) elif action == \\"remove\\": if isbn in inventory: inventory.remove(isbn) else: result.append(\\"error\\") return result"},{"question":"from typing import List def num_unique_paths(grid: List[str], n: int, m: int) -> int: Determine the number of unique paths a mouse can take to navigate through a grid maze. Args: grid (List[str]): A list of strings representing the grid, where '.' is an open cell and '#' is a blocked cell. n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: Number of unique paths from the top-left to the bottom-right corner of the grid. Examples: >>> num_unique_paths([\\".\\", \\".#.\\", \\"...\\"], 3, 3) 1 >>> num_unique_paths([\\".#.\\", \\"#\\", \\"...\\"], 3, 3) 0","solution":"def num_unique_paths(grid, n, m): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 paths = [[0] * m for _ in range(n)] paths[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': paths[i][j] = 0 else: if i > 0: paths[i][j] += paths[i-1][j] if j > 0: paths[i][j] += paths[i][j-1] return paths[n-1][m-1] def parse_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [] idx = 2 for i in range(n): grid.append(data[idx]) idx += 1 return grid, n, m if __name__ == \\"__main__\\": grid, n, m = parse_input() print(num_unique_paths(grid, n, m))"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any continuous subarray within the sequence. >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, -10, 1, 2, 3]) 10 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([-2, 3, -1, 2]) 4 >>> max_subarray_sum([5, -2, 5, -2, 5]) 11","solution":"def max_subarray_sum(arr): Returns the maximum sum of any continuous subarray within the sequence. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_items(N: int, items: List[int]) -> int: Determine the maximum number of items Alex can collect starting from any stall. Args: N : int : Number of stalls items : List[int] : Number of items at each stall Returns: int : Maximum number of items collected Examples: >>> max_items(5, [4, 2, 3, 5, 1]) 15 >>> max_items(3, [10, 20, 30]) 60 pass # Test cases: def test_max_items(): assert max_items(5, [4, 2, 3, 5, 1]) == 15 assert max_items(3, [10, 20, 30]) == 60 assert max_items(1, [42]) == 42 assert max_items(2, [100, 200]) == 300 assert max_items(4, [1, 2, 3, 4]) == 10 def test_max_items_edge_cases(): assert max_items(0, []) == 0 assert max_items(1, [1]) == 1 assert max_items(1, [10]) == 10","solution":"def max_items(N, items): Returns the maximum number of items Alex can collect starting from any stall. if N == 0: return 0 if N == 1: return items[0] # Initialize two arrays to store the maximum items collected with option of starting in the middle left_sum = [0] * N right_sum = [0] * N # Filling left_sum array left_sum[0] = items[0] for i in range(1, N): left_sum[i] = left_sum[i-1] + items[i] # Filling right_sum array right_sum[N-1] = items[N-1] for i in range(N-2, -1, -1): right_sum[i] = right_sum[i+1] + items[i] # Find the maximum possible items collected max_items_collected = 0 for i in range(N): total_collected = left_sum[i] + right_sum[i] - items[i] if total_collected > max_items_collected: max_items_collected = total_collected return max_items_collected"},{"question":"def is_anagram(s: str, t: str) -> bool: Given two strings \`s\` and \`t\`, determine if \`t\` is an anagram of \`s\`. >>> is_anagram(\\"anagram\\", \\"nagaram\\") True >>> is_anagram(\\"rat\\", \\"car\\") False","solution":"def is_anagram(s, t): Determines if t is an anagram of s. # One way to determine if two strings are anagrams is to count the occurrences of each character in both strings # and compare the counts. If both strings have identical counts for each character, then they are anagrams. if len(s) != len(t): return False count_s = {} count_t = {} for char in s: count_s[char] = count_s.get(char, 0) + 1 for char in t: count_t[char] = count_t.get(char, 0) + 1 return count_s == count_t"},{"question":"def find_missing_number(arr): Finds the single missing number in a sequence ranging from 1 to n+1, where n is the length of the input list. Args: arr (list): The input list of integers. Returns: int: The missing number. >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6","solution":"def find_missing_number(arr): Finds the single missing number in a sequence ranging from 1 to n+1, where n is the length of the input list. Args: arr (list): The input list of integers. Returns: int: The missing number. n = len(arr) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(arr) return total_sum - actual_sum"},{"question":"def findMaxLength(arr: List[int], n: int) -> int: Find the maximum length of a contiguous subarray with equal number of 0s and 1s in a binary array. Args: arr (List[int]): List of binary integers (0s and 1s). n (int): Size of the array. Returns: int: Maximum length of the subarray with equal number of 0s and 1s. >>> findMaxLength([0, 1, 0], 3) 2 >>> findMaxLength([0, 1, 1, 0, 1, 1, 1, 0], 8) 4","solution":"def findMaxLength(arr, n): Returns the maximum length of a contiguous subarray with equal number of 0s and 1s. # Store (current_sum, index) hash_map = {} max_len = 0 curr_sum = 0 for i in range(n): # Replace 0 with -1 for easier sum calculation if arr[i] == 0: curr_sum += -1 else: curr_sum += 1 # If curr_sum is 0, it means we found a subarray from the beginning if curr_sum == 0: max_len = i + 1 # If curr_sum is seen before, calculate subarray length if curr_sum in hash_map: max_len = max(max_len, i - hash_map[curr_sum]) else: # Store the current sum with index hash_map[curr_sum] = i return max_len"},{"question":"def largest_uniform_altitude_rect(T: int, cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Find the area of the largest rectangle with uniform altitude for each test case. Args: T (int): Number of test cases. cases (List[Tuple[int, int, List[List[int]]]]): List of test cases, where each test case is represented by a tuple containing the number of rows, columns, and the grid itself. Returns: List[int]: A list of integers representing the area of the largest rectangle with uniform altitude for each test case. >>> largest_uniform_altitude_rect(1, [(3, 4, [[1, 2, 2, 3], [1, 1, 1, 3], [3, 3, 3, 3]])]) [4] >>> largest_uniform_altitude_rect(1, [(2, 3, [[1, 2, 2], [2, 2, 2]])]) [4] >>> largest_uniform_altitude_rect(1, [(2, 2, [[1, 1], [1, 2]])]) [3]","solution":"def largest_uniform_altitude_rect(T, cases): results = [] def find_largest_with_same_altitude(grid, N, M): largest_area = 0 for i in range(N): for j in range(M): altitude = grid[i][j] min_width = float('inf') for k in range(i, N): if grid[k][j] != altitude: break width = 0 for l in range(j, M): if grid[k][l] != altitude: break width += 1 min_width = min(min_width, width) largest_area = max(largest_area, min_width * (k - i + 1)) return largest_area for case in cases: N, M, grid = case largest_area = find_largest_with_same_altitude(grid, N, M) results.append(largest_area) return results # For each test case, we input the number of rows, columns, and the grid itself, then call the function."},{"question":"def countOddSumPairs(nums: List[int]) -> int: Find the number of pairs (i, j) where 0 <= i < j < len(nums) and nums[i] + nums[j] is an odd number. >>> countOddSumPairs([1, 2, 3, 4]) 4 >>> countOddSumPairs([2, 4, 6]) 0 >>> countOddSumPairs([1, 1, 1, 1]) 0","solution":"def countOddSumPairs(nums): Returns the number of pairs (i, j) where 0 <= i < j < len(nums) and nums[i] + nums[j] is an odd number. odd_count = 0 even_count = 0 for num in nums: if num % 2 == 0: even_count += 1 else: odd_count += 1 # A pair sum is odd if one number is odd and the other is even return odd_count * even_count"},{"question":"def smallest_lexicographical_string(s: str) -> str: Returns the smallest lexicographical string obtained by deleting exactly one character from the given string. >>> smallest_lexicographical_string(\\"abc\\") \\"ab\\" >>> smallest_lexicographical_string(\\"acdb\\") \\"acb\\"","solution":"def smallest_lexicographical_string(s): Returns the smallest lexicographical string obtained by deleting exactly one character from s. n = len(s) for i in range(n - 1): if s[i] > s[i + 1]: return s[:i] + s[i + 1:] return s[:-1] # If all characters are in increasing order, remove the last character # Example test case can be run using the below line # print(smallest_lexicographical_string(\\"acdb\\"))"},{"question":"def is_valid_badge(sequence: str) -> str: Determine if the given badge sequence is valid. A sequence is valid if every character repeats an even number of times, except for one particular character which can appear an odd number of times. Sample Inputs and Outputs: >>> is_valid_badge(\\"civic\\") 'YES' >>> is_valid_badge(\\"code\\") 'NO' >>> is_valid_badge(\\"aabbccddx\\") 'YES' from solution import is_valid_badge def test_is_valid_badge_sample_inputs(): assert is_valid_badge(\\"civic\\") == \\"YES\\" assert is_valid_badge(\\"code\\") == \\"NO\\" assert is_valid_badge(\\"aabbccddx\\") == \\"YES\\" def test_is_valid_badge_additional(): assert is_valid_badge(\\"aaa\\") == \\"YES\\" # Only one character with odd count assert is_valid_badge(\\"aaabbb\\") == \\"NO\\" # More than one character with odd count assert is_valid_badge(\\"abcd\\") == \\"NO\\" # All characters with odd count assert is_valid_badge(\\"aabbccdde\\") == \\"YES\\" # Only 'e' with odd count def test_is_valid_badge_edge_cases(): assert is_valid_badge(\\"a\\") == \\"YES\\" # Single character, odd count assert is_valid_badge(\\"\\") == \\"YES\\" # Empty string considered as valid assert is_valid_badge(\\"aa\\") == \\"YES\\" # All characters with even count assert is_valid_badge(\\"aaaabbcc\\") == \\"YES\\" # 'a' appears four times (even), 'b' and 'c' appear twice (even) def test_is_valid_badge_large_input(): assert is_valid_badge(\\"a\\" * 500 + \\"b\\" * 500 + \\"c\\") == \\"YES\\" # Only 'c' with odd count assert is_valid_badge(\\"a\\" * 499 + \\"b\\" * 501 + \\"c\\") == \\"NO\\" # 'a' and 'b' have odd count","solution":"def is_valid_badge(sequence): Determine if the given badge sequence is valid. A sequence is valid if every character should repeat an even number of times, except for one particular character which can appear an odd number of times. from collections import Counter counts = Counter(sequence) odd_count = sum(1 for count in counts.values() if count % 2 == 1) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def can_attend_meetings(intervals): Determines if a person can attend all meetings without any overlaps. Args: intervals (List[List[int]]): List of meeting intervals [start, end]. Returns: bool: True if there are no overlapping meetings, False otherwise. >>> can_attend_meetings([[7, 10], [2, 4]]) True >>> can_attend_meetings([[0, 30], [5, 10], [15, 20]]) False >>> can_attend_meetings([[1, 5], [5, 9]]) True","solution":"def can_attend_meetings(intervals): Determines if a person can attend all meetings without any overlaps. Args: intervals (List[List[int]]): List of meeting intervals [start, end]. Returns: bool: True if there are no overlapping meetings, False otherwise. # Sort intervals by start time intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # If there is an overlap between the current meeting and the previous meeting if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"from itertools import permutations def is_prime(num): Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(29) True >>> is_prime(0) False >>> is_prime(1) False pass def can_form_prime(S): Check if it is possible to rearrange the characters of string S to form a prime number. >>> can_form_prime(\\"17\\") \\"YES\\" >>> can_form_prime(\\"23\\") \\"YES\\" >>> can_form_prime(\\"28\\") \\"NO\\" >>> can_form_prime(\\"11\\") \\"YES\\" >>> can_form_prime(\\"222\\") \\"NO\\" pass def process_test_cases(T, test_cases): Process multiple test cases and determine if each string can form a prime number. >>> process_test_cases(3, [\\"17\\", \\"23\\", \\"28\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"97\\", \\"43\\"]) [\\"YES\\", \\"YES\\"] >>> process_test_cases(2, [\\"44\\", \\"55\\"]) [\\"NO\\", \\"NO\\"] pass","solution":"from itertools import permutations def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def can_form_prime(S): for perm in permutations(S): num = int(''.join(perm)) if is_prime(num): return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(can_form_prime(S)) return results"},{"question":"def subset_sum_divisible_by_k(m: int, k: int, nums: List[int]) -> str: Determines if there exists a non-empty subset of the given integers whose sum is divisible by k. Args: m (int): The number of integers. k (int): The divisor. nums (List[int]): The list of integers. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". Examples: >>> subset_sum_divisible_by_k(5, 3, [1, 2, 3, 4, 5]) 'YES' >>> subset_sum_divisible_by_k(4, 10, [6, 2, 5, 8]) 'NO'","solution":"def subset_sum_divisible_by_k(m, k, nums): Determines if there exists a non-empty subset of the given integers whose sum is divisible by k. prefix_sum_mod_k = set() current_sum = 0 for num in nums: current_sum += num current_sum_mod_k = current_sum % k if current_sum_mod_k == 0: return \\"YES\\" if current_sum_mod_k in prefix_sum_mod_k: return \\"YES\\" prefix_sum_mod_k.add(current_sum_mod_k) return \\"NO\\""},{"question":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindromic substring that can be created using the characters of the given string s. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1 >>> longest_palindrome_length(\\"bb\\") 2 # Your code here def process_queries(queries: List[str]) -> List[int]: Processes a list of query strings and returns the length of the longest palindromic substring for each string as a list of integers. >>> process_queries([\\"abccccdd\\", \\"a\\", \\"bb\\"]) [7, 1, 2] >>> process_queries([\\"abc\\", \\"ccc\\", \\"ababa\\"]) [1, 3, 5] # Your code here","solution":"def longest_palindrome_length(s): Returns the length of the longest palindromic substring that can be created using the characters of the given string s. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True # Add one if there was any odd count character to place it in the middle if odd_found: length += 1 return length def process_queries(queries): Processes a list of query strings and returns the length of the longest palindromic substring for each string as a list of integers. results = [] for query in queries: results.append(longest_palindrome_length(query)) return results"},{"question":"def fibonacci(n): Generates the first n Fibonacci numbers. if n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence def fibonacci_spiral_area(n): Computes the total area covered by the first n Fibonacci numbers' tiles. fib_sequence = fibonacci(n) return sum(x**2 for x in fib_sequence) def compute_areas(test_cases): Computes the areas for multiple test cases. results = [] for n in test_cases: results.append(fibonacci_spiral_area(n)) return results import pytest def test_fibonacci(): assert fibonacci(1) == [0] assert fibonacci(2) == [0, 1] assert fibonacci(3) == [0, 1, 1] assert fibonacci(5) == [0, 1, 1, 2, 3] def test_fibonacci_spiral_area(): assert fibonacci_spiral_area(1) == 0 # single 0x0 tile assert fibonacci_spiral_area(2) == 1 # tiles: 0, 1 -> area = 0 + 1 = 1 assert fibonacci_spiral_area(3) == 2 # tiles: 0, 1, 1 -> area = 0 + 1 + 1 = 2 assert fibonacci_spiral_area(4) == 6 # tiles: 0, 1, 1, 2 -> area = 0 + 1 + 1 + 4 = 6 assert fibonacci_spiral_area(5) == 15 # tiles: 0, 1, 1, 2, 3 -> area = 0 + 1 + 1 + 4 + 9 = 15 def test_compute_areas(): assert compute_areas([1, 2, 4]) == [0, 1, 6] assert compute_areas([1, 2, 3, 5]) == [0, 1, 2, 15] assert compute_areas([2, 4, 5]) == [1, 6, 15] if __name__ == \\"__main__\\": pytest.main()","solution":"def fibonacci(n): Generates the first n Fibonacci numbers. if n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence def fibonacci_spiral_area(n): Computes the total area covered by the first n Fibonacci numbers' tiles. fib_sequence = fibonacci(n) return sum(x**2 for x in fib_sequence) def compute_areas(test_cases): Computes the areas for multiple test cases. results = [] for n in test_cases: results.append(fibonacci_spiral_area(n)) return results"},{"question":"def nLargestElements(arr, n): Returns the n largest elements from the array \`arr\` in sorted order. If n is greater than the length of the array, returns the whole array sorted in descending order. >>> nLargestElements([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3) [9, 6, 5] >>> nLargestElements([3, 2, 1], 5) [3, 2, 1] >>> nLargestElements([-3, -1, -4, -1, -5, -9, -2, -6, -5, -3, -5], 3) [-1, -1, -2] >>> nLargestElements([-10, 7, -3, 2, 0, 15, 1, -7], 4) [15, 7, 2, 1] >>> nLargestElements([10], 1) [10] >>> nLargestElements([5, 5, 5, 5], 2) [5, 5] >>> nLargestElements([1, 2, 3, 4, 5, 6], 6) [6, 5, 4, 3, 2, 1]","solution":"def nLargestElements(arr, n): Returns the n largest elements from the array \`arr\` in sorted order. If n is greater than the length of the array, returns the whole array sorted in descending order. if n >= len(arr): return sorted(arr, reverse=True) # Using built-in function heapq.nlargest to find the n largest elements import heapq largest_elements = heapq.nlargest(n, arr) # Sorting the n largest elements in descending order return sorted(largest_elements, reverse=True)"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit possible from buying and selling a single stock. :param prices: List of stock prices. :return: Maximum possible profit. If no profit can be achieved, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit possible from buying and selling a single stock. :param prices: List of stock prices. :return: Maximum possible profit. If no profit can be achieved, return 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def organize_registrations(n: int, registrations: List[Tuple[str, bool]]) -> Dict[str, List[str]]: Organizes registrations into categories of those who opted for daily updates and those who did not. Args: n (int): Number of registrations. registrations (list of tuples): List of tuples where each tuple contains: - name of the registrant (string) - boolean indicating whether they opted for daily updates Returns: dict: A dictionary with two keys: - \\"daily_updates\\": list of names of registrants who opted for daily updates, sorted alphabetically - \\"no_updates\\": list of names of registrants who did not opt for daily updates, sorted alphabetically from solution import organize_registrations def test_organize_registrations_standard_case(): registrations = [(\\"Alice\\", True), (\\"Bob\\", False), (\\"Charlie\\", True), (\\"Dave\\", False), (\\"Eve\\", True)] expected_output = { \\"daily_updates\\": [\\"Alice\\", \\"Charlie\\", \\"Eve\\"], \\"no_updates\\": [\\"Bob\\", \\"Dave\\"] } assert organize_registrations(5, registrations) == expected_output def test_organize_registrations_all_opt_in(): registrations = [(\\"Alice\\", True), (\\"Bob\\", True), (\\"Charlie\\", True)] expected_output = { \\"daily_updates\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], \\"no_updates\\": [] } assert organize_registrations(3, registrations) == expected_output def test_organize_registrations_all_opt_out(): registrations = [(\\"Alice\\", False), (\\"Bob\\", False), (\\"Charlie\\", False)] expected_output = { \\"daily_updates\\": [], \\"no_updates\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] } assert organize_registrations(3, registrations) == expected_output def test_organize_registrations_empty_list(): registrations = [] expected_output = { \\"daily_updates\\": [], \\"no_updates\\": [] } assert organize_registrations(0, registrations) == expected_output def test_organize_registrations_mixed_case(): registrations = [(\\"Xander\\", True), (\\"Aaron\\", False), (\\"Maria\\", True), (\\"Bob\\", False), (\\"Zara\\", True)] expected_output = { \\"daily_updates\\": [\\"Maria\\", \\"Xander\\", \\"Zara\\"], \\"no_updates\\": [\\"Aaron\\", \\"Bob\\"] } assert organize_registrations(5, registrations) == expected_output","solution":"def organize_registrations(n, registrations): Organizes registrations into categories of those who opted for daily updates and those who did not. Args: n (int): Number of registrations. registrations (list of tuples): List of tuples where each tuple contains: - name of the registrant (string) - boolean indicating whether they opted for daily updates Returns: dict: A dictionary with two keys: - \\"daily_updates\\": list of names of registrants who opted for daily updates, sorted alphabetically - \\"no_updates\\": list of names of registrants who did not opt for daily updates, sorted alphabetically daily_updates = [name for name, opted in registrations if opted] no_updates = [name for name, opted in registrations if not opted] return { \\"daily_updates\\": sorted(daily_updates), \\"no_updates\\": sorted(no_updates) }"},{"question":"from math import factorial from typing import Tuple def count_scrabble_words(n: int, characters: str, k: int) -> int: Given the number of distinct characters, a string containing all distinct characters, and the length of the words Tina wants to form, return the total number of valid Scrabble words that can be formed using exactly k characters. Each character in the set can be used at most once in each word. Args: n: int - The number of distinct characters. characters: str - A string containing the distinct characters. k: int - The length of the words to form. Returns: int - The number of valid Scrabble words. >>> count_scrabble_words(4, 'abcd', 2) 12 >>> count_scrabble_words(3, 'xyz', 1) 3 >>> count_scrabble_words(5, 'abcde', 3) 60 def test_valid_combinations_case_1(): assert count_scrabble_words(4, 'abcd', 2) == 12 def test_valid_combinations_case_2(): assert count_scrabble_words(3, 'xyz', 1) == 3 def test_valid_combinations_case_3(): assert count_scrabble_words(5, 'abcde', 3) == 60 def test_valid_combinations_case_4(): assert count_scrabble_words(6, 'abcdef', 6) == 720 def test_valid_combinations_case_5(): assert count_scrabble_words(1, 'a', 1) == 1 def test_valid_combinations_case_6(): assert count_scrabble_words(2, 'ab', 2) == 2 def test_invalid_case_k_greater_than_n(): assert count_scrabble_words(3, 'xyz', 4) == 0","solution":"from math import factorial def count_scrabble_words(n, characters, k): Returns the number of valid Scrabble words that can be formed using exactly k characters from the given set of n characters. Args: n: int - The number of distinct characters. characters: str - A string containing the distinct characters. k: int - The length of the words to form. Returns: int - The number of valid Scrabble words. if k > n: return 0 return factorial(n) // factorial(n - k)"},{"question":"from typing import List def maximum_product_of_three_distinct_elements(N: int, A: List[int]) -> int: Find the maximum product of any three distinct elements in the array. If it is not possible to pick three distinct elements, return -1. >>> maximum_product_of_three_distinct_elements(5, [1, 2, 3, 4, 5]) == 60 >>> maximum_product_of_three_distinct_elements(6, [-10, -10, 5, 2, 3, 1]) == 500 >>> maximum_product_of_three_distinct_elements(3, [-1, 0, 1]) == 0 >>> maximum_product_of_three_distinct_elements(4, [1, 2, 3, -4]) == 6 >>> maximum_product_of_three_distinct_elements(2, [1, 2]) == -1 >>> maximum_product_of_three_distinct_elements(3, [1, 2, 2]) == 4 >>> maximum_product_of_three_distinct_elements(3, [1, 2, 3]) == 6 pass","solution":"def maximum_product_of_three_distinct_elements(N, A): if N < 3: return -1 # Sort the array A.sort() # Calculate possible maximum products using the sorted array max1 = A[N-1] * A[N-2] * A[N-3] # The largest three numbers max2 = A[0] * A[1] * A[N-1] # Two smallest (potentially negative) and the largest number # Return the maximum of the two possible products return max(max1, max2)"},{"question":"from typing import List, Optional def best_travel(distances: List[int], k: int, max_distance: int) -> Optional[int]: Returns the maximum possible distance covered by selecting k stops from the given distances list such that the total distance doesn't exceed max_distance. If no valid combination is found, returns None. >>> best_travel([50, 55, 57, 58, 60], 3, 174) 173 >>> best_travel([50], 3, 174) None >>> best_travel([91, 74, 73, 85, 73, 81, 87], 3, 230) 228","solution":"from itertools import combinations def best_travel(distances, k, max_distance): Returns the maximum possible distance covered by selecting k stops from the given distances list such that the total distance doesn't exceed max_distance. If no valid combination is found, returns None. if k > len(distances): return None best_sum = None for combo in combinations(distances, k): total = sum(combo) if total <= max_distance and (best_sum is None or total > best_sum): best_sum = total return best_sum"},{"question":"from typing import List def find_most_recent_login(timestamps: List[str]) -> str: Returns the most recent timestamp from a list of timestamps in string format. >>> find_most_recent_login([\\"2023-03-15 13:45:30\\", \\"2023-03-14 18:20:10\\", \\"2023-03-15 14:05:00\\"]) \\"2023-03-15 14:05:00\\" >>> find_most_recent_login([\\"2022-11-09 09:05:43\\"]) \\"2022-11-09 09:05:43\\" def parse_input(data: str) -> List[str]: Parses input data and returns a list of timestamps. >>> parse_input(\\"3n2023-03-15 13:45:30n2023-03-14 18:20:10n2023-03-15 14:05:00\\") [\\"2023-03-15 13:45:30\\", \\"2023-03-14 18:20:10\\", \\"2023-03-15 14:05:00\\"] >>> parse_input(\\"1n2022-11-09 09:05:43\\") [\\"2022-11-09 09:05:43\\"]","solution":"from datetime import datetime def find_most_recent_login(timestamps): Returns the most recent timestamp from a list of timestamps in string format. most_recent = max(timestamps, key=lambda ts: datetime.strptime(ts, \\"%Y-%m-%d %H:%M:%S\\")) return most_recent def parse_input(data): Parses input data and returns a list of timestamps. lines = data.strip().split('n') n = int(lines[0]) timestamps = lines[1:n + 1] return timestamps"},{"question":"def validate_credit_card(card_num: str) -> bool: Check if the given card number is valid based on the Luhn algorithm. Parameters: card_num (str): The credit card number as a string of digits Returns: bool: True if the card number is valid, False otherwise >>> validate_credit_card(\\"4532015112830366\\") True >>> validate_credit_card(\\"4532015112830367\\") False >>> validate_credit_card(\\"6011514433546201\\") True >>> validate_credit_card(\\"6011514433546200\\") False >>> validate_credit_card(\\"5105105105105100\\") True >>> validate_credit_card(\\"4111111111111111\\") True","solution":"def validate_credit_card(card_num): Check if the given card number is valid based on the Luhn algorithm. Parameters: card_num (str): The credit card number as a string of digits Returns: bool: True if the card number is valid, False otherwise # Step 1: Convert the card number to a list of integers digits = [int(d) for d in card_num] # Step 2: Double every second digit from the right (starting with second last) for i in range(len(digits) - 2, -1, -2): doubled = digits[i] * 2 if doubled > 9: doubled -= 9 digits[i] = doubled # Step 3: Calculate the sum of all digits total = sum(digits) # Step 4: If the total modulo 10 is 0, the number is valid return total % 10 == 0"},{"question":"def count_distinct_pairs_of_marbles(n: int, m: int, first_bag: List[int], second_bag: List[int]) -> int: Determine the number of distinct pairs of marbles with the same color from two bags. :param n: Number of marbles in the first bag. :param m: Number of marbles in the second bag. :param first_bag: List of integers representing colors of marbles in the first bag. :param second_bag: List of integers representing colors of marbles in the second bag. :return: Number of distinct color pairs. >>> count_distinct_pairs_of_marbles(6, 5, [1, 2, 3, 4, 1, 2], [2, 3, 4, 4, 5]) 3 >>> count_distinct_pairs_of_marbles(4, 4, [1, 1, 1, 1], [2, 2, 2, 2]) 0 >>> count_distinct_pairs_of_marbles(7, 6, [2, 4, 6, 8, 10, 12, 14], [1, 3, 6, 8, 11, 14]) 3","solution":"def count_distinct_pairs_of_marbles(n, m, first_bag, second_bag): Determine the number of distinct pairs of marbles with the same color from two bags. :param n: Number of marbles in the first bag. :param m: Number of marbles in the second bag. :param first_bag: List of integers representing colors of marbles in the first bag. :param second_bag: List of integers representing colors of marbles in the second bag. :return: Number of distinct color pairs. set_first_bag = set(first_bag) set_second_bag = set(second_bag) # The intersection of both sets will give the distinct colors present in both bags common_colors = set_first_bag.intersection(set_second_bag) # The number of elements in the intersection set is the answer return len(common_colors)"},{"question":"def longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring containing at most two distinct characters. >>> longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") 10 >>> longest_substring_two_distinct(\\"\\") 0 >>> longest_substring_two_distinct(\\"a\\") 1 >>> longest_substring_two_distinct(\\"ab\\") 2 >>> longest_substring_two_distinct(\\"aaaaaaa\\") 7 >>> longest_substring_two_distinct(\\"abbcccc\\") 6 >>> longest_substring_two_distinct(\\"aaabbcccc\\") 6 >>> longest_substring_two_distinct(\\"a\\" * 1000) 1000","solution":"def longest_substring_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. if not s: return 0 start = 0 max_length = 0 char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def generate_fibonacci(n): Generates the first 'n' terms of the Fibonacci sequence. Parameters: n (int): The number of terms to generate. Returns: list: A list containing the first 'n' terms of the Fibonacci sequence. >>> generate_fibonacci(0) [] >>> generate_fibonacci(1) [0] >>> generate_fibonacci(2) [0, 1] >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def generate_fibonacci(n): Generates the first 'n' terms of the Fibonacci sequence. Parameters: n (int): The number of terms to generate. Returns: list: A list containing the first 'n' terms of the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for i in range(2, n): next_term = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_term) return fib_sequence"},{"question":"def longest_word(sentence: str) -> str: Returns the longest word in the sentence. If multiple words have the same length, return the first one encountered. Punctuation is considered part of words. >>> longest_word(\\"The quick brown fox jumps over the lazy dog\\") 'quick' >>> longest_word(\\"To be or not to be, that is the question\\") 'question' >>> longest_word(\\"\\") '' >>> longest_word(\\"Supercalifragilisticexpialidocious!\\") 'Supercalifragilisticexpialidocious!' >>> longest_word(\\"To be or not to be\\") 'not' # \\"not\\" and \\"to\\" have the same length, returns \\"not\\" since it appears first >>> longest_word(\\"A cat sat on the mat\\") 'cat'","solution":"def longest_word(sentence): Returns the longest word in the sentence. If multiple words have the same length, return the first one encountered. Punctuation is considered part of words. if not sentence: return \\"\\" words = sentence.split() longest = words[0] for word in words[1:]: if len(word) > len(longest): longest = word return longest"},{"question":"def find_best_car_to_rent(T: int, test_cases: list) -> list: Determine which car should be rented to maximize the number of rental days under a given budget. Parameters: T (int): The number of test cases. test_cases (list): A list containing test case information, where each test case is a tuple with the budget, number of available cars, and a list of costs per day of renting each car. Returns: list: A list containing the cost per day of the car that should be rented for each test case. If all cars exceed the budget, returns \\"Not Affordable\\". Example: >>> T = 3 >>> test_cases = [(1000, 3, [500, 300, 700]), (500, 4, [400, 600, 800, 1000]), (150, 2, [200, 250])] >>> find_best_car_to_rent(T, test_cases) [300, 400, \\"Not Affordable\\"]","solution":"def find_best_car_to_rent(T, test_cases): results = [] for i in range(T): B, N, cars = test_cases[i] max_days = 0 chosen_car = -1 for cost in cars: if cost <= B: days = B // cost if days > max_days or (days == max_days and cost < chosen_car): max_days = days chosen_car = cost if chosen_car == -1: results.append(\\"Not Affordable\\") else: results.append(chosen_car) return results"},{"question":"def prime_matrix(m: int) -> str: Alex is fascinated by prime numbers. For his latest project, he wants to generate a matrix of positive integers where the sum of elements in each row, column, and both main diagonals are all prime numbers. Given an integer m, help Alex determine if it is possible to create such an m x m matrix that meets these criteria, and if so, provide one valid matrix. >>> prime_matrix(3) == \\"YESn2 2 3n3 5 2n3 2 2\\" True >>> prime_matrix(4) == \\"NO\\" True","solution":"import sympy def is_prime(n): Returns True if the given number n is prime, else False. return sympy.isprime(n) def find_prime_greater_than(n): Returns the smallest prime number greater than n. prime = n + 1 while not is_prime(prime): prime += 1 return prime def create_matrix(m): Returns a m x m matrix where the sum of elements in each row, column and both main diagonals are prime numbers, if possible. If not possible, returns \\"NO\\". if m == 2: return (False, \\"NO\\") # No solution for 2x2 matrix # Start with sum target for rows, columns, and diagonals prime_target = find_prime_greater_than(m*3) # to be more than trivial sums # Generate basic matrix, initially filling diagonals matrix = [[1]*m for _ in range(m)] # Adjust diagonal elements to meet the prime requirement for i in range(m): matrix[i][i] = prime_target for i in range(m): # Adjust the last row elements except one to meet the sum of each row matrix[m-1][i] = 1 if i < m-1 else prime_target - (matrix[m-1][i] * (m-1)) for i in range(m): # Adjust the last column elements except one to meet the sum of each column matrix[i][m-1] = 1 if i < m-1 else prime_target - (matrix[i][m-1] * (m-1)) return (True, matrix) def prime_matrix(m): possible, response = create_matrix(m) if not possible: return \\"NO\\" else: result = [\\"YES\\"] for row in response: result.append(\\" \\".join(map(str, row))) return \\"n\\".join(result) # Example usage: # print(prime_matrix(3)) # print(prime_matrix(4))"},{"question":"def largest_square_subgrid(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Find the size of the largest square subgrid containing only ones for each test case. >>> largest_square_subgrid(2, [(3, [\\"111\\", \\"111\\", \\"111\\"]), (4, [\\"1100\\", \\"1110\\", \\"0111\\", \\"0111\\"]])) [3, 2] >>> largest_square_subgrid(1, [(1, [\\"0\\"])]) [0]","solution":"def largest_square_subgrid(t, test_cases): results = [] for test_case in test_cases: n, grid = test_case dp = [[0] * (n + 1) for _ in range(n + 1)] max_side = 0 for i in range(1, n + 1): for j in range(1, n + 1): if grid[i-1][j-1] == '1': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) results.append(max_side) return results # Example usage t = 2 test_cases = [ (3, [\\"111\\", \\"111\\", \\"111\\"]), (4, [\\"1100\\", \\"1110\\", \\"0111\\", \\"0111\\"]) ] print(largest_square_subgrid(t, test_cases)) # Output: [3, 2]"},{"question":"def can_reach_end(N, M, grid): Determines if the player can reach the bottom-right cell from the top-left cell without encountering any blocked cells. Args: N : int : the number of rows in the grid M : int : the number of columns in the grid grid : List of str : the grid representation Returns: str : 'YES' if the player can reach the bottom-right cell, otherwise 'NO' Examples: >>> can_reach_end(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 'YES' >>> can_reach_end(3, 3, [\\"...\\", \\"..#\\", \\".#.\\"]) 'NO'","solution":"def can_reach_end(N, M, grid): Determines if the player can reach the bottom-right cell from the top-left cell without encountering any blocked cells. Args: N : int : the number of rows in the grid M : int : the number of columns in the grid grid : List of str : the grid representation Returns: str : 'YES' if the player can reach the bottom-right cell, otherwise 'NO' if grid[0][0] == '#' or grid[N-1][M-1] == '#': return \\"NO\\" # Initialize a DP table to store whether a cell is reachable or not dp = [[False] * M for _ in range(N)] dp[0][0] = True for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = False else: if i > 0: dp[i][j] = dp[i][j] or dp[i-1][j] if j > 0: dp[i][j] = dp[i][j] or dp[i][j-1] return \\"YES\\" if dp[N-1][M-1] else \\"NO\\""},{"question":"def is_possible_split(K: int, N: int, hobbies: List[int]) -> str: Determine if it is possible to split the citizens into exactly K contiguous groups such that each group contains the same number of hobbies. Args: K (int): Number of hobby groups N (int): Number of citizens hobbies (List[int]): List of integers representing the hobbies of citizens Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\" >>> is_possible_split(2, 6, [1, 1, 2, 2, 1, 2]) \\"YES\\" >>> is_possible_split(3, 9, [1, 2, 3, 1, 2, 3, 1, 2, 3]) \\"YES\\" >>> is_possible_split(2, 5, [1, 1, 2, 2, 1]) \\"NO\\" def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Process multiple test cases for determining if the citizens can be split as required. Args: T (int): Number of test cases test_cases (List[Tuple[int, int, List[int]]]): List of tuples containing K, N and hobbies Returns: List[str]: List of results for each test case >>> process_test_cases(3, [(2, 6, [1, 1, 2, 2, 1, 2]), (3, 9, [1, 2, 3, 1, 2, 3, 1, 2, 3]), (2, 5, [1, 1, 2, 2, 1])]) [\\"YES\\", \\"YES\\", \\"NO\\"] from typing import List, Tuple def test_is_possible_split(): test_cases = [ (2, 6, [1, 1, 2, 2, 1, 2], \\"YES\\"), (3, 9, [1, 2, 3, 1, 2, 3, 1, 2, 3], \\"YES\\"), (2, 5, [1, 1, 2, 2, 1], \\"NO\\"), (3, 6, [1, 1, 2, 2, 3, 3], \\"YES\\"), (4, 8, [1, 2, 3, 4, 1, 2, 3, 4], \\"YES\\"), (3, 7, [1, 1, 2, 2, 3, 3, 2], \\"NO\\"), (1, 4, [1, 1, 1, 1], \\"YES\\"), (2, 4, [1, 1, 2, 2], \\"YES\\"), (2, 4, [1, 2, 1, 2], \\"YES\\"), (2, 4, [1, 1, 1, 2], \\"NO\\") ] for K, N, hobbies, expected in test_cases: assert is_possible_split(K, N, hobbies) == expected def test_process_test_cases(): test_input = [ (2, 6, [1, 1, 2, 2, 1, 2]), (3, 9, [1, 2, 3, 1, 2, 3, 1, 2, 3]), (2, 5, [1, 1, 2, 2, 1]) ] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(3, test_input) == expected_output","solution":"def is_possible_split(K, N, hobbies): if N % K != 0: return \\"NO\\" # early exit if N is not multiple of K group_size = N // K hobby_count = [0] * K for hobby in hobbies: hobby_count[hobby - 1] += 1 for count in hobby_count: if count % group_size != 0: return \\"NO\\" return \\"YES\\" def process_test_cases(T, test_cases): results = [] for K, N, hobbies in test_cases: results.append(is_possible_split(K, N, hobbies)) return results"},{"question":"def calculate_total_cost(purchases): A bakery offers a special discount based on the type and quantity of baked goods purchased. The discount rules for the bakery are as follows: 1. For every 3 loaves of bread, you get 1 loaf for free. 2. For every 2 cakes, you get a 50% discount on the second cake. 3. For every 5 cookies, you get 2 cookies for free. The price list is as follows: - Bread: 3.00 each - Cake: 7.00 each - Cookie: 2.00 each The input is a dictionary where keys are the names of the baked goods ('bread', 'cake', 'cookie') and values are the quantities purchased. Examples: >>> calculate_total_cost({'bread': 3, 'cake': 1, 'cookie': 5}) 18.0 >>> calculate_total_cost({'bread': 4, 'cake': 2, 'cookie': 6}) 27.5 >>> calculate_total_cost({'bread': 7, 'cake': 4, 'cookie': 12}) 52.0 Returns the total cost as a float rounded to two decimal places.","solution":"def calculate_total_cost(purchases): prices = { 'bread': 3.00, 'cake': 7.00, 'cookie': 2.00 } total_cost = 0.0 if 'bread' in purchases: bread_qty = purchases['bread'] bread_cost = (bread_qty // 3) * 2 * prices['bread'] + (bread_qty % 3) * prices['bread'] total_cost += bread_cost if 'cake' in purchases: cake_qty = purchases['cake'] cake_cost = (cake_qty // 2) * (prices['cake'] + prices['cake'] * 0.5) + (cake_qty % 2) * prices['cake'] total_cost += cake_cost if 'cookie' in purchases: cookie_qty = purchases['cookie'] cookie_cost = (cookie_qty // 5) * 3 * prices['cookie'] + (cookie_qty % 5) * prices['cookie'] total_cost += cookie_cost return round(total_cost, 2)"},{"question":"def decode_message(n: int, m: int, measurements: List[str]) -> str: Determine the most probable original message from noisy measurements. Parameters: - n (int): The length of the binary string. - m (int): The number of noisy measurements. - measurements (list of str): The noisy binary strings. Returns: - str: The most probable original message. >>> decode_message(5, 3, [\\"10101\\", \\"11100\\", \\"10100\\"]) \\"10100\\" >>> decode_message(4, 2, [\\"0001\\", \\"0011\\"]) \\"0001\\"","solution":"def decode_message(n, m, measurements): Determine the most probable original message from noisy measurements. Parameters: - n (int): The length of the binary string. - m (int): The number of noisy measurements. - measurements (list of str): The noisy binary strings. Returns: - str: The most probable original message. from collections import Counter # Initialize the count arrays for each bit position bit_count = [[0, 0] for _ in range(n)] # Count the occurrences of '0' and '1' at each bit position for measurement in measurements: for idx, char in enumerate(measurement): bit_count[idx][int(char)] += 1 # Determine the most common bit at each position original_message = ''.join('1' if bit_count[idx][1] > bit_count[idx][0] else '0' for idx in range(n)) return original_message"},{"question":"def prepare_solution(V: float, C: float) -> (int, int, int): Prepare the required solution volume V with concentration C using solutions A, B, and C. Solutions have concentrations of 10%, 20%, and 30%, respectively. Returns the volumes (in liters) of A, B, and C used. If there are multiple solutions, returns any one of them. >>> prepare_solution(100.0, 10.0) (100, 0, 0) >>> prepare_solution(100.0, 20.0) (0, 100, 0) >>> prepare_solution(100.0, 30.0) (0, 0, 100) >>> prepare_solution(150.0, 25.0) (75, 0, 75)","solution":"def prepare_solution(V, C): Prepare the required solution volume V with concentration C using solutions A, B, and C. Solutions have concentrations of 10%, 20%, and 30%, respectively. Returns the volumes of A, B, and C used. # Simple case where the target concentration matches one of the solution concentrations if C == 10.0: return V, 0, 0 elif C == 20.0: return 0, V, 0 elif C == 30.0: return 0, 0, V # We need to find volumes a, b, and c such that: # a + b + c = V # 10a + 20b + 30c = C * V # Substituting b and c in terms of a: for a in range(int(V) + 1): for b in range(int(V - a) + 1): c = V - a - b if (10 * a + 20 * b + 30 * c) == (C * V): return a, b, c return 0, 0, 0"},{"question":"def count_file_extensions(file_list: List[str]) -> dict: Count the number of files for each extension (case-insensitive). Args: file_list (list of str): List of filenames with extensions. Returns: dict: Dictionary with extensions as keys and their counts as values. Example: >>> count_file_extensions([\\"report.docx\\", \\"data.csv\\", \\"SCRIPT.JS\\", \\"image.PNG\\", \\"photo.jpg\\"]) {\\"docx\\": 1, \\"csv\\": 1, \\"js\\": 1, \\"png\\": 1, \\"jpg\\": 1} pass def organize_files_by_extension(file_list: List[str]) -> List[str]: Organize files by their extensions and return the counts sorted by the extension alphabetically. Args: file_list (list of str): List of filenames with extensions. Returns: list of str: List of strings where each string represents extension and count in the format \\"extension count\\". Example: >>> organize_files_by_extension([\\"report.docx\\", \\"data.csv\\", \\"SCRIPT.JS\\", \\"image.PNG\\", \\"photo.jpg\\"]) [\\"csv 1\\", \\"docx 1\\", \\"jpg 1\\", \\"js 1\\", \\"png 1\\"] pass","solution":"def count_file_extensions(file_list): Count the number of files for each extension (case-insensitive). Args: file_list (list of str): List of filenames with extensions. Returns: dict: Dictionary with extensions as keys and their counts as values. extension_count = {} for file in file_list: extension = file.split('.')[-1].lower() if extension in extension_count: extension_count[extension] += 1 else: extension_count[extension] = 1 return extension_count def organize_files_by_extension(file_list): Organize files by their extensions and return the counts sorted by the extension alphabetically. Args: file_list (list of str): List of filenames with extensions. Returns: list of str: List of strings where each string represents extension and count in the format \\"extension count\\". extension_count = count_file_extensions(file_list) sorted_extensions = sorted(extension_count.keys()) result = [f\\"{ext} {extension_count[ext]}\\" for ext in sorted_extensions] return result"},{"question":"def longest_unique_path(R: int, C: int, grid: List[str]) -> int: Finds the length of the longest path in a grid where each cell in the path contains a unique letter. >>> longest_unique_path(2, 2, [\\"ab\\", \\"cd\\"]) 4 >>> longest_unique_path(3, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 12 >>> longest_unique_path(1, 1, [\\"a\\"]) 1 >>> longest_unique_path(3, 3, [\\"aaa\\", \\"aba\\", \\"aaa\\"]) 2 >>> longest_unique_path(1, 5, [\\"abcde\\"]) 5 >>> longest_unique_path(5, 1, [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) 5","solution":"def longest_unique_path(R, C, grid): def dfs(x, y, path_set): max_length = len(path_set) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] not in path_set: path_set.add(grid[nx][ny]) max_length = max(max_length, dfs(nx, ny, path_set)) path_set.remove(grid[nx][ny]) return max_length max_path_length = 0 for i in range(R): for j in range(C): max_path_length = max(max_path_length, dfs(i, j, set(grid[i][j]))) return max_path_length # Example usage # R, C = 2, 2 # grid = [\\"ab\\", \\"cd\\"] # print(longest_unique_path(R, C, grid)) # Output: 4"},{"question":"def top_selling_book(book_sales): Determines the top-selling book based on sales records. Parameters: book_sales (list): List of integers representing book IDs sold. Returns: int: ID of the book sold the most. If multiple books have the same highest sales, return any one of them. >>> top_selling_book([1]) 1 >>> top_selling_book([1, 2, 2, 3, 1]) in [1, 2] True >>> top_selling_book([5, 5, 5, 5]) 5 >>> top_selling_book([4, 4, 2, 2]) in [4, 2] True >>> top_selling_book([5, 4, 5]) 5 >>> top_selling_book([4, 5, 5]) 5 >>> top_selling_book([10, 20, 30, 40, 10]) 10 >>> top_selling_book([100000, 99999, 100000]) 100000","solution":"def top_selling_book(book_sales): Determines the top-selling book based on sales records. Parameters: book_sales (list): List of integers representing book IDs sold. Returns: int: ID of the book sold the most. If multiple books have the same highest sales, return any one of them. from collections import Counter sales_count = Counter(book_sales) top_selling = max(sales_count, key=sales_count.get) return top_selling"},{"question":"def is_valid_sudoku(board): Checks if the provided Sudoku board is valid. :param board: 2D list with 9x9 dimensions representing the Sudoku board. :return: Boolean indicating whether the board is valid. Example: >>> board = [ ... [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], ... [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], ... [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], ... [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], ... [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ... ] >>> is_valid_sudoku(board) True pass from solution import is_valid_sudoku def test_valid_sudoku(): board = [ [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] assert is_valid_sudoku(board) == True def test_invalid_sudoku_row_duplicate(): board = [ [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\"6\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] assert is_valid_sudoku(board) == False def test_invalid_sudoku_column_duplicate(): board = [ [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] assert is_valid_sudoku(board) == False def test_invalid_sudoku_subgrid_duplicate(): board = [ [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\"3\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] assert is_valid_sudoku(board) == False","solution":"def is_valid_sudoku(board): Checks if the provided Sudoku board is valid. :param board: 2D list with 9x9 dimensions representing the Sudoku board. :return: Boolean indicating whether the board is valid. # Helper function to check if a sub-box, row, or column is valid. def is_valid_unit(unit): unit = [i for i in unit if i != '.'] return len(unit) == len(set(unit)) # Check rows and columns. for i in range(9): row = [board[i][j] for j in range(9)] column = [board[j][i] for j in range(9)] if not is_valid_unit(row) or not is_valid_unit(column): return False # Check 3x3 sub-grids. for i in range(0, 9, 3): for j in range(0, 9, 3): subgrid = [ board[x][y] for x in range(i, i + 3) for y in range(j, j + 3) ] if not is_valid_unit(subgrid): return False return True"},{"question":"def lengthOfLongestSubstringTwoDistinct(nums: List[int]) -> int: Returns the length of the longest subarray that contains at most two distinct integers. Examples: >>> lengthOfLongestSubstringTwoDistinct([1, 2, 1]) 3 >>> lengthOfLongestSubstringTwoDistinct([0, 1, 2, 2]) 3 >>> lengthOfLongestSubstringTwoDistinct([1, 2, 3, 4, 5]) 2","solution":"def lengthOfLongestSubstringTwoDistinct(nums): Returns the length of the longest subarray that contains at most two distinct integers. n = len(nums) if n < 3: return n left = 0 right = 0 hashmap = {} max_len = 2 while right < n: if len(hashmap) < 3: hashmap[nums[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[nums[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"from typing import List def max_photos(stored: List[int], capacity: int) -> int: Determines the maximum number of photos that can be stored without exceeding the given capacity. >>> max_photos([200000000, 150000000, 300000000, 500000000], 800000000) 3 >>> max_photos([100000000, 200000000, 300000000], 1000000000) 3 >>> max_photos([500000000, 400000000, 600000000], 100000000) 0 >>> max_photos([100000000, 100000000, 300000000, 400000000], 500000000) 3 >>> max_photos([100000000, 300000000], 400000000) 2 >>> max_photos([], 500000000) 0 >>> max_photos([100000000, 300000000], 0) 0","solution":"def max_photos(stored, capacity): This function takes a list of photo sizes and a remaining capacity in bytes, and returns the maximum number of photos that can be stored without exceeding the given capacity. # Sort the list of photo sizes in ascending order stored.sort() # Initialize variables to count photos and track the used capacity count = 0 used_capacity = 0 # Iterate through the sorted photo sizes for photo_size in stored: # Check if adding this photo exceeds the remaining capacity if used_capacity + photo_size <= capacity: # If not, add the photo size to the used capacity and increment the count used_capacity += photo_size count += 1 else: # If it does, break out of the loop since adding more photos is not possible break # Return the total count of photos that can be stored return count"},{"question":"def calculate_scores(m: int, n: int, weights: List[int], scores_matrix: List[List[int]]) -> List[Tuple[int, int]]: Calculate the total score for each participant and return the results in descending order. Each participant's score is calculated based on the weights of problems they solved correctly. :param m: Number of participants :param n: Number of problems :param weights: List of weights for each problem :param scores_matrix: Matrix containing scores (1 if solved correctly, 0 otherwise) for each participant :return: List of tuples containing total score and participant index in descending order of scores >>> calculate_scores(4, 3, [5, 3, 2], [[1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 1, 1]]) [(11, 4), (8, 2), (7, 1), (2, 3)] >>> calculate_scores(2, 2, [5, 5], [[1, 1], [1, 1]]) [(10, 1), (10, 2)] >>> calculate_scores(3, 3, [1, 10, 100], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) [(100, 3), (10, 2), (1, 1)] >>> calculate_scores(2, 3, [3, 6, 9], [[0, 0, 0], [0, 0, 0]]) [(0, 1), (0, 2)]","solution":"def calculate_scores(m, n, weights, scores_matrix): participants_scores = [] for i in range(m): total_score = sum(weights[j] * scores_matrix[i][j] for j in range(n)) participants_scores.append((total_score, i + 1)) participants_scores.sort(key=lambda x: (-x[0], x[1])) return participants_scores def print_scores(scores): for score in scores: print(f\\"{score[0]} {score[1]}\\") def main(): import sys input = sys.stdin.read data = input().split() idx = 0 m = int(data[idx]) n = int(data[idx + 1]) idx += 2 weights = [int(data[i]) for i in range(idx, idx + n)] idx += n scores_matrix = [] for i in range(m): scores_matrix.append([int(data[j]) for j in range(idx, idx + n)]) idx += n scores = calculate_scores(m, n, weights, scores_matrix) print_scores(scores)"},{"question":"def find_pairs_with_sum(n, arr, target): Finds and prints all pairs of integers in the list whose sum is equal to the given target value. Each pair is printed on a new line, sorted in increasing order based on the first integer of the pair. If no such pairs exist, it prints \\"No pairs found\\". Args: n (int): Number of elements in the list. arr (List[int]): List of integers. target (int): Target sum. Returns: None Examples: >>> find_pairs_with_sum(6, [1, 5, -1, 4, 2, -4], 0) -4 4 -1 1 >>> find_pairs_with_sum(3, [3, 3, 3], 6) 3 3 >>> find_pairs_with_sum(4, [1, 2, 3, 4], 8) No pairs found","solution":"def find_pairs_with_sum(n, arr, target): Finds and prints all pairs of integers in the list whose sum is equal to the given target value. Each pair is printed on a new line, sorted in increasing order based on the first integer of the pair. If no such pairs exist, it prints \\"No pairs found\\". pairs = [] seen = set() for number in arr: complement = target - number if complement in seen: pairs.append((min(number, complement), max(number, complement))) seen.add(number) pairs = list(set(pairs)) pairs.sort() if pairs: for pair in pairs: print(pair[0], pair[1]) else: print(\\"No pairs found\\")"},{"question":"def find_min_abs_difference(N: int, arr: List[int]) -> int: Function to find the minimum possible absolute difference between the sums of two non-empty contiguous subarrays of the given array. Args: N : int : the length of the array arr : List[int] : the list of integers Returns: int : the minimum possible absolute difference Examples: >>> find_min_abs_difference(5, [1, 2, 3, 4, 5]) 3 >>> find_min_abs_difference(4, [10, -10, 20, -20]) 0 >>> find_min_abs_difference(3, [1, 3, -1]) 1","solution":"def find_min_abs_difference(N, arr): Function to find the minimum possible absolute difference between the sums of two non-empty contiguous subarrays of the given array. total_sum = sum(arr) min_diff = float('inf') left_sum = 0 for i in range(N - 1): left_sum += arr[i] right_sum = total_sum - left_sum current_diff = abs(left_sum - right_sum) min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def rotate_matrix(mat: List[List[int]], k: int) -> List[List[int]]: Rotate the matrix 90 degrees clockwise k times. Args: mat (List[List[int]]): A list of lists of integers representing the matrix k (int): Number of times the matrix should be rotated 90 degrees clockwise Returns: List[List[int]]: The matrix after performing the rotations Examples: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]], 2) [[4, 3], [2, 1]] >>> rotate_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 3) [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]","solution":"def rotate_matrix(mat, k): Rotates the matrix 90 degrees clockwise k times. def rotate_once(matrix): return [list(reversed(col)) for col in zip(*matrix)] for _ in range(k % 4): # Since rotating 4 times results in the same matrix mat = rotate_once(mat) return mat"},{"question":"def min_window(s: str, t: str) -> str: Returns the minimum window in s which will contain all the characters in t. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> min_window(\\"a\\", \\"a\\") 'a' >>> min_window(\\"a\\", \\"aa\\") '' from solution import min_window def test_min_window_example_1(): assert min_window(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" def test_min_window_example_2(): assert min_window(\\"a\\", \\"a\\") == \\"a\\" def test_min_window_example_3(): assert min_window(\\"a\\", \\"aa\\") == \\"\\" def test_min_window_no_valid_window(): assert min_window(\\"ADOBECODEBANC\\", \\"XYZ\\") == \\"\\" def test_min_window_empty_string_s(): assert min_window(\\"\\", \\"ABC\\") == \\"\\" def test_min_window_empty_string_t(): assert min_window(\\"ADOBECODEBANC\\", \\"\\") == \\"\\" def test_min_window_t_larger_than_s(): assert min_window(\\"a\\", \\"aa\\") == \\"\\" def test_min_window_all_characters_in_s(): assert min_window(\\"ABC\\", \\"ABC\\") == \\"ABC\\" def test_min_window_single_repeated_character(): assert min_window(\\"aa\\", \\"aa\\") == \\"aa\\" def test_min_window_no_repeated_characters(): assert min_window(\\"abc\\", \\"cba\\") == \\"abc\\"","solution":"def min_window(s, t): Returns the minimum window in s which will contain all the characters in t. If there is no such window, returns the empty string \\"\\". from collections import Counter, defaultdict if not s or not t: return \\"\\" t_count = Counter(t) current_count = defaultdict(int) required = len(t_count) formed = 0 l, r = 0, 0 min_len = float('inf') start, end = 0, 0 while r < len(s): character = s[r] current_count[character] += 1 if character in t_count and current_count[character] == t_count[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < min_len: min_len = r - l + 1 start, end = l, r current_count[character] -= 1 if character in t_count and current_count[character] < t_count[character]: formed -= 1 l += 1 r += 1 return \\"\\" if min_len == float('inf') else s[start:end + 1]"},{"question":"from typing import List, Tuple def min_transformations(start: str, end: str, transformations: List[Tuple[str, str]]) -> int: Find the minimum number of transformations required to convert the \`start\` string into the \`end\` string by applying given allowed transformations, or return \`-1\` if the transformation is not possible. >>> min_transformations(\\"abc\\", \\"def\\", [(\\"a\\", \\"d\\"), (\\"b\\", \\"e\\"), (\\"c\\", \\"f\\")]) == 3 >>> min_transformations(\\"xyz\\", \\"foo\\", [(\\"x\\", \\"m\\"), (\\"y\\", \\"n\\")]) == -1 pass def process_input(num_datasets: int, datasets: List[Tuple[str, str, int, List[Tuple[str, str]]]]) -> List[int]: Process multiple datasets and output the minimum number of transformations required, or \`-1\` if transformation is not possible for each dataset. >>> process_input(2, [(\\"abc\\", \\"def\\", 3, [(\\"a\\", \\"d\\"), (\\"b\\", \\"e\\"), (\\"c\\", \\"f\\")]), (\\"xyz\\", \\"foo\\", 2, [(\\"x\\", \\"m\\"), (\\"y\\", \\"n\\")])]) == [3, -1] >>> process_input(1, [(\\"aaaa\\", \\"bbbb\\", 1, [(\\"a\\", \\"b\\")])]) == [4] pass","solution":"from collections import deque, defaultdict def min_transformations(start, end, transformations): if start == end: return 0 allowed = defaultdict(list) for a, b in transformations: allowed[a].append(b) queue = deque([(start, 0)]) visited = set() while queue: current, steps = queue.popleft() if current == end: return steps if current in visited: continue visited.add(current) for i, (c_start, c_end) in enumerate(zip(current, end)): if c_start != c_end: alternatives = allowed[c_start] for alt in alternatives: next_state = current[:i] + alt + current[i+1:] if next_state not in visited: queue.append((next_state, steps + 1)) return -1 def process_input(num_datasets, datasets): results = [] for i in range(num_datasets): dataset = datasets[i] start, end, n, transformations = dataset results.append(min_transformations(start, end, transformations)) return results"},{"question":"from typing import List, Tuple def most_frequent_species(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the species that appears most frequently in the collection. If there's a tie, return the smallest label. Args: T (int): Number of test cases. cases (List[Tuple[int, List[int]]]): List of tuples, where each tuple contains an integer N and a list of N integers representing wildlife species labels. Returns: List[int]: List of labels of the most frequently appearing species for each test case. If no photos taken, return None for that test case. >>> most_frequent_species(2, [(5, [3, 3, 2, 5, 2]), (4, [1, 2, 2, 1])]) [2, 1] >>> most_frequent_species(1, [(1, [7])]) [7] >>> most_frequent_species(1, [(5, [4, 4, 4, 4, 4])]) [4] >>> most_frequent_species(1, [(0, [])]) [None] >>> most_frequent_species(1, [(6, [3, 3, 1, 1, 2, 2])]) [1] >>> most_frequent_species(1, [(1000, [i % 10 for i in range(1000)])]) [0]","solution":"from collections import Counter def most_frequent_species(T, cases): results = [] for i in range(T): N = cases[i][0] species_labels = cases[i][1] if N == 0: results.append(None) continue frequency_count = Counter(species_labels) most_common_label = min(frequency_count, key=lambda x: (-frequency_count[x], x)) results.append(most_common_label) return results"},{"question":"def calculateDiscount(price: float, isMember: bool) -> float: Calculate the price after applying the discount. If the buyer is a member of the store, they receive a 20% discount. Otherwise, a 10% discount is applied. Examples: >>> calculateDiscount(100, True) 80.0 >>> calculateDiscount(100, False) 90.0 >>> calculateDiscount(200, True) 160.0 >>> calculateDiscount(200, False) 180.0","solution":"def calculateDiscount(price, isMember): Calculate the price after applying the discount. Parameters: - price (float): The original price of the item. - isMember (bool): Whether the buyer is a member of the store. Returns: - float: The price after applying the discount. if isMember: return price * 0.8 else: return price * 0.9"},{"question":"from typing import List, Tuple def important_nodes(n: int, m: int, edges: List[Tuple[int, int]]) -> List[int]: Find the important nodes in an undirected graph. An important node is defined as a node that, if removed along with its incident edges, would increase the number of connected components of the graph. Args: n (int): Number of nodes. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges where each edge is represented by a tuple of two integers. Returns: List[int]: A sorted list of important nodes. If there are no important nodes, return [-1]. Examples: >>> important_nodes(7, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) [2, 3, 4, 5, 6] >>> important_nodes(2, 1, [(1, 2)]) [-1]","solution":"from collections import defaultdict def find_important_nodes(n, m, edges): def dfs(v, parent): nonlocal time visited[v] = True discovery[v] = low[v] = time time += 1 children = 0 for to in graph[v]: if to == parent: continue if visited[to]: # Update the low-link value low[v] = min(low[v], discovery[to]) else: dfs(to, v) # Update the low-link value after recursive DFS call low[v] = min(low[v], low[to]) # Check if v is an articulation point if low[to] >= discovery[v] and parent != -1: articulation_points.add(v) children += 1 # Special case for root node if parent == -1 and children > 1: articulation_points.add(v) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) discovery = [float('inf')] * (n + 1) low = [float('inf')] * (n + 1) articulation_points = set() time = 0 for i in range(1, n + 1): if not visited[i]: dfs(i, -1) if not articulation_points: return [-1] else: return sorted(articulation_points) def important_nodes(n, m, edges): return find_important_nodes(n, m, edges)"},{"question":"def rotate_matrix_90_clockwise(matrix): Given a matrix of size n x n filled with integer values, rotate the matrix 90 degrees clockwise. Constraints: - 1 ≤ n ≤ 100 - -1000 ≤ matrix[i][j] ≤ 1000 Input: - An integer n, followed by an n x n matrix. Output: - The rotated matrix. Examples: >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise. n = len(matrix) # Create a new matrix for the rotated result rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - i - 1] = matrix[i][j] return rotated"},{"question":"def count_unique_file_paths(firm_data): Given the lists of file paths from participating firms, returns the number of unique file paths. Parameters: firm_data (list): List of tuples where each tuple contains the number of file paths followed by the file path strings. Returns: int: The number of unique file paths across all lists. >>> count_unique_file_paths([(3, 'src/main.py', 'src/utils.py', 'README.md'), (2, 'src/utils.py', 'src/config.yaml'), (4, 'tests/test_main.py', 'README.md', 'src/config.yaml', 'LICENSE.txt')]) 6 >>> count_unique_file_paths([(3, 'a.txt', 'b.txt', 'c.txt')]) 3 >>> count_unique_file_paths([(0,)]) 0 >>> count_unique_file_paths([(3, 'a.txt', 'b.txt', 'a.txt'), (2, 'a.txt', 'c.txt')]) 3 >>> count_unique_file_paths([(2, 'File.txt', 'file.txt'), (2, 'FILE.txt', 'file.txt')]) 3","solution":"def count_unique_file_paths(firm_data): Given the lists of file paths from participating firms, returns the number of unique file paths. Parameters: firm_data (list): List of tuples where each tuple contains the number of file paths followed by the file path strings. Returns: int: The number of unique file paths across all lists. unique_paths = set() for firm in firm_data: num_files = firm[0] file_paths = firm[1:num_files + 1] unique_paths.update(file_paths) return len(unique_paths)"},{"question":"def maximize_lexicographical_string(T: int, test_cases: List[Tuple[str, int]]) -> List[str]: You are given a string S consisting of lowercase English letters and a number K. You want to perform exactly K operations on the string to maximize the lexicographical value of the resulting string. In one operation, you can: - Choose any non-empty substring of S and reverse it. Your task is to find the lexicographically largest string possible after exactly K operations. Parameters: - T (int): The number of test cases. - test_cases (List[Tuple[str, int]]): Each test case starts with a string S and an integer K. Returns: List[str]: For each test case, the lexicographically largest string possible after exactly K operations. Examples: >>> maximize_lexicographical_string(3, [(\\"abc\\", 1), (\\"abba\\", 2), (\\"dcba\\", 1)]) ['cba', 'bbaa', 'dcba'] from typing import List, Tuple def test_single_case(): assert maximize_lexicographical_string(1, [(\\"abc\\", 1)]) == ['cba'] def test_multiple_operations(): assert maximize_lexicographical_string(1, [(\\"abba\\", 2)]) == ['bbaa'] def test_non_improvement_case(): assert maximize_lexicographical_string(1, [(\\"dcba\\", 1)]) == ['dcba'] def test_multiple_cases(): assert maximize_lexicographical_string(3, [(\\"abc\\", 1), (\\"abba\\", 2), (\\"dcba\\", 1)]) == ['cba', 'bbaa', 'dcba'] def test_all_chars_the_same(): assert maximize_lexicographical_string(1, [(\\"aaaa\\", 3)]) == ['aaaa']","solution":"def maximize_lexicographical_string(T, test_cases): results = [] for S, K in test_cases: if K == 1: results.append(''.join(sorted(S, reverse=True))) else: results.append(''.join(sorted(S, reverse=True))) return results"},{"question":"def min_max_files_per_server(m: int, n: int) -> int: Returns the minimum possible value for the maximum number of files any single server holds. Examples: >>> min_max_files_per_server(3, 5) 2 >>> min_max_files_per_server(4, 10) 3 >>> min_max_files_per_server(1, 7) 7 >>> min_max_files_per_server(5, 2) 1 >>> min_max_files_per_server(10**5, 10**9) 10000","solution":"def min_max_files_per_server(m, n): Returns the minimum possible value for the maximum number of files any single server holds. # If there are fewer files than servers, the max number files per server is 1. if n <= m: return 1 return (n + m - 1) // m # This is equivalent to ceiling division: math.ceil(n / m)"},{"question":"def get_prefix_sums(arr): This function returns the prefix sums of the input array. pass def query_sums(prefix_sums, l, r): This function returns the sum of the subarray from index l to r (inclusive) using the prefix sums array. pass def find_subarray_sums(arr, queries): Given an array arr of N integers and a list of Q queries, where each query is a tuple (l, r), this function returns a list of sums for each subarray defined by the queries. >>> find_subarray_sums([1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> find_subarray_sums([1], [(1, 1)]) [1] >>> find_subarray_sums([1000000000], [(1, 1)]) [1000000000] pass","solution":"def get_prefix_sums(arr): This function returns the prefix sums of the input array. prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(prefix_sums)): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] return prefix_sums def query_sums(prefix_sums, l, r): This function returns the sum of the subarray from index l to r (inclusive) using the prefix sums array. return prefix_sums[r] - prefix_sums[l - 1] def find_subarray_sums(arr, queries): prefix_sums = get_prefix_sums(arr) results = [] for l, r in queries: results.append(query_sums(prefix_sums, l, r)) return results"},{"question":"def max_orders_delivered(d: int, o: int, drone_capacities: List[int], order_distances: List[int]) -> int: Returns the maximum number of orders that can be successfully delivered by the delivery drones. Parameters: d (int): Number of drones. o (int): Number of orders. drone_capacities (List[int]): List of maximum distances each drone can cover. order_distances (List[int]): List of distances to each order destination. Returns: int: Maximum number of orders that can be delivered. Example: >>> max_orders_delivered(3, 4, [5, 7, 8], [4, 6, 8, 10]) 3 >>> max_orders_delivered(2, 2, [5, 3], [6, 7]) 0","solution":"def max_orders_delivered(d, o, drone_capacities, order_distances): Returns the maximum number of orders that can be successfully delivered. # Sort drone capacities in increasing order drone_capacities.sort() # Sort order distances in increasing order order_distances.sort() delivered_orders = 0 i, j = 0, 0 while i < d and j < o: if drone_capacities[i] >= order_distances[j]: # Drone i can deliver order j delivered_orders += 1 j += 1 # Move to the next drone i += 1 return delivered_orders"},{"question":"def count_days_above_average(N: int, temperatures: List[int]) -> int: Counts the number of days when the temperature was strictly greater than the average temperature. :param N: Integer, number of days of temperature recordings. :param temperatures: List of integers, each representing the temperature on a particular day. :return: Integer, number of days with temperature strictly greater than the average temperature. >>> count_days_above_average(5, [10, 20, 30, 40, 50]) == 2 >>> count_days_above_average(3, [-10, 0, 10]) == 1 >>> count_days_above_average(4, [0,0,0,0]) == 0 >>> count_days_above_average(1, [10]) == 0 >>> count_days_above_average(6, [1, 2, 3, 4, 5, 6]) == 3 >>> count_days_above_average(3, [100, 0, -100]) == 1 pass","solution":"def count_days_above_average(N, temperatures): Counts the number of days when the temperature was strictly greater than the average temperature. :param N: Integer, number of days of temperature recordings. :param temperatures: List of integers, each representing the temperature on a particular day. :return: Integer, number of days with temperature strictly greater than the average temperature. average_temp = sum(temperatures) / N return sum(1 for temp in temperatures if temp > average_temp)"},{"question":"def most_frequent_char(s: str) -> str: Returns the most frequently occurring character in the string. If there is a tie, returns the character that comes first lexicographically. >>> most_frequent_char(\\"examplestring\\") == 'e' >>> most_frequent_char(\\"aabbcc\\") == 'a' >>> most_frequent_char(\\"aaaaa\\") == 'a' >>> most_frequent_char(\\"banana\\") == 'a' >>> most_frequent_char(\\"z\\") == 'z' >>> most_frequent_char(\\"abbccc\\") == 'c'","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string. If there is a tie, returns the character that comes first lexicographically. from collections import Counter count = Counter(s) max_count = max(count.values()) # Filter characters with the max_count and return the smallest lexicographically return min([char for char, cnt in count.items() if cnt == max_count])"},{"question":"def max_sum_submatrix(matrix): Given a matrix of integers with n rows and m columns, find the maximum sum of any submatrix and determine the smallest submatrix (in terms of area) which, when added to this maximum sum submatrix, results in a new submatrix that has an even larger sum. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_sum_submatrix(matrix) (45, 1) >>> matrix = [ ... [7] ... ] >>> max_sum_submatrix(matrix) (7, 1) >>> matrix = [ ... [-1, -2], ... [-3, 4] ... ] >>> max_sum_submatrix(matrix) (4, 1) >>> matrix = [ ... [-1, -2], ... [-3, -4] ... ] >>> max_sum_submatrix(matrix) (-1, 1) >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> max_sum_submatrix(matrix) (136, 1)","solution":"def max_sum_submatrix(matrix): def calculate_prefix_sum(matrix): n, m = len(matrix), len(matrix[0]) prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sum[i + 1][j + 1] = matrix[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] return prefix_sum def get_sum(prefix_sum, x1, y1, x2, y2): return ( prefix_sum[x2 + 1][y2 + 1] - prefix_sum[x1][y2 + 1] - prefix_sum[x2 + 1][y1] + prefix_sum[x1][y1] ) n, m = len(matrix), len(matrix[0]) prefix_sum = calculate_prefix_sum(matrix) max_sum = float('-inf') for x1 in range(n): for y1 in range(m): for x2 in range(x1, n): for y2 in range(y1, m): current_sum = get_sum(prefix_sum, x1, y1, x2, y2) max_sum = max(max_sum, current_sum) smallest_positive = float('inf') for i in range(n): for j in range(m): if matrix[i][j] > 0: smallest_positive = min(smallest_positive, matrix[i][j]) return max_sum, 1 # Since the smallest submatrix increasing the sum by a positive value will have an area of 1."},{"question":"def find_swaps(nums, target): Given two integer arrays \`nums\` and \`target\` where \`nums\` is a non-empty array of distinct integers and \`target\` is an array generated by shuffling \`nums\`, find the minimum number of swaps to transform \`nums\` into \`target\`. Each swap should be represented as a pair of indices. The function should return a list of swaps with each swap represented as a list of two integers. Args: nums (List[int]): The initial array of integers. target (List[int]): The target array of integers after shuffling. Returns: List[List[int]]: A 2-dimensional list containing the series of swaps required to transform nums to target. >>> find_swaps([1, 3, 2], [3, 2, 1]) [[0, 1], [1, 2]] >>> find_swaps([1, 2, 3], [1, 2, 3]) [] >>> find_swaps([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) [[0, 4], [1, 3]] def solve(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): n = int(data[index]) index += 1 nums = list(map(int, data[index:index + n])) index += n target = list(map(int, data[index:index + n])) index += n swaps = find_swaps(nums, target) results.append((len(swaps), swaps)) for m, swaps in results: print(m) for i, j in swaps: print(i, j)","solution":"def find_swaps(nums, target): Function to find the minimum swaps required to transform the nums array into the target array. :param nums: List[int], the initial array :param target: List[int], the target array after transformation :return: List[List[int]], a list of swaps as pairs of indices swaps = [] index_map = {value: idx for idx, value in enumerate(nums)} for i in range(len(nums)): while nums[i] != target[i]: target_index = index_map[target[i]] nums[i], nums[target_index] = nums[target_index], nums[i] index_map[nums[target_index]] = target_index index_map[nums[i]] = i swaps.append([i, target_index]) return swaps def solve(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 results = [] for _ in range(T): n = int(data[index]) index += 1 nums = list(map(int, data[index:index + n])) index += n target = list(map(int, data[index:index + n])) index += n swaps = find_swaps(nums, target) results.append((len(swaps), swaps)) for m, swaps in results: print(m) for i, j in swaps: print(i, j)"},{"question":"def valid_tree(n, m, routes): Determine if the given routes form a valid tree. Args: n (int): The number of distinct points. m (int): The number of routes. routes (List[Tuple[int, int]]): List of routes represented as pairs of points. Returns: str: \\"Yes\\" if routes form a valid tree, otherwise \\"No\\". Examples: >>> valid_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"Yes\\" >>> valid_tree(4, 3, [(1, 2), (2, 3), (3, 1)]) \\"No\\" >>> valid_tree(4, 2, [(1, 2), (3, 4)]) \\"No\\"","solution":"def valid_tree(n, m, routes): if m != n - 1: return \\"No\\" parent = list(range(n + 1)) def find(x): if parent[x] == x: return x parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY return True return False for u, v in routes: if not union(u, v): return \\"No\\" return \\"Yes\\""},{"question":"def count_themes_with_multiple_books(T: int, test_cases: List[Tuple[int, List[Tuple[str, str]]]]) -> List[int]: Alice is organizing her vast collection of unique books and has decided to group them by their themes. Each book has a name and a theme. Her goal is to find out how many themes have more than one book associated with them. Input: The first line contains an integer T, the number of test cases. Each test case starts with an integer N, the number of books. The next N lines each contain two strings, the first string is the name of the book, and the second string is the theme of the book. Output: For every test case, print the number of themes that have more than one book associated with them. Constraints: 1 ≤ T ≤ 100 1 ≤ N ≤ 1000 1 ≤ length of book name, theme ≤ 100 Example: >>> count_themes_with_multiple_books(2, [(4, [(\\"PrideAndPrejudice\\", \\"Romance\\"), (\\"Emma\\", \\"Romance\\"), ... (\\"ToKillAMockingbird\\", \\"Classic\\"), (\\"GoneWithTheWind\\", \\"Classic\\")]), ... (3, [(\\"1984\\", \\"Dystopian\\"), (\\"BraveNewWorld\\", \\"Dystopian\\"), ... (\\"Fahrenheit451\\", \\"Dystopian\\")])]) [2, 1] >>>","solution":"def count_themes_with_multiple_books(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] book_data = test_cases[i][1] theme_count = {} for book in book_data: name, theme = book if theme in theme_count: theme_count[theme] += 1 else: theme_count[theme] = 1 count = sum(1 for value in theme_count.values() if value > 1) results.append(count) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string that represents a mathematical expression containing single-digit positive integers, addition, subtraction, and parentheses, and return the result as an integer. >>> evaluate_expression(\\"1 + 1\\") 2 >>> evaluate_expression(\\" 2-1 + 2 \\") 3 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23","solution":"def evaluate_expression(expression): def helper(s, i): stack = [] num = 0 sign = 1 while i < len(s): char = s[i] if char.isdigit(): num = num * 10 + int(char) elif char in '+-': stack.append(sign * num) num = 0 sign = 1 if char == '+' else -1 elif char == '(': num, i = helper(s, i + 1) elif char == ')': break i += 1 stack.append(sign * num) return sum(stack), i clean_expr = expression.replace(' ', '') result, _ = helper(clean_expr, 0) return result"},{"question":"def possible_to_organize(pairs): Determine if it is possible to organize a set of pairs such that all members can \\"see\\" each other. >>> possible_to_organize([(1, 4), (2, 3)]) \\"POSSIBLE\\" >>> possible_to_organize([(1, 2), (2, 3), (3, 1)]) \\"IMPOSSIBLE\\" >>> possible_to_organize([(1, 2)]) \\"POSSIBLE\\" >>> possible_to_organize([(1, 2), (3, 4)]) \\"POSSIBLE\\" >>> possible_to_organize([(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) \\"IMPOSSIBLE\\"","solution":"def is_bipartite(n, edges): from collections import deque, defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * (n + 1) def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(1, n + 1): if color[i] == -1: if not bfs(i): return False return True def possible_to_organize(pairs): n = 4 # number of members edges = pairs if is_bipartite(n, edges): return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\" # Example application pairs = [(1, 4), (2, 3)] print(possible_to_organize(pairs)) # Expected output: \\"POSSIBLE\\""},{"question":"def count_distinct_substrings(T: int, strings: List[str]) -> List[int]: Determine the number of distinct substrings for a given string. >>> count_distinct_substrings(2, [\\"abcd\\", \\"aaa\\"]) == [10, 3]","solution":"def count_distinct_substrings(T, strings): results = [] for s in strings: substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) results.append(len(substrings)) return results"},{"question":"def construct_sequence(n): Constructs a sequence of length n using characters 'A', 'B', 'C' such that no two adjacent characters are the same. If it is impossible, returns \\"Not Possible\\". >>> construct_sequence(1) in [\\"A\\", \\"B\\", \\"C\\"] True >>> construct_sequence(3) == \\"ABC\\" True >>> construct_sequence(4) == \\"ABCA\\" True >>> construct_sequence(6) == \\"ABCABC\\" True >>> construct_sequence(0) == \\"Not Possible\\" True >>> construct_sequence(1001) == \\"Not Possible\\" True","solution":"def construct_sequence(n): Constructs a sequence of length n using characters 'A', 'B', 'C' such that no two adjacent characters are the same. If it is impossible, returns \\"Not Possible\\". if n < 1 or n > 1000: return \\"Not Possible\\" characters = \\"ABC\\" result = [] for i in range(n): result.append(characters[i % 3]) return \\"\\".join(result)"},{"question":"def sumOfPrimes(n: int) -> int: Calculate the sum of all prime numbers up to and including a given number \`n\`. A prime number is only divisible by 1 and itself, and 1 is not considered a prime number. The input \`n\` will always be a positive integer. >>> sumOfPrimes(10) 17 >>> sumOfPrimes(20) 77 >>> sumOfPrimes(1) 0 def test_sum_of_primes_up_to_10(): assert sumOfPrimes(10) == 17 def test_sum_of_primes_up_to_20(): assert sumOfPrimes(20) == 77 def test_sum_of_primes_up_to_1(): assert sumOfPrimes(1) == 0 def test_sum_of_primes_up_to_0(): assert sumOfPrimes(0) == 0 def test_sum_of_primes_up_to_2(): assert sumOfPrimes(2) == 2 def test_sum_of_primes_up_to_30(): assert sumOfPrimes(30) == 129","solution":"def sumOfPrimes(n: int) -> int: Returns the sum of all prime numbers up to and including n. if n < 2: return 0 def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True prime_sum = 0 for i in range(2, n + 1): if is_prime(i): prime_sum += i return prime_sum"},{"question":"class TaskManager: def __init__(self): Initialize a new TaskManager instance. pass def add_task(self, description: str, priority: int): Add a new task with the given description and priority. :param description: Description of the task :param priority: Priority of the task pass def remove_task(self, description: str): Remove the task with the given description. :param description: Description of the task to be removed pass def fetch_highest_priority_task(self) -> str: Fetch the description of the task with the highest priority. :return: Description of the highest priority task pass def process_operations(operations: List[str]) -> List[str]: Process a list of operations and return the results. :param operations: List of operations to be processed :return: List of results for FETCH operations >>> process_operations([\\"ADD task1 10\\", \\"ADD task2 20\\", \\"ADD task3 15\\", \\"FETCH\\", \\"REMOVE task2\\", \\"FETCH\\", \\"REMOVE task1\\"]) [\\"task2\\", \\"task3\\"] >>> process_operations([\\"FETCH\\"]) [\\"NONE\\"] pass","solution":"import heapq class TaskManager: def __init__(self): self.task_map = {} self.priority_queue = [] self.removed_tasks = set() def add_task(self, description, priority): if description in self.task_map: self.remove_task(description) task = (priority, description) self.task_map[description] = task heapq.heappush(self.priority_queue, (-priority, description)) def remove_task(self, description): if description in self.task_map: removed_task = self.task_map.pop(description) self.removed_tasks.add(removed_task) def fetch_highest_priority_task(self): while self.priority_queue: priority, description = heapq.heappop(self.priority_queue) if (priority, description) not in self.removed_tasks: return description return \\"NONE\\" def process_operations(operations): manager = TaskManager() results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": description = parts[1] priority = int(parts[2]) manager.add_task(description, priority) elif command == \\"REMOVE\\": description = parts[1] manager.remove_task(description) elif command == \\"FETCH\\": results.append(manager.fetch_highest_priority_task()) return results"},{"question":"def count_unique_pairs(A, T): Return the number of unique pairs of elements in the array A whose sum is equal to T. >>> count_unique_pairs([1, 5, 7, -1, 5], 6) 2 >>> count_unique_pairs([1, 1, 1, 1], 2) 1 >>> count_unique_pairs([1, -2, 3, 0, 4, 5], 3) 2 >>> count_unique_pairs([1, 2, 3, 4, 5], 10) 0 >>> count_unique_pairs([], 10) 0","solution":"def count_unique_pairs(A, T): Return the number of unique pairs of elements in the array A whose sum is equal to T. seen = set() pairs = set() for num in A: complement = T - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs) # Example usage: # n = 5 # A = [1, 5, 7, -1, 5] # T = 6 # Output: 2 # print(count_unique_pairs(A, T))"},{"question":"def merge_ordered_lists(list_a: list, list_b: list) -> list: Merges two ordered lists into one ordered list. Parameters: - list_a: A list of integers in ascending order. - list_b: A list of integers in ascending order. Returns: - A new list with all integers from list_a and list_b in ascending order. Examples: >>> merge_ordered_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_ordered_lists([1, 1, 2, 3], [2, 2, 3, 4]) [1, 1, 2, 2, 2, 3, 3, 4] >>> merge_ordered_lists([1, 5, 9], [2, 6]) [1, 2, 5, 6, 9] pass","solution":"def merge_ordered_lists(list_a, list_b): Merges two ordered lists into one ordered list. Parameters: - list_a: A list of integers in ascending order. - list_b: A list of integers in ascending order. Returns: - A new list with all integers from list_a and list_b in ascending order. merged_list = [] i, j = 0, 0 # Traverse both lists and merge them into merged_list while i < len(list_a) and j < len(list_b): if list_a[i] < list_b[j]: merged_list.append(list_a[i]) i += 1 else: merged_list.append(list_b[j]) j += 1 # Collect the remaining elements from list_a while i < len(list_a): merged_list.append(list_a[i]) i += 1 # Collect the remaining elements from list_b while j < len(list_b): merged_list.append(list_b[j]) j += 1 return merged_list"},{"question":"def transformation_steps(n: int, S: int) -> int: Determines the number of steps to reach 1 using Alice's number transformation. Args: n (int): The starting number. S (int): The maximum number of steps allowed. Returns: int: The number of steps to reach 1, or \\"Too Long\\" if it exceeds S steps. >>> transformation_steps(6, 10) 8 >>> transformation_steps(15, 20) 17 >>> transformation_steps(3, 5) \\"Too Long\\" def number_transformation(T: int, test_cases: List[Tuple[int, int]]) -> List[Union[int, str]]: For each test case, determines the number of steps for number transformation. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int]]): List of tuples each containing (n, S) Returns: List[Union[int, str]]: List of results for each test case. >>> number_transformation(1, [(6, 10)]) [8] >>> number_transformation(3, [(6, 10), (15, 20), (3, 5)]) [8, 17, \\"Too Long\\"] # Example Unit Tests from solution import transformation_steps, number_transformation def test_transformation_steps_even_number(): assert transformation_steps(6, 10) == 8 def test_transformation_steps_odd_number(): assert transformation_steps(15, 20) == 17 def test_transformation_steps_too_long(): assert transformation_steps(3, 5) == \\"Too Long\\" def test_transformation_steps_exact_limit(): assert transformation_steps(3, 7) == 7 def test_number_transformation_single_case(): assert number_transformation(1, [(6, 10)]) == [8] def test_number_transformation_multiple_cases(): test_cases = [(6, 10), (15, 20), (3, 5)] expected = [8, 17, \\"Too Long\\"] assert number_transformation(3, test_cases) == expected def test_number_transformation_edge_case_1(): assert number_transformation(1, [(1, 1)]) == [0] def test_number_transformation_limit_s(): large_n = 2**300 - 1 assert transformation_steps(large_n, 300) == \\"Too Long\\"","solution":"def transformation_steps(n, S): steps = 0 while n != 1 and steps <= S: if n % 2 == 0: n //= 2 else: n = n * 3 + 1 steps += 1 return steps if steps <= S else \\"Too Long\\" def number_transformation(T, test_cases): results = [] for i in range(T): n, S = test_cases[i] result = transformation_steps(n, S) results.append(result) return results"},{"question":"def is_perfect_number(n: int) -> str: Determines if the given number is a perfect number (contains only the digits 3 and/or 7). :param n: Integer number to check. :return: \\"YES\\" if the number is perfect, otherwise \\"NO\\". >>> is_perfect_number(37) \\"YES\\" >>> is_perfect_number(123) \\"NO\\" >>> is_perfect_number(7337) \\"YES\\" >>> is_perfect_number(777) \\"YES\\" >>> is_perfect_number(8) \\"NO\\" # Testing the function if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def is_perfect_number(n: int) -> str: Determines if the given number is a perfect number (contains only the digits 3 and/or 7). :param n: Integer number to check. :return: \\"YES\\" if the number is perfect, otherwise \\"NO\\". for digit in str(n): if digit not in {'3', '7'}: return \\"NO\\" return \\"YES\\""},{"question":"def min_bills(N: int, M: int, denominations: List[Tuple[int, int]]) -> int: Find the minimum number of currency bills needed to make up a given amount. >>> min_bills(3, 620, [(500, 1), (100, 2), (20, 2)]) 3 >>> min_bills(2, 300, [(100, 1), (200, 1)]) 2 >>> min_bills(3, 300, [(100, 3), (50, 2), (20, 1)]) 3 >>> min_bills(2, 700, [(500, 1), (100, 1)]) -1","solution":"def min_bills(N, M, denominations): # Sort denominations by value in descending order denominations.sort(reverse=True, key=lambda x: x[0]) total_bills = 0 for d, q in denominations: if M <= 0: break max_bills = min(q, M // d) total_bills += max_bills M -= max_bills * d return total_bills if M == 0 else -1 # Example usage: # N = 3 # M = 620 # denominations = [(500, 1), (100, 2), (20, 2)] # print(min_bills(N, M, denominations)) # Output: 3"},{"question":"def min_unique_heights(n: int, heights: List[int]) -> int: Returns the minimum number of unique heights required to group the books. >>> min_unique_heights(6, [5, 3, 4, 5, 7, 2]) 4 >>> min_unique_heights(1, [5]) 1 >>> min_unique_heights(3, [5, 5, 5]) 1 >>> min_unique_heights(5, [1, 2, 3, 4, 5]) 5","solution":"def min_unique_heights(n, heights): Returns the minimum number of unique heights required to group the books. return len(set(heights))"},{"question":"def remove_duplicates(datasets): This function accepts a list of integer datasets (each dataset being a list of integers), and returns a list of datasets with duplicate values removed, preserving only the first occurrence. pass # Unit tests def test_remove_duplicates_single_dataset(): input_data = [[4, 5, 6, 5, 4, 7, 8, 4, 9]] expected_output = [[4, 5, 6, 7, 8, 9]] assert remove_duplicates(input_data) == expected_output def test_remove_duplicates_multiple_datasets(): input_data = [ [4, 5, 6, 5, 4, 7, 8, 4, 9], [1, 2, 3, 4, 5, 5, 4, 3, 2, 1] ] expected_output = [ [4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5] ] assert remove_duplicates(input_data) == expected_output def test_remove_duplicates_empty_dataset(): input_data = [[]] expected_output = [[]] assert remove_duplicates(input_data) == expected_output def test_remove_duplicates_all_duplicates(): input_data = [[1, 1, 1, 1, 1, 1]] expected_output = [[1]] assert remove_duplicates(input_data) == expected_output def test_remove_duplicates_no_duplicates(): input_data = [[1, 2, 3, 4, 5]] expected_output = [[1, 2, 3, 4, 5]] assert remove_duplicates(input_data) == expected_output","solution":"def remove_duplicates(datasets): This function accepts a list of integer datasets (each dataset being a list of integers), and returns a list of datasets with duplicate values removed, preserving only the first occurrence. result = [] for dataset in datasets: seen = set() filtered_dataset = [] for num in dataset: if num not in seen: seen.add(num) filtered_dataset.append(num) result.append(filtered_dataset) return result"},{"question":"def maxSubArraySum(arr): Returns the sum of the maximum sum subarray using Kadane's Algorithm. >>> maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxSubArraySum([1, 2, 3, 4, 5]) 15 >>> maxSubArraySum([-1, -2, -3, -4, -5]) -1 >>> maxSubArraySum([1]) 1 >>> maxSubArraySum([-1]) -1 >>> maxSubArraySum([3, -2, 5, -1, 4, -3]) 9 >>> maxSubArraySum([0, -3, 5, -2, 0, 2, -1, 3]) 7 >>> maxSubArraySum([10**4, -10**4, 10**4, -10**4, 10**4]) 10**4 >>> maxSubArraySum([-10**4, -10**4, -10**4]) -10**4","solution":"def maxSubArraySum(arr): Returns the sum of the maximum sum subarray using Kadane's Algorithm. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_even_sum_pairs(n: int, array: List[int]) -> int: Returns the number of pairs (i, j) such that i < j and the sum of elements at these indices is even. >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs(3, [2, 4, 6]) 3","solution":"def count_even_sum_pairs(n, array): Returns the number of pairs (i, j) such that i < j and the sum of elements at these indices is even. # Separate the numbers into evens and odds even_count = sum(1 for x in array if x % 2 == 0) odd_count = n - even_count # Any pair of evens or pair of odds will produce an even sum # Hence, count the pairs of even numbers and odd numbers even_pairs = even_count * (even_count - 1) // 2 odd_pairs = odd_count * (odd_count - 1) // 2 # Total valid pairs return even_pairs + odd_pairs"},{"question":"def fibonacci_like_sequence(a, b, n, coefficients): Generate the nth number in the Fibonacci-like sequence using given starting numbers and coefficients. >>> fibonacci_like_sequence(1, 1, 5, [2, 3, 4]) # 76 >>> fibonacci_like_sequence(2, 3, 6, [1, 2, 3, 4]) # 316 >>> fibonacci_like_sequence(10, 20, 3, [1, 2]) # 30 >>> fibonacci_like_sequence(5, 8, 2, [1, 2, 3]) # 8 >>> fibonacci_like_sequence(0, 0, 1, [5, 10, 15]) # 0 def process_sequences(inputs): Process multiple datasets and return results. >>> process_sequences([\\"1 1 5\\", \\"2 3 4\\", \\"2 3 6\\", \\"1 2 3 4\\", \\"0 0 0\\"]) # [76, 316] >>> process_sequences([\\"10 20 3\\", \\"1 2\\", \\"5 8 2\\", \\"1 2 3\\", \\"0 0 0\\"]) # [30, 8]","solution":"def fibonacci_like_sequence(a, b, n, coefficients): Generate the nth number in the Fibonacci-like sequence using given starting numbers and coefficients. if n == 1: return a if n == 2: return b sequence = [a, b] coeff_len = len(coefficients) for i in range(2, n): next_val = (sequence[-1] + sequence[-2]) * coefficients[(i - 2) % coeff_len] sequence.append(next_val) return sequence[-1] def process_sequences(inputs): results = [] idx = 0 while idx < len(inputs): a, b, n = map(int, inputs[idx].split()) if a == 0 and b == 0 and n == 0: break idx += 1 coefficients = list(map(int, inputs[idx].split())) results.append(fibonacci_like_sequence(a, b, n, coefficients)) idx += 1 return results # Example usage with provided sample input input_data = [ \\"1 1 5\\", \\"2 3 4\\", \\"2 3 6\\", \\"1 2 3 4\\", \\"0 0 0\\" ] result = process_sequences(input_data) for number in result: print(number)"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root: TreeNode) -> int: Determine the maximum level sum in a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(8) >>> root.right.right.left = TreeNode(6) >>> root.right.right.right = TreeNode(7) >>> maxLevelSum(root) 17","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root): if not root: return 0 max_sum = float('-inf') queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) max_sum = max(max_sum, level_sum) return max_sum"},{"question":"def process_operations(operations): Processes a series of stack operations and returns the sum of elements in the stack after all operations. Parameters: - operations (List of strings): List of operations where each operation is one of the \\"PUSH X\\", \\"POP\\", or \\"INC K V\\". Returns: - int: The sum of elements in the stack after all operations. Example: >>> process_operations([\\"PUSH 5\\", \\"PUSH 2\\", \\"INC 2 3\\", \\"POP\\", \\"PUSH 10\\"]) 18 >>> process_operations([]) 0 >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\"]) 6 >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"POP\\", \\"POP\\", \\"POP\\"]) 0 >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"INC 5 10\\"]) 23 >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"POP\\", \\"INC 2 5\\", \\"PUSH 4\\"]) 17 >>> process_operations([\\"POP\\", \\"PUSH 10\\", \\"POP\\", \\"POP\\"]) 0 >>> process_operations([\\"PUSH -10\\", \\"PUSH -20\\", \\"INC 2 5\\"]) -20","solution":"def process_operations(operations): Processes a series of stack operations and returns the sum of elements in the stack after all operations. Parameters: - operations: List of operations as strings. Returns: - An integer representing the sum of elements in the stack after processing all operations. stack = [] for operation in operations: parts = operation.split() if parts[0] == \\"PUSH\\": stack.append(int(parts[1])) elif parts[0] == \\"POP\\": if stack: stack.pop() elif parts[0] == \\"INC\\": K = int(parts[1]) V = int(parts[2]) for i in range(min(K, len(stack))): stack[i] += V return sum(stack)"},{"question":"def maximum_altitude_difference(test_cases): Given multiple test cases with the number of waypoints and their respective altitudes, calculates the maximum difference in altitude between any two waypoints for each test case. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples where the first element is the number of waypoints, and the second element is a list of altitudes at those waypoints. Returns: List[int]: A list of integers representing the maximum difference in altitude for each test case. >>> maximum_altitude_difference([(5, [100, 200, 150, 500, 300])]) == [400] >>> maximum_altitude_difference([(3, [50, 300, 150])]) == [250]","solution":"def maximum_altitude_difference(test_cases): Given multiple test cases with the number of waypoints and their respective altitudes, calculates the maximum difference in altitude between any two waypoints for each test case. results = [] for case in test_cases: N, altitudes = case max_altitude = max(altitudes) min_altitude = min(altitudes) max_difference = max_altitude - min_altitude results.append(max_difference) return results"},{"question":"from typing import List def shortest_path(R: int, C: int, grid: List[str]) -> int: Find the shortest path from the top-left corner to the bottom-right corner in a warehouse grid. Avoiding shelves (cells marked 'S') and moving only through open spaces (cells marked 'O'). Args: R (int): Number of rows. C (int): Number of columns. grid (List[str]): The warehouse grid. Returns: int: Length of the shortest path, or -1 if no valid path exists. Examples: >>> shortest_path(5, 5, [\\"OOOOO\\", \\"OSSSO\\", \\"OOOOO\\", \\"OSSSO\\", \\"OOOOO\\"]) 8 >>> shortest_path(3, 3, [\\"OSO\\", \\"SSO\\", \\"OSO\\"]) -1","solution":"from collections import deque def shortest_path(R, C, grid): # Helper to check if a cell is within grid bounds and not a shelf def is_valid(x, y): return 0 <= x < R and 0 <= y < C and grid[x][y] == 'O' # Directions for moving in the grid directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Starting point start = (0, 0) end = (R-1, C-1) # Check initial and final position validity if not is_valid(*start) or not is_valid(*end): return -1 # BFS setup queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() # If we reach the end if (x, y) == end: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # No valid path found # Example usage: # R, C = 5, 5 # grid = [ # 'OOOOO', # 'OSSSO', # 'OOOOO', # 'OSSSO', # 'OOOOO' # ] # print(shortest_path(R, C, grid)) # Output should be 8"},{"question":"from typing import List, Tuple, Dict def check_supplies(daily_consumptions: List[Tuple[str, int]], safe_limits: Dict[str, int]) -> List[str]: Determine the supplies that have exceeded their safe limits based on daily consumption. >>> check_supplies([('water', 120), ('oxygen', 60), ('food', 100)], {'water': 100, 'oxygen': 60, 'food': 120}) ['water'] >>> check_supplies([('water', 80), ('oxygen', 60), ('food', 100)], {'water': 100, 'oxygen': 60, 'food': 120}) [] >>> check_supplies([('water', 120), ('oxygen', 70), ('food', 130)], {'water': 100, 'oxygen': 60, 'food': 120}) ['water', 'oxygen', 'food'] >>> check_supplies([('water', 50), ('oxygen', 30), ('food', 90)], {'water': 100, 'oxygen': 60, 'food': 120}) [] >>> check_supplies([('water', 0), ('oxygen', 0), ('food', 0)], {'water': 100, 'oxygen': 60, 'food': 120}) [] >>> check_supplies([('water', 1000), ('oxygen', 1000), ('food', 1000)], {'water': 1000, 'oxygen': 1000, 'food': 1000}) [] >>> check_supplies([('water', 90), ('oxygen', 70), ('food', 110)], {'water': 100, 'oxygen': 80, 'food': 100}) ['food'] pass","solution":"from typing import List, Tuple, Dict def check_supplies(daily_consumptions: List[Tuple[str, int]], safe_limits: Dict[str, int]) -> List[str]: over_consumed_supplies = [] for supply_id, consumption in daily_consumptions: if consumption > safe_limits[supply_id]: over_consumed_supplies.append(supply_id) return over_consumed_supplies"},{"question":"def largest_palindrome(n): Find the largest palindrome made from the product of two numbers, each with \`n\` digits. If no such palindrome exists, return -1. - If \`n\` is less than 1, return -1. >>> largest_palindrome(2) 9009 >>> largest_palindrome(3) 906609 >>> largest_palindrome(1) 9 >>> largest_palindrome(0) -1 >>> largest_palindrome(-1) -1","solution":"def is_palindrome(number): return str(number) == str(number)[::-1] def largest_palindrome(n): if n < 1: return -1 max_factor = 10**n - 1 min_factor = 10**(n - 1) largest_palindrome = -1 for i in range(max_factor, min_factor - 1, -1): for j in range(i, min_factor - 1, -1): product = i * j if is_palindrome(product) and product > largest_palindrome: largest_palindrome = product return largest_palindrome"},{"question":"def largest_surrounded_square(matrix: List[List[int]]) -> int: Returns the size of the largest square that contains only 1s and is surrounded by 0s. >>> largest_surrounded_square([ >>> [0, 0, 0, 0, 0], >>> [0, 1, 1, 1, 0], >>> [0, 1, 1, 1, 0], >>> [0, 1, 1, 1, 0], >>> [0, 0, 0, 0, 0], >>> ]) == 3 >>> largest_surrounded_square([ >>> [0, 0, 0, 0], >>> [0, 1, 1, 0], >>> [0, 1, 1, 0], >>> [0, 0, 0, 0], >>> ]) == 2 >>> largest_surrounded_square([ >>> [0, 0, 0], >>> [0, 1, 0], >>> [0, 0, 0], >>> ]) == 1 >>> largest_surrounded_square([ >>> [1, 1, 1], >>> [1, 1, 1], >>> [1, 1, 1], >>> ]) == 0 >>> largest_surrounded_square([ >>> [0, 0], >>> [0, 0], >>> ]) == 0 >>> largest_surrounded_square([ >>> [0], >>> ]) == 0 >>> largest_surrounded_square([ >>> [1], >>> ]) == 0 >>> largest_surrounded_square([ >>> [0, 0, 0, 0, 0], >>> [0, 1, 1, 0, 0], >>> [0, 1, 1, 0, 0], >>> [0, 0, 0, 1, 1], >>> [0, 0, 0, 1, 1], >>> ]) == 2","solution":"def largest_surrounded_square(matrix): Returns the size of the largest square that contains only 1s and is surrounded by 0s. if not matrix: return 0 N = len(matrix) M = len(matrix[0]) def is_square_surrounded(i, j, size): for x in range(i, i + size): if matrix[x][j - 1] != 0 or matrix[x][j + size] != 0: return False for y in range(j, j + size): if matrix[i - 1][y] != 0 or matrix[i + size][y] != 0: return False return True max_size = min(N, M) for size in range(max_size, 0, -1): for i in range(size, N): for j in range(size, M): if matrix[i][j] == 1: if all(matrix[x][y] == 1 for x in range(i-size+1, i+1) for y in range(j-size+1, j+1)): if is_square_surrounded(i-size+1, j-size+1, size): return size return 0"},{"question":"def average_ctr(campaigns: List[Tuple[int, int]]) -> float: Calculate and return the average Click-Through Rate (CTR) for multiple ad campaigns. >>> average_ctr([(100, 25)]) 25.0 >>> average_ctr([(200, 50), (300, 30)]) 17.5 >>> average_ctr([(0, 10), (400, 40)]) 5.0 >>> average_ctr([(50, 10), (150, 30), (200, 50)]) 21.67 >>> average_ctr([(0, 0), (0, 0)]) 0.0 >>> average_ctr([(0, 20), (100, 20)]) 10.0","solution":"def average_ctr(campaigns): total_ctr = 0 for impressions, clicks in campaigns: if impressions == 0: ctr = 0 else: ctr = (clicks / impressions) * 100 total_ctr += ctr average_ctr = total_ctr / len(campaigns) return round(average_ctr, 2)"},{"question":"def calculate_bonuses(employees: List[Tuple[int, int]]) -> List[int]: Calculate the bonus for each employee based on their performance score. Args: employees (list of tuples): Each tuple contains the base salary and performance score of an employee. Returns: list: List of calculated bonuses for each employee. Examples: >>> calculate_bonuses([(5000, 95), (7000, 85), (3000, 65), (8000, 45), (9000, 76)]) [1000, 700, 150, 0, 900] >>> calculate_bonuses([(6000, 100), (5000, 89), (4000, 50), (3000, 49)]) [1200, 500, 200, 0] ...","solution":"def calculate_bonuses(employees): Calculate the bonus for each employee based on their performance score. Args: employees (list of tuples): Each tuple contains the base salary and performance score of an employee. Returns: list: List of calculated bonuses for each employee. bonuses = [] for (base_salary, score) in employees: if 90 <= score <= 100: bonus = 0.20 * base_salary elif 75 <= score <= 89: bonus = 0.10 * base_salary elif 50 <= score <= 74: bonus = 0.05 * base_salary else: bonus = 0 bonuses.append(int(bonus)) return bonuses # Sample usage # N = 5 # employees = [(5000, 95), (7000, 85), (3000, 65), (8000, 45), (9000, 76)] # print(calculate_bonuses(employees)) # Output: [1000, 700, 150, 0, 900]"},{"question":"from typing import List, Tuple def longest_zero_sum_subarray(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases, find the length of the longest subarray with zero sum for each test case. Each test case consists of a number of days (N) and an array of joyfulness levels. >>> longest_zero_sum_subarray(3, [(5, [1, -1, 3, 2, -2]), (4, [1, 2, 3, 4]), (6, [1, -1, 2, -2, 3, -3])]) [2, -1, 6] >>> longest_zero_sum_subarray(1, [(5, [1, 2, -3, 1, 1])]) [3]","solution":"def longest_zero_sum_subarray(T, test_cases): results = [] for case in test_cases: N, arr = case prefix_sum = 0 index_map = {} max_len = 0 for i in range(N): prefix_sum += arr[i] if prefix_sum == 0: max_len = i + 1 if prefix_sum in index_map: max_len = max(max_len, i - index_map[prefix_sum]) else: index_map[prefix_sum] = i results.append(max_len if max_len > 0 else -1) return results"},{"question":"def num_alliances(n, names): Determine how many distinct alliances can be formed in Wordville. An alliance is a group of citizens such that there is some way to connect any two citizens in the group via a series of alliances. >>> >>> num_alliances(5, [\\"alice\\", \\"bob\\", \\"charlie\\", \\"david\\", \\"ed\\"]) 2 >>> num_alliances(1, [\\"alice\\"]) 1 >>> num_alliances(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) 3 >>> num_alliances(3, [\\"abc\\", \\"bca\\", \\"cab\\"]) 1 >>> num_alliances(4, [\\"abc\\", \\"bca\\", \\"xyz\\", \\"yzx\\"]) 2 >>> names = [\\"a\\" * 50 for _ in range(100000)] >>> num_alliances(100000, names) 1","solution":"def num_alliances(n, names): from collections import defaultdict def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Create a unique set of characters for each name char_to_names = defaultdict(list) for i in range(n): unique_chars = set(names[i]) for char in unique_chars: char_to_names[char].append(i) parent = list(range(n)) rank = [0] * n # Union names with the same characters for indices in char_to_names.values(): for i in range(1, len(indices)): union(parent, rank, indices[0], indices[i]) # The number of distinct alliances is the number of unique roots alliance_count = len(set(find(parent, i) for i in range(n))) return alliance_count # Sample input/output n = 5 names = [\\"alice\\", \\"bob\\", \\"charlie\\", \\"david\\", \\"ed\\"] print(num_alliances(n, names)) # Output: 2"},{"question":"def dungeon_explorer(input_data: str) -> List[str]: Determine if the player can reach the exit after updating the magic walls. Parameters: input_data (str): A formatted string containing the dungeon grid and queries. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each query. Example: >>> input_data = '''4 ... .M#M ... .#M. ... M..M ... #. ... 2 ... 1 2 ... 2 3 ... 0''' >>> dungeon_explorer(input_data) ['YES', 'YES'] # Your code here","solution":"import sys from collections import deque def can_reach_exit(dungeon, N): Check if the player can reach the exit in the dungeon starting from (0, 0). directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) exit_pos = (N - 1, N - 1) if dungeon[start[0]][start[1]] == '#' or dungeon[exit_pos[0]][exit_pos[1]] == '#': return False queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == exit_pos: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and dungeon[nx][ny] in ('.', 'M') and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False def update_magic_wall(dungeon, x, y, N): Update the state of the magic wall at (x, y) if the conditions are met. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] open_neighbors = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and dungeon[nx][ny] == '.': open_neighbors += 1 if open_neighbors == 2: dungeon[x][y] = '.' def process_dungeon(dungeon, N, queries): results = [] for x, y in queries: x -= 1 y -= 1 if dungeon[x][y] == 'M': update_magic_wall(dungeon, x, y, N) results.append(\\"YES\\" if can_reach_exit(dungeon, N) else \\"NO\\") return results def dungeon_explorer(input_data): input_lines = input_data.strip().split(\\"n\\") index = 0 results = [] while index < len(input_lines): N = int(input_lines[index]) if N == 0: break index += 1 dungeon = [list(input_lines[index + i]) for i in range(N)] index += N Q = int(input_lines[index]) index += 1 queries = [] for _ in range(Q): x, y = map(int, input_lines[index].split()) queries.append((x, y)) index += 1 results.extend(process_dungeon(dungeon, N, queries)) return results"},{"question":"def is_path_possible(n: int, m: int, grid: List[str]) -> str: Determine if it is possible to reach the bottom-right corner from the top-left corner of the grid. >>> is_path_possible(5, 5, [\\".....\\", \\".#.\\", \\".#.#.\\", \\".#...\\", \\".....\\"]) \\"Yes\\" >>> is_path_possible(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) \\"No\\" import pytest def test_example_1(): n = 5 m = 5 grid = [ \\".....\\", \\".#.\\", \\".#.#.\\", \\".#...\\", \\".....\\" ] assert is_path_possible(n, m, grid) == \\"Yes\\" def test_example_2(): n = 3 m = 3 grid = [ \\".#.\\", \\"#\\", \\".#.\\" ] assert is_path_possible(n, m, grid) == \\"No\\" def test_only_free_cells(): n = 2 m = 2 grid = [ \\"..\\", \\"..\\" ] assert is_path_possible(n, m, grid) == \\"Yes\\" def test_blocked_adjacent_cells(): n = 3 m = 3 grid = [ \\"...\\", \\".\\", \\"...\\", ] assert is_path_possible(n, m, grid) == \\"Yes\\" def test_no_path_due_to_block(): n = 4 m = 4 grid = [ \\"....\\", \\".#\\", \\"\\", \\"....\\" ] assert is_path_possible(n, m, grid) == \\"No\\"","solution":"def is_path_possible(n, m, grid): from collections import deque # Define directions for moving in the grid directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Function to check if a cell is within the grid and is not blocked def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' # Initialize BFS queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() # Check if we've reached the bottom-right corner if (x, y) == (n-1, m-1): return \\"Yes\\" # Explore all four possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"No\\""},{"question":"def can_form_palindrome(n: int, pieces: str) -> str: Given n characters, determine if they can be rearranged to form a palindrome. :param n: int, number of characters :param pieces: str, a string of n characters :return: str, \\"YES\\" if it is possible to rearrange the characters to form a palindrome, otherwise \\"NO\\" Examples: >>> can_form_palindrome(7, \\"aabbccd\\") \\"YES\\" >>> can_form_palindrome(5, \\"abcde\\") \\"NO\\"","solution":"def can_form_palindrome(n, pieces): Given n characters, determine if they can be rearranged to form a palindrome. :param n: int, number of characters :param pieces: str, a string of n characters :return: str, \\"YES\\" if it is possible to rearrange the characters to form a palindrome, otherwise \\"NO\\" from collections import Counter counts = Counter(pieces) odd_count = sum(1 for count in counts.values() if count % 2 != 0) if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def shortest_path_in_labyrinth(R: int, C: int, labyrinth: List[str]) -> int: Determine the shortest path from the entrance ('E') to the treasure ('T') in a rectangular grid of cells. Return the length of this path, or -1 if no such path exists. :param R: Number of rows in the grid :param C: Number of columns in the grid :param labyrinth: List of strings representing the grid :return: Length of the shortest path from 'E' to 'T', or -1 if no path exists >>> shortest_path_in_labyrinth(6, 7, [\\"E......\\", \\".#...\\", \\".#.....\\", \\".#.#.\\", \\"....#T.\\", \\".......\\"]) 11 >>> shortest_path_in_labyrinth(5, 5, [\\"E\\", \\"#...#\\", \\"#.#\\", \\"#...#\\", \\"#T#\\"]) -1 >>> shortest_path_in_labyrinth(3, 3, [\\"E..\\", \\"#..\\", \\"..T\\"]) 4 >>> shortest_path_in_labyrinth(1, 2, [\\"ET\\"]) 1 >>> shortest_path_in_labyrinth(3, 3, [\\"E#.\\", \\"#\\", \\".#T\\"]) -1","solution":"from collections import deque def shortest_path_in_labyrinth(R, C, labyrinth): def find_start_and_end(grid): start = end = None for r in range(R): for c in range(C): if grid[r][c] == 'E': start = (r, c) elif grid[r][c] == 'T': end = (r, c) return start, end def bfs(start, end): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set([start]) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in visited and labyrinth[nx][ny] != '#': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 start, end = find_start_and_end(labyrinth) if not start or not end: return -1 return bfs(start, end) def solve(): import sys input = sys.stdin.read data = input().splitlines() index = 0 results = [] while True: R, C = map(int, data[index].split()) if R == 0 and C == 0: break labyrinth = [] for i in range(1, R + 1): labyrinth.append(data[index + i]) result = shortest_path_in_labyrinth(R, C, labyrinth) results.append(result) index += R + 1 for result in results: print(result)"},{"question":"def calculate_final_scores(n: int, initial_points: List[int], m: int, rounds: List[List[int]]) -> List[int]: Calculate the final scores of each player after all rounds. >>> calculate_final_scores(3, [10, 15, 20], 2, [[5, -3, 2], [-1, 4, -5]]) [14, 16, 17] >>> calculate_final_scores(2, [0, 0], 3, [[1, 2], [2, 3], [3, 4]]) [6, 9] >>> calculate_final_scores(2, [10, 5], 2, [[-1, -2], [-2, -1]]) [7, 2] >>> calculate_final_scores(3, [100, 200, 300], 2, [[0, 0, 0], [0, 0, 0]]) [100, 200, 300] >>> calculate_final_scores(3, [5, 10, 15], 3, [[1, -1, 2], [-2, 3, -3], [0, 0, 0]]) [4, 12, 14]","solution":"def calculate_final_scores(n, initial_points, m, rounds): Calculate the final scores of each player after all rounds. :param n: Number of players :param initial_points: List of initial points of each player :param m: Number of rounds :param rounds: List of changes in points for each round :return: List of final scores of each player final_scores = initial_points[:] for round_changes in rounds: for i in range(n): final_scores[i] += round_changes[i] return final_scores"},{"question":"def length_of_lis(nums): Returns the length of the longest strictly increasing subsequence. >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> length_of_lis([7]) 1 >>> length_of_lis([4, 4, 4, 4, 4]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([3, 10, 2, 1, 20]) 3 >>> length_of_lis([50, 3, 10, 7, 40, 80]) 4 >>> length_of_lis([]) 0 >>> length_of_lis([1000000000, 999999999, 999999998, 999999997, 1000000001]) 2 >>> length_of_lis([1, 2, 1, 2, 1, 2]) 2","solution":"def length_of_lis(nums): Returns the length of the longest strictly increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def isPerfectPalindrome(S: str) -> bool: Determine if the given string is a perfect palindrome, ignoring letter cases. Args: S (str): Input string consisting of lowercase and uppercase alphabets. Returns: bool: True if the string is a perfect palindrome, False otherwise. Example: >>> isPerfectPalindrome(\\"AmanaplanacanalPanama\\") True >>> isPerfectPalindrome(\\"Hello\\") False","solution":"def isPerfectPalindrome(S): Returns True if the string S is a perfect palindrome, ignoring case. Otherwise, returns False. lower_s = S.lower() # Convert the string to lowercase return lower_s == lower_s[::-1] # Check if the string is equal to its reverse"},{"question":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrder(root): Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> levelOrder(root) [ [3], [9, 20], [15, 7] ] >>> root = TreeNode(1) >>> levelOrder(root) [[1]] >>> root = None >>> levelOrder(root) [] >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.left.left = TreeNode(8) >>> root.left.left.left = TreeNode(7) >>> levelOrder(root) [ [3], [9], [8], [7] ] >>> root = TreeNode(3) >>> root.right = TreeNode(9) >>> root.right.right = TreeNode(8) >>> root.right.right.right = TreeNode(7) >>> levelOrder(root) [ [3], [9], [8], [7] ]","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrder(root): Returns the level order traversal of the binary tree's nodes' values. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for i in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine the number of unique paths Jay can take from the top-left corner to the bottom-right corner, avoiding obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 6 >>> unique_paths_with_obstacles([ ... [0, 1], ... [1, 0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 1","solution":"def unique_paths_with_obstacles(grid): n = len(grid) m = len(grid[0]) # If starting or ending cell is an obstacle, return 0 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 # Create a DP table initialized with 0s dp = [[0] * m for _ in range(n)] # Initialize the starting position dp[0][0] = 1 # Fill the first row for j in range(1, m): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] # Fill the first column for i in range(1, n): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] # Fill the DP table for i in range(1, n): for j in range(1, m): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][m-1]"},{"question":"def strongest_interaction(test_cases): Determine the strongest interaction strength between any two cultures for each test case. Args: test_cases: A list of tuples, where each tuple consists of: - an integer, n, representing the number of cultures, - an n x n matrix of integers representing the interaction strengths between the cultures. Returns: A list of integers, where each integer is the strongest interaction strength for the corresponding test case. pass def parse_input(input_str): Parse the input string into a list of test cases. Args: input_str: A string representing the input, with multiple lines. Returns: A list of tuples, where each tuple consists of: - an integer, n, representing the number of cultures, - an n x n matrix of integers representing the interaction strengths between the cultures. pass # Unit tests def test_single_case(): input_str = \\"4n0 2 3 4n2 0 5 1n3 5 0 7n4 1 7 0n0n\\" test_cases = parse_input(input_str) assert strongest_interaction(test_cases) == [7] def test_multiple_cases(): input_str = \\"4n0 2 3 4n2 0 5 1n3 5 0 7n4 1 7 0n3n0 1 0n1 0 2n0 2 0n0n\\" test_cases = parse_input(input_str) assert strongest_interaction(test_cases) == [7, 2] def test_no_interaction(): input_str = \\"2n0 0n0 0n0n\\" test_cases = parse_input(input_str) assert strongest_interaction(test_cases) == [0] def test_large_numbers(): input_str = \\"3n0 999 1000n999 0 123n1000 123 0n0n\\" test_cases = parse_input(input_str) assert strongest_interaction(test_cases) == [1000] def test_min_size(): input_str = \\"1n0n0n\\" test_cases = parse_input(input_str) assert strongest_interaction(test_cases) == [0]","solution":"def strongest_interaction(test_cases): results = [] for case in test_cases: n, matrix = case max_strength = 0 for i in range(n): for j in range(i + 1, n): if matrix[i][j] > max_strength: max_strength = matrix[i][j] results.append(max_strength) return results def parse_input(input_str): lines = input_str.strip().split('n') index = 0 test_cases = [] while index < len(lines): n = int(lines[index]) if n == 0: break index += 1 matrix = [] for i in range(n): row = list(map(int, lines[index].strip().split())) matrix.append(row) index += 1 test_cases.append((n, matrix)) return test_cases"},{"question":"def library_management(t, test_cases): Process the transactions for each test case to determine the status of each book. Parameters: - t: int, number of test cases - test_cases: list of tuples where each tuple contains: - M: int, number of members - B: int, number of books - N: int, number of transactions - transactions: list of strings where each string represents a transaction Returns: - results: list of list of ints, each inner list contains the status of the books for a test case >>> library_management(2, [(3, 5, 7, [\\"issue 1 2\\", \\"issue 2 3\\", \\"return 1 2\\", \\"issue 3 2\\", \\"issue 2 4\\", \\"return 2 3\\", \\"issue 1 3\\"]), (2, 3, 4, [\\"issue 1 1\\", \\"issue 2 2\\", \\"return 2 2\\", \\"issue 1 2\\"])]) [[-1, 3, 1, 2, -1], [1, 1, -1]] # BYO implementation here","solution":"def library_management(t, test_cases): Process the transactions for each test case to determine the status of each book. Parameters: - t: int, number of test cases - test_cases: list of tuples where each tuple contains: - M: int, number of members - B: int, number of books - N: int, number of transactions - transactions: list of strings where each string represents a transaction Returns: - results: list of list of ints, each inner list contains the status of the books for a test case results = [] for M, B, N, transactions in test_cases: book_status = [-1] * (B + 1) # book_status[i] = member ID if issued, -1 if not issued for transaction in transactions: parts = transaction.split() action, X, Y = parts[0], int(parts[1]), int(parts[2]) if action == \\"issue\\": if book_status[Y] == -1: # If the book is not already issued book_status[Y] = X elif action == \\"return\\": if book_status[Y] == X: # The book is returned by the correct member book_status[Y] = -1 # Exclude the dummy book_status[0] which we do not use results.append(book_status[1:]) return results"},{"question":"def find_rich_numbers(up_to): Finds all rich numbers less than or equal to up_to. A rich number is an integer greater than 1 that can be written as the sum of positive integers in at least two distinct ways, where the order of terms does not matter. Parameters: up_to (int): The upper limit to search for rich numbers. Returns: list: A list of all rich numbers up to the specified limit. pass def test_find_rich_numbers(): assert find_rich_numbers(10) == [5, 6, 7, 8, 9, 10] assert find_rich_numbers(15) == [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] assert find_rich_numbers(20) == [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] assert find_rich_numbers(2) == [] assert find_rich_numbers(3) == [] assert find_rich_numbers(5) == [5] assert find_rich_numbers(4) == []","solution":"def find_rich_numbers(up_to): Finds all rich numbers less than or equal to up_to. A rich number is an integer greater than 1 that can be written as the sum of positive integers in at least two distinct ways, where the order of terms does not matter. Parameters: up_to (int): The upper limit to search for rich numbers. Returns: list: A list of all rich numbers up to the specified limit. def is_rich_number(n): count = 0 for i in range(1, (n // 2) + 1): remainder = n - i if remainder > i: count += 1 else: break if count >= 2: return True return False rich_numbers = [] for number in range(2, up_to + 1): if is_rich_number(number): rich_numbers.append(number) return rich_numbers"},{"question":"from typing import List, Tuple def shortest_path_length(n: int, q: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given a tree with n nodes and n-1 edges, answers q queries to determine the length of the shortest path between two nodes u and v. :param n: Number of nodes in the tree. :param q: Number of queries. :param edges: List of edges defining the tree. :param queries: List of queries, each a tuple (u, v). :return: A list of shortest path lengths for each query. >>> shortest_path_length(5, 3, [(1, 2), (1, 3), (3, 4), (4, 5)], [(1, 5), (2, 4), (3, 5)]) [3, 3, 2] >>> shortest_path_length(2, 1, [(1, 2)], [(1, 2)]) [1]","solution":"from collections import deque def bfs_distance(tree, n, start, end): Perform BFS to find the shortest distance between start and end nodes in the given tree. visited = [False] * (n + 1) queue = deque([(start, 0)]) # store pairs of (node, current_distance) visited[start] = True while queue: current_node, dist = queue.popleft() if current_node == end: return dist for neighbor in tree[current_node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, dist + 1)) return -1 # should never hit this line if the tree is connected def shortest_path_length(n, q, edges, queries): :param n: Number of nodes in the tree :param q: Number of queries :param edges: List of edges defining the tree :param queries: List of queries, each a tuple (u, v) :return: A list of shortest path lengths for each query # Build the adjacency list for the tree tree = [[] for _ in range(n + 1)] for a, b in edges: tree[a].append(b) tree[b].append(a) results = [] for u, v in queries: results.append(bfs_distance(tree, n, u, v)) return results"},{"question":"from typing import List, Tuple def median_mode(numbers: List[int]) -> Tuple[float, int]: Returns the median and the mode of a list of integers. Parameters: numbers (list): List of integers. Returns: tuple: median (float), mode (int) >>> median_mode([1, 3, 3, 6, 7, 8, 9]) (6.0, 3) >>> median_mode([4, 2, 2, 8, 8, 9, 9]) (8.0, 2) from solution import median_mode def test_single_element(): assert median_mode([5]) == (5.0, 5) def test_odd_number_of_elements(): assert median_mode([1, 3, 3, 6, 7, 8, 9]) == (6.0, 3) def test_even_number_of_elements(): assert median_mode([1, 2, 3, 4, 5, 6, 8, 9]) == (4.5, 1) def test_mode_tie(): assert median_mode([4, 2, 2, 8, 8, 9, 9]) == (8.0, 2) def test_negative_numbers(): assert median_mode([-1, -2, -3, -3, -4]) == (-3.0, -3) def test_large_range_of_numbers(): assert median_mode([-1000000, 0, 1000000]) == (0.0, -1000000) def test_tie_for_mode_select_smallest(): assert median_mode([4, 5, 6, 6, 7, 7, 8]) == (6.0, 6)","solution":"from collections import Counter def median_mode(numbers): Returns the median and the mode of a list of integers. Parameters: numbers (list): List of integers. Returns: tuple: median (float), mode (int) # Sort the list to find the median sorted_numbers = sorted(numbers) n = len(sorted_numbers) # Compute the median if n % 2 == 1: median = sorted_numbers[n // 2] else: median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2 # Compute the mode count = Counter(sorted_numbers) mode = min(number for number, freq in count.items() if freq == max(count.values())) return float(median), mode"},{"question":"import math def max_guesses_needed(low: int, high: int) -> int: Determine the maximum number of guesses needed to find the number using a binary search strategy. Args: low (int): the lower bound of the guessing range (inclusive) high (int): the upper bound of the guessing range (inclusive) Returns: int: the maximum number of guesses needed. Examples: >>> max_guesses_needed(1, 100) 7 >>> max_guesses_needed(0, 10) 4","solution":"import math def max_guesses_needed(low, high): Returns the maximum number of guesses needed for a binary search strategy between the given low and high inclusive. return math.ceil(math.log2(high - low + 1))"},{"question":"def max_positive_revenue(n: int, revenues: List[int]) -> int: Find the maximum positive revenue over any continuous subarray of days. Args: n (int): Number of days. revenues (List[int]): List of integers representing daily sales revenue. Returns: int: Maximum positive revenue over any continuous subarray of days. If no such subarray exists, returns 0. Examples: >>> max_positive_revenue(7, [-3, -2, 4, -1, -2, 1, 5]) 7 >>> max_positive_revenue(5, [-1, -2, -3, -4, -5]) 0","solution":"def max_positive_revenue(n, revenues): Returns the maximum positive revenue over any continuous subarray of days. max_current = 0 max_global = 0 for revenue in revenues: max_current = max(revenue, max_current + revenue) max_global = max(max_global, max_current) # If max_global is still 0, we will return 0 (no positive subarray found) return max_global"},{"question":"from typing import List def wave_sort(arr: List[int]) -> List[int]: Rearranges the array to satisfy the wave condition. >>> wave_sort([3, 6, 5, 10, 7, 20]) in ([6, 3, 10, 5, 20, 7], [5, 3, 10, 6, 20, 7], [6, 5, 10, 3, 20, 7]) True >>> wave_sort([10, 90, 49, 2, 1, 5, 23]) [90, 10, 49, 2, 23, 1, 5] >>> wave_sort([4, 4, 4, 4, 4]) [4, 4, 4, 4, 4] >>> wave_sort([4, 1]) [4, 1] >>> wave_sort([5]) [5] >>> wave_sort([4, 1, 3, 1, 2, 1]) [4, 1, 3, 1, 2, 1]","solution":"def wave_sort(arr): Rearranges the array to satisfy the wave condition. n = len(arr) for i in range(1, n, 2): if arr[i-1] < arr[i]: arr[i-1], arr[i] = arr[i], arr[i-1] if i+1 < n and arr[i+1] < arr[i]: arr[i+1], arr[i] = arr[i], arr[i+1] return arr"},{"question":"def longest_palindrome_length(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the length of the longest palindrome that can be formed using characters of the string s. >>> longest_palindrome_length(3, [(5, \\"aabbc\\"), (6, \\"abcdef\\"), (4, \\"aaaa\\")]) [5, 1, 4] >>> longest_palindrome_length(2, [(3, \\"aaa\\"), (5, \\"bbbbb\\")]) [3, 5] >>> longest_palindrome_length(1, [(4, \\"abcd\\")]) [1] >>> longest_palindrome_length(2, [(5, \\"abbcc\\"), (7, \\"aabbccc\\")]) [5, 7] >>> longest_palindrome_length(1, [(1, \\"a\\")]) [1]","solution":"def longest_palindrome_length(t, test_cases): from collections import Counter results = [] for n, s in test_cases: freq = Counter(s) length = 0 odd_found = False for count in freq.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 results.append(length) return results"},{"question":"def can_rearrange(nums) -> str: Determine if it is possible to rearrange the elements of the array such that no two adjacent elements in the rearranged array are the same. >>> can_rearrange([1, 1, 1, 2, 2, 3]) \\"Yes\\" >>> can_rearrange([1]) \\"Yes\\" >>> can_rearrange([1, 1, 1, 1]) \\"No\\" >>> can_rearrange([3, 3, 3, 3, 2, 2, 2, 2, 1, 1]) \\"Yes\\" >>> can_rearrange([]) \\"No\\" >>> can_rearrange([10**6, 10**6, -(10**6), -(10**6)]) \\"Yes\\"","solution":"from collections import Counter def can_rearrange(nums): Returns \\"Yes\\" if it's possible to rearrange the array such that no two adjacent elements are the same, otherwise \\"No\\". if not nums: return \\"No\\" # Get the frequency of each element freq = Counter(nums) # Find the element with the maximum frequency max_count = max(freq.values()) # If the highest frequency of any element is more than (n+1)//2, then it's not possible # to rearrange the elements to meet the condition if max_count > (len(nums) + 1) // 2: return \\"No\\" return \\"Yes\\""},{"question":"def consecutive_happy_events(n: int, events: List[int], preferences: List[int]) -> List[int]: Dado un número total de eventos y las preferencias de los trabajadores sobre esos eventos, encuentra el conteo de eventos consecutivos que les gustaban a los trabajadores hasta la posición actual (a partir del segundo evento). Args: n (int): El número total de eventos. events (List[int]): Una lista de enteros que representan los eventos. preferences (List[int]): Una lista de enteros donde 1 indica que el trabajador gusta del evento y 0 lo contrario. Returns: List[int]: Una lista de enteros de longitud n-1 que representa el conteo de eventos consecutivos que le gustaban al trabajador. Ejemplo: >>> consecutive_happy_events(7, [1, 2, 2, 3, 3, 3, 4], [1, 1, 0, 1, 1, 1, 1]) [1, 0, 1, 2, 3, 4] >>> consecutive_happy_events(8, [1, 1, 2, 2, 3, 3, 4, 4], [1, 0, 1, 1, 0, 1, 1, 1]) [0, 1, 2, 0, 1, 2, 3]","solution":"def consecutive_happy_events(n, events, preferences): consecutive_counts = [] count = 0 for i in range(1, n): if preferences[i] == 1: if preferences[i - 1] == 1: count += 1 else: count = 1 else: count = 0 consecutive_counts.append(count) return consecutive_counts"},{"question":"def divisible_by_others(lst): Returns a list containing all integers from the original list that are divisible by at least one other integer in the same list. >>> divisible_by_others([2, 3, 8, 6, 12, 7]) [8, 6, 12] >>> divisible_by_others([5, 7, 11, 13]) [] # Unit Tests def test_example_case1(): assert divisible_by_others([2, 3, 8, 6, 12, 7]) == [8, 6, 12] def test_example_case2(): assert divisible_by_others([5, 7, 11, 13]) == [] def test_no_divisors(): assert divisible_by_others([1, 2, 3]) == [2, 3] def test_all_divisible(): assert divisible_by_others([2, 4, 6, 8]) == [4, 6, 8] def test_large_input(): assert divisible_by_others([1, 10**9]) == [10**9] def test_mixed_large_small(): assert divisible_by_others([10**9, 1, 10**6]) == [10**9, 10**6] def test_identical_numbers(): assert divisible_by_others([5, 5, 5, 5]) == [5, 5, 5, 5] def test_single_element(): assert divisible_by_others([1]) == [] def test_empty_input(): assert divisible_by_others([]) == [] def test_multiple_divisors(): assert divisible_by_others([2, 3, 6, 12, 24]) == [6, 12, 24] def test_prime_numbers(): assert divisible_by_others([5, 7, 11, 13, 17]) == []","solution":"def divisible_by_others(lst): Returns a list containing all integers from the original list that are divisible by at least one other integer in the same list. result = [] for i in range(len(lst)): for j in range(len(lst)): if i != j and lst[i] % lst[j] == 0: result.append(lst[i]) break return result"},{"question":"def length_of_lis(arr): Returns the length of the longest increasing subsequence (LIS) within the list. Parameters: arr (List[int]): A list of integers. Returns: int: The length of the longest increasing subsequence. Examples: >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the list. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def largestTeamSize(employees: int) -> List[int]: A company wants to organize a team-building exercise for its employees. The employees will be divided into teams such that each team has an equal number of members. The team size must be the largest possible that is a factor of the total number of employees. Given the number of employees in the company, this function returns the largest possible team size and the number of teams formed. Parameters: employees (int): The total number of employees. Returns: List[int]: A list with two elements, the largest possible team size and the number of teams. Examples: >>> largestTeamSize(100) [50, 2] >>> largestTeamSize(12) [6, 2] >>> largestTeamSize(17) [1, 17] def test_largest_team_size_100(): assert largestTeamSize(100) == [50, 2] def test_largest_team_size_12(): assert largestTeamSize(12) == [6, 2] def test_largest_team_size_17(): assert largestTeamSize(17) == [1, 17] def test_largest_team_size_prime_number(): assert largestTeamSize(19) == [1, 19] def test_largest_team_size_1(): assert largestTeamSize(1) == [1, 1] def test_largest_team_size_49(): assert largestTeamSize(49) == [7, 7] def test_largest_team_size_60(): assert largestTeamSize(60) == [30, 2]","solution":"from typing import List def largestTeamSize(employees: int) -> List[int]: Returns the largest possible team size and the number of teams formed. Parameters: employees (int): The total number of employees. Returns: List[int]: A list with two elements, the largest possible team size and the number of teams. for team_size in range(employees // 2, 0, -1): if employees % team_size == 0: return [team_size, employees // team_size] return [1, employees]"},{"question":"def recommend_books(n, book_author_list, m, user_ratings_list): Recommends books to users based on their highest rated book and its author. Parameters: - n (int): Number of books. - book_author_list (list): List of tuples, where each tuple contains a book title and an author. - m (int): Number of users. - user_ratings_list (list): List of tuples, where each tuple contains a user name and a dictionary with book titles as keys and ratings as values. Returns: - list: List of recommended books for each user or \\"No Recommendation\\". >>> recommend_books(5, [(\\"BookA\\", \\"Alice\\"), (\\"BookB\\", \\"Bob\\"), (\\"BookC\\", \\"Alice\\"), (\\"BookD\\", \\"Charlie\\"), (\\"BookE\\", \\"Bob\\")], 2, [(\\"User1\\", {\\"BookA\\": 8, \\"BookB\\": 9}), (\\"User2\\", {\\"BookA\\": 5, \\"BookD\\": 7})]) ['BookE', 'No Recommendation'] >>> recommend_books(4, [(\\"BookA\\", \\"Alice\\"), (\\"BookB\\", \\"Bob\\"), (\\"BookC\\", \\"Alice\\"), (\\"BookD\\", \\"Charlie\\")], 1, [(\\"User1\\", {\\"BookA\\": 10, \\"BookC\\": 10})]) ['BookC'] >>> recommend_books(3, [(\\"BookA\\", \\"Alice\\"), (\\"BookB\\", \\"Bob\\"), (\\"BookC\\", \\"Charlie\\")], 1, [(\\"User1\\", {\\"BookC\\": 5})]) ['No Recommendation'] >>> recommend_books(6, [(\\"BookA\\", \\"Alice\\"), (\\"BookB\\", \\"Bob\\"), (\\"BookC\\", \\"Alice\\"), (\\"BookD\\", \\"Charlie\\"), (\\"BookE\\", \\"Bob\\"), (\\"BookF\\", \\"Charlie\\")], 2, [(\\"User1\\", {\\"BookA\\": 7, \\"BookB\\": 6}), (\\"User2\\", {\\"BookD\\": 8})]) ['BookC', 'BookF']","solution":"def recommend_books(n, book_author_list, m, user_ratings_list): author_book_map = {} book_author_map = {} # Create mapping of author to the list of books they have written for book, author in book_author_list: if author in author_book_map: author_book_map[author].append(book) else: author_book_map[author] = [book] book_author_map[book] = author recommendations = [] for user, ratings in user_ratings_list: # Find the highest rated book the user has read highest_rated_book = max(ratings, key=ratings.get) highest_rating = ratings[highest_rated_book] author_of_highest = book_author_map[highest_rated_book] # Recommend a new book from the same author potential_books = sorted(book for book in author_book_map[author_of_highest] if book != highest_rated_book) if potential_books: recommendation = potential_books[0] else: recommendation = \\"No Recommendation\\" recommendations.append(recommendation) return recommendations"},{"question":"def count_unended_processes(n: int, events: List[str]) -> int: Determine how many processes have started but not yet ended at the end of the given list of events. Args: n (int): The number of events. events (List[str]): A list containing events. Returns: int: The number of processes that have started but not yet ended. Examples: >>> count_unended_processes(5, [\\"START1\\", \\"START2\\", \\"END1\\", \\"START3\\", \\"END3\\"]) 1 >>> count_unended_processes(3, [\\"START1\\", \\"START2\\", \\"END1\\"]) 1 >>> count_unended_processes(4, [\\"START4\\", \\"END4\\", \\"START5\\", \\"END5\\"]) 0 pass","solution":"def count_unended_processes(n, events): started_processes = set() ended_processes = set() for event in events: if event.startswith(\\"START\\"): process_id = event[5:] started_processes.add(process_id) elif event.startswith(\\"END\\"): process_id = event[3:] if process_id in started_processes: ended_processes.add(process_id) return len(started_processes - ended_processes)"},{"question":"def can_form_anagram(t: int, test_cases: List[Tuple[str, str]]) -> List[str]: Given two strings, determine if the first string can be rearranged to form the second string. >>> can_form_anagram(3, [(\\"anagram\\", \\"nagaram\\"), (\\"rat\\", \\"car\\"), (\\"listen\\", \\"silent\\")]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_form_anagram(1, [(\\"\\", \\"\\")]) [\\"YES\\"] >>> can_form_anagram(2, [(\\"a\\", \\"a\\"), (\\"a\\", \\"b\\")]) [\\"YES\\", \\"NO\\"] >>> can_form_anagram(1, [(\\"aabbcc\\", \\"abc\\")]) [\\"NO\\"] >>> can_form_anagram(1, [(\\"testcase\\", \\"testcase\\")]) [\\"YES\\"]","solution":"def can_form_anagram(t, test_cases): results = [] for a, b in test_cases: if sorted(a) == sorted(b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # t = 3 # test_cases = [(\\"anagram\\", \\"nagaram\\"), (\\"rat\\", \\"car\\"), (\\"listen\\", \\"silent\\")] # print(can_form_anagram(t, test_cases))"},{"question":"def min_percentage_of_transformation(n: int, k: int, transformations: List[int]) -> int: Determines the minimum number of occurrences of any transformation in percentage form. Parameters: n (int): Total number of files. k (int): Total number of unique transformations. transformations (List[int]): List of transformations applied to each file. Returns: int: Minimum percentage of any transformation rounded down to the nearest integer. Examples: >>> min_percentage_of_transformation(6, 3, [1, 2, 1, 3, 1, 2]) 16 >>> min_percentage_of_transformation(5, 2, [1, 2, 1, 1, 2]) 40","solution":"def min_percentage_of_transformation(n, k, transformations): Determines the minimum number of occurrences of any transformation in percentage form. from collections import Counter # Count occurrences of each transformation transformation_counts = Counter(transformations) # Find percentages percentages = [(count / n) * 100 for count in transformation_counts.values()] # Sort percentages in ascending order percentages.sort() # Return the minimum percentage rounded down return int(percentages[0])"},{"question":"def min_max_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the minimum possible value for the maximum difference between any two elements in the array after performing the allowed operations. Parameters: t (int): Number of test cases test_cases (list): List of tuples, each containing an integer \`n\` and a list \`a\` of length \`n\` Returns: list: List of integers where each integer is the minimum possible value of \`max(b) - min(b)\` for the corresponding test case >>> t = 3 >>> test_cases = [(3, [1, 5, 9]), (5, [1, 3, 3, 3, 7]), (4, [10, 10, 10, 10])] >>> min_max_difference(t, test_cases) [6, 4, 0] >>> t = 1 >>> test_cases = [(1, [5])] >>> min_max_difference(t, test_cases) [0] >>> t = 1 >>> test_cases = [(3, [7, 7, 7])] >>> min_max_difference(t, test_cases) [0] >>> t = 1 >>> test_cases = [(3, [1000000000, 1, 999999999])] >>> min_max_difference(t, test_cases) [999999997] >>> t = 2 >>> test_cases = [(5, [1, 2, 3, 4, 5]), (4, [10, 20, 30, 40])] >>> min_max_difference(t, test_cases) [2, 28]","solution":"def min_max_difference(t, test_cases): Finds the minimum possible value for the maximum difference between any two elements in the array after performing the allowed operations. Parameters: t (int): Number of test cases test_cases (list): List of tuples, each containing an integer \`n\` and a list \`a\` of length \`n\` Returns: list: List of integers where each integer is the minimum possible value of \`max(b) - min(b)\` for the corresponding test case results = [] for n, a in test_cases: min_a, max_a = min(a), max(a) diff = max_a - min_a results.append(max(0, diff - 2)) return results"},{"question":"from typing import List def can_segment(words: List[str], s: str) -> bool: Determine if the string \`s\` can be segmented into a space-separated sequence of one or more dictionary words from the list \`words\`. :param words: List of dictionary words :param s: The string to be segmented :return: True if s can be segmented, False otherwise >>> can_segment([\\"apple\\", \\"pen\\"], \\"applepenapple\\") == True >>> can_segment([\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"], \\"catsandog\\") == False >>> can_segment([\\"leet\\", \\"code\\"], \\"leetcode\\") == True >>> can_segment([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") == True def test_can_segment_example1(): assert can_segment([\\"apple\\", \\"pen\\"], \\"applepenapple\\") == True def test_can_segment_example2(): assert can_segment([\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"], \\"catsandog\\") == False def test_can_segment_example3(): assert can_segment([\\"leet\\", \\"code\\"], \\"leetcode\\") == True def test_can_segment_example4(): assert can_segment([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") == True def test_can_segment_single_character_true(): assert can_segment([\\"a\\"], \\"a\\") == True def test_can_segment_single_character_false(): assert can_segment([\\"a\\"], \\"b\\") == False def test_can_segment_empty_string(): assert can_segment([\\"apple\\", \\"pen\\"], \\"\\") == True def test_can_segment_partial_match(): assert can_segment([\\"apple\\", \\"pen\\"], \\"applepenapplepenman\\") == False","solution":"def can_segment(words, s): Determine if the string \`s\` can be segmented into a space-separated sequence of one or more dictionary words from the list \`words\`. :param words: List of dictionary words :param s: The string to be segmented :return: True if s can be segmented, False otherwise word_set = set(words) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"import heapq from typing import List def trapRainWater(grid: List[List[int]]) -> int: Given an n x m grid representing a field with terrain heights, simulate rainwater falling and determine how much water would be trapped after it settles. >>> trapRainWater([ ... [1, 1, 1, 1], ... [1, 0, 0, 1], ... [1, 0, 0, 1], ... [1, 1, 1, 1] ... ]) == 4 >>> trapRainWater([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 0 >>> trapRainWater([ ... [2, 2, 2, 2], ... [2, 0, 2, 2], ... [2, 2, 0, 2], ... [2, 2, 2, 2] ... ]) == 4 >>> trapRainWater([ ... [0] ... ]) == 0 >>> trapRainWater([ ... [1, 1], ... [1, 1] ... ]) == 0","solution":"import heapq def trapRainWater(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) visited = [[False] * m for _ in range(n)] heap = [] # Add boundary cells to the heap for i in range(n): heapq.heappush(heap, (grid[i][0], i, 0)) heapq.heappush(heap, (grid[i][m-1], i, m-1)) visited[i][0] = visited[i][m-1] = True for j in range(m): heapq.heappush(heap, (grid[0][j], 0, j)) heapq.heappush(heap, (grid[n-1][j], n-1, j)) visited[0][j] = visited[n-1][j] = True total_water = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True total_water += max(0, height - grid[nx][ny]) heapq.heappush(heap, (max(height, grid[nx][ny]), nx, ny)) return total_water"},{"question":"from typing import List, Tuple def max_subarray_sum(arr: List[int]) -> int: Returns the sum of the maximum subarray in the array. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1, -2, -3]) == -1 pass def min_energy(arr: List[int]) -> int: Returns the minimum energy in the list. >>> min_energy([1, 2, 3, 4, 5]) == 1 >>> min_energy([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == -5 >>> min_energy([-1, -2, -3]) == -3 pass def bird_flight_analysis(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Birds are migrating, and they take flight in groups. Each bird is represented by its energy level. The Bird Leader wants to know the group’s strength, which is defined as the sum of the maximum subarray in the energies. Additionally, the Bird Leader is curious if the group has any weak links, defined as the minimum energy in the group. Args: T: int - the number of test cases test_cases: List of tuples, each containing the number of birds (N) and a list of N space-separated integers representing the energy levels of the birds. Returns: A list of tuples, where each tuple contains the strength of the group and the weakest link for each test case. >>> input_data = [(5, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (3, [-1, -2, -3])] >>> bird_flight_analysis(2, input_data) == [(6, -5), (-1, -3)] >>> input_data = [(4, [1, -2, 3, 10, -4, 7, 2, -5]), (5, [-2, -3, 4, -1, -2, 1, 5, -3])] >>> bird_flight_analysis(2, input_data) == [(18, -5), (7, -3)] pass","solution":"def max_subarray_sum(arr): Returns the sum of the maximum subarray in the array. max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def min_energy(arr): Returns the minimum energy in the list. return min(arr) def bird_flight_analysis(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] energies = test_cases[i][1] group_strength = max_subarray_sum(energies) weakest_link = min_energy(energies) results.append((group_strength, weakest_link)) return results"},{"question":"def create_longest_playlist(n, songs, genres): Create the longest possible playlist such that no two consecutive songs share the same genre. Args: n (int): the number of songs in the list. songs (List[str]): a list of unique song names. genres (List[str]): a list of genres where the ith genre corresponds to the ith song. Returns: List[str]: the names of the songs in one possible longest playlist such that no two consecutive songs share the same genre. Example: >>> create_longest_playlist(7, [\\"song1\\", \\"song2\\", \\"song3\\", \\"song4\\", \\"song5\\", \\"song6\\", \\"song7\\"], [\\"rock\\", \\"jazz\\", \\"pop\\", \\"rock\\", \\"pop\\", \\"jazz\\", \\"pop\\"]) ['song1', 'song2', 'song3', 'song4', 'song6', 'song7', 'song5']","solution":"def create_longest_playlist(n, songs, genres): # Creating a list of tuples where each tuple contains a song and its genre song_list = list(zip(songs, genres)) # Sort songs by genre to facilitate the creation of non-repetitive genre playlist song_list.sort(key=lambda x: x[1]) # Dictionary to keep track of last added song genre last_genre = None playlist = [] while song_list: for i in range(len(song_list)): if song_list[i][1] != last_genre: playlist.append(song_list[i][0]) last_genre = song_list.pop(i)[1] break else: # In case we can't find a different genre (it means we are done) break return playlist"},{"question":"from typing import List, Tuple def min_operations_to_uniform_matrix(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determine the minimum number of operations required to make the entire matrix uniform. >>> min_operations_to_uniform_matrix(2, [(2, 2, [[1, 3], [2, 4]]), (3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]])]) [6, 0] pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, List[List[int]]]]]: Parse input string to extract the number of test cases and the test case details. >>> input_str = '2n2 2n1 3n2 4n3 3n1 1 1n1 1 1n1 1 1' >>> parse_input(input_str) (2, [(2, 2, [[1, 3], [2, 4]]), (3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]])]) pass def format_output(results: List[int]) -> str: Format the list of results into a string for output. >>> format_output([6, 0]) '6n0' pass","solution":"def min_operations_to_uniform_matrix(t, test_cases): results = [] for case in test_cases: m, n, matrix = case max_val = max(max(row) for row in matrix) total_increments = sum(max_val - cell for row in matrix for cell in row) results.append(total_increments) return results def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") t = int(input_lines[0]) test_cases = [] line_index = 1 for _ in range(t): m, n = map(int, input_lines[line_index].split()) matrix = [list(map(int, input_lines[line_index+1+i].split())) for i in range(m)] test_cases.append((m, n, matrix)) line_index += m + 1 return t, test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def max_parking_spaces(T, parking_lot_data): Determines the maximum number of parking spaces available on any single day for each parking lot. Args: T (int): The number of parking lots. parking_lot_data (list of tuples): Each tuple contains M (int) and a list of M integers representing space availability. Returns: list: A list containing the maximum number of parking spaces available on any day for each parking lot. >>> max_parking_spaces(1, [(3, [10, 0, 15])]) == [15] >>> max_parking_spaces(2, [(3, [10, 0, 15]), (4, [8, 8, 8, 16])]) == [15, 16] >>> max_parking_spaces(1, [(4, [8, 8, 8, 8])]) == [8] >>> max_parking_spaces(1, [(3, [0, 0, 0])]) == [0] >>> max_parking_spaces(3, [(5, [1, 2, 3, 4, 5]), (2, [5, 10]), (6, [0, 1, 0, 1, 0, 1])]) == [5, 10, 1]","solution":"def max_parking_spaces(T, parking_lot_data): Determines the maximum number of parking spaces available on any single day for each parking lot. Args: T (int): The number of parking lots. parking_lot_data (list of tuples): Each tuple contains M (int) and a list of M integers representing space availability. Returns: list: A list containing the maximum number of parking spaces available on any day for each parking lot. max_spaces = [] for data in parking_lot_data: M, spaces = data max_spaces.append(max(spaces)) return max_spaces"},{"question":"def uniquePaths(grid): Returns the number of unique paths from top-left to bottom-right corner in a grid, avoiding walls. Arguments: grid -- m x n 2D list containing integers 0 (free space) or 1 (wall) Returns: int -- number of unique paths >>> grid1 = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> uniquePaths(grid1) 2 >>> grid2 = [ ... [0, 1], ... [0, 0] ... ] >>> uniquePaths(grid2) 1 >>> grid3 = [ ... [1, 0], ... [0, 0] ... ] >>> uniquePaths(grid3) 0 >>> grid4 = [ ... [0, 0], ... [0, 1] ... ] >>> uniquePaths(grid4) 0 >>> grid5 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> uniquePaths(grid5) 6 >>> grid6 = [ ... [0] ... ] >>> uniquePaths(grid6) 1 >>> grid7 = [ ... [0, 0], ... [1, 0] ... ] >>> uniquePaths(grid7) 1 >>> grid8 = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> uniquePaths(grid8) 1 >>> grid9 = [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0] ... ] >>> uniquePaths(grid9) 3","solution":"def uniquePaths(grid): Returns the number of unique paths from top-left to bottom-right corner in a grid, avoiding walls. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def max_boxes_stored(T, test_cases): Determine the maximum number of boxes that can be stored in the warehouse for each test case. Parameters: - T: int, number of test cases - test_cases: list of tuples, each tuple contains: - N: int, number of boxes - C: int, capacity of the warehouse - weights: list of ints, weights of the boxes Returns: - list of ints, maximum number of boxes that can be stored for each test case pass # Test cases def test_case_1(): T = 2 test_cases = [ (5, 10, [2, 3, 5, 4, 6]), (3, 8, [7, 3, 2]) ] assert max_boxes_stored(T, test_cases) == [3, 2] def test_case_all_fit(): T = 1 test_cases = [ (4, 20, [2, 3, 5, 4]) ] assert max_boxes_stored(T, test_cases) == [4] def test_case_none_fit(): T = 1 test_cases = [ (3, 3, [4, 5, 6]) ] assert max_boxes_stored(T, test_cases) == [0] def test_case_single_box_fits(): T = 1 test_cases = [ (5, 5, [6, 7, 4, 11, 10]) ] assert max_boxes_stored(T, test_cases) == [1] def test_case_max_single_box_weight(): T = 1 test_cases = [ (5, 1000000, [1000000, 999999, 500000, 1, 2]) ] assert max_boxes_stored(T, test_cases) == [3]","solution":"def max_boxes_stored(T, test_cases): Given number of test cases and the test case details, return the maximum number of boxes that can be stored in the warehouse for each test case. Parameters: - T: int, number of test cases - test_cases: list of tuples, each tuple contains: - N: int, number of boxes - C: int, capacity of the warehouse - weights: list of ints, weights of the boxes Returns: - list of ints, maximum number of boxes that can be stored for each test case results = [] for N, C, weights in test_cases: weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= C: total_weight += weight count += 1 else: break results.append(count) return results"},{"question":"def reverse_sentence(sentence: str) -> str: Reverses each word in the sentence while maintaining original word order and capitalization of the first letter. >>> reverse_sentence(\\"Hello World\\") 'Olleh Dlrow' >>> reverse_sentence(\\"Python is Fun\\") 'Nohtyp Si Nuf'","solution":"def reverse_sentence(sentence): Reverses each word in the sentence while maintaining original word order and capitalization of the first letter. def reverse_word(word): if not word: # if the word is empty return word reversed_word = word[1:][::-1] + word[0] return reversed_word.capitalize() words = sentence.split() reversed_words = [reverse_word(word) for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List def process_queries(n: int, m: int, grid: List[List[int]], queries: List[str]) -> List[int]: Process queries on a grid where you can set values and find the maximum value in subgrids. >>> process_queries(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [\\"MAX 1 1 3 3\\", \\"SET 2 2 10\\", \\"MAX 1 1 3 3\\", \\"MAX 2 2 3 3\\", \\"SET 3 1 0\\"]) [9, 10, 10] >>> process_queries(2, 2, [[1, 2], [3, 4]], [\\"MAX 1 1 2 2\\", \\"SET 1 1 5\\", \\"MAX 1 1 2 2\\", \\"MAX 1 1 1 2\\", \\"MAX 2 1 2 2\\"]) [4, 5, 5, 4] >>> process_queries(1, 1, [[1]], [\\"MAX 1 1 1 1\\", \\"SET 1 1 2\\", \\"MAX 1 1 1 1\\"]) [1, 2] >>> process_queries(3, 3, [[1, 2, 3], [0, 1, 0], [4, 5, 1]], [\\"MAX 1 1 1 3\\", \\"SET 1 3 10\\", \\"MAX 1 1 1 3\\"]) [3, 10]","solution":"def process_queries(n, m, grid, queries): from functools import reduce def set_value(grid, x, y, val): grid[x-1][y-1] = val def max_in_subgrid(grid, x1, y1, x2, y2): return max([max(row[y1-1:y2]) for row in grid[x1-1:x2]]) results = [] for query in queries: tokens = query.split() if tokens[0] == 'SET': x, y, val = int(tokens[1]), int(tokens[2]), int(tokens[3]) set_value(grid, x, y, val) elif tokens[0] == 'MAX': x1, y1, x2, y2 = int(tokens[1]), int(tokens[2]), int(tokens[3]), int(tokens[4]) results.append(max_in_subgrid(grid, x1, y1, x2, y2)) return results"},{"question":"def longest_increasing_subarray(n, sweetness): Finds the length of the longest strictly increasing subarray. Parameters: n (int): The number of candies. sweetness (list of int): The sweetness values. Returns: int: The length of the longest strictly increasing subarray. >>> longest_increasing_subarray(6, [1, 2, 2, 3, 5, 6]) == 4 >>> longest_increasing_subarray(10, [5, 1, 2, 3, 2, 4, 5, 6, 7, 8]) == 6 >>> longest_increasing_subarray(5, [1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subarray(5, [5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subarray(1, [7]) == 1 >>> longest_increasing_subarray(8, [1, 2, 3, 1, 2, 3, 4, 5]) == 5","solution":"def longest_increasing_subarray(n, sweetness): Finds the length of the longest strictly increasing subarray. Parameters: n (int): The number of candies. sweetness (list of int): The sweetness values. Returns: int: The length of the longest strictly increasing subarray. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sweetness[i] > sweetness[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Check for the last increasing subarray max_length = max(max_length, current_length) return max_length"},{"question":"from math import comb from typing import List, Tuple def count_basket_combinations(M: int, N: int, quantities: List[int]) -> int: Calculate the number of ways to create a basket with exactly N items. Parameters: M (int): The number of types of items. N (int): The number of items that each basket must contain. quantities (List[int]): The quantities of each type of item. Returns: int: The number of different combinations of baskets that can be created. >>> count_basket_combinations(3, 2, [1, 2, 3]) 3 >>> count_basket_combinations(4, 3, [2, 2, 1, 1]) 4 pass def solve_basket_combinations(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Solve the basket combination problem for multiple test cases. Parameters: test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, where each test case is a tuple containing: - An integer M representing the number of types of items. - An integer N representing the number of items that each basket must contain. - A list of integers representing the quantities of each type of item. Returns: List[int]: A list of results corresponding to the number of different combinations of baskets that can be created for each test case. >>> solve_basket_combinations([(3, 2, [1, 2, 3]), (4, 3, [2, 2, 1, 1]), (5, 3, [1, 1, 1, 1, 1])]) [3, 4, 10] pass","solution":"from math import comb def count_basket_combinations(M, N, quantities): Calculate the number of ways to create a basket with exactly N items. return comb(M, N) def solve_basket_combinations(test_cases): Solve the basket combination problem for multiple test cases. results = [] for M, N, quantities in test_cases: results.append(count_basket_combinations(M, N, quantities)) return results"},{"question":"def will_robots_collide(n: int, robots: List[Tuple[int, int, str]], m: int, commands: List[Tuple[int, int]]) -> str: Determine if any two robots collide after executing the commands. The function takes the number of robots, their initial positions and directions, the number of commands, and each command detailing which robot to move and by how many steps. Parameters: n (int): Number of robots. robots (List[Tuple[int, int, str]]): Each tuple contains x (int), y (int) coordinates and direction (str). m (int): Number of commands. commands (List[Tuple[int, int]]): Each tuple contains robot index (1-based) and number of steps. Returns: str: \\"Yes\\" if any robots collide, otherwise \\"No\\". Example: >>> will_robots_collide( ... 4, ... [(1, 1, 'N'), (2, 2, 'E'), (0, 2, 'S'), (2, 3, 'W')], ... 3, ... [(1, 2), (2, 1), (3, 1)] ... ) \\"No\\" >>> will_robots_collide( ... 4, ... [(1, 1, 'N'), (1, 3, 'S'), (3, 3, 'W'), (5, 7, 'E')], ... 2, ... [(1, 2), (2, 2)] ... ) \\"Yes\\"","solution":"def will_robots_collide(n, robots, m, commands): directions = { 'N': (0, 1), 'E': (1, 0), 'S': (0, -1), 'W': (-1, 0) } positions = {} for i, (x, y, d) in enumerate(robots): positions[i] = (x, y, d) position_set = set() for key, value in positions.items(): position_set.add((value[0], value[1])) for i, steps in commands: robot_index = i - 1 x, y, d = positions[robot_index] dx, dy = directions[d] new_x = x + dx * steps new_y = y + dy * steps if (new_x, new_y) in position_set: return \\"Yes\\" position_set.remove((x, y)) position_set.add((new_x, new_y)) positions[robot_index] = (new_x, new_y, d) return \\"No\\""},{"question":"def find_jedi_master(candidates): Returns the name of the Jedi candidate with the highest power level. If there's a tie, the lexicographically first name is chosen. jedi_master_name = '' max_power = -1 for candidate in candidates: name, power = candidate.split() power = int(power) if power > max_power or (power == max_power and name < jedi_master_name): jedi_master_name = name max_power = power return jedi_master_name def test_find_jedi_master_single(): candidates = [\\"yoda 950\\"] assert find_jedi_master(candidates) == \\"yoda\\" def test_find_jedi_master_multiple(): candidates = [\\"anakin 850\\", \\"yoda 950\\", \\"mace 950\\", \\"obiwan 920\\"] assert find_jedi_master(candidates) == \\"mace\\" def test_find_jedi_master_tie(): candidates = [\\"anakin 850\\", \\"obiwan 850\\", \\"mace 850\\"] assert find_jedi_master(candidates) == \\"anakin\\" def test_find_jedi_master_varied_power_levels(): candidates = [\\"anakin 851\\", \\"yoda 900\\", \\"mace 930\\", \\"obiwan 850\\"] assert find_jedi_master(candidates) == \\"mace\\" def test_find_jedi_master_all_same_level(): candidates = [\\"bob 450\\", \\"alice 450\\", \\"zara 450\\"] assert find_jedi_master(candidates) == \\"alice\\"","solution":"def find_jedi_master(candidates): Returns the name of the Jedi candidate with the highest power level. If there's a tie, the lexicographically first name is chosen. jedi_master_name = '' max_power = -1 for candidate in candidates: name, power = candidate.split() power = int(power) if power > max_power or (power == max_power and name < jedi_master_name): jedi_master_name = name max_power = power return jedi_master_name"},{"question":"import math from typing import List def extractAndSortPrimes(arr: List[int]) -> List[int]: Given an unsorted array of integers, return a new array containing all the prime numbers from the original array, sorted in descending order. A prime number is defined as a number greater than 1 that has no positive divisors other than 1 and itself. If there are no prime numbers in the given array, the function should return an empty array. >>> extractAndSortPrimes([10, 15, 3, 7, 11, 18, 29]) [29, 11, 7, 3] >>> extractAndSortPrimes([4, 6, 8, 10, 12]) [] def test_example_1(): assert extractAndSortPrimes([10, 15, 3, 7, 11, 18, 29]) == [29, 11, 7, 3] def test_example_2(): assert extractAndSortPrimes([4, 6, 8, 10, 12]) == [] def test_no_primes(): assert extractAndSortPrimes([1, 4, 6, 8, 10, 12, 14, 15]) == [] def test_all_primes(): assert extractAndSortPrimes([2, 3, 5, 7, 11, 13, 17, 19]) == [19, 17, 13, 11, 7, 5, 3, 2] def test_mixed_numbers(): assert extractAndSortPrimes([10, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [7, 5, 3, 2] def test_large_array(): large_list = list(range(1, 100000)) primes = extractAndSortPrimes(large_list) assert primes[-1] == 2 # Smallest prime assert primes[0] == 99991 # Largest prime in the range","solution":"import math def is_prime(num): if num <= 1: return False for i in range(2, math.isqrt(num) + 1): if num % i == 0: return False return True def extractAndSortPrimes(arr): primes = [num for num in arr if is_prime(num)] primes.sort(reverse=True) return primes"},{"question":"def min_transformations(start: str, end: str, allowed: List[str]) -> int: Determine the minimum number of transformations required to convert \`start\` into \`end\` using the strings in \`allowed\`. Each transformation involves changing exactly one character of the current string to match an allowed string. Parameters: - start (str): The initial string. - end (str): The target string. - allowed (List[str]): List of allowed strings for transformation. Returns: - int: The minimum number of transformations required, or -1 if no valid transformation sequence exists. Examples: >>> min_transformations(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 4 >>> min_transformations(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) -1 >>> min_transformations(\\"abc\\", \\"cab\\", [\\"aac\\", \\"cbc\\", \\"cac\\", \\"cab\\", \\"aab\\"]) 3","solution":"def min_transformations(start, end, allowed): from collections import deque def is_adjacent(word1, word2): Check if two words differ by exactly one character. differences = sum(1 for a, b in zip(word1, word2) if a != b) return differences == 1 allowed_set = set(allowed) queue = deque([(start, 0)]) # (current string, current transformation count) visited = set() # To keep track of visited words while queue: current_word, steps = queue.popleft() if current_word == end: return steps for allowed_word in allowed_set: if is_adjacent(current_word, allowed_word) and allowed_word not in visited: visited.add(allowed_word) queue.append((allowed_word, steps + 1)) return -1"},{"question":"def find_single(nums): Given a list of integers where each integer appears exactly twice except for one integer which appears exactly once, returns the single integer. def solve(test_cases): Processes multiple test cases and returns a list of results where each result is the single integer among a list of integers for each test case. Each test case is a tuple containing: - an integer n: the number of integers in the list - an list of n integers: where each integer appears exactly twice except one Example: >>> solve([(7, [2, 3, 2, 4, 4, 3, 5]), (5, [1, 1, 2, 2, 3]), (3, [7, 8, 7])]) [5, 3, 8]","solution":"def find_single(nums): Given a list of integers where each integer appears exactly twice except for one integer which appears exactly once, returns the single integer. xor_result = 0 for num in nums: xor_result ^= num return xor_result def solve(test_cases): results = [] for case in test_cases: n, nums = case results.append(find_single(nums)) return results"},{"question":"def sliding_window_sum(nums: List[int], k: int) -> List[int]: Computes the sum of each sliding window of size k. Parameters: nums (list of integers): The list of integers. k (int): The size of the sliding window. Returns: list of integers: The list containing the sum of each sliding window. >>> sliding_window_sum([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, -1, 1, 5, 14, 16] >>> sliding_window_sum([5], 1) [5] >>> sliding_window_sum([-4, -5, -6, -7], 2) [-9, -11, -13] >>> sliding_window_sum([1, 2, 3, 4, 5], 5) [15] >>> sliding_window_sum([10**4, 10**4, -10**4], 2) [20000, 0] >>> sliding_window_sum([], 3) [] >>> sliding_window_sum([1, 2], 3) []","solution":"def sliding_window_sum(nums, k): Computes the sum of each sliding window of size k. Parameters: nums (list of integers): The list of integers. k (int): The size of the sliding window. Returns: list of integers: The list containing the sum of each sliding window. n = len(nums) if n == 0 or k == 0 or k > n: return [] window_sum = sum(nums[:k]) result = [window_sum] for i in range(n - k): window_sum += nums[i + k] - nums[i] result.append(window_sum) return result"},{"question":"def count_differences(N: int, A: str, B: str) -> int: Determine the number of positions where the characters in A and B differ. Parameters: N (int): Length of the sequences A and B. A (str): DNA sequence of length N. B (str): DNA sequence of length N. Returns: int: Number of positions where A and B differ. >>> count_differences(5, 'ACGTT', 'ACGGT') 1 >>> count_differences(6, 'AAGGCT', 'TTCCGG') 6 >>> count_differences(10, 'AAACCCGGGT', 'AAACTCGGGC') 2","solution":"def count_differences(N, A, B): Returns the number of positions where the characters in A and B differ. Parameters: N (int): Length of the sequences A and B. A (str): DNA sequence of length N. B (str): DNA sequence of length N. Returns: int: Number of positions where A and B differ. differences = 0 for i in range(N): if A[i] != B[i]: differences += 1 return differences"},{"question":"class SumMatrix: def __init__(self, matrix): Preprocess the 2D matrix to handle submatrix sum queries efficiently. :param matrix: List[List[int]], a 2D matrix of size m x n to be preprocessed. def query(self, r1, c1, r2, c2): Return the sum of all elements in the submatrix defined by the top-left (r1, c1) and bottom-right (r2, c2) corners. :param r1: int, the row of the top-left corner (1-indexed). :param c1: int, the column of the top-left corner (1-indexed). :param r2: int, the row of the bottom-right corner (1-indexed). :param c2: int, the column of the bottom-right corner (1-indexed). :return: int, the sum of all elements in the defined submatrix. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> sm = SumMatrix(matrix) >>> sm.query(1, 1, 2, 2) 12 >>> sm.query(2, 2, 3, 3) 28 from solution import SumMatrix def test_sum_matrix_simple_case(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] sm = SumMatrix(matrix) assert sm.query(1, 1, 2, 2) == 12 # Sum of submatrix [[1, 2], [4, 5]] assert sm.query(2, 2, 3, 3) == 28 # Sum of submatrix [[5, 6], [8, 9]] assert sm.query(1, 1, 3, 3) == 45 # Sum of entire matrix def test_sum_matrix_single_element(): matrix = [ [1, 2], [3, 4] ] sm = SumMatrix(matrix) assert sm.query(1, 1, 1, 1) == 1 assert sm.query(2, 2, 2, 2) == 4 def test_sum_matrix_entire_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] sm = SumMatrix(matrix) assert sm.query(1, 1, 3, 4) == 78 # Sum of entire matrix def test_sum_matrix_multiple_queries(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] sm = SumMatrix(matrix) assert sm.query(1, 1, 3, 1) == 12 # Sum of first column [1, 4, 7] assert sm.query(1, 1, 3, 2) == 27 # Sum of first two columns assert sm.query(2, 1, 3, 2) == 24 # Sum of part of matrix [[4, 5], [7, 8]] def test_sum_matrix_edge_cases(): matrix = [[5]] sm = SumMatrix(matrix) assert sm.query(1, 1, 1, 1) == 5","solution":"class SumMatrix: def __init__(self, matrix): self.m = len(matrix) self.n = len(matrix[0]) self.prefix_sum = [[0] * (self.n + 1) for _ in range(self.m + 1)] for i in range(1, self.m + 1): for j in range(1, self.n + 1): self.prefix_sum[i][j] = (matrix[i-1][j-1] + self.prefix_sum[i-1][j] + self.prefix_sum[i][j-1] - self.prefix_sum[i-1][j-1]) def query(self, r1, c1, r2, c2): return (self.prefix_sum[r2][c2] - self.prefix_sum[r1-1][c2] - self.prefix_sum[r2][c1-1] + self.prefix_sum[r1-1][c1-1])"},{"question":"def find_top_contestant(N, M, scores): Finds the contestant with the highest total score. Parameters: N (int): Number of contestants M (int): Number of dishes each contestant has cooked scores (list of lists): A 2D list where each sublist contains M scores of a contestant Returns: int: 1-based index of the contestant with the highest total score pass # Test Cases def test_example_case_1(): N = 3 M = 4 scores = [ [10, 20, 30, 40], [5, 15, 25, 35], [7, 14, 21, 28] ] assert find_top_contestant(N, M, scores) == 1 def test_all_contestants_tie(): N = 3 M = 4 scores = [ [10, 10, 10, 10], [10, 10, 10, 10], [10, 10, 10, 10] ] assert find_top_contestant(N, M, scores) == 1 def test_diff_scores(): N = 3 M = 3 scores = [ [5, 15, 10], [12, 11, 13], [6, 10, 9] ] assert find_top_contestant(N, M, scores) == 2 def test_single_contestant(): N = 1 M = 4 scores = [ [8, 9, 10, 11] ] assert find_top_contestant(N, M, scores) == 1 def test_multiple_top_scores(): N = 3 M = 2 scores = [ [15, 15], [15, 15], [10, 20] ] assert find_top_contestant(N, M, scores) == 1 def test_all_zero_scores(): N = 2 M = 3 scores = [ [0, 0, 0], [0, 0, 0] ] assert find_top_contestant(N, M, scores) == 1","solution":"def find_top_contestant(N, M, scores): Finds the contestant with the highest total score. Parameters: N (int): Number of contestants M (int): Number of dishes each contestant has cooked scores (list of lists): A 2D list where each sublist contains M scores of a contestant Returns: int: 1-based index of the contestant with the highest total score max_total_score = -1 top_contestant = -1 for i in range(N): total_score = sum(scores[i]) if total_score > max_total_score: max_total_score = total_score top_contestant = i + 1 # convert 0-based index to 1-based index return top_contestant"},{"question":"def three_sum_exists(nums: List[int], target: int) -> bool: Determines if there are three distinct elements in the list nums that sum up to target. :param nums: List[int] - A list of integers. :param target: int - The target sum. :return: bool - True if there are three distinct elements in nums that sum up to target, otherwise False. pass # Test Cases def test_three_sum_exists_positive(): assert three_sum_exists([2, 4, 8, -1, 3, 5], 7) == True def test_three_sum_exists_all_ones(): assert three_sum_exists([1, 1, 1, 1, 1], 4) == False def test_three_sum_exists_mixed_numbers(): assert three_sum_exists([5, 9, -3, 7, 2, 6], 10) == True def test_three_sum_exists_no_combination(): assert three_sum_exists([1, 2, 3, 4], 100) == False def test_three_sum_exists_not_enough_elements(): assert three_sum_exists([1, 2], 3) == False def test_three_sum_exists_with_zero(): assert three_sum_exists([0, -1, 1, 2], 1) == True def test_three_sum_exists_neg_pos_mix(): assert three_sum_exists([-5, -2, 0, 2, 3, 5], 1) == True","solution":"def three_sum_exists(nums, target): Determines if there are three distinct elements in the list nums that sum up to target. :param nums: List[int] - A list of integers. :param target: int - The target sum. :return: bool - True if there are three distinct elements in nums that sum up to target, otherwise False. n = len(nums) if n < 3: return False nums.sort() for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: # avoid duplicates continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def find_decimal_equivalent(fraction_string): Returns the decimal equivalent of a fraction in the format \`N/D\`. If the denominator is 0, returns None. >>> find_decimal_equivalent(\\"3/4\\") 0.7500 >>> find_decimal_equivalent(\\"10/3\\") 3.3333 >>> find_decimal_equivalent(\\"2/0\\") None >>> find_decimal_equivalent(\\"-3/4\\") -0.7500 >>> find_decimal_equivalent(\\"not a fraction\\") None","solution":"def find_decimal_equivalent(fraction_string): Returns the decimal equivalent of a fraction in the format \`N/D\`. If the denominator is 0, returns None. try: numerator, denominator = map(int, fraction_string.split('/')) if denominator == 0: return None return round(numerator / denominator, 4) except ValueError: # Handle cases where input is not in the correct format return None"},{"question":"def check_supplies_network(n: int, m: int, roads: List[Tuple[int, int]]) -> str: Check if the supply distribution network is effectively designed. Args: n (int): Number of shelters. m (int): Number of connecting roads. roads (List[Tuple[int, int]]): List of tuples where each tuple represents a road connecting two shelters. Returns: str: \\"valid\\" if the network is designed properly, otherwise \\"invalid\\". Examples: >>> check_supplies_network(4, 3, [(1, 2), (2, 3), (3, 4)]) 'valid' >>> check_supplies_network(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) 'invalid' from typing import List, Tuple def test_valid_network(): assert check_supplies_network(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"valid\\" def test_invalid_network(): assert check_supplies_network(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) == \\"invalid\\" def test_minimum_network(): assert check_supplies_network(2, 1, [(1, 2)]) == \\"valid\\" def test_disconnected_network(): assert check_supplies_network(4, 2, [(1, 2), (3, 4)]) == \\"invalid\\" def test_cycle_network(): assert check_supplies_network(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"invalid\\"","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def is_valid_network(n, roads): parent = list(range(n)) rank = [0] * n for a, b in roads: x = find(parent, a - 1) y = find(parent, b - 1) if x != y: union(parent, rank, x, y) else: return False root = find(parent, 0) for i in range(1, n): if find(parent, i) != root: return False return True def check_supplies_network(n, m, roads): if is_valid_network(n, roads): return \\"valid\\" else: return \\"invalid\\""},{"question":"def filter_words_by_frequency(input_dict: dict, min_freq: int, max_freq: int) -> dict: Filters the words in the dictionary based on the frequency range [min_freq, max_freq]. Parameters: input_dict (dict): A dictionary with words as keys and their frequencies as values. min_freq (int): The minimum frequency to filter words. max_freq (int): The maximum frequency to filter words. Returns: dict: A new dictionary with words filtered by frequency. Example: >>> input_dict = { >>> 'apple': 4, >>> 'banana': 2, >>> 'orange': 1, >>> 'grape': 5, >>> 'mango': 3 >>> } >>> filter_words_by_frequency(input_dict, 2, 4) {'apple': 4, 'banana': 2, 'mango': 3} from solution import filter_words_by_frequency def test_filter_words_by_frequency_normal_case(): input_dict = { 'apple': 4, 'banana': 2, 'orange': 1, 'grape': 5, 'mango': 3 } min_freq = 2 max_freq = 4 expected_output = { 'apple': 4, 'banana': 2, 'mango': 3 } assert filter_words_by_frequency(input_dict, min_freq, max_freq) == expected_output def test_filter_words_by_frequency_empty_result(): input_dict = { 'apple': 4, 'banana': 2, 'orange': 1, 'grape': 5, 'mango': 3 } min_freq = 6 max_freq = 10 expected_output = {} assert filter_words_by_frequency(input_dict, min_freq, max_freq) == expected_output def test_filter_words_by_frequency_all_words(): input_dict = { 'apple': 4, 'banana': 2, 'orange': 1, 'grape': 5, 'mango': 3 } min_freq = 1 max_freq = 5 expected_output = { 'apple': 4, 'banana': 2, 'orange': 1, 'grape': 5, 'mango': 3 } assert filter_words_by_frequency(input_dict, min_freq, max_freq) == expected_output def test_filter_words_by_frequency_single_word_result(): input_dict = { 'apple': 4, 'banana': 2, 'orange': 1, 'grape': 5, 'mango': 3 } min_freq = 5 max_freq = 5 expected_output = { 'grape': 5 } assert filter_words_by_frequency(input_dict, min_freq, max_freq) == expected_output def test_filter_words_by_frequency_no_words(): input_dict = {} min_freq = 1 max_freq = 5 expected_output = {} assert filter_words_by_frequency(input_dict, min_freq, max_freq) == expected_output","solution":"def filter_words_by_frequency(input_dict, min_freq, max_freq): Filters the words in the dictionary based on the frequency range [min_freq, max_freq]. Parameters: input_dict (dict): A dictionary with words as keys and their frequencies as values. min_freq (int): The minimum frequency to filter words. max_freq (int): The maximum frequency to filter words. Returns: dict: A new dictionary with words filtered by frequency. return {word: freq for word, freq in input_dict.items() if min_freq <= freq <= max_freq}"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums): Build the maximum binary tree from the given array. >>> tree_to_list(constructMaximumBinaryTree([3, 2, 1, 6, 0, 5])) [6, 3, 5, None, 2, 0, None, None, 1] >>> tree_to_list(constructMaximumBinaryTree([3, 2, 1])) [3, None, 2, None, 1] >>> tree_to_list(constructMaximumBinaryTree([1])) [1] >>> tree_to_list(constructMaximumBinaryTree([1, 2, 3, 4, 5])) [5, 4, None, 3, None, 2, None, 1] >>> tree_to_list(constructMaximumBinaryTree([5, 4, 3, 2, 1])) [5, None, 4, None, 3, None, 2, None, 1] >>> tree_to_list(constructMaximumBinaryTree([0, 0, 0, 0])) [0, None, 0, None, 0, None, 0]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums): if not nums: return None max_val = max(nums) max_index = nums.index(max_val) root = TreeNode(max_val) left_subarray = nums[:max_index] right_subarray = nums[max_index+1:] root.left = constructMaximumBinaryTree(left_subarray) root.right = constructMaximumBinaryTree(right_subarray) return root def tree_to_list(root): Transform the binary tree into a list using level-order traversal where each node is represented, and nulls are added where there are no nodes. from collections import deque if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing None values while result and result[-1] is None: result.pop() return result # Example usage: nums1 = [3,2,1,6,0,5] root1 = constructMaximumBinaryTree(nums1) print(tree_to_list(root1)) # Output: [6, 3, 5, None, 2, 0, None, None, 1]"},{"question":"def can_form_arithmetic_sequence(n: int, lst: List[int]) -> str: Determine if the list can be rearranged to form an arithmetic sequence. >>> can_form_arithmetic_sequence(5, [3, 6, 9, 12, 15]) == \\"YES\\" >>> can_form_arithmetic_sequence(4, [1, 4, 2, 8]) == \\"NO\\" >>> can_form_arithmetic_sequence(3, [20, 10, 30]) == \\"YES\\"","solution":"def can_form_arithmetic_sequence(n, lst): if n == 2: # Any two numbers can form an arithmetic sequence return \\"YES\\" lst.sort() common_diff = lst[1] - lst[0] for i in range(2, n): if lst[i] - lst[i-1] != common_diff: return \\"NO\\" return \\"YES\\""},{"question":"def min_travel_time(n: int, m: int, roads: List[Tuple[int, int, int]], start: int, end: int, k: int, traffic_updates: List[Tuple[int, int, int]]) -> int: Calculate the minimum travel time from the starting city to the destination city after traffic jam updates. >>> n = 5 >>> m = 6 >>> roads = [(1, 2, 5), (2, 3, 2), (1, 3, 1), (3, 4, 7), (4, 5, 3), (3, 5, 2)] >>> start = 1 >>> end = 5 >>> k = 2 >>> traffic_updates = [(2, 3, 3), (3, 5, 10)] >>> min_travel_time(n, m, roads, start, end, k, traffic_updates) 11 >>> n = 5 >>> m = 6 >>> roads = [(1, 2, 5), (2, 3, 2), (1, 3, 1), (3, 4, 7), (4, 5, 3), (3, 5, 2)] >>> start = 1 >>> end = 5 >>> k = 0 >>> traffic_updates = [] >>> min_travel_time(n, m, roads, start, end, k, traffic_updates) 3 >>> n = 2 >>> m = 1 >>> roads = [(1, 2, 5)] >>> start = 1 >>> end = 2 >>> k = 1 >>> traffic_updates = [(1, 2, 100)] >>> min_travel_time(n, m, roads, start, end, k, traffic_updates) 105","solution":"import heapq from collections import defaultdict def min_travel_time(n, m, roads, start, end, k, traffic_updates): graph = defaultdict(list) for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) for x, y, delta in traffic_updates: for i, (v, t) in enumerate(graph[x]): if v == y: graph[x][i] = (v, t + delta) for i, (u, t) in enumerate(graph[y]): if u == x: graph[y][i] = (u, t + delta) def dijkstra(source, target): heap = [(0, source)] min_time = {i: float('inf') for i in range(1, n+1)} min_time[source] = 0 while heap: current_time, u = heapq.heappop(heap) if u == target: return current_time for v, t in graph[u]: time = current_time + t if time < min_time[v]: min_time[v] = time heapq.heappush(heap, (time, v)) return -1 return dijkstra(start, end)"},{"question":"def numPairs(nums, target): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] is equal to the target. >>> numPairs([1, 2, 3, 4, 5], 6) 2 >>> numPairs([1, 1, 1, 1], 2) 1 >>> numPairs([1, 2, 3], 10) 0 >>> numPairs([2, 2, 2, 2], 4) 1 >>> numPairs([1] * 100000, 2) 1 >>> numPairs([2, 4, 6, 8, 10], 10) 2","solution":"def numPairs(nums, target): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] is equal to the target. pairs = set() seen = set() for num in nums: diff = target - num if diff in seen: pairs.add((min(num, diff), max(num, diff))) seen.add(num) return len(pairs)"},{"question":"from typing import List def containsNearbyAlmostDuplicate(nums: List[int], k: int, t: int) -> bool: Determine if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is less than or equal to t, and the absolute difference between i and j is less than or equal to k. >>> containsNearbyAlmostDuplicate([1, 2, 3, 1], 3, 0) True >>> containsNearbyAlmostDuplicate([1, 0, 1, 1], 1, 2) True >>> containsNearbyAlmostDuplicate([1, 5, 9, 1, 5, 9], 2, 3) False","solution":"from typing import List def containsNearbyAlmostDuplicate(nums: List[int], k: int, t: int) -> bool: if t < 0 or k < 0 or len(nums) < 2: return False buckets = {} bucket_size = t + 1 # To handle the case when t == 0 for i, num in enumerate(nums): bucket_id = num // bucket_size if bucket_id in buckets: return True if (bucket_id - 1 in buckets and abs(num - buckets[bucket_id - 1]) < bucket_size): return True if (bucket_id + 1 in buckets and abs(num - buckets[bucket_id + 1]) < bucket_size): return True buckets[bucket_id] = num if i >= k: del buckets[nums[i - k] // bucket_size] return False"},{"question":"def min_circular_shifts(S, T): Determines the minimum number of circular shift operations needed to transform string S into string T. >>> min_circular_shifts(\\"abcde\\", \\"deabc\\") 2 >>> min_circular_shifts(\\"hello\\", \\"ohell\\") 1 >>> min_circular_shifts(\\"a\\", \\"a\\") 0 >>> min_circular_shifts(\\"abcd\\", \\"bcda\\") 1 # Implementation here def process_test_cases(test_cases): Processes multiple test cases and returns results. >>> process_test_cases([(\\"abcde\\", \\"deabc\\"), (\\"hello\\", \\"ohell\\"), (\\"a\\", \\"a\\"), (\\"abcd\\", \\"bcda\\")]) [2, 1, 0, 1] # Implementation here","solution":"def min_circular_shifts(S, T): Determines the minimum number of circular shift operations needed to transform string S into string T. if S == T: return 0 n = len(S) # Create the concatenation of S with itself to cover all possible rotations double_S = S + S # Check for T in the doubled string S to find the minimum shift for i in range(1, n): if double_S[i:i+n] == T: return min(i, n - i) return -1 # If it is not possible to transform S into T (ideally should not happen with given constraints) def process_test_cases(test_cases): Processes multiple test cases and returns results. results = [] for S, T in test_cases: results.append(min_circular_shifts(S, T)) return results"},{"question":"def array_action(N, t, A): Based on the value of t, perform actions on the array A: 1. Print the array A in reverse order, elements separated by spaces. 2. Print the sum of the first half of A (if N is odd, include the middle element). 3. Print \\"Palindrome\\" if the sequence of numbers in A reads the same forward and backward, otherwise print \\"Not Palindrome\\". 4. Print the maximum difference between any two elements in A. 5. Print the product of all odd-indexed elements in A. 6. Replace each element in A with the greatest common divisor (GCD) of the element and the sum of its digits and print A. 7. Start from index i = 0; jump forward by i + 1 positions, based on specified conditions, print \\"Out\\", \\"Done\\", or \\"Cyclic\\". Example: >>> array_action(7, 1, [1, 2, 3, 4, 5, 6, 7]) 7 6 5 4 3 2 1 >>> array_action(7, 2, [1, 2, 3, 4, 5, 6, 7]) 16 >>> array_action(7, 3, [1, 2, 3, 4, 3, 2, 1]) Palindrome >>> array_action(7, 3, [1, 2, 3, 4, 5, 6, 7]) Not Palindrome >>> array_action(7, 4, [1, 5, 3, 9, 4, 8, 2]) 8 >>> array_action(7, 5, [1, 2, 3, 4, 5, 6, 7]) 210 >>> array_action(5, 6, [15, 44, 23, 85, 19]) 3 4 8 5 1 >>> array_action(7, 7, [6, 3, 1, 5, 7, 9, 2]) Out","solution":"import math from math import gcd def array_action(N, t, A): if t == 1: print(\\" \\".join(map(str, A[::-1]))) elif t == 2: half_point = (N + 1) // 2 print(sum(A[:half_point])) elif t == 3: if A == A[::-1]: print(\\"Palindrome\\") else: print(\\"Not Palindrome\\") elif t == 4: max_diff = max(A) - min(A) print(max_diff) elif t == 5: product = 1 for i in range(1, N, 2): product *= A[i] print(product) elif t == 6: def sum_of_digits(n): return sum(map(int, str(n))) new_A = [gcd(a, sum_of_digits(a)) for a in A] print(\\" \\".join(map(str, new_A))) elif t == 7: visited = set() i = 0 while True: if i >= N: print(\\"Out\\") break if i == N - 1: print(\\"Done\\") break if i in visited: print(\\"Cyclic\\") break visited.add(i) i += i + 1"},{"question":"from typing import List def move_zeroes(nums: List[int]) -> None: Move all zeros in the list to the end in-place while maintaining the order of non-zero elements. Example: >>> nums = [0, 1, 0, 3, 12] >>> move_zeroes(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [4, 2, 4, 0, 0, 3, 0, 5, 1, 0] >>> move_zeroes(nums) >>> nums [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]","solution":"from typing import List def move_zeroes(nums: List[int]) -> None: Move all zeros in the list to the end in-place while maintaining the order of non-zero elements. last_non_zero_found_at = 0 # Move all non-zero numbers forward for num in nums: if num != 0: nums[last_non_zero_found_at] = num last_non_zero_found_at += 1 # Fill remaining positions with zeros for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0"},{"question":"def next_alphabet(S: str) -> str: Replaces each character in the string with the character that comes after it in the alphabet. Uppercase remains uppercase and lowercase remains lowercase. If the character is 'z' or 'Z', it wraps around to 'a' or 'A' respectively. >>> next_alphabet(\\"abc\\") 'bcd' >>> next_alphabet(\\"AbYz\\") 'BcZa'","solution":"def next_alphabet(S): Replaces each character in the string with the character that comes after it in the alphabet. Uppercase remains uppercase and lowercase remains lowercase. If the character is 'z' or 'Z', it wraps around to 'a' or 'A' respectively. result = [] for char in S: if 'a' <= char <= 'z': if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) elif 'A' <= char <= 'Z': if char == 'Z': result.append('A') else: result.append(chr(ord(char) + 1)) else: result.append(char) # In case there are other characters, they remain the same return ''.join(result)"},{"question":"from typing import List, Tuple def process_test_cases(T: int, test_cases: List[Tuple[int, List[int], List[Tuple[int, int]]]]) -> List[List[int]]: For each node in the tree, find the difference between the maximum value and the minimum value among all the nodes present in its subtree, including the node itself. >>> T = 1 >>> test_cases = [(5, [1, 3, 7, 4, 6], [(1, 2), (1, 3), (3, 4), (3, 5)])] >>> process_test_cases(T, test_cases) == [[6, 0, 3, 0, 0]] True def test_example_case(): T = 1 test_cases = [ (5, [1, 3, 7, 4, 6], [(1, 2), (1, 3), (3, 4), (3, 5)]) ] expected = [ [6, 0, 3, 0, 0] ] assert process_test_cases(T, test_cases) == expected def test_single_node(): T = 1 test_cases = [ (1, [10], []) ] expected = [ [0] ] assert process_test_cases(T, test_cases) == expected def test_strictly_increasing_values(): T = 1 test_cases = [ (3, [1, 2, 3], [(1, 2), (1, 3)]) ] expected = [ [2, 0, 0] ] assert process_test_cases(T, test_cases) == expected def test_large_tree_with_same_values(): T = 1 test_cases = [ (7, [5, 5, 5, 5, 5, 5, 5], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) ] expected = [ [0, 0, 0, 0, 0, 0, 0] ] assert process_test_cases(T, test_cases) == expected","solution":"from collections import defaultdict class TreeNode: def __init__(self, value): self.value = value self.children = [] self.min_value = value self.max_value = value def build_tree(N, values, edges): tree = [TreeNode(values[i]) for i in range(N)] for u, v in edges: tree[u-1].children.append(tree[v-1]) tree[v-1].children.append(tree[u-1]) return tree def dfs(node, parent=None): min_val = node.value max_val = node.value for child in node.children: if child == parent: continue sub_min, sub_max = dfs(child, node) min_val = min(min_val, sub_min) max_val = max(max_val, sub_max) node.min_value = min_val node.max_value = max_val return min_val, max_val def solve(N, values, edges): tree = build_tree(N, values, edges) dfs(tree[0]) results = [0] * N for i in range(N): results[i] = tree[i].max_value - tree[i].min_value return results def process_test_cases(T, test_cases): results = [] for case in test_cases: N, values, edges = case results.append(solve(N, values, edges)) return results"},{"question":"def find_anagrams(word_list: List[str], target_word: str) -> List[str]: Finds all anagrams of the target word from the list of words. Args: word_list (list): List of words. target_word (str): The word to find anagrams for. Returns: list: List of anagrams of the target word. Examples: >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"facebook\\"], \\"silent\\") [\\"listen\\", \\"silent\\", \\"enlist\\"] >>> find_anagrams([\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\"], \\"orange\\") []","solution":"def find_anagrams(word_list, target_word): Finds all anagrams of the target word from the list of words. Args: word_list (list): List of words. target_word (str): The word to find anagrams for. Returns: list: List of anagrams of the target word. from collections import Counter target_counter = Counter(target_word) anagrams = [word for word in word_list if Counter(word) == target_counter] return anagrams"},{"question":"def count_pairs_with_sum(arr, target_sum): Returns the count of distinct pairs (a, b) in the list such that a + b is equal to the target sum. Args: arr (List[int]): List of integers that may contain duplicates and is not sorted. target_sum (int): The target sum of the pairs. Returns: int: The count of distinct pairs with the sum equal to target_sum. Examples: >>> count_pairs_with_sum([1, 5, 7, 1, 5], 6) 1 >>> count_pairs_with_sum([1, 2, 3, 4, 5, 6], 7) 3 >>> count_pairs_with_sum([1, 2, 3, 4, 5], 10) 0 >>> count_pairs_with_sum([1, 1, 1, 1, 1], 2) 1 >>> count_pairs_with_sum([-1, -2, -3, -4, -5], -8) 1 >>> count_pairs_with_sum([1, -1, 2, -2, 3, -3], 0) 3","solution":"def count_pairs_with_sum(arr, target_sum): Returns the count of distinct pairs (a, b) in the list such that a + b is equal to the target sum. seen = set() pairs = set() for number in arr: complement = target_sum - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return len(pairs)"},{"question":"def count_days_above_threshold(T, test_cases): Determines how many days each culture's population exceeded a specified threshold. Args: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): Each test case is represented by a tuple where the first element is a tuple containing (N, K), and the second element is a list of population sizes for N days. Returns: List[int]: A list of integers where each integer is the number of days the population exceeded the threshold for a test case. Example: >>> count_days_above_threshold(2, [((5, 50), [10, 60, 45, 70, 30]), ((4, 25), [20, 30, 25, 40])]) [2, 2] from solution import count_days_above_threshold def test_example_case(): T = 2 test_cases = [ [(5, 50), [10, 60, 45, 70, 30]], [(4, 25), [20, 30, 25, 40]] ] assert count_days_above_threshold(T, test_cases) == [2, 2] def test_all_below_threshold(): T = 1 test_cases = [ [(4, 100), [10, 20, 30, 40]] ] assert count_days_above_threshold(T, test_cases) == [0] def test_all_above_threshold(): T = 1 test_cases = [ [(3, 10), [20, 30, 40]] ] assert count_days_above_threshold(T, test_cases) == [3] def test_mixed_values(): T = 1 test_cases = [ [(5, 25), [5, 10, 30, 25, 26]] ] assert count_days_above_threshold(T, test_cases) == [2] def test_single_day_case(): T = 1 test_cases = [ [(1, 15), [20]] ] assert count_days_above_threshold(T, test_cases) == [1] def test_multiple_equal_threshold(): T = 1 test_cases = [ [(5, 50), [50, 50, 50, 50, 50]] ] assert count_days_above_threshold(T, test_cases) == [0]","solution":"def count_days_above_threshold(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] populations = test_cases[i][1] count = sum(1 for population in populations if population > K) results.append(count) return results"},{"question":"def min_subsequences(N: int, K: int, A: List[int]) -> List[List[int]]: This function returns the minimum number of subsequences required such that the sum of each subsequence is at least K and the subsequences themselves. Parameters: N (int): Number of elements in the sequence. K (int): The minimum sum for each subsequence. A (List[int]): The list of integers. Returns: List[List[int]]: A list of subsequences. >>> min_subsequences(5, 5, [1, 3, 4, 2, 2]) [[1, 3, 4], [2, 2]] >>> min_subsequences(4, 10, [6, 7, 5, 4]) [[6, 7], [5, 4]] pass from solution import min_subsequences def test_case_1(): N = 5 K = 5 A = [1, 3, 4, 2, 2] expected_output = [[1, 3, 4], [2, 2]] assert min_subsequences(N, K, A) == expected_output def test_case_2(): N = 4 K = 10 A = [6, 7, 5, 4] expected_output = [[6, 7], [5, 4]] assert min_subsequences(N, K, A) == expected_output def test_case_3(): N = 3 K = 15 A = [5, 5, 5] expected_output = [[5, 5, 5]] assert min_subsequences(N, K, A) == expected_output def test_case_4(): N = 6 K = 10 A = [3, 8, 2, 6, 1, 7] expected_output = [[3, 8], [2, 6, 1, 7]] assert min_subsequences(N, K, A) == expected_output def test_case_5(): N = 5 K = 1 A = [1, 1, 1, 1, 1] expected_output = [[1], [1], [1], [1], [1]] assert min_subsequences(N, K, A) == expected_output","solution":"def min_subsequences(N, K, A): This function returns the minimum number of subsequences required such that the sum of each subsequence is at least K and the subsequences themselves. result = [] current_subseq = [] current_sum = 0 for num in A: if current_sum + num >= K: current_subseq.append(num) result.append(current_subseq) current_subseq = [] current_sum = 0 else: current_subseq.append(num) current_sum += num if current_subseq: result.append(current_subseq) return result if __name__ == '__main__': import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) A = list(map(int, data[2:])) result = min_subsequences(N, K, A) print(len(result)) for subsequence in result: print(' '.join(map(str, subsequence)))"},{"question":"def transform_simpligrad_text(n: int, text: str) -> str: Transforms the given Simpligrad text following the rules: - Each letter maps to another letter (bijective mapping). - No letter maps to itself. Parameters: n (int): length of the Simpligrad text. text (str): the Simpligrad text. Returns: str: Transformed text where no character maps to itself. >>> transform_simpligrad_text(6, \\"abcdef\\") \\"fbcdea\\" >>> transform_simpligrad_text(3, \\"xyz\\") \\"yzx\\"","solution":"import random def transform_simpligrad_text(n, text): Transforms the given Simpligrad text following the rules: - Each letter maps to another letter (bijective mapping). - No letter maps to itself. Parameters: n (int): length of the Simpligrad text. text (str): the Simpligrad text. Returns: str: Transformed text where no character maps to itself. letters = list(text) if n == 1: return text while True: shuffled = letters[:] random.shuffle(shuffled) if all(letters[i] != shuffled[i] for i in range(n)): return ''.join(shuffled)"},{"question":"def most_frequent_flower(n: int, m: int, garden: List[str]) -> str: Determine the type of flower that appears the most frequently in the garden. If there are multiple flowers with the same highest frequency, return the one that comes first lexicographically. >>> garden = [ ... \\"abbca\\", ... \\"abcdef\\", ... \\"ghiaj\\", ... \\"kllmn\\" ... ] >>> most_frequent_flower(4, 5, garden) 'a' >>> garden = [ ... \\"aab\\", ... \\"bcc\\", ... \\"cdd\\" ... ] >>> most_frequent_flower(3, 3, garden) 'c' >>> garden = [ ... \\"aabbbcc\\" ... ] >>> most_frequent_flower(1, 7, garden) 'b' >>> garden = [ ... \\"a\\", ... \\"b\\", ... \\"a\\", ... \\"b\\", ... \\"c\\" ... ] >>> most_frequent_flower(5, 1, garden) 'a' >>> garden = [ ... \\"abc\\", ... \\"def\\", ... \\"ghi\\" ... ] >>> most_frequent_flower(3, 3, garden) 'a' >>> n, m = 4, 25 >>> garden = [ ... \\"abcdefghijklmnopqrstuvwxyz\\"[i % 26] + \\"abcdefghijklmnopqrstuvwxyz\\"[:24] for i in range(n) ... ] >>> most_frequent_flower(n, m, garden) 'a'","solution":"def most_frequent_flower(n, m, garden): Returns the most frequent flower in the garden. In case of ties, returns the lexicographically smallest one. from collections import Counter # Count frequency of each flower type flower_count = Counter() for row in garden: flower_count.update(row) # Find the most frequent flower, with ties broken lexicographically most_frequent = min(flower_count.items(), key=lambda x: (-x[1], x[0])) return most_frequent[0]"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def areMirror(root1, root2): Check if two binary trees are mirror images of each other. >>> tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) >>> tree2 = TreeNode(1, TreeNode(3), TreeNode(2)) >>> areMirror(tree1, tree2) == True >>> tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) >>> tree2 = TreeNode(1, TreeNode(3, TreeNode(4)), TreeNode(2)) >>> areMirror(tree1, tree2) == False >>> tree1 = TreeNode(1) >>> tree2 = TreeNode(1) >>> areMirror(tree1, tree2) == True >>> tree1 = TreeNode(1) >>> tree2 = None >>> areMirror(tree1, tree2) == False >>> tree1 = None >>> tree2 = None >>> areMirror(tree1, tree2) == True >>> tree1 = TreeNode(1, left=TreeNode(2, left=TreeNode(4), right=TreeNode(5)), right=TreeNode(3, left=TreeNode(6), right=TreeNode(7))) >>> tree2 = TreeNode(1, left=TreeNode(3, left=TreeNode(7), right=TreeNode(6)), right=TreeNode(2, left=TreeNode(5), right=TreeNode(4))) >>> areMirror(tree1, tree2) == True >>> tree1 = TreeNode(1, left=TreeNode(2, left=TreeNode(4), right=TreeNode(5)), right=TreeNode(3, left=TreeNode(6), right=TreeNode(7))) >>> tree2 = TreeNode(1, left=TreeNode(2, left=TreeNode(4), right=TreeNode(5)), right=TreeNode(3, left=TreeNode(7), right=TreeNode(6))) >>> areMirror(tree1, tree2) == False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def areMirror(root1, root2): Check if two binary trees are mirror images of each other. # If both trees are empty, they are mirrors of each other if root1 is None and root2 is None: return True # If only one of the trees is empty, then they are not mirrors if root1 is None or root2 is None: return False # Both nodes should have the same value and the left subtree of root1 # should be a mirror of the right subtree of root2 and vice versa. return (root1.value == root2.value and areMirror(root1.left, root2.right) and areMirror(root1.right, root2.left))"},{"question":"import re from typing import List, Dict def keyword_count(text: str, keywords: List[str]) -> Dict[str, int]: Returns a dictionary with the count of each keyword in the text. The search is case-insensitive and counts only whole words. :param text: str, block of text to search in :param keywords: list, list of keywords to count in text :return: dict, dictionary with each keyword and its count >>> keyword_count(\\"Data science is the future. Many experts believe that data analysis will change the world.\\", [\\"data\\", \\"science\\"]) {\\"data\\": 2, \\"science\\": 1} >>> keyword_count(\\"Machine Learning and Artificial Intelligence are the future of technology. Machine Learning drives innovation.\\", [\\"machine\\", \\"learning\\", \\"innovation\\"]) {\\"machine\\": 2, \\"learning\\": 2, \\"innovation\\": 1} from solution import keyword_count def test_keyword_count_basic(): text = \\"Data science is the future. Many experts believe that data analysis will change the world.\\" keywords = [\\"data\\", \\"science\\"] expected = {\\"data\\": 2, \\"science\\": 1} assert keyword_count(text, keywords) == expected def test_keyword_count_case_insensitive(): text = \\"Data science is the future. Many experts believe that Data Analysis will change the world.\\" keywords = [\\"data\\", \\"science\\"] expected = {\\"data\\": 2, \\"science\\": 1} assert keyword_count(text, keywords) == expected def test_keyword_count_no_keywords(): text = \\"Machine Learning and Artificial Intelligence are the future of technology. Machine Learning drives innovation.\\" keywords = [\\"machine\\", \\"learning\\", \\"innovation\\"] expected = {\\"machine\\": 2, \\"learning\\": 2, \\"innovation\\": 1} assert keyword_count(text, keywords) == expected def test_keyword_count_keywords_not_found(): text = \\"Artificial Intelligence is transforming the world.\\" keywords = [\\"data\\", \\"science\\"] expected = {\\"data\\": 0, \\"science\\": 0} assert keyword_count(text, keywords) == expected def test_keyword_count_partial_matches(): text = \\"Artificial Intelligence is transforming the world of data science.\\" keywords = [\\"data\\", \\"sci\\"] expected = {\\"data\\": 1, \\"sci\\": 0} assert keyword_count(text, keywords) == expected","solution":"import re from collections import Counter def keyword_count(text, keywords): Returns a dictionary with the count of each keyword in the text. The search is case-insensitive and counts only whole words. :param text: str, block of text to search in :param keywords: list, list of keywords to count in text :return: dict, dictionary with each keyword and its count # Convert the text to lower case text = text.lower() # Initialize a dictionary to hold keyword counts keyword_counts = {keyword: 0 for keyword in keywords} # Tokenize the text into words words = re.findall(r'bw+b', text) # Create a Counter object of the words in the text word_counts = Counter(words) # Count each keyword in the text for keyword in keywords: keyword_counts[keyword] = word_counts[keyword] return keyword_counts"},{"question":"def reverse_alpha(s: str) -> str: Reverses the alphabetical characters in a string, leaving special characters in their original positions. Args: s (str): The input string containing alphabetical and special characters. Returns: str: The modified string with the alphabetical characters reversed. >>> reverse_alpha(\\"a,bc\\") 'c,ba' >>> reverse_alpha(\\"Ab,c,de!\\") 'ed,c,bA!' >>> reverse_alpha(\\"a!!!b.c.d,e'f,ghi\\") 'i!!!h.g.f,e'd,cba'","solution":"def reverse_alpha(s): Reverses the alphabetical characters in a string, leaving special characters in their original positions. Args: s (str): The input string containing alphabetical and special characters. Returns: str: The modified string with the alphabetical characters reversed. # Extract the alphabetical characters into a list letters = [c for c in s if c.isalpha()] # Initialize an empty list to build the result result = [] for char in s: if char.isalpha(): # Pop from the letters list to reverse the alphabetical characters result.append(letters.pop()) else: # Append special characters as is result.append(char) return ''.join(result)"},{"question":"def minimalMoves(N: int) -> int: Computes the minimal number of moves required to rearrange N books. >>> minimalMoves(1) 0 >>> minimalMoves(2) 3 >>> minimalMoves(3) 5 >>> minimalMoves(4) 7 >>> minimalMoves(5) 9 >>> minimalMoves(6) 11 >>> minimalMoves(10) 19 >>> minimalMoves(100) 199","solution":"def minimalMoves(N): Computes the minimal number of moves required to rearrange N books. if N <= 1: return 0 else: return N * 2 - 1"},{"question":"def can_segment_string(m: int, words: List[str], s: str) -> bool: Returns true if the string s can be segmented into a sequence of one or more dictionary words from words, otherwise false. >>> can_segment_string(5, ['apple', 'pen', 'applepen', 'pine', 'pineapple'], 'pineapplepenapple') True >>> can_segment_string(3, ['cats', 'dog', 'sand'], 'catdog') False","solution":"def can_segment_string(m, words, s): Returns true if the string s can be segmented into a sequence of one or more dictionary words from words, otherwise false. word_set = set(words) n = len(s) dp = [False] * (n+1) dp[0] = True for i in range(1, n+1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[n] # Function to process inputs and outputs def main(): import sys input = sys.stdin.read data = input().split('n') M = int(data[0].strip()) words = [data[i+1].strip() for i in range(M)] s = data[M+1].strip() result = can_segment_string(M, words, s) print(\\"true\\" if result else \\"false\\")"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Determines whether the given strings are anagrams of each other, ignoring spaces, punctuation, and case. >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") True >>> is_anagram(\\"Hello\\", \\"World\\") False >>> is_anagram(\\"Dormitory\\", \\"Dirty room\\") True # Your implementation here","solution":"def is_anagram(str1, str2): Determines whether the given strings are anagrams of each other, ignoring spaces, punctuation, and case. Args: str1 (str): The first string to compare. str2 (str): The second string to compare. Returns: bool: True if the strings are anagrams, False otherwise. import re # Remove non-alphabet characters and convert to lower case cleaned_str1 = re.sub(r'[^a-z]', '', str1.lower()) cleaned_str2 = re.sub(r'[^a-z]', '', str2.lower()) # Check if sorted cleaned strings are the same return sorted(cleaned_str1) == sorted(cleaned_str2)"},{"question":"def min_diff_partition(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible absolute difference between the sum of skill levels of two teams for each test case. >>> min_diff_partition(3, [(4, [1, 2, 3, 4]), (3, [1, 1, 4]), (5, [6, 3, 2, 8, 7])]) [0, 2, 0] >>> min_diff_partition(2, [(1, [1]), (2, [1, 1000])]) [1, 999]","solution":"def min_diff_partition(t, test_cases): results = [] for i in range(t): n, skills = test_cases[i] total_sum = sum(skills) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for skill in skills: for j in range(target, skill - 1, -1): dp[j] |= dp[j - skill] closest_sum = max(j for j, can_achieve in enumerate(dp) if can_achieve) min_diff = total_sum - 2 * closest_sum results.append(min_diff) return results"},{"question":"def longest_word(words: List[str]) -> str: Write a function longest_word that takes a list of strings as input and returns the longest string in the list. If two or more strings have the same maximum length, the function should return the first one encountered. >>> longest_word([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"banana\\" >>> longest_word([\\"cat\\", \\"dinosaur\\", \\"elephant\\"]) == \\"dinosaur\\" :param words: List of strings :return: Longest string in the list pass # Implement the function here # Unit Tests def test_longest_word_single_element(): assert longest_word([\\"apple\\"]) == \\"apple\\" def test_longest_word_all_same_length(): assert longest_word([\\"cat\\", \\"dog\\", \\"bat\\"]) == \\"cat\\" def test_longest_word_varied_lengths(): assert longest_word([\\"cat\\", \\"elephant\\", \\"dinosaur\\", \\"applepie\\"]) == \\"elephant\\" def test_longest_word_multiple_max_length(): assert longest_word([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"banana\\" def test_longest_word_empty_list(): assert longest_word([]) == \\"\\" def test_longest_word_same_word_repeated(): assert longest_word([\\"repeat\\", \\"repeat\\", \\"repeat\\"]) == \\"repeat\\" def test_longest_word_all_empty_strings(): assert longest_word([\\"\\", \\"\\", \\"\\"]) == \\"\\" def test_longest_word_including_empty_string(): assert longest_word([\\"\\", \\"short\\", \\"longer\\", \\"longest\\"]) == \\"longest\\"","solution":"def longest_word(words): Returns the longest string in the list of words. If two or more strings have the same maximum length, the function returns the first one encountered. :param words: List of strings :return: Longest string in the list if not words: return \\"\\" longest = words[0] for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def shortest_time(T, N, M, edges, S): Computes the shortest time required to send data from source node S to all other nodes in the network. Parameters: - T: An integer representing the time for data to travel each link. - N: An integer representing the number of nodes. - M: An integer representing the number of directional links. - edges: A list of pairs (U, V) representing the directional link from node U to node V. - S: An integer representing the source node. Returns: - A list of integers representing the shortest time required to send data from node S to node i. If a node is unreachable, the value should be -1 for that node. pass # Unit Tests def test_sample_case(): T = 10 N = 5 M = 6 edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 3), (3, 4)] S = 0 assert shortest_time(T, N, M, edges, S) == [0, 10, 10, 20, 20] def test_unreachable_nodes(): T = 5 N = 4 M = 2 edges = [(0, 1), (1, 2)] S = 0 assert shortest_time(T, N, M, edges, S) == [0, 5, 10, -1] def test_all_nodes_reachable(): T = 1 N = 3 M = 3 edges = [(0, 1), (1, 2), (0, 2)] S = 0 assert shortest_time(T, N, M, edges, S) == [0, 1, 1] def test_multiple_paths(): T = 3 N = 4 M = 5 edges = [(0, 1), (1, 2), (0, 2), (2, 3), (1, 3)] S = 0 assert shortest_time(T, N, M, edges, S) == [0, 3, 3, 6] def test_large_network(): T = 50 N = 6 M = 6 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)] S = 0 assert shortest_time(T, N, M, edges, S) == [0, 50, 100, 150, 200, 250]","solution":"from collections import defaultdict, deque def shortest_time(T, N, M, edges, S): Computes the shortest time required to send data from source node S to all other nodes in the network. Parameters: - T: An integer representing the time for data to travel each link. - N: An integer representing the number of nodes. - M: An integer representing the number of directional links. - edges: A list of pairs (U, V) representing the directional link from node U to node V. - S: An integer representing the source node. Returns: - A list of integers representing the shortest time required to send data from node S to node i. If a node is unreachable, the value should be -1 for that node. # Adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Distance array and queue initialization dist = [-1] * N dist[S] = 0 queue = deque([S]) while queue: node = queue.popleft() current_distance = dist[node] for neighbor in graph[node]: if dist[neighbor] == -1 or current_distance + T < dist[neighbor]: dist[neighbor] = current_distance + T queue.append(neighbor) return dist"},{"question":"import math from typing import List def normalize_vector(n: int, vector: List[float]) -> List[float]: Normalize a vector using its L2 norm. Parameters: n : int : the dimension of the vector vector : list of float : the components of the vector Returns: list of float : the normalized vector Examples: >>> normalize_vector(3, [3.0, 4.0, 0.0]) [0.6, 0.8, 0.0] >>> normalize_vector(2, [-3.0, -4.0]) [-0.6, -0.8] >>> normalize_vector(3, [0.0, 0.0, 0.0]) [0.0, 0.0, 0.0]","solution":"import math def normalize_vector(n, vector): Normalize a vector using its L2 norm. Parameters: n : int : the dimension of the vector vector : list of float : the components of the vector Returns: list of float : the normalized vector l2_norm = math.sqrt(sum(x**2 for x in vector)) if l2_norm == 0: return [0.0] * n return [x / l2_norm for x in vector] # Example usage: # n = 3 # vector = [3.0, 4.0, 0.0] # print(normalize_vector(n, vector)) # Output should be [0.6, 0.8, 0.0]"},{"question":"from typing import List def count_unique_strings(s: str) -> int: Returns the number of unique strings that can be generated by reversing any prefix multiple times. >>> count_unique_strings(\\"abc\\") 6 >>> count_unique_strings(\\"aab\\") 3 >>> count_unique_strings(\\"abcd\\") 24 >>> count_unique_strings(\\"a\\") 1 def unique_strings(t: int, test_cases: List[str]) -> List[int]: For each test case, returns the number of unique strings that can be generated by reversing any prefix multiple times. >>> unique_strings(4, [\\"abc\\", \\"aab\\", \\"abcd\\", \\"a\\"]) [6, 3, 24, 1] >>> unique_strings(2, [\\"zz\\", \\"az\\"]) [1, 2] >>> unique_strings(3, [\\"aaa\\", \\"bbb\\", \\"abc\\"]) [1, 1, 6]","solution":"from collections import deque from itertools import permutations def count_unique_strings(s): Returns the number of unique strings that can be generated by reversing any prefix multiple times. # Generate all possible permutations of the string perm_set = set(permutations(s)) return len(perm_set) def unique_strings(t, test_cases): For each test case, returns the number of unique strings that can be generated by reversing any prefix multiple times. result = [] for s in test_cases: result.append(count_unique_strings(s)) return result"},{"question":"def search_word_in_grid(grid, word): Determine if a specific word exists in a grid by moving in any of the 8 possible directions. >>> search_word_in_grid([['a', 'b', 'c', 'f'], ['b', 'd', 'e', 'f'], ['d', 'h', 'a', 'g'], ['e', 'h', 'k', 'f']], 'beak') 'YES' >>> search_word_in_grid([['a', 'b', 'c', 'f'], ['b', 'd', 'e', 'f'], ['d', 'h', 'a', 'g'], ['e', 'h', 'k', 'f']], 'xyz') 'NO' >>> search_word_in_grid([['a', 'a', 'a', 'a'], ['a', 'b', 'b', 'a'], ['a', 'b', 'a', 'a'], ['a', 'a', 'a', 'b']], 'abba') 'YES' >>> search_word_in_grid([['a', 'a', 'a', 'a'], ['b', 'b', 'b', 'a'], ['b', 'c', 'a', 'a'], ['b', 'a', 'a', 'a']], 'bc') 'YES' >>> search_word_in_grid([['x', 'x', 'x', 'x'], ['x', 'y', 'x', 'x'], ['x', 'x', 'z', 'x'], ['x', 'x', 'x', 'x']], 'xyz') 'YES' # Helper function to read input and invoke search_word_in_grid def word_search_in_grid(): import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for _ in range(R): grid.append(list(data[index])) index += 1 word = data[index] print(search_word_in_grid(grid, word))","solution":"def search_word_in_grid(grid, word): R = len(grid) C = len(grid[0]) word_len = len(word) # Directions: right, left, down, up, diagonals directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)] def is_valid(x, y): return 0 <= x < R and 0 <= y < C def search_from(x, y, word_index): if word_index == word_len: return True if not is_valid(x, y) or grid[x][y] != word[word_index]: return False saved_char = grid[x][y] grid[x][y] = '#' for dx, dy in directions: if search_from(x + dx, y + dy, word_index + 1): return True grid[x][y] = saved_char return False for row in range(R): for col in range(C): if grid[row][col] == word[0]: if search_from(row, col, 0): return \\"YES\\" return \\"NO\\" # Helper function to read input and invoke search_word_in_grid def word_search_in_grid(): import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for _ in range(R): grid.append(list(data[index])) index += 1 word = data[index] print(search_word_in_grid(grid, word))"},{"question":"def can_form_palindrome(s: str) -> str: Checks if the input string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") 'YES' >>> can_form_palindrome(\\"ivicc\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO' pass def check_palindrome_possibility(strings: List[str]) -> List[str]: Checks if each string in the list can be rearranged to form a palindrome. >>> check_palindrome_possibility([\\"civic\\", \\"ivicc\\", \\"hello\\"]) ['YES', 'YES', 'NO'] >>> check_palindrome_possibility([\\"a\\", \\"aa\\", \\"aaa\\", \\"aab\\", \\"abcd\\"]) ['YES', 'YES', 'YES', 'YES', 'NO'] pass","solution":"def can_form_palindrome(s): Checks if the input string can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # A string can be rearranged to form a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\" def check_palindrome_possibility(strings): return [can_form_palindrome(s) for s in strings]"},{"question":"def number_of_binary_digits(N: int) -> int: Returns the number of digits in the binary representation of the integer N. >>> number_of_binary_digits(1) 1 >>> number_of_binary_digits(5) 3 >>> number_of_binary_digits(16) 5 >>> number_of_binary_digits(31) 5 >>> number_of_binary_digits(100) 7","solution":"def number_of_binary_digits(N): Returns the number of digits in the binary representation of the integer N. if not (1 <= N <= 100): raise ValueError(\\"N must be between 1 and 100\\") return len(bin(N)[2:])"},{"question":"def longest_arithmetic_subarray(arr): Returns the length of the longest arithmetic subarray in the given list of integers. >>> longest_arithmetic_subarray([10, 7, 4, 6, 8, 10, 11]) 4 >>> longest_arithmetic_subarray([9, 4, 7, 2]) 2 >>> longest_arithmetic_subarray([5]) 0 >>> longest_arithmetic_subarray([1, 2]) 2 >>> longest_arithmetic_subarray([1, 2, 4, 7, 11]) 2 >>> longest_arithmetic_subarray([-4, -1, 2, 5, 8]) 5 >>> longest_arithmetic_subarray([5, 10, 15, 20, 25, 30]) 6","solution":"def longest_arithmetic_subarray(arr): Returns the length of the longest arithmetic subarray in the given list of integers. n = len(arr) if n < 2: return 0 max_length = 2 current_length = 2 current_difference = arr[1] - arr[0] for i in range(2, n): if arr[i] - arr[i-1] == current_difference: current_length += 1 else: current_difference = arr[i] - arr[i-1] current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"def min_video_clips(n, k, s, vi): Determine the minimum possible total number of video clips generated by the selected k cameras. Parameters: n (int): the number of cameras in the forest. k (int): the number of cameras to be selected. s (int): the maximum number of swaps allowed. vi (list): the list of video clips generated by each camera. Returns: int: the minimum possible total number of video clips generated by the selected k cameras. pass def test_example_1(): assert min_video_clips(4, 2, 1, [5, 3, 8, 2]) == 5 def test_example_2(): assert min_video_clips(6, 3, 2, [10, 4, 2, 11, 5, 7]) == 11 def test_example_3(): assert min_video_clips(5, 3, 4, [7, 5, 1, 3, 6]) == 9 def test_single_camera(): assert min_video_clips(1, 1, 1, [100]) == 100 def test_no_swaps_needed(): assert min_video_clips(3, 2, 1, [1, 2, 3]) == 3 def test_all_same_clips(): assert min_video_clips(4, 2, 2, [5, 5, 5, 5]) == 10","solution":"def min_video_clips(n, k, s, vi): Determine the minimum possible total number of video clips generated by the selected k cameras. Parameters: n (int): the number of cameras in the forest. k (int): the number of cameras to be selected. s (int): the maximum number of swaps allowed. vi (list): the list of video clips generated by each camera. Returns: int: the minimum possible total number of video clips generated by the selected k cameras. vi_sorted = sorted(vi) return sum(vi_sorted[:k])"},{"question":"def is_prime(num: int) -> bool: Determines if a number is a prime number. # Your code here def smallest_prime_with_prime_sum(n: int) -> int: Returns the smallest prime number p such that p and p + n are both prime numbers. >>> smallest_prime_with_prime_sum(10) 3 >>> smallest_prime_with_prime_sum(4) 3 >>> smallest_prime_with_prime_sum(1) 2 # Your code here","solution":"def is_prime(num): Determines if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def smallest_prime_with_prime_sum(n): Returns the smallest prime number p such that p and p + n are both prime numbers. p = 2 while True: if is_prime(p) and is_prime(p + n): return p p += 1"},{"question":"def generate_circle_of_friends(): Return all permutations of the friends' names in a circular arrangement. >>> expected_outputs = [ ... \\"Alice, Bob, Charlie\\", ... \\"Alice, Charlie, Bob\\", ... \\"Bob, Alice, Charlie\\", ... \\"Bob, Charlie, Alice\\", ... \\"Charlie, Alice, Bob\\", ... \\"Charlie, Bob, Alice\\" ... ]","solution":"import itertools def generate_circle_of_friends(): Return all permutations of the friends' names in a circular arrangement. friends = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] permutations = [\\"{}, {}, {}\\".format(a, b, c) for a, b, c in itertools.permutations(friends, 3)] return permutations"},{"question":"def trap_rain_water(heights): Calculate the total amount of rainwater trapped. :param heights: List of non-negative integers representing building heights. :return: Integer, total amount of trapped rainwater. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([]) 0 >>> trap_rain_water([4]) 0 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_rain_water([5, 4, 3, 2, 1, 0]) 0 >>> trap_rain_water([0, 1, 2, 3, 4, 5]) 0 >>> trap_rain_water([2, 0, 2]) 2","solution":"def trap_rain_water(heights): Calculate the total amount of rainwater trapped. :param heights: List of non-negative integers representing building heights. :return: Integer, total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def first_repeating_integer(test_cases): You are given a list of integers, and you need to find the first Integer which is repeated in the list. If there is no repeating integer, return \`-1\`. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing an integer N (the number of integers in the list) and a list of integers. Returns: List[int]: A list of integers where each integer is the first repeating integer in the corresponding test case, or -1 if there is no repeating integer. Example: >>> first_repeating_integer([(5, [1, 2, 3, 2, 5]), (4, [1, 2, 3, 4]), (6, [6, 1, 3, 5, 3, 6])]) [2, -1, 3] def test_first_repeating_integer(): # Test case 1 test_cases = [(5, [1, 2, 3, 2, 5])] assert first_repeating_integer(test_cases) == [2] # Test case 2 test_cases = [(4, [1, 2, 3, 4])] assert first_repeating_integer(test_cases) == [-1] # Test case 3 test_cases = [(6, [6, 1, 3, 5, 3, 6])] assert first_repeating_integer(test_cases) == [3] # Test case 4: No elements test_cases = [(0, [])] assert first_repeating_integer(test_cases) == [-1] # Test case 5: All elements the same test_cases = [(5, [4, 4, 4, 4, 4])] assert first_repeating_integer(test_cases) == [4] # Test case 6: Single element test_cases = [(1, [4])] assert first_repeating_integer(test_cases) == [-1]","solution":"def first_repeating_integer(test_cases): results = [] for N, integers in test_cases: seen = set() first_repeat = -1 for num in integers: if num in seen: first_repeat = num break seen.add(num) results.append(first_repeat) return results"},{"question":"def highlight_text(T, input_lines): Process the list of queries to highlight text according to starting and ending indices. Args: T (int): The number of test cases. input_lines (List[str]): The input lines containing document texts and queries. Returns: List[List[str]]: The highlighted sections for each query in each test case or \\"INVALID QUERY\\" for invalid ones. >>> T = 2 >>> input_lines = [ ... \\"hello world\\", ... \\"3\\", ... \\"0 4\\", ... \\"6 10\\", ... \\"5 15\\", ... \\"coding is fun\\", ... \\"2\\", ... \\"0 5\\", ... \\"4 3\\" ... ] >>> highlight_text(T, input_lines) [ [\\"hello\\", \\"world\\", \\"INVALID QUERY\\"], [\\"coding\\", \\"INVALID QUERY\\"] ] >>> T = 1 >>> input_lines = [ ... \\"abcde\\", ... \\"4\\", ... \\"0 0\\", ... \\"1 3\\", ... \\"2 4\\", ... \\"4 4\\" ... ] >>> highlight_text(T, input_lines) [ [\\"a\\", \\"bcd\\", \\"cde\\", \\"e\\"] ] >>> T = 1 >>> input_lines = [ ... \\"xyz\\", ... \\"3\\", ... \\"0 2\\", ... \\"1 1\\", ... \\"2 3\\" ... ] >>> highlight_text(T, input_lines) [ [\\"xyz\\", \\"y\\", \\"INVALID QUERY\\"] ] >>> T = 1 >>> input_lines = [ ... \\"short\\", ... \\"1\\", ... \\"3 2\\" ... ] >>> highlight_text(T, input_lines) [ [\\"INVALID QUERY\\"] ]","solution":"def process_queries(T, test_cases): results = [] for case in test_cases: D, queries = case case_result = [] for start, end in queries: if start < 0 or end >= len(D) or start > end: case_result.append(\\"INVALID QUERY\\") else: case_result.append(D[start:end + 1]) results.append(case_result) return results # A function to prepare the input according to the given problem def highlight_text(T, input_lines): test_cases = [] i = 0 for _ in range(T): D = input_lines[i] Q = int(input_lines[i + 1]) queries = [] for j in range(Q): start, end = map(int, input_lines[i + 2 + j].split()) queries.append((start, end)) test_cases.append((D, queries)) i += 2 + Q return process_queries(T, test_cases)"},{"question":"def MaxSteps(grid: List[List[int]]) -> int: Given a 2D grid with dimensions \`m x n\`, where each cell in the grid is either a 0 or a 1. You are initially positioned at the top-left corner in cell (0, 0) and your goal is to reach the bottom-right corner in cell (m-1, n-1). From each cell, you can move to the right, down, left, or up. You cannot move to a cell containing a 0, and you cannot move outside the boundaries of the grid. Write a function that finds the maximum number of steps you can take to reach the bottom-right corner from the top-left corner while ensuring that you do not pass through any cell more than once. If there is no such path, return -1. >>> MaxSteps([[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 1, 1]]) 7 >>> MaxSteps([[1, 0], [0, 1]]) -1 >>> MaxSteps([[1, 0], [1, 1]]) 3 >>> MaxSteps([[1, 1, 1]]) 3 >>> MaxSteps([[1], [1], [1]]) 3 >>> MaxSteps([[1] * 100 for _ in range(100)]) 199 from typing import List def test_max_steps_example(): grid = [[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 1, 1]] assert MaxSteps(grid) == 7 def test_no_path(): grid = [[1, 0], [0, 1]] assert MaxSteps(grid) == -1 def test_direct_path(): grid = [[1, 0], [1, 1]] assert MaxSteps(grid) == 3 def test_single_row(): grid = [[1, 1, 1]] assert MaxSteps(grid) == 3 def test_single_column(): grid = [[1], [1], [1]] assert MaxSteps(grid) == 3 def test_large_grid(): grid = [[1] * 100 for _ in range(100)] assert MaxSteps(grid) == 199","solution":"def MaxSteps(grid): Returns the maximum number of steps to reach the bottom-right corner from the top-left corner in the grid. If there is no such path, returns -1. from collections import deque m = len(grid) n = len(grid[0]) if grid[0][0] == 0 or grid[m-1][n-1] == 0: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # (row, col, steps) visited = set((0, 0)) max_steps = -1 while queue: r, c, steps = queue.popleft() if (r, c) == (m-1, n-1): max_steps = max(max_steps, steps) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 1: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return max_steps if max_steps != -1 else -1 # Example usage grid = [[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 1, 1]] print(MaxSteps(grid)) # Output: 7"},{"question":"def find_triplets(arr): Returns \\"YES\\" if there is a triplet in arr that sums to zero, \\"NO\\" otherwise >>> find_triplets([-1, 2, 9, -6, 7]) 'YES' >>> find_triplets([1, 2, 3, 4]) 'NO' >>> find_triplets([0, -1, 2, -3, 1]) 'YES'","solution":"def find_triplets(arr): Returns \\"YES\\" if there is a triplet in arr that sums to zero, \\"NO\\" otherwise arr.sort() # sort the array n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue # skip duplicate elements left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: return \\"YES\\" elif current_sum < 0: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def can_form_special_formation(N, heights): Determine if it is possible to rearrange the soldiers such that every soldier has exactly one taller soldier standing in front of him. >>> can_form_special_formation(5, [5, 4, 3, 2, 1]) == \\"YES\\" >>> can_form_special_formation(3, [3, 3, 3]) == \\"NO\\" >>> can_form_special_formation(4, [1, 3, 3, 2]) == \\"NO\\"","solution":"def can_form_special_formation(N, heights): Determine if it is possible to rearrange the soldiers such that every soldier has exactly one taller soldier standing in front of him. unique_heights = set(heights) if len(unique_heights) == N: return \\"YES\\" else: return \\"NO\\" # Parsing input for standalone execution if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) heights = list(map(int, data[1:])) print(can_form_special_formation(N, heights))"},{"question":"def arrange_booths(n: int, booth_categories: List[int]) -> List[str]: Determines whether it is possible to rearrange the booths in such a way that no two adjacent booths sell the same category of items. Args: n: The number of booths. booth_categories: List representing the desired category of items for each booth. Returns: A list containing \\"No\\" if the rearrangement is not possible, or \\"Yes\\" followed by a valid arrangement if possible. Examples: >>> arrange_booths(4, [1, 2, 3, 4]) [\\"Yes\\", \\"1 2 3 4\\"] >>> arrange_booths(5, [1, 1, 1, 1, 1]) [\\"No\\"] >>> arrange_booths(3, [3, 1, 3]) [\\"Yes\\", \\"3 1 3\\"] pass","solution":"from collections import Counter import heapq def arrange_booths(n, booth_categories): Determines whether it's possible to rearrange booths so that no two adjacent booths have the same category of items. Returns 'No' if not possible, otherwise returns 'Yes' followed by a representative arrangement. count = Counter(booth_categories) max_count = max(count.values()) if max_count > (n + 1) // 2: return [\\"No\\"] # Max-heap based on counts (inverted for max-heap in Python which has min-heap) max_heap = [(-freq, category) for category, freq in count.items()] heapq.heapify(max_heap) result = [] prev_freq, prev_category = 0, None while max_heap: freq, category = heapq.heappop(max_heap) result.append(category) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_category)) prev_freq = freq + 1 prev_category = category return [\\"Yes\\", \\" \\".join(map(str, result))] # Example test case execution example_input = [4, [1, 2, 3, 4]] print(arrange_booths(*example_input))"},{"question":"from typing import List, Tuple def max_non_overlapping_events(n: int, m: int, events: List[Tuple[int, int, int]]) -> int: Returns the maximum number of non-overlapping events that can be scheduled. # Add your code here # Test cases to validate the solution def test_max_non_overlapping_events(): # Test case 1 n1 = 2 m1 = 3 events1 = [ (1, 1, 5), (1, 2, 6), (2, 1, 3), ] assert max_non_overlapping_events(n1, m1, events1) == 2 # Test case 2 n2 = 2 m2 = 3 events2 = [ (1, 1, 2), (1, 3, 4), (2, 1, 2), ] assert max_non_overlapping_events(n2, m2, events2) == 3 # Test case 3 n3 = 3 m3 = 5 events3 = [ (1, 1, 5), (1, 6, 10), (2, 1, 3), (3, 2, 5), (3, 6, 8), ] assert max_non_overlapping_events(n3, m3, events3) == 5 # Test case 4 n4 = 1 m4 = 4 events4 = [ (1, 1, 3), (1, 2, 4), (1, 3, 5), (1, 4, 6), ] assert max_non_overlapping_events(n4, m4, events4) == 2 # Test case 5 n5 = 2 m5 = 4 events5 = [ (1, 1, 3), (1, 3, 5), (2, 2, 4), (2, 4, 6), ] assert max_non_overlapping_events(n5, m5, events5) == 4 if __name__ == \\"__main__\\": test_max_non_overlapping_events() print(\\"All tests passed.\\")","solution":"def max_non_overlapping_events(n, m, events): Returns the maximum number of non-overlapping events that can be scheduled. from collections import defaultdict # Dictionary to hold events by classroom events_by_classroom = defaultdict(list) # Collect events per classroom for c, s, e in events: events_by_classroom[c].append((s, e)) # Function to find the maximum number of non-overlapping intervals def max_non_overlapping_intervals(intervals): intervals.sort(key=lambda x: x[1]) count, last_end_time = 0, -1 for start, end in intervals: if start >= last_end_time: count += 1 last_end_time = end return count total_non_overlapping_events = 0 # Calculate the maximum number of non-overlapping events for each classroom for event_list in events_by_classroom.values(): total_non_overlapping_events += max_non_overlapping_intervals(event_list) return total_non_overlapping_events"},{"question":"def max_value_path(grid): Calculate the maximum sum of the values collected by the robot as it moves from the top-left to the bottom-right corner of the grid. Args: grid (List[List[int]]): 2D grid representing the values in each cell Returns: int: Maximum sum of the values collected by the robot Examples: >>> grid = [ >>> [1, -3, 4], >>> [2, 0, 6], >>> [-1, 4, 3] >>> ] >>> max_value_path(grid) 12 >>> grid = [[5]] >>> max_value_path(grid) 5 >>> grid = [ >>> [-1, -2, -3], >>> [-4, -5, -6], >>> [-7, -8, -9] >>> ] >>> max_value_path(grid) -21 >>> grid = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> max_value_path(grid) 29 >>> grid = [ >>> [0, 0, 0], >>> [0, 0, 0], >>> [0, 0, 0] >>> ] >>> max_value_path(grid) 0 pass def main(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) grid = [] idx = 2 for _ in range(M): row = [] for _ in range(N): row.append(int(data[idx])) idx += 1 grid.append(row) result = max_value_path(grid) print(result)","solution":"def max_value_path(grid): Calculate the maximum sum of the values collected by the robot as it moves from the top-left to the bottom-right corner of the grid. M = len(grid) N = len(grid[0]) # Initialize a DP table with the same dimensions as the grid dp = [[0] * N for _ in range(M)] # Fill in the DP table dp[0][0] = grid[0][0] # Fill the first row (only one way to get to each cell) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (only one way to get to each cell) for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The value at the bottom-right corner is the result return dp[M-1][N-1] # Function to read input and output the result def main(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) grid = [] idx = 2 for _ in range(M): row = [] for _ in range(N): row.append(int(data[idx])) idx += 1 grid.append(row) result = max_value_path(grid) print(result)"},{"question":"def trap_water(heights: List[int]) -> int: Compute the total units of water that can be trapped between the buildings after the rain. >>> trap_water([0, 1, 0, 2]) 1 >>> trap_water([0, 1, 0, 2, 1, 0]) 1 >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6","solution":"def trap_water(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def isValidNumber(s: str) -> int: Determine whether the input string s is a valid number. A valid number in this context includes: - integers (e.g., \\"123\\") - integers with an optional sign (e.g., \\"-123\\", \\"+123\\") - floating-point numbers (e.g., \\"123.45\\", \\"-123.45\\") This does not consider scientific notation (e.g., \\"123e5\\"). Args: s (str): Input string to be checked. Returns: int: 1 if s is a valid number, 0 otherwise. >>> isValidNumber(\\"123\\") 1 >>> isValidNumber(\\"-123.45\\") 1 >>> isValidNumber(\\"123e5\\") 0 >>> isValidNumber(\\"abc\\") 0 >>> isValidNumber(\\"12.3.4\\") 0","solution":"def isValidNumber(s): Determine whether the input string s is a valid number. A valid number in this context includes: - integers (e.g., \\"123\\") - integers with an optional sign (e.g., \\"-123\\", \\"+123\\") - floating-point numbers (e.g., \\"123.45\\", \\"-123.45\\") This does not consider scientific notation (e.g., \\"123e5\\"). s = s.strip() if not s: return 0 sign = False decimal = False digit = False for i, char in enumerate(s): if char in '+-': if i != 0 or sign or digit: return 0 sign = True elif char == '.': if decimal: return 0 decimal = True elif char.isdigit(): digit = True else: return 0 return 1 if digit else 0"},{"question":"def generate_ip_addresses(s: str) -> List[str]: Generate all possible valid IP address combinations that can be formed by inserting three dots into the string. An IP address consists of four integer numbers between 0 and 255, separated by dots. Do not use leading zeros unless the segment is exactly '0'. >>> generate_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> generate_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> generate_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> generate_ip_addresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] >>> generate_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] # Your code implementation","solution":"from typing import List def is_valid(segment: str) -> bool: Check if the segment is a valid IP address segment. An IP address segment is valid if: - It is not empty. - It does not have leading zeros unless it is \\"0\\". - It is a number between 0 and 255. return len(segment) > 0 and (segment == \\"0\\" or (segment[0] != \\"0\\" and 0 < int(segment) <= 255)) def generate_ip_addresses(s: str) -> List[str]: Generate all possible valid IP address combinations from a string of digits. def backtrack(start: int = 0, dots: int = 3, path: List[str] = []): if dots == 0: segment = s[start:] if is_valid(segment): result.append(\\".\\".join(path + [segment])) return for i in range(start, min(start + 3, len(s) - dots)): segment = s[start:i+1] if is_valid(segment): backtrack(i + 1, dots - 1, path + [segment]) result = [] backtrack() return result"},{"question":"def add_two_binary_trees(t1: List[int], t2: List[int]) -> List[int]: Adds two binary trees represented as level-order arrays. Handles cases where trees have different sizes and node values of -1 (None nodes). Args: t1 (List[int]): Level-order traversal of the first binary tree. t2 (List[int]): Level-order traversal of the second binary tree. Returns: List[int]: Level-order traversal of the resultant binary tree after addition. Examples: >>> add_two_binary_trees([4, -1, 3], [5, 6, -1]) [9, 6, 3] >>> add_two_binary_trees([1, 1], [9, 9]) [10, 10] def process_input_output(input_data: str) -> List[List[int]]: Processes input according to the problem statement. Args: input_data (str): Input data in the specified format. Returns: List[List[int]]: Results of each test case in the specified format. Examples: >>> process_input_output(\\"2n3n4 -1 3n3n5 6 -1n2n1 1n2n9 9n\\") [[9, 6, 3], [10, 10]] >>> process_input_output(\\"1n3n1 -1 2n3n3 4 5n\\") [[4, 4, 7]] >>> process_input_output(\\"1n1n3n3n1 2 3n\\") [[4, 2, 3]]","solution":"def add_two_binary_trees(t1, t2): Adds two binary trees represented as level-order arrays. Handles cases where trees have different sizes and node values of -1 (None nodes). max_len = max(len(t1), len(t2)) t1 += [-1] * (max_len - len(t1)) t2 += [-1] * (max_len - len(t2)) result = [] for i in range(max_len): if t1[i] == -1 and t2[i] == -1: result.append(-1) elif t1[i] == -1: result.append(t2[i]) elif t2[i] == -1: result.append(t1[i]) else: result.append(t1[i] + t2[i]) return result def process_input_output(input_data): Processes input according to the problem statement. results = [] lines = input_data.strip().split('n') T = int(lines[0]) index = 1 for _ in range(T): N = int(lines[index]) t1 = list(map(int, lines[index + 1].split())) M = int(lines[index + 2]) t2 = list(map(int, lines[index + 3].split())) index += 4 result = add_two_binary_trees(t1, t2) results.append(result) return results"},{"question":"def find_highest_expression(expressions: List[str]) -> str: Evaluates mathematical expressions and returns the one that yields the highest result. >>> find_highest_expression(['3+4', '10-5', '6*2']) '6*2' >>> find_highest_expression(['1+1', '2+2', '1+1']) '2+2' >>> find_highest_expression(['-1-1', '-2-2', '-1-1']) '-1-1' >>> find_highest_expression(['0*1', '0+0', '0-0']) '0*1' >>> find_highest_expression(['10/2', '3*3', '2+2']) '3*3' >>> find_highest_expression([]) 'No expressions provided' >>> find_highest_expression(['5+5']) '5+5'","solution":"def evaluate_expression(expression): Evaluates a single mathematical expression in string form. Supports +, -, *, / operators. return eval(expression) def find_highest_expression(expressions): Finds the mathematical expression from the list that yields the highest result. If the highest result is negative or zero, or there are multiple yielding the same highest, return the first one. If the list is empty, return 'No expressions provided'. if not expressions: return 'No expressions provided' highest_result = float('-inf') highest_expression = None for expr in expressions: result = evaluate_expression(expr) if result > highest_result: highest_result = result highest_expression = expr return highest_expression"},{"question":"from typing import List, Union, Tuple def schedule_presentation(M: int, A: int, durations: List[int]) -> Union[str, List[Tuple[int, int]]]: Schedules the presentations for authors without overlapping time slots. Parameters: M (int): The total duration of the exhibition. A (int): The number of authors. durations (list of int): List of presentation durations each author requires. Returns: list or str: \\"No Schedule Possible\\" if scheduling isn't possible, or list of tuples with start and end times for each presentation. >>> schedule_presentation(10, 3, [3, 3, 4]) [(0, 3), (3, 6), (6, 10)] >>> schedule_presentation(5, 2, [3, 3]) 'No Schedule Possible' pass def format_schedule(M: int, A: int, durations: List[int]) -> str: Formats the schedule output as required. Parameters: M (int): The total duration of the exhibition. A (int): The number of authors. durations (list of int): List of presentation durations each author requires. Returns: str: Formatted string of the schedule or \\"No Schedule Possible\\". >>> format_schedule(10, 3, [3, 3, 4]) 'Schedule Possiblen0 3n3 6n6 10' >>> format_schedule(5, 2, [3, 3]) 'No Schedule Possible' pass # Tests def test_sample_input_1(): M = 10 A = 3 durations = [3, 3, 4] expected = [(0, 3), (3, 6), (6, 10)] assert schedule_presentation(M, A, durations) == expected def test_sample_input_2(): M = 5 A = 2 durations = [3, 3] expected = \\"No Schedule Possible\\" assert schedule_presentation(M, A, durations) == expected def test_single_author(): M = 5 A = 1 durations = [5] expected = [(0, 5)] assert schedule_presentation(M, A, durations) == expected def test_exact_fit(): M = 9 A = 3 durations = [3, 3, 3] expected = [(0, 3), (3, 6), (6, 9)] assert schedule_presentation(M, A, durations) == expected def test_overflow(): M = 6 A = 2 durations = [4, 3] expected = \\"No Schedule Possible\\" assert schedule_presentation(M, A, durations) == expected def test_format_output(): M = 10 A = 3 durations = [3, 3, 4] expected_output = \\"Schedule Possiblen0 3n3 6n6 10\\" assert format_schedule(M, A, durations) == expected_output def test_format_output_no_schedule(): M = 5 A = 2 durations = [3, 3] expected_output = \\"No Schedule Possible\\" assert format_schedule(M, A, durations) == expected_output","solution":"def schedule_presentation(M, A, durations): Schedules the presentations for authors without overlapping time slots. Parameters: M (int): The total duration of the exhibition. A (int): The number of authors. durations (list of int): List of presentation durations each author requires. Returns: list or str: \\"No Schedule Possible\\" if scheduling isn't possible, or list of tuples with start and end times for each presentation. if sum(durations) > M: return \\"No Schedule Possible\\" schedule = [] current_time = 0 for duration in durations: if current_time + duration <= M: schedule.append((current_time, current_time + duration)) current_time += duration else: return \\"No Schedule Possible\\" return schedule # Function to print the output in the required format def format_schedule(M, A, durations): result = schedule_presentation(M, A, durations) if result == \\"No Schedule Possible\\": return result else: output = [\\"Schedule Possible\\"] output.extend([f\\"{start} {end}\\" for start, end in result]) return \\"n\\".join(output)"},{"question":"def min_deletions_to_no_consecutive_duplicates(T: int, test_cases: List[str]) -> List[int]: Remove the minimum number of characters from each binary string so that no two consecutive characters are the same. Args: T (int): Number of test cases. test_cases (List[str]): A list of binary strings for each test case. Returns: List[int]: The minimum number of deletions required for each binary string. Example: >>> min_deletions_to_no_consecutive_duplicates(3, [\\"010101\\", \\"0001\\", \\"1110\\"]) [0, 2, 2]","solution":"def min_deletions_to_no_consecutive_duplicates(T, test_cases): results = [] for S in test_cases: deletions = 0 for i in range(1, len(S)): if S[i] == S[i-1]: deletions += 1 results.append(deletions) return results # Example usage: # T = 3 # test_cases = [\\"010101\\", \\"0001\\", \\"1110\\"] # print(min_deletions_to_no_consecutive_duplicates(T, test_cases)) # Output: [0, 2, 2]"},{"question":"def can_buy_exact_bread_pieces(n: int, bread_packs: List[int], m: int) -> str: Determine if it is possible to buy exactly the specified number of bread pieces using any combination of the available bread packs. >>> can_buy_exact_bread_pieces(3, [2, 3, 5], 11) \\"Yes\\" >>> can_buy_exact_bread_pieces(2, [4, 6], 7) \\"No\\"","solution":"def can_buy_exact_bread_pieces(n, bread_packs, m): dp = [False] * (m + 1) dp[0] = True for pack in bread_packs: for i in range(pack, m + 1): if dp[i - pack]: dp[i] = True return \\"Yes\\" if dp[m] else \\"No\\""},{"question":"def longest_increasing_subsequence(input_sequence: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. :param input_sequence: List[int], sequence of integers :return: int, length of the longest strictly increasing subsequence >>> longest_increasing_subsequence([5, 2, 8, 6, 3, 6]) 3 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([10]) 1","solution":"def longest_increasing_subsequence(input_sequence): Returns the length of the longest strictly increasing subsequence. :param input_sequence: List[int], sequence of integers :return: int, length of the longest strictly increasing subsequence if not input_sequence: return 0 n = len(input_sequence) dp = [1] * n for i in range(1, n): for j in range(i): if input_sequence[i] > input_sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def min_energy_beams(grid: List[str]) -> int: Find the minimum number of energy beams required to destroy all starred cells. >>> min_energy_beams([ ... '.....', ... '.*#..', ... '#.*..', ... '..*..' ... ]) == 3 >>> min_energy_beams([ ... '.*.', ... '.#.', ... '*.' ... ]) == 2 >>> min_energy_beams([ ... '...', ... '...', ... '...' ... ]) == 0 >>> min_energy_beams([ ... '.*.', ... '*..', ... '.*.' ... ]) == 3 >>> min_energy_beams([ ... '.*.', ... '#', ... '*..' ... ]) == 2 >>> min_energy_beams([ ... '.*.', ... '#.#', ... '.*.' ... ]) == 2","solution":"def min_energy_beams(grid): n = len(grid) m = len(grid[0]) row_beams = [0] * n col_beams = [0] * m for i in range(n): if '*' in grid[i]: row_beams[i] = 1 for j in range(m): for i in range(n): if grid[i][j] == '*': col_beams[j] = 1 break return max(sum(row_beams), sum(col_beams))"},{"question":"def process_queries(N, Q, B, queries): Process a series of queries on two sequences A and B. Args: N (int): Length of sequences A and B. Q (int): Number of queries. B (list of int): Initial values of sequence B. queries (list of tuples): List of queries to process. Returns: list of int: Results of the queries of the first type. >>> N = 5 >>> Q = 4 >>> B = [3, 6, 2, 7, 5] >>> queries = [ (1, 1, 3), (2, 2, 4), (3, 1, 2, 10), (4, 3, 5, 2) ] >>> process_queries(N, Q, B, queries) [6] def test_process_queries(): N = 5 Q = 4 B = [3, 6, 2, 7, 5] queries = [ (1, 1, 3), (2, 2, 4), (3, 1, 2, 10), (4, 3, 5, 2) ] expected = [6] result = process_queries(N, Q, B, queries) assert result == expected def test_process_queries_with_different_operations(): N = 6 Q = 5 B = [1, 2, 3, 4, 5, 6] queries = [ (1, 1, 2), (2, 1, 3), (1, 1, 3), (4, 1, 3, 2), (1, 1, 3) ] expected = [3, 6, 12] result = process_queries(N, Q, B, queries) assert result == expected def test_full_range_update(): N = 3 Q = 3 B = [10, 20, 30] queries = [ (2, 1, 3), (1, 1, 3), (4, 1, 3, 2) ] expected = [60] result = process_queries(N, Q, B, queries) assert result == expected def test_multiple_sum_queries(): N = 5 Q = 4 B = [3, 6, 2, 7, 5] queries = [ (1, 1, 3), (2, 2, 4), (1, 2, 5), (4, 3, 5, 2) ] expected = [6, 20] result = process_queries(N, Q, B, queries) assert result == expected if __name__ == \\"__main__\\": test_process_queries() test_process_queries_with_different_operations() test_full_range_update() test_multiple_sum_queries()","solution":"def process_queries(N, Q, B, queries): A = list(range(1, N+1)) results = [] for query in queries: query_type = query[0] if query_type == 1: l, r = query[1], query[2] sum_lr = sum(A[l-1:r]) results.append(sum_lr) elif query_type == 2: l, r = query[1], query[2] for i in range(l-1, r): A[i] = B[i] elif query_type == 3: l, r, x = query[1], query[2], query[3] for i in range(l-1, r): B[i] = x elif query_type == 4: l, r, x = query[1], query[2], query[3] for i in range(l-1, r): A[i] *= x return results def parse_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) B = list(map(int, data[2:N+2])) queries = [] index = N+2 for _ in range(Q): if data[index] == \\"1\\": queries.append((1, int(data[index+1]), int(data[index+2]))) index += 3 elif data[index] == \\"2\\": queries.append((2, int(data[index+1]), int(data[index+2]))) index += 3 elif data[index] == \\"3\\": queries.append((3, int(data[index+1]), int(data[index+2]), int(data[index+3]))) index += 4 elif data[index] == \\"4\\": queries.append((4, int(data[index+1]), int(data[index+2]), int(data[index+3]))) index += 4 return N, Q, B, queries if __name__ == \\"__main__\\": N, Q, B, queries = parse_input() results = process_queries(N, Q, B, queries) for result in results: print(result)"},{"question":"def is_prime(num): Determines if a number is prime. # Implement this function to check if a number is prime. def sum_of_primes(n, elements): Returns the sum of prime numbers in a list of n elements. # Implement this function to return the sum of prime numbers in the list. def process_input(data): Process input data and prints sum of primes for each dataset. # Implement this function to process the input data and return the sum of primes for each dataset. # Unit tests def test_is_prime(): # Test prime numbers assert is_prime(2) == True assert is_prime(3) == True assert is_prime(5) == True assert is_prime(13) == True # Test non-prime numbers assert is_prime(1) == False assert is_prime(4) == False assert is_prime(10) == False assert is_prime(-1) == False def test_sum_of_primes(): assert sum_of_primes(5, [2, 3, 4, 5, 6]) == 10 assert sum_of_primes(3, [-5, 0, 1]) == 0 assert sum_of_primes(4, [8, 10, 12, 14]) == 0 assert sum_of_primes(1, [2]) == 2 assert sum_of_primes(2, [1, 13]) == 13 def test_process_input(): data = \\"5n2 3 4 5 6n3n-5 0 1n4n8 10 12 14n0n\\" expected = [10, 0, 0] assert process_input(data) == expected data = \\"2n17 19n1n20n1n5n0n\\" expected = [36, 0, 5] assert process_input(data) == expected data = \\"1n23n1n4n1n2n0n\\" expected = [23, 0, 2] assert process_input(data) == expected data = \\"0n\\" expected = [] assert process_input(data) == expected","solution":"def is_prime(num): Determines if a number is prime. if num <= 1: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def sum_of_primes(n, elements): Returns the sum of prime numbers in a list of n elements. prime_sum = sum(x for x in elements if is_prime(x)) return prime_sum def process_input(data): Process input data and prints sum of primes for each dataset. lines = data.strip().split('n') results = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break elements = list(map(int, lines[i + 1].split())) results.append(sum_of_primes(n, elements)) i += 2 return results"},{"question":"def longest_arithmetic_subsequence(arr: List[int]) -> int: Determine the length of the longest arithmetic subsequence in a list of integers. >>> longest_arithmetic_subsequence([3, 6, 9, 12, 15]) 5 >>> longest_arithmetic_subsequence([3, 6, 9, 12, 15, 10]) 5 >>> longest_arithmetic_subsequence([5]) 1 >>> longest_arithmetic_subsequence([1, 3, 7, 8]) 2 >>> longest_arithmetic_subsequence([-1, -4, -7, -10]) 4","solution":"def longest_arithmetic_subsequence(arr): if not arr: return 0 n = len(arr) if n == 1: return 1 dp = [{} for _ in range(n)] max_length = 1 for i in range(n): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"def check_consistency(m, scrolls): Determine if all the quantities of each potion remain consistent across the ordered scrolls. >>> check_consistency(3, [[2, 3, 5], [2, 5, 7], [3, 5, 8]]) 'CONSISTENT' >>> check_consistency(2, [[4, 6], [5, 6, 9]]) 'INCONSISTENT' def parse_input(input_string): Parse the input string and return the number of scrolls and their potion quantities. >>> parse_input(\\"3n3n2 3 5n3n2 5 7n3n3 5 8n\\") (3, [[2, 3, 5], [2, 5, 7], [3, 5, 8]]) >>> parse_input(\\"2n2n4 6n3n5 6 9n\\") (2, [[4, 6], [5, 6, 9]])","solution":"def check_consistency(m, scrolls): for i in range(1, m): if len(scrolls[i]) != len(scrolls[i-1]): return \\"INCONSISTENT\\" for j in range(len(scrolls[i])): if scrolls[i][j] < scrolls[i-1][j]: return \\"INCONSISTENT\\" return \\"CONSISTENT\\" def parse_input(input_string): lines = input_string.strip().split(\\"n\\") m = int(lines[0]) scrolls = [] idx = 1 for _ in range(m): l_i = int(lines[idx]) quan_list = list(map(int, lines[idx + 1].split())) scrolls.append(quan_list) idx += 2 return m, scrolls"},{"question":"def largest_rectangle_area(heights): This function returns the area of the largest rectangle that can be formed between buildings in the skyline. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 4]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9","solution":"def largest_rectangle_area(heights): This function returns the area of the largest rectangle that can be formed between buildings in skyline. stack = [] max_area = 0 heights.append(0) # Append a zero to make sure we empty the stack at the end for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def max_non_overlapping_task_duration(test_cases): Find the maximum total duration of selected non-overlapping tasks. Args: test_cases (List[List[Tuple[int, int]]]): A list of test cases, where each test case is a list of tasks represented by tuples (startTime, endTime). Returns: List[int]: A list of integers representing the maximum total duration of selected non-overlapping tasks for each test case. >>> max_non_overlapping_task_duration([[(1, 3), (2, 5), (4, 6)], [(1, 2), (2, 3), (3, 4), (4, 5)]]) [4, 4] >>> max_non_overlapping_task_duration([[(1, 4), (2, 5), (3, 6)]]) [3] def process_input(input_str): Process the input string and return the list of test cases. Args: input_str (str): A string representation of the input, containing number of test cases, number of tasks per test case, and the start and end times of each task. Returns: List[List[Tuple[int, int]]]: A structured list where each test case is a list of tasks represented by tuples (startTime, endTime). >>> process_input(\\"2n3n1 3n2 5n4 6n4n1 2n2 3n3 4n4 5\\") [[(1, 3), (2, 5), (4, 6)], [(1, 2), (2, 3), (3, 4), (4, 5)]] >>> process_input(\\"1n3n1 4n2 5n3 6n\\") [[(1, 4), (2, 5), (3, 6)]]","solution":"def max_non_overlapping_task_duration(test_cases): results = [] for tasks in test_cases: # Sort the tasks based on the end time tasks.sort(key=lambda x: x[1]) total_duration = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: total_duration += (end - start) last_end_time = end results.append(total_duration) return results def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 tasks = [] for _ in range(N): start, end = map(int, lines[index].split()) tasks.append((start, end)) index += 1 test_cases.append(tasks) return max_non_overlapping_task_duration(test_cases)"},{"question":"def longest_consecutive_sequence(arr: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the array. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10, 5, 100]) 1 >>> longest_consecutive_sequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_sequence([1, 2, 2, 3, 3, 4]) 4 >>> longest_consecutive_sequence([10**9, 10**9 - 1, 10**9 - 2, 10**9 - 3]) 4 >>> longest_consecutive_sequence([-2, -1, 0, 1, 2]) 5 >>> longest_consecutive_sequence([-3, -2, -1, -1, 0, 1]) 5","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest consecutive elements sequence in the array. if not arr: return 0 # Create a set of the array elements for O(1) look-up times elements = set(arr) longest_length = 0 for num in elements: # Only consider 'num' as the start of a sequence if num-1 is not in the set if num - 1 not in elements: current_length = 1 current_num = num # Count the length of the consecutive sequence while current_num + 1 in elements: current_length += 1 current_num += 1 # Update the longest length found so far longest_length = max(longest_length, current_length) return longest_length"},{"question":"def remove_last_character(strings): Removes the last character from each string in the list. Args: strings (list of str): A list of strings. Returns: list of str: A new list where each string has its last character removed. >>> remove_last_character([\\"HELLO\\", \\"WORLD\\", \\"PYTHON\\"]) == [\\"HELL\\", \\"WORL\\", \\"PYTHO\\"] >>> remove_last_character([\\"A\\", \\"B\\", \\"C\\"]) == [\\"\\", \\"\\", \\"\\"] >>> remove_last_character([\\"ABC\\", \\"DEF\\", \\"GHIJ\\"]) == [\\"AB\\", \\"DE\\", \\"GHI\\"] >>> remove_last_character([\\"ZZZ\\", \\"YYY\\", \\"XXX\\"]) == [\\"ZZ\\", \\"YY\\", \\"XX\\"] >>> remove_last_character([\\"A\\" * 100]) == [\\"A\\" * 99]","solution":"def remove_last_character(strings): Removes the last character from each string in the list. Args: strings (list of str): A list of strings. Returns: list of str: A new list where each string has its last character removed. return [s[:-1] for s in strings]"},{"question":"def calculate_perimeter(queries: List[Tuple[int, int]]) -> List[int]: Function to compute the perimeter of cards given a list of queries. Each query is a tuple (width, height). Returns a list of perimeters for each query. Example: >>> calculate_perimeter([(4, 5)]) == [18] >>> calculate_perimeter([(4, 5), (6, 7), (1, 1)]) == [18, 26, 4] >>> calculate_perimeter([(1000, 1000)]) == [4000] >>> calculate_perimeter([(1, 1)]) == [4] >>> calculate_perimeter([(1, 1), (1000, 1000), (500, 300)]) == [4, 4000, 1600]","solution":"def calculate_perimeter(queries): Function to compute the perimeter of cards given a list of queries. Each query is a tuple (width, height). Returns a list of perimeters for each query. results = [] for width, height in queries: perimeter = 2 * (width + height) results.append(perimeter) return results # Example usage: # number_of_queries = 3 # queries = [(4, 5), (6,7), (1, 1)] # print(calculate_perimeter(queries)) # Output: [18, 26, 4]"},{"question":"def warehouse_operations(test_cases): Process a series of operations to manage inventory levels for different products. >>> warehouse_operations([[\\"Add 1 100\\", \\"Add 2 50\\", \\"Get 1\\", \\"Get 2\\", \\"Get 3\\"], [\\"Add 5 200\\", \\"Get 5\\", \\"Get 1\\"]]) [100, 50, 0, 200, 0] >>> warehouse_operations([[\\"Get 1\\"]]) [0] >>> warehouse_operations([[\\"Add 1 100\\"]]) [] >>> warehouse_operations([]) [] >>> warehouse_operations([[\\"Add 1 100\\", \\"Add 1 200\\", \\"Get 1\\"]]) [300]","solution":"def warehouse_operations(test_cases): results = [] for operations in test_cases: inventory = {} for operation in operations: parts = operation.split() if parts[0] == \\"Add\\": product_id = int(parts[1]) quantity = int(parts[2]) if product_id in inventory: inventory[product_id] += quantity else: inventory[product_id] = quantity elif parts[0] == \\"Get\\": product_id = int(parts[1]) results.append(inventory.get(product_id, 0)) return results"},{"question":"def min_operations_to_equalize_sequence(n, sequence): Returns the minimum number of operations required to make all elements in the sequence equal. Parameters: n (int): The length of the sequence. sequence (List[int]): The sequence of integers. Returns: int: The minimum number of operations required. Examples: >>> min_operations_to_equalize_sequence(5, [2, 2, 1, 3, 3]) 3 >>> min_operations_to_equalize_sequence(1, [1]) 1 >>> min_operations_to_equalize_sequence(3, [4, 4, 4]) 1 >>> min_operations_to_equalize_sequence(6, [1, 2, 3, 4, 5, 6]) 6 >>> min_operations_to_equalize_sequence(7, [3, 3, 3, 3, 3, 3, 3]) 1 >>> min_operations_to_equalize_sequence(2, [1, 2]) 2 >>> min_operations_to_equalize_sequence(10, [2, 5, 1, 5, 6, 6, 7, 8, 5, 3]) 7","solution":"def min_operations_to_equalize_sequence(n, sequence): Returns the minimum number of operations required to make all elements in the sequence equal. if n == 1: return 1 # Only one element, already equal unique_elements = set(sequence) return len(unique_elements)"},{"question":"def canAttendMeetings(meeting_intervals): Determines if a person can attend all given meetings without any overlap. Args: meeting_intervals (list of tuple): A list of tuples where each tuple contains two integers representing the start and end time of a meeting. Returns: bool: True if the person can attend all meetings, False otherwise. >>> canAttendMeetings([]) True >>> canAttendMeetings([(1, 5)]) True >>> canAttendMeetings([(7, 10), (2, 4)]) True >>> canAttendMeetings([(0, 30), (5, 10), (15, 20)]) False >>> canAttendMeetings([(0, 5), (5, 10)]) True >>> canAttendMeetings([(0, 5), (5, 15), (10, 20)]) False >>> intervals = [(i, i + 1) for i in range(0, 10000, 2)] >>> canAttendMeetings(intervals) True >>> intervals = [(i, i + 2) for i in range(0, 10000, 2)] >>> intervals.append((1, 3)) >>> canAttendMeetings(intervals) False","solution":"def canAttendMeetings(meeting_intervals): Determines if a person can attend all given meetings without any overlap. Args: meeting_intervals (list of tuple): A list of tuples where each tuple contains two integers representing the start and end time of a meeting. Returns: bool: True if the person can attend all meetings, False otherwise. # Sort the meetings by start times meeting_intervals.sort() # Iterate through the sorted meetings and check for overlaps for i in range(1, len(meeting_intervals)): # If the current meeting starts before the previous meeting ends, there's an overlap if meeting_intervals[i][0] < meeting_intervals[i - 1][1]: return False return True"},{"question":"def find_longest_word(s: str) -> Tuple[str, int]: Returns the longest word in the input string and its length. If there is a tie, returns the word that occurs first. :param s: String consisting of words separated by spaces. :return: Tuple containing the longest word and its length. >>> find_longest_word(\\"The quick brown fox.\\") (\\"quick\\", 5) >>> find_longest_word(\\"A journey of a thousand miles begins with a single step.\\") (\\"thousand\\", 8) >>> find_longest_word(\\"To be or not to be, that is the question.\\") (\\"question.\\", 9) >>> find_longest_word(\\"\\") (\\"\\", 0) >>> find_longest_word(\\"hello\\") (\\"hello\\", 5) >>> find_longest_word(\\"world!\\") (\\"world!\\", 6) >>> find_longest_word(\\"apple banana cherry\\") (\\"banana\\", 6) >>> find_longest_word(\\"wow!!! so many goods.\\") (\\"wow!!!\\", 6) >>> find_longest_word(\\"red tie bus hat cat\\") (\\"red\\", 3) >>> find_longest_word(\\" \\") (\\"\\", 0) >>> find_longest_word(\\" leading and trailing spaces \\") (\\"trailing\\", 8) # Your code here","solution":"def find_longest_word(s): Returns the longest word in the input string and its length. If there is a tie, returns the word that occurs first. :param s: String consisting of words separated by spaces. :return: Tuple containing the longest word and its length. if not s: return (\\"\\", 0) words = s.split() longest_word = \\"\\" max_length = 0 for word in words: if len(word) > max_length: longest_word = word max_length = len(word) return longest_word, max_length"},{"question":"def can_form_palindrome_by_one_replacement(s: str) -> str: Returns 'Yes' if it's possible to make the string a palindrome with at most one character replacement. Otherwise, returns 'No'. >>> can_form_palindrome_by_one_replacement(\\"abca\\") \\"Yes\\" >>> can_form_palindrome_by_one_replacement(\\"racecar\\") \\"Yes\\" >>> can_form_palindrome_by_one_replacement(\\"abc\\") \\"No\\" >>> can_form_palindrome_by_one_replacement(\\"a\\") \\"Yes\\" def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns a list of 'Yes' or 'No' results for each test case. >>> test_cases = [\\"abca\\", \\"racecar\\", \\"abc\\", \\"a\\"] >>> process_test_cases(test_cases) [\\"Yes\\", \\"Yes\\", \\"No\\", \\"Yes\\"] # Implementation here","solution":"def can_form_palindrome_by_one_replacement(s): Returns 'Yes' if it's possible to make the string a palindrome with at most one character replacement. Otherwise, returns 'No'. def is_palindrome_range(left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: if is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1): return 'Yes' else: return 'No' left += 1 right -= 1 return 'Yes' def process_test_cases(test_cases): results = [] for s in test_cases: results.append(can_form_palindrome_by_one_replacement(s)) return results"},{"question":"def is_perfect_square(n): Determines if the given positive integer n is a perfect square. :param n: A positive integer :return: True if n is a perfect square, else False >>> is_perfect_square(16) True >>> is_perfect_square(14) False >>> is_perfect_square(1) True >>> is_perfect_square(0) True >>> is_perfect_square(25) True >>> is_perfect_square(26) False >>> is_perfect_square(4) True >>> is_perfect_square(15) False >>> is_perfect_square(100) True >>> is_perfect_square(99) False","solution":"def is_perfect_square(n): Determines if the given positive integer n is a perfect square. :param n: A positive integer :return: True if n is a perfect square, else False if n < 0: return False if n == 0 or n == 1: return True left, right = 1, n while left <= right: mid = (left + right) // 2 mid_squared = mid * mid if mid_squared == n: return True elif mid_squared < n: left = mid + 1 else: right = mid - 1 return False"},{"question":"def can_form_palindrome(S: str) -> str: Determines if characters in the string S can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_form_palindrome(S): Determines if characters in the string S can be rearranged to form a palindrome. :param S: Input string consisting of lowercase alphabets :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\" from collections import Counter char_count = Counter(S) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def min_strength(grid): Determine the minimum strength Takahashi needs to reach the bottom-right corner from the top-left corner. >>> min_strength([ ... [1, 1, 1], ... [1, 100, 1], ... [1, 1, 1] ... ]) 5 >>> min_strength([ ... [1] ... ]) 1 >>> min_strength([ ... [1, 1, 1, 1], ... [1, 100, 100, 1], ... [1, 1, 100, 1], ... [1, 1, 1, 1] ... ]) 7 >>> min_strength([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 >>> min_strength([ ... [1, 2, 3], ... [2, 100, 2], ... [3, 2, 1] ... ]) 9","solution":"def min_strength(grid): N = len(grid) dp = [[0] * N for _ in range(N)] dp[0][0] = grid[0][0] for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, N): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][N-1]"},{"question":"from typing import List, Tuple def longest_bitonic_subsequence(arr: List[int]) -> int: Function to find the length of the longest bitonic subsequence. >>> longest_bitonic_subsequence([1, 2, 3, 4, 5, 3]) 6 >>> longest_bitonic_subsequence([12, 4, 78, 90, 45, 23, 45, 90]) 5 >>> longest_bitonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) 6 >>> longest_bitonic_subsequence([12, 11, 40, 5, 3, 1]) 5 >>> longest_bitonic_subsequence([80, 60, 30, 40, 20, 10]) 5 def longest_bitonic_subsequences(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Function to find the lengths of the longest bitonic subsequences for multiple test cases. >>> longest_bitonic_subsequences([(6, [1, 2, 3, 4, 5, 3]), (8, [12, 4, 78, 90, 45, 23, 45, 90])]) [6, 5]","solution":"def longest_bitonic_subsequence(arr): Function to find the length of the longest bitonic subsequence. n = len(arr) # Edge case if n == 0: return 0 # Initialize increasing and decreasing subsequence lengths inc = [1] * n dec = [1] * n # Fill inc[] from left to right for i in range(1, n): for j in range(i): if arr[i] > arr[j]: inc[i] = max(inc[i], inc[j] + 1) # Fill dec[] from right to left for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if arr[i] > arr[j]: dec[i] = max(dec[i], dec[j] + 1) # Find maximum of inc[i] + dec[i] - 1 max_length = 0 for i in range(n): max_length = max(max_length, inc[i] + dec[i] - 1) return max_length def longest_bitonic_subsequences(test_cases): results = [] for N, array in test_cases: results.append(longest_bitonic_subsequence(array)) return results"},{"question":"def max_crops_harvested(grid: List[List[int]]) -> int: Calculates the maximum total amount of crops that can be harvested by the time the bottom-right corner is reached. >>> max_crops_harvested([ ... [1, 2, 3], ... [0, 1, 4] ... ]) 10 >>> max_crops_harvested([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Processes multiple test cases and returns the results as a list. >>> process_test_cases(2, [ ... (2, 3, [ ... [1, 2, 3], ... [0, 1, 4] ... ]), ... (3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) ... ]) [10, 29]","solution":"def max_crops_harvested(grid): n = len(grid) m = len(grid[0]) # Create a DP table to store the maximum crops collected upto that cell dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row (only move right) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (only move down) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the answer return dp[n-1][m-1] def process_test_cases(t, test_cases): results = [] for case in test_cases: n, m, grid = case result = max_crops_harvested(grid) results.append(result) return results"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Determine the minimum number of characters that need to be removed to transform the string \`s\` into a palindrome. >>> min_deletions_to_palindrome(\\"abac\\") 1 >>> min_deletions_to_palindrome(\\"abcde\\") 4 >>> min_deletions_to_palindrome(\\"racecar\\") 0 >>> min_deletions_to_palindrome(\\"a\\") 0 >>> min_deletions_to_palindrome(\\"aa\\") 0","solution":"def min_deletions_to_palindrome(s): def lcs(X, Y, m, n): dp = [[0 for x in range(n + 1)] for y in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] rev_s = s[::-1] longest_palindromic_subseq_length = lcs(s, rev_s, len(s), len(s)) return len(s) - longest_palindromic_subseq_length"},{"question":"def factorial(n: int) -> int: Returns the factorial of n modulo 10^9 + 7. Given an integer n, this function calculates the factorial of n and returns the result modulo 10^9 + 7. Parameters: n (int): The integer to calculate the factorial of. Returns: int: The factorial of n modulo 10^9 + 7. Examples: >>> factorial(5) 120 >>> factorial(3) 6 >>> factorial(13) 227020758","solution":"MOD = 10**9 + 7 def factorial(n): Returns the factorial of n modulo 10^9 + 7. Parameters: n (int): The integer to calculate the factorial of. Returns: int: The factorial of n modulo 10^9 + 7. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result = (result * i) % MOD return result"},{"question":"def check_workshop_capacity(T, test_cases): Determines whether any workshop exceeds its capacity. :param T: int, number of test cases :param test_cases: list of tuples, each containing capacity C and attendees P :return: list of strings, \\"OVERBOOKED\\" or \\"AVAILABLE\\" for each test case >>> check_workshop_capacity(3, [(50, 60), (30, 25), (15, 15)]) [\\"OVERBOOKED\\", \\"AVAILABLE\\", \\"AVAILABLE\\"] >>> check_workshop_capacity(1, [(20, 20)]) [\\"AVAILABLE\\"] >>> check_workshop_capacity(1, [(45, 30)]) [\\"AVAILABLE\\"] >>> check_workshop_capacity(2, [(10, 12), (5, 6)]) [\\"OVERBOOKED\\", \\"OVERBOOKED\\"] >>> check_workshop_capacity(2, [(100, 80), (50, 50)]) [\\"AVAILABLE\\", \\"AVAILABLE\\"]","solution":"def check_workshop_capacity(T, test_cases): Determines whether any workshop exceeds its capacity. :param T: int, number of test cases :param test_cases: list of tuples, each containing capacity C and attendees P :return: list of strings, \\"OVERBOOKED\\" or \\"AVAILABLE\\" for each test case results = [] for i in range(T): C, P = test_cases[i] if P > C: results.append(\\"OVERBOOKED\\") else: results.append(\\"AVAILABLE\\") return results"},{"question":"def is_valid_sudoku(board: List[List[int]]) -> bool: Determines if a given 9x9 Sudoku board is a valid solution. :param board: List[List[int]] - A 9x9 list of lists representing the Sudoku board. :return: bool - True if the board is a valid Sudoku solution, False otherwise. >>> valid_board = [ >>> [5, 3, 4, 6, 7, 8, 9, 1, 2], >>> [6, 7, 2, 1, 9, 5, 3, 4, 8], >>> [1, 9, 8, 3, 4, 2, 5, 6, 7], >>> [8, 5, 9, 7, 6, 1, 4, 2, 3], >>> [4, 2, 6, 8, 5, 3, 7, 9, 1], >>> [7, 1, 3, 9, 2, 4, 8, 5, 6], >>> [9, 6, 1, 5, 3, 7, 2, 8, 4], >>> [2, 8, 7, 4, 1, 9, 6, 3, 5], >>> [3, 4, 5, 2, 8, 6, 1, 7, 9] >>> ] >>> is_valid_sudoku(valid_board) == True >>> invalid_board_row = [ >>> [5, 3, 4, 6, 7, 8, 9, 1, 1], # Duplicate 1 in the last row >>> [6, 7, 2, 1, 9, 5, 3, 4, 8], >>> [1, 9, 8, 3, 4, 2, 5, 6, 7], >>> [8, 5, 9, 7, 6, 1, 4, 2, 3], >>> [4, 2, 6, 8, 5, 3, 7, 9, 1], >>> [7, 1, 3, 9, 2, 4, 8, 5, 6], >>> [9, 6, 1, 5, 3, 7, 2, 8, 4], >>> [2, 8, 7, 4, 1, 9, 6, 3, 5], >>> [3, 4, 5, 2, 8, 6, 1, 7, 9] >>> ] >>> is_valid_sudoku(invalid_board_row) == False >>> invalid_board_column = [ >>> [5, 3, 4, 6, 7, 8, 9, 1, 2], >>> [6, 7, 2, 1, 9, 5, 3, 4, 8], >>> [1, 9, 8, 3, 4, 2, 5, 6, 7], >>> [8, 5, 9, 7, 6, 1, 4, 2, 3], >>> [4, 2, 6, 8, 5, 3, 7, 9, 1], >>> [7, 1, 3, 9, 2, 4, 8, 5, 6], >>> [9, 6, 1, 5, 3, 7, 2, 8, 4], >>> [2, 8, 7, 4, 1, 9, 6, 3, 5], >>> [3, 4, 5, 2, 8, 6, 1, 7, 5] # Duplicate 5 in the last column >>> ] >>> is_valid_sudoku(invalid_board_column) == False >>> invalid_board_subgrid = [ >>> [5, 3, 4, 6, 7, 8, 9, 1, 2], >>> [6, 7, 2, 1, 9, 5, 3, 4, 8], >>> [1, 9, 8, 3, 4, 2, 5, 6, 7], >>> [8, 5, 9, 7, 6, 1, 4, 2, 3], >>> [4, 2, 6, 8, 5, 3, 7, 9, 1], >>> [7, 1, 3, 9, 2, 4, 8, 5, 6], >>> [9, 6, 1, 5, 3, 7, 2, 8, 4], >>> [2, 8, 7, 4, 1, 9, 6, 3, 5], >>> [3, 4, 5, 2, 8, 6, 1, 4, 9] # Duplicate 4 in the bottom-right subgrid >>> ] >>> is_valid_sudoku(invalid_board_subgrid) == False >>> invalid_board_not_1_to_9 = [ >>> [5, 3, 4, 6, 7, 8, 9, 1, 0], # 0 is not a valid number >>> [6, 7, 2, 1, 9, 5, 3, 4, 8], >>> [1, 9, 8, 3, 4, 2, 5, 6, 7], >>> [8, 5, 9, 7, 6, 1, 4, 2, 3], >>> [4, 2, 6, 8, 5, 3, 7, 9, 1], >>> [7, 1, 3, 9, 2, 4, 8, 5, 6], >>> [9, 6, 1, 5, 3, 7, 2, 8, 4], >>> [2, 8, 7, 4, 1, 9, 6, 3, 5], >>> [3, 4, 5, 2, 8, 6, 1, 7, 9] >>> ] >>> is_valid_sudoku(invalid_board_not_1_to_9) == False","solution":"def is_valid_sudoku(board): Determines if a given 9x9 Sudoku board is a valid solution. :param board: List[List[int]] - A 9x9 list of lists representing the Sudoku board. :return: bool - True if the board is a valid Sudoku solution, False otherwise. # Validate rows and columns for i in range(9): row_nums = set() col_nums = set() for j in range(9): if board[i][j] in row_nums or not 1 <= board[i][j] <= 9: return False if board[j][i] in col_nums or not 1 <= board[j][i] <= 9: return False row_nums.add(board[i][j]) col_nums.add(board[j][i]) # Validate 3x3 sub-grids for i in range(0, 9, 3): for j in range(0, 9, 3): sub_grid_nums = set() for k in range(3): for l in range(3): if board[i + k][j + l] in sub_grid_nums: return False sub_grid_nums.add(board[i + k][j + l]) return True"},{"question":"def XO(s: str) -> bool: Check if a string contains equal amounts of 'x' and 'o' (case insensitive). For example: >>> XO(\\"ooxx\\") True >>> XO(\\"xooxx\\") False >>> XO(\\"ooxXm\\") True >>> XO(\\"zpzpzpp\\") True >>> XO(\\"\\") True","solution":"def XO(s): Check if string s contains equal numbers of 'x' and 'o' (case insensitive). s = s.lower() return s.count('x') == s.count('o')"},{"question":"def min_congestion_route(m, n, grid): Function to calculate the minimum total congestion level from top-left to bottom-right in a grid. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (list of list of int): Matrix representing the congestion levels of each block. Returns: int: Minimum total congestion level. >>> min_congestion_route(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_congestion_route(1, 1, [[0]]) 0 >>> min_congestion_route(2, 2, [[1, 2], [3, 4]]) 7 >>> min_congestion_route(1, 4, [[3, 3, 3, 3]]) 12 >>> min_congestion_route(4, 1, [[1], [2], [3], [4]]) 10 >>> min_congestion_route(3, 3, [[1, 1, 1], [1, 0, 1], [1, 1, 1]]) 4 >>> grid = [[1 for _ in range(20)] for _ in range(20)] >>> min_congestion_route(20, 20, grid) 39","solution":"def min_congestion_route(m, n, grid): Function to calculate the minimum total congestion level from top-left to bottom-right in a grid. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (list of list of int): Matrix representing the congestion levels of each block. Returns: int: Minimum total congestion level. # Initialize a 2D dp array with the same dimensions as grid dp = [[0 for _ in range(n)] for _ in range(m)] # Base case: the congestion level of the starting point dp[0][0] = grid[0][0] # Fill in the dp array for i in range(m): for j in range(n): if i == 0 and j > 0: dp[i][j] = dp[i][j-1] + grid[i][j] # Can only come from the left elif j == 0 and i > 0: dp[i][j] = dp[i-1][j] + grid[i][j] # Can only come from above elif i > 0 and j > 0: dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Can come from either left or above # The answer is the value at the bottom-right corner of dp array return dp[m-1][n-1]"},{"question":"class Dragon: def __init__(self, name, fire_power, scale_thickness): Initialize a Dragon with name, fire_power, and scale_thickness self.name = name self.fire_power = fire_power self.scale_thickness = scale_thickness class Unicorn: def __init__(self, name, horn_length, magic_power): Initialize a Unicorn with name, horn_length, and magic_power self.name = name self.horn_length = horn_length self.magic_power = magic_power def create_creature(creature_dict): Create a creature instance from a dictionary. Args: creature_dict (dict): Dictionary containing type and attributes of the creature. Returns: An instance of Dragon or Unicorn based on the type specified in the creature_dict. def get_strongest_creature(creatures): Find the strongest creature based on power (fire_power or magic_power). Args: creatures (list): List of creature instances. Returns: The instance of the creature with the highest power. def group_by_type(creatures): Group creatures by their type. Args: creatures (list): List of creature instances. Returns: dict: A dictionary with keys \\"Dragon\\" and \\"Unicorn\\" and lists of corresponding creature instances as values.","solution":"class Dragon: def __init__(self, name, fire_power, scale_thickness): self.name = name self.fire_power = fire_power self.scale_thickness = scale_thickness class Unicorn: def __init__(self, name, horn_length, magic_power): self.name = name self.horn_length = horn_length self.magic_power = magic_power def create_creature(creature_dict): if creature_dict['type'] == \\"Dragon\\": return Dragon(creature_dict['name'], creature_dict['fire_power'], creature_dict['scale_thickness']) elif creature_dict['type'] == \\"Unicorn\\": return Unicorn(creature_dict['name'], creature_dict['horn_length'], creature_dict['magic_power']) else: raise ValueError(\\"Unknown creature type\\") def get_strongest_creature(creatures): strongest = creatures[0] highest_power = creatures[0].fire_power if isinstance(creatures[0], Dragon) else creatures[0].magic_power for creature in creatures[1:]: power = creature.fire_power if isinstance(creature, Dragon) else creature.magic_power if power > highest_power: strongest = creature highest_power = power return strongest def group_by_type(creatures): grouped = {\\"Dragon\\": [], \\"Unicorn\\": []} for creature in creatures: if isinstance(creature, Dragon): grouped[\\"Dragon\\"].append(creature) elif isinstance(creature, Unicorn): grouped[\\"Unicorn\\"].append(creature) return grouped"},{"question":"def shortest_possible_length(s: str) -> int: Determine the length of the shortest possible string you can obtain after performing the given operations. Args: s (str): A string consisting of lowercase letters. Returns: int: The length of the shortest possible string. >>> shortest_possible_length(\\"abaacb\\") 2 >>> shortest_possible_length(\\"a\\") 1 >>> shortest_possible_length(\\"abcd\\") 2","solution":"def shortest_possible_length(s): Returns the length of the shortest possible string that can be obtained after performing the allowed operations. unique_characters = len(set(s)) # If we have n unique characters, the shortest length we can achieve is 2 if n > 1 # and 1 if n == 1. return 2 if unique_characters > 1 else 1"},{"question":"def sum_of_digits_list(int_list: list) -> list: Returns a list where each integer is replaced by the sum of its digits. Args: int_list (list): A list of integers. Returns: list: A list of integers with each integer replaced by the sum of its digits. Examples: >>> sum_of_digits_list([123, 456, 789]) [6, 15, 24] >>> sum_of_digits_list([1, 22, 333]) [1, 4, 9] >>> sum_of_digits_list([]) []","solution":"def sum_of_digits_list(int_list): Returns a list where each integer is replaced by the sum of its digits. Args: int_list (list): A list of integers. Returns: list: A list of integers with each integer replaced by the sum of its digits. def sum_of_digits(n): return sum(int(digit) for digit in str(n)) return [sum_of_digits(num) for num in int_list]"},{"question":"def count_unique_characters(strings): Takes a list of strings and returns a list of integers representing the number of unique characters in each string. >>> count_unique_characters([\\"hello\\", \\"world\\", \\"Programming\\"]) [4, 5, 8] >>> count_unique_characters([\\"a\\", \\"aa\\", \\"aaa\\"]) [1, 1, 1] >>> count_unique_characters([\\"apple\\", \\"banana\\", \\"test\\"]) [4, 3, 3] >>> count_unique_characters([\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) [4, 4, 4] >>> count_unique_characters([\\"\\", \\"a\\", \\"abcde\\"]) [0, 1, 5] def process_input(input_lines): Processes the input lines and returns the result from count_unique_characters function. >>> process_input([\\"3\\", \\"hello\\", \\"world\\", \\"Programming\\"]) [4, 5, 8] >>> process_input([\\"5\\", \\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\", \\"qrst\\"]) [4, 4, 4, 4, 4] >>> process_input([\\"2\\", \\"12345\\", \\"54321\\"]) [5, 5]","solution":"def count_unique_characters(strings): Takes a list of strings and returns a list of integers representing the number of unique characters in each string. return [len(set(s)) for s in strings] def process_input(input_lines): Processes the input lines and returns the result from count_unique_characters function. T = int(input_lines[0]) strings = input_lines[1:T+1] return count_unique_characters(strings)"},{"question":"def word_ladder(start, end, word_list): Write a function called \`word_ladder\` that takes two parameters: the starting word and the ending word. The function should return the minimum number of steps required to transform the starting word into the ending word, given the following rules: 1. You can only change one letter at a time. 2. Each intermediate word must be a valid English word from a predefined list called \`word_list\`. If the transformation is not possible, return \`-1\`. Parameters: - start (str): The starting word. - end (str): The ending word. - word_list (List[str]): List of valid English words. Returns: - int: Minimum number of steps required to transform the start word into the end word. Example: >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) -1","solution":"from collections import deque def word_ladder(start, end, word_list): Returns the minimum number of steps required to transform the starting word into the ending word. word_set = set(word_list) if end not in word_set: return -1 queue = deque([(start, 1)]) # Queue for BFS, storing (current_word, step_count) while queue: current_word, steps = queue.popleft() if current_word == end: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, steps + 1)) return -1"},{"question":"def determine_ranks(n: int, heights: List[int]) -> List[int]: Determine the rank of each student after they are rearranged in ascending order of height. >>> determine_ranks(5, [170, 150, 160, 160, 180]) [4, 1, 2, 3, 5] >>> determine_ranks(3, [160, 160, 160]) [1, 2, 3] >>> determine_ranks(4, [180, 170, 160, 150]) [4, 3, 2, 1] # Your code here from solution import determine_ranks def test_example_1(): n = 5 heights = [170, 150, 160, 160, 180] expected = [4, 1, 2, 3, 5] assert determine_ranks(n, heights) == expected def test_example_2(): n = 3 heights = [160, 160, 160] expected = [1, 2, 3] assert determine_ranks(n, heights) == expected def test_example_3(): n = 4 heights = [180, 170, 160, 150] expected = [4, 3, 2, 1] assert determine_ranks(n, heights) == expected def test_single_student(): n = 1 heights = [160] expected = [1] assert determine_ranks(n, heights) == expected def test_all_same_height(): n = 5 heights = [160, 160, 160, 160, 160] expected = [1, 2, 3, 4, 5] assert determine_ranks(n, heights) == expected def test_already_sorted(): n = 4 heights = [150, 160, 170, 180] expected = [1, 2, 3, 4] assert determine_ranks(n, heights) == expected","solution":"def determine_ranks(n, heights): # Create an array of (height, index) tuples indexed_heights = list(enumerate(heights)) # Sort by height, preserving initial indices for tie-breaking indexed_heights.sort(key=lambda x: x[1]) # Create a result array ranks = [0] * n # Assign ranks based on sorted order for rank, (index, _) in enumerate(indexed_heights, start=1): ranks[index] = rank return ranks"},{"question":"def unique_combos(n: int, orders: List[int]) -> List[int]: Returns a list of unique combo values formed by summing every three consecutive orders. Parameters: n (int): Number of orders. orders (list): A list of integers representing the order numbers. Returns: list: A sorted list of unique combo values. >>> unique_combos(6, [1, 2, 3, 4, 5, 6]) [6, 9, 12, 15] >>> unique_combos(5, [1, 5, 3, 2, 4]) [9, 10] >>> unique_combos(7, [3, 3, 3, 3, 3, 3, 3]) [9] >>> unique_combos(5, [0, 0, 0, 0, 0]) [0] >>> unique_combos(1, [1]) [] >>> unique_combos(2, [1, 2]) [] >>> unique_combos(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [6, 9, 12, 15, 18, 21, 24, 27]","solution":"def unique_combos(n, orders): Returns a list of unique combo values formed by summing every three consecutive orders. Parameters: n (int): Number of orders. orders (list): A list of integers representing the order numbers. Returns: list: A sorted list of unique combo values. if n < 3: return [] combos = set() for i in range(n - 2): combo_sum = orders[i] + orders[i + 1] + orders[i + 2] combos.add(combo_sum) return sorted(combos)"},{"question":"def countAndSay(n: int) -> str: Generate the nth term of the count-and-say sequence. >>> countAndSay(1) \\"1\\" >>> countAndSay(4) \\"1211\\" >>> countAndSay(6) \\"312211\\"","solution":"def countAndSay(n): Generate the nth term of the count-and-say sequence. if n == 1: return \\"1\\" def next_sequence(sequence): result = [] i = 0 while i < len(sequence): count = 1 while i + 1 < len(sequence) and sequence[i] == sequence[i + 1]: i += 1 count += 1 result.append(str(count) + sequence[i]) i += 1 return ''.join(result) sequence = \\"1\\" for _ in range(1, n): sequence = next_sequence(sequence) return sequence"},{"question":"def word_puzzle_score(grid: List[List[str]], words: List[str]) -> int: Determine the total score for all valid words that can be formed using the rules of the game. >>> grid = [ ... ['A', 'C', 'D', 'E'], ... ['B', 'A', 'C', 'D'], ... ['E', 'F', 'G', 'H'], ... ['I', 'J', 'K', 'L'] ... ] >>> words = [\\"CADE\\", \\"AFE\\", \\"XYZ\\"] >>> word_puzzle_score(grid, words) 5","solution":"def word_puzzle_score(grid, words): def can_form_word(word): from collections import Counter word_counter = Counter(word) grid_counter = Counter() for row in grid: grid_counter.update(row) for letter, count in word_counter.items(): if grid_counter[letter] < count: return False return True def word_score(word): length = len(word) if length == 2: return 1 elif length == 3: return 2 elif length >= 4: return 3 return 0 total_score = 0 for word in words: if can_form_word(word): total_score += word_score(word) return total_score"},{"question":"from typing import List, Dict def maximalSquare(matrix: List[List[int]]) -> int: Given a binary grid of size M x N, consisting of only 0s and 1s, find the largest square containing only 1s and return its area. >>> maximalSquare([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) 4 >>> maximalSquare([[0, 1], [1, 1]]) 1 >>> maximalSquare([]) 0 >>> maximalSquare([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 0 >>> maximalSquare([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 16 >>> maximalSquare([[1]]) 1 >>> maximalSquare([[0]]) 0 pass def find_maximal_squares(testcases: List[Dict]) -> List[int]: Given multiple binary grids, find the largest square for each and return their areas. >>> testcases = [{\\"M\\": 4, \\"N\\": 5, \\"grid\\": [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]}, {\\"M\\": 2, \\"N\\": 2, \\"grid\\": [[0, 1], [1, 1]]}, {\\"M\\": 3, \\"N\\": 4, \\"grid\\": [[1, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 0]]}] >>> find_maximal_squares(testcases) [4, 1, 4] pass","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) dp = [[0] * N for _ in range(M)] max_side = 0 for i in range(M): for j in range(N): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side def find_maximal_squares(testcases): results = [] for case in testcases: M, N, grid = case['M'], case['N'], case['grid'] results.append(maximalSquare(grid)) return results"},{"question":"def sum_of_even_numbers(n): Returns the sum of all even numbers from 1 to n inclusive. If n is less than 1, the function returns 0. >>> sum_of_even_numbers(10) 30 >>> sum_of_even_numbers(5) 6 >>> sum_of_even_numbers(0) 0 >>> sum_of_even_numbers(-4) 0","solution":"def sum_of_even_numbers(n): Returns the sum of all even numbers from 1 to n inclusive. If n is less than 1, the function returns 0. if n < 1: return 0 return sum(i for i in range(2, n + 1, 2))"},{"question":"def sort_photos(n, photo_effects): Sorts the photo effects based on the desired sequence: Sepia, B&W, Color. Args: n (int): The number of photos. photo_effects (list of str): List of strings where each string is one of \\"Sepia\\", \\"B&W\\" or \\"Color\\". Returns: list of str: A list of photo effects sorted based on the desired sequence. >>> sort_photos(5, [\\"Sepia\\", \\"B&W\\", \\"Color\\", \\"Sepia\\", \\"Color\\"]) ['Sepia', 'Sepia', 'B&W', 'Color', 'Color'] >>> sort_photos(3, [\\"B&W\\", \\"Color\\", \\"Sepia\\"]) ['Sepia', 'B&W', 'Color'] >>> sort_photos(4, [\\"Color\\", \\"Color\\", \\"B&W\\", \\"Sepia\\"]) ['Sepia', 'B&W', 'Color', 'Color'] from solution import sort_photos def test_sort_photos_with_all_effects(): assert sort_photos(5, [\\"Sepia\\", \\"B&W\\", \\"Color\\", \\"Sepia\\", \\"Color\\"]) == [\\"Sepia\\", \\"Sepia\\", \\"B&W\\", \\"Color\\", \\"Color\\"] def test_sort_photos_with_single_effect_of_each(): assert sort_photos(3, [\\"B&W\\", \\"Color\\", \\"Sepia\\"]) == [\\"Sepia\\", \\"B&W\\", \\"Color\\"] def test_sort_photos_with_multiple_colors_only(): assert sort_photos(4, [\\"Color\\", \\"Color\\", \\"B&W\\", \\"Sepia\\"]) == [\\"Sepia\\", \\"B&W\\", \\"Color\\", \\"Color\\"] def test_sort_photos_with_one_photo(): assert sort_photos(1, [\\"Color\\"]) == [\\"Color\\"] def test_sort_photos_with_no_bw(): assert sort_photos(3, [\\"Sepia\\", \\"Color\\", \\"Sepia\\"]) == [\\"Sepia\\", \\"Sepia\\", \\"Color\\"] def test_sort_photos_with_only_one_type(): assert sort_photos(4, [\\"B&W\\", \\"B&W\\", \\"B&W\\", \\"B&W\\"]) == [\\"B&W\\", \\"B&W\\", \\"B&W\\", \\"B&W\\"]","solution":"def sort_photos(n, photo_effects): Sorts the photo effects based on the desired sequence: Sepia, B&W, Color. Args: n (int): The number of photos. photo_effects (list of str): List of strings where each string is one of \\"Sepia\\", \\"B&W\\" or \\"Color\\". Returns: list of str: A list of photo effects sorted based on the desired sequence. sepia = [photo for photo in photo_effects if photo == \\"Sepia\\"] bw = [photo for photo in photo_effects if photo == \\"B&W\\"] color = [photo for photo in photo_effects if photo == \\"Color\\"] return sepia + bw + color"},{"question":"from typing import List from functools import reduce from math import gcd def findGCD(arr: List[int]) -> int: Returns the greatest common divisor (GCD) of a list of integers. >>> findGCD([2, 4, 6]) 2 >>> findGCD([7, 14, 21]) 7 >>> findGCD([10, 20, 40]) 10 >>> findGCD([5]) 5 >>> findGCD([12, 15]) 3 >>> findGCD([3, 5, 7]) 1 def test_gcd_single_element_list(): assert findGCD([5]) == 5 def test_gcd_two_elements(): assert findGCD([12, 15]) == 3 def test_gcd_multiple_elements(): assert findGCD([2, 4, 6]) == 2 assert findGCD([7, 14, 21]) == 7 assert findGCD([10, 20, 40]) == 10 def test_gcd_with_prime_numbers(): assert findGCD([3, 5, 7]) == 1 def test_gcd_with_duplicates(): assert findGCD([8, 8, 8, 8]) == 8 def test_gcd_with_no_common_factors(): assert findGCD([13, 17, 19]) == 1 assert findGCD([6, 10, 15]) == 1 def test_gcd_large_numbers(): assert findGCD([100000, 50000, 25000]) == 25000","solution":"from math import gcd from functools import reduce def findGCD(arr): Returns the GCD of a list of integers. return reduce(gcd, arr)"},{"question":"def is_happy_number(n): Check if a given number is a happy number. Parameters: n (int): The number to check. Returns: bool: True if the number is a happy number, False otherwise. >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(1) True >>> is_happy_number(7) True >>> is_happy_number(10) True def happy_number_check(n): Determine if the given number is a happy number and return \\"YES\\" or \\"NO\\". Parameters: n (int): The number to check. Returns: str: \\"YES\\" if the number is a happy number, \\"NO\\" otherwise. >>> happy_number_check(19) \\"YES\\" >>> happy_number_check(2) \\"NO\\" >>> happy_number_check(1) \\"YES\\" >>> happy_number_check(7) \\"YES\\" >>> happy_number_check(10) \\"YES\\"","solution":"def is_happy_number(n): def get_next_number(num): return sum(int(digit) ** 2 for digit in str(num)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next_number(n) return n == 1 def happy_number_check(n): return \\"YES\\" if is_happy_number(n) else \\"NO\\""},{"question":"def split_array_into_power_of_two_sums(N: int, K: int, arr: List[int]) -> str: Determines if it is possible to split the array 'arr' of length 'N' into exactly 'K' contiguous non-empty subarrays such that the sum of elements in each subarray is a power of two. >>> split_array_into_power_of_two_sums(5, 3, [1, 2, 4, 8, 16]) == \\"NO\\" >>> split_array_into_power_of_two_sums(6, 2, [3, 1, 2, 2, 5, 8]) == \\"NO\\" >>> split_array_into_power_of_two_sums(1, 1, [1]) == \\"YES\\" >>> split_array_into_power_of_two_sums(5, 5, [1, 2, 4, 8, 16]) == \\"YES\\" >>> split_array_into_power_of_two_sums(6, 3, [4, 2, 2, 4, 16, 16]) == \\"YES\\" >>> split_array_into_power_of_two_sums(5, 2, [3, 1, 2, 5, 3]) == \\"NO\\" >>> split_array_into_power_of_two_sums(10, 10, [1]*10) == \\"YES\\" >>> split_array_into_power_of_two_sums(1000, 1, [1]*1000) == \\"NO\\"","solution":"def is_power_of_two(n): Helper function to check if a given number n is a power of two. return (n & (n - 1)) == 0 and n != 0 def split_array_into_power_of_two_sums(N, K, arr): Determines if it is possible to split the array 'arr' of length 'N' into exactly 'K' contiguous non-empty subarrays such that the sum of elements in each subarray is a power of two. def dfs(index, subarrays_left): if index == N: return subarrays_left == 0 if subarrays_left == 0: return False current_sum = 0 for i in range(index, N): current_sum += arr[i] if is_power_of_two(current_sum): if dfs(i + 1, subarrays_left - 1): return True return False return \\"YES\\" if dfs(0, K) else \\"NO\\""},{"question":"def maxCoinValue(grid: List[List[int]]) -> int: Given a grid of size m x n where each cell represents a coin with a value (an integer), find the maximum value of coins that can be collected starting from the top-left cell to the bottom-right cell. Movements are only allowed either right or down at each step. >>> maxCoinValue([ ... [0, 3, 1, 1], ... [2, 0, 0, 4], ... [1, 5, 3, 1] ... ]) 12 >>> maxCoinValue([ ... [1, 2, 5], ... [3, 2, 1] ... ]) 9 from typing import List def test_example1(): grid = [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] assert maxCoinValue(grid) == 12 def test_example2(): grid = [ [1, 2, 5], [3, 2, 1] ] assert maxCoinValue(grid) == 9 def test_single_row(): grid = [ [1, 2, 3, 4] ] assert maxCoinValue(grid) == 10 def test_single_column(): grid = [ [1], [2], [3], [4] ] assert maxCoinValue(grid) == 10 def test_minimal_grid(): grid = [[0]] assert maxCoinValue(grid) == 0 def test_zero_in_all_cells(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert maxCoinValue(grid) == 0 def test_negative_values(): grid = [ [1, -2, 5], [-3, 2, 1] ] assert maxCoinValue(grid) == 5 def test_large_grid(): grid = [[i * j % 100 for j in range(100)] for i in range(100)] assert maxCoinValue(grid) > 0 # just check it doesn't break, correct value can be complicated","solution":"def maxCoinValue(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def min_diff(weight_list): This function returns the minimal possible difference in weight between two bags when the weight_list is split optimally. >>> min_diff([5, 3, 8, 6]) 0 >>> min_diff([1, 2, 7]) 4 >>> min_diff([5]) 5 >>> min_diff([10, 10]) 0 >>> min_diff([10, 1, 1, 1, 1]) 6 >>> min_diff([5, 5, 6, 6]) 0 >>> min_diff([3, 1, 4, 2, 2]) 0 >>> min_diff([13, 15, 17, 22, 40]) 1 >>> min_diff([7, 7, 7, 7]) 0","solution":"def min_diff(weight_list): This function returns the minimal possible difference in weight between two bags when the weight_list is split optimally. N = len(weight_list) total_weight = sum(weight_list) target = total_weight // 2 dp = [False] * (target + 1) dp[0] = True for weight in weight_list: for i in range(target, weight - 1, -1): dp[i] = dp[i] or dp[i - weight] for i in range(target, -1, -1): if dp[i]: return total_weight - 2 * i # Sample usage # print(min_diff([5, 3, 8, 6])) # Should output 0 # print(min_diff([1, 2, 7])) # Should output 4"},{"question":"def longestIncreasingSubarray(checkpoints: List[int]) -> int: Calculate the length of the longest subarray of strictly increasing checkpoints. Args: checkpoints (List[int]): The list of integer checkpoints representing the marathon route. Returns: int: The length of the longest strictly increasing subarray. Examples: >>> longestIncreasingSubarray([1, 2, 3, 4, 2, 2, 3, 4, 5, 6]) 5 >>> longestIncreasingSubarray([1, 2, 3, 1, 2, 3, 4, 1]) 4 >>> longestIncreasingSubarray([5, 6, 7, 8, 9, 10]) 6 >>> longestIncreasingSubarray([5, 5, 5, 5, 5]) 1 >>> longestIncreasingSubarray([10, 9, 8, 7, 6, 5]) 1 >>> longestIncreasingSubarray([]) 0 >>> longestIncreasingSubarray([1]) 1 >>> longestIncreasingSubarray([1, 3, 2, 4, 3, 5, 4, 6, 5, 7, 8]) 3 >>> longestIncreasingSubarray([1, 1, 1, 2, 2, 3, 3, 4, 4, 5]) 2","solution":"def longestIncreasingSubarray(checkpoints): if not checkpoints: return 0 max_len = 1 current_len = 1 for i in range(1, len(checkpoints)): if checkpoints[i] > checkpoints[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"import math def will_collide(x1, y1, r1, x2, y2, r2): Determines if two robots will collide based on their coordinates and radii. Args: x1, y1: Coordinates of the center of the first robot. r1: Radius of the first robot. x2, y2: Coordinates of the center of the second robot. r2: Radius of the second robot. Returns: \\"Collision\\" if the robots collide, otherwise \\"No Collision\\". pass # Example execution if __name__ == \\"__main__\\": import sys input_values = list(map(float, sys.stdin.read().strip().split())) x1, y1, r1, x2, y2, r2 = input_values result = will_collide(x1, y1, r1, x2, y2, r2) print(result)","solution":"import math def will_collide(x1, y1, r1, x2, y2, r2): Determines if two robots will collide based on their coordinates and radii. Args: x1, y1: Coordinates of the center of the first robot. r1: Radius of the first robot. x2, y2: Coordinates of the center of the second robot. r2: Radius of the second robot. Returns: \\"Collision\\" if the robots collide, otherwise \\"No Collision\\". distance_between_centers = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) if distance_between_centers <= r1 + r2: return \\"Collision\\" else: return \\"No Collision\\" # Example execution if __name__ == \\"__main__\\": import sys input_values = list(map(float, sys.stdin.read().strip().split())) x1, y1, r1, x2, y2, r2 = input_values result = will_collide(x1, y1, r1, x2, y2, r2) print(result)"},{"question":"def max_smoke_bombs_deployable(n: int) -> int: Given the number of rooms in the treehouse, determines the maximum number of smoke bombs that Team Alpha can deploy to ensure their victory. Parameters: n (int): The number of rooms in the treehouse. Returns: int: Maximum number of smoke bombs deployable by Team Alpha. pass def solve(test_cases: List[int]) -> List[int]: Determines the results for multiple test cases where we need to find the maximum number of smoke bombs deployable by Team Alpha for each case. Parameters: test_cases (List[int]): A list containing the number of rooms for each test case. Returns: List[int]: A list containing the results for each test case. pass from typing import List def test_max_smoke_bombs_deployable(): assert max_smoke_bombs_deployable(3) == 2 assert max_smoke_bombs_deployable(5) == 3 assert max_smoke_bombs_deployable(4) == 2 assert max_smoke_bombs_deployable(1) == 1 assert max_smoke_bombs_deployable(6) == 3 assert max_smoke_bombs_deployable(10) == 5 assert max_smoke_bombs_deployable(9) == 5 def test_solve(): assert solve([3, 5, 4]) == [2, 3, 2] assert solve([1, 2, 10, 15]) == [1, 1, 5, 8] def test_large_input(): # Test the solution with a large input size assert max_smoke_bombs_deployable(100000) == 50000 def test_edge_cases(): assert max_smoke_bombs_deployable(1) == 1 assert max_smoke_bombs_deployable(2) == 1 assert max_smoke_bombs_deployable(10**5) == 50000","solution":"def max_smoke_bombs_deployable(n): Returns the maximum number of smoke bombs that Team Alpha can deploy in an n-room treehouse to ensure their victory. Parameters: n (int): number of rooms in the treehouse Returns: int: number of rooms where Team Alpha can deploy smoke bombs to guarantee their victory # Team Alpha can deploy smoke bombs in every second room return (n + 1) // 2 def solve(test_cases): results = [] for n in test_cases: results.append(max_smoke_bombs_deployable(n)) return results"},{"question":"from typing import List, Tuple def find_optimal_medic_position(checkpoints: List[Tuple[int, int]]) -> Tuple[float, float]: Given a list of coordinates of checkpoints, find the optimal position for the medic so that the maximum distance to any checkpoint is minimized. Parameters: checkpoints: List of tuples representing the coordinates (x, y) of checkpoints. Returns: Tuple of x and y coordinates of the optimal position for the medic. Examples: >>> find_optimal_medic_position([(0, 0), (10, 0), (10, 10), (0, 10)]) (5.0000000000, 5.0000000000) >>> find_optimal_medic_position([(1, 1), (1, 2), (2, 2)]) (1.5000000000, 1.5000000000) pass","solution":"from scipy.spatial import ConvexHull from scipy.optimize import minimize def find_optimal_medic_position(checkpoints): Given a list of coordinates of checkpoints, find the optimal position for the medic so that the maximum distance to any checkpoint is minimized. Parameters: checkpoints: List of tuples representing the coordinates (x, y) of checkpoints. Returns: Tuple of x and y coordinates of the optimal position for the medic. def max_distance(point): x, y = point return max(((x - px)**2 + (y - py)**2)**0.5 for px, py in checkpoints) hull_points = ConvexHull(checkpoints).points centroid = hull_points.mean(axis=0) result = minimize(max_distance, centroid, method='Nelder-Mead', tol=1e-9) return result.x[0], result.x[1]"},{"question":"def can_transform_to_unique_char(S: str, K: int) -> str: Determine if Alex can transform the string S to consist of exactly one unique character after performing exactly K operations. Parameters: S (str): The string to be transformed. K (int): The number of operations Alex can perform. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". >>> can_transform_to_unique_char(\\"abc\\", 2) == \\"YES\\" >>> can_transform_to_unique_char(\\"aabb\\", 1) == \\"NO\\" >>> can_transform_to_unique_char(\\"xyz\\", 3) == \\"YES\\" >>> can_transform_to_unique_char(\\"aaa\\", 0) == \\"YES\\" >>> can_transform_to_unique_char(\\"abcdef\\", 5) == \\"YES\\" >>> can_transform_to_unique_char(\\"aabbcc\\", 4) == \\"YES\\" >>> can_transform_to_unique_char(\\"abcdefghijklmnopqrstuvwxy\\", 25) == \\"YES\\" def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases to determine if each string can be transformed. Parameters: test_cases (list): List of tuples (S, K) for each test case. Returns: list: List of results (\\"YES\\" or \\"NO\\") for each test case. >>> process_test_cases([(\\"abc\\", 2), (\\"aabb\\", 1), (\\"xyz\\", 3)]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases([(\\"abcdefg\\", 6), (\\"a\\", 1), (\\"bbbbb\\", 0)]) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_transform_to_unique_char(S, K): Determine if it is possible to transform the string S into a string of one unique character with exactly K operations. Parameters: S (str): The string to transform. K (int): The number of operations allowed. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". # Count frequency of each character freq = {} for char in S: if char in freq: freq[char] += 1 else: freq[char] = 1 # Find the maximum frequency of a single character max_freq = max(freq.values()) # The number of operations needed to make all characters the same operations_needed = len(S) - max_freq # If K operations are enough to make all characters the same, return \\"YES\\", otherwise return \\"NO\\" if operations_needed <= K: return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): Process multiple test cases. Parameters: test_cases (list): List of tuples (S, K) for each test case. Returns: list: List of results for each test case. results = [] for S, K in test_cases: results.append(can_transform_to_unique_char(S, K)) return results"},{"question":"from typing import List def element_wise_maximum(N: int, A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Returns the element-wise maximum of two NxN matrices A and B. >>> element_wise_maximum(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]], [ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1]]) [[9, 8, 7], [6, 5, 6], [7, 8, 9]] >>> element_wise_maximum(2, [ ... [5, 1], ... [0, 2]], [ ... [5, 3], ... [7, 2]]) [[5, 3], [7, 2]]","solution":"def element_wise_maximum(N, A, B): Returns the element-wise maximum of two NxN matrices A and B. C = [] for i in range(N): row = [] for j in range(N): row.append(max(A[i][j], B[i][j])) C.append(row) return C"},{"question":"def num_excellent_students(n: int, marks: List[Tuple[int, int, int]]) -> int: Determines the number of students who have achieved excellence based on the criteria. A student achieves excellence by securing an overall average of at least 75%, with no subject mark falling below 50%. Parameters: n (int): The number of students. marks (List[Tuple[int, int, int]]): A list of tuples, each containing three integers representing the marks in Mathematics, Physics, and Chemistry, respectively. Returns: int: The number of students who have achieved excellence. Examples: >>> num_excellent_students(5, [(90, 80, 70), (50, 60, 70), (90, 91, 92), (85, 40, 90), (78, 88, 84)]) 3 >>> num_excellent_students(3, [(90, 90, 90), (80, 80, 80), (75, 75, 75)]) 3 >>> num_excellent_students(4, [(40, 90, 90), (80, 40, 80), (75, 75, 45), (60, 60, 60)]) 0 >>> num_excellent_students(2, [(75, 75, 75), (50, 50, 50)]) 1 >>> num_excellent_students(1, [(85, 88, 92)]) 1 >>> num_excellent_students(1, [(35, 40, 45)]) 0","solution":"def num_excellent_students(n, marks): Returns the number of students who have achieved excellence. Parameters: n (int): The number of students. marks (list of tuples): Each tuple contains three integers, the marks in Mathematics, Physics, and Chemistry respectively. Returns: int: The number of students who have achieved excellence. count = 0 for math, physics, chemistry in marks: average = (math + physics + chemistry) / 3 if average >= 75 and math >= 50 and physics >= 50 and chemistry >= 50: count += 1 return count # Example usage: n = 5 marks = [ (90, 80, 70), (50, 60, 70), (90, 91, 92), (85, 40, 90), (78, 88, 84), ] print(num_excellent_students(n, marks)) # Output: 3"},{"question":"def evaluate_expressions(expressions: List[str]) -> List[Union[float, str]]: Evaluate a list of mathematical expressions. Handles addition, subtraction, multiplication, and division. Division by zero and invalid operators are handled with clear error messages. Args: expressions (List[str]): List of mathematical expressions in string format. Returns: List[Union[float, str]]: List of results or error messages for each expression. >>> evaluate_expressions([\\"3 + 5\\"]) [8.0] >>> evaluate_expressions([\\"10 / 0\\"]) [\\"Error: Division by zero\\"] >>> evaluate_expressions([\\"7 ? 2\\"]) [\\"Error: Invalid operator '?'\\"] >>> evaluate_expressions([\\"7 +\\"]) [\\"Error: Invalid syntax\\"] >>> evaluate_expressions([\\"/ 2\\"]) [\\"Error: Invalid syntax\\"] >>> evaluate_expressions([\\"7 2\\"]) [\\"Error: Invalid syntax\\"]","solution":"def evaluate_expressions(expressions): results = [] for expression in expressions: try: left_operand, operator, right_operand = expression.split() left_operand = int(left_operand) right_operand = int(right_operand) if operator == '+': result = left_operand + right_operand elif operator == '-': result = left_operand - right_operand elif operator == '*': result = left_operand * right_operand elif operator == '/': if right_operand == 0: result = \\"Error: Division by zero\\" else: result = left_operand / right_operand else: result = \\"Error: Invalid operator '{}'\\".format(operator) results.append(result) except ValueError as e: results.append(\\"Error: Invalid syntax\\") return results"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Determines the minimum number of operations required to transform string s into string t. :param s: First string. :param t: Second string. :return: The minimum number of operations required to transform s into t, or -1 if it's impossible. >>> min_operations_to_transform(\\"abcd\\", \\"abcd\\") 0 >>> min_operations_to_transform(\\"abcd\\", \\"dcba\\") 1 >>> min_operations_to_transform(\\"abba\\", \\"baab\\") 1 >>> min_operations_to_transform(\\"aaaa\\", \\"bbbb\\") -1 pass def process_test_cases(test_cases: list) -> list: Processes multiple test cases to determine the minimum number of operations for each one. :param test_cases: A list of tuples where each tuple contains two strings (s, t). :return: A list of integers representing the results for each test case. >>> process_test_cases([(\\"abcd\\", \\"abcd\\"), (\\"abcd\\", \\"dcba\\"), (\\"abba\\", \\"baab\\"), (\\"aaaa\\", \\"bbbb\\")]) [0, 1, 1, -1] pass def main(input_list: list) -> list: Processes input and returns the results for the test cases. :param input_list: A list of input, with the first item being the number of test cases, followed by pairs of strings (s, t). :return: A list of integers representing the results for each test case. >>> main([\\"4\\", \\"abcd\\", \\"abcd\\", \\"abcd\\", \\"dcba\\", \\"abba\\", \\"baab\\", \\"aaaa\\", \\"bbbb\\"]) [0, 1, 1, -1] pass # Example test case to run the implementation def test_min_operations_to_transform(): assert min_operations_to_transform(\\"abcd\\", \\"abcd\\") == 0 assert min_operations_to_transform(\\"abcd\\", \\"dcba\\") == 1 assert min_operations_to_transform(\\"abba\\", \\"baab\\") == 1 assert min_operations_to_transform(\\"aaaa\\", \\"bbbb\\") == -1 def test_process_test_cases(): test_cases = [(\\"abcd\\", \\"abcd\\"), (\\"abcd\\", \\"dcba\\"), (\\"abba\\", \\"baab\\"), (\\"aaaa\\", \\"bbbb\\")] assert process_test_cases(test_cases) == [0, 1, 1, -1] def test_main(): input_list = [\\"4\\", \\"abcd\\", \\"abcd\\", \\"abcd\\", \\"dcba\\", \\"abba\\", \\"baab\\", \\"aaaa\\", \\"bbbb\\"] assert main(input_list) == [0, 1, 1, -1] # Run the tests test_min_operations_to_transform() test_process_test_cases() test_main()","solution":"def min_operations_to_transform(s, t): Determines the minimum number of operations required to transform string s into string t. if sorted(s) != sorted(t): return -1 reverse_s = s[::-1] if reverse_s == t: return 1 if s == t: return 0 return 1 def process_test_cases(test_cases): results = [] for s, t in test_cases: results.append(min_operations_to_transform(s, t)) return results def main(input_list): t = int(input_list[0]) test_cases = [(input_list[i * 2 + 1], input_list[i * 2 + 2]) for i in range(t)] return process_test_cases(test_cases)"},{"question":"def largest_rectangle_area(n: int, points: List[Tuple[int, int]]) -> int: Determine the area of the largest possible rectangular park that can be built. >>> largest_rectangle_area(6, [(1, 1), (1, 4), (4, 1), (4, 4), (2, 5), (5, 2)]) 9 >>> largest_rectangle_area(3, [(1, 1), (2, 2), (3, 3)]) 0 from typing import List, Tuple","solution":"def largest_rectangle_area(n, points): if n < 4: return 0 points_set = set(points) max_area = 0 for i in range(n): for j in range(i + 1, n): if points[i][0] != points[j][0] and points[i][1] != points[j][1]: p1 = (points[i][0], points[j][1]) p2 = (points[j][0], points[i][1]) if p1 in points_set and p2 in points_set: area = abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1]) max_area = max(max_area, area) return max_area"},{"question":"def manage_registration(n: int, queries: List[Tuple[str, int]]) -> List[str]: Handles the registration and deregistration of students based on provided queries. >>> manage_registration(3, [(\\"REGISTER\\", 101), (\\"REGISTER\\", 102), (\\"REGISTER\\", 101)]) [\\"Student registered\\", \\"Student registered\\", \\"ID already taken\\"] >>> manage_registration(4, [(\\"REGISTER\\", 200), (\\"DEREGISTER\\", 200), (\\"DEREGISTER\\", 200), (\\"REGISTER\\", 200)]) [\\"Student registered\\", \\"Student deregistered\\", \\"ID not found\\", \\"Student registered\\"]","solution":"def manage_registration(n, queries): registered_ids = set() results = [] for query in queries: action, student_id = query if action == \\"REGISTER\\": if student_id in registered_ids: results.append(\\"ID already taken\\") else: registered_ids.add(student_id) results.append(\\"Student registered\\") elif action == \\"DEREGISTER\\": if student_id not in registered_ids: results.append(\\"ID not found\\") else: registered_ids.remove(student_id) results.append(\\"Student deregistered\\") return results"},{"question":"from typing import List def generateParentheses(n: int) -> List[str]: Generate all possible combinations of well-formed parentheses of length 2*n. All outputs must be in lexicographical order. >>> generateParentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generateParentheses(2) [\\"(())\\", \\"()()\\"] >>> generateParentheses(1) [\\"()\\"] pass","solution":"from typing import List def generateParentheses(n: int) -> List[str]: def backtrack(S, left, right): if len(S) == 2 * n: res.append(\\"\\".join(S)) return if left < n: S.append('(') backtrack(S, left + 1, right) S.pop() if right < left: S.append(')') backtrack(S, left, right + 1) S.pop() res = [] backtrack([], 0, 0) return res"},{"question":"def smallestNumber(N: int) -> int: Generate the smallest number X such that the sum of the digits of X is equal to N. Args: N (int): The target sum of the digits. Returns: int: The smallest number X with the digit sum equal to N. Examples: >>> smallestNumber(10) 19 >>> smallestNumber(15) 69","solution":"def smallestNumber(N): Generate the smallest number X such that the sum of the digits of X is equal to N. if N == 0: return 0 digits = [] while N > 0: if N > 9: digits.append(9) N -= 9 else: digits.append(N) N = 0 return int(\\"\\".join(map(str, digits[::-1])))"},{"question":"def sum_of_missing_numbers(arr: list[int]) -> int: Returns the sum of missing numbers within the smallest contiguous range that includes all values from 0 to max(arr). >>> sum_of_missing_numbers([2, 3, 7, 4, 9]) 20 >>> sum_of_missing_numbers([0, 1, 2, 3, 4, 5]) 0 >>> sum_of_missing_numbers([]) 0","solution":"def sum_of_missing_numbers(arr): Returns the sum of missing numbers within the smallest contiguous range that includes all values from 0 to max(arr). if not arr: return 0 max_value = max(arr) full_set = set(range(max_value + 1)) arr_set = set(arr) missing_numbers = full_set - arr_set return sum(missing_numbers)"},{"question":"import math from typing import List def vector_magnitude(vec: List[float]) -> float: Calculate the magnitude of a vector represented by a list of its components. Args: vec (List[float]): A list of numerical values representing the components of the vector. Returns: float: The magnitude of the vector. Examples: >>> vector_magnitude([3, 4]) 5.0 >>> vector_magnitude([1, 2, 2]) 3.0 >>> vector_magnitude([0, 0, 0]) 0.0 >>> vector_magnitude([5]) 5.0","solution":"import math def vector_magnitude(vec): Returns the magnitude of a vector represented by the list 'vec'. return math.sqrt(sum(x ** 2 for x in vec))"},{"question":"def count_unique_substrings(S: str) -> int: Returns the number of unique substrings of the given string S. >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"aaa\\") 3 pass def solve(T: int, strings: List[str]) -> List[int]: For each string S in strings, computes the number of unique substrings and returns the results in a list. >>> solve(2, [\\"abc\\", \\"aaa\\"]) [6, 3] >>> solve(3, [\\"a\\", \\"ab\\", \\"abc\\"]) [1, 3, 6] pass","solution":"def count_unique_substrings(S): Returns the number of unique substrings of the given string S. unique_substrings = set() for i in range(len(S)): for j in range(i + 1, len(S) + 1): unique_substrings.add(S[i:j]) return len(unique_substrings) def solve(T, strings): For each string S in strings, computes the number of unique substrings and prints it. results = [] for S in strings: results.append(count_unique_substrings(S)) return results"},{"question":"def find_maximum_subarray_sums(n: int, array: List[int]) -> List[int]: Find the maximum subarray sum for each possible length K from 1 to N. Args: n (int): the size of the array array (List[int]): the elements of the array Returns: List[int]: an array of length \`n\`, where the \`i\`-th element is the maximum sum of any subarray of length \`i+1\` in the original array. Examples: >>> find_maximum_subarray_sums(5, [1, 2, 3, 4, 5]) [5, 9, 12, 14, 15] >>> find_maximum_subarray_sums(3, [2, 1, 5]) [5, 6, 8]","solution":"def find_maximum_subarray_sums(n, array): max_sums = [0] * n for k in range(1, n + 1): current_sum = sum(array[:k]) max_sum = current_sum for i in range(k, n): current_sum = current_sum - array[i - k] + array[i] if current_sum > max_sum: max_sum = current_sum max_sums[k - 1] = max_sum return max_sums"},{"question":"def minimum_operations_to_equal_array(test_cases): Determine the minimum number of operations needed to make all elements of the array equal. >>> minimum_operations_to_equal_array([(3, [1, 2, 3]), (2, [3, 4]), (5, [1, 1, 1, 1, 1])]) [1, 1, 0] >>> minimum_operations_to_equal_array([(3, [1, 1, 1]), (4, [5, 5, 5, 5])]) [0, 0] >>> minimum_operations_to_equal_array([(3, [4, 5, 4]), (3, [2, 2, 3]), (4, [1, 2, 1, 2])]) [1, 1, 1] >>> minimum_operations_to_equal_array([(5, [1, 1, 3, 1, 1]), (3, [0, 0, 0]), (2, [6, 7])]) [1, 0, 1]","solution":"def minimum_operations_to_equal_array(test_cases): results = [] for n, a in test_cases: if len(set(a)) == 1: results.append(0) else: results.append(1) return results"},{"question":"def smallest_suffix(a, N): Generate an array b such that each element b_i is the smallest possible element from the subarray a[i:] of the given array a. :param a: List[int] : Input array :param N: int : Size of the input array :return: List[int] : Resulting array with the smallest elements from suffixes of a >>> smallest_suffix([4, 3, 2, 5, 1], 5) [1, 1, 1, 1, 1] >>> smallest_suffix([6, 8, 7, 5], 4) [5, 5, 5, 5]","solution":"def smallest_suffix(a, N): Generate an array b such that each element b_i is the smallest possible element from the subarray a[i:] of the given array a. :param a: List[int] : Input array :param N: int : Size of the input array :return: List[int] : Resulting array with the smallest elements from suffixes of a if not a or N == 0: return [] b = [0] * N b[N-1] = a[N-1] # Traverse from the second last to the first element for i in range(N - 2, -1, -1): b[i] = min(a[i], b[i + 1]) return b"},{"question":"def lcs_length(str1, str2): Function to find the length of the Longest Common Subsequence (LCS) of two strings. >>> lcs_length('abcd', 'ab') 2 >>> lcs_length('abcd', 'ef') 0 >>> lcs_length('efgh', 'ef') 2 >>> lcs_length('ijkl', 'ef') 0 >>> lcs_length('bland', 'brand') 4 >>> lcs_length('abcdef', 'ace') 3 pass def longest_common_subsequence(N, Q, citizen_ids, queries): Function to calculate LCS length for each query against each citizen ID. >>> N = 3 >>> Q = 2 >>> citizen_ids = [\\"abcd\\", \\"efgh\\", \\"ijkl\\"] >>> queries = [\\"ab\\", \\"ef\\"] >>> longest_common_subsequence(N, Q, citizen_ids, queries) [2, 0, 0, 0, 2, 0] >>> N = 1 >>> Q = 1 >>> citizen_ids = [\\"abcdefgh\\"] >>> queries = [\\"aceg\\"] >>> longest_common_subsequence(N, Q, citizen_ids, queries) [4] >>> N = 2 >>> Q = 2 >>> citizen_ids = [\\"abcdefgh\\", \\"ijklmnop\\"] >>> queries = [\\"aceg\\", \\"ikmo\\"] >>> longest_common_subsequence(N, Q, citizen_ids, queries) [4, 0, 0, 4] pass","solution":"def lcs_length(str1, str2): Function to find the length of the Longest Common Subsequence (LCS) of two strings. m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def longest_common_subsequence(N, Q, citizen_ids, queries): Function to calculate LCS length for each query against each citizen ID. results = [] for query in queries: for id_ in citizen_ids: results.append(lcs_length(id_, query)) return results"},{"question":"def find_pair_with_sum(n: int, x: int, arr: List[int]) -> Tuple[int, int]: Finds two distinct integers a and b from the list arr such that their sum is equal to x. If there are multiple pairs, returns any one of them. If no such pair exists, returns -1. Parameters: n (int): number of integers in the list x (int): target sum arr (list): list of integers Returns: tuple: a pair of integers (a, b) whose sum is x, or -1 if no such pair exists >>> find_pair_with_sum(5, 9, [2, 7, 11, 15, 1]) (2, 7) >>> find_pair_with_sum(4, 8, [1, 2, 4, 4]) (4, 4) >>> find_pair_with_sum(5, 10, [1, 2, 3, 4, 5]) -1 >>> find_pair_with_sum(6, 10, [1, 9, 2, 8, 3, 7]) (1, 9) >>> find_pair_with_sum(2, 5, [2, 3]) (2, 3)","solution":"def find_pair_with_sum(n, x, arr): Finds two distinct integers a and b from the list arr such that their sum is equal to x. If there are multiple pairs, returns any one of them. If no such pair exists, returns -1. Parameters: n (int): number of integers in the list x (int): target sum arr (list): list of integers Returns: tuple: a pair of integers (a, b) whose sum is x, or -1 if no such pair exists seen = {} for num in arr: complement = x - num if complement in seen and seen[complement] > 0: return (complement, num) if num in seen: seen[num] += 1 else: seen[num] = 1 return -1"},{"question":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates a list to the right by 'k' steps. Args: nums: List of integers to be rotated. k: Number of steps to rotate the list to the right. Returns: Rotated list. Examples: >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3]","solution":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates a list to the right by 'k' steps. Args: nums: List of integers to be rotated. k: Number of steps to rotate the list to the right. Returns: Rotated list. if not nums: # if the list is empty return [] n = len(nums) k = k % n # handle cases where k > n return nums[-k:] + nums[:-k]"},{"question":"def smallest_integer_k_elements(n: int, k: int, array: List[int]) -> int: Find the smallest positive integer x such that there are exactly k integers in the list greater than or equal to x. Parameters: n (int): Number of elements in the list. k (int): The required number of integers greater than or equal to x. array (list): List of n integers. Returns: int: Smallest integer x such that there are exactly k integers in the list greater than or equal to x, or -1 if no such x exists. >>> smallest_integer_k_elements(5, 2, [1, 2, 3, 4, 5]) 4 >>> smallest_integer_k_elements(6, 3, [5, 2, 8, 6, 3, 1]) 5 >>> smallest_integer_k_elements(4, 5, [7, 3, 4, 5]) -1","solution":"def smallest_integer_k_elements(n, k, array): Find the smallest positive integer x such that there are exactly k integers in the list greater than or equal to x. Parameters: n (int): Number of elements in the list. k (int): The required number of integers greater than or equal to x. array (list): List of n integers. Returns: int: Smallest integer x such that there are exactly k integers in the list greater than or equal to x, or -1 if no such x exists. sorted_array = sorted(array, reverse=True) # If k is more than the number of elements in the list, we cannot find such x if k > n: return -1 # Check if there are at least k elements in sorted array to consider if k <= 0 or k > len(sorted_array): return -1 # We are interested in the k-th largest element x = sorted_array[k - 1] # Verify if there are exactly k elements greater than or equal to x count = sum(1 for num in array if num >= x) if count == k: return x else: return -1"},{"question":"def min_operations_to_target_sum(nums: List[int], target: int) -> int: Determine the minimum number of operations required to make the sum of the list nums equal to target, or return -1 if it is not possible. >>> min_operations_to_target_sum([1, 2, 3, 4, 5], 15) == 0 >>> min_operations_to_target_sum([1, 2, 3, 9], 10) == 1 >>> min_operations_to_target_sum([1, 1, 1], 5) == -1 >>> min_operations_to_target_sum([10, 20, 30], 5) == 55 >>> min_operations_to_target_sum([-1, -2, -3, -4, -5], -15) == 0 >>> min_operations_to_target_sum([-1, -2, -3, -4, -5], -10) == -1 >>> min_operations_to_target_sum([3, 3, 4], 0) == 10","solution":"def min_operations_to_target_sum(nums, target): Determine the minimum number of operations required to make the sum of the list nums equal to target. If it is not possible return -1. current_sum = sum(nums) # If the current sum of nums is already equal to the target, no operations are needed if current_sum == target: return 0 # If the sum is less than target, return -1 as we cannot increase the sum if current_sum < target: return -1 # To find the minimum operations to match the target, we need to reduce the sum by (current_sum - target) difference = current_sum - target return difference"},{"question":"import math class Circle: A class to model a circle with a given radius. Methods: - __init__(radius): Initializes the circle with a radius. - get_area(): Returns the area of the circle. - get_circumference(): Returns the circumference of the circle. - set_radius(radius): Updates the radius of the circle with appropriate validation. Example usage: >>> circle = Circle(5) >>> circle.get_area() 78.53981633974483 >>> circle.get_circumference() 31.41592653589793 >>> circle.set_radius(3) >>> circle.get_area() 28.274333882308138","solution":"import math class Circle: def __init__(self, radius): if radius <= 0: raise ValueError(\\"Radius must be a positive number\\") self.radius = radius def get_area(self): return math.pi * (self.radius ** 2) def get_circumference(self): return 2 * math.pi * self.radius def set_radius(self, radius): if radius <= 0: raise ValueError(\\"Radius must be a positive number\\") self.radius = radius"},{"question":"class EmployeeDB: Class to manage employee records and process queries. Methods: - add_employee(emp_id: int, name: str, department: str, salary: int) - query_name_by_id(emp_id: int) -> str - query_ids_by_department(department: str) -> list - query_avg_salary_by_department(department: str) -> int def __init__(self): self.employees = {} self.departments = {} def add_employee(self, emp_id, name, department, salary): Add employee to the database pass def query_name_by_id(self, emp_id): Retrieve the name of the employee given their unique ID. pass def query_ids_by_department(self, department): Retrieve a list of employees (their IDs) who work in a particular department. pass def query_avg_salary_by_department(self, department): Retrieve the average salary of employees in a particular department, rounded to the nearest integer. pass def process_queries(n, employee_data, q, query_data): Function to process the queries on employee data. pass # Examples if __name__ == '__main__': n = 5 employee_data = [ (1, \\"Alice\\", \\"HR\\", 50000), (2, \\"Bob\\", \\"Engineering\\", 60000), (3, \\"Carol\\", \\"HR\\", 55000), (4, \\"Dave\\", \\"Marketing\\", 45000), (5, \\"Eve\\", \\"Engineering\\", 62000) ] q = 4 query_data = [ (1, 3), (2, \\"HR\\"), (3, \\"Engineering\\"), (1, 6) ] # Expected output: # [\\"Carol\\", \\"1 3\\", \\"61000\\", \\"Employee not found\\"] print(process_queries(n, employee_data, q, query_data))","solution":"class EmployeeDB: def __init__(self): self.employees = {} self.departments = {} def add_employee(self, emp_id, name, department, salary): self.employees[emp_id] = {\\"name\\": name, \\"department\\": department, \\"salary\\": salary} if department not in self.departments: self.departments[department] = [] self.departments[department].append(emp_id) def query_name_by_id(self, emp_id): if emp_id in self.employees: return self.employees[emp_id][\\"name\\"] else: return \\"Employee not found\\" def query_ids_by_department(self, department): if department in self.departments: return sorted(self.departments[department]) else: return [] def query_avg_salary_by_department(self, department): if department in self.departments: total_salary = sum(self.employees[emp_id][\\"salary\\"] for emp_id in self.departments[department]) return round(total_salary / len(self.departments[department])) else: return 0 def process_queries(n, employee_data, q, query_data): db = EmployeeDB() for emp in employee_data: emp_id, name, department, salary = emp db.add_employee(emp_id, name, department, salary) results = [] for query in query_data: type_query = query[0] if type_query == 1: emp_id = query[1] results.append(db.query_name_by_id(emp_id)) elif type_query == 2: department = query[1] ids = db.query_ids_by_department(department) results.append(\\" \\".join(map(str, ids))) elif type_query == 3: department = query[1] average_salary = db.query_avg_salary_by_department(department) results.append(str(average_salary)) return results"},{"question":"def auction_results(n: int, items: list) -> list: Determines if each item's highest bid meets or exceeds its minimum price. :param n: number of items :param items: list of tuples containing (name, minimum price, highest bid) :return: list of \\"YES\\" or \\"NO\\" for each item # Your code here def process_auction_input(n: int, raw_items: list) -> list: Processes the raw input data and returns the auction results. :param n: number of items :param raw_items: list of strings containing the items information :return: list of \\"YES\\" or \\"NO\\" for each item items = [] for raw_item in raw_items: parts = raw_item.split() name = parts[0] price = int(parts[1]) bid = int(parts[2]) items.append((name, price, bid)) return auction_results(n, items)","solution":"def auction_results(n, items): Determines if each item's highest bid meets or exceeds its minimum price. :param n: number of items :param items: list of tuples containing (name, minimum price, highest bid) :return: list of \\"YES\\" or \\"NO\\" for each item results = [] for item in items: name, price, bid = item if bid >= price: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to facilitate input and output def process_auction_input(n, raw_items): items = [] for raw_item in raw_items: parts = raw_item.split() name = parts[0] price = int(parts[1]) bid = int(parts[2]) items.append((name, price, bid)) return auction_results(n, items)"},{"question":"def max_items(prices: List[int], budget: int) -> int: Returns the maximum number of different items that can be bought without exceeding the given budget. >>> max_items([1, 3, 2, 4, 1], 7) 4 >>> max_items([10, 6, 8, 7, 7, 8], 5) 0 >>> max_items([1, 1, 1, 1, 1], 3) 3","solution":"def max_items(prices, budget): Returns the maximum number of different items that can be bought without exceeding the given budget. # Sort the prices in ascending order prices.sort() total_cost = 0 count = 0 for price in prices: if total_cost + price <= budget: total_cost += price count += 1 else: break return count"},{"question":"def unique_stamps(a: int, b: int, roy_stamps_list: List[int], biv_stamps_list: List[int]) -> int: Returns the number of unique stamps after merging Roy's and Biv's collections. Parameters: a (int): Number of stamps in Roy's collection. b (int): Number of stamps in Biv's collection. roy_stamps_list (list of int): Stamps in Roy's collection. biv_stamps_list (list of int): Stamps in Biv's collection. Returns: int: The number of unique stamps. >>> unique_stamps(3, 4, [1, 2, 3], [2, 3, 4, 5]) 5 >>> unique_stamps(5, 3, [1, 1, 1, 2, 3], [3, 3, 4]) 4 >>> unique_stamps(2, 2, [1, 3], [2, 4]) 4 >>> unique_stamps(3, 3, [1, 2, 3], [1, 2, 3]) 3 >>> unique_stamps(6, 7, [5, 6, 7, 8, 9, 10], [10, 11, 12, 13, 14, 15, 16]) 12","solution":"def unique_stamps(a, b, roy_stamps_list, biv_stamps_list): Returns the number of unique stamps after merging Roy's and Biv's collections. Parameters: a (int): Number of stamps in Roy's collection. b (int): Number of stamps in Biv's collection. roy_stamps_list (list of int): Stamps in Roy's collection. biv_stamps_list (list of int): Stamps in Biv's collection. Returns: int: The number of unique stamps. # Using set to get unique stamps from both collections combined_stamps = set(roy_stamps_list) | set(biv_stamps_list) return len(combined_stamps)"},{"question":"def contains_all_alphabets(strings): For each string in a list, check if it contains all 26 letters of the English alphabet. :param strings: List of strings to check :return: List of 'YES' or 'NO' corresponding to each input string >>> contains_all_alphabets([\\"thequickbrownfoxjumpsoverthelazydog\\", \\"hello\\", \\"abcdefghijklmnopqrstuvwxyz\\"]) ['YES', 'NO', 'YES'] >>> contains_all_alphabets([\\"a\\", \\"\\", \\"abcd\\"]) ['NO', 'NO', 'NO']","solution":"def contains_all_alphabets(strings): For each string in a list, check if it contains all 26 letters of the English alphabet. :param strings: List of strings to check :return: List of 'YES' or 'NO' corresponding to each input string result = [] all_letters_set = set(\\"abcdefghijklmnopqrstuvwxyz\\") for s in strings: if set(s) >= all_letters_set: result.append('YES') else: result.append('NO') return result"},{"question":"def is_karma_sequence(N: int, sequence: List[int]) -> str: Determines if the given sequence can be rearranged into a karma-sequence. >>> is_karma_sequence(4, [1, 2, 3, 0]) == \\"Yes\\" >>> is_karma_sequence(5, [1, 2, 3, 0, 1]) == \\"No\\" >>> is_karma_sequence(3, [10, 5, 15]) == \\"Yes\\" >>> is_karma_sequence(3, [0, 0, 0]) == \\"Yes\\" >>> is_karma_sequence(2, [5, 5]) == \\"Yes\\" >>> is_karma_sequence(2, [6, 9]) == \\"No\\" >>> is_karma_sequence(1, [0]) == \\"Yes\\"","solution":"def is_karma_sequence(N, sequence): Determines if the given sequence can be rearranged into a karma-sequence. Parameters: N (int): The number of elements in the sequence. sequence (list of int): The sequence of non-negative integers. Returns: str: \\"Yes\\" if the sequence can be rearranged into a karma-sequence, otherwise \\"No\\". xor_sum = 0 for num in sequence: xor_sum ^= num return \\"Yes\\" if xor_sum == 0 else \\"No\\""},{"question":"def will_meet(a1, a2, a3, v1, v2, v3): Determines if three racers starting at positions a1, a2, a3 with speeds v1, v2, v3 will ever be at the same position at the same time. Returns \\"YES\\" if they meet at a common point, otherwise \\"NO\\". >>> will_meet(1, 2, 3, 1, 2, 3) \\"NO\\" >>> will_meet(0, 10, 20, 2, 2, 2) \\"YES\\"","solution":"def will_meet(a1, a2, a3, v1, v2, v3): Determines if three racers starting at positions a1, a2, a3 with speeds v1, v2, v3 will ever be at the same position at the same time. Returns \\"YES\\" if they meet at a common point, otherwise \\"NO\\". # If all speeds are the same, it's possible for them to meet if # they are equally spaced initially if v1 == v2 == v3: return \\"YES\\" # Calculate time differences between the first and the other racers if v1 != v2 and (a2 - a1) % (v2 - v1) != 0: return \\"NO\\" if v1 != v3 and (a3 - a1) % (v3 - v1) != 0: return \\"NO\\" if v2 != v3 and (a3 - a2) % (v3 - v2) != 0: return \\"NO\\" # There should be a common t where any two conditions meet t12 = (a2 - a1) / (v1 - v2) if v1 != v2 else None t13 = (a3 - a1) / (v1 - v3) if v1 != v3 else None t23 = (a3 - a2) / (v2 - v3) if v2 != v3 else None if t12 is not None and t12 >= 0 and (t13 is None or t12 == t13) and (t23 is None or t12 == t23): return \\"YES\\" if t13 is not None and t13 >= 0 and (t12 is None or t12 == t13) and (t23 is None or t13 == t23): return \\"YES\\" if t23 is not None and t23 >= 0 and (t12 is None or t12 == t23) and (t13 is None or t13 == t23): return \\"YES\\" return \\"NO\\""},{"question":"def solve_magic_square(n: int, matrix: List[List[int]]) -> List[List[int]]: Help Anna fill the matrix in such a way that all rows, columns, and the two main diagonals contain all integers from 1 to n. >>> solve_magic_square(3, [ ... [1, 0, 3], ... [0, 2, 0], ... [0, 0, 0] ... ]) [[1, 2, 3], [3, 2, 1], [2, 1, 3]] >>> solve_magic_square(3, [ ... [1, 2, 3], ... [3, 2, 1], ... [2, 1, 3] ... ]) [[1, 2, 3], [3, 2, 1], [2, 1, 3]] >>> solve_magic_square(3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) [[1, 2, 3], [3, 1, 2], [2, 3, 1]]","solution":"def solve_magic_square(n, matrix): def is_valid(num, row, col): # Check if num is already in the row or column for i in range(n): if matrix[row][i] == num or matrix[i][col] == num: return False # Check the main diagonals if row == col: for i in range(n): if matrix[i][i] == num: return False if row + col == n - 1: for i in range(n): if matrix[i][n - 1 - i] == num: return False return True def solve(row, col): if row == n: return True if col == n: return solve(row + 1, 0) if matrix[row][col] != 0: return solve(row, col + 1) for num in range(1, n + 1): if is_valid(num, row, col): matrix[row][col] = num if solve(row, col + 1): return True matrix[row][col] = 0 return False solve(0, 0) return matrix"},{"question":"def canMakeEqual(arr: List[int]) -> str: Determines if it is possible to make all the elements of the array equal with at most one increment or decrement operation. Parameters: arr (list of int): The input array of integers. Returns: str: \\"Yes\\" if it is possible to make all elements equal with at most one operation, otherwise \\"No\\". Examples: >>> canMakeEqual([1, 2, 3]) \\"No\\" >>> canMakeEqual([3, 3, 3, 4]) \\"Yes\\" >>> canMakeEqual([5, 5, 5, 5]) \\"Yes\\"","solution":"def canMakeEqual(arr): Determines if it is possible to make all the elements of the array equal with at most one increment or decrement operation. Parameters: arr (list of int): The input array of integers. Returns: str: \\"Yes\\" if it is possible to make all elements equal with at most one operation, otherwise \\"No\\". min_val = min(arr) max_val = max(arr) # If the difference between the max and min value is greater than 1, it's not possible to make all elements equal if max_val - min_val > 1: return \\"No\\" else: return \\"Yes\\""},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generates an nxn spiral matrix with numbers from 1 to n^2. >>> generate_spiral_matrix(3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> generate_spiral_matrix(4) [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] >>> generate_spiral_matrix(5) [ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ] >>> generate_spiral_matrix(1) [ [1] ] >>> generate_spiral_matrix(0) [] >>> generate_spiral_matrix(2) [ [1, 2], [4, 3] ]","solution":"def generate_spiral_matrix(n): Generates an n x n spiral matrix with numbers from 1 to n^2. if n <= 0: return [] matrix = [[0] * n for _ in range(n)] num = 1 left, right = 0, n - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: # Fill top row for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Fill right column for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Fill bottom row if there is still a row to fill if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Fill left column if there is still a column to fill if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def find_students_with_most_excellent(n, data): Finds the student(s) with the maximum number of 'Excellent' submissions. Args: n (int): Number of students. data (List[Tuple[int, str, List[int]]]): List containing student data tuples with (number_of_submissions, student_name, [submission_scores]) Returns: str: Student(s) with the highest number of 'Excellent' submissions. Examples: >>> find_students_with_most_excellent(3, [(4, \\"Alice\\", [100, 82, 100, 75]), (3, \\"Bob\\", [100, 100, 100]), (5, \\"Charlie\\", [90, 100, 85, 75, 100])]) \\"Student(s) with the highest number of 'Excellent' submissions: Bob.\\" >>> find_students_with_most_excellent(3, [(4, \\"Alice\\", [100, 100, 100, 75]), (4, \\"Bob\\", [100, 100, 100, 75]), (3, \\"Charlie\\", [100, 100, 100])]) \\"Student(s) with the highest number of 'Excellent' submissions: Alice, Bob, Charlie.\\"","solution":"def find_students_with_most_excellent(n, data): Finds the student(s) with the maximum number of 'Excellent' submissions. Args: n (int): Number of students. data (List[Tuple[int, str, List[int]]]): List containing student data tuples with (number_of_submissions, student_name, [submission_scores]) Returns: str: Student(s) with the highest number of 'Excellent' submissions. max_excellent_count = -1 students_with_max_excellent = [] for i in range(n): num_submissions, name, scores = data[i] excellent_count = scores.count(100) if excellent_count > max_excellent_count: max_excellent_count = excellent_count students_with_max_excellent = [name] elif excellent_count == max_excellent_count: students_with_max_excellent.append(name) return f\\"Student(s) with the highest number of 'Excellent' submissions: {', '.join(students_with_max_excellent)}.\\""},{"question":"def can_transform(N, A, B): Determine if it is possible to make the two strings equal by applying any number of transformations and swaps. >>> can_transform(3, \\"a*c\\", \\"abc\\") \\"YES\\" >>> can_transform(5, \\"abc*e\\", \\"bbcde\\") \\"NO\\"","solution":"def can_transform(N, A, B): # Remove all '*' from A and compare the rest of characters. A_filtered = [char for char in A if char != '*'] if len(A_filtered) > len(B): return \\"NO\\" # Create a frequency dictionary for A_filtered and B freq_A = {} freq_B = {} for char in A_filtered: if char in freq_A: freq_A[char] += 1 else: freq_A[char] = 1 for char in B: if char in freq_B: freq_B[char] += 1 else: freq_B[char] = 1 # Compare the frequency dictionaries for char, count in freq_A.items(): if char not in freq_B or freq_B[char] < count: return \\"NO\\" return \\"YES\\""},{"question":"def process_file_events(n: int, events: List[str]) -> List[str]: Process a series of file system events and outputs the results. Parameters: n (int): The number of events. events (list of str): The list of events in the given format. Returns: list of str: Processed events in the desired output format. # Example test cases # # >>> process_file_events(1, [\\"CREATE FILE /home/user/docs/file1.txt\\"]) # [\\"CREATE /home/user/docs/file1.txt\\"] # # >>> process_file_events(3, [ # ... \\"CREATE DIR /var/log/\\", # ... \\"CREATE FILE /var/log/syslog\\", # ... \\"DELETE FILE /var/log/syslog\\" # ... ]) # [\\"CREATE /var/log/\\", # \\"CREATE /var/log/syslog\\", # \\"DELETE /var/log/syslog\\"]","solution":"def process_file_events(n, events): Process a series of file system events and outputs the results. Parameters: n (int): The number of events. events (list of str): The list of events in the given format. Returns: list of str: Processed events in the desired output format. results = [] for event in events: parts = event.split() action = parts[0] type_ = parts[1] # This can be FILE or DIR, but it's not used directly path = ' '.join(parts[2:]) # The path could have spaces, so join the rest of the parts result = f\\"{action} {path}\\" results.append(result) return results"},{"question":"def validate_identifier(identifier: str) -> int: Validates if the identifier starts with \\"USR-\\" and is followed by six digits. >>> validate_identifier(\\"USR-123456\\") == 1 >>> validate_identifier(\\"USR-abc123\\") == 0 >>> validate_identifier(\\"USR-12345\\") == 0","solution":"import re def validate_identifier(identifier): Validates if the identifier starts with \\"USR-\\" and is followed by six digits. Parameters: identifier (str): The input identifier to be validated. Returns: int: 1 if the identifier is valid, 0 otherwise. if re.fullmatch(r\\"USR-d{6}\\", identifier): return 1 return 0"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determine if string s1 can be transformed into s2 using zero or more moves. >>> can_transform(\\"abc\\", \\"bca\\") True >>> can_transform(\\"aabb\\", \\"bbaa\\") True >>> can_transform(\\"xyz\\", \\"yyz\\") False pass def solve(test_cases: List[Tuple[str, str]]) -> List[str]: For each test case, determine if s1 can be transformed into s2 and return the results. >>> solve([(\\"abc\\", \\"bca\\"), (\\"aabb\\", \\"bbaa\\"), (\\"xyz\\", \\"yyz\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_transform(s1, s2): Determine if string s1 can be transformed into s2 using zero or more moves. return sorted(s1) == sorted(s2) def solve(test_cases): results = [] for s1, s2 in test_cases: if can_transform(s1, s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def does_any_building_block_view(buildings: List[int]) -> str: Determines if any building blocks the view of another building. Args: buildings (list): A list of integers representing the heights of buildings. Returns: str: \\"YES\\" if any building blocks the view of another, otherwise \\"NO\\". pass # Test Cases def test_buildings_with_block(): assert does_any_building_block_view([3, 1, 4, 2, 5]) == \\"YES\\" def test_buildings_without_block(): assert does_any_building_block_view([1, 2, 3, 4]) == \\"NO\\" def test_single_building(): assert does_any_building_block_view([5]) == \\"NO\\" def test_equal_height_buildings(): assert does_any_building_block_view([3, 3, 3, 3]) == \\"YES\\" def test_increasing_height_buildings(): assert does_any_building_block_view([2, 4, 6, 7, 9]) == \\"NO\\" def test_decreasing_height_buildings(): assert does_any_building_block_view([10, 9, 8, 7, 6]) == \\"YES\\"","solution":"def does_any_building_block_view(buildings): Determines if any building blocks the view of another building. Args: buildings (list): A list of integers representing the heights of buildings. Returns: str: \\"YES\\" if any building blocks the view of another, otherwise \\"NO\\". for i in range(len(buildings) - 1): if buildings[i] >= buildings[i + 1]: return \\"YES\\" return \\"NO\\""},{"question":"def max_of_three(X: int, Y: int, Z: int) -> int: Returns the maximum of three integers X, Y, and Z. >>> max_of_three(3, 9, -5) 9 >>> max_of_three(-3, -9, -5) -3 >>> max_of_three(-3, 15, -5) 15 >>> max_of_three(0, 0, 0) 0 >>> max_of_three(7, 7, 7) 7 >>> max_of_three(10, 10, -10) 10","solution":"def max_of_three(X, Y, Z): Returns the maximum of three integers X, Y, and Z. return max(X, Y, Z) # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read() X, Y, Z = map(int, input.strip().split()) print(max_of_three(X, Y, Z))"},{"question":"def sortedEmployeesInRange(employees, minExperience, maxExperience): Retrieves the names of employees who have experience within a specific range and returns them sorted in ascending order by name. :param employees: List of tuples where each tuple is (EmployeeID, Department, Name, Experience) :param minExperience: Minimum years of experience to filter by (inclusive) :param maxExperience: Maximum years of experience to filter by (inclusive) :return: Sorted list of names of employees with experience within the given range >>> sortedEmployeesInRange([(1, 101, 'Alice', 5), (2, 102, 'Bob', 10), (3, 101, 'Charlie', 7), (4, 103, 'David', 3)], 4, 8) ['Alice', 'Charlie'] >>> sortedEmployeesInRange([(5, 101, 'Eve', 2), (6, 102, 'Frank', 1), (7, 103, 'Grace', 3), (8, 104, 'Heidi', 9)], 1, 3) ['Eve', 'Frank', 'Grace'] >>> sortedEmployeesInRange([(5, 101, 'Eve', 2), (6, 102, 'Frank', 1), (7, 103, 'Grace', 3), (8, 104, 'Heidi', 9)], 10, 20) [] >>> sortedEmployeesInRange([(5, 101, 'Eve', 2), (6, 102, 'Frank', 1), (7, 103, 'Grace', 3), (8, 104, 'Heidi', 9)], 0, 10) ['Eve', 'Frank', 'Grace', 'Heidi'] >>> sortedEmployeesInRange([(5, 101, 'Eve', 1), (6, 102, 'Frank', 9), (7, 104, 'Grace', 10), (8, 103, 'Heidi', 11)], 7, 10) ['Frank', 'Grace']","solution":"def sortedEmployeesInRange(employees, minExperience, maxExperience): Returns the sorted list of names of employees who have experience within the specified range. :param employees: List of tuples where each tuple is (EmployeeID, Department, Name, Experience) :param minExperience: minimum years of experience to filter by (inclusive) :param maxExperience: maximum years of experience to filter by (inclusive) :return: Sorted list of names of employees with experience within the given range # Filter the employees based on the experience range filtered_employees = [emp[2] for emp in employees if minExperience <= emp[3] <= maxExperience] # Sort the names of the filtered employees sorted_names = sorted(filtered_employees) return sorted_names"},{"question":"def unique_paths(M: int, N: int) -> int: Calculates the number of unique paths to move from the top-left corner to the bottom-right corner of an M x N grid, where the only allowable moves are right and down. :param M: Number of rows (int). :param N: Number of columns (int). :return: Number of unique paths (int). >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 2) 3 >>> unique_paths(3, 7) 28 >>> unique_paths(20, 20) 35345263800 >>> unique_paths(100, 1) 1 >>> unique_paths(1, 100) 1 >>> unique_paths(100, 100) 22750883079422934966181954039568885395604168260154104734000 # Your code here","solution":"def unique_paths(M, N): Calculates the number of unique paths to move from the top-left corner to the bottom-right corner of an M x N grid, where the only allowable moves are right and down. :param M: Number of rows (int). :param N: Number of columns (int). :return: Number of unique paths (int). # Initialize a 2D array with zeros dp = [[0] * N for _ in range(M)] # Set the base cases for i in range(M): dp[i][0] = 1 for j in range(N): dp[0][j] = 1 # Compute the number of paths for each cell in the grid for i in range(1, M): for j in range(1, N): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[M-1][N-1]"},{"question":"def min_deletions_to_make_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string s a palindrome. Examples: >>> min_deletions_to_make_palindrome(\\"1433541\\") 1 >>> min_deletions_to_make_palindrome(\\"12345\\") 4","solution":"def min_deletions_to_make_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string s a palindrome. n = len(s) # Create a table to store the length of longest palindromic subsequence L = [[0] * n for _ in range(n)] # Strings of length 1 are palindromes of length 1 for i in range(n): L[i][i] = 1 # Build the table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: L[i][j] = 2 elif s[i] == s[j]: L[i][j] = L[i + 1][j - 1] + 2 else: L[i][j] = max(L[i][j - 1], L[i + 1][j]) # The length of the longest palindromic subsequence lps = L[0][n - 1] # Minimum deletions to make the string a palindrome return n - lps"},{"question":"def max_subarray_sum(spending): Returns the maximum sum of any contiguous subarray in the provided list of spending amounts. :param spending: List of integers representing daily spending amounts. :return: Integer, the maximum sum of any contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([3, -2, 5, -1, 4, -3, 2]) == 9 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(spending): Returns the maximum sum of any contiguous subarray in the provided list of spending amounts. :param spending: List of integers representing daily spending amounts. :return: Integer, the maximum sum of any contiguous subarray. if not spending: return 0 current_sum = max_sum = spending[0] for amount in spending[1:]: current_sum = max(amount, current_sum + amount) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def transformArray(arr: List[int]) -> List[int]: Re-position the array elements with the constraint that each element must now be at the index corresponding to its value if that index is within the bounds of the array. >>> transformArray([2, 0, 3, 5, -4, 1]) [0, 1, 2, 3, -1, 5] >>> transformArray([8, 3, 7, 9, 2, 6]) [-1, -1, 2, 3, -1, -1]","solution":"def transformArray(arr): Re-position the array elements with the constraint that each element must now be at the index corresponding to its value if that index is within the bounds of the array. n = len(arr) result = [-1] * n for val in arr: if 0 <= val < n: result[val] = val return result"},{"question":"def min_total_distance(packages, n): Determines the minimum total distance traveled by all packages to their respective delivery points. :param packages: List of tuples where each tuple contains an integer representing the weight of the package and an integer representing the delivery point's index. :param n: Number of delivery points on the belt. :return: An integer representing the minimum total distance traveled by all packages. >>> min_total_distance([(5, 2)], 3) == 10 >>> min_total_distance([(5, 2), (3, 4), (2, 1)], 5) == 23 >>> min_total_distance([(2, 3), (3, 3), (1, 3)], 4) == 18 >>> min_total_distance([(2, 0), (3, 1), (1, 2)], 3) == 5 >>> min_total_distance([(i, i) for i in range(1000)], 1000) == sum(i * i for i in range(1000))","solution":"def min_total_distance(packages, n): Determines the minimum total distance traveled by all packages to their respective delivery points. :param packages: List of tuples where each tuple contains an integer representing the weight of the package and an integer representing the delivery point's index. :param n: Number of delivery points on the belt. :return: An integer representing the minimum total distance traveled by all packages. # The packages list is already in the form where each element represents (weight, delivery_point) min_distance = 0 # Calculate the total minimum distance for package in packages: weight, point = package # Since the distance is the point's index multiplied by the weight min_distance += weight * point return min_distance"},{"question":"def sequence(n: int) -> int: Generate the n-th number in the sequence starting from 1 where the next number is determined based on whether the previous number is even or odd. :param n: index of the number in the sequence to be returned (1-indexed) :type n: int :return: n-th number in the sequence :rtype: int >>> sequence(1) 1 >>> sequence(2) 4 >>> sequence(3) 2 >>> sequence(4) 1","solution":"def sequence(n): Generate the n-th number in the sequence starting from 1 where the next number is determined based on whether the previous number is even or odd. :param n: index of the number in the sequence to be returned (1-indexed) :type n: int :return: n-th number in the sequence :rtype: int if n < 1: raise ValueError(\\"n must be a positive integer\\") seq = [1] for _ in range(1, n): last = seq[-1] if last % 2 == 0: seq.append(last // 2) else: seq.append(last * 3 + 1) return seq[-1]"},{"question":"def find_peaks(lst): Finds all the peak elements in the list. A peak element is an element that is greater than its neighbors. Bounds of the list are considered as negative infinity. :param lst: List of integers :return: List containing all peak elements >>> find_peaks([]) [] >>> find_peaks([1]) [1] >>> find_peaks([1, 2, 3, 4, 5]) [5] >>> find_peaks([5, 4, 3, 2, 1]) [5] >>> find_peaks([1, 2, 1, 3, 5, 6, 4]) [2, 6] >>> find_peaks([3, 3, 3, 3]) [] >>> find_peaks([1, 3, 2, 3, 1]) [3, 3] >>> find_peaks([2, 1]) [2] >>> find_peaks([1, 2]) [2]","solution":"def find_peaks(lst): Finds all the peak elements in the list. A peak element is an element that is greater than its neighbors. Bounds of the list are considered as negative infinity. :param lst: List of integers :return: List containing all peak elements if not lst: # If the list is empty return [] n = len(lst) if n == 1: # If the list has only one element return [lst[0]] peaks = [] for i in range(n): if (i == 0 and lst[i] > lst[i + 1]) or (i == n - 1 and lst[i] > lst[i - 1]) or (0 < i < n - 1 and lst[i] > lst[i - 1] and lst[i] > lst[i + 1]): peaks.append(lst[i]) return peaks"},{"question":"def rearrange_words(s: str) -> str: Re-arrange the words in the string in ascending order of their lengths. Words of the same length should appear in the order they appeared in the original string. >>> rearrange_words(\\"the quick brown fox jumps over the lazy dog\\") \\"the fox the dog over lazy quick brown jumps\\" >>> rearrange_words(\\"hello world\\") \\"hello world\\" >>> rearrange_words(\\"hi there everyone\\") \\"hi there everyone\\" >>> rearrange_words(\\"I am going to the market\\") \\"I am to the going market\\"","solution":"def rearrange_words(s): Returns a string with words rearranged in ascending order of their lengths. Words of the same length should appear in the order they appeared in the original string. words = s.split() sorted_words = sorted(words, key=len) return ' '.join(sorted_words)"},{"question":"def min_operations_to_palindrome(S: str) -> int: Given a string S, returns the minimum number of operations needed to make it a palindrome. An operation is defined as changing any character to any other character. >>> min_operations_to_palindrome(\\"abca\\") 1 >>> min_operations_to_palindrome(\\"racecar\\") 0 >>> min_operations_to_palindrome(\\"abcd\\") 2 >>> min_operations_to_palindrome(\\"a\\") 0 >>> min_operations_to_palindrome(\\"abcba\\") 0 >>> min_operations_to_palindrome(\\"abccba\\") 0 >>> min_operations_to_palindrome(\\"abcdef\\") 3 >>> min_operations_to_palindrome(\\"ab\\") 1 >>> min_operations_to_palindrome(\\"aa\\") 0 >>> min_operations_to_palindrome(\\"aaa\\") 0","solution":"def min_operations_to_palindrome(S): Given a string S, returns the minimum number of operations needed to make it a palindrome. An operation is defined as changing any character to any other character. n = len(S) count = 0 for i in range(n // 2): if S[i] != S[n - i - 1]: count += 1 return count"},{"question":"def min_total_travel_distance(positions): Calculates the minimum total distance that all robots need to travel to deliver packages to specified positions on the number line. >>> min_total_travel_distance([]) == 0 >>> min_total_travel_distance([10]) == 0 >>> min_total_travel_distance([1, 2, 3, 4]) == 4 >>> min_total_travel_distance([1, 2, 3]) == 2 >>> min_total_travel_distance([1, 2, 2, 3]) == 2 >>> min_total_travel_distance([1000000, -1000000, 0]) == 2000000 >>> min_total_travel_distance([-5, -3, -1]) == 4 >>> min_total_travel_distance([-1, 0, 1]) == 2","solution":"def min_total_travel_distance(positions): Calculates the minimum total distance that all robots need to travel to deliver packages to specified positions on the number line. if not positions: return 0 median_position = sorted(positions)[len(positions) // 2] total_distance = sum(abs(pos - median_position) for pos in positions) return total_distance"},{"question":"def find_min_value_in_grid_after_operations(N: int, M: int, Q: int, operations: List[Tuple[int, int, int, int]]) -> int: Given matrix dimensions N x M and a list of Q operations to increment values in the subgrids, returns the minimum value in the grid after all operations. >>> find_min_value_in_grid_after_operations(3, 3, 3, [(1, 1, 2, 2), (2, 2, 3, 3), (1, 1, 3, 3)]) 1 >>> find_min_value_in_grid_after_operations(2, 2, 1, [(1, 1, 2, 2)]) 1 >>> find_min_value_in_grid_after_operations(3, 3, 0, []) 0 >>> find_min_value_in_grid_after_operations(3, 3, 3, [(1, 1, 1, 1), (1, 1, 1, 1), (1, 1, 1, 1)]) 0 >>> find_min_value_in_grid_after_operations(3, 3, 2, [(1, 1, 3, 3), (1, 1, 3, 1)]) 1","solution":"def find_min_value_in_grid_after_operations(N, M, Q, operations): Given matrix dimensions N x M and a list of Q operations to increment values in the subgrids, returns the minimum value in the grid after all operations. grid = [[0]*M for _ in range(N)] for x1, y1, x2, y2 in operations: for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): grid[i][j] += 1 min_value = min(min(row) for row in grid) return min_value"},{"question":"def count_vowels(sentence: str) -> int: Given a string which represents a sentence, count the number of vowels (a, e, i, o, u) in it. Consider both uppercase and lowercase vowels. >>> count_vowels(\\"This is an example.\\") 6 >>> count_vowels(\\"Hello, world!\\") 3 >>> count_vowels(\\"bcdfg\\") 0 >>> count_vowels(\\"aeiouAEIOU\\") 10 >>> count_vowels(\\"123 AEI 456 oei!\\") 6 >>> count_vowels(\\"\\") 0","solution":"def count_vowels(sentence): Returns the number of vowels in the given sentence. Consider both uppercase and lowercase vowels (a, e, i, o, u). vowels = \\"aeiouAEIOU\\" count = 0 for char in sentence: if char in vowels: count += 1 return count"},{"question":"def square_positive_numbers(numbers): Returns a list containing the square of each positive number in the input list. Negative numbers and zeros are excluded from the output. :param numbers: List of integers :return: List of integers pass import unittest class TestSquarePositiveNumbers(unittest.TestCase): def test_all_positive_numbers(self): self.assertEqual(square_positive_numbers([1, 2, 3, 4]), [1, 4, 9, 16]) def test_with_negative_numbers(self): self.assertEqual(square_positive_numbers([-1, -2, 3, 4]), [9, 16]) def test_with_zero(self): self.assertEqual(square_positive_numbers([0, 1, 2, 3, 4]), [1, 4, 9, 16]) def test_all_negative_numbers(self): self.assertEqual(square_positive_numbers([-1, -2, -3, -4]), []) def test_mixed_numbers(self): self.assertEqual(square_positive_numbers([-1, 2, 0, -3, 4, 5]), [4, 16, 25]) def test_empty_list(self): self.assertEqual(square_positive_numbers([]), []) def test_single_positive_number(self): self.assertEqual(square_positive_numbers([3]), [9]) def test_single_negative_number(self): self.assertEqual(square_positive_numbers([-3]), []) if __name__ == '__main__': unittest.main()","solution":"def square_positive_numbers(numbers): Returns a list containing the square of each positive number in the input list. Negative numbers and zeros are excluded from the output. :param numbers: List of integers :return: List of integers return [num ** 2 for num in numbers if num > 0]"},{"question":"def rotate_right(arr, x): Rotates the list 'arr' to the right by 'x' positions. >>> rotate_right([1, 2, 3, 4, 5, 6], 2) [5, 6, 1, 2, 3, 4] >>> rotate_right([10, 20, 30, 40, 50], 1) [50, 10, 20, 30, 40] >>> rotate_right([1, 2, 3, 4], 3) [2, 3, 4, 1] def process_test_cases(test_cases): Processes multiple test cases and applies the rotate_right function. >>> process_test_cases([([1, 2, 3, 4, 5, 6], 2), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 3)]) [[5, 6, 1, 2, 3, 4], [50, 10, 20, 30, 40], [2, 3, 4, 1]]","solution":"def rotate_right(arr, x): Rotates the list 'arr' to the right by 'x' positions. n = len(arr) x = x % n # Handle cases where x >= n return arr[-x:] + arr[:-x] def process_test_cases(test_cases): Processes multiple test cases and applies the rotate_right function. results = [] for case in test_cases: arr, x = case rotated_arr = rotate_right(arr, x) results.append(rotated_arr) return results"},{"question":"def warehouse_inventory(N, D, initial_stocks, transactions): Manage the inventory of a warehouse and calculate the total amount of items in the warehouse at the end of each day. :param N: Number of different types of items in the warehouse. :param D: Number of days for which transactions are recorded. :param initial_stocks: List of initial stock levels for each item type. :param transactions: List of transactions, where each transaction is a tuple (day, item_type, quantity). :return: A list of total stock of all items in the warehouse at the end of each day. >>> warehouse_inventory(3, 5, [100, 200, 300], [(1, 1, 50), (2, 2, -30), (3, 3, 100), (4, 1, -60), (5, 2, 10)]) [650, 620, 720, 660, 670] >>> warehouse_inventory(1, 3, [100], [(1, 1, 20), (2, 1, -10), (3, 1, 30)]) [120, 110, 140] >>> warehouse_inventory(2, 3, [50, 60], []) [110, 110, 110] >>> warehouse_inventory(2, 2, [30, 70], [(1, 1, 10), (1, 2, 20), (2, 1, -5), (2, 2, -15)]) [130, 110]","solution":"def warehouse_inventory(N, D, initial_stocks, transactions): stocks = initial_stocks[:] results = [] for d in range(1, D+1): for transaction in transactions: if transaction[0] == d: item_type = transaction[1] - 1 quantity = transaction[2] stocks[item_type] += quantity results.append(sum(stocks)) return results def parse_input(input_str): lines = input_str.strip().split('n') N, D = map(int, lines[0].split()) initial_stocks = list(map(int, lines[1].split())) transactions = [tuple(map(int, line.split())) for line in lines[2:]] return N, D, initial_stocks, transactions if __name__ == '__main__': import sys input_str = sys.stdin.read() N, D, initial_stocks, transactions = parse_input(input_str) result = warehouse_inventory(N, D, initial_stocks, transactions) for r in result: print(r)"},{"question":"def gem_collection_value(t: int, gem_collections: List[str]) -> List[int]: Calculate the total value V of Rita's gem collection for multiple test cases. Args: t (int): Number of test cases. gem_collections (List[str]): List of strings where each string represents the types of gems in the collection. Returns: List[int]: A list of total values V for each test case. Example: >>> gem_collection_value(2, ['aabb', 'ababc']) [12, 14]","solution":"def gem_collection_value(t, gem_collections): results = [] for G in gem_collections: gem_counts = {} for gem in G: if gem in gem_counts: gem_counts[gem] += 1 else: gem_counts[gem] = 1 value = 0 for count in gem_counts.values(): value += count * (count + 1) results.append(value) return results"},{"question":"def safety_check(sector_data, priority): Generates a safety report prioritizing the given status. Args: sector_data (dict): A dictionary containing sector data. priority (str): The status to prioritize, either \\"Critical\\" or \\"Warning\\". Returns: dict: A dictionary with sector names and the count of prioritized status modules. # Your code here from typing import Dict, List def test_safety_check_with_critical_priority(): sector_data = { \\"Sector 1\\": [ {\\"name\\": \\"Module A\\", \\"status\\": \\"Safe\\"}, {\\"name\\": \\"Module B\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module C\\", \\"status\\": \\"Warning\\"}, ], \\"Sector 2\\": [ {\\"name\\": \\"Module D\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module E\\", \\"status\\": \\"Critical\\"}, ], \\"Sector 3\\": [ {\\"name\\": \\"Module F\\", \\"status\\": \\"Safe\\"}, {\\"name\\": \\"Module G\\", \\"status\\": \\"Warning\\"}, ] } priority = \\"Critical\\" expected_output = {\\"Sector 1\\": 1, \\"Sector 2\\": 2} assert safety_check(sector_data, priority) == expected_output def test_safety_check_with_warning_priority(): sector_data = { \\"Sector 1\\": [ {\\"name\\": \\"Module A\\", \\"status\\": \\"Safe\\"}, {\\"name\\": \\"Module B\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module C\\", \\"status\\": \\"Warning\\"}, ], \\"Sector 2\\": [ {\\"name\\": \\"Module D\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module E\\", \\"status\\": \\"Critical\\"}, ], \\"Sector 3\\": [ {\\"name\\": \\"Module F\\", \\"status\\": \\"Safe\\"}, {\\"name\\": \\"Module G\\", \\"status\\": \\"Warning\\"}, ] } priority = \\"Warning\\" expected_output = {\\"Sector 1\\": 1, \\"Sector 3\\": 1} assert safety_check(sector_data, priority) == expected_output def test_safety_check_no_priority_modules(): sector_data = { \\"Sector 1\\": [ {\\"name\\": \\"Module A\\", \\"status\\": \\"Safe\\"}, {\\"name\\": \\"Module B\\", \\"status\\": \\"Safe\\"}, {\\"name\\": \\"Module C\\", \\"status\\": \\"Safe\\"}, ], \\"Sector 2\\": [ {\\"name\\": \\"Module D\\", \\"status\\": \\"Safe\\"}, {\\"name\\": \\"Module E\\", \\"status\\": \\"Safe\\"}, ], \\"Sector 3\\": [ {\\"name\\": \\"Module F\\", \\"status\\": \\"Safe\\"}, {\\"name\\": \\"Module G\\", \\"status\\": \\"Safe\\"}, ] } priority = \\"Critical\\" expected_output = {} assert safety_check(sector_data, priority) == expected_output def test_safety_check_all_critical_modules(): sector_data = { \\"Sector 1\\": [ {\\"name\\": \\"Module A\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module B\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module C\\", \\"status\\": \\"Critical\\"}, ], \\"Sector 2\\": [ {\\"name\\": \\"Module D\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module E\\", \\"status\\": \\"Critical\\"}, ], \\"Sector 3\\": [ {\\"name\\": \\"Module F\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module G\\", \\"status\\": \\"Critical\\"}, ] } priority = \\"Critical\\" expected_output = {\\"Sector 1\\": 3, \\"Sector 2\\": 2, \\"Sector 3\\": 2} assert safety_check(sector_data, priority) == expected_output def test_safety_check_mix_status_modules(): sector_data = { \\"Sector 1\\": [ {\\"name\\": \\"Module A\\", \\"status\\": \\"Critical\\"}, {\\"name\\": \\"Module B\\", \\"status\\": \\"Warning\\"}, {\\"name\\": \\"Module C\\", \\"status\\": \\"Safe\\"}, ], \\"Sector 2\\": [ {\\"name\\": \\"Module D\\", \\"status\\": \\"Warning\\"}, {\\"name\\": \\"Module E\\", \\"status\\": \\"Critical\\"}, ], \\"Sector 3\\": [ {\\"name\\": \\"Module F\\", \\"status\\": \\"Warning\\"}, {\\"name\\": \\"Module G\\", \\"status\\": \\"Warning\\"}, ] } priority = \\"Warning\\" expected_output = {\\"Sector 1\\": 1, \\"Sector 2\\": 1, \\"Sector 3\\": 2} assert safety_check(sector_data, priority) == expected_output","solution":"def safety_check(sector_data, priority): Generates a safety report prioritizing the given status. Args: sector_data (dict): A dictionary containing sector data. priority (str): The status to prioritize, either \\"Critical\\" or \\"Warning\\". Returns: dict: A dictionary with sector names and the count of prioritized status modules. report = {} for sector, modules in sector_data.items(): count = sum(1 for module in modules if module['status'] == priority) if count > 0: report[sector] = count return report"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most 2 distinct characters. >>> length_of_longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") 10 >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 def solve(queries: List[str]) -> List[int]: Processes multiple queries of finding the length of the longest substring with at most 2 distinct characters. >>> solve([\\"abcbbbbcccbdddadacb\\", \\"eceba\\"]) [10, 3] >>> solve([\\"aaaa\\", \\"a\\", \\"abaccc\\"]) [4, 1, 4]","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most 2 distinct characters. n = len(s) if n < 3: return n left, right = 0, 0 hashmap = {} max_len = 2 while right < n: if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len def solve(queries): Processes multiple queries of finding the length of the longest substring with at most 2 distinct characters. results = [] for s in queries: longest_length = length_of_longest_substring_two_distinct(s) results.append(longest_length) return results"},{"question":"def min_difference_in_candies(N: int, M: int) -> int: Function to find minimum possible difference between the maximum number of candies received by any child and the minimum number of candies received by any child. Parameters: N (int): The number of candies. M (int): The number of children. Returns: int: Minimum possible difference. >>> min_difference_in_candies(7, 3) 1 >>> min_difference_in_candies(10, 5) 0 >>> min_difference_in_candies(9, 6) 1","solution":"def min_difference_in_candies(N, M): Function to find minimum possible difference between the maximum number of candies received by any child and the minimum number of candies received by any child. Parameters: N (int): The number of candies. M (int): The number of children. Returns: int: Minimum possible difference. if M == 0: return 0 # No children to distribute candies to return 1 if N % M != 0 else 0"},{"question":"from typing import List, Tuple def max_R_and_min_M(cards: List[int]) -> Tuple[int, int]: This function calculates the maximum possible value of R (each member receives) and the minimum number of audience members M. :param cards: List of integers representing cards in each deck :return: Tuple (R, M) def magic_card_trick(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: This function determines the maximum possible value of R and the minimum number of audience members M for multiple test cases and returns the results. :param T: Number of test cases :param test_cases: A list containing pairs of number of decks and list of integers representing cards in each deck :return: A list of tuples where each tuple contains (max_R, min_M) for each test case # Unit test cases def test_max_R_and_min_M(): assert max_R_and_min_M([12, 15]) == (3, 9) assert max_R_and_min_M([12, 15, 18]) == (3, 15) assert max_R_and_min_M([24, 36, 60]) == (12, 10) assert max_R_and_min_M([1, 1, 1]) == (1, 3) assert max_R_and_min_M([1000, 2000, 3000]) == (1000, 6) def test_magic_card_trick(): assert magic_card_trick(2, [ (2, [12, 15]), (3, [12, 15, 18]) ]) == [(3, 9), (3, 15)] assert magic_card_trick(1, [ (4, [4, 8, 16, 32]) ]) == [(4, 15)] assert magic_card_trick(3, [ (3, [100, 200, 300]), (2, [5, 10]), (5, [1, 2, 3, 4, 5]) ]) == [(100, 6), (5, 3), (1, 15)]","solution":"from math import gcd from functools import reduce def max_R_and_min_M(cards): This function calculates the maximum possible value of R (each member receives) and the minimum number of audience members M. :param cards: List of integers representing cards in each deck :return: Tuple (R, M) total_cards = sum(cards) # Function to find GCD of a list of numbers def find_gcd_of_list(num_list): x = reduce(gcd, num_list) return x # Finding GCD of all cards in the decks gcd_all_cards = find_gcd_of_list(cards) # The maximum value of R is the GCD obtained from all decks max_R = gcd_all_cards # The minimum number of audience members M min_M = total_cards // max_R return max_R, min_M def magic_card_trick(T, test_cases): results = [] for case in test_cases: N = case[0] cards = case[1] results.append(max_R_and_min_M(cards)) return results"},{"question":"def max_pairs(N, K, values, edges): Find the maximum number of pairs with node values sum being a multiple of K. Args: N (int): Number of nodes in the tree. K (int): The given integer to check the sum multiple. values (List[int]): List containing values of each node. edges (List[Tuple[int, int]]): List of tuples representing edges in the tree. Returns: int: The maximum number of pairs that can be formed with the sum of their values being a multiple of K. Examples: >>> max_pairs(5, 3, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) 2 >>> max_pairs(4, 2, [1, 3, 5, 6], [(1, 2), (2, 3), (3, 4)]) 1","solution":"def max_pairs(N, K, values, edges): from collections import defaultdict, Counter # Count remainders of the values when divided by K remainder_count = Counter([value % K for value in values]) # Calculate pairs pairs = 0 for remainder in range((K // 2) + 1): if remainder == 0 or remainder == K - remainder: pairs += remainder_count[remainder] // 2 else: pairs += min(remainder_count[remainder], remainder_count[K - remainder]) return pairs def parse_input(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) K = int(data[1]) values = list(map(int, data[2:N+2])) edges = [] for i in range(N-1): a = int(data[N+2 + 2*i]) b = int(data[N+3 + 2*i]) edges.append((a, b)) return N, K, values, edges if __name__ == \\"__main__\\": N, K, values, edges = parse_input() print(max_pairs(N, K, values, edges))"},{"question":"import math from typing import List, Tuple def find_gcd_pairs_count(arr: List[int]) -> int: n = len(arr) count = 0 for i in range(n): for j in range(i + 1, n): if math.gcd(arr[i], arr[j]) > 1: count += 1 return count def number_of_gcd_pairs(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of positive integers, determine the number of pairs (i, j) where i < j and the greatest common divisor (GCD) of the elements at these indices is greater than 1. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n (the size of the array) and a list of n positive integers. Returns: List[int]: A list of integers where each integer is the number of pairs (i, j) for a given test case. Example: >>> number_of_gcd_pairs([(3, [6, 10, 15]), (4, [12, 15, 18, 20])]) [3, 6]","solution":"import math def find_gcd_pairs_count(arr): n = len(arr) count = 0 for i in range(n): for j in range(i + 1, n): if math.gcd(arr[i], arr[j]) > 1: count += 1 return count def number_of_gcd_pairs(test_cases): results = [] for test_case in test_cases: n, arr = test_case results.append(find_gcd_pairs_count(arr)) return results"},{"question":"def steps_to_one(S: int) -> int: Returns the number of operations needed for number S to reach 1 following the defined sequence. >>> steps_to_one(6) 8 >>> steps_to_one(1) 0 >>> steps_to_one(7) 16 >>> steps_to_one(2) 1 >>> steps_to_one(3) 7 def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases([6, 1, 7]) [8, 0, 16] >>> process_test_cases([2, 3, 4]) [1, 7, 2] >>> process_test_cases([1, 2, 3, 4, 5]) [0, 1, 7, 2, 5] >>> process_test_cases([10, 20, 30]) [6, 7, 18]","solution":"def steps_to_one(S): Returns the number of operations needed for number S to reach 1 following the defined sequence. steps = 0 while S != 1: if S % 2 == 0: S //= 2 else: S = S * 3 + 1 steps += 1 return steps def process_test_cases(test_cases): Processes multiple test cases and returns a list of results for each test case. results = [] for S in test_cases: results.append(steps_to_one(S)) return results"},{"question":"def longest_contiguous_ones(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Find the longest contiguous subarray of 1s in a binary array for multiple test cases. >>> longest_contiguous_ones(3, [(6, '110111'), (5, '00001'), (4, '0000')]) [3, 1, 0] >>> longest_contiguous_ones(2, [(1, '0'), (1, '1')]) [0, 1] >>> longest_contiguous_ones(1, [(5, '11111')]) [5]","solution":"def longest_contiguous_ones(t, test_cases): results = [] for n, binary_array in test_cases: max_count = 0 current_count = 0 for bit in binary_array: if bit == '1': current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 results.append(max_count) return results"},{"question":"import math from typing import List def primeFactorization(n: int) -> List[int]: Given an integer n, return the list of prime factors of the integer in ascending order. Parameters: n (int): The integer to factorize. Returns: List[int]: A list of prime factors in ascending order. Examples: >>> primeFactorization(10) [2, 5] >>> primeFactorization(28) [2, 2, 7] >>> primeFactorization(13) [13] >>> primeFactorization(100) [2, 2, 5, 5]","solution":"import math def primeFactorization(n): Returns the list of prime factors of the given integer n in ascending order. factors = [] # Account for the number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point, so a skip of 2 (i.e., 3, 5, 7, ...) for i in range(3, int(math.sqrt(n)) + 1, 2): # While i divides n, append i and divide n while n % i == 0: factors.append(i) n = n // i # This condition is to check if n is a prime number # greater than 2 if n > 2: factors.append(n) return factors"},{"question":"def manage_movie_collection(n, m, operations): Manage the movie collection and return the maximum movie rating after each operation. Args: n (int): Number of slots on the shelf m (int): Number of operations operations (List[Tuple[int, ...]]): List of operations; each operation is a tuple. Returns: List[int]: The maximum movie rating on the shelf after each operation. Example: >>> manage_movie_collection(5, 6, [(1, 3, 10), (1, 1, 5), (1, 5, 7), (2, 3), (1, 2, 20), (2, 5)]) [10, 10, 10, 7, 20, 20]","solution":"def manage_movie_collection(n, m, operations): shelf = [0] * n max_rating = 0 results = [] for operation in operations: op = operation[0] if op == 1: p, r = operation[1] - 1, operation[2] # Adjust for 0-based indexing shelf[p] = r if r > max_rating: max_rating = r results.append(max_rating) elif op == 2: p = operation[1] - 1 # Adjust for 0-based indexing if shelf[p] == max_rating: shelf[p] = 0 max_rating = max(shelf) else: shelf[p] = 0 results.append(max_rating) return results # Example usage n, m = 5, 6 operations = [(1, 3, 10), (1, 1, 5), (1, 5, 7), (2, 3), (1, 2, 20), (2, 5)] print(manage_movie_collection(n, m, operations))"},{"question":"def is_authorized(roles: dict, user_roles: list, requested_action: str) -> bool: Check if the user is authorized to perform the requested action based on their roles. Args: roles: A dictionary where the key is the role name and the value is a list of allowed actions. user_roles: A list of roles assigned to the user. requested_action: The requested action the user wants to perform. Returns: bool: True if the user is authorized to perform the action, False otherwise. >>> roles = { ... \\"admin\\": [\\"create\\", \\"read\\", \\"update\\", \\"delete\\"], ... \\"editor\\": [\\"create\\", \\"read\\", \\"update\\"], ... \\"viewer\\": [\\"read\\"] ... } >>> user_roles = [\\"editor\\", \\"viewer\\"] >>> is_authorized(roles, user_roles, \\"update\\") True >>> is_authorized(roles, user_roles, \\"delete\\") False","solution":"def is_authorized(roles: dict, user_roles: list, requested_action: str) -> bool: Check if the user is authorized to perform the requested action based on their roles. Args: roles: A dictionary where the key is the role name and the value is a list of allowed actions. user_roles: A list of roles assigned to the user. requested_action: The requested action the user wants to perform. Returns: bool: True if the user is authorized to perform the action, False otherwise. for role in user_roles: if role in roles and requested_action in roles[role]: return True return False"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") == True >>> can_form_palindrome(\\"ivicc\\") == True >>> can_form_palindrome(\\"hello\\") == False >>> can_form_palindrome(\\"aabbcc\\") == True >>> can_form_palindrome(\\"xyz\\") == False","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # A string can be rearranged into a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeTwoSortedLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists such that the resulting list is in sorted order. The task should be done in-place without using extra memory. Example 1: Input: List1: 1->3->5->7 List2: 2->4->6->8 Output: 1->2->3->4->5->6->7->8 Example 2: Input: List1: 5->10->15 List2: 2->3->20 Output: 2->3->5->10->15->20 >>> list_to_linked_list = lambda x: None # function definition for example purposes >>> linked_list_to_list = lambda x: None # function definition for example purposes >>> l1 = list_to_linked_list([1, 3, 5, 7]) >>> l2 = list_to_linked_list([2, 4, 6, 8]) >>> linked_list_to_list(mergeTwoSortedLists(l1, l2)) [1, 2, 3, 4, 5, 6, 7, 8] >>> l1 = list_to_linked_list([5, 10, 15]) >>> l2 = list_to_linked_list([2, 3, 20]) >>> linked_list_to_list(mergeTwoSortedLists(l1, l2)) [2, 3, 5, 10, 15, 20] # Implement your code here","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeTwoSortedLists(l1, l2): # Creating a dummy node to help with merging dummy = ListNode(-1) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If there are remaining elements in either list, append them if l1: current.next = l1 if l2: current.next = l2 return dummy.next"},{"question":"from typing import List def word_search(grid: List[List[str]], word: str) -> bool: Given a grid of characters and a target word, determine if the word can be found in the grid following these rules: - The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. - The same letter cell may not be used more than once. >>> grid1 = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> word_search(grid1, \\"ABCCED\\") == True >>> word_search(grid1, \\"SEE\\") == True >>> word_search(grid1, \\"ABCB\\") == False def test_word_found(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] assert word_search(grid, \\"ABCCED\\") == True def test_word_found_2(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] assert word_search(grid, \\"SEE\\") == True def test_word_not_found(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] assert word_search(grid, \\"ABCB\\") == False def test_single_cell_grid_word_found(): grid = [['A']] assert word_search(grid, \\"A\\") == True def test_single_cell_grid_word_not_found(): grid = [['A']] assert word_search(grid, \\"B\\") == False def test_word_with_no_path(): grid = [ ['A', 'A', 'A', 'A'], ['A', 'A', 'A', 'A'], ['A', 'A', 'A', 'A'] ] assert word_search(grid, \\"AAAAAAAAAAAAA\\") == False","solution":"def word_search(grid, word): rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp, grid[r][c] = grid[r][c], '#' found = (dfs(r + 1, c, index + 1) or dfs(r - 1, c, index + 1) or dfs(r, c + 1, index + 1) or dfs(r, c - 1, index + 1)) grid[r][c] = temp return found for row in range(rows): for col in range(cols): if grid[row][col] == word[0] and dfs(row, col, 0): return True return False"},{"question":"def max_attendees(events: List[Tuple[int, int]]) -> int: Returns the maximum number of participants present at the event simultaneously. >>> max_attendees([(1, 4), (2, 5), (9, 12), (5, 9), (5, 12)]) 3 >>> max_attendees([(1, 4)]) 1 >>> max_attendees([(1, 3), (2, 5), (4, 6)]) 2 >>> max_attendees([(1, 2), (3, 4), (5, 6)]) 1 >>> max_attendees([(1, 5), (1, 5), (1, 5)]) 3 >>> max_attendees([(1, 10), (2, 8), (3, 7), (4, 6), (5, 10)]) 5","solution":"def max_attendees(events): Returns the maximum number of participants present at the event simultaneously. time_points = [] for arrival, departure in events: time_points.append((arrival, 'arrive')) time_points.append((departure, 'depart')) time_points.sort() current_attendees = 0 max_attendees = 0 for time, event in time_points: if event == 'arrive': current_attendees += 1 max_attendees = max(max_attendees, current_attendees) else: current_attendees -= 1 return max_attendees"},{"question":"def max_non_overlap_sessions(n, time_slots): Returns the maximum number of non-overlapping time slots. :param n: The number of time slots. :param time_slots: A list of tuples representing the time slots. :return: The maximum number of non-overlapping time slots. >>> max_non_overlap_sessions(5, [(1, 3), (2, 5), (4, 7), (6, 9), (8, 10)]) 3 >>> max_non_overlap_sessions(3, [(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlap_sessions(4, [(1, 2), (1, 3), (2, 4), (3, 5)]) 2","solution":"def max_non_overlap_sessions(n, time_slots): Returns the maximum number of non-overlapping time slots. :param n: The number of time slots. :param time_slots: A list of tuples representing the time slots. :return: The maximum number of non-overlapping time slots. # Sort time slots by their end time time_slots.sort(key=lambda x: x[1]) # Initialize variables count = 0 last_end_time = 0 # Iterate through the sorted time slots for start, end in time_slots: if start >= last_end_time: count += 1 last_end_time = end return count # Example Usage: n = 5 time_slots = [ (1, 3), (2, 5), (4, 7), (6, 9), (8, 10) ] print(max_non_overlap_sessions(n, time_slots)) # Output: 3"},{"question":"def triangular_number(n: int) -> int: Returns the nth triangular number. >>> triangular_number(1) # 1 1 >>> triangular_number(3) # 6 6 >>> triangular_number(5) # 15 15 # Your code here from solution import triangular_number def test_triangular_number_1(): assert triangular_number(1) == 1 def test_triangular_number_3(): assert triangular_number(3) == 6 def test_triangular_number_5(): assert triangular_number(5) == 15 def test_triangular_number_10(): assert triangular_number(10) == 55 def test_triangular_number_100(): assert triangular_number(100) == 5050 def test_triangular_number_1000(): assert triangular_number(1000) == 500500 def test_triangular_number_10000(): assert triangular_number(10000) == 50005000","solution":"def triangular_number(n): Returns the nth triangular number. return n * (n + 1) // 2"},{"question":"from typing import List def smallest_possible_sum(n: int, sequence: List[int]) -> int: Returns the smallest possible sum of the sequence after performing the operations of replacing any element with the absolute difference of two elements until no further reductions can be made. Args: n (int): The number of elements in the sequence. sequence (List[int]): The sequence of integers. Returns: int: The smallest possible sum of the sequence. Examples: >>> smallest_possible_sum(3, [5, 3, 9]) 1 >>> smallest_possible_sum(4, [4, 8, 16, 32]) 4","solution":"def smallest_possible_sum(n, sequence): Returns the smallest possible sum of the sequence after performing the given operations. # Using Euclidean Algorithm to find the GCD of the sequence from math import gcd from functools import reduce if n == 1: return sequence[0] total_gcd = reduce(gcd, sequence) return total_gcd"},{"question":"def reverse_long_words(sentence: str) -> str: Takes a string of words separated by spaces, and returns the same string with all words that are five letters or longer reversed. Examples: >>> reverse_long_words(\\"Welcome to the coding challenge\\") 'emocleW to the gnidoc egnellahc' >>> reverse_long_words(\\"This is an example of a test string\\") 'This is an elpmaxe of a test gnirts'","solution":"def reverse_long_words(sentence): Takes a string of words separated by spaces, and returns the same string with all words that are five letters or longer reversed. words = sentence.split() for i in range(len(words)): if len(words[i]) >= 5: words[i] = words[i][::-1] return ' '.join(words)"},{"question":"def highest_possible_balance(n: int, transactions: List[Tuple[str, int]]) -> int: Determines the highest possible balance at any point after processing all the transactions. >>> highest_possible_balance(6, [('D', 100), ('W', 50), ('D', 200), ('W', 150), ('D', 300), ('W', 100)]) 400 >>> highest_possible_balance(4, [('D', 100), ('D', 200), ('W', 150), ('W', 50)]) 300 def parse_input(input_str: str) -> Tuple[int, List[Tuple[str, int]]]: Parses the input and converts it into relevant data structures. >>> parse_input(\\"4nD 100nD 200nW 150nW 50\\") (4, [('D', 100), ('D', 200), ('W', 150), ('W', 50)])","solution":"def highest_possible_balance(n, transactions): Determines the highest possible balance at any point after processing all the transactions. Args: n (int): Number of transactions. transactions (list of tuples): Each tuple contains a character ('D' or 'W') and an integer (value). Returns: int: The highest balance possible. balance = 0 max_balance = 0 for trans_type, value in transactions: if trans_type == 'D': balance += value elif trans_type == 'W': balance -= value max_balance = max(max_balance, balance) return max_balance def parse_input(input_str): Parses the input and converts it into relevant data structures. Args: input_str (str): Input string containing the number of transactions followed by transactions. Returns: tuple: Contains number of transactions and the list of transactions. lines = input_str.strip().split('n') n = int(lines[0]) transactions = [(line.split()[0], int(line.split()[1])) for line in lines[1:]] return n, transactions"},{"question":"def has_pair_with_sum(arr, k): Determines if there are two distinct elements in the array that sum up to k. Parameters: arr (list): A list of integers. k (int): The target sum. Returns: str: \\"YES\\" if there are two distinct elements that sum up to k, otherwise \\"NO\\". Examples: >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) 'YES' >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) 'NO' >>> has_pair_with_sum([-1, -2, -3], -4) 'YES'","solution":"def has_pair_with_sum(arr, k): Determines if there are two distinct elements in the array that sum up to k. Parameters: arr (list): A list of integers. k (int): The target sum. Returns: str: \\"YES\\" if there are two distinct elements that sum up to k, otherwise \\"NO\\". seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def weighted_average(n: int, consumptions: List[int], weights: List[int]) -> float: Calculate the weighted average daily consumption and round it to six decimal places. >>> weighted_average(3, [10, 20, 30], [1, 2, 3]) 23.333333 >>> weighted_average(4, [10, 20, 30, 40], [1, 1, 1, 1]) 25.000000 >>> weighted_average(1, [50], [10]) 50.000000 >>> weighted_average(3, [10, 20, 30], [0, 0, 1]) 30.000000 >>> weighted_average(3, [10000, 10000, 10000], [100, 100, 100]) 10000.000000 >>> weighted_average(3, [10000, 0, 5000], [1, 1, 1]) 5000.000000","solution":"def weighted_average(n, consumptions, weights): total_weighted_sum = sum(c * w for c, w in zip(consumptions, weights)) total_weight = sum(weights) weighted_avg = total_weighted_sum / total_weight return round(weighted_avg, 6)"},{"question":"def max_trades(crop_values, initial_crop_value, available_trades): Function to calculate the maximum number of trades that can be performed starting with the initial crop value. Parameters: crop_values (list of int): List of crop values. initial_crop_value (int): Initial crop value. available_trades (int): Number of crops available to trade. Returns: int: Maximum number of trades possible. pass def process_test_cases(T, test_cases): Function to process multiple test cases for the crop trading problem. Parameters: T (int): Number of test cases. test_cases (list of tuples): List of test case tuples where each tuple contains: (N (int), crop_values (list of int), initial_crop_value (int), available_trades (int)) Returns: list of int: List of results for each test case. pass def from_input_string(input_str): Function to parse the input string for the crop trading problem. Parameters: input_str (str): Input string containing multiple test cases. Returns: tuple: Tuple containing the number of test cases and a list of test case tuples. pass def to_output_string(results): Function to format the output for the crop trading problem. Parameters: results (list of int): List of results for each test case. Returns: str: Formatted output string. pass","solution":"def max_trades(crop_values, initial_crop_value, available_trades): Function to calculate the maximum number of trades that can be performed starting with the initial crop value. Parameters: crop_values (list of int): List of crop values. initial_crop_value (int): Initial crop value. available_trades (int): Number of crops available to trade. Returns: int: Maximum number of trades possible. # Maximum trades we can perform is bounded by the number of available trades return available_trades def process_test_cases(T, test_cases): results = [] for i in range(T): N, crop_values, initial_crop_value, available_trades = test_cases[i] result = max_trades(crop_values, initial_crop_value, available_trades) results.append(result) return results # Input function def from_input_string(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) crop_values = list(map(int, lines[idx + 1].split())) initial_crop_value, available_trades = map(int, lines[idx + 2].split()) test_cases.append((N, crop_values, initial_crop_value, available_trades)) idx += 3 return T, test_cases # Output function def to_output_string(results): return 'n'.join(map(str, results))"},{"question":"def optimize_enrollments(N: int, M: int, K: List[int], S: List[int], eligibility: List[List[int]]) -> List[int]: Assign students to courses optimizing for the total enrollments under given constraints. N: Number of students M: Number of courses K: List of maximum courses each student can enroll in S: List of available slots in each course eligibility: Matrix indicating student eligibility for courses >>> optimize_enrollments(3, 3, [2, 1, 2], [1, 2, 1], [[1, 0, 1], [0, 1, 1], [1, 1, 0]]) [1, 2, 1] >>> optimize_enrollments(4, 3, [2, 2, 2, 2], [2, 2, 2], [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]) [2, 2, 2] >>> optimize_enrollments(3, 3, [3, 3, 3], [1, 1, 1], [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) [1, 1, 1] >>> optimize_enrollments(3, 3, [1, 1, 1], [1, 1, 1], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) [1, 1, 1] >>> optimize_enrollments(4, 3, [3, 3, 3, 3], [2, 2, 2], [[1, 0, 1], [0, 1, 1], [1, 1, 0], [0, 0, 1]]) [2, 2, 2] >>> optimize_enrollments(5, 3, [1, 2, 2, 2, 2], [2, 1, 1], [[1, 0, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]) [2, 1, 1]","solution":"def optimize_enrollments(N, M, K, S, eligibility): # Initialize the result list which will store the count of students in each course result = [0] * M # Initialize a list that keeps track of current enrolled courses for each student student_courses = [[] for _ in range(N)] # List to keep track of students' remaining course slots student_remaining = K[:] while True: enrolled = False for i in range(N): for j in range(M): if eligibility[i][j] == 1 and result[j] < S[j] and student_remaining[i] > 0 and j not in student_courses[i]: student_courses[i].append(j) result[j] += 1 student_remaining[i] -= 1 enrolled = True if not enrolled: break return result"},{"question":"def smallest_permutation(n: int) -> int: Returns the smallest number that can be formed by rearranging the digits of the given number n. If n is already the smallest permutation, returns n. >>> smallest_permutation(34021) 10234 >>> smallest_permutation(111332) 111233","solution":"def smallest_permutation(n): Returns the smallest number that can be formed by rearranging the digits of the given number n. If n is already the smallest permutation, returns n. digits = sorted(str(n)) # Find the first non-zero digit to avoid leading zeros in the result for i, digit in enumerate(digits): if digit != '0': # Swap the first non-zero digit with the leading zero (if any) digits[0], digits[i] = digits[i], digits[0] break return int(''.join(digits))"},{"question":"def most_frequent_element(lst): Returns the element that appears most frequently in the list. If there are multiple elements with the highest frequency, returns the one that appears first in the list. Args: lst (list): List of integers. Returns: int: The most frequent element. def test_single_element(): assert most_frequent_element([1]) == 1 def test_multiple_most_frequent(): assert most_frequent_element([5, 5, 6, 6, 7, 7]) == 5 def test_most_frequent_first_occurrence(): assert most_frequent_element([1, 3, 2, 1, 4, 1]) == 1 def test_most_frequent_last_occurrence(): assert most_frequent_element([1, 1, 1, 3, 2, 2, 2]) == 1 def test_mixed_frequencies(): assert most_frequent_element([4, 4, 1, 2, 2, 5, 4]) == 4 def test_all_unique_elements(): assert most_frequent_element([10, 20, 30, 40]) == 10","solution":"def most_frequent_element(lst): Returns the element that appears most frequently in the list. If there are multiple elements with the highest frequency, returns the one that appears first in the list. Args: lst (list): List of integers. Returns: int: The most frequent element. from collections import Counter count = Counter(lst) max_freq = max(count.values()) for element in lst: if count[element] == max_freq: return element"},{"question":"def min_delivery_time(num_vehicles, num_packages, capacities, delivery_times): Calculate the minimum total delivery time for given packages and vehicles. Parameters: - num_vehicles: int - The number of vehicles. - num_packages: int - The number of packages. - capacities: List[int] - A list containing the capacity of each vehicle. - delivery_times: List[int] - A list containing the delivery times of each package. Returns: - int: The minimum total delivery time. # Your code here def solve_delivery_problem(): Read input, solve the delivery problem and print the result for each test case. import sys input = sys.stdin.read data = input().split('n') index = 0 results = [] while index < len(data): if data[index].strip() == '0 0': break V, P = map(int, data[index].strip().split()) capacities = list(map(int, data[index + 1].strip().split())) delivery_times = list(map(int, data[index + 2].strip().split())) results.append(min_delivery_time(V, P, capacities, delivery_times)) index += 3 for result in results: print(result)","solution":"def min_delivery_time(num_vehicles, num_packages, capacities, delivery_times): delivery_times.sort() min_total_time = 0 for i in range(num_packages): min_total_time += delivery_times[i] return min_total_time def solve_delivery_problem(): import sys input = sys.stdin.read data = input().split('n') index = 0 results = [] while index < len(data): if data[index].strip() == '0 0': break V, P = map(int, data[index].strip().split()) capacities = list(map(int, data[index + 1].strip().split())) delivery_times = list(map(int, data[index + 2].strip().split())) results.append(min_delivery_time(V, P, capacities, delivery_times)) index += 3 for result in results: print(result)"},{"question":"def top_three_highest(numbers): Returns the top 3 highest unique values from the list in descending order. If there are less than 3 unique values, it returns all unique values in descending order. >>> top_three_highest([4, 1, 4, 3, 2, 5]) [5, 4, 3] >>> top_three_highest([10, 10, 10]) [10] >>> top_three_highest([]) []","solution":"def top_three_highest(numbers): Returns the top 3 highest unique values from the list in descending order. If there are less than 3 unique values, it returns all unique values in descending order. # Convert to set to get unique values unique_numbers = list(set(numbers)) # Sort the unique values in descending order unique_numbers.sort(reverse=True) # Return the top 3 or all if less than 3 unique values return unique_numbers[:3]"},{"question":"def min_length_difference(N: int, K: int, S: str) -> int: Returns the minimum possible difference between the length of the longest substring and the shortest substring after dividing the string into K contiguous non-empty substrings. Parameters: - N : int : The length of the string S. - K : int : The number of substrings to divide into. - S : str : The string consisting of N lowercase English letters. Returns: - int : The minimum possible difference between the length of the longest and the shortest substring. >>> min_length_difference(7, 3, \\"abcdefg\\") 1 >>> min_length_difference(5, 5, \\"abcde\\") 0 >>> min_length_difference(8, 4, \\"abcdefgh\\") 0","solution":"def min_length_difference(N, K, S): Returns the minimum possible difference between the length of the longest substring and the shortest substring after dividing the string into K contiguous non-empty substrings. base_length = N // K extra = N % K return 1 if extra > 0 else 0"},{"question":"def min_additional_mana(test_cases): Calculate the minimal amount of additional mana required to ensure all Alphas can win over the Betas in each test case. Parameters: test_cases (list): List of dictionaries representing each test case. Each dictionary contains: - \\"N\\": int, number of Alphas. - \\"M\\": int, number of Betas. - \\"alphas\\": list of tuples, each (mana, level). - \\"betas\\": list of tuples, each (mana, level). Returns: list: List of integers representing the minimum additional mana required for each test case. >>> min_additional_mana([ {\\"N\\": 2, \\"M\\": 3, \\"alphas\\": [(30, 1), (45, 2)], \\"betas\\": [(25, 1), (30, 2), (15, 2)]}, {\\"N\\": 1, \\"M\\": 1, \\"alphas\\": [(20, 3)], \\"betas\\": [(25, 3)]} ]) [0, 5] pass","solution":"def min_additional_mana(test_cases): results = [] for case in test_cases: N, M = case[\\"N\\"], case[\\"M\\"] alphas = case[\\"alphas\\"] betas = case[\\"betas\\"] additional_mana_required = 0 # Group alphas and betas by their expertise levels from collections import defaultdict alphas_by_level = defaultdict(list) betas_by_level = defaultdict(list) for mana, level in alphas: alphas_by_level[level].append(mana) for mana, level in betas: betas_by_level[level].append(mana) # Sort mana levels in ascending order to minimize additional mana in duels for level in alphas_by_level: if level in betas_by_level: alphas_by_level[level].sort() betas_by_level[level].sort() for level in betas_by_level: if level in alphas_by_level: alpha_manas = alphas_by_level[level] beta_manas = betas_by_level[level] while alpha_manas and beta_manas: if alpha_manas[-1] >= beta_manas[-1]: alpha_manas[-1] -= beta_manas.pop() else: additional_mana_required += beta_manas[-1] - alpha_manas[-1] beta_manas.pop() alpha_manas.pop() else: for mana in betas_by_level[level]: additional_mana_required += mana results.append(additional_mana_required) return results"},{"question":"def can_sort_by_reversing_subarray(arr): Determines if it is possible to sort the entire sequence in non-decreasing order by performing the described operation, which is reversing any subarray. >>> can_sort_by_reversing_subarray([4, 3, 2, 1, 5]) 'YES' >>> can_sort_by_reversing_subarray([1, 2, 3]) 'YES' >>> can_sort_by_reversing_subarray([2, 1, 4, 3]) 'NO' >>> can_sort_by_reversing_subarray([3, 1, 2, 5, 4, 6]) 'NO' pass def process_test_cases(t, test_cases): Process all the test cases and return the result for each case. >>> process_test_cases(4, [ ... (5, [4, 3, 2, 1, 5]), ... (3, [1, 2, 3]), ... (4, [2, 1, 4, 3]), ... (6, [3, 1, 2, 5, 4, 6]), ... ]) ['YES', 'YES', 'NO', 'NO'] pass","solution":"def can_sort_by_reversing_subarray(arr): Determines if it is possible to sort the entire sequence in non-decreasing order by performing the described operation, which is reversing any subarray. n = len(arr) # Create a sorted version of the array sorted_arr = sorted(arr) # Find the first mismatch start = 0 while start < n and arr[start] == sorted_arr[start]: start += 1 # Find the last mismatch end = n - 1 while end >= 0 and arr[end] == sorted_arr[end]: end -= 1 # If no mismatch, array is already sorted or single element array if start >= end: return \\"YES\\" # Reverse the suspected sub-array and check if it matches the sorted array if arr[start:end+1][::-1] == sorted_arr[start:end+1]: return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): Process all the test cases and return the result for each case. results = [] for n, arr in test_cases: results.append(can_sort_by_reversing_subarray(arr)) return results"},{"question":"def rotate_string(S: str, N: int) -> str: Rotates the string S to the right N times. Parameters: S (str): The input string consisting of lowercase letters. N (int): The number of times to rotate the string. Returns: str: The rotated string. Examples: >>> rotate_string(\\"abcdef\\", 2) 'efabcd' >>> rotate_string(\\"abcdef\\", 8) 'efabcd' >>> rotate_string(\\"a\\", 1) 'a' >>> rotate_string(\\"abcdef\\", 12) 'abcdef'","solution":"def rotate_string(S, N): Rotates the string S to the right N times. Parameters: S (str): The input string consisting of lowercase letters. N (int): The number of times to rotate the string. Returns: str: The rotated string. length = len(S) N = N % length # To handle cases where N is larger than the length of S return S[-N:] + S[:-N]"},{"question":"def letter_combinations(digits: str) -> list: Given a string containing only digits, return an array containing all possible letter combinations that the number could represent as per the mapping on a telephone keypad. The mappings are as follows: 1 -> \\"\\" 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" 0 -> \\"\\" >>> letter_combinations(\\"23\\") [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"]","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent as per the mapping on a telephone keypad. if not digits: return [] mapping = { '1': \\"\\", '2': \\"abc\\", '3': \\"def\\", '4': \\"ghi\\", '5': \\"jkl\\", '6': \\"mno\\", '7': \\"pqrs\\", '8': \\"tuv\\", '9': \\"wxyz\\", '0': \\"\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return letters = mapping[digits[index]] for letter in letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def parse_logs_and_compute_statistics(logs: List[str]) -> List[str]: Parse a list of transaction logs and compute basic statistics for each stock symbol. Each transaction log is a string in the format \\"TIMESTAMP ACTION SYMBOL PRICE\\". Returns a list of results containing the symbol, highest price, lowest price, and average price (rounded to 2 decimal places) for each stock symbol. >>> logs = [ ... \\"2023-01-01 09:00:00 BUY APPLE 150.00\\", ... \\"2023-01-01 10:00:00 SELL APPLE 155.00\\", ... \\"2023-01-01 11:00:00 BUY GOOGLE 1000.00\\", ... \\"2023-01-01 12:00:00 SELL GOOGLE 1015.00\\", ... \\"2023-01-01 13:00:00 BUY APPLE 152.00\\"] >>> parse_logs_and_compute_statistics(logs) [\\"APPLE\\", \\"155.00\\", \\"150.00\\", \\"152.33\\", \\"GOOGLE\\", \\"1015.00\\", \\"1000.00\\", \\"1007.50\\"] >>> logs = [ ... \\"2023-01-01 09:00:00 BUY MICROSOFT 250.00\\", ... \\"2023-01-01 10:00:00 SELL MICROSOFT 245.00\\", ... \\"2023-01-01 11:00:00 BUY MICROSOFT 248.00\\", ... \\"2023-01-01 12:00:00 SELL MICROSOFT 255.00\\", ... \\"2023-01-01 13:00:00 BUY AMAZON 3500.00\\", ... \\"2023-01-01 14:00:00 SELL AMAZON 3490.00\\"] >>> parse_logs_and_compute_statistics(logs) [\\"AMAZON\\", \\"3500.00\\", \\"3490.00\\", \\"3495.00\\", \\"MICROSOFT\\", \\"255.00\\", \\"245.00\\", \\"249.50\\"] >>> logs = [\\"2023-01-01 09:00:00 BUY TESLA 780.00\\"] >>> parse_logs_and_compute_statistics(logs) [\\"TESLA\\", \\"780.00\\", \\"780.00\\", \\"780.00\\"] >>> logs = [ ... \\"2023-01-01 09:00:00 BUY TESLA 780.00\\", ... \\"2023-01-01 10:00:00 SELL TESLA 780.00\\", ... \\"2023-01-01 11:00:00 BUY TESLA 780.00\\"] >>> parse_logs_and_compute_statistics(logs) [\\"TESLA\\", \\"780.00\\", \\"780.00\\", \\"780.00\\"]","solution":"def parse_logs_and_compute_statistics(logs): from collections import defaultdict stock_data = defaultdict(list) for log in logs: parts = log.split() timestamp = parts[0] + ' ' + parts[1] action = parts[2] symbol = parts[3] price = float(parts[4]) stock_data[symbol].append(price) result = [] for symbol in sorted(stock_data.keys()): prices = stock_data[symbol] highest_price = max(prices) lowest_price = min(prices) average_price = sum(prices) / len(prices) result.append(symbol) result.append(f\\"{highest_price:.2f}\\") result.append(f\\"{lowest_price:.2f}\\") result.append(f\\"{average_price:.2f}\\") return result"},{"question":"def calculate_expression(expression: str) -> int: Evaluates the arithmetic expression according to the order of operations (PEMDAS/BODMAS). >>> calculate_expression(\\"3+2*2\\") 7 >>> calculate_expression(\\"3/2\\") 1 >>> calculate_expression(\\"2*3+4\\") 10 >>> calculate_expression(\\"8/4-1\\") 1 def process_expressions(expressions: List[str]) -> List[int]: Takes a list of arithmetic expressions and returns their evaluated results. >>> process_expressions([\\"3+2*2\\", \\"3/2\\"]) [7, 1]","solution":"def calculate_expression(expression): Evaluates the arithmetic expression according to the order of operations (PEMDAS/BODMAS). # Step 1: Convert the expression to a list of characters for easier manipulation tokens = list(expression) # Step 2: Evaluate * and / first i = 0 while i < len(tokens): if tokens[i] == '*' or tokens[i] == '/': operator = tokens[i] left_operand = int(tokens[i-1]) right_operand = int(tokens[i+1]) if operator == '*': result = left_operand * right_operand elif operator == '/': result = left_operand // right_operand tokens = tokens[:i-1] + [str(result)] + tokens[i+2:] i -= 1 # Adjust index to recheck the modified parts else: i += 1 # Step 3: Evaluate + and - i = 0 while i < len(tokens): if tokens[i] == '+' or tokens[i] == '-': operator = tokens[i] left_operand = int(tokens[i-1]) right_operand = int(tokens[i+1]) if operator == '+': result = left_operand + right_operand elif operator == '-': result = left_operand - right_operand tokens = tokens[:i-1] + [str(result)] + tokens[i+2:] i -= 1 # Adjust index to recheck the modified parts else: i += 1 # The final result will be the only remaining token return int(tokens[0]) def process_expressions(expressions): Takes a list of arithmetic expressions and returns their evaluated results. results = [] for expression in expressions: result = calculate_expression(expression) results.append(result) return results"},{"question":"import random def deal_cards(num_cards: int) -> list: Simulates shuffling a standard deck of 52 cards and deals a specified number of cards. Args: num_cards (int): The number of cards to deal. Returns: list: A list of dealt cards in the format \\"{rank} of {suit}\\". If num_cards > 52, returns a string message indicating there aren't enough cards. suits = ['hearts', 'diamonds', 'clubs', 'spades'] ranks = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'] if num_cards > 52: return \\"Not enough cards to deal\\" deck = [f\\"{rank} of {suit}\\" for suit in suits for rank in ranks] random.shuffle(deck) return deck[:num_cards] # Test cases import pytest def test_deal_correct_number_of_cards(): num_cards = 5 dealt_cards = deal_cards(num_cards) assert len(dealt_cards) == num_cards def test_deal_all_cards(): num_cards = 52 dealt_cards = deal_cards(num_cards) assert len(dealt_cards) == num_cards def test_more_than_52_cards(): num_cards = 60 result = deal_cards(num_cards) assert result == \\"Not enough cards to deal\\" def test_dealt_cards_unique(): num_cards = 10 dealt_cards = deal_cards(num_cards) assert len(set(dealt_cards)) == num_cards def test_shuffling_effect(): num_cards = 5 dealt_cards1 = deal_cards(num_cards) dealt_cards2 = deal_cards(num_cards) assert dealt_cards1 != dealt_cards2 if __name__ == \\"__main__\\": pytest.main()","solution":"import random def deal_cards(num_cards): Simulates shuffling a standard deck of 52 cards and deals a specified number of cards. Args: num_cards (int): The number of cards to deal. Returns: list: A list of dealt cards in the format \\"{rank} of {suit}\\". If num_cards > 52, returns a string message indicating there aren't enough cards. suits = ['hearts', 'diamonds', 'clubs', 'spades'] ranks = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'] if num_cards > 52: return \\"Not enough cards to deal\\" deck = [f\\"{rank} of {suit}\\" for suit in suits for rank in ranks] random.shuffle(deck) return deck[:num_cards]"},{"question":"def has_subarray_with_sum(n: int, k: int, array: List[int]) -> str: Determine if there exists a contiguous subarray with sum equal to k. >>> has_subarray_with_sum(5, 10, [1, 2, 3, 4, 5]) 'YES' >>> has_subarray_with_sum(4, 7, [1, -1, 5, 1]) 'NO' >>> has_subarray_with_sum(1, 5, [5]) 'YES' >>> has_subarray_with_sum(1, 5, [-5]) 'NO' >>> has_subarray_with_sum(5, -10, [-1, -2, -3, -4, -5]) 'YES' >>> has_subarray_with_sum(5, -10, [-1, -2, -3, -1, -1]) 'NO' >>> has_subarray_with_sum(5, 0, [0, 0, 0, 0, 0]) 'YES' >>> has_subarray_with_sum(5, 15, [1, 2, 3, 4, 5]) 'YES' >>> has_subarray_with_sum(5, 20, [1, 2, 3, 4, 5]) 'NO'","solution":"def has_subarray_with_sum(n, k, array): Returns \\"YES\\" if there exists a contiguous subarray with sum equal to k. Otherwise, returns \\"NO\\". current_sum = 0 sum_dict = {} for i in range(n): current_sum += array[i] if current_sum == k: return \\"YES\\" if (current_sum - k) in sum_dict: return \\"YES\\" sum_dict[current_sum] = i return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) array = list(map(int, data[2:])) print(has_subarray_with_sum(n, k, array)) if __name__ == \\"__main__\\": main()"},{"question":"def can_form_arithmetic_sequence(arr): Determines if the elements of the array can be rearranged to form an arithmetic sequence. Args: arr (list of int): The array of integers. Returns: str: \\"YES\\" if the array can be rearranged to form an arithmetic sequence, otherwise \\"NO\\". >>> can_form_arithmetic_sequence([3, 5, 1]) == \\"YES\\" >>> can_form_arithmetic_sequence([1, 2, 4, 8]) == \\"NO\\"","solution":"def can_form_arithmetic_sequence(arr): Determines if the elements of the array can be rearranged to form an arithmetic sequence. Args: arr (list of int): The array of integers. Returns: str: \\"YES\\" if the array can be rearranged to form an arithmetic sequence, otherwise \\"NO\\". arr.sort() difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] != difference: return \\"NO\\" return \\"YES\\""},{"question":"def min_operations_to_make_distinct(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and corresponding arrays, determine the minimum number of operations to make all elements in each array distinct. >>> min_operations_to_make_distinct(2, [(3, [2, 1, 2]), (4, [1, 1, 1, 1])]) [1, 3]","solution":"def min_operations_to_make_distinct(t, cases): results = [] for m, b in cases: count = {} operations = 0 for num in b: if num not in count: count[num] = 0 count[num] += 1 for num in b: while count[num] > 1: operations += 1 new_num = num while new_num in count: new_num += 1 count[new_num] = 1 count[num] -= 1 results.append(operations) return results"},{"question":"def count_vertical_and_right(dominoes: str) -> int: Returns the count of dominoes that are either vertical or fallen to the right. >>> count_vertical_and_right(\\"|||////||\\") 7 >>> count_vertical_and_right(\\"/////\\") 0 >>> count_vertical_and_right(\\"|||||\\") 6 pass","solution":"def count_vertical_and_right(dominoes): Returns the count of dominoes that are either vertical or fallen to the right. :param dominoes: A string representing the state of each domino. :return: An integer count of vertical ('|') and fallen to the right ('') dominoes. count = 0 for domino in dominoes: if domino == '|' or domino == '': count += 1 return count"},{"question":"def minimum_weight_difference(n: int, k: int, weights: List[int]) -> int: Determine the minimum possible weight difference between the heaviest and the lightest package after items are distributed. Parameters: - n: number of items - k: number of packages - weights: list of integers representing the weights of the items Returns: - int: minimum possible weight difference Examples: >>> minimum_weight_difference(5, 2, [8, 1, 7, 3, 9]) == 2 >>> minimum_weight_difference(6, 3, [5, 8, 6, 4, 7, 2]) == 1 pass # Your code goes here","solution":"def minimum_weight_difference(n, k, weights): Determine the minimum possible weight difference between the heaviest and the lightest package. Parameters: - n: number of items - k: number of packages - weights: list of integers representing the weights of the items Returns: - int: minimum possible weight difference # Sort weights in descending order weights.sort(reverse=True) # Initialize an array to store package weights package_weights = [0] * k # Distribute items into packages for weight in weights: # Find the package with the minimum weight currently min_index = package_weights.index(min(package_weights)) # Add the current item weight to this package package_weights[min_index] += weight # The difference between the heaviest and lightest package return max(package_weights) - min(package_weights)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Given a string s, return the lexicographically smallest string after deleting exactly one character. >>> lexicographically_smallest_string(\\"abc\\") 'ab' >>> lexicographically_smallest_string(\\"abxyz\\") 'abxy' def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases for the problem. >>> process_test_cases(2, [(3, \\"abc\\"), (5, \\"abxyz\\")]) ['ab', 'abxy'] >>> process_test_cases(3, [(4, \\"bcda\\"), (3, \\"aab\\"), (3, \\"bca\\")]) ['bca', 'aa', 'ba']","solution":"def lexicographically_smallest_string(s): Given a string s, return the lexicographically smallest string after deleting exactly one character. n = len(s) # Initialize the result to be the string with the first character removed min_string = s[1:] for i in range(1, n): # Generate a string with the i-th character removed temp_string = s[:i] + s[i+1:] # Update the min_string if temp_string is lexicographically smaller if temp_string < min_string: min_string = temp_string return min_string def process_test_cases(T, test_cases): Process multiple test cases for the problem. results = [] for i in range(T): N, S = test_cases[i] results.append(lexicographically_smallest_string(S)) return results"},{"question":"def first_repeating_character(s: str) -> str: Returns the first repeating character in the string s. If no character repeats, return '-1'. >>> first_repeating_character(\\"abca\\") == 'a' True >>> first_repeating_character(\\"abcdef\\") == '-1' True >>> first_repeating_character(\\"geeksforgeeks\\") == 'e' True","solution":"def first_repeating_character(s): Returns the first repeating character in the string s. If no character repeats, return '-1'. seen = set() for char in s: if char in seen: return char seen.add(char) return '-1'"},{"question":"import math from typing import List, Tuple def is_covered(W: int, H: int, sensors: List[Tuple[int, int]], R: int) -> bool: Check if the sensors can cover the entire rectangular area. Parameters: W (int): Width of the rectangular area. H (int): Height of the rectangular area. sensors (List[Tuple[int, int]]): List of tuples representing the coordinates of each sensor. R (int): Radius of each sensor. Returns: bool: True if the sensors can cover the entire rectangular area, otherwise False. def analyze_coverage(test_cases: List[Tuple[Tuple[int, int, int, int], List[Tuple[int, int]]]]) -> List[str]: Analyze multiple test cases for sensor coverage. Parameters: test_cases (List[Tuple[Tuple[int, int, int, int], List[Tuple[int, int]]]]): List of test cases. Returns: List[str]: List of results for each test case. def read_input_data(input_data: str) -> List[Tuple[Tuple[int, int, int, int], List[Tuple[int, int]]]]: Read the input data and parse into test cases. Parameters: input_data (str): Input data as a string. Returns: List[Tuple[Tuple[int, int, int, int], List[Tuple[int, int]]]]: Parsed test cases. def main(input_data: str) -> None: Main function to analyze the coverage and print the results. Parameters: input_data (str): Input data as a string. test_cases = read_input_data(input_data) results = analyze_coverage(test_cases) for result in results: print(result) # Example usage: if __name__ == \\"__main__\\": input_data = 5 5 4 2 1 1 1 4 4 1 4 4 10 10 5 3 1 1 1 9 9 1 9 9 5 5 0 main(input_data)","solution":"import math def is_covered(W, H, sensors, R): # A function to check if each point in the rectanglar area is covered by at least one sensor def point_covered(x, y): for (sx, sy) in sensors: if math.sqrt((sx - x)**2 + (sy - y)**2) <= R: return True return False for x in range(W + 1): for y in range(H + 1): if not point_covered(x, y): # If any point in the rectangle is not covered return False return True def analyze_coverage(test_cases): results = [] case_num = 1 for case in test_cases: W, H, N, R = case[0] sensors = case[1] if is_covered(W, H, sensors, R): results.append(f\\"Case {case_num}: Yes\\") else: results.append(f\\"Case {case_num}: No\\") case_num += 1 return results def read_input_data(input_data): test_cases = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): first_line = list(map(int, lines[i].split())) if first_line == [0]: break W, H, N, R = first_line sensors = [tuple(map(int, lines[i+j+1].split())) for j in range(N)] test_cases.append(((W, H, N, R), sensors)) i += N + 1 return test_cases def main(input_data): test_cases = read_input_data(input_data) results = analyze_coverage(test_cases) for result in results: print(result) # Example usage: if __name__ == \\"__main__\\": input_data = 5 5 4 2 1 1 1 4 4 1 4 4 10 10 5 3 1 1 1 9 9 1 9 9 5 5 0 main(input_data)"},{"question":"def is_beautiful_array(n: int, arr: List[int]) -> str: Checks if an array is beautiful. An array is beautiful if for any two elements a_i and a_j (1 ≤ i < j ≤ n), a_i is divisible by a_j or a_j is divisible by a_i. :param n: Size of the array :param arr: List of integers :return: \\"YES\\" if the array is beautiful, otherwise \\"NO\\" >>> is_beautiful_array(3, [4, 8, 16]) 'YES' >>> is_beautiful_array(4, [5, 10, 15, 20]) 'NO'","solution":"def is_beautiful_array(n, arr): Checks if an array is beautiful. An array is beautiful if for any two elements a_i and a_j (1 ≤ i < j ≤ n), a_i is divisible by a_j or a_j is divisible by a_i. :param n: Size of the array :param arr: List of integers :return: \\"YES\\" if the array is beautiful, otherwise \\"NO\\" sorted_arr = sorted(arr) for i in range(n): for j in range(i + 1, n): if sorted_arr[j] % sorted_arr[i] != 0: return \\"NO\\" return \\"YES\\""},{"question":"def smallest_lexicographical_rotation(S: str) -> str: Finds the smallest lexicographical rotation of S. >>> smallest_lexicographical_rotation(\\"bca\\") \\"abc\\" >>> smallest_lexicographical_rotation(\\"abc\\") \\"abc\\" >>> smallest_lexicographical_rotation(\\"cab\\") \\"abc\\" def process_test_cases(T: int, cases: List[str]) -> List[str]: Processes T test cases and returns a list of smallest lexicographical rotations for each case. >>> process_test_cases(3, [\\"bca\\", \\"abc\\", \\"cab\\"]) ['abc', 'abc', 'abc']","solution":"def smallest_lexicographical_rotation(S): Finds the smallest lexicographical rotation of S. doubled_S = S + S N = len(S) rotations = [doubled_S[i:i+N] for i in range(N)] return min(rotations) def process_test_cases(T, cases): results = [] for i in range(T): results.append(smallest_lexicographical_rotation(cases[i])) return results"},{"question":"def min_enclosed_area(n: int, k: int) -> int: Calculate the minimum enclosed area of the polygon that can be formed. The polygon is formed by drawing lines with white and black chalk according to the game rules. Parameters: n (int): The total number of friends and thus the number of segments to be drawn. k (int): The initial length of the horizontal white line. Returns: int: The minimum enclosed area of the polygon. >>> min_enclosed_area(3, 1) 1 >>> min_enclosed_area(4, 3) 2","solution":"def min_enclosed_area(n, k): # For minimum enclosed area, we need the smallest rectangle (polygon) # possible. Starting with a horizontal white line of length k. # The smallest rectangle would be a k x 1, which means we need only # 3 more segments to complete the rectangle (if n >= 3). # If n < 3, it's impossible to form a polygon if n < 3: return 0 # For the 3 segments, they form a k x 1 rectangle, thus the area inside is k-1 # (linear dimension of k minus the white line used as one side) return k * 1"},{"question":"def count_islands(grid: List[List[str]]) -> int: Returns the number of islands in the given grid. An island is surrounded by water and is formed by connecting adjacent land horizontally or vertically. You may assume all four edges of the grid are surrounded by water. >>> count_islands([['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0']]) 1 >>> count_islands([['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]) 3 >>> count_islands([['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0']]) 0 >>> count_islands([['1', '1'], ['1', '1']]) 1 >>> count_islands([['1', '0', '0', '1'], ['0', '1', '1', '0'], ['0', '0', '0', '0'], ['1', '0', '0', '1']]) 5","solution":"def count_islands(grid): Returns the number of islands in the given grid. if not grid: return 0 n = len(grid) m = len(grid[0]) def dfs(i, j): # If out of bounds or at water, return immediately if i < 0 or j < 0 or i >= n or j >= m or grid[i][j] == '0': return # Mark the current cell as visited by setting it to '0' grid[i][j] = '0' # Visit all adjacent cells (4-directionally) dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': island_count += 1 dfs(i, j) return island_count"},{"question":"def isKPalindrome(S: str, K: int) -> bool: Determine if it's possible to remove exactly K characters from the string S so that the resulting string is a palindrome. >>> isKPalindrome(\\"abca\\", 1) True >>> isKPalindrome(\\"abcde\\", 2) False >>> isKPalindrome(\\"aba\\", 0) True >>> isKPalindrome(\\"abbacdef\\", 4) True >>> isKPalindrome(\\"abcdba\\", 2) True >>> isKPalindrome(\\"abcba\\", 3) True >>> isKPalindrome(\\"abcde\\", 3) False >>> isKPalindrome(\\"\\", 0) True >>> isKPalindrome(\\"a\\", 0) True >>> isKPalindrome(\\"a\\", 1) True >>> isKPalindrome(\\"ab\\", 1) True >>> isKPalindrome(\\"aa\\", 0) True","solution":"def isKPalindrome(S, K): Determine if it's possible to remove exactly K characters from S to make it a palindrome. n = len(S) # Helper function to find the length of the Longest Common Subsequence (LCS) def LCS(str1, str2): dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][n] rev_S = S[::-1] lcs_length = LCS(S, rev_S) # Minimum number of deletions to make the string a palindrome min_deletions = n - lcs_length return min_deletions <= K"},{"question":"def longest_contiguous_subsequence(arr): Returns the length of the longest contiguous subsequence where the absolute difference between any two consecutive elements is at most 1. >>> longest_contiguous_subsequence([5]) 1 >>> longest_contiguous_subsequence([1, 3, 5, 7]) 1 >>> longest_contiguous_subsequence([4, 4, 4, 4]) 4 >>> longest_contiguous_subsequence([1, 2, 2, 3, 5, 6, 7]) 4 >>> longest_contiguous_subsequence([1, 2, 5, 6, 7]) 3 >>> longest_contiguous_subsequence([-1, 0, 1, 2, 3, 2, 1]) 7 >>> longest_contiguous_subsequence([1, 2, 2, 1, 3, 3, 4, 1, 2]) 4 >>> longest_contiguous_subsequence([]) 0","solution":"def longest_contiguous_subsequence(arr): Returns the length of the longest contiguous subsequence where the absolute difference between any two consecutive elements is at most 1. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def maximum_chocolates(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Returns the maximum number of chocolates Anita can buy for each test case without spending her emergency savings. :param T: int, number of test cases :param test_cases: list of tuples, where each tuple contains three integers C, D, S :return: list of integers, maximum number of chocolates for each test case >>> maximum_chocolates(3, [(10, 100, 20), (5, 50, 10), (2, 30, 5)]) [8, 8, 12] >>> maximum_chocolates(1, [(10, 50, 60)]) [0] >>> maximum_chocolates(2, [(2, 20, 10), (5, 15, 5)]) [5, 2] >>> maximum_chocolates(1, [(100, 1000, 0)]) [10] >>> maximum_chocolates(3, [(1, 3, 1), (2, 4, 1), (3, 9, 4)]) [2, 1, 1] >>> maximum_chocolates(1, [(5, 10, 10)]) [0] >>> maximum_chocolates(1, [(10, 5, 10)]) [0] >>> maximum_chocolates(1, [(2, 5, 10)]) [0] >>> maximum_chocolates(1, [(10, 20, 10)]) [1]","solution":"def maximum_chocolates(T, test_cases): Returns the maximum number of chocolates Anita can buy for each test case. :param T: int, number of test cases :param test_cases: list of tuples, where each tuple contains three integers C, D, S :return: list of integers, maximum number of chocolates for each test case results = [] for C, D, S in test_cases: if D < S: results.append(0) else: max_chocolates = (D - S) // C results.append(max_chocolates) return results"},{"question":"def longest_valid_parentheses(s: str) -> int: Returns the length of the longest well-formed parentheses substring in s. >>> longest_valid_parentheses(\\"(()())\\") 6 >>> longest_valid_parentheses(\\"))((\\") 0 >>> longest_valid_parentheses(\\"()(()))))\\") 6 pass def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases to find the length of the longest well-formed parentheses substring. >>> process_test_cases(3, [\\"(()())\\", \\"))((\\", \\"()(()))))\\"]) [6, 0, 6] >>> process_test_cases(2, [\\"((()))\\", \\"\\"]) [6, 0] pass","solution":"def longest_valid_parentheses(s): Returns the length of the longest well-formed parentheses substring in s. max_len = 0 stack = [-1] for i, ch in enumerate(s): if ch == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(longest_valid_parentheses(s)) return results"},{"question":"def max_non_adjacent_sum(nums): This function calculates the maximum sum of non-adjacent numbers in the given list. :param nums: List[int] - list of integers :return: int - maximum sum of non-adjacent numbers def solve_multiple_cases(test_cases): This function processes multiple test cases and applies the max_non_adjacent_sum function to each case. :param test_cases: List[List[int]] - list of test cases, where each test case is a list of integers :return: List[int] - list of results for each test case # Unit test examples for the functions if __name__ == \\"__main__\\": assert max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 assert max_non_adjacent_sum([3, 2, 7, 10]) == 13 assert max_non_adjacent_sum([]) == 0 assert max_non_adjacent_sum([1, 2, 9, 4]) == 10 test_cases = [ [3, 2, 5, 10, 7], [3, 2, 7, 10], [3, 2, 5], [] ] expected = [15, 13, 8, 0] assert solve_multiple_cases(test_cases) == expected","solution":"def max_non_adjacent_sum(nums): This function calculates the maximum sum of non-adjacent numbers in the given list. :param nums: List[int] - list of integers :return: int - maximum sum of non-adjacent numbers if not nums: return 0 incl = 0 excl = 0 for num in nums: new_excl = max(excl, incl) incl = excl + num excl = new_excl return max(incl, excl) def solve_multiple_cases(test_cases): results = [] for nums in test_cases: results.append(max_non_adjacent_sum(nums)) return results"},{"question":"def createMultiplicationTable(n: int) -> list: Creates an n x n multiplication table. Each element in the table is the product of its row and column indices. Args: n (int): The size of the multiplication table. Returns: list: A 2D array representing the n x n multiplication table. Example: >>> createMultiplicationTable(3) [[1, 2, 3], [2, 4, 6], [3, 6, 9]] >>> createMultiplicationTable(5) [[1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20], [5, 10, 15, 20, 25]]","solution":"def createMultiplicationTable(n): Creates an n x n multiplication table. table = [] for i in range(1, n+1): row = [] for j in range(1, n+1): row.append(i * j) table.append(row) return table"},{"question":"def maxJobs(jobs): Returns a list of job names that can be scheduled without overlapping. Parameters: jobs (List[Tuple[str, int, int]]): A list of tuples where each tuple contains a job name, start time, and end time. Returns: List[str]: A list of job names that can be scheduled without overlapping. >>> maxJobs([ (\\"Job1\\", 1, 3), (\\"Job2\\", 2, 5), (\\"Job3\\", 4, 6), (\\"Job4\\", 5, 8), (\\"Job5\\", 7, 9) ]) [\\"Job1\\", \\"Job3\\", \\"Job5\\"] >>> maxJobs([ (\\"JobA\\", 1, 2), (\\"JobB\\", 3, 4), (\\"JobC\\", 0, 6) ]) [\\"JobA\\", \\"JobB\\"]","solution":"def maxJobs(jobs): Returns a list of job names that can be scheduled without overlapping. # Sort jobs by end time, if end time is the same, sort by lexicographical order of job name jobs.sort(key=lambda x: (x[2], x[0])) # List to store selected jobs selected_jobs = [] # Initialize the last end time to a very small number last_end_time = -1 for job in jobs: job_name, start_time, end_time = job if start_time >= last_end_time: # If the job's start time is greater or equal to the last end time, select the job selected_jobs.append(job_name) # Update the last end time last_end_time = end_time return selected_jobs"},{"question":"class BusSystem: A system to monitor and analyze the traffic of buses along specific routes. The system supports the following operations: * add_bus(bus_id, start_stop, end_stop): Add a bus with a specified range of stops. Reports \\"Bus added\\" if successful. If the bus with the same bus_id already exists, reports \\"Bus already exists\\". * update_bus(bus_id, new_start_stop, new_end_stop): Update the stops of an existing bus. Reports \\"Bus updated\\" if successful. If the bus does not exist, reports \\"Bus not found\\". * remove_bus(bus_id): Remove the bus from the system. Reports \\"Bus removed\\" if successful. If the bus does not exist, reports \\"Bus not found\\". * query_buses(stop): Print the bus IDs of all buses passing through the specified stop, sorted in ascending order. If no buses pass through the stop, prints \\"No buses\\". >>> system = BusSystem() >>> system.add_bus(100, 5, 10) 'Bus added' >>> system.query_buses(8) [100] def add_bus(self, bus_id, start_stop, end_stop): pass def update_bus(self, bus_id, new_start_stop, new_end_stop): pass def remove_bus(self, bus_id): pass def query_buses(self, stop): pass import pytest def test_add_bus(): system = BusSystem() assert system.add_bus(100, 5, 10) == \\"Bus added\\" assert system.add_bus(100, 5, 10) == \\"Bus already exists\\" assert system.add_bus(101, 2, 8) == \\"Bus added\\" def test_update_bus(): system = BusSystem() system.add_bus(100, 5, 10) assert system.update_bus(100, 6, 9) == \\"Bus updated\\" assert system.update_bus(101, 3, 9) == \\"Bus not found\\" def test_remove_bus(): system = BusSystem() system.add_bus(100, 5, 10) assert system.remove_bus(100) == \\"Bus removed\\" assert system.remove_bus(100) == \\"Bus not found\\" def test_query_buses(): system = BusSystem() system.add_bus(100, 5, 10) system.add_bus(101, 2, 8) assert system.query_buses(8) == [100, 101] assert system.update_bus(101, 3, 9) == \\"Bus updated\\" assert system.query_buses(8) == [100, 101] assert system.remove_bus(100) == \\"Bus removed\\" assert system.query_buses(6) == [101] assert system.remove_bus(101) == \\"Bus removed\\" assert system.query_buses(6) == \\"No buses\\" if __name__ == \\"__main__\\": pytest.main()","solution":"class BusSystem: def __init__(self): self.buses = {} self.stops = {} def add_bus(self, bus_id, start_stop, end_stop): if bus_id in self.buses: return \\"Bus already exists\\" else: self.buses[bus_id] = (start_stop, end_stop) for stop in range(start_stop, end_stop + 1): if stop not in self.stops: self.stops[stop] = set() self.stops[stop].add(bus_id) return \\"Bus added\\" def update_bus(self, bus_id, new_start_stop, new_end_stop): if bus_id not in self.buses: return \\"Bus not found\\" else: old_start_stop, old_end_stop = self.buses[bus_id] for stop in range(old_start_stop, old_end_stop + 1): if stop in self.stops: self.stops[stop].remove(bus_id) if not self.stops[stop]: del self.stops[stop] self.buses[bus_id] = (new_start_stop, new_end_stop) for stop in range(new_start_stop, new_end_stop + 1): if stop not in self.stops: self.stops[stop] = set() self.stops[stop].add(bus_id) return \\"Bus updated\\" def remove_bus(self, bus_id): if bus_id not in self.buses: return \\"Bus not found\\" else: start_stop, end_stop = self.buses[bus_id] del self.buses[bus_id] for stop in range(start_stop, end_stop + 1): if stop in self.stops: self.stops[stop].remove(bus_id) if not self.stops[stop]: del self.stops[stop] return \\"Bus removed\\" def query_buses(self, stop): if stop in self.stops and self.stops[stop]: return sorted(self.stops[stop]) else: return \\"No buses\\""},{"question":"def transform_and_sum_sequence(n: int, sequence: List[int]) -> int: Transforms the sequence according to the specified rules and returns the sum of the transformed sequence. :param n: The number of elements in the sequence :param sequence: List of integers representing the sequence :return: The sum of the transformed sequence >>> transform_and_sum_sequence(5, [3, -2, 0, 7, 4]) 17 >>> transform_and_sum_sequence(4, [1, 2, 3, 4]) 10 >>> transform_and_sum_sequence(3, [-1, -2, -3]) 6 >>> transform_and_sum_sequence(5, [0, 0, 0, 0, 0]) 0 >>> transform_and_sum_sequence(2, [1000, -1000]) 1999 >>> transform_and_sum_sequence(5, [-5, 5, 0, 10, 15]) 36","solution":"def transform_and_sum_sequence(n, sequence): Transforms the sequence according to the specified rules and returns the sum of the transformed sequence. :param n: The number of elements in the sequence :param sequence: List of integers representing the sequence :return: The sum of the transformed sequence transformed_sequence = [] for num in sequence: if num > 0: if num % 2 == 0: transformed_sequence.append(num - 1) else: transformed_sequence.append(num + 1) elif num < 0: transformed_sequence.append(abs(num)) else: transformed_sequence.append(num) return sum(transformed_sequence)"},{"question":"from typing import List def min_moves_through_asteroids(n: int, m: int, grid: List[str]) -> int: Returns the minimum number of moves required to reach the bottom-right corner of the grid from the top-left corner, or \\"Impossible\\" if it cannot be reached. >>> min_moves_through_asteroids(4, 4, [\\"....\\", \\".#..\\", \\".#..\\", \\"....\\"]) 6 >>> min_moves_through_asteroids(3, 3, [\\"..#\\", \\".#.\\", \\"..#\\"]) \\"Impossible\\"","solution":"from collections import deque def min_moves_through_asteroids(n, m, grid): Returns the minimum number of moves required to reach the bottom-right corner of the grid from the top-left corner, or \\"Impossible\\" if it cannot be reached. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"Impossible\\" directions = [(0, 1), (1, 0)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: r, c, dist = queue.popleft() if r == n-1 and c == m-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc] and grid[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return \\"Impossible\\""},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list where each element is the product of all the elements in the original list except the one at the current index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] def input_to_output(input_string: str) -> str: Converts the input string to the expected output string format based on the product_except_self function. >>> input_to_output(\\"1 2 3 4\\") \\"24 12 8 6\\" >>> input_to_output(\\"-1 -2 -3 -4\\") \\"-24 -12 -8 -6\\" >>> input_to_output(\\"2 3 4 5\\") \\"60 40 30 24\\"","solution":"def product_except_self(nums): Returns a list such that each element is the product of all other elements except itself. n = len(nums) if n == 0: return [] # Initialize the result array with 1 result = [1] * n # Calculate the left products left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Calculate the right products and update the result array right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result def input_to_output(input_string): nums = list(map(int, input_string.split())) result = product_except_self(nums) return ' '.join(map(str, result))"},{"question":"def make_alternating(s: str) -> str: Given a string 's' consisting of only lowercase 'a' and 'b' characters, remove the minimum number of characters to make the string alternating. >>> make_alternating(\\"aab\\") \\"ab\\" >>> make_alternating(\\"aabb\\") \\"ab\\" or \\"ba\\" >>> make_alternating(\\"abab\\") \\"abab\\" pass # Unit Tests def test_make_alternating_example1(): assert make_alternating(\\"aab\\") == \\"ab\\" def test_make_alternating_example2(): result = make_alternating(\\"aabb\\") assert result == \\"ab\\" or result == \\"ba\\" def test_make_alternating_example3(): assert make_alternating(\\"abab\\") == \\"abab\\" def test_make_alternating_single_character(): assert make_alternating(\\"a\\") == \\"a\\" assert make_alternating(\\"b\\") == \\"b\\" def test_make_alternating_empty_string(): assert make_alternating(\\"\\") == \\"\\" def test_make_alternating_longer_string(): assert make_alternating(\\"aaabbb\\") == \\"ab\\" assert make_alternating(\\"abba\\") == \\"aba\\" assert make_alternating(\\"bbaa\\") == \\"ba\\" assert make_alternating(\\"bbbaaa\\") == \\"ba\\" def test_make_alternating_already_alternating(): assert make_alternating(\\"ababab\\") == \\"ababab\\" assert make_alternating(\\"babababa\\") == \\"babababa\\"","solution":"def make_alternating(s): Returns the resultant alternating string after removing the minimum number of characters. if not s: return \\"\\" result = [s[0]] # Initialize result with the first character for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result) # Example usage: # print(make_alternating(\\"aab\\")) # Output: \\"ab\\" # print(make_alternating(\\"aabb\\")) # Output: \\"ab\\" or \\"ba\\" # print(make_alternating(\\"abab\\")) # Output: \\"abab\\""},{"question":"def maximizeBCount(s: str) -> int: Given a string s of length N consisting only of characters 'a' and 'b', transform the string such that the count of the character 'b' in the string is maximized by changing at most one contiguous substring of 'a' in the string to 'b'. >>> maximizeBCount(\\"aabba\\") 4 >>> maximizeBCount(\\"babaa\\") 4 >>> maximizeBCount(\\"ababa\\") 3","solution":"def maximizeBCount(s): Maximizes the count of 'b' in the given string s by changing at most one contiguous substring of 'a' into 'b'. :param s: string consisting of characters 'a' and 'b' :return: maximum possible count of 'b' in the transformed string current_max = 0 max_b = 0 total_b = 0 for char in s: if char == 'b': total_b += 1 for i in range(len(s)): if s[i] == 'a': current_max += 1 else: current_max = 0 max_b = max(max_b, total_b + current_max) return min(max_b, len(s)) # we cannot have more 'b's than the total length of the string"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"radar\\") True >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aabbc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"aabbccdde\\") True >>> can_form_palindrome(\\"aabbcde\\") False","solution":"from collections import Counter def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. Parameters: s (str): The input string to check. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. char_count = Counter(s) odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) return odd_counts <= 1"},{"question":"def convert_to_seconds(hours: int, minutes: int, seconds: int) -> int: Converts the provided running time into total seconds. Parameters: hours (int): Number of hours (0 <= hours <= 23). minutes (int): Number of minutes (0 <= minutes <= 59). seconds (int): Number of seconds (0 <= seconds <= 59). Returns: int: Total time in seconds. >>> convert_to_seconds(2, 15, 30) 8130 >>> convert_to_seconds(0, 45, 15) 2715 >>> convert_to_seconds(1, 0, 0) 3600","solution":"def convert_to_seconds(hours: int, minutes: int, seconds: int) -> int: Converts the provided running time into total seconds. Parameters: hours (int): Number of hours (0 <= hours <= 23). minutes (int): Number of minutes (0 <= minutes <= 59). seconds (int): Number of seconds (0 <= seconds <= 59). Returns: int: Total time in seconds. return hours * 3600 + minutes * 60 + seconds"},{"question":"def max_flowers_in_garden(n, m): Returns the maximum number of flowers that can be planted in an n x m garden without any two flowers being planted in adjacent plots. >>> max_flowers_in_garden(3, 3) 5 >>> max_flowers_in_garden(4, 4) 8 >>> max_flowers_in_garden(1, 1) 1 >>> max_flowers_in_garden(2, 2) 2 >>> max_flowers_in_garden(10, 10) 50 >>> max_flowers_in_garden(5, 4) 10","solution":"def max_flowers_in_garden(n, m): Returns the maximum number of flowers that can be planted in an n x m garden without any two flowers being planted in adjacent plots. # A simple approach can be to place flowers in a checkerboard pattern for n <= 10 and m <= 10 count = 0 for i in range(n): for j in range(m): if (i + j) % 2 == 0: count += 1 return count"},{"question":"from typing import List def can_construct(source: str, targets: List[str]) -> List[bool]: Determine if any of the target strings can be constructed from the source string by deleting zero or more characters without reordering the remaining characters. >>> can_construct(\\"abcde\\", [\\"ace\\", \\"aec\\", \\"abcd\\", \\"xyz\\"]) [True, False, True, False] >>> can_construct(\\"abcdefgh\\", [\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\", \\"efg\\", \\"fgh\\"]) [True, True, True, True, True, True] >>> can_construct(\\"abcdef\\", [\\"abcdef\\", \\"abcf\\", \\"abcfgh\\", \\"abcdefg\\", \\"cde\\", \\"ace\\"]) [True, True, False, False, True, True] >>> can_construct(\\"abcdefghijk\\", [\\"xyz\\", \\"klm\\", \\"nop\\", \\"abcdefhijz\\"]) [False, False, False, False] >>> can_construct(\\"abcde\\", [\\"a\\", \\"b\\", \\"e\\", \\"f\\"]) [True, True, True, False] >>> can_construct(\\"a\\", [\\"a\\", \\"aa\\", \\"aaa\\"]) [True, False, False] >>> can_construct(\\"abc\\", []) [] >>> can_construct(\\"a\\" * 200, [\\"a\\" * 100]) [True]","solution":"from typing import List def can_construct(source: str, targets: List[str]) -> List[bool]: def is_subsequence(s: str, t: str) -> bool: t_idx = 0 for char in s: if t_idx < len(t) and char == t[t_idx]: t_idx += 1 if t_idx == len(t): return True return t_idx == len(t) return [is_subsequence(source, target) for target in targets]"},{"question":"class TreeLinkNode: def __init__(self, x): self.val = x self.left = None self.right = None self.next = None def connect(root): Connects each node in the binary tree such that each node's 'next' pointer points to the next right node in the same level. If there is no next right node, the 'next' pointer should be set to null. :param root: Root of the binary tree :type root: TreeLinkNode from solution import TreeLinkNode, connect def test_connect(): Test the connect function with the provided input and output examples. # Example 1: root1 = TreeLinkNode(1) root1.left = TreeLinkNode(2) root1.right = TreeLinkNode(3) root1.left.left = TreeLinkNode(4) root1.left.right = TreeLinkNode(5) root1.right.right = TreeLinkNode(7) connect(root1) assert root1.next == None assert root1.left.next == root1.right assert root1.right.next == None assert root1.left.left.next == root1.left.right assert root1.left.right.next == root1.right.right assert root1.right.right.next == None # Example 2: root2 = TreeLinkNode(10) root2.left = TreeLinkNode(5) root2.right = TreeLinkNode(15) root2.left.left = TreeLinkNode(2) root2.left.right = TreeLinkNode(6) root2.right.left = TreeLinkNode(12) root2.right.right = TreeLinkNode(20) connect(root2) assert root2.next == None assert root2.left.next == root2.right assert root2.right.next == None assert root2.left.left.next == root2.left.right assert root2.left.right.next == root2.right.left assert root2.right.left.next == root2.right.right assert root2.right.right.next == None def test_connect_single_node(): Test the connect function on a tree with a single node. root = TreeLinkNode(1) connect(root) assert root.next == None def test_connect_empty_tree(): Test the connect function on an empty tree. root = None connect(root) assert root == None","solution":"class TreeLinkNode: def __init__(self, x): self.val = x self.left = None self.right = None self.next = None def connect(root): Connects each node in the binary tree such that each node's 'next' pointer points to the next right node in the same level. If there is no next right node, the 'next' pointer should be set to null. :param root: Root of the binary tree :type root: TreeLinkNode if not root: return # Start with the root node leftmost = root while leftmost: curr = leftmost prev = None leftmost = None while curr: # Iterate over the current level for child in (curr.left, curr.right): if child: if prev: prev.next = child else: leftmost = child prev = child curr = curr.next # The leftmost variable now points to the first node of the next level"},{"question":"def reconstruct_message(dictionary: List[str], corrupted_message: str) -> str: Reconstruct the original message such that it forms a valid English word from a provided dictionary. >>> reconstruct_message([\\"hello\\", \\"world\\", \\"happy\\"], \\"h?ll?\\") 'YESnhello' >>> reconstruct_message([\\"apple\\", \\"orange\\", \\"banana\\", \\"grape\\"], \\"a?pl?\\") 'YESnapple' >>> reconstruct_message([\\"cat\\", \\"dog\\", \\"fish\\"], \\"d?g?\\") 'NO' >>> reconstruct_message([\\"a\\", \\"b\\", \\"c\\"], \\"?\\") 'YESna' or 'YESnb' or 'YESnc' >>> reconstruct_message([\\"hello\\", \\"world\\", \\"python\\"], \\"hello\\") 'YESnhello' >>> reconstruct_message([\\"hello\\", \\"world\\", \\"python\\"], \\"?????\\") 'YESnhello' or 'YESnworld' or 'YESnpython'","solution":"def reconstruct_message(dictionary, corrupted_message): def possible_matches(word, corrupted_message): if len(word) != len(corrupted_message): return False for wc, cm in zip(word, corrupted_message): if cm != '?' and wc != cm: return False return True for word in dictionary: if possible_matches(word, corrupted_message): return f\\"YESn{word}\\" return \\"NO\\""},{"question":"import heapq from typing import List, Tuple def minimum_toll_fee(N: int, M: int, S: int, T: int, highways: List[Tuple[int, int, int]]) -> int: Calculate the minimum toll fee required to travel from City S to City T. If there is no possible route, return -1. Args: N (int): Number of cities M (int): Number of highways S (int): Start city T (int): Target city highways (List[Tuple[int, int, int]]): List of highways, where each highway is represented as a tuple (A_i, B_i, C_i) Returns: int: Minimum toll fee to travel from S to T, or -1 if no route exists. Examples: >>> minimum_toll_fee(4, 5, 1, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 15), (3, 4, 5), (4, 3, 2)]) 15 >>> minimum_toll_fee(4, 4, 1, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10)]) 30 >>> minimum_toll_fee(3, 2, 1, 3, [(1, 2, 10), (2, 3, 10)]) 20 def test_minimum_toll_fee(): assert minimum_toll_fee(4, 5, 1, 3, [ (1, 2, 5), (2, 3, 10), (1, 3, 15), (3, 4, 5), (4, 3, 2) ]) == 15 assert minimum_toll_fee(4, 4, 1, 4, [ (1, 2, 10), (2, 3, 10), (3, 4, 10) ]) == 30 assert minimum_toll_fee(3, 2, 1, 3, [ (1, 2, 10), (2, 3, 10) ]) == 20 assert minimum_toll_fee(3, 2, 1, 3, [ (1, 2, 10), (3, 2, 10) ]) == -1 assert minimum_toll_fee(2, 1, 1, 2, [ (1, 2, 5) ]) == 5 assert minimum_toll_fee(2, 1, 1, 2, [ (1, 2, 100000) ]) == 100000","solution":"import heapq def minimum_toll_fee(N, M, S, T, highways): graph = {i: [] for i in range(1, N+1)} for A, B, C in highways: graph[A].append((B, C)) # Using Dijkstra's algorithm to find the shortest path dist = {i: float('inf') for i in range(1, N+1)} dist[S] = 0 priority_queue = [(0, S)] while priority_queue: current_toll, u = heapq.heappop(priority_queue) if u == T: return current_toll if current_toll > dist[u]: continue for neighbor, weight in graph[u]: distance = current_toll + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if dist[T] == float('inf') else dist[T]"},{"question":"def can_form_equilateral_triangle(n: int, matchsticks: List[int]) -> str: Determine if it's possible to select three matchsticks that can form an equilateral triangle. >>> can_form_equilateral_triangle(6, [1, 1, 1, 2, 3, 4]) \\"YES\\" >>> can_form_equilateral_triangle(4, [1, 2, 3, 7]) \\"NO\\" >>> can_form_equilateral_triangle(5, [10, 10, 10, 10, 15]) \\"YES\\"","solution":"def can_form_equilateral_triangle(n, matchsticks): from collections import Counter # Count occurrences of each matchstick length matchstick_counts = Counter(matchsticks) # Check if any length occurs at least 3 times for length, count in matchstick_counts.items(): if count >= 3: return \\"YES\\" return \\"NO\\""},{"question":"def decode_string(s: str) -> str: Decodes an encoded string according to the specified rule. The encoding rule consists of k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. Note that k is guaranteed to be a positive integer. :param s: String to be decoded (1 ≤ len(s) ≤ 30) :return: Decoded string Examples: >>> decode_string(\\"3[a2[c]]\\") 'accaccacc' >>> decode_string(\\"2[abc]3[cd]ef\\") 'abcabccdcdcdef' >>> decode_string(\\"3[a]\\") 'aaa' >>> decode_string(\\"2[3[a]b]\\") 'aaabaaab' >>> decode_string(\\"abc\\") 'abc' >>> decode_string(\\"2[a2[b3[c]]]\\") 'abcccbcccabcccbccc' >>> decode_string(\\"2[a3[b2[c]]]\\") 'abccbccbccabccbccbcc' >>> decode_string(\\"1[a]\\") 'a' >>> decode_string(\\"abcd\\") 'abcd'","solution":"def decode_string(s): Decodes an encoded string according to the specified rule. :param s: String to be decoded (1 ≤ len(s) ≤ 30) :return: Decoded string stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == ']': prev_string, multiplier = stack.pop() current_string = prev_string + current_string * multiplier else: current_string += char return current_string"},{"question":"def count_palindromic_words(sentence: str) -> int: Returns the number of palindromic words in a sentence. >>> count_palindromic_words(\\"racecar anna kayak\\") 3 >>> count_palindromic_words(\\"hello world\\") 0 >>> count_palindromic_words(\\"madam arora teaches malayalam\\") 3 >>> count_palindromic_words(\\"\\") 0 >>> count_palindromic_words(\\"noon\\") 1 >>> count_palindromic_words(\\"python\\") 0","solution":"def count_palindromic_words(sentence): Returns the number of palindromic words in a sentence. words = sentence.split() palindrome_count = sum(1 for word in words if word == word[::-1]) return palindrome_count"},{"question":"def count_ways(n: int, m: int) -> int: Returns the number of ways to assign the plays to the stages such that each stage has exactly one play, and each play is performed on at least one stage. >>> count_ways(3, 2) 6 >>> count_ways(4, 3) 36 >>> count_ways(1, 1) 1 >>> count_ways(2, 2) 2 >>> count_ways(5, 2) 30 >>> count_ways(3, 4) 0 >>> count_ways(0, 3) 0 >>> count_ways(3, 0) 0","solution":"from itertools import permutations, product def count_ways(n, m): Returns the number of ways to assign the plays to the stages such that each stage has exactly one play, and each play is performed on at least one stage. if m == 0: return 0 if n < m: return 0 stages = list(range(n)) plays = list(range(m)) # Generate all possibilities of assign plays to stages count = 0 for assign in product(plays, repeat=n): if len(set(assign)) == m: count += 1 return count"},{"question":"def max_non_overlapping_appointments(n: int, appointments: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping appointments that can be scheduled. Parameters: n (int): Number of appointments. appointments (list of tuples): Each tuple contains the start and end time of an appointment. Returns: int: Maximum number of non-overlapping appointments. >>> max_non_overlapping_appointments(3, [(60, 120), (130, 170), (100, 240)]) 2 >>> max_non_overlapping_appointments(4, [(0, 30), (5, 10), (15, 20), (30, 40)]) 3","solution":"def max_non_overlapping_appointments(n, appointments): Returns the maximum number of non-overlapping appointments that can be scheduled. Parameters: n (int): Number of appointments. appointments (list of tuples): Each tuple contains the start and end time of an appointment. Returns: int: Maximum number of non-overlapping appointments. # Sort by end time appointments.sort(key=lambda x: x[1]) count = 0 last_end_time = -1 for start, end in appointments: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def contains_max_subarray(arr: List[int], k: int) -> str: Determines if there is a contiguous subarray of length at least k that contains the maximum element of the list. Parameters: arr (List[int]): List of integers. k (int): Minimum length of the subarray. Returns: str: \\"YES\\" if such a subarray exists, \\"NO\\" otherwise. >>> contains_max_subarray([2, 1, 4, 3, 5], 2) \\"YES\\" >>> contains_max_subarray([1, 2, 3, 4, 3, 2], 3) \\"YES\\" >>> contains_max_subarray([1, 2, 3], 3) \\"YES\\" >>> contains_max_subarray([1, 1, 1, 1, 1], 2) \\"YES\\" >>> contains_max_subarray([-100, -200, -300, -400, -500], 2) \\"YES\\" >>> contains_max_subarray([3, 1, 4, 1, 5, 9, 2, 6], 4) \\"YES\\" >>> contains_max_subarray([1, 2, 3, 4, 5], 1) \\"YES\\" >>> contains_max_subarray([2, 7, 1, 8, 2, 8, 1, 8], 5) \\"YES\\" >>> contains_max_subarray([0, 1, 2, 3, 0, 1, 2, 3, 2, 1], 3) \\"YES\\" >>> contains_max_subarray([10, -2, 3, 5, 1, 4, 6], 3) \\"YES\\"","solution":"def contains_max_subarray(arr, k): Returns \\"YES\\" if there is a contiguous subarray of length at least k that contains the maximum element of the list. Otherwise, returns \\"NO\\". max_elem = max(arr) n = len(arr) for i in range(n - k + 1): if max_elem in arr[i:i + k]: return \\"YES\\" return \\"NO\\""},{"question":"def can_form_palindrome(s: str) -> bool: Determine if the input string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> can_form_palindrome(\\"No 'x' in Nixon\\") True >>> can_form_palindrome(\\"abcba\\") True >>> can_form_palindrome(\\"abcde\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"Aa\\") True >>> can_form_palindrome(\\"aaAA\\") True","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Determine if the input string can be rearranged to form a palindrome. # Normalize the string to include only alphanumeric characters and ignore case s = ''.join(filter(str.isalnum, s)).lower() # Count the frequency of each character char_count = Counter(s) # Check the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd count return odd_count <= 1"},{"question":"def read_operations(m: int, p: int, operations: List[str]) -> List[int]: Returns the number of read chapters after each operation. Parameters: m (int): Number of chapters in the book. p (int): Number of operations. operations (list of str): List of operations to be performed. Returns: list of int: Number of read chapters after each operation. >>> read_operations(4, 5, [\\"READ 3\\", \\"READ 1\\", \\"READ 3\\", \\"UNREADALL\\", \\"READ 2\\"]) [1, 2, 1, 0, 1] >>> read_operations(3, 6, [\\"READ 1\\", \\"READ 2\\", \\"READ 3\\", \\"UNREADALL\\", \\"READ 3\\", \\"READ 1\\"]) [1, 2, 3, 0, 1, 2] >>> read_operations(1, 4, [\\"READ 1\\", \\"READ 1\\", \\"UNREADALL\\", \\"READ 1\\"]) [1, 0, 0, 1] >>> read_operations(4, 3, [\\"UNREADALL\\", \\"READ 3\\", \\"READ 3\\"]) [0, 1, 0] >>> read_operations(5, 5, [\\"READ 1\\", \\"READ 2\\", \\"READ 3\\", \\"READ 4\\", \\"READ 5\\"]) [1, 2, 3, 4, 5] pass","solution":"def read_operations(m, p, operations): Returns the number of read chapters after each operation. Parameters: m (int): Number of chapters in the book. p (int): Number of operations. operations (list of str): List of operations to be performed. Returns: list of int: Number of read chapters after each operation. read_status = [0] * m result = [] for operation in operations: if operation.startswith(\\"READ\\"): _, x = operation.split() x = int(x) - 1 read_status[x] = 1 - read_status[x] # Toggle the read status elif operation == \\"UNREADALL\\": read_status = [0] * m result.append(sum(read_status)) return result"},{"question":"def reorder_string(s: str) -> str: Reorders the string such that all digits come before alphabets while preserving their relative orders. >>> reorder_string(\\"a2b3c1d\\") == \\"231abcd\\" >>> reorder_string(\\"1e4f2g5h\\") == \\"1425efgh\\" >>> reorder_string(\\"abc123\\") == \\"123abc\\" >>> reorder_string(\\"123abc\\") == \\"123abc\\" >>> reorder_string(\\"a1b2c3\\") == \\"123abc\\" >>> reorder_string(\\"z2y1x\\") == \\"21zyx\\" >>> reorder_string(\\"z2y1x3\\") == \\"213zyx\\" >>> reorder_string(\\"abc\\") == \\"abc\\" >>> reorder_string(\\"123\\") == \\"123\\"","solution":"def reorder_string(s): Reorders the string such that all digits come before alphabets while preserving their relative orders. digits = [] alphabets = [] for char in s: if char.isdigit(): digits.append(char) else: alphabets.append(char) return ''.join(digits) + ''.join(alphabets)"},{"question":"from typing import List def getAllUniquePermutations(s: str) -> List[str]: Given a string s, return a list of all unique permutations of the string sorted in lexicographical order. >>> getAllUniquePermutations(\\"ABC\\") [\\"ABC\\", \\"ACB\\", \\"BAC\\", \\"BCA\\", \\"CAB\\", \\"CBA\\"] >>> getAllUniquePermutations(\\"AAB\\") [\\"AAB\\", \\"ABA\\", \\"BAA\\"]","solution":"from itertools import permutations def getAllUniquePermutations(s): Returns a list of all unique permutations of the string s sorted in lexicographical order. # Generate all permutations of the string all_perms = permutations(s) # Remove duplicates using a set and convert to a sorted list unique_perms = sorted(set([''.join(p) for p in all_perms])) return unique_perms"},{"question":"def find_task_order(n: int, m: int, priorities: List[int], dependencies: List[Tuple[int, int]]) -> str: Determines the order in which tasks should be completed taking into account their dependencies and priorities. Parameters: n (int): The number of tasks. m (int): The number of dependencies. priorities (List[int]): A list of integers representing the priorities of the tasks. dependencies (List[Tuple[int, int]]): A list of dependencies, where each tuple (u, v) means task u must be completed before task v. Returns: str: A space-separated string representing the order of tasks to be completed, or \\"Not possible\\" if there are cyclic dependencies. >>> find_task_order(4, 2, [3, 2, 5, 4], [(1, 2), (3, 4)]) '3 4 1 2' >>> find_task_order(4, 3, [4, 2, 3, 1], [(1, 2), (2, 3), (3, 1)]) 'Not possible' >>> find_task_order(3, 0, [3, 1, 2], []) '1 3 2' >>> find_task_order(5, 4, [3, 6, 1, 4, 5], [(1, 2), (1, 3), (3, 4), (4, 5)]) '2 5 4 1 3' >>> find_task_order(6, 5, [10, 9, 8, 7, 6, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) '1 2 3 4 5 6'","solution":"from collections import deque, defaultdict def find_task_order(n, m, priorities, dependencies): # Build the graph and calculate in-degrees graph = defaultdict(list) in_degree = [0] * n for u, v in dependencies: graph[u-1].append(v-1) in_degree[v-1] += 1 # Topological sorting using Kahn's algorithm zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) topological_order = [] while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topological_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Check if there was a cycle if len(topological_order) != n: return \\"Not possible\\" # Sort the topological order based on priorities in descending order topological_order.sort(key=lambda x: -priorities[x]) # Convert 0-indexed to 1-indexed return ' '.join(str(task + 1) for task in topological_order) # Example of usage: # n, m = 4, 2 # priorities = [3, 2, 5, 4] # dependencies = [(1, 2), (3, 4)] # print(find_task_order(n, m, priorities, dependencies))"},{"question":"def find_char_paths(matrix: List[List[str]], char: str) -> List[List[Tuple[int, int]]]: Write a function that takes two arguments: a character matrix (list of lists of single characters) and a single character. Your function should return a list of all possible contiguous paths in the matrix that spell out the provided single character. Paths can be formed by moving up, down, left, right, or diagonally, but you cannot revisit a cell in a single path. The output should be a list of lists, where each list represents a unique path. Within each list, each element should be a 2-tuple indicating the row and column indices of the cell in the matrix. >>> matrix = [ >>> ['C', 'O', 'D'], >>> ['O', 'D', 'E'], >>> ['D', 'E', 'D'] >>> ] >>> char = 'D' >>> find_char_paths(matrix, char) [[(0, 2)], [(1, 1)], [(2, 0)], [(2, 2)]] >>> matrix = [ >>> ['C', 'O', 'A'], >>> ['O', 'B', 'E'], >>> ['G', 'E', 'F'] >>> ] >>> char = 'D' >>> find_char_paths(matrix, char) [] >>> matrix = [ >>> ['A', 'B', 'C'], >>> ['D', 'E', 'F'], >>> ['G', 'H', 'I'] >>> ] >>> char = 'E' >>> find_char_paths(matrix, char) [[(1, 1)]] >>> matrix = [ >>> ['A', 'B', 'A'], >>> ['B', 'C', 'B'], >>> ['A', 'B', 'A'] >>> ] >>> char = 'A' >>> find_char_paths(matrix, char) [[(0, 0)], [(0, 2)], [(2, 0)], [(2, 2)]] pass","solution":"def find_char_paths(matrix, char): Find all unique paths that spell out the given character in the matrix. Paths are represented as lists of 2-tuples indicating (row, col) indices. rows = len(matrix) cols = len(matrix[0]) if rows > 0 else 0 def is_within_bounds(r, c): return 0 <= r < rows and 0 <= c < cols def search_path(r, c, path): if not is_within_bounds(r, c) or (r, c) in path: return [] if matrix[r][c] != char: return [] path.append((r, c)) # This path is valid and complete for the single character search return [path] paths = [] for row in range(rows): for col in range(cols): if matrix[row][col] == char: paths.extend(search_path(row, col, [])) return paths"},{"question":"def number_of_ways_to_fill(n: int) -> int: Returns the number of distinct ways the cars can be filled up sequentially, ensuring that no car which is already filled is used again. The result is given modulo 10^9+7. >>> number_of_ways_to_fill(3) 6 >>> number_of_ways_to_fill(4) 24","solution":"def number_of_ways_to_fill(n): Returns the number of distinct ways the cars can be filled up sequentially, ensuring that no car which is already filled is used again. MOD = 10**9 + 7 if n < 2: return 0 # The number of distinct ways to fill up \`n\` cars is simply \`n!\` (n factorial). # We compute \`n! % MOD\` to get the result. factorial = 1 for i in range(2, n + 1): factorial = (factorial * i) % MOD return factorial"},{"question":"def character_count(text: str) -> dict: Takes a string of text and returns a dictionary where the keys are unique characters (excluding spaces and special characters), and the values are the number of times each character appears in the string. >>> character_count(\\"Hello World!\\") == {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1} >>> character_count(\\"coding\\") == {'c': 1, 'o': 1, 'd': 1, 'i': 1, 'n': 1, 'g': 1} >>> character_count(\\"a1b2c3\\") == {'a': 1, '1': 1, 'b': 1, '2': 1, 'c': 1, '3': 1} >>> character_count(\\"a@bc#\\") == {'a': 1, 'b': 1, 'c': 1} >>> character_count(\\"a b c\\") == {'a': 1, 'b': 1, 'c': 1} >>> character_count(\\"\\") == {} >>> character_count(\\"AaBbCc\\") == {'A': 1, 'a': 1, 'B': 1, 'b': 1, 'C': 1, 'c': 1} >>> character_count(\\"aaAA\\") == {'a': 2, 'A': 2}","solution":"import re from collections import Counter def character_count(text): Takes a string of text and returns a dictionary where the keys are unique characters (excluding spaces and special characters) and the values are the number of times each character appears in the string. # Remove spaces and special characters using regex filtered_text = re.sub(r'[^a-zA-Z0-9]', '', text) # Count occurrence of each character char_counts = Counter(filtered_text) return dict(char_counts)"},{"question":"def convert_minutes(total_minutes): Converts total minutes into hours and minutes. Parameters: total_minutes (int): The total number of minutes to convert. Returns: tuple: A tuple containing two integers - the number of hours and the remaining minutes. pass from solution import convert_minutes def test_convert_exact_hour(): assert convert_minutes(120) == (2, 0) def test_convert_with_remaining_minutes(): assert convert_minutes(135) == (2, 15) def test_convert_zero_minutes(): assert convert_minutes(0) == (0, 0) def test_convert_less_than_hour(): assert convert_minutes(45) == (0, 45) def test_convert_large_number(): assert convert_minutes(10000) == (166, 40)","solution":"def convert_minutes(total_minutes): Converts total minutes into hours and minutes. Parameters: total_minutes (int): The total number of minutes to convert. Returns: tuple: A tuple containing two integers - the number of hours and the remaining minutes. hours = total_minutes // 60 minutes = total_minutes % 60 return hours, minutes"},{"question":"def solve(m, n, garden): Mary wants to plant new flowers in some of the empty cells but ensure that no two adjacent cells (vertically or horizontally) contain flowers. >>> solve(3, 3, [ \\".#.\\", \\"...\\", \\"..#\\" ]) 4 >>> solve(4, 4, [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ]) 8 >>> solve(1, 1, [\\"#\\"]) 0 >>> solve(1, 1, [\\".\\"]) 1 >>> solve(2, 2, [ \\".#\\", \\"#.\\" ]) 2 >>> solve(4, 5, [ \\".....\\", \\".#.#.\\", \\".....\\", \\"..#..\\" ]) 8","solution":"def max_flowers(garden): m = len(garden) n = len(garden[0]) count = 0 for r in range(m): for c in range(n): if garden[r][c] == '.': if (r == 0 or garden[r - 1][c] != 'F') and (c == 0 or garden[r][c - 1] != 'F'): garden[r][c] = 'F' count += 1 return count def solve(m, n, garden): garden_grid = [list(row) for row in garden] return max_flowers(garden_grid)"},{"question":"def process_queries(s: str, queries: List[str]) -> List[int]: Process a series of update and range queries on a string. Args: s (str): The initial string. queries (List[str]): The list of queries, each either an update or a range query. Returns: List[int]: The results of each RANGE_LEFTMOST query. >>> process_queries(\\"abcde\\", [\\"2 c 1 4\\", \\"1 2 x\\", \\"2 c 1 4\\", \\"1 1 y\\", \\"2 y 0 2\\"]) == [2, -1, 1] >>> process_queries(\\"abc\\", [\\"1 1 x\\", \\"2 x 0 2\\"]) == [1] >>> process_queries(\\"abc\\", [\\"2 d 0 2\\"]) == [-1] >>> process_queries(\\"abcd\\", [\\"1 0 x\\", \\"1 2 y\\", \\"2 x 0 3\\", \\"2 y 0 3\\", \\"1 3 z\\", \\"2 z 2 3\\"]) == [0, 2, 3] >>> process_queries(\\"aaaabbbb\\", [\\"2 a 0 7\\", \\"2 b 4 7\\", \\"2 c 0 7\\", \\"1 0 c\\", \\"2 c 0 7\\"]) == [0, 4, -1, 0]","solution":"def process_queries(s, queries): s = list(s) result = [] for query in queries: parts = query.split() if parts[0] == '1': i, c = int(parts[1]), parts[2] s[i] = c elif parts[0] == '2': c, l, r = parts[1], int(parts[2]), int(parts[3]) found = -1 for index in range(l, r + 1): if s[index] == c: found = index break result.append(found) return result # Example usage: s = \\"abcde\\" queries = [ \\"2 c 1 4\\", \\"1 2 x\\", \\"2 c 1 4\\", \\"1 1 y\\", \\"2 y 0 2\\" ] print(process_queries(s, queries)) # Output should be [2, -1, 1]"},{"question":"def longest_contiguous_subsequence(arr: List[int]) -> int: Returns the length of the longest contiguous subsequence such that the difference between the maximum and minimum elements in this subsequence is at most one. >>> longest_contiguous_subsequence([1, 2, 2, 2, 1, 3, 4]) 5 >>> longest_contiguous_subsequence([5]) 1 >>> longest_contiguous_subsequence([3, 3, 3, 3, 3]) 5 >>> longest_contiguous_subsequence([1, 3, 5, 7, 9]) 1 >>> longest_contiguous_subsequence([1, 2, 1, 2, 1, 2]) 6 >>> longest_contiguous_subsequence([10, 1, 10, 1, 10]) 1 >>> longest_contiguous_subsequence([1, 2, 3, 4, 5, 6]) 2 >>> longest_contiguous_subsequence([]) 0 >>> longest_contiguous_subsequence(list(range(1000))) 2 >>> longest_contiguous_subsequence([-1, -2, -2, -1, -1]) 5","solution":"def longest_contiguous_subsequence(arr): Returns the length of the longest contiguous subsequence such that the difference between the maximum and minimum elements in this subsequence is at most one. if not arr: return 0 max_len = 1 current_len = 1 min_val = arr[0] max_val = arr[0] for i in range(1, len(arr)): min_val = min(min_val, arr[i]) max_val = max(max_val, arr[i]) if max_val - min_val <= 1: current_len += 1 else: min_val = arr[i] max_val = arr[i] current_len = 1 for j in range(i - 1, -1, -1): if abs(arr[i] - arr[j]) <= 1: current_len += 1 min_val = min(min_val, arr[j]) max_val = max(max_val, arr[j]) else: break max_len = max(max_len, current_len) return max_len"},{"question":"def most_expensive(items, budget): Returns the most expensive item that can be bought with the given budget. If no item can be bought within the budget, returns -1. >>> most_expensive([150, 20, 35, 75, 100], 50) # Output: 35 >>> most_expensive([5, 10, 12, 8, 7], 6) # Output: 5 >>> most_expensive([300, 150, 200, 350], 100) # Output: -1 >>> most_expensive([20, 30, 50, 25], 25) # Output: 25 >>> most_expensive([60, 40, 20, 80, 100], 70) # Output: 60","solution":"def most_expensive(items, budget): Returns the most expensive item that can be bought with the given budget. If no item can be bought within the budget, returns -1. affordable_items = [item for item in items if item <= budget] if not affordable_items: return -1 return max(affordable_items)"},{"question":"def ipv4_to_binary(ip): Converts an IPv4 address in dotted-decimal notation to a binary string. Parameters: - ip (str): The IPv4 address, e.g., '192.168.0.1' Returns: - str: The binary representation of the IP address. >>> ipv4_to_binary('192.168.0.1') '11000000101010000000000000000001' >>> ipv4_to_binary('10.0.0.2') '00001010000000000000000000000010' >>> ipv4_to_binary('0.0.0.0') '00000000000000000000000000000000' >>> ipv4_to_binary('255.255.255.255') '11111111111111111111111111111111' >>> ipv4_to_binary('172.16.254.1') '10101100000100001111111000000001'","solution":"def ipv4_to_binary(ip): Converts an IPv4 address in dotted-decimal notation to a binary string. Parameters: - ip (str): The IPv4 address, e.g., '192.168.0.1' Returns: - str: The binary representation of the IP address. parts = ip.split('.') return ''.join(format(int(part), '08b') for part in parts) # Example Usage: # The output of ipv4_to_binary('192.168.0.1') should be '11000000101010000000000000000001'"},{"question":"def is_substring(pattern: str, text: str) -> str: Determine if the pattern is a substring of the text. Args: pattern (str): The pattern string to search for in the text. text (str): The text string where the search is performed. Returns: str: \\"YES\\" if the pattern is found in the text, otherwise \\"NO\\". Examples: >>> is_substring(\\"abc\\", \\"abcdefg\\") \\"YES\\" >>> is_substring(\\"hello\\", \\"worldhello\\") \\"YES\\" >>> is_substring(\\"test\\", \\"testing\\") \\"YES\\" >>> is_substring(\\"abc\\", \\"defghijk\\") \\"NO\\"","solution":"def is_substring(pattern, text): Determine if the pattern is a substring of the text. Args: pattern (str): The pattern string to search for in the text. text (str): The text string where the search is performed. Returns: str: \\"YES\\" if the pattern is found in the text, otherwise \\"NO\\". return \\"YES\\" if pattern in text else \\"NO\\""},{"question":"from typing import List, Tuple def count_distinct_bird_populations(n: int, m: int, trails: List[Tuple[int, int]], s: int) -> int: Determine the number of distinct bird populations in the subgraph of the park starting from section \`s\`. >>> count_distinct_bird_populations(4, 3, [(1, 2), (2, 3), (3, 4)], 1) 4 >>> count_distinct_bird_populations(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (4, 6)], 4) 3","solution":"def count_distinct_bird_populations(n, m, trails, s): from collections import defaultdict, deque # Build adjacency list adjacency_list = defaultdict(list) for u, v in trails: adjacency_list[u].append(v) adjacency_list[v].append(u) # Perform BFS to explore the connected component visited = [False] * (n + 1) queue = deque([s]) visited[s] = True while queue: current = queue.popleft() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) distinct_populations = sum(visited) return distinct_populations"},{"question":"def group_files_by_content(n: int, file_data: List[Tuple[int, str]]) -> List[str]: Group files by their content, ensuring that duplicates are managed efficiently. >>> group_files_by_content(5, [(101, \\"abcd\\"), (102, \\"efgh\\"), (103, \\"abcd\\"), (104, \\"ijkl\\"), (105, \\"efgh\\")]) ['101 103', '102 105', '104'] >>> group_files_by_content(4, [(201, \\"xyz\\"), (202, \\"abc\\"), (203, \\"def\\"), (204, \\"xyz\\")]) ['201 204', '202', '203'] >>> group_files_by_content(3, [(1, \\"hello\\"), (2, \\"world\\"), (3, \\"hello\\")]) ['1 3', '2']","solution":"def group_files_by_content(n, file_data): from collections import defaultdict content_to_ids = defaultdict(list) for file_id, content in file_data: content_to_ids[content].append(file_id) sorted_contents = sorted( content_to_ids.items(), key=lambda x: (-len(x[1]), x[0]) ) result = [] for content, ids in sorted_contents: result.append(\\" \\".join(map(str, sorted(ids)))) return result"},{"question":"def find_max_min_sums(n: int, k: int, nums: List[int]) -> Tuple[int, int]: Calculate the maximum and minimum possible sums by choosing exactly k integers from the given list of numbers. Args: n (int): The number of integers in the collection. k (int): The number of integers to choose. nums (List[int]): The list of integers in the collection. Returns: Tuple[int, int]: The maximum and minimum possible sums. Examples: >>> find_max_min_sums(5, 3, [1, 2, 3, 4, 5]) (12, 6) >>> find_max_min_sums(4, 2, [-1, 2, -3, 4]) (6, -4) >>> find_max_min_sums(6, 4, [-5, -3, -1, 1, 3, 5]) (8, -8)","solution":"def find_max_min_sums(n, k, nums): This function calculates the maximum and minimum possible sums by choosing exactly k integers from the given list of numbers. Parameters: n (int): The number of integers in the collection. k (int): The number of integers to choose. nums (list of int): The list of integers in the collection. Returns: tuple (int, int): The maximum and minimum possible sums. nums.sort() max_sum = sum(nums[-k:]) # sum of the largest k numbers min_sum = sum(nums[:k]) # sum of the smallest k numbers return max_sum, min_sum # Example runs: print(find_max_min_sums(5, 3, [1, 2, 3, 4, 5])) # Output: (12, 6) print(find_max_min_sums(4, 2, [-1, 2, -3, 4])) # Output: (6, -4) print(find_max_min_sums(6, 4, [-5, -3, -1, 1, 3, 5])) # Output: (8, -8)"},{"question":"def can_alice_win(N: int, K: int) -> str: Determine if Alice will win the game with given N candies and maximum K candies taken per turn. >>> can_alice_win(10, 3) \\"Alice\\" >>> can_alice_win(5, 4) \\"Bob\\" >>> can_alice_win(7, 2) \\"Alice\\" >>> can_alice_win(1000, 1) \\"Bob\\" >>> can_alice_win(1, 1) \\"Alice\\" def solve(test_cases: List[Tuple[int, int]]) -> List[str]: Solve multiple test cases to determine if Alice will win each game. >>> solve([(10, 3)]) [\\"Alice\\"] >>> solve([(5, 4)]) [\\"Bob\\"] >>> solve([(7, 2)]) [\\"Alice\\"] >>> solve([(10, 3), (5, 4), (7, 2)]) [\\"Alice\\", \\"Bob\\", \\"Alice\\"] >>> solve([(1000, 1), (1, 1)]) [\\"Bob\\", \\"Alice\\"] def main(): import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N = int(data[index]) K = int(data[index + 1]) test_cases.append((N, K)) index += 2 results = solve(test_cases) for result in results: print(result)","solution":"def can_alice_win(N, K): # Use Dynamic Programming to determine if Alice can guarantee a win dp = [False] * (N + 1) # Fill the DP table for candies in range(1, N + 1): for take in range(1, K + 1): if candies - take >= 0 and not dp[candies - take]: dp[candies] = True break return \\"Alice\\" if dp[N] else \\"Bob\\" def solve(test_cases): results = [] for N, K in test_cases: results.append(can_alice_win(N, K)) return results def main(): import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N = int(data[index]) K = int(data[index+1]) test_cases.append((N, K)) index += 2 results = solve(test_cases) for result in results: print(result)"},{"question":"def is_path_possible(m: int, n: int, field: List[str]) -> str: Determine if it's possible to reach the treasure 'T' from the start point 'S' by moving through path cells ('.'), avoiding obstacles ('#'). >>> is_path_possible(3, 3, [\\"S..\\", \\"#\\", \\".T.\\"]) == \\"NO\\" >>> is_path_possible(3, 3, [\\"S..\\", \\".#.\\", \\"..T\\"]) == \\"YES\\"","solution":"def is_path_possible(m, n, field): from collections import deque # Find start and treasure positions start = None treasure = None for i in range(m): for j in range(n): if field[i][j] == 'S': start = (i, j) elif field[i][j] == 'T': treasure = (i, j) # Define movements: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS to check reachability queue = deque([start]) visited = set() visited.add(start) while queue: x, y = queue.popleft() if (x, y) == treasure: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and field[nx][ny] != '#': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\" # Example usage: m1, n1 = 3, 3 field1 = [\\"S..\\", \\"#\\", \\".T.\\"] assert is_path_possible(m1, n1, field1) == \\"NO\\" m2, n2 = 3, 3 field2 = [\\"S..\\", \\".#.\\", \\"..T\\"] assert is_path_possible(m2, n2, field2) == \\"YES\\""},{"question":"def is_path_exists(grid: List[List[int]]) -> bool: Determine if a path exists from the top-left to the bottom-right of the grid. Args: grid: List[List[int]], the 2D grid of obstacles (1) and empty cells (0). Returns: bool: True if a path exists, False otherwise. >>> is_path_exists([[0, 0, 1], ... [0, 1, 0], ... [0, 0, 0]]) True >>> is_path_exists([[0, 1, 0, 0], ... [0, 1, 0, 1], ... [1, 0, 0, 0], ... [0, 0, 1, 0]]) False pass","solution":"def is_path_exists(grid): Determine if a path exists from the top-left to the bottom-right of the grid. Args: grid: List[List[int]], the 2D grid of obstacles (1) and empty cells (0). Returns: bool: True if a path exists, False otherwise. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return False from collections import deque # Directions for moving right, down, left, and up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Initialize the queue with the starting point queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # Check if we've reached the bottom-right corner if (x, y) == (m-1, n-1): return True # Check all adjacent cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: Determine the maximum sum you can get by selecting elements from an array with the constraint that no two selected elements are adjacent. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([-3, -2, -5, -10, -7]) 0 >>> max_non_adjacent_sum([5, 1, 1, 5]) 10 >>> max_non_adjacent_sum([0, 0, 0, 0]) 0 >>> max_non_adjacent_sum([-1, 10, -3, 7]) 17","solution":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) # Initialize two variables to store the maximum sum till the previous element and the one before it. prev1 = max(0, nums[0]) prev2 = 0 for num in nums[1:]: current = max(prev1, prev2 + num) prev2 = prev1 prev1 = current return prev1"},{"question":"def preceding_characters(S: str) -> str: Returns a new string where each character in S is replaced by the preceding character in the alphabet. If a character is 'a', it is replaced by 'z'. >>> preceding_characters('abc') 'zab' >>> preceding_characters('mno') 'lmn' >>> preceding_characters('xyz') 'wxy' >>> preceding_characters('abcdefghijklmnopqrstuvwxyz') 'zabcdefghijklmnopqrstuvwxy' >>> preceding_characters('azz') 'zyy'","solution":"def preceding_characters(S): Returns a new string where each character in S is replaced by the preceding character in the alphabet. If a character is 'a', it is replaced by 'z'. result = [] for char in S: if char == 'a': result.append('z') else: result.append(chr(ord(char) - 1)) return \\"\\".join(result)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing +, -, *, / operators and parentheses. The division operation is integer division. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"10+(2*3)\\") 16 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing +, -, *, / operators and parentheses. def calculate(ops, nums): right = nums.pop() left = nums.pop() op = ops.pop() if op == '+': nums.append(left + right) elif op == '-': nums.append(left - right) elif op == '*': nums.append(left * right) elif op == '/': nums.append(left // right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 nums = [] ops = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': ops.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 nums.append(val) i -= 1 elif expression[i] == ')': while len(ops) != 0 and ops[-1] != '(': calculate(ops, nums) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(expression[i])): calculate(ops, nums) ops.append(expression[i]) i += 1 while len(ops) != 0: calculate(ops, nums) return nums[-1]"},{"question":"def find_shortest_words(words, queries): Returns the shortest word in each query range. Args: words: List of words (strings). queries: List of tuples, where each tuple contains two integers (start, end). Returns: A list of the shortest words for each query segment. >>> find_shortest_words([\\"algorithm\\", \\"is\\", \\"fun\\", \\"and\\", \\"challenging\\"], [(1, 3), (0, 4), (2, 4)]) ['is', 'is', 'fun'] >>> find_shortest_words([\\"dynamic\\", \\"programming\\", \\"is\\", \\"quite\\", \\"powerful\\"], [(0, 1), (1, 4), (0, 4)]) ['dynamic', 'is', 'is'] # Your code here","solution":"def find_shortest_words(words, queries): Returns the shortest word in each query range. Args: words: List of words (strings). queries: List of tuples, where each tuple contains two integers (start, end). Returns: A list of the shortest words for each query segment. results = [] for start, end in queries: shortest_word = words[start] for i in range(start, end + 1): if len(words[i]) < len(shortest_word): shortest_word = words[i] results.append(shortest_word) return results"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: This function takes a list of daily temperatures and returns a list of integers representing the number of days one has to wait for a warmer temperature. If no warmer temperature exists in the future, 0 is returned. Example: >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 60, 90]) [1, 1, 0] >>> daily_temperatures([50, 50, 50]) [0, 0, 0] >>> daily_temperatures([42]) [0] >>> daily_temperatures([]) []","solution":"def daily_temperatures(temperatures): This function takes a list of daily temperatures and returns a list of integers representing the number of days one has to wait for a warmer temperature. If no warmer temperature exists in the future, 0 is returned. :param temperatures: A list of daily temperatures. :return: A list of integers with the wait time for a warmer temperature. result = [0] * len(temperatures) stack = [] # This stack will store the indices of the temperatures list. for i, temp in enumerate(temperatures): # While stack is not empty and the current temperature is greater than the temperature at index stored in stack's top while stack and temperatures[stack[-1]] < temp: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"def place_obstacles(n: int) -> List[Tuple[int, int]]: Place obstacles such that no path exists from the top-left corner to the bottom-right corner. Parameters: n (int): The size of the grid (n x n) Returns: List[Tuple[int, int]]: List of coordinates where obstacles should be placed Examples: >>> place_obstacles(2) [(2, 1), (1, 2)] >>> place_obstacles(3) [(2, 1), (1, 2), (3, 1), (1, 3)] >>> place_obstacles(4) [(2, 1), (1, 2), (3, 1), (1, 3), (4, 1), (1, 4)] >>> place_obstacles(5) [(2, 1), (1, 2), (3, 1), (1, 3), (4, 1), (1, 4), (5, 1), (1, 5)]","solution":"def place_obstacles(n): Place obstacles such that no path exists from the top-left corner to the bottom-right corner. Parameters: n (int): The size of the grid (n x n) Returns: List[Tuple[int, int]]: List of coordinates where obstacles should be placed obstacles = [] # Start from the second row and second column for i in range(2, n + 1): obstacles.append((i, 1)) # Block the first column except the first row obstacles.append((1, i)) # Block the first row except the first column return obstacles"},{"question":"from typing import List def min_steps_to_reach_end(grid: List[str]) -> int: Determine the minimum number of steps required to move from the top-left corner (0,0) to the bottom-right corner (N-1,N-1) of the grid. You can move up, down, left, or right, and you cannot move through obstacles. If it is not possible to reach the bottom-right corner, return -1. :param grid: List of strings representing the grid :return: Minimum steps to reach the end or -1 if not possible >>> min_steps_to_reach_end(['...', '.X.', '...']) 4 >>> min_steps_to_reach_end(['.X.', 'X..', '...']) -1 pass def solve(grid_cases: List[List[str]]) -> List[int]: Solve the problem given multiple test cases. :param grid_cases: List of test cases, each test case is a grid represented as a list of strings :return: List of results for each test case >>> solve([[['...', '.X.', '...'], ['.X.', 'X..', '...']]]) [4, -1] pass def process_input_output(input_str: str) -> List[int]: Process the input string and produce the required output. :param input_str: String containing the input in the defined format :return: List of results for each test case >>> process_input_output('2n3n...n.X.n...n3n.X.nX..n...n') [4, -1] pass import pytest def test_single_case_1(): input_str = \\"1n3n...n.X.n...n\\" expected_output = [4] assert process_input_output(input_str) == expected_output def test_single_case_2(): input_str = \\"1n3n.X.nX..n...n\\" expected_output = [-1] assert process_input_output(input_str) == expected_output def test_single_case_3(): input_str = \\"1n2n..n..n\\" expected_output = [2] assert process_input_output(input_str) == expected_output def test_multiple_cases(): input_str = \\"2n3n...n.X.n...n3n.X.nX..n...n\\" expected_output = [4, -1] assert process_input_output(input_str) == expected_output def test_start_blocked(): input_str = \\"1n3nX..n...n...n\\" expected_output = [-1] assert process_input_output(input_str) == expected_output def test_end_blocked(): input_str = \\"1n3n...n...n..Xn\\" expected_output = [-1] assert process_input_output(input_str) == expected_output def test_no_path(): input_str = \\"1n3n.X.nXXXn.X.n\\" expected_output = [-1] assert process_input_output(input_str) == expected_output","solution":"from collections import deque def min_steps_to_reach_end(grid): N = len(grid) if grid[0][0] == 'X' or grid[N-1][N-1] == 'X': return -1 # If start or end is blocked directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == N-1 and col == N-1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < N and 0 <= new_col < N and grid[new_row][new_col] == '.' and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1 # If no path is found def solve(grid_cases): results = [] for grid in grid_cases: results.append(min_steps_to_reach_end(grid)) return results def process_input_output(input_str): input_lines = input_str.strip().split(\\"n\\") test_cases = int(input_lines[0]) index = 1 grid_cases = [] for _ in range(test_cases): N = int(input_lines[index]) index += 1 grid = [] for _ in range(N): grid.append(input_lines[index]) index += 1 grid_cases.append(grid) results = solve(grid_cases) return results"},{"question":"def distribute_candies(n: int, candies: List[int]) -> Tuple[int, int]: Distribute the candies into groups of three. :param n: Number of bags :param candies: List of integers representing candies in each bag :return: Tuple containing the maximum number of groups of three and the number of leftover candies >>> distribute_candies(4, [7, 11, 13, 9]) (13, 1) >>> distribute_candies(3, [3, 3, 3]) (3, 0)","solution":"def distribute_candies(n, candies): Distribute the candies into groups of three. :param n: Number of bags :param candies: List of integers representing candies in each bag :return: Tuple containing the maximum number of groups of three and the number of leftover candies total_groups = 0 leftover_candies = 0 for candy in candies: total_groups += candy // 3 leftover_candies += candy % 3 # Convert leftover candies into groups of three if possible additional_groups = leftover_candies // 3 leftover_candies = leftover_candies % 3 total_groups += additional_groups return total_groups, leftover_candies"},{"question":"from typing import List, Dict def group_transactions_by_date(transactions: List[str]) -> Dict[str, List[str]]: Groups transactions by their date. Args: transactions (list of str): List of transaction strings in the format \\"YYYY-MM-DD HH:MM:SS <transaction_details>\\" Returns: dict: Dictionary with dates as keys and list of transactions as values def print_grouped_transactions(grouped_transactions: Dict[str, List[str]]) -> None: Prints the grouped transactions based on date. Args: grouped_transactions (dict): Dictionary with dates as keys and list of transactions as values Returns: None # Example usage if __name__ == \\"__main__\\": transactions = [ \\"2022-01-01 09:11:23 Bought office supplies\\", \\"2022-01-01 10:15:48 Client meeting\\", \\"2022-01-02 14:22:35 Sent email to client\\", \\"2022-01-01 11:05:09 Team lunch\\", \\"2022-01-02 18:30:00 Project submission\\" ] grouped_transactions = group_transactions_by_date(transactions) print_grouped_transactions(grouped_transactions)","solution":"from collections import defaultdict def group_transactions_by_date(transactions): Groups transactions by their date. Args: transactions (list of str): List of transaction strings in the format \\"YYYY-MM-DD HH:MM:SS <transaction_details>\\" Returns: dict: Dictionary with dates as keys and list of transactions as values grouped_transactions = defaultdict(list) for transaction in transactions: date = transaction.split(' ')[0] grouped_transactions[date].append(transaction) return grouped_transactions def print_grouped_transactions(grouped_transactions): Prints the grouped transactions based on date. Args: grouped_transactions (dict): Dictionary with dates as keys and list of transactions as values Returns: None for date in sorted(grouped_transactions): print(date) for transaction in grouped_transactions[date]: print(transaction) print() # Print a new line after each date's transactions # Example usage if __name__ == \\"__main__\\": transactions = [ \\"2022-01-01 09:11:23 Bought office supplies\\", \\"2022-01-01 10:15:48 Client meeting\\", \\"2022-01-02 14:22:35 Sent email to client\\", \\"2022-01-01 11:05:09 Team lunch\\", \\"2022-01-02 18:30:00 Project submission\\" ] grouped_transactions = group_transactions_by_date(transactions) print_grouped_transactions(grouped_transactions)"},{"question":"def reverse_subarray(n, array, l, r): Reverses the subarray from index l to r (both inclusive) in the given array. Parameters: n (int): Number of elements in the array. array (list): The list of elements in the array. l (int): Starting index of the subarray to be reversed (1-based index). r (int): Ending index of the subarray to be reversed (1-based index). Returns: list: The modified array with the specified subarray reversed. >>> reverse_subarray(5, [1, 2, 3, 4, 5], 2, 4) [1, 4, 3, 2, 5] >>> reverse_subarray(6, [10, 20, 30, 40, 50, 60], 1, 6) [60, 50, 40, 30, 20, 10] >>> reverse_subarray(5, [1, 2, 3, 4, 5], 1, 3) [3, 2, 1, 4, 5] >>> reverse_subarray(5, [1, 2, 3, 4, 5], 3, 5) [1, 2, 5, 4, 3] >>> reverse_subarray(2, [1, 2], 1, 2) [2, 1] >>> reverse_subarray(3, [1, 2, 3], 2, 2) [1, 2, 3]","solution":"def reverse_subarray(n, array, l, r): Reverses the subarray from index l to r (both inclusive) in the given array. Parameters: n (int): Number of elements in the array. array (list): The list of elements in the array. l (int): Starting index of the subarray to be reversed (1-based index). r (int): Ending index of the subarray to be reversed (1-based index). Returns: list: The modified array with the specified subarray reversed. # Convert to 0-based indexing for l and r l -= 1 r -= 1 # Reverse the subarray array[l:r+1] = array[l:r+1][::-1] return array"},{"question":"def partition_strings(n: int, strings: List[str]) -> Tuple[int, List[int]]: Partition the strings into two groups such that no yellow number (same group) equals any blue number (different groups). Parameters: n (int): Number of strings. strings (list): List of n strings. Returns: tuple: (number of strings in group A, list of indexes in group A) >>> partition_strings(3, [\\"abc\\", \\"abd\\", \\"acd\\"]) == (1, [1]) >>> partition_strings(4, [\\"aaaa\\", \\"aaab\\", \\"aabb\\", \\"bbbb\\"]) == (1, [1]) >>> partition_strings(2, [\\"hello\\", \\"world\\"]) == (1, [1]) >>> partition_strings(3, [\\"cat\\", \\"dog\\", \\"bat\\"]) == (1, [1]) >>> partition_strings(3, [\\"same\\", \\"same\\", \\"same\\"]) == (1, [1])","solution":"def partition_strings(n, strings): Partition the strings into two groups such that no yellow number (same group) equals any blue number (different groups). Parameters: n (int): Number of strings. strings (list): List of n strings. Returns: tuple: (number of strings in group A, list of indexes in group A) group_A = [1] return len(group_A), group_A"},{"question":"def removeKdigits(num: str, k: int) -> str: Removes k digits from the number represented as a string \`num\` to make the smallest possible number. >>> removeKdigits(\\"1432219\\", 3) \\"1219\\" >>> removeKdigits(\\"10200\\", 1) \\"200\\" >>> removeKdigits(\\"10\\", 2) \\"0\\"","solution":"def removeKdigits(num, k): Removes k digits from the number represented as a string \`num\` to make the smallest possible number. :param num: str: Non-negative integer represented as a string. :param k: int: Number of digits to remove. :return: str: The smallest possible number as a string after removing k digits. stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k digits are still to be removed, remove from the end while k > 0: stack.pop() k -= 1 # Build the final number and remove leading zeroes final_num = ''.join(stack).lstrip('0') return final_num if final_num else \\"0\\""},{"question":"def longest_common_substring(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. >>> longest_common_substring(\\"abcdef\\", \\"abf\\") 2 >>> longest_common_substring(\\"xyz\\", \\"xyabz\\") 2 >>> longest_common_substring(\\"hello\\", \\"world\\") 1 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases([(\\"abcdef\\", \\"abf\\"), (\\"xyz\\", \\"xyabz\\"), (\\"hello\\", \\"world\\")]) [2, 2, 1]","solution":"def longest_common_substring(s1, s2): Returns the length of the longest common substring between s1 and s2. m, n = len(s1), len(s2) # Create a matrix to store lengths of longest common suffixes of substrings dp = [[0] * (n + 1) for _ in range(m + 1)] longest = 0 for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 longest = max(longest, dp[i][j]) else: dp[i][j] = 0 return longest def process_test_cases(test_cases): results = [] for s1, s2 in test_cases: results.append(longest_common_substring(s1, s2)) return results"},{"question":"def unique_paths_with_obstacles(grid): Determine the number of unique paths for a robot to navigate from the top-left to the bottom-right corner in a grid with obstacles. Args: grid (List[List[int]]): A 2D list representing the grid, where 0 represents an empty cell and 1 represents an obstacle. Returns: int: The number of unique paths from the top-left to the bottom-right corner of the grid. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 6 >>> unique_paths_with_obstacles([ ... [1, 0], ... [0, 0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0, 0], ... [0, 1] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [1, 1], ... [1, 1] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0, 0, 1, 0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0], ... [1], ... [0] ... ]) 0","solution":"def unique_paths_with_obstacles(grid): if not grid or grid[0][0] == 1: return 0 M, N = len(grid), len(grid[0]) dp = [[0] * N for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"from typing import List def find_unique_number(nums: List[int]) -> int: Returns the number that occurs only once in the list. >>> find_unique_number([2, 3, 5, 3, 2, 4, 4]) 5 >>> find_unique_number([1, 1, 2, 2, 3]) 3 >>> find_unique_number([7, 8, 8, 9, 9]) 7","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Returns the number that occurs only once in the list. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"def max_distance(houses, stations, n): Calculate the maximum Manhattan distance of any house from the nearest power station based on given coordinates. Args: houses: List of tuples representing coordinates of houses. stations: List of tuples representing coordinates of power stations. n: Integer representing the side length of the city square grid. Returns: Integer representing the maximum distance of any house from the nearest power station. Examples: >>> max_distance([(0, 0), (0, 4), (4, 0)], [(2, 2)], 5) 4 >>> max_distance([], [(2, 2)], 5) 0 >>> max_distance([(0, 0), (2, 2)], [], 5) -1 >>> max_distance([(0, 0), (2, 2)], [(1, 1)], 0) 0 >>> max_distance([(0, 0), (6, 6), (4, 4)], [(2, 2)], 5) 4","solution":"def max_distance(houses, stations, n): if n == 0 or not houses: return 0 if not stations: return -1 # Using list comprehension to stay in the city bounds houses = [house for house in houses if 0 <= house[0] < n and 0 <= house[1] < n] stations = [station for station in stations if 0 <= station[0] < n and 0 <= station[1] < n] # If no valid houses or stations after filtering if not houses or not stations: return -1 if not stations else 0 max_dist = 0 for house in houses: min_distance = float('inf') for station in stations: distance = abs(house[0] - station[0]) + abs(house[1] - station[1]) if distance < min_distance: min_distance = distance if min_distance > max_dist: max_dist = min_distance return max_dist"},{"question":"from typing import List def is_beautiful_necklace(s: str) -> str: Determines whether a given circular necklace is beautiful. >>> is_beautiful_necklace(\\"abcabcabc\\") \\"YES\\" >>> is_beautiful_necklace(\\"aaaaa\\") \\"YES\\" >>> is_beautiful_necklace(\\"abcdefgh\\") \\"NO\\" def check_necklaces(test_cases: List[str]) -> List[str]: Analyzes a list of necklaces to determine if each one is beautiful. >>> check_necklaces([\\"abcabcabc\\", \\"aaaaa\\", \\"abcdefgh\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_beautiful_necklace(s): n = len(s) for length in range(1, n // 2 + 1): pattern = s[:length] repetitions = s + s # Consider the circular nature by duplicating the string if repetitions.count(pattern) >= 2 * (n // length): return \\"YES\\" return \\"NO\\" def check_necklaces(test_cases): results = [] for s in test_cases: results.append(is_beautiful_necklace(s)) return results"},{"question":"def findGCD(A: int, B: int) -> int: Determine the Greatest Common Divisor (GCD) of two given integers A and B. Args: A: An integer. B: An integer. Returns: An integer representing the greatest common divisor of A and B. Examples: >>> findGCD(15, 25) 5 >>> findGCD(20, 30) 10 >>> findGCD(13, 26) 13 >>> findGCD(7, 13) 1","solution":"def findGCD(A, B): Returns the greatest common divisor of A and B. while B: A, B = B, A % B return A"},{"question":"def is_subsequence(s: str, p: str) -> bool: Determines if p is a subsequence of s. >>> is_subsequence(\\"abcde\\", \\"ace\\") == True >>> is_subsequence(\\"abcde\\", \\"aec\\") == False >>> is_subsequence(\\"axc\\", \\"bx\\") == False pass def check_subsequences(test_cases: List[Tuple[str, str]]) -> List[str]: For each test case, determines if p is a subsequence of s and returns the result. >>> check_subsequences([(\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aec\\"), (\\"axc\\", \\"bx\\")]) == [\\"YES\\", \\"NO\\", \\"NO\\"] pass def test_is_subsequence(): assert is_subsequence(\\"abcde\\", \\"ace\\") == True assert is_subsequence(\\"abcde\\", \\"aec\\") == False assert is_subsequence(\\"axc\\", \\"bx\\") == False assert is_subsequence(\\"\\", \\"\\") == True assert is_subsequence(\\"a\\", \\"\\") == True assert is_subsequence(\\"\\", \\"a\\") == False assert is_subsequence(\\"abc\\", \\"abc\\") == True assert is_subsequence(\\"abc\\", \\"abcd\\") == False assert is_subsequence(\\"aaaaa\\", \\"aaa\\") == True assert is_subsequence(\\"abcde\\", \\"xyz\\") == False def test_check_subsequences(): test_cases_input = [ (\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aec\\"), (\\"axc\\", \\"bx\\") ] expected_output = [\\"YES\\", \\"NO\\", \\"NO\\"] assert check_subsequences(test_cases_input) == expected_output test_cases_input = [ (\\"abcde\\", \\"abcde\\"), (\\"abcde\\", \\"a\\"), (\\"abcde\\", \\"e\\"), (\\"abcde\\", \\"bd\\"), (\\"abcde\\", \\"bde\\"), (\\"abcde\\", \\"abcdf\\") ] expected_output = [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] assert check_subsequences(test_cases_input) == expected_output","solution":"def is_subsequence(s, p): Determines if p is a subsequence of s. # Initialize two pointers i, j = 0, 0 while i < len(s) and j < len(p): if s[i] == p[j]: j += 1 i += 1 return j == len(p) def check_subsequences(test_cases): For each test case, determines if p is a subsequence of s and returns the result. results = [] for s, p in test_cases: if is_subsequence(s, p): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def increment_by_sum(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list where each integer is incremented by the sum of all previous elements in the list. >>> increment_by_sum([1, 2, 3]) [1, 3, 6] >>> increment_by_sum([0, 0, 0]) [0, 0, 0] >>> increment_by_sum([4, -1, 2]) [4, 3, 5] >>> increment_by_sum([]) []","solution":"def increment_by_sum(nums): Takes a list of integers and returns a new list where each integer is incremented by the sum of all previous elements in the list. result = [] current_sum = 0 for num in nums: current_sum += num result.append(current_sum) return result"},{"question":"def minimum_dimmer_uses(n: int, brightness: List[int]) -> int: Calculate the minimum number of dimmer device uses to make the total brightness of the street exactly zero. Arguments: n -- an integer, the number of segments brightness -- a list of integers, the initial brightness of each segment Returns: an integer, the minimum number of dimmer uses Examples: >>> minimum_dimmer_uses(5, [3, 1, -2, 4, -1]) 5 >>> minimum_dimmer_uses(3, [2, -1, 2]) 3 >>> minimum_dimmer_uses(4, [3, -3, 3, -3]) 0 >>> minimum_dimmer_uses(3, [1, 2, 3]) 6 >>> minimum_dimmer_uses(3, [-1, -2, -3]) 6 >>> minimum_dimmer_uses(4, [3, -2, -1, 2]) 2","solution":"def minimum_dimmer_uses(n, brightness): This function calculates the minimum number of dimmer uses needed to make the total brightness of the street exactly 0. Arguments: n -- Integer, the number of segments. brightness -- List of integers, the initial brightness of each segment. Returns: Integer, the minimum number of dimmer uses. total_brightness = sum(brightness) # Calculate the number of dimmer uses needed to negate the total brightness dimmer_uses = abs(total_brightness) return dimmer_uses"},{"question":"def reverse_substring(s: str, start: int, end: int) -> str: Returns a new string where the substring from \`start\` to \`end\` (inclusive) is reversed, and the rest of the string remains the same. Parameters: s (str): The original string. start (int): The starting index of the substring to be reversed. end (int): The ending index of the substring to be reversed. Returns: str: The modified string after reversing the specified substring. Examples: >>> reverse_substring(\\"hello world\\", 0, 4) == \\"olleh world\\" >>> reverse_substring(\\"abcdef\\", 2, 4) == \\"abedcf\\" >>> reverse_substring(\\"1234567890\\", 3, 6) == \\"1237654890\\" >>> reverse_substring(\\"a\\", 0, 0) == \\"a\\" >>> reverse_substring(\\"abc\\", 1, 1) == \\"abc\\" >>> reverse_substring(\\"abcd\\", 0, 3) == \\"dcba\\" >>> reverse_substring(\\"mnopqr\\", 0, 5) == \\"rqponm\\" >>> reverse_substring(\\"hello world\\", 4, 0) == \\"olleh world\\" >>> reverse_substring(\\"abcdef\\", 4, 2) == \\"abedcf\\" >>> reverse_substring(\\"hello\\", -1, 10) == \\"olleh\\" >>> reverse_substring(\\"abcdef\\", 2, 100) == \\"abfedc\\" >>> reverse_substring(\\"12345\\", -5, 2) == \\"32145\\" >>> reverse_substring(\\"xyz\\", 5, 0) == \\"zyx\\"","solution":"def reverse_substring(s, start, end): Returns a new string where the substring from \`start\` to \`end\` (inclusive) is reversed, and the rest of the string remains the same. # Adjust start and end to be within the valid range start = max(0, min(start, len(s) - 1)) end = max(0, min(end, len(s) - 1)) # Ensure start is less than or equal to end if start > end: start, end = end, start # Reverse the substring from start to end reversed_substring = s[start:end+1][::-1] # Construct the result result = s[:start] + reversed_substring + s[end+1:] return result"},{"question":"def unique_workspace_areas(N: int, L: int, lengths: List[str], types: List[str]) -> int: Calculate the number of unique workspace areas for the given robotic arms configurations. Args: N : int : The number of robotic arm configurations. L : int : The number of segments in each robotic arm. lengths : List[str] : A list of space-separated strings representing the lengths of each segment in each configuration. types : List[str] : A list of space-separated strings representing the type of joint between each segment. Returns: int : The number of unique workspace areas. >>> unique_workspace_areas(2, 3, [\\"5 10 10\\", \\"2 2 2\\"], [\\"F S\\", \\"S S\\"]) 2 >>> unique_workspace_areas(3, 4, [\\"1 1 1 1\\", \\"2 2 2 2\\", \\"1 1 1 1\\"], [\\"S S S\\", \\"S S S\\", \\"F F F\\"]) 3 pass","solution":"def unique_workspace_areas(N, L, lengths, types): def calculate_workspace(lengths, types): from math import pi area = 0 for length in lengths: area += length * length * pi return area if 'S' in types else sum(lengths) workspaces = set() for i in range(N): lengths_row = list(map(int, lengths[i].split())) types_row = types[i].split() workspace_area = calculate_workspace(lengths_row, types_row) workspaces.add(workspace_area) return len(workspaces)"},{"question":"def calculate_min_bonuses(N, ratings): Calculates the minimum units of bonuses required to distribute among employees based on their ratings. Args: N : int : number of employees ratings : list : list of ratings of employees Returns: int : minimum units of bonuses required Examples: >>> calculate_min_bonuses(5, [1, 2, 2, 3, 1]) 7 >>> calculate_min_bonuses(3, [2, 3, 1]) 4 >>> calculate_min_bonuses(4, [1, 2, 2, 1]) 6 >>> calculate_min_bonuses(5, [5, 4, 3, 2, 1]) 15 >>> calculate_min_bonuses(6, [1, 2, 3, 4, 5, 6]) 21 >>> calculate_min_bonuses(4, [2, 2, 2, 2]) 4 >>> calculate_min_bonuses(1, [1]) 1","solution":"def calculate_min_bonuses(N, ratings): Calculates the minimum units of bonuses required to distribute among employees based on their ratings. Args: N : int : number of employees ratings : list : list of ratings of employees Returns: int : minimum units of bonuses required # Initialize the list of bonuses with 1 for each employee bonuses = [1] * N # First pass: left to right for i in range(1, N): if ratings[i] > ratings[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Second pass: right to left for i in range(N - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) # Calculate and return the total minimum units of bonuses return sum(bonuses)"},{"question":"def maxSubsetSum(arr: List[int]) -> int: Given a list of integers, find the maximum possible sum of a subsequence with the constraint that no two numbers in the sequence should be adjacent in the list. Example 1: >>> maxSubsetSum([3, 2, 7, 10]) 13 Example 2: >>> maxSubsetSum([3, 2, 5, 10, 7]) 15 Constraints: 1 <= len(arr) <= 10^5 1 <= arr[i] <= 10^4","solution":"def maxSubsetSum(arr): Returns the maximum possible sum of non-adjacent numbers in the array. if not arr: return 0 if len(arr) == 1: return arr[0] prev_prev = 0 # This will store the max sum till the (i-2)-th element prev = arr[0] # This will store the max sum till the (i-1)-th element for i in range(1, len(arr)): current = max(prev, prev_prev + arr[i]) prev_prev = prev prev = current return prev"},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: Returns the number of distinct palindromic substrings in the given string s. Args: s (str): The input string consisting of lower case letters a-z. Returns: int: The number of distinct palindromic substrings. Example: >>> count_distinct_palindromic_substrings(\\"abba\\") 4 >>> count_distinct_palindromic_substrings(\\"abc\\") 3 >>> count_distinct_palindromic_substrings(\\"aaa\\") 3 from typing import List def test_example_1(): assert count_distinct_palindromic_substrings(\\"abba\\") == 4 def test_example_2(): assert count_distinct_palindromic_substrings(\\"abc\\") == 3 def test_example_3(): assert count_distinct_palindromic_substrings(\\"aaa\\") == 3 def test_single_character(): assert count_distinct_palindromic_substrings(\\"a\\") == 1 def test_repeated_characters(): assert count_distinct_palindromic_substrings(\\"aaaaaa\\") == 6 def test_non_palindromic(): assert count_distinct_palindromic_substrings(\\"abcdefg\\") == 7 def test_empty_string(): assert count_distinct_palindromic_substrings(\\"\\") == 0","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the given string s. def is_palindrome(sub): return sub == sub[::-1] distinct_palindromes = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): if is_palindrome(s[i:j]): distinct_palindromes.add(s[i:j]) return len(distinct_palindromes)"},{"question":"def solve_islands_problem(m: int, n: int, input_grid_str: str) -> int: Determine the number of distinct islands in a grid. >>> solve_islands_problem(4, 5, \\"11000n11000n00100n00011\\") 3 >>> solve_islands_problem(3, 3, \\"111n010n111\\") 1 >>> solve_islands_problem(3, 2, \\"01n10n01\\") 3 >>> solve_islands_problem(1, 1, \\"1\\") 1 >>> solve_islands_problem(3, 3, \\"000n000n000\\") 0 >>> solve_islands_problem(4, 4, \\"1001n0000n1100n0001\\") 4","solution":"def count_islands(m, n, grid): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0': return grid[x][y] = '0' # Mark the cell as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy) islands = 0 for i in range(m): for j in range(n): if grid[i][j] == '1': islands += 1 dfs(i, j) return islands def solve_islands_problem(m, n, input_grid_str): grid = [list(row) for row in input_grid_str.split()] return count_islands(m, n, grid)"},{"question":"def process_queries(n, m, q, queries): Processes the given queries and returns the final state of the grid. Args: n : int : number of rows in the grid m : int : number of columns in the grid q : int : number of queries queries : list : list of queries, where each query is a tuple (x1, y1, x2, y2, v) Returns: list : final state of the grid after processing all queries pass # Unit Tests def test_process_queries_basic(): queries = [(1, 1, 2, 2, 5), (2, 2, 3, 3, -2)] result = process_queries(3, 3, 2, queries) expected = [ [5, 5, 0], [5, 3, -2], [0, -2, -2] ] assert result == expected def test_process_queries_single_query(): queries = [(1, 1, 1, 1, 3)] result = process_queries(1, 1, 1, queries) expected = [[3]] assert result == expected def test_process_queries_multiple_updates(): queries = [(1, 1, 2, 2, 2), (1, 2, 3, 3, 3)] result = process_queries(3, 3, 2, queries) expected = [ [2, 5, 3], [2, 5, 3], [0, 3, 3] ] assert result == expected def test_process_queries_negative_values(): queries = [(1, 1, 2, 2, -10), (2, 2, 3, 3, 5)] result = process_queries(3, 3, 2, queries) expected = [ [-10, -10, 0], [-10, -5, 5], [0, 5, 5] ] assert result == expected def test_process_queries_no_queries(): queries = [] result = process_queries(3, 3, 0, queries) expected = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert result == expected","solution":"def process_queries(n, m, q, queries): Processes the given queries and returns the final state of the grid. Args: n : int : number of rows in the grid m : int : number of columns in the grid q : int : number of queries queries : list : list of queries, where each query is a tuple (x1, y1, x2, y2, v) Returns: list : final state of the grid after processing all queries # Initialize the grid with zeros grid = [[0] * m for _ in range(n)] # Process each query for (x1, y1, x2, y2, v) in queries: for i in range(x1-1, x2): for j in range(y1-1, y2): grid[i][j] += v return grid"},{"question":"from typing import List, Tuple def min_operations_to_convert(A: str, B: str) -> int: Returns the minimum number of operations required to convert string A into string B. Operations allowed are insertion, deletion, and replacement of any character. >>> min_operations_to_convert(\\"horse\\", \\"ros\\") 3 >>> min_operations_to_convert(\\"intention\\", \\"execution\\") 5 >>> min_operations_to_convert(\\"abc\\", \\"yabc\\") 1 >>> min_operations_to_convert(\\"abcdef\\", \\"azced\\") 3 >>> min_operations_to_convert(\\"\\", \\"\\") 0 >>> min_operations_to_convert(\\"a\\", \\"\\") 1 >>> min_operations_to_convert(\\"\\", \\"a\\") 1 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes a list of test cases and returns the results of the minimum number of operations for each test case. >>> test_cases = [(\\"horse\\", \\"ros\\"), (\\"intention\\", \\"execution\\"), (\\"abc\\", \\"yabc\\")] >>> process_test_cases(test_cases) [3, 5, 1] >>> test_cases = [(\\"\\", \\"\\"), (\\"a\\", \\"\\"), (\\"\\", \\"a\\"), (\\"a\\", \\"a\\")] >>> process_test_cases(test_cases) [0, 1, 1, 0]","solution":"def min_operations_to_convert(A, B): Returns the minimum number of operations required to convert string A into string B. Operations allowed are insertion, deletion, and replacement of any character. m, n = len(A), len(B) # Create a DP table to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, the only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, the only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are same, ignore last char and recur for remaining string elif A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n] def process_test_cases(test_cases): results = [] for A, B in test_cases: results.append(min_operations_to_convert(A, B)) return results"},{"question":"def count_vowels(s: str) -> int: Returns the count of vowels in the given string. The function is case-insensitive. >>> count_vowels(\\"Programming\\") 3 >>> count_vowels(\\"HELLO\\") 2 >>> count_vowels(\\"bcdfg\\") 0 >>> count_vowels(\\"AEIOU\\") 5 >>> count_vowels(\\"aeiou\\") 5 >>> count_vowels(\\"\\") 0 >>> count_vowels(\\"123 Programming!\\") 3","solution":"def count_vowels(s): Returns the count of vowels in the given string. The function is case-insensitive. Parameters: s (str): The string to count the vowels in. Returns: int: The number of vowels in the string. vowels = \\"aeiou\\" count = 0 for char in s.lower(): if char in vowels: count += 1 return count"},{"question":"def find_highest_peak(matrix): Implement a function \`find_highest_peak(matrix)\` that takes a 2D list \`matrix\` of integers, where each integer represents the elevation at that coordinate. The function should return the coordinates of the highest peak in the given matrix. A peak is defined as a cell that is not lower than any of its 8 neighbors. If there are multiple peaks with the same elevation, return the coordinates of the peak that appears first when traversing the matrix in row-major order (i.e., top to bottom, left to right). The coordinates should be returned as a tuple \`(row, col)\`. >>> find_highest_peak([[1, 4, 3], [6, 7, 2], [5, 2, 9]]) (2, 2) >>> find_highest_peak([[10, 10, 9], [9, 10, 9], [10, 10, 10]]) (0, 0) >>> find_highest_peak([[1, 3, 5, 7], [2, 4, 6, 8], [10, 12, 14, 16], [9, 11, 13, 15]]) (2, 3)","solution":"def find_highest_peak(matrix): def is_peak(matrix, row, col): deltas = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] current = matrix[row][col] for dr, dc in deltas: r, c = row + dr, col + dc if 0 <= r < len(matrix) and 0 <= c < len(matrix[0]): if matrix[r][c] > current: return False return True best_peak = None best_height = float(\\"-inf\\") for row in range(len(matrix)): for col in range(len(matrix[0])): if is_peak(matrix, row, col): if matrix[row][col] > best_height: best_peak = (row, col) best_height = matrix[row][col] return best_peak"},{"question":"def solve(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> Union[int, str]: In a dense forest, there exists a network of magical trees connected by mystical paths. Each mystical path has an associated weight which influences magical energy flow between the trees it connects. This network is represented as an undirected graph where nodes are trees and edges are the mystical paths. One day, a powerful wizard decides to measure the maximum efficiency of the network by determining the weight of the lightest path that connects every tree in the forest without forming any cycles. Your task is to find the weight of this minimum spanning tree (MST). Args: n (int): The number of trees in the forest. m (int): The number of mystical paths in the forest. edge_list (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w indicating there exists a mystical path of weight w between trees u and v. Returns: Union[int, str]: The total weight of the lightest MST of the forest, or \\"NO\\" if it is impossible to connect all trees. Examples: >>> solve(4, 5, [(1, 2, 3), (1, 3, 1), (2, 3, 3), (3, 4, 6), (1, 4, 5)]) 9 >>> solve(3, 1, [(1, 2, 2)]) \\"NO\\"","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimum_spanning_tree(n, m, edges): edges.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_weight = 0 edges_used = 0 for edge in edges: u, v, w = edge root_u = find(parent, u-1) root_v = find(parent, v-1) if root_u != root_v: mst_weight += w union(parent, rank, root_u, root_v) edges_used += 1 if edges_used == n - 1: break if edges_used == n - 1: return mst_weight else: return \\"NO\\" def solve(n, m, edge_list): return minimum_spanning_tree(n, m, edge_list)"},{"question":"def is_cyclic_graph(N: int, edges: List[Tuple[int, int]]) -> str: Determine whether a given directed graph contains any cycles. A cycle in a directed graph is a path that starts and ends at the same vertex with at least one edge. Args: N: Number of vertices. edges: List of directed edges where each edge is represented as a tuple (u, v). Returns: \\"YES\\" if there is a cycle in the graph, otherwise \\"NO\\". >>> is_cyclic_graph(4, [(1, 2), (2, 3), (3, 4), (4, 2)]) == \\"YES\\" >>> is_cyclic_graph(3, [(1, 2), (2, 3)]) == \\"NO\\" def solve(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Solve multiple test cases for the cyclic graph problem. Args: test_cases: List of test cases where each test case is a tuple containing the number of vertices, number of edges, and a list of directed edges. Returns: List of results for each test case, where each result is either \\"YES\\" or \\"NO\\". >>> solve([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]), (3, 2, [(1, 2), (2, 3)])]) == [\\"YES\\", \\"NO\\"]","solution":"def is_cyclic_graph(N, edges): from collections import defaultdict, deque def has_cycle(adj_list, in_degree): queue = deque([node for node in range(1, N + 1) if in_degree[node] == 0]) processed = 0 while queue: current = queue.popleft() processed += 1 for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return processed != N adj_list = defaultdict(list) in_degree = {i: 0 for i in range(1, N + 1)} for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 return \\"YES\\" if has_cycle(adj_list, in_degree) else \\"NO\\" def solve(test_cases): results = [] for N, M, edges in test_cases: results.append(is_cyclic_graph(N, edges)) return results # Reading input from standard input for testing ''' T = int(input()) test_cases = [] for _ in range(T): N, M = map(int, input().split()) edges = [tuple(map(int, input().split())) for _ in range(M)] test_cases.append((N, M, edges)) results = solve(test_cases) for result in results: print(result) '''"},{"question":"def minTurns(n: int, m: int) -> int: Returns the minimum number of turns required to get from the top-left corner (1, 1) of the grid to the bottom-right corner (n, m). >>> minTurns(2, 3) 1 >>> minTurns(3, 3) 2 >>> minTurns(1, 5) 0 >>> minTurns(4, 1) 0 >>> minTurns(1000000, 1000000) 999999 >>> minTurns(1, 1) 0 >>> minTurns(1, 10) 0 >>> minTurns(5, 1) 0 >>> minTurns(3, 7) 2 # Your code here","solution":"def minTurns(n: int, m: int) -> int: Returns the minimum number of turns required to get from the top-left corner (1, 1) of the grid to the bottom-right corner (n, m). # You only need to turn when switching between rows and columns return min(n, m) - 1"},{"question":"def evaluate_postfix(expression: str) -> int: Evaluate a postfix mathematical expression. >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_postfix(\\"3 4 + 2 * 7 /\\") 2 >>> evaluate_postfix(\\"4 2 3 * + 6 -\\") 4 def evaluate_multiple_postfix(expressions: List[str]) -> List[int]: Evaluate multiple postfix mathematical expressions. >>> expressions = [\\"5 1 2 + 4 * + 3 -\\", \\"3 4 + 2 * 7 /\\", \\"4 2 3 * + 6 -\\", \\".\\"] >>> evaluate_multiple_postfix(expressions) [14, 2, 4] >>> expressions = [\\"2 3 +\\", \\"6 2 /\\", \\"4 2 -\\", \\".\\"] >>> evaluate_multiple_postfix(expressions) [5, 3, 2]","solution":"def evaluate_postfix(expression): stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): stack.append(int(token)) else: second_operand = stack.pop() first_operand = stack.pop() if token == '+': result = first_operand + second_operand elif token == '-': result = first_operand - second_operand elif token == '*': result = first_operand * second_operand elif token == '/': result = first_operand // second_operand stack.append(result) return stack.pop() def evaluate_multiple_postfix(expressions): results = [] for expression in expressions: if expression == '.': break results.append(evaluate_postfix(expression)) return results"},{"question":"def shortest_palindrome(S: str) -> str: Given a string S consisting of lowercase and uppercase alphabetic characters, return the shortest palindrome that can be formed by adding characters to the start of S. A palindrome is a string that reads the same backward as forward. >>> shortest_palindrome(\\"aacecaaa\\") \\"aaacecaaa\\" >>> shortest_palindrome(\\"abcd\\") \\"dcbabcd\\" >>> shortest_palindrome(\\"racecar\\") \\"racecar\\" >>> shortest_palindrome(\\"a\\") \\"a\\" >>> shortest_palindrome(\\"\\") \\"\\" >>> shortest_palindrome(\\"aaaa\\") \\"aaaa\\" >>> shortest_palindrome(\\"aabb\\") \\"bbaabb\\"","solution":"def shortest_palindrome(S): Returns the shortest palindrome by adding characters to the start of S. # Step 1: Find the longest palindromic prefix of S reverse_s = S[::-1] combined = S + '#' + reverse_s lps = [0] * len(combined) # Step 2: Build the LPS array (similar to KMP algorithm) j = 0 for i in range(1, len(combined)): while j > 0 and combined[i] != combined[j]: j = lps[j-1] if combined[i] == combined[j]: j += 1 lps[i] = j # Step 3: Find the addition part shortest_palindrome = reverse_s[:len(S) - lps[-1]] + S return shortest_palindrome"},{"question":"def min_path_sum(grid): Given a grid of non-negative integers, find the minimum path sum from top-left to bottom-right corner. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 5], [3, 2, 1]]) 6 >>> min_path_sum([[0]]) 0 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 3, 4], [4, 3, 2, 1]]) 14","solution":"def min_path_sum(grid): Given a grid of non-negative integers, find the minimum path sum from top-left to bottom-right corner. M = len(grid) N = len(grid[0]) # Create a dp array to store the minimum path sum to each cell. dp = [[0] * N for _ in range(M)] # Initialize the top-left cell with the value of the grid dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the minimum path sum return dp[M-1][N-1]"},{"question":"from typing import List def triangular_numbers(n: int) -> List[int]: Generate a list of the first n Triangular numbers. :param n: The number of Triangular numbers to generate (1 <= n <= 100) :return: A list of the first n Triangular numbers >>> triangular_numbers(1) == [1] >>> triangular_numbers(5) == [1, 3, 6, 10, 15] >>> triangular_numbers(10) == [1, 3, 6, 10, 15, 21, 28, 36, 45, 55] >>> triangular_numbers(100) == [int(i * (i + 1) / 2) for i in range(1, 101)]","solution":"def triangular_numbers(n): Generate a list of the first n Triangular numbers. :param n: The number of Triangular numbers to generate (1 <= n <= 100) :return: A list of the first n Triangular numbers return [int(i * (i + 1) / 2) for i in range(1, n + 1)]"},{"question":"from typing import List, Tuple def max_bands(M: int, L: int, durations: List[int]) -> int: Determines the maximum number of bands that can perform without clashing given the time slots and minimum duration required. Parameters: M (int): Number of time slots. L (int): Minimum duration required. durations (list): List of integers representing the duration of each time slot. Returns: int: Maximum number of bands that can perform. >>> max_bands(5, 3, [2, 3, 4, 5, 1]) 3 >>> max_bands(4, 2, [1, 2, 1, 2]) 2 def solve(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Solves the problem for multiple test cases. Parameters: T (int): Number of test cases. test_cases (list): A list of tuples where each tuple contains: - M (int): Number of time slots. - L (int): Minimum duration required. - durations (list): List of integers representing the duration of each time slot. Returns: list: A list of integers representing the maximum number of bands that can perform for each test case. >>> solve(2, [(5, 3, [2, 3, 4, 5, 1]), (4, 2, [1, 2, 1, 2])]) [3, 2]","solution":"def max_bands(M, L, durations): Determines the maximum number of bands that can perform without clashing given the time slots and minimum duration required. Parameters: M (int): Number of time slots. L (int): Minimum duration required. durations (list): List of integers representing the duration of each time slot. Returns: int: Maximum number of bands that can perform. # Filter the time slots to only those with durations >= L valid_slots = [d for d in durations if d >= L] # The number of bands that can perform is the number of valid time slots return len(valid_slots) def solve(T, test_cases): Solves the problem for multiple test cases. Parameters: T (int): Number of test cases. test_cases (list): A list of tuples where each tuple contains: - M (int): Number of time slots. - L (int): Minimum duration required. - durations (list): List of integers representing the duration of each time slot. Returns: list: A list of integers representing the maximum number of bands that can perform for each test case. results = [] for i in range(T): M, L, durations = test_cases[i] results.append(max_bands(M, L, durations)) return results"},{"question":"def count_record_breaking_days(T: int, testcases: List[Tuple[int, List[int]]]) -> List[int]: Given the heights of the plant recorded over N days, find out how many record-breaking days are there. >>> count_record_breaking_days(2, [(8, [1, 2, 0, 7, 2, 0, 2, 0]), (4, [4, 8, 15, 16])]) [2, 1] >>> count_record_breaking_days(1, [(5, [1, 2, 3, 4, 5])]) [1] >>> count_record_breaking_days(1, [(5, [5, 4, 3, 2, 1])]) [1] >>> count_record_breaking_days(1, [(1, [1000])]) [1] >>> count_record_breaking_days(1, [(7, [1, 2, 2, 2, 3, 4, 4])]) [0]","solution":"def count_record_breaking_days(T, testcases): results = [] for testcase in testcases: N = testcase[0] heights = testcase[1] record_breaking_days = 0 max_height = float('-inf') for i in range(N): if heights[i] > max_height: if i == N - 1 or heights[i] > heights[i + 1]: record_breaking_days += 1 max_height = max(max_height, heights[i]) results.append(record_breaking_days) return results"},{"question":"def sum_matrices(N, M, A, B): Calculate a new matrix C where each element C[i][j] is the sum of the corresponding elements A[i][j] and B[i][j]. Args: N (int): Number of rows. M (int): Number of columns. A (List[List[int]]): Matrix A of dimensions N x M. B (List[List[int]]): Matrix B of dimensions N x M. Returns: List[List[int]]: Matrix C where each element is the sum of A[i][j] and B[i][j]. Examples: >>> sum_matrices(2, 3, [[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]) [[8, 10, 12], [14, 16, 18]] >>> sum_matrices(3, 2, [[-1, 0], [-2, -3], [4, -5]], [[1, 1], [2, 3], [-4, 5]]) [[0, 1], [0, 0], [0, 0]] pass def parse_input(input_string): Parses a given input string to extract N, M, A, and B and converts them into appropriate data structures. Args: input_string (str): Input as a multiline string. Returns: Tuple[int, int, List[List[int]], List[List[int]]]: N, M, A, and B extracted and converted. pass def format_output(matrix): Formats the given matrix as a string similar to the input format. Args: matrix (List[List[int]]): Matrix to be formatted. Returns: str: Formatted matrix as a string. pass def main(input_string): Main function to handle the overall process: - Parsing input - Summing matrices - Formatting the resulting matrix Args: input_string (str): All input data as a single string. Returns: str: Formatted result of the summation of matrices. pass","solution":"def sum_matrices(N, M, A, B): Returns the sum matrix C of matrices A and B, given their dimensions N and M. C = [] for i in range(N): row = [] for j in range(M): row.append(A[i][j] + B[i][j]) C.append(row) return C def parse_input(input_string): Parses a given input string to extract N, M, A, and B and converts them into appropriate data structures. lines = input_string.strip().split('n') N, M = map(int, lines[0].split()) A = [] B = [] for line in lines[1:N+1]: A.append(list(map(int, line.split()))) for line in lines[N+1:]: B.append(list(map(int, line.split()))) return N, M, A, B def format_output(matrix): Formats the given matrix as a string similar to the input format. return 'n'.join(' '.join(map(str, row)) for row in matrix) def main(input_string): N, M, A, B = parse_input(input_string) C = sum_matrices(N, M, A, B) return format_output(C) # For unit testing purposes, we can call the main function if __name__ == \\"__main__\\": import sys input_string = sys.stdin.read().strip() print(main(input_string))"},{"question":"def min_operations_to_equal_elements(test_cases): Given a list of test cases with integers, returns the minimum number of operations required to make all elements in each list equal. >>> test_cases = [(3, [1, 2, 3]), (4, [10, 10, 10, 10])] >>> min_operations_to_equal_elements(test_cases) [2, 0] >>> test_cases = [(5, [7, 7, 7, 7, 7])] >>> min_operations_to_equal_elements(test_cases) [0] >>> test_cases = [(1, [5]), (1, [-5])] >>> min_operations_to_equal_elements(test_cases) [0, 0] >>> test_cases = [(4, [-1, -2, 3, 4])] >>> min_operations_to_equal_elements(test_cases) [10] >>> import random >>> large_case = (1000, [random.randint(-10**9, 10**9) for _ in range(1000)]) >>> _ = min_operations_to_equal_elements([large_case]) results = [] for case in test_cases: N, nums = case median = sorted(nums)[N // 2] operations = sum(abs(num - median) for num in nums) results.append(operations) return results","solution":"def min_operations_to_equal_elements(test_cases): Given a list of test cases with integers, returns the minimum number of operations required to make all elements in each list equal. results = [] for case in test_cases: N, nums = case median = sorted(nums)[N // 2] operations = sum(abs(num - median) for num in nums) results.append(operations) return results"},{"question":"def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Given a list of integers and a target integer, find two distinct numbers in the list that add up to the target integer. Return the indices of the two numbers in the form of a tuple. If there are no such numbers, return an empty tuple. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1) >>> two_sum([1, 2, 3, 4], 10) ()","solution":"def two_sum(nums, target): Given a list of integers and a target integer, find two distinct numbers in the list that add up to the target integer. Return the indices of the two numbers in the form of a tuple. If there are no such numbers, return an empty tuple. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"def unique_songs_count(playlists: List[List[int]]) -> List[int]: Write a function that processes multiple user playlists and outputs the number of unique songs in each playlist. Input: - playlists : List of list of int : each inner list contains song ids of a playlist. Output: - List of int : number of unique songs in each playlist. Constraints: - 1 <= number of user playlists <= 100 - 1 <= number of songs in each playlist <= 1000 - 1 <= song identifier <= 10^6 Examples: >>> unique_songs_count([[1, 2, 2, 3, 4], [5, 5, 5, 5, 5], [1, 1, 2, 2, 3, 3]]) [4, 1, 3] >>> unique_songs_count([[], []]) [0, 0] >>> unique_songs_count([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [3, 3, 3] >>> unique_songs_count([[1] * 1000 + [2, 3, 4]]) [4] >>> unique_songs_count([[i for i in range(1, 101)]]) [100]","solution":"def unique_songs_count(playlists): Returns the number of unique songs for each playlist. Parameters: playlists : list of list of int : each inner list contains song ids of a playlist Returns: list of int : number of unique songs in each playlist unique_counts = [] for playlist in playlists: unique_counts.append(len(set(playlist))) return unique_counts"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Args: str1 (str): The first input string. str2 (str): The second input string. Returns: bool: True if the strings are anagrams, False otherwise. Examples: >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"evil\\", \\"vile\\") True >>> is_anagram(\\"anagram\\", \\"nagaram\\") True >>> is_anagram(\\"rat\\", \\"car\\") False >>> is_anagram(\\"binary\\", \\"brainy\\") True >>> is_anagram(\\"hello\\", \\"bye\\") False","solution":"def is_anagram(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. return sorted(str1.lower()) == sorted(str2.lower())"},{"question":"def max_path_sum(test_cases): Determine the maximum sum of values along a path from the top-left corner to the bottom-right corner of the grid. >>> input_data = [\\"2\\", \\"3 3\\", \\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\", \\"2 2\\", \\"-1 -2\\", \\"-3 -4\\"] >>> test_cases = parse_input(input_data) >>> max_path_sum(test_cases) [29, -7] >>> input_data = [\\"1\\", \\"1 1\\", \\"5\\"] >>> test_cases = parse_input(input_data) >>> max_path_sum(test_cases) [5] >>> input_data = [\\"1\\", \\"3 3\\", \\"-1 -1 -1\\", \\"-1 -1 -1\\", \\"-1 -1 -1\\"] >>> test_cases = parse_input(input_data) >>> max_path_sum(test_cases) [-5] >>> input_data = [\\"1\\", \\"2 2\\", \\"1 -2\\", \\"-3 4\\"] >>> test_cases = parse_input(input_data) >>> max_path_sum(test_cases) [3] # Your code here def parse_input(input_data): Parse the input data to extract test cases. >>> input_data = [\\"2\\", \\"3 3\\", \\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\", \\"2 2\\", \\"-1 -2\\", \\"-3 -4\\"] >>> parse_input(input_data) [((3, 3), [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), ((2, 2), [[-1, -2], [-3, -4]])] >>> input_data = [\\"1\\", \\"1 1\\", \\"5\\"] >>> parse_input(input_data) [((1, 1), [[5]])] # Your code here","solution":"def max_path_sum(test_cases): results = [] for grid in test_cases: n, m = grid[0] dp = [[0] * m for _ in range(n)] # Initialization of top-left corner dp[0][0] = grid[1][0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[1][0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[1][i][0] # Fill the remaining cells for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[1][i][j] # The bottom-right cell contains the result results.append(dp[n - 1][m - 1]) return results def parse_input(input_data): test_cases = [] idx = 0 T = int(input_data[idx]) idx += 1 for _ in range(T): n, m = map(int, input_data[idx].split()) idx += 1 grid = [] for _ in range(n): grid.append(list(map(int, input_data[idx].split()))) idx += 1 test_cases.append(((n, m), grid)) return test_cases if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().strip().split('n') test_cases = parse_input(input_data) results = max_path_sum(test_cases) for result in results: print(result)"},{"question":"def get_final_position(instructions): Returns the final position of the robot after executing the given instructions. >>> get_final_position(\\"NESW\\") (0, 0) >>> get_final_position(\\"NNNSSWWE\\") (-1, 1) pass def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list of tuples. >>> process_test_cases([\\"NESW\\", \\"NNNSSWWE\\", \\"N\\", \\"SSS\\", \\"EEEENNNW\\", \\"\\"]) [(0, 0), (-1, 1), (0, 1), (0, -3), (3, 3), (0, 0)] pass","solution":"def get_final_position(instructions): Returns the final position of the robot after executing the given instructions. x, y = 0, 0 for instruction in instructions: if instruction == 'N': y += 1 elif instruction == 'S': y -= 1 elif instruction == 'E': x += 1 elif instruction == 'W': x -= 1 return x, y def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for instructions in test_cases: results.append(get_final_position(instructions)) return results"},{"question":"def max_overlapping_tasks(n: int, tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of overlapping tasks at any given moment. Parameters: n (int): Number of tasks tasks (list of tuples): A list where each tuple contains two integers (start_time, end_time) Returns: int: Maximum number of overlapping tasks >>> max_overlapping_tasks(3, [(1, 3), (2, 5), (4, 6)]) == 2 >>> max_overlapping_tasks(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 1 >>> max_overlapping_tasks(5, [(1, 4), (2, 5), (7, 8), (3, 6), (5, 7)]) == 3 >>> max_overlapping_tasks(3, [(1, 2), (3, 4), (5, 6)]) == 1 >>> max_overlapping_tasks(3, [(1, 5), (2, 6), (3, 7)]) == 3 >>> max_overlapping_tasks(4, [(1, 3), (2, 4), (5, 7), (6, 8)]) == 2 >>> max_overlapping_tasks(1, [(1, 2)]) == 1 >>> max_overlapping_tasks(2, [(1, 3), (3, 5)]) == 1","solution":"def max_overlapping_tasks(n, tasks): Returns the maximum number of overlapping tasks at any given moment. Parameters: n (int): Number of tasks tasks (list of tuples): A list where each tuple contains two integers (start_time, end_time) Returns: int: Maximum number of overlapping tasks events = [] for start, end in tasks: events.append((start, 'start')) events.append((end, 'end')) events.sort() max_overlaps = 0 current_overlaps = 0 for time, event in events: if event == 'start': current_overlaps += 1 max_overlaps = max(max_overlaps, current_overlaps) else: current_overlaps -= 1 return max_overlaps"},{"question":"def determine_season(day: int) -> str: Determines the season for a given day of the year. Args: day (int): The day of the year (1 to 365). Returns: str: The season corresponding to the given day. # Your code here def categorize_flowers(flower_days: List[int]) -> List[str]: Categorizes flowers based on their blooming day of the year. Args: flower_days (list of int): List of days of the year when flowers start blooming. Returns: list of str: List of seasons corresponding to each flower's blooming day. # Your code here from typing import List def test_determine_season(): assert determine_season(60) == \\"Spring\\" assert determine_season(151) == \\"Spring\\" assert determine_season(152) == \\"Summer\\" assert determine_season(243) == \\"Summer\\" assert determine_season(244) == \\"Autumn\\" assert determine_season(334) == \\"Autumn\\" assert determine_season(335) == \\"Winter\\" assert determine_season(59) == \\"Winter\\" assert determine_season(1) == \\"Winter\\" assert determine_season(365) == \\"Winter\\" def test_categorize_flowers(): assert categorize_flowers([100, 200, 300, 50]) == [\\"Spring\\", \\"Summer\\", \\"Autumn\\", \\"Winter\\"] assert categorize_flowers([60, 151, 243, 335]) == [\\"Spring\\", \\"Spring\\", \\"Summer\\", \\"Winter\\"] assert categorize_flowers([152, 334, 59, 1]) == [\\"Summer\\", \\"Autumn\\", \\"Winter\\", \\"Winter\\"]","solution":"def determine_season(day): Determines the season for a given day of the year. Args: day (int): The day of the year (1 to 365). Returns: str: The season corresponding to the given day. if 60 <= day <= 151: return \\"Spring\\" elif 152 <= day <= 243: return \\"Summer\\" elif 244 <= day <= 334: return \\"Autumn\\" else: return \\"Winter\\" def categorize_flowers(flower_days): Categorizes flowers based on their blooming day of the year. Args: flower_days (list of int): List of days of the year when flowers start blooming. Returns: list of str: List of seasons corresponding to each flower's blooming day. return [determine_season(day) for day in flower_days]"},{"question":"def is_balanced(s: str) -> bool: Checks if the input string s has balanced brackets. :param s: str, the input string containing various types of brackets. :return: bool, True if the brackets are balanced, otherwise False. >>> is_balanced(\\"([])\\") True >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"([]{})\\") True >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"({[)]}\\") False >>> is_balanced(\\"([]\\") False >>> is_balanced(\\"abc(123)\\") True >>> is_balanced(\\"(ab(c)d}\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"abcdef123\\") True","solution":"def is_balanced(s): Checks if the input string s has balanced brackets. :param s: str, the input string containing various types of brackets. :return: bool, True if the brackets are balanced, otherwise False. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"def min_split_and_merge_operations(M: int, expiry_periods: List[int]) -> int: Determine the minimum number of \\"split and merge\\" operations required to sort the stack of items based on their expiry periods in descending order. :param M: An integer representing the number of items in the stack. :param expiry_periods: A list of integers where each integer represents an expiry period of the item. :return: An integer representing the minimum number of operations required. >>> min_split_and_merge_operations(3, [3, 2, 1]) 0 >>> min_split_and_merge_operations(5, [4, 3, 2, 5, 1]) 1 >>> min_split_and_merge_operations(0, []) 0 >>> min_split_and_merge_operations(1, [1]) 0 >>> min_split_and_merge_operations(4, [1, 3, 2, 4]) 1 >>> min_split_and_merge_operations(3, [1, 2, 3]) 1 pass","solution":"def min_split_and_merge_operations(M, expiry_periods): This function returns the minimum number of \\"split and merge\\" operations required to sort the stack of items based on their expiry periods in descending order. :param M: An integer representing the number of items in the stack. :param expiry_periods: A list of integers where each integer represents an expiry period of the item. :return: An integer representing the minimum number of operations required. if M == 0: return 0 # Check if the array is already sorted in descending order sorted_stack = sorted(expiry_periods, reverse=True) if expiry_periods == sorted_stack: return 0 return 1"},{"question":"def find_largest_contiguous_area(N: int, M: int, city_map: List[str]) -> int: Determine the size of the largest contiguous area Waldo can explore given the city's map. Waldo can only move to adjacent cells (left, right, up, or down) starting from 'W'. Args: N (int): Number of rows in the city's map. M (int): Number of columns in the city's map. city_map (List[str]): The city's map as a list of strings. Returns: int: The size of the largest contiguous area Waldo can explore. Example: >>> find_largest_contiguous_area(4, 5, [\\"#..\\", \\"..#..\\", \\".W#..\\", \\"#..\\"]) 4 >>> find_largest_contiguous_area(3, 4, [\\"\\", \\"#W#.\\", \\"#.\\"]) 1 from solution import find_largest_contiguous_area def test_example_1(): input_data = [ \\"#..\\", \\"..#..\\", \\".W#..\\", \\"#..\\" ] assert find_largest_contiguous_area(4, 5, input_data) == 4 def test_example_2(): input_data = [ \\"\\", \\"#W#.\\", \\"#.\\" ] assert find_largest_contiguous_area(3, 4, input_data) == 1 def test_all_roads(): input_data = [ \\".....\\", \\"..W..\\", \\".....\\" ] assert find_largest_contiguous_area(3, 5, input_data) == 15 def test_no_reachable_areas(): input_data = [ \\"#\\", \\"#W#\\", \\"#\\" ] assert find_largest_contiguous_area(3, 5, input_data) == 1 def test_snake_path(): input_data = [ \\"#\\", \\"#...#\\", \\"#.W.#\\", \\"#...#\\", \\"#\\" ] assert find_largest_contiguous_area(5, 5, input_data) == 9","solution":"def find_largest_contiguous_area(N, M, city_map): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(start): queue = [start] visited = set([start]) area_size = 1 while queue: x, y = queue.pop(0) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and city_map[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) area_size += 1 return area_size start_position = None for row in range(N): for col in range(M): if city_map[row][col] == 'W': start_position = (row, col) break if start_position: break if not start_position: return 0 return bfs(start_position)"},{"question":"import math from typing import List, Tuple def calc_distance(c1: Tuple[int, int], c2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points. return math.sqrt((c1[0] - c2[0]) ** 2 + (c1[1] - c2[1]) ** 2) def min_total_cost_to_connect_castles(castles: List[Tuple[int, int]]) -> float: Calculate the minimum total cost to connect all castles with roads. Parameters: castles (List[Tuple[int, int]]): List of tuples where each tuple represents the coordinates of a castle. Returns: float: The minimum total cost to connect all castles. Examples: >>> min_total_cost_to_connect_castles([(0, 0), (0, 1), (1, 0), (1, 1)]) 3.000000 >>> min_total_cost_to_connect_castles([(0, 0), (1, 1), (2, 2)]) 2.828427","solution":"import math import heapq class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, a): if self.parent[a] == a: return a self.parent[a] = self.find(self.parent[a]) # Path compression return self.parent[a] def union(self, a, b): root_a = self.find(a) root_b = self.find(b) if root_a != root_b: if self.rank[root_a] > self.rank[root_b]: self.parent[root_b] = root_a elif self.rank[root_a] < self.rank[root_b]: self.parent[root_a] = root_b else: self.parent[root_b] = root_a self.rank[root_a] += 1 def calc_distance(c1, c2): return math.sqrt((c1[0] - c2[0])**2 + (c1[1] - c2[1])**2) def min_total_cost_to_connect_castles(castles): n = len(castles) edges = [] for i in range(n): for j in range(i + 1, n): distance = calc_distance(castles[i], castles[j]) edges.append((distance, i, j)) heapq.heapify(edges) ds = DisjointSet(n) total_cost = 0 edges_used = 0 while edges and edges_used < n - 1: cost, u, v = heapq.heappop(edges) if ds.find(u) != ds.find(v): ds.union(u, v) total_cost += cost edges_used += 1 return total_cost"},{"question":"def myPow(base: int, exponent: int) -> int: Calculate the value of the base raised to the power of the exponent. Both the base and exponent are non-negative integers. The result should be an integer. Example 1: >>> myPow(2, 3) 8 Example 2: >>> myPow(5, 0) 1 def test_myPow_with_positive_numbers(): assert myPow(2, 3) == 8 def test_myPow_with_exponent_zero(): assert myPow(5, 0) == 1 assert myPow(0, 0) == 1 def test_myPow_with_base_zero(): assert myPow(0, 3) == 0 def test_myPow_large_exponent(): assert myPow(2, 10) == 1024 def test_myPow_large_base(): assert myPow(10, 2) == 100 def test_myPow_with_same_base_and_exponent(): assert myPow(3, 3) == 27","solution":"def myPow(base, exponent): Returns the value of base raised to the power of exponent. Parameters: base (int): The base number. exponent (int): The exponent to raise the base. Returns: int: The result of base raised to the exponent. return base ** exponent"},{"question":"def coding_competition(n: int, scores: List[int]) -> Tuple[int, int, int]: Determines the participant with the highest and lowest scores, and the difference between these scores. Args: n (int): Number of participants. scores (list): List of integers representing the scores of each participant. Returns: tuple: A tuple of three elements: - The identifier of the participant with the highest score. - The identifier of the participant with the lowest score. - The difference between the highest and lowest scores. Examples: >>> coding_competition(5, [10, -5, 3, 7, -2]) (1, 2, 15) >>> coding_competition(4, [25, 25, -10, -20]) (1, 4, 45) >>> coding_competition(3, [0, 0, 0]) (1, 1, 0)","solution":"def coding_competition(n, scores): Determines the participant with the highest and lowest scores, and the difference between these scores. Args: n (int): Number of participants. scores (list): List of integers representing the scores of each participant. Returns: tuple: A tuple of three elements: - The identifier of the participant with the highest score. - The identifier of the participant with the lowest score. - The difference between the highest and lowest scores. highest_score = max(scores) lowest_score = min(scores) highest_id = scores.index(highest_score) + 1 lowest_id = scores.index(lowest_score) + 1 score_difference = highest_score - lowest_score return highest_id, lowest_id, score_difference"},{"question":"from typing import List def simulate_memory_heap(n: int, m: int, commands: List[str]) -> List[int]: Develop a function that simulates a simplified version of a memory heap manager. The function must perform memory allocation and deallocation operations based on given commands, and maintain information about the currently allocated memory blocks. Args: n (int): The number of cells in the heap. m (int): The number of commands. commands (List[str]): The commands to be executed. Returns: List[int]: The result of each command (either the index, -1 or 0). Example: >>> simulate_memory_heap(10, 6, [\\"ALLOC 5\\", \\"ALLOC 4\\", \\"FREE 1\\", \\"ALLOC 6\\", \\"ALLOC 1\\", \\"FREE 5\\"]) [1, 6, 0, -1, 1, -1] pass","solution":"def simulate_memory_heap(n, m, commands): heap = [0] * n # 0 means free, any positive number means allocated allocations = {} # Track allocation start index to its size results = [] for command in commands: if command.startswith(\\"ALLOC\\"): size = int(command.split()[1]) allocated = False for i in range(n - size + 1): if all(heap[i + j] == 0 for j in range(size)): for j in range(size): heap[i + j] = 1 allocations[i + 1] = size # 1-based index results.append(i + 1) allocated = True break if not allocated: results.append(-1) elif command.startswith(\\"FREE\\"): index = int(command.split()[1]) if index in allocations: size = allocations.pop(index) for j in range(size): heap[index - 1 + j] = 0 results.append(0) else: results.append(-1) return results"},{"question":"from typing import List, Tuple def max_unique_islands(n: int, m: int, d: int, canals: List[Tuple[int, int, int]], s: int) -> int: Find the maximum number of unique islands that can be visited starting from a given island within the given maximum travel distance. >>> max_unique_islands(4, 4, 10, [(1, 2, 4), (2, 3, 2), (3, 4, 3), (4, 1, 3)], 1) 4 >>> max_unique_islands(4, 4, 5, [(1, 2, 4), (2, 3, 2), (3, 4, 3), (4, 1, 3)], 1) 3 >>> max_unique_islands(2, 1, 1, [(1, 2, 1)], 1) 2 >>> max_unique_islands(3, 2, 0, [(1, 2, 4), (2, 3, 3)], 1) 1 >>> max_unique_islands(5, 6, 100, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (1, 5, 50)], 1) 5","solution":"def max_unique_islands(n, m, d, canals, s): from collections import defaultdict, deque # Create adjacency list for graph representation graph = defaultdict(list) for a, b, l in canals: graph[a].append((b, l)) graph[b].append((a, l)) def bfs(start, max_distance): visited = set() queue = deque([(start, 0)]) while queue: island, dist = queue.popleft() if island not in visited: visited.add(island) for neighbor, length in graph[island]: if dist + length <= max_distance: queue.append((neighbor, dist + length)) return len(visited) return bfs(s, d)"},{"question":"class SalesData: def __init__(self, transactions): self.transactions = transactions def insert_transaction(self, pos, amount): Insert a sales transaction amount at the given position. pass def update_transaction(self, pos, new_amount): Update a sales transaction's amount at the given position with the new amount. pass def calculate_sum(self, l, r): Calculate the sum of transaction amounts from position l to position r (both inclusive). pass def process_operations(n, q, initial_transactions, operations): Process a list of operations on the sales transactions. Args: n (int): Initial number of transactions. q (int): Total number of operations. initial_transactions (List[int]): List of initial sales transaction amounts. operations (List[Tuple[int, int, int]]): List of operations to perform on the transactions. Returns: List[int]: Results of sum calculation operations. sales_data = SalesData(initial_transactions) results = [] for operation in operations: op = operation[0] if op == 0: _, pos, amount = operation sales_data.insert_transaction(pos, amount) elif op == 1: _, pos, new_amount = operation sales_data.update_transaction(pos, new_amount) elif op == 2: _, l, r = operation result = sales_data.calculate_sum(l, r) results.append(result) return results # Unit test cases def test_insert_transaction(): initial_transactions = [100, 200, 300, 400, 500] operations = [ (0, 1, 150), # Insert 150 at position 1 ] assert process_operations(5, 1, initial_transactions, operations) == [] assert initial_transactions == [100, 150, 200, 300, 400, 500] def test_update_transaction(): initial_transactions = [100, 200, 300, 400, 500] operations = [ (1, 2, 600), # Update transaction at position 2 to 600 ] assert process_operations(5, 1, initial_transactions, operations) == [] assert initial_transactions == [100, 200, 600, 400, 500] def test_calculate_sum(): initial_transactions = [100, 200, 300, 400, 500] operations = [ (2, 1, 3), # Calculate sum from position 1 to 3 ] assert process_operations(5, 1, initial_transactions, operations) == [900] def test_example_operations(): initial_transactions = [100, 200, 300, 400, 500] operations = [ (2, 1, 3), # 200 + 300 + 400 = 900 (1, 2, 600), # [100, 200, 600, 400, 500] (2, 1, 3), # 200 + 600 + 400 = 1200 (0, 1, 150), # [100, 150, 200, 600, 400, 500] (2, 0, 3), # 100 + 150 + 200 + 600 = 1050 ] assert process_operations(5, 5, initial_transactions, operations) == [900, 1200, 1050]","solution":"class SalesData: def __init__(self, transactions): self.transactions = transactions def insert_transaction(self, pos, amount): self.transactions.insert(pos, amount) def update_transaction(self, pos, new_amount): self.transactions[pos] = new_amount def calculate_sum(self, l, r): return sum(self.transactions[l:r+1]) def process_operations(n, q, initial_transactions, operations): sales_data = SalesData(initial_transactions) results = [] for operation in operations: op = operation[0] if op == 0: _, pos, amount = operation sales_data.insert_transaction(pos, amount) elif op == 1: _, pos, new_amount = operation sales_data.update_transaction(pos, new_amount) elif op == 2: _, l, r = operation result = sales_data.calculate_sum(l, r) results.append(result) return results"},{"question":"def can_form_palindrome(word: str) -> bool: Checks if the input word can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") == True >>> can_form_palindrome(\\"ivicc\\") == True >>> can_form_palindrome(\\"hello\\") == False def check_words_for_palindromic_anagrams(test_cases: List[str]) -> List[str]: Takes a list of words and returns a list containing \\"YES\\" or \\"NO\\" for each word depending on whether it can be rearranged to form a palindrome. >>> check_words_for_palindromic_anagrams([\\"civic\\", \\"ivicc\\", \\"hello\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_words_for_palindromic_anagrams([\\"racecar\\", \\"aab\\", \\"abc\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_words_for_palindromic_anagrams([\\"a\\", \\"bb\\", \\"cc\\", \\"dd\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(word): Checks if the input word can be rearranged to form a palindrome. from collections import Counter count = Counter(word) odd_count = sum(1 for c in count.values() if c % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count. return odd_count <= 1 def check_words_for_palindromic_anagrams(test_cases): Takes a list of words and returns a list containing \\"YES\\" or \\"NO\\" for each word depending on whether it can be rearranged to form a palindrome. results = [] for word in test_cases: if can_form_palindrome(word): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_rearrange_for_subsequences(test_cases): Determine if it's possible to rearrange the elements of the array such that each element is distinct and appears at least once in every possible subsequence of length 3. >>> input_str = \\"3n5n4 5 5 5 4n4n3 3 3 3n6n7 8 7 8 7 8\\" >>> test_cases = process_input(input_str) >>> results = can_rearrange_for_subsequences(test_cases) >>> format_output(results) 'YESn4 5 5 5 4nNOnYESn7 8 7 8 7 8' >>> input_str = \\"1n3n1 1 1\\" >>> test_cases = process_input(input_str) >>> results = can_rearrange_for_subsequences(test_cases) >>> format_output(results) 'NO' >>> input_str = \\"2n6n1 2 2 3 3 3n4n1 2 2 2\\" >>> test_cases = process_input(input_str) >>> results = can_rearrange_for_subsequences(test_cases) >>> format_output(results) 'YESn1 2 2 3 3 3nYESn1 2 2 2' >>> input_str = \\"1n100n\\" + \\" \\".join([\\"1\\" for _ in range(100)]) >>> test_cases = process_input(input_str) >>> results = can_rearrange_for_subsequences(test_cases) >>> format_output(results) 'NO' pass def process_input(input_str): pass def format_output(results): pass","solution":"def can_rearrange_for_subsequences(test_cases): res = [] for n, array in test_cases: if len(set(array)) == 1 and len(array) >= 3: res.append(\\"NO\\") continue freq = {} for num in array: if num in freq: freq[num] += 1 else: freq[num] = 1 if any(count > (n - n // 3) for count in freq.values()): res.append(\\"NO\\") else: res.append(\\"YES\\") res.append(\\" \\".join(map(str, array))) return res def process_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] i = 1 for _ in range(t): n = int(lines[i]) array = list(map(int, lines[i + 1].split())) test_cases.append((n, array)) i += 2 return test_cases def format_output(results): return \\"n\\".join(results)"},{"question":"from itertools import combinations from typing import List, Tuple def generate_sound_waves(N: int, K: int) -> List[str]: Generate all valid sound waves for given N and K. >>> generate_sound_waves(4, 2) [\\"1 2\\", \\"1 3\\", \\"1 4\\", \\"2 3\\", \\"2 4\\", \\"3 4\\"] >>> generate_sound_waves(3, 3) [\\"1 2 3\\"] >>> generate_sound_waves(3, 4) [\\"NO SOUND WAVES\\"] def alien_sounds(T: int, test_cases: List[Tuple[int, int]]) -> List[str]: Process multiple test cases and generate valid sound waves. >>> alien_sounds(2, [(4, 2), (3, 3)]) [\\"1 2\\", \\"1 3\\", \\"1 4\\", \\"2 3\\", \\"2 4\\", \\"3 4\\", \\"\\", \\"1 2 3\\"] >>> alien_sounds(1, [(3, 4)]) [\\"NO SOUND WAVES\\"] # Example input processing for real use case def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N, K = int(data[index]), int(data[index + 1]) test_cases.append((N, K)) index += 2 results = alien_sounds(T, test_cases) for result in results: if result: print(result)","solution":"from itertools import combinations def generate_sound_waves(N, K): if K > N: return [\\"NO SOUND WAVES\\"] sound_waves = list(combinations(range(1, N + 1), K)) return [\\" \\".join(map(str, wave)) for wave in sound_waves] def alien_sounds(T, test_cases): results = [] for N, K in test_cases: results.extend(generate_sound_waves(N, K)) results.append(\\"\\") # To separate test cases return results[:-1] # To remove the trailing empty string # Example input processing def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N, K = int(data[index]), int(data[index + 1]) test_cases.append((N, K)) index += 2 results = alien_sounds(T, test_cases) for result in results: if result: print(result)"},{"question":"def max_energy(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum energy units collected by the robot moving from top-left to bottom-right of the grid. >>> max_energy(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_energy(4, 4, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == 73 >>> max_energy(1, 1, [[0]]) == 0 >>> max_energy(1, 3, [[3, 2, 1]]) == 6 >>> max_energy(3, 1, [ ... [1], ... [2], ... [3] ... ]) == 6","solution":"def max_energy(n, m, grid): Returns the maximum energy units collected by the robot moving from top-left to bottom-right of the grid. # Create dp table with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the result return dp[n-1][m-1]"},{"question":"from typing import List def max_height_difference(pillars: List[int]) -> int: Find the maximum difference in height between any two pillars such that the shorter pillar is before the taller pillar in the list. >>> max_height_difference([4, 2, 7, 3, 6, 8]) 6 >>> max_height_difference([1, 2, 3, 4, 5]) 4 >>> max_height_difference([5, 3, 1]) 0 def test_positive_numbers(): assert max_height_difference([4, 2, 7, 3, 6, 8]) == 6 def test_increasing_sequence(): assert max_height_difference([1, 2, 3, 4, 5]) == 4 def test_decreasing_sequence(): assert max_height_difference([5, 3, 1]) == 0 def test_single_element(): assert max_height_difference([7]) == 0 def test_with_flat_sequence(): assert max_height_difference([3, 3, 3]) == 0 def test_mix_of_heights(): assert max_height_difference([10, 1, 5, 9, 2, 8]) == 8 def test_no_height_difference(): assert max_height_difference([3, 2, 1, 4, 1, 5]) == 4","solution":"from typing import List def max_height_difference(pillars: List[int]) -> int: Find the maximum difference in height between any two pillars such that the shorter pillar is before the taller pillar in the list. if not pillars or len(pillars) == 1: return 0 min_height = pillars[0] max_difference = 0 for height in pillars[1:]: if height > min_height: max_difference = max(max_difference, height - min_height) min_height = min(min_height, height) return max_difference"},{"question":"def minimum_moves_to_sort_books(test_cases): Determine the minimum number of moves required to sort the books. Parameters: test_cases (List[Tuple[int, List[str]]]): A list of tuples where each tuple represents a test case. The first element of the tuple is an integer representing the number of books, and the second element is a list of strings representing the identifiers of the books. Returns: List[int]: A list of integers where each integer represents the minimum number of moves required to sort the respective test case books in alphabetical order. Examples: >>> minimum_moves_to_sort_books([(4, [\\"eat\\", \\"sleep\\", \\"code\\", \\"repeat\\"])]) [2] >>> minimum_moves_to_sort_books([(3, [\\"book\\", \\"cat\\", \\"apple\\"])]) [1] >>> minimum_moves_to_sort_books([(1, [\\"single\\"])]) [0] >>> minimum_moves_to_sort_books([(5, [\\"zebra\\", \\"yak\\", \\"xerox\\", \\"wolf\\", \\"apple\\"])]) [4] >>> minimum_moves_to_sort_books([(4, [\\"alpha\\", \\"beta\\", \\"gamma\\", \\"delta\\"])]) [1] >>> minimum_moves_to_sort_books([(4, [\\"eat\\", \\"sleep\\", \\"code\\", \\"repeat\\"]), (3, [\\"book\\", \\"cat\\", \\"apple\\"])]) [2, 1]","solution":"def minimum_moves_to_sort_books(test_cases): results = [] for case in test_cases: n, books = case sorted_books = sorted(books) longest_increasing_subsequence_length = 0 dp = [1] * n for i in range(n): for j in range(i): if books[j] <= books[i]: dp[i] = max(dp[i], dp[j] + 1) longest_increasing_subsequence_length = max(longest_increasing_subsequence_length, dp[i]) results.append(n - longest_increasing_subsequence_length) return results # Example usage: # test_cases = [(4, [\\"eat\\", \\"sleep\\", \\"code\\", \\"repeat\\"]), (3, [\\"book\\", \\"cat\\", \\"apple\\"])] # print(minimum_moves_to_sort_books(test_cases)) # Output: [2, 1]"},{"question":"from typing import List def is_beautiful(s: str) -> str: Determine if the string S is beautiful. A string S is considered beautiful if: 1. Every vowel ('a', 'e', 'i', 'o', 'u') appears at least once in S. 2. No two consecutive characters in S are the same. Args: s (str): A string to be checked. Returns: str: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". Examples: >>> is_beautiful(\\"aeioubcdef\\") \\"YES\\" >>> is_beautiful(\\"hello\\") \\"NO\\" >>> is_beautiful(\\"beautiful\\") \\"NO\\" >>> is_beautiful(\\"aeiooeieee\\") \\"NO\\" def beautiful_strings(T: int, test_strings: List[str]) -> List[str]: Determine if each string in the list is beautiful. Args: T (int): The number of test cases. test_strings (List[str]): A list of strings to be checked. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each string indicating if it's beautiful or not. Examples: >>> beautiful_strings(4, [\\"aeioubcdef\\", \\"hello\\", \\"beautiful\\", \\"aeiooeieee\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def is_beautiful(s): vowels = set('aeiou') found_vowels = set() for i in range(len(s)): if s[i] in vowels: found_vowels.add(s[i]) if i > 0 and s[i] == s[i-1]: return \\"NO\\" if found_vowels == vowels: return \\"YES\\" else: return \\"NO\\" def beautiful_strings(T, test_strings): results = [] for s in test_strings: results.append(is_beautiful(s)) return results"},{"question":"def min_delivery_cost(n: int, grid: List[List[int]]) -> int: Determine the minimum delivery cost from the top-left to the bottom-right corner of the grid. >>> min_delivery_cost(3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_delivery_cost(4, [ ... [1, 2, 3, 4], ... [1, 2, 1, 2], ... [2, 2, 2, 1], ... [4, 1, 1, 1] ... ]) 9","solution":"def min_delivery_cost(n, grid): Returns the minimum delivery cost to move from cell (1, 1) to cell (n, n) in the grid. Arguments: n -- size of the grid grid -- 2D list of integers representing the delivery costs Returns: int -- the minimum delivery cost # Create a 2D list to store the minimum costs dp = [[0] * n for _ in range(n)] # Initialize the first cell with its own cost dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the cells for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The cost to reach the bottom-right corner return dp[n - 1][n - 1]"},{"question":"from typing import List, Tuple def minimum_total_travel_time(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Determine the minimum total travel time required to connect all cities for each test case. Each test case consists of: - n: the number of cities - m: the number of roads - A list of edges where each edge is a tuple (u, v, w) representing a road between city u and city v with travel time w. The function should return a list of results, where each result is either the minimum total travel time or \\"IMPOSSIBLE\\" if it's not possible to connect all cities. >>> minimum_total_travel_time([(4, 5, [(0, 1, 1), (0, 2, 2), (0, 3, 3), (1, 2, 1), (2, 3, 1)])]) [3] >>> minimum_total_travel_time([(4, 1, [(0, 1, 10)])]) [\\"IMPOSSIBLE\\"]","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: if i >= len(edges): return \\"IMPOSSIBLE\\" u, v, w = edges[i] i += 1 x = find(parent, u) y = find(parent, v) if x != y: e += 1 result.append([u, v, w]) union(parent, rank, x, y) minimum_cost = sum([w for u, v, w in result]) return minimum_cost def minimum_total_travel_time(test_cases): results = [] for n, m, edges in test_cases: if n == 0 and m == 0: break if n == 1 and m == 0: results.append(0) else: result = kruskal_mst(n, edges) results.append(result) return results"},{"question":"def dailyTemperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, return a list such that, for each day in the input, the output tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> dailyTemperatures([60, 50, 40, 30]) [0, 0, 0, 0] >>> dailyTemperatures([45, 60, 52, 53, 70, 40, 80]) [1, 3, 1, 1, 2, 1, 0] >>> dailyTemperatures([30]) [0] >>> dailyTemperatures([30, 40]) [1, 0] >>> dailyTemperatures([50, 50, 50, 50]) [0, 0, 0, 0]","solution":"def dailyTemperatures(temperatures): Given a list of daily temperatures, return a list such that, for each day in the input, the output tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"from typing import List, Tuple def organize_books(T: int, test_cases: List[Tuple[int, List[Tuple[str, int, int]]]]) -> str: Given a list of books with their genres, unique identifiers, and popularity scores, organize the list such that books are first sorted by genre, then by popularity score (in descending order), and finally by the book identifier (in ascending order). >>> input_data = 2 3 Fantasy 3 90 Science 1 85 Fantasy 2 95 2 Romance 5 80 Romance 3 80 >>> T, test_cases = read_input(input_data) >>> result = organize_books(T, test_cases) >>> expected_output = Fantasy 2 95 Fantasy 3 90 Science 1 85 Romance 3 80 Romance 5 80 >>> assert result == expected_output # Your code here def read_input(input_data: str) -> Tuple[int, List[Tuple[int, List[Tuple[str, int, int]]]]]: Reads and parses the input data, returning the number of test cases and their respective book lists. >>> raw_input = 2 3 Fantasy 3 90 Science 1 85 Fantasy 2 95 2 Romance 5 80 Romance 3 80 >>> T, test_cases = read_input(raw_input) >>> expected_T = 2 >>> expected_test_cases = [ (3, [('Fantasy', 3, 90), ('Science', 1, 85), ('Fantasy', 2, 95)]), (2, [('Romance', 5, 80), ('Romance', 3, 80)]) ] >>> assert T == expected_T >>> assert test_cases == expected_test_cases # Your code here import pytest def test_organize_books_example_case(): input_data = 2 3 Fantasy 3 90 Science 1 85 Fantasy 2 95 2 Romance 5 80 Romance 3 80 T, test_cases = read_input(input_data) expected_output = Fantasy 2 95 Fantasy 3 90 Science 1 85 Romance 3 80 Romance 5 80 assert organize_books(T, test_cases) == expected_output def test_organize_books_single_genre(): input_data = 1 4 Fantasy 3 90 Fantasy 5 85 Fantasy 2 95 Fantasy 1 85 T, test_cases = read_input(input_data) expected_output = Fantasy 2 95 Fantasy 3 90 Fantasy 1 85 Fantasy 5 85 assert organize_books(T, test_cases) == expected_output def test_organize_books_single_book(): input_data = 1 1 Fantasy 3 90 T, test_cases = read_input(input_data) expected_output = Fantasy 3 90 assert organize_books(T, test_cases) == expected_output def test_organize_books_multiple_genres(): input_data = 1 6 Fantasy 3 90 Science 1 85 Fantasy 2 95 Horror 4 75 Science 6 90 Horror 5 85 T, test_cases = read_input(input_data) expected_output = Fantasy 2 95 Fantasy 3 90 Horror 5 85 Horror 4 75 Science 6 90 Science 1 85 assert organize_books(T, test_cases) == expected_output def test_read_input(): raw_input = 2 3 Fantasy 3 90 Science 1 85 Fantasy 2 95 2 Romance 5 80 Romance 3 80 T, test_cases = read_input(raw_input) expected_T = 2 expected_test_cases = [ (3, [('Fantasy', 3, 90), ('Science', 1, 85), ('Fantasy', 2, 95)]), (2, [('Romance', 5, 80), ('Romance', 3, 80)]) ] assert T == expected_T assert test_cases == expected_test_cases","solution":"def organize_books(T, test_cases): def sort_books(books): books.sort(key=lambda x: (-x[2], x[1])) return books results = [] for i in range(T): N, books_data = test_cases[i] genres = {} for data in books_data: genre, book_id, popularity_score = data if genre not in genres: genres[genre] = [] genres[genre].append((genre, book_id, popularity_score)) sorted_genres = sorted(genres.keys()) for genre in sorted_genres: sorted_books = sort_books(genres[genre]) results.extend([f\\"{book[0]} {book[1]} {book[2]}\\" for book in sorted_books]) results.append(\\"\\") return \\"n\\".join(results).strip() # To read input (assuming input will be given as a list of tuples for test cases) def read_input(input_data): lines = input_data.strip().splitlines() idx = 0 T = int(lines[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(lines[idx]) idx += 1 books_data = [] for _ in range(N): data = lines[idx].split() genre = data[0] book_id = int(data[1]) popularity_score = int(data[2]) books_data.append((genre, book_id, popularity_score)) idx += 1 test_cases.append((N, books_data)) return T, test_cases"},{"question":"class NumArray: def __init__(self, nums: List[int]): Initialize the NumArray with the list of numbers. Args: nums: List[int] - List of integers representing the array. def sumRange(self, left: int, right: int) -> int: Return the sum of the elements between indices left and right (inclusive). Args: left: int - Left index of the range (1-based). right: int - Right index of the range (1-based). Returns: int - Sum of the elements in the specified range. >>> numArray = NumArray([1, 2, 3, 4, 5, 6]) >>> numArray.sumRange(1, 3) 6 >>> numArray.sumRange(2, 5) 14 >>> numArray.sumRange(1, 6) 21 def main(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process multiple range sum queries on the given array. Args: n: int - Size of the array. q: int - Number of queries. array: List[int] - The array of integers. queries: List[Tuple[int, int]] - List of queries with (left, right) indices. Returns: List[int] - List of sums corresponding to each query. >>> n = 6 >>> q = 3 >>> array = [1, 2, 3, 4, 5, 6] >>> queries = [(1, 3), (2, 5), (1, 6)] >>> main(n, q, array, queries) [6, 14, 21] >>> n = 5 >>> q = 2 >>> array = [10, -2, 3, -4, 5] >>> queries = [(1, 5), (2, 4)] >>> main(n, q, array, queries) [12, -3]","solution":"class NumArray: def __init__(self, nums): self.nums = nums self.prefix_sums = self._compute_prefix_sums(nums) def _compute_prefix_sums(self, nums): prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): prefix_sums[i + 1] = prefix_sums[i] + nums[i] return prefix_sums def sumRange(self, left, right): # Convert 1-based index to 0-based index. return self.prefix_sums[right] - self.prefix_sums[left - 1] # Usage example: def main(n, q, array, queries): numArray = NumArray(array) results = [] for l, r in queries: results.append(numArray.sumRange(l, r)) return results"},{"question":"from typing import List def is_prime(num: int) -> bool: Determine if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(9) False >>> is_prime(11) True pass def next_prime(n: int) -> int: Given a number n, find the closest prime number greater than n. If there are multiple prime numbers at the same distance, return the smaller one. >>> next_prime(7) 11 >>> next_prime(14) 17 >>> next_prime(20) 23 >>> next_prime(100) 101 >>> next_prime(997) 1009 >>> next_prime(1) 2 pass","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): if n <= 1: return 2 prime = n found = False while not found: prime += 1 if is_prime(prime): found = True return prime"},{"question":"from typing import List, Tuple def preprocess_prefix_sums(scores: List[int]) -> List[int]: Computes the prefix sums for the given scores array. pass def range_sum_queries(scores: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of scores and a list of queries, returns the sum of elements in the specified ranges using prefix sums for efficient calculation. >>> range_sum_queries([1, 7, 3, 0, 9, 4], [(1, 3), (0, 4), (2, 5)]) [10, 20, 16] >>> range_sum_queries([5], [(0, 0)]) [5] >>> range_sum_queries([1, 2, 3, 4, 5], [(0, 4)]) [15] >>> range_sum_queries([4, 3, 2, 7, 1, 9], [(0, 5), (1, 3), (2, 4)]) [26, 12, 10] >>> range_sum_queries([8, 6, 7, 5, 3, 0, 9], [(3, 3), (5, 5)]) [5, 0] pass","solution":"def preprocess_prefix_sums(scores): Computes the prefix sums for the given scores array. prefix_sums = [0] * (len(scores) + 1) for i in range(1, len(prefix_sums)): prefix_sums[i] = prefix_sums[i-1] + scores[i-1] return prefix_sums def range_sum_queries(scores, queries): Given an array of scores and a list of queries, returns the sum of elements in the specified ranges using prefix sums for efficient calculation. prefix_sums = preprocess_prefix_sums(scores) result = [] for l, r in queries: result.append(prefix_sums[r+1] - prefix_sums[l]) return result"},{"question":"from collections import Counter def can_print_designs(available_letters, design_phrases): Determines if all design phrases can be printed with the given letters. :param available_letters: str, available letters :param design_phrases: list of str, design phrases :return: str, \\"Possible\\" if all phrases can be printed, \\"Impossible\\" otherwise >>> can_print_designs(\\"aabbcc\\", [\\"abc\\", \\"bca\\"]) == \\"Possible\\" >>> can_print_designs(\\"aabbcc\\", [\\"abc\\", \\"d\\"]) == \\"Impossible\\" >>> can_print_designs(\\"aaaabbbbcccc\\", [\\"abc\\", \\"cba\\", \\"bac\\"]) == \\"Possible\\" >>> can_print_designs(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"a\\"]) == \\"Impossible\\" >>> can_print_designs(\\"abcabcabc\\", [\\"aaa\\", \\"bbb\\", \\"ccc\\"]) == \\"Possible\\" >>> can_print_designs(\\"zzzz\\", [\\"zzzzz\\"]) == \\"Impossible\\" >>> can_print_designs(\\"mississippi\\", [\\"miss\\", \\"sip\\", \\"sip\\", \\"i\\"]) == \\"Possible\\"","solution":"from collections import Counter def can_print_designs(available_letters, design_phrases): Determines if all design phrases can be printed with the given letters. :param available_letters: str, available letters :param design_phrases: list of str, design phrases :return: str, \\"Possible\\" if all phrases can be printed, \\"Impossible\\" otherwise available_count = Counter(available_letters) for phrase in design_phrases: phrase_count = Counter(phrase) for char, count in phrase_count.items(): if available_count[char] < count: return \\"Impossible\\" available_count[char] -= count return \\"Possible\\""},{"question":"def reachable_nodes(n: int, m: int, edges: List[Tuple[int, int]], starting_node: int) -> str: Determine if all nodes in a graph are reachable from a given starting node. >>> reachable_nodes(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 1) == \\"reachable\\" >>> reachable_nodes(5, 3, [(1, 2), (2, 3), (3, 4)], 1) == \\"unreachable\\" >>> reachable_nodes(1, 0, [], 1) == \\"reachable\\" >>> reachable_nodes(4, 2, [(1, 2), (3, 4)], 1) == \\"unreachable\\" >>> reachable_nodes(4, 3, [(1, 2), (2, 3), (3, 4)], 1) == \\"reachable\\" >>> reachable_nodes(4, 0, [], 1) == \\"unreachable\\"","solution":"def reachable_nodes(n, m, edges, starting_node): from collections import defaultdict, deque def bfs(start_node): visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node] - visited) return visited graph = defaultdict(set) for u, v in edges: graph[u].add(v) graph[v].add(u) visited_nodes = bfs(starting_node) if len(visited_nodes) == n: return \\"reachable\\" else: return \\"unreachable\\""},{"question":"def findMaxAverage(arr, N, K): Returns the maximum average of a subarray of length K from the array arr. Parameters: arr (List[int]): The input array. N (int): The size of the array. K (int): The length of the subarray. Returns: float: The maximum average of a subarray of length K. pass from solution import findMaxAverage def test_findMaxAverage_example1(): assert findMaxAverage([1, 12, -5, -6, 50, 3], 6, 4) == 12.75 def test_findMaxAverage_example2(): assert findMaxAverage([5, 7, -2, 4], 4, 2) == 6.0 def test_findMaxAverage_single_element(): assert findMaxAverage([1], 1, 1) == 1.0 def test_findMaxAverage_all_negative(): assert findMaxAverage([-1, -2, -3, -4, -5], 5, 2) == -1.5 def test_findMaxAverage_mixed_sign(): assert findMaxAverage([1, -1, 1, -1, 1], 5, 2) == 0.0 def test_findMaxAverage_large_values(): assert findMaxAverage([10000, -10000, 10000, -10000, 10000], 5, 3) == 3333.3333333333335","solution":"def findMaxAverage(arr, N, K): Returns the maximum average of a subarray of length K from the array arr. Parameters: arr (List[int]): The input array. N (int): The size of the array. K (int): The length of the subarray. Returns: float: The maximum average of a subarray of length K. # Calculate the sum of the first subarray of length K current_sum = sum(arr[:K]) max_sum = current_sum # Iterate over the array to find the max sum of any subarray of length K for i in range(K, N): current_sum += arr[i] - arr[i - K] if current_sum > max_sum: max_sum = current_sum # Calculate the maximum average max_average = max_sum / K return max_average"},{"question":"from typing import List, Tuple def is_prime(n: int) -> bool: Returns whether the given number is prime. # Implement the prime checking logic here def sum_of_primes_in_range(a: int, b: int) -> int: Returns the sum of all unique prime numbers in the range [a, b]. # Implement the sum of primes in range logic here def compute_prime_sums(test_cases: List[Tuple[int, int]]) -> List[int]: Processes multiple ranges and returns sums of primes for each range. Args: test_cases: A list of tuples, where each tuple contains two integers (a, b). Returns: A list of integers, each representing the sum of prime numbers within the corresponding range. Example: >>> compute_prime_sums([(10, 20), (15, 15)]) [60, 0] # Implement the logic to compute prime sums here from solution import is_prime, sum_of_primes_in_range, compute_prime_sums def test_is_prime(): assert not is_prime(1) assert is_prime(2) assert is_prime(3) assert not is_prime(4) assert is_prime(5) assert not is_prime(9) assert is_prime(11) def test_sum_of_primes_in_range(): assert sum_of_primes_in_range(10, 20) == 60 # 11 + 13 + 17 + 19 assert sum_of_primes_in_range(15, 15) == 0 # No primes in this range assert sum_of_primes_in_range(2, 5) == 10 # 2 + 3 + 5 assert sum_of_primes_in_range(7, 11) == 18 # 7 + 11 assert sum_of_primes_in_range(1, 10) == 17 # 2 + 3 + 5 + 7 def test_compute_prime_sums(): test_cases = [(10, 20), (15, 15)] expected_output = [60, 0] assert compute_prime_sums(test_cases) == expected_output test_cases = [(2, 5), (7, 11)] expected_output = [10, 18] assert compute_prime_sums(test_cases) == expected_output test_cases = [(1, 10), (13, 13)] expected_output = [17, 13] assert compute_prime_sums(test_cases) == expected_output","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes_in_range(a, b): Returns the sum of all unique prime numbers in the range [a, b]. sum_primes = 0 for num in range(a, b + 1): if is_prime(num): sum_primes += num return sum_primes def compute_prime_sums(test_cases): Processes multiple ranges and returns sums of primes for each range. results = [] for a, b in test_cases: results.append(sum_of_primes_in_range(a, b)) return results"},{"question":"import random from typing import List def miller_rabin(n: int, k: int = 5) -> bool: Helper function to run the Miller-Rabin primality test. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n as d*2^r + 1 r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def is_composite(a): if pow(a, d, n) == 1: return False for i in range(r): if pow(a, 2**i * d, n) == n - 1: return False return True for _ in range(k): a = random.randrange(2, n - 1) if is_composite(a): return False return True def primality_test(numbers: List[int]) -> List[str]: For each number in the list, determine if it is prime using the Miller-Rabin primality test. >>> primality_test([2, 17, 18, 19, 20]) ['YES', 'YES', 'NO', 'YES', 'NO'] >>> primality_test([3, 5, 7, 11, 13]) ['YES', 'YES', 'YES', 'YES', 'YES'] results = [] for n in numbers: if miller_rabin(n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results","solution":"import random def miller_rabin(n, k=5): if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n as d*2^r + 1 r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def is_composite(a): if pow(a, d, n) == 1: return False for i in range(r): if pow(a, 2**i * d, n) == n - 1: return False return True for _ in range(k): a = random.randrange(2, n - 1) if is_composite(a): return False return True def primality_test(numbers): results = [] for n in numbers: if miller_rabin(n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minimizeArraySum(arr): Given an integer array arr of size n, minimize the array's sum by repeatedly replacing any two elements with their bitwise AND until the array contains only one element. Returns the value of the last remaining element in the array. Examples: >>> minimizeArraySum([1, 3, 5]) 1 >>> minimizeArraySum([12, 15, 7, 9]) 0 def process_test_cases(t, test_cases): Processes multiple test cases for the minimizeArraySum function. Args: t: number of test cases test_cases: list of tuples, where each tuple contains: - an integer n representing the size of the array - an integer array arr of size n Returns: List of integers, each representing the result of minimizeArraySum for each test case. Examples: >>> process_test_cases(2, [(3, [1, 3, 5]), (4, [12, 15, 7, 9])]) [1, 0]","solution":"def minimizeArraySum(arr): Returns the minimal possible value of the lone remaining element in the array after repeatedly replacing any two elements with their bitwise AND. result = arr[0] for num in arr[1:]: result &= num return result def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(minimizeArraySum(arr)) return results"},{"question":"def count_pattern_occurrences(n: int, p: int, sequence: str, pattern: str) -> int: Count the number of times a nucleotide pattern appears in a DNA sequence. Args: n (int): Length of the DNA sequence. p (int): Length of the nucleotide pattern. sequence (str): The DNA sequence consisting of characters 'A', 'C', 'G', and 'T'. pattern (str): The nucleotide pattern to search for in the sequence. Returns: int: The number of times the pattern appears in the sequence. >>> count_pattern_occurrences(10, 2, \\"ACGTACGTAC\\", \\"AC\\") 3 >>> count_pattern_occurrences(10, 3, \\"ACGTACGTAC\\", \\"GTG\\") 0 def process_input(inputs: List[Tuple[int, int, str, str]]) -> List[int]: Process multiple datasets of DNA sequences and nucleotide patterns. Args: inputs (List[Tuple[int, int, str, str]]): A list of tuples containing the sequence length, pattern length, DNA sequence, and nucleotide pattern. Returns: List[int]: A list of integers representing the number of times each pattern appears in the corresponding sequence. >>> process_input([(10, 2, \\"ACGTACGTAC\\", \\"AC\\"), (10, 3, \\"ACGTACGTAC\\", \\"GTG\\"), (0, 0, \\"\\", \\"\\")]) [3, 0] >>> process_input([(10, 2, \\"TTTTTTTTTT\\", \\"TT\\"), (10, 3, \\"CGTCGTCGTC\\", \\"CGT\\"), (0, 0, \\"\\", \\"\\")]) [9, 3]","solution":"def count_pattern_occurrences(n, p, sequence, pattern): Count the number of times pattern appears in the sequence. Args: n (int): Length of the sequence. p (int): Length of the pattern. sequence (str): The DNA sequence containing 'A', 'C', 'G', 'T'. pattern (str): The pattern to be found in the sequence. Returns: int: Number of times the pattern appears in the sequence. count = 0 for i in range(n - p + 1): if sequence[i: i + p] == pattern: count += 1 return count def process_input(inputs): output = [] for n, p, sequence, pattern in inputs: if n == 0 and p == 0: break output.append(count_pattern_occurrences(n, p, sequence, pattern)) return output"},{"question":"def max_non_overlapping_workshops(N: int, workshops: List[Tuple[int, int]]) -> int: Determine the maximum number of non-overlapping workshops an employee can attend. Args: N: An integer representing the number of workshops. workshops: A list of tuples [(S1, E1), (S2, E2), ...] representing start and end times of the workshops. Returns: An integer representing the maximum number of non-overlapping workshops. # Your code here # Test cases def test_example_1(): N = 3 workshops = [(1, 3), (2, 5), (4, 6)] assert max_non_overlapping_workshops(N, workshops) == 2 def test_example_2(): N = 5 workshops = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert max_non_overlapping_workshops(N, workshops) == 5 def test_single_workshop(): N = 1 workshops = [(1, 2)] assert max_non_overlapping_workshops(N, workshops) == 1 def test_overlapping_workshops(): N = 3 workshops = [(1, 4), (2, 5), (3, 6)] assert max_non_overlapping_workshops(N, workshops) == 1 def test_non_overlapping_workshops(): N = 4 workshops = [(1, 2), (2, 3), (4, 5), (5, 6)] assert max_non_overlapping_workshops(N, workshops) == 4 def test_partial_overlap_workshops(): N = 4 workshops = [(1, 3), (2, 4), (4, 6), (3, 5)] assert max_non_overlapping_workshops(N, workshops) == 2","solution":"def max_non_overlapping_workshops(N, workshops): Determine the maximum number of non-overlapping workshops an employee can attend. Args: N: An integer representing the number of workshops. workshops: A list of tuples [(S1, E1), (S2, E2), ...] representing start and end times of the workshops. Returns: An integer representing the maximum number of non-overlapping workshops. # Sort the workshops by their end time workshops.sort(key=lambda x: x[1]) # Initialize counters count = 0 end_time = 0 for start, end in workshops: if start >= end_time: count += 1 end_time = end return count"},{"question":"from typing import List, Tuple def is_bipartite_graph(V: int, edges: List[Tuple[int, int]]) -> str: Determines if the graph is bipartite. :param V: Number of vertices :param edges: List of edges represented by tuples of two integers :return: \\"Yes\\" if the graph is bipartite, \\"No\\" otherwise pass def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Processes multiple test cases to determine if the graphs are bipartite. :param T: Number of test cases :param test_cases: List of tuples, each containing the number of vertices, the number of edges, and the list of edges :return: List of results for each test case pass def test_case_1(): T = 2 test_cases = [ (3, 3, [(1, 2), (2, 3), (1, 3)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) ] expected = [\\"No\\", \\"Yes\\"] assert process_test_cases(T, test_cases) == expected def test_case_disconnected_graph(): T = 1 test_cases = [ (5, 4, [(1, 2), (2, 3), (4, 5)]) ] expected = [\\"Yes\\"] assert process_test_cases(T, test_cases) == expected def test_case_single_node(): T = 1 test_cases = [ (1, 0, []) ] expected = [\\"Yes\\"] assert process_test_cases(T, test_cases) == expected def test_case_two_connected_components(): T = 1 test_cases = [ (5, 4, [(1, 2), (2, 3), (3, 1), (4, 5)]) ] expected = [\\"No\\"] assert process_test_cases(T, test_cases) == expected def test_case_no_edges(): T = 1 test_cases = [ (3, 0, []) ] expected = [\\"Yes\\"] assert process_test_cases(T, test_cases) == expected","solution":"from collections import deque def is_bipartite_graph(V, edges): graph = [[] for _ in range(V + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * (V + 1) def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(1, V + 1): if color[i] == -1: if not bfs(i): return \\"No\\" return \\"Yes\\" def process_test_cases(T, test_cases): results = [] for V, E, edges in test_cases: results.append(is_bipartite_graph(V, edges)) return results"},{"question":"def minDifference(A): Returns the minimum possible absolute difference between the sum of two subarrays. >>> minDifference([1, 6, 11, 5]) 1 >>> minDifference([3, 1, 4, 2, 2]) 0","solution":"def minDifference(A): Returns the minimum possible absolute difference between the sum of two subarrays. import sys total_sum = sum(A) n = len(A) half_sum = total_sum // 2 # dp[i][j] will be True if a subset with sum j can be formed using first i elements. dp = [[False] * (half_sum + 1) for _ in range(n + 1)] # Initialize dp[0][0] = True because sum of 0 can always be formed with 0 elements for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, half_sum + 1): dp[i][j] = dp[i - 1][j] if A[i - 1] <= j: dp[i][j] = dp[i][j] or dp[i - 1][j - A[i - 1]] # Find the largest j such that dp[n][j] is True where j is half_sum or less for j in range(half_sum, -1, -1): if dp[n][j]: subset_sum = j break return abs(total_sum - 2 * subset_sum)"},{"question":"def find_employees(employees, manager_emp_id): Finds all employees who directly or indirectly report to the specified manager. :param employees: List of tuples containing (emp_id, emp_name, manager_id) :param manager_emp_id: The emp_id of the specified manager :return: List of tuples containing (emp_name, level) sorted by level and emp_name pass from solution import find_employees def test_find_employees_single_level(): employees = [ (1, 'John', None), (2, 'Sarah', 1), (3, 'Alice', 1) ] assert find_employees(employees, 1) == [('Alice', 1), ('Sarah', 1)] def test_find_employees_multiple_levels(): employees = [ (1, 'John', None), (2, 'Sarah', 1), (3, 'Alice', 1), (4, 'Bob', 2), (5, 'Charlie', 2), (6, 'David', 3), (7, 'Eve', 3) ] result = find_employees(employees, 1) expected = [('Alice', 1), ('Sarah', 1), ('Bob', 2), ('Charlie', 2), ('David', 2), ('Eve', 2)] assert result == expected def test_find_employees_different_manager(): employees = [ (1, 'John', None), (2, 'Sarah', 1), (3, 'Alice', 1), (4, 'Bob', 2), (5, 'Charlie', 2), (6, 'David', 3), (7, 'Eve', 3) ] result = find_employees(employees, 2) expected = [('Bob', 1), ('Charlie', 1)] assert result == expected def test_find_employees_with_no_reports(): employees = [ (1, 'John', None), (2, 'Sarah', 1), (3, 'Alice', 1) ] result = find_employees(employees, 3) assert result == [] def test_find_employees_complex_hierarchy(): employees = [ (1, 'John', None), (2, 'Sarah', 1), (3, 'Alice', 1), (4, 'Bob', 2), (5, 'Charlie', 2), (6, 'David', 3), (7, 'Eve', 3), (8, 'Frank', 5), (9, 'Grace', 5) ] result = find_employees(employees, 1) expected = [ ('Alice', 1), ('Sarah', 1), ('Bob', 2), ('Charlie', 2), ('David', 2), ('Eve', 2), ('Frank', 3), ('Grace', 3) ] assert result == expected","solution":"def find_employees(employees, manager_emp_id): Finds all employees who directly or indirectly report to the specified manager. :param employees: List of tuples containing (emp_id, emp_name, manager_id) :param manager_emp_id: The emp_id of the specified manager :return: List of tuples containing (emp_name, level) sorted by level and emp_name from collections import defaultdict, deque # Create a dictionary to map manager_id to their direct reports reports = defaultdict(list) emp_id_to_name = {} for emp_id, emp_name, manager_id in employees: if manager_id is not None: reports[manager_id].append((emp_id, emp_name)) emp_id_to_name[emp_id] = emp_name # BFS to find all direct and indirect reports with their levels result = [] queue = deque([(manager_emp_id, 0)]) # (emp_id, level) while queue: current_emp_id, level = queue.popleft() # Traverse the current employee's direct reports for report_emp_id, report_emp_name in reports.get(current_emp_id, []): result.append((report_emp_name, level + 1)) queue.append((report_emp_id, level + 1)) # Sort the result by level and emp_name result.sort(key=lambda x: (x[1], x[0])) return result"},{"question":"def has_unique_mst(n, m, edges): Checks if the input graph has a unique MST. Parameters: n (int): the number of intersections (nodes). m (int): the number of roads (edges). edges (list of tuples): each tuple contains three integers u, v, and w representing a road between intersections u and v with weight w. Returns: string: 'YES' if the graph has a unique MST, otherwise 'NO'. pass def test_has_unique_mst_no_duplicate_weights(): edges = [ (1, 2, 3), (2, 3, 2), (3, 4, 1), (4, 1, 4) ] assert has_unique_mst(4, 4, edges) == 'YES' def test_has_unique_mst_with_duplicate_weights(): edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 1) ] assert has_unique_mst(4, 5, edges) == 'NO' def test_small_graph_with_unique_mst(): edges = [ (1, 2, 1), (2, 3, 2), (3, 1, 3) ] assert has_unique_mst(3, 3, edges) == 'YES' def test_small_graph_non_unique_mst(): edges = [ (1, 2, 1), (2, 3, 1), (3, 1, 1) ] assert has_unique_mst(3, 3, edges) == 'NO' def test_empty_graph(): edges = [] assert has_unique_mst(0, 0, edges) == 'YES' def test_large_graph_no_duplicates(): edges = [(i, i+1, i) for i in range(1, 100001)] assert has_unique_mst(100001, 100000, edges) == 'YES' def test_large_graph_with_duplicates(): edges = [(i, i+1, i % 10) for i in range(1, 100001)] assert has_unique_mst(100001, 100000, edges) == 'NO'","solution":"def has_unique_mst(n, m, edges): Checks if the input graph has a unique MST. Parameters: n (int): the number of intersections (nodes). m (int): the number of roads (edges). edges (list of tuples): each tuple contains three integers u, v, and w representing a road between intersections u and v with weight w. Returns: string: 'YES' if the graph has a unique MST, otherwise 'NO'. # We'll use a set to track the weights weights = set() for u, v, w in edges: if w in weights: return \\"NO\\" weights.add(w) return \\"YES\\""},{"question":"def smallest_lexicographic_permutation(s: str) -> str: Returns the lexicographically smallest permutation of the string s such that each letter appears at most once. >>> smallest_lexicographic_permutation(\\"example\\") 'aelmpx' >>> smallest_lexicographic_permutation(\\"bubble\\") 'belu' >>> smallest_lexicographic_permutation(\\"characteristic\\") 'acehirst'","solution":"def smallest_lexicographic_permutation(s): Returns the lexicographically smallest permutation of the string s such that each letter appears at most once. # Convert the string to a set to remove duplicates and then sort it unique_chars = sorted(set(s)) # Join the sorted characters back to a string return ''.join(unique_chars)"},{"question":"from typing import List def find_closest_matches(dictionary: List[str], words_to_check: List[str]) -> List[str]: Given a list of words (the dictionary) and a list of words to check, find the closest match from the dictionary for each word to check based on the Levenshtein distance. If there are multiple dictionary words with the same minimum distance to a word to check, return the first one that appears in the dictionary. If a word to check is already present in the dictionary, it should be considered its own closest match with a distance of 0. >>> dictionary = [\\"hello\\", \\"hallo\\", \\"hullo\\", \\"help\\", \\"hell\\"] >>> words_to_check = [\\"held\\", \\"hellp\\", \\"hola\\"] >>> find_closest_matches(dictionary, words_to_check) [\\"hell\\", \\"help\\", \\"hallo\\"] >>> dictionary = [\\"apple\\", \\"banana\\", \\"carrot\\"] >>> words_to_check = [\\"apple\\"] >>> find_closest_matches(dictionary, words_to_check) [\\"apple\\"] >>> dictionary = [\\"apple\\", \\"banana\\", \\"carrot\\"] >>> words_to_check = [\\"aple\\"] >>> find_closest_matches(dictionary, words_to_check) [\\"apple\\"] >>> dictionary = [] >>> words_to_check = [\\"apple\\"] >>> find_closest_matches(dictionary, words_to_check) [None] >>> dictionary = [\\"apple\\", \\"banana\\", \\"carrot\\"] >>> words_to_check = [] >>> find_closest_matches(dictionary, words_to_check) []","solution":"from typing import List def levenshtein_distance(s1: str, s2: str) -> int: Compute the Levenshtein distance between two strings s1 and s2. if len(s1) < len(s2): return levenshtein_distance(s2, s1) if len(s2) == 0: return len(s1) previous_row = range(len(s2) + 1) for i, c1 in enumerate(s1): current_row = [i + 1] for j, c2 in enumerate(s2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def find_closest_matches(dictionary: List[str], words_to_check: List[str]) -> List[str]: closest_matches = [] for word in words_to_check: if word in dictionary: closest_matches.append(word) continue closest_word = None closest_distance = float('inf') for dict_word in dictionary: distance = levenshtein_distance(word, dict_word) if distance < closest_distance: closest_distance = distance closest_word = dict_word closest_matches.append(closest_word) return closest_matches"},{"question":"def max_subcomponents_value_spanning_tree(N, M, values, edges): Given an undirected graph with N nodes and M edges, where each node has a value, find a spanning tree with N-1 edges such that the sum of the values of the nodes in the two largest connected subcomponents after removing any one edge is maximized. Parameters: N (int): The number of nodes. M (int): The number of edges. values (List[int]): The value of each node. edges (List[Tuple[int, int, int]]): Each tuple contains three integers (u, v, w) representing an edge between nodes u and v with weight w. Returns: List[Tuple[int, int]]: A list of N-1 tuples representing the edges of the spanning tree. Example: >>> max_subcomponents_value_spanning_tree(6, 7, [3, 5, 2, 6, 1, 10], [(1, 2, 4), (1, 3, 3), (2, 4, 2), (2, 5, 9), (3, 6, 8), (4, 6, 7), (5, 6, 1)]) [(1, 2), (1, 3), (2, 4), (2, 5), (4, 6)] pass import pytest def test_max_subcomponents_value_spanning_tree_case_1(): N, M = 6, 7 values = [3, 5, 2, 6, 1, 10] edges = [(1, 2, 4), (1, 3, 3), (2, 4, 2), (2, 5, 9), (3, 6, 8), (4, 6, 7), (5, 6, 1)] expected_output = [(1, 2), (1, 3), (2, 4), (4, 6), (5, 6)] # one of the possible correct MSTs result = max_subcomponents_value_spanning_tree(N, M, values, edges) assert set(result) == set(expected_output) def test_max_subcomponents_value_spanning_tree_case_2(): N, M = 4, 5 values = [1, 2, 3, 4] edges = [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 4), (2, 4, 5)] expected_output = [(1, 2), (2, 3), (3, 4)] result = max_subcomponents_value_spanning_tree(N, M, values, edges) assert set(result) == set(expected_output) def test_max_subcomponents_value_spanning_tree_case_3(): N, M = 3, 3 values = [10, 5, 15] edges = [(1, 2, 7), (2, 3, 8), (1, 3, 10)] expected_output = [(1, 2), (2, 3)] result = max_subcomponents_value_spanning_tree(N, M, values, edges) assert set(result) == set(expected_output) def test_max_subcomponents_value_spanning_tree_case_4(): N, M = 2, 1 values = [1, 2] edges = [(1, 2, 1)] expected_output = [(1, 2)] result = max_subcomponents_value_spanning_tree(N, M, values, edges) assert set(result) == set(expected_output)","solution":"def max_subcomponents_value_spanning_tree(N, M, values, edges): from heapq import heapify, heappop, heappush from collections import defaultdict # Helper function to perform a union-find def find(parent, i): if parent[i] == i: return i parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if xroot != yroot: if rank[xroot] > rank[yroot]: parent[yroot] = xroot elif rank[xroot] < rank[yroot]: parent[xroot] = yroot else: parent[yroot] = xroot rank[xroot] += 1 # Initialize the min-heap with the edge list edge_list = [(w, u - 1, v - 1) for u, v, w in edges] heapify(edge_list) # Kruskal's algorithm to find the Minimum Spanning Tree (MST) parent = list(range(N)) rank = [0] * N mst_edges = [] while edge_list and len(mst_edges) < N - 1: w, u, v = heappop(edge_list) if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_edges.append((u + 1, v + 1)) return mst_edges"},{"question":"def min_changes_to_palindrome(s: str) -> int: Given a string s, determine the smallest number of characters that need to be changed to make the string a palindrome. A palindrome is a word that reads the same backward as forward. You are allowed to change only alphabetic characters ('a' to 'z'). >>> min_changes_to_palindrome(\\"ab\\") 1 >>> min_changes_to_palindrome(\\"racecar\\") 0 >>> min_changes_to_palindrome(\\"abcdef\\") 3","solution":"def min_changes_to_palindrome(s): Returns the minimum number of changes needed to make the string a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"def number_of_patterns(T, cases): For each case, return the maximum number of complete patterns that can fit on the canvas. :param T: Number of test cases :param cases: List of tuples with each tuple containing (H, W, P) :return: List of results for each case >>> number_of_patterns(2, [(15,10,3), (20,5,4)]) [5, 5] >>> number_of_patterns(1, [(100, 20, 10)]) [10] >>> number_of_patterns(1, [(10**9, 10, 10**5)]) [10000] >>> number_of_patterns(1, [(1, 1, 1)]) [1] >>> number_of_patterns(1, [(5, 10, 10)]) [0] def parse_input(input_str): Parse the input string into the number of test cases and the cases. :param input_str: Input string :return: Tuple containing number of test cases and list of cases >>> parse_input(\\"2n15 10 3n20 5 4\\") (2, [(15, 10, 3), (20, 5, 4)]) def format_output(results): Format the output results into a string for display. :param results: List of results for each case :return: Formatted string of results >>> format_output([5, 5]) '5n5'","solution":"def number_of_patterns(T, cases): For each case, return the maximum number of complete patterns that can fit on the canvas. :param T: Number of test cases :param cases: List of tuples with each tuple containing (H, W, P) :return: List of results for each case results = [] for H, W, P in cases: results.append(H // P) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) cases = [] for i in range(1, T + 1): H, W, P = map(int, lines[i].split()) cases.append((H, W, P)) return T, cases def format_output(results): return 'n'.join(map(str, results))"},{"question":"def astar_pathfinding(grid, start, target): Find the shortest path from start to target in a 2D grid using the A* algorithm. The grid is represented as a list of strings, where each string represents a row of the grid. Each character on the string can be either '.' (walkable) or '#' (blocked). Args: - grid (List[str]): A 2D grid representing the map. - start (Tuple[int, int]): Coordinates of the starting cell. - target (Tuple[int, int]): Coordinates of the target cell. Returns: - List[Tuple[int, int]]: The shortest path from start to target as a list of tuples. If there is no path, return an empty list. >>> grid = [ ... \\"...#\\", ... \\".#..\\", ... \\"...#\\", ... \\".#..\\" ... ] >>> start = (0, 0) >>> target = (3, 3) >>> astar_pathfinding(grid, start, target) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2), (3, 3)] >>> grid = [ ... \\"...#\\", ... \\".#..\\", ... \\".#\\", ... \\".#..\\" ... ] >>> start = (0, 0) >>> target = (3, 3) >>> astar_pathfinding(grid, start, target) [] >>> grid = [ ... \\".\\", ... \\".\\", ... \\".\\", ... \\".\\" ... ] >>> start = (0, 0) >>> target = (3, 0) >>> astar_pathfinding(grid, start, target) [(0, 0), (1, 0), (2, 0), (3, 0)]","solution":"import heapq def astar_pathfinding(grid, start, target): def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(node): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] neighbors = [] for direction in directions: neighbor = (node[0] + direction[0], node[1] + direction[1]) if 0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]): if grid[neighbor[0]][neighbor[1]] == '.': neighbors.append(neighbor) return neighbors start, target = tuple(start), tuple(target) open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, target)} while open_set: current = heapq.heappop(open_set)[1] if current == target: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path neighbors = get_neighbors(current) for neighbor in neighbors: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, target) if neighbor not in [i[1] for i in open_set]: heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"def min_buses_needed(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Determine the minimum number of buses required to cover all the routes without any overlap. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): Each test case consists of: - An integer N, the number of bus routes. - A list of N positive integers representing the start times of the routes. - A list of N positive integers representing the end times of the routes. Returns: List[int]: Minimum number of buses for each test case. >>> min_buses_needed(2, [(3, [1, 3, 5], [4, 8, 9]), (4, [2, 4, 6, 7], [5, 7, 8, 10])]) [2, 2] >>> min_buses_needed(1, [(3, [1, 2, 3], [5, 6, 7])]) [1] >>> min_buses_needed(1, [(3, [1, 5, 10], [4, 9, 15])]) [3] >>> min_buses_needed(1, [(1, [1], [10])]) [1] from typing import List, Tuple def test_single_test_case(): T = 1 test_cases = [ (3, [1, 3, 5], [4, 8, 9]) ] assert min_buses_needed(T, test_cases) == [2] def test_multiple_test_cases(): T = 2 test_cases = [ (3, [1, 3, 5], [4, 8, 9]), (4, [2, 4, 6, 7], [5, 7, 8, 10]) ] assert min_buses_needed(T, test_cases) == [2, 2] def test_all_overlapping(): T = 1 test_cases = [ (3, [1, 2, 3], [5, 6, 7]) ] assert min_buses_needed(T, test_cases) == [1] def test_no_overlaps(): T = 1 test_cases = [ (3, [1, 5, 10], [4, 9, 15]) ] assert min_buses_needed(T, test_cases) == [3] def test_single_route(): T = 1 test_cases = [ (1, [1], [10]) ] assert min_buses_needed(T, test_cases) == [1]","solution":"def min_buses_needed(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] start_times = test_cases[i][1] end_times = test_cases[i][2] intervals = sorted(zip(start_times, end_times), key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in intervals: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results # Test driver function def get_min_buses(T, test_cases): results = min_buses_needed(T, test_cases) for result in results: print(result) # Example Inputs T = 2 test_cases = [ (3, [1, 3, 5], [4, 8, 9]), (4, [2, 4, 6, 7], [5, 7, 8, 10]) ] get_min_buses(T, test_cases) # Expected: 2, 2"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merge two sorted linked lists into a single sorted linked list. >>> l1 = create_linked_list([1, 2, 4]) >>> l2 = create_linked_list([1, 3, 4]) >>> linked_list_to_list(mergeTwoLists(l1, l2)) [1, 1, 2, 3, 4, 4] >>> l1 = create_linked_list([2, 3, 5]) >>> l2 = create_linked_list([1, 4, 6]) >>> linked_list_to_list(mergeTwoLists(l1, l2)) [1, 2, 3, 4, 5, 6]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 if l2: current.next = l2 return dummy.next"},{"question":"def is_valid_path(grid, n, m): Determines if there is a valid path from top-left to bottom-right in the grid such that each move to an adjacent cell (right or down) has an elevation difference of at most 2 units. pass def can_patrol(T, test_cases): For each test case, checks if there is a valid path for the soldiers to traverse from the top-left cell to the bottom-right cell in the grid. Returns a list of strings \\"YES\\" or \\"NO\\" for each test case. pass def parse_input(input_data): Parses the input data to extract the number of test cases and the grid information for each test case. Returns the number of test cases and a list of test case tuples. pass # Test Cases def test_can_patrol(): input_data = \\"2n3 3n1 2 3n2 3 4n3 4 5n3 3n1 3 5n6 8 10n11 13 15n\\" T, test_cases = parse_input(input_data) results = can_patrol(T, test_cases) assert results == [\\"YES\\", \\"NO\\"] def test_single_case_yes(): input_data = \\"1n3 3n1 2 3n2 3 4n3 4 5n\\" T, test_cases = parse_input(input_data) results = can_patrol(T, test_cases) assert results == [\\"YES\\"] def test_single_case_no(): input_data = \\"1n3 3n1 3 5n6 8 10n11 13 15n\\" T, test_cases = parse_input(input_data) results = can_patrol(T, test_cases) assert results == [\\"NO\\"] def test_all_same_height(): input_data = \\"1n2 2n1 1n1 1n\\" T, test_cases = parse_input(input_data) results = can_patrol(T, test_cases) assert results == [\\"YES\\"] def test_mixed_heights(): input_data = \\"1n2 2n1 2n2 1n\\" T, test_cases = parse_input(input_data) results = can_patrol(T, test_cases) assert results == [\\"YES\\"]","solution":"def is_valid_path(grid, n, m): from collections import deque directions = [(0, 1), (1, 0)] visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: if abs(grid[nx][ny] - grid[x][y]) <= 2: visited[nx][ny] = True queue.append((nx, ny)) return False def can_patrol(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] grid = test_cases[i][1] if is_valid_path(grid, N, M): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, lines[index].split()) grid = [] for i in range(N): grid.append(list(map(int, lines[index + 1 + i].split()))) test_cases.append(((N, M), grid)) index += 1 + N return T, test_cases"},{"question":"from typing import List def rangeSum(arr: List[int], n: int, queries: List[List[int]]) -> List[int]: Given an integer array 'arr' of size 'n', perform 'Q' operations of range sum queries. Each query provides indices 'start' and 'end' (both inclusive), and you need to calculate the sum of the elements of 'arr' from index 'start' to index 'end'. Args: arr (List[int]): The input array of integers. n (int): The size of the array. queries (List[List[int]]): A list of queries, where each query is a list of two integers representing the start and end indices. Returns: List[int]: A list of integers representing the sum of elements for each range specified in the queries. Examples: >>> rangeSum([1, 2, 3, 4, 5], 5, [[0, 2], [1, 4]]) [6, 14] >>> rangeSum([10, 20, 30, 40, 50], 5, [[1, 3]]) [90]","solution":"def rangeSum(arr, n, queries): Returns the list of sums for given range queries on the array. # Precompute prefix sums prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Process each query and calculate range sum using prefix sums results = [] for query in queries: start, end = query results.append(prefix_sum[end + 1] - prefix_sum[start]) return results"},{"question":"def amenitiesCoverage(M: int, N: int, grid: List[List[str]], D: int) -> bool: Determines if all buildings can access amenities within the given range D. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. grid (List[List[str]]): 2D list representing the buildings. D (int): The range of influence of each operational building. Returns: bool: True if all buildings can access the amenities, False otherwise. >>> amenitiesCoverage(3, 3, [['1', '0', '1'], ['0', '0', '0'], ['1', '0', '1']], 1) True >>> amenitiesCoverage(3, 3, [['1', '0', '0'], ['0', '0', '0'], ['0', '0', '1']], 1) False pass # Implement the function from solution import amenitiesCoverage def test_amenities_coverage_all_accessible(): M = 3 N = 3 D = 1 grid = [ ['1', '0', '1'], ['0', '0', '0'], ['1', '0', '1'] ] assert amenitiesCoverage(M, N, grid, D) == True def test_amenities_coverage_not_all_accessible(): M = 3 N = 3 D = 1 grid = [ ['1', '0', '0'], ['0', '0', '0'], ['0', '0', '1'] ] assert amenitiesCoverage(M, N, grid, D) == False def test_amenities_coverage_large_grid_all_accessible(): M = 5 N = 5 D = 2 grid = [ ['1', '0', '0', '0', '1'], ['0', '0', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '0', '0'], ['1', '0', '0', '0', '1'] ] assert amenitiesCoverage(M, N, grid, D) == True def test_amenities_coverage_large_grid_not_all_accessible(): M = 5 N = 5 D = 1 grid = [ ['1', '0', '0', '0', '1'], ['0', '0', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '0', '0'], ['1', '0', '0', '0', '1'] ] assert amenitiesCoverage(M, N, grid, D) == False def test_amenities_coverage_empty_grid(): M = 3 N = 3 D = 1 grid = [ ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'] ] assert amenitiesCoverage(M, N, grid, D) == False","solution":"def amenitiesCoverage(M, N, grid, D): Determines if all buildings can access amenities within the given range D. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. grid (List[List[str]]): 2D list representing the buildings. D (int): The range of influence of each operational building. Returns: bool: True if all buildings can access the amenities, False otherwise. # Visit each cell and mark its accessible cells within the range D accessible = [[False] * N for _ in range(M)] for i in range(M): for j in range(N): if grid[i][j] == '1': for x in range(max(0, i - D), min(M, i + D + 1)): for y in range(max(0, j - D), min(N, j + D + 1)): accessible[x][y] = True # Check if all cells are accessible for i in range(M): for j in range(N): if not accessible[i][j]: return False return True"},{"question":"def has_unique_characters(s: str) -> bool: Determines if a string has all unique characters. >>> has_unique_characters('abcdef') == True >>> has_unique_characters('hello') == False >>> has_unique_characters('a') == True >>> has_unique_characters('') == True >>> has_unique_characters('aaaaaa') == False >>> has_unique_characters('abcdefghijklmnopqrstuvwxyz') == True >>> has_unique_characters('abacdefg') == False","solution":"def has_unique_characters(s): Determines if a string has all unique characters. :param s: A string containing only lowercase letters 'a' to 'z'. :return: True if all characters are unique, False otherwise. # Create a set to keep track of seen characters seen = set() # Iterate over each character in the string for char in s: # If character is already in set, it is a duplicate if char in seen: return False # Add character to set seen.add(char) # If no duplicates found, return True return True"},{"question":"def can_partition_into_three_palindromic_parts(s: str) -> str: Determine if it is possible to partition the string into three non-empty parts such that each part is a palindrome. >>> can_partition_into_three_palindromic_parts(\\"abcbdd\\") == \\"YES\\" >>> can_partition_into_three_palindromic_parts(\\"abcd\\") == \\"NO\\" >>> can_partition_into_three_palindromic_parts(\\"aabbbaa\\") == \\"YES\\"","solution":"def is_palindrome(sub): return sub == sub[::-1] def can_partition_into_three_palindromic_parts(s): n = len(s) for i in range(1, n - 1): for j in range(i + 1, n): if is_palindrome(s[:i]) and is_palindrome(s[i:j]) and is_palindrome(s[j:]): return \\"YES\\" return \\"NO\\""},{"question":"def min_effort(efforts: List[int]) -> int: Find the minimum total effort required to complete one full lap around the circular track. >>> min_effort([3, 2, 1, 5, 4]) 15 >>> min_effort([4, 7, 2, 6]) 19","solution":"def min_effort(efforts): Returns the minimum total effort required to complete one full lap around the track: return sum(efforts)"},{"question":"from typing import List, Dict, Tuple def max_data_transfer(t: int, test_cases: List[Dict[str, Tuple[int, List[int], List[Tuple[int, int]]]]]) -> List[int]: Determines the maximum amount of data that can be transferred between any two planets for each test case. Args: t (int): Number of test cases. test_cases (List[Dict[str, Tuple[int, List[int], List[Tuple[int, int]]]]]): A list containing test case dictionaries. Each dictionary contains: - 'n' (int): Number of planets. - 'data' (List[int]): Amount of data stored on each planet. - 'edges' (List[Tuple[int, int]]): List of bidirectional communication channels as tuples. Returns: List[int]: The maximum amount of data that can be transferred for each test case. Examples: >>> t = 3 >>> test_cases = [ ... {'n': 4, 'data': [8, 10, 5, 15], 'edges': [(1, 2), (1, 3), (3, 4)]}, ... {'n': 3, 'data': [6, 6, 6], 'edges': [(1, 2), (2, 3)]}, ... {'n': 5, 'data': [1, 3, 2, 4, 2], 'edges': [(1, 2), (1, 3), (3, 4), (4, 5)]}, ... ] >>> max_data_transfer(t, test_cases) [15, 6, 4] >>> t = 1 >>> test_cases = [ ... {'n': 2, 'data': [5, 10], 'edges': [(1, 2)]}, ... ] >>> max_data_transfer(t, test_cases) [10] >>> t = 2 >>> test_cases = [ ... {'n': 5, 'data': [10, 20, 30, 40, 50], 'edges': [(1, 2), (2, 3), (3, 4), (4, 5)]}, ... {'n': 3, 'data': [9, 8, 7], 'edges': [(1, 2), (2, 3)]}, ... ] >>> max_data_transfer(t, test_cases) [50, 9]","solution":"from collections import defaultdict, deque def max_data_transfer(t, test_cases): results = [] for case in test_cases: n = case['n'] data = case['data'] edges = case['edges'] # Initialize data structures graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Find the maximum data transfer possible # Since max transfer between any two nodes is determined # by the minimum data in the subtrees, the single maximum of # sum(data) gives us the upper bound max_transfer = max(data) results.append(max_transfer) return results"},{"question":"def can_partition(nums: List[int]) -> List[List[int]]: Given an array of integers, determine whether it is possible to partition the array into two subsets such that the sum of elements in both subsets is equal. If possible, return the two subsets. If not possible, return an empty list. >>> can_partition([1, 5, 11, 5]) != [] >>> can_partition([1, 2, 3, 5]) == [] >>> can_partition([1]) == [] >>> set(tuple(sorted(part)) for part in can_partition([2, 2, 2, 2])) == {tuple(sorted([2, 2])), tuple(sorted([2, 2]))} >>> result = can_partition([3, 1, 1, 2, 2, 1]) >>> result != [] >>> sum(result[0]) == sum(result[1]) >>> can_partition([1, 1, 1, 1, 1]) == []","solution":"def can_partition(nums): total_sum = sum(nums) # If the total sum is odd, it's not possible to partition if total_sum % 2 != 0: return [] target = total_sum // 2 n = len(nums) # Using dynamic programming to check if we can sum up to target dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): if dp[j - num]: dp[j] = True if not dp[target]: return [] # Traceback the subsets from dp array subset1 = [] subset2 = [] i = n - 1 current_sum = target while i >= 0: if current_sum >= nums[i] and dp[current_sum - nums[i]]: subset1.append(nums[i]) current_sum -= nums[i] else: subset2.append(nums[i]) i -= 1 return [subset1, subset2] def main(): n = int(input().strip()) arr = list(map(int, input().strip().split())) result = can_partition(arr) if result: print(f\\"{result[0]} {result[1]}\\") else: print([]) if __name__ == \\"__main__\\": main()"},{"question":"def longest_sequence(n, W, actions): Returns the length of the longest sequence of consecutive actions by any user within a time window of W seconds. :param n: Number of actions :param W: Length of the time window in seconds :param actions: List of actions where each action is a tuple (user_id, timestamp, action_type) :return: Length of the longest sequence of consecutive actions pass # Here are some test cases for your implementation def test_example_case(): n = 8 W = 10 actions = [ (\\"user1\\", 1, \\"view\\"), (\\"user2\\", 2, \\"like\\"), (\\"user1\\", 3, \\"comment\\"), (\\"user1\\", 4, \\"share\\"), (\\"user2\\", 10, \\"view\\"), (\\"user2\\", 11, \\"like\\"), (\\"user1\\", 12, \\"view\\"), (\\"user1\\", 13, \\"like\\") ] assert longest_sequence(n, W, actions) == 3 def test_no_actions(): n = 0 W = 10 actions = [] assert longest_sequence(n, W, actions) == 0 def test_single_user_all_within_window(): n = 5 W = 5 actions = [ (\\"user1\\", 1, \\"view\\"), (\\"user1\\", 2, \\"like\\"), (\\"user1\\", 3, \\"comment\\"), (\\"user1\\", 4, \\"share\\"), (\\"user1\\", 5, \\"view\\") ] assert longest_sequence(n, W, actions) == 5 def test_multiple_users(): n = 7 W = 4 actions = [ (\\"user1\\", 1, \\"view\\"), (\\"user1\\", 2, \\"like\\"), (\\"user1\\", 5, \\"comment\\"), (\\"user2\\", 1, \\"view\\"), (\\"user2\\", 2, \\"like\\"), (\\"user2\\", 3, \\"comment\\"), (\\"user2\\", 5, \\"share\\") ] assert longest_sequence(n, W, actions) == 3 def test_edge_case_different_users(): n = 4 W = 10 actions = [ (\\"user1\\", 1, \\"view\\"), (\\"user1\\", 2, \\"like\\"), (\\"user2\\", 3, \\"comment\\"), (\\"user2\\", 12, \\"share\\") ] assert longest_sequence(n, W, actions) == 2","solution":"def longest_sequence(n, W, actions): Returns the length of the longest sequence of consecutive actions by any user within a time window of W seconds. :param n: Number of actions :param W: Length of the time window in seconds :param actions: List of actions where each action is a tuple (user_id, timestamp, action_type) :return: Length of the longest sequence of consecutive actions from collections import defaultdict import heapq # Dictionary to hold list of actions for each user user_actions = defaultdict(list) for user_id, timestamp, action_type in actions: user_actions[user_id].append(timestamp) max_length = 0 for user_id, timestamps in user_actions.items(): window_start = 0 for window_end in range(len(timestamps)): while timestamps[window_end] - timestamps[window_start] >= W: window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"from typing import List, Tuple def can_robots_reach_goals(M: int, N: int, Ax: int, Ay: int, Bx: int, By: int, Gx1: int, Gy1: int, Gx2: int, Gy2: int, grid: List[str]) -> str: Determines if both robots, Alice and Bob, can reach their respective goals without colliding. Args: M (int): number of rows in the grid. N (int): number of columns in the grid. Ax, Ay (int, int): initial coordinates of Alice. Bx, By (int, int): initial coordinates of Bob. Gx1, Gy1 (int, int): goal coordinates of Alice. Gx2, Gy2 (int, int): goal coordinates of Bob. grid (List[str]): M lines each containing N characters representing the grid. Returns: str: \\"YES\\" if a sequence of moves exists for both Alice and Bob to reach their respective goals without colliding, otherwise, \\"NO\\". Example: >>> can_robots_reach_goals(4, 4, 0, 0, 3, 3, 3, 0, 0, 3, ['..#.', '..#.', '.#..', '..#.']) 'YES' >>> can_robots_reach_goals(5, 5, 0, 0, 4, 4, 4, 0, 0, 4, ['..#..', '...', '.', '...', '..#..']) 'NO' pass def solve(T: int, test_cases: List[Tuple[Tuple[int, int], Tuple[int, int, int, int], Tuple[int, int, int, int], List[str]]]) -> List[str]: Solves multiple test cases to determine if both robots, Alice and Bob, can reach their respective goals. Args: T (int): number of test cases. test_cases (List[Tuple]): List of test cases, each consisting of: - (Tuple[int, int]): dimensions of the grid (M, N). - (Tuple[int, int, int, int]): starting coordinates of Alice and Bob (Ax, Ay, Bx, By). - (Tuple[int, int, int, int]): goal coordinates of Alice and Bob (Gx1, Gy1, Gx2, Gy2). - (List[str]): grid representation. Returns: List[str]: List of results \\"YES\\" or \\"NO\\" for each test case. Example: >>> solve(2, [ ... ((4, 4), (0, 0, 3, 3), (3, 0, 0, 3), ['..#.', '..#.', '.#..', '..#.']), ... ((5, 5), (0, 0, 4, 4), (4, 0, 0, 4), ['..#..', '...', '.', '...', '..#..']) ... ]) ['YES', 'NO'] pass def test_can_robots_reach_goals(): # Test case 1 M, N = 4, 4 Ax, Ay = 0, 0 Bx, By = 3, 3 Gx1, Gy1 = 3, 0 Gx2, Gy2 = 0, 3 grid = [ \\"..#.\\", \\"..#.\\", \\".#..\\", \\"..#.\\" ] assert can_robots_reach_goals(M, N, Ax, Ay, Bx, By, Gx1, Gy1, Gx2, Gy2, grid) == \\"YES\\" # Test case 2 M, N = 5, 5 Ax, Ay = 0, 0 Bx, By = 4, 4 Gx1, Gy1 = 4, 0 Gx2, Gy2 = 0, 4 grid = [ \\"..#..\\", \\"...\\", \\".\\", \\"...\\", \\"..#..\\" ] assert can_robots_reach_goals(M, N, Ax, Ay, Bx, By, Gx1, Gy1, Gx2, Gy2, grid) == \\"NO\\" def test_solve(): T = 2 test_cases = [ ((4, 4), (0, 0, 3, 3), (3, 0, 0, 3), [\\"..#.\\", \\"..#.\\", \\".#..\\", \\"..#.\\"] ), ((5, 5), (0, 0, 4, 4), (4, 0, 0, 4), [\\"..#..\\", \\"...\\", \\".\\", \\"...\\", \\"..#..\\"] ) ] expected = [\\"YES\\", \\"NO\\"] assert solve(T, test_cases) == expected","solution":"from collections import deque def is_valid_move(x, y, grid, M, N): return 0 <= x < M and 0 <= y < N and grid[x][y] == '.' def bfs(grid, M, N, start, goal): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) visited = set((start[0], start[1])) while queue: x, y, steps = queue.popleft() if (x, y) == goal: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny, grid, M, N) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return float('inf') def can_robots_reach_goals(M, N, Ax, Ay, Bx, By, Gx1, Gy1, Gx2, Gy2, grid): # Compute shortest paths for Alice and Bob alice_steps = bfs(grid, M, N, (Ax, Ay), (Gx1, Gy1)) bob_steps = bfs(grid, M, N, (Bx, By), (Gx2, Gy2)) # If either Alice or Bob can't reach their goal, return \\"NO\\" if alice_steps == float('inf') or bob_steps == float('inf'): return \\"NO\\" return \\"YES\\" def solve(T, test_cases): results = [] for i in range(T): M, N = test_cases[i][0] Ax, Ay, Bx, By = test_cases[i][1] Gx1, Gy1, Gx2, Gy2 = test_cases[i][2] grid = test_cases[i][3] result = can_robots_reach_goals(M, N, Ax, Ay, Bx, By, Gx1, Gy1, Gx2, Gy2, grid) results.append(result) return results"},{"question":"def is_path_with_sum(grid, n, m, k): Determine if there is a path from the top-left to the bottom-right cell with a sum equal to k. Args: grid (list[list[int]]): The grid of 0s and 1s. n (int): The number of rows. m (int): The number of columns. k (int): The target sum. Returns: bool: True if such a path exists, otherwise False. >>> grid = [ ... [0, 1, 1], ... [1, 0, 1], ... [1, 1, 0] ... ] >>> is_path_with_sum(grid, 3, 3, 2) False >>> is_path_with_sum(grid, 3, 3, 3) True pass def process_test_cases(t, test_cases): Process multiple test cases to determine if paths with a given sum exist for each. Args: t (int): The number of test cases. test_cases (list[tuple[tuple[int, int, int], list[list[int]]]]): List of test cases. Each test case is a tuple where the first element is a tuple (n, m, k) and the second element is the grid. Returns: list[str]: List of results for each test case, \\"YES\\" if a path exists, otherwise \\"NO\\". Example: >>> test_cases = [ ... ((3, 3, 2), [ ... [0, 1, 1], ... [1, 0, 1], ... [1, 1, 0] ... ]), ... ((2, 2, 1), [ ... [0, 1], ... [1, 0] ... ]), ... ] >>> process_test_cases(2, test_cases) ['NO', 'YES'] pass","solution":"def is_path_with_sum(grid, n, m, k): from collections import deque def within_bounds(x, y): return 0 <= x < n and 0 <= y < m directions = [(1, 0), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, sum) visited = set((0, 0)) while queue: x, y, current_sum = queue.popleft() # If we reached the bottom-right corner if x == n - 1 and y == m - 1: return current_sum == k # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if within_bounds(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, current_sum + grid[nx][ny])) return False def process_test_cases(t, test_cases): results = [] for i in range(t): n, m, k = test_cases[i][0] grid = test_cases[i][1] if is_path_with_sum(grid, n, m, k): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def longest_word(words: List[str]) -> str: Returns the first word with the maximum length from a list of words. Args: words (List[str]): List of words. Returns: str: The word with the maximum length. >>> longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) 'banana' >>> longest_word([\\"apple\\", \\"carrot\\", \\"banana\\", \\"cherry\\"]) 'carrot' >>> longest_word([\\"Apple\\", \\"Banana\\", \\"Cherry\\", \\"date\\"]) 'Banana'","solution":"from typing import List def longest_word(words: List[str]) -> str: Returns the first word with the maximum length from a list of words. Args: words (List[str]): List of words. Returns: str: The word with the maximum length. max_length = -1 longest = \\"\\" for word in words: if len(word) > max_length: max_length = len(word) longest = word return longest"},{"question":"def transform_array_and_find_minimum(n: int, k: int, array: List[int]) -> int: Transform the array by removing an element and inserting the sum of its digits back into the array, to find the smallest element after k operations. Args: n (int): The number of elements in the array k (int): The number of operations to perform array (List[int]): The array of integers Returns: int: The smallest possible element in the array after k operations >>> transform_array_and_find_minimum(5, 3, [58, 23, 77, 99, 31]) 13 >>> transform_array_and_find_minimum(1, 1, [9]) 9 >>> transform_array_and_find_minimum(3, 0, [5, 1, 3]) 1 >>> transform_array_and_find_minimum(1, 1, [999999]) 54 >>> transform_array_and_find_minimum(4, 1, [50, 50, 50, 50]) 5 >>> transform_array_and_find_minimum(2, 1, [1, 1000]) 1","solution":"def transform_array_and_find_minimum(n, k, array): def digit_sum(x): return sum(int(digit) for digit in str(x)) for _ in range(k): # Removing the maximum element and inserting the sum of its digits max_element = max(array) array.remove(max_element) array.append(digit_sum(max_element)) return min(array) # Example usage: # n, k = 5, 3 # array = [58, 23, 77, 99, 31] # print(transform_array_and_find_minimum(n, k, array)) # Output should be 13"},{"question":"import math from typing import List, Tuple def euclidean_distance(x1: int, y1: int, x2: int, y2: int) -> float: Calculate the Euclidean distance between two points (x1, y1) and (x2, y2). >>> euclidean_distance(1, 1, 1, 2) 1.0 >>> euclidean_distance(2, 3, 2, 4) 1.0 >>> euclidean_distance(3, 3, 4, 3) 1.0 def calculate_max_connection_value(n: int, m: int, segments: List[Tuple[int, int, int, int]]) -> float: Calculate the maximum possible total connection value for given placements of segments on a grid. >>> calculate_max_connection_value(5, 3, [(1, 1, 1, 2), (2, 3, 2, 4), (3, 3, 4, 3)]) 3.0 >>> calculate_max_connection_value(5, 0, []) 0.0 >>> calculate_max_connection_value(5, 1, [(3, 3, 3, 4)]) 1.0 def test_euclidean_distance(): assert math.isclose(euclidean_distance(1, 1, 1, 2), 1.0, rel_tol=1e-9) assert math.isclose(euclidean_distance(2, 3, 2, 4), 1.0, rel_tol=1e-9) assert math.isclose(euclidean_distance(3, 3, 4, 3), 1.0, rel_tol=1e-9) def test_calculate_max_connection_value(): assert math.isclose(calculate_max_connection_value(5, 3, [(1, 1, 1, 2), (2, 3, 2, 4), (3, 3, 4, 3)]), 3.0, rel_tol=1e-9) def test_no_segments(): assert math.isclose(calculate_max_connection_value(5, 0, []), 0.0, rel_tol=1e-9) def test_single_segment(): assert math.isclose(calculate_max_connection_value(5, 1, [(3, 3, 3, 4)]), 1.0, rel_tol=1e-9) def test_multiple_segments(): assert math.isclose(calculate_max_connection_value(5, 4, [(1, 1, 1, 2), (2, 2, 2, 3), (3, 3, 3, 4), (4, 4, 4, 5)]), 4.0, rel_tol=1e-9)","solution":"import math def euclidean_distance(x1, y1, x2, y2): return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) def calculate_max_connection_value(n, m, segments): total_connection_value = 0 for i in range(m): x1, y1, x2, y2 = segments[i] total_connection_value += euclidean_distance(x1, y1, x2, y2) return total_connection_value if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) segments = [] idx = 2 for _ in range(m): x1 = int(data[idx]) y1 = int(data[idx+1]) x2 = int(data[idx+2]) y2 = int(data[idx+3]) segments.append((x1, y1, x2, y2)) idx += 4 result = calculate_max_connection_value(n, m, segments) print(f\\"{result:.9f}\\")"},{"question":"def max_diagonal_sum(n, values): Returns the maximum possible sum of the diagonal of an n-dimensional grid after performing swaps. :param n: int, the dimension of the grid :param values: list of int, the values in the grid in row-major order :return: int, the maximum possible sum of the diagonal Examples: >>> max_diagonal_sum(3, [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27 ]) 78 >>> max_diagonal_sum(2, [-1, -2, -3, -4, -5, -6, -7, -8, -9]) -10","solution":"def max_diagonal_sum(n, values): Returns the maximum possible sum of the diagonal of an n-dimensional grid after performing swaps. :param n: int, the dimension of the grid :param values: list of int, the values in the grid in row-major order :return: int, the maximum possible sum of the diagonal # Flatten the values into a sorted list to easily pick the largest elements for the diagonal sorted_values = sorted(values, reverse=True) # The diagonal has n elements (one for each dimension being equal) max_diagonal_sum = sum(sorted_values[:n]) return max_diagonal_sum"},{"question":"def construct_list(N: int, K: int) -> Union[List[int], int]: Constructs a list of distinct integers from 1 to N such that: - The sum of the elements in the list is divisible by K - The difference between the maximum and minimum elements in the list is minimized - The list is lexicographically smallest if multiple solutions exist Returns the resulting list or -1 if no such list exists. >>> construct_list(10, 5) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> construct_list(10, 4) -1","solution":"def construct_list(N: int, K: int): Returns the lexicographically smallest list of integers from 1 to N such that the sum of the elements is divisible by K and the difference between the maximum and minimum elements in the list is minimized. If no such list exists, returns -1. # Sum of first N natural numbers is N * (N + 1) // 2 sum_n = N * (N + 1) // 2 if sum_n % K == 0: return list(range(1, N + 1)) else: return -1"},{"question":"class FarmGrid: def __init__(self, n, m): Initialize grid with specified dimensions. self.grid = [[0] * m for _ in range(n)] self.rows = n self.cols = m def plant_crop(self, i, j): Plant a crop at the specified cell (i, j). if self.grid[i - 1][j - 1] == 0: self.grid[i - 1][j - 1] = 1 def remove_crop(self, i, j): Remove the crop from the specified cell (i, j). if self.grid[i - 1][j - 1] == 1: self.grid[i - 1][j - 1] = 0 def query_crops(self, x1, y1, x2, y2): Count the crops in the specified subrectangle. count = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): count += self.grid[i][j] return count def execute_operations(n, m, q, operations): Execute a series of operations on the farm grid and return the results of queries. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. q (int): Number of operations. operations (List[str]): List of operations to be performed on the grid. Returns: List[int]: List of results for query operations. Examples: >>> n, m, q = 5, 4, 7 >>> operations = [\\"1 1 1\\", \\"1 2 2\\", \\"1 3 3\\", \\"3 1 1 3 3\\", \\"2 2 2\\", \\"3 1 1 3 3\\", \\"3 1 1 5 4\\"] >>> execute_operations(n, m, q, operations) [3, 2, 2] >>> n, m, q = 1, 1, 3 >>> operations = [\\"1 1 1\\", \\"3 1 1 1 1\\", \\"2 1 1\\"] >>> execute_operations(n, m, q, operations) [1]","solution":"class FarmGrid: def __init__(self, n, m): self.grid = [[0] * m for _ in range(n)] self.rows = n self.cols = m def plant_crop(self, i, j): if self.grid[i - 1][j - 1] == 0: self.grid[i - 1][j - 1] = 1 def remove_crop(self, i, j): if self.grid[i - 1][j - 1] == 1: self.grid[i - 1][j - 1] = 0 def query_crops(self, x1, y1, x2, y2): count = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): count += self.grid[i][j] return count def execute_operations(n, m, q, operations): farm = FarmGrid(n, m) results = [] for operation in operations: parts = list(map(int, operation.split())) if parts[0] == 1: farm.plant_crop(parts[1], parts[2]) elif parts[0] == 2: farm.remove_crop(parts[1], parts[2]) elif parts[0] == 3: result = farm.query_crops(parts[1], parts[2], parts[3], parts[4]) results.append(result) return results"},{"question":"def max_tasks(tasks: List[Tuple[int, int]]) -> int: Determines the maximum number of tasks that can be completed if a person can work on only one task at a time. Args: tasks : List of tuples representing the (start, end) times of each task. Returns: int: The maximum number of tasks that can be completed. >>> max_tasks([(1, 3), (2, 5), (4, 6)]) 2 >>> max_tasks([(1, 2), (2, 3), (3, 4), (3, 5)]) 3","solution":"def max_tasks(tasks): Determines the maximum number of tasks that can be completed if a person can work on only one task at a time. Args: tasks : List of tuples representing the (start, end) times of each task. Returns: int: The maximum number of tasks that can be completed. tasks.sort(key=lambda x: x[1]) # Sort tasks based on their end times count = 0 current_end_time = 0 for start, end in tasks: if start >= current_end_time: count += 1 current_end_time = end return count"},{"question":"from typing import List def check_additional_growth(d: int, g: int, days: List[int]) -> List[str]: Given the intervals d and g, and a list of days, determine if the plant grows an additional centimeter on those days due to genetic mutation. :param d: int - the number of days after which the plant grows normally :param g: int - the number of days after which the plant grows an extra centimeter :param days: list - the specific days to check for additional growth :return: list of strings 'YES' or 'NO' for additional growth on the given days >>> check_additional_growth(3, 5, [1, 5, 15, 20]) ['NO', 'YES', 'YES', 'YES'] >>> check_additional_growth(2, 7, [2, 14, 28]) ['NO', 'YES', 'YES'] pass","solution":"def check_additional_growth(d, g, days): Given the intervals d and g, and a list of days, determine if the plant grows an additional centimeter on those days due to genetic mutation. :param d: int - the number of days after which the plant grows normally :param g: int - the number of days after which the plant grows an extra centimeter :param days: list - the specific days to check for additional growth :return: list of strings 'YES' or 'NO' for additional growth on the given days results = [] for day in days: if day % g == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def maximalRectangle(matrix): Find the area of the largest rectangle containing only 1s in a given binary matrix. >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 6 >>> maximalRectangle([ ... [0, 1, 0], ... [1, 1, 1], ... [1, 1, 1] ... ]) 6 >>> maximalRectangle([ ... [0, 0], ... [0, 0] ... ]) 0 >>> maximalRectangle([ ... [1, 1, 1, 1] ... ]) 4 >>> maximalRectangle([ ... [1], ... [1], ... [1], ... [0], ... [1] ... ]) 3 >>> maximalRectangle([]) 0","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 rows, cols = len(matrix), len(matrix[0]) heights = [0] * cols for row in matrix: for i in range(cols): heights[i] = heights[i] + 1 if row[i] == 1 else 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): stack = [-1] max_area = 0 for i in range(len(heights)): while stack[-1] != -1 and heights[stack[-1]] >= heights[i]: height = heights[stack.pop()] width = i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack[-1] != -1: height = heights[stack.pop()] width = len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area # Example usage: # matrix = [ # [1, 0, 1, 0, 0], # [1, 0, 1, 1, 1], # [1, 1, 1, 1, 1], # [1, 0, 0, 1, 0] # ] # print(maximalRectangle(matrix)) # Output: 6"},{"question":"def find_max_congestion_bridge(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Analyze the traffic data and find the bridge that has the maximum congestion for each test case. Congestion for a bridge is defined as the product of the number of vehicles and the travel time across the bridge. If multiple bridges have the same maximum congestion, return the bridge with the smallest index. Args: test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases. Each test case is a tuple containing an integer N (number of bridges) and a list of N tuples, each containing two integers Vi (number of vehicles) and Ti (travel time across the bridge). Returns: List[int]: List of 1-based index of the bridge with the maximum congestion for each test case. >>> find_max_congestion_bridge([(1, [(10, 5)])]) [1] >>> find_max_congestion_bridge([(3, [(10, 5), (8, 6), (12, 4)]), (4, [(20, 3), (15, 4), (10, 5), (7, 6)])]) [1, 1]","solution":"def find_max_congestion_bridge(test_cases): results = [] for case in test_cases: N = case[0] bridges = case[1] max_congestion = -1 max_index = -1 for i in range(N): Vi, Ti = bridges[i] congestion = Vi * Ti if congestion > max_congestion: max_congestion = congestion max_index = i elif congestion == max_congestion: max_index = min(max_index, i) results.append(max_index + 1) return results"},{"question":"def is_happy_number(n: int) -> bool: Determines if a given number n is a Happy Number. >>> is_happy_number(19) True >>> is_happy_number(2) False def get_next(number): # Helper function to get the next number in the sequence pass seen = set() while n != 1 and n not in seen: # Implement the logic for checking Happy Number pass return n == 1","solution":"def is_happy_number(n): Determines if a number n is a Happy Number. Returns True if it is a Happy Number, otherwise returns False. def get_next(number): return sum(int(char) ** 2 for char in str(number)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1"},{"question":"class BookCatalog: def __init__(self): self.books = set() def add_book(self, title): self.books.add(title) def check_book(self, title): return \\"YES\\" if title in self.books else \\"NO\\" def process_operations(operations): Process a list of operations to add and check books in Kathy's collection. Args: operations (List[str]): List of operations to be performed. Returns: List[str]: List of results for each check operation (\\"YES\\" or \\"NO\\"). >>> process_operations([\\"1 Pride and Prejudice\\", \\"1 The Great Gatsby\\", \\"2 Pride and Prejudice\\", \\"2 Moby Dick\\", \\"1 Moby Dick\\", \\"2 Moby Dick\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"class BookCatalog: def __init__(self): self.books = set() def add_book(self, title): self.books.add(title) def check_book(self, title): return \\"YES\\" if title in self.books else \\"NO\\" def process_operations(operations): catalog = BookCatalog() results = [] for operation in operations: parts = operation.split(maxsplit=1) if parts[0] == \\"1\\": catalog.add_book(parts[1]) elif parts[0] == \\"2\\": results.append(catalog.check_book(parts[1])) return results"},{"question":"import math from typing import List def is_prime(n: int) -> str: Determines if a number n is prime. Parameters: n (int): The number to check. Returns: str: \\"PRIME\\" if n is a prime number, \\"NOT PRIME\\" otherwise. def evaluate_numbers(numbers: List[int]) -> List[str]: Evaluates a list of numbers, returning whether each is prime or not. Parameters: numbers (list of int): The list of numbers to evaluate. Returns: list of str: A list of \\"PRIME\\" or \\"NOT PRIME\\" for each number. # Example usage: # >>> evaluate_numbers([2, 4, 5, 10, 11]) # [\\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\"] # Unit tests: def test_is_prime(): assert is_prime(2) == \\"PRIME\\" assert is_prime(3) == \\"PRIME\\" assert is_prime(4) == \\"NOT PRIME\\" assert is_prime(5) == \\"PRIME\\" assert is_prime(10) == \\"NOT PRIME\\" assert is_prime(11) == \\"PRIME\\" assert is_prime(1) == \\"NOT PRIME\\" assert is_prime(0) == \\"NOT PRIME\\" assert is_prime(-5) == \\"NOT PRIME\\" assert is_prime(13) == \\"PRIME\\" assert is_prime(25) == \\"NOT PRIME\\" def test_evaluate_numbers(): assert evaluate_numbers([2, 4, 5, 10, 11]) == [\\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\"] assert evaluate_numbers([17, 18, 19, 20, 23]) == [\\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\"] assert evaluate_numbers([31, 33, 37, 39, 41]) == [\\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\"] assert evaluate_numbers([101, 102, 103, 104, 105]) == [\\"PRIME\\", \\"NOT PRIME\\", \\"PRIME\\", \\"NOT PRIME\\", \\"NOT PRIME\\"] assert evaluate_numbers([]) == [] def test_edge_cases(): assert evaluate_numbers([1]) == [\\"NOT PRIME\\"] assert evaluate_numbers([0]) == [\\"NOT PRIME\\"] assert evaluate_numbers([-1, -10, -13]) == [\\"NOT PRIME\\", \\"NOT PRIME\\", \\"NOT PRIME\\"] assert evaluate_numbers([10**6]) == [\\"NOT PRIME\\"] assert evaluate_numbers([10**6 + 3]) == [\\"PRIME\\"]","solution":"import math def is_prime(n): Determines if a number n is prime. Parameters: n (int): The number to check. Returns: str: \\"PRIME\\" if n is a prime number, \\"NOT PRIME\\" otherwise. if n <= 1: return \\"NOT PRIME\\" if n == 2: return \\"PRIME\\" if n % 2 == 0: return \\"NOT PRIME\\" for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return \\"NOT PRIME\\" return \\"PRIME\\" def evaluate_numbers(numbers): Evaluates a list of numbers, returning whether each is prime or not. Parameters: numbers (list of int): The list of numbers to evaluate. Returns: list of str: A list of \\"PRIME\\" or \\"NOT PRIME\\" for each number. return [is_prime(number) for number in numbers]"},{"question":"def calculate_popularity_scores(n, hashtags_weights, m, posts): Calculates the popularity scores for a list of posts. :param n: Number of different hashtags :param hashtags_weights: List of tuples containing hashtag and its weight :param m: Number of posts :param posts: List of posts, where each post is a list of hashtags :return: List of popularity scores for each post >>> n = 5 >>> hashtags_weights = [('#food', 5), ('#travel', 8), ('#photography', 7), ('#foodie', 6), ('#nature', 4)] >>> m = 3 >>> posts = [['#food', '#travel'], ['#photography', '#nature', '#travel'], ['#food', '#foodie', '#nature']] >>> calculate_popularity_scores(n, hashtags_weights, m, posts) [13, 19, 15] >>> n = 3 >>> hashtags_weights = [('#tech', 10), ('#science', 15), ('#art', 20)] >>> m = 2 >>> posts = [['#tech', '#science'], ['#art', '#tech']] >>> calculate_popularity_scores(n, hashtags_weights, m, posts) [25, 30] >>> n = 4 >>> hashtags_weights = [('#fun', 3), ('#summer', 5), ('#holidays', 7), ('#sun', 2)] >>> m = 2 >>> posts = [['#fun', '#summer', '#fun'], ['#holidays', '#sun', '#holidays']] >>> calculate_popularity_scores(n, hashtags_weights, m, posts) [8, 9] >>> n = 2 >>> hashtags_weights = [('#uni', 10), ('#exam', 5)] >>> m = 2 >>> posts = [['#uni'], ['#exam']] >>> calculate_popularity_scores(n, hashtags_weights, m, posts) [10, 5] >>> n = 0 >>> hashtags_weights = [] >>> m = 2 >>> posts = [[], []] >>> calculate_popularity_scores(n, hashtags_weights, m, posts) [0, 0]","solution":"def calculate_popularity_scores(n, hashtags_weights, m, posts): Calculates the popularity scores for a list of posts. :param n: Number of different hashtags :param hashtags_weights: List of tuples containing hashtag and its weight :param m: Number of posts :param posts: List of posts, where each post is a list of hashtags :return: List of popularity scores for each post # Create a dictionary to map hashtags to their weights hashtag_to_weight = {hashtag: weight for hashtag, weight in hashtags_weights} # Calculate popularity scores for each post popularity_scores = [] for post in posts: unique_hashtags = set(post) # Use a set to count each hashtag only once score = sum(hashtag_to_weight[hashtag] for hashtag in unique_hashtags if hashtag in hashtag_to_weight) popularity_scores.append(score) return popularity_scores # Example usage n = 5 hashtags_weights = [('#food', 5), ('#travel', 8), ('#photography', 7), ('#foodie', 6), ('#nature', 4)] m = 3 posts = [['#food', '#travel'], ['#photography', '#nature', '#travel'], ['#food', '#foodie', '#nature']] popularity_scores = calculate_popularity_scores(n, hashtags_weights, m, posts) for score in popularity_scores: print(score)"},{"question":"import re from collections import Counter from typing import List def most_frequent_word(text: str) -> str: Identify the most frequently occurring word in the text. Rules: 1. A word is defined as a sequence of alphabetic characters. 2. Words are case-insensitive. 3. Punctuation, numbers, and other non-alphabetic characters should be ignored. 4. The function should return the result in lowercase. Examples: >>> most_frequent_word(\\"Hello, world! Hello.\\") 'hello' >>> most_frequent_word(\\"This is a test. This test is only a test.\\") 'test' >>> most_frequent_word(\\"Hello, hello, hi!\\") 'hello' >>> most_frequent_word(\\"One fish, two fish, red fish, blue fish.\\") 'fish' pass","solution":"import re from collections import Counter def most_frequent_word(text): Returns the most frequently occurring word in the text according to specified rules. # Normalize the text to lowercase and find all words words = re.findall(r'[a-zA-Z]+', text.lower()) if not words: return \\"\\" # Count occurrences of each word word_counts = Counter(words) # Find the most frequently occurring word most_common_word, _ = max(word_counts.items(), key=lambda item: (item[1], -words.index(item[0]))) return most_common_word"},{"question":"from typing import List def is_reachable(n: int, m: int, grid: List[str], sx: int, sy: int, dx: int, dy: int) -> str: Determine whether the drone can reach the destination from the start point in a city grid. >>> is_reachable(5, 5, [\\".....\\", \\".#...\\", \\"....#\\", \\".#.#.\\", \\"...#.\\"], 1, 1, 5, 5) 'YES' >>> is_reachable(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"], 1, 1, 3, 3) 'NO' pass def test_is_reachable_case1(): n = 5 m = 5 grid = [ \\".....\\", \\".#...\\", \\"....#\\", \\".#.#.\\", \\"...#.\\" ] sx, sy, dx, dy = 1, 1, 5, 5 assert is_reachable(n, m, grid, sx, sy, dx, dy) == \\"YES\\" def test_is_reachable_case2(): n = 3 m = 3 grid = [ \\".#.\\", \\".#.\\", \\".#.\\" ] sx, sy, dx, dy = 1, 1, 3, 3 assert is_reachable(n, m, grid, sx, sy, dx, dy) == \\"NO\\" def test_is_reachable_blocked_start(): n = 3 m = 3 grid = [ \\"#\\", \\"#.#\\", \\"#..\\" ] sx, sy, dx, dy = 2, 2, 3, 3 assert is_reachable(n, m, grid, sx, sy, dx, dy) == \\"NO\\" def test_is_reachable_blocked_end(): n = 3 m = 3 grid = [ \\"...\\", \\".#.\\", \\"..#\\" ] sx, sy, dx, dy = 1, 1, 3, 3 assert is_reachable(n, m, grid, sx, sy, dx, dy) == \\"NO\\" def test_is_reachable_no_obstacles(): n = 2 m = 2 grid = [ \\"..\\", \\"..\\" ] sx, sy, dx, dy = 1, 1, 2, 2 assert is_reachable(n, m, grid, sx, sy, dx, dy) == \\"YES\\"","solution":"def is_reachable(n, m, grid, sx, sy, dx, dy): from collections import deque sx -= 1 sy -= 1 dx -= 1 dy -= 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if grid[sx][sy] == '#' or grid[dx][dy] == '#': return \\"NO\\" visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([(sx, sy)]) visited[sx][sy] = True while queue: x, y = queue.popleft() if (x, y) == (dx, dy): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"from collections import deque def min_moves_to_reach_end(grid, N, M): Calculate the minimum number of moves needed to reach the bottom-right corner of the given grid. The table represents a grid where you start at the top-left corner (cell (1,1)) and your goal is to reach the bottom-right corner (cell (N,M)). You can only move right or down, but stepping on a cell containing a 1 allows you to take an extra step in any of the four directions. Parameters: grid (List[List[int]]): A 2D list representing the grid. N (int): The number of rows. M (int): The number of columns. Returns: int: The minimum number of moves to reach the bottom-right corner or -1 if it is not possible. >>> min_moves_to_reach_end([ [0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 0, 0] ], 3, 4) 5 >>> min_moves_to_reach_end([ [0, 1], [1, 0] ], 2, 2) 2 def process_test_cases(t, test_cases): Process multiple test cases to compute the minimum number of moves for each. Parameters: t (int): Number of test cases. test_cases (List[Dict]): A list of dictionaries, each containing: - 'N': The number of rows. - 'M': The number of columns. - 'grid': A 2D list representing the grid. Returns: List[int]: A list containing the results for each test case. Example: >>> test_cases = [ { 'N': 3, 'M': 4, 'grid': [ [0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 0, 0] ] }, { 'N': 2, 'M': 2, 'grid': [ [0, 1], [1, 0] ] } ] >>> process_test_cases(2, test_cases) [5, 2] def test_min_moves_to_reach_end(): results = process_test_cases(2, [ { 'N': 3, 'M': 4, 'grid': [ [0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 0, 0] ] }, { 'N': 2, 'M': 2, 'grid': [ [0, 1], [1, 0] ] } ]) assert results == [5, 2] if __name__ == \\"__main__\\": test_min_moves_to_reach_end() print(\\"All tests passed!\\")","solution":"from collections import deque def min_moves_to_reach_end(grid, N, M): ''' This function calculates the minimum number of moves needed to reach the bottom-right corner. ''' directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def bfs(): # BFS to find the shortest path queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # Check if we have reached the bottom-right corner if r == N - 1 and c == M - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and (nr, nc) not in visited: if grid[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) else: # We can take an additional step to any direction for er, ec in directions: er, ec = nr + er, nc + ec if 0 <= er < N and 0 <= ec < M and (er, ec) not in visited: queue.append((er, ec, dist + 2)) visited.add((er, ec)) return -1 return bfs() def process_test_cases(t, test_cases): results = [] for case in test_cases: N, M, grid = case['N'], case['M'], case['grid'] result = min_moves_to_reach_end(grid, N, M) results.append(result) return results"},{"question":"def repeat_word(): Read multiple datasets and print the word w n times separated by a space. The input format: n w The input ends with a dataset where n is 0. Your program should not process this dataset. Example Input: 3 hello 2 world 5 test 0 end Example Output: hello hello hello world world test test test test test","solution":"def repeat_word(): import sys input = sys.stdin.read data = input().splitlines() results = [] for line in data: n, w = line.split() n = int(n) if n == 0: break results.append((w + ' ') * n) for result in results: print(result.strip())"},{"question":"def find_pairs_with_sum(numbers: List[int], target: int) -> List[Tuple[int, int]]: Finds all pairs of integers in a given list that sum up to a specific target number. >>> find_pairs_with_sum([1, 3, 2, 2, 4, 5], 6) [(1, 5), (2, 4)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) [] :param numbers: List of integers :param target: Target sum :return: List of unique pairs that sum up to the target number","solution":"def find_pairs_with_sum(numbers, target): Finds all pairs of integers in a given list that sum up to a specific target number. :param numbers: List of integers :param target: Target sum :return: List of unique pairs that sum up to the target number numbers.sort() pairs = set() seen = set() for number in numbers: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) return sorted(pairs)"},{"question":"def product_except_self(nums): Given an array of integers, return an array where each element at index i is the product of all the elements in the original array except for the one at i. Solve this problem without using division and in O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Returns an array where each element at index i is the product of all the elements in the original array except for the one at i. length = len(nums) result = [1] * length # Initialize the result array with ones # Compute the prefix product for each element prefix = 1 for i in range(length): result[i] *= prefix prefix *= nums[i] # Compute the suffix product for each element and multiply with the result array suffix = 1 for i in reversed(range(length)): result[i] *= suffix suffix *= nums[i] return result"},{"question":"def can_have_even_sum_component(n, m, a, edges): Determine if it is possible to delete exactly m edges such that at least one component has an even sum and return the minimum number of such components. If not possible, return -1. >>> can_have_even_sum_component(6, 2, [1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 2 >>> can_have_even_sum_component(5, 1, [5, 6, 7, 8, 9], [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> can_have_even_sum_component(4, 2, [1, 8, 7, 6], [(1, 2), (2, 3), (3, 4)]) 1 def process_test_cases(t, test_cases): Process multiple test cases for the can_have_even_sum_component function. >>> test_cases = [ ... {\\"n\\": 6, \\"m\\": 2, \\"a\\": [1, 2, 3, 4, 5, 6], \\"edges\\": [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]}, ... {\\"n\\": 5, \\"m\\": 1, \\"a\\": [5, 6, 7, 8, 9], \\"edges\\": [(1, 2), (2, 3), (3, 4), (4, 5)]}, ... {\\"n\\": 4, \\"m\\": 2, \\"a\\": [1, 8, 7, 6], \\"edges\\": [(1, 2), (2, 3), (3, 4)]}] >>> process_test_cases(3, test_cases) [2, 1, 1]","solution":"def can_have_even_sum_component(n, m, a, edges): # Function to check the conditions and return the minimum number of even sum components # Or -1 if not possible total_sum = sum(a) if total_sum % 2 == 0: # Total sum is even, so we can have at least one component with an even sum return 1 # When total sum is odd, we need to check if after removing exactly \`m\` edges we can achieve an even sum component # If we can't ever make components where sum is even, return -1 return -1 if m == n-1 else 1 def process_test_cases(t, test_cases): results = [] for test_case in test_cases: n, m = test_case[\\"n\\"], test_case[\\"m\\"] a = test_case[\\"a\\"] edges = test_case[\\"edges\\"] result = can_have_even_sum_component(n, m, a, edges) results.append(result) return results"},{"question":"def removeDuplicates(S: str) -> str: Removes duplicate characters from the input string S while preserving the original order of characters. Parameters: S (str): The input string consisting of lowercase alphabets. Returns: str: The string after removing duplicates. Examples: >>> removeDuplicates(\\"geeksforgeeks\\") 'geksfor' >>> removeDuplicates(\\"hello\\") 'helo' >>> removeDuplicates(\\"character\\") 'charte'","solution":"def removeDuplicates(S): Removes duplicate characters from the input string S while preserving the original order of characters. Parameters: S (str): The input string consisting of lowercase alphabets. Returns: str: The string after removing duplicates. seen = set() result = [] for char in S: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def min_cost_to_travel(H: int, W: int, cost: List[List[int]]) -> int: Compute the minimum travel cost from the top-left corner (0, 0) to the bottom-right corner (H-1, W-1). Args: H (int): the height of the grid. W (int): the width of the grid. cost (List[List[int]]): 2D list representing the cost matrix where cost[i][j] is the cost of entering cell (i, j). Returns: int: the minimum travel cost. Examples: >>> min_cost_to_travel(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_to_travel(1, 1, [[0]]) 0 from solution import min_cost_to_travel def test_example_case(): H = 3 W = 3 cost = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_to_travel(H, W, cost) == 7 def test_single_cell(): H = 1 W = 1 cost = [ [0] ] assert min_cost_to_travel(H, W, cost) == 0 def test_one_row(): H = 1 W = 4 cost = [ [1, 2, 3, 4] ] assert min_cost_to_travel(H, W, cost) == 10 def test_one_column(): H = 4 W = 1 cost = [ [1], [2], [3], [4] ] assert min_cost_to_travel(H, W, cost) == 10 def test_large_grid(): H = 3 W = 3 cost = [ [1, 1000, 1], [1, 1000, 1], [1, 1, 1] ] assert min_cost_to_travel(H, W, cost) == 5 def test_path_in_middle(): H = 4 W = 4 cost = [ [1, 1, 1, 1], [1, 100, 100, 1], [1, 1, 100, 1], [1, 1, 1, 1] ] assert min_cost_to_travel(H, W, cost) == 7 def test_all_zero_cost(): H = 3 W = 3 cost = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert min_cost_to_travel(H, W, cost) == 0","solution":"import heapq def min_cost_to_travel(H, W, cost): This function returns the minimum cost to travel from the top-left corner to the bottom-right corner of a grid. # Directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Priority queue to store (cost, x, y) pq = [(cost[0][0], 0, 0)] # Distance matrix initialized to infinity dist = [[float('inf')] * W for _ in range(H)] dist[0][0] = cost[0][0] while pq: current_cost, x, y = heapq.heappop(pq) # If we have reached the bottom-right corner if x == H-1 and y == W-1: return current_cost # Visit all neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < H and 0 <= ny < W: new_cost = current_cost + cost[nx][ny] if new_cost < dist[nx][ny]: dist[nx][ny] = new_cost heapq.heappush(pq, (new_cost, nx, ny)) return dist[H-1][W-1]"},{"question":"def unique_paths(m: int, n: int, grid: List[List[int]]) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, where certain cells are blocked and cannot be passed through. Args: m (int): Number of rows. n (int): Number of columns. grid (List[List[int]]): The grid representation. Returns: int: Number of unique paths from top-left to bottom-right. >>> unique_paths(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths(3, 3, [[0, 1, 0], [1, 0, 0], [0, 0, 0]]) 0","solution":"def unique_paths(m, n, grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, where certain cells are blocked and cannot be passed through. # Create a dp table of the same size as the grid dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 # Fill the dp table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # Blocked cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] # The number of ways to reach the bottom-right corner return dp[-1][-1] # Function to read input as specified in the question def read_input(): m, n = map(int, input().split()) grid = [list(map(int, input().split())) for _ in range(m)] print(unique_paths(m, n, grid))"},{"question":"def infix_to_postfix(expression: str) -> str: Convert a given infix expression to its equivalent postfix (Reverse Polish notation) expression. >>> infix_to_postfix(\\"2 + 3\\") '2 3 +' >>> infix_to_postfix(\\"2 + 3 * 4\\") '2 3 4 * +' >>> infix_to_postfix(\\"((2 + 3) * 5) - (8 / (4 + 2))\\") '2 3 + 5 * 8 4 2 + / -' >>> infix_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 )\\") '3 4 2 * 1 5 - / +' >>> infix_to_postfix(\\"((1 + 2) * 3) + (4 * (5 + 6))\\") '1 2 + 3 * 4 5 6 + * +' >>> infix_to_postfix(\\"42\\") '42'","solution":"def infix_to_postfix(expression): precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output = [] stack = [] def is_operator(c): return c in precedence def precedence_level(c): return precedence[c] tokens = expression.replace('(', ' ( ').replace(')', ' ) ').split() for token in tokens: if token.isnumeric(): output.append(token) elif token == '(': stack.append(token) elif token == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # pop '(' elif is_operator(token): while stack and stack[-1] != '(' and precedence_level(stack[-1]) >= precedence_level(token): output.append(stack.pop()) stack.append(token) while stack: output.append(stack.pop()) return ' '.join(output)"},{"question":"def probability_equal_zeros_ones(dna1: str, dna2: str) -> str: Calculate the probability that the offspring of two Trivellea plants will have a DNA string with an equal number of 0s and 1s. Arguments: dna1 -- binary DNA string of the first parent plant dna2 -- binary DNA string of the second parent plant Returns: The probability as a string rounded to five decimal places. >>> probability_equal_zeros_ones(\\"1010\\", \\"0101\\") \\"0.00000\\" >>> probability_equal_zeros_ones(\\"1100\\", \\"1010\\") \\"1.00000\\"","solution":"def calculate_xor_dna(dna1, dna2): Helper function to calculate the XOR DNA string from two binary DNA strings. return ''.join(str(int(b1) ^ int(b2)) for b1, b2 in zip(dna1, dna2)) def probability_equal_zeros_ones(dna1, dna2): Calculate the probability that the offspring of two Trivellea plants will have a DNA string with an equal number of 0s and 1s. n = len(dna1) # If n is odd, it's impossible to have an equal number of 0s and 1s if n % 2 != 0: return \\"0.00000\\" # Calculate XOR DNA string of the offspring offspring_dna = calculate_xor_dna(dna1, dna2) # Count the number of 0s and 1s count_0s = offspring_dna.count('0') count_1s = offspring_dna.count('1') # Check if the number of 0s and 1s are equal if count_0s == count_1s: return \\"1.00000\\" else: return \\"0.00000\\""},{"question":"def find_pairs_with_difference_k(nums, k): Determines if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is equal to k. Examples: >>> find_pairs_with_difference_k([10, 15, 3, 7], 5) \\"YES\\" >>> find_pairs_with_difference_k([1, 2, 3, 4], 3) \\"YES\\" >>> find_pairs_with_difference_k([1, 5, 9, 14], 6) \\"NO\\" def solve(test_cases): Process each test case to determine if there exist two indices with the given difference. test_cases: list of tuples where each tuple contains an integer k and a list of integers nums Returns a list of results for each test case. def parse_input(input_str): Parse the input string and return test cases as list of tuples. input_str: a string containing the input as described in the problem statement Returns a list of tuples where each tuple is (k, nums) for each test case. from solution import find_pairs_with_difference_k, solve, parse_input def test_find_pairs_with_difference_k(): assert find_pairs_with_difference_k([10, 15, 3, 7], 5) == \\"YES\\" assert find_pairs_with_difference_k([1, 2, 3, 4], 3) == \\"YES\\" assert find_pairs_with_difference_k([1, 5, 9, 14], 6) == \\"NO\\" assert find_pairs_with_difference_k([-1, -2, -3, -4], 1) == \\"YES\\" assert find_pairs_with_difference_k([-1, 1, 2, 4], 3) == \\"YES\\" assert find_pairs_with_difference_k([1], 1) == \\"NO\\" def test_solve(): input_cases = [ (5, [10, 15, 3, 7]), (3, [1, 2, 3, 4]), (6, [1, 5, 9, 14]) ] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert solve(input_cases) == expected_output def test_parse_input(): input_str = \\"3n5n10 15 3 7n3n1 2 3 4n6n1 5 9 14\\" expected_output = [ (5, [10, 15, 3, 7]), (3, [1, 2, 3, 4]), (6, [1, 5, 9, 14]) ] assert parse_input(input_str) == expected_output","solution":"def find_pairs_with_difference_k(nums, k): Determines if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is equal to k. num_set = set(nums) for num in nums: if (num + k) in num_set or (num - k) in num_set: return \\"YES\\" return \\"NO\\" def solve(test_cases): Process each test case to determine if there exist two indices with the given difference. test_cases: list of tuples where each tuple contains an integer k and a list of integers nums Returns a list of results for each test case. results = [] for k, nums in test_cases: results.append(find_pairs_with_difference_k(nums, k)) return results def parse_input(input_str): Parse the input string and return test cases as list of tuples. input_str: a string containing the input as described in the problem statement Returns a list of tuples where each tuple is (k, nums) for each test case. input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): k = int(input_lines[index]) nums = list(map(int, input_lines[index+1].split())) test_cases.append((k, nums)) index += 2 return test_cases"},{"question":"def transpose(mat): Returns the transpose of a given n x n matrix. >>> transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose([[1, 2], [3, 4]]) [[1, 3], [2, 4]]","solution":"def transpose(mat): Returns the transpose of a given n x n matrix. n = len(mat) transposed = [] for i in range(n): new_row = [] for j in range(n): new_row.append(mat[j][i]) transposed.append(new_row) return transposed"},{"question":"def maxGold(N: int, A: List[int]) -> int: Given an array A of size N, where each element represents the amount of gold coins in a chest, calculate the maximum amount of gold coins you can collect with the restriction that you cannot take coins from two consecutive chests. >>> maxGold(4, [5, 3, 4, 11]) 16 >>> maxGold(3, [8, 15, 3]) 15 >>> maxGold(1, [7]) 7 >>> maxGold(2, [7, 10]) 10 >>> maxGold(0, []) 0 >>> maxGold(5, [2, 4, 6, 8, 10]) 18 >>> maxGold(5, [5, 5, 5, 5, 5]) 15","solution":"def maxGold(N, A): if N == 0: return 0 if N == 1: return A[0] dp = [0] * N dp[0] = A[0] dp[1] = max(A[0], A[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + A[i]) return dp[-1]"},{"question":"def min_blocks(M: int) -> int: Returns the minimum number of blocks required to build M stacks with heights 1, 2, ..., M. >>> min_blocks(3) 6 >>> min_blocks(4) 10 pass def solve(test_cases: List[int]) -> List[int]: For each test case, calculate and return the minimum number of blocks required. >>> solve([3]) [6] >>> solve([4, 3, 1]) [10, 6, 1] pass","solution":"def min_blocks(M): Returns the minimum number of blocks required to build M stacks with heights 1, 2, ..., M. The sum of the first M natural numbers is given by the formula M * (M + 1) // 2. return M * (M + 1) // 2 def solve(test_cases): For each test case, calculate and return the minimum number of blocks required. results = [] for M in test_cases: results.append(min_blocks(M)) return results"},{"question":"def print_hourglass(n): Prints an hourglass pattern using the '#' symbol with n rows. :param n: An odd integer greater than 1 and less than or equal to 15 Example: >>> print_hourglass(3) # # # >>> print_hourglass(7) # # # # # # #","solution":"def print_hourglass(n): Prints an hourglass pattern using the '#' symbol with n rows. :param n: An odd integer greater than 1 and less than or equal to 15 # Ensure n is an odd number and within the specified range if n % 2 == 0 or n <= 1 or n > 15: raise ValueError(\\"n must be an odd number greater than 1 and less than or equal to 15\\") for i in range(n): if i <= n//2: print(\\" \\" * i + \\"#\\" * (n - 2 * i)) else: print(\\" \\" * (n - i - 1) + \\"#\\" * (2 * (i - n//2) + 1)) # Example calls to visually inspect the output # print_hourglass(7)"},{"question":"from typing import List def balance_parentheses(lst: List[str]) -> List[int]: Returns a list of integers representing the minimum number of parentheses that need to be added or removed to make all parentheses in each string balanced. >>> balance_parentheses([\\"(()))\\", \\"(((\\", \\"(())\\", \\")(\\", \\"()\\"]) [1, 3, 0, 2, 0] >>> balance_parentheses([\\"\\"]) [0] >>> balance_parentheses([\\"()\\", \\"(())\\", \\"(()())\\"]) [0, 0, 0] >>> balance_parentheses([\\"(\\", \\"(((\\", \\"(((((\\"]) [1, 3, 5] >>> balance_parentheses([\\")\\", \\"))\\", \\")))\\"]) [1, 2, 3] >>> balance_parentheses([\\"()())\\", \\"((())\\"]) [1, 1] >>> balance_parentheses([\\"((((((\\"]) [6] >>> balance_parentheses([\\")))))\\"]) [5]","solution":"from typing import List def balance_parentheses(lst: List[str]) -> List[int]: Returns a list of integers representing the minimum number of parentheses that need to be added or removed to make all parentheses in each string balanced. res = [] for s in lst: open_count = 0 close_count = 0 for char in s: if char == '(': open_count += 1 elif char == ')' and open_count > 0: open_count -= 1 else: close_count += 1 res.append(open_count + close_count) return res"},{"question":"def next_permutation(N: int) -> int: Given an integer N, this function returns the next higher permutation of its digits. If no such permutation exists, it returns the smallest permutation of N. >>> next_permutation(231) == 312 >>> next_permutation(987) == 789","solution":"def next_permutation(N): Given an integer N, this function returns the next higher permutation of its digits. If no such permutation exists, it returns the smallest permutation of N. digits = list(str(N)) length = len(digits) # Step 1: Find the first decreasing digit from the right i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, return the smallest permutation if i == -1: return int(''.join(sorted(digits))) # Step 2: Find the smallest digit on the right side of the found digit which is larger than the found digit j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digits digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits to the right of the initially found digit digits = digits[:i+1] + digits[i+1:][::-1] return int(''.join(digits))"},{"question":"def longestUniqueSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longestUniqueSubstring(\\"abcabcbb\\") 3 >>> longestUniqueSubstring(\\"bbbbb\\") 1 >>> longestUniqueSubstring(\\"pwwkew\\") 3 >>> longestUniqueSubstring(\\"\\") 0 >>> longestUniqueSubstring(\\"a\\") 1 >>> longestUniqueSubstring(\\"ab\\") 2 >>> longestUniqueSubstring(\\"abcd\\") 4 >>> longestUniqueSubstring(\\"aab\\") 2 >>> longestUniqueSubstring(\\"dvdf\\") 3 >>> longestUniqueSubstring(\\"anviaj\\") 5 >>> longestUniqueSubstring(\\"abacacab\\") 3 >>> longestUniqueSubstring(\\"tmmzuxt\\") 5","solution":"def longestUniqueSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. # Initialize the starting point of the window and the max_length variable start = 0 max_length = 0 # Dictionary to store the last indexes of each character seen char_index_map = {} for end in range(len(s)): if s[end] in char_index_map: # update the start position if the character is already seen start = max(start, char_index_map[s[end]] + 1) # Update the last seen index of the character char_index_map[s[end]] = end # Calculate the length of the current window and update max_length max_length = max(max_length, end - start + 1) return max_length"},{"question":"def most_sold_genre(N: int, genres: List[str]) -> tuple: Find the genre that has been sold the most and the number of times it was sold. Parameters: N (int): number of books sold genres (list): list of genres of books sold Returns: tuple: (genre, count) the genre that was sold the most and the count >>> most_sold_genre(6, [\\"fantasy\\", \\"mystery\\", \\"romance\\", \\"fantasy\\", \\"mystery\\", \\"fantasy\\"]) ('fantasy', 3) >>> most_sold_genre(3, [\\"thriller\\", \\"romance\\", \\"fantasy\\"]) ('thriller', 1) # based on alphabetical order when all counts are equal >>> most_sold_genre(1, [\\"thriller\\"]) ('thriller', 1) >>> most_sold_genre(10, [\\"fantasy\\"] * 5 + [\\"romance\\"] * 3 + [\\"mystery\\"] * 2) ('fantasy', 5)","solution":"def most_sold_genre(N, genres): Find the genre that has been sold the most and the number of times it was sold. Parameters: N (int): number of books sold genres (list): list of genres of books sold Returns: tuple: (genre, count) the genre that was sold the most and the count from collections import Counter genre_count = Counter(genres) most_common_genre, count = genre_count.most_common(1)[0] return most_common_genre, count"},{"question":"def lexicographically_smallest_string(s: str) -> str: Transform the input string into the lexicographically smallest string possible using the described operations. >>> lexicographically_smallest_string(\\"BCDA\\") \\"ABCD\\" >>> lexicographically_smallest_string(\\"ZXYABC\\") \\"ABCXYZ\\" >>> lexicographically_smallest_string(\\"BXABYACZB\\") \\"AABBBCXYZ\\"","solution":"def lexicographically_smallest_string(s): Transform the input string into the lexicographically smallest string possible using the described operations. return \\"\\".join(sorted(s))"},{"question":"def is_palindrome(s: str) -> str: Determine if the given string is a palindrome. >>> is_palindrome(\\"madam\\") \\"YES\\" >>> is_palindrome(\\"hello\\") \\"NO\\" >>> is_palindrome(\\"Race car\\") \\"YES\\" >>> is_palindrome(\\"nurses run\\") \\"YES\\" >>> is_palindrome(\\"a\\") \\"YES\\" >>> is_palindrome(\\" \\") \\"YES\\"","solution":"def is_palindrome(s): Returns \\"YES\\" if the given string is a palindrome, else returns \\"NO\\" # Remove spaces and convert to lowercase cleaned_s = s.replace(\\" \\", \\"\\").lower() # Check if the cleaned string is equal to its reverse if cleaned_s == cleaned_s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def min_swaps_to_alternate(binary_string: str) -> int: You are given a binary string of length n. A binary string is a string containing only the characters '0' and '1'. Your task is to find the minimum number of swaps required to make the string alternating. A string is alternating if no two adjacent characters are the same (i.e., \\"010101\\" or \\"101010\\"). Swapping means selecting any two characters from the string and swapping their positions. Args: binary_string (str): A single string binary_string of length n (1 le n le 10^5), consisting of characters '0' and '1' only. Returns: int: A single integer, the minimum number of swaps required to make the string alternating, or -1 if it is not possible. Examples: >>> min_swaps_to_alternate(\\"101010\\") 0 >>> min_swaps_to_alternate(\\"1001\\") 1 >>> min_swaps_to_alternate(\\"1111\\") -1","solution":"def min_swaps_to_alternate(binary_string: str) -> int: n = len(binary_string) if n <= 1: return 0 # A single character string is already alternating. count_0 = binary_string.count('0') count_1 = binary_string.count('1') if abs(count_0 - count_1) > 1: return -1 # Pattern starting with '0' pattern_0 = ''.join('0' if i % 2 == 0 else '1' for i in range(n)) # Pattern starting with '1' pattern_1 = ''.join('1' if i % 2 == 0 else '0' for i in range(n)) mismatch_0 = sum(1 for i in range(n) if binary_string[i] != pattern_0[i]) mismatch_1 = sum(1 for i in range(n) if binary_string[i] != pattern_1[i]) if count_0 == count_1: return min(mismatch_0 // 2, mismatch_1 // 2) elif count_0 > count_1: return mismatch_0 // 2 else: return mismatch_1 // 2"},{"question":"from typing import List, Tuple def smallest_lexicographic_array(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[List[int]]: Find the lexicographically smallest array achievable after K reversals. Args: T: Integer, number of test cases. test_cases: List of tuples, each containing: - N: Integer, size of array. - K: Integer, number of operations. - A: List of integers, the array elements. Returns: List of lists, each containing the lexicographically smallest array for each test case. Example: >>> smallest_lexicographic_array(2, [(5, 1, [3, 1, 4, 1, 5]), (4, 2, [4, 3, 2, 1])]) [[1, 3, 4, 1, 5], [1, 2, 3, 4]] pass # Implementation here def test_sample_1(): T = 2 test_cases = [ (5, 1, [3, 1, 4, 1, 5]), (4, 2, [4, 3, 2, 1]) ] expected = [ [1, 3, 4, 1, 5], [1, 2, 3, 4] ] assert smallest_lexicographic_array(T, test_cases) == expected def test_single_element_array(): T = 1 test_cases = [ (1, 1, [1]) ] expected = [ [1] ] assert smallest_lexicographic_array(T, test_cases) == expected def test_no_reversal_needed(): T = 1 test_cases = [ (5, 1, [1, 2, 3, 4, 5]) ] expected = [ [1, 2, 3, 4, 5] ] assert smallest_lexicographic_array(T, test_cases) == expected def test_short_array(): T = 1 test_cases = [ (3, 1, [3, 1, 2]) ] expected = [ [1, 3, 2] ] assert smallest_lexicographic_array(T, test_cases) == expected def test_two_reversals_needed(): T = 1 test_cases = [ (6, 2, [5, 6, 3, 4, 2, 1]) ] expected = [ [1, 2, 3, 4, 5, 6] ] assert smallest_lexicographic_array(T, test_cases) == expected","solution":"def smallest_lexicographic_array(T, test_cases): results = [] for case in test_cases: N, K, A = case if K > 1: results.append(sorted(A)) else: min_array = A[:] for i in range(N): for j in range(i, N): B = A[:i] + A[i:j+1][::-1] + A[j+1:] min_array = min(min_array, B) results.append(min_array) return results"},{"question":"def lexicographically_smallest_rope(n: int, segments: List[int]) -> List[int]: Returns the lexicographically smallest sequence of segments that maintains the maximum power for the rope. Parameters: n (int): the number of segments in the rope. segments (list of int): the energy levels of the segments in the rope. Returns: list of int: the lexicographically smallest sequence of segments. >>> lexicographically_smallest_rope(4, [3, 3, 1, 2]) [3, 3, 2, 1] >>> lexicographically_smallest_rope(3, [2, 1, 1]) [2, 1, 1]","solution":"def lexicographically_smallest_rope(n, segments): Returns the lexicographically smallest sequence of segments that maintains the maximum power for the rope. Parameters: n (int): the number of segments in the rope. segments (list of int): the energy levels of the segments in the rope. Returns: list of int: the lexicographically smallest sequence of segments. # Sort the segments in descending order to achieve the maximum power segments.sort(reverse=True) return segments"},{"question":"from typing import List, Tuple def find_shortest_travel_time(N: int, K: int, S: int, T: int, train_data: List[Tuple[int, int, int]]) -> int: Find the shortest possible travel time for a commuter to travel from city S to city T. Parameters: N (int): Number of cities. K (int): Number of trains. S (int): Starting city number. T (int): Destination city number. train_data (List[Tuple[int, int, int]]): List of tuples (Ai, Bi, Ti) where Ai and Bi are cities connected by the i-th train and Ti is the travel time. Returns: int: The minimum possible travel time from city S to city T, or -1 if there is no possible route. Examples: >>> find_shortest_travel_time(5, 6, 1, 5, [(1, 2, 4), (2, 3, 3), (3, 4, 2), (4, 5, 1), (1, 3, 7), (2, 5, 8)]) 10 >>> find_shortest_travel_time(3, 2, 1, 3, [(1, 2, 5), (2, 1, 5)]) -1 >>> find_shortest_travel_time(3, 3, 1, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 3)]) 3 >>> find_shortest_travel_time(4, 4, 1, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10)]) 3 >>> find_shortest_travel_time(3, 3, 1, 1, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) 0 pass # Your implementation here def test_shortest_travel_time_basic(): N = 5 K = 6 S = 1 T = 5 train_data = [ (1, 2, 4), (2, 3, 3), (3, 4, 2), (4, 5, 1), (1, 3, 7), (2, 5, 8) ] assert find_shortest_travel_time(N, K, S, T, train_data) == 10 def test_no_connection(): N = 3 K = 2 S = 1 T = 3 train_data = [ (1, 2, 5), (2, 1, 5) ] assert find_shortest_travel_time(N, K, S, T, train_data) == -1 def test_direct_connection(): N = 3 K = 3 S = 1 T = 3 train_data = [ (1, 2, 2), (2, 3, 2), (1, 3, 3) ] assert find_shortest_travel_time(N, K, S, T, train_data) == 3 def test_multiple_paths(): N = 4 K = 4 S = 1 T = 4 train_data = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10) ] assert find_shortest_travel_time(N, K, S, T, train_data) == 3 def test_same_start_end_city(): N = 3 K = 3 S = 1 T = 1 train_data = [ (1, 2, 1), (2, 3, 1), (3, 1, 1) ] assert find_shortest_travel_time(N, K, S, T, train_data) == 0","solution":"import heapq def find_shortest_travel_time(N, K, S, T, train_data): graph = {i: [] for i in range(1, N + 1)} for Ai, Bi, Ti in train_data: graph[Ai].append((Bi, Ti)) graph[Bi].append((Ai, Ti)) # Assuming bidirectional travel # Dijkstra's algorithm priority_queue = [(0, S)] min_times = {i: float('inf') for i in range(1, N + 1)} min_times[S] = 0 while priority_queue: current_time, current_city = heapq.heappop(priority_queue) if current_city == T: return current_time for neighbor, travel_time in graph[current_city]: time = current_time + travel_time if time < min_times[neighbor]: min_times[neighbor] = time heapq.heappush(priority_queue, (time, neighbor)) return -1 if min_times[T] == float('inf') else min_times[T]"},{"question":"import re def password_strength(password: str) -> str: Evaluate the strength of a password based on specific criteria. A strong password: 1. Has at least 8 characters. 2. Contains both uppercase and lowercase letters. 3. Includes at least one numerical digit. 4. Has at least one special character from the set !@#%^&*()-+. >>> password_strength(\\"WeakP@ss\\") \\"Missing numerical digit\\" >>> password_strength(\\"P@ssw0rd\\") \\"Strong Password\\"","solution":"import re def password_strength(password: str) -> str: missing_criteria = [] if len(password) < 8: missing_criteria.append(\\"length\\") if not re.search(r'[A-Z]', password): missing_criteria.append(\\"uppercase letter\\") if not re.search(r'[a-z]', password): missing_criteria.append(\\"lowercase letter\\") if not re.search(r'[0-9]', password): missing_criteria.append(\\"numerical digit\\") if not re.search(r'[!@#%^&*()-+]', password): missing_criteria.append(\\"special character\\") if missing_criteria: return \\"Missing \\" + \\", \\".join(missing_criteria) else: return \\"Strong Password\\""},{"question":"def max_balanced_substrings(s: str) -> int: Returns the maximum number of non-empty substrings such that each substring contains the same number of 'L's and 'R's. Example: >>> max_balanced_substrings(\\"RLRRLLRLRL\\") 4 >>> max_balanced_substrings(\\"RLLLLRRRLR\\") 3 >>> max_balanced_substrings(\\"LLLLRRRR\\") 1","solution":"def max_balanced_substrings(s): Returns the maximum number of non-empty substrings such that each substring contains the same number of 'L's and 'R's. count = 0 balance = 0 for ch in s: if ch == 'L': balance += 1 else: balance -= 1 if balance == 0: count += 1 return count"},{"question":"def min_operations_to_reduce_array(N: int, array: List[int]) -> int: Nisha has an integer array of length N. She can perform an operation where she selects any two elements from the array, removes them, and inserts their sum back into the array. She wants to continue doing this until there is only one element left in the array. This function returns the minimum number of operations required for Nisha to reduce the array to a single element. >>> min_operations_to_reduce_array(4, [3, 1, 4, 1]) 3 >>> min_operations_to_reduce_array(5, [5, 6, 7, 8, 9]) 4 >>> min_operations_to_reduce_array(3, [2, 2, 2]) 2","solution":"def min_operations_to_reduce_array(N, array): Returns the minimum number of operations required to reduce the array to a single element. return N - 1"},{"question":"def length_of_LIS(arr): Function to determine the length of the longest increasing subsequence. >>> length_of_LIS([10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> length_of_LIS([3, 10, 2, 1, 20, 19]) 3 def longest_increasing_subsequence(test_cases): Function to process multiple test cases and return the results of longest increasing subsequence for each case. >>> test_cases = [(8, [10, 22, 9, 33, 21, 50, 41, 60]), (6, [3, 10, 2, 1, 20, 19])] >>> longest_increasing_subsequence(test_cases) [5, 3] def parse_input(input_str): Function to parse the input string into test cases. >>> input_str = \\"2n8n10 22 9 33 21 50 41 60n6n3 10 2 1 20 19\\" >>> parse_input(input_str) [(8, [10, 22, 9, 33, 21, 50, 41, 60]), (6, [3, 10, 2, 1, 20, 19])]","solution":"def length_of_LIS(arr): Function to determine the length of the longest increasing subsequence. if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def longest_increasing_subsequence(test_cases): Function to process multiple test cases and return the results of longest increasing subsequence for each case. results = [] for n, arr in test_cases: results.append(length_of_LIS(arr)) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] line_index = 1 for _ in range(T): n = int(input_lines[line_index]) arr = list(map(int, input_lines[line_index + 1].split())) test_cases.append((n, arr)) line_index += 2 return test_cases"},{"question":"def count_possible_strings(T: int, test_cases: List[str]) -> List[int]: Given a number of test cases and a list of strings, returns the number of possible unique strings that can be formed for each test case string by replacing '?' with any single alphabet character. Parameters: T (int): The number of test cases. test_cases (list of str): A list of strings containing lowercase letters, '_', and '?'. Returns: list of int: A list of integers representing the number of possible unique strings for each test case. >>> count_possible_strings(3, [\\"a_d\\", \\"?\\", \\"_?\\"]) == [1, 26, 26] [1, 26, 26] >>> count_possible_strings(1, [\\"a_d\\"]) == [1] [1] >>> count_possible_strings(1, [\\"?\\"]) == [26] [26] >>> count_possible_strings(1, [\\"??\\"]) == [26*26] [676] >>> count_possible_strings(1, [\\"abc\\"]) == [1] [1] >>> count_possible_strings(3, [\\"a_d\\", \\"?\\", \\"_?\\"]) == [1, 26, 26] [1, 26, 26] >>> count_possible_strings(1, [\\"a?c\\"]) == [26] [26] >>> count_possible_strings(1, [\\"a?c_?e?\\"]) == [26**3] [17576]","solution":"def count_possible_strings(T, test_cases): Given a number of test cases and a list of strings, returns the number of possible unique strings that can be formed for each test case string by replacing '?' with any single alphabet character. Parameters: T (int): The number of test cases. test_cases (list of str): A list of strings containing lowercase letters, '_', and '?'. Returns: list of int: A list of integers representing the number of possible unique strings for each test case. results = [] for case in test_cases: # Count the number of '?' characters in the string num_question_marks = case.count('?') # Each '?' character can be replaced with any of 26 letters. possible_strings = 26 ** num_question_marks results.append(possible_strings) return results"},{"question":"def encrypt(s: str, k: int) -> str: Encrypt the string s by shifting each character by k positions in the alphabet, wrapping around if necessary. Parameters: s (str): the input string consisting of lowercase English letters k (int): the shift value Returns: str: the encrypted string >>> encrypt(\\"abc\\", 3) 'def' >>> encrypt(\\"xyz\\", 2) 'zab' >>> encrypt(\\"hello\\", 27) 'ifmmp' >>> encrypt(\\"z\\", 1) 'a' >>> encrypt(\\"a\\", 25) 'z' >>> encrypt(\\"abcdefghijklmnopqrstuvwxyz\\", 26) 'abcdefghijklmnopqrstuvwxyz' >>> encrypt(\\"abcdefghijklmnopqrstuvwxyz\\", 52) 'abcdefghijklmnopqrstuvwxyz'","solution":"def encrypt(s, k): Encrypt the string s by shifting each character by k positions in the alphabet, wrapping around if necessary. Parameters: s (str): the input string consisting of lowercase English letters k (int): the shift value Returns: str: the encrypted string encrypted = [] k = k % 26 # As the alphabet size is 26, we make use of modulo for wrapping around for char in s: new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) encrypted.append(new_char) return ''.join(encrypted) # Examples to demonstrate the function: # Input: \\"abc\\", 3 -> Output: \\"def\\" # Input: \\"xyz\\", 2 -> Output: \\"zab\\" # Input: \\"hello\\", 27 -> Output: \\"ifmmp\\""},{"question":"def is_prime(n: int) -> bool: Determine whether an integer n is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Args: n: The integer to check for primality. Returns: True if n is a prime number, False otherwise. Examples: >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False","solution":"def is_prime(n): Return True if the given integer n is a prime number, otherwise return False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring with all unique characters. Parameters: s (str): The input string. Returns: str: The longest substring with all unique characters. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"abcdef\\") == \\"abcdef\\" >>> longest_unique_substring(\\"aab\\") == \\"ab\\" >>> longest_unique_substring(\\"dvdf\\") == \\"vdf\\" >>> longest_unique_substring(\\"anviaj\\") == \\"nviaj\\" >>> longest_unique_substring(\\"abcdea\\") == \\"abcde\\"","solution":"def longest_unique_substring(s): Returns the longest substring with all unique characters. Parameters: s (str): The input string. Returns: str: The longest substring with all unique characters. start = 0 max_length = 0 max_substring = \\"\\" seen = {} for i, char in enumerate(s): if char in seen and seen[char] >= start: start = seen[char] + 1 seen[char] = i current_length = i - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:i+1] return max_substring"},{"question":"def three_sum_exists(nums, target): This function checks whether there exists any trio of numbers within the array that add up to the target. Parameters: nums (list): A list of integers. target (int): The target sum. Returns: str: \\"YES\\" if there exists such a trio, otherwise \\"NO\\". pass # Unit Tests def test_sample_input_1(): assert three_sum_exists([1, 2, 3, 4, 5, 6], 10) == \\"YES\\" def test_sample_input_2(): assert three_sum_exists([1, 2, 3, 7, 8], 20) == \\"NO\\" def test_no_possible_trio(): assert three_sum_exists([1, 1, 1, 1], 10) == \\"NO\\" def test_all_negative_numbers(): assert three_sum_exists([-5, -4, -3, -2, -1], -6) == \\"YES\\" def test_mixed_positive_and_negative(): assert three_sum_exists([-1, 2, 3, -2, 4], 5) == \\"YES\\" def test_large_numbers(): assert three_sum_exists([1000, 2000, 3000, -1000, -2000], 4000) == \\"YES\\" def test_repeated_numbers(): assert three_sum_exists([2, 2, 2, 2, 2], 6) == \\"YES\\" def test_exactly_three_numbers(): assert three_sum_exists([3, 1, 2], 6) == \\"YES\\" assert three_sum_exists([3, 1, 2], 7) == \\"NO\\" def test_large_input_size_meeting_target(): assert three_sum_exists(list(range(-500, 501)), 0) == \\"YES\\"","solution":"def three_sum_exists(nums, target): This function checks whether there exists any trio of numbers within the array that add up to the target. Parameters: nums (list): A list of integers. target (int): The target sum. Returns: str: \\"YES\\" if there exists such a trio, otherwise \\"NO\\". nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return \\"YES\\" elif total < target: left += 1 else: right -= 1 return \\"NO\\" # Function to parse input and call the helper function above def trio_sum_solver(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) array = list(map(int, data[1:N+1])) T = int(data[N+1]) print(three_sum_exists(array, T))"},{"question":"def smallest_integer_with_digit_sum(n: int) -> int: Returns the smallest integer X such that the sum of the digits of X is equal to n. def solve(test_cases: List[int]) -> List[int]: Solve multiple test cases, finds the smallest integer X for each n. from typing import List def test_smallest_integer_with_digit_sum(): assert smallest_integer_with_digit_sum(1) == 1 assert smallest_integer_with_digit_sum(5) == 5 assert smallest_integer_with_digit_sum(10) == 19 assert smallest_integer_with_digit_sum(15) == 69 assert smallest_integer_with_digit_sum(17) == 89 assert smallest_integer_with_digit_sum(18) == 99 assert smallest_integer_with_digit_sum(20) == 299 def test_solve(): assert solve([1]) == [1] assert solve([10]) == [19] assert solve([1, 5, 15]) == [1, 5, 69] assert solve([1, 9, 18, 27]) == [1, 9, 99, 999]","solution":"def smallest_integer_with_digit_sum(n): Returns the smallest integer X such that the sum of the digits of X is equal to n. if n <= 9: return n base_number = '9' * (n // 9) + str(n % 9) # We should reverse because the most significant digit should be the non-zero one return int(base_number[::-1]) def solve(test_cases): Solve multiple test cases, finds the smallest integer X for each n. results = [] for n in test_cases: results.append(smallest_integer_with_digit_sum(n)) return results"},{"question":"def singleNumber(nums): Find the single number that appears exactly once in the array where each other element appears exactly three times. Args: nums (List[int]): List of integers where each integer appears exactly three times except for one which appears once. Returns: int: The single integer that appears exactly once Examples: >>> singleNumber([2, 2, 3, 2]) 3 >>> singleNumber([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def singleNumber(nums): Find the single number that appears exactly once in the array where each other element appears exactly three times. # Initialize a variable to store the single number single_number = 0 # Iterate through each bit position (0 to 31 for 32-bit integer) for i in range(32): # Sum the i-th bit for all numbers bit_sum = 0 for num in nums: # Mask and shift to get the i-th bit of num bit_sum += (num >> i) & 1 # Determine if the i-th bit of the single number is 1 or 0 if bit_sum % 3 != 0: single_number |= (1 << i) # Handle the case when the single number is negative if single_number >= 2**31: single_number -= 2**32 return single_number"},{"question":"def determine_winner(n: int, b: List[int]) -> str: Determine the winner of the game where players collect firewood optimally. Arguments: n : int : Number of locations with firewood. b : List[int] : List of integers representing the amount of firewood at each location. Returns: str : The name of the winner (\\"BitLGM\\" or \\"BitYao\\"). Examples: >>> determine_winner(3, [1, 0, 2]) 'BitLGM' >>> determine_winner(2, [1, 1]) 'BitYao'","solution":"def determine_winner(n, b): Determines the winner of the game given a list of integers representing firewood at different locations. if n == 1: return \\"BitLGM\\" xor_sum = 0 for bi in b: xor_sum ^= bi if n == 2: if xor_sum == 0: return \\"BitYao\\" return \\"BitLGM\\" return \\"BitLGM\\" # Example usage: # print(determine_winner(3, [1, 0, 2])) # BitLGM # print(determine_winner(2, [1, 1])) # BitYao # print(determine_winner(4, [2, 3, 1, 2])) # BitLGM"},{"question":"def find_min_max_danger_level(n, m, edges): Find the minimum possible maximum danger level of a path from the capital (node 1) to any other city. Args: n (int): Number of nodes. m (int): Number of edges. edges (List[Tuple[int, int, int]]): List of edges with their danger levels. Returns: int: Minimum possible maximum danger level of any path from the capital to any other city. Example: >>> find_min_max_danger_level(3, 3, [(1, 2, 10), (1, 3, 20), (2, 3, 30)]) 20","solution":"import heapq def find_min_max_danger_level(n, m, edges): graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(): heap = [(0, 1)] # (danger_level, node) danger_levels = [float('inf')] * (n + 1) danger_levels[1] = 0 while heap: max_danger, u = heapq.heappop(heap) for v, w in graph[u]: new_danger = max(max_danger, w) if new_danger < danger_levels[v]: danger_levels[v] = new_danger heapq.heappush(heap, (new_danger, v)) return max(danger_levels[2:]) return dijkstra()"},{"question":"def process_input(input_string: str) -> List[List[str]]: Parse the input string and find all files exceeding the given size threshold. Args: input_string (str): Multi-line input string containing the number of test cases, file system structure, and size thresholds. Returns: List[List[str]]: A list of lists, where each inner list contains the paths of files exceeding the size threshold for each test case. If no files exceed the threshold, the inner list contains the string \\"No large files\\". >>> input_data = '''1 6 D root F file1.txt 500 root F file2.txt 1500 root D subdir root F file3.txt 1000 subdir F file4.txt 2000 subdir 1000''' >>> process_input(input_data) [['root/file2.txt', 'root/subdir/file4.txt']] >>> input_data = '''1 4 D root F file1.txt 500 root F file2.txt 700 root D subdir root 1000''' >>> process_input(input_data) [['No large files']]","solution":"def find_large_files(test_cases): results = [] for case in test_cases: nodes, threshold = case filesystem = {} file_paths = {} for node in nodes: if node[0] == 'D': _, dirname, parent = node filesystem[dirname] = parent elif node[0] == 'F': _, filename, size, parent = node file_paths[filename] = (int(size), parent) root_fs = {} def build_path(file_or_dir): if file_or_dir in root_fs: return root_fs[file_or_dir] path = file_or_dir parent = filesystem.get(file_or_dir, None) while parent: path = f\\"{parent}/{path}\\" parent = filesystem.get(parent, None) root_fs[file_or_dir] = path return path large_files = [] for filename, (size, parent) in file_paths.items(): if size > threshold: large_files.append((build_path(parent) + '/' + filename, size)) if large_files: large_files.sort() results.append([file for file, size in large_files]) else: results.append([\\"No large files\\"]) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(T): N = int(lines[index].strip()) nodes = [] for i in range(N): node_info = lines[index + 1 + i].strip().split() if node_info[0] == 'D': nodes.append(('D', node_info[1], node_info[2] if len(node_info) > 2 else None)) elif node_info[0] == 'F': nodes.append(('F', node_info[1], node_info[2], node_info[3])) threshold = int(lines[index + N + 1].strip()) test_cases.append((nodes, threshold)) index += N + 2 return test_cases # Combining input parsing and finding large files def process_input(input_string): test_cases = parse_input(input_string) return find_large_files(test_cases)"},{"question":"import numpy as np def perform_numpy_operations(N, arr): Given a 2-D array of size NXN, find the sum along axis 0, the prod along axis 1, and the cumulative sum along axis None. Args: N (int): The size of the 2-D array. arr (list of list of int): The 2-D array elements. Returns: tuple: A tuple containing three numpy arrays - sum along axis 0, product along axis 1, and cumulative sum along axis None. Examples: >>> N = 2 >>> arr = [ ... [1, 2], ... [3, 4] ... ] >>> perform_numpy_operations(N, arr) (array([4, 6]), array([2, 12]), array([ 1, 3, 6, 10]))","solution":"import numpy as np def perform_numpy_operations(N, arr): my_array = np.array(arr) sum_axis_0 = np.sum(my_array, axis=0) prod_axis_1 = np.prod(my_array, axis=1) cumsum_axis_none = np.cumsum(my_array, axis=None) return sum_axis_0, prod_axis_1, cumsum_axis_none"},{"question":"def count_unique_strings(s: str) -> int: Returns the number of unique strings that can be formed by replacing all occurrences of '?' in the given string with any lowercase alphabetical character. >>> count_unique_strings(\\"a?c\\") # 26 >>> count_unique_strings(\\"a??b\\") # 676 >>> count_unique_strings(\\"?ab?\\") # 676 >>> count_unique_strings(\\"abc\\") # 1 >>> count_unique_strings(\\"???\\") # 17576 >>> count_unique_strings(\\"a\\" + \\"?\\"*5 + \\"z\\") # 11881376 >>> count_unique_strings(\\"?\\") # 26 >>> count_unique_strings(\\"\\") # 1","solution":"def count_unique_strings(s): Returns the number of unique strings that can be formed by replacing all occurrences of '?' in the given string with any lowercase alphabetical character. # Count the number of '?' in the string num_questions = s.count('?') # Each '?' can be replaced by any of the 26 lowercase letters # So the number of unique strings is 26 raised to the power of the number of '?' return 26 ** num_questions"},{"question":"def are_cyclic_permutations(a: str, b: str) -> str: Returns \\"YES\\" if strings a and b are cyclic permutations of each other, otherwise \\"NO\\". >>> are_cyclic_permutations(\\"abc\\", \\"cab\\") \\"YES\\" >>> are_cyclic_permutations(\\"abc\\", \\"def\\") \\"NO\\"","solution":"def are_cyclic_permutations(a, b): Returns \\"YES\\" if strings a and b are cyclic permutations of each other, otherwise \\"NO\\". if len(a) != len(b): return \\"NO\\" concatenated_a = a + a if b in concatenated_a: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def rearrange_string_lexicographically(S: str) -> str: Determine the smallest lexicographical string that can be formed by rearranging the characters of a given string such that no two adjacent characters are identical. If it is not possible to create such a string, return \\"IMPOSSIBLE\\". pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process multiple test cases to find the smallest lexicographical string for each. :param T: The number of test cases. :param test_cases: The list of input strings. :return: A list of results for each test case. pass # Example usage with test cases if __name__ == '__main__': T = int(input().strip()) test_cases = [input().strip() for _ in range(T)] results = process_test_cases(T, test_cases) for res in results: print(res)","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string_lexicographically(S): char_count = Counter(S) max_freq = max(char_count.values()) if max_freq > (len(S) + 1) // 2: return \\"IMPOSSIBLE\\" max_heap = [] for char, freq in char_count.items(): heappush(max_heap, (-freq, char)) result = [] prev_char, prev_freq = '', 0 while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 return ''.join(result) def process_test_cases(T, test_cases): results = [] for S in test_cases: res = rearrange_string_lexicographically(S) results.append(res) return results # Sample input to test the function if __name__ == '__main__': T = int(input().strip()) test_cases = [input().strip() for _ in range(T)] results = process_test_cases(T, test_cases) for res in results: print(res)"},{"question":"from typing import List, Tuple def earliest_activation_times(N: int, M: int, K: int, friendships: List[Tuple[int, int]], interactions: List[Tuple[int, int, int]]) -> List[int]: Determine the earliest time at which each user became active in a social network. >>> earliest_activation_times(5, 4, 3, [(1, 2), (1, 3), (3, 4), (2, 5)], [(1, 1, 2), (2, 1, 3), (3, 3, 4)]) [1, 1, 2, 3, -1] >>> earliest_activation_times(3, 2, 2, [(1, 2), (2, 3)], [(1, 1, 2), (3, 2, 3)]) [1, 1, 3]","solution":"def earliest_activation_times(N, M, K, friendships, interactions): from collections import defaultdict, deque # Create an adjacency list for friendships friends = defaultdict(list) for u, v in friendships: friends[u].append(v) friends[v].append(u) # Initialize activation times with -1 (inactive) activation_times = [-1] * (N + 1) # Process interactions in chronological order for time, user1, user2 in interactions: if activation_times[user1] == -1: activation_times[user1] = time if activation_times[user2] == -1: activation_times[user2] = time return activation_times[1:] # Example usage: # N = 5, M = 4, K = 3 # friendships = [(1, 2), (1, 3), (3, 4), (2, 5)] # interactions = [(1, 1, 2), (2, 1, 3), (3, 3, 4)] # print(earliest_activation_times(N, M, K, friendships, interactions))"},{"question":"def smallest_subarray_with_given_sum(S, arr): Find the length of the smallest subarray with a sum >= S. Args: S (int): The target sum. arr (List[int]): The list of positive integers. Returns: int: The length of the smallest subarray with sum >= S, or -1 if no such subarray exists. >>> smallest_subarray_with_given_sum(7, [2, 3, 1, 2, 4, 3]) 2 >>> smallest_subarray_with_given_sum(15, [1, 2, 3, 4, 5]) 5 >>> smallest_subarray_with_given_sum(100, [1, 10, 5, 2, 7, 1, 9, 3]) -1 def find_smallest_subarray(T, test_cases): Finds the length of the smallest subarray for each test case. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains S and the list of integers. Returns: List[int]: List of results for each test case. >>> find_smallest_subarray(3, [(7, [2, 3, 1, 2, 4, 3]), (15, [1, 2, 3, 4, 5]), (100, [1, 10, 5, 2, 7, 1, 9, 3])]) [2, 5, -1] >>> find_smallest_subarray(2, [(6, [1, 2, 3, 4, 5]), (3, [1, 1, 1, 1, 1])]) [2, 3]","solution":"def smallest_subarray_with_given_sum(S, arr): Finds the length of the smallest subarray with a sum >= S. n = len(arr) start = 0 current_sum = 0 min_length = float(\\"inf\\") for end in range(n): current_sum += arr[end] while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\\"inf\\") else -1 def find_smallest_subarray(T, test_cases): result = [] for t in range(T): S, arr = test_cases[t] result.append(smallest_subarray_with_given_sum(S, arr)) return result"},{"question":"def distinct_substring_count(L: int, s: str) -> int: Returns the number of distinct substrings in string s, modulo 10^9 + 7. Args: L (int): The length of the string. s (str): The string consisting of L lowercase English letters. Returns: int: The number of distinct substrings modulo 10^9 + 7. Example: >>> distinct_substring_count(4, \\"abcd\\") 10 >>> distinct_substring_count(1, \\"a\\") 1 pass # Unit Tests def test_example_case(): assert distinct_substring_count(4, \\"abcd\\") == 10 def test_single_character(): assert distinct_substring_count(1, \\"a\\") == 1 def test_repeated_characters(): assert distinct_substring_count(3, \\"aaa\\") == 3 def test_mixed_characters(): assert distinct_substring_count(5, \\"abcde\\") == 15 def test_palindrome(): assert distinct_substring_count(5, \\"ababa\\") == 9 def test_large_input_small_variation(): assert distinct_substring_count(5, \\"aaaab\\") == 9","solution":"MOD = 10**9 + 7 def distinct_substring_count(L, s): Returns the number of distinct substrings in string s, modulo 10^9 + 7. substrings = set() for i in range(L): for j in range(i + 1, L + 1): substrings.add(s[i:j]) return len(substrings) % MOD"},{"question":"def is_balanced(sequence: str) -> str: Check if the given sequence of brackets is balanced. :param sequence: String containing the sequence of brackets. :return: 'YES' if the sequence is balanced, 'NO' otherwise. >>> is_balanced(\\"()\\") 'YES' >>> is_balanced(\\"([])\\") 'YES' >>> is_balanced(\\"{[()()]}\\") 'YES' >>> is_balanced(\\"(\\") 'NO' >>> is_balanced(\\"([)]\\") 'NO' >>> is_balanced(\\"{[(])}\\") 'NO' def evaluate_sequences(sequences: List[str]) -> List[str]: Evaluate multiple sequences of brackets to determine if each is balanced. :param sequences: List of strings, each containing a sequence of brackets. :return: List of strings, either 'YES' or 'NO' for each sequence. >>> evaluate_sequences([\\"()\\", \\"([])\\", \\"{[()()]}\\", \\"(\\", \\"([)]\\", \\"{[(])}\\"]) ['YES', 'YES', 'YES', 'NO', 'NO', 'NO']","solution":"def is_balanced(sequence): Check if the given sequence of brackets is balanced. :param sequence: String containing the sequence of brackets. :return: 'YES' if the sequence is balanced, 'NO' otherwise. bracket_map = {')': '(', ']': '[', '}': '{'} open_brackets = {'(', '[', '{'} stack = [] for char in sequence: if char in open_brackets: stack.append(char) elif char in bracket_map: if not stack or stack[-1] != bracket_map[char]: return 'NO' stack.pop() return 'YES' if not stack else 'NO' def evaluate_sequences(sequences): Evaluate multiple sequences of brackets to determine if each is balanced. :param sequences: List of strings, each containing a sequence of brackets. :return: List of strings, either 'YES' or 'NO' for each sequence. return [is_balanced(sequence) for sequence in sequences]"},{"question":"def can_be_sorted_by_one_swap(heights): Returns True if the list heights can be sorted in strictly increasing order by performing at most one swap, otherwise returns False. >>> can_be_sorted_by_one_swap([1, 5, 3, 4, 2]) True >>> can_be_sorted_by_one_swap([4, 3, 2, 1]) False","solution":"def can_be_sorted_by_one_swap(heights): Returns True if the list heights can be sorted in strictly increasing order by performing at most one swap, otherwise returns False. def is_sorted(lst): return all(lst[i] < lst[i+1] for i in range(len(lst)-1)) n = len(heights) if n <= 1: return True # Find the first pair of elements that are out of order first = second = -1 for i in range(n - 1): if heights[i] > heights[i + 1]: if first == -1: first = i elif second == -1: second = i + 1 if first == -1: # Already sorted return True if second == -1: # Only one pair out of order second = first + 1 # Swap the two out of order elements and check if the list becomes sorted heights[first], heights[second] = heights[second], heights[first] result = is_sorted(heights) # Swap back to restore original list heights[first], heights[second] = heights[second], heights[first] return result"},{"question":"def generate_sequence(S: int) -> list: Generate a sequence of numbers starting from the given positive integer S. The rules for generating the sequence are: - If the current number is even, the next number is half of the current number. - If the current number is odd, the next number is 3 * current_number + 1. - The sequence terminates when it reaches the number 1. Parameters: S (int): The starting positive integer (1 <= S <= 10^6). Returns: list: The sequence of numbers generated. Example: >>> generate_sequence(6) [6, 3, 10, 5, 16, 8, 4, 2, 1] >>> generate_sequence(15) [15, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1] pass","solution":"def generate_sequence(S): Generate the sequence of numbers starting from S according to the specified rules. if S < 1 or S > 10**6: raise ValueError(\\"S must be within the range 1 <= S <= 10^6\\") sequence = [S] while S != 1: if S % 2 == 0: S = S // 2 else: S = 3 * S + 1 sequence.append(S) return sequence"},{"question":"def findNumberInList(number, list_numbers): Determines if the number is in the list_numbers and at what index. Args: number: int - A number to search in the list. list_numbers: list - A list of integers in which the search is conducted. Prints: str: \\"{number} is at index {index}\\" if the number is found at that index. str: \\"{number} is not in the list\\" if the number is not found in the list.","solution":"def findNumberInList(number, list_numbers): Determines if the number is in the list_numbers and at what index. Args: number: int - A number to search in the list. list_numbers: list - A list of integers in which the search is conducted. Prints: str: \\"{number} is at index {index}\\" if the number is found at that index. str: \\"{number} is not in the list\\" if the number is not found in the list. if number in list_numbers: index = list_numbers.index(number) print(f\\"{number} is at index {index}\\") else: print(f\\"{number} is not in the list\\")"},{"question":"def minimize_max_sum(n: int, k: int, array: List[int]) -> int: Determine the minimal possible value of the maximum sum among the k or fewer subarrays that the given array can be split into. >>> minimize_max_sum(5, 3, [7, 2, 5, 10, 8]) 14 >>> minimize_max_sum(1, 1, [10]) 10 >>> minimize_max_sum(4, 1, [1, 2, 3, 4]) 10 >>> minimize_max_sum(4, 4, [1, 2, 3, 4]) 4 >>> minimize_max_sum(5, 2, [1, 2, 3, 4, 5]) 9 >>> minimize_max_sum(10, 5, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) 150","solution":"def minimize_max_sum(n, k, array): def can_partition(max_sum): current_sum = 0 parts = 1 for num in array: if current_sum + num > max_sum: parts += 1 current_sum = num if parts > k: return False else: current_sum += num return True left, right = max(array), sum(array) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"def unique_paths(maze: List[List[str]]) -> int: Calculate the number of unique paths from top-left to bottom-right in a maze. >>> unique_paths([ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ]) 2 >>> unique_paths([ ['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.'] ]) 4 >>> unique_paths([ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ]) 1 >>> unique_paths([ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ]) 6 >>> unique_paths([ ['.', '.', '.'], ['#', '#', '#'], ['.', '.', '.'] ]) 0 pass def solve_mazes(test_cases: List[List[List[str]]]) -> List[int]: Solve multiple mazes and return the number of unique paths for each. >>> solve_mazes([ [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ], [ ['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.'] ] ]) [2, 4] >>> solve_mazes([ [ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ], [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ], [ ['.', '.', '.'], ['#', '#', '#'], ['.', '.', '.'] ] ]) [1, 6, 0] pass","solution":"def unique_paths(maze): if not maze or not maze[0]: return 0 N = len(maze) M = len(maze[0]) if maze[0][0] == '#' or maze[N-1][M-1] == '#': return 0 dp = [[0 for _ in range(M)] for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if maze[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1] def solve_mazes(test_cases): results = [] for maze in test_cases: results.append(unique_paths(maze)) return results"},{"question":"def shift_sentence(sentence: str) -> str: Replace each character in the sentence with its succeeding character in the alphabet. If the character is 'z' or 'Z', it should wrap around to 'a' or 'A', respectively. Maintain the case of the original character and avoid altering spaces and punctuation. Examples: >>> shift_sentence(\\"Hello, World!\\") \\"Ifmmp, Xpsme!\\" >>> shift_sentence(\\"abc xyz\\") \\"bcd yza\\"","solution":"def shift_char(c): if 'a' <= c <= 'y' or 'A' <= c <= 'Y': return chr(ord(c) + 1) elif c == 'z': return 'a' elif c == 'Z': return 'A' else: return c def shift_sentence(sentence): return ''.join(shift_char(c) for c in sentence)"},{"question":"def canFormPalindrome(s: str) -> str: Determines if the string can be rearranged to form a palindrome. >>> canFormPalindrome(\\"civic\\") \\"YES\\" >>> canFormPalindrome(\\"ivicc\\") \\"YES\\" >>> canFormPalindrome(\\"hello\\") \\"NO\\" >>> canFormPalindrome(\\"\\") \\"YES\\" >>> canFormPalindrome(\\"aabbccdd\\") \\"YES\\"","solution":"def canFormPalindrome(s): Determines if the string can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def check_overlaps(test_cases): Determine if there is any overlap in participants’ running intervals for each test case. >>> check_overlaps([(3, [(1, 5), (2, 6), (8, 10)]), (4, [(1, 3), (4, 6), (7, 9), (10, 12)])]) ['YES', 'NO'] def parse_input(input_str): Parse input string and return list of test cases. >>> parse_input(\\"2n3n1 5n2 6n8 10n4n1 3n4 6n7 9n10 12\\") [(3, [(1, 5), (2, 6), (8, 10)]), (4, [(1, 3), (4, 6), (7, 9), (10, 12)])] def main(input_str): Main function to determine overlap for given input. >>> main(\\"2n3n1 5n2 6n8 10n4n1 3n4 6n7 9n10 12\\") 'YESnNO'","solution":"def check_overlaps(test_cases): results = [] for case in test_cases: n, intervals = case intervals.sort() overlap_found = False for i in range(1, n): if intervals[i][0] < intervals[i - 1][1]: overlap_found = True break results.append(\\"YES\\" if overlap_found else \\"NO\\") return results def parse_input(input_str): input_lines = input_str.strip().split('n') idx = 0 t = int(input_lines[idx]) idx += 1 test_cases = [] for _ in range(t): n = int(input_lines[idx]) idx += 1 intervals = [] for _ in range(n): start, end = map(int, input_lines[idx].split()) idx += 1 intervals.append((start, end)) test_cases.append((n, intervals)) return test_cases def main(input_str): test_cases = parse_input(input_str) results = check_overlaps(test_cases) return \\"n\\".join(results)"},{"question":"from typing import List, Tuple def find_meeting_slot(n: int, availabilities: List[Tuple[int, int, int]]) -> str: A software company wants to develop an automated scheduling system for their team meetings. Every team member has a preferred start and end time for taking meetings and a priority level for each of their available timeslots. The aim is to schedule a meeting at a time slot that has the highest aggregate priority. If multiple timeslots have the same aggregate priority, choose the earliest one. A meeting can only be scheduled in a time slot where at least half of the team members are available. Args: n (int): The number of team members. availabilities (List[Tuple[int, int, int]]): List of tuples where each tuple contains start_time, end_time and priority. Returns: str: The scheduled meeting time slot in the format \\"start_time end_time\\". If no suitable time slot is found, return \\"No suitable time slot found!\\". >>> find_meeting_slot(4, [(9, 11, 7), (10, 12, 5), (11, 13, 3), (9, 13, 4)]) '10 11' >>> find_meeting_slot(3, [(9, 10, 7), (12, 13, 5), (14, 15, 3)]) 'No suitable time slot found!'","solution":"from collections import defaultdict def find_meeting_slot(n, availabilities): priorities = defaultdict(int) availability_count = defaultdict(int) for start, end, priority in availabilities: for time in range(start, end): priorities[(time, time + 1)] += priority availability_count[(time, time + 1)] += 1 suitable_slots = {slot: priority for slot, priority in priorities.items() if availability_count[slot] >= n / 2} if not suitable_slots: return \\"No suitable time slot found!\\" best_slot = max(suitable_slots, key=lambda x: (suitable_slots[x], -x[0])) return f\\"{best_slot[0]} {best_slot[1]}\\" # Example usage with hard coded input n = 4 availabilities = [ (9, 11, 7), (10, 12, 5), (11, 13, 3), (9, 13, 4) ] print(find_meeting_slot(n, availabilities)) # Expected \\"10 11\\""},{"question":"def can_form_palindrome(s): Determine if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"Possible\\" >>> can_form_palindrome(\\"ivicc\\") \\"Possible\\" >>> can_form_palindrome(\\"hello\\") \\"Impossible\\" def handle_test_cases(t, test_cases): Handles multiple test cases for the can_form_palindrome function. >>> handle_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"Possible\\", \\"Possible\\", \\"Impossible\\"]","solution":"def can_form_palindrome(s): Determine if the given string can be rearranged to form a palindrome. Args: s (str): The string to check. Returns: str: \\"Possible\\" if the string can be rearranged to form a palindrome, else \\"Impossible\\". from collections import Counter # Count occurrence of each character in the string char_count = Counter(s) # Check how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd count return \\"Possible\\" if odd_count <= 1 else \\"Impossible\\" def handle_test_cases(t, test_cases): Handles multiple test cases for the can_form_palindrome function. Args: t (int): Number of test cases. test_cases (list): List of strings, each representing a test case. Returns: list: List of results for each test case. return [can_form_palindrome(case) for case in test_cases]"},{"question":"def can_transform(a: int, b: int) -> str: Determines whether it is possible to transform integer a into integer b using the custom defined operations \\"combine\\" and \\"diff\\" >>> can_transform(123, 1234) \\"YES\\" >>> can_transform(15, 1) \\"NO\\" >>> can_transform(123456, 123456) \\"YES\\" >>> can_transform(123, 234) \\"NO\\" >>> can_transform(1000000, 10000001) \\"YES\\" >>> can_transform(1000000, 1000000) \\"YES\\" >>> can_transform(100000, 10000000) \\"YES\\" >>> can_transform(1, 12) \\"YES\\" >>> can_transform(1, 21) \\"NO\\"","solution":"def can_transform(a, b): Determines whether it is possible to transform integer a into integer b using the custom defined operations \\"combine\\" and \\"diff\\" str_a, str_b = str(a), str(b) if str_b.startswith(str_a): return \\"YES\\" return \\"NO\\""},{"question":"def factorial(N): Returns the factorial of the positive integer N. Args: N (int): A positive integer (1 <= N <= 15) Returns: int: The factorial of N # Complete the function to return the factorial of N from solution import factorial def test_factorial_of_1(): assert factorial(1) == 1 def test_factorial_of_small_numbers(): assert factorial(2) == 2 assert factorial(3) == 6 def test_factorial_of_4(): assert factorial(4) == 24 def test_factorial_of_5(): assert factorial(5) == 120 def test_factorial_of_larger_numbers(): assert factorial(10) == 3628800 assert factorial(15) == 1307674368000 def test_factorial_non_traditional(): assert factorial(6) == 720","solution":"def factorial(N): Returns the factorial of the positive integer N. Args: N (int): A positive integer (1 <= N <= 15) Returns: int: The factorial of N result = 1 for i in range(2, N + 1): result *= i return result"},{"question":"def isPermutation(arr, N): Checks if the given array is a permutation of the first N natural numbers. Parameters: arr (list of int): the input array N (int): the size of the permutation Returns: bool: True if the array is a permutation of the first N natural numbers, else False >>> isPermutation([4, 3, 1, 2], 4) True >>> isPermutation([1, 2, 2, 3], 4) False >>> isPermutation([1, 3, 4, 5], 5) False >>> isPermutation([1, 3, 4, 2, 5, 6], 5) False >>> isPermutation([1], 1) True >>> isPermutation([2], 1) False >>> isPermutation([], 0) True","solution":"def isPermutation(arr, N): Checks if the given array is a permutation of the first N natural numbers. Parameters: arr (list of int): the input array N (int): the size of the permutation Returns: bool: True if the array is a permutation of the first N natural numbers, else False if len(arr) != N: return False count = [0] * (N + 1) for num in arr: if num < 1 or num > N or count[num] != 0: return False count[num] += 1 return True"},{"question":"def top_k_scores(test_cases): Given a number of test cases, each with a set of scores, return the top k unique scores for each test case in descending order. Args: test_cases (List[Tuple[int, int, List[int]]]): A list where each element is a tuple containing: - an integer n: number of participants - an integer k: the number of top scores to be returned - a list of integers representing participants' scores Returns: List[List[int]]: A list where each element is a list of the top k unique scores for the corresponding test case. >>> test_cases = [(6, 3, [70, 80, 80, 90, 70, 60]), (5, 4, [50, 50, 50, 50, 50])] >>> top_k_scores(test_cases) [[90, 80, 70], [50]] >>> test_cases = [(5, 3, [1, 2, 3, 4, 5])] >>> top_k_scores(test_cases) [[5, 4, 3]] >>> test_cases = [(5, 2, [10, 10, 10, 10, 10])] >>> top_k_scores(test_cases) [[10]] >>> test_cases = [(5, 10, [1, 1, 2, 2, 3])] >>> top_k_scores(test_cases) [[3, 2, 1]] >>> test_cases = [] >>> top_k_scores(test_cases) []","solution":"def top_k_scores(test_cases): results = [] for test_case in test_cases: n, k, scores = test_case unique_scores = sorted(set(scores), reverse=True) results.append(unique_scores[:k]) return results # Example Usage: # test_cases = [ # (6, 3, [70, 80, 80, 90, 70, 60]), # (5, 4, [50, 50, 50, 50, 50]) # ] # print(top_k_scores(test_cases)) # Output: [[90, 80, 70], [50]]"},{"question":"def count_bird_moves(tree_heights): Given a list of integers representing the heights of trees in a row, count the number of times a bird will move to a taller tree as it travels from left to right. >>> count_bird_moves([2, 3, 4, 3, 5]) 3 >>> count_bird_moves([1, 1, 1, 1, 1, 1]) 0 >>> count_bird_moves([4, 4, 4, 4, 4, 4, 4]) 0 >>> count_bird_moves([5]) 0 >>> count_bird_moves([1, 2, 3, 4, 5]) 4 >>> count_bird_moves([5, 4, 3, 2, 1]) 0 >>> count_bird_moves([1, 3, 2, 4, 3, 5]) 3","solution":"def count_bird_moves(tree_heights): max_height = tree_heights[0] move_count = 0 for height in tree_heights[1:]: if height > max_height: move_count += 1 max_height = height return move_count"},{"question":"from typing import List def min_jumps(nums: List[int]) -> int: Determine the minimum number of jumps required for the frog to reach the last element of the river. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([0]) 0 >>> min_jumps([1, 0]) 1 >>> min_jumps([0, 1]) -1 >>> min_jumps([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 1 >>> min_jumps([1] * 10000) 9999","solution":"def min_jumps(rocks): n = len(rocks) if n <= 1: return 0 max_reach = steps = jumps = 0 for i in range(n): if i > max_reach: return -1 max_reach = max(max_reach, i + rocks[i]) if i == steps: jumps += 1 steps = max_reach if steps >= n - 1: return jumps return -1"},{"question":"def largest_empty_plot_area(n, m, grid): Returns the area of the largest rectangle consisting exclusively of empty plots in the grid. Input: - n: number of rows in the grid (1 ≤ n ≤ 1000) - m: number of columns in the grid (1 ≤ m ≤ 1000) - grid: a list of strings where each string represents a row of the grid with '.' for empty plots and '#' for obstacles Output: - Integer representing the area of the largest rectangle that consists only of empty plots ('.') >>> largest_empty_plot_area(4, 5, [\\".....\\", \\"..#..\\", \\"....#\\", \\".#...\\"]) == 6 >>> largest_empty_plot_area(1, 5, [\\".....\\"]) == 5 >>> largest_empty_plot_area(5, 1, [\\".\\", \\".\\", \\"#\\", \\".\\", \\".\\"]) == 2 >>> largest_empty_plot_area(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) == 0 >>> largest_empty_plot_area(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) == 9","solution":"def largest_empty_plot_area(n, m, grid): Returns the area of the largest rectangle consisting exclusively of empty plots in the grid. if n == 0 or m == 0: return 0 def max_histogram_area(heights): Helper function to calculate the largest rectangle area in a histogram given by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area heights = [0] * m max_area = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"def lexicographically_smallest_c(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Determine the lexicographically smallest sequence c that can be obtained from sequence b. >>> lexicographically_smallest_c(3, [(5, [4, 2, 2, 7, 4]), (3, [1, 3, 3]), (7, [10, 20, 30, 10, 20, 30, 10])]) [[3, 1, 2, 5, 4], [1, 2, 3], [1, 2, 3, 1, 2, 3, 1]] >>> lexicographically_smallest_c(1, [(1, [1])]) [[1]] def test_lexicographically_smallest_c(): assert lexicographically_smallest_c(3, [(5, [4, 2, 2, 7, 4]), (3, [1, 3, 3]), (7, [10, 20, 30, 10, 20, 30, 10])]) == [[1, 2, 2, 3, 1], [1, 2, 2], [1, 2, 3, 1, 2, 3, 1]] def test_single_element_cases(): assert lexicographically_smallest_c(2, [(1, [1]), (1, [1000])]) == [[1], [1]] def test_increasing_order(): assert lexicographically_smallest_c(1, [(3, [1, 2, 3])]) == [[1, 2, 3]] def test_decreasing_order(): assert lexicographically_smallest_c(1, [(3, [3, 2, 1])]) == [[1, 2, 3]] def test_same_elements(): assert lexicographically_smallest_c(2, [(5, [5, 5, 5, 5, 5]), (3, [2, 2, 2])]) == [[1, 1, 1, 1, 1], [1, 1, 1]]","solution":"def lexicographically_smallest_c(t, test_cases): results = [] for i in range(t): n, b = test_cases[i] unique_numbers = sorted(set(b)) # Set of unique numbers from sequence b, sorted c = [] used = set() assignment = {} min_int = 1 for num in b: if num in assignment: c.append(assignment[num]) else: while min_int in used: min_int += 1 assignment[num] = min_int c.append(min_int) used.add(min_int) results.append(c) return results"},{"question":"def stack_operations(N:int, M:int, ops:List[str]) -> List[str]: Perform a series of operations on the stack and return the final state of the stack. Arguments: N : int : the maximum capacity of the stack M : int : the number of operations to be performed ops : List[str] : the series of operations in the format described Returns: List[str] : each element on a new line representing the final state of the stack from top to bottom. If the stack is empty after all operations, return [\\"EMPTY\\"]. >>> stack_operations(5, 6, [\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"INCREMENT 2 5\\", \\"POP\\", \\"PUSH 6\\"]) [\\"6\\", \\"7\\", \\"6\\"] >>> stack_operations(5, 0, []) [\\"EMPTY\\"] >>> stack_operations(5, 3, [\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\"]) [\\"3\\", \\"2\\", \\"1\\"] >>> stack_operations(5, 6, [\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"POP\\", \\"POP\\", \\"POP\\"]) [\\"EMPTY\\"] >>> stack_operations(5, 4, [\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"INCREMENT 5 2\\"]) [\\"5\\", \\"4\\", \\"3\\"] >>> stack_operations(5, 3, [\\"PUSH 1\\", \\"PUSH 2\\", \\"INCREMENT 1 5\\"]) [\\"2\\", \\"6\\"] >>> stack_operations(3, 5, [\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"PUSH 4\\", \\"PUSH 5\\"]) [\\"3\\", \\"2\\", \\"1\\"]","solution":"def stack_operations(N, M, ops): stack = [] for op in ops: parts = op.split() command = parts[0] if command == \\"PUSH\\": if len(stack) < N: stack.append(int(parts[1])) elif command == \\"POP\\": if stack: stack.pop() elif command == \\"INCREMENT\\": k = int(parts[1]) m = int(parts[2]) increment_size = min(k, len(stack)) for i in range(increment_size): stack[i] += m if not stack: return [\\"EMPTY\\"] return list(map(str, stack[::-1])) # Usage Example N, M = 5, 6 operations = [\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"INCREMENT 2 5\\", \\"POP\\", \\"PUSH 6\\"] print(\\"n\\".join(stack_operations(N, M, operations)))"},{"question":"def min_operations_to_transform(initial: str, target: str): Determine the minimum number of operations required to transform the initial string into the target string. >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") (3, [\\"Replace 1 s\\", \\"Replace 5 i\\", \\"Insert 7 g\\"]) >>> min_operations_to_transform(\\"abcd\\", \\"abcde\\") (1, [\\"Insert 5 e\\"]) # Function implementation goes here # Unit Tests def test_min_operations_example1(): ops_count, operations = min_operations_to_transform(\\"kitten\\", \\"sitting\\") assert ops_count == 3 assert operations == [ \\"Replace 1 s\\", \\"Replace 5 i\\", \\"Insert 7 g\\" ] def test_min_operations_example2(): ops_count, operations = min_operations_to_transform(\\"abcd\\", \\"abcde\\") assert ops_count == 1 assert operations == [ \\"Insert 5 e\\" ] def test_min_operations_same_strings(): ops_count, operations = min_operations_to_transform(\\"abcdef\\", \\"abcdef\\") assert ops_count == 0 assert operations == [] def test_min_operations_insert_only(): ops_count, operations = min_operations_to_transform(\\"abc\\", \\"abcd\\") assert ops_count == 1 assert operations == [ \\"Insert 4 d\\" ] def test_min_operations_delete_only(): ops_count, operations = min_operations_to_transform(\\"abcd\\", \\"abc\\") assert ops_count == 1 assert operations == [ \\"Delete 4\\" ]","solution":"def min_operations_to_transform(initial, target): n = len(initial) m = len(target) # dp[i][j] will be the minimum number of operations required to transform # initial[0...i-1] into target[0...j-1] dp = [[0] * (m + 1) for _ in range(n + 1)] # Base case: transforming string to an empty string for i in range(1, n + 1): dp[i][0] = i for j in range(1, m + 1): dp[0][j] = j # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if initial[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1 # Now to find the operations i, j = n, m operations = [] while i > 0 and j > 0: if initial[i - 1] == target[j - 1]: i -= 1 j -= 1 else: if dp[i][j] == dp[i - 1][j - 1] + 1: operations.append(f\\"Replace {i} {target[j - 1]}\\") i -= 1 j -= 1 elif dp[i][j] == dp[i][j - 1] + 1: operations.append(f\\"Insert {i + 1} {target[j - 1]}\\") j -= 1 else: operations.append(f\\"Delete {i}\\") i -= 1 while i > 0: operations.append(f\\"Delete {i}\\") i -= 1 while j > 0: operations.append(f\\"Insert {1} {target[j - 1]}\\") j -= 1 operations.reverse() return dp[n][m], operations # The function can be called with initial and target strings as follows: # min_operations_to_transform(\\"kitten\\", \\"sitting\\")"},{"question":"def generate_sequence(n, m): Generates a sequence of N integers following specific rules and modifies the sequence for M iterations. :param n: The length of the sequence. :param m: The number of iterations for modification. :returns: A list representing the final sequence after M iterations. Example: >>> generate_sequence(5, 0) == [1, 2, 4, 8, 16] >>> generate_sequence(5, 1) == [3, 2, 12, 8, 16] >>> generate_sequence(5, 2) == [5, 2, 20, 8, 16] >>> generate_sequence(1, 0) == [1] >>> generate_sequence(6, 0) == [1, 2, 4, 8, 16, 32] >>> generate_sequence(6, 1) == [3, 2, 12, 8, 48, 32]","solution":"def generate_sequence(n, m): Generates a sequence of N integers following specific rules and modifies the sequence for M iterations. sequence = [1] # Generate the initial sequence for _ in range(1, n): sequence.append(sequence[-1] * 2) # Perform M modification iterations for _ in range(m): modified_sequence = sequence[:] for i in range(0, n, 2): # Iterate through odd-position integers (1st, 3rd, 5th, etc. in 1-based indexing) if i + 1 < n: modified_sequence[i] += modified_sequence[i + 1] sequence = modified_sequence return sequence # Function to handle input and output def main(): input_line = input().strip() n, m = map(int, input_line.split()) result = generate_sequence(n, m) print(' '.join(map(str, result))) # If executed as a script (for testing outside autogenerated test framework) if __name__ == \\"__main__\\": main()"},{"question":"def max_energy_collected(n: int, energies: List[int]) -> int: Determine the maximum energy that can be collected by traversing all gardens in a loop, starting from any garden and ending at the same garden. >>> max_energy_collected(5, [5, 3, 7, 2, 9]) 26 >>> max_energy_collected(4, [1, 3, 9, 2]) 15 >>> max_energy_collected(3, [8, 4, 5]) 17","solution":"def max_energy_collected(n, energies): extended_energies = energies + energies # to simulate the circular loop max_energy = 0 for i in range(n): current_energy = sum(extended_energies[i:i + n]) max_energy = max(max_energy, current_energy) return max_energy"},{"question":"def max_possible_value(n: int, arr: List[int]) -> int: Returns the maximum possible value of any integer in the sequence after any number of operations. Parameters: n (int): The length of the sequence. arr (list): The sequence of integers. Returns: int: The maximum possible value of any integer in the sequence. >>> max_possible_value(3, [1, 2, 3]) 6 >>> max_possible_value(4, [2, 2, 2, 2]) 8 >>> max_possible_value(2, [3, 5]) 8 >>> max_possible_value(3, [1000000000, 1000000000, 1000000000]) 3000000000 >>> max_possible_value(5, [1, 2, 3, 4, 5]) 15 >>> max_possible_value(2, [1, 1]) 2","solution":"def max_possible_value(n, arr): Returns the maximum possible value of any integer in the sequence after any number of operations. Parameters: n (int): The length of the sequence. arr (list): The sequence of integers. Returns: int: The maximum possible value of any integer in the sequence. return sum(arr)"},{"question":"def capitalize_sentence(sentence: str) -> str: Takes a sentence and returns it with each word's first letter capitalized and the rest in lowercase, ignoring words with numerical digits. Punctuation marks should not interfere with capitalization. >>> capitalize_sentence(\\" hello world! 123abC is a 45great PLACE. \\") 'Hello World! 123abC Is A 45great Place.' >>> capitalize_sentence(\\"this is a test\\") 'This Is A Test' >>> capitalize_sentence(\\"this is 123a test\\") 'This Is 123a Test' >>> capitalize_sentence(\\"hello world! is this a test.\\") 'Hello World! Is This A Test.' >>> capitalize_sentence(\\" hello world \\") 'Hello World' >>> capitalize_sentence(\\"\\") '' >>> capitalize_sentence(\\"THIS IS A TEST\\") 'This Is A Test' >>> capitalize_sentence(\\"tHiS iS a MiXeD cAsE sEnTeNcE\\") 'This Is A Mixed Case Sentence'","solution":"def capitalize_sentence(sentence): Takes a sentence and returns it with each word's first letter capitalized and the rest in lowercase, ignoring words with numerical digits. import re sentence = re.sub(r's+', ' ', sentence.strip()) words = sentence.split(' ') result = [] for word in words: if any(char.isdigit() for char in word): result.append(word) else: result.append(word.capitalize()) return ' '.join(result)"},{"question":"def return_to_start(instructions: str) -> bool: Determines whether the robot returns to the starting position after executing a sequence of instructions. Args: instructions (str): A string consisting of the characters 'L', 'R', 'U', 'D' Returns: bool: True if the robot returns to the starting position, False otherwise. Examples: >>> return_to_start(\\"LR\\") == True >>> return_to_start(\\"URURD\\") == False >>> return_to_start(\\"LUDR\\") == True >>> return_to_start(\\"UUDDLRLR\\") == True >>> return_to_start(\\"ULLDRR\\") == True","solution":"def return_to_start(instructions: str) -> bool: Determines whether the robot returns to the starting position after executing a sequence of instructions. Args: instructions (str): A string consisting of the characters 'L', 'R', 'U', 'D' Returns: bool: True if the robot returns to the starting position, False otherwise. x, y = 0, 0 for instr in instructions: if instr == 'L': x -= 1 elif instr == 'R': x += 1 elif instr == 'U': y += 1 elif instr == 'D': y -= 1 return x == 0 and y == 0"},{"question":"def reverseWords(s: str) -> str: This function takes a string containing alphabetic characters and spaces, and returns a new string with the order of words reversed but the order of characters within each word maintained. Args: s (str): input string containing alphabetic characters and spaces. Returns: str: the string with the order of words reversed. >>> reverseWords(\\"Hello World\\") \\"World Hello\\" >>> reverseWords(\\"Coding is fun\\") \\"fun is Coding\\" >>> reverseWords(\\"Keep calm and code on\\") \\"on code and calm Keep\\"","solution":"def reverseWords(s): This function takes a string containing alphabetic characters and spaces, and returns a new string with the order of words reversed but the order of characters within each word maintained. Args: s (str): input string containing alphabetic characters and spaces. Returns: str: the string with the order of words reversed. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def knapsack(W, n, items): Solves the 0/1 Knapsack problem for optimizing warehouse inventory. W: Integer, capacity of the warehouse. n: Integer, number of different types of items. items: List of tuples [(wi, vi), ..., (wn, vn)], where wi is the weight and vi is the value. >>> knapsack(50, 3, [(10, 60), (20, 100), (30, 120)]) == 220 >>> knapsack(100, 2, [(50, 200), (50, 300)]) == 500 pass def process_warehouse_data(input_data): Processes the input data and finds the maximum total value of items that the warehouse can store without exceeding its capacity. input_data: List of strings, each string being a line from input. >>> process_warehouse_data([\\"50 3\\", \\"10 60\\", \\"20 100\\", \\"30 120\\", \\"100 2\\", \\"50 200\\", \\"50 300\\", \\"0 0\\"]) == [220, 500] >>> process_warehouse_data([\\"10 1\\", \\"10 100\\", \\"5 1\\", \\"5 50\\", \\"10 2\\", \\"10 100\\", \\"5 40\\", \\"0 0\\"]) == [100, 50, 100] pass","solution":"def knapsack(W, n, items): Solves the 0/1 Knapsack problem. W: Integer, capacity of the warehouse. n: Integer, number of different types of items. items: List of tuples [(wi, vi), ..., (wn, vn)] dp = [0] * (W + 1) for weight, value in items: for j in range(W, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + value) return dp[W] def process_warehouse_data(input_data): Processes the input data and finds the maximum total value of items that the warehouse can store without exceeding its capacity. input_data: List of strings, each string being a line from input results = [] i = 0 while i < len(input_data): W, n = map(int, input_data[i].split()) if W == 0 and n == 0: break items = [] for j in range(i + 1, i + 1 + n): wi, vi = map(int, input_data[j].split()) items.append((wi, vi)) results.append(knapsack(W, n, items)) i += (n + 1) return results"},{"question":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of parentheses needed to make the string valid. >>> min_add_to_make_valid(\\"()\\") == 0 >>> min_add_to_make_valid(\\"(())\\") == 0 >>> min_add_to_make_valid(\\"(()\\") == 1 >>> min_add_to_make_valid(\\"(((\\") == 3 >>> min_add_to_make_valid(\\"())\\") == 1 >>> min_add_to_make_valid(\\")))\\") == 3 >>> min_add_to_make_valid(\\")))((\\") == 5 >>> min_add_to_make_valid(\\"()())(()\\") == 2 >>> min_add_to_make_valid(\\"\\") == 0","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses needed to make the string valid. left_bracket_needed = 0 right_bracket_needed = 0 for char in s: if char == '(': right_bracket_needed += 1 elif char == ')': if right_bracket_needed > 0: right_bracket_needed -= 1 else: left_bracket_needed += 1 return left_bracket_needed + right_bracket_needed"},{"question":"def can_rearrange_no_adjacent(n: int, s: str) -> str: Determines if the characters of the string can be rearranged such that no two adjacent characters are the same. >>> can_rearrange_no_adjacent(4, \\"AABB\\") 'YES' >>> can_rearrange_no_adjacent(3, \\"AAA\\") 'NO' >>> can_rearrange_no_adjacent(6, \\"AABCDE\\") 'YES' def process_input(t: int, cases: [(int, str)]) -> [str]: Processes multiple test cases and determines if the characters of each string can be rearranged such that no two adjacent characters are the same. >>> process_input(3, [(4, \\"AABB\\"), (3, \\"AAA\\"), (6, \\"AABCDE\\")]) ['YES', 'NO', 'YES'] # Unit tests def test_can_rearrange_no_adjacent(): assert can_rearrange_no_adjacent(4, \\"AABB\\") == \\"YES\\" assert can_rearrange_no_adjacent(3, \\"AAA\\") == \\"NO\\" assert can_rearrange_no_adjacent(6, \\"AABCDE\\") == \\"YES\\" assert can_rearrange_no_adjacent(1, \\"A\\") == \\"YES\\" assert can_rearrange_no_adjacent(2, \\"AA\\") == \\"NO\\" assert can_rearrange_no_adjacent(5, \\"AAAAA\\") == \\"NO\\" assert can_rearrange_no_adjacent(5, \\"AABBC\\") == \\"YES\\" def test_process_input(): input_cases = [ (4, \\"AABB\\"), (3, \\"AAA\\"), (6, \\"AABCDE\\") ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_input(3, input_cases) == expected_output input_cases = [ (1, \\"A\\"), (5, \\"AAAAA\\"), (5, \\"AABBC\\") ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_input(3, input_cases) == expected_output","solution":"def can_rearrange_no_adjacent(n, s): Determines if the characters of the string can be rearranged such that no two adjacent characters are the same. from collections import Counter # Count the frequency of each character char_count = Counter(s) # Get the frequency of the most common character max_count = max(char_count.values()) # If the most common character appears more than (n+1)/2 times, it's not possible to rearrange if max_count > (n + 1) // 2: return \\"NO\\" else: return \\"YES\\" def process_input(t, cases): results = [] for n, s in cases: results.append(can_rearrange_no_adjacent(n, s)) return results"},{"question":"def suggest_cars(n, cars, preferred_type, max_cost, min_seating): Suggest the best available cars to a user based on their preferences. Args: n (int): The number of cars available for rent. cars (list): A list of tuples where each tuple contains the type (str), cost per day (int), and seating capacity (int). preferred_type (str): The user's preferred vehicle type. max_cost (int): The user's preferred maximum cost per day. min_seating (int): The user's preferred minimum seating capacity. Returns: list: A list of cars that match the user's preferences or [\\"No cars available\\"] if no cars match. pass def parse_input(input_string): Parse the given input string to extract car details and user preferences. Args: input_string (str): The input string containing details of cars and user preferences. Returns: tuple: A tuple containing the number of cars, a list of car details, and user preferences. pass # Example usage: input_data = 5 Sedan 70 3 SUV 100 6 Convertible 150 4 Coupe 80 2 Sedan 60 4 Sedan 80 4 n, cars, preferred_type, max_cost, min_seating = parse_input(input_data) print(suggest_cars(n, cars, preferred_type, max_cost, min_seating))","solution":"def suggest_cars(n, cars, preferred_type, max_cost, min_seating): suitable_cars = [ f\\"{car[0]} {car[1]} {car[2]}\\" for car in cars if car[0] == preferred_type and car[1] <= max_cost and car[2] >= min_seating ] if suitable_cars: return suitable_cars else: return [\\"No cars available\\"] # Parsing input for demonstration, this part would typically be outside of function definitions def parse_input(input_string): lines = input_string.strip().split(\\"n\\") n = int(lines[0]) cars = [] for i in range(1, n + 1): type_, cost, seating = lines[i].split() cars.append((type_, int(cost), int(seating))) preferred_type = lines[n + 1] max_cost, min_seating = map(int, lines[n + 2].split()) return n, cars, preferred_type, max_cost, min_seating # Example usage: input_data = 5 Sedan 70 3 SUV 100 6 Convertible 150 4 Coupe 80 2 Sedan 60 4 Sedan 80 4 n, cars, preferred_type, max_cost, min_seating = parse_input(input_data) print(suggest_cars(n, cars, preferred_type, max_cost, min_seating))"},{"question":"def find_start_and_end_towns(n: int, connections: List[Tuple[int, int]]) -> Tuple[int, int]: Given the number of towns and their connections, find the starting and ending town. Args: n (int): The number of towns. connections (List[Tuple[int, int]]): The connections between the towns. Returns: Tuple[int, int]: The starting and ending towns for the marathon route. >>> find_start_and_end_towns(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) (1, 5) >>> find_start_and_end_towns(3, [(3, 2), (2, 1)]) (3, 1) >>> find_start_and_end_towns(2, [(1, 2)]) (1, 2)","solution":"def find_start_and_end_towns(n, connections): Given the number of towns and their connections, find the starting and ending town. from collections import defaultdict # Use a dictionary to count the degree of each town town_degrees = defaultdict(int) # Count the degree for each town for a, b in connections: town_degrees[a] += 1 town_degrees[b] += 1 start = end = None # Starting and ending towns will have a degree of 1 for town, degree in town_degrees.items(): if degree == 1: if start is None: start = town else: end = town return start, end"},{"question":"def max_product(lst): Returns the greatest product of any two distinct numbers in the list. >>> max_product([1, 2, 3]) 6 >>> max_product([-10, -10, 5, 2]) 100","solution":"def max_product(lst): Returns the greatest product of any two distinct numbers in the list. if len(lst) < 2: raise ValueError(\\"List must contain at least two elements.\\") lst.sort() # The greatest product could be from the two largest positive numbers # or from the two smallest (most negative) numbers. return max(lst[0] * lst[1], lst[-1] * lst[-2])"},{"question":"from typing import List def maxCoins(grid: List[List[int]]) -> int: Returns the maximum number of coins that can be collected when moving from the top-left corner to the bottom-right corner of the grid. If it is impossible to reach the bottom-right corner, returns 0. >>> grid = [ ... [0, 3, 1, 1], ... [2, 0, 0, 4], ... [1, 5, 3, 1] ... ] >>> maxCoins(grid) 12 >>> grid = [ ... [0, 3, -1, 1], ... [-1, 5, 0, -1], ... [2, 0, 0, -1] ... ] >>> maxCoins(grid) 0","solution":"from typing import List def maxCoins(grid: List[List[int]]) -> int: Returns the maximum number of coins that can be collected when moving from the top-left corner to the bottom-right corner of the grid. If it is impossible to reach the bottom-right corner, returns 0. if not grid or not grid[0] or grid[0][0] == -1 or grid[-1][-1] == -1: return 0 m, n = len(grid), len(grid[0]) # Initialize dp array with -1 since -1 represents obstacles dp = [[-1] * n for _ in range(m)] # Starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): if grid[0][j] == -1: break dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): if grid[i][0] == -1: break dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): if grid[i][j] != -1: if dp[i-1][j] != -1 and dp[i][j-1] != -1: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] elif dp[i-1][j] != -1: dp[i][j] = dp[i-1][j] + grid[i][j] elif dp[i][j-1] != -1: dp[i][j] = dp[i][j-1] + grid[i][j] return dp[m-1][n-1] if dp[m-1][n-1] != -1 else 0"},{"question":"def findSubstring(s: str, words: List[str]) -> List[int]: Given a string 's' and a list of words 'words' (each of which has the same length), return all starting indices of substrings in 's' which concatenate all words in 'words' exactly once and without any intervening characters. >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> findSubstring(\\"\\", [\\"foo\\", \\"bar\\"]) [] >>> findSubstring(\\"foobar\\", [\\"foo\\", \\"bar\\"]) [0] >>> findSubstring(\\"thisisnotamatch\\", [\\"foo\\", \\"bar\\"]) [] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) [8] >>> findSubstring(\\"aaaaaa\\", [\\"aa\\", \\"aa\\"]) [0, 1, 2]","solution":"def findSubstring(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) total_len = word_len * len(words) word_count = Counter(words) result = [] for i in range(len(s) - total_len + 1): seen_words = {} for j in range(len(words)): start_index = i + j * word_len word = s[start_index:start_index + word_len] if word in word_count: if word in seen_words: seen_words[word] += 1 else: seen_words[word] = 1 if seen_words[word] > word_count[word]: break else: break else: result.append(i) return result"},{"question":"def count_elements_with_frequency_at_least_k(A, l, r, k): Returns the number of distinct integers in the subarray A[l:r] that appear at least k times. def process_queries(n, k, A, queries): Processes each query and returns a list of results for each query. def test_example_1(): n = 8 k = 3 A = [1, 2, 2, 1, 2, 2, 1, 3] queries = [(1, 4), (2, 6), (3, 8)] assert process_queries(n, k, A, queries) == [0, 1, 1] def test_example_2(): n = 5 k = 2 A = [5, 3, 5, 5, 4] queries = [(1, 3), (2, 5)] assert process_queries(n, k, A, queries) == [1, 1] def test_single_element(): n = 1 k = 1 A = [1] queries = [(1, 1)] assert process_queries(n, k, A, queries) == [1] def test_no_repeating_elements(): n = 5 k = 2 A = [1, 2, 3, 4, 5] queries = [(1, 5), (2, 4), (3, 3)] assert process_queries(n, k, A, queries) == [0, 0, 0] def test_large_k(): n = 10 k = 5 A = [1, 2, 3, 1, 2, 1, 3, 1, 2, 1] queries = [(1, 10), (1, 5), (2, 7)] assert process_queries(n, k, A, queries) == [1, 0, 0]","solution":"def count_elements_with_frequency_at_least_k(A, l, r, k): Returns the number of distinct integers in the subarray A[l:r] that appear at least k times. subarray = A[l-1:r] frequency = {} for num in subarray: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 count = 0 for num in frequency: if frequency[num] >= k: count += 1 return count def process_queries(n, k, A, queries): Processes each query and returns a list of results for each query. results = [] for l, r in queries: result = count_elements_with_frequency_at_least_k(A, l, r, k) results.append(result) return results"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True # Solution code here def any_prime_permutation(num: int) -> str: Check if any permutation of the digits of num is a prime number. >>> any_prime_permutation(13) \\"YES\\" >>> any_prime_permutation(31) \\"YES\\" >>> any_prime_permutation(245) \\"NO\\" # Solution code here def process_test_cases(t: int, test_cases: List[int]) -> List[str]: Process multiple test cases to find if any permutation of the digits is a prime number. >>> process_test_cases(3, [13, 31, 245]) [\\"YES\\", \\"YES\\", \\"NO\\"] # Solution code here","solution":"from itertools import permutations def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def any_prime_permutation(num): Check if any permutation of the digits of num is a prime number. digits = str(num) perms = {int(''.join(p)) for p in permutations(digits)} for perm in perms: if is_prime(perm): return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): results = [] for case in test_cases: results.append(any_prime_permutation(case)) return results"},{"question":"def can_form_palindrome(t: int, test_cases: List[Tuple[int, str, int]]) -> List[str]: Determines if it is possible to rearrange the string and remove at most \`m\` characters to form a palindrome. >>> can_form_palindrome(4, [(5, 'abcbc', 1), (3, 'aaab', 1), (6, 'racecar', 0), (4, 'abcda', 1)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> can_form_palindrome(1, [(1, 'a', 0)]) [\\"YES\\"] >>> can_form_palindrome(1, [(2, 'ab', 0)]) [\\"NO\\"] >>> can_form_palindrome(1, [(5, 'abcde', 5)]) [\\"YES\\"]","solution":"def can_form_palindrome(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] s = test_cases[i][1] m = test_cases[i][2] from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Calculate the minimum number of removals needed to form a palindrome min_removals_needed = max(0, odd_count - 1) if min_removals_needed <= m: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minPathSum(grid): Given a 2D array grid representing an n x n grid filled with non-negative integers, find a path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1) which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time. >>> minPathSum([[1,3,1],[1,5,1],[4,2,1]]) 7 >>> minPathSum([[1,2,5],[3,2,1]]) 6 >>> minPathSum([[1,2,3],[4,5,6],[7,8,9]]) 21 >>> minPathSum([[3]]) 3 >>> minPathSum([[1,2],[1,1]]) 3","solution":"def minPathSum(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Populate the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][cols - 1]"},{"question":"def find_triplet_sum(array: List[int], target: int) -> bool: Determine whether there are three distinct integers in the array that add up to the target sum. >>> find_triplet_sum([-1, 2, 1, -4, 2], 0) True >>> find_triplet_sum([1, 2, 3, 4, 5], 50) False >>> find_triplet_sum([-5, -2, -3, -6], -10) True >>> find_triplet_sum([6, -5, 3, -5, -6], -4) True >>> find_triplet_sum([1000000000, 2000000000, -3000000000], 500000000) False >>> find_triplet_sum([i for i in range(0, 501)], 1200) True >>> find_triplet_sum([1, 1, 1, 2, 2, 2, 3, 3, 3], 6) True","solution":"def find_triplet_sum(array, target): Determine whether there are three distinct integers in the array that add up to the target sum. Returns: bool: True if such a triplet exists, else False. array.sort() N = len(array) for i in range(N - 2): left = i + 1 right = N - 1 while left < right: current_sum = array[i] + array[left] + array[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False # Function to interact with input-output format of the problem def solve(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) target = int(data[1]) array = list(map(int, data[2:])) if find_triplet_sum(array, target): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"def has_hamiltonian_cycle(n: int, roads: List[Tuple[int, int]]) -> str: Determine if there exists at least one Hamiltonian cycle in the given directed graph. Args: n (int): Number of viewpoints. roads (List[Tuple[int, int]]): List of directed roads between viewpoints. Returns: str: \\"YES\\" if there is a Hamiltonian cycle, otherwise \\"NO\\". Examples: >>> has_hamiltonian_cycle(4, [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)]) \\"YES\\" >>> has_hamiltonian_cycle(4, [(1, 2), (2, 3), (3, 4), (4, 2)]) \\"NO\\" >>> has_hamiltonian_cycle(3, [(1, 2), (2, 3), (3, 1)]) \\"YES\\"","solution":"def has_hamiltonian_cycle(n, roads): from itertools import permutations if n == 1: return \\"YES\\" if len(roads) < n: return \\"NO\\" graph = {i: [] for i in range(1, n+1)} for u, v in roads: graph[u].append(v) nodes = list(range(1, n+1)) for perm in permutations(nodes[1:], n-1): perm = (nodes[0],) + perm + (nodes[0],) if all(perm[i+1] in graph[perm[i]] for i in range(n)): return \\"YES\\" return \\"NO\\""},{"question":"def bishop_moves(r1, c1, r2, c2): Returns the minimum number of moves a bishop needs to move from (r1, c1) to (r2, c2). If it is not possible, return -1. >>> bishop_moves(1, 1, 8, 8) 1 >>> bishop_moves(1, 1, 2, 3) -1 >>> bishop_moves(4, 2, 4, 2) 0","solution":"def bishop_moves(r1, c1, r2, c2): Returns the minimum number of moves a bishop needs to move from (r1, c1) to (r2, c2). If it is not possible, return -1. # Check if both positions are on the same color if (r1 + c1) % 2 != (r2 + c2) % 2: return -1 # If same position, no move needed if r1 == r2 and c1 == c2: return 0 # Check if it's a direct diagonal move if abs(r1 - r2) == abs(c1 - c2): return 1 # Otherwise, it's possible in two moves since it's on the same color return 2"},{"question":"def minTransformationSteps(start: str, end: str, wordPairs: List[Tuple[str, str]]) -> int: Given a start word, an end word, and a list of word pairs, determine the number of steps required for the shortest transformation sequence from the start word to the end word. Each transformation sequence is such that each word in the sequence is transformed into another by changing exactly one character, and each transformed word must exist in the list of word pairs. If no such sequence exists, return -1. >>> minTransformationSteps(\\"hit\\", \\"cog\\", [(\\"hit\\", \\"hot\\"), (\\"hot\\", \\"dot\\"), (\\"dot\\", \\"dog\\"), (\\"dog\\", \\"cog\\")]) 4 >>> minTransformationSteps(\\"hit\\", \\"cog\\", [(\\"hit\\", \\"hot\\"), (\\"hot\\", \\"dot\\"), (\\"dot\\", \\"dog\\")]) -1 >>> minTransformationSteps(\\"hit\\", \\"hit\\", [(\\"hit\\", \\"hot\\"), (\\"hot\\", \\"dot\\"), (\\"dot\\", \\"dog\\"), (\\"dog\\", \\"cog\\")]) 0 >>> minTransformationSteps(\\"hit\\", \\"hot\\", [(\\"hit\\", \\"hot\\")]) 1 >>> minTransformationSteps(\\"hit\\", \\"cog\\", [(\\"hit\\", \\"hot\\"), (\\"hot\\", \\"dot\\"), (\\"dot\\", \\"dog\\"), (\\"dog\\", \\"log\\")]) -1 >>> minTransformationSteps(\\"hit\\", \\"cog\\", [(\\"hit\\", \\"hot\\"), (\\"hot\\", \\"hit\\"), (\\"hot\\", \\"dot\\"), (\\"dot\\", \\"dog\\"), (\\"dog\\", \\"cog\\")]) 4 pass","solution":"from collections import deque, defaultdict def minTransformationSteps(start, end, wordPairs): # Create a graph from word pairs graph = defaultdict(list) for word1, word2 in wordPairs: graph[word1].append(word2) graph[word2].append(word1) # Perform BFS queue = deque([(start, 0)]) # (current word, step count) visited = set([start]) while queue: current_word, steps = queue.popleft() # If we reached the end word, return the steps if current_word == end: return steps # Iterate through the neighbors of the current word for neighbor in graph[current_word]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) return -1 # If end word is not reachable # Example usage # start = \\"hit\\" # end = \\"cog\\" # wordPairs = [(\\"hit\\", \\"hot\\"), (\\"hot\\", \\"dot\\"), (\\"dot\\", \\"dog\\"), (\\"dog\\", \\"cog\\")] # print(minTransformationSteps(start, end, wordPairs)) # Output: 4"},{"question":"def can_sum_to_target(arr: list, target: int) -> bool: Determines whether any combination of elements in the array (without repetition) adds up to the target value. Parameters: arr (list): A list of positive integers. target (int): The target sum value. Returns: bool: True if there exists a combination that sums to target, otherwise False. Examples: >>> can_sum_to_target([2, 3, 7, 8, 10], 11) True >>> can_sum_to_target([1, 5, 10], 12) False","solution":"def can_sum_to_target(arr, target): Determines if any combination of elements in the array adds up to the target value. Parameters: arr (list): A list of positive integers. target (int): The target sum value. Returns: bool: True if there exists a combination that sums to target, otherwise False. n = len(arr) dp = [False] * (target + 1) dp[0] = True for num in arr: for t in range(target, num - 1, -1): if dp[t - num]: dp[t] = True return dp[target]"},{"question":"def unique_sorted(lst): Returns a list of unique integers sorted in non-decreasing order. >>> unique_sorted([4, 5, 2, 2, 3, 5, 1]) [1, 2, 3, 4, 5] >>> unique_sorted([7, 8, 9, 8, 7, 6]) [6, 7, 8, 9]","solution":"def unique_sorted(lst): Returns a list of unique integers sorted in non-decreasing order. return sorted(set(lst))"},{"question":"def can_distribute_supplies(T: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[str]: Determine if it's possible to distribute the supplies without exceeding any friend's carrying capacity. Arguments: T -- the number of test cases test_cases -- a list of test cases, each containing: - a tuple with two integers, N (number of supplies) and K (number of friends) - a list of N integers representing the weight of each supply - a list of K integers representing the carrying capacity of each friend Returns: A list of strings, \\"Possible\\" if the supplies can be distributed without exceeding any friend's carrying capacity, otherwise \\"Not Possible\\". Example: >>> can_distribute_supplies(2, [((3, 2), [5, 10, 15], [20, 20]), ((4, 3), [8, 5, 7, 14], [10, 10, 10])]) [\\"Possible\\", \\"Not Possible\\"] >>> can_distribute_supplies(1, [((4, 1), [10, 20, 30, 40], [100])]) [\\"Possible\\"] pass","solution":"def can_distribute_supplies(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] supplies = sorted(test_cases[i][1], reverse=True) capacities = sorted(test_cases[i][2], reverse=True) if sum(supplies) > sum(capacities): results.append(\\"Not Possible\\") continue can_distribute = True for supply in supplies: placed = False for j in range(len(capacities)): if supply <= capacities[j]: capacities[j] -= supply placed = True break if not placed: can_distribute = False break results.append(\\"Possible\\" if can_distribute else \\"Not Possible\\") return results"},{"question":"def find_longest_palindrome(n: int, puzzle_pieces: List[str]) -> Tuple[int, List[int]]: Alice is a puzzle enthusiast who loves brain teasers involving word formation. Recently, she came across a riddle that involves combining puzzle pieces to form the longest palindrome possible. Alice has n puzzle pieces, where each piece is a lowercase English alphabet string. She can combine any two puzzle pieces to create a new string by concatenating them. Alice's goal is to find a combination of up to two puzzle pieces that, when concatenated, form the longest possible palindrome. Help Alice determine the maximum length of the palindrome that can be formed and the indices of the puzzle pieces she should use. >>> find_longest_palindrome(5, [\\"madam\\", \\"racecar\\", \\"hello\\", \\"level\\", \\"world\\"]) (7, [2]) >>> find_longest_palindrome(4, [\\"a\\", \\"ab\\", \\"ba\\", \\"civic\\"]) (5, [4]) >>> find_longest_palindrome(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) (0, []) >>> find_longest_palindrome(5, [\\"a\\", \\"z\\", \\"ab\\", \\"ba\\", \\"x\\"]) (4, [3, 4]) >>> find_longest_palindrome(4, [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) (1, [1])","solution":"def find_longest_palindrome(n, puzzle_pieces): def is_palindrome(s): return s == s[::-1] longest_palindrome_length = 0 longest_palindrome_indices = [] # Check all single puzzle pieces for i in range(n): if is_palindrome(puzzle_pieces[i]): if len(puzzle_pieces[i]) > longest_palindrome_length: longest_palindrome_length = len(puzzle_pieces[i]) longest_palindrome_indices = [i + 1] # Check all pairs of puzzle pieces for i in range(n): for j in range(i + 1, n): combined_1 = puzzle_pieces[i] + puzzle_pieces[j] combined_2 = puzzle_pieces[j] + puzzle_pieces[i] if is_palindrome(combined_1) or is_palindrome(combined_2): combined_length = max(len(combined_1), len(combined_2)) if combined_length > longest_palindrome_length: longest_palindrome_length = combined_length longest_palindrome_indices = [i + 1, j + 1] if longest_palindrome_length == 0: return 0, [] else: return longest_palindrome_length, longest_palindrome_indices"},{"question":"def find_winners(auction_data: List[List[int]]) -> List[int]: Given the bids placed on various items by different participants, find the index of the winning participant (0-based) for each corresponding item. The winner for each item is determined based on the highest bid. In case of ties, the participant with the smallest index in the list of bids wins. Args: auction_data (List[List[int]]): A list of lists where each sublist contains the bids for an item placed by different participants. Returns: List[int]: A list of integers where each integer is the index of the winning participant for the corresponding item. Examples: >>> find_winners([[10]]) [0] >>> find_winners([[10, 20, 30, 20]]) [2] >>> find_winners([[10, 20, 30, 20, 30]]) [2] >>> find_winners([[10, 20, 30, 20, 30], [50, 50, 30]]) [2, 0] >>> find_winners([[15, 15, 15]]) [0] >>> fake_data = [[i for i in range(100000)]] >>> find_winners(fake_data) [99999] >>> find_winners([[10, 20, 30], [50, 60], [5, 5, 5, 5]]) [2, 1, 0]","solution":"def find_winners(auction_data): winners = [] n = len(auction_data) for i in range(n): bids = auction_data[i] max_bid = max(bids) winner_index = bids.index(max_bid) winners.append(winner_index) return winners"},{"question":"def total_distance_covered(test_cases): Given the number of test cases each followed by the number of days and distances hiked each day, calculate the total distance covered for each test case. Parameters: test_cases (list of tuples): Each tuple contains the number of days and the distances for those days. Returns: list: A list containing the total distance for each test case. pass # Fill in the logic to calculate total distances # Example usage: # test_cases = [(3, 10, 20, 30), (2, 5, 15)] # result = total_distance_covered(test_cases) # print(result) # Output should be [60, 20]","solution":"def total_distance_covered(test_cases): Given the number of test cases each followed by the number of days and distances hiked each day, calculate the total distance covered for each test case. Parameters: test_cases (list of tuples): Each tuple contains the number of days and the distances for those days. Returns: list: A list containing the total distance for each test case. total_distances = [] for case in test_cases: D, *distances = case total_distance = sum(distances) total_distances.append(total_distance) return total_distances # Example usage: # test_cases = [(3, 10, 20, 30), (2, 5, 15)] # result = total_distance_covered(test_cases) # print(result) # Output should be [60, 20]"},{"question":"def max_rounds(r: int, b: int) -> int: Determine the maximum number of rounds a game can last given the initial number of red and blue balloons. >>> max_rounds(3, 5) 7 >>> max_rounds(0, 0) 0 >>> max_rounds(1, 1) 2 >>> max_rounds(4, 3) 7 >>> max_rounds(10, 10) 20 >>> max_rounds(5, 3) 7 >>> max_rounds(0, 5) 1 >>> max_rounds(5, 0) 1 >>> max_rounds(50, 50) 100 >>> max_rounds(100, 50) 101 >>> max_rounds(100, 0) 1","solution":"def max_rounds(r, b): return min(r, b) * 2 + (1 if abs(r - b) > 0 else 0)"},{"question":"def min_length_substring_to_remove(n: int, s: str) -> int: Returns the length of the minimum substring that needs to be removed so that each character in the remaining string appears the same number of times. >>> min_length_substring_to_remove(7, \\"aabbccd\\") 1 >>> min_length_substring_to_remove(6, \\"aabbcc\\") 0 >>> min_length_substring_to_remove(5, \\"aaaaa\\") 0 >>> min_length_substring_to_remove(6, \\"abcdad\\") 2 >>> min_length_substring_to_remove(10, \\"aabbccddaa\\") 4 >>> min_length_substring_to_remove(1, \\"a\\") 0","solution":"from collections import Counter def min_length_substring_to_remove(n, s): Returns the length of the minimum substring that needs to be removed so that each character in the remaining string appears the same number of times. char_count = Counter(s) freq_count = Counter(char_count.values()) if len(freq_count) == 1: return 0 # All characters already appear the same number of times freq_items = sorted(freq_count.items()) min_removals = float('inf') for i in range(len(freq_items)): count_removals = 0 for j in range(len(freq_items)): if i != j: count_removals += freq_items[j][0] * freq_items[j][1] if count_removals < min_removals: min_removals = count_removals return min_removals"},{"question":"def count_pairs_with_difference(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[int]: For each test case, finds the number of pairs (i, j) such that the absolute difference between the elements at these indices is exactly D. Parameters: T (int): The number of test cases. cases (List[Tuple[int, int, List[int]]]): A list containing tuples, where each tuple contains: - an integer N representing the length of the list, - an integer D representing the required difference, - a list of integers L. Returns: List[int]: A list containing the results for each test case. >>> count_pairs_with_difference(2, [(5, 2, [1, 5, 3, 4, 2]), (3, 0, [1, 1, 1])]) [3, 3] >>> count_pairs_with_difference(1, [(4, 1, [1, 2, 3, 4])]) [3] >>> count_pairs_with_difference(1, [(5, 3, [1, 1, 1, 1, 1])]) [0] >>> count_pairs_with_difference(1, [(6, 4, [1, 5, 9, 13, 17, 21])]) [5] >>> count_pairs_with_difference(1, [(4, 6, [1, 7, 1, 7])]) [4] pass","solution":"def count_pairs_with_difference(T, cases): results = [] for i in range(T): N, D = cases[i][:2] L = cases[i][2] count = 0 value_count = {} for num in L: if num + D in value_count: count += value_count[num + D] if num - D in value_count and D != 0: count += value_count[num - D] if num in value_count: value_count[num] += 1 else: value_count[num] = 1 results.append(count) return results"},{"question":"def min_unique_items_needed(tasks: List[List[int]]) -> int: Given a list of tasks with required items, this function calculates the minimum number of unique items needed to complete all tasks. Args: tasks (List[List[int]]): A list of tasks, each task is represented by a list of item IDs required for that task. Returns: int: Minimum number of unique items needed to complete all tasks. Examples: >>> min_unique_items_needed([[1, 2], [2], [3, 4]]) 4 >>> min_unique_items_needed([[1], [1], [1]]) 1","solution":"def min_unique_items_needed(tasks): Given a list of tasks with required items, this function calculates the minimum number of unique items needed to complete all tasks. all_items = set() for task in tasks: for item in task: all_items.add(item) return len(all_items) # Example usage: n = 3 tasks = [ [1, 2], [2], [3, 4] ] print(min_unique_items_needed(tasks)) # Output: 4"},{"question":"import numpy as np def create_custom_array(N: int, M: int) -> np.ndarray: Creates an N x M array with the main diagonal elements filled with 9 and the rest filled with zeros. >>> create_custom_array(3, 3) array([[9, 0, 0], [0, 9, 0], [0, 0, 9]]) >>> create_custom_array(4, 5) array([[9, 0, 0, 0, 0], [0, 9, 0, 0, 0], [0, 0, 9, 0, 0], [0, 0, 0, 9, 0]])","solution":"import numpy as np def create_custom_array(N, M): Creates an N x M array with the main diagonal elements filled with 9 and the rest filled with zeros. # Initialize an NxM array filled with zeros result = np.zeros((N, M), dtype=int) # Fill the main diagonal with 9 for i in range(min(N, M)): result[i, i] = 9 return result"},{"question":"def largest_connected_component(n, edges): Create a program that simulates a system to monitor and find the largest group of connected devices in a network. Each device is represented as a node in a graph, and each connection between two devices as an edge. Your task is to implement a function that reads a list of edges representing the connections and outputs the size of the largest group of connected devices. A group of connected devices is defined as a set of nodes that are all reachable from each other. >>> largest_connected_component(6, [(1, 2), (2, 3), (3, 4), (5, 6), (6, 7), (8, 8)]) 4 >>> largest_connected_component(5, [(1, 2), (2, 3), (3, 4), (4, 1), (5, 6)]) 4 >>> largest_connected_component(3, [(1, 2), (3, 4), (5, 6)]) 2 >>> largest_connected_component(0, []) 0 >>> largest_connected_component(4, [(1, 2), (2, 3), (3, 4), (5, 5)]) 4","solution":"def largest_connected_component(n, edges): from collections import defaultdict, deque def bfs(node, visited, graph): queue = deque([node]) visited.add(node) size = 0 while queue: current = queue.popleft() size += 1 for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return size # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() max_size = 0 for node in graph: if node not in visited: component_size = bfs(node, visited, graph) max_size = max(max_size, component_size) return max_size"},{"question":"def sentence_with_highest_word_count(feedback): Returns the sentence with the highest word count from the given feedback. Sentences are separated by periods, and words by spaces. >>> sentence_with_highest_word_count(\\"This product is amazing. I loved using it every day. Highly recommend to everyone.\\") \\"I loved using it every day\\" >>> sentence_with_highest_word_count(\\"\\") \\"\\" >>> sentence_with_highest_word_count(\\"This is the only sentence.\\") \\"This is the only sentence\\" >>> sentence_with_highest_word_count(\\"The cat sat on the mat. The dog sat on the rug.\\") \\"The cat sat on the mat\\" >>> sentence_with_highest_word_count(\\"Amazing product. Must buy..\\") \\"Amazing product\\" >>> sentence_with_highest_word_count(\\" Excellent design and quality. Worth the price. \\") \\"Excellent design and quality\\"","solution":"def sentence_with_highest_word_count(feedback): Returns the sentence with the highest word count from the given feedback. Sentences are separated by periods, and words by spaces. if not feedback: return \\"\\" sentences = feedback.split('.') max_word_count = 0 result_sentence = \\"\\" for sentence in sentences: words = sentence.strip().split() word_count = len(words) if word_count > max_word_count: max_word_count = word_count result_sentence = sentence.strip() return result_sentence"},{"question":"def distinct_substrings_count(s): Returns the number of distinct substrings in the given string s. pass def malfunction_check(t, limits_and_strings): Returns a list of results (\\"NO MALFUNCTION\\" or \\"MALFUNCTION\\") for each test case. Args: - t (int): number of test cases - limits_and_strings (list of tuples): each tuple contains an integer l (upper limit of distinct substrings) and a string s (the string to analyze) Returns: - list: results for each test case Example: >>> malfunction_check(2, [(10, \\"abc\\"), (5, \\"ababa\\")]) [\\"NO MALFUNCTION\\", \\"MALFUNCTION\\"] >>> malfunction_check(1, [(1, \\"a\\")]) [\\"NO MALFUNCTION\\"] pass","solution":"def distinct_substrings_count(s): Returns the number of distinct substrings in the given string s. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) def malfunction_check(t, limits_and_strings): Returns a list of results (\\"NO MALFUNCTION\\" or \\"MALFUNCTION\\") for each test case. results = [] for l, s in limits_and_strings: distinct_count = distinct_substrings_count(s) if distinct_count > l: results.append(\\"MALFUNCTION\\") else: results.append(\\"NO MALFUNCTION\\") return results"},{"question":"def max_performances(total_duration: int, artists: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping performances that can be scheduled within the festival's time limit. Args: total_duration: An integer representing the total duration of the festival in minutes. artists: A list of tuples where each tuple contains two integers, the availability start time and the duration of the performance of each artist. Returns: An integer representing the maximum number of non-overlapping performances. >>> max_performances(300, [(30, 100), (120, 150), (180, 90), (240, 50)]) 2 >>> max_performances(200, [(10, 50), (60, 50), (120, 50)]) 3 >>> max_performances(200, [(10, 50), (20, 50)]) 1 >>> max_performances(500, [(50, 200), (250, 200), (100, 100), (400, 50), (450, 30)]) 3 >>> max_performances(180, [(0, 60), (60, 60), (120, 60)]) 3","solution":"def max_performances(total_duration, artists): Returns the maximum number of non-overlapping performances that can be scheduled within the festival's time limit. # Create a list of the performances with their end times performances = [(start, start + duration) for start, duration in artists] # Sort performances based on the end time performances.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in performances: # Check if this performance can be scheduled if start >= last_end_time and end <= total_duration: count += 1 last_end_time = end return count # Example usage: total_duration = 300 artists = [(30, 100), (120, 150), (180, 90), (240, 50)] print(max_performances(total_duration, artists)) # Output: 2"},{"question":"def group_words_by_length(words: List[str]) -> Dict[int, List[str]]: Returns a dictionary where the keys are the lengths of the words, and the values are lists of words of that length, sorted alphabetically. >>> group_words_by_length([\\"apple\\", \\"bat\\", \\"banana\\", \\"ape\\", \\"grape\\", \\"kiwi\\"]) { 3: [\\"ape\\", \\"bat\\"], 4: [\\"kiwi\\"], 5: [\\"apple\\", \\"grape\\"], 6: [\\"banana\\"] }","solution":"def group_words_by_length(words): Returns a dictionary where the keys are the lengths of the words, and the values are lists of words of that length, sorted alphabetically. from collections import defaultdict length_dict = defaultdict(list) for word in words: length_dict[len(word)].append(word) # Sort each list of words alphabetically for length in length_dict: length_dict[length].sort() return dict(length_dict)"},{"question":"def calculate_total_sales(input_data: str) -> List[Tuple[int, int]]: Given sales data for two weeks separated by a blank line, return the total sales for products that were sold in both weeks. >>> calculate_total_sales(\\"101,500n202,3000n303,200nn101,700n202,2000n404,100n\\") [(101, 1200), (202, 5000)] >>> calculate_total_sales(\\"101,500n303,200nn202,2000n404,100n\\") [] pass","solution":"def calculate_total_sales(input_data): Given sales data for two weeks separated by a blank line, return the total sales for products that were sold in both weeks. week1_data, week2_data = input_data.strip().split(\\"nn\\") def parse_data(data): sales_dict = {} for line in data.strip().split(\\"n\\"): product_id, sales_amount = map(int, line.split(',')) sales_dict[product_id] = sales_dict.get(product_id, 0) + sales_amount return sales_dict week1_sales = parse_data(week1_data) week2_sales = parse_data(week2_data) common_products = set(week1_sales.keys()) & set(week2_sales.keys()) result = [(product_id, week1_sales[product_id] + week2_sales[product_id]) for product_id in common_products] result.sort() return result"},{"question":"def find_winner(n: int, votes: List[int]) -> int: Determines the candidate with the maximum votes. If there's a tie, the candidate with the lower integer value wins. Args: n (int): Total number of votes. votes (list of int): List of votes. Returns: int: Candidate who received the most votes.","solution":"def find_winner(n, votes): Determines the candidate with the maximum votes. If there's a tie, the candidate with the lower integer value wins. Args: n (int): Total number of votes. votes (list of int): List of votes. Returns: int: Candidate who received the most votes. from collections import defaultdict vote_count = defaultdict(int) for vote in votes: vote_count[vote] += 1 max_votes = -1 winner = None for candidate, count in vote_count.items(): if count > max_votes or (count == max_votes and candidate < winner): max_votes = count winner = candidate return winner"},{"question":"def nextPrime(N: int) -> int: Returns the smallest prime number greater than N. >>> nextPrime(10) 11 >>> nextPrime(17) 19 >>> nextPrime(1) 2 >>> nextPrime(23) 29 >>> nextPrime(1000000) 1000003","solution":"import math def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def nextPrime(N): Returns the smallest prime number greater than N. candidate = N + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"def smallest_palindrome(s: str) -> str: Given a string of lowercase English letters, determine the lexicographically smallest palindrome that can be obtained by rearranging the characters of the original string. If it is impossible to form any palindrome, return the string \\"IMPOSSIBLE\\". >>> smallest_palindrome(\\"aabb\\") 'abba' >>> smallest_palindrome(\\"abc\\") 'IMPOSSIBLE' >>> smallest_palindrome(\\"aaabbbb\\") 'abbabba'","solution":"def smallest_palindrome(s): from collections import Counter count = Counter(s) odd_char_count = sum(1 for v in count.values() if v % 2 != 0) if odd_char_count > 1: return \\"IMPOSSIBLE\\" first_half = [] middle_char = \\"\\" for char in sorted(count): if count[char] % 2 != 0: middle_char = char first_half.append(char * (count[char] // 2)) first_half_str = \\"\\".join(first_half) second_half_str = first_half_str[::-1] return first_half_str + middle_char + second_half_str"},{"question":"def process_queries(queries): Tom is designing a new text-based game and needs your help to keep track of scores for each player. Each player can gain or lose points after a series of actions. The game should maintain a running total of each player's score and be able to print the top player(s) at any given time, including the possibility of a tie. Parameters: queries -> List of string queries where each query is either of the form \\"UPDATE player_name delta\\" or \\"TOP\\". Returns: List of strings where each string corresponds to the result of a \\"TOP\\" query. Examples: >>> process_queries([\\"UPDATE alice 5\\", \\"TOP\\"]) [\\"alice\\"] >>> process_queries([\\"UPDATE alice 5\\", \\"UPDATE bob 5\\", \\"TOP\\"]) [\\"alice bob\\"]","solution":"def process_queries(queries): from collections import defaultdict scores = defaultdict(int) output = [] for query in queries: parts = query.split() if parts[0] == \\"UPDATE\\": player_name = parts[1] delta = int(parts[2]) scores[player_name] += delta elif parts[0] == \\"TOP\\": # Determine top score if not scores: output.append('') continue top_score = max(scores.values()) top_players = sorted([player for player, score in scores.items() if score == top_score]) output.append(\\" \\".join(top_players)) return output"},{"question":"def trap_rain_water(height: List[int]) -> int: Calculate the total amount of rainwater trapped between different heights after raining. Args: height (List[int]): A list of non-negative integers representing the heights. Returns: int: The total amount of trapped rainwater. Examples: >>> trap_rain_water([0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2]) 8 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_rain_water(height): if not height: return 0 n = len(height) left_max, right_max = [0] * n, [0] * n left_max[0] = height[0] right_max[n - 1] = height[n - 1] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def all_vowels(words: List[str]) -> int: Returns the count of words that contain all five vowels (a, e, i, o, u). >>> all_vowels([\\"education\\", \\"automobile\\", \\"unicorn\\", \\"communication\\"]) # 2 >>> all_vowels([\\"bcdfg\\", \\"hjklm\\"]) # 0 >>> all_vowels([\\"edu\\", \\"automobile\\", \\"communication\\"]) # 1 >>> all_vowels([\\"educationeducation\\", \\"automobile\\", \\"uouaei\\", \\"communication\\"]) # 3 >>> all_vowels([\\"aeiou\\", \\"oueia\\"]) # 2 >>> all_vowels([]) # 0 >>> all_vowels([\\"aeiou\\"*4]) # 1","solution":"def all_vowels(words): Returns the count of words that contain all five vowels (a, e, i, o, u). vowels = set('aeiou') count = 0 for word in words: if vowels.issubset(word): count += 1 return count"},{"question":"def longest_unique_substring_length(s: str) -> int: Finds the length of the longest substring that consists of unique characters in the given string. >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"bbbbb\\") 1 >>> longest_unique_substring_length(\\"pwwkew\\") 3 >>> longest_unique_substring_length(\\"a\\") 1 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"abcdef\\") 6 >>> longest_unique_substring_length(\\"abca\\") 3 >>> longest_unique_substring_length(\\"abba\\") 2","solution":"def longest_unique_substring_length(s): Finds the length of the longest substring with all unique characters. :param s: A string consisting of lowercase letters. :return: An integer representing the length of the longest unique substring. n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_index = {} for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def can_complete_assembly(n: int, commands: str, m: int) -> str: Returns \\"YES\\" if the robot can complete the assembly process given its memory limit, otherwise returns \\"NO\\". >>> can_complete_assembly(8, 'abcdefgh', 5) \\"NO\\" >>> can_complete_assembly(5, 'abcde', 5) \\"YES\\"","solution":"def can_complete_assembly(n, commands, m): Returns \\"YES\\" if the robot can complete the assembly process given its memory limit, otherwise returns \\"NO\\". if n <= m: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_branches(N: int) -> int: Given an integer N, representing the number of years since Alice planted the tree, find the number of branches present on the tree after N years. >>> count_branches(1) 4 >>> count_branches(2) 8 >>> count_branches(5) 108","solution":"def count_branches(N): branches = 1 # Initially, there is 1 branch for year in range(1, N + 1): if year % 2 == 1: # Odd year branches *= 4 # Each branch produces 3 new, so total becomes 4 times else: # Even year branches *= 2 # Each branch produces 2 new, so total becomes 3 times return branches"},{"question":"def find_books_to_keep(n: int, k: int, books: List[Tuple[int, int]]) -> List[int]: Returns the identifiers of the k most expensive books that Marie should keep. If multiple books have the same price, the book with the smaller identifier is preferred. >>> find_books_to_keep(5, 3, [(101, 25), (102, 30), (103, 25), (104, 30), (105, 20)]) [101, 102, 104]","solution":"def find_books_to_keep(n, k, books): Returns the identifiers of the k most expensive books that Marie should keep. If multiple books have the same price, the book with the smaller identifier is preferred. # Sort books first by price in descending order, then by id in ascending order sorted_books = sorted(books, key=lambda x: (-x[1], x[0])) # Take the first k books from the sorted list most_expensive_books = sorted_books[:k] # Extract the ids and sort them result = [book[0] for book in most_expensive_books] result.sort() return result # Example of usage: # n = 5 # k = 3 # books = [(101, 25), (102, 30), (103, 25), (104, 30), (105, 20)] # print(find_books_to_keep(n, k, books)) # Output: [101, 102, 104]"},{"question":"def min_number_of_albums(N, stamps): Determine the minimum number of albums needed to organize the stamps collection. Parameters: N: int - the number of stamps. stamps: List[int] - a list of integer types of stamps. Returns: int - the minimum number of albums needed. Example: >>> min_number_of_albums(6, [2, 3, 2, 5, 3, 2]) 3 >>> min_number_of_albums(5, [1, 1, 1, 1, 1]) 1 >>> min_number_of_albums(4, [1, 2, 3, 4]) 4 >>> min_number_of_albums(7, [1, 2, 1, 3, 4, 2, 4]) 4 >>> min_number_of_albums(0, []) 0 >>> min_number_of_albums(10**5, [i for i in range(1, 10001)] * 10) 10000","solution":"def min_number_of_albums(N, stamps): Determine the minimum number of albums needed to organize the stamps collection. Parameters: N: int - the number of stamps. stamps: List[int] - a list of integer types of stamps. Returns: int - the minimum number of albums needed. return len(set(stamps))"},{"question":"def reverse_integer(x: int) -> int: Reverses the digits of an integer x. Returns 0 if the reversed integer overflows a 32-bit signed integer. >>> reverse_integer(123) # should return 321 >>> reverse_integer(-123) # should return -321 >>> reverse_integer(1534236469) # should return 0","solution":"def reverse_integer(x): Reverses the digits of an integer x. Returns 0 if the reversed integer overflows a 32-bit signed integer. # Define the boundaries for a 32-bit signed integer INT_MAX = 2**31 - 1 INT_MIN = -2**31 # Initialize result as 0 result = 0 negative = x < 0 x = abs(x) while x != 0: pop = x % 10 x //= 10 if result > (INT_MAX - pop) // 10: return 0 result = result * 10 + pop return result if not negative else -result"},{"question":"def can_transform_by_one_swap(source: str, target: str) -> str: Louisa is a fan of word puzzles and she likes to create new words by shuffling the letters of a given word using any number of operations. She wants to know if a target word can be formed by performing exactly one swap of any two letters of a given source word. Check if the target word can be formed by performing exactly one swap of any two letters of the source word. >>> can_transform_by_one_swap(\\"listen\\", \\"silent\\") \\"NO\\" >>> can_transform_by_one_swap(\\"converse\\", \\"conserve\\") \\"YES\\" >>> can_transform_by_one_swap(\\"abcde\\", \\"abced\\") \\"YES\\" >>> can_transform_by_one_swap(\\"example\\", \\"samples\\") \\"NO\\" >>> can_transform_by_one_swap(\\"racecar\\", \\"racecra\\") \\"YES\\"","solution":"def can_transform_by_one_swap(source: str, target: str) -> str: Check if the target word can be formed by performing exactly one swap of any two letters of the source word. if len(source) != len(target): return \\"NO\\" # Find the positions where the two words differ differences = [] for i in range(len(source)): if source[i] != target[i]: differences.append(i) # If there are not exactly two differences, return \\"NO\\" if len(differences) != 2: return \\"NO\\" # Check if swapping the differing characters in source makes it equal to target i, j = differences if source[i] == target[j] and source[j] == target[i]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def first_peak_element(arr: List[int]) -> int: Finds the first peak element in the array. A peak element is an element that is greater than its neighbors. Args: arr (List[int]): List of integers representing the array. Returns: int: The first peak element in the array. If no peak element, return -1. Examples: >>> first_peak_element([1, 3, 20, 4, 1, 0]) 20 >>> first_peak_element([10, 1, 2, 3]) 10 >>> first_peak_element([1, 2, 2, 2, 1]) -1 pass def test_first_peak_element_single_element(): assert first_peak_element([5]) == 5 def test_first_peak_element_peak_at_start(): assert first_peak_element([10, 1, 2, 3]) == 10 def test_first_peak_element_peak_at_end(): assert first_peak_element([1, 2, 3, 10]) == 10 def test_first_peak_element_peak_in_middle(): assert first_peak_element([1, 3, 20, 4, 1, 0]) == 20 def test_first_peak_element_no_peak(): assert first_peak_element([1, 2, 2, 2, 1]) == -1 def test_first_peak_element_multiple_peaks(): assert first_peak_element([10, 1, 10, 1, 10]) == 10 def test_first_peak_element_all_same_elements(): assert first_peak_element([5, 5, 5, 5, 5]) == -1","solution":"def first_peak_element(arr): Finds the first peak element in the array. A peak element is an element that is greater than its neighbors. n = len(arr) if n == 1: return arr[0] if n > 1 and arr[0] > arr[1]: return arr[0] if n > 1 and arr[n-1] > arr[n-2]: return arr[n-1] for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: return arr[i] return -1"},{"question":"def find_path(grid: List[List[int]]) -> int: Given a grid of 0s and 1s, determines if there is a path from the top row to the bottom row using only cells containing 1. Movement can be horizontal, vertical, or diagonal. >>> find_path([ ... [1, 0, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 0, 1, 1, 1] ... ]) == 1 >>> find_path([ ... [1, 0, 0, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [1, 0, 0, 0, 0] ... ]) == 0 def solution(R: int, C: int, flat_grid: List[int]) -> int: Given the dimensions of the grid (R and C) and the grid in a flat list format, process the grid and return the result of find_path function. >>> solution(5, 5, [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1]) == 1 >>> solution(5, 5, [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]) == 0","solution":"def find_path(grid): Given a grid of 0s and 1s, determines if there is a path from the top row to the bottom row using only cells containing 1. Movement can be horizontal, vertical, or diagonal. R = len(grid) C = len(grid[0]) def dfs(x, y, visited): if x == R - 1: # Reached the last row return True directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == 1 and (nx, ny) not in visited: if dfs(nx, ny, visited): return True return False for col in range(C): if grid[0][col] == 1: if dfs(0, col, set()): return 1 return 0 # Function to process input def solution(R, C, flat_grid): grid = [] for i in range(R): grid.append(flat_grid[i * C: (i + 1) * C]) return find_path(grid)"},{"question":"def moveNegativesToEnd(arr): Move all negative numbers to the end of the array while maintaining the order of positive numbers and zeros. Parameters: arr (List[int]): Input array of integers. Returns: List[int]: Array with all negative numbers moved to the end.","solution":"def moveNegativesToEnd(arr): Move all negative numbers to the end of the array while maintaining the order of positive numbers and zeros. Parameters: arr (List[int]): Input array of integers. Returns: List[int]: Array with all negative numbers moved to the end. n = len(arr) result = [] # Collect positive numbers and zeros for num in arr: if num >= 0: result.append(num) # Collect negative numbers for num in arr: if num < 0: result.append(num) return result"},{"question":"def maxLengthSubarray(arr: List[int]) -> int: Given an array of n integers, find the maximum length of a subarray where the absolute difference between any two elements is less than or equal to 1. >>> maxLengthSubarray([1, 1, 2, 2, 3, 4]) == 4 >>> maxLengthSubarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 >>> maxLengthSubarray([5, 5, 5, 5, 5]) == 5 >>> maxLengthSubarray([1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) == 10 >>> maxLengthSubarray([1, 3, 5, 7, 9]) == 1","solution":"def maxLengthSubarray(arr): from collections import defaultdict # Frequency dictionary to keep track of the occurrence of each number freq = defaultdict(int) max_length = 0 for num in arr: freq[num] += 1 # Check the combination of each number and its consecutive number for num in set(arr): if num + 1 in freq: max_length = max(max_length, freq[num] + freq[num + 1]) max_length = max(max_length, freq[num]) return max_length"},{"question":"def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a new list containing all elements that are present in both list1 and list2. The elements in the result list are in decreasing order. Examples: >>> common_elements([4, 3, 7, 9], [3, 9, 10, 11]) [9, 3] >>> common_elements([1, 2, 3], [4, 5, 6]) [] >>> common_elements([5, 5, 10, 20], [5, 10, 20, 20]) [20, 10, 5]","solution":"def common_elements(list1, list2): Returns a new list containing all elements that are present in both list1 and list2. The elements in the result list are in decreasing order. # Find the intersection of both lists common_set = set(list1) & set(list2) # Convert the set to a sorted list in decreasing order return sorted(common_set, reverse=True)"},{"question":"def num_paths(n: int, m: int, grid: List[str]) -> int: Determine the number of distinct paths to reach the bottom-right corner of the grid. >>> num_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths(2, 2, [\\"..\\", \\"#.\\"]) 1 >>> num_paths(4, 4, [\\"...#\\", \\"..#.\\", \\"#...\\", \\"...#\\"]) 0 from solution import num_paths def test_example_1(): n, m = 3, 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert num_paths(n, m, grid) == 2 def test_example_2(): n, m = 2, 2 grid = [ \\"..\\", \\"#.\\" ] assert num_paths(n, m, grid) == 1 def test_example_3(): n, m = 4, 4 grid = [ \\"...#\\", \\"..#.\\", \\"#...\\", \\"...#\\" ] assert num_paths(n, m, grid) == 0 def test_starting_point_blocked(): n, m = 2, 2 grid = [ \\"#.\\", \\"..\\" ] assert num_paths(n, m, grid) == 0 def test_ending_point_blocked(): n, m = 2, 2 grid = [ \\"..\\", \\".#\\" ] assert num_paths(n, m, grid) == 0 def test_single_cell(): n, m = 1, 1 grid = [ \\".\\" ] assert num_paths(n, m, grid) == 1 def test_all_walls(): n, m = 3, 3 grid = [ \\"#\\", \\"#\\", \\"#\\" ] assert num_paths(n, m, grid) == 0 def test_large_grid_no_obstacles(): n, m = 3, 5 grid = [ \\".....\\", \\".....\\", \\".....\\" ] assert num_paths(n, m, grid) == 15","solution":"def num_paths(n, m, grid): # Initialize a dp array with zeros dp = [[0 for _ in range(m)] for _ in range(n)] # Set the starting point if grid[0][0] == '.': dp[0][0] = 1 else: return 0 # Fill the dp table for i in range(n): for j in range(m): if grid[i][j] == '.': if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[n - 1][m - 1]"},{"question":"def max_sum_submatrix(n: int, m: int, matrix: List[List[int]]) -> int: Calculate the sum of elements for all possible sub-matrices and return the maximum sum. >>> max_sum_submatrix(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> max_sum_submatrix(2, 2, [[0, 1], [2, 3]]) 6 >>> max_sum_submatrix(1, 1, [[50]]) 50 >>> max_sum_submatrix(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 136 >>> max_sum_submatrix(3, 3, [[1, 2, 0], [0, 1, 2], [2, 3, 4]]) 15","solution":"def max_sum_submatrix(n, m, matrix): # Create an auxiliary matrix to store sums of sub-matrices dp = [[0]*m for _ in range(n)] max_sum = float('-inf') for i in range(n): for j in range(m): dp[i][j] = matrix[i][j] if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] if i > 0 and j > 0: dp[i][j] -= dp[i-1][j-1] # Loop through to find the maximum sum sub-matrix for i1 in range(n): for j1 in range(m): for i2 in range(i1, n): for j2 in range(j1, m): sub_sum = dp[i2][j2] if i1 > 0: sub_sum -= dp[i1-1][j2] if j1 > 0: sub_sum -= dp[i2][j1-1] if i1 > 0 and j1 > 0: sub_sum += dp[i1-1][j1-1] max_sum = max(max_sum, sub_sum) return max_sum"},{"question":"def find_primes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n. >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def find_primes(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(n + 1) if sieve[num]]"},{"question":"def first_unique_integer(test_cases): For each test case, returns the first unique integer in the list of integers. If no unique integer is found, returns -1. >>> first_unique_integer([[4, 5, 1, 2, 5, 1, 4, 3], [1, 2, 2, 1, 3, 4, 3, 3], [7, 7, 7, 6, 6, 6, 5, 5, 5], [9]]) [2, 4, -1, 9] >>> first_unique_integer([[1, 2, 3, 4, 5], [6, 6, 7, 8, 9], [10, 10, 11, 11, 12]]) [1, 7, 12] pass def find_first_unique_integers(T, test_cases): return first_unique_integer(test_cases) def test_find_first_unique_integers(): assert find_first_unique_integers(4, [ [4, 5, 1, 2, 5, 1, 4, 3], [1, 2, 2, 1, 3, 4, 3, 3], [7, 7, 7, 6, 6, 6, 5, 5, 5], [9] ]) == [2, 4, -1, 9] assert find_first_unique_integers(3, [ [1, 2, 3, 4, 5], [6, 6, 7, 8, 9], [10, 10, 11, 11, 12] ]) == [1, 7, 12] assert find_first_unique_integers(2, [ [1, 1, 1, 1, 1], [100, 200, 300, 400, 500] ]) == [-1, 100] def test_first_unique_integer_single_case(): assert first_unique_integer([ [4, 5, 1, 2, 5, 1, 4, 3] ]) == [2] assert first_unique_integer([ [1, 2, 2, 1, 3, 4, 3, 3] ]) == [4] def test_first_unique_integer_no_unique(): assert first_unique_integer([ [7, 7, 7, 6, 6, 6, 5, 5, 5] ]) == [-1] assert first_unique_integer([ [8, 8, 8, 8, 8] ]) == [-1] def test_first_unique_integer_all_unique(): assert first_unique_integer([ [9, 10, 11, 12, 13] ]) == [9] assert first_unique_integer([ [20] ]) == [20] def test_first_unique_integer_large_inputs(): assert find_first_unique_integers(2, [ [i for i in range(1000)], [1]*999 + [2] ]) == [0, 2]","solution":"def first_unique_integer(test_cases): For each test case, returns the first unique integer in the list of integers. If no unique integer is found, returns -1. results = [] for case in test_cases: count = {} for num in case: if num in count: count[num] += 1 else: count[num] = 1 found = False for num in case: if count[num] == 1: results.append(num) found = True break if not found: results.append(-1) return results # Function to process the input and call the first_unique_integer function def find_first_unique_integers(T, test_cases): return first_unique_integer(test_cases)"},{"question":"def path_exists(grid: List[str]) -> str: Determine if there is a path from the top-left corner of the grid (0, 0) to the bottom-right corner of the grid (N-1, N-1) moving only on cells containing '1'. Args: grid (List[str]): A list of strings representing the grid. Returns: str: \\"YES\\" if such a path exists, and \\"NO\\" otherwise. Example: >>> path_exists([\\"110\\", \\"010\\", \\"011\\"]) \\"YES\\" >>> path_exists([\\"100\\", \\"010\\", \\"001\\"]) \\"NO\\"","solution":"def path_exists(grid): N = len(grid) if grid[0][0] == '0' or grid[N-1][N-1] == '0': return \\"NO\\" visited = [[False] * N for _ in range(N)] def dfs(x, y): if x < 0 or x >= N or y < 0 or y >= N or grid[x][y] == '0' or visited[x][y]: return False if x == N-1 and y == N-1: return True visited[x][y] = True if dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1): return True return False return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def conditional_sort(n: int, k: int, arr: List[int]) -> List[int]: Sorts arr such that all integers less than k come first, followed by all integers equal to k, followed by all integers greater than k. Parameters: n (int): The number of integers in the list. k (int): The key to partition the list around. arr (List[int]): The list of integers. Returns: List[int]: The sorted list as per the defined criteria. Examples: >>> conditional_sort(6, 3, [4, 3, 5, 2, 3, 1]) [2, 1, 3, 3, 4, 5] >>> conditional_sort(7, 5, [6, 2, 5, 9, 5, 2, 1]) [2, 2, 1, 5, 5, 6, 9] def sort_multiple_tests(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases to sort lists according to the defined criteria. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of tuples where each tuple contains: - n (int): The number of integers in the list. - k (int): The key to partition the list around. - arr (List[int]): The list of integers. Returns: List[str]: A list of strings, each string representing the sorted list for each test case. Examples: >>> sort_multiple_tests(2, [(6, 3, [4, 3, 5, 2, 3, 1]), (7, 5, [6, 2, 5, 9, 5, 2, 1])]) [\\"2 1 3 3 4 5\\", \\"2 2 1 5 5 6 9\\"]","solution":"def conditional_sort(n, k, arr): Sorts arr such that all integers less than k come first, followed by all integers equal to k, followed by all integers greater than k. less_than_k = [x for x in arr if x < k] equal_to_k = [x for x in arr if x == k] greater_than_k = [x for x in arr if x > k] return less_than_k + equal_to_k + greater_than_k def sort_multiple_tests(T, test_cases): results = [] for t in range(T): n, k, arr = test_cases[t] sorted_arr = conditional_sort(n, k, arr) results.append(\\" \\".join(map(str, sorted_arr))) return results"},{"question":"def can_allocate_meeting_rooms(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[str]: Determine if it's possible to allocate rooms such that no meetings overlap within the same room. >>> can_allocate_meeting_rooms([(3, [(0, 30), (5, 10), (15, 20)]), (2, [(7, 10), (2, 4)])]) [\\"No\\", \\"Yes\\"] >>> can_allocate_meeting_rooms([(1, [(0, 10)])]) [\\"Yes\\"] >>> can_allocate_meeting_rooms([(3, [(1, 2), (3, 4), (5, 6)])]) [\\"Yes\\"] >>> can_allocate_meeting_rooms([(3, [(1, 5), (2, 6), (3, 7)])]) [\\"No\\"] >>> can_allocate_meeting_rooms([(0, [])]) [\\"Yes\\"] >>> can_allocate_meeting_rooms([(2, [(0, 10), (0, 10)])]) [\\"No\\"]","solution":"def can_allocate_meeting_rooms(test_cases): results = [] for case in test_cases: n = case[0] meetings = case[1] # Sort meetings by start time, and then by end time. meetings.sort(key=lambda x: (x[0], x[1])) # Check for overlapping intervals overlap = False for i in range(1, n): if meetings[i][0] < meetings[i-1][1]: overlap = True break if overlap: results.append(\\"No\\") else: results.append(\\"Yes\\") return results"},{"question":"def isPossiblePalindrome(S: str) -> str: This function checks if it is possible to rearrange the characters of the given string S to form a palindrome. If it is possible, it returns \\"YES\\", otherwise \\"NO\\". A string can be rearranged to form a palindrome if at most one character appears an odd number of times. >>> isPossiblePalindrome(\\"aabb\\") == \\"YES\\" >>> isPossiblePalindrome(\\"abc\\") == \\"NO\\" >>> isPossiblePalindrome(\\"a\\") == \\"YES\\" >>> isPossiblePalindrome(\\"aa\\") == \\"YES\\" >>> isPossiblePalindrome(\\"aab\\") == \\"YES\\" >>> isPossiblePalindrome(\\"racecar\\") == \\"YES\\" >>> isPossiblePalindrome(\\"aabbccdde\\") == \\"YES\\" >>> isPossiblePalindrome(\\"aabbccdd\\") == \\"YES\\" >>> isPossiblePalindrome(\\"aabcddee\\") == \\"NO\\" >>> isPossiblePalindrome(\\"abcdee\\") == \\"NO\\"","solution":"def isPossiblePalindrome(S): This function checks if it is possible to rearrange the characters of the given string S to form a palindrome. If it is possible, it returns \\"YES\\", otherwise \\"NO\\". A string can be rearranged to form a palindrome if at most one character appears an odd number of times. :param S: str, the input string :return: str, 'YES' if the string can be rearranged to form a palindrome, otherwise 'NO' from collections import Counter # Count the frequency of each character in the string char_count = Counter(S) # Count how many characters have an odd frequency count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Palindrome condition if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def min_moves_to_capture_all_castles(N: int, M: int, roads: List[Tuple[int, int]]) -> int: Calculate the minimum number of moves needed to capture all castles starting from the most advantageous castle. >>> min_moves_to_capture_all_castles(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 2 >>> min_moves_to_capture_all_castles(3, 2, [(1, 2), (2, 3)]) 2 >>> min_moves_to_capture_all_castles(5, 6, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 1)]) 2 >>> min_moves_to_capture_all_castles(5, 0, []) 0 >>> min_moves_to_capture_all_castles(1, 0, []) 0 pass def parse_input(input_string: str) -> Tuple[int, int, List[Tuple[int, int]]]: Parse the input string to extract the number of castles, number of roads, and the list of roads. >>> parse_input(\\"4 4n1 2n2 3n3 4n4 1\\") (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) >>> parse_input(\\"3 2n1 2n2 3\\") (3, 2, [(1, 2), (2, 3)]) pass","solution":"from collections import deque, defaultdict def min_moves_to_capture_all_castles(N, M, roads): # Create an adjacency list for the graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) def bfs(start): visited = [False] * (N + 1) distance = [-1] * (N + 1) queue = deque([start]) visited[start] = True distance[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[node] + 1 queue.append(neighbor) return max(distance) max_distance = 0 for castle in range(1, N + 1): max_distance = max(max_distance, bfs(castle)) return max_distance def parse_input(input_string): lines = input_string.strip().split(\\"n\\") N, M = map(int, lines[0].split()) roads = [tuple(map(int, line.split())) for line in lines[1:]] return N, M, roads"},{"question":"def gcd(a, b): Calculates the Greatest Common Divisor (GCD) of two integers using the Euclidean algorithm. Prints each pair of values (A, B) at the start of each iteration of the loop until B equals 0. Returns the GCD of the two integers. >>> gcd(48, 18) 48 18 18 12 12 6 6 0 6 >>> gcd(56, 98) 56 98 98 56 56 42 42 14 14 0 14 >>> gcd(35, 10) 35 10 10 5 5 0 5 >>> gcd(101, 103) 101 103 103 101 101 2 2 1 1 0 1 >>> gcd(1000, 250) 1000 250 250 0 250","solution":"def gcd(a, b): Calculates the Greatest Common Divisor (GCD) of two integers using the Euclidean algorithm. Prints each pair of values (A, B) at the start of each iteration of the loop until B equals 0. Returns the GCD of the two integers. while b != 0: print(a, b) a, b = b, a % b print(a, 0) return a"},{"question":"def min_steps_to_reach(N, M, K, dangerous_buildings): Determine the minimum number of steps required to travel from (1, 1) to (N, M) in a grid with dangerous buildings. Args: - N (int): Number of rows in the grid. - M (int): Number of columns in the grid. - K (int): Number of dangerous buildings. - dangerous_buildings (List[Tuple[int, int]]): List of coordinates of dangerous buildings. Returns: - int: Minimum number of steps required or -1 if it is not possible to reach the destination. >>> min_steps_to_reach(3, 3, 1, [(2, 2)]) 4 >>> min_steps_to_reach(4, 4, 2, [(2, 2), (3, 3)]) 6 >>> min_steps_to_reach(3, 3, 3, [(1, 2), (2, 1), (2, 2)]) -1 >>> min_steps_to_reach(5, 5, 0, []) 8 >>> min_steps_to_reach(1, 1, 0, []) 0 # Implementation here def process_test_cases(T, test_cases): Process multiple test cases to determine minimum steps for each case. Args: - T (int): Number of test cases. - test_cases (List[Tuple[int, int, int, List[Tuple[int, int]]]]): List of test case parameters. Returns: - List[int]: List of results for each test case. >>> test_cases = [ ... (3, 3, 1, [(2, 2)]), # Expected 4 ... (4, 4, 2, [(2, 2), (3, 3)]) # Expected 6 ...] >>> process_test_cases(len(test_cases), test_cases) [4, 6] # Implementation here","solution":"from collections import deque def min_steps_to_reach(N, M, K, dangerous_buildings): # Create a grid and mark dangerous buildings grid = [[0]*M for _ in range(N)] for x, y in dangerous_buildings: grid[x-1][y-1] = -1 # Mark dangerous building as -1 # Directions for moving in the grid (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Initialize BFS queue = deque([(0, 0)]) grid[0][0] = 1 # Mark start as visited with step count 1 while queue: x, y = queue.popleft() if (x, y) == (N-1, M-1): return grid[x][y] - 1 # Subtract the initial step, calculate total steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == 0: grid[nx][ny] = grid[x][y] + 1 queue.append((nx, ny)) return -1 # If no path found def process_test_cases(T, test_cases): results = [] for N, M, K, dangerous_buildings in test_cases: result = min_steps_to_reach(N, M, K, dangerous_buildings) results.append(result) return results # This function wraps the entire process from input to output def main(): T = int(input()) test_cases = [] for _ in range(T): N, M = map(int, input().split()) K = int(input()) dangerous_buildings = [tuple(map(int, input().split())) for _ in range(K)] test_cases.append((N, M, K, dangerous_buildings)) results = process_test_cases(T, test_cases) for result in results: print(result) # Example of how the main function operates. Uncomment to run in a local environment. # if __name__ == \\"__main__\\": # main()"},{"question":"def min_moves_to_target(arr: List[int], target: int) -> int: Returns the minimum number of moves required to make all elements of the array equal to the target value. >>> min_moves_to_target([1, 2, 3], 2) 2 >>> min_moves_to_target([4, 4, 4], 4) 0 >>> min_moves_to_target([], 1) 0 >>> min_moves_to_target([1, 1, 1], 1) 0 >>> min_moves_to_target([7, 8, 9], 7) 2 >>> min_moves_to_target([11, 13, 17, 19], 11) 3 >>> min_moves_to_target([5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8], 8) 8","solution":"def min_moves_to_target(arr, target): Returns the minimum number of moves required to make all elements of the array equal to the target value. :param arr: List of integers :param target: The target value to make all elements of the array equal to :return: Minimum number of moves if not arr: return 0 moves = 0 for num in arr: if num != target: moves += 1 return moves"},{"question":"def minimal_operations(t: int, strings: List[str]) -> List[int]: Returns the minimal number of operations required to make each given string contain at most one contiguous segment of 'a's and at most one contiguous segment of 'b's. :param t: Number of test cases :param strings: List of test case strings consisting of 'a' and 'b' :return: List of minimal number of operations for each test case from solution import minimal_operations def test_minimal_operations(): assert minimal_operations(3, [\\"abba\\", \\"abab\\", \\"aaa\\"]) == [1, 2, 0] assert minimal_operations(1, [\\"aaaabbbb\\"]) == [1] assert minimal_operations(2, [\\"a\\", \\"b\\"]) == [0, 0] assert minimal_operations(2, [\\"aaabbb\\", \\"bbbaaa\\"]) == [1, 1] assert minimal_operations(1, [\\"abababab\\"]) == [4] def test_large_input(): assert minimal_operations(1, [\\"a\\" * 500 + \\"b\\" * 500]) == [1] assert minimal_operations(1, [\\"ab\\" * 500]) == [500]","solution":"def minimal_operations(t, strings): Returns the minimal number of operations required to make each given string contain at most one contiguous segment of 'a's and at most one contiguous segment of 'b's. :param t: Number of test cases :param strings: List of test case strings consisting of 'a' and 'b' :return: List of minimal number of operations for each test case results = [] for s in strings: # Count the number of transitions between 'a' and 'b' transitions = sum(1 for i in range(1, len(s)) if s[i] != s[i-1]) # Minimal operations needed is the number of transitions divided by 2 (rounding up if necessary) operations = (transitions + 1) // 2 results.append(operations) return results"},{"question":"def find_substring(s: str, words: List[str]) -> List[int]: Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. >>> find_substring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == [0, 9] >>> find_substring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) == []","solution":"def find_substring(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) concat_len = word_len * len(words) word_count = Counter(words) result = [] for i in range(len(s) - concat_len + 1): seen_words = [] for j in range(i, i + concat_len, word_len): current_word = s[j:j + word_len] if current_word in word_count: seen_words.append(current_word) else: break if Counter(seen_words) == word_count: result.append(i) return result"},{"question":"def can_partition_into_pairs(n: int, k: int, sequence: List[int]) -> str: Determine whether it is possible to partition the sequence into pairs such that each pair sums up to a given target value k. >>> can_partition_into_pairs(4, 7, [1, 6, 2, 5]) \\"possible\\" >>> can_partition_into_pairs(4, 8, [1, 6, 2, 5]) \\"impossible\\" >>> can_partition_into_pairs(6, 10, [5, 5, 5, 5, 5, 5]) \\"possible\\"","solution":"def can_partition_into_pairs(n, k, sequence): if n % 2 != 0: return \\"impossible\\" count_map = {} for num in sequence: if num in count_map: count_map[num] += 1 else: count_map[num] = 1 for num in sequence: complement = k - num if count_map[num] == 0: continue if count_map.get(complement, 0) == 0: return \\"impossible\\" count_map[num] -= 1 count_map[complement] -= 1 return \\"possible\\""},{"question":"def minimum_highway_length(n: int, highways: List[Tuple[int, int, int]]) -> int: Determine the minimum length of new highways required to ensure all towns are connected. >>> minimum_highway_length(4, [(1, 2, 3), (3, 4, 5)]) == 8 >>> minimum_highway_length(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) == 0","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) # Path compression return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimum_highway_length(n, highways): parent = [i for i in range(n)] rank = [0] * n highways.sort(key=lambda x: x[2]) minimum_length = 0 for u, v, w in highways: if find(parent, u - 1) != find(parent, v - 1): union(parent, rank, u - 1, v - 1) minimum_length += w connected_components = len(set(find(parent, i) for i in range(n))) if connected_components == 1: return 0 else: return minimum_length def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) highways = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) highways.append((u, v, w)) index += 3 print(minimum_highway_length(n, highways)) # Sample test execution # Note: In real scenarios, the input would come from stdin or file. if __name__ == \\"__main__\\": main()"},{"question":"def longest_substring(s: str) -> str: Returns the longest contiguous substring in which all characters are the same. If there are multiple substrings with the same length, return the first one. >>> longest_substring(\\"aaabbccddddde\\") == \\"ddddd\\" >>> longest_substring(\\"a\\") == \\"a\\" >>> longest_substring(\\"abc\\") == \\"a\\" >>> longest_substring(\\"bbbaaabb\\") == \\"bbb\\"","solution":"def longest_substring(s): Returns the longest contiguous substring of \`s\` that consists of the same character. If multiple substrings have the same length, the first one is returned. if not s: return \\"\\" max_length = 1 current_length = 1 max_char = s[0] current_char = s[0] for i in range(1, len(s)): if s[i] == current_char: current_length += 1 else: if current_length > max_length: max_length = current_length max_char = current_char current_char = s[i] current_length = 1 # Check the last character sequence if current_length > max_length: max_length = current_length max_char = current_char return max_char * max_length"},{"question":"def fibonacci_sum_decomposition(N: int) -> List[int]: Decompose the integer N into the sum of distinct Fibonacci numbers. Parameters: N (int): The input integer (1 ≤ N ≤ 10^18) Returns: list of int: A list of distinct Fibonacci numbers that sum up to N. >>> fibonacci_sum_decomposition(10) [1, 2, 3, 5] >>> fibonacci_sum_decomposition(20) [1, 2, 5, 12] >>> fibonacci_sum_decomposition(19) [3, 5, 11]","solution":"def fibonacci_sum_decomposition(N): Decompose the integer N into the sum of distinct Fibonacci numbers. Parameters: N (int): The input integer (1 ≤ N ≤ 10^18) Returns: list of int: A list of distinct Fibonacci numbers that sum up to N. if N == 0: return [] # Generate Fibonacci numbers up to N fibs = [1, 2] while fibs[-1] <= N: fibs.append(fibs[-1] + fibs[-2]) # Since the sequence is dynamic, we remove the last element which exceeds N if fibs[-1] > N: fibs.pop() result = [] # Traverse the Fibonacci sequence in reverse order to achieve a greedy solution while N > 0: for fib in reversed(fibs): if fib <= N: result.append(fib) N -= fib break # Output the result in non-decreasing order result.sort() return result"},{"question":"from typing import List def minimum_hours_to_cover_forest(N: int, M: int, grid: List[List[str]]) -> int: Find the minimum number of hours required to plant the new type of tree so that it spreads to cover all the empty cells in the forest. >>> minimum_hours_to_cover_forest(4, 5, [ ... [\\"T\\", \\".\\", \\"T\\", \\".\\", \\".\\"], ... [\\".\\", \\".\\", \\"T\\", \\".\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"T\\", \\".\\", \\".\\", \\"T\\"] ... ]) 2 >>> minimum_hours_to_cover_forest(3, 3, [ ... [\\"T\\", \\"T\\", \\"T\\"], ... [\\"T\\", \\".\\", \\"T\\"], ... [\\"T\\", \\"T\\", \\"T\\"] ... ]) 1 >>> minimum_hours_to_cover_forest(1, 1, [ ... [\\".\\"] ... ]) 0 >>> minimum_hours_to_cover_forest(1, 1, [ ... [\\"T\\"] ... ]) 0 >>> minimum_hours_to_cover_forest(2, 2, [ ... [\\"T\\", \\".\\"], ... [\\".\\", \\".\\"] ... ]) 1","solution":"from collections import deque def minimum_hours_to_cover_forest(N, M, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] queue = deque() empty_cells = 0 for r in range(N): for c in range(M): if grid[r][c] == 'T': queue.append((r, c)) elif grid[r][c] == '.': empty_cells += 1 if empty_cells == 0: return 0 hours = 0 while queue and empty_cells > 0: hours += 1 for _ in range(len(queue)): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == '.': grid[nr][nc] = 'T' empty_cells -= 1 queue.append((nr, nc)) return hours"},{"question":"class FenwickTree: def __init__(self, size): Initialize the Fenwick Tree with a given size. def update(self, index: int, delta: int): Update the Fenwick Tree at a specific index by a given delta. def query(self, index: int) -> int: Query the sum from the Fenwick Tree from index 1 to a given index. def process_operations(N: int, Q: int, sequence: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Given a sequence of N positive integers and Q operations, perform the operations on the sequence efficiently. - 1 x y: Update the value at index x to y. - 2 l r: Query the sum of values from index l to index r. Example: >>> process_operations(5, 4, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 8), (2, 2, 4), (2, 1, 5)]) [6, 14, 20] >>> process_operations(3, 2, [10, 20, 30], [(1, 2, 25), (2, 1, 3)]) [65] def test_fenwick_tree_operations(): N = 5 Q = 4 sequence = [1, 2, 3, 4, 5] operations = [(2, 1, 3), (1, 3, 8), (2, 2, 4), (2, 1, 5)] expected = [6, 14, 20] assert process_operations(N, Q, sequence, operations) == expected def test_single_update_operation(): N = 3 Q = 2 sequence = [10, 20, 30] operations = [(1, 2, 25), (2, 1, 3)] expected = [65] assert process_operations(N, Q, sequence, operations) == expected def test_multiple_operations(): N = 4 Q = 5 sequence = [4, 6, 8, 10] operations = [(2, 1, 4), (2, 2, 3), (1, 1, 5), (2, 1, 2), (2, 1, 4)] expected = [28, 14, 11, 29] assert process_operations(N, Q, sequence, operations) == expected def test_no_queries(): N = 4 Q = 3 sequence = [4, 6, 8, 10] operations = [(1, 1, 5), (1, 2, 7), (1, 3, 9)] expected = [] assert process_operations(N, Q, sequence, operations) == expected","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def process_operations(N, Q, sequence, operations): fenwick_tree = FenwickTree(N) for idx, value in enumerate(sequence): fenwick_tree.update(idx + 1, value) result = [] for operation in operations: if operation[0] == 1: index, new_value = operation[1], operation[2] current_value = sequence[index - 1] delta = new_value - current_value sequence[index - 1] = new_value fenwick_tree.update(index, delta) elif operation[0] == 2: l, r = operation[1], operation[2] sum_of_range = fenwick_tree.query(r) - fenwick_tree.query(l - 1) result.append(sum_of_range) return result"},{"question":"def count_special_subsequences(N: int, X: int, A: List[int]) -> int: Returns the number of special contiguous subsequences whose sum is equal to X. >>> count_special_subsequences(5, 5, [1, 2, 3, 4, 5]) 2 >>> count_special_subsequences(4, 3, [1, 2, 1, 2]) 3 >>> count_special_subsequences(6, 10, [10, 10, 10, 10, 10, 10]) 6","solution":"def count_special_subsequences(N, X, A): Returns the number of special contiguous subsequences whose sum is equal to X. from collections import defaultdict prefix_sums = defaultdict(int) prefix_sums[0] = 1 count = 0 current_sum = 0 for num in A: current_sum += num if current_sum - X in prefix_sums: count += prefix_sums[current_sum - X] prefix_sums[current_sum] += 1 return count"},{"question":"class BuildingSimulation: def __init__(self, n, m): self.grid = [[0 for _ in range(m)] for _ in range(n)] def add(self, x, y, h): Add blocks to the position (x, y) at a height starting from the current height up to (current height + h). pass def remove(self, x, y, h): Remove blocks from the position (x, y) down to a height (current height - h). If (current height - h) is less than zero, just set the height to zero. pass def height(self, x, y): Output the current height of blocks at position (x, y). pass def total_height(self): Output the total height of all blocks in the entire building. pass def process_commands(n, m, k, commands): Simulate the process of constructing buildings with the given commands. >>> process_commands(3, 3, 5, [\\"add 1 1 1 5\\", \\"add 2 2 2 3\\", \\"height 1 1\\", \\"remove 1 1 1 2\\", \\"total_height\\"]) [5, 6] >>> process_commands(2, 2, 4, [\\"add 0 0 0 4\\", \\"add 1 1 1 2\\", \\"remove 0 0 0 4\\", \\"total_height\\"]) [2] Using the given dimensions n, m, and number of operations k, process each command in the list of commands. simulation = BuildingSimulation(n, m) results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"add\\": x, y, z, h = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) simulation.add(x, y, h) elif action == \\"remove\\": x, y, z, h = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) simulation.remove(x, y, h) elif action == \\"height\\": x, y = int(parts[1]), int(parts[2]) results.append(simulation.height(x, y)) elif action == \\"total_height\\": results.append(simulation.total_height()) return results","solution":"class BuildingSimulation: def __init__(self, n, m): self.n = n self.m = m self.grid = [[0 for _ in range(m)] for _ in range(n)] def add(self, x, y, h): self.grid[x][y] += h def remove(self, x, y, h): self.grid[x][y] = max(0, self.grid[x][y] - h) def height(self, x, y): return self.grid[x][y] def total_height(self): return sum(sum(row) for row in self.grid) def process_commands(n, m, k, commands): simulation = BuildingSimulation(n, m) results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"add\\": x, y, z, h = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) simulation.add(x, y, h) elif action == \\"remove\\": x, y, z, h = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) simulation.remove(x, y, h) elif action == \\"height\\": x, y = int(parts[1]), int(parts[2]) results.append(simulation.height(x, y)) elif action == \\"total_height\\": results.append(simulation.total_height()) return results"},{"question":"def rank_participants(scores: List[int]) -> List[int]: Ranks the participants based on their scores. Participants with the same score will receive the same rank. The ranking is such that the highest score gets the rank 1, the second highest gets rank 2, and so forth. Args: scores (List[int]): A list of integers representing the scores of participants. Returns: List[int]: A list of integers representing the ranks of the participants in the order of their input scores. >>> rank_participants([100, 200, 100, 300, 200]) [4, 2, 4, 1, 2] >>> rank_participants([50, 50, 50]) [1, 1, 1]","solution":"def rank_participants(scores): This function ranks the participants based on their scores. Participants with the same score will receive the same rank. sorted_scores = sorted(enumerate(scores), key=lambda x: x[1], reverse=True) rank = [0] * len(scores) current_rank = 1 rank[sorted_scores[0][0]] = current_rank for i in range(1, len(scores)): if sorted_scores[i][1] == sorted_scores[i - 1][1]: rank[sorted_scores[i][0]] = current_rank else: current_rank = i + 1 rank[sorted_scores[i][0]] = current_rank return rank # Test the function with the example input and output scores = [100, 200, 100, 300, 200] print(rank_participants(scores)) # Should print [4, 2, 4, 1, 2]"},{"question":"def is_prime(num: int) -> bool: Helper function to determine if a number is a prime. # Implementation here def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers below the given positive integer n. Examples: >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(2) 0 >>> sum_of_primes(1) 0 # Implementation here","solution":"def is_prime(num): Helper function to determine if a number is a prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_of_primes(n): Returns the sum of all prime numbers below the given positive integer n. sum_primes = 0 for i in range(2, n): if is_prime(i): sum_primes += i return sum_primes"},{"question":"def can_distribute_tokens(m: int, aA: int, aB: int, bA: int, bB: int): Determine if Alice and Bob can distribute exactly \`m\` tokens using the tokens they have. Args: m (int): The total number of tokens to be distributed. aA (int): The number of Type A tokens Alice has. aB (int): The number of Type B tokens Alice has. bA (int): The number of Type A tokens Bob has. bB (int): The number of Type B tokens Bob has. Returns: str, Tuple[int, int, int, int]: \\"YES\\" and four non-negative integers \`x\`, \`y\`, \`p\`, and \`q\` if it's possible to distribute exactly \`m\` tokens, otherwise \\"NO\\". >>> can_distribute_tokens(10, 5, 3, 4, 6) ('YES', (3, 2, 2, 3)) >>> can_distribute_tokens(8, 2, 2, 2, 1) ('NO', None) from solution import can_distribute_tokens def test_example_case1(): result, tokens = can_distribute_tokens(10, 5, 3, 4, 6) assert result == \\"YES\\" x, y, p, q = tokens assert x + y + p + q == 10 def test_example_case2(): result, _ = can_distribute_tokens(8, 2, 2, 2, 1) assert result == \\"NO\\" def test_total_tokens_less_than_m(): result, _ = can_distribute_tokens(10, 2, 1, 2, 1) assert result == \\"NO\\" def test_excess_tokens(): result, tokens = can_distribute_tokens(10, 6, 6, 6, 6) assert result == \\"YES\\" x, y, p, q = tokens assert x + y + p + q == 10 def test_all_from_alice(): result, tokens = can_distribute_tokens(5, 5, 5, 1, 1) assert result == \\"YES\\" x, y, p, q = tokens assert x + y + p + q == 5 def test_all_from_bob(): result, tokens = can_distribute_tokens(5, 1, 1, 5, 5) assert result == \\"YES\\" x, y, p, q = tokens assert x + y + p + q == 5","solution":"def can_distribute_tokens(m, aA, aB, bA, bB): total_tokens = aA + aB + bA + bB if total_tokens < m: return \\"NO\\", None for x in range(max(0, m - aB - bA - bB), min(aA, m) + 1): for y in range(max(0, m - x - bA - bB), min(aB, m - x) + 1): remaining = m - x - y if remaining >= 0 and remaining <= bA + bB: for p in range(max(0, remaining - bB), min(bA, remaining) + 1): q = remaining - p if q >= 0 and q <= bB: return \\"YES\\", (x, y, p, q) return \\"NO\\", None"},{"question":"import re def is_palindrome(s: str) -> bool: Returns True if the given string is a palindrome, ignoring case, spaces, and punctuation. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"Able was I ere I saw Elba\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"!!!@@@#\\") True >>> is_palindrome(\\" \\") True","solution":"import re def is_palindrome(s): Returns True if the given string is a palindrome, ignoring case, spaces, and punctuation. # Use regex to remove all non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[W_]', '', s).lower() # Check if cleaned string is the same forwards and backwards return cleaned == cleaned[::-1]"},{"question":"def starting_times(n): Returns the starting times for n teams such that the sum of the starting times is minimized and each starting time is a distinct positive integer. >>> starting_times(1) [1] >>> starting_times(3) [1, 2, 3] >>> starting_times(5) [1, 2, 3, 4, 5] >>> starting_times(7) [1, 2, 3, 4, 5, 6, 7]","solution":"def starting_times(n): Returns the starting times for n teams such that the sum of the starting times is minimized and each starting time is a distinct positive integer. return list(range(1, n + 1))"},{"question":"def track_prices_and_queries(n: int, m: int, initial_prices: List[int], operations: List[List[int]]) -> List[int]: Tracks prices of products over days and handles queries to give total cost. :param n: Number of products :param m: Number of days/operations :param initial_prices: List of initial prices of products :param operations: List of operations (price updates or queries) :return: List of results for each query >>> track_prices_and_queries(5, 3, [1, 2, 3, 4, 5], [[2], [1, 3, 10], [2]]) [15, 22] >>> track_prices_and_queries(4, 5, [5, 10, 15, 20], [[2], [1, 1, 100], [2], [1, 4, 50], [2]]) [50, 145, 175]","solution":"def track_prices_and_queries(n, m, initial_prices, operations): Tracks prices of products over days and handles queries to give total cost. :param n: Number of products :param m: Number of days/operations :param initial_prices: List of initial prices of products :param operations: List of operations (price updates or queries) :return: List of results for each query prices = initial_prices[:] total_cost = sum(prices) results = [] for operation in operations: if operation[0] == 1: # Update operation: 1 p v p, v = operation[1], operation[2] total_cost += v - prices[p - 1] prices[p - 1] = v elif operation[0] == 2: # Query operation: 2 results.append(total_cost) return results # Example usage n = 5 m = 3 initial_prices = [1, 2, 3, 4, 5] operations = [ [2], [1, 3, 10], [2] ] print(track_prices_and_queries(n, m, initial_prices, operations)) # Output: [15, 22]"},{"question":"def allocate_budget(T, test_cases): This function takes the number of test cases and a list of test cases, each containing the number of employees and the total budget. It returns a list of tuples where each tuple contains the amount of money each swag bag should be worth in dollars and the total amount of money kept in the reserve fund. >>> allocate_budget(3, [(10, 100), (7, 75), (15, 200)]) [(10, 0), (10, 5), (13, 5)] >>> allocate_budget(1, [(1, 1)]) [(1, 0)] >>> allocate_budget(2, [(2, 5), (3, 14)]) [(2, 1), (4, 2)] >>> allocate_budget(1, [(1, 1000000000)]) [(1000000000, 0)] >>> allocate_budget(1, [(1000000, 1)]) [(0, 1)] >>> allocate_budget(1, [(1000000, 999999)]) [(0, 999999)]","solution":"def allocate_budget(T, test_cases): results = [] for i in range(T): N, B = test_cases[i] swag_value = B // N reserve_fund = B % N results.append((swag_value, reserve_fund)) return results"},{"question":"def calculate_total_salary(company_structure): Recursively calculates the total salary of all employees in the company structure. :param company_structure: dict, The nested dictionary representing the company structure :return: int, Total salary of all employees >>> company = { >>> 'HR': { >>> 'recruitment': { >>> 'employees': [ >>> {'name': 'Alice', 'salary': 50000}, >>> {'name': 'Bob', 'salary': 60000} >>> ] >>> }, >>> 'training': { >>> 'employees': [ >>> {'name': 'Charlie', 'salary': 55000} >>> ] >>> } >>> }, >>> 'IT': { >>> 'development': { >>> 'backend': { >>> 'employees': [ >>> {'name': 'Dave', 'salary': 70000}, >>> {'name': 'Eve', 'salary': 80000} >>> ] >>> }, >>> 'frontend': { >>> 'employees': [ >>> {'name': 'Frank', 'salary': 75000} >>> ] >>> } >>> }, >>> 'support': { >>> 'employees': [ >>> {'name': 'Grace', 'salary': 50000} >>> ] >>> } >>> } >>> } >>> calculate_total_salary(company) >>> 440000 >>> empty_company = {} >>> calculate_total_salary(empty_company) >>> 0 >>> company = { >>> 'HR': {}, >>> 'IT': {} >>> } >>> calculate_total_salary(company) >>> 0 >>> company = { >>> 'HR': { >>> 'employees': [ >>> {'name': 'Alice', 'salary': 50000} >>> ] >>> } >>> } >>> calculate_total_salary(company) >>> 50000","solution":"def calculate_total_salary(company_structure): Recursively calculates the total salary of all employees in the company structure. :param company_structure: dict, The nested dictionary representing the company structure :return: int, Total salary of all employees def helper(department): total = 0 for key, value in department.items(): if key == 'employees': for employee in value: total += employee['salary'] elif isinstance(value, dict): total += helper(value) return total return helper(company_structure)"},{"question":"def sequence_operations(t: int, test_cases: List[Tuple[int, int]]) -> List[Tuple[int, str]]: Determine the minimum number of operations required to transform \`x\` into \`y\` and output one such sequence of operations. The input contains multiple test cases. Each test case contains two integers \`x\` and \`y\` (1 <= x, y <= 10^9). The output for each test case consists of: - The minimum number of operations required. - The sequence of operations (each operation separated by a space). Use '+' for adding 1 and '-' for subtracting 1. >>> sequence_operations(1, [(5, 8)]) [(3, '+ + +')] >>> sequence_operations(1, [(10, 7)]) [(3, '- - -')] >>> sequence_operations(1, [(3, 3)]) [(0, '')] >>> sequence_operations(2, [(5, 8), (10, 7)]) [(3, '+ + +'), (3, '- - -')] >>> sequence_operations(1, [(999999998, 1000000000)]) [(2, '+ +')]","solution":"def sequence_operations(t, test_cases): results = [] for x, y in test_cases: operations = abs(y - x) if x < y: op_sequence = '+ ' * operations elif x > y: op_sequence = '- ' * operations else: op_sequence = '' results.append((operations, op_sequence.strip())) return results"},{"question":"def can_form_word(magazine: str, word: str) -> bool: Check if a word can be formed using characters from a given magazine string. Args: magazine (str): The magazine string to use. word (str): The word to form. Returns: bool: True if the word can be formed, False otherwise. Examples: >>> can_form_word(\\"The quick brown fox jumps over the lazy dog\\", \\"lazy\\") True >>> can_form_word(\\"Hello World\\", \\"worm\\") False","solution":"def can_form_word(magazine: str, word: str) -> bool: from collections import Counter magazine = magazine.lower() word = word.lower() magazine_counter = Counter(magazine) word_counter = Counter(word) for char, count in word_counter.items(): if magazine_counter[char] < count: return False return True"},{"question":"def find_unsorted_subarray(nums): Given an integer array nums, find one continuous subarray that if sorted in ascending order, the whole array will be sorted in ascending order. Returns the length of the shortest such subarray. >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) 5 >>> find_unsorted_subarray([1, 2, 3, 4]) 0 >>> find_unsorted_subarray([1, 3, 2, 2, 2]) 4 pass","solution":"def find_unsorted_subarray(nums): Finds the length of the shortest subarray that, if sorted, results in the entire array being sorted in ascending order. n = len(nums) start, end = -1, -1 max_seen, min_seen = float('-inf'), float('inf') for i in range(n): max_seen = max(max_seen, nums[i]) if nums[i] < max_seen: end = i for i in range(n-1, -1, -1): min_seen = min(min_seen, nums[i]) if nums[i] > min_seen: start = i if start == -1 and end == -1: return 0 return end - start + 1"},{"question":"def find_single_number(arr: List[int]) -> int: Finds the single number in the array where every other number appears twice. Parameters: arr (list of int): The input array of integers. Returns: int: The single integer that appears only once in the array. >>> find_single_number([4, 3, 2, 4, 1, 3, 2]) == 1 >>> find_single_number([7, 9, 7, 1, 5, 1, 5]) == 9 >>> find_single_number([10]) == 10 >>> large_array = list(range(1, 100001)) + list(range(1, 100000)) # includes 100000 and each number up to 99999 twice >>> find_single_number(large_array) == 100000 >>> find_single_number([2, 1, 2, 1, 3]) == 3","solution":"def find_single_number(arr): Finds the single number in the array where every other number appears twice. Parameters: arr (list of int): The input array of integers. Returns: int: The single integer that appears only once in the array. single_num = 0 for num in arr: single_num ^= num return single_num"},{"question":"def can_form_string(t: int, test_cases: List[Tuple[str, int, List[str]]]) -> List[str]: You have a string consisting of lowercase Latin letters and the question is whether you can obtain this string by concatenating some (not necessarily different) words from a given dictionary in some order. A word from the dictionary can be used more than once. Args: t (int): The number of test cases. test_cases (List[Tuple[str, int, List[str]]]): List of tuples where each tuple contains: - A string s to be checked. - An integer n indicating the size of the dictionary. - A list of n strings containing the words in the dictionary. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_form_string(3, [ ... (\\"applepenapple\\", 3, [\\"apple\\", \\"pen\\", \\"applepen\\"]), ... (\\"catsandog\\", 5, [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]), ... (\\"pineapplepenapple\\", 4, [\\"apple\\", \\"pen\\", \\"pine\\", \\"pineapple\\"]) ... ]) ['YES', 'NO', 'YES']","solution":"def can_form_string(t, test_cases): results = [] for i in range(t): s, n, words = test_cases[i] word_set = set(words) dp = [False] * (len(s) + 1) dp[0] = True for j in range(1, len(s) + 1): for k in range(j): if dp[k] and s[k:j] in word_set: dp[j] = True break results.append(\\"YES\\" if dp[len(s)] else \\"NO\\") return results"},{"question":"def are_all_colonies_reachable(N: int, M: int, S: int, corridors: List[Tuple[int, int]]) -> str: Determine whether all colonies are reachable from the starting colony \`S\` Args: N : int : Number of colonies M : int : Number of corridors S : int : Starting colony corridors : List[Tuple[int, int]] : List of corridors connecting colonies Returns: str : \\"Yes\\" if all colonies are reachable from the starting colony \`S\`, \\"No\\" otherwise. Examples: >>> are_all_colonies_reachable(6, 5, 1, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) \\"Yes\\" >>> are_all_colonies_reachable(6, 4, 1, [(1, 2), (2, 3), (4, 5), (5, 6)]) \\"No\\"","solution":"def are_all_colonies_reachable(N, M, S, corridors): from collections import defaultdict, deque graph = defaultdict(list) for A, B in corridors: graph[A].append(B) graph[B].append(A) visited = set() queue = deque([S]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return \\"Yes\\" if len(visited) == N else \\"No\\""},{"question":"def find_books_by_tag(t: int, data: List[str]) -> List[str]: Given the number of test cases and a list of test case data, return the list of books that match the queried tags. Each book has a unique name and a single unique tag. If no books are found for a queried tag, return \\"No books found.\\" >>> find_books_by_tag(1, [\\"5\\", \\"MobyDick Fiction\\", \\"Hamlet Drama\\", \\"OfMiceAndMen Fiction\\", \\"Dune SciFi\\", \\"Frankenstein Horror\\", \\"3\\", \\"Drama\\", \\"Fiction\\", \\"Fantasy\\"]) [\\"Hamlet\\", \\"MobyDick,OfMiceAndMen\\", \\"No books found.\\"] >>> find_books_by_tag(1, [\\"2\\", \\"BookOne GenreA\\", \\"BookTwo GenreB\\", \\"1\\", \\"NonExistentGenre\\"]) [\\"No books found.\\"] >>> find_books_by_tag(2, [\\"3\\", \\"BookOne GenreA\\", \\"BookTwo GenreB\\", \\"BookThree GenreA\\", \\"2\\", \\"GenreA\\", \\"GenreB\\", \\"2\\", \\"SingleBook GenreX\\", \\"OnlyOne GenreZ\\", \\"1\\", \\"GenreX\\"]) [\\"BookOne,BookThree\\", \\"BookTwo\\", \\"SingleBook\\"]","solution":"def find_books_by_tag(t, data): Given the number of test cases and a list of test case data, return the list of books that match the queried tags. result = [] index = 0 for _ in range(t): n = int(data[index]) index += 1 book_dict = {} for _ in range(n): book_entry = data[index].split() book_name = book_entry[0] book_tag = book_entry[1] if book_tag in book_dict: book_dict[book_tag].append(book_name) else: book_dict[book_tag] = [book_name] index += 1 q = int(data[index]) index += 1 for _ in range(q): query_tag = data[index] index += 1 if query_tag in book_dict: result.append(\\",\\".join(sorted(book_dict[query_tag]))) else: result.append(\\"No books found.\\") return result"},{"question":"def lengthOfLongestSubstring(s: str) -> int: Find the length of the longest substring without repeating characters. >>> lengthOfLongestSubstring(\\"abcabcbb\\") 3 >>> lengthOfLongestSubstring(\\"bbbbb\\") 1 >>> lengthOfLongestSubstring(\\"pwwkew\\") 3","solution":"def lengthOfLongestSubstring(s): This function returns the length of the longest substring without repeating characters. char_set = set() left = 0 # start of the sliding window max_length = 0 for right in range(len(s)): # If character is in the set, move the left pointer while s[right] in char_set: char_set.remove(s[left]) left += 1 # Add the current character to the set char_set.add(s[right]) # Update the maximum length max_length = max(max_length, right - left + 1) return max_length"},{"question":"def min_water_level_difference(N: int, K: int, A: List[int]) -> int: Determine the minimum possible difference between the maximum and minimum water levels in the tanks after performing at most \`K\` operations. >>> min_water_level_difference(5, 10, [1, 5, 7, 10, 12]) 7 >>> min_water_level_difference(3, 0, [5, 7, 9]) 4 >>> min_water_level_difference(1, 10, [5]) 0 >>> min_water_level_difference(3, 10, [5, 5, 5]) 0 >>> min_water_level_difference(5, 3, [1, 5, 7, 10, 12]) 8 >>> min_water_level_difference(3, 1000, [5, 8, 12]) 0","solution":"def min_water_level_difference(N, K, A): A.sort() min_diff = A[-1] - A[0] for i in range(N): if K == 0: break max_operation = min(K, A[-1] - A[i]) K -= max_operation A[i] += max_operation A.sort() return A[-1] - A[0]"},{"question":"def unique_characters_count(input_str: str) -> dict: This function takes a string consisting of only uppercase and lowercase alphabets and returns a dictionary with the counts of the occurrences of each character. The function is case-sensitive. Args: input_str (str): The input string containing only uppercase and lowercase alphabets. Returns: dict: A dictionary with characters as keys and their counts as values. >>> unique_characters_count(\\"abc\\") {'a': 1, 'b': 1, 'c': 1} >>> unique_characters_count(\\"Programming\\") {'P': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> unique_characters_count(\\"AaBbCc\\") {'A': 1, 'a': 1, 'B': 1, 'b': 1, 'C': 1, 'c': 1} # Complete the function implementation","solution":"def unique_characters_count(input_str: str) -> dict: This function takes a string consisting of only uppercase and lowercase alphabets and returns a dictionary with the counts of the occurrences of each character. The function is case-sensitive. Args: input_str (str): The input string containing only uppercase and lowercase alphabets. Returns: dict: A dictionary with characters as keys and their counts as values. character_counts = {} for char in input_str: if char in character_counts: character_counts[char] += 1 else: character_counts[char] = 1 return character_counts"},{"question":"def min_removals_to_make_simple(arr): Returns the minimum number of elements to remove from the array to make it simple. >>> min_removals_to_make_simple([1, 2, 2, 3, 4]) == 1 >>> min_removals_to_make_simple([5, 5, 5, 5, 5, 5]) == 5 >>> min_removals_to_make_simple([1, 2, 3, 4]) == 0 >>> min_removals_to_make_simple([1, 1, 1, 2, 2, 3]) == 3 >>> min_removals_to_make_simple([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0 >>> min_removals_to_make_simple([1, 1, 2, 2, 3, 3, 3]) == 4 def process_test_cases(test_cases): Processes multiple test cases. Each test case is a tuple (n, arr). >>> process_test_cases([(5, [1, 2, 2, 3, 4]), (6, [5, 5, 5, 5, 5, 5]), (4, [1, 2, 3, 4])]) == [1, 5, 0] >>> process_test_cases([(6, [1, 1, 1, 2, 2, 3]), (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), (7, [1, 1, 2, 2, 3, 3, 3])]) == [3, 0, 4]","solution":"def min_removals_to_make_simple(arr): Returns the minimum number of elements to remove from the array to make it simple. seen = set() duplicates_count = 0 for num in arr: if num in seen: duplicates_count += 1 else: seen.add(num) return duplicates_count def process_test_cases(test_cases): Processes multiple test cases. Each test case is a tuple (n, arr). results = [] for n, arr in test_cases: results.append(min_removals_to_make_simple(arr)) return results"},{"question":"def shortest_unsorted_subarray_length(n: int, A: List[int]) -> int: Returns the length of the shortest subarray that, if sorted in non-decreasing order, will make the whole array sorted in non-decreasing order. >>> shortest_unsorted_subarray_length(6, [1, 3, 5, 4, 2, 6]) 4 >>> shortest_unsorted_subarray_length(5, [1, 2, 3, 4, 5]) 0 >>> shortest_unsorted_subarray_length(7, [10, 12, 11, 14, 13, 15, 16]) 4","solution":"def shortest_unsorted_subarray_length(n, A): Returns the length of the shortest subarray that, if sorted in non-decreasing order, will make the whole array sorted in non-decreasing order. if n <= 1: return 0 start, end = 0, n-1 # Find the first element which is not at the correct position from the left while start < n-1 and A[start] <= A[start+1]: start += 1 # if the array is already sorted if start == n-1: return 0 # Find the first element which is not at the correct position from the right while end > 0 and A[end] >= A[end-1]: end -= 1 # Find the maximum and minimum of the subarray A[start:end+1] min_subarray, max_subarray = min(A[start:end+1]), max(A[start:end+1]) # Extend the subarray to the left while start > 0 and A[start-1] > min_subarray: start -= 1 # Extend the subarray to the right while end < n-1 and A[end+1] < max_subarray: end += 1 return end - start + 1"},{"question":"def find_lexicographical_bounds(s: str) -> Tuple[str, str]: Given a string s, return the lexicographically smallest and largest strings that can be formed by any number of swaps of any two characters. Arguments: s -- The input string consisting of lowercase English letters. Returns: A tuple (smallest, largest) where: - smallest is the lexicographically smallest string - largest is the lexicographically largest string Example: >>> find_lexicographical_bounds(\\"bcda\\") ('abcd', 'dcba') >>> find_lexicographical_bounds(\\"a\\") ('a', 'a')","solution":"def find_lexicographical_bounds(s): Given a string s, return the lexicographically smallest and largest strings that can be formed by any number of swaps of any two characters. Arguments: s -- The input string consisting of lowercase English letters. Returns: A tuple (smallest, largest) where: - smallest is the lexicographically smallest string - largest is the lexicographically largest string smallest = ''.join(sorted(s)) largest = ''.join(sorted(s, reverse=True)) return smallest, largest"},{"question":"def largest_single_flower_square(m, n, garden): Determine the size of the largest square sub-grid that contains only one type of flower ('R' for roses or 'T' for tulips). >>> largest_single_flower_square(3, 3, ['RTR', 'TRT', 'RTR']) 1 >>> largest_single_flower_square(4, 4, ['RRRR', 'RTTR', 'RTTR', 'RRRR']) 2 # Complete the function here import pytest def test_example_1(): assert largest_single_flower_square(3, 3, ['RTR', 'TRT', 'RTR']) == 1 def test_example_2(): assert largest_single_flower_square(4, 4, ['RRRR', 'RTTR', 'RTTR', 'RRRR']) == 2 def test_all_roses(): assert largest_single_flower_square(3, 3, ['RRR', 'RRR', 'RRR']) == 3 def test_all_tulips(): assert largest_single_flower_square(2, 2, ['TT', 'TT']) == 2 def test_mixed(): assert largest_single_flower_square(5, 5, ['RRTTR', 'RRTTR', 'RTRTR', 'RRTTR', 'RRTTR']) == 2 def test_minimum_case(): assert largest_single_flower_square(1, 1, ['R']) == 1 assert largest_single_flower_square(1, 1, ['T']) == 1 def test_large_uniform_grid(): m, n = 200, 200 garden = ['T' * n for _ in range(m)] assert largest_single_flower_square(m, n, garden) == 200","solution":"def largest_single_flower_square(m, n, garden): if not garden or m == 0 or n == 0: return 0 def max_square_side(char): dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if garden[i-1][j-1] == char: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side max_R = max_square_side('R') max_T = max_square_side('T') return max(max_R, max_T)"},{"question":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Parameters: arr (List[int]): The array to rotate k (int): The number of steps to rotate the array Returns: List[int]: The rotated array Examples: >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, 0, 0], 1) [0, 0, 0] >>> rotate_array([1, 2, 3, 4], 0) [1, 2, 3, 4] >>> rotate_array([1, 2], 3) [2, 1] >>> rotate_array([], 5) [] >>> rotate_array([1], 7) [1]","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. if not arr: return [] n = len(arr) k = k % n return arr[-k:] + arr[:-k]"},{"question":"def count_distinct_chars_in_substrings(s: str, queries: List[List[int]]) -> List[int]: For each query [left, right], return the number of distinct characters in the substring s[left:right+1]. Args: s: A string of lowercase English letters. queries: A list of queries, where each query is a list [left, right] representing a substring. Returns: A list of integers where each integer is the number of distinct characters in the corresponding query. Examples: >>> count_distinct_chars_in_substrings(\\"abcba\\", [[0, 1], [1, 4], [1, 1]]) [2, 3, 1] >>> count_distinct_chars_in_substrings(\\"abacabad\\", [[0, 4], [1, 7], [3, 5]]) [3, 4, 3] >>> count_distinct_chars_in_substrings(\\"aaaa\\", [[0, 3], [1, 2], [2, 3]]) [1, 1, 1]","solution":"def count_distinct_chars_in_substrings(s, queries): For each query [left, right], return the number of distinct characters in the substring s[left:right+1]. results = [] for left, right in queries: substring = s[left:right + 1] distinct_chars = len(set(substring)) # set to find unique characters results.append(distinct_chars) return results"},{"question":"def bubble_sort(arr): Sorts an array of integers in ascending order without using any built-in sort function, implementing the Bubble Sort algorithm. Parameters: arr (list): The input array of integers which may include positive, negative numbers and zero. Returns: list: The sorted array in ascending order. >>> bubble_sort([]) == [] >>> bubble_sort([1]) == [1] >>> bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> bubble_sort([3, -1, 2, 10, -2, 0]) == [-2, -1, 0, 2, 3, 10] >>> bubble_sort([4, 5, 3, 3, 1, 2, 4]) == [1, 2, 3, 3, 4, 4, 5]","solution":"def bubble_sort(arr): Sorts an array of integers in ascending order using the Bubble Sort algorithm. Parameters: arr (list): The input array of integers. Returns: list: The sorted array. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"def decodeString(s: str) -> str: Decode the given string according to the rule: k[encoded_string] where the encoded_string inside the square brackets is being repeated exactly k times. Args: s (str): The encoded string. Returns: str: The decoded string. Examples: >>> decodeString(\\"3[a]\\") \\"aaa\\" >>> decodeString(\\"3[abc]\\") \\"abcabcabc\\" >>> decodeString(\\"3[a2[c]]\\") \\"accaccacc\\" >>> decodeString(\\"3[a]2[bc]\\") \\"aaabcbc\\" >>> decodeString(\\"2[abc]3[cd]ef\\") \\"abcabccdcdcdef\\" >>> decodeString(\\"10[a]\\") \\"aaaaaaaaaa\\"","solution":"def decodeString(s): stack = [] current_string = \\"\\" current_number = 0 for char in s: if char.isdigit(): current_number = current_number * 10 + int(char) elif char == '[': stack.append((current_string, current_number)) current_string = \\"\\" current_number = 0 elif char == ']': last_string, number = stack.pop() current_string = last_string + current_string * number else: current_string += char return current_string"},{"question":"def arrange_students(heights): Arrange students' heights such that neighbors alternately increase and decrease in height. If it is not possible to rearrange the array to meet the requirement, return the original array. Args: heights (List[int]): List of students' heights. Returns: List[int]: Rearranged array of students' heights. Example: >>> arrange_students([4, 3, 2, 1, 6]) [1, 6, 2, 4, 3] >>> arrange_students([3, 1, 2, 4, 6, 5]) [1, 5, 2, 6, 3, 4]","solution":"def arrange_students(heights): n = len(heights) if n == 1: return heights heights.sort() arranged = [0] * n left = 0 right = n - 1 for i in range(n): if i % 2 == 0: arranged[i] = heights[left] left += 1 else: arranged[i] = heights[right] right -= 1 return arranged"},{"question":"def toggle_case(n, s): Toggles the case of each character in the string s. Parameters: n (int): The length of the string s. s (str): The input string consisting of lowercase and uppercase English letters. Returns: str: The modified string where all uppercase letters are converted to lowercase and all lowercase letters are converted to uppercase. Examples: >>> toggle_case(5, 'aBcDe') 'AbCdE' >>> toggle_case(10, 'HelloWorld') 'hELLOwORLD'","solution":"def toggle_case(n, s): Toggles the case of each character in the string s. Parameters: n (int): The length of the string s. s (str): The input string consisting of lowercase and uppercase English letters. Returns: str: The modified string where all uppercase letters are converted to lowercase and all lowercase letters are converted to uppercase. return s.swapcase()"},{"question":"def final_robot_position(commands: str) -> tuple: Computes the final position of the robot on a 2D grid after following a sequence of movement commands. Parameters: commands (str): A string containing the sequence of movement commands. Returns: tuple: A tuple (x, y) representing the final coordinates of the robot. >>> final_robot_position(\\"\\") (0, 0) >>> final_robot_position(\\"UUUU\\") (0, 4) >>> final_robot_position(\\"DDDD\\") (0, -4) >>> final_robot_position(\\"LLLL\\") (-4, 0) >>> final_robot_position(\\"RRRR\\") (4, 0) >>> final_robot_position(\\"UUDDLRLR\\") (0, 0) >>> final_robot_position(\\"UUUDDLR\\") (0, 1) >>> final_robot_position(\\"LURDLURD\\") (0, 0) >>> final_robot_position(\\"ULLL\\") (-3, 1) >>> final_robot_position(\\"RRDDL\\") (1, -2)","solution":"def final_robot_position(commands): Computes the final position of the robot on a 2D grid after following a sequence of movement commands. Parameters: commands (str): A string containing the sequence of movement commands. Returns: tuple: A tuple (x, y) representing the final coordinates of the robot. x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x, y"},{"question":"def min_boxes_needed(n: int) -> int: Returns the minimum number of boxes needed to pack n widgets. Each widget must be packed into its own box, but the boxes come in three different sizes: small, medium, and large. A small box can contain 1 widget, a medium box can contain 3 widgets, and a large box can contain 5 widgets. The goal is to minimize the number of boxes used, with a priority to use larger boxes first. Args: n (int): The number of widgets to be packed. Returns: int: The minimum number of boxes needed to pack n widgets. >>> min_boxes_needed(9) 3 >>> min_boxes_needed(20) 4 >>> min_boxes_needed(7) 3","solution":"def min_boxes_needed(n): Returns the minimum number of boxes needed to pack n widgets. large_boxes = n // 5 remaining_widgets = n % 5 medium_boxes = remaining_widgets // 3 remaining_widgets = remaining_widgets % 3 small_boxes = remaining_widgets return large_boxes + medium_boxes + small_boxes def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) results = [] for i in range(1, T + 1): N = int(data[i]) results.append(min_boxes_needed(N)) for result in results: print(result)"},{"question":"def infix_to_postfix(expression: str) -> str: Convert an infix expression to its corresponding postfix expression. Parameters: expression (str): The infix expression. Returns: str: The postfix expression. >>> infix_to_postfix(\\"a+b*c\\") \\"abc*+\\" >>> infix_to_postfix(\\"(a+b)*c\\") \\"ab+c*\\" >>> infix_to_postfix(\\"a+b\\") \\"ab+\\" >>> infix_to_postfix(\\"a*(b+c)\\") \\"abc+*\\" >>> infix_to_postfix(\\"(a+b)*(c+d)\\") \\"ab+cd+*\\" def infix_to_postfix_multiple_cases(t: int, expressions: List[str]) -> List[str]: Converts multiple infix expressions to postfix expressions. Parameters: t (int): Number of test cases. expressions (list of str): List of infix expressions. Returns: list of str: List of corresponding postfix expressions. >>> infix_to_postfix_multiple_cases(2, [\\"a+b*c\\", \\"(a+b)*c\\"]) [\\"abc*+\\", \\"ab+c*\\"] >>> infix_to_postfix_multiple_cases(1, [\\"a+b\\"]) [\\"ab+\\"] >>> infix_to_postfix_multiple_cases(3, [\\"a+b\\", \\"a*(b+c)\\", \\"(a+b)*(c+d)\\"]) [\\"ab+\\", \\"abc+*\\", \\"ab+cd+*\\"]","solution":"def infix_to_postfix(expression): Convert an infix expression to its corresponding postfix expression. Parameters: expression (str): The infix expression. Returns: str: The postfix expression. precedence = {'+': 1, '-': 1, '*': 2, '/': 2} stack = [] output = [] for char in expression: if char.isalpha(): # Operand output.append(char) elif char == '(': # Opening parenthesis stack.append(char) elif char == ')': # Closing parenthesis while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # Pop the '(' else: # Operator while stack and stack[-1] != '(' and precedence[char] <= precedence[stack[-1]]: output.append(stack.pop()) stack.append(char) # Pop all the remaining operators in the stack while stack: output.append(stack.pop()) return ''.join(output) def infix_to_postfix_multiple_cases(t, expressions): Converts multiple infix expressions to postfix expressions. Parameters: t (int): Number of test cases. expressions (list of str): List of infix expressions. Returns: list of str: List of corresponding postfix expressions. return [infix_to_postfix(expression) for expression in expressions]"},{"question":"def reverseInteger(N: int) -> int: Reverses the digits of the given integer without converting it to a string. Examples: >>> reverseInteger(12345) 54321 >>> reverseInteger(-123) -321","solution":"def reverseInteger(N): Reverses the digits of the given integer without converting it to a string. is_negative = N < 0 N = abs(N) reversed_number = 0 while N > 0: reversed_number = reversed_number * 10 + (N % 10) N = N // 10 return -reversed_number if is_negative else reversed_number"},{"question":"def generate_item_codes(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Generate short strings that uniquely identify items in the inventory based on the item names and the given value of K. Args: T: int - The number of test cases test_cases: List of tuples, each containing an integer K and a string representing the item name. Returns: List of strings - The corresponding item codes. Examples: >>> generate_item_codes(4, [(5, \\"Open #Box!\\"), (3, \\"USB-Drive\\"), (4, \\"4K TV\\"), (7, \\"Notebook\\")]) [\\"Open_\\", \\"USB\\", \\"4K_T\\", \\"Noteboo\\"] >>> generate_item_codes(2, [(5, \\"Hi!\\"), (10, \\"A B\\")]) [\\"Hi#\\", \\"A_B#\\"] Unit Test: from solution import generate_item_codes def test_sample(): T = 4 test_cases = [ (5, \\"Open #Box!\\"), (3, \\"USB-Drive\\"), (4, \\"4K TV\\"), (7, \\"Notebook\\") ] expected = [\\"Open_\\", \\"USB\\", \\"4K_T\\", \\"Noteboo\\"] assert generate_item_codes(T, test_cases) == expected def test_less_alphanumeric_chars(): T = 2 test_cases = [ (5, \\"Hi!\\"), (10, \\"A B\\") ] expected = [\\"Hi#\\", \\"A_B#\\"] assert generate_item_codes(T, test_cases) == expected def test_no_spaces(): T = 2 test_cases = [ (3, \\"Boxed\\"), (5, \\"12345\\") ] expected = [\\"Box\\", \\"12345\\"] assert generate_item_codes(T, test_cases) == expected def test_with_special_characters(): T = 2 test_cases = [ (4, \\"A@B#CD%\\"), (6, \\"1-2_3=4\\") ] expected = [\\"ABCD\\", \\"1234\\"] assert generate_item_codes(T, test_cases) == expected def test_exact_alphanumeric_chars(): T = 2 test_cases = [ (4, \\"ABCD\\"), (5, \\"12345\\") ] expected = [\\"ABCD\\", \\"12345\\"] assert generate_item_codes(T, test_cases) == expected","solution":"def generate_item_codes(T, test_cases): result = [] for i in range(T): K, item_name = test_cases[i] alphanumeric_chars = [] for char in item_name: if char.isalnum(): alphanumeric_chars.append(char) elif char == ' ': alphanumeric_chars.append('_') item_code = ''.join(alphanumeric_chars[:K]) if len(item_code) < K: item_code += '#' * (K - len(item_code)) result.append(item_code) return result"},{"question":"def can_adhere_to_diet(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: For each test case, determine if Chef can find at least one container that does not exceed the calorie limit. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of test cases where each test case is a tuple containing: - C (int): Maximum calories allowed in a meal. - N (int): Number of containers. - calorie_counts (List[int]): List of calorie counts for each container. Returns: List[str]: A list of strings where each string is \\"DietSuccess\\" if there is a container with calories <= C, else \\"DietFail\\". >>> can_adhere_to_diet(3, [(500, 3, [600, 400, 300]), (200, 2, [250, 300]), (100, 5, [90, 85, 80, 95, 100])]) [\\"DietSuccess\\", \\"DietFail\\", \\"DietSuccess\\"] >>> can_adhere_to_diet(2, [(100, 3, [150, 200, 300]), (50, 4, [60, 70, 80, 90])]) [\\"DietFail\\", \\"DietFail\\"]","solution":"def can_adhere_to_diet(T, test_cases): results = [] for i in range(T): C, N, calorie_counts = test_cases[i] if any(calorie <= C for calorie in calorie_counts): results.append(\\"DietSuccess\\") else: results.append(\\"DietFail\\") return results"},{"question":"from typing import List def top_m_frequent_responses(n: int, responses: List[int], m: int) -> List[int]: Returns the top M most frequent responses in descending order of frequency. If two responses have the same frequency, the smaller number comes first. :param n: Number of responses :param responses: List of responses :param m: Number of top frequent responses to return :return: List of M most frequent responses >>> top_m_frequent_responses(6, [3, 3, 1, 2, 2, 2], 2) [2, 3] >>> top_m_frequent_responses(7, [10, 10, 20, 30, 20, 20, 30], 3) [20, 10, 30]","solution":"from collections import Counter def top_m_frequent_responses(n, responses, m): Returns the top M most frequent responses in descending order of frequency. If two responses have the same frequency, the smaller number comes first. :param n: Number of responses :param responses: List of responses :param m: Number of top frequent responses to return :return: List of M most frequent responses counter = Counter(responses) sorted_responses = sorted(counter.keys(), key=lambda x: (-counter[x], x)) return sorted_responses[:m]"},{"question":"def min_chemicals_to_target(n: int, t: int, effects: List[int]) -> int: Determine the minimum number of chemical types required to achieve the target effect. >>> min_chemicals_to_target(3, 7, [2, 3, 5]) 2 >>> min_chemicals_to_target(3, 12, [2, 3, 5]) -1 >>> min_chemicals_to_target(3, 3, [1, 2, 3]) 1 >>> min_chemicals_to_target(3, 6, [1, 2, 3]) 3 >>> min_chemicals_to_target(4, 0, [1, -1, 2, -2]) 2 >>> min_chemicals_to_target(4, -1, [1, -1, 2, -2]) 1 >>> min_chemicals_to_target(4, 7, [1, 3, 4, 5]) 2 >>> min_chemicals_to_target(0, 5, []) -1","solution":"def min_chemicals_to_target(n, t, effects): from itertools import combinations for r in range(1, n + 1): for combo in combinations(effects, r): if sum(combo) == t: return r return -1 if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) t = int(data[1]) effects = [int(data[i + 2]) for i in range(n)] print(min_chemicals_to_target(n, t, effects))"},{"question":"def max_cakes(recipe: Dict[str, int], available: Dict[str, int]) -> int: Determine the maximum number of cakes that can be made with the given recipe and available ingredients. >>> max_cakes({\\"flour\\": 500, \\"sugar\\": 200, \\"eggs\\": 1}, {\\"flour\\": 1200, \\"sugar\\": 1200, \\"eggs\\": 5}) 2 >>> max_cakes({\\"flour\\": 300, \\"sugar\\": 150, \\"milk\\": 100}, {\\"flour\\": 1000, \\"sugar\\": 600, \\"milk\\": 200}) 2 >>> max_cakes({\\"flour\\": 400, \\"sugar\\": 100}, {\\"flour\\": 500, \\"sugar\\": 1200}) 1 >>> max_cakes({\\"flour\\": 500, \\"sugar\\": 200, \\"eggs\\": 1}, {\\"flour\\": 1200, \\"sugar\\": 1200}) 0 >>> max_cakes({\\"flour\\": 400, \\"sugar\\": 100}, {\\"flour\\": 0, \\"sugar\\": 1200}) 0 >>> max_cakes({\\"chocolate\\": 2, \\"milk\\": 1}, {\\"chocolate\\": 4, \\"milk\\": 2, \\"sugar\\": 5}) 2 >>> max_cakes({\\"flour\\": 100, \\"sugar\\": 50, \\"milk\\": 25, \\"eggs\\": 1}, {\\"flour\\": 200, \\"sugar\\": 150, \\"milk\\": 50}) 0","solution":"def max_cakes(recipe, available): Returns the maximum number of cakes that can be made with the given recipe and available ingredients. Parameters: recipe (dict): Dictionary of required ingredients and their respective quantities. available (dict): Dictionary of available ingredients and their respective quantities. Returns: int: Maximum number of cakes that can be made. min_cakes = float('inf') for ingredient, required_amount in recipe.items(): if ingredient in available: possible_cakes_from_ingredient = available[ingredient] // required_amount else: possible_cakes_from_ingredient = 0 min_cakes = min(min_cakes, possible_cakes_from_ingredient) return min_cakes"},{"question":"def process_commands(E: int, Q: int, commands: List[str]) -> List[str]: Processes a series of sales command for employees and returns the results of TOP_K queries. >>> E = 5 >>> Q = 6 >>> commands = [ ... \\"SALE 1 100\\", ... \\"SALE 2 200\\", ... \\"SALE 3 50\\", ... \\"TOP_K 2\\", ... \\"RESET 2\\", ... \\"TOP_K 2\\" ... ] >>> process_commands(E, Q, commands) [\\"2 1\\", \\"1 3\\"] >>> E = 3 >>> Q = 5 >>> commands = [ ... \\"SALE 1 150\\", ... \\"SALE 2 150\\", ... \\"SALE 3 100\\", ... \\"TOP_K 2\\", ... \\"RESET 1\\", ... \\"TOP_K 2\\" ... ] >>> process_commands(E, Q, commands) [\\"1 2\\", \\"2 3\\"]","solution":"def process_commands(E, Q, commands): from heapq import nlargest from collections import defaultdict sales = defaultdict(int) results = [] for command in commands: parts = command.split() if parts[0] == \\"SALE\\": employee_id = int(parts[1]) sales_amount = int(parts[2]) sales[employee_id] += sales_amount elif parts[0] == \\"TOP_K\\": k = int(parts[1]) top_k = sorted(sales.items(), key=lambda x: (-x[1], x[0]))[:k] results.append(' '.join(str(emp_id) for emp_id, _ in top_k)) elif parts[0] == \\"RESET\\": employee_id = int(parts[1]) sales[employee_id] = 0 return results"},{"question":"def is_valid_return_sequence(n, sequence): Verifies if the book return sequence is valid. Parameters: n (int): Number of books being returned. sequence (list of int): Sequence in which the books are being returned. Returns: str: \\"YES\\" if the sequence is valid, \\"NO\\" otherwise. >>> is_valid_return_sequence(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> is_valid_return_sequence(5, [1, 3, 2, 5, 4]) \\"NO\\" >>> is_valid_return_sequence(1, [1]) \\"YES\\" >>> is_valid_return_sequence(3, [1, 3, 2]) \\"NO\\" >>> is_valid_return_sequence(4, [1, 2, 4, 3]) \\"NO\\" >>> is_valid_return_sequence(6, [1, 2, 3, 4, 5, 6]) \\"YES\\" >>> is_valid_return_sequence(4, [4, 1, 2, 3]) \\"NO\\"","solution":"def is_valid_return_sequence(n, sequence): Verifies if the book return sequence is valid. Parameters: n (int): Number of books being returned. sequence (list of int): Sequence in which the books are being returned. Returns: str: \\"YES\\" if the sequence is valid, \\"NO\\" otherwise. seen = [False] * (n + 1) for book in sequence: if book > 1 and not seen[book - 1]: return \\"NO\\" seen[book] = True return \\"YES\\""},{"question":"from typing import List def count_pairs_with_sum(nums: List[int], k: int) -> int: Returns the number of pairs in the list whose sum is equal to k. Example 1: >>> count_pairs_with_sum([1, 2, 3, 4, 3], 6) 2 Example 2: >>> count_pairs_with_sum([1, 1, 1, 1], 2) 6 Example 3: >>> count_pairs_with_sum([0, -1, 2, -3, 1], -2) 1","solution":"from collections import Counter def count_pairs_with_sum(nums, k): Returns the number of pairs in the list whose sum is equal to k. count = 0 freq = Counter(nums) for num in nums: complement = k - num if complement in freq: count += freq[complement] if complement == num: count -= 1 return count // 2"},{"question":"def min_cost_path(costs): Returns the minimum cost to reach the bottom-right corner of the matrix from the top-left corner. >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 2, 3, 4]]) 10 >>> min_cost_path([ ... [1], ... [2], ... [3], ... [4] ... ]) 10","solution":"def min_cost_path(costs): Returns the minimum cost to reach the bottom-right corner of the matrix from the top-left corner. if not costs or not costs[0]: return 0 n = len(costs) m = len(costs[0]) # Create a 2D dp array with the same dimensions as costs dp = [[0] * m for _ in range(n)] dp[0][0] = costs[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + costs[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + costs[i][0] # Fill in the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + costs[i][j] return dp[n-1][m-1]"},{"question":"def checkString(S): Determines if the string S contains only digits and characters 'a' to 'e'. Parameters: S (str): The input string. Returns: int: 1 if valid, otherwise 0. Examples: >>> checkString(\\"12b34\\") 1 >>> checkString(\\"12x34\\") 0 >>> checkString(\\"abcde\\") 1 >>> checkString(\\"ghi567\\") 0 def test_checkString_valid(): assert checkString(\\"12b34\\") == 1 assert checkString(\\"abcde\\") == 1 assert checkString(\\"12345\\") == 1 assert checkString(\\"aa11bb22cc33\\") == 1 def test_checkString_invalid(): assert checkString(\\"12x34\\") == 0 assert checkString(\\"abcdefg\\") == 0 assert checkString(\\"123@456\\") == 0 assert checkString(\\"ghi567\\") == 0 def test_checkString_empty(): assert checkString(\\"\\") == 1 def test_checkString_border_cases(): assert checkString(\\"a\\") == 1 assert checkString(\\"e\\") == 1 assert checkString(\\"!a\\") == 0 assert checkString(\\"z\\") == 0","solution":"def checkString(S): Determines if the string S contains only digits and characters 'a' to 'e'. Parameters: S (str): The input string. Returns: int: 1 if valid, otherwise 0. for char in S: if not (char.isdigit() or 'a' <= char <= 'e'): return 0 return 1"},{"question":"def hasPairWithSum(arr, S): Determine if there are two distinct elements in the array that add up to S. Parameters: arr (list of int): the list of integers S (int): the target sum Returns: bool: True if such a pair exists, otherwise False Examples: >>> hasPairWithSum([1, 4, 45, 6, 10, -8], 16) True >>> hasPairWithSum([1, 2, 3, 9], 8) False >>> hasPairWithSum([0, -1, 2, -3, 1], -2) True","solution":"def hasPairWithSum(arr, S): Determine if there are two distinct elements in the array that add up to S. Parameters: arr (list of int): the list of integers S (int): the target sum Returns: bool: True if such a pair exists, otherwise False seen = set() for num in arr: complement = S - num if complement in seen: return True seen.add(num) return False"},{"question":"def unique_chapters(N, chapter_names): This function returns a list of unique chapter names in the order they first appear. >>> unique_chapters(5, [\\"introduction\\", \\"basics\\", \\"variables\\", \\"basics\\", \\"syntax\\"]) [\\"introduction\\", \\"basics\\", \\"variables\\", \\"syntax\\"] >>> unique_chapters(3, [\\"chapterone\\", \\"chaptertwo\\", \\"chapterthree\\"]) [\\"chapterone\\", \\"chaptertwo\\", \\"chapterthree\\"] >>> unique_chapters(4, [\\"chapter\\", \\"chapter\\", \\"chapter\\", \\"chapter\\"]) [\\"chapter\\"] >>> unique_chapters(0, []) [] >>> unique_chapters(1, [\\"onlychapter\\"]) [\\"onlychapter\\"]","solution":"def unique_chapters(N, chapter_names): This function returns a list of unique chapter names in the order they first appear. :param N: Number of chapter names (integer) :param chapter_names: List of chapter names (list of strings) :return: List of unique chapter names in the order they first appeared (list of strings) seen = set() unique_names = [] for name in chapter_names: if name not in seen: seen.add(name) unique_names.append(name) return unique_names"},{"question":"def minimum_energy_stops(floors: List[int]) -> int: Given a non-empty list of positive integers representing the floor number reached by a sequence of elevator stops, determine the minimum energy required for the elevator to make all the stops. The energy is defined as the total number of floors traveled, where moving one floor up or down counts as one floor traveled. >>> minimum_energy_stops([1, 3, 6, 2, 9, 5]) 20 >>> minimum_energy_stops([4, 4, 5, 6, 5]) 3","solution":"def minimum_energy_stops(floors): Returns the minimum energy needed to make all the stops given the sequence of floors. # Initialize the total energy required total_energy = 0 # Iterate through the list of floors and calculate the total energy for i in range(1, len(floors)): total_energy += abs(floors[i] - floors[i-1]) return total_energy"},{"question":"def max_observed_values(n, data_entries): Finds the maximum observed value for each date from the given data entries. :param n: number of data entries :param data_entries: list of tuples where each tuple contains a date and an integer value :return: list of tuples containing unique dates and their corresponding maximum observed values # Your code here # Sample Input: # n = 5 # data_entries = [('2023-01-01', 10), ('2023-01-01', 5), ('2023-01-02', -2), ('2023-01-02', 3), ('2023-01-02', 1)] # Expected Output: # [('2023-01-01', 10), ('2023-01-02', 3)]","solution":"def max_observed_values(n, data_entries): Finds the maximum observed value for each date from the given data entries. :param n: number of data entries :param data_entries: list of tuples where each tuple contains a date and an integer value :return: list of tuples containing unique dates and their corresponding maximum observed values date_values = {} for date, value in data_entries: if date not in date_values: date_values[date] = value else: date_values[date] = max(date_values[date], value) result = [(date, date_values[date]) for date in date_values] return result # Sample Input: # n = 5 # data_entries = [('2023-01-01', 10), ('2023-01-01', 5), ('2023-01-02', -2), ('2023-01-02', 3), ('2023-01-02', 1)] # Expected Output: # [('2023-01-01', 10), ('2023-01-02', 3)]"},{"question":"def find_pair(arr): Finds the pair of integers (a, b) such that a < b and there are no integers in between a and b. Parameters: arr (list): List of unique integers. Returns: tuple: Pair of integers (a, b). >>> find_pair([5, 1, 7, 3, 9]) in [(1, 3), (3, 5), (7, 9)] True >>> find_pair([8, 2, 6, 4]) in [(2, 4), (4, 6), (6, 8)] True >>> find_pair([10, 30, 20, 40]) == (10, 20) True >>> find_pair([1000000000, 500000000, 300000000, 700000000]) == (300000000, 500000000) True >>> find_pair([4, 3, 2, 1]) == (1, 2) True","solution":"def find_pair(arr): Finds the pair of integers (a, b) such that a < b and there are no integers in between a and b. Parameters: arr (list): List of unique integers. Returns: tuple: Pair of integers (a, b). arr.sort() n = len(arr) min_diff = float('inf') pair = (arr[0], arr[1]) for i in range(n - 1): if arr[i+1] - arr[i] < min_diff: min_diff = arr[i+1] - arr[i] pair = (arr[i], arr[i+1]) return pair"},{"question":"def count_connected_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph with N nodes and M edges, return the number of connected components. >>> count_connected_components(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> count_connected_components(6, 0, []) 6 >>> count_connected_components(7, 5, [(1, 2), (2, 3), (3, 4), (5, 6), (6, 7)]) 2","solution":"def count_connected_components(n, m, edges): from collections import defaultdict, deque # Creating adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() def bfs(node): queue = deque([node]) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) connected_components = 0 for node in range(1, n + 1): if node not in visited: visited.add(node) bfs(node) connected_components += 1 return connected_components"},{"question":"def minimum_swaps_to_sort(N): Calculate the minimum number of swaps required to sort an array of length N with elements from 0 to N-1 when the elements need to remain in their original order after each swap operation. Parameters: N (int): The length of the array. Returns: int: The minimum number of swaps needed. >>> minimum_swaps_to_sort(4) 3 >>> minimum_swaps_to_sort(5) 4 def solve_minimum_swaps(T, test_cases): For each test case, calculate and return the minimum number of swaps required. Parameters: T (int): The number of test cases. test_cases (list of int): Each int is the length of the array for a test case. Returns: list of int: The minimum number of swaps for each test case. >>> solve_minimum_swaps(2, [4, 5]) [3, 4] >>> solve_minimum_swaps(1, [10]) [9]","solution":"def minimum_swaps_to_sort(N): Calculate the minimum number of swaps required to sort an array of length N with elements from 0 to N-1 when the elements need to remain in their original order after each swap operation. Parameters: N (int): The length of the array. Returns: int: The minimum number of swaps needed. # The minimum number of swaps to sort an array of length N from [0, N-1] # is always N-1 because the array is already in sorted order. return N - 1 def solve_minimum_swaps(T, test_cases): For each test case, calculate and return the minimum number of swaps required. Parameters: T (int): The number of test cases. test_cases (list of int): Each int is the length of the array for a test case. Returns: list of int: The minimum number of swaps for each test case. results = [] for N in test_cases: results.append(minimum_swaps_to_sort(N)) return results"},{"question":"def total_productive_hours(T: int, log_entries: List[List[Tuple[int, int]]]) -> List[int]: Computes total productive hours for each employee given the log entries of their projects. Args: T (int): Number of employees log_entries (List[List[Tuple[int, int]]]): List of logs per employee Returns: List[int]: Total productive hours for each employee Examples: >>> total_productive_hours(2, [[(9, 11), (10, 12), (14, 16)], [(8, 12), (11, 15)]]) [5, 7] >>> total_productive_hours(1, [[(9, 11), (12, 14), (15, 17)]]) [6] >>> total_productive_hours(1, [[(9, 12), (10, 11), (11, 12)]]) [3] >>> total_productive_hours(1, [[(9, 11), (10, 12)]]) [3] >>> total_productive_hours(1, [[(9, 12)]]) [3]","solution":"def total_productive_hours(T, log_entries): Computes total productive hours for each employee. Args: T: int : Number of employees log_entries: list : List of logs per employee Returns: list : Total productive hours for each employee result = [] for logs in log_entries: intervals = [] for s, e in logs: intervals.append((s, e)) # Sort intervals by start time intervals.sort() total_hours = 0 current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # Merge intervals current_end = max(current_end, end) else: # No overlap, account the current interval time to total and start new interval total_hours += current_end - current_start current_start, current_end = start, end # Add the last interval to total total_hours += current_end - current_start result.append(total_hours) return result"},{"question":"def find_items_to_reorder(N, sales, threshold): This function returns the 1-based indices of items that need to be reordered. Parameters: N (int): Number of items. sales (list of int): Sales quantities of each item. threshold (int): Reorder threshold. Returns: list of int: 1-based indices of items that need to be reordered. # Your code here # Example usage: # N = 5 # sales = [3, 10, 6, 2, 8] # threshold = 5 # Output should be [1, 4]","solution":"def find_items_to_reorder(N, sales, threshold): This function returns the 1-based indices of items that need to be reordered. Parameters: N (int): Number of items. sales (list of int): Sales quantities of each item. threshold (int): Reorder threshold. Returns: list of int: 1-based indices of items that need to be reordered. reorder_indices = [i + 1 for i in range(N) if sales[i] < threshold] if reorder_indices: return reorder_indices else: return [\\"No reorders\\"] # Example usage: # N = 5 # sales = [3, 10, 6, 2, 8] # threshold = 5 # Output should be [1, 4]"},{"question":"def rotate_matrix(matrix): Rotates a given matrix 90 degrees clockwise. Args: matrix (list of list of int): The matrix to rotate. Returns: list of list of int: Rotated matrix. def process_input(T, test_cases): Processes input and returns the rotated matrices. Args: T (int): Number of test cases. test_cases (list of tuples): List of tuples where each tuple contains (N, M, matrix) for each test case. Returns: list of lists of list of int: List of rotated matrices for each test case. >>> T = 2 >>> test_cases = [ ... (3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), ... (2, 4, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8] ... ]) ... ] >>> process_input(T, test_cases) [ [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ], [ [5, 1], [6, 2], [7, 3], [8, 4] ] ]","solution":"def rotate_matrix(matrix): Rotates a given matrix 90 degrees clockwise. Args: matrix (list of list of int): The matrix to rotate. Returns: list of list of int: Rotated matrix. # Computing the transpose of the matrix transposed_matrix = list(zip(*matrix)) # Reversing each row of the transposed matrix to get the rotated matrix rotated_matrix = [list(reversed(row)) for row in transposed_matrix] return rotated_matrix def process_input(T, test_cases): Processes input and returns the rotated matrices. Args: T (int): Number of test cases. test_cases (list of tuples): List of tuples where each tuple contains (N, M, matrix) for each test case. Returns: list of lists of list of int: List of rotated matrices for each test case. results = [] for N, M, matrix in test_cases: rotated_matrix = rotate_matrix(matrix) results.append(rotated_matrix) return results"},{"question":"from typing import List def longest_palindrome_length(s: str) -> int: Given a string s, determine if the characters can be rearranged to form a palindrome. Return the length of the longest palindrome that can be formed, otherwise return -1 if no palindrome can be made. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"aabbcc\\") 6 >>> longest_palindrome_length(\\"abcdefg\\") -1 # Your code goes here","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be formed by rearranging the characters of the given string. If it's impossible, returns -1. from collections import Counter # Count frequency of each character char_count = Counter(s) length = 0 odd_count = 0 for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count += 1 # If there's any odd count, we can still place one odd character in the middle if odd_count > 0: length += 1 # If we cannot form a palindrome if length <= 1 and len(s) > 1: return -1 return length"},{"question":"def solve(input_array): Given an array of integers, returns a new array where each element at index i is the sum of all the elements in the original array except the one at index i. >>> solve([1, 2, 3, 4]) [9, 8, 7, 6] >>> solve([0, 1, 2, 3, 4]) [10, 9, 8, 7, 6] >>> solve([-1, -2, -3, -4]) [-9, -8, -7, -6] >>> solve([-1, 1, -1, 1]) [1, -1, 1, -1] >>> solve([5]) [0] >>> solve([0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def solve(input_array): Given an array of integers, returns a new array where each element at index i is the sum of all the elements in the original array except the one at index i. Parameters: input_array (list of int): The input array of integers. Returns: list of int: The new array with the described property. total_sum = sum(input_array) return [total_sum - x for x in input_array]"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detectLoop(head: ListNode) -> bool: Detects if a linked list contains a loop. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node5 = ListNode(5) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node5 >>> node5.next = node2 >>> detectLoop(node1) True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node5 = ListNode(5) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node5 >>> detectLoop(node1) False >>> detectLoop(None) False >>> node1 = ListNode(1) >>> detectLoop(node1) False >>> node1 = ListNode(1) >>> node1.next = node1 >>> detectLoop(node1) True","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detectLoop(head): Detects if a linked list contains a loop. :param head: The head node of the linked list :return: True if there is a loop, False otherwise slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def custom_sort(sequence): Sorts the sequence according to the following criteria: 1. All negative integers come before all positive integers. 2. The relative order of the negative integers and the positive integers should remain the same as in the original sequence. 3. All zeros should be moved to the end of the sequence, maintaining their relative order. pass # Unit Tests def test_custom_sort_regular_case(): assert custom_sort([4, -3, 0, 2, -7, 0, 1, -6]) == [-3, -7, -6, 4, 2, 1, 0, 0] def test_custom_sort_all_positive(): assert custom_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_custom_sort_all_negative(): assert custom_sort([-1, -2, -3, -4, -5]) == [-1, -2, -3, -4, -5] def test_custom_sort_all_zeros(): assert custom_sort([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0] def test_custom_sort_mixed_no_zeros(): assert custom_sort([-1, 2, -3, 4, -5]) == [-1, -3, -5, 2, 4] def test_custom_sort_with_zeros_and_positives(): assert custom_sort([0, 2, 0, 4, 0, 1]) == [2, 4, 1, 0, 0, 0] def test_custom_sort_with_zeros_and_negatives(): assert custom_sort([-1, 0, -2, 0, -3]) == [-1, -2, -3, 0, 0] def test_custom_sort_single_element(): assert custom_sort([5]) == [5] assert custom_sort([-5]) == [-5] assert custom_sort([0]) == [0] def test_custom_sort_edge_case_large_numbers(): assert custom_sort([0, -10**9, 10**9, 0]) == [-10**9, 10**9, 0, 0]","solution":"def custom_sort(sequence): Sorts the sequence according to the following criteria: 1. All negative integers come before all positive integers. 2. The relative order of the negative integers and the positive integers should remain the same as in the original sequence. 3. All zeros should be moved to the end of the sequence, maintaining their relative order. negatives = [x for x in sequence if x < 0] positives = [x for x in sequence if x > 0] zeros = [x for x in sequence if x == 0] return negatives + positives + zeros"},{"question":"def count_forests(n: int, m: int, grid: List[List[str]]) -> int: Returns the number of distinct forests in the given grid. >>> count_forests(4, 5, [['.', '.', '.', '.', '.'], ['.', 'T', 'T', 'T', '.'], ['.', 'T', '.', '.', '.'], ['.', '.', '.', '.', '.']]) 1 >>> count_forests(4, 4, [['.', 'T', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', 'T', '.'], ['.', 'T', 'T', '.', '.']]) 3 >>> count_forests(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 0 >>> count_forests(3, 3, [['T', 'T', 'T'], ['T', 'T', 'T'], ['T', 'T', 'T']]) 1 >>> count_forests(3, 3, [['T', '.', 'T'], ['.', '.', '.'], ['T', '.', 'T']]) 4","solution":"def count_forests(n, m, grid): Returns the number of distinct forests in the given grid. if not grid: return 0 def dfs(i, j): if 0 <= i < n and 0 <= j < m and grid[i][j] == 'T': grid[i][j] = '.' # Mark this tree as visited # Explore all possible directions dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) forest_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'T': forest_count += 1 dfs(i, j) return forest_count # Example usage # n, m = 4, 5 # grid = [ # ['.', '.', '.', '.', '.'], # ['.', 'T', 'T', 'T', '.'], # ['.', 'T', '.', '.', '.'], # ['.', '.', '.', '.', '.'] # ] # print(count_forests(n, m, grid)) # Output: 1 # n, m = 4, 4 # grid = [ # ['.', 'T', '.', '.', '.'], # ['.', '.', '.', '.', '.'], # ['.', '.', '.', 'T', '.'], # ['.', 'T', 'T', '.', '.'] # ] # print(count_forests(n, m, grid)) # Output: 3"},{"question":"def min_photograph_time(test_cases): Determine the minimum amount of time required to photograph all the birds on all trees given the camera's cooldown period. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case is a tuple. The first element of the tuple is an integer N representing the number of trees, and the second element is a list of integers representing the number of birds on each tree. Returns: List[int]: A list of integers representing the minimum amount of time required to photograph all the birds for each test case. Examples: >>> min_photograph_time([(3, [2, 3, 4])]) [9] >>> min_photograph_time([(3, [2, 3, 4]), (4, [1, 2, 3, 4])]) [9, 10]","solution":"def min_photograph_time(test_cases): results = [] for test in test_cases: N, birds_on_trees = test total_time = 0 for birds in birds_on_trees: total_time += birds results.append(total_time) return results"},{"question":"def smallest_N_for_digit(L: int, R: int) -> int: Find the smallest non-negative integer N such that the last digit of N multiplied by any integer in the range [L, R] is the same. >>> smallest_N_for_digit(3, 8) 0 >>> smallest_N_for_digit(5, 5) 1 >>> smallest_N_for_digit(1, 1) 0 >>> smallest_N_for_digit(10, 1000) 0 >>> smallest_N_for_digit(999, 1000) 0","solution":"def smallest_N_for_digit(L, R): Find the smallest N such that for every integer X in the range [L, R], the last digit of (N * X) is the same. # Last digit of 0 is universally 0 for any multiplication, hence it always satisfies the condition. return 0"},{"question":"def final_position(n: int, start_pos: int, k: int) -> int: Determines the final position of the ball after making one full rotation around the circle. Args: n (int): Number of children sitting in a circle. start_pos (int): The starting position of the ball. k (int): The number of positions the ball is passed to the right each time. Returns: int: The final position of the ball. Examples: >>> final_position(5, 0, 2) 2 >>> final_position(7, 4, 3) 0 >>> final_position(10, 3, 5) 8","solution":"def final_position(n: int, start_pos: int, k: int) -> int: Determines the final position of the ball after making one full rotation around the circle. Args: n (int): Number of children sitting in a circle. start_pos (int): The starting position of the ball. k (int): The number of positions the ball is passed to the right each time. Returns: int: The final position of the ball. # The final position can be determined using modulo arithmetic to handle wrapping around the circle return (start_pos + k % n) % n"},{"question":"def find_largest_elements(test_cases: List[List[int]]) -> List[int]: Given a list of test cases, where each test case is a list of integers starting with the size of the array, this function finds and returns the largest element in each subarray. Args: test_cases: A list of test cases, where each test case is a list starting with an integer N followed by N integers. Returns: A list of integers representing the largest element in each test case. Example: >>> find_largest_elements([[5, 1, 3, -2, 8, 5], [3, -1, -5, -3], [4, 7, 4, 2, 9]]) [8, -1, 9] >>> find_largest_elements([[1, -1000000], [1, 1000000]]) [-1000000, 1000000]","solution":"def find_largest_elements(test_cases): Given a list of test cases, where each test case is a list of integers starting with the size of the array, this function finds and returns the largest element in each subarray. largest_elements = [] for case in test_cases: N = case[0] arr = case[1:] if N != len(arr): raise ValueError(\\"The array size does not match the given N.\\") largest_elements.append(max(arr)) return largest_elements"},{"question":"def countElementsGreater(arr1, arr2): Counts the number of elements in arr1 that are greater than the maximum element of arr2. Parameters: arr1 (list): First list of integers. arr2 (list): Second list of integers. Returns: int: Number of elements in arr1 greater than the maximum element of arr2. >>> countElementsGreater([5, 3, 9, 7], [6, 4, 8]) == 1 >>> countElementsGreater([1, 2, 3, 4], [5, 6, 7, 8]) == 0 >>> countElementsGreater([10, 15, 20, 25], [19, 22, 23]) == 1 >>> countElementsGreater([], [1, 2, 3]) == 0 >>> countElementsGreater([1, 2, 3], []) == 0 >>> countElementsGreater([], []) == 0 >>> countElementsGreater([10, 12, 15], [2, 3, 5, 7]) == 3 >>> countElementsGreater([1, 2, 3, 4], [10, 11, 12]) == 0","solution":"def countElementsGreater(arr1, arr2): Counts the number of elements in arr1 that are greater than the maximum element of arr2. Parameters: arr1 (list): First list of integers. arr2 (list): Second list of integers. Returns: int: Number of elements in arr1 greater than the maximum element of arr2. if not arr1 or not arr2: return 0 max_arr2 = max(arr2) count = sum(1 for x in arr1 if x > max_arr2) return count"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"\\") == 0","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest_length = 0 window_start = 0 for window_end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= window_start: window_start = char_index_map[char] + 1 char_index_map[char] = window_end longest_length = max(longest_length, window_end - window_start + 1) return longest_length"},{"question":"def minimal_spanning_tree(N: int, roads: List[Tuple[int, int, int]]) -> int: Finds the minimal sum of all road lengths forming a fully connected network. Args: N (int): Number of intersections. roads (List[Tuple[int, int, int]]): List of roads where each tuple is (u, v, L). Returns: int: Minimal sum of road lengths in the spanning tree. >>> minimal_spanning_tree(4, [(1, 2, 1), (1, 3, 3), (2, 3, 1), (3, 4, 1), (4, 1, 6)]) 3 >>> minimal_spanning_tree(3, [(1, 2, 1), (2, 3, 3), (1, 3, 4)]) 4","solution":"def minimal_spanning_tree(N, roads): Finds the minimal sum of all road lengths forming a fully connected network. Args: N (int): Number of intersections. roads (list of tuples): List of roads where each tuple is (u, v, L). Returns: int: Minimal sum of road lengths in the spanning tree. # Sort the roads by weight (length) roads.sort(key=lambda x: x[2]) # Initialize parent and rank arrays for Union-Find/Disjoint Set Union (DSU) parent = list(range(N)) rank = [0] * N def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 mst_length = 0 for u, v, length in roads: u -= 1 # Convert to zero-indexed v -= 1 # Convert to zero-indexed if find(u) != find(v): union(u, v) mst_length += length return mst_length def run_solution(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) roads = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index + 1]) L = int(data[index + 2]) roads.append((u, v, L)) index += 3 result = minimal_spanning_tree(N, roads) print(result)"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths in a grid with obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1], ... [1, 0] ... ]) 0","solution":"def unique_paths_with_obstacles(grid): m, n = len(grid), len(grid[0]) # If the starting or ending point is an obstacle, return 0 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Create a dp table with the same dimensions as the grid dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting point # Fill the dp table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # Obstacle cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def can_deliver_exact_weight(a: int, b: int, W: int) -> str: Determine if it is possible to achieve the exact weight W using any combination of Model A and Model B robots. >>> can_deliver_exact_weight(4, 6, 8) \\"POSSIBLE\\" >>> can_deliver_exact_weight(4, 6, 10) \\"POSSIBLE\\" >>> can_deliver_exact_weight(4, 6, 13) \\"IMPOSSIBLE\\" pass def solve(t: int, weights: List[int]) -> List[str]: For each test case, determine if it is possible to achieve the exact weight W using any combination of Model A and Model B robots. >>> solve(3, [8, 10, 13]) [\\"POSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\"] >>> solve(1, [6]) [\\"POSSIBLE\\"] >>> solve(5, [1, 2, 3, 4, 5]) [\\"IMPOSSIBLE\\", \\"IMPOSSIBLE\\", \\"IMPOSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\"] pass","solution":"def can_deliver_exact_weight(a, b, W): for i in range((W // a) + 1): for j in range((W // b) + 1): if a * i + b * j == W: return \\"POSSIBLE\\" return \\"IMPOSSIBLE\\" def solve(t, weights): results = [] for i in range(t): results.append(can_deliver_exact_weight(4, 6, weights[i])) return results"},{"question":"def is_valid_parentheses(s: str) -> str: Check if the parentheses string is valid. Parameters: s (str): A string containing only '(' and ')' with even length. Returns: str: \\"Yes\\" if the string is valid, otherwise \\"No\\". >>> is_valid_parentheses(\\"()\\") \\"Yes\\" >>> is_valid_parentheses(\\"(())\\") \\"Yes\\" >>> is_valid_parentheses(\\"(()())\\") \\"Yes\\" >>> is_valid_parentheses(\\"((()))\\") \\"Yes\\" >>> is_valid_parentheses(\\")(\\") \\"No\\" >>> is_valid_parentheses(\\"(()\\") \\"No\\" >>> is_valid_parentheses(\\"())\\") \\"No\\" >>> is_valid_parentheses(\\"())(\\") \\"No\\" >>> is_valid_parentheses(\\")()(\\") \\"No\\" >>> is_valid_parentheses(\\"()()()()()()()()()()\\") \\"Yes\\" >>> is_valid_parentheses(\\"(((((((((())))))))))\\") \\"Yes\\" >>> is_valid_parentheses(\\"(\\" * 50 + \\")\\" * 50) \\"Yes\\" >>> is_valid_parentheses(\\")\\" * 1 + \\"(\\" * 1) \\"No\\" >>> is_valid_parentheses(\\"()())(()\\") \\"No\\"","solution":"def is_valid_parentheses(s): Check if the parentheses string is valid. Parameters: s (str): A string containing only '(' and ')' with even length. Returns: str: \\"Yes\\" if the string is valid, otherwise \\"No\\". stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if stack: stack.pop() else: return \\"No\\" return \\"Yes\\" if not stack else \\"No\\""},{"question":"def generate_hierarchy(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Generate the hierarchy and print the manager-employee relationships. >>> generate_hierarchy([(5, [4, 1, 7, 3, 2])]) [\\"2 1\\", \\"3 1\\", \\"4 1\\", \\"7 1\\"] >>> generate_hierarchy([(3, [10, 5, 3])]) [\\"5 3\\", \\"10 3\\"] >>> generate_hierarchy([(4, [2, 10, 5, 1])]) [\\"2 1\\", \\"5 1\\", \\"10 1\\"] >>> generate_hierarchy([ (5, [4, 1, 7, 3, 2]), (3, [10, 5, 3]) ]) [\\"2 1\\", \\"3 1\\", \\"4 1\\", \\"7 1\\", \\"5 3\\", \\"10 3\\"] >>> generate_hierarchy([(3, [1, 2, 3])]) [\\"2 1\\", \\"3 1\\"]","solution":"def generate_hierarchy(test_cases): result = [] for case in test_cases: N, employee_ids = case employee_ids.sort() for i in range(1, N): result.append(f\\"{employee_ids[i]} {employee_ids[0]}\\") return result"},{"question":"def calculate_average_scores(input_lines): Takes a list of strings where each string contains a student's name and their scores in Math, Science, and English. Returns a list of strings where each string contains the student's name and their average score. >>> calculate_average_scores([\\"Alice,85,90,78\\"]) == [\\"Alice 84\\"] >>> calculate_average_scores([ \\"Alice,85,90,78\\", \\"Bob,75,80,88\\", \\"Charlie,90,85,91\\", \\"David,60,70,75\\", \\"Eve,88,92,95\\" ]) == [ \\"Alice 84\\", \\"Bob 81\\", \\"Charlie 89\\", \\"David 68\\", \\"Eve 92\\" ]","solution":"def calculate_average_scores(input_lines): Takes a list of strings where each string contains a student's name and their scores in Math, Science, and English. Returns a list of strings where each string contains the student's name and their average score. result = [] for line in input_lines: parts = line.split(',') name = parts[0] scores = list(map(int, parts[1:])) average_score = round(sum(scores) / len(scores)) result.append(f\\"{name} {average_score}\\") return result"},{"question":"def second_largest(numbers): Returns the second largest distinct number in the list. If the list has fewer than two distinct numbers, returns None. >>> second_largest([4, 2, 5, 1, 5, 3]) == 4 >>> second_largest([7, 7, 7]) == None >>> second_largest([7]) == None >>> second_largest([]) == None >>> second_largest([-1, -2, -3, -4]) == -2 >>> second_largest([10, 20, 20, 20, 30]) == 20 >>> second_largest([1, 2]) == 1 >>> second_largest([1, 2, 2, 2, 2]) == 1 >>> second_largest([1, 1, 2, 3, 4, 4, 4]) == 3","solution":"def second_largest(numbers): Returns the second largest distinct number in the list. If the list has fewer than two distinct numbers, returns None. unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return None unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"def solve(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], int, List[Tuple[int, int]]]]) -> List[List[int]]: Calculate the shortest guaranteed path for each given query in multiple test cases. >>> solve(1, [(5, 6, [(1, 2, 10), (1, 3, 3), (2, 3, 1), (2, 4, 2), (3, 5, 6), (4, 5, 7)], 3, [(1, 5), (2, 5), (1, 4)])]) [[9, 7, 6]] >>> solve(1, [(4, 2, [(1, 2, 5), (3, 4, 7)], 2, [(1, 4), (2, 3)])]) [[-1, -1]] >>> solve(2, [(5, 6, [(1, 2, 10), (1, 3, 3), (2, 3, 1), (2, 4, 2), (3, 5, 6), (4, 5, 7)], 3, [(1, 5), (2, 5), (1, 4)]), (4, 2, [(1, 2, 5), (3, 4, 7)], 2, [(1, 4), (2, 3)])]) [[9, 7, 6], [-1, -1]]","solution":"import heapq def dijkstra_shortest_path(n, graph, start, end): distances = {node: float('inf') for node in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 def process_queries(n, edges, queries): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) result = [] for a, b in queries: result.append(dijkstra_shortest_path(n, graph, a, b)) return result def solve(t, test_cases): results = [] for i in range(t): n, m, edges, q, queries = test_cases[i] result = process_queries(n, edges, queries) results.append(result) return results"},{"question":"import re from typing import List def checkPasswordStrength(password: str) -> str: Check if a password is strong. A password is considered strong if: 1. It is at least 8 characters long. 2. It has at least one uppercase letter. 3. It has at least one lowercase letter. 4. It has at least one digit. 5. It has at least one special character from - ! @ # % ^ & * Parameters: password (str): The password to be checked. Returns: str: \\"STRONG\\" if the password meets the criteria, otherwise \\"WEAK\\". >>> checkPasswordStrength(\\"Abcdef1!\\") 'STRONG' >>> checkPasswordStrength(\\"Abc1!\\") 'WEAK' >>> checkPasswordStrength(\\"abcdefg1\\") 'WEAK' >>> checkPasswordStrength(\\"ABCDEFG1!\\") 'WEAK' >>> checkPasswordStrength(\\"Abcdefgh!\\") 'WEAK' >>> checkPasswordStrength(\\"Abcdefg1\\") 'WEAK' >>> checkPasswordStrength(\\"A1bcdef!\\") 'STRONG' >>> checkPasswordStrength(\\"abcdefgh1234\\") 'WEAK'","solution":"import re def checkPasswordStrength(password): Check if a password is strong. Parameters: password (str): The password to be checked. Returns: str: \\"STRONG\\" if the password meets the criteria, otherwise \\"WEAK\\". # Check length if len(password) < 8: return \\"WEAK\\" # Define pattern for the checks has_upper = re.search(r'[A-Z]', password) has_lower = re.search(r'[a-z]', password) has_digit = re.search(r'd', password) has_special = re.search(r'[-!@#%^&*]', password) # If all conditions are met, return \\"STRONG\\" if has_upper and has_lower and has_digit and has_special: return \\"STRONG\\" return \\"WEAK\\""},{"question":"def minimum_energy(n: int, deliveries: List[int]) -> int: Compute the minimum energy required for the robot to complete all deliveries and return to the starting point. :param n: Integer, the number of locations :param deliveries: List of integers (0s and 1s) representing locations requiring deliveries :return: Integer, the minimum energy required >>> minimum_energy(7, [0, 1, 0, 0, 1, 0, 0]) 6 >>> minimum_energy(5, [1, 0, 1, 0, 1]) 8 >>> minimum_energy(3, [1, 1, 0]) 4","solution":"def minimum_energy(n, deliveries): Compute the minimum energy required for the robot to complete all deliveries and return to the starting point. :param n: Integer, the number of locations :param deliveries: List of integers (0s and 1s) representing locations requiring deliveries :return: Integer, the minimum energy required first = -1 last = -1 # Find the first and last delivery points for i in range(n): if deliveries[i] == 1: if first == -1: first = i last = i # No deliveries needed if first == -1: return 0 # Minimum energy is 2 * the distance from first to last delivery points return 2 * (last - first)"},{"question":"def longest_palindromic_substring_length(t: int, strings: List[str]) -> List[int]: Vasya has a unique ability to find patterns in strings. One of his favorite tasks is to identify the longest palindromic substring within a given string. A string is called a palindrome if it reads the same from left to right and from right to left. For example, the strings \\"racecar\\", \\"madam\\", and \\"a\\" are palindromes, but the strings \\"hello\\" and \\"abc\\" are not. Vasya decided to play a game using this ability. Given multiple strings, he wants to determine the length of the longest palindromic substring for each string. Help Vasya by writing a function that solves this problem. The function takes an integer t (1 <= t <= 100) — the number of test cases. Then t strings follow (1 <= |s| <= 1000) — the strings for which the longest palindromic substring length must be found. The string consists of English letters only. For each test case, the function returns a list of integers — the length of the longest palindromic substring in each given string. >>> longest_palindromic_substring_length(4, [\\"racecar\\", \\"hello\\", \\"a\\", \\"abcba\\"]) [7, 2, 1, 5]","solution":"def longest_palindromic_substring_length(t, strings): def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 results = [] for s in strings: if len(s) == 0: results.append(0) continue start, end = 0, 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 results.append(end - start + 1) return results"},{"question":"def isSumOfPrimesPrime(N: int) -> str: Given a number N, generate all the prime numbers less than or equal to N and check whether the sum of these prime numbers is also a prime number. >>> isSumOfPrimesPrime(10) \\"Yes\\" >>> isSumOfPrimesPrime(20) \\"No\\" >>> isSumOfPrimesPrime(2) \\"Yes\\" >>> isSumOfPrimesPrime(4) \\"Yes\\" >>> isSumOfPrimesPrime(1) \\"No\\"","solution":"def is_prime(num): if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def isSumOfPrimesPrime(N): primes = [] the_sum = 0 is_prime_list = [True] * (N + 1) is_prime_list[0] = is_prime_list[1] = False for current in range(2, N + 1): if is_prime_list[current]: primes.append(current) the_sum += current for multiple in range(current * current, N + 1, current): is_prime_list[multiple] = False if is_prime(the_sum): return \\"Yes\\" else: return \\"No\\""},{"question":"def smallest_x(a: int, b: int, m: int) -> int: Returns the smallest non-negative integer x that satisfies (a + x) % m == (b + x) % m >>> smallest_x(10, 12, 5) 2 >>> smallest_x(6, 8, 4) 2 >>> smallest_x(15, 20, 10) 5 def solve(test_cases: list) -> list: Processes multiple test cases and returns their respective smallest x values. >>> solve([(10, 12, 5), (6, 8, 4), (15, 20, 10)]) [2, 2, 5]","solution":"def smallest_x(a, b, m): Returns the smallest non-negative integer x that satisfies (a + x) % m == (b + x) % m. # The difference between a and b must be divisible by m return (b - a) % m def solve(test_cases): Processes multiple test cases and returns their respective smallest x values. results = [] for a, b, m in test_cases: results.append(smallest_x(a, b, m)) return results"},{"question":"def calculate_total_weight(T: int, test_cases: List[str]) -> List[int]: Calculate the total weight of each string in the test cases. Each alphabet letter contributes a weight corresponding to its position in the alphabet regardless of case (i.e., 'a' and 'A' both map to 1, 'b' and 'B' both map to 2, etc.), and each digit contributes its numeric value to the weight. >>> calculate_total_weight(2, ['aB2', 'zZ9']) [5, 61] >>> calculate_total_weight(1, ['abcABC']) [12]","solution":"def calculate_total_weight(T, test_cases): results = [] for case in test_cases: total_weight = 0 for ch in case: if ch.isdigit(): total_weight += int(ch) elif ch.isalpha(): total_weight += ord(ch.lower()) - ord('a') + 1 results.append(total_weight) return results"},{"question":"def merge_alternating_characters(A: str, B: str) -> str: Merges two strings A and B by picking characters in alternating order, starting with the first character of A. If one string is exhausted before the other, appends the remaining characters of the non-exhausted string to the end of the merged string. Parameters: - A (str): First input string. - B (str): Second input string. Returns: - str: Merged string. Example: >>> merge_alternating_characters(\\"abc\\", \\"1234\\") 'a1b2c34' >>> merge_alternating_characters(\\"abcd\\", \\"xyz\\") 'axbyczd'","solution":"def mergeAlternatingCharacters(A, B): Merges two strings A and B by picking characters in alternating order, starting with the first character of A. If one string is exhausted before the other, appends the remaining characters of the non-exhausted string to the end of the merged string. Parameters: - A (str): First input string. - B (str): Second input string. Returns: - str: Merged string. len_a, len_b = len(A), len(B) min_len = min(len_a, len_b) result = [] for i in range(min_len): result.append(A[i]) result.append(B[i]) result.append(A[min_len:]) result.append(B[min_len:]) return ''.join(result)"},{"question":"def max_non_overlapping_intervals(intervals): Given a series of N intervals on a number line, each defined by their start and end values, find the maximum number of non-overlapping intervals that can be selected. >>> max_non_overlapping_intervals([(1, 2), (2, 3), (3, 4)]) == 3 >>> max_non_overlapping_intervals([(1, 5), (2, 6), (3, 7)]) == 1 pass def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) intervals = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)] result = max_non_overlapping_intervals(intervals) print(result)","solution":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals. # Sort intervals by their end time intervals.sort(key=lambda x: x[1]) count = 0 prev_end = -1 for start, end in intervals: if start >= prev_end: count += 1 prev_end = end return count def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) intervals = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)] result = max_non_overlapping_intervals(intervals) print(result)"},{"question":"def count_magical_strings(N: int) -> int: Compute the number of Magical strings of length N. A Magical string consists only of characters 'a' and 'b' and does not contain two consecutive 'a's. The result is output modulo 1,000,000,007. >>> count_magical_strings(3) 5 >>> count_magical_strings(4) 8 >>> count_magical_strings(1) 2","solution":"def count_magical_strings(N): Returns the number of Magical strings of length N. A Magical string consists only of characters 'a' and 'b' and does not contain two consecutive 'a's. Result is modulo 1,000,000,007. MOD = 1_000_000_007 # Base Cases: For length 1, there are 2 ('a', 'b') if N == 1: return 2 # Initialize dp arrays dp_a = [0] * (N + 1) # Ending with 'a' dp_b = [0] * (N + 1) # Ending with 'b' # Initial values dp_a[1] = 1 dp_b[1] = 1 # Fill the dp arrays for i in range(2, N + 1): dp_a[i] = dp_b[i - 1] % MOD dp_b[i] = (dp_a[i - 1] + dp_b[i - 1]) % MOD # Total magical strings are those ending with 'a' or 'b' return (dp_a[N] + dp_b[N]) % MOD # Example usage: # print(count_magical_strings(3)) # Should print 5 # print(count_magical_strings(4)) # Should print 8"},{"question":"def product_except_self(nums): Function to return a list where each element is the product of all the elements in the original list except the one at the current index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 2, 3, 4]) [24, 0, 0, 0] >>> product_except_self([1, 0, 3, 0]) [0, 0, 0, 0] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6] >>> product_except_self([1, 2, 3, 0]) [0, 0, 0, 6] >>> product_except_self([1, 2, 3]) [6, 3, 2] >>> product_except_self([]) []","solution":"def product_except_self(nums): Function to return a list where each element is the product of all the elements in the original list except the one at the current index. length = len(nums) if length == 0: return [] # Initialize the answer array answer = [1] * length # Calculate the prefixes product prefix = 1 for i in range(length): answer[i] = prefix prefix *= nums[i] # Calculate the suffixes product and finalize the answer array suffix = 1 for i in range(length - 1, -1, -1): answer[i] *= suffix suffix *= nums[i] return answer"},{"question":"def shortest_subarray_with_sum_at_least_k(nums, k): Returns the length of the shortest subarray with sum at least k. If no such subarray exists, returns -1. >>> shortest_subarray_with_sum_at_least_k([2, 3, 1, 2, 4, 3, 1, 1, 1, 6], 7) 2 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 15) 5 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 16) -1 >>> shortest_subarray_with_sum_at_least_k([10], 10) 1 >>> shortest_subarray_with_sum_at_least_k([5], 10) -1 >>> shortest_subarray_with_sum_at_least_k([-1, -2, -3, -4, -5], -3) 1 >>> shortest_subarray_with_sum_at_least_k([-1, -2, -3, -4, -5], -1) 1 >>> shortest_subarray_with_sum_at_least_k([-1, -2, -3, -4, -5], 0) -1 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, -3, -2, 5, 2, 1, 2, 3], 5) 1 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, -3, -2, 5, 2, 1, 2, 3], 6) 2","solution":"from collections import deque def shortest_subarray_with_sum_at_least_k(nums, k): Returns the length of the shortest subarray with sum at least k. If no such subarray exists, returns -1. n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] result = float('inf') deq = deque() for i in range(n + 1): while deq and prefix_sum[i] - prefix_sum[deq[0]] >= k: result = min(result, i - deq.popleft()) while deq and prefix_sum[i] <= prefix_sum[deq[-1]]: deq.pop() deq.append(i) return result if result != float('inf') else -1"},{"question":"def longestPowerOf2Subseq(arr: List[int]) -> int: Find the length of the longest subsequence such that every element in the subsequence is an increasing power of 2 sequence. >>> longestPowerOf2Subseq([3, 10, 4, 8, 16, 20]) 3 >>> longestPowerOf2Subseq([1, 2, 4, 8, 3, 6, 12]) 4","solution":"def is_power_of_2(x): Helper function to check if a number is a power of 2. return (x != 0) and (x & (x - 1)) == 0 def longestPowerOf2Subseq(arr): Finds the length of the longest subsequence such that every element in the subsequence is an increasing power of 2 sequence. powers_of_2 = [x for x in arr if is_power_of_2(x)] if not powers_of_2: return 0 # Sort the powers_of_2 to ensure increasing sequence powers_of_2.sort() max_length = 1 dp = [1] * len(powers_of_2) for i in range(1, len(powers_of_2)): for j in range(i): if powers_of_2[i] > powers_of_2[j]: dp[i] = max(dp[i], dp[j] + 1) max_length = max(dp) return max_length"},{"question":"def checkPairSum(arr, target): Determines if there are two distinct integers in the array whose sum is equal to the given target. Args: arr: list of integers target: integer Returns: True if there are two distinct integers in the array whose sum equals the target, otherwise False. Examples: >>> checkPairSum([2, 7, 11, 15], 9) True >>> checkPairSum([3, 2, 4], 6) True >>> checkPairSum([3, 3], 6) True >>> checkPairSum([1, 2, 3, 4, 5], 10) False","solution":"def checkPairSum(arr, target): Determines if there are two distinct integers in the array whose sum is equal to the given target. Args: arr: list of integers target: integer Returns: True if there are two distinct integers in the array whose sum equals the target, otherwise False. seen = set() for number in arr: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit from buying and selling a single stock given its price history. If no profit is possible, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit from buying and selling a single stock given its price history. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns an array where each element is the product of all the elements in the input array except the one at the respective index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 3, 4]) [12, 8, 6] >>> product_except_self([0, 0]) [0, 0] >>> product_except_self([1, -1]) [-1, 1]","solution":"def product_except_self(nums): Returns an array where each element is the product of all the elements in the input array except the one at the respective index. length = len(nums) answer = [0]*length left_products = [1]*length right_products = [1]*length for i in range(1, length): left_products[i] = nums[i - 1] * left_products[i - 1] for i in range(length - 2, -1, -1): right_products[i] = nums[i + 1] * right_products[i + 1] for i in range(length): answer[i] = left_products[i] * right_products[i] return answer"},{"question":"from typing import List def numDistinctIslands(grid: List[List[int]]) -> int: Returns the number of distinct islands in the grid. An island is represented as a group of connected land cells (1s). Distinct islands are based on their shapes and disregards their positions. >>> numDistinctIslands([ ... [1, 1, 0, 0, 0], ... [1, 0, 0, 1, 1], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [1, 1, 1, 0, 0] ... ]) == 3 >>> numDistinctIslands([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 1 >>> numDistinctIslands([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 pass","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. An island is represented as a group of connected land cells (1s). Distinct islands are based on their shapes and disregards their positions. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c, r0, c0, path): if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]): return visited[r][c] = True path.append((r - r0, c - c0)) dfs(r + 1, c, r0, c0, path) dfs(r - 1, c, r0, c0, path) dfs(r, c + 1, r0, c0, path) dfs(r, c - 1, r0, c0, path) unique_islands = set() for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: path = [] dfs(r, c, r, c, path) unique_islands.add(tuple(path)) return len(unique_islands)"},{"question":"def isPalindrome(s: str) -> bool: Returns True if the input string is a palindrome (ignoring spaces, punctuation, and capitalization), and False otherwise. >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") == True >>> isPalindrome(\\"racecar\\") == True >>> isPalindrome(\\"hello\\") == False >>> isPalindrome(\\"Was it a car or a cat I saw?\\") == True >>> isPalindrome(\\"No 'x' in Nixon\\") == True","solution":"def isPalindrome(s): Returns True if the input string is a palindrome (ignoring spaces, punctuation, and capitalization), and False otherwise. import re s = re.sub('[^A-Za-z0-9]', '', s).lower() return s == s[::-1]"},{"question":"def minimum_new_edges(datasets: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Calculate the minimum number of new edges required to connect all landmarks. >>> minimum_new_edges([(5, 2, [(1, 2), (3, 4)]), (3, 3, [(1, 2), (2, 3), (3, 1)])]) [2, 0] >>> minimum_new_edges([(4, 0, []), (2, 0, [])]) [3, 1]","solution":"def find_min_new_edges(V, edges): def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) if V == 0: return 0 visited = [False] * (V + 1) adj_list = [[] for _ in range(V + 1)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) components_count = 0 for i in range(1, V + 1): if not visited[i]: components_count += 1 visited[i] = True dfs(i, visited, adj_list) return max(0, components_count - 1) def minimum_new_edges(datasets): results = [] for V, E, edges in datasets: results.append(find_min_new_edges(V, edges)) return results"},{"question":"def determine_winner(scores, N): Determines the winner of the competition based on the described criteria. Parameters: scores (list of list of int): Scores of each participant in each challenge. N (int): Number of challenges. Returns: int: The ID of the winning participant. Example: >>> determine_winner([[50, 90, 85], [85, 90, 80], [50, 90, 85]], 3) 1 >>> determine_winner([[50, 60, 70], [50, 60, 70], [50, 60, 70]], 3) 0 pass # Unit Tests def test_single_participant(): scores = [[70, 80, 90]] N = 3 assert determine_winner(scores, N) == 0 def test_multiple_participants_different_total_scores(): scores = [ [50, 90, 85], [85, 90, 80], [70, 80, 75] ] N = 3 assert determine_winner(scores, N) == 1 def test_multiple_participants_tied_total_scores_different_best_scores(): scores = [ [50, 90, 85], [50, 90, 80], [50, 90, 85] ] N = 3 assert determine_winner(scores, N) == 0 def test_all_tied_scores(): scores = [ [50, 60, 70], [50, 60, 70], [50, 60, 70] ] N = 3 assert determine_winner(scores, N) == 0 def test_edge_case_min_scores(): scores = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] N = 3 assert determine_winner(scores, N) == 0 def test_edge_case_max_scores(): scores = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] N = 3 assert determine_winner(scores, N) == 0 def test_tiebreaker_with_second_highest_score(): scores = [ [90, 85, 80], [85, 90, 85], # Highest sum, same highest individual, higher second-highest [85, 90, 70] # Highest sum, same highest individual, lower second-highest ] N = 3 assert determine_winner(scores, N) == 1","solution":"def determine_winner(scores, N): Determines the winner of the competition based on the described criteria. Parameters: scores (list of list of int): Scores of each participant in each challenge. N (int): Number of challenges. Returns: int: The ID of the winning participant. def sort_key(participant): total_score = sum(participant[1]) return (total_score, sorted(participant[1], reverse=True)) participants_sorted = sorted(enumerate(scores), key=sort_key, reverse=True) winner_id = participants_sorted[0][0] return winner_id"},{"question":"def max_subarray(arr): Given an array of integers, find the maximum sum of a contiguous subarray. Also, return the start and end indices of this subarray. >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 3, 6) >>> max_subarray([1]) (1, 0, 0) >>> max_subarray([-2, -3, -1, -4]) (-1, 2, 2) >>> max_subarray([1, 2, 3, 4]) (10, 0, 3) >>> max_subarray([3, -2, 5, -1]) (6, 0, 2)","solution":"def max_subarray(arr): Returns the maximum sum of a contiguous subarray, along with its start and end indices. n = len(arr) if n == 0: return 0, -1, -1 max_sum = current_sum = arr[0] start = end = s = 0 for i in range(1, n): if current_sum < 0: current_sum = arr[i] s = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = s end = i elif current_sum == max_sum: if i - s < end - start or (i - s == end - start and s < start): start = s end = i return max_sum, start, end"},{"question":"def shortest_path(grid, start, target): Computes the shortest path from the start position to the target position in a grid, avoiding obstacles. Args: grid (List[List[int]]): 2D list representing the grid layout, where 0 is open space and 1 is an obstacle. start (Tuple[int, int]): Tuple representing the starting coordinates (row, column). target (Tuple[int, int]): Tuple representing the target coordinates (row, column). Returns: int: The length of the shortest path, or -1 if the target is unreachable. Examples: >>> grid = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(grid, start, target) 4 >>> grid = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(grid, start, target) 4 >>> grid = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(grid, start, target) -1 >>> grid = [ ... [0, 0, 1], ... [0, 0, 0], ... [1, 0, 0] ... ] >>> start = (1, 1) >>> target = (1, 1) >>> shortest_path(grid, start, target) 0 >>> grid = [ ... [0] * 100 for _ in range(100) ... ] >>> start = (0, 0) >>> target = (99, 99) >>> shortest_path(grid, start, target) 198","solution":"from collections import deque def shortest_path(grid, start, target): if start == target: return 0 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: row, col, dist = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols: if (new_row, new_col) == target: return dist + 1 if grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"def wildcard_match(s: str, p: str) -> str: Determines if the pattern p matches the entire string s. Args: s (str): the input string to match, consisting of lowercase English letters. p (str): the pattern string, consisting of lowercase English letters, '?' and '*'. Returns: str: \\"YES\\" if the pattern matches the entire input string, \\"NO\\" otherwise. >>> wildcard_match(\\"ababab\\", \\"a?ab*\\") \\"YES\\" >>> wildcard_match(\\"abcdefg\\", \\"abc?fg\\") \\"NO\\" >>> wildcard_match(\\"xyz\\", \\"*x\\") \\"NO\\" >>> wildcard_match(\\"abcdefg\\", \\"abc*fg\\") \\"YES\\" >>> wildcard_match(\\"zzzz\\", \\"z*\\") \\"YES\\" >>> wildcard_match(\\"zzzz\\", \\"z*zz\\") \\"YES\\" >>> wildcard_match(\\"hello\\", \\"h?llo\\") \\"YES\\" >>> wildcard_match(\\"hello\\", \\"h*l?\\") \\"YES\\" >>> wildcard_match(\\"hello\\", \\"h?l*a\\") \\"NO\\" >>> wildcard_match(\\"world\\", \\"w*d\\") \\"YES\\"","solution":"def wildcard_match(s, p): Determines if the pattern p matches the entire string s. Args: s (str): the input string to match, consisting of lowercase English letters. p (str): the pattern string, consisting of lowercase English letters, '?' and '*'. Returns: str: \\"YES\\" if the pattern matches the entire input string, \\"NO\\" otherwise. len_s = len(s) len_p = len(p) dp = [[False] * (len_p + 1) for _ in range(len_s + 1)] dp[0][0] = True for j in range(1, len_p + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, len_s + 1): for j in range(1, len_p + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == '?' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return \\"YES\\" if dp[len_s][len_p] else \\"NO\\""},{"question":"def count_paths_through_grid(m: int, n: int, grid: List[List[int]]) -> int: Function to count the number of distinct valid paths from the top-left corner to the bottom-right corner of a grid with obstacles. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :param grid: 2D list representing the grid where 1 indicates blocked cells and 0 indicates free cells. :return: Number of distinct valid paths from (0, 0) to (m-1, n-1). pass # Implement the function here # Test cases def test_count_paths_through_grid(): assert count_paths_through_grid(3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) == 2 assert count_paths_through_grid(3, 3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) == 1 assert count_paths_through_grid(3, 3, [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) == 0 assert count_paths_through_grid(2, 2, [ [0, 0], [0, 0] ]) == 2 assert count_paths_through_grid(4, 4, [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0] ]) == 2 assert count_paths_through_grid(1, 5, [ [0, 0, 0, 0, 0] ]) == 1 assert count_paths_through_grid(5, 1, [ [0], [0], [0], [0], [0] ]) == 1 assert count_paths_through_grid(5, 5, [ [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ]) == 0 if __name__ == \\"__main__\\": test_count_paths_through_grid() print(\\"All tests passed.\\")","solution":"def count_paths_through_grid(m, n, grid): Function to count the number of distinct valid paths from the top-left corner to the bottom-right corner of a grid with obstacles. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :param grid: 2D list representing the grid where 1 indicates blocked cells and 0 indicates free cells. :return: Number of distinct valid paths from (0, 0) to (m-1, n-1). if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def longest_stable_period(operations: List[int]) -> int: Finds the longest continuous period of hours during which the number of active devices remains unchanged. >>> longest_stable_period([]) 0 >>> longest_stable_period([1]) 1 >>> longest_stable_period([1, -1, 1, -1]) 1 >>> longest_stable_period([1, 1, 1, 1, 1]) 5 >>> longest_stable_period([-1, -1, -1, -1, -1]) 5 >>> longest_stable_period([1, -1, 1, 1, -1, -1]) 2 >>> longest_stable_period([1, 1, 1, -1, -1, -1, -1]) 4 >>> longest_stable_period([1, 1, 1, 1, 1, 1]) 6 >>> longest_stable_period([1, 1, -1, 1, 1, -1, -1, 1, 1, 1]) 3 pass","solution":"def longest_stable_period(operations): Finds the longest continuous period of hours during which the number of active devices remains unchanged. Parameters: operations (list of int): List of hourly operations (1 for 'on', -1 for 'off') Returns: int: Length of the longest stable period if not operations: return 0 max_length = 0 current_length = 1 net_change = operations[0] for i in range(1, len(operations)): if operations[i] == operations[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Reset the length for the new constant sequence # Check last sequence length max_length = max(max_length, current_length) return max_length"},{"question":"import itertools from typing import List def generate_derangements(s: str, n: int) -> List[str]: Returns n unique derangements of the string s. A derangement is a permutation of the elements of a set, such that no element appears in its original position. >>> generate_derangements('abc', 2) ['bca', 'cab'] >>> generate_derangements('abcd', 3) ['bcda', 'cadb', 'dbac'] pass def test_generate_derangements(): # Test case 1 result = generate_derangements('abc', 2) assert len(result) == 2 assert len(set(result)) == 2 for derangement in result: assert len(derangement) == len('abc') assert set(derangement) == set('abc') assert all(derangement[i] != 'abc'[i] for i in range(len('abc'))) # Test case 2 result = generate_derangements('abcd', 3) assert len(result) == 3 assert len(set(result)) == 3 for derangement in result: assert len(derangement) == len('abcd') assert set(derangement) == set('abcd') assert all(derangement[i] != 'abcd'[i] for i in range(len('abcd'))) # Test case 3 (edge case with only one character) result = generate_derangements('a', 1) assert len(result) == 0 # No derangement possible for single character # Test case 4 (exact amount of possible derangements) result = generate_derangements('ab', 1) # Only one derangement for 'ab' which is 'ba' assert len(result) == 1 assert result[0] == 'ba' # Test case 5 (more n than possible derangements) result = generate_derangements('ab', 10) # only 1 possible derangement assert len(result) == 1 assert result[0] == 'ba' import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"import itertools def generate_derangements(s, n): Returns n unique derangements of the string s. A derangement is a permutation of the elements of a set, such that no element appears in its original position. def is_derangement(perm, original): for i in range(len(perm)): if perm[i] == original[i]: return False return True permutations = itertools.permutations(s) derangements = [] seen = set() for perm in permutations: if perm not in seen and is_derangement(perm, s): derangements.append(''.join(perm)) seen.add(perm) if len(derangements) == n: break return derangements def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 results = [] for _ in range(t): s = data[index] n = int(data[index + 1]) index += 2 derangements = generate_derangements(s, n) results.append(derangements) for case in results: for derangement in case: print(derangement)"},{"question":"def single_number(nums: List[int]) -> int: Function to find the single number in a list where every other number appears twice. :param nums: List[int] - A list of integers. :return: int - The single number that appears only once in the list. Example: >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1]) 1 >>> single_number([0, 0, -1]) -1 >>> single_number([-2, -2, -3]) -3 >>> single_number([0]) 0","solution":"def single_number(nums): Function to find the single number in a list where every other number appears twice. :param nums: List[int] - A list of integers. :return: int - The single number that appears only once in the list. unique = 0 for num in nums: unique ^= num return unique"},{"question":"def digit_sum_pascal_triangle(m: int): Generates the first m rows of a digit-sum version of Pascal's triangle. Each number in Pascal's triangle is replaced by the sum of its digits. >>> digit_sum_pascal_triangle(1) 1 >>> digit_sum_pascal_triangle(2) 1 1 1 >>> digit_sum_pascal_triangle(3) 1 1 1 1 2 1 >>> digit_sum_pascal_triangle(6) 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 1 1 5 1","solution":"def digit_sum_pascal_triangle(m): def digit_sum(n): return sum(int(x) for x in str(n)) triangle = [[1]] for i in range(1, m): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) for row in triangle: digit_sum_row = [digit_sum(num) for num in row] print(\\" \\".join(map(str, digit_sum_row))) # Example usage # digit_sum_pascal_triangle(6)"},{"question":"def most_popular_product(Q: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: Determine the ID of the most popular product based on the given data. Each test case contains: - N: the number of unique products. - M: the number of purchases. - A list of M pairs of integers U and P, where U denotes the ID of the user and P denotes the ID of the product. >>> most_popular_product(2, [[(5, 6), [(1, 1), (2, 2), (1, 2), (3, 2), (2, 3), (3, 1)]], [(3, 4), [(1, 1), (1, 2), (2, 2), (2, 1)]]]) [2, 1] >>> most_popular_product(1, [[(3, 3), [(1, 1), (2, 1), (3, 1)]]]) [1]","solution":"def most_popular_product(Q, test_cases): result = [] for i in range(Q): N, M = test_cases[i][0] purchases = test_cases[i][1] product_user_mapping = {} for user, product in purchases: if product not in product_user_mapping: product_user_mapping[product] = set() product_user_mapping[product].add(user) max_purchases = -1 most_popular_product_id = -1 for product in range(1, N+1): if product in product_user_mapping: unique_purchases = len(product_user_mapping[product]) if unique_purchases > max_purchases or (unique_purchases == max_purchases and product < most_popular_product_id): max_purchases = unique_purchases most_popular_product_id = product result.append(most_popular_product_id) return result"},{"question":"def longest_consecutive_active_streak(status): Returns the length of the longest consecutive streak of active statuses (1s) in the binary array status. >>> longest_consecutive_active_streak([1, 1, 0, 1, 1, 1, 0, 0, 1, 1]) 3 >>> longest_consecutive_active_streak([0, 0, 0, 0, 0]) 0 >>> longest_consecutive_active_streak([1, 1, 1, 1, 1, 1, 1]) 7 >>> longest_consecutive_active_streak([1]) 1 >>> longest_consecutive_active_streak([0]) 0 >>> longest_consecutive_active_streak([1, 0, 1, 1, 0, 1, 1, 1]) 3 >>> longest_consecutive_active_streak([0, 0, 0, 0, 0, 0]) 0","solution":"def longest_consecutive_active_streak(status): Returns the length of the longest consecutive streak of active statuses (1s) in the binary array status. max_streak = 0 current_streak = 0 for s in status: if s == 1: current_streak += 1 if current_streak > max_streak: max_streak = current_streak else: current_streak = 0 return max_streak"},{"question":"def total_weight_below_threshold(test_cases): Calculate the total weight of deliveries that are strictly less than the threshold. Args: test_cases (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents a test case with keys 'N', 'weights', 'threshold'. Returns: List[int]: A list of integers where each integer represents the total weight of deliveries below the threshold for a test case. Example: test_cases = [{'N': 5, 'weights': [50, 75, 100, 120, 30], 'threshold': 100}] >>> total_weight_below_threshold(test_cases) [155] pass def parse_input(input_str): Parse the input string to extract the test cases. Args: input_str (str): A string representing the input containing multiple test cases. Returns: List[Dict[str, Any]]: A list of dictionaries where each dictionary represents a test case with keys 'N', 'weights', and 'threshold'. Example: input_str = \\"1n5n50 75 100 120 30n100n\\" >>> parse_input(input_str) [{'N': 5, 'weights': [50, 75, 100, 120, 30], 'threshold': 100}] pass","solution":"def total_weight_below_threshold(test_cases): results = [] for case in test_cases: N = case['N'] weights = case['weights'] K = case['threshold'] total_weight = sum(weight for weight in weights if weight < K) results.append(total_weight) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0].strip()) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index].strip()) weights = list(map(int, input_lines[index+1].strip().split())) K = int(input_lines[index+2].strip()) test_cases.append({ 'N': N, 'weights': weights, 'threshold': K }) index += 3 return test_cases"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[str]) -> List[int]: Process a series of queries on an array of integers. Each query performs one of the following operations: 1 x y: Add y to the value at index x. 2 l r k: Return the kth smallest element in the subarray from index l to index r, inclusive. Args: n: Initial size of the array. q: Number of queries. array: The elements of the initial array. queries: A list of queries, each in the format '1 x y' or '2 l r k'. Returns: A list of results for each query of type 2. Example: >>> process_queries(6, 5, [3, 2, 5, 1, 6, 4], [\\"2 0 5 3\\", \\"1 3 3\\", \\"2 1 4 2\\", \\"1 5 -1\\", \\"2 0 5 4\\"]) [3, 4, 4] results = [] for query in queries: parts = query.split() if parts[0] == '1': x = int(parts[1]) y = int(parts[2]) array[x] += y elif parts[0] == '2': l = int(parts[1]) r = int(parts[2]) k = int(parts[3]) subarray = array[l:r + 1] subarray.sort() results.append(subarray[k - 1]) return results # Example test case print(process_queries(6, 5, [3, 2, 5, 1, 6, 4], [\\"2 0 5 3\\", \\"1 3 3\\", \\"2 1 4 2\\", \\"1 5 -1\\", \\"2 0 5 4\\"])) # Output: [3, 4, 4]","solution":"def process_queries(n, q, array, queries): results = [] for query in queries: parts = query.split() if parts[0] == '1': x = int(parts[1]) y = int(parts[2]) array[x] += y elif parts[0] == '2': l = int(parts[1]) r = int(parts[2]) k = int(parts[3]) subarray = array[l:r+1] subarray.sort() results.append(subarray[k - 1]) return results"},{"question":"def find_peak_element(arr: List[int]) -> int: Given an array of integers, return the index of any one of its peak elements. A peak element is an element that is greater than its neighbors. Examples: >>> find_peak_element([1]) 0 >>> find_peak_element([10, 1, 2, 3, 4, 5]) 0 >>> find_peak_element([1, 2, 3, 4, 5, 10]) 5 >>> find_peak_element([1, 3, 20, 4, 1, 0]) 2 >>> find_peak_element([1, 3, 20, 4, 1, 0, 25, 15]) 2 >>> find_peak_element(list(range(10000)) + list(range(9999, -1, -1))) 9999","solution":"def find_peak_element(arr): Returns the index of any one of its peak elements. A peak element is an element that is greater than its neighbors. n = len(arr) if n == 1: return 0 if arr[0] >= arr[1]: return 0 if arr[n - 1] >= arr[n - 2]: return n - 1 for i in range(1, n - 1): if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]: return i"},{"question":"def find_pair(arr, target): Finds a pair of numbers in the array that add up to the target sum. Parameters: arr (list of int): The list of integers to search through. target (int): The target sum. Returns: list of int: A pair of numbers that add up to the target sum or an empty list if no such pair exists. # Your code here # Example usage: arr = [2, 7, 11, 15] target = 9 print(find_pair(arr, target)) # Output: [2, 7] arr = [1, 2, 3, 4] target = 8 print(find_pair(arr, target)) # Output: [] arr = [3, 3, 4, 5] target = 6 print(find_pair(arr, target)) # Output: [3, 3] from solution import find_pair def test_find_pair_with_existing_pair(): arr = [2, 7, 11, 15] target = 9 result = find_pair(arr, target) assert result == [2, 7] or result == [7, 2] def test_find_pair_no_pair(): arr = [1, 2, 3, 4] target = 8 result = find_pair(arr, target) assert result == [] def test_find_pair_empty_array(): arr = [] target = 5 result = find_pair(arr, target) assert result == [] def test_find_pair_multiple_pairs(): arr = [3, 3, 4, 5] target = 6 result = find_pair(arr, target) assert result == [3, 3] def test_find_pair_single_element(): arr = [5] target = 5 result = find_pair(arr, target) assert result == [] def test_find_pair_negative_numbers(): arr = [-1, -2, -3, -4, 1, 4, 3] target = 0 result = find_pair(arr, target) assert result == [-1, 1] or result == [1, -1] def test_find_pair_zero_sum(): arr = [0, 0, -1, 1] target = 0 result = find_pair(arr, target) assert result == [0, 0] def test_find_pair_no_duplicates_needed(): arr = [1, 2, 3, 4, 5] target = 10 result = find_pair(arr, target) assert result == []","solution":"def find_pair(arr, target): Finds a pair of numbers in the array that add up to the target sum. Parameters: arr (list of int): The list of integers to search through. target (int): The target sum. Returns: list of int: A pair of numbers that add up to the target sum or an empty list if no such pair exists. nums_seen = {} for num in arr: complement = target - num if complement in nums_seen: return [complement, num] nums_seen[num] = True return []"},{"question":"def count_distinct_substrings(S: str) -> int: Returns the number of distinct substrings of the string S. >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"ab\\") 3 >>> count_distinct_substrings(\\"aa\\") 2 >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"ababc\\") 12 >>> count_distinct_substrings(\\"\\") 0 >>> count_distinct_substrings(\\"racecar\\") 25 >>> count_distinct_substrings(\\"aaa\\") 3 >>> count_distinct_substrings(\\"banana\\") 15","solution":"def count_distinct_substrings(S): Returns the number of distinct substrings of the string S. substrings = set() n = len(S) # Iterate through all possible substrings for i in range(n): for j in range(i + 1, n + 1): substrings.add(S[i:j]) return len(substrings)"},{"question":"from typing import List def exist(grid: List[List[str]], word: str) -> bool: Given an m x n grid of characters \`grid\` and a string \`word\`, return \`true\` if \`word\` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCCED\\") True >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"SEE\\") True >>> exist([ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], \\"ABCB\\") False","solution":"from typing import List def exist(grid: List[List[str]], word: str) -> bool: # Function to check if the word can be found starting from position (i, j) def dfs(i, j, k): # If the entire word is found if k == len(word): return True # If out of bounds or character does not match or already visited if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[k]: return False # Mark the cell as visited by changing to a non-alphabet character tmp, grid[i][j] = grid[i][j], '#' # Explore all possible directions: up, down, left, right found = (dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)) # Restore the original value back grid[i][j] = tmp return found for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == word[0]: # Optimization to start DFS only if first letter matches if dfs(i, j, 0): return True return False"},{"question":"def has_pair_with_sum(arr, n, t): Determines if there are any two distinct indices i and j in the array such that the sum of the integers at these indices equals the target T. Parameters: arr (list): The list of integers. n (int): The number of elements in the array. t (int): The target sum. Returns: str: \\"YES\\" if such indices exist, otherwise \\"NO\\". pass # Unit tests def test_has_pair_with_sum_example(): assert has_pair_with_sum([1, 2, 3, 4, 5], 5, 9) == \\"YES\\" def test_has_pair_with_sum_no_pair(): assert has_pair_with_sum([1, 2, 3, 4, 5], 5, 10) == \\"NO\\" def test_has_pair_with_sum_single_element(): assert has_pair_with_sum([1], 1, 2) == \\"NO\\" def test_has_pair_with_sum_negative_numbers(): assert has_pair_with_sum([-1, -2, -3, -4, -5], 5, -9) == \\"YES\\" def test_has_pair_with_sum_mixed_numbers(): assert has_pair_with_sum([1, -2, 3, 4, -5], 5, -1) == \\"YES\\" def test_has_pair_with_sum_multiple_pairs(): assert has_pair_with_sum([1, 2, 4, 4], 4, 8) == \\"YES\\" def test_has_pair_with_sum_large_input(): arr = [i for i in range(10001)] assert has_pair_with_sum(arr, 10001, 19999) == \\"YES\\" def test_has_pair_with_sum_duplicate_elements(): assert has_pair_with_sum([1, 1, 1, 1], 4, 2) == \\"YES\\"","solution":"def has_pair_with_sum(arr, n, t): Determines if there are any two distinct indices i and j in the array such that the sum of the integers at these indices equals the target T. Parameters: arr (list): The list of integers. n (int): The number of elements in the array. t (int): The target sum. Returns: str: \\"YES\\" if such indices exist, otherwise \\"NO\\". seen = set() for num in arr: if t - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" # Example Usage # N = 5 # ARR = [1, 2, 3, 4, 5] # T = 9 # print(has_pair_with_sum(ARR, N, T)) # Output: YES"},{"question":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be scheduled. :param events: List of tuples where each tuple contains two integers (start, end) of an event :type events: List[Tuple[int, int]] :return: Maximum number of non-overlapping events :rtype: int >>> max_non_overlapping_events([(1, 3), (2, 5), (4, 6), (6, 8), (9, 10)]) 4 >>> max_non_overlapping_events([(1, 4), (2, 3), (3, 5)]) 2 >>> max_non_overlapping_events([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_events([(1, 5), (2, 6), (4, 8)]) 1 >>> max_non_overlapping_events([(1, 3), (0, 3), (2, 3)]) 1 >>> max_non_overlapping_events([]) 0 # Your code here","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be scheduled. :param events: List of tuples where each tuple contains two integers (start, end) of an event :type events: List[Tuple[int, int]] :return: Maximum number of non-overlapping events :rtype: int if not events: return 0 # Sort events by their end times events.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in events: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def min_students_to_sit(n: int, heights: List[int]) -> int: Determine the minimum number of students who need to sit to ensure that all students have a clear view of the photo. >>> min_students_to_sit(5, [150, 140, 155, 160, 145]) 2 >>> min_students_to_sit(6, [130, 125, 140, 150, 145, 155]) 2","solution":"def min_students_to_sit(n, heights): if not heights: return 0 sit_count = 0 max_height_so_far = heights[0] for i in range(1, n): if heights[i] < max_height_so_far: sit_count += 1 else: max_height_so_far = heights[i] return sit_count"},{"question":"def smallest_fib_greater_equal(N: int) -> int: Returns the smallest Fibonacci number which is greater than or equal to N. >>> smallest_fib_greater_equal(0) 0 >>> smallest_fib_greater_equal(1) 1 >>> smallest_fib_greater_equal(15) 21","solution":"def smallest_fib_greater_equal(N): Returns the smallest Fibonacci number which is greater than or equal to N. if N == 0: return 0 a, b = 0, 1 while b < N: a, b = b, a + b return b"},{"question":"def min_operations_to_merge_characters(test_cases): Find the minimum number of operations required to reduce the entire character line to one character by repeatedly merging the adjacent characters with powers differing by 1. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N and a list of power levels. Returns: List[int]: A list of integers representing the minimum number of operations for each test case. Examples: >>> min_operations_to_merge_characters([(4, [1, 2, 3, 4]), (3, [2, 3, 4]), (5, [1, 3, 5, 7, 9])]) [3, 2, 0] >>> min_operations_to_merge_characters([(4, [1, 3, 5, 7]), (3, [10, 11, 12]), (5, [6, 7, 8, 9, 10])]) [0, 2, 4] >>> min_operations_to_merge_characters([(3, [1, 100, 101]), (4, [50, 51, 52, 53]), (2, [99, 100])]) [1, 3, 1] >>> min_operations_to_merge_characters([(0, [])]) [0] >>> min_operations_to_merge_characters([(1, [1])]) [0]","solution":"def min_operations_to_merge_characters(test_cases): results = [] for n, powers in test_cases: # Convert the powers list to a set for quick lookups power_set = set(powers) operations_count = 0 for power in powers: # Check if there is an adjacent power (either power-1 or power+1) if (power - 1 in power_set) or (power + 1 in power_set): operations_count += 1 power_set.remove(power) # Simulate merge by removing power from set results.append(operations_count) return results"},{"question":"def minimum_total_duration(n: int, durations: List[int]) -> int: Calculate the minimum total duration to turn on all lights at different brightness levels. >>> minimum_total_duration(5, [3, 2, 5, 1, 4]) 15 >>> minimum_total_duration(3, [4, 4, 4]) 12 >>> minimum_total_duration(5, [1, 2, 3, 4, 5]) 15 >>> minimum_total_duration(1, [7]) 7 >>> minimum_total_duration(3, [10, 20, 30]) 60 >>> minimum_total_duration(2, [1000000, 1000000]) 2000000 pass","solution":"def minimum_total_duration(n, durations): This function takes an integer n and a list of durations. It returns the minimum total duration to turn on all lights at different brightness levels. return sum(durations)"},{"question":"def minimal_possible_difference(n: int, skill_levels: List[int]) -> int: Returns the minimal possible absolute difference between the total skill levels of the two teams. Args: n: an integer, representing the number of participants. skill_levels: a list of integers, representing the skill levels of each participant. Returns: An integer, the minimal possible absolute difference between the total skill levels of the two teams. Example: >>> minimal_possible_difference(6, [3, 1, 4, 2, 2, 1]) 1 >>> minimal_possible_difference(1, [5]) 5 >>> minimal_possible_difference(2, [1, 2]) 1 >>> minimal_possible_difference(4, [1, 2, 1, 2]) 0 pass from typing import List # Sample Unit Tests def test_example(): assert minimal_possible_difference(6, [3, 1, 4, 2, 2, 1]) == 1 def test_single_participant(): assert minimal_possible_difference(1, [5]) == 5 def test_two_participants(): assert minimal_possible_difference(2, [1, 2]) == 1 assert minimal_possible_difference(2, [10, 5]) == 5 def test_equal_participants(): assert minimal_possible_difference(4, [1, 2, 1, 2]) == 0 def test_multiple_split_options(): assert minimal_possible_difference(5, [5, 5, 5, 5, 4]) == 4 def test_large_number_of_participants(): assert minimal_possible_difference(8, [2, 3, 7, 4, 8, 10, 1, 5]) == 0 def test_sum_closest_split(): assert minimal_possible_difference(3, [1, 1, 4]) == 2","solution":"def minimal_possible_difference(n, skill_levels): Returns the minimal possible absolute difference between the total skill levels of the two teams. total_sum = sum(skill_levels) # Initialize a dp array where dp[j] is True if a subset with sum j can be made from the skills dp = [False] * (total_sum + 1) dp[0] = True # Update dp array based on each skill level for skill in skill_levels: for i in range(total_sum, skill - 1, -1): dp[i] = dp[i] or dp[i - skill] # Find the minimal possible difference min_diff = float('inf') for i in range(total_sum // 2 + 1): if dp[i]: min_diff = min(min_diff, total_sum - 2 * i) return min_diff # example usage if __name__ == \\"__main__\\": n = 6 skill_levels = [3, 1, 4, 2, 2, 1] print(minimal_possible_difference(n, skill_levels)) # Output: 1"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None class MyQueue: def __init__(self): self.front = None self.rear = None def enqueue(self, x: int): Add an element 'x' to the queue. def dequeue(self) -> int: Remove an element from the front of the queue and return its value. If the queue is empty, return -1.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class MyQueue: def __init__(self): self.front = None self.rear = None def enqueue(self, x): new_node = Node(x) if self.rear is None: self.front = self.rear = new_node return self.rear.next = new_node self.rear = new_node def dequeue(self): if self.front is None: return -1 temp = self.front self.front = temp.next if self.front is None: self.rear = None return temp.data"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestPath(root): Find the length of the longest path from the root node to a leaf node. The path length is measured by the number of edges in the path. If the binary tree is empty, return -1. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> longestPath(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> longestPath(root) 2 >>> longestPath(None) -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestPath(root): if not root: return -1 def findLongestPath(node): if not node: return 0 left_length = findLongestPath(node.left) right_length = findLongestPath(node.right) return max(left_length, right_length) + 1 # Subtracting 1 to convert the number of nodes in the path to number of edges return findLongestPath(root) - 1"},{"question":"def recover_array_from_B(N, B): Given the array B, recover an array A such that the sum of the product of each pair of adjacent elements in A from index 1 to i matches the given values in B. Args: N (int): size of the array A. B (List[int]): array B of size N-1. Returns: List[int]: the recovered array A of size N. Example: >>> recover_array_from_B(3, [2, 5]) [1, 2, 2] >>> recover_array_from_B(4, [7, 8, 9]) [1, 7, 1, 9] pass def process_test_cases(test_cases): Process multiple test cases to recover arrays A from given arrays B. Args: test_cases (List[Tuple[int, List[int]]]): list of tuples with N and array B. Returns: List[List[int]]: list of recovered arrays A corresponding to each test case. Example: >>> process_test_cases([(3, [2, 5]), (4, [7, 8, 9])]) [[1, 2, 2], [1, 7, 1, 9]] pass","solution":"def recover_array_from_B(N, B): Given the array B, recover an array A such that the sum of the product of each pair of adjacent elements in A from index 1 to i matches the given values in B. Args: N (int): size of the array A. B (List[int]): array B of size N-1. Returns: List[int]: the recovered array A of size N. A = [1] # Start with an initial value of 1 for A[0] for i in range(N-1): next_value = B[i] // A[-1] A.append(next_value) return A def process_test_cases(test_cases): results = [] for case in test_cases: N, B = case results.append(recover_array_from_B(N, B)) return results"},{"question":"import math from typing import List, Tuple def minimum_possible_list(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible value of the list you can achieve after any number of operations. >>> minimum_possible_list(2, [(3, [10, 25, 16]), (2, [4, 9])]) [1, 1] >>> minimum_possible_list(1, [(6, [2, 3, 5, 7, 11, 13])]) [1] results = [] for i in range(T): M = cases[i][0] arr = cases[i][1] results.append(min_possible_value(arr)) return results # Add your implementation of min_possible_value function below","solution":"import math from functools import reduce from math import gcd def min_possible_value(arr): Returns the minimum possible value of the list after any number of operations. # If the array contains 1, the smallest element is already 1 if 1 in arr: return 1 # Compute the GCD of the entire list overall_gcd = reduce(gcd, arr) if overall_gcd == 1: return 1 # If overall gcd is greater than 1, apply the square root operation arr = [math.isqrt(x) for x in arr] if 1 in arr: return 1 # Recompute the GCD of the modified list overall_gcd = reduce(gcd, arr) return overall_gcd if overall_gcd <= 1 else 1 def minimum_possible_list(T, cases): results = [] for i in range(T): M = cases[i][0] arr = cases[i][1] results.append(min_possible_value(arr)) return results"},{"question":"def find_motif(dna_sequence: str, motif: str) -> list: Finds all occurrences of the nucleotide motif within the given DNA sequence. Args: dna_sequence (str): The DNA sequence to search within. motif (str): The nucleotide motif to find. Returns: list: A list of starting indices where the motif occurs within the DNA sequence. >>> find_motif(\\"ATCGATCG\\", \\"CGA\\") [2] >>> find_motif(\\"ATCGATCGA\\", \\"CGA\\") [2, 6] >>> find_motif(\\"ATCGATCG\\", \\"TGC\\") [] >>> find_motif(\\"ATCG\\", \\"ATCG\\") [0] >>> find_motif(\\"ATCGATCG\\", \\"GACT\\") [] >>> find_motif(\\"ATATATAT\\", \\"ATA\\") [0, 2, 4] >>> find_motif(\\"GATCGA\\", \\"GA\\") [0, 4]","solution":"def find_motif(dna_sequence, motif): Finds all occurrences of the nucleotide motif within the given DNA sequence. Args: dna_sequence (str): The DNA sequence to search within. motif (str): The nucleotide motif to find. Returns: list: A list of starting indices where the motif occurs within the DNA sequence. occurrences = [] motif_length = len(motif) sequence_length = len(dna_sequence) # Traverse through dna_sequence to find all occurrences of motif for i in range(sequence_length - motif_length + 1): if dna_sequence[i:i + motif_length] == motif: occurrences.append(i) return occurrences"},{"question":"def process_queries(N: int, M: int, array: List[int], queries: List[List[int]]) -> List[int]: Processes M queries on an array of N integers. Parameters: N (int): The number of elements in the array. M (int): The number of queries. array (list): The initial array of integers. queries (list): The list of queries. Returns: list: List of results for the sum queries. >>> process_queries(5, 5, [5, 3, 6, 2, 1], [[2, 1, 3], [1, 2, 8], [2, 2, 4], [1, 5, 10], [2, 1, 5]]) [14, 16, 31] >>> process_queries(1, 2, [3], [[1, 1, 7], [2, 1, 1]]) [7] >>> process_queries(3, 3, [1, 2, 3], [[2, 1, 3], [1, 2, 5], [2, 1, 3]]) [6, 9] >>> process_queries(4, 5, [4, 5, 6, 7], [[1, 1, 10], [1, 2, 20], [1, 3, 30], [1, 4, 40], [2, 1, 4]]) [100]","solution":"def process_queries(N, M, array, queries): Processes M queries on an array of N integers. Parameters: N (int): The number of elements in the array. M (int): The number of queries. array (list): The initial array of integers. queries (list): The list of queries. Returns: list: List of results for the sum queries. results = [] for query in queries: if query[0] == 1: # Update operation u = query[1] - 1 # converting to 0-based index x = query[2] array[u] = x elif query[0] == 2: # Range sum operation l = query[1] - 1 # converting to 0-based index r = query[2] - 1 # converting to 0-based index results.append(sum(array[l:r+1])) return results"},{"question":"def has_pair_with_product(arr: List[int], p: int) -> str: Determines if there is a pair of distinct elements in the array whose product equals p. Args: arr : list of int : the array of integers. p : int : the product value to check. Returns: str : \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_product([2, 4, 6, 8, 10], 16) 'YES' >>> has_pair_with_product([-1, 2, -3, 4], -6) 'YES' >>> has_pair_with_product([1, 2, 3], 7) 'NO' >>> has_pair_with_product([0, 1], 0) 'YES' >>> has_pair_with_product([0, 2], 0) 'YES' >>> has_pair_with_product([1, 2, 3, 4, 5], 20) 'YES' >>> has_pair_with_product([1, 2, 3, 4, 5], 25) 'NO'","solution":"def has_pair_with_product(arr, p): Determines if there is a pair of distinct elements in the array whose product equals p. Args: arr : list of int : the array of integers. p : int : the product value to check. Returns: str : \\"YES\\" if such a pair exists, otherwise \\"NO\\". n = len(arr) seen = set() for element in arr: if element != 0 and p % element == 0: if (p // element) in seen: return \\"YES\\" seen.add(element) return \\"NO\\""},{"question":"def find_intersection(list1, list2): Finds the intersection of two lists of unique integers. Returns a sorted list of integers that appear in both lists. >>> find_intersection([1, 3, 4, 6, 7, 9], [1, 2, 4, 5, 9, 10]) [1, 4, 9] >>> find_intersection([2, 4, 6, 8], [1, 3, 5, 7, 9]) [] >>> find_intersection([10, 20, 30, 40], [15, 20, 25, 30]) [20, 30] >>> find_intersection([], []) [] >>> find_intersection([1, 2, 3], []) [] >>> find_intersection([], [4, 5, 6]) [] >>> find_intersection([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> find_intersection([1000000, 2000000, 3000000], [2000000, 4000000, 1000000]) [1000000, 2000000] >>> find_intersection([1], [1]) [1]","solution":"def find_intersection(list1, list2): Finds the intersection of two lists of unique integers. Returns a sorted list of integers that appear in both lists. # Convert both lists to sets to perform set intersection set1 = set(list1) set2 = set(list2) # Perform intersection operation intersection = set1.intersection(set2) # Return the sorted list of the intersection return sorted(intersection)"},{"question":"def count_palindromic_substrings(s: str) -> int: Compute the number of palindromic substrings in the given string s. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"abcdef\\") 6","solution":"def count_palindromic_substrings(s): This function computes the number of palindromic substrings in the given string s. n = len(s) count = 0 # Create a 2D list to store if s[i:j] is a palindrome dp = [[False]*n for _ in range(n)] # Single letter substrings are palindromes for i in range(n): dp[i][i] = True count += 1 # Check for substrings of length 2 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True count += 1 # Check for substrings of length > 2 for length in range(3, n+1): # length of substring for i in range(n-length+1): j = i+length-1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True count += 1 return count"},{"question":"def next_greater_elements(nums: List[int]) -> List[int]: Returns a list of the next greater element for each integer in the list. If no greater element exists, returns -1 for that position in the list. >>> next_greater_elements([2, 5, 3, 8]) [5, 8, 8, -1] >>> next_greater_elements([1, 3, 2, 4]) [3, 4, 4, -1] >>> next_greater_elements([4, 5, 2, 25]) [5, 25, 25, -1] >>> next_greater_elements([10]) [-1] >>> next_greater_elements([5, 4, 3, 2]) [-1, -1, -1, -1] >>> next_greater_elements([2, 3, 4, 5]) [3, 4, 5, -1] >>> next_greater_elements([4, 4, 4, 4]) [-1, -1, -1, -1] >>> next_greater_elements([]) []","solution":"def next_greater_elements(nums): Returns a list of the next greater element for each integer in the list. If no greater element exists, returns -1 for that position in the list. n = len(nums) result = [-1] * n stack = [] for i in range(n): while stack and nums[stack[-1]] < nums[i]: index = stack.pop() result[index] = nums[i] stack.append(i) return result"},{"question":"def check_contiguous_subsequence(n: int, m: int, grid: List[str], s: str) -> str: Checks if the string \`s\` is a contiguous subsequence in any of the rows of the grid. >>> check_contiguous_subsequence(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"], \\"abc\\") \\"Yes\\" >>> check_contiguous_subsequence(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") \\"No\\" >>> check_contiguous_subsequence(3, 3, [\\"abcde\\", \\"fghij\\", \\"klmno\\"], \\"abc\\") \\"Yes\\" >>> check_contiguous_subsequence(3, 3, [\\"abcde\\", \\"fghij\\", \\"klmno\\"], \\"no\\") \\"Yes\\" >>> check_contiguous_subsequence(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"], \\"\\") \\"Yes\\" >>> check_contiguous_subsequence(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"], \\"ghi\\") \\"Yes\\"","solution":"def check_contiguous_subsequence(n, m, grid, s): Checks if the string \`s\` is a contiguous subsequence in any of the rows of the grid. for row in grid: if s in row: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List def maxTrappedWater(buildings: List[int]) -> int: Calculate the maximum units of rainwater that can be trapped between buildings of various heights. >>> maxTrappedWater([3, 0, 0, 2, 0, 4]) 10 >>> maxTrappedWater([4, 2, 0, 3, 2, 5, 1]) 9 >>> maxTrappedWater([4, 4, 4, 4]) 0 >>> maxTrappedWater([]) 0 >>> maxTrappedWater([5]) 0 >>> maxTrappedWater([2, 1]) 0 >>> maxTrappedWater([0, 7, 1, 4, 6]) 7 >>> maxTrappedWater([6, 5, 4, 3, 2, 1]) 0 >>> maxTrappedWater([1, 2, 3, 4, 5, 6]) 0","solution":"from typing import List def maxTrappedWater(buildings: List[int]) -> int: if not buildings: return 0 n = len(buildings) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = buildings[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], buildings[i]) # Fill right_max array right_max[n - 1] = buildings[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], buildings[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - buildings[i] return trapped_water"},{"question":"def solve_last_problem(t: int, difficulties: List[int]) -> List[str]: Determine who solves the last problem of each cycle given the initial difficulty scores. Args: t (int): Number of test cases. difficulties (List[int]): List of initial difficulty scores. Returns: List[str]: List of programmers who solve the last problem of each cycle for the given difficulties. >>> solve_last_problem(5, [1, 2, 3, 4, 5]) [\\"Alice\\", \\"Charlie\\", \\"Bob\\", \\"Alice\\", \\"Charlie\\"]","solution":"def solve_last_problem(t, difficulties): results = [] for D in difficulties: # The pattern repeats every 3 problems, hence we can use modulo to determine who handles the last problem. if D % 3 == 1: results.append(\\"Alice\\") elif D % 3 == 2: results.append(\\"Charlie\\") else: results.append(\\"Bob\\") return results"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum possible profit from buying and selling a stock once based on the given list of prices. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 def process_test_cases(T: int, test_cases: List[List[int]]) -> List[int]: Process multiple test cases and return the results as a list of maximum profits for each case. >>> process_test_cases(2, [[7, 1, 5, 3, 6, 4], [7, 6, 4, 3, 1]]) == [5, 0] >>> process_test_cases(1, [[1, 2, 3, 4, 5]]) == [4]","solution":"def max_profit(prices): Returns the maximum possible profit from buying and selling a stock once based on the given list of prices. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def process_test_cases(T, test_cases): results = [] for prices in test_cases: results.append(max_profit(prices)) return results"},{"question":"def format_number_with_commas(number_str: str) -> str: Takes a non-empty string of digits representing a number and returns a new string with commas inserted as thousands separators. Example: >>> format_number_with_commas(\\"1234567\\") \\"1,234,567\\" >>> format_number_with_commas(\\"1000\\") \\"1,000\\" >>> format_number_with_commas(\\"1234567890\\") \\"1,234,567,890\\" >>> format_number_with_commas(\\"1\\") \\"1\\" >>> format_number_with_commas(\\"1234\\") \\"1,234\\"","solution":"def format_number_with_commas(number_str): Takes a non-empty string of digits representing a number and returns a new string with commas inserted as thousands separators. return \\"{:,}\\".format(int(number_str))"},{"question":"import heapq from typing import List def min_cost_path(maze: List[List[int]]) -> int: Returns the minimum cost to travel through the maze from the top-left corner to the bottom-right corner. >>> min_cost_path([[1, 2, 2], [4, 5, 6], [7, 8, 1]]) 12 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 2], [1, 1]]) 3 >>> min_cost_path([[1, 1, 5], [2, 1, 1], [3, 1, 1]]) 5 >>> min_cost_path([[1] * 1000 for _ in range(1000)]) 1999 >>> min_cost_path([[1, 1000, 1], [1, 1, 1], [1000, 1, 1]]) 5","solution":"import heapq def min_cost_path(maze): Returns the minimum cost to travel through the maze from the top-left corner to the bottom-right corner. n = len(maze) if n == 0: return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(maze[0][0], 0, 0)] min_cost = [[float('inf')] * n for _ in range(n)] min_cost[0][0] = maze[0][0] while min_heap: current_cost, x, y = heapq.heappop(min_heap) if (x, y) == (n-1, n-1): return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: new_cost = current_cost + maze[nx][ny] if new_cost < min_cost[nx][ny]: min_cost[nx][ny] = new_cost heapq.heappush(min_heap, (new_cost, nx, ny)) return min_cost[n-1][n-1]"},{"question":"def min_horizontal_distance(n, coordinates): Determines the minimum horizontal distance the bird needs to fly to reach the highest peak. Parameters: n (int): Number of points coordinates (list of tuples): List of (x, y) coordinates of the points Returns: int: Minimum horizontal distance to the highest peak pass def process_datasets(data): Processes multiple datasets to determine the minimum horizontal distance for each. Parameters: data (list): List of strings containing the datasets Returns: list: List of results for each dataset pass # Unit tests def test_min_horizontal_distance_example1(): assert min_horizontal_distance(5, [(0, 0), (3, 1), (6, 5), (9, 8), (12, 4)]) == 9 def test_min_horizontal_distance_example2(): assert min_horizontal_distance(3, [(0, 2), (3, 6), (6, 10)]) == 6 def test_min_horizontal_distance_example3(): assert min_horizontal_distance(4, [(0, 0), (2, 3), (4, 7), (8, 10)]) == 8 def test_process_datasets(): input_data = [ \\"5\\", \\"0 0\\", \\"3 1\\", \\"6 5\\", \\"9 8\\", \\"12 4\\", \\"3\\", \\"0 2\\", \\"3 6\\", \\"6 10\\", \\"4\\", \\"0 0\\", \\"2 3\\", \\"4 7\\", \\"8 10\\", \\"0\\" ] expected_output = [9, 6, 8] assert process_datasets(input_data) == expected_output def test_min_horizontal_distance_single_step(): assert min_horizontal_distance(2, [(0, 0), (10, 10)]) == 10 def test_min_horizontal_distance_multiple_steps(): assert min_horizontal_distance(5, [(0, 0), (1, 2), (3, 5), (6, 8), (9, 10)]) == 9","solution":"def min_horizontal_distance(n, coordinates): Determines the minimum horizontal distance the bird needs to fly to reach the highest peak. Parameters: n (int): Number of points coordinates (list of tuples): List of (x, y) coordinates of the points Returns: int: Minimum horizontal distance to the highest peak sorted_by_altitude = sorted(coordinates, key=lambda x: x[1], reverse=True) highest_peak = sorted_by_altitude[0] position = coordinates[0] total_distance = 0 while position != highest_peak: next_positions = [p for p in coordinates if p[1] > position[1]] next_position = min(next_positions, key=lambda x: x[0]) total_distance += abs(next_position[0] - position[0]) position = next_position return total_distance def process_datasets(data): Processes multiple datasets to determine the minimum horizontal distance for each. Parameters: data (list): List of strings containing the datasets Returns: list: List of results for each dataset results = [] index = 0 while index < len(data): n = int(data[index]) if n == 0: break coordinates = [] for _ in range(n): index += 1 x, y = map(int, data[index].split()) coordinates.append((x, y)) results.append(min_horizontal_distance(n, coordinates)) index += 1 return results # Example usage: # input_data = [ # \\"5\\", # \\"0 0\\", \\"3 1\\", \\"6 5\\", \\"9 8\\", \\"12 4\\", # \\"3\\", # \\"0 2\\", \\"3 6\\", \\"6 10\\", # \\"4\\", # \\"0 0\\", \\"2 3\\", \\"4 7\\", \\"8 10\\", # \\"0\\" # ] # print(process_datasets(input_data)) # Output: [9, 6, 8]"},{"question":"from typing import List from collections import Counter import heapq def top_k_frequent(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements from the array. >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1], 1) [1]","solution":"from collections import Counter import heapq def top_k_frequent(arr, k): Returns the k most frequent elements from the array. if k == len(arr): return arr # Build a frequency map count = Counter(arr) # Use a heap to extract the top k frequent elements return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"def isPathExists(n, startX, startY, blocked): Determine if there is a path from the starting point to the bottom-right corner of the grid that avoids all the blocked cells. >>> isPathExists(5, 0, 0, [(1, 2), (2, 1), (3, 3)]) True >>> isPathExists(5, 0, 0, [(1, 0), (1, 1), (0, 1), (4, 4)]) False >>> isPathExists(5, 0, 0, []) True >>> isPathExists(5, 4, 4, [(1, 2), (2, 1), (3, 3)]) True >>> isPathExists(3, 0, 0, [(1, 1), (2, 1), (1, 2)]) False","solution":"def isPathExists(n, startX, startY, blocked): from collections import deque # Directions for Up, Down, Left, Right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] blocked_set = set((bx, by) for bx, by in blocked) target = (n-1, n-1) if (startX, startY) == target: return True # BFS Queue for exploration queue = deque([(startX, startY)]) visited = set((startX, startY)) while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in blocked_set and (nx, ny) not in visited: if (nx, ny) == target: return True queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"def min_flips(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of flips required to ensure that the maximum 1-burst in the binary string is at most k for each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, str]]): List of tuples, each containing an integer k and a binary string s. Returns: List[int]: List of integers, each representing the minimum number of flips required for the corresponding test case. Examples: >>> min_flips(3, [(1, \\"1110101\\"), (2, \\"110011\\"), (0, \\"1010101\\")]) [2, 0, 4] >>> min_flips(2, [(3, \\"111\\"), (2, \\"11011\\")]) [0, 0]","solution":"def min_flips(t, test_cases): results = [] for i in range(t): k = test_cases[i][0] s = test_cases[i][1] # Count clusters of '1's in the string clusters = [] count = 0 for char in s: if char == '1': count += 1 else: if count > 0: clusters.append(count) count = 0 if count > 0: clusters.append(count) # If the maximum cluster length is already less than or equal to k, # no flips are needed if all(cluster <= k for cluster in clusters): results.append(0) continue # Calculate the number of flips needed flips = 0 for cluster in clusters: if cluster > k: flips += cluster - k results.append(flips) return results"},{"question":"def calculate_total_quantities(input_list): Calculates the total quantities sold for each unique item. Args: input_list (list): A list of strings in the format of \\"item_name,quantity\\". Returns: dict: A dictionary where keys are item names and values are the total quantities sold. >>> calculate_total_quantities([\\"apple,10\\", \\"banana,5\\", \\"apple,4\\"]) {\\"apple\\": 14, \\"banana\\": 5} >>> calculate_total_quantities([\\"apple,10\\", \\"banana,5\\", \\"orange,7\\"]) {\\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 7}","solution":"def calculate_total_quantities(input_list): Calculates the total quantities sold for each unique item. Args: input_list (list): A list of strings in the format of \\"item_name,quantity\\". Returns: dict: A dictionary where keys are item names and values are the total quantities sold. total_quantities = {} for item in input_list: name, quantity = item.split(',') quantity = int(quantity) if name in total_quantities: total_quantities[name] += quantity else: total_quantities[name] = quantity return total_quantities"},{"question":"def min_stabilizing_cost(grid: List[List[int]]) -> int: Determine the minimum cost to stabilize a rectangular sub-grid of at least one plot. The arena is built on a rectangular grid of land plots, and each plot has a different cost associated with stabilizing it. The foundation must form a contiguous sub-rectangle on the grid. Args: grid (List[List[int]]): A 2D list where grid[i][j] represents the cost of stabilizing the plot at position (i, j). Returns: int: The minimum cost to stabilize a rectangular sub-grid. Example: grid = [ [2, 4, 1, 5], [3, 2, 7, 6], [4, 8, 3, 2] ] assert min_stabilizing_cost(grid) == 1 grid = [ [3, 3], [3, 1] ] assert min_stabilizing_cost(grid) == 1 grid = [ [10, 15, 20], [15, 18, 25], [5, 10, 5], [10, 10, 10] ] assert min_stabilizing_cost(grid) == 5","solution":"def min_stabilizing_cost(grid): n = len(grid) m = len(grid[0]) min_cost = float('inf') for i in range(n): for j in range(m): min_cost = min(min_cost, grid[i][j]) return min_cost # Example usage: # grid = [ # [2, 4, 1, 5], # [3, 2, 7, 6], # [4, 8, 3, 2] # ] # print(min_stabilizing_cost(grid)) # Output: 1"},{"question":"def substitution_cipher(operation: str, k: int, text: str) -> str: Simulate a basic substitution cipher for encryption and decryption. Args: - operation: 'e' for encryption or 'd' for decryption. - k: the shift value (1 ≤ k ≤ 25). - text: the input text consisting of lowercase English letters and spaces. Returns: - The encrypted or decrypted text. >>> substitution_cipher('e', 3, 'hello world') 'khoor zruog' >>> substitution_cipher('d', 3, 'khoor zruog') 'hello world'","solution":"def substitution_cipher(operation, k, text): Encrypts or decrypts the given text using a substitution cipher with a shift of k. Args: - operation: 'e' for encryption or 'd' for decryption - k: the shift value (1 ≤ k ≤ 25) - text: the input text consisting of lowercase English letters and spaces Returns: - The encrypted or decrypted text result = [] if operation == 'd': k = -k for char in text: if char.isalpha(): shift = (ord(char) - ord('a') + k) % 26 new_char = chr(ord('a') + shift) result.append(new_char) else: result.append(char) return ''.join(result)"},{"question":"def generate_array(N, M): Generates an array of length N such that the absolute difference between any two consecutive elements is divisible by M. def solve(test_cases): Solves multiple test cases to generate arrays based on given N and M. >>> solve([(1, 2)]) == [[1]] >>> solve([(2, 3)]) == [[1, 4]] >>> solve([(3, 1)]) == [[1, 2, 3]] def test_generate_array(): assert generate_array(1, 2) == [1] assert generate_array(2, 3) == [1, 4] assert generate_array(3, 1) == [1, 2, 3] assert generate_array(4, 3) == [1, 4, 7, 10] def test_solve(): test_cases = [(1, 2), (2, 3), (3, 1)] expected = [[1], [1, 4], [1, 2, 3]] assert solve(test_cases) == expected test_cases = [(4, 2), (5, 5)] expected = [[1, 3, 5, 7], [1, 6, 11, 16, 21]] assert solve(test_cases) == expected","solution":"def generate_array(N, M): Generates an array of length N such that the absolute difference between any two consecutive elements is divisible by M. return [i * M + 1 for i in range(N)] def solve(test_cases): results = [] for N, M in test_cases: array = generate_array(N, M) results.append(array) return results"},{"question":"from typing import List, Dict def calculate_overflow_water(test_cases: List[Dict[str, int]]) -> List[int]: Determines the amount of overflow water after a rain session. This function takes a list of test cases, where each test case is a dictionary containing the number of tanks, their capacities, and the total amount of rainwater collected. It returns a list of integers representing the amount of overflow water for each test case. Args: test_cases (List[Dict[str, int]]): A list of dictionaries representing the test cases. Returns: List[int]: A list of integers representing the amount of overflow water for each test case. >>> calculate_overflow_water([{'N': 3, 'capacities': [100, 200, 300], 'R': 600}]) [0] >>> calculate_overflow_water([{'N': 2, 'capacities': [500, 300], 'R': 1000}]) [200] >>> calculate_overflow_water([ {'N': 3, 'capacities': [100, 200, 300], 'R': 600}, {'N': 2, 'capacities': [500, 300], 'R': 1000} ]) [0, 200] def parse_input(data: str) -> (List[Dict[str, int]], int): Parses the input data and returns the test cases and the number of test cases. Args: data (str): A string representing the input data. Returns: Tuple: A tuple containing a list of dictionaries representing the test cases, and an integer T. >>> data = \\"2n3n100 200 300n600n2n500 300n1000n\\" >>> parse_input(data) ([{'N': 3, 'capacities': [100, 200, 300], 'R': 600}, {'N': 2, 'capacities': [500, 300], 'R': 1000}], 2)","solution":"def calculate_overflow_water(test_cases): results = [] for case in test_cases: N, capacities, R = case['N'], case['capacities'], case['R'] total_capacity = sum(capacities) overflow = max(0, R - total_capacity) results.append(overflow) return results def parse_input(data): lines = data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) capacities = list(map(int, lines[index + 1].split())) R = int(lines[index + 2]) test_cases.append({'N': N, 'capacities': capacities, 'R': R}) index += 3 return test_cases, T"},{"question":"def minimal_leaps(a: int, b: int, d: int) -> int: Returns the minimal number of leaps required for the mouse to travel from a to b. >>> minimal_leaps(0, 10, 3) 4 >>> minimal_leaps(5, 20, 6) 3 >>> minimal_leaps(1, 1000000000, 999999) 1001","solution":"def minimal_leaps(a, b, d): Returns the minimal number of leaps required for the mouse to travel from a to b. distance = b - a leaps = distance // d if distance % d != 0: leaps += 1 return leaps"},{"question":"def max_min_loyalty_points(n, k, loyalty_points): Finds the maximum value among the minimum loyalty points of the customers who receive gifts. Parameters: n (int): Number of customers k (int): Number of gifts loyalty_points (list): List of loyalty points of customers Returns: int: Maximum value among the minimum loyalty points of the customers who receive the gifts >>> max_min_loyalty_points(5, 3, [1, 2, 3, 4, 5]) 3 >>> max_min_loyalty_points(6, 2, [10, 20, 30, 40, 50, 60]) 50 >>> max_min_loyalty_points(4, 4, [4, 5, 1, 3]) 1 >>> max_min_loyalty_points(1, 1, [100]) 100 >>> max_min_loyalty_points(5, 3, [7, 7, 7, 7, 7]) 7 >>> max_min_loyalty_points(5, 4, [1, 3, 5, 7, 9]) 3 >>> max_min_loyalty_points(5, 2, [1000000000, 999999999, 888888888, 777777777, 666666666]) 999999999 >>> max_min_loyalty_points(3, 3, [1, 1, 1]) 1","solution":"def max_min_loyalty_points(n, k, loyalty_points): Returns the maximum value among the minimum loyalty points of the customers who receive gifts. Parameters: n (int): Number of customers k (int): Number of gifts loyalty_points (list): List of loyalty points of customers Returns: int: Maximum value among the minimum loyalty points of the customers who receive the gifts loyalty_points.sort(reverse=True) return loyalty_points[k - 1]"},{"question":"class MedianDataStructure: This class implements a data structure that supports inserting, removing, and getting the median of a sequence of integers. Methods: - insert(x: int): Insert an integer \`x\` into the sequence. - remove(x: int): Remove an integer \`x\` from the sequence if it exists. - get_median() -> Union[int, float, str]: Return the median of the current sequence of integers. If the sequence's length is even, the median is the average of the two middle numbers. If the sequence is empty, it returns the string \\"Empty\\". def insert(self, x: int) -> None: pass def remove(self, x: int) -> None: pass def get_median(self) -> 'Union[int, float, str]': pass from pytest import mark @mark.parametrize(\\"operations, expected\\", [ ([ (\\"insert\\", 1), (\\"insert\\", 3), (\\"get_median\\", ), (\\"remove\\", 1), (\\"get_median\\", ), (\\"insert\\", 1) ], [2, 3]) ]) def test_median_operations(operations, expected): ds = MedianDataStructure() result = [] for operation in operations: if operation[0] == 'insert': ds.insert(operation[1]) elif operation[0] == 'remove': ds.remove(operation[1]) elif operation[0] == 'get_median': result.append(ds.get_median()) assert result == expected @mark.parametrize(\\"operations, expected\\", [ ([ (\\"insert\\", 1), (\\"get_median\\",), (\\"remove\\", 1), (\\"get_median\\",) ], [1, \\"Empty\\"]), ]) def test_sequence_becoming_empty(operations, expected): ds = MedianDataStructure() result = [] for operation in operations: if operation[0] == 'insert': ds.insert(operation[1]) elif operation[0] == 'remove': ds.remove(operation[1]) elif operation[0] == 'get_median': result.append(ds.get_median()) assert result == expected @mark.parametrize(\\"operations, expected\\", [ ([ (\\"insert\\", 2), (\\"insert\\", 4), (\\"insert\\", 6), (\\"insert\\", 8), (\\"get_median\\",) ], [5]) ]) def test_median_with_even_numbers_count(operations, expected): ds = MedianDataStructure() result = [] for operation in operations: if operation[0] == 'insert': ds.insert(operation[1]) elif operation[0] == 'remove': ds.remove(operation[1]) elif operation[0] == 'get_median': result.append(ds.get_median()) assert result == expected","solution":"import bisect class MedianDataStructure: def __init__(self): self.data = [] def insert(self, x): bisect.insort(self.data, x) def remove(self, x): if x in self.data: self.data.remove(x) def get_median(self): n = len(self.data) if n == 0: return \\"Empty\\" if n % 2 == 1: return self.data[n // 2] else: mid1 = self.data[n // 2 - 1] mid2 = self.data[n // 2] return (mid1 + mid2) / 2"},{"question":"def min_trips(n: int, k: int, passengers_start: List[int], passengers_dest: List[int]) -> int: Determine the minimum number of trips the railway car must make to transport all passengers to their respective destinations. >>> min_trips(3, 6, [5, 8, 3], [7, 5, 4]) == 3 >>> min_trips(3, 6, [0, 0, 0], [0, 0, 0]) == 0 >>> min_trips(1, 5, [10], [10]) == 2 >>> min_trips(3, 6, [6, 6, 6], [6, 6, 6]) == 3 >>> min_trips(2, 1000, [1000, 2000], [1500, 1500]) == 3 >>> min_trips(3, 5, [10, 0, 0], [0, 5, 5]) == 2","solution":"def min_trips(n, k, passengers_start, passengers_dest): total_passengers = sum(passengers_start) full_trips_needed = total_passengers // k remaining_passengers = total_passengers % k if remaining_passengers > 0: full_trips_needed += 1 return full_trips_needed"},{"question":"def rearrange_list(n: int, arr: List[int]) -> List[int]: Rearranges the given list such that every integer appears at most twice. Parameters: n (int): The number of elements in the list. arr (list): The list of integers. Returns: list: The modified list where every integer appears at most twice. >>> rearrange_list(7, [1, 1, 1, 2, 2, 3, 4, 4]) [1, 1, 2, 2, 3, 4, 4] >>> rearrange_list(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rearrange_list(6, [1, 1, 1, 1, 1, 1]) [1, 1] >>> rearrange_list(10, [3, 3, 3, 1, 2, 2, 2, 1, 4, 4]) [3, 3, 1, 2, 2, 1, 4, 4] >>> rearrange_list(1, [999]) [999] >>> rearrange_list(8, [-1, -1, -1, -2, -2, -2, -3, -3]) [-1, -1, -2, -2, -3, -3] >>> rearrange_list(0, []) []","solution":"def rearrange_list(n, arr): Rearranges the given list such that every integer appears at most twice. Parameters: n (int): The number of elements in the list. arr (list): The list of integers. Returns: list: The modified list where every integer appears at most twice. from collections import Counter count_dict = Counter() result = [] for num in arr: if count_dict[num] < 2: result.append(num) count_dict[num] += 1 return result"},{"question":"def categorize_books(book_purchases): Categorizes and counts the number of purchases for each type of book. Args: book_purchases (list of str): List of book types purchased. Returns: dict: Dictionary with book types as keys and counts as values. >>> categorize_books([\\"fiction\\", \\"comic\\", \\"non-fiction\\", \\"educational\\", \\"comic\\", \\"fiction\\", \\"magazine\\"]) {'fiction': 2, 'non-fiction': 1, 'comic': 2, 'educational': 1, 'magazine': 1} >>> categorize_books([\\"fiction\\", \\"non-fiction\\", \\"comic\\", \\"educational\\", \\"magazine\\"]) {'fiction': 1, 'non-fiction': 1, 'comic': 1, 'educational': 1, 'magazine': 1} >>> categorize_books([\\"comic\\", \\"comic\\", \\"comic\\", \\"comic\\"]) {'fiction': 0, 'non-fiction': 0, 'comic': 4, 'educational': 0, 'magazine': 0} >>> categorize_books([]) {'fiction': 0, 'non-fiction': 0, 'comic': 0, 'educational': 0, 'magazine': 0} >>> categorize_books([\\"fiction\\", \\"comic\\", \\"non-fiction\\", \\"comic\\", \\"comic\\"]) {'fiction': 1, 'non-fiction': 1, 'comic': 3, 'educational': 0, 'magazine': 0}","solution":"def categorize_books(book_purchases): Categorizes and counts the number of purchases for each type of book. Args: book_purchases (list of str): List of book types purchased. Returns: dict: Dictionary with book types as keys and counts as values. book_count = { \\"fiction\\": 0, \\"non-fiction\\": 0, \\"comic\\": 0, \\"educational\\": 0, \\"magazine\\": 0 } for book in book_purchases: if book in book_count: book_count[book] += 1 return book_count"},{"question":"def can_monkey_reach(n: int, d: int, positions: List[int]) -> str: Determines if the monkey can reach the last pillar starting from the first pillar using jumps that are exact multiples of d. :param n: int - the number of pillars :param d: int - the exact jump distance that needs to be a multiple of d :param positions: list of int - positions of the pillars :return: str - \\"YES\\" if the monkey can reach the last pillar, \\"NO\\" otherwise >>> can_monkey_reach(5, 3, [1, 4, 7, 10, 13]) \\"YES\\" >>> can_monkey_reach(4, 5, [1, 3, 6, 8]) \\"NO\\" >>> can_monkey_reach(2, 2, [1, 3]) \\"YES\\" >>> can_monkey_reach(3, 10, [1, 11, 21]) \\"YES\\" >>> can_monkey_reach(3, 7, [1, 14, 29]) \\"NO\\" >>> can_monkey_reach(6, 2, [1, 3, 7, 10, 14, 16]) \\"NO\\" >>> can_monkey_reach(4, 6, [1, 7, 13, 19]) \\"YES\\"","solution":"def can_monkey_reach(n, d, positions): Determines if the monkey can reach the last pillar starting from the first pillar using jumps that are exact multiples of d. :param n: int - the number of pillars :param d: int - the exact jump distance that needs to be a multiple of d :param positions: list of int - positions of the pillars :return: str - \\"YES\\" if the monkey can reach the last pillar, \\"NO\\" otherwise for i in range(n - 1): if (positions[i + 1] - positions[i]) % d != 0: return \\"NO\\" return \\"YES\\""},{"question":"def minimum_sum_of_subarray(n: int, array: List[int], k: int) -> int: Returns the minimum sum of elements in any contiguous subarray of size k. >>> minimum_sum_of_subarray(5, [1, 2, 3, 4, 5], 2) 3 >>> minimum_sum_of_subarray(7, [-1, -2, -3, -4, -5, -6, -7], 3) -18 pass def process_multiple_cases(test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Processes multiple test cases for the minimum_sum_of_subarray function. >>> test_cases = [(5, [1, 2, 3, 4, 5], 2), (7, [-1, -2, -3, -4, -5, -6, -7], 3)] >>> process_multiple_cases(test_cases) [3, -18] pass","solution":"def minimum_sum_of_subarray(n, array, k): Returns the minimum sum of elements in any contiguous subarray of size k. Parameters: n (int): size of the array array (List[int]): the elements of the array k (int): the size of the subarray Returns: int: minimum sum of elements in any contiguous subarray of size k if k > n: raise ValueError(\\"Subarray size k must be less than or equal to the size of the array n.\\") min_sum = float('inf') current_sum = sum(array[:k]) # initial sum of the first k elements min_sum = min(min_sum, current_sum) for i in range(k, n): current_sum += array[i] - array[i - k] min_sum = min(min_sum, current_sum) return min_sum def process_multiple_cases(test_cases): Processes multiple test cases for the minimum_sum_of_subarray function. Parameters: test_cases (List[Tuple[int, List[int], int]]): A list of test cases where each test case is a tuple of (n, array, k). Returns: List[int]: A list of results for each test case. results = [] for n, array, k in test_cases: results.append(minimum_sum_of_subarray(n, array, k)) return results"},{"question":"def max_subgrid_sum(grid, N, k): Returns the maximum sum of any k x k sub-grid within the NxN grid. Parameters: grid (list of list of int): The NxN grid filled with integers. N (int): The size of the grid. k (int): The size of the sub-grid to consider. Returns: int: The maximum sum of any k x k sub-grid. pass def test_max_subgrid_sum_example1(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] N = 4 k = 2 assert max_subgrid_sum(grid, N, k) == 54 def test_max_subgrid_sum_example2(): grid = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] N = 3 k = 3 assert max_subgrid_sum(grid, N, k) == -45 def test_max_subgrid_sum_single_element(): grid = [ [5] ] N = 1 k = 1 assert max_subgrid_sum(grid, N, k) == 5 def test_max_subgrid_sum_size_1_k_2(): grid = [ [1] ] N = 1 k = 2 assert max_subgrid_sum(grid, N, k) == 0 def test_max_subgrid_sum_different_values(): grid = [ [1, 2, -1], [-3, 4, 5], [6, 7, 8] ] N = 3 k = 2 assert max_subgrid_sum(grid, N, k) == 24 def test_max_subgrid_sum_large_values(): grid = [ [10**5, 10**5], [10**5,10**5] ] N = 2 k = 2 assert max_subgrid_sum(grid, N, k) == 4 * 10**5","solution":"def max_subgrid_sum(grid, N, k): Returns the maximum sum of any k x k sub-grid within the NxN grid. Parameters: grid (list of list of int): The NxN grid filled with integers. N (int): The size of the grid. k (int): The size of the sub-grid to consider. Returns: int: The maximum sum of any k x k sub-grid. if N == 0 or k > N: return 0 # Create a prefix sum matrix prefix_sum = [[0] * (N + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, N + 1): prefix_sum[i][j] = grid[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] max_sum = float('-inf') for i in range(k, N + 1): for j in range(k, N + 1): total = (prefix_sum[i][j] - prefix_sum[i - k][j] - prefix_sum[i][j - k] + prefix_sum[i - k][j - k]) max_sum = max(max_sum, total) return max_sum"},{"question":"def categorize_products(t, test_cases): Categorizes products into different price ranges within each category and counts the number of products in each range. t: int, number of test cases test_cases: list, each entry in the list is a tuple with two elements: - an integer representing number of products - a list of tuples, each containing a string (category name) and an integer (price) Returns a list of dictionaries, each dictionary representing the price range counts for each category in each test case. Example: >>> categorize_products(2, [ (5, [('electronics', 10), ('electronics', 20), ('clothing', 15), ('clothing', 55), ('clothing', 100)]), (4, [('books', 15), ('books', 25), ('books', 99), ('books', 105)]) ]) [ { 'electronics': {'Cheap': 1, 'Moderate': 1, 'Expensive': 0, 'Luxury': 0}, 'clothing': {'Cheap': 1, 'Moderate': 0, 'Expensive': 1, 'Luxury': 1} }, { 'books': {'Cheap': 1, 'Moderate': 1, 'Expensive': 1, 'Luxury': 1} } ]","solution":"def categorize_products(t, test_cases): Categorizes products into different price ranges within each category and counts the number of products in each range. t: int, number of test cases test_cases: list, each entry in the list is a tuple with two elements: - an integer representing number of products - a list of tuples, each containing a string (category name) and an integer (price) Returns a list of dictionaries, each dictionary representing the price range counts for each category in each test case. results = [] price_ranges = { 'Cheap': (0, 19), 'Moderate': (20, 50), 'Expensive': (51, 99), 'Luxury': (100, float('inf')), } for i in range(t): n, products = test_cases[i] category_counts = {} for category, price in products: if category not in category_counts: category_counts[category] = { 'Cheap': 0, 'Moderate': 0, 'Expensive': 0, 'Luxury': 0 } for range_name, (lower, upper) in price_ranges.items(): if lower <= price <= upper: category_counts[category][range_name] += 1 break results.append(category_counts) return results"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def minimum_travel_time(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum time required to travel from Node 1 to Node N in a directed acyclic graph. Parameters: N (int): Number of nodes M (int): Number of edges edges (List[Tuple[int, int, int]]): List of edges represented as tuples (u, v, weight) Returns: int: Minimum time required to travel from Node 1 to Node N, or -1 if not possible. >>> minimum_travel_time(5, 6, [(1, 2, 5), (2, 3, 10), (1, 3, 15), (3, 4, 7), (2, 5, 9), (4, 5, 3)]) 14 >>> minimum_travel_time(2, 1, [(1, 2, 10)]) 10 >>> minimum_travel_time(4, 2, [(1, 2, 5), (3, 4, 7)]) -1","solution":"import heapq from collections import defaultdict def minimum_travel_time(N, M, edges): def dijkstra(start, end): distances = {node: float('inf') for node in range(1, N + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 graph = defaultdict(list) for u, v, weight in edges: graph[u].append((v, weight)) return dijkstra(1, N)"},{"question":"def min_deletions_to_balance(S: str) -> int: Determine the minimum number of deletions required to make the sequence balanced. A sequence is considered balanced if it contains an equal number of 'X' and 'Y' characters. Args: S (str): The input string composed of 'X' and 'Y' characters. Returns: int: The minimum number of deletions needed to balance the sequence. Examples: >>> min_deletions_to_balance('XXXY') 2 >>> min_deletions_to_balance('XYY') 1 from solution import min_deletions_to_balance def test_equal_X_Y(): assert min_deletions_to_balance('XYXY') == 0 assert min_deletions_to_balance('XXYY') == 0 def test_more_X_than_Y(): assert min_deletions_to_balance('XXXY') == 2 assert min_deletions_to_balance('XXXXXYY') == 3 def test_more_Y_than_X(): assert min_deletions_to_balance('YYXXY') == 1 assert min_deletions_to_balance('YYYYXX') == 2 def test_all_X(): assert min_deletions_to_balance('XXXX') == 4 assert min_deletions_to_balance('X') == 1 def test_all_Y(): assert min_deletions_to_balance('YYYYY') == 5 assert min_deletions_to_balance('Y') == 1 def test_minimum_length(): assert min_deletions_to_balance('X') == 1 assert min_deletions_to_balance('Y') == 1 def test_long_balanced_string(): assert min_deletions_to_balance('XY' * (10**5)) == 0","solution":"def min_deletions_to_balance(S): This function calculates the minimum number of deletions required to make the string S balanced, where a balanced string contains equal number of 'X' and 'Y' characters. count_X = S.count('X') count_Y = S.count('Y') # The number of deletions needed to balance the string is the absolute difference # between the number of 'X' and 'Y' characters. return abs(count_X - count_Y) # Example usage: # print(min_deletions_to_balance('XXXY')) # Expected output: 2"},{"question":"def minimumInteractions(n: int) -> int: Return the minimum number of interactions required for all computers to communicate with each other. Parameters: n (int): the number of computers Returns: int: the minimum number of interactions required Example: >>> minimumInteractions(4) 6 >>> minimumInteractions(10) 45","solution":"def minimumInteractions(n): Return the minimum number of interactions required for all computers to communicate with each other. Parameters: n (int): the number of computers Returns: int: the minimum number of interactions required if n <= 1: return 0 return n * (n - 1) // 2"},{"question":"def temperature_variation(datasets): Compute the temperature variation for each day in the provided datasets. Each variation is the sum of absolute differences in hourly temperature readings for a day. Parameters: datasets (List[Tuple[int, List[int]]]): A list of datasets where each dataset is a tuple. The first element of the tuple is the number of days (int). The second element is a list containing the number of temperature readings for each day followed by the actual readings (List[int]). Returns: List[int]: A list of temperature variations for each day. Example: >>> temperature_variation([ ... (2, 5, 20, 21, 19, 22, 20, 3, 15, 18, 15), ... (0,) ... ]) [8, 6] >>> temperature_variation([ ... (1, 4, 10, 20, 30, 40), ... (0,) ... ]) [30]","solution":"def temperature_variation(datasets): variations = [] for data in datasets: d = data[0] if d == 0: break index = 1 for _ in range(d): h = data[index] readings = data[index + 1:index + 1 + h] variation = sum(abs(readings[i] - readings[i - 1]) for i in range(1, h)) variations.append(variation) index += h + 1 return variations"},{"question":"def alternate_case(s: str) -> str: Returns a new string with the case of each letter in the input string s swapped. Only the case of alphabetic characters should be swapped; other characters should remain unchanged. An empty string should return an empty string. Examples: >>> alternate_case(\\"Hello World\\") 'hELLO wORLD' >>> alternate_case(\\"1234!@#\\") '1234!@#' >>> alternate_case(\\"aBcDeF123\\") 'AbCdEf123'","solution":"def alternate_case(s): Returns a new string with the case of each letter in the input string s swapped. return ''.join([char.lower() if char.isupper() else char.upper() for char in s])"},{"question":"def max_sum_of_subarray_of_length_k(n: int, k: int, arr: List[int]) -> int: Finds the maximum sum of any contiguous subarray of length exactly k. Args: n : int : Length of the sequence k : int : Length of the subarrays arr : list of int : The sequence of integers Returns: int : The maximum sum of any contiguous subarray of length k pass def test_max_sum_of_subarray_of_length_k_example(): assert max_sum_of_subarray_of_length_k(5, 3, [1, -2, 3, 4, -1]) == 6 def test_max_sum_of_subarray_of_length_k_negative(): assert max_sum_of_subarray_of_length_k(5, 2, [-1, -2, -3, -4, -5]) == -3 def test_max_sum_of_subarray_of_length_k_all_positive(): assert max_sum_of_subarray_of_length_k(5, 2, [1, 2, 3, 4, 5]) == 9 def test_max_sum_of_subarray_of_length_k_mixed(): assert max_sum_of_subarray_of_length_k(7, 4, [4, -1, 2, 1, -5, 4, -3]) == 6 def test_max_sum_of_subarray_of_length_k_single(): assert max_sum_of_subarray_of_length_k(1, 1, [10]) == 10 def test_max_sum_of_subarray_of_length_k_small_k(): assert max_sum_of_subarray_of_length_k(3, 2, [1, 2, 3]) == 5 def test_max_sum_of_subarray_of_length_k_large_n(): assert max_sum_of_subarray_of_length_k(100000, 1, list(range(100000))) == 99999","solution":"def max_sum_of_subarray_of_length_k(n, k, arr): Finds the maximum sum of any contiguous subarray of length exactly k. Args: n : int : Length of the sequence k : int : Length of the subarrays arr : list of int : The sequence of integers Returns: int : The maximum sum of any contiguous subarray of length k # Initialize the sum of the first subarray of length k. current_sum = sum(arr[:k]) max_sum = current_sum # Use sliding window technique to find the maximum sum of subarray of length k. for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def longest_subarray_with_limit(arr: List[int], k: int) -> int: Returns the length of the longest contiguous subarray such that the difference between the maximum and minimum element in that subarray does not exceed k. >>> longest_subarray_with_limit([1, 3, 2, 6, 4, 6, 8], 2) 3 >>> longest_subarray_with_limit([5, 5, 5, 5, 5], 0) 5 >>> longest_subarray_with_limit([10], 100) 1 >>> longest_subarray_with_limit([1, 10, 1, 10, 1, 10], 0) 1 >>> longest_subarray_with_limit([1, 2, 3, 4, 5], 4) 5 >>> longest_subarray_with_limit([1, 5, 9, 14, 20], 100) 5 >>> longest_subarray_with_limit([1000000000, 999999999, 999999998, 1000000001], 5) 4","solution":"def longest_subarray_with_limit(arr, k): Returns the length of the longest contiguous subarray such that the difference between the maximum and minimum element in that subarray does not exceed k. from collections import deque if not arr: return 0 min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right in range(len(arr)): while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() min_deque.append(right) while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"def min_operations_to_equal_elements(n: int, array: List[int]) -> int: Calculate the minimum number of operations needed to make all elements of the array equal by either incrementing or decrementing selected pairs of elements. >>> min_operations_to_equal_elements(4, [2, 2, 3, 3]) 2 >>> min_operations_to_equal_elements(3, [1, 2, 3]) 2 >>> min_operations_to_equal_elements(1, [5]) 0 >>> min_operations_to_equal_elements(5, [7, 7, 7, 7, 7]) 0 >>> min_operations_to_equal_elements(4, [-1, -2, -3, -4]) 4 >>> min_operations_to_equal_elements(6, [-1000000000, 1000000000, 0, 0, 500000000, -500000000]) 3000000000 >>> min_operations_to_equal_elements(4, [1, 2, 2, 3]) 2 >>> min_operations_to_equal_elements(5, [1, 1, 2, 2, 2]) 2","solution":"def min_operations_to_equal_elements(n, array): sorted_array = sorted(array) median = sorted_array[n // 2] # Using median minimizes the sum of absolute deviations operations = sum(abs(x - median) for x in array) return operations"},{"question":"def min_supply_stations(n: int, roads: List[Tuple[int, int]]) -> int: Calculate the minimum number of supply stations required to ensure that all cities have access to them. Args: n (int): The number of cities. roads (List[Tuple[int, int]]): List of tuples representing roads connecting the cities. Returns: int: Minimum number of supply stations required. Examples: >>> min_supply_stations(4, [(1, 2), (2, 3), (3, 4)]) 2 >>> min_supply_stations(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 2 pass","solution":"def min_supply_stations(n, roads): from collections import defaultdict # Edge case for a single city if n == 1: return 1 # Build adjacency list for the tree tree = defaultdict(list) for u, v in roads: tree[u].append(v) tree[v].append(u) # DP arrays supply_here = [0] * (n + 1) no_supply = [0] * (n + 1) visited = [False] * (n + 1) def dfs(node): visited[node] = True supply_node = 1 # we place a station here no_supply_node = 0 # compute this if no station here for nei in tree[node]: if not visited[nei]: dfs(nei) supply_node += min(supply_here[nei], no_supply[nei]) no_supply_node += supply_here[nei] supply_here[node] = supply_node no_supply[node] = no_supply_node # Start DFS from node 1 (assuming nodes are 1-indexed) dfs(1) # Return the minimum of having a supply station at root or not return min(supply_here[1], no_supply[1])"},{"question":"def longest_palindrome(s: str) -> str: Write a function to find the longest palindrome in a given string. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). If there are multiple palindromes of the same length, return the one that appears first in the string. >>> longest_palindrome(\\"a\\") == \\"a\\" >>> longest_palindrome(\\"babad\\") == \\"bab\\" or longest_palindrome(\\"babad\\") == \\"aba\\" >>> longest_palindrome(\\"A man, a plan, a canal, Panama\\") == \\"amanaplanacanalpanama\\" >>> longest_palindrome(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" >>> longest_palindrome(\\"racecar\\") == \\"racecar\\" >>> longest_palindrome(\\"abc\\") == \\"a\\"","solution":"def longest_palindrome(s): Returns the longest palindrome in the given string. def preprocess_string(s): return ''.join(c.lower() for c in s if c.isalnum()) def is_palindrome(subs): return subs == subs[::-1] s = preprocess_string(s) n = len(s) longest = \\"\\" for i in range(n): for j in range(i, n): subs = s[i:j+1] if is_palindrome(subs) and len(subs) > len(longest): longest = subs return longest"},{"question":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) self.build(array) def build(self, array): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = array[i] # Construct the segment tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update the leaf node pos += self.n self.tree[pos] = value # Update the rest of the tree while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, l, r): Return the sum of elements in the range [l, r). l += self.n r += self.n sum_val = 0 while l < r: if l % 2: sum_val += self.tree[l] l += 1 if r % 2: r -= 1 sum_val += self.tree[r] l //= 2 r //= 2 return sum_val def process_input(N, Q, array, operations): Manage an array and perform update and query operations >>> process_input(5, 3, [5, 2, 4, 7, 10], [[2, 1, 3], [1, 2, 8], [2, 2, 4]]) [11, 19] >>> process_input(3, 2, [5, 5, 5], [[1, 1, 10], [2, 1, 3]]) [20] seg_tree = SegmentTree(array) result = [] for operation in operations: if operation[0] == 1: _, x, y = operation seg_tree.update(x - 1, y) # 1-based to 0-based index elif operation[0] == 2: _, l, r = operation result.append(seg_tree.query(l - 1, r)) # 1-based to 0-based index return result","solution":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) self.build(array) def build(self, array): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = array[i] # Construct the segment tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update the leaf node pos += self.n self.tree[pos] = value # Update the rest of the tree while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, l, r): # sum on interval [l, r) l += self.n r += self.n sum_val = 0 while l < r: if l % 2: sum_val += self.tree[l] l += 1 if r % 2: r -= 1 sum_val += self.tree[r] l //= 2 r //= 2 return sum_val def process_input(N, Q, array, operations): seg_tree = SegmentTree(array) result = [] for operation in operations: if operation[0] == 1: _, x, y = operation seg_tree.update(x - 1, y) # 1-based to 0-based index elif operation[0] == 2: _, l, r = operation result.append(seg_tree.query(l - 1, r)) # 1-based to 0-based index return result"},{"question":"def generate_key_strings(S, K): Returns the first K key strings generated by rotating the original string S. Parameters: S (str): The original string. K (int): The number of key strings to generate. Returns: list of str: The first K key strings. >>> generate_key_strings(\\"abcdef\\", 3) [\\"bcdefa\\", \\"cdefab\\", \\"defabc\\"] >>> generate_key_strings(\\"xyz\\", 2) [\\"yzx\\", \\"zxy\\"] def process_test_cases(test_cases): Processes multiple test cases. Parameters: test_cases (list of tuples): Each tuple contains a string S and an integer K. Returns: list of lists: Each inner list contains the first K key strings for the corresponding test case. >>> process_test_cases([(\\"abcdef\\", 3), (\\"xyz\\", 2)]) [ [\\"bcdefa\\", \\"cdefab\\", \\"defabc\\"], [\\"yzx\\", \\"zxy\\"] ]","solution":"def generate_key_strings(S, K): Returns the first K key strings generated by rotating the original string S. key_strings = [] for i in range(K): # Rotate the string by one character to the left S = S[1:] + S[0] key_strings.append(S) return key_strings def process_test_cases(test_cases): Processes multiple test cases. Parameters: test_cases (list of tuples): Each tuple contains a string S and an integer K. Returns: list of lists: Each inner list contains the first K key strings for the corresponding test case. results = [] for S, K in test_cases: results.append(generate_key_strings(S, K)) return results"},{"question":"def find_min_in_subarray(arr, queries): For each query, find the minimum value in the specified subarray. >>> find_min_in_subarray([5, 2, 4, 7, 1, 3, 6, 8], [(0, 4), (3, 6), (1, 5), (2, 2), (3, 7)]) [1, 1, 1, 4, 1] >>> find_min_in_subarray([10], [(0, 0)]) [10] >>> find_min_in_subarray([15, 3, 25, 1, 9], [(0, 4)]) [1] >>> find_min_in_subarray([5, 5, 5, 5, 5, 5], [(0, 5), (2, 4), (1, 3)]) [5, 5, 5] >>> find_min_in_subarray([9, 3, 8, 6, 2, 5, 1, 7, 4], [(1, 3), (4, 7), (0, 8)]) [3, 1, 1]","solution":"def find_min_in_subarray(arr, queries): For each query, find the minimum value in the specified subarray. Parameters: arr (list): List of integers representing the array. queries (list of tuples): List of tuples where each tuple represents a query (L, R). Returns: list: List of integers representing the minimum values for each query. results = [] for L, R in queries: min_value = min(arr[L:R+1]) results.append(min_value) return results"},{"question":"def circular_array_operations(N, M, operations): Perform operations on a circular array and return the results of sum operations. Args: N: int - The number of elements in the array. M: int - The number of operations. operations: List of tuples, where each tuple represents an operation. Returns: List[int] - Results of each sum operation. arr = [0] * N results = [] for operation in operations: if operation[0] == 1: # Increment operation _, L, R, X = operation for i in range(L-1, R): arr[i] += X elif operation[0] == 2: # Sum operation _, L, R = operation results.append(sum(arr[L-1:R])) return results Test Cases: from solution import circular_array_operations def test_single_increment_single_sum(): operations = [(1, 1, 3, 10), (2, 1, 3)] assert circular_array_operations(5, 2, operations) == [30] def test_multiple_increments_multiple_sums(): operations = [ (1, 1, 3, 10), (2, 1, 3), (1, 2, 5, 5), (2, 1, 3), (2, 2, 4), (1, 1, 5, 2) ] assert circular_array_operations(5, 6, operations) == [30, 40, 35] def test_no_operations(): operations = [] assert circular_array_operations(5, 0, operations) == [] def test_increment_entire_array(): operations = [ (1, 1, 5, 7), (2, 1, 5) ] assert circular_array_operations(5, 2, operations) == [35] def test_multiple_sums(): operations = [ (1, 1, 2, 3), (2, 1, 2), (2, 2, 2), (2, 1, 1) ] assert circular_array_operations(3, 4, operations) == [6, 3, 3]","solution":"def circular_array_operations(N, M, operations): Perform operations on a circular array and return the results of sum operations. Args: N: int - The number of elements in the array. M: int - The number of operations. operations: List of tuples, where each tuple represents an operation. Returns: List[int] - Results of each sum operation. arr = [0] * N results = [] for operation in operations: if operation[0] == 1: # Increment operation _, L, R, X = operation for i in range(L-1, R): arr[i] += X elif operation[0] == 2: # Sum operation _, L, R = operation results.append(sum(arr[L-1:R])) return results"},{"question":"def shortest_distance_to_house(n, m, grid): Find the shortest distance from any land cell ('0') to the nearest house cell ('1'). Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[str]]): The 2D grid representing the map. Returns: int: The shortest distance from any land cell to the nearest house cell, or -1 if no such distance exists. >>> shortest_distance_to_house(3, 3, [\\"001\\", \\"010\\", \\"000\\"]) 1 >>> shortest_distance_to_house(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) -1 import pytest from your_completed_solution import shortest_distance_to_house def test_example_1(): grid = [ \\"001\\", \\"010\\", \\"000\\" ] assert shortest_distance_to_house(3, 3, grid) == 1 def test_example_2(): grid = [ \\"111\\", \\"111\\", \\"111\\" ] assert shortest_distance_to_house(3, 3, grid) == -1 def test_no_land_cells(): grid = [ \\"111\\", \\"111\\", \\"111\\" ] assert shortest_distance_to_house(3, 3, grid) == -1 def test_no_house_cells(): grid = [ \\"000\\", \\"000\\", \\"000\\" ] assert shortest_distance_to_house(3, 3, grid) == -1 def test_large_grid(): grid = [ \\"00000\\", \\"00100\\", \\"00010\\", \\"00000\\", \\"00000\\" ] assert shortest_distance_to_house(5, 5, grid) == 1 def test_all_land_cells(): grid = [ \\"0000\\", \\"0000\\", \\"0000\\" ] assert shortest_distance_to_house(3, 4, grid) == -1 def test_corner_case(): grid = [ \\"1000\\", \\"0001\\", \\"0000\\" ] assert shortest_distance_to_house(3, 4, grid) == 1 def test_complex_case(): grid = [ \\"0101\\", \\"1010\\", \\"0101\\" ] assert shortest_distance_to_house(3, 4, grid) == 1","solution":"from collections import deque def shortest_distance_to_house(n, m, grid): Function to find the shortest distance from any land cell ('0') to the nearest house cell ('1'). Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[str]]): The 2D grid representing the map. Returns: int: The shortest distance from any land cell to the nearest house cell, or -1 if no such distance exists. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Create a queue for BFS and set for visited nodes queue = deque() visited = set() # Initialize the queue with all house locations for i in range(n): for j in range(m): if grid[i][j] == '1': # House queue.append((i, j, 0)) # (row, col, distance) visited.add((i, j)) # If no houses, return -1 if not queue: return -1 shortest_distance = float('inf') # Perform BFS while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '0': # If it's a land cell shortest_distance = min(shortest_distance, dist + 1) visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return shortest_distance if shortest_distance != float('inf') else -1"},{"question":"def is_almost_palindrome(s: str) -> bool: Checks if the given string can become a palindrome by removing at most one character. >>> is_almost_palindrome(\\"abca\\") True >>> is_almost_palindrome(\\"racecar\\") True >>> is_almost_palindrome(\\"hello\\") False >>> is_almost_palindrome(\\"deified\\") True >>> is_almost_palindrome(\\"radarx\\") True >>> is_almost_palindrome(\\"Aba\\") True >>> is_almost_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_almost_palindrome(\\"Able , was I saw eLba\\") True >>> is_almost_palindrome(\\"No 'x' in Nixon\\") True >>> is_almost_palindrome(\\"a\\") True >>> is_almost_palindrome(\\"ab\\") True >>> is_almost_palindrome(\\"abc\\") False >>> is_almost_palindrome(\\"\\") True","solution":"def is_almost_palindrome(s: str) -> bool: Checks if the given string can become a palindrome by removing at most one character. def is_palindrome_range(i, j): Helper function to check if the part of the string from index i to j is a palindrome. while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True s = ''.join([c.lower() for c in s if c.isalnum()]) i, j = 0, len(s) - 1 while i < j: if s[i] != s[j]: return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1) i += 1 j -= 1 return True"},{"question":"def min_operations_to_all_ones(n: int, s: str) -> int: Returns the minimum number of operations required to transform the binary string s into a string where all characters are '1'. >>> min_operations_to_all_ones(5, \\"11001\\") 3 >>> min_operations_to_all_ones(4, \\"0000\\") 1 >>> min_operations_to_all_ones(3, \\"111\\") 0 >>> min_operations_to_all_ones(5, \\"11111\\") 0 >>> min_operations_to_all_ones(1, \\"0\\") 1 >>> min_operations_to_all_ones(1, \\"1\\") 0 >>> min_operations_to_all_ones(6, \\"101010\\") 6 >>> min_operations_to_all_ones(6, \\"010101\\") 6 >>> min_operations_to_all_ones(10, \\"1110001110\\") 4 >>> min_operations_to_all_ones(10, \\"0000000000\\") 1","solution":"def min_operations_to_all_ones(n, s): Returns the minimum number of operations required to transform the binary string s into a string where all characters are '1'. operations = 0 # traverse the binary string for i in range(1, n): if s[i] != s[i-1]: operations += 1 # we always need one additional operation for the last segment # If string has at least one '0' if '0' in s: operations += 1 return operations"},{"question":"def min_trims_to_non_decreasing(P): Returns the minimum number of trimming operations required to make the array P non-decreasing. If it's impossible to achieve this by any number of trimmings, return -1. >>> min_trims_to_non_decreasing([3, 4, 2, 5, 4, 5, 6]) 2 >>> min_trims_to_non_decreasing([1, 2, 3, 4, 5]) 0 >>> min_trims_to_non_decreasing([5, 4, 3, 2, 1]) -1 >>> min_trims_to_non_decreasing([3, 3, 2, 2, 2]) -1 >>> min_trims_to_non_decreasing([1, 3, 2, 4]) 1 >>> min_trims_to_non_decreasing([2]) 0 # Single element is always non-decreasing pass def process_test_cases(T, test_cases): Process multiple test cases to determine the minimum number of trimming operations required for each. >>> process_test_cases(2, [(7, [3, 4, 2, 5, 4, 5, 6]), (5, [1, 2, 3, 4, 5])]) [2, 0] >>> process_test_cases(1, [(5, [3, 3, 2, 2, 2])]) [-1] pass","solution":"def min_trims_to_non_decreasing(P): Returns the minimum number of trimming operations required to make the array P non-decreasing. N = len(P) trims = 0 for i in range(1, N): if P[i-1] > P[i]: if i == N - 1 or P[i] >= P[i+1]: # If this is the last element or it already forms a non-decreasing sequence with the next one return -1 # Impossible to fix else: trims += 1 P[i-1] = P[i] # Effectively trim element at position i-1 to the value of P[i] return trims def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] P = test_cases[i][1] result = min_trims_to_non_decreasing(P) results.append(result) return results"},{"question":"from typing import List def has_pair_with_difference(arr: List[int], k: int) -> bool: Determines if there exists a pair of distinct indices in the array such that the absolute difference between the elements at these indices is equal to a target value k. Parameters: - arr: List[int], the input array of integers - k: int, the target difference value Returns: - bool: True if such a pair exists, False otherwise >>> has_pair_with_difference([1, 5, 3, 4, 2], 3) == True >>> has_pair_with_difference([8, 12, 16, 4, 0], 8) == True >>> has_pair_with_difference([1, 2, 3, 4, 5], 7) == False >>> has_pair_with_difference([5, 5, 5, 5, 5], 0) == True >>> has_pair_with_difference([], 3) == False >>> has_pair_with_difference([1], 1) == False >>> has_pair_with_difference([-1, -5, -3, -4, -2], 3) == True >>> has_pair_with_difference([-8, -12, -16, -4, 0], 8) == True >>> has_pair_with_difference([-1, 3, 4, -4, 2], 7) == True >>> has_pair_with_difference([-1, 2, 3, 4, 5], 4) == True","solution":"def has_pair_with_difference(arr, k): Determines if there exists a pair of distinct indices in the array such that the absolute difference between the elements at these indices is equal to a target value k. Parameters: - arr: List[int], the input array of integers - k: int, the target difference value Returns: - bool: True if such a pair exists, False otherwise seen = set() for num in arr: if (num + k) in seen or (num - k) in seen: return True seen.add(num) return False"},{"question":"def longest_common_prefix(strs): Returns the longest common prefix of an array of strings. if not strs: return 0 # The shortest string will limit the comparison of the common prefix. min_length = min(len(s) for s in strs) for i in range(min_length): char = strs[0][i] for s in strs[1:]: if s[i] != char: return i return min_length def find_longest_common_prefix_length(test_cases): Takes a list of test cases, where each test case is a list of dish names, and returns a list of the lengths of the longest common prefix for each test case. :param test_cases: List of test cases, where each test case is a list of strings. :return: List of integers representing the length of the longest common prefix for each test case. results = [] for dishes in test_cases: prefix_length = longest_common_prefix(dishes) results.append(prefix_length) return results def process_input(input_str): Processes the input string, executes the test cases, and returns the results as a list of integers. :param input_str: Input string containing multiple test cases. :return: List of integers representing the length of the longest common prefix for each test case. input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) dishes = [] for j in range(N): dishes.append(input_lines[index + 1 + j]) test_cases.append(dishes) index += N + 1 return find_longest_common_prefix_length(test_cases) # Example Test Cases input_data = 3 3 spaghetti spanakopita spicy 2 pizza pizzicato 4 applepie applejuice applecrumble appletart print(process_input(input_data)) # Output: [2, 4, 5]","solution":"def longest_common_prefix(strs): Returns the longest common prefix of an array of strings. if not strs: return 0 # The shortest string will limit the comparison of the common prefix. min_length = min(len(s) for s in strs) for i in range(min_length): char = strs[0][i] for s in strs[1:]: if s[i] != char: return i return min_length def find_longest_common_prefix_length(test_cases): results = [] for dishes in test_cases: prefix_length = longest_common_prefix(dishes) results.append(prefix_length) return results def process_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) dishes = [] for j in range(N): dishes.append(input_lines[index + 1 + j]) test_cases.append(dishes) index += N + 1 return find_longest_common_prefix_length(test_cases)"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a string s. Args: s (str): the input string. Returns: str: a string of the words in reverse order. >>> reverse_words(\\"the sky is blue\\") 'blue is sky the' >>> reverse_words(\\" hello world \\") 'world hello' >>> reverse_words(\\"a good example\\") 'example good a' >>> reverse_words(\\" Bob Loves Alice \\") 'Alice Loves Bob' >>> reverse_words(\\"Alice does not even like bob\\") 'bob like even not does Alice'","solution":"def reverse_words(s): Reverses the order of words in a string s. Args: s (str): the input string. Returns: str: a string of the words in reverse order. words = s.strip().split() return ' '.join(reversed(words))"},{"question":"def minimize_max_load(S: int, N: int, tasks: List[int]) -> int: Distributes tasks to servers and outputs the minimized maximum processing time of any server. >>> minimize_max_load(4, 6, [10, 20, 30, 40, 50, 60]) 60 >>> minimize_max_load(1, 5, [10, 20, 30, 40, 50]) 150 >>> minimize_max_load(5, 5, [10, 20, 30, 40, 50]) 50 >>> minimize_max_load(3, 6, [10, 10, 10, 10, 10, 10]) 20 >>> minimize_max_load(2, 5, [100, 200, 300, 400, 500]) 800 >>> minimize_max_load(4, 4, [30, 30, 30, 30]) 30 >>> minimize_max_load(1, 1, [1]) 1","solution":"def minimize_max_load(S, N, tasks): def can_distribute(max_load): server_loads = [0] * S for task in tasks: server_loads.sort() if server_loads[0] + task > max_load: return False server_loads[0] += task return True tasks.sort(reverse=True) low, high = max(tasks), sum(tasks) while low < high: mid = (low + high) // 2 if can_distribute(mid): high = mid else: low = mid + 1 return low"},{"question":"from typing import List def find_first_unique_URL(urls: List[str]) -> str: Returns the first unique URL from the list of URLs. >>> find_first_unique_URL(['google.com', 'facebook.com', 'google.com', 'youtube.com', 'yahoo.com', 'youtube.com', 'amazon.com']) == 'facebook.com' >>> find_first_unique_URL(['google.com', 'facebook.com', 'youtube.com', 'yahoo.com', 'amazon.com']) == 'google.com' >>> find_first_unique_URL(['google.com', 'facebook.com', 'google.com', 'facebook.com']) == '' >>> find_first_unique_URL(['unique.com', 'common.com', 'common.com', 'common.com']) == 'unique.com' >>> find_first_unique_URL(['common.com', 'common.com', 'common.com', 'unique.com']) == 'unique.com' >>> find_first_unique_URL(['Example.com', 'example.com', 'example.com']) == 'Example.com'","solution":"from typing import List def find_first_unique_URL(urls: List[str]) -> str: Returns the first unique URL from the list of URLs. url_count = {} # Count occurrences of each URL for url in urls: if url in url_count: url_count[url] += 1 else: url_count[url] = 1 # Find the first URL that appears only once for url in urls: if url_count[url] == 1: return url # If no unique URL is found (though the problem ensures at least one unique URL) return \\"\\""},{"question":"def longest_valid_subsequence(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of flowers and their respective heights, determine the longest subsequence of flowers such that no two adjacent flowers have the same height. >>> T = 2 >>> cases = [ ... (5, [1, 2, 2, 3, 4]), ... (6, [5, 6, 5, 5, 7, 8]) ... ] >>> longest_valid_subsequence(T, cases) [4, 5]","solution":"def longest_valid_subsequence(T, cases): results = [] for N, heights in cases: if N == 1: results.append(1) continue longest_subseq_length = 1 previous_height = heights[0] for i in range(1, N): if heights[i] != previous_height: longest_subseq_length += 1 previous_height = heights[i] results.append(longest_subseq_length) return results"},{"question":"def shortest_even_product_subarray_size(arr): Returns the length of the shortest subarray with an even product. If no such subarray exists, returns -1. Parameters: arr (List[int]): The list of integers representing the array Returns: int: The length of the shortest subarray with an even product, or -1 if no such subarray exists. pass def process_input(T, test_cases): Processes the input and returns the results for each test case. Parameters: T (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the number of elements n and the array A Returns: List[int]: List of results for each test case pass from solution import process_input def test_case1(): T = 3 test_cases = [ (4, [1, 5, 3, 7]), (5, [2, 4, 6, 8, 10]), (3, [3, 7, 5]) ] expected = [-1, 1, -1] assert process_input(T, test_cases) == expected def test_case2(): T = 2 test_cases = [ (4, [11, 13, 17, 19]), (6, [1, 13, 15, 18, 21, 23]) ] expected = [-1, 1] assert process_input(T, test_cases) == expected def test_case3(): T = 1 test_cases = [ (5, [5, 15, 25, 10, 20]) ] expected = [1] assert process_input(T, test_cases) == expected def test_case4(): T = 2 test_cases = [ (3, [1000000000, 999999999, 88888888]), (4, [7777777, 666666, 55555, 4444]) ] expected = [1, 1] assert process_input(T, test_cases) == expected def test_case5(): T = 1 test_cases = [ (7, [1, 3, 5, 7, 2, 9, 11]) ] expected = [1] assert process_input(T, test_cases) == expected","solution":"def shortest_even_product_subarray_size(arr): Returns the length of the shortest subarray with an even product. If no such subarray exists, returns -1. for i in range(len(arr)): if arr[i] % 2 == 0: return 1 return -1 def process_input(T, test_cases): Processes the input and returns the results for each test case. results = [] for test_case in test_cases: n = test_case[0] arr = test_case[1] result = shortest_even_product_subarray_size(arr) results.append(result) return results"},{"question":"def maximizeBeauty(N: int, M: int, beauty: List[int]) -> int: Returns the maximum sum of beauty values by planting M trees in N locations. >>> maximizeBeauty(5, 2, [1, 3, 2, 5, 4]) 9 >>> maximizeBeauty(4, 1, [1, 2, 3, 4]) 4","solution":"def maximizeBeauty(N, M, beauty): Returns the maximum sum of beauty values by planting M trees in N locations. # Sort the array in descending order beauty.sort(reverse=True) # Sum the top M values from the sorted array return sum(beauty[:M])"},{"question":"def distribute_water_bottles(total_bottles, checkpoints): Distributes total_bottles evenly across checkpoints. Returns a list of number of water bottles at each checkpoint. If checkpoints is zero, returns \\"We need more checkpoints!\\". Examples: >>> distribute_water_bottles(20, 3) [7, 7, 6] >>> distribute_water_bottles(8, 5) [2, 2, 2, 1, 1] >>> distribute_water_bottles(15, 4) [4, 4, 4, 3] >>> distribute_water_bottles(0, 0) \\"We need more checkpoints!\\" def test_distribute_water_bottles(): assert distribute_water_bottles(20, 3) == [7, 7, 6] assert distribute_water_bottles(8, 5) == [2, 2, 2, 1, 1] assert distribute_water_bottles(15, 4) == [4, 4, 4, 3] assert distribute_water_bottles(0, 0) == \\"We need more checkpoints!\\" assert distribute_water_bottles(10, 1) == [10] assert distribute_water_bottles(0, 5) == [0, 0, 0, 0, 0] assert distribute_water_bottles(7, 4) == [2, 2, 2, 1] assert distribute_water_bottles(7, 7) == [1, 1, 1, 1, 1, 1, 1] test_distribute_water_bottles()","solution":"def distribute_water_bottles(total_bottles, checkpoints): Distributes total_bottles evenly across checkpoints. Returns a list of number of water bottles at each checkpoint. If checkpoints is zero, returns \\"We need more checkpoints!\\". if checkpoints == 0: return \\"We need more checkpoints!\\" base_count = total_bottles // checkpoints remainder = total_bottles % checkpoints distribution = [base_count] * checkpoints for i in range(remainder): distribution[i] += 1 return distribution"},{"question":"def minimum_maximum_hours(tasks, k): Determines the minimum possible value of the maximum hours worked by any employee after optimally distributing the tasks. :param tasks: List[int] - List of integers where each integer represents the hours needed for a task. :param k: int - The number of employees. :return: int - Minimum possible value of the maximum hours worked by any employee. >>> minimum_maximum_hours([10, 7, 8, 12, 6, 8, 7], 3) 21 >>> minimum_maximum_hours([1, 2, 3, 4, 5], 2) 9","solution":"def minimum_maximum_hours(tasks, k): Determines the minimum possible value of the maximum hours worked by any employee after optimally distributing the tasks. :param tasks: List[int] - List of integers where each integer represents the hours needed for a task. :param k: int - The number of employees. :return: int - Minimum possible value of the maximum hours worked by any employee. def can_distribute_tasks(max_hours): current_sum = 0 employees_needed = 1 for task in tasks: if current_sum + task > max_hours: employees_needed += 1 current_sum = task if employees_needed > k: return False else: current_sum += task return True low, high = max(tasks), sum(tasks) result = high while low <= high: mid = (low + high) // 2 if can_distribute_tasks(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"from typing import List def check_prime_subarray(arr: List[int]) -> str: Derek loves puzzles involving prime numbers. Given an integer array \`arr\`, determine if there exists any subarray (contiguous part of the array) such that the sum of its elements is a prime number. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. >>> check_prime_subarray([2, 3, -5, 5, 6]) \\"YES\\" >>> check_prime_subarray([4, 6, 8]) \\"NO\\" def is_prime(num: int) -> bool: Determines if a number is a prime number. >>> is_prime(5) True >>> is_prime(4) False pass","solution":"from typing import List def is_prime(num: int) -> bool: Determines if a number is a prime number. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def check_prime_subarray(arr: List[int]) -> str: Checks if there exists any subarray whose sum is a prime number. N = len(arr) for i in range(N): current_sum = 0 for j in range(i, N): current_sum += arr[j] if is_prime(current_sum): return \\"YES\\" return \\"NO\\""},{"question":"import math def count_book_arrangements(n: int, k: int) -> int: Returns the number of ways to arrange exactly k books out of n books. >>> count_book_arrangements(5, 3) 60 >>> count_book_arrangements(5, 0) 1 >>> count_book_arrangements(5, 5) 120 >>> count_book_arrangements(0, 0) 1 >>> count_book_arrangements(1, 2) 0","solution":"import math def count_book_arrangements(n, k): Returns the number of ways to arrange exactly k books out of n books. if k > n or k < 0 or n < 0: return 0 return math.perm(n, k)"},{"question":"def max_gold_to_rob(N: int, gold: List[int]) -> int: Determine the maximum amount of gold you can rob from N houses aligned in a row without robbing two directly adjacent houses. >>> max_gold_to_rob(4, [1, 2, 3, 1]) 4 >>> max_gold_to_rob(5, [2, 7, 9, 3, 1]) 12 >>> max_gold_to_rob(3, [0, 0, 0]) 0 >>> max_gold_to_rob(1, [5]) 5 >>> max_gold_to_rob(2, [3, 10]) 10 >>> max_gold_to_rob(0, []) 0 >>> max_gold_to_rob(4, [10, 10, 10, 10]) 20 >>> max_gold_to_rob(6, [5, 1, 5, 1, 5, 1]) 15","solution":"def max_gold_to_rob(N, gold): if N == 0: return 0 elif N == 1: return gold[0] dp = [0] * N dp[0] = gold[0] dp[1] = max(gold[0], gold[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + gold[i]) return dp[-1]"},{"question":"def find_pairs(nums: List[int], k: int) -> List[Tuple[int, int]]: Finds all unique pairs of integers in the array that add up to k. Args: nums (list of int): The list of integers. k (int): The target sum. Returns: list of tuple: A list of tuples representing the pairs. >>> find_pairs([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([1, 1, 1, 6, 6, 6], 7) [(1, 6)] >>> find_pairs([-3, -2, 0, 1, 2, 3], 0) [(-3, 3), (-2, 2)] >>> find_pairs([5], 5) [] >>> find_pairs([1, 2, 3, 4, 2, 3, 5, 6], 7) [(1, 6), (2, 5), (3, 4)]","solution":"def find_pairs(nums, k): Finds all unique pairs of integers in the array that add up to k. Args: nums (list of int): The list of integers. k (int): The target sum. Returns: list of tuple: A list of tuples representing the pairs. nums.sort() pairs = [] seen = set() for num in nums: target = k - num if target in seen: pairs.append((min(num, target), max(num, target))) seen.add(num) # Remove duplicates unique_pairs = list(set(pairs)) unique_pairs.sort() return unique_pairs"},{"question":"def longest_path_with_ones(n, values, edges): Find the length of the longest path in the tree that starts and ends at a node with value 1. >>> data = \\"5n1 0 1 0 1n1 2n1 3n3 4n3 5\\" >>> n, values, edges = parse_input(data) >>> longest_path_with_ones(n, values, edges) 3 >>> data = \\"3n0 0 1n1 2n2 3\\" >>> n, values, edges = parse_input(data) >>> longest_path_with_ones(n, values, edges) 0 def parse_input(data): Parse the input data for the binary tree problem. >>> data = \\"5n1 0 1 0 1n1 2n1 3n3 4n3 5\\" >>> parse_input(data) (5, [1, 0, 1, 0, 1], [(1, 2), (1, 3), (3, 4), (3, 5)]) lines = data.strip().split('n') n = int(lines[0]) values = list(map(int, lines[1].strip().split())) edges = [tuple(map(int, line.split())) for line in lines[2:]] return n, values, edges","solution":"def longest_path_with_ones(n, values, edges): from collections import defaultdict, deque if values.count(1) < 2: return 0 # No path exists if there are less than two nodes with value 1 # Create the tree as an adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def bfs(start): visited = [-1] * (n + 1) # start with unvisited nodes visited[start] = 0 queue = deque([start]) farthest_node = start max_distance = 0 while queue: node = queue.popleft() for neighbor in tree[node]: if visited[neighbor] == -1: # if not visited visited[neighbor] = visited[node] + 1 queue.append(neighbor) if visited[neighbor] > max_distance: farthest_node = neighbor max_distance = visited[neighbor] return (farthest_node, max_distance) # Start BFS from any node that has value 1 to find the farthest one start_node = values.index(1) + 1 # 1-based index farthest_node, _ = bfs(start_node) # Start BFS from the farthest node found to get the longest path farthest_node, longest_path_length = bfs(farthest_node) return longest_path_length # Usage def parse_input(data): lines = data.strip().split('n') n = int(lines[0]) values = list(map(int, lines[1].strip().split())) edges = [tuple(map(int, line.split())) for line in lines[2:]] return n, values, edges"},{"question":"def process_operations(N: int, operations: List[str]) -> str: Process a series of operations to determine the final sequence of numbers. Each operation is either \`add x\` to append a number to the sequence or \`remove k\` to remove the k-th number. Args: N (int): Number of operations to perform. operations (List[str]): List of operations as strings. Returns: str: Final sequence of numbers separated by spaces or \\"empty\\" if the sequence is empty. Examples: >>> process_operations(6, [\\"add 5\\", \\"add 3\\", \\"add 10\\", \\"remove 2\\", \\"add 7\\", \\"remove 1\\"]) \\"10 7\\" >>> process_operations(4, [\\"add 6\\", \\"add 8\\", \\"remove 1\\", \\"remove 1\\"]) \\"empty\\"","solution":"def process_operations(N, operations): sequence = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"add\\": x = int(parts[1]) sequence.append(x) elif command == \\"remove\\": k = int(parts[1]) if 1 <= k <= len(sequence): sequence.pop(k - 1) return \\" \\".join(map(str, sequence)) if sequence else \\"empty\\""},{"question":"def calculate_target(T: int, cases: List[Tuple[int, int]]) -> List[int]: Calculate the minimum number of days required to meet or exceed the target production. :param T: An integer representing the number of test cases. :param cases: A list of tuples, each containing two integers D (target) and P (production per day). :return: A list of integers, each representing the minimum number of days for the corresponding test case. >>> calculate_target(3, [(20, 50), (10, 200), (30, 90)]) == [1, 1, 1] >>> calculate_target(1, [(1, 1)]) == [1] >>> calculate_target(4, [(1000, 1), (5, 2), (12, 3), (15, 4)]) == [1000, 3, 4, 4] pass","solution":"def calculate_target(T, cases): Calculate the minimum number of days required to meet or exceed the target production. :param T: An integer representing the number of test cases. :param cases: A list of tuples, each containing two integers D (target) and P (production per day). :return: A list of integers, each representing the minimum number of days for the corresponding test case. results = [] for D, P in cases: days = (D + P - 1) // P # This is equivalent to ceil(D / P) results.append(days) return results"},{"question":"def sum_of_primes(N: int) -> int: Write a program that takes an integer N and outputs the sum of all prime numbers less than or equal to N. >>> sum_of_primes(10) 17 >>> sum_of_primes(0) 0 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 2 >>> sum_of_primes(3) 5","solution":"def sum_of_primes(N): Returns the sum of all prime numbers less than or equal to N. if N < 2: return 0 sieve = [True] * (N + 1) sieve[0] = sieve[1] = False for start in range(2, int(N**0.5) + 1): if sieve[start]: for multiple in range(start*start, N + 1, start): sieve[multiple] = False return sum(i for i in range(2, N + 1) if sieve[i])"},{"question":"from typing import List def aggregate_sales(sales_data: List[List[int]]) -> List[int]: Aggregate daily sales data for a product across multiple stores. Each store logs its sales data as a list of integers, where each index represents a day, and the value at that index represents the sales for that day. Parameters: sales_data (List[List[int]]): Nested list containing sales data for multiple stores, where each sublist contains sales data for one store. Returns: List[int]: A list where each element is the total sales for that day across all stores. Example: >>> aggregate_sales([ ... [10, 20, 30], ... [5, 15, 25], ... [7, 14, 21] ... ]) [22, 49, 76] >>> aggregate_sales([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) [0, 0, 0] pass","solution":"from typing import List def aggregate_sales(sales_data: List[List[int]]) -> List[int]: if not sales_data: return [] num_days = len(sales_data[0]) aggregated_data = [0] * num_days for store_sales in sales_data: for day in range(num_days): aggregated_data[day] += store_sales[day] return aggregated_data"},{"question":"from typing import List def sort_by_frequency(arr: List[int]) -> List[int]: Sort the array in ascending order based on the frequency of the values. If multiple values have the same frequency, they should appear in ascending order. Args: arr: List of integers to be sorted Returns: List of integers sorted by frequency and value pass def formatted_output(n: int, arr: List[int]) -> str: Formats the sorted list to a space-separated string. Args: n: Number of elements in the array arr: List of integers to be sorted Returns: A string representation of the sorted array pass from solution import sort_by_frequency, formatted_output def test_sort_by_frequency_case_1(): assert formatted_output(6, [4, 5, 6, 5, 4, 3]) == \\"3 6 4 4 5 5\\" def test_sort_by_frequency_case_2(): assert formatted_output(5, [9, 9, 4, 8, 8]) == \\"4 8 8 9 9\\" def test_sort_by_frequency_single_element(): assert formatted_output(1, [5]) == \\"5\\" def test_sort_by_frequency_same_elements(): assert formatted_output(4, [7, 7, 7, 7]) == \\"7 7 7 7\\" def test_sort_by_frequency_different_frequencies(): assert formatted_output(7, [4, 4, 4, 5, 5, 7, 8]) == \\"7 8 5 5 4 4 4\\" def test_sort_by_frequency_negative_numbers(): assert formatted_output(6, [-1, -2, -2, 3, 3, 3]) == \\"-1 -2 -2 3 3 3\\"","solution":"from collections import Counter def sort_by_frequency(arr): Sort the array in ascending order based on the frequency of the values. If multiple values have the same frequency, they should appear in ascending order. count = Counter(arr) # Sort primarily by frequency, secondarily by value sorted_arr = sorted(arr, key=lambda x: (count[x], x)) return sorted_arr def formatted_output(n, arr): return \\" \\".join(map(str, sort_by_frequency(arr)))"},{"question":"def find_smallest_duplicate_id(n: int, ids: List[int]) -> int: Find the smallest duplicated ID from the list of entered IDs. Parameters: n (int): The number of IDs entered. ids (List[int]): List of integers representing the IDs. Returns: int: The smallest duplicated ID or -1 if no IDs are duplicated. >>> find_smallest_duplicate_id(5, [1, 2, 3, 2, 4]) 2 >>> find_smallest_duplicate_id(6, [1, 3, 4, 2, 6, 5]) -1 >>> find_smallest_duplicate_id(8, [4, 5, 6, 7, 4, 7, 6, 8]) 4","solution":"def find_smallest_duplicate_id(n, ids): Finds the smallest duplicated ID from the list of entered IDs. Parameters: n (int): The number of IDs entered. ids (list): List of integers representing the IDs. Returns: int: The smallest duplicated ID or -1 if no IDs are duplicated. id_count = {} for id in ids: if id in id_count: id_count[id] += 1 else: id_count[id] = 1 duplicates = [id for id, count in id_count.items() if count > 1] return min(duplicates) if duplicates else -1"},{"question":"def final_position(M, R_start, C_start, commands): Determine the final position of the robot after executing all commands. Args: M (int): Size of the grid (MxM). R_start (int): Starting row position (1-based). C_start (int): Starting column position (1-based). commands (str): Sequence of commands. Returns: (int, int): Final position of the robot. >>> final_position(5, 3, 3, \\"UUDDLLRR\\") (3, 3) >>> final_position(8, 1, 1, \\"DRRRUUU\\") (1, 4) >>> final_position(10, 5, 5, \\"LLLLUUUU\\") (1, 1)","solution":"def final_position(M, R_start, C_start, commands): Determine the final position of the robot after executing all commands. Args: M (int): Size of the grid (MxM). R_start (int): Starting row position (1-based). C_start (int): Starting column position (1-based). commands (str): Sequence of commands. Returns: (int, int): Final position of the robot. x, y = R_start, C_start for cmd in commands: if cmd == 'U' and x > 1: x -= 1 elif cmd == 'D' and x < M: x += 1 elif cmd == 'L' and y > 1: y -= 1 elif cmd == 'R' and y < M: y += 1 return (x, y)"},{"question":"def countPalindromicSubstrings(text: str) -> int: Write a function named \`countPalindromicSubstrings\` that takes a single parameter, a string \`text\`, and returns an integer representing the number of palindromic substrings in the given text. A palindromic substring is a substring that reads the same backward as forward. Single character substrings are considered palindromic. Examples: >>> countPalindromicSubstrings(\\"abba\\") 6 >>> countPalindromicSubstrings(\\"abc\\") 3 def test_countPalindromicSubstrings(): assert countPalindromicSubstrings(\\"abba\\") == 6 assert countPalindromicSubstrings(\\"abc\\") == 3 assert countPalindromicSubstrings(\\"madam\\") == 7 assert countPalindromicSubstrings(\\"racecar\\") == 10 assert countPalindromicSubstrings(\\"a\\") == 1 assert countPalindromicSubstrings(\\"aa\\") == 3 assert countPalindromicSubstrings(\\"aaa\\") == 6 assert countPalindromicSubstrings(\\"\\") == 0 def test_countPalindromicSubstrings_edge_cases(): assert countPalindromicSubstrings(\\"abcdedcba\\") == 13 assert countPalindromicSubstrings(\\"abcba\\") == 7 assert countPalindromicSubstrings(\\"xyzyx\\") == 7 assert countPalindromicSubstrings(\\"aabbcc\\") == 9","solution":"def countPalindromicSubstrings(text): Returns the number of palindromic substrings in the given text. :param text: A string in which to count palindromic substrings. :return: An integer representing the number of palindromic substrings. n = len(text) count = 0 def is_palindrome(left, right): while left >= 0 and right < n and text[left] == text[right]: left -= 1 right += 1 nonlocal count count += 1 for i in range(n): # Count odd length palindromes centered at i is_palindrome(i, i) # Count even length palindromes centered between i and i+1 is_palindrome(i, i + 1) return count"},{"question":"def min_delivery_cost(grid: List[List[int]]) -> int: A courier company needs to optimize its delivery schedule within a city grid layout. The city is represented as an N x N grid where each cell has a certain time cost associated with it. The goal is to find the minimum time cost required to reach from the top-left corner of the grid (0, 0) to the bottom-right corner (N-1, N-1) by only moving right or down at each step. >>> min_delivery_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_delivery_cost([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21","solution":"def min_delivery_cost(grid): This function calculates the minimum time cost to reach from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1) in an N x N grid by only moving right or down. Parameters: grid (list of list of int): 2D list representing the grid with time costs. Returns: int: Minimum time cost to traverse from (0, 0) to (N-1, N-1). N = len(grid) if N == 0: return 0 # Initialize the dp array with the same dimensions as grid dp = [[0]*N for _ in range(N)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, N): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][N-1]"},{"question":"def letterCombinations(digits): Given a string containing digits from 2-9 inclusive, returns all possible letter combinations that the number could represent. Parameters: digits (str): input string containing digits from 2-9 inclusive Returns: List[str]: list of possible letter combinations in lexicographical order >>> letterCombinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letterCombinations(\\"\\") [] >>> letterCombinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] >>> letterCombinations(\\"32\\") [\\"da\\", \\"db\\", \\"dc\\", \\"ea\\", \\"eb\\", \\"ec\\", \\"fa\\", \\"fb\\", \\"fc\\"] >>> letterCombinations(\\"567\\") [\\"jmp\\", \\"jmq\\", \\"jmr\\", \\"jms\\", \\"jnp\\", \\"jnq\\", \\"jnr\\", \\"jns\\", \\"jop\\", \\"joq\\", \\"jor\\", \\"jos\\", \\"kmp\\", \\"kmq\\", \\"kmr\\", \\"kms\\", \\"knp\\", \\"knq\\", \\"knr\\", \\"kns\\", \\"kop\\", \\"koq\\", \\"kor\\", \\"kos\\", \\"lmp\\", \\"lmq\\", \\"lmr\\", \\"lms\\", \\"lnp\\", \\"lnq\\", \\"lnr\\", \\"lns\\", \\"lop\\", \\"loq\\", \\"lor\\", \\"los\\"]","solution":"def letterCombinations(digits): Given a string containing digits from 2-9 inclusive, returns all possible letter combinations that the number could represent. Parameters: digits (str): input string containing digits from 2-9 inclusive Returns: List[str]: list of possible letter combinations in lexicographical order if not digits: return [] mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } # Helper function to perform backtracking def backtrack(index, path): if index == len(digits): combinations.append(''.join(path)) return possible_letters = mapping[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return sorted(combinations)"},{"question":"from collections import Counter from typing import List, Tuple def find_mode(numbers: List[int]) -> int: Given a list of numbers, returns the mode. If there are multiple modes, returns the smallest one. >>> find_mode([1, 2, 2, 3, 3]) == 2 >>> find_mode([4, 5, 6, 5, 6, 6]) == 6 pass def process_test_cases(T: int, test_cases: List[List[int]]) -> List[int]: Given a number of test cases and a list of test case data, returns a list of modes. >>> process_test_cases(2, [[5, 1, 2, 2, 3, 3], [6, 4, 5, 6, 5, 6, 6]]) == [2, 6] pass","solution":"from collections import Counter def find_mode(numbers): Given a list of numbers, returns the mode. If there are multiple modes, returns the smallest one. number_counts = Counter(numbers) max_frequency = max(number_counts.values()) # Find the numbers with the max frequency modes = [num for num, freq in number_counts.items() if freq == max_frequency] # Return the smallest number among the modes return min(modes) def process_test_cases(T, test_cases): results = [] for case in test_cases: _, *numbers = case results.append(find_mode(numbers)) return results"},{"question":"def generate_sequences(T: int, test_cases: List[int]) -> List[List[int]]: Generates a sequence based on the given pattern for each test case. Parameters: T (int): Number of test cases. test_cases (list of int): List of numbers N. Returns: list of list: Each inner list contains the sequence for the corresponding test case. pass # Write your code here def format_sequences(sequences: List[List[int]]) -> str: Formats the sequences into the required output format. Parameters: sequences (list of list): List of sequences to format. Returns: str: The formatted string representing the sequences. pass # Write your code here # Test cases to validate the solution if __name__ == \\"__main__\\": sequences = generate_sequences(4, [1, 2, 3, 4]) formatted_output = format_sequences(sequences) print(formatted_output) Expected Output: 1 1 2 1 2 4 1 2 4 8","solution":"def generate_sequences(T, test_cases): Generates a sequence based on the given pattern for each test case. Parameters: T (int): Number of test cases. test_cases (list of int): List of numbers N. Returns: list of list: Each inner list contains the sequence for the corresponding test case. results = [] for N in test_cases: sequence = [2**i for i in range(N)] results.append(sequence) return results # Function to format the sequences into required output format def format_sequences(sequences): return \\"n\\".join(\\" \\".join(map(str, seq)) for seq in sequences)"},{"question":"import bisect class MedianFinder: def __init__(self): Initializes an empty data structure to store the elements of the dataset. self.data = [] def addNum(self, num: int): Adds a new number to the dataset. :param num: The number to be added to the dataset. bisect.insort(self.data, num) def findMedian(self): Finds and returns the median of the current dataset. :return: The median of the dataset if it is non-empty, otherwise \\"Empty\\". if not self.data: return \\"Empty\\" n = len(self.data) if n % 2 == 1: return self.data[n // 2] else: return (self.data[n // 2 - 1] + self.data[n // 2]) / 2 def process_operations(operations): Processes a list of operations on the dataset and outputs the result of median calculation when requested. :param operations: A list of strings representing operations on the dataset. :return: A list of medians after each \\"median\\" operation. Example: >>> process_operations([\\"add 1\\", \\"add 3\\", \\"median\\", \\"add 2\\", \\"median\\", \\"add 5\\", \\"add 4\\", \\"median\\", \\"end\\"]) [2, 2, 3] median_finder = MedianFinder() results = [] for operation in operations: if operation.startswith(\\"add\\"): _, num = operation.split() median_finder.addNum(int(num)) elif operation == \\"median\\": results.append(median_finder.findMedian()) return results def test_empty_dataset(): operations = [\\"median\\", \\"end\\"] output = process_operations(operations) assert output == [\\"Empty\\"] def test_single_addition(): operations = [\\"add 5\\", \\"median\\", \\"end\\"] output = process_operations(operations) assert output == [5] def test_odd_number_of_elements(): operations = [\\"add 1\\", \\"add 3\\", \\"add 2\\", \\"median\\", \\"end\\"] output = process_operations(operations) assert output == [2] def test_even_number_of_elements(): operations = [\\"add 1\\", \\"add 3\\", \\"add 2\\", \\"add 4\\", \\"median\\", \\"end\\"] output = process_operations(operations) assert output == [2.5] def test_multiple_medians(): operations = [ \\"add 1\\", \\"add 3\\", \\"median\\", \\"add 2\\", \\"median\\", \\"add 5\\", \\"add 4\\", \\"median\\", \\"end\\" ] output = process_operations(operations) assert output == [2, 2, 3] # Example Usage if __name__ == \\"__main__\\": operations = [ \\"add 1\\", \\"add 3\\", \\"median\\", \\"add 2\\", \\"median\\", \\"add 5\\", \\"add 4\\", \\"median\\", \\"end\\" ] output = process_operations(operations) for value in output: print(value)","solution":"import bisect class MedianFinder: def __init__(self): self.data = [] def addNum(self, num: int): # Insert the number in the sorted position bisect.insort(self.data, num) def findMedian(self): if not self.data: return \\"Empty\\" n = len(self.data) if n % 2 == 1: return self.data[n // 2] else: return (self.data[n // 2 - 1] + self.data[n // 2]) / 2 def process_operations(operations): median_finder = MedianFinder() results = [] for operation in operations: if operation.startswith(\\"add\\"): _, num = operation.split() median_finder.addNum(int(num)) elif operation == \\"median\\": results.append(median_finder.findMedian()) return results # Example Usage operations = [ \\"add 1\\", \\"add 3\\", \\"median\\", \\"add 2\\", \\"median\\", \\"add 5\\", \\"add 4\\", \\"median\\", \\"end\\" ] output = process_operations(operations) for value in output: print(value)"},{"question":"def reverse_words(S: str) -> str: Output the string S with the order of words reversed. The words are separated by a single space. >>> reverse_words(\\"Hello World\\") \\"World Hello\\" >>> reverse_words(\\"Code Assessment Question\\") \\"Question Assessment Code\\" >>> reverse_words(\\"Sample Test Case\\") \\"Case Test Sample\\" >>> reverse_words(\\"Reversal Of Words\\") \\"Words Of Reversal\\"","solution":"def reverse_words(S): Reverses the order of words in the given string S. :param S: A string consisting of uppercase and lowercase letters, and spaces. :return: A string with the order of words reversed. words = S.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def count_overlapping_tasks(t_s, t_e, tasks): Counts the number of tasks that overlap with the defective component's operational time. t_s: int, start time of defective component's operation t_e: int, end time of defective component's operation tasks: list of tuples, each tuple contains start and end time of a task returns: int, number of overlapping tasks >>> count_overlapping_tasks(5, 10, [(2, 6), (8, 12), (1, 4), (9, 15)]) == 2 >>> count_overlapping_tasks(5, 10, [(1, 4), (11, 15)]) == 0 >>> count_overlapping_tasks(5, 10, [(5, 10), (6, 9), (4, 11)]) == 3","solution":"def count_overlapping_tasks(t_s, t_e, tasks): Counts the number of tasks that overlap with the defective component's operational time. t_s: int, start time of defective component's operation t_e: int, end time of defective component's operation tasks: list of tuples, each tuple contains start and end time of a task returns: int, number of overlapping tasks overlap_count = 0 for a_i, b_i in tasks: if not (b_i < t_s or a_i > t_e): # Check if the task overlaps with the defective component time overlap_count += 1 return overlap_count"},{"question":"def three_sum(nums, target): Determine if there are three distinct integers within the array that add up to the target value. >>> three_sum([-1, 2, 3, 0, -4, 1], 2) True >>> three_sum([1, 2, 3, 4], 10) False","solution":"def three_sum(nums, target): nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: summation = nums[i] + nums[left] + nums[right] if summation == target: return True elif summation < target: left += 1 else: right -= 1 return False"},{"question":"def max_overlapping_workshops(n, intervals): Determine the maximum number of overlapping workshops on any single day. Args: n (int): The number of workshops. intervals (List[Tuple[int, int]]): A list of tuples where each tuple contains the start day and end day of a workshop. Returns: int: The maximum number of overlapping workshops on any single day. Examples: >>> max_overlapping_workshops(3, [(1, 5), (2, 6), (3, 7)]) 3 >>> max_overlapping_workshops(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 2","solution":"def max_overlapping_workshops(n, intervals): events = [] for start, end in intervals: events.append((start, 'start')) events.append((end + 1, 'end')) events.sort() current_overlap = 0 max_overlap = 0 for time, event in events: if event == 'start': current_overlap += 1 if current_overlap > max_overlap: max_overlap = current_overlap else: current_overlap -= 1 return max_overlap"},{"question":"def largest_connected_component(n: int, m: int, k: int, marks: List[Tuple[int, int]]) -> int: Calculate the size of the largest connected component of marked cells in a grid. >>> largest_connected_component(3, 3, 3, [(1, 1), (2, 1), (1, 2)]) == 3 >>> largest_connected_component(5, 5, 5, [(1, 1), (1, 2), (1, 3), (4, 4), (5, 5)]) == 3 >>> largest_connected_component(3, 3, 1, [(2, 2)]) == 1 >>> largest_connected_component(3, 3, 9, [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]) == 9 >>> largest_connected_component(3, 3, 0, []) == 0","solution":"def largest_connected_component(n, m, k, marks): def dfs(r, c): stack = [(r, c)] count = 0 while stack: x, y = stack.pop() if (x, y) in visited: continue visited.add((x, y)) count += 1 for direction in directions: nx, ny = x + direction[0], y + direction[1] if 1 <= nx <= n and 1 <= ny <= m and (nx, ny) in mark_set: stack.append((nx, ny)) return count directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] mark_set = set(marks) visited = set() largest = 0 for r, c in marks: if (r, c) not in visited: largest = max(largest, dfs(r, c)) return largest"},{"question":"def max_days_of_reading(T, test_cases): Calculate the maximum number of days Sophie can spend reading spells, given the power levels of spells in each row of the library. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): A list of test cases, where each test case is a tuple containing: - An integer N, the number of rows - A list of lists, where each sublist represents the power levels of the spells in a row. Returns: List[int]: A list of integers, where each integer is the maximum number of days for the corresponding test case. Example: >>> T = 2 >>> test_cases = [ ... (4, [ ... [10, 20, 15], ... [5, 25, 5], ... [18, 4, 6], ... [7, 4, 11] ... ]), ... (3, [ ... [8, 8], ... [5], ... [7, 7] ... ]) ... ] >>> max_days_of_reading(T, test_cases) [3, 2]","solution":"def max_days_of_reading(T, test_cases): Calculate the maximum number of days Sophie can spend reading spells. Args: T: int, number of test cases. test_cases: list of tuples, each containing: - N: int, number of rows in the library. - rows: list of lists of int, representing the power levels of spells in each row. Returns: list of int, where each int is the maximum number of days for a corresponding test case. results = [] for case in test_cases: N, rows = case # Calculate the sum of spell powers in each row row_sums = [sum(row) for row in rows] # Sort the row sums in non-decreasing order row_sums.sort() # The maximum number of days Sophie can spend is simply the length of row_sums results.append(len(row_sums)) return results"},{"question":"def count_unique_symbols(n: int, q: int, sequence: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of unique symbols in the specified subsequence for each query. >>> count_unique_symbols(7, 1, [1, 2, 1, 3, 2, 1, 4], [(0, 3)]) [3] >>> count_unique_symbols(7, 3, [1, 2, 1, 3, 2, 1, 4], [(0, 3), (2, 5), (1, 6)]) [3, 3, 4]","solution":"def count_unique_symbols(n, q, sequence, queries): Returns the number of unique symbols in the specified subsequence for each query. Parameters: n (int): Length of the sequence q (int): Number of queries sequence (list): List of integers representing the sequence of symbols queries (list of tuples): Each tuple contains two integers representing the start and end of the range (0-based indices) Returns: list: A list of integers where each integer is the number of unique symbols in the corresponding query range results = [] for l, r in queries: unique_symbols = set(sequence[l:r+1]) results.append(len(unique_symbols)) return results"},{"question":"def min_transpositions_to_equal_rows(matrix: List[List[int]]) -> int: Determines if it is possible to make all rows equal by transposing submatrices, and if so, returns the minimum number of transpositions required. Parameters: matrix (list of list of int): The initial matrix. Returns: int: The minimum number of transpositions required, or -1 if not possible. >>> min_transpositions_to_equal_rows([[1, 2, 3], [3, 2, 1], [1, 2, 3]]) 1 >>> min_transpositions_to_equal_rows([[1, 2, 3, 4], [4, 3, 2, 1]]) -1","solution":"def min_transpositions_to_equal_rows(matrix): Determines if it is possible to make all rows equal by transposing submatrices, and if so, returns the minimum number of transpositions required. Parameters: matrix (list of list of int): The initial matrix. Returns: int: The minimum number of transpositions required, or -1 if not possible. n = len(matrix) m = len(matrix[0]) # If there's only one row, it's already the same and requires 0 transpositions if n == 1: return 0 # Treating each row as a tuple, to track row occurrences rows = list(map(tuple, matrix)) from collections import Counter # Counting the frequency of each row row_count = Counter(rows) # If any row appears n times, we've achieved the goal for row in row_count: if row_count[row] == n: return 0 # For each row, try to create such a condition by aggregating frequency # Analysis if we transpose rows max_count = max(row_count.values()) # The minimum number of transpositions required to make all rows equal is # n minus the max frequency count of any single row since we can't # achieve more without transforming whole rows. if max_count > 1: return n - max_count # If no such row appears, it's impossible return -1"},{"question":"def sort_books_by_binary_ones(book_ids): Sorts a list of book IDs first by the number of 1's in their binary representation (ascending), and then by their integer value (ascending). Args: - book_ids: List of integers representing book IDs. Returns: - A list of integers sorted by the described criteria. >>> sort_books_by_binary_ones([3, 7, 8, 6, 5]) [8, 3, 5, 6, 7] >>> sort_books_by_binary_ones([3, 7, 15, 31]) [3, 7, 15, 31] >>> sort_books_by_binary_ones([0, 0, 0]) [0, 0, 0] >>> sort_books_by_binary_ones([10, 1, 2]) [1, 2, 10] >>> sort_books_by_binary_ones([1048576, 512, 1024, 256]) [256, 512, 1024, 1048576] >>> sort_books_by_binary_ones([5, 9]) [5, 9]","solution":"def sort_books_by_binary_ones(book_ids): Sorts a list of book IDs first by the number of 1's in their binary representation (ascending), and then by their integer value (ascending). Args: - book_ids: List of integers representing book IDs. Returns: - A list of integers sorted by the described criteria. def count_ones(num): return bin(num).count('1') # Sort by the number of 1's in binary representation, and then by the integer value sorted_books = sorted(book_ids, key=lambda x: (count_ones(x), x)) return sorted_books"},{"question":"def largest_number(s: str) -> int: Returns the largest number that can be formed by concatenating a subset of the given integers without repeating any integer. >>> largest_number(\\"012345\\") == 543210 >>> largest_number(\\"3021\\") == 3210 >>> largest_number(\\"00000\\") == 0","solution":"def largest_number(s): Returns the largest number that can be formed by concatenating a subset of the given integers without repeating any integer. # Convert string to a set to remove duplicates and then sort in descending order unique_digits = sorted(set(s), reverse=True) # Join the sorted unique digits into a string largest_num_str = ''.join(unique_digits) # Convert the result to an integer to remove any leading zero effect return int(largest_num_str)"},{"question":"def track_queries(limit: int, queries: List[int]) -> List[bool]: Determines if each query is allowed based on the unique query limit. Parameters: limit (int): The maximum number of unique queries allowed per session. queries (list of int): The sequence of product IDs being searched during a session. Returns: list of bool: A list indicating whether each query is allowed (True) or restricted (False). >>> track_queries(3, [1, 2, 1, 3, 4, 2]) [True, True, True, True, False, True] >>> track_queries(3, [1, 2, 1, 3, 2]) [True, True, True, True, True] >>> track_queries(3, []) [] >>> track_queries(1, [0, 0, 0, 0]) [True, True, True, True] >>> track_queries(1, [1, 2, 3, 1]) [True, False, False, True] >>> track_queries(100000, [i % 1000000 for i in range(10000)]) [True,]*10000","solution":"def track_queries(limit, queries): Determines if each query is allowed based on the unique query limit. Parameters: limit (int): The maximum number of unique queries allowed per session. queries (list of int): The sequence of product IDs being searched during a session. Returns: list of bool: A list indicating whether each query is allowed (True) or restricted (False). unique_queries = set() results = [] for query in queries: if query not in unique_queries: if len(unique_queries) < limit: unique_queries.add(query) results.append(True) else: results.append(False) else: results.append(True) return results"},{"question":"def average_book_prices(n: int, q: int, books: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: For given a list of books and their respective prices, and a list of queries specifying ranges of book ratings, determine the average price of books with ratings within each range. >>> average_book_prices(5, 3, [(10, 100), (20, 200), (30, 300), (40, 400), (50, 500)], [(15, 35), (10, 50), (5, 25)]) [\\"250.00\\", \\"300.00\\", \\"150.00\\"] >>> average_book_prices(3, 2, [(10, 150), (20, 250), (30, 350)], [(40, 50), (5, 8)]) [\\"0.00\\", \\"0.00\\"]","solution":"def average_book_prices(n, q, books, queries): results = [] for a, b in queries: total_price = 0 count = 0 for r, p in books: if a <= r <= b: total_price += p count += 1 if count == 0: results.append(\\"0.00\\") else: average_price = total_price / count results.append(f\\"{average_price:.2f}\\") return results"},{"question":"def find_shortest_path(input_str: str) -> int: Determine the shortest path from a starting station to an ending station using the given network of tracks in a monorail system. The function takes a string input representing the network, the start and end stations and returns the shortest distance from start to end. If no path exists, it returns -1. >>> find_shortest_path(\\"6 7n1 2n2 3n2 4n3 4n4 5n5 6n3 6n1 6\\") 3 >>> find_shortest_path(\\"5 5n1 2n1 3n2 4n3 4n4 5n1 5\\") 3 >>> find_shortest_path(\\"4 2n1 2n3 4n1 3\\") -1 >>> find_shortest_path(\\"3 1n1 2n1 3\\") -1 >>> find_shortest_path(\\"1 0n1 1\\") 0","solution":"from collections import deque def shortest_path_monorail(num_stations, num_tracks, tracks, start, end): # Create the graph as an adjacency list graph = {i: [] for i in range(1, num_stations + 1)} for u, v in tracks: graph[u].append(v) graph[v].append(u) # BFS to find the shortest path queue = deque([(start, 0)]) # (current station, current distance) visited = set() visited.add(start) while queue: current_station, current_distance = queue.popleft() # If we have reached the end station if current_station == end: return current_distance # Visit adjacent stations for neighbor in graph[current_station]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + 1)) # If no path found return -1 # Wrapper to parse the input and call the solution function def find_shortest_path(input_str): lines = input_str.strip().split('n') num_stations, num_tracks = map(int, lines[0].split()) tracks = [list(map(int, line.split())) for line in lines[1:num_tracks+1]] start, end = map(int, lines[num_tracks+1].split()) return shortest_path_monorail(num_stations, num_tracks, tracks, start, end)"},{"question":"from typing import List, Tuple def rangeSum(N: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of N integers, perform Q range queries to find the sum of elements in the given range [L, R]. >>> rangeSum(8, [3, 4, 2, 7, 5, 8, 10, 6], [(0, 3), (2, 5), (0, 7)]) [16, 22, 45] >>> rangeSum(5, [1, 2, 3, 4, 5], [(0, 4)]) [15]","solution":"def rangeSum(N, arr, queries): # Create a prefix sum array prefix_sum = [0] * (N + 1) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] result = [] for L, R in queries: sum_range = prefix_sum[R + 1] - prefix_sum[L] result.append(sum_range) return result"},{"question":"def find_topper(students_data): Determine the overall topper based on their average marks. >>> find_topper([ ... (\\"John\\", 50, 60, 70), ... (\\"Doe\\", 100, 90, 80), ... (\\"Jane\\", 60, 70, 80), ... (\\"Smith\\", 50, 50, 50), ... (\\"Kim\\", 80, 85, 90) ... ]) [('John', 60), ('Doe', 90), ('Jane', 70), ('Smith', 50), ('Kim', 85)] >>> find_topper([ ... (\\"Alice\\", 90, 80, 85), ... (\\"Bob\\", 85, 90, 80), ... (\\"Charlie\\", 90, 80, 85) ... ]) [('Alice', 85), ('Bob', 85), ('Charlie', 85)]","solution":"def find_topper(students_data): result = [] # Iterate through each student data in the provided input for student in students_data: name, marks = student[0], student[1:] average_mark = round(sum(marks) / len(marks)) result.append((name, average_mark)) return result"},{"question":"from typing import List def transform_string(s: str) -> str: Transform the string such that all letters appear in sorted order followed by all digits in sorted order. Parameters: s (str): Input string consisting of lowercase English letters and digits. Returns: str: Transformed string with sorted letters followed by sorted digits. >>> transform_string(\\"a3c1b2\\") 'abc123' >>> transform_string(\\"b2a1c3\\") 'abc123' >>> transform_string(\\"h8e1l4l3o7\\") 'ehllo13478' >>> transform_string(\\"5g2a4b1c3\\") 'abcg12345' # Your code here def process_multiple_strings(strings: List[str]) -> List[str]: Process multiple strings as per the given test cases. Parameters: strings (list): List of input strings consisting of lowercase English letters and digits. Returns: list: List of transformed strings. >>> process_multiple_strings([\\"a3c1b2\\", \\"b2a1c3\\", \\"h8e1l4l3o7\\", \\"5g2a4b1c3\\"]) ['abc123', 'abc123', 'ehllo13478', 'abcg12345'] # Your code here # Unit tests def test_transform_single_string(): assert transform_string(\\"a3c1b2\\") == \\"abc123\\" assert transform_string(\\"b2a1c3\\") == \\"abc123\\" assert transform_string(\\"h8e1l4l3o7\\") == \\"ehllo13478\\" assert transform_string(\\"5g2a4b1c3\\") == \\"abcg12345\\" def test_process_multiple_strings(): input_strings = [\\"a3c1b2\\", \\"b2a1c3\\", \\"h8e1l4l3o7\\", \\"5g2a4b1c3\\"] expected_output = [\\"abc123\\", \\"abc123\\", \\"ehllo13478\\", \\"abcg12345\\"] assert process_multiple_strings(input_strings) == expected_output def test_empty_string(): assert transform_string(\\"\\") == \\"\\" def test_all_digits(): assert transform_string(\\"54321\\") == \\"12345\\" def test_all_letters(): assert transform_string(\\"edcba\\") == \\"abcde\\" def test_mixed_characters(): assert transform_string(\\"9ab8c7de6f5\\") == \\"abcdef56789\\"","solution":"def transform_string(s): Transform the string such that all letters appear in sorted order followed by all digits in sorted order. Parameters: s (str): Input string consisting of lowercase English letters and digits. Returns: str: Transformed string with sorted letters followed by sorted digits. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) sorted_letters = ''.join(sorted(letters)) sorted_digits = ''.join(sorted(digits)) return sorted_letters + sorted_digits def process_multiple_strings(strings): Process multiple strings as per the given test cases. Parameters: strings (list): List of input strings consisting of lowercase English letters and digits. Returns: list: List of transformed strings. result = [] for s in strings: result.append(transform_string(s)) return result"},{"question":"def sum_of_abs_differences(arr: List[int]) -> int: Given an integer array 'arr' where 1 <= len(arr) <= 1000 and 1 <= arr[i] <= 10^6, find the sum of the absolute differences between all pairs of distinct elements in the array. The result may be large, so output it modulo 10^9+7. >>> sum_of_abs_differences([1, 2, 3]) 8 >>> sum_of_abs_differences([4, 8, 6, 3]) 34 MOD = 10**9 + 7 def test_sum_of_abs_differences_sample_1(): assert sum_of_abs_differences([1, 2, 3]) == 8 def test_sum_of_abs_differences_sample_2(): assert sum_of_abs_differences([4, 8, 6, 3]) == 34 def test_sum_of_abs_differences_single_element(): assert sum_of_abs_differences([1]) == 0 # No pairs to compare, hence sum is 0 def test_sum_of_abs_differences_identical_elements(): assert sum_of_abs_differences([5, 5, 5, 5]) == 0 # All pairs have a difference of 0 def test_sum_of_abs_differences_large_numbers(): assert sum_of_abs_differences([10**6, 10**6 - 1, 10**6 - 2]) == 8 # All differences are small def test_sum_of_abs_differences_large_array(): large_array = list(range(1, 1001)) result = sum_of_abs_differences(large_array) # We can calculate the expected value explicitly, but for now just make sure it's calculable. assert result >= 0 assert result < 10**9 + 7","solution":"def sum_of_abs_differences(arr): MOD = 10**9 + 7 N = len(arr) arr.sort() total_sum = 0 total = 0 for i in range(1, N): total += arr[i] for i in range(N): total_sum = (total_sum + (total - (N - 1 - i) * arr[i]) % MOD) % MOD if i < N - 1: total -= arr[i + 1] return (2 * total_sum) % MOD"},{"question":"def transform_string(s: str) -> str: Transforms the input string by replacing each consecutive sequence of the same character with a single instance of that character followed by the length of the sequence. >>> transform_string(\\"aaabbcccc\\") 'a3b2c4' >>> transform_string(\\"aaaaa\\") 'a5' >>> transform_string(\\"aabbcc\\") 'a2b2c2' >>> transform_string(\\"abc\\") 'a1b1c1' >>> transform_string(\\"mississippi\\") 'm1i1s2i1s2i1p2i1' >>> transform_string(\\"a\\") 'a1' >>> transform_string(\\"\\") '' >>> transform_string(\\"abcdefg\\") 'a1b1c1d1e1f1g1'","solution":"def transform_string(s): Transforms the input string by replacing each consecutive sequence of the same character with a single instance of that character followed by the length of the sequence. if not s: return \\"\\" result = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: result.append(s[i - 1] + str(count)) count = 1 result.append(s[-1] + str(count)) return \\"\\".join(result)"},{"question":"def length_of_lis(nums): Returns the length of the longest increasing subsequence. Args: nums (list of int): The input list of integers. Returns: int: The length of the longest increasing subsequence. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([2]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence. Args: nums (list of int): The input list of integers. Returns: int: The length of the longest increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def assign_students_to_courses(course_limits, students_preferences): Assigns students to their highest preferred courses that still have available slots. Args: course_limits (list of int): Maximum number of students for each course. students_preferences (list of list of int): Student preferences in descending order. Returns: list of int: Number of students assigned to each course. >>> course_limits = [2, 1, 1] >>> students_preferences = [ ... [1, 2, 3], ... [2, 1, 3], ... [3, 1], ... [1, 3] ... ] >>> assign_students_to_courses(course_limits, students_preferences) [2, 1, 1] >>> course_limits = [1, 2, 1, 3] >>> students_preferences = [ ... [1, 2, 3, 4], ... [4, 3, 2, 1], ... [3, 1, 2], ... [2, 4, 3, 1], ... [1, 2, 4] ... ] >>> assign_students_to_courses(course_limits, students_preferences) [1, 2, 1, 1]","solution":"def assign_students_to_courses(course_limits, students_preferences): Assigns students to their highest preferred courses that still have available slots. Args: course_limits (list of int): Maximum number of students for each course. students_preferences (list of list of int): Student preferences in descending order. Returns: list of int: Number of students assigned to each course. m = len(course_limits) assignments = [0] * m # to track the number of students assigned to each course for preferences in students_preferences: for preferred_course in preferences: course_index = preferred_course - 1 if assignments[course_index] < course_limits[course_index]: assignments[course_index] += 1 break return assignments"},{"question":"def product_except_self(nums): Returns an array such that each element at index i is the product of all the elements of nums except nums[i]. Args: nums: List[int] - The list of integers. Returns: List[int] - The product array. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([0, 0]) [0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([5, 1]) [1, 5] >>> product_except_self([1] * 100000) [1] * 100000","solution":"def product_except_self(nums): Returns an array such that each element at index i is the product of all the elements of nums except nums[i]. n = len(nums) answer = [1] * n # Step 1: Calculate left products left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] # Step 2: Calculate right products and multiply with the left products right_product = 1 for i in range(n-1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Returns the area of the largest rectangle that can be formed using one or more contiguous rectangles from the histogram. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> largestRectangleArea([1, 1, 1, 1, 1, 1]) == 6","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed using one or more contiguous rectangles from the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def update_inventory(inventory, sales): Update inventory based on sales and return a list of item names that need to be re-ordered. Args: inventory (list of tuples): List containing items and their quantities. sales (list of tuples): List containing sales with the item names and the quantities sold. Returns: list: List of item names that need to be re-ordered. >>> update_inventory([['apple', 10], ['banana', 5], ['orange', 8]], [['apple', 4], ['orange', 5], ['banana', 5], ['apple', 6]]) ['apple', 'banana'] >>> update_inventory([['apple', 10], ['banana', 5], ['orange', 8]], []) [] >>> update_inventory([], [['apple', 4], ['orange', 5], ['banana', 5], ['apple', 6]]) [] >>> update_inventory([['apple', 10], ['banana', 5], ['orange', 8]], [['apple', 20], ['orange', 10], ['banana', 10]]) ['apple', 'banana', 'orange'] >>> update_inventory([['apple', 10], ['banana', 5], ['orange', 8]], [['apple', 1], ['banana', 2]]) []","solution":"def update_inventory(inventory, sales): Update inventory based on sales and return a list of item names that need to be re-ordered. Args: inventory (list of tuples): List containing items and their quantities. sales (list of tuples): List containing sales with the item names and the quantities sold. Returns: list: List of item names that need to be re-ordered. item_dict = {item[0]: item[1] for item in inventory} for sale in sales: item, quantity_sold = sale if item in item_dict: item_dict[item] -= quantity_sold reorder_list = [item for item, quantity in item_dict.items() if quantity <= 0] return reorder_list"},{"question":"import math from typing import Union, Tuple def find_xy(n: int) -> Union[Tuple[int, int], int]: Determine whether there are two positive integers (X, Y) such that X^2 + Y^2 = N. Return one such pair if it exists, otherwise return -1. >>> find_xy(25) (3, 4) >>> find_xy(3) -1","solution":"import math def find_xy(n): Determine whether there are two positive integers (X, Y) such that X^2 + Y^2 = N. Return one such pair if it exists, otherwise return -1. for x in range(1, int(math.isqrt(n)) + 1): y_squared = n - x**2 if y_squared > 0: y = int(math.isqrt(y_squared)) if y**2 == y_squared: return x, y return -1"},{"question":"from typing import List class ProjectManager: def __init__(self): # Initialize the project manager with a dictionary to track the status of tasks and subtasks self.status = {} def change_status(self, t: str, x: int): Change the completion status of task or subtask \`t\` to \`x\` (0 for not completed, 1 for completed). self.status[t] = x def query_status(self, t: str) -> int: Query the current completion status of task or subtask \`t\`. If \`t\` is \\"P\\", query the completion status of the entire project. if t == \\"P\\": # The project is considered completed if all tasks and subtasks are completed return int(all(self.status.values())) else: return self.status.get(t, 0) # Default to 0 if the task or subtask is not found def process_operations(n: int, operations: List[str]) -> List[int]: Process a list of operations to change or query the status of tasks and subtasks. Args: n (int): The number of operations. operations (List[str]): The list of operations. Returns: List[int]: The list of results for query operations. Example: >>> process_operations(8, [\\"C 1 1\\", \\"C 2 0\\", \\"C 3 1\\", \\"Q 1\\", \\"Q 2\\", \\"Q 3\\", \\"C P 1\\", \\"Q P\\"]) [1, 0, 1, 0] pm = ProjectManager() result = [] for op in operations: parts = op.split() if parts[0] == \\"C\\": pm.change_status(parts[1], int(parts[2])) elif parts[0] == \\"Q\\": result.append(pm.query_status(parts[1])) return result # Unit tests import pytest def test_case_1(): n = 8 operations = [ \\"C 1 1\\", \\"C 2 0\\", \\"C 3 1\\", \\"Q 1\\", \\"Q 2\\", \\"Q 3\\", \\"C P 1\\", \\"Q P\\"] expected_output = [1, 0, 1, 0] assert process_operations(n, operations) == expected_output def test_case_2(): n = 5 operations = [ \\"C 5 1\\", \\"C 6 1\\", \\"C 7 1\\", \\"Q 6\\", \\"Q P\\"] expected_output = [1, 1] assert process_operations(n, operations) == expected_output def test_case_3(): n = 3 operations = [ \\"C 10 1\\", \\"Q 10\\", \\"Q P\\"] expected_output = [1, 1] assert process_operations(n, operations) == expected_output def test_case_4(): n = 4 operations = [ \\"C 1 0\\", \\"C 2 1\\", \\"Q 1\\", \\"Q P\\"] expected_output = [0, 0] assert process_operations(n, operations) == expected_output","solution":"class ProjectManager: def __init__(self): self.status = {} def change_status(self, t, x): self.status[t] = x def query_status(self, t): if t == \\"P\\": # The project is considered completed if all tasks and subtasks are completed return int(all(self.status.values())) else: return self.status.get(t, 0) # Default to 0 if the task or subtask is not found def process_operations(n, operations): pm = ProjectManager() result = [] for op in operations: parts = op.split() if parts[0] == \\"C\\": pm.change_status(parts[1], int(parts[2])) elif parts[0] == \\"Q\\": result.append(pm.query_status(parts[1])) return result"},{"question":"def most_frequent_ip(ip_addresses): Returns the most frequent IP address in the provided list. If there is a tie, returns the one that appears first in the list. >>> most_frequent_ip([\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.1\\", \\"10.0.0.1\\", \\"192.168.1.2\\", \\"192.168.1.1\\"]) \\"192.168.1.1\\" >>> most_frequent_ip([\\"192.168.0.1\\", \\"192.168.0.1\\", \\"10.0.0.1\\", \\"10.0.0.1\\"]) \\"192.168.0.1\\" >>> most_frequent_ip([\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.3\\"]) \\"192.168.1.1\\" >>> most_frequent_ip([\\"192.168.1.1\\"] * 50000 + [\\"192.168.1.2\\"] * 49999) \\"192.168.1.1\\" >>> most_frequent_ip([\\"192.168.1.1\\", \\"10.0.0.1\\", \\"192.168.1.1\\", \\"10.0.0.1\\"]) \\"192.168.1.1\\"","solution":"def most_frequent_ip(ip_addresses): Returns the most frequent IP address in the provided list. If there is a tie, returns the one that appears first in the list. from collections import Counter ip_counter = Counter(ip_addresses) # Count occurrences of each IP max_freq = max(ip_counter.values()) # Get the maximum frequency for ip in ip_addresses: if ip_counter[ip] == max_freq: return ip"},{"question":"def is_path_exists(grid: List[str], n: int, m: int) -> str: Checks if there is a path from the top-left corner to the bottom-right corner of the grid, without moving through obstacles. >>> is_path_exists([\\"....\\",\\".#..\\",\\".#\\",\\"....\\"], 4, 4) \\"YES\\" >>> is_path_exists([\\"....\\",\\".#..\\",\\".#\\",\\"..\\"], 4, 4) \\"NO\\" >>> is_path_exists([\\".\\"], 1, 1) \\"YES\\" >>> is_path_exists([\\"#\\"], 1, 1) \\"NO\\" >>> is_path_exists([\\".\\" * 1000] * 1000, 1000, 1000) \\"YES\\" >>> is_path_exists([\\"#\\" * 1000] * 1000, 1000, 1000) \\"NO\\" >>> is_path_exists([\\"#...\\",\\"....\\",\\"....\\",\\"....\\"], 4, 4) \\"NO\\" >>> is_path_exists([\\"....\\",\\"....\\",\\"....\\",\\"...#\\"], 4, 4) \\"NO\\"","solution":"def is_path_exists(grid, n, m): Returns 'YES' if there is a path from the top-left corner to the bottom-right corner through the open cells, and 'NO' otherwise. from collections import deque # Directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' def bfs(): queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n - 1, m - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False if grid[0][0] == '#' or grid[n - 1][m - 1] == '#': return \\"NO\\" return \\"YES\\" if bfs() else \\"NO\\" # Example usage: example_grid_1 = [\\"....\\", \\".#..\\", \\".#\\", \\"....\\"] print(is_path_exists(example_grid_1, 4, 4)) # Output: YES example_grid_2 = [\\"....\\", \\".#..\\", \\".#\\", \\"..\\"] print(is_path_exists(example_grid_2, 4, 4)) # Output: NO"},{"question":"def evaluate_expression(expr: str) -> int: Evaluates a mathematical expression containing non-negative integers, +, -, and parentheses. >>> evaluate_expression(\\"1 + 2\\") 3 >>> evaluate_expression(\\"2 - (3 + 4)\\") -5 >>> evaluate_expression(\\"5 + (8 - 6) - (3 + 4)\\") 0 >>> evaluate_expression(\\"6 - (4 - (2 + 3))\\") 7","solution":"def evaluate_expression(expr): def helper(s, idx): stack = [] num = 0 sign = 1 while idx < len(s): char = s[idx] if char.isdigit(): num = num * 10 + int(char) elif char == '+': stack.append(sign * num) num = 0 sign = 1 elif char == '-': stack.append(sign * num) num = 0 sign = -1 elif char == '(': num, idx = helper(s, idx + 1) elif char == ')': stack.append(sign * num) return sum(stack), idx idx += 1 stack.append(sign * num) return sum(stack) return helper(expr, 0)"},{"question":"def word_count(text: str) -> dict: Returns a dictionary with unique words as keys and the number of times each word appears in the text as values. Ignores case. >>> word_count(\\"Hello hello world\\") {\\"hello\\": 2, \\"world\\": 1} >>> word_count(\\"This is a test This is only a test\\") {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 2, \\"only\\": 1} >>> word_count(\\"Python coding is fun Coding in python is even more fun\\") {\\"python\\": 2, \\"coding\\": 2, \\"is\\": 2, \\"fun\\": 2, \\"in\\": 1, \\"even\\": 1, \\"more\\": 1}","solution":"def word_count(text): Returns a dictionary with unique words as keys and the number of times each word appears in the text as values. Ignores case. text = text.lower() words = text.split() word_count_dict = {} for word in words: if word in word_count_dict: word_count_dict[word] += 1 else: word_count_dict[word] = 1 return word_count_dict"},{"question":"def lexicographically_smallest_string(S: str) -> str: Returns the lexicographically smallest string by moving exactly one non-empty substring to the start of the string. >>> lexicographically_smallest_string(\\"programming\\") \\"ammingprogr\\" >>> lexicographically_smallest_string(\\"abcdef\\") \\"abcdef\\"","solution":"def lexicographically_smallest_string(S): Returns the lexicographically smallest string by moving exactly one non-empty substring to the start of the string. n = len(S) min_string = S for i in range(1, n): new_string = S[i:] + S[:i] if new_string < min_string: min_string = new_string return min_string"},{"question":"def max_difference(n: int, bacteria_counts: List[int]) -> int: Returns the maximum difference in bacteria counts observed between two different days. >>> max_difference(5, [3, 8, 2, 7, 10]) 8 >>> max_difference(6, [1, 2, 3, 4, 5, 6]) 5 >>> max_difference(4, [100, 150, 200, 50]) 150 pass # Unit Test def test_max_difference_example_1(): assert max_difference(5, [3, 8, 2, 7, 10]) == 8 def test_max_difference_example_2(): assert max_difference(6, [1, 2, 3, 4, 5, 6]) == 5 def test_max_difference_example_3(): assert max_difference(4, [100, 150, 200, 50]) == 150 def test_max_difference_single_day(): try: max_difference(1, [5]) except ValueError as e: assert str(e) == \\"The number of days must be at least 2.\\" def test_max_difference_max_first_min_last(): assert max_difference(3, [10, 7, 1]) == 9 # max and min appear at the boundaries def test_max_difference_min_first_max_last(): assert max_difference(3, [1, 7, 10]) == 9 # min and max appear at the boundaries def test_max_difference_alternate_extremes(): assert max_difference(5, [1, 1000000000, 1, 1000000000, 1]) == 999999999 # alternates between min and max","solution":"def max_difference(n, bacteria_counts): Returns the maximum difference in bacteria counts observed between two different days. if n < 2: raise ValueError(\\"The number of days must be at least 2.\\") min_bacteria = bacteria_counts[0] max_bacteria = bacteria_counts[0] for count in bacteria_counts: if count < min_bacteria: min_bacteria = count if count > max_bacteria: max_bacteria = count return max_bacteria - min_bacteria"},{"question":"def removeInvalidParentheses(s: str) -> List[str]: Remove the minimum number of invalid parentheses to make the input string valid and return all possible results in lexicographical order. >>> removeInvalidParentheses(\\"()())()\\") [\\"(())()\\", \\"()()()\\"] >>> removeInvalidParentheses(\\"(a)())()\\") [\\"(a())()\\", \\"(a)()()\\"] from typing import List # Unit Tests def test_example_1(): assert removeInvalidParentheses(\\"()())()\\") == [\\"(())()\\", \\"()()()\\"] def test_example_2(): assert removeInvalidParentheses(\\"(a)())()\\") == [\\"(a())()\\", \\"(a)()()\\"] def test_edge_case_all_invalid(): assert removeInvalidParentheses(\\")(\\") == [\\"\\"] def test_no_parentheses(): assert removeInvalidParentheses(\\"abc\\") == [\\"abc\\"] def test_nested_parentheses(): assert removeInvalidParentheses(\\"(a(b)c)\\") == [\\"(a(b)c)\\"] def test_one_pair_parentheses(): assert removeInvalidParentheses(\\"(()\\") == [\\"()\\"]","solution":"def removeInvalidParentheses(s): def is_valid(string): cnt = 0 for char in string: if char == '(': cnt += 1 elif char == ')': cnt -= 1 if cnt < 0: return False return cnt == 0 def backtrack(s, start, l, r): if l == 0 and r == 0: if is_valid(s): result.add(\\"\\".join(s)) return for i in range(start, len(s)): if i != start and s[i] == s[i - 1]: continue if s[i] in ('(', ')'): curr = \\"\\".join(s[:i] + s[i + 1:]) if r > 0 and s[i] == ')': backtrack(curr, i, l, r - 1) elif l > 0 and s[i] == '(': backtrack(curr, i, l - 1, r) l = r = 0 for char in s: if char == '(': l += 1 elif char == ')': if l: l -= 1 else: r += 1 result = set() backtrack(list(s), 0, l, r) return sorted(result)"},{"question":"def sum_of_min_elements(m: int, n: int, grid: List[List[int]]) -> int: Returns the sum of the minimum elements from each row after rearranging the row in non-decreasing order. :param m: int, the number of rows in the grid :param n: int, the number of columns in the grid :param grid: List[List[int]], the grid of integers :return: int, the sum of minimal elements from each row >>> sum_of_min_elements(3, 3, [[3, 1, 2], [4, 5, 6], [7, 8, 9]]) 12 >>> sum_of_min_elements(2, 4, [[-5, -4, -3, -2], [10, 20, 30, 40]]) 5 >>> sum_of_min_elements(3, 2, [[-1, 3], [2, -2], [0, 1]]) -3","solution":"def sum_of_min_elements(m, n, grid): Returns the sum of the minimum elements from each row after rearranging the row in non-decreasing order. :param m: int, the number of rows in the grid :param n: int, the number of columns in the grid :param grid: List[List[int]], the grid of integers :return: int, the sum of minimal elements from each row # Initialize the sum sum_min_elements = 0 # Iterate through each row in the grid for row in grid: # Sort the row and take the first element (which is the minimum) row_sorted = sorted(row) # Add the minimum element to the sum sum_min_elements += row_sorted[0] return sum_min_elements"},{"question":"def is_prime(num: int) -> bool: Determine if a number is a prime. >>> is_prime(2) True >>> is_prime(4) False # Implementation here def precompute_prime_sums(arr: List[int]) -> List[int]: Precompute the prefix sums of prime numbers in the array. >>> precompute_prime_sums([1, 2, 3, 4, 5]) [0, 0, 2, 5, 5, 10] >>> precompute_prime_sums([0, 1, 1, 1]) [0, 0, 0, 0, 0] # Implementation here def power_value(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Compute the Power Value for each queried subarray. >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 5), (2, 4), (3, 3)] >>> power_value(arr, queries) [10, 5, 3] >>> arr = [10, 11, 15, 17, 19] >>> queries = [(1, 3), (2, 5), (4, 5)] >>> power_value(arr, queries) [11, 47, 36] >>> arr = [4, 6, 8, 10] >>> queries = [(1, 2), (1, 4)] >>> power_value(arr, queries) [0, 0] # Implementation here","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True # 2 is the only even prime number if num % 2 == 0: return False # other even numbers are not prime for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def precompute_prime_sums(arr): n = len(arr) prime_sums = [0] * (n + 1) for i in range(n): prime_sums[i + 1] = prime_sums[i] if is_prime(arr[i]): prime_sums[i + 1] += arr[i] return prime_sums def power_value(arr, queries): prime_sums = precompute_prime_sums(arr) results = [] for l, r in queries: results.append(prime_sums[r] - prime_sums[l - 1]) return results"},{"question":"def hollow_square(N): Create an N x N square made of asterisks (‘*’) with a hollow center. >>> hollow_square(1) \\"*\\" >>> hollow_square(3) \\"***n* *n***\\" >>> hollow_square(4) \\"****n* *n* *n****\\" >>> hollow_square(5) \\"*****n* *n* *n* *n*****\\" >>> hollow_square(6) \\"******n* *n* *n* *n* *n******\\"","solution":"def hollow_square(N): Create an N x N square made of asterisks (‘*’) with a hollow center. if N == 1: return \\"*\\" result = [] for i in range(N): if i == 0 or i == N - 1: result.append('*' * N) else: result.append('*' + ' ' * (N - 2) + '*') return 'n'.join(result)"},{"question":"def transform_string(s: str) -> str: Transforms the input string such that if the number of uppercase letters is greater than or equal to the number of lowercase letters, the whole string is converted to uppercase. Otherwise, the whole string is converted to lowercase. >>> transform_string(\\"aBcDe\\") 'abcde' >>> transform_string(\\"HelLO\\") 'HELLO' >>> transform_string(\\"PyThon\\") 'python' >>> transform_string(\\"AaB\\") 'AAB' >>> transform_string(\\"BbC\\") 'BBC' >>> transform_string(\\"HELLO\\") 'HELLO' >>> transform_string(\\"world\\") 'world' >>> transform_string(\\"a\\") 'a' >>> transform_string(\\"A\\") 'A'","solution":"def transform_string(s): Transforms the input string such that if the number of uppercase letters is greater than or equal to the number of lowercase letters, the whole string is converted to uppercase. Otherwise, the whole string is converted to lowercase. upper_count = sum(1 for char in s if char.isupper()) lower_count = len(s) - upper_count # Since the string only contains alphabets if upper_count >= lower_count: return s.upper() else: return s.lower()"},{"question":"def can_form_zigzag(heights): Determine if it is possible to rearrange the heights to form a zigzag pattern. Parameters: heights (List[int]): A list of integers representing the heights of plants. Returns: str: \\"YES\\" if it's possible to rearrange heights to form a zigzag pattern, otherwise \\"NO\\". >>> can_form_zigzag([4, 3, 7, 8, 2]) \\"YES\\" >>> can_form_zigzag([1, 2, 2]) \\"NO\\"","solution":"def can_form_zigzag(heights): Determines if it is possible to rearrange the heights to form a zigzag pattern. n = len(heights) if n == 1: return \\"YES\\" heights.sort() zigzag = [0] * n # Place smaller half first and larger half second left = 0 right = n - 1 for i in range(0, n, 2): if left <= right: zigzag[i] = heights[left] left += 1 if i + 1 < n and left <= right: zigzag[i + 1] = heights[right] right -= 1 # Check for zigzag property for i in range(1, n - 1): if not ((zigzag[i] > zigzag[i-1] and zigzag[i] > zigzag[i+1]) or (zigzag[i] < zigzag[i-1] and zigzag[i] < zigzag[i+1])): return \\"NO\\" return \\"YES\\""},{"question":"def min_operations_to_equal_elements(N: int, elements: List[int]) -> int: Returns the minimum number of operations required to make all integers in the list equal. Each operation can increment or decrement an integer by 1. Parameters: N (int): The number of elements in the list. elements (list of int): The list of positive integers. Returns: int: The minimum number of operations required. from solution import min_operations_to_equal_elements def test_single_element(): assert min_operations_to_equal_elements(1, [1000]) == 0 def test_all_elements_equal(): assert min_operations_to_equal_elements(3, [10, 10, 10]) == 0 def test_elements_in_sequence(): assert min_operations_to_equal_elements(4, [1, 2, 3, 4]) == 4 def test_prime_numbers(): assert min_operations_to_equal_elements(5, [2, 3, 5, 7, 11]) == 13 def test_large_elements(): assert min_operations_to_equal_elements(3, [1000000, 1000000, 1000000]) == 0 def test_mixed_elements(): assert min_operations_to_equal_elements(5, [10, 20, 30, 40, 50]) == 60","solution":"def min_operations_to_equal_elements(N, elements): Returns the minimum number of operations required to make all integers in the list equal. Each operation can increment or decrement an integer by 1. Parameters: N (int): The number of elements in the list. elements (list of int): The list of positive integers. Returns: int: The minimum number of operations required. # The target value should be the median of the list for the minimum operations elements.sort() median = elements[N // 2] # choosing median return sum(abs(x - median) for x in elements)"},{"question":"def can_be_equal_by_swapping(str1: str, str2: str) -> bool: Determines if str1 can be made equal to str2 by swapping at most two characters within str1. >>> can_be_equal_by_swapping('ab', 'ba') True >>> can_be_equal_by_swapping('ab', 'ab') True >>> can_be_equal_by_swapping('aaa', 'bbb') False","solution":"def can_be_equal_by_swapping(str1: str, str2: str) -> bool: Determines if str1 can be made equal to str2 by swapping at most two characters within str1. # If the strings are already equal, return True if str1 == str2: return True # List to keep track of differing characters' positions diff_indices = [] # Loop to find indices where characters differ for i in range(len(str1)): if str1[i] != str2[i]: diff_indices.append(i) # If there are exactly 2 places where they differ, check for a valid swap if len(diff_indices) == 2: i, j = diff_indices # Check if swapping makes the strings equal if str1[i] == str2[j] and str1[j] == str2[i]: return True # If there are not exactly 2 differences, or the swap doesn't make the strings equal, return False return False"},{"question":"def count_anagram_groups(words: List[str]) -> int: Count the number of anagram groups in the provided list of words. >>> count_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"tinsel\\"]) 1 >>> count_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"gogole\\"]) 2 >>> count_anagram_groups([\\"apple\\", \\"banana\\", \\"carrot\\"]) 3 >>> count_anagram_groups([\\"apple\\", \\"banana\\", \\"carrot\\", \\"dog\\", \\"egg\\"]) 5 >>> count_anagram_groups([\\"apple\\"]) 1 >>> count_anagram_groups([]) 0 >>> count_anagram_groups([\\"apple\\", \\"papel\\", \\"pale\\", \\"peal\\"]) 2","solution":"def count_anagram_groups(words): Count the number of anagram groups in the provided list of words. :param words: List of strings where each string is a word :return: Integer representing the number of anagram groups from collections import defaultdict anagram_groups = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_groups[sorted_word].append(word) return len(anagram_groups)"},{"question":"def min_moves_to_equal_elements(nums): Returns the minimum number of moves required to make all elements equal. Each move increments or decrements a number by 1. >>> min_moves_to_equal_elements([1, 2, 3]) == 2 >>> min_moves_to_equal_elements([1, 10, 2, 9]) == 16 >>> min_moves_to_equal_elements([5]) == 0 >>> min_moves_to_equal_elements([7, 7, 7, 7]) == 0 >>> min_moves_to_equal_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 25 >>> min_moves_to_equal_elements([-5, -1, -1, -5]) == 8 >>> min_moves_to_equal_elements([-10, -5, 0, 5, 10]) == 30","solution":"def min_moves_to_equal_elements(nums): Returns the minimum number of moves required to make all elements equal. Each move increments or decrements a number by 1. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"def min_boxes(t: int, test_cases: list) -> list: Determines the minimum number of boxes required to pack all items for each test case. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple consists of: - n (int): Number of items - w (int): Maximum weight capacity of a box - items (list of int): List of item weights Returns: list of int: Minimum number of boxes required for each test case >>> min_boxes(1, [(5, 10, [1, 8, 3, 5, 12])]) [3] >>> min_boxes(1, [(4, 20, [15, 10, 5, 7])]) [2]","solution":"def min_boxes(t, test_cases): Determines the minimum number of boxes required to pack all items for each test case. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple consists of: - n (int): Number of items - w (int): Maximum weight capacity of a box - items (list of int): List of item weights Returns: list of int: Minimum number of boxes required for each test case from heapq import heappush, heappop results = [] for n, w, items in test_cases: items.sort(reverse=True) # Sort items in descending order pq = [] # min-heap to manage current open boxes by their remaining capacities for item in items: placed = False for i in range(len(pq)): if pq[i] >= item: # Find if the item can fit into an existing box pq[i] -= item placed = True break if not placed: heappush(pq, w - item) # Create a new box with capacity (w - item) results.append(len(pq)) return results"},{"question":"def determine_winner(S: str) -> str: Determine whether Pia or Tony will win the game given the initial string. >>> determine_winner(\\"aabcaa\\") == \\"Pia\\" >>> determine_winner(\\"a\\") == \\"Tony\\" >>> determine_winner(\\"aaabbbccc\\") == \\"Tony\\" >>> determine_winner(\\"aaabbbcc\\") == \\"Pia\\" >>> determine_winner(\\"aabbcc\\") == \\"Pia\\" >>> determine_winner(\\"aaa\\") == \\"Tony\\" >>> determine_winner(\\"a\\" * 50000 + \\"b\\" * 50000) == \\"Pia\\" >>> determine_winner(\\"abcabcabcab\\") == \\"Tony\\"","solution":"def determine_winner(S): Determine whether Pia or Tony will win the game given the initial string. # Count frequencies of each character in the string counts = {} for char in S: if char in counts: counts[char] += 1 else: counts[char] = 1 # Count the number of characters with odd frequencies odd_count = sum(1 for count in counts.values() if count % 2 == 1) # If the number of odd frequency characters is even or zero, Pia wins. Otherwise, Tony wins. if odd_count % 2 == 0: return \\"Pia\\" else: return \\"Tony\\""},{"question":"def floyd_warshall(n, edges): Floyd-Warshall algorithm to determine the shortest distance between all pairs of nodes. pass def shortest_distances(n, edges, queries): Find the shortest distance between pairs of cities in a given representation of Geeklandia. Args: n : int : Number of cities (2 ≤ n ≤ 100) edges : List[Tuple[int, int, int]] : List of roads where each road is represented as a tuple (u, v, w) queries : List[Tuple[int, int]] : Queries to find the shortest distance between pairs of cities Returns: List[int] : List of shortest distances for each query Examples: >>> n = 4 >>> edges = [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7)] >>> queries = [(1, 4), (2, 4), (1, 1)] >>> shortest_distances(n, edges, queries) [9, 8, 0] pass def test_floyd_warshall_basic(): edges = [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7)] n = 4 dist = floyd_warshall(n, edges) assert dist[1][4] == 9 assert dist[2][4] == 8 assert dist[1][1] == 0 def test_shortest_distances(): n = 4 edges = [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7)] queries = [(1, 4), (2, 4), (1, 1)] assert shortest_distances(n, edges, queries) == [9, 8, 0] def test_non_connected_cities(): n = 4 edges = [(1, 2, 4), (3, 4, 2)] queries = [(1, 3), (2, 4)] assert shortest_distances(n, edges, queries) == [-1, -1] def test_same_city(): n = 4 edges = [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7)] queries = [(1, 1), (2, 2), (3, 3), (4, 4)] assert shortest_distances(n, edges, queries) == [0, 0, 0, 0]","solution":"def floyd_warshall(n, edges): Floyd-Warshall algorithm to determine the shortest distance between all pairs of nodes. # Initialize distance array dist = [[float('inf')] * (n + 1) for _ in range(n + 1)] # Distance from any node to itself is 0 for i in range(1, n + 1): dist[i][i] = 0 # Fill initial distances with given edges for u, v, w in edges: dist[u][v] = w dist[v][u] = w # Floyd-Warshall algorithm for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def shortest_distances(n, edges, queries): dist = floyd_warshall(n, edges) results = [] for a, b in queries: if dist[a][b] != float('inf'): results.append(dist[a][b]) else: results.append(-1) return results"},{"question":"def max_stability_value(M, weights): Determine the maximum possible stability value of any subsequence of stones. Parameters: M (int): Number of stones weights (list of int): Weights of the stones Returns: float: Maximum possible stability value formatted to six decimal places Example: >>> max_stability_value(6, [3, 1, 4, 1, 5, 9]) 5.000000 >>> max_stability_value(5, [3, 1, 4, 1, 5]) 3.000000 >>> max_stability_value(1, [7]) 7.000000 >>> max_stability_value(2, [8, 10]) 9.000000","solution":"def max_stability_value(M, weights): Returns the maximum possible stability value of any subsequence of stones. Parameters: M (int): Number of stones weights (list of int): Weights of the stones Returns: float: Maximum possible stability value formatted to six decimal places weights.sort() if M % 2 == 1: # If the number of stones is odd, find the middle stone. stability_value = weights[M // 2] else: # If the number of stones is even, find the average of the two middle stones. stability_value = (weights[(M // 2) - 1] + weights[M // 2]) / 2.0 return round(stability_value, 6) # Example usage (this line should not be part of the final solution module): # print(max_stability_value(6, [3, 1, 4, 1, 5, 9])) # Output: 5.000000"},{"question":"def find_path_with_sum(matrix, N, M, k): Given a rectangular matrix of size NxM, consisting of integers and a specific target value k, find a path from the top-left corner to the bottom-right corner such that the sum of the integers along the path is equal to k. You can only move right or down at each step. Parameters: matrix: List[List[int]] - The matrix of integers N: int - Number of rows in the matrix M: int - Number of columns in the matrix k: int - The target sum to find along a path Returns: str - \\"YES\\" if such a path exists, otherwise \\"NO\\" >>> find_path_with_sum([ [5, 9, 6], [1, 2, 4], [8, 3, 7] ], 3, 3, 19) \\"YES\\" >>> find_path_with_sum([ [5, 9, 6], [1, 2, 4], [8, 3, 7] ], 3, 3, 12) \\"NO\\"","solution":"def find_path_with_sum(matrix, N, M, k): Function to determine if there is a path from top-left to bottom-right in a given NxM matrix such that the sum of the path is equal to k. from collections import deque def is_valid(x, y): return 0 <= x < N and 0 <= y < M # Directions for right (0, 1) and down (1, 0) movements directions = [(0, 1), (1, 0)] # Use a deque to implement BFS queue = deque([(0, 0, matrix[0][0])]) while queue: x, y, current_sum = queue.popleft() # Check if we've reached the bottom-right corner if x == N - 1 and y == M - 1: if current_sum == k: return \\"YES\\" # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): queue.append((nx, ny, current_sum + matrix[nx][ny])) return \\"NO\\""},{"question":"def max_unique_path_length(grid): Determine the maximum length of a contiguous path in a grid of characters, where each cell in the path contains a different letter. You can move up, down, left, or right. >>> grid = [ ... \\"abcd\\", ... \\"efgh\\", ... \\"ijkl\\", ... \\"mnop\\" ... ] >>> max_unique_path_length(grid) 16 >>> grid = [\\"abcde\\"] >>> max_unique_path_length(grid) 5 >>> grid = [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] >>> max_unique_path_length(grid) 5 >>> grid = [ ... \\"ab\\", ... \\"cd\\" ... ] >>> max_unique_path_length(grid) 4 >>> grid = [ ... \\"aa\\", ... \\"aa\\" ... ] >>> max_unique_path_length(grid) 1 >>> grid = [ ... \\"abca\\", ... \\"bcdb\\", ... \\"cadc\\" ... ] >>> max_unique_path_length(grid) 4","solution":"def max_unique_path_length(grid): M = len(grid) N = len(grid[0]) if M > 0 else 0 def dfs(x, y, visited): max_length = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] not in visited: max_length = max(max_length, 1 + dfs(nx, ny, visited | {grid[nx][ny]})) return max_length max_path = 0 for i in range(M): for j in range(N): max_path = max(max_path, dfs(i, j, {grid[i][j]})) return max_path"},{"question":"from typing import List, Tuple def min_operations_to_equal_elements(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of integers, find the minimum number of operations required to make all elements in the array equal. An operation consists of selecting any two indices i and j (1 <= i, j <= N, i != j) and setting A[i] = A[j]. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing an integer N and a list of N integers. Returns: List[int]: A list of integers representing the minimum number of operations required for each test case. >>> min_operations_to_equal_elements(2, [(4, [1, 2, 3, 4]), (5, [10, 10, 10, 10, 10])]) [3, 0] >>> min_operations_to_equal_elements(1, [(3, [1, 1, 1])]) [0]","solution":"def min_operations_to_equal_elements(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] freq = {} for num in A: if num in freq: freq[num] += 1 else: freq[num] = 1 max_freq = max(freq.values()) min_ops = N - max_freq results.append(min_ops) return results"},{"question":"def geometric_sequence_elements(a, r, n): Returns the first n elements of a geometric sequence with the given first element a and common ratio r. Args: - a (int): the first element of the sequence - r (int): the common ratio of the sequence - n (int): the number of elements in the sequence Returns: - str: a string of the first n elements, separated by a comma and a space >>> geometric_sequence_elements(2, 3, 4) '2, 6, 18, 54' >>> geometric_sequence_elements(5, 1, 5) '5, 5, 5, 5, 5' >>> geometric_sequence_elements(7, 2, 1) '7' >>> geometric_sequence_elements(2, -2, 4) '2, -4, 8, -16' >>> geometric_sequence_elements(1, 10, 5) '1, 10, 100, 1000, 10000'","solution":"def geometric_sequence_elements(a, r, n): Returns the first n elements of a geometric sequence with the given first element a and common ratio r. Args: - a (int): the first element of the sequence - r (int): the common ratio of the sequence - n (int): the number of elements in the sequence Returns: - str: a string of the first n elements, separated by a comma and a space elements = [a * r ** i for i in range(n)] return ', '.join(map(str, elements))"},{"question":"def minEnergyCost(grid): Determine the minimum total energy cost required to reach the bottom-right cell from the top-left cell. >>> minEnergyCost([ ... [1, 3, 1], ... [2, 3, 2], ... [4, 5, 1] ... ]) == 4 >>> minEnergyCost([ ... [1, 2, 3, 4] ... ]) == 3 >>> minEnergyCost([ ... [1], ... [2], ... [3], ... [4] ... ]) == 3 >>> minEnergyCost([ ... [5, 5, 5], ... [5, 5, 5] ... ]) == 0 >>> minEnergyCost([ ... [1, 1000], ... [1000, 1] ... ]) == 1998 >>> minEnergyCost([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0","solution":"def minEnergyCost(grid): n = len(grid) m = len(grid[0]) dp = [[float('inf')] * m for _ in range(n)] dp[0][0] = 0 for i in range(n): for j in range(m): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + abs(grid[i][j] - grid[i-1][j])) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + abs(grid[i][j] - grid[i][j-1])) return dp[n-1][m-1]"},{"question":"def generate_binary_strings(n: int, m: int, numbers: List[int]) -> List[str]: Converts a list of numerical identifiers to binary strings of a specified length. >>> generate_binary_strings(3, 8, [5, 18, 255]) ['00000101', '00010010', '11111111'] >>> generate_binary_strings(5, 4, [1, 2, 3, 4, 7]) ['0001', '0010', '0011', '0100', '0111'] >>> generate_binary_strings(2, 6, [15, 32]) ['001111', '100000']","solution":"def generate_binary_strings(n, m, numbers): Converts a list of numerical identifiers to binary strings of a specified length. Parameters: n (int): The number of numerical identifiers. m (int): The length of the binary strings. numbers (list of int): The list of numerical identifiers. Returns: list of str: The list of binary strings. binary_strings = [] for number in numbers: binary_string = format(number, '0{}b'.format(m)) binary_strings.append(binary_string) return binary_strings # Example usage: # n = 3, m = 8, numbers = [5, 18, 255] # The output should be: ['00000101', '00010010', '11111111']"},{"question":"def make_palindrome(S: str) -> str: Given a string S, transform it using replace and transpose operations into a palindromic string. If it is not possible to transform S into a palindrome, return \\"Not Possible\\". If multiple transformations can make S palindromic, return the lexicographically smallest one. >>> make_palindrome(\\"abccba\\") 'abccba' >>> make_palindrome(\\"aabbac\\") 'Not Possible' >>> make_palindrome(\\"abba\\") 'abba' >>> make_palindrome(\\"aabbccdde\\") 'abcdedcba' >>> make_palindrome(\\"abcdeedcba\\") 'abcdeedcba' >>> make_palindrome(\\"a\\") 'a' >>> make_palindrome(\\"\\") '' >>> make_palindrome(\\"aaabb\\") 'ababa' >>> make_palindrome(\\"aaabbbccc\\") 'Not Possible'","solution":"def make_palindrome(S): def is_palindrome(s): return s == s[::-1] from collections import Counter count = Counter(S) odd_count = sum(1 for x in count.values() if x % 2 != 0) # If there are more than one odd character count, it's not possible to form a palindrome if odd_count > 1: return \\"Not Possible\\" half = [] middle = '' for c in sorted(count): if count[c] % 2 != 0: middle = c half.append(c * (count[c] // 2)) half_str = ''.join(half) return half_str + middle + half_str[::-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def leafPathSum(root: TreeNode) -> int: Given a binary tree, find the sum of all root-to-leaf path numbers. Each root-to-leaf path represents a number formed by concatenating the node values along the path. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> leafPathSum(root) 25 >>> root = TreeNode(4) >>> root.left = TreeNode(9) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(1) >>> leafPathSum(root) 1026","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def leafPathSum(root): def helper(node, current_sum): if not node: return 0 current_sum = current_sum * 10 + node.val if not node.left and not node.right: return current_sum return helper(node.left, current_sum) + helper(node.right, current_sum) return helper(root, 0)"},{"question":"from typing import List def minimum_time(n: int, time: List[int]) -> int: Returns the minimum time required to complete tasks at all checkpoints. Parameters: n (int): Number of checkpoints time (List[int]): Time required at each checkpoint Returns: int: Total minimum time to complete all tasks >>> minimum_time(5, [2, 1, 3, 2, 4]) 12 >>> minimum_time(1, [5]) 5 >>> minimum_time(4, [1, 1, 1, 1]) 4 >>> minimum_time(3, [100, 100, 100]) 300 >>> minimum_time(3, [10, 1, 7]) 18 >>> minimum_time(6, [1, 2, 1, 2, 1, 2]) 9","solution":"from typing import List def minimum_time(n: int, time: List[int]) -> int: Returns the minimum time required to complete tasks at all checkpoints. Parameters: n (int): Number of checkpoints time (List[int]): Time required at each checkpoint Returns: int: Total minimum time to complete all tasks return sum(time)"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. :param s: input string :return: longest palindromic substring >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"abcde\\") \\"a\\" >>> longest_palindromic_substring(\\"abccba\\") \\"abccba\\" >>> longest_palindromic_substring(\\"racecar\\") \\"racecar\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"aaaa\\") \\"aaaa\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. :param s: input string :return: longest palindromic substring if not s: return \\"\\" n = len(s) start = 0 max_length = 1 # Create a table to store lengths of palindrome substrings dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for substrings of length 2. for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2. for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # Check if the current substring is a palindrome if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"from collections import defaultdict from typing import List, Tuple def subtree_sums(n: int, node_values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Compute the sum of the values of all nodes within a sub-tree rooted at a given node. Parameters: n (int): the number of nodes in the tree. node_values (List[int]): values of the nodes in the tree. edges (List[Tuple[int, int]]): edges defining the tree structure. queries (List[int]): queries for sub-tree sums. Returns: List[int]: the sum of the values for the sub-trees specified in queries. pass # Unit tests def test_example_case(): n = 5 node_values = [10, 20, 30, 40, 50] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [1, 3, 4] expected = [150, 120, 40] assert subtree_sums(n, node_values, edges, queries) == expected def test_single_node_tree(): n = 1 node_values = [5] edges = [] queries = [1] expected = [5] assert subtree_sums(n, node_values, edges, queries) == expected def test_line_tree(): n = 4 node_values = [1, 2, 3, 4] edges = [(1, 2), (2, 3), (3, 4)] queries = [1, 2, 3, 4] expected = [10, 9, 7, 4] assert subtree_sums(n, node_values, edges, queries) == expected def test_star_tree(): n = 5 node_values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (1, 4), (1, 5)] queries = [1, 2, 3, 4, 5] expected = [15, 2, 3, 4, 5] assert subtree_sums(n, node_values, edges, queries) == expected def test_disjoint_queries(): n = 6 node_values = [3, 6, 2, 1, 4, 5] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] queries = [1, 2, 5] expected = [21, 11, 4] assert subtree_sums(n, node_values, edges, queries) == expected","solution":"from collections import defaultdict def subtree_sums(n, node_values, edges, queries): # Build the graph tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to perform DFS and calculate subtree sums def dfs(node, parent): subtree_sum[node] = node_values[node-1] for neighbor in tree[node]: if neighbor != parent: subtree_sum[node] += dfs(neighbor, node) return subtree_sum[node] subtree_sum = [0] * (n + 1) dfs(1, -1) return [subtree_sum[v] for v in queries]"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, ignoring case, spaces, and non-alphanumeric characters. Returns False otherwise. >>> is_anagram(\\"listen\\", \\"silent\\") == True >>> is_anagram(\\"triangle\\", \\"integral\\") == True >>> is_anagram(\\"Astronomer\\", \\"Moon starer!\\") == True >>> is_anagram(\\"rat\\", \\"car\\") == False >>> is_anagram(\\"A1B2\\", \\"B1A2\\") == True >>> is_anagram(\\"\\", \\"\\") == False >>> is_anagram(\\"nonempty\\", \\"\\") == False","solution":"def is_anagram(s1, s2): Returns True if s1 and s2 are anagrams, ignoring case, spaces, and non-alphanumeric characters. Returns False otherwise. def clean_string(s): return ''.join(c.lower() for c in s if c.isalnum()) cleaned_s1 = clean_string(s1) cleaned_s2 = clean_string(s2) if not cleaned_s1 or not cleaned_s2: return False return sorted(cleaned_s1) == sorted(cleaned_s2)"},{"question":"def maximize_data_transfer(T, test_cases): Determine the maximum amount of data that can be transferred if each device can be used such that no two devices overlap their operating times. Input: - T: An integer denoting the number of test cases. - test_cases: A list of dictionaries where each dictionary has the following keys: - 'N': The number of devices in the test case. - 'rates': A list of integers representing data transfer rates of each device. - 'times': A list of integers representing the operating times of each device. Output: - A list of integers where each integer represents the maximum amount of data that can be transferred for each test case. >>> maximize_data_transfer(1, [{'N': 3, 'rates': [10, 20, 30], 'times': [1, 2, 3]}]) [140] >>> maximize_data_transfer(2, [{'N': 3, 'rates': [10, 20, 30], 'times': [1, 2, 3]}, {'N': 2, 'rates': [5, 10], 'times': [4, 5]}]) [140, 70] pass def process_input(input_str): Process the input string into the required format. Input: - input_str: A string containing the raw input for the problem. Output: - A tuple containing: - An integer T denoting the number of test cases. - A list of dictionaries for each test case with keys 'N', 'rates', and 'times'. >>> process_input(\\"1n3n10 20 30n1 2 3n\\") (1, [{'N': 3, 'rates': [10, 20, 30], 'times': [1, 2, 3]}]) pass def get_output_str(results): Convert a list of results into a formatted string. Input: - results: A list of integers representing the results for each test case. Output: - A string with each result on a new line. >>> get_output_str([140, 70]) \\"140n70\\" pass","solution":"def maximize_data_transfer(T, test_cases): results = [] for case in test_cases: N = case['N'] rates = case['rates'] times = case['times'] # Combining rates and times to calculate data for each device data = [rates[i] * times[i] for i in range(N)] # Summing up the data total_data = sum(data) results.append(total_data) return results def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) rates = list(map(int, lines[index + 1].split())) times = list(map(int, lines[index + 2].split())) test_cases.append({'N': N, 'rates': rates, 'times': times}) index += 3 return T, test_cases def get_output_str(results): return 'n'.join(map(str, results)) if __name__ == \\"__main__\\": import sys input_str = sys.stdin.read() T, test_cases = process_input(input_str) results = maximize_data_transfer(T, test_cases) output_str = get_output_str(results) print(output_str)"},{"question":"import heapq from typing import List def min_path_cost(grid: List[List[int]]) -> int: Compute the minimum possible cost to travel from the top-left to the bottom-right of the grid. >>> grid1 = [ ... [1, 3, 5], ... [2, 8, 2], ... [4, 6, 1] ... ] >>> min_path_cost(grid1) 8 >>> grid2 = [ ... [1, 2], ... [3, 4] ... ] >>> min_path_cost(grid2) 3","solution":"import heapq def min_path_cost(grid): n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(0, 0, 0)] # (cost, x, y) costs = [[float('inf')] * m for _ in range(n)] costs[0][0] = 0 while pq: cost, x, y = heapq.heappop(pq) if x == n-1 and y == m-1: return cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = cost + abs(grid[nx][ny] - grid[x][y]) if new_cost < costs[nx][ny]: costs[nx][ny] = new_cost heapq.heappush(pq, (new_cost, nx, ny)) return -1 # in theory, we should never reach here # Example usage: grid1 = [ [1, 3, 5], [2, 8, 2], [4, 6, 1] ] print(min_path_cost(grid1)) # Output: 8 grid2 = [ [1, 2], [3, 4] ] print(min_path_cost(grid2)) # Output: 3"},{"question":"def rearrange(A): Rearranges the array A such that all odd numbers appear before all even numbers, while preserving the relative order. pass def test_rearrange_all_odds_at_start(): assert rearrange([1, 2, 3, 4, 5, 6]) == [1, 3, 5, 2, 4, 6] def test_rearrange_mixed_numbers(): assert rearrange([4, 6, 3, 7, 8, 5]) == [3, 7, 5, 4, 6, 8] def test_rearrange_all_evens(): assert rearrange([2, 4, 6, 8]) == [2, 4, 6, 8] def test_rearrange_all_odds(): assert rearrange([1, 3, 5, 7]) == [1, 3, 5, 7] def test_rearrange_single_element(): assert rearrange([1]) == [1] assert rearrange([2]) == [2] def test_rearrange_no_elements(): assert rearrange([]) == [] def test_rearrange_large_input(): large_input = list(range(1, 100001)) rearrange(large_input) assert large_input[:50000] == list(range(1, 100001, 2)) assert large_input[50000:] == list(range(2, 100001, 2))","solution":"def rearrange(A): Rearranges the array A such that all odd numbers appear before all even numbers, while preserving the relative order. # Two-pointer technique odd_index = 0 for i in range(len(A)): if A[i] % 2 != 0: A.insert(odd_index, A.pop(i)) odd_index += 1 return A"},{"question":"def find_sequence(N: int, M: int) -> str: Determines whether a sequence of length N can be constructed such that every range [1, M] appears exactly once in every contiguous subsequence of length M. Returns 'No' if it cannot be constructed or the sequence if it is possible. >>> find_sequence(5, 3) \\"Yesn1 2 3 1 2\\" >>> find_sequence(4, 4) \\"Yesn1 2 3 4\\" >>> find_sequence(3, 4) \\"No\\" pass","solution":"def find_sequence(N, M): Determines whether a sequence of length N can be constructed such that every range [1, M] appears exactly once in every contiguous subsequence of length M. Returns 'No' if it cannot be constructed or the sequence if it is possible. if M > N: return \\"No\\" sequence = [] for i in range(N): sequence.append((i % M) + 1) return f\\"Yesn{' '.join(map(str, sequence))}\\""},{"question":"def largest_equal_submatrix(matrix): Finds the area of the largest submatrix where all elements are equal. >>> largest_equal_submatrix([ ... [1, 2, 2, 2], ... [2, 2, 2, 2], ... [2, 2, 2, 1] ... ]) == 6 >>> largest_equal_submatrix([ ... [5, 5], ... [5, 5] ... ]) == 4 >>> largest_equal_submatrix([ ... [7] ... ]) == 1 >>> largest_equal_submatrix([ ... [1, 2], ... [3, 4] ... ]) == 1 >>> largest_equal_submatrix([ ... [1, 1, 1, 0, 0], ... [1, 1, 1, 0, 0], ... [1, 1, 1, 0, 0], ... [0, 0, 0, 2, 2], ... [0, 0, 0, 2, 2] ... ]) == 9 >>> largest_equal_submatrix([ ... [1, 1, 1], ... [2, 2, 2] ... ]) == 3 >>> largest_equal_submatrix([ ... [1, 2], ... [1, 2], ... [1, 2] ... ]) == 3","solution":"def largest_equal_submatrix(matrix): Finds the area of the largest submatrix where all elements are equal. n = len(matrix) m = len(matrix[0]) # Function to check and find the largest submatrix starting from (i, j) def find_submatrix_area(i, j): value = matrix[i][j] height = 0 max_area = 0 for row in range(i, n): if matrix[row][j] != value: break height += 1 width = 0 for col in range(j, m): if matrix[row][col] != value: break width += 1 max_area = max(max_area, height * width) return max_area max_area = 0 for i in range(n): for j in range(m): max_area = max(max_area, find_submatrix_area(i, j)) return max_area"},{"question":"def sort_students(names_scores): Given a list of tuples containing student names and their scores, returns the list of names sorted by total score in descending order. If two students have the same total score, their names are sorted in alphabetical order. Args: names_scores (List[Tuple[str, int, int]]): List of tuples where each tuple contains a student's name and two scores. Returns: List[str]: List of student names sorted by total score in descending order. Example: >>> sort_students([(\\"Alice\\", 90, 95), (\\"Bob\\", 80, 85), (\\"Charlie\\", 85, 90), (\\"David\\", 90, 95)]) [\\"Alice\\", \\"David\\", \\"Charlie\\", \\"Bob\\"] pass def read_input(lines): Reads the input from a list of strings and returns the number of students and their details as a list of tuples. Args: lines (List[str]): List of input lines containing number of students and their details. Returns: List[Tuple[str, int, int]]: List of tuples where each tuple contains a student's name and two scores. Example: >>> read_input([\\"4\\", \\"Alice 90 95\\", \\"Bob 80 85\\", \\"Charlie 85 90\\", \\"David 90 95\\"]) [(\\"Alice\\", 90, 95), (\\"Bob\\", 80, 85), (\\"Charlie\\", 85, 90), (\\"David\\", 90, 95)] pass from solution import sort_students, read_input def test_sort_students(): input_data = [\\"4\\", \\"Alice 90 95\\", \\"Bob 80 85\\", \\"Charlie 85 90\\", \\"David 90 95\\"] names_scores = read_input(input_data) sorted_names = sort_students(names_scores) assert sorted_names == [\\"Alice\\", \\"David\\", \\"Charlie\\", \\"Bob\\"] def test_sort_students_single_student(): input_data = [\\"1\\", \\"Alice 90 95\\"] names_scores = read_input(input_data) sorted_names = sort_students(names_scores) assert sorted_names == [\\"Alice\\"] def test_sort_students_same_scores_different_names(): input_data = [\\"3\\", \\"Alice 85 90\\", \\"Bob 85 90\\", \\"Charlie 85 90\\"] names_scores = read_input(input_data) sorted_names = sort_students(names_scores) assert sorted_names == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_sort_students_variety_scores(): input_data = [\\"4\\", \\"Alice 100 50\\", \\"Bob 60 80\\", \\"Charlie 90 90\\", \\"David 100 50\\"] names_scores = read_input(input_data) sorted_names = sort_students(names_scores) assert sorted_names == [\\"Charlie\\", \\"Alice\\", \\"David\\", \\"Bob\\"]","solution":"def sort_students(names_scores): Given a list of tuples containing student names and their scores, returns the list of names sorted by total score in descending order. If two students have the same total score, their names are sorted in alphabetical order. students = [] for ns in names_scores: name, score1, score2 = ns[0], int(ns[1]), int(ns[2]) total_score = score1 + score2 students.append((name, total_score)) students.sort(key=lambda x: (-x[1], x[0])) sorted_names = [student[0] for student in students] return sorted_names def read_input(lines): Reads the input from a list of strings and returns the number of students and their details as a list of tuples. n = int(lines[0]) names_scores = [line.split() for line in lines[1:n+1]] return names_scores"},{"question":"def process_grid_operations(N: int, M: int, grid: List[List[int]], Q: int, operations: List[List[int]]) -> List[List[int]]: Perform a series of operations on the grid and return the final grid. Args: - N (int): Number of rows in the grid. - M (int): Number of columns in the grid. - grid (List[List[int]]): The initial grid. - Q (int): Number of operations. - operations (List[List[int]]): A list of operations represented as lists. Returns: - List[List[int]]: The state of the grid after applying all the operations. >>> N, M = 2, 2 >>> grid = [ ... [1, 2], ... [3, 4] ... ] >>> Q = 3 >>> operations = [ ... [1, 1, 1, 1, 1, 2], ... [2, 2, 2, 2, 2, 5], ... [1, 1, 1, 2, 2, 1] ... ] >>> process_grid_operations(N, M, grid, Q, operations) [[4, 3], [4, 6]] >>> N, M = 1, 1 >>> grid = [[7]] >>> Q = 1 >>> operations = [[1, 1, 1, 1, 1, 1]] >>> process_grid_operations(N, M, grid, Q, operations) [[8]] >>> N, M = 1, 1 >>> grid = [[7]] >>> Q = 1 >>> operations = [[2, 1, 1, 1, 1, 5]] >>> process_grid_operations(N, M, grid, Q, operations) [[5]] >>> N, M = 3, 3 >>> grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> Q = 1 >>> operations = [[1, 1, 1, 3, 3, 1]] >>> process_grid_operations(N, M, grid, Q, operations) [[2, 3, 4], [5, 6, 7], [8, 9, 10]] >>> N, M = 3, 3 >>> grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> Q = 1 >>> operations = [[2, 1, 1, 3, 3, 0]] >>> process_grid_operations(N, M, grid, Q, operations) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] pass","solution":"def process_grid_operations(N, M, grid, Q, operations): for op in operations: op_type, x1, y1, x2, y2, val = op for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): if op_type == 1: grid[i][j] += val elif op_type == 2: grid[i][j] = val return grid # Reading input def main(): import sys input = sys.stdin.read data = input().split() idx = 0 N = int(data[idx]) M = int(data[idx+1]) idx += 2 grid = [] for i in range(N): grid.append(list(map(int, data[idx]))) idx += 1 Q = int(data[idx]) idx += 1 operations = [] for _ in range(Q): operations.append(list(map(int, data[idx:idx+6]))) idx += 6 result = process_grid_operations(N, M, grid, Q, operations) for row in result: print(\\"\\".join(map(str, row))) if __name__ == \\"__main__\\": main()"},{"question":"def longest_increasing_subsequence(nums: List[int]) -> int: Write a function that takes an integer array as input and returns the length of the longest increasing subsequence within that array. A subsequence is a sequence derived from another sequence by deleting some or none of the elements without changing the order of the remaining elements. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence in the array. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def second_minimum(arr): Returns the second minimum value in the array. If the array is None or contains less than 2 unique elements, return None. pass # Unit tests from solution import second_minimum def test_second_minimum_normal_case(): assert second_minimum([3, 1, 4, 1, 5, 9, 2]) == 2 def test_second_minimum_with_duplicates(): assert second_minimum([2, 2, 1, 1, 3, 3]) == 2 def test_second_minimum_with_negatives(): assert second_minimum([-5, -4, -7, -2, -1]) == -5 def test_second_minimum_none_input(): assert second_minimum(None) == None def test_second_minimum_single_element(): assert second_minimum([1]) == None def test_second_minimum_all_duplicates(): assert second_minimum([2, 2, 2, 2]) == None def test_second_minimum_two_elements(): assert second_minimum([5, 3]) == 5 def test_second_minimum_sorted_array(): assert second_minimum([1, 2, 3, 4]) == 2 def test_second_minimum_reverse_sorted_array(): assert second_minimum([4, 3, 2, 1]) == 2","solution":"def second_minimum(arr): Returns the second minimum value in the array. If the array is None or contains less than 2 unique elements, return None. if arr is None: return None unique_elements = sorted(set(arr)) if len(unique_elements) < 2: return None return unique_elements[1]"},{"question":"class LibraryCatalog: def __init__(self): self.catalog = {} self.book_categories = {} def add_book(self, book_id: int, categories: List[str]) -> None: Adds a book with book_id to the catalog under the specified categories. pass def remove_book(self, book_id: int) -> None: Removes the book with book_id from the catalog. pass def get_books_by_category(self, category: str) -> List[int]: Retrieves a list of book_ids that fall under the given category, sorted in ascending order. pass def process_commands(commands: List[str]) -> List[List[int]]: Processes a list of commands to manipulate and retrieve data from the book catalog. >>> process_commands([\\"add_book 1 fiction mystery\\", \\"add_book 2 science fiction\\", \\"add_book 3 mystery\\", \\"get_books_by_category fiction\\", \\"get_books_by_category mystery\\", \\"remove_book 1\\", \\"get_books_by_category fiction\\", \\"get_books_by_category mystery\\", \\"end\\"]) [[1, 2], [1, 3], [2], [3]] >>> process_commands([\\"get_books_by_category non_existent\\", \\"end\\"]) [[]] >>> process_commands([\\"add_book 1 fiction\\", \\"remove_book 2\\", \\"get_books_by_category fiction\\", \\"end\\"]) [[1]] >>> process_commands([\\"add_book 5 science fiction\\", \\"add_book 6 science\\", \\"get_books_by_category science\\", \\"remove_book 5\\", \\"get_books_by_category science\\", \\"remove_book 6\\", \\"get_books_by_category science\\", \\"end\\"]) [[5, 6], [6], []] pass # Diagnostic function to simulate inputs and retrieve outputs def simulate_library_operations(input_commands: str) -> List[List[int]]: Simulates the library operations based on input commands. commands = input_commands.strip().split('n') outputs = process_commands(commands[:-1]) # Exclude the last \\"end\\" command return outputs","solution":"class LibraryCatalog: def __init__(self): self.catalog = {} self.book_categories = {} def add_book(self, book_id, categories): if book_id in self.book_categories: return self.book_categories[book_id] = set(categories) for category in categories: if category not in self.catalog: self.catalog[category] = set() self.catalog[category].add(book_id) def remove_book(self, book_id): if book_id not in self.book_categories: return categories = self.book_categories.pop(book_id) for category in categories: self.catalog[category].remove(book_id) if len(self.catalog[category]) == 0: self.catalog.pop(category) def get_books_by_category(self, category): if category not in self.catalog: return [] return sorted(self.catalog[category]) def process_commands(commands): library = LibraryCatalog() results = [] for command in commands: parts = command.split() if parts[0] == \\"add_book\\": book_id = int(parts[1]) categories = parts[2:] library.add_book(book_id, categories) elif parts[0] == \\"remove_book\\": book_id = int(parts[1]) library.remove_book(book_id) elif parts[0] == \\"get_books_by_category\\": category = parts[1] result = library.get_books_by_category(category) results.append(result) return results # Diagnostic function to simulate inputs and retrieve outputs def simulate_library_operations(input_commands): commands = input_commands.strip().split('n') outputs = process_commands(commands[:-1]) # Exclude the last \\"end\\" command return outputs"},{"question":"def min_bushes_to_prune(test_cases): Calculate the minimum number of bushes that need to be pruned to reduce their height to be at most the target height. Args: test_cases (List[Dict]): A list of dictionaries, where each dictionary represents a test case with: 'meta': A tuple containing the number of bushes and the target height. 'heights': A list of integers representing the heights of the bushes. Returns: List[int]: A list of integers where each integer represents the minimum number of bushes that need to be pruned for the corresponding test case. Example: >>> test_cases = [ ... {'meta': (3, 15), 'heights': [18, 13, 20]}, ... {'meta': (5, 10), 'heights': [5, 15, 10, 20, 5]} ... ] >>> min_bushes_to_prune(test_cases) [2, 3]","solution":"def min_bushes_to_prune(test_cases): results = [] for case in test_cases: N, target_height = case['meta'] heights = case['heights'] count = sum(1 for height in heights if height > target_height) results.append(count) return results"},{"question":"def find_number_of_islands(test_cases: List[List[List[int]]]) -> List[int]: Determine the number of unique islands in each test case provided. Args: test_cases (List): A list containing the test cases, where each test case is a 2D grid represented by a list of lists of integers (0's and 1's). Returns: List[int]: A list of integers where each integer represents the number of unique islands in the corresponding test case. >>> parse_input(\\"1n2 2n1 1n1 1n\\")[0] [[1, 1], [1, 1]] >>> find_number_of_islands(parse_input(\\"1n2 2n1 1n1 1n\\"))[0] 1 >>> parse_input(\\"1n3 3n1 0 1n0 1 0n1 0 1n\\")[0] [[1, 0, 1], [0, 1, 0], [1, 0, 1]] >>> find_number_of_islands(parse_input(\\"1n3 3n1 0 1n0 1 0n1 0 1n\\"))[0] 5 pass def parse_input(input_str: str) -> List[List[List[int]]]: Parse the input string to extract test cases. Args: input_str (str): The input string containing multiple test cases. Returns: List[List[List[int]]]: A list where each item is a 2D grid representing a test case. >>> parse_input(\\"1n2 2n1 1n1 1n\\") [[[1, 1], [1, 1]]] >>> parse_input(\\"1n3 3n1 0 1n0 1 0n1 0 1n\\") [[[1, 0, 1], [0, 1, 0], [1, 0, 1]]] pass","solution":"def dfs(grid, x, y, visited): n = len(grid) m = len(grid[0]) stack = [(x, y)] while stack: cx, cy = stack.pop() if (cx, cy) in visited: continue visited.add((cx, cy)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1 and (nx, ny) not in visited: stack.append((nx, ny)) def num_islands(grid): n = len(grid) m = len(grid[0]) visited = set() islands = 0 for i in range(n): for j in range(m): if grid[i][j] == 1 and (i, j) not in visited: dfs(grid, i, j, visited) islands += 1 return islands def find_number_of_islands(test_cases): results = [] for grid in test_cases: results.append(num_islands(grid)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, lines[index].split()) grid = [list(map(int, lines[index + 1 + i].split())) for i in range(N)] test_cases.append(grid) index += N + 1 return test_cases"},{"question":"def find_contiguous_subarray(n: int, k: int, arr: List[int]) -> str: Determine if there exists a contiguous subarray of the given array that sums to the target value k. >>> find_contiguous_subarray(5, 15, [1, 2, 3, 4, 5]) \\"YES\\" >>> find_contiguous_subarray(5, 9, [1, 2, 3, 4, 5]) \\"YES\\" >>> find_contiguous_subarray(5, 20, [1, 2, 3, 4, 5]) \\"NO\\" >>> find_contiguous_subarray(4, -10, [-1, -2, -3, -4]) \\"YES\\"","solution":"def find_contiguous_subarray(n, k, arr): Returns \\"YES\\" if there exists a contiguous subarray in \`arr\` that sums to \`k\`, otherwise \\"NO\\". curr_sum = 0 prefix_sum_map = {} for i in range(n): curr_sum += arr[i] if curr_sum == k: return \\"YES\\" if (curr_sum - k) in prefix_sum_map: return \\"YES\\" prefix_sum_map[curr_sum] = i return \\"NO\\""},{"question":"def reverse_array(arr): Reverse the input array in place. Parameters: arr (list): The list to be reversed. Returns: None Example: >>> arr = [1, 2, 3, 4, 5] >>> reverse_array(arr) >>> print(arr) [5, 4, 3, 2, 1] >>> arr = [1, 2, 3, 4] >>> reverse_array(arr) >>> print(arr) [4, 3, 2, 1]","solution":"def reverse_array(arr): Reverse the input array in place. Parameters: arr (list): The list to be reversed. Returns: None left, right = 0, len(arr) - 1 while left < right: # Swap left and right elements arr[left], arr[right] = arr[right], arr[left] # Move towards the middle left += 1 right -= 1"}]`),E={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},P={class:"card-container"},C={key:0,class:"empty-state"},D=["disabled"],M={key:0},z={key:1};function F(r,e,u,_,i,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",P,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",C,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),n("span",z,"Loading...")):(s(),n("span",M,"See more"))],8,D)):l("",!0)])}const I=c(E,[["render",F],["__scopeId","data-v-776b277a"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/32.md","filePath":"guide/32.md"}'),O={name:"guide/32.md"},G=Object.assign(O,{setup(r){return(e,u)=>(s(),n("div",null,[v(I)]))}});export{B as __pageData,G as default};
