import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-34639948"]]),F=JSON.parse('[{"question":"You are tasked with creating a function `unique_elements` that returns a list of unique elements from an input list while preserving the order of their first occurrence. This function should simulate the behavior of removing duplicates and maintaining order without using external libraries or the `set` data structure. 1. The function should accept a single parameter `input_list`, which is the list containing potentially duplicated elements. 2. The function should return a list of elements that appear only once in their first occurrence order. Function Signature ```python def unique_elements(input_list): pass ``` Example ```python # Sample Input input_list = [4, 5, 6, 4, 7, 8, 5, 9, 1, 7, 8, 1] # Expected Output output = [6, 9] # The output removes all duplicate elements and preserves the remaining in their order of first occurrence. ``` Libraries to Use - None","solution":"def unique_elements(input_list): Returns a list of unique elements in the order of their first occurrence. unique_list = [] seen = set() for element in input_list: if input_list.count(element) == 1: unique_list.append(element) seen.add(element) return unique_list"},{"question":"You are tasked with writing a function called `calculate_portfolio_metrics` that evaluates a financial portfolio based on stock data. This function should use the following libraries and their specific functionalities: `pandas.DataFrame`, `numpy.std`, and `numpy.mean`. # Function Requirements 1. **Load Data**: Accept a pandas DataFrame containing stock prices with columns named as stock symbols and rows indexed by date (format `YYYY-MM-DD`). 2. **Calculate Daily Returns**: Compute daily returns for each stock. 3. **Portfolio Weights**: Use a dictionary input `weights` where keys are stock symbols and values are the weights of each stock in the portfolio. Ensure the weights sum up to 1. 4. **Portfolio Return and Volatility**: Compute the portfolio\'s return and volatility based on the daily returns and given weights. 5. **Sharpe Ratio**: Calculate the Sharpe ratio of the portfolio assuming a risk-free rate of 0. # Parameters ```python def calculate_portfolio_metrics( stock_data: pd.DataFrame, weights: dict) -> dict: Calculates portfolio metrics including daily returns, overall return, volatility, and Sharpe ratio. Args: - stock_data (pd.DataFrame): DataFrame with stock prices, columns as stock symbols, and indexed by date. - weights (dict): Dictionary with stock symbols as keys and portfolio weights as values. Returns: - dict: A dictionary containing portfolio metrics: \'portfolio_return\', \'portfolio_volatility\', \'sharpe_ratio\'. pass ``` # Example Usage: ```python import pandas as pd data = { \'AAPL\': [150.0, 153.0, 155.0, 149.0, 152.0], \'MSFT\': [200.0, 202.0, 205.0, 198.0, 199.0], \'GOOGL\': [2700.0, 2720.0, 2735.0, 2650.0, 2680.0] } index = [\'2022-01-01\', \'2022-01-02\', \'2022-01-03\', \'2022-01-04\', \'2022-01-05\'] stock_data = pd.DataFrame(data, index=index) weights = {\'AAPL\': 0.4, \'MSFT\': 0.4, \'GOOGL\': 0.2} metrics = calculate_portfolio_metrics(stock_data, weights) print(metrics) ``` # Instructions: 1. Implement the `calculate_portfolio_metrics` function using the specified libraries. 2. Compute daily returns for each stock from the stock price data. 3. Ensure the portfolio weights sum up to 1. If they don\'t, raise a ValueError. 4. Calculate the portfolio\'s overall return and volatility based on the daily returns and weights. 5. Calculate the Sharpe ratio of the portfolio assuming a risk-free rate of 0. 6. Return the portfolio metrics in a dictionary containing keys: `portfolio_return`, `portfolio_volatility`, and `sharpe_ratio`.","solution":"import pandas as pd import numpy as np def calculate_portfolio_metrics(stock_data: pd.DataFrame, weights: dict) -> dict: Calculates portfolio metrics including daily returns, overall return, volatility, and Sharpe ratio. Args: - stock_data (pd.DataFrame): DataFrame with stock prices, columns as stock symbols, and indexed by date. - weights (dict): Dictionary with stock symbols as keys and portfolio weights as values. Returns: - dict: A dictionary containing portfolio metrics: \'portfolio_return\', \'portfolio_volatility\', \'sharpe_ratio\'. # Check if weights sum up to 1 total_weight = sum(weights.values()) if not np.isclose(total_weight, 1): raise ValueError(\\"The portfolio weights must sum to 1. Current sum is {}\\".format(total_weight)) # Calculate daily returns daily_returns = stock_data.pct_change().dropna() # Calculate portfolio return portfolio_return = np.dot(daily_returns, list(weights.values())) mean_daily_return = np.mean(portfolio_return) # Calculate portfolio volatility portfolio_volatility = np.std(portfolio_return) # Calculate Sharpe ratio sharpe_ratio = mean_daily_return / portfolio_volatility return { \'portfolio_return\': mean_daily_return, \'portfolio_volatility\': portfolio_volatility, \'sharpe_ratio\': sharpe_ratio }"},{"question":"Generate a Fibonacci-like sequence using custom starting values and specific sequence length. The function should accept two starting values, a sequence length, and compute the sequence based on the summation of the two prior elements, similar to traditional Fibonacci sequence logic. Return the generated sequence as a list. The function should output with: list[int]: A list representing the Fibonacci-like sequence. You should write self-contained code starting with: ``` def generate_fibonacci_like_sequence(start1, start2, length): ```","solution":"def generate_fibonacci_like_sequence(start1, start2, length): Generates a Fibonacci-like sequence of a given length using two custom starting values. Args: start1 (int): The first starting value. start2 (int): The second starting value. length (int): The length of the sequence to generate. Returns: list[int]: A list representing the Fibonacci-like sequence. if length <= 0: return [] elif length == 1: return [start1] elif length == 2: return [start1, start2] sequence = [start1, start2] for _ in range(2, length): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"You are tasked with developing a feature for an online book store that allows users to search for books based on specific keywords. The book data consists of a list of books, where each book is represented as a dictionary with keys: \'title\', \'author\', and \'description\'. Your job is to implement a function `search_books(keyword, books)` that returns a list of books that contain the given keyword in their title, author, or description. Your function `search_books(keyword, books)` should: 1. Take a string `keyword` and a list of dictionaries `books` as input. 2. Perform a case-insensitive search for the keyword within the `title`, `author`, and `description` fields of each book. 3. Return a list of books (dictionaries) that match the search criteria. # Requirements: - The search should be case-insensitive. - Ensure that if no books match the keyword, an empty list is returned. # Example: Given the books data: ```python books = [ {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'description\': \'A novel set in the Jazz Age.\'}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'description\': \'A novel about racial injustice.\'}, {\'title\': \'1984\', \'author\': \'George Orwell\', \'description\': \'A dystopian social science fiction novel.\'}, {\'title\': \'Moby Dick\', \'author\': \'Herman Melville\', \'description\': \'The saga of Captain Ahab.\'} ] ``` And the keyword: `novel` Your function should return: ```python [ {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'description\': \'A novel set in the Jazz Age.\'}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'description\': \'A novel about racial injustice.\'}, {\'title\': \'1984\', \'author\': \'George Orwell\', \'description\': \'A dystopian social science fiction novel.\'} ] ``` Ensure your solution is efficient and clear, while accurately finding books that contain the keyword in any field.","solution":"def search_books(keyword, books): Searches for books that contain the keyword in the title, author, or description fields. The search is case-insensitive. :param keyword: The keyword to search for. :param books: A list of dictionaries, each representing a book with \'title\', \'author\', and \'description\' keys. :return: A list of books (dictionaries) that match the search criteria. keyword_lower = keyword.lower() result_books = [] for book in books: if (keyword_lower in book[\'title\'].lower() or keyword_lower in book[\'author\'].lower() or keyword_lower in book[\'description\'].lower()): result_books.append(book) return result_books"},{"question":"Write a function named `measure_string_safety` that determines if the given string is safe based on certain criteria. For a string to be considered \\"safe\\", it must meet the following conditions: 1. The string must be at least 8 characters long. 2. It must contain at least one uppercase letter (A-Z). 3. It must contain at least one lowercase letter (a-z). 4. It must contain at least one digit (0-9). 5. It must contain at least one special character from the set: !@#%^&*()-_+= The function should take one parameter: - `input_string` (a `str`): The string to be evaluated. The function should return a boolean: - `True` if the string meets all the criteria. - `False` otherwise. The signature of the function should be: ```python def measure_string_safety(input_string: str) -> bool: ``` **Example**: 1. For `input_string = \\"Password123!\\"`, the function should return `True` since the password meets all the safety criteria. 2. For `input_string = \\"Password\\"`, the function should return `False` because it does not contain any digits or special characters. 3. For `input_string = \\"pass123!\\"`, the function should return `False` as it lacks an uppercase letter. **Function Example**: ```python def measure_string_safety(input_string: str) -> bool: if len(input_string) < 8: return False has_upper = any(c.isupper() for c in input_string) has_lower = any(c.islower() for c in input_string) has_digit = any(c.isdigit() for c in input_string) has_special = any(c in \\"!@#%^&*()-_+=\\" for c in input_string) return has_upper and has_lower and has_digit and has_special ```","solution":"def measure_string_safety(input_string: str) -> bool: Determines if the given string meets the safety criteria. Args: input_string (str): The string to be evaluated. Returns: bool: True if the string is safe, False otherwise. if len(input_string) < 8: return False has_upper = any(c.isupper() for c in input_string) has_lower = any(c.islower() for c in input_string) has_digit = any(c.isdigit() for c in input_string) has_special = any(c in \\"!@#%^&*()-_+=\\" for c in input_string) return has_upper and has_lower and has_digit and has_special"},{"question":"Write a Python function `extract_integer_ranges` that extracts and processes sequences of consecutive integers from a given list. The function should identify clusters of three or more consecutive integers, and for each cluster, it should return a tuple containing the start and end of that range. If the list contains no such clusters, an empty list should be returned. Specifically, you need to: 1. Iterate through the list of integers and find sequences of three or more consecutive numbers. 2. For each sequence, create a tuple with the first and last numbers of that sequence. 3. Return a list of these tuples. Your function should be named `extract_integer_ranges` and should accept a single parameter: - A list of integers (e.g., [1, 2, 3, 7, 8, 10, 11, 12, 13]). # Function Signature ```python def extract_integer_ranges(numbers: list) -> list: pass ``` # Example ```python # Given the input numbers = [1, 2, 3, 7, 8, 10, 11, 12, 13] # The function should return [(1, 3), (10, 13)] # Given the input numbers = [5, 6, 7, 10, 100, 101, 102, 103] # The function should return [(5, 7), (100, 103)] # Given the input numbers = [1, 2, 4, 5, 7] # The function should return [] ``` # Requirements - Identify clusters of three or more consecutive integers. - Create and return a list of tuples, each representing the start and end of a consecutive sequence.","solution":"def extract_integer_ranges(numbers: list) -> list: if not numbers: return [] ranges = [] start = numbers[0] count = 1 for i in range(1, len(numbers)): if numbers[i] == numbers[i-1] + 1: count += 1 else: if count >= 3: ranges.append((start, numbers[i-1])) start = numbers[i] count = 1 if count >= 3: ranges.append((start, numbers[-1])) return ranges"},{"question":"Write a function to extract and count all unique words from a given list of strings while ignoring case and punctuation. Return a dictionary where the keys are the unique words and the values are the counts of those words across all strings in the list. The function should output: dict: A dictionary with unique words as keys and their counts as values. You should write self-contained code starting with: ``` import string def task_func(sentence_list): ``` Example: ``` sentence_list = [\\"Hello, world!\\", \\"Hello there\\", \\"There is a world of difference\\"] Output: {\'hello\': 2, \'world\': 2, \'there\': 2, \'is\': 1, \'a\': 1, \'of\': 1, \'difference\': 1} ```","solution":"import string def task_func(sentence_list): Extract and count all unique words from a given list of strings while ignoring case and punctuation. Return a dictionary where the keys are the unique words and the values are the counts of those words. word_count = {} table = str.maketrans(\'\', \'\', string.punctuation) for sentence in sentence_list: # Remove punctuation and convert to lowercase cleaned_sentence = sentence.translate(table).lower() words = cleaned_sentence.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"You are tasked with writing a function `find_longest_subsequence(seq)` that finds the longest contiguous subsequence in a list of integers where the elements are in strictly increasing order. The function should: 1. Take a list of integers as input. 2. Identify all contiguous subsequences where each element is greater than the one preceding it. 3. Return the longest such subsequence. If there are multiple subsequences of the same length, return the first one encountered. Special Considerations: - If the list is empty, the function should return an empty list. - The input list may contain both positive and negative integers as well as duplicates. To clarify, your task is to implement the `find_longest_subsequence(seq)` function only. Here is a specification for the function signature: ```python def find_longest_subsequence(seq): Finds the longest contiguous strictly increasing subsequence in the given list. :param seq: List of integers :return: The longest contiguous strictly increasing subsequence as a list # Your implementation goes here ```","solution":"def find_longest_subsequence(seq): Finds the longest contiguous strictly increasing subsequence in the given list. :param seq: List of integers :return: The longest contiguous strictly increasing subsequence as a list if not seq: return [] max_length = 0 current_length = 0 start_idx = 0 longest_subseq = [] for i in range(len(seq)): if i == 0 or seq[i] > seq[i - 1]: current_length += 1 if current_length > max_length: max_length = current_length start_idx = i - current_length + 1 else: current_length = 1 return seq[start_idx:start_idx + max_length]"},{"question":"# Rotating a Matrix Clockwise by 90 Degrees You are given an `n x n` matrix representing an image. Rotate the image by 90 degrees (clockwise). You need to implement a function `rotate_matrix` that modifies the input matrix in-place to perform the rotation. The function signature should be: ```python def rotate_matrix(matrix): ``` Parameters: - `matrix` (list of list of int): A 2D list where each element is a row of the matrix. The matrix is always square. Functionality: 1. Use a two-step process to achieve the rotation without using an additional matrix: - Transpose the matrix. - Reverse each row of the transposed matrix. Example: ```python # Given an initial matrix: # [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # After rotating the matrix clockwise by 90 degrees, the matrix should be modified to: # [ # [7, 4, 1], # [8, 5, 2], # [9, 3, 0] # ] matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # The matrix will be modified to: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Educational Objective This exercise will help you practice manipulating 2D arrays and understand the fundamental operations needed for rotating elements within a matrix in-place. It is an excellent problem for reinforcing array indexing and in-place transformations.","solution":"def rotate_matrix(matrix): Rotate the given n x n matrix by 90 degrees clockwise in-place. Parameters: matrix (list of list of int): An n x n matrix represented as a list of lists. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You need to create a function that simulates a simple countdown timer using the `time` and `turtle` libraries in Python. The timer should start from a given number of seconds and count down to zero, updating the display each second. **Function Specification:** - Function Name: `countdown_timer` - Parameters: - `seconds` (int): The starting number of seconds for the countdown. **Task:** Implement the `countdown_timer` function to do the following: 1. Set up a turtle screen and create a turtle object for displaying the time. 2. Use a loop to update the turtle\'s display every second, decrementing the countdown by one each iteration until it reaches zero. 3. Clear the previous time display before showing the updated time. 4. Use the `time.sleep(1)` function to create the one-second interval between each countdown step. 5. Ensure the turtle text is centered on the screen and displayed in a large, readable font. **Libraries to Use:** - `time` - `turtle` You can assume the `turtle` library\'s screen is already set up appropriately before calling your function. **Example Usage:** ```python countdown_timer(10) ``` This should start a countdown from 10, updating the display each second until it reaches zero.","solution":"import time import turtle def countdown_timer(seconds): Displays a countdown timer on the turtle screen. Parameters: seconds (int): The starting number of seconds for the countdown. # Set up the turtle screen screen = turtle.Screen() screen.title(\\"Countdown Timer\\") # Set up the turtle timer_turtle = turtle.Turtle() timer_turtle.hideturtle() timer_turtle.penup() timer_turtle.speed(0) timer_turtle.goto(0, 0) for i in range(seconds, -1, -1): timer_turtle.clear() timer_turtle.write(str(i), align=\\"center\\", font=(\\"Arial\\", 48, \\"normal\\")) time.sleep(1) # Hide the turtle and close the screen after the countdown timer_turtle.clear() timer_turtle.write(\\"Time\'s up!\\", align=\\"center\\", font=(\\"Arial\\", 48, \\"normal\\")) time.sleep(2) screen.bye() # Example Usage # countdown_timer(10)"},{"question":"Write a Python function named `count_connected_islands(grid)` that calculates the number of connected islands in a given grid. The grid is represented as a list of lists containing 1s and 0s, where 1 represents land and 0 represents water. An island is formed by connecting adjacent lands horizontally or vertically. You must implement a depth-first search (DFS) algorithm to count the number of islands. Your function must: 1. Traverse the grid to find all connected components of 1s. 2. Use a DFS approach to mark all cells in a found island to avoid counting it more than once. 3. Return the total number of islands found in the grid. Function Signature: ```python def count_connected_islands(grid): pass ``` Example: ```python # Example grid grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] # Example function call print(count_connected_islands(grid)) # Output: 3 ``` Explanation: - There are three islands in the example grid: - The first island is formed by the cells (0,0), (0,1), (1,0), (1,1). - The second island is formed by the cell (2,2). - The third island is formed by the cells (3,3), (3,4).","solution":"def count_connected_islands(grid): if not grid or not grid[0]: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark the current cell as visited # Perform DFS on all four directions dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Start a DFS if a land cell is found island_count += 1 dfs(i, j) return island_count"},{"question":"You are tasked with creating a Python function that simulates the rolling of a pair of dice and calculates the probability of rolling a specific sum. The function should repeatedly roll the dice a large number of times (say, 100,000 rolls) and count how often the specified sum appears. The function should take one argument, the desired sum (an integer between 2 and 12 inclusive). It must return the empirical probability of that sum appearing. To simulate the rolling of the dice, you will use the `random.randint` function from the `random` module, which returns a random integer between two provided integers (inclusive). Given the following documentation for the required function: 1. `random.randint(a, b)`: Returns a random integer _N_ such that `a <= N <= b`, where `a` and `b` are the provided integers. Your function should have the following steps: - Roll the two dice 100,000 times. - Count the occurrences of rolls where the sum of the two dice equals the desired sum. - Calculate and return the probability as the ratio of the count to the total number of rolls. **Function Signature:** ```python def calculate_probability_of_sum(desired_sum: int) -> float: pass ```","solution":"import random def calculate_probability_of_sum(desired_sum: int) -> float: Simulates rolling a pair of dice 100,000 times and calculates the probability of rolling the specified sum. Parameters: desired_sum (int): The desired sum of the dice rolls (between 2 and 12 inclusive). Returns: float: The probability of rolling the specified sum. assert 2 <= desired_sum <= 12, \\"Desired sum must be between 2 and 12 inclusive.\\" num_rolls = 100000 count = 0 for _ in range(num_rolls): roll_sum = random.randint(1, 6) + random.randint(1, 6) if roll_sum == desired_sum: count += 1 probability = count / num_rolls return probability"},{"question":"In this problem, you will be developing a function to forecast the next day\'s temperature based on historical data using a linear regression model. The temperature data is given in a pandas DataFrame. You will follow these steps to generate and test your machine learning model. # Input: - A DataFrame `df` with columns: \'Date\' and \'Temperature\'. - \'Date\': represents the date of the temperature reading. - \'Temperature\': represents the temperature reading on that date. # Steps to Follow: 1. **Prepare the Data**: Parse the \'Date\' column as datetime and set it as the DataFrame index. 2. **Feature Engineering**: - Create a new column \'DayOfYear\' which represents each date as a day of the year (ranging from 1 to 365 or 366). 3. **Create a Lag Feature**: - Create a new column \'PreviousTemp\' which contains the temperature of the previous day. 4. **Handle Missing Values**: - Drop any rows where \'PreviousTemp\' is NaN (this will happen for the first day since there is no previous day data). 5. **Train-Test Split**: - Split the dataset into training and testing sets such that the last 30 days of data are reserved for testing. 6. **Train a Linear Regression Model**: Use the `LinearRegression` model from `sklearn.linear_model` to fit the training data. 7. **Predict Next Day Temperature**: Use the trained model to predict the next day\'s temperature for the test set. 8. **Return Predictions**: Return the predictions as a numpy array. # Output: - A numpy array containing the predicted temperatures for the test set. Create the function `predict_next_day_temperature(df)` with the following signature. Ensure required libraries such as `pandas` and `sklearn` are imported within the function. Example: ```python import pandas as pd from sklearn.linear_model import LinearRegression import numpy as np def predict_next_day_temperature(df): # Your implementation here return predictions ```","solution":"import pandas as pd from sklearn.linear_model import LinearRegression import numpy as np def predict_next_day_temperature(df): # Step 1: Parse the \'Date\' column as datetime and set it as the DataFrame index df[\'Date\'] = pd.to_datetime(df[\'Date\']) df.set_index(\'Date\', inplace=True) # Step 2: Create \'DayOfYear\' column df[\'DayOfYear\'] = df.index.dayofyear # Step 3: Create \'PreviousTemp\' column df[\'PreviousTemp\'] = df[\'Temperature\'].shift(1) # Step 4: Drop rows with NaN values in \'PreviousTemp\' df = df.dropna() # Step 5: Train-Test Split (last 30 days reserved for testing) train = df[:-30] test = df[-30:] # Features and target variable for training X_train = train[[\'DayOfYear\', \'PreviousTemp\']] y_train = train[\'Temperature\'] # Features for testing X_test = test[[\'DayOfYear\', \'PreviousTemp\']] # Step 6: Train the Linear Regression Model model = LinearRegression() model.fit(X_train, y_train) # Step 7: Predict next day temperature for the test set predictions = model.predict(X_test) # Step 8: Return the predictions return predictions"},{"question":"You are given a list of integers which represent the lengths of various ropes. Each time you connect two ropes, you incur a cost equal to the sum of their lengths. Your task is to connect all the ropes into a single rope in such a way that minimizes the total cost. Write a function `min_cost_to_connect_ropes(ropes)` that: 1. Uses a priority queue (min-heap) to efficiently get the smallest ropes to connect. 2. Continually combines the two smallest ropes until one rope remains. # Function Signature ```python import heapq def min_cost_to_connect_ropes(ropes: list[int]) -> int: pass ``` # Input - `ropes (list[int])`: A list of integers representing the lengths of the ropes. Assume the list contains at least one rope. # Output - Returns an integer representing the minimum cost to connect all the ropes into one. # Example ```python print(min_cost_to_connect_ropes([8, 4, 6, 12])) # Output: 58 print(min_cost_to_connect_ropes([20, 4, 8, 2])) # Output: 54 print(min_cost_to_connect_ropes([1, 2, 5, 10, 35, 89])) # Output: 224 print(min_cost_to_connect_ropes([2, 2, 3, 3])) # Output: 20 ``` **Note:** - You must use the priority queue (min-heap) from the `heapq` module to manage the ropes efficiently. - Ensure that the function works efficiently even for large lists of ropes.","solution":"import heapq def min_cost_to_connect_ropes(ropes: list[int]) -> int: Returns the minimum cost to connect all ropes into one. if len(ropes) <= 1: return 0 heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"You are tasked with implementing a function named `longestCommonSubsequence` that finds the length of the longest common subsequence between two given strings. The longest common subsequence (LCS) is defined as the longest sequence that can be derived from both the strings without changing the order of characters. You will be provided with two strings: - `s1`: A string containing the first sequence. - `s2`: A string containing the second sequence. The function `longestCommonSubsequence` should compute the length of the LCS using dynamic programming. Follow these steps: 1. Create a 2D array (list of lists) `dp` with dimensions `(len(s1) + 1) x (len(s2) + 1)`, where each element is initialized to 0. 2. Iterate through each character of `s1` and `s2` to fill the `dp` array: - If the characters of `s1` and `s2` match, set `dp[i][j] = dp[i-1][j-1] + 1`. - If not, set `dp[i][j] = max(dp[i][j-1], dp[i-1][j])`. 3. The value at `dp[len(s1)][len(s2)]` will have the length of the LCS. Your task is to implement the function `longestCommonSubsequence(s1, s2)` which returns an integer representing the length of the longest common subsequence between the two given strings.","solution":"def longestCommonSubsequence(s1, s2): Returns the length of the longest common subsequence between s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) return dp[m][n]"},{"question":"You are given a list of dictionaries, where each dictionary represents a student and contains two keys: `name` (a string) and `score` (an integer). Your task is to create a Python function that groups the students by their scores and returns a new dictionary. The keys of this new dictionary should be the scores, and the values should be lists of names of students who achieved that score. **Function Name**: `group_students_by_score` **Function Signature**: `def group_students_by_score(students: List[Dict[str, Union[str, int]]]) -> Dict[int, List[str]]:` **Parameters**: - `students` (List[Dict[str, Union[str, int]]]): A list of dictionaries representing students. Each dictionary has two keys: - `name` (str): The name of the student. - `score` (int): The student\'s score. **Returns**: - `Dict[int, List[str]]`: A dictionary where the keys are scores, and the values are lists of names of students who earned that score. **Requirements**: - The order of the names in the lists does not matter. - If no students are present, the function should return an empty dictionary. Example: ```python students = [ {\\"name\\": \\"Alice\\", \\"score\\": 90}, {\\"name\\": \\"Bob\\", \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"score\\": 90}, {\\"name\\": \\"David\\", \\"score\\": 85}, {\\"name\\": \\"Eve\\", \\"score\\": 92} ] result = group_students_by_score(students) print(result) # Output: {90: [\'Alice\', \'Charlie\'], 85: [\'Bob\', \'David\'], 92: [\'Eve\']} ``` Write your function such that it efficiently groups the students by their scores and handles various edge cases.","solution":"from typing import List, Dict, Union def group_students_by_score(students: List[Dict[str, Union[str, int]]]) -> Dict[int, List[str]]: result = {} for student in students: score = student[\'score\'] name = student[\'name\'] if score not in result: result[score] = [] result[score].append(name) return result"},{"question":"You are required to create a function that manipulates a list of integers. The objective is to learn how to use list operations to transform and analyze the data. Write a function called `process_integer_list` which takes two parameters: 1. `numbers`: a list of integers which can be positive, negative, or zero. 2. `operation`: a string indicating the operation to perform on the list. The operation can be one of \'sum\', \'mean\', \'max\', \'min\', or \'remove_zeros\'. The function should perform the following based on the operation provided: - If the operation is \'sum\', return the sum of all integers in the list. - If the operation is \'mean\', return the mean (average) of all integers in the list. Return `None` if the list is empty. - If the operation is \'max\', return the maximum integer in the list. Return `None` if the list is empty. - If the operation is \'min\', return the minimum integer in the list. Return `None` if the list is empty. - If the operation is \'remove_zeros\', return a new list with all zeros removed from the original list. Example Usage: ```python print(process_integer_list([1, 2, 3, 4, 5], \'sum\')) # Output: 15 print(process_integer_list([1, 2, 3, 4, 5], \'mean\')) # Output: 3.0 print(process_integer_list([1, 2, 3, 4, 5], \'max\')) # Output: 5 print(process_integer_list([1, 2, 3, 4, 5], \'min\')) # Output: 1 print(process_integer_list([1, 0, 2, 0, 3], \'remove_zeros\')) # Output: [1, 2, 3] ```","solution":"def process_integer_list(numbers, operation): Processes a list of integers based on the specified operation. Parameters: - numbers: A list of integers. - operation: A string indicating the operation to perform. It can be \'sum\', \'mean\', \'max\', \'min\', or \'remove_zeros\'. Returns: - The result of the specified operation. if operation == \'sum\': return sum(numbers) elif operation == \'mean\': return sum(numbers) / len(numbers) if numbers else None elif operation == \'max\': return max(numbers) if numbers else None elif operation == \'min\': return min(numbers) if numbers else None elif operation == \'remove_zeros\': return [num for num in numbers if num != 0] else: raise ValueError(\\"Invalid operation\\")"},{"question":"The task is to create a function that generates an NxN multiplication table and returns it as a list of lists. Each element in the table at position (i, j) should contain the product of (i + 1) and (j + 1), where `0 <= i < N` and `0 <= j < N`. Specifically, your task is to define a function named `generate_multiplication_table` which: 1. Takes one parameter: `N` (an integer that specifies the size of the multiplication table). 2. Generates an NxN multiplication table. 3. Returns the generated table as a list of lists, where each inner list represents a row of the table. # Example If the function is called with the argument `N = 3`, the returned value should be: ``` [ [1, 2, 3], [2, 4, 6], [3, 6, 9] ] ``` If the function is called with the argument `N = 4`, the returned value should be: ``` [ [1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16] ] ``` # Requirements Your function should generate the multiplication table using nested loops to ensure correctness and should not use any built-in functions like `numpy` to create the table directly. # Function Signature ```python def generate_multiplication_table(N: int) -> List[List[int]]: pass ``` # Constraints - You can assume that the input `N` will be a positive integer with 1 <= N <= 100. - The function should handle any edge cases where N is at its minimum or maximum value.","solution":"from typing import List def generate_multiplication_table(N: int) -> List[List[int]]: Generates an NxN multiplication table and returns it as a list of lists. Args: N (int): size of the multiplication table. Returns: List[List[int]]: the generated NxN multiplication table. table = [] for i in range(1, N + 1): row = [] for j in range(1, N + 1): row.append(i * j) table.append(row) return table"},{"question":"Implement a function that takes a binary tree and returns a list where each element is the list of node values at that depth in the tree. The function should accept: - A root of the binary tree. The function should output: - A list of lists, where each inner list contains node values at a specific depth, starting from depth 0. For example, for the binary tree: ``` 1 / 2 3 / 4 5 ``` The function should return: ``` [[1], [2, 3], [4, 5]] ``` You should write self-contained code starting with: ``` class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrderTraversal(root: TreeNode): ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None from collections import deque def levelOrderTraversal(root: TreeNode): Given the root of a binary tree, return its level order traversal as a list of lists. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"In the fascinating world of combinatorics, the binomial coefficient, commonly expressed as ( binom{n}{k} ), represents the number of ways to choose ( k ) elements from a set of ( n ) elements without considering the order. It can be computed using the formula: [ binom{n}{k} = frac{n!}{k!(n-k)!} ] Where `!` denotes the factorial of a number. For example, ( binom{5}{2} = frac{5!}{2!(5-2)!} = 10 ). In this problem, you are required to write a function named `binomial_coefficient` that computes the binomial coefficient ( binom{n}{k} ) for given values of `n` and `k`. If `k` is greater than `n`, the function should return `0` because it is impossible to choose more elements than are available. **Function Signature:** ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` **Input:** - `n` (int): A non-negative integer representing the total number of elements. - `k` (int): A non-negative integer representing the number of elements to choose from the set of `n`. **Output:** - `int`: The binomial coefficient ( binom{n}{k} ). **Example:** ```python print(binomial_coefficient(5, 2)) # Output: 10 print(binomial_coefficient(10, 3)) # Output: 120 print(binomial_coefficient(6, 0)) # Output: 1 print(binomial_coefficient(4, 5)) # Output: 0 ``` In your solution, you might find it useful to define a helper function for computing factorials to ensure efficiency and clarity. Be mindful of edge cases where `k` is greater than `n`, which should immediately return `0`.","solution":"def factorial(n): if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result def binomial_coefficient(n: int, k: int) -> int: if k > n: return 0 return factorial(n) // (factorial(k) * factorial(n - k))"},{"question":"``` Create a function that reads a JSON file containing details of multiple products and generates a summary report in CSV format. The JSON file will have the following structure: [ { \\"id\\": 1, \\"name\\": \\"Product A\\", \\"category\\": \\"Category 1\\", \\"price\\": 29.99, \\"quantity\\": 100 }, ... ] The CSV file should contain the following columns: - id (integer): Unique identifier for each product, taken directly from the JSON. - name (string): The name of the product. - category (string): The product\'s category. - total_value (float): Calculated as price * quantity for each product. - stock_status (string): \\"In stock\\" if quantity > 0, otherwise \\"Out of stock\\". The function should return the absolute path of the created CSV file. You should write self-contained code starting with: ``` import json import csv import os def generate_product_summary(json_filename, csv_filename=\'product_summary.csv\'): with open(json_filename, \'r\') as json_file: data = json.load(json_file) ```","solution":"import json import csv import os def generate_product_summary(json_filename, csv_filename=\'product_summary.csv\'): with open(json_filename, \'r\') as json_file: data = json.load(json_file) with open(csv_filename, \'w\', newline=\'\') as csv_file: writer = csv.writer(csv_file) writer.writerow([\'id\', \'name\', \'category\', \'total_value\', \'stock_status\']) for product in data: total_value = product[\'price\'] * product[\'quantity\'] stock_status = \'In stock\' if product[\'quantity\'] > 0 else \'Out of stock\' writer.writerow([product[\'id\'], product[\'name\'], product[\'category\'], total_value, stock_status]) return os.path.abspath(csv_filename)"},{"question":"Implement a Python function named `highlight_significant_trend` that processes a given time series data of stock prices and highlights periods of significant upward or downward trends. The function should plot the time series data and highlight the significant upward trends in green and downward trends in red. # Requirements 1. The x-axis represents the date. 2. The y-axis represents the stock price. 3. Use matplotlib to plot the time series and apply the highlights. 4. A significant upward trend is defined as an increase of 5% or more in the stock price over a consecutive 5-day period. 5. A significant downward trend is defined as a decrease of 5% or more in the stock price over a consecutive 5-day period. 6. The function should save the plot as an image with the file name `\\"highlighted_trends.png\\"`. # Function Signature: ```python def highlight_significant_trend(df: pd.DataFrame) -> None: ``` # Parameters: - `df` (pd.DataFrame): The DataFrame containing the data. It should have at least two columns: `\'date\'` and `\'price\'`. # Ensure: - The function does not return any value. - The function saves the plot as an image in the current working directory. # Example Usage: ```python df = pd.DataFrame({ \'date\': pd.date_range(start=\'2023-01-01\', periods=30, freq=\'D\'), \'price\': [100, 102, 105, 107, 110, 115, 120, 118, 116, 112, 110, 111, 113, 115, 117, 120, 125, 130, 127, 125, 124, 122, 121, 123, 126, 129, 128, 127, 130, 132] }) highlight_significant_trend(df) ```","solution":"import pandas as pd import matplotlib.pyplot as plt def highlight_significant_trend(df: pd.DataFrame) -> None: This function processes a given time series data of stock prices and highlights periods of significant upward or downward trends. Significant upward trends are highlighted in green and downward trends in red. Parameters: df (pd.DataFrame): The DataFrame containing the data with columns \'date\' and \'price\'. df = df.copy() df[\'date\'] = pd.to_datetime(df[\'date\']) fig, ax = plt.subplots(figsize=(14, 7)) ax.plot(df[\'date\'], df[\'price\'], label=\'Stock Price\', color=\'blue\') for i in range(len(df) - 5): sub_df = df.iloc[i:i + 5] start_price = sub_df[\'price\'].iloc[0] end_price = sub_df[\'price\'].iloc[-1] percent_change = (end_price - start_price) / start_price * 100 if percent_change >= 5: ax.plot(sub_df[\'date\'], sub_df[\'price\'], color=\'green\', linewidth=2) elif percent_change <= -5: ax.plot(sub_df[\'date\'], sub_df[\'price\'], color=\'red\', linewidth=2) ax.set_xlabel(\'Date\') ax.set_ylabel(\'Price\') ax.set_title(\'Stock Price with Highlighted Trends\') ax.legend() plt.savefig(\\"highlighted_trends.png\\") plt.show()"},{"question":"You are provided with a CSV file `employee_data.csv` containing records of employees in a company. Each row in the file represents one employee and has the following columns: `employee_id`, `name`, `age`, `department`, `salary`. Your task is to implement a function `department_salary_stats(fname)` that computes statistical data regarding the salaries in each department: 1. Reads the content of the CSV file specified by `fname`. 2. For each department, calculates the following statistics for salaries: - Minimum salary - Maximum salary - Average salary 3. Prints the results in the following format: ``` Department: [department_name] Min Salary: [min_salary] Max Salary: [max_salary] Average Salary: [average_salary] ``` Note: - Use the `csv` module to read the CSV file. - Assume `employee_data.csv` has a header row and the subsequent rows contain valid data. - Ensure the printing format matches the given example exactly. - Handle any exceptions that may occur during file reading gracefully, and print an appropriate error message. ```python import csv def department_salary_stats(fname): # Your implementation here pass ```","solution":"import csv from collections import defaultdict def department_salary_stats(fname): # Using defaultdict to store lists of salaries for each department department_salaries = defaultdict(list) try: with open(fname, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: department = row[\'department\'] salary = float(row[\'salary\']) department_salaries[department].append(salary) for department, salaries in department_salaries.items(): if salaries: # ensuring there\'s at least one salary for the statistics min_salary = min(salaries) max_salary = max(salaries) avg_salary = sum(salaries) / len(salaries) print(f\\"Department: {department}\\") print(f\\"Min Salary: {min_salary}\\") print(f\\"Max Salary: {max_salary}\\") print(f\\"Average Salary: {avg_salary}\\") print() except FileNotFoundError: print(\\"Error: File not found.\\") except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"Write a function named `find_common_elements(list1, list2)` that finds the common elements between two given lists. The function should perform the following steps: 1. Convert both lists to sets. 2. Find the intersection of the two sets. 3. Return the intersection as a sorted list. **Requirements and Constraints**: 1. Use Python\'s built-in `set` operations to find the intersection. 2. Use Python\'s built-in `sorted` function to return the result in a sorted list. **Function Signature**: ```python def find_common_elements(list1: list, list2: list) -> list: # Implementation here pass ``` **Example**: ```python # Example Input list1 = [4, 9, 5, 7, 6, 3] list2 = [6, 4, 2, 7, 4, 8, 10] # Function Call result = find_common_elements(list1, list2) # Expected Output # The details below illustrate how the output is calculated: # Set from list1: {4, 9, 5, 7, 6, 3} # Set from list2: {6, 4, 2, 7, 4, 8, 10} # Intersection of sets: {4, 6, 7} # Sorted result: [4, 6, 7] print(result) # Should print: [4, 6, 7] ``` Ensure the function works efficiently for any arbitrary list of elements, and handle edge cases where either of the lists might be empty.","solution":"def find_common_elements(list1, list2): Returns a sorted list of common elements between list1 and list2. set1 = set(list1) set2 = set(list2) intersection = set1 & set2 return sorted(intersection)"},{"question":"Write a function named `generate_squared_matrix` that creates an `n x n` matrix where each element is the square of its column index multiplied by 2. This function can serve to generate matrices for testing algorithms that operate on square matrices. # Function Signature: ```python def generate_squared_matrix(n): # Your code here ``` # Function Objective: - The function `generate_squared_matrix` should accept a single parameter `n`, which specifies the dimensions of the square matrix. - Each element in the matrix should be calculated as `2 * j^2` where `j` is the column index (0-based) of the matrix cell. - The function should return a list of lists representing the matrix. # Example: ```python # Example usage matrix = generate_squared_matrix(3) for row in matrix: print(row) ``` Expected Output: ``` [0, 2, 8] [0, 2, 8] [0, 2, 8] ``` # Constraints: - The matrix generated should have integer values. - The input `n` will be a positive integer. # Libraries to Use: - No external libraries are necessary for this task. Use of Python\'s standard library and basic data structures is sufficient. The goal of this exercise is to practice creating and manipulating lists, applying arithmetic operations, and understanding iterations over list elements.","solution":"def generate_squared_matrix(n): Generates an n x n matrix where each element is the square of its column index multiplied by 2. Parameters: n (int): The dimensions of the square matrix. Returns: list of lists: The generated n x n matrix. return [[2 * (j ** 2) for j in range(n)] for _ in range(n)]"},{"question":"This function calculates the shortest path in a weighted undirected graph using Dijkstra\'s algorithm. The function should receive an adjacency list representation of the graph, where each node is associated with a list of tuples containing its neighbors and the respective weights of the edges. The function should also receive the start node and the end node. It needs to return the total weight of the shortest path from the start node to the end node. If no path exists, it should return -1. The function should output: int: The total weight of the shortest path from the start node to the end node or -1 if no path exists. You should write self-contained code starting with: ``` import heapq def dijkstra(graph, start, end): ```","solution":"import heapq def dijkstra(graph, start, end): Calculate the shortest path in a weighted undirected graph using Dijkstra\'s algorithm. :param graph: A dictionary where keys are nodes and values are lists of tuples (neighbor, weight). :param start: The start node. :param end: The end node. :return: The total weight of the shortest path from start to end, or -1 if no path exists. # Priority queue to store (current_distance, current_node) pq = [(0, start)] # Dictionary to store the shortest distance to each node distances = {start: 0} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == end: return current_distance # Check neighbors for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1"},{"question":"You are tasked with designing a function that can help determine the minimum number of steps required to convert a given string into another string. Specifically, you need to calculate the minimum number of single-character operations (insertions, deletions, or substitutions) required to change the first string into the second string. The function you need to write is called `min_edit_distance`, and it should take two parameters: - `source` (a string representing the initial word) - `target` (a string representing the target word) The goal is to determine the minimum edit distance between the two provided strings. To solve this problem, you will need to use dynamic programming to build a matrix where each cell `(i, j)` represents the minimum edit distance between the `i`-length prefix of `source` and the `j`-length prefix of `target`. Requirements: 1. Use dynamic programming to build the solution. 2. The function should return the minimum number of operations required. 3. Make sure the solution is optimized in terms of space and time complexity. # Example: ```python source = \\"kitten\\" target = \\"sitting\\" print(min_edit_distance(source, target)) # Output: 3 ``` In the example above, the minimum number of operations required to convert \\"kitten\\" into \\"sitting\\" is 3. Specifically, you can perform the following operations: substitute \'k\' with \'s\', substitute \'e\' with \'i\', and add \'g\' at the end. Hence, the expected output would be 3.","solution":"def min_edit_distance(source, target): Calculate the minimum edit distance between two strings using dynamic programming. Parameters: source (str): The initial string. target (str): The target string. Returns: int: The minimum number of operations required to convert source to target. m = len(source) n = len(target) # Create a DP matrix dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Initialize first row and first column for i in range(m + 1): dp[i][0] = i # deletion from source to empty target for j in range(n + 1): dp[0][j] = j # insertion to empty source to target # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # delete dp[i][j - 1] + 1, # insert dp[i - 1][j - 1] + 1) # substitute return dp[m][n]"},{"question":"You are provided with a file containing information about different products sold by an e-commerce website. You need to prepare a summary that includes the total sales, average sales price, and the highest priced product sold each day. Implement the function `summarize_sales()` that reads the sales data from a CSV file named `sales_data.csv` and outputs a summary in a new CSV file `daily_summary.csv`. The input `sales_data.csv` contains the following columns: - `Date`: The date of sale in the format \'YYYY-MM-DD\'. - `Product`: The name of the product sold. - `Units_Sold`: The number of units sold. - `Unit_Price`: The price of one unit of the product sold. The output `daily_summary.csv` should have the following columns: - `Date`: The date of the sales. - `Total_Sales`: The total sales amount (sum of `Units_Sold` * `Unit_Price`) for that day. - `Average_Price`: The average price per unit sold for that day. - `Highest_Priced_Product`: The product with the highest unit price sold on that day. Heres a sample structure of the input data for better understanding: ``` Date,Product,Units_Sold,Unit_Price 2023-01-01,Product_A,4,100 2023-01-01,Product_B,2,150 2023-01-02,Product_C,1,300 ... ``` # Implementation: - The function name should be `summarize_sales`. - Use the `pandas` library for data manipulation and file operations. **Function Signature:** ```python def summarize_sales(): pass ```","solution":"import pandas as pd def summarize_sales(): # Load data from the CSV file sales_data = pd.read_csv(\\"sales_data.csv\\") # Calculate total sales for each day sales_data[\'Total_Sale\'] = sales_data[\'Units_Sold\'] * sales_data[\'Unit_Price\'] total_sales = sales_data.groupby(\'Date\')[\'Total_Sale\'].sum() # Calculate average sales price for each day average_price = sales_data.groupby(\'Date\')[\'Unit_Price\'].mean() # Determine the highest priced product for each day idx_max_price = sales_data.groupby(\'Date\')[\'Unit_Price\'].idxmax() highest_priced_product = sales_data.loc[idx_max_price, [\'Date\', \'Product\']].set_index(\'Date\')[\'Product\'] # Combine results into a summary dataframe summary_df = pd.DataFrame({ \'Total_Sales\': total_sales, \'Average_Price\': average_price, \'Highest_Priced_Product\': highest_priced_product }).reset_index() # Save the summary dataframe to a CSV file summary_df.to_csv(\\"daily_summary.csv\\", index=False)"},{"question":"You are tasked with creating a function `generateSpiralMatrix(n)` that generates an n x n matrix filled with integers from 1 to n^2 in a spiral order, starting from the top left corner and moving clockwise. **Function Signature**: ```python def generateSpiralMatrix(n: int) -> List[List[int]]: pass ``` **Parameters**: - `n` (int): The size of the n x n matrix. **Returns**: - `List[List[int]]`: The n x n matrix filled with integers from 1 to n^2 in spiral order. **Example**: ```python generateSpiralMatrix(3) # Output: # [ # [1, 2, 3], # [8, 9, 4], # [7, 6, 5] # ] generateSpiralMatrix(4) # Output: # [ # [1, 2, 3, 4], # [12, 13, 14, 5], # [11, 16, 15, 6], # [10, 9, 8, 7] # ] ``` **Constraints**: - 1 <= `n` <= 20","solution":"from typing import List def generateSpiralMatrix(n: int) -> List[List[int]]: matrix = [[0] * n for _ in range(n)] num = 1 left, right = 0, n - 1 top, bottom = 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"You are tasked with creating a function that converts a list of dictionaries into a data table using the `pandas` library and saves it as a CSV file. The function will take three arguments: the list of dictionaries, the file path where the CSV should be saved, and the column order for the output CSV file. If the column order is not specified, the CSV should be saved based on the sorted order of the keys. Additionally, the function should handle dictionaries with missing keys by filling those missing values with `NaN`. To achieve this, use the `pandas.DataFrame`, `pandas.DataFrame.to_csv`, and `pandas.DataFrame.reindex` APIs. Define the function as follows: ```python def dictionaries_to_csv(data, file_path, column_order=None): Convert a list of dictionaries into a CSV file. Parameters: data (list of dict): The data to be saved as a CSV. file_path (str): The path where the CSV should be saved. column_order (list of str, optional): The order of columns in the output CSV file. Defaults to None. ``` Example usage: ```python data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"city\\": \\"San Francisco\\"} ] dictionaries_to_csv(data, \'output.csv\', column_order=[\'name\', \'age\', \'city\']) ``` This will create a CSV file named \'output.csv\' with columns in the order \'name\', \'age\', \'city\'. Missing values will be filled with `NaN`. If the `column_order` argument is not specified, the columns in the output CSV will be in the sorted order of the keys.","solution":"import pandas as pd def dictionaries_to_csv(data, file_path, column_order=None): Convert a list of dictionaries into a CSV file. Parameters: data (list of dict): The data to be saved as a CSV. file_path (str): The path where the CSV should be saved. column_order (list of str, optional): The order of columns in the output CSV file. Defaults to None. df = pd.DataFrame(data) if column_order: df = df.reindex(columns=column_order) else: df = df.reindex(columns=sorted(df.columns)) df.to_csv(file_path, index=False)"},{"question":"You are required to write a Python function `word_count()` that reads a text input from the user and counts the occurrences of each word in the text. The function should ignore punctuation and be case-insensitive. It should then display each word along with its count in a well-formatted manner. The function will: 1. Prompt the user to enter a text. 2. Normalize the text by converting it to lowercase and removing any punctuation marks (you may assume punctuation marks are: `.,!?;:`). 3. Split the text into individual words. 4. Count the occurrences of each word using a dictionary. 5. Display the word counts in a sorted order (alphabetically by word). Your function must be named `word_count()`. Make sure to handle user inputs properly, and provide concise, user-friendly output messages. **Function Signature:** ```python def word_count(): pass ``` **Example:** ``` Enter your text: Hello, world! Hello Python. Python programming is awesome, isn\'t it? Word Count: awesome 1 hello 2 is 1 isn\'t 1 it 1 programming 1 python 2 world 1 ``` Note: In the example, punctuation has been removed, all words converted to lowercase, and the final word counts displayed in alphabetical order.","solution":"def word_count(): import re from collections import defaultdict # Prompt the user to enter a text text = input(\\"Enter your text: \\") # Normalize the text: convert to lowercase and remove punctuation text = text.lower() text = re.sub(r\'[.,!?;:]\', \'\', text) # Split the text into words words = text.split() # Count occurrences of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 # Sort the words alphabetically sorted_words = sorted(word_counts.items()) # Display the word counts print(\\"Word Count:\\") for word, count in sorted_words: print(f\\"{word} {count}\\")"},{"question":"Write a function `common_prefix_length` in Python that determines the length of the common prefix between two strings. This function is useful in text processing tasks, where you need to find the longest matching starting sequence between two strings. Parameters: - `str1` (string): The first string. - `str2` (string): The second string. Returns: - An integer representing the length of the common prefix between the two strings. # Example: ```python str1 = \\"abcdef\\" str2 = \\"abcpqr\\" print(common_prefix_length(str1, str2)) # Expected output: 3 ``` # Requirements: - Iterate over both strings and compare their characters one by one. - Stop the comparison as soon as a mismatch is found, and keep track of the number of matching characters. # Edge Cases: - If one or both of the strings are empty, the answer should be `0`. - If the strings are identical, the entire length of the strings should be returned.","solution":"def common_prefix_length(str1, str2): Determines the length of the common prefix between two strings. Parameters: - str1: The first string. - str2: The second string. Returns: - An integer representing the length of the common prefix between the two strings. common_length = 0 # Find the shorter length of the two strings to avoid index errors min_length = min(len(str1), len(str2)) # Iterate over both strings and compare their characters for i in range(min_length): if str1[i] == str2[i]: common_length += 1 else: break return common_length"},{"question":"Design a function that reads a text file and identifies all unique words, counts their occurrences, and then returns a dictionary where the keys are the words (in lowercase) and the values are their respective counts. Ignore punctuation and consider words with different cases as the same word. Returns an empty dictionary if the file is empty or contains no words. You should raise the exception for: FileNotFoundError if the file does not exist. The function should output: dict: A dictionary with words as keys and their occurrence counts as values. You should write self-contained code starting with: ``` import string def count_words(file_path): ```","solution":"import string def count_words(file_path): Reads a text file and identifies all unique words, counts their occurrences. Parameters: file_path (str): Path to the text file Returns: dict: A dictionary with words as keys and their occurrence counts as values. All words are in lowercase. words_count = {} try: with open(file_path, \'r\') as file: for line in file: # Remove punctuation and convert to lowercase line = line.translate(str.maketrans(\'\', \'\', string.punctuation)).lower() words = line.split() for word in words: if word in words_count: words_count[word] += 1 else: words_count[word] = 1 except FileNotFoundError: raise FileNotFoundError(f\\"The file at {file_path} does not exist.\\") return words_count"},{"question":"Write a function that calculates and returns the transpose of a given 2D matrix (list of lists). The transpose of a matrix is a new matrix whose rows are the columns of the original matrix and whose columns are the rows of the original matrix. **Function Name: `transpose_matrix`** **Input Parameter:** - `matrix` (list of lists): A 2D matrix where each element is a list representing a row in the matrix. **Output:** - The function should return a new 2D list representing the transpose of the input matrix. **Requirements:** - Ensure to handle edge cases such as an empty matrix or matrices with a single element. - Do not use any external libraries. Implement the solution using basic Python constructs. Here is an example input for the function and the expected behavior: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = transpose_matrix(matrix) ``` The above input should return: ```python [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ```","solution":"def transpose_matrix(matrix): Returns the transpose of the given 2D matrix. Parameters: matrix (list of lists): The original 2D matrix. Returns: list of lists: Transposed matrix. if not matrix or not matrix[0]: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"**Problem Statement:** Write a function `find_disappeared_numbers` that takes a list of integers `arr` (with length `n`, where 1  n  10^5) consisting of elements between 1 and `n` (inclusive) and returns a list of all the integers between 1 and `n` that do not appear in `arr`. The function should achieve this in O(n) time complexity without using extra space for another list or array, but you may modify the input array in place. You can assume that the input array is not sorted, and the numbers may appear multiple times. **Function Signature:** ```python def find_disappeared_numbers(arr: List[int]) -> List[int]: pass ``` **Requirements:** - Use an in-place algorithm with O(n) time complexity. - The resulting list should contain the missing numbers in any order. **Input:** - `arr` (List[int]): The input list containing integers between 1 and n. **Output:** - A list of integers representing the numbers that are missing in the range from 1 to n. **Examples:** ```python print(find_disappeared_numbers([4,3,2,7,8,2,3,1])) ``` should output: ``` [5, 6] ``` ```python print(find_disappeared_numbers([1,1])) ``` should output: ``` [2] ``` **Note:** The input list length is guaranteed to be between 1 and 100,000, and the integers within the list are guaranteed to be between 1 and the length of the list inclusive.","solution":"from typing import List def find_disappeared_numbers(arr: List[int]) -> List[int]: Finds all the integers between 1 and len(arr) that do not appear in arr. # Iterate over each number in the list for i in range(len(arr)): # Calculate the index based on the value of the current element index = abs(arr[i]) - 1 # Mark the element at the calculated index as visited (negative sign) if arr[index] > 0: arr[index] = -arr[index] # Create a result list for numbers that are missing result = [] # Iterate over the range from 1 to length of the array for i in range(len(arr)): # If the value at index i is positive, then (i + 1) is missing if arr[i] > 0: result.append(i + 1) return result"},{"question":"Design a function that simulates the spread of an infectious disease through a population and visualizes the number of susceptible, infected, and recovered individuals over time using the SIR model. The SIR model divides the population into three compartments: - S (Susceptible): Individuals who can contract the disease. - I (Infected): Individuals who have the disease and can spread it to susceptible individuals. - R (Recovered): Individuals who have recovered from the disease and are no longer infectious. The function should take the following parameters: - population: The total number of individuals in the population. - initial_infected: The initial number of infected individuals. - infection_rate: The average number of contacts per person per time step that can spread the disease. - recovery_rate: The rate at which infected individuals recover. - days: The number of days to simulate. The function should raise a ValueError if any of the parameters are non-positive or if initial_infected is greater than the population. The function should: 1. Calculate the change in the number of susceptible, infected, and recovered individuals for each time step using the SIR model differential equations. 2. Plot the number of susceptible, infected, and recovered individuals as a function of time. The x-axis should be labeled \'Time [days]\' and the y-axis \'Number of individuals\'. 3. Return the final values of susceptible, infected, and recovered individuals. You should write self-contained code starting with: ``` import numpy as np import matplotlib.pyplot as plt def SIR_model(population, initial_infected, infection_rate, recovery_rate, days): ```","solution":"import numpy as np import matplotlib.pyplot as plt def SIR_model(population, initial_infected, infection_rate, recovery_rate, days): # Validate input parameters if population <= 0 or initial_infected <= 0 or infection_rate <= 0 or recovery_rate <= 0 or days <= 0: raise ValueError(\\"All parameters must be positive.\\") if initial_infected > population: raise ValueError(\\"Initial infected individuals cannot be greater than the population.\\") # Initialize SIR model variables susceptible = population - initial_infected infected = initial_infected recovered = 0 # Store the results for plotting S = [susceptible] I = [infected] R = [recovered] # Calculate values for each day for _ in range(days): new_infected = (infection_rate * infected * susceptible) / population new_recovered = recovery_rate * infected susceptible = susceptible - new_infected infected = infected + new_infected - new_recovered recovered = recovered + new_recovered S.append(susceptible) I.append(infected) R.append(recovered) # Plot results plt.figure(figsize=(10, 6)) plt.plot(S, label=\'Susceptible\') plt.plot(I, label=\'Infected\') plt.plot(R, label=\'Recovered\') plt.xlabel(\'Time [days]\') plt.ylabel(\'Number of individuals\') plt.legend() plt.grid(True) plt.title(\\"SIR Model Simulation\\") plt.show() return S[-1], I[-1], R[-1]"},{"question":"Create a function `summarize_sales` that processes a CSV file containing daily sales data and generates a summary report. The report should include the total sales and the average sales per day. You\'ll be working with the `csv` module in Python to read and write data. Here\'s how you can approach the problem: 1. **Reading the CSV file**: - Open the CSV file in read mode. - Use `csv.reader` to read the contents of the file. - Iterate through the rows to compute the total sales and keep track of the number of days. 2. **Writing the Summary Report**: - Open a new CSV file in write mode. - Use `csv.writer` to write the summary information. - Calculate the average sales per day. - Write the total sales and average sales to the new CSV file. **Function Signature:** ```python def summarize_sales(salesFilePath: str, summaryFilePath: str) -> None: # Function body here ``` **Parameters:** - `salesFilePath` (str): The file path of the sales data CSV file. - `summaryFilePath` (str): The file path to write the summary report CSV file. **Returns:** - None. The function writes the summary information to the specified summary file. **Constraints:** - The CSV file format assumes the first row contains headers and subsequent rows contain sales data for each day. - Each data row contains at least a \\"date\\" and \\"sales\\" column. Example Usage: ```python summarize_sales(\\"/path/to/sales.csv\\", \\"/path/to/summary.csv\\") ``` Given the details, implement the `summarize_sales` function to read the sales data and generate the summary report correctly.","solution":"import csv def summarize_sales(salesFilePath: str, summaryFilePath: str) -> None: total_sales = 0 num_days = 0 # Read the sales data with open(salesFilePath, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file) for row in reader: total_sales += float(row[\'sales\']) num_days += 1 # Calculate average sales average_sales = total_sales / num_days if num_days > 0 else 0 # Write the summary report with open(summaryFilePath, mode=\'w\', newline=\'\') as file: writer = csv.writer(file) writer.writerow([\'Total Sales\', \'Average Sales\']) writer.writerow([total_sales, average_sales])"},{"question":"**Context:** In many applications, it is crucial to process data efficiently. One common technique is to parse logs that record application activities over time. These logs usually contain timestamped events, and one might need to analyze such logs to extract specific insights, like identifying the most frequent events in a given time window. **Objective:** Write a function named `most_frequent_events` that takes the following arguments: - `logs`: a list of tuples where each tuple contains a timestamp (as a string in \\"YYYY-MM-DD HH:MM:SS\\" format) and an event name (as a string). - `start_time`: a string representing the start time of the analysis window in \\"YYYY-MM-DD HH:MM:SS\\" format. - `end_time`: a string representing the end time of the analysis window in \\"YYYY-MM-DD HH:MM:SS\\" format. The function should: 1. Parse the timestamps and filter the events that fall within the given time window (inclusive). 2. Count the frequency of each event within this window. 3. Return a list of the most frequent events, sorted in descending order of frequency. If two events have the same frequency, they should be sorted lexicographically. **Requirements:** - Use the `datetime` module to handle date and time operations. - Use the `collections.Counter` class to count event frequencies. **Example:** ```python logs = [ (\\"2023-08-01 12:00:00\\", \\"login\\"), (\\"2023-08-01 12:01:00\\", \\"logout\\"), (\\"2023-08-01 12:01:30\\", \\"login\\"), (\\"2023-08-01 12:02:00\\", \\"login\\"), (\\"2023-08-01 12:03:00\\", \\"view_page\\") ] start_time = \\"2023-08-01 12:00:00\\" end_time = \\"2023-08-01 12:02:30\\" # The function should return the list of the most frequent events in the specified time window. # Example output: # [\\"login\\"] ```","solution":"from datetime import datetime from collections import Counter def most_frequent_events(logs, start_time, end_time): Returns the most frequent events occurring within the specified time window. start = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") # Filter logs within the time window filtered_logs = [event for timestamp, event in logs if start <= datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") <= end] # Count the frequency of each event event_counts = Counter(filtered_logs) if not event_counts: return [] # Identify the maximum frequency max_freq = max(event_counts.values()) # Collect events with the maximum frequency most_frequent = [event for event in sorted(event_counts.keys()) if event_counts[event] == max_freq] return most_frequent"},{"question":"You are responsible for designing a function that computes and visualizes the trajectory of a projectile. The dataset contains information about initial velocity, angle of projection, and time intervals. The objective is to use kinematic equations to calculate the position of the projectile at each time interval, and then plot the trajectory using `matplotlib`. Additionally, store the trajectory data in a `pandas` DataFrame and return it along with the plot. Your task: Write a function `plot_trajectory(filepath)` that takes a file path to a CSV file as input, performs the following operations, and returns a tuple containing `df` and `fig`: 1. **Read the CSV file** using `pandas.read_csv` into a DataFrame, which has columns `velocity`, `angle`, `time`. 2. **Compute the X and Y** coordinates for each time point using the formulas: - ( x = v cdot t cdot cos(theta) ) - ( y = v cdot t cdot sin(theta) - frac{1}{2} g cdot t^2 ) where ( v ) is the initial velocity, ( theta ) is the angle in radians, ( t ) is the time, and ( g ) is the gravitational constant (9.8 m/s(^2)). 3. **Store** the computed X and Y coordinates along with the original data in a new `pandas` DataFrame. 4. **Visualize** the projectile trajectory on a plot using `matplotlib.pyplot.subplots`. - Plot the data points with a solid blue line representing the trajectory. 5. **Return** the DataFrame and the figure. **Function Signature:** ```python def plot_trajectory(filepath: str) -> tuple: ``` **Assume the CSV file has the following format**: ```plaintext velocity,angle,time 50,45,1 50,45,2 50,45,3 ... ``` - `velocity` is the initial velocity of the projectile in m/s. - `angle` is the angle of projection in degrees. - `time` is the time interval in seconds. Utilize the library APIs exactly as specified: - `pandas.read_csv` - `matplotlib.pyplot.subplots` - `numpy.cos` - `numpy.sin` - `numpy.deg2rad`","solution":"import pandas as pd import numpy as np import matplotlib.pyplot as plt def plot_trajectory(filepath: str) -> tuple: g = 9.8 # acceleration due to gravity in m/s^2 # Read the CSV file df = pd.read_csv(filepath) # Convert angle in degrees to radians df[\'angle\'] = np.deg2rad(df[\'angle\']) # Compute X and Y coordinates df[\'x\'] = df[\'velocity\'] * df[\'time\'] * np.cos(df[\'angle\']) df[\'y\'] = df[\'velocity\'] * df[\'time\'] * np.sin(df[\'angle\']) - 0.5 * g * df[\'time\'] ** 2 # Create the plot fig, ax = plt.subplots() ax.plot(df[\'x\'], df[\'y\'], \'-b\', label=\'Trajectory\') ax.set_xlabel(\'X Coordinate (m)\') ax.set_ylabel(\'Y Coordinate (m)\') ax.set_title(\'Projectile Trajectory\') ax.legend() # Return the DataFrame and the figure return df, fig"},{"question":"You are required to implement a function that will generate a Fibonacci sequence up to a certain count without using recursion. The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones. This task will test your understanding of loops and series generation in Python. **Objective:** Write a function named `generate_fibonacci` that takes one argument, `count`, which represents the number of Fibonacci numbers to generate. The function should return a list containing the Fibonacci sequence up to the given count. **Parameters:** - `count` (int): The number of Fibonacci numbers to generate. If `count` is 0, return an empty list. If `count` is 1, return a list with only the first Fibonacci number [0]. **Expected Behavior:** 1. Initialize your sequence with the first two Fibonacci numbers [0, 1]. 2. Use a loop to generate the remaining Fibonacci numbers until you reach the desired count. 3. Return the resulting list of Fibonacci numbers. **Requirements:** - Do not use recursion. - Use a loop to build the sequence. - Handle edge cases where `count` is less than 2 appropriately. Example: ```python generate_fibonacci(5) ``` The above call should return `[0, 1, 1, 2, 3]` as the first five Fibonacci numbers. Example 2: ```python generate_fibonacci(1) ``` The above call should return `[0]` as the first Fibonacci number. #","solution":"def generate_fibonacci(count): Returns a list containing the Fibonacci sequence up to the given count. Parameters: count (int): The number of Fibonacci numbers to generate. Returns: list: A list of the first \'count\' Fibonacci numbers. if count <= 0: return [] elif count == 1: return [0] elif count == 2: return [0, 1] fib_seq = [0, 1] for _ in range(2, count): fib_seq.append(fib_seq[-1] + fib_seq[-2]) return fib_seq"},{"question":"Implement a Python function called `LongestConsecutiveSubsequence` that takes a list of integers and returns the length of the longest consecutive elements subsequence. The elements of the subsequence should appear in ascending order without any gaps. # Function Signature: ```python def LongestConsecutiveSubsequence(nums: List[int]) -> int: pass ``` # Input: - `nums` is a list of integers, which may contain duplicates and is unsorted. # Output: - The function should return an integer representing the length of the longest subsequence of consecutive integers. # Example: ```python nums = [100, 4, 200, 1, 3, 2] print(LongestConsecutiveSubsequence(nums)) # Output: 4 ``` # Explanation: The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore, the length is 4. # Constraints: - The list can have up to 10,000 elements. - The values within the list may range between -10^9 and 10^9. Implement the `LongestConsecutiveSubsequence` function to find the length of the longest consecutive sequence in the given list.","solution":"from typing import List def LongestConsecutiveSubsequence(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only check if this number is the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are asked to write a function `k_distance_nodes` to find all nodes at a distance `k` from a given target node in a binary tree. The function should take the root of the binary tree and the target node value, and return a list of node values that are exactly `k` edges away from the target node. The binary tree is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The function signature should be: ```python def k_distance_nodes(root: TreeNode, target: int, k: int) -> List[int]: # Your code here pass ``` # Rules and Requirements: - Nodes are represented by their values, which are unique. - All nodes in the list should be sorted in ascending order. - If no nodes are found at distance `k`, return an empty list. # Examples: Example 1: ``` Input: root = [3,5,1,6,2,0,8,None,None,7,4] target = 5 k = 2 Output: [7, 4, 1] ``` Example 2: ``` Input: root = [1] target = 1 k = 3 Output: [] ``` # Additional Notes: 1. Assume binary tree is defined in level-order traversal format for easier comprehension of the structure. 2. Use Breadth-First Search (BFS) or Depth-First Search (DFS) as appropriate to solve the problem. Implement the function `k_distance_nodes(root: TreeNode, target: int, k: int) -> List[int]`.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target(root, target): if not root: return None if root.val == target: return root left_search = find_target(root.left, target) if left_search: return left_search return find_target(root.right, target) def k_distance_nodes_dfs(node, k, result, visited): if not node or node in visited: return visited.add(node) if k == 0: result.append(node.val) return k_distance_nodes_dfs(node.left, k-1, result, visited) k_distance_nodes_dfs(node.right, k-1, result, visited) def k_distance_nodes_upwards(node, target, k, result, visited): if not node or node in visited: return -1 if node.val == target: k_distance_nodes_dfs(node, k, result, visited) return 0 dl = k_distance_nodes_upwards(node.left, target, k, result, visited) if dl != -1: if dl + 1 == k: result.append(node.val) else: k_distance_nodes_dfs(node.right, k - dl - 2, result, visited) return 1 + dl dr = k_distance_nodes_upwards(node.right, target, k, result, visited) if dr != -1: if dr + 1 == k: result.append(node.val) else: k_distance_nodes_dfs(node.left, k - dr - 2, result, visited) return 1 + dr return -1 def k_distance_nodes(root: TreeNode, target: int, k: int) -> List[int]: target_node = find_target(root, target) if not target_node: return [] result = [] visited = set() k_distance_nodes_upwards(root, target, k, result, visited) return sorted(result)"},{"question":"You are requested to develop a Python function named `compare_salaries`. This function will analyze the salary increments of employees in a company over a span of years based on their job performance ratings. The function will generate a line plot to visually compare the salary growth over the years for employees with different performance ratings using the `Matplotlib` library. Specifically, your function should: 1. Use two helper functions: `high_performer_salaries()` and `low_performer_salaries()`, both of which return a list of salary increments over the years for high and low performing employees respectively. 2. Plot two lines on the same graph: - One line representing the salary increments for high performers (colored green). - One line representing the salary increments for low performers (colored orange). 3. Label the x-axis as \\"Year\\". 4. Label the y-axis as \\"Salary Increment (%)\\". 5. Limit the x-axis to the range of years available in the lists. 6. Set the y-axis to range from 0 to the maximum salary increment percentage plus a small margin for clarity. 7. Include a legend identifying which line represents high performers and which represents low performers. Below is a starter code to help you implement this function: ```python def high_performer_salaries(): # This function returns a list of salary increments for high performers pass def low_performer_salaries(): # This function returns a list of salary increments for low performers pass def compare_salaries(): import matplotlib.pyplot as plt high_perf = high_performer_salaries() low_perf = low_performer_salaries() years = range(1, len(high_perf) + 1) plt.plot(years, high_perf, \'g\', label=\'High Performers\') plt.plot(years, low_perf, \'orange\', label=\'Low Performers\') plt.xlabel(\'Year\') plt.ylabel(\'Salary Increment (%)\') plt.xlim(1, len(years)) plt.ylim(0, max(max(high_perf), max(low_perf)) + 5) plt.legend() plt.show() ``` **Note**: You may assume that both `high_performer_salaries` and `low_performer_salaries` functions are correctly implemented and return the expected lists of salary increments.","solution":"def high_performer_salaries(): This function returns a list of salary increments (in percentages) over the years for high performers. # Example data for high performers; in real scenario, this data would be fetched from a database or any other source. return [5, 7, 10, 12, 15] def low_performer_salaries(): This function returns a list of salary increments (in percentages) over the years for low performers. # Example data for low performers; in real scenario, this data would be fetched from a database or any other source. return [2, 3, 4, 4, 5] def compare_salaries(): import matplotlib.pyplot as plt high_perf = high_performer_salaries() low_perf = low_performer_salaries() years = range(1, len(high_perf) + 1) plt.plot(years, high_perf, \'g\', label=\'High Performers\') plt.plot(years, low_perf, \'orange\', label=\'Low Performers\') plt.xlabel(\'Year\') plt.ylabel(\'Salary Increment (%)\') plt.xlim(1, len(years)) plt.ylim(0, max(max(high_perf), max(low_perf)) + 5) plt.legend() plt.show()"},{"question":"You are assigned to develop a function that can analyze a set of given products and their respective prices, then determine a price range category for each product. The function will help classify products into different pricing tiers for better organizational understanding. Implement a function `categorize_products` that adheres to the following specifications: 1. **Function Signature**: ```python def categorize_products(product_dict: dict[str, float]) -> dict[str, str]: ``` 2. **Parameters**: - `product_dict`: A dictionary where the keys are product names (strings) and the values are product prices (floats). 3. **Requirements**: - Categorize each product into one of three price range categories: - \\"Budget\\": Products priced below 20. - \\"Mid-Range\\": Products priced between 20 (inclusive) and 100 (exclusive). - \\"Premium\\": Products priced at 100 and above. - Generate a new dictionary where each key is a product name and its corresponding value is the category it falls into (\\"Budget\\", \\"Mid-Range\\", or \\"Premium\\"). 4. **Return**: - A dictionary where keys are product names and values are their respective price categories. # Example Usage: ```python product_dict = { \\"Product A\\": 15.99, \\"Product B\\": 45.50, \\"Product C\\": 120.00, \\"Product D\\": 99.99, \\"Product E\\": 19.99, \\"Product F\\": 200.00, } result = categorize_products(product_dict) print(result) # Output should be: { # \\"Product A\\": \\"Budget\\", # \\"Product B\\": \\"Mid-Range\\", # \\"Product C\\": \\"Premium\\", # \\"Product D\\": \\"Mid-Range\\", # \\"Product E\\": \\"Budget\\", # \\"Product F\\": \\"Premium\\", # } ```","solution":"def categorize_products(product_dict: dict[str, float]) -> dict[str, str]: Categorize each product into price range categories. Parameters: - product_dict: A dictionary where keys are product names and values are product prices. Returns: - A dictionary where keys are product names and values are their respective price categories (\\"Budget\\", \\"Mid-Range\\", \\"Premium\\"). categorized_dict = {} for product, price in product_dict.items(): if price < 20: categorized_dict[product] = \\"Budget\\" elif 20 <= price < 100: categorized_dict[product] = \\"Mid-Range\\" else: categorized_dict[product] = \\"Premium\\" return categorized_dict"},{"question":"You are required to create a function called `max_circular_subarray_sum` which determines the maximum sum of a subarray in a circular array. In a circular array, the end of the array wraps around to the start. Heres the approach to solve the problem: 1. Compute the maximum subarray sum without considering the circular nature of the array using Kadanes algorithm. 2. Compute the maximum subarray sum that includes circular subarrays. This can be done by finding the minimum subarray sum using Kadanes algorithm and subtracting this from the total array sum. 3. The result will be the maximum of the two sums computed in the previous steps. However, if all numbers are negative then the maximum sum will simply be the largest number, as the circular subarray sum would be zero or less in this case. **Function Signature:** ```python def max_circular_subarray_sum(arr: List[int]) -> int: ``` **Input:** - `arr` (a list of integers): The input array, which can contain both positive and negative integers. **Output:** - An integer representing the maximum sum of a subarray in the circular array. **Constraints:** - The length of the array will be between 1 and 10^5. - Each element of the array will be between -10^5 and 10^5. **Examples:** ```python print(max_circular_subarray_sum([8, -1, 3, 4])) # Output: 15 print(max_circular_subarray_sum([-4, 5, 1, 0])) # Output: 6 print(max_circular_subarray_sum([-1, -2, -3, -4])) # Output: -1 ```","solution":"from typing import List def kadane(arr: List[int]) -> int: Standard Kadane\'s algorithm to find the maximum subarray sum. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def max_circular_subarray_sum(arr: List[int]) -> int: n = len(arr) # Case 1: Get the maximum subarray sum using Kadane\'s algorithm max_kadane = kadane(arr) # Case 2: Find the maximum subarray sum that includes corner elements total_sum = sum(arr) # Invert the array elements to apply Kadane\'s algorithm for finding the minimum subarray sum for i in range(n): arr[i] = -arr[i] max_inverse_kadane = kadane(arr) # Undo inversion for i in range(n): arr[i] = -arr[i] max_wrap = total_sum + max_inverse_kadane # Handle the case where all elements are negative if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"In this task, you are required to write a Python function named `matrix_diagonal_sum` which calculates the sum of the diagonals of a square matrix. # Function Specifications: Your function, `matrix_diagonal_sum`, should: 1. Receive a 2D list of integers (a square matrix) as a parameter. 2. Calculate the sum of the elements on the primary (top-left to bottom-right) and secondary (top-right to bottom-left) diagonals. 3. Return the sum as an integer. # Constraints: - The matrix will be of size ( n times n ) where ( 1 leq n leq 100 ) - The elements of the matrix will be integers within the range [-1000, 1000]. # Example Call: ```python matrix_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ``` # Expected Output: ```python 25 ``` # Explanation: For the given matrix: - The primary diagonal elements are 1, 5, and 9. - The secondary diagonal elements are 3, 5, and 7. - The sum is ( 1 + 5 + 9 + 3 + 5 + 7 = 30 ). Note that in the case where the matrix size is odd, the middle element, which appears in both diagonals, should only be counted once. For example, in the above matrix, the element 5 appears in both diagonals but is only counted once in the final sum. Thus, ( 30 - 5 = 25 ).","solution":"def matrix_diagonal_sum(matrix): Calculate the sum of the primary and secondary diagonals of a square matrix. If the matrix size is odd, the middle element which appears in both diagonals is counted only once. Args: matrix: list of list of int, representing a square matrix Returns: int: The sum of the diagonals\' elements. n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - i - 1] total_sum = primary_diagonal_sum + secondary_diagonal_sum # If n is odd, subtract the middle element (as it\'s been counted twice) if n % 2 == 1: middle_index = n // 2 total_sum -= matrix[middle_index][middle_index] return total_sum"},{"question":"You are tasked with implementing a function named `stringCompressor` which compresses a given string by replacing consecutive repeating characters with the character followed by the number of repetitions. This scenario is common in simple data compression algorithms. # Requirements: - The function should take a single argument: - `input_string`: A non-empty string consisting of lowercase alphabetic characters. The function should perform the following actions: 1. Traverse the input string and identify consecutive repeating characters. 2. For each set of consecutive repeating characters, replace them with the character followed by the number of repetitions. 3. If a character does not repeat consecutively, it should remain as is in the compressed string. 4. The function should return the compressed string. # Additional Note: - If the compressed string is not shorter than the original string, return the original string instead. # Example: ```python input_string = \\"aaabbcaaa\\" result = stringCompressor(input_string) # Expected output: \\"a3b2ca3\\" input_string = \\"abcd\\" result = stringCompressor(input_string) # Expected output: \\"abcd\\" because compressed version \\"a1b1c1d1\\" is longer ``` You are required to implement the function `stringCompressor` to achieve the described functionality. Ensure that the function handles typical use cases properly. ```python def stringCompressor(input_string): # Your code here pass ```","solution":"def stringCompressor(input_string): Compresses the given string by replacing consecutive repeating characters with the character followed by the number of repetitions. If the compressed string is not shorter than the original string, returns the original string. if not input_string: return input_string compressed_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i-1]: count += 1 else: compressed_string.append(input_string[i-1]) if count > 1: compressed_string.append(str(count)) count = 1 # Add the last character and its count compressed_string.append(input_string[-1]) if count > 1: compressed_string.append(str(count)) compressed = \'\'.join(compressed_string) return compressed if len(compressed) < len(input_string) else input_string"},{"question":"Write a Python function that retrieves and displays the real-time stock prices of a given list of companies over the last month, plots these prices using matplotlib, and calculates the average stock price for each company over the given period. The function should output a dictionary containing the company\'s ticker symbol and its corresponding average price. You may use any stock market API of your choice. Ensure to handle API limits and exceptions appropriately. The function prototype should be: ``` import requests import matplotlib.pyplot as plt import datetime def retrieve_and_plot_stock_prices(tickers): ```","solution":"import requests import matplotlib.pyplot as plt import datetime import numpy as np def retrieve_and_plot_stock_prices(tickers): Retrieves and plots the real-time stock prices of the given list of companies over the last month. Calculates and returns the average stock price for each company over the given period. Args: tickers (list): List of company ticker symbols. Returns: dict: Dictionary containing the company\'s ticker symbol as key and its corresponding average price as value. api_key = \'YOUR_API_KEY\' # Replace with your actual API key base_url = \'https://www.alphavantage.co/query?\' results = {} all_prices = {} today = datetime.date.today() one_month_ago = today - datetime.timedelta(days=30) # Retrieving stock data for each ticker for ticker in tickers: params = { \'function\': \'TIME_SERIES_DAILY\', \'symbol\': ticker, \'apikey\': api_key } response = requests.get(base_url, params=params) if response.status_code == 200: data = response.json() if \'Time Series (Daily)\' in data: time_series = data[\'Time Series (Daily)\'] prices = [] for date, price_info in time_series.items(): date_obj = datetime.datetime.strptime(date, \'%Y-%m-%d\').date() if one_month_ago <= date_obj <= today: prices.append(float(price_info[\'4. close\'])) if prices: average_price = np.mean(prices) results[ticker] = average_price all_prices[ticker] = prices else: results[ticker] = None else: results[ticker] = None else: results[ticker] = None # Plotting the stock prices plt.figure(figsize=(14, 8)) for ticker, prices in all_prices.items(): plt.plot(prices, label=ticker) plt.xlabel(\'Days\') plt.ylabel(\'Stock Price (USD)\') plt.title(\'Stock Prices Over The Last Month\') plt.legend() plt.grid() plt.show() return results"},{"question":"You are tasked with writing a function called `matrix_transform` that performs a series of operations on an input matrix (a list of lists) of integers. The function should perform the following operations based on the provided command: 1. \'rotate\': Rotates the matrix 90 degrees clockwise. 2. \'row_sum\': Returns a list of sums for each row. 3. \'col_sum\': Returns a list of sums for each column. 4. \'transpose\': Returns the transpose of the matrix. 5. \'flatten\': Returns a flattened list of all elements in the matrix. # Instructions 1. Implement the `matrix_transform` function that takes two arguments: `matrix` (the input matrix) and `command` (the operation to perform). 2. Ensure that the matrix is properly transformed based on the given command. 3. The function should handle edge cases, such as empty matrices, appropriately. # Example Usage ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(matrix_transform(matrix, \'rotate\')) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(matrix_transform(matrix, \'row_sum\')) # Output: [6, 15, 24] print(matrix_transform(matrix, \'col_sum\')) # Output: [12, 15, 18] print(matrix_transform(matrix, \'transpose\')) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(matrix_transform(matrix, \'flatten\')) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Notes - You can assume that the input matrix is always rectangular. - You may use helper functions if needed to perform specific operations. - The input matrix can contain any integers, including negative values. ```python def matrix_transform(matrix, command): if command == \'rotate\': return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]) - 1, -1, -1)] elif command == \'row_sum\': return [sum(row) for row in matrix] elif command == \'col_sum\': return [sum(matrix[i][j] for i in range(len(matrix))) for j in range(len(matrix[0]))] elif command == \'transpose\': return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] elif command == \'flatten\': return [item for row in matrix for item in row] else: raise ValueError(\\"Invalid command\\") ```","solution":"def matrix_transform(matrix, command): if command == \'rotate\': return [[matrix[j][i] for j in range(len(matrix)-1, -1, -1)] for i in range(len(matrix[0]))] elif command == \'row_sum\': return [sum(row) for row in matrix] elif command == \'col_sum\': return [sum(matrix[i][j] for i in range(len(matrix))) for j in range(len(matrix[0]))] elif command == \'transpose\': return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] elif command == \'flatten\': return [item for row in matrix for item in row] else: raise ValueError(\\"Invalid command\\")"},{"question":"** You are required to write a function named `words_frequency` that takes in a text file and returns the frequency of each word in the text. The function should ignore case sensitivity, remove punctuation, and exclude common stop words from the frequency count. The result should be a dictionary where the keys are words and the values are their respective frequencies sorted by frequency in descending order. **Function Signature:** ```python def words_frequency(filename: str) -> dict: ``` **Parameters:** - `filename` (str): The name of the text file from which to read the data. **Requirements:** - Use the `collections` library\'s `Counter` to help count the word frequencies. - Ignore case (e.g., \\"Python\\" and \\"python\\" should be treated as the same word). - Remove punctuation (`.` `,` `!` `?` `:` `;` `\'` `\\"`). - Exclude the following common stop words: \\"a\\", \\"an\\", \\"the\\", \\"and\\", \\"or\\", \\"but\\", \\"if\\", \\"in\\", \\"on\\", \\"at\\", \\"by\\", \\"for\\", \\"with\\", \\"to\\", \\"of\\", \\"from\\". - Return a dictionary where the words are keys and their frequencies are values, sorted in descending order of frequencies. **Example Text File Content (example.txt):** ``` Python is powerful... and fast; plays well with others; runs everywhere; is friendly & easy to learn; is Open. These are some of Python\'s selling points. ``` **Example Usage:** ```python result = words_frequency(\'example.txt\') print(result) ``` **Expected Output:** ```python { \'python\': 2, \'is\': 2, \'powerful\': 1, \'fast\': 1, \'plays\': 1, \'well\': 1, \'others\': 1, \'runs\': 1, \'everywhere\': 1, \'friendly\': 1, \'easy\': 1, \'learn\': 1, \'open\': 1, \'these\': 1, \'some\': 1, \'selling\': 1, \'points\': 1 } ```","solution":"import string from collections import Counter def words_frequency(filename: str) -> dict: stop_words = set([\\"a\\", \\"an\\", \\"the\\", \\"and\\", \\"or\\", \\"but\\", \\"if\\", \\"in\\", \\"on\\", \\"at\\", \\"by\\", \\"for\\", \\"with\\", \\"to\\", \\"of\\", \\"from\\"]) def clean_word(word): return word.strip(string.punctuation).lower() with open(filename, \'r\') as file: text = file.read() words = text.split() cleaned_words = [clean_word(word) for word in words if clean_word(word) not in stop_words and clean_word(word) != \'\'] word_counts = Counter(cleaned_words) sorted_word_counts = dict(sorted(word_counts.items(), key=lambda item: item[1], reverse=True)) return sorted_word_counts # Example usage # result = words_frequency(\'example.txt\') # print(result)"},{"question":"You are tasked with writing a function called `unique_elements_sum` that processes a given list of integers and returns the sum of all the elements that appear exactly once in the list. The function should take the following steps: 1. **Input**: The function should accept a single parameter `elements`, which is a list of integers. 2. **Count Elements**: The function should count the occurrences of each integer in the list. 3. **Filter Unique Elements**: Identify integers that appear exactly once in the list. 4. **Sum Unique Elements**: Compute the sum of the integers that appear exactly once. 5. **Return Result**: The function should return the computed sum. You are encouraged to use Python\'s built-in data structures and functions to implement this. Function Signature: ```python def unique_elements_sum(elements: list) -> int: ``` **Example**: ```python elements = [1, 2, 2, 3, 4, 4, 5] result = unique_elements_sum(elements) print(result) ``` Expected Output: ``` 9 ``` In this problem, we practice using Python\'s dictionary to count occurrences of elements and list comprehensions to filter and sum unique elements.","solution":"def unique_elements_sum(elements: list) -> int: Returns the sum of elements that appear exactly once in the list. :param elements: List of integers :return: Sum of unique elements # Create a dictionary to count occurrences of each element counts = {} for element in elements: if element in counts: counts[element] += 1 else: counts[element] = 1 # Sum elements that appear exactly once in the list unique_elements_sum = sum(element for element, count in counts.items() if count == 1) return unique_elements_sum"},{"question":"Write a function `alter_list_elements` that takes in two parameters: 1. A list of integers `nums`. 2. An integer `n`. The function should iterate through the list and perform the following operations: 1. If an element is divisible by `n`, multiply the element by 2. 2. If an element is not divisible by `n`, subtract 3 from the element. Finally, the function should return the modified list. Example: ```python alter_list_elements([10, 15, 20, 25], 5) # returns [20, 30, 40, 22] alter_list_elements([4, 7, 10, 13], 2) # returns [8, 4, 20, 10] ```","solution":"def alter_list_elements(nums, n): Modifies each element in the list `nums` based on its divisibility by `n`. If an element is divisible by `n`, it is multiplied by 2. If an element is not divisible by `n`, 3 is subtracted from it. Parameters: nums (list): A list of integers. n (int): The integer to check divisibility by. Returns: list: The modified list. return [x * 2 if x % n == 0 else x - 3 for x in nums]"},{"question":"In this problem, you will work with string manipulation and regular expressions. The goal is to construct a function `extract_emails()` that extracts all unique email addresses from a given text and returns them in a sorted list. **Objectives:** 1. Identify and extract all email addresses from the provided text. 2. Ensure that the email addresses match the general format of `username@domain.extension`. 3. Remove any duplicate email addresses. 4. Return the unique email addresses in a case-insensitive sorted order. # Detailed Steps: 1. **Define the function `extract_emails(text)`**: - Use a regular expression to find all instances of email addresses in the text. An email is typically in the format `username@domain.extension`, where: - `username` may include alphanumeric characters, dots, hyphens, and underscores. - `domain` may include alphanumeric characters and dots. - `extension` typically includes only alphabetic characters and is 2-6 characters long. - Collect all emails found by the regex in a set to ensure uniqueness. - Convert the set to a list and sort it in a case-insensitive manner. - Return the sorted list of unique email addresses. **Function Signature:** ```python def extract_emails(text): Extracts all unique email addresses from the provided text and returns them in a case-insensitive sorted list. Args: text (str): The text to scan for email addresses. Returns: List[str]: A sorted list of unique email addresses. ``` Ensure the use of the following library APIs: - `re.findall`: To find all occurrences that match the email pattern. - `sorted`: To sort the list of unique email addresses. - String methods and set operations for case-insensitive handling and uniqueness.","solution":"import re def extract_emails(text): Extracts all unique email addresses from the provided text and returns them in a case-insensitive sorted list. Args: text (str): The text to scan for email addresses. Returns: List[str]: A sorted list of unique email addresses. # Regex pattern for matching email addresses email_pattern = r\'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,6}\' # Find all matching email addresses in the text and convert to lowercase for case-insensitive matching emails = re.findall(email_pattern, text) unique_emails = {email.lower() for email in emails} # Sort the unique email addresses in case-insensitive manner sorted_emails = sorted(unique_emails) return sorted_emails"},{"question":"In this problem, you\'ll implement a basic command-line calculator in Python that can handle addition, subtraction, multiplication, and division of integers. You are to write a function called `calculate` that: 1. Takes a single string input `expression` in the form of \\"a op b\\", where: - `a` is an integer (can be positive or negative), - `op` is one of the operators: `+`, `-`, `*`, or `/`, - `b` is an integer (can be positive or negative). 2. Parses this input string to extract the two integers and the operator. 3. Performs the calculation based on the operator and returns the result. 4. If the operator is `/` (division), perform integer division and truncate towards zero. # Constraints: - You can assume the input format is always correct and it will always contain valid integers and operators. - Division by zero is not permitted, and you should handle it by returning the string `\\"Error: Division by zero\\"`. # Example: ```python calculate(\\"10 + 5\\") ``` Expected output: ``` 15 ``` ```python calculate(\\"10 / 0\\") ``` Expected output: ``` Error: Division by zero ``` ```python calculate(\\"-3 * -6\\") ``` Expected output: ``` 18 ``` Your task is to complete the `calculate` function so that it operates as described and handles the given constraints.","solution":"def calculate(expression): Parses the input expression string and performs the calculation. Parameters: expression (str): The input string in the form \'a op b\'. Returns: int/str: The result of the arithmetic operation or an error message if division by zero is attempted. # Split the expression into components parts = expression.split() a = int(parts[0]) op = parts[1] b = int(parts[2]) # Perform the appropriate calculation if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b elif op == \'/\': if b == 0: return \\"Error: Division by zero\\" else: return a // b # Integer division"},{"question":"You are given a class `BinaryTree` that represents a binary tree. The class supports the following methods: - `insert(value)`: Inserts a new node with the given value into the tree following standard binary search tree insertion rules. - `delete(value)`: Deletes the node with the given value from the tree, maintaining the binary search tree properties. - `find(value)`: Finds and returns the node with the given value if it exists, otherwise returns None. Your task is to implement a function `is_symmetric(tree)` that checks whether the given binary tree is symmetric around its center. A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree. The function should handle the following cases: 1. If the tree is empty, return `True`. 2. If the tree has only one node, return `True`. 3. For larger trees, recursively check the symmetry condition for left and right subtrees. The exact details of the function are as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, value): # Implementation of insert method def delete(self, value): # Implementation of delete method def find(self, value): # Implementation of find method def is_symmetric(tree): \'\'\' Checks whether the binary tree `tree` is symmetric around its center. Parameters: tree: BinaryTree object with methods as described above. Returns: bool: True if the tree is symmetric, False otherwise. \'\'\' def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.value == right.value) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) if not tree.root: return True return is_mirror(tree.root.left, tree.root.right) ``` Use the class `TreeNode` for representing individual nodes in the binary tree. The `is_mirror` helper function can be used recursively to check the symmetry condition by comparing corresponding nodes in the left and right subtrees.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_rec(self.root, value) def _insert_rec(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_rec(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_rec(node.right, value) def delete(self, value): self.root = self._delete_rec(self.root, value) def _delete_rec(self, node, value): if node is None: return node if value < node.value: node.left = self._delete_rec(node.left, value) elif value > node.value: node.right = self._delete_rec(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left temp_value = self._min_value_node(node.right).value node.value = temp_value node.right = self._delete_rec(node.right, temp_value) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def find(self, value): return self._find_rec(self.root, value) def _find_rec(self, node, value): if node is None or node.value == value: return node if value < node.value: return self._find_rec(node.left, value) return self._find_rec(node.right, value) def is_symmetric(tree): def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.value == right.value) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) if not tree.root: return True return is_mirror(tree.root.left, tree.root.right)"},{"question":"In this exercise, you will implement a system to manage a collection of books in a library. The system should allow users to add books, remove books, and search for books by their title. Create a class called `Library` that has the following methods: 1. `__init__()`  Initializes an empty list of books. 2. `add_book(title: str)`  Adds a book with the given title to the collection. 3. `remove_book(title: str)`  Removes the book with the given title from the collection. If the book is not found, this method should do nothing. 4. `find_book(title: str) -> bool`  Returns `True` if the book with the given title is in the collection, otherwise returns `False`. Below is a sample usage of the `Library` class: ```python library = Library() library.add_book(\\"The Great Gatsby\\") assert library.find_book(\\"The Great Gatsby\\") == True library.remove_book(\\"The Great Gatsby\\") assert library.find_book(\\"The Great Gatsby\\") == False ``` Ensure that your code follows good object-oriented design practices and is well-documented.","solution":"class Library: def __init__(self): Initializes the Library with an empty list of books. self.books = [] def add_book(self, title: str): Adds a book with the given title to the collection. :param title: Title of the book to add self.books.append(title) def remove_book(self, title: str): Removes the book with the given title from the collection. If the book is not found, does nothing. :param title: Title of the book to remove if title in self.books: self.books.remove(title) def find_book(self, title: str) -> bool: Returns True if the book with the given title is in the collection, otherwise returns False. :param title: Title of the book to find :return: Boolean indicating if the book is found return title in self.books"},{"question":"Given a list of integers, write a function that identifies the longest consecutive subsequence of increasing numbers and returns the starting and ending indices of that subsequence. If there are multiple subsequences of the same length, return the first one found. The function should handle an empty list and list with one element appropriately. The function should return: - Tuple[int, int]: The starting and ending indices of the longest increasing consecutive subsequence. You should write self-contained code starting with: ``` def longest_increasing_subsequence(nums): ```","solution":"def longest_increasing_subsequence(nums): Identifies the longest consecutive subsequence of increasing numbers in a list. Args: nums (List[int]): A list of integers Returns: Tuple[int, int]: The starting and ending indices of the longest increasing consecutive subsequence if not nums: return (None, None) if len(nums) == 1: return (0, 0) max_len = 1 curr_len = 1 start_index = 0 max_start_index = 0 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: curr_len += 1 else: if curr_len > max_len: max_len = curr_len max_start_index = start_index curr_len = 1 start_index = i if curr_len > max_len: max_len = curr_len max_start_index = start_index return (max_start_index, max_start_index + max_len - 1)"},{"question":"You need to create a function `compare_bst` that compares two binary search trees (BSTs) to determine if they are structurally identical and their node values are equal. The function should be implemented recursively and should adhere to the specifications provided below: Function Signature: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def compare_bst(tree1, tree2): Compare two binary search trees to check if they are identical in structure and node values. Parameters: tree1 : TreeNode The root node of the first binary search tree. tree2 : TreeNode The root node of the second binary search tree. Returns: bool True if the two binary search trees are identical, False otherwise. ``` The function must ensure: 1. If both nodes being compared are null, they are considered identical. 2. If only one of the nodes is null, they are not identical. 3. If the values of the two nodes are different, they are not identical. 4. If the values of the two nodes are equal, recursively check the left subtrees and the right subtrees. For example: ```python # Tree 1 # 3 # / # 1 4 # Tree 2 # 3 # / # 1 4 node1 = TreeNode(3) node1.left = TreeNode(1) node1.right = TreeNode(4) node2 = TreeNode(3) node2.left = TreeNode(1) node2.right = TreeNode(4) print(compare_bst(node1, node2)) # should return True # Tree 1 # 3 # / # 1 # Tree 2 # 3 # # 1 node3 = TreeNode(3) node3.left = TreeNode(1) node4 = TreeNode(3) node4.right = TreeNode(1) print(compare_bst(node3, node4)) # should return False ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def compare_bst(tree1, tree2): Compare two binary search trees to check if they are identical in structure and node values. Parameters: tree1 : TreeNode The root node of the first binary search tree. tree2 : TreeNode The root node of the second binary search tree. Returns: bool True if the two binary search trees are identical, False otherwise. if tree1 is None and tree2 is None: return True if tree1 is None or tree2 is None: return False if tree1.val != tree2.val: return False return compare_bst(tree1.left, tree2.left) and compare_bst(tree1.right, tree2.right)"},{"question":"You are tasked with writing a function that takes a string representation of a non-negative integer and adds one to the integer it represents, returning the result as a string. The input string will not have leading zeros and will only contain digits. Your goal is to implement a function named `add_one` that performs this operation. The input string represents a valid non-negative integer, and the function should return its incremented value as a new string. **Requirements**: - You should not convert the input string directly to an integer type to perform the addition due to potential limitations with very large numbers. - You must process the string character by character and handle the carry-over manually. **Example**: ```python add_one(\\"123\\") ``` **Expected Output**: ```python \\"124\\" ``` **Example**: ```python add_one(\\"999\\") ``` **Expected Output**: ```python \\"1000\\" ``` Here, the function takes a string as input, manipulates it to add one to the represented number, and returns the new number as a string.","solution":"def add_one(s): Adds one to the integer represented by the string s. Args: s (str): The string representation of the non-negative integer. Returns: str: The string representation of the incremented integer. n = len(s) result = [] carry = 1 for i in range(n - 1, -1, -1): num = int(s[i]) + carry carry = num // 10 result.append(str(num % 10)) if carry: result.append(str(carry)) return \'\'.join(result[::-1])"},{"question":"A chef is preparing a large meal for a party, and a key task is to ensure all the dishes are ready at the same time. Each dish has a different preparation time, and some dishes require other dishes to be completed first (dependencies). Your task is to simulate a scheduling system for the chef\'s meal preparation using a Python function `optimal_cooking_schedule(dishes)`. This function should determine the optimal order to prepare and cook the dishes such that all the dependencies are satisfied and the total preparation time is minimized. **Context and Requirements:** 1. **Dishes Information**: Each dish will be represented as a dictionary entry with the following details: - `name`: A string representing the name of the dish. - `prep_time`: An integer representing the preparation time in minutes. - `dependencies`: A list of dish names that must be completed before this dish can start. 2. **Cooking Schedule**: The function should output a list of tuples, where each tuple contains: - The dish name. - The start time when the preparation for that dish should begin. 3. **Assumptions**: - If there are multiple dishes the chef can start preparing at the same time, they can choose any order for those dishes. - Time starts at 0 minutes. **Function Signature:** ```python def optimal_cooking_schedule(dishes: List[Dict[str, object]]) -> List[Tuple[str, int]]: # Your implementation here ``` **Example Input:** ```python dishes = [ {\\"name\\": \\"Salad\\", \\"prep_time\\": 10, \\"dependencies\\": []}, {\\"name\\": \\"Soup\\", \\"prep_time\\": 20, \\"dependencies\\": [\\"Salad\\"]}, {\\"name\\": \\"Steak\\", \\"prep_time\\": 30, \\"dependencies\\": [\\"Salad\\"]}, {\\"name\\": \\"Dessert\\", \\"prep_time\\": 15, \\"dependencies\\": [\\"Soup\\", \\"Steak\\"]} ] ``` **Example Output:** ```python [ (\\"Salad\\", 0), (\\"Soup\\", 10), (\\"Steak\\", 10), (\\"Dessert\\", 40) ] ``` **Explanation**: 1. \\"Salad\\" can be prepared starting at time 0. 2. \\"Soup\\" and \\"Steak\\" can both start preparing after \\"Salad\\" is done at time 10. 3. \\"Dessert\\" can only start after both \\"Soup\\" and \\"Steak\\" are done, which would be at the maximum of their completion times, i.e., 40 minutes after \\"Steak\\" finishes. Implement the function `optimal_cooking_schedule` that generates an optimal cooking schedule based on the described constraints and dependencies.","solution":"def optimal_cooking_schedule(dishes): from collections import defaultdict, deque # Create a dictionary to store the preparation times and dependencies prep_times = {dish[\'name\']: dish[\'prep_time\'] for dish in dishes} dependencies = {dish[\'name\']: dish[\'dependencies\'] for dish in dishes} # Create a graph to represent the dependencies graph = defaultdict(list) in_degree = defaultdict(int) # Build the graph and the in-degree dict for dish in dishes: for dependency in dish[\'dependencies\']: graph[dependency].append(dish[\'name\']) in_degree[dish[\'name\']] += 1 # Use a queue to perform topological sort queue = deque() for dish in prep_times: if in_degree[dish] == 0: queue.append((dish, 0)) schedule = [] start_times = {} while queue: dish, start_time = queue.popleft() start_times[dish] = start_time schedule.append((dish, start_time)) end_time = start_time + prep_times[dish] for dependent in graph[dish]: in_degree[dependent] -= 1 if in_degree[dependent] == 0: max_start_time = max(start_times[dep] + prep_times[dep] for dep in dependencies[dependent]) queue.append((dependent, max_start_time)) return schedule"},{"question":"# Context You need to process large text documents and extract meaningful insights efficiently. Given a text document represented as a string (`textDocument`), your task is to count the frequency of each word in the document, identify the top N most frequent words, and return them in descending order of their frequency, along with their counts. Words are considered case-insensitively, and common punctuation marks should be ignored. # Objective Write a function named `get_top_n_frequent_words` that: 1. Takes the following inputs: - A string `textDocument` representing the contents of the text document. - An integer `N` representing the number of top frequent words to return. 2. Normalizes the text by converting all words to lower case. 3. Removes common punctuation marks (e.g., commas, periods, semicolons, and colons). 4. Counts the frequency of each word in the text. 5. Identifies the top N most frequent words. 6. Returns the top N words along with their counts as a list of tuples, in descending order of frequency. # Constraints - The function should be case-insensitive. - Common punctuation marks include: commas, periods, semicolons, and colons. - If the document contains fewer than N unique words, the function should return all unique words. # Requirements - Use the `collections.Counter` from the `collections` library. Here\'s a prototype of the function: ```python def get_top_n_frequent_words(textDocument, N): # Your code here ``` Example ```python textDocument = \\"Hello, world! Hello... Python; Python, world: hello!\\" topWords = get_top_n_frequent_words(textDocument, 3) print(topWords) # Example output: [(\'hello\', 3), (\'python\', 2), (\'world\', 2)] ```","solution":"import re from collections import Counter def get_top_n_frequent_words(textDocument, N): Returns the top N most frequent words in the textDocument. Words are normalized to lowercase and common punctuation is removed. Args: textDocument (str): The text to analyze. N (int): The number of top frequent words to return. Returns: List[Tuple[str, int]]: A list of tuples where each tuple contains a word and its frequency. # Normalize text: convert to lowercase and remove punctuation normalized_text = re.sub(r\'[^ws]\', \'\', textDocument.lower()) # Split the text into words words = normalized_text.split() # Count the frequency of each word word_counts = Counter(words) # Get the top N most frequent words most_common_words = word_counts.most_common(N) return most_common_words"},{"question":"You are asked to write a function named `categorize_ages` that takes two arguments: `names` and `ages`. Both arguments are lists of equal length where `names` contains strings representing the names of individuals, and `ages` contains integers representing the ages of these individuals. The goal is to categorize these individuals into three groups: \\"child\\" for ages 0-12, \\"teen\\" for ages 13-19, and \\"adult\\" for ages 20 and above. Your function should return a dictionary where the keys are the names of the individuals and the values are their respective categories. Function Signature: ```python def categorize_ages(names: list, ages: list) -> dict: pass ``` # Example Input: ```python names = [\'Alice\', \'Bob\', \'Charlie\', \'David\'] ages = [10, 17, 25, 8] ``` # Example Output: ```python { \'Alice\': \'child\', \'Bob\': \'teen\', \'Charlie\': \'adult\', \'David\': \'child\' } ``` Make sure to follow these rules in your implementation: 1. Iterate over the `names` and `ages` lists simultaneously. 2. For each individual, determine their category based on their age. 3. Populate the resulting dictionary with names as keys and their corresponding categories as values.","solution":"def categorize_ages(names: list, ages: list) -> dict: Categorize individuals into child, teen, and adult based on their ages. Parameters: names (list): List of names ages (list): List of ages corresponding to the names Returns: dict: Dictionary with names as keys and categories (\'child\', \'teen\', \'adult\') as values category_dict = {} for name, age in zip(names, ages): if 0 <= age <= 12: category_dict[name] = \'child\' elif 13 <= age <= 19: category_dict[name] = \'teen\' elif age >= 20: category_dict[name] = \'adult\' return category_dict"},{"question":"Calculate the Euclidean distance in a multi-dimensional space. This function accepts two numpy arrays representing points in a multidimensional space. The input arrays should have the same dimensions. The function calculates the Euclidean distance between the two points and returns the result. The function should raise an exception for: ValueError: If the input arrays do not have the same dimensions. The function should output with: float: The Euclidean distance between the given points in the multidimensional space. You should write self-contained code starting with: ``` import numpy as np def calculate_euclidean_distance(point_a, point_b): ```","solution":"import numpy as np def calculate_euclidean_distance(point_a, point_b): Calculates the Euclidean distance between two points in a multi-dimensional space. Parameters: point_a (np.ndarray): Numpy array representing the coordinates of the first point. point_b (np.ndarray): Numpy array representing the coordinates of the second point. Returns: float: The Euclidean distance between the two points. Raises: ValueError: If the input arrays do not have the same dimensions. if point_a.shape != point_b.shape: raise ValueError(\\"Input arrays must have the same dimensions\\") return np.linalg.norm(point_a - point_b)"},{"question":"You are given a CSV file (`city_temperatures.csv`) containing daily temperature data for multiple cities. The file has three columns - `city`, `date`, and `temperature`. Your task is to implement a function called `average_temperature` that takes a city name as a string input and returns the average temperature for that city, rounded to two decimal places. Here\'s what you need to do: 1. Load the data using the `pandas.read_csv` function. 2. Filter the data to obtain temperatures for the specified city. 3. Calculate the average temperature for the filtered data. 4. Return the average temperature rounded to two decimal places. ```python import pandas as pd def average_temperature(city): # Your implementation here return avg_temp ``` *Function Signature:* ```python def average_temperature(city: str) -> float: ... ``` *Input:* - `city`: A string representing the name of the city. *Output:* - A float representing the average temperature for the city, rounded to two decimal places. Please make sure to use the `pandas` library for loading and manipulating the data.","solution":"import pandas as pd def average_temperature(city: str) -> float: # Load the data from the CSV file df = pd.read_csv(\'city_temperatures.csv\') # Filter the dataframe to get data for the specified city city_data = df[df[\'city\'] == city] # Calculate the average temperature for the filtered data avg_temp = city_data[\'temperature\'].mean() # Return the average temperature rounded to two decimal places return round(avg_temp, 2)"},{"question":"You are asked to write a function `evaluate_expression(s: str) -> int` that takes a string representing a mathematical expression as input and returns its evaluation as an integer. The expression can include the four basic arithmetic operations: addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). The input string may contain white spaces, which should be ignored during the evaluation. The function should follow the standard operator precedence rules: 1. Multiplication and division are performed before addition and subtraction. 2. Operators of the same precedence level are evaluated from left to right. You are not allowed to use any built-in functions that directly evaluate the expression (like `eval` or `ast.literal_eval`). Function Signature: ```python def evaluate_expression(s: str) -> int: ... ``` Example: ```python >>> evaluate_expression(\\" 3+2 * 2 \\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5 ``` # Requirements: 1. Process the expression string character by character. 2. Implement appropriate data structures (such as stacks) to manage intermediate results and operators. 3. Ensure correct handling of operator precedence and associativity.","solution":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression given in a string and returns the result as an integer. The expression may contain the operators: +, -, *, / and may contain whitespace. def operate(a, b, operator): if operator == \'+\': return a + b elif operator == \'-\': return a - b elif operator == \'*\': return a * b elif operator == \'/\': return int(a / b) # integer division # Remove white spaces s = s.replace(\' \', \'\') # Stacks to hold numbers and operators num_stack = [] op_stack = [] i = 0 n = len(s) while i < n: if s[i].isdigit(): num = 0 while i < n and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 num_stack.append(num) else: while op_stack and (op_stack[-1] in \\"*/\\" or (op_stack[-1] in \\"+-\\" and s[i] in \\"+-\\")): num2 = num_stack.pop() num1 = num_stack.pop() op = op_stack.pop() num_stack.append(operate(num1, num2, op)) op_stack.append(s[i]) i += 1 while op_stack: num2 = num_stack.pop() num1 = num_stack.pop() op = op_stack.pop() num_stack.append(operate(num1, num2, op)) return num_stack[0]"},{"question":"You work for a meal delivery service where customers can create meal plans and can select dishes from various menus. Each menu contains different dishes with associated prices. Your task is to create a function that calculates the total cost of a meal plan based on the menus provided by the customer. The function should create a summary of the total cost and the detailed breakdown of dishes ordered from each menu. # Function Signature: ```python def calculate_meal_plan_cost(meal_plan: dict) -> tuple: ``` # Parameters: - `meal_plan` (dict): A dictionary where keys are menu names (strings), and values are lists of tuples. Each tuple contains a dish name (str) and its price (float). # Returns: - `tuple`: A tuple containing two elements: - `total_cost` (float): Total cost of all dishes in the meal plan. - `details` (dict): A dictionary with menu names as keys and lists of tuples as values. Each tuple consists of a dish name and its price. # Instructions: 1. Iterate through the `meal_plan` dictionary. 2. For each menu, sum the prices of the dishes. 3. Accumulate the total cost of all dishes across all menus. 4. Create a details dictionary that mirrors `meal_plan` but is formatted for human-readable output. # Example Usage: ```python meal_plan = { \'breakfast\': [(\'pancakes\', 5.00), (\'coffee\', 2.50)], \'lunch\': [(\'burger\', 8.50), (\'fries\', 3.00), (\'soda\', 1.50)], \'dinner\': [(\'salad\', 7.00), (\'steak\', 12.00), (\'wine\', 6.50)] } total_cost, details = calculate_meal_plan_cost(meal_plan) print(f\\"Total Cost: {total_cost}\\") print(f\\"Details: {details}\\") ``` # Example Output: ``` Total Cost: 45.00 Details: { \'breakfast\': [(\'pancakes\', 5.00), (\'coffee\', 2.50)], \'lunch\': [(\'burger\', 8.50), (\'fries\', 3.00), (\'soda\', 1.50)], \'dinner\': [(\'salad\', 7.00), (\'steak\', 12.00), (\'wine\', 6.50)] } ``` # Note: - You can assume the structure of `meal_plan` will always follow the described format. - Make sure to handle cases where the meal plan might be empty (without any menus or dishes). **Hint:** Use dictionary and list comprehensions to make your function more concise and readable.","solution":"def calculate_meal_plan_cost(meal_plan: dict) -> tuple: Calculate the total cost of a meal plan and provide a detailed breakdown. Parameters: - meal_plan (dict): A dictionary where keys are menu names (strings), and values are lists of tuples. Each tuple contains a dish name (str) and its price (float). Returns: - tuple: A tuple containing two elements: - total_cost (float): Total cost of all dishes in the meal plan. - details (dict): A dictionary with menu names as keys and lists of tuples as values. Each tuple consists of a dish name and its price. total_cost = 0.0 details = {} for menu, dishes in meal_plan.items(): for dish, price in dishes: total_cost += price details[menu] = dishes return total_cost, details"},{"question":"You are asked to write a function named `simulate_robot_walk` that will simulate the random walk of a robot on a 2D grid. The function should visualize the path of the robot using the `matplotlib.pyplot` library. The robot starts at the origin (0, 0) and takes a predefined number of steps, where each step is in one of the four cardinal directions (north, south, east, or west). Your function should accept the following parameters: - `steps` (int): The number of steps the robot will take. - `step_size` (int): The distance covered in each step. The robot\'s movements are defined as follows: - A north step adds `step_size` to the y-coordinate. - A south step subtracts `step_size` from the y-coordinate. - An east step adds `step_size` to the x-coordinate. - A west step subtracts `step_size` from the x-coordinate. The function should generate the robot\'s path and produce a plot visualizing this path, starting from the origin. Ensure to use the following `matplotlib.pyplot` functions: - `plot` - `xlabel` - `ylabel` - `title` The function signature should be: ```python def simulate_robot_walk(steps, step_size): ``` To illustrate: ```python import matplotlib.pyplot as plt import random def simulate_robot_walk(steps, step_size): x, y = 0, 0 x_coords = [x] y_coords = [y] for _ in range(steps): direction = random.choice([\'N\', \'S\', \'E\', \'W\']) if direction == \'N\': y += step_size elif direction == \'S\': y -= step_size elif direction == \'E\': x += step_size elif direction == \'W\': x -= step_size x_coords.append(x) y_coords.append(y) plt.plot(x_coords, y_coords, marker=\'o\') plt.xlabel(\'X Coordinate\') plt.ylabel(\'Y Coordinate\') plt.title(\'Robot Random Walk Simulation\') plt.show() # Example usage: steps = 100 step_size = 1 simulate_robot_walk(steps, step_size) ``` In the example usage, it should generate a plot showing the path of the robot as it randomly walks 100 steps on the 2D grid, starting from the origin.","solution":"import matplotlib.pyplot as plt import random def simulate_robot_walk(steps, step_size): Simulates a random walk of a robot on a 2D grid and visualizes the path. Parameters: steps (int): The number of steps the robot will take. step_size (int): The distance covered in each step. The function visualizes the robot\'s path using matplotlib. x, y = 0, 0 x_coords = [x] y_coords = [y] for _ in range(steps): direction = random.choice([\'N\', \'S\', \'E\', \'W\']) if direction == \'N\': y += step_size elif direction == \'S\': y -= step_size elif direction == \'E\': x += step_size elif direction == \'W\': x -= step_size x_coords.append(x) y_coords.append(y) plt.plot(x_coords, y_coords, marker=\'o\') plt.xlabel(\'X Coordinate\') plt.ylabel(\'Y Coordinate\') plt.title(\'Robot Random Walk Simulation\') plt.show()"},{"question":"You have been assigned to create a function `find_frequent_words` that identifies and returns the most frequently occurring words in a given text file. This exercise will help you practice file handling, string manipulation, and dictionary usage in Python. **Function Signature**: ```python def find_frequent_words(file_path: str, top_n: int) -> list: ``` **Parameters**: - `file_path` (str): The path to the text file that needs to be analyzed. - `top_n` (int): The number of top most frequent words to return. **Requirements**: 1. Read the contents of the specified text file. 2. Normalize the text by converting it to lowercase and removing punctuation. 3. Split the text into words and count the frequency of each word using a dictionary. 4. Identify the `top_n` most frequent words in the text. 5. Return the `top_n` words as a list of tuples, each containing the word and its frequency, sorted by frequency in descending order. If two words have the same frequency, they should be sorted alphabetically. **Constraints**: - Assume that the text file will contain only plain text and no special formatting. - You may use the `string` module for handling punctuation. **Example**: ```python # If the file content is: # \\"This is a test. This test is simple. Simple test works.\\" # Calling the function as: find_frequent_words(\\"path_to_file.txt\\", 2) # Should return: [(\'test\', 3), (\'is\', 2)] ```","solution":"import string def find_frequent_words(file_path: str, top_n: int) -> list: Identifies and returns the most frequently occurring words in a given text file. Parameters: file_path (str): The path to the text file that needs to be analyzed. top_n (int): The number of top most frequent words to return. Returns: list: A list of tuples containing the words and their frequencies, sorted by frequency. # Read the file content with open(file_path, \'r\') as file: text = file.read() # Normalize the text text = text.lower() text = text.translate(str.maketrans(\'\', \'\', string.punctuation)) # Split the text into words words = text.split() # Count the frequency of each word word_freq = {} for word in words: word_freq[word] = word_freq.get(word, 0) + 1 # Sort the words by frequency (descending) and alphabetically sorted_words = sorted(word_freq.items(), key=lambda x: (-x[1], x[0])) # Return the top_n words return sorted_words[:top_n]"},{"question":"You are tasked with creating a Python function `closest_sum_pairs` that finds all pairs of integers from two different lists whose sums are closest to a given target value. Your function should handle the following cases: 1. If either list is empty, the function should return an empty list. 2. The output should be a list of tuples, where each tuple contains one integer from each list and their sum is the closest to the target value. **Function signature:** ```python def closest_sum_pairs(list1: List[int], list2: List[int], target: int) -> List[Tuple[int, int]]: pass ``` **Examples:** ```python assert closest_sum_pairs([1, 3, 5, 7], [10, 20, 30, 40], 32) == [(1, 30), (3, 30)] assert closest_sum_pairs([1, 2, 3], [4, 5, 6], 10) == [(3, 6)] assert closest_sum_pairs([], [1, 2], 5) == [] assert closest_sum_pairs([1], [2], 3) == [(1, 2)] assert closest_sum_pairs([5, 5, 5], [5, 5, 5], 10) == [(5, 5), (5, 5), (5, 5)] ``` **Requirements:** - The solution should have a time complexity that ensures efficiency with reasonably large inputs. - The function should return all pairs with the closest sum to the target value, even if multiple pairs have the same closest sum. **Hints:** - Consider sorting one or both of the input lists to make the problem easier to solve with a two-pointer or binary search approach. - Carefully manage the use of min difference for finding the closest sum. By solving this problem, you will gain experience in working with Python lists, tuple handling, and the efficient searching of pairs to meet a target sum condition.","solution":"from typing import List, Tuple def closest_sum_pairs(list1: List[int], list2: List[int], target: int) -> List[Tuple[int, int]]: if not list1 or not list2: return [] list1.sort() list2.sort() closest_pairs = [] closest_diff = float(\'inf\') i, j = 0, len(list2) - 1 while i < len(list1) and j >= 0: sum_pair = list1[i] + list2[j] diff = abs(sum_pair - target) if diff < closest_diff: closest_diff = diff closest_pairs = [(list1[i], list2[j])] elif diff == closest_diff: closest_pairs.append((list1[i], list2[j])) if sum_pair < target: i += 1 else: j -= 1 return closest_pairs"},{"question":"Write a function `student_grade_statistics(grades, student_names, include_pass, title_str)` that generates a bar chart representing the average grades of students and optionally highlights the pass or fail status with different colors. # Function Signature ```python def student_grade_statistics(grades, student_names, include_pass, title_str): ``` # Parameters 1. `grades` (ndarray): A 2D NumPy array where each row represents the grades of a student across different subjects. 2. `student_names` (list of str): A list of student names corresponding to the rows of `grades`. 3. `include_pass` (bool): A boolean indicating if the bar should be colored differently for passing and failing students. A student is considered to pass if their average grade is 50 or higher. 4. `title_str` (str): The title of the bar chart. # Requirements 1. Calculate the average grade for each student using `numpy.mean`. 2. Generate a bar chart using `matplotlib` with each bar representing a student and labeled according to the student names. 3. If `include_pass` is `True`, color the bars representing passing students (average grade >= 50) in green and failing students in red. Otherwise, use a default color. 4. Set the title of the bar chart using `matplotlib.pyplot.title`. 5. Label the y-axis with \\"Average Grade\\" and the x-axis with \\"Students\\". 6. Display the created bar chart. # Example If `grades = np.array([[40, 50, 60], [70, 80, 90], [45, 55, 65]])`, `student_names = [\'Alice\', \'Bob\', \'Charlie\']`, and `include_pass = True`, the function should calculate the average grades for \'Alice\', \'Bob\', and \'Charlie\', then display a bar chart with green bars for \'Bob\' (pass) and red bars for \'Alice\' and \'Charlie\' (fail). The chart\'s title will be given by `title_str`. # Note Use the `numpy` and `matplotlib` libraries to achieve the solution.","solution":"import numpy as np import matplotlib.pyplot as plt def student_grade_statistics(grades, student_names, include_pass, title_str): Generates a bar chart representing the average grades of students. Parameters: grades (ndarray): 2D NumPy array where each row represents grades of a student. student_names (list of str): List of student names. include_pass (bool): Whether to color bars based on pass or fail. title_str (str): Title of the bar chart. # Calculate the average grades averages = np.mean(grades, axis=1) # Determine bar colors if include_pass is True if include_pass: colors = [\'green\' if avg >= 50 else \'red\' for avg in averages] else: colors = \'blue\' # Generate the bar chart plt.figure(figsize=(10, 5)) plt.bar(student_names, averages, color=colors) plt.xlabel(\'Students\') plt.ylabel(\'Average Grade\') plt.title(title_str) plt.show()"},{"question":"You are tasked with implementing a function that computes the shortest path in a directed graph using Dijkstra\'s algorithm. The graph is represented using an adjacency matrix where each element [i][j] represents the weight of the edge from node `i` to node `j`. A value of `0` means there is no edge between the nodes. The function `dijkstra` should find the shortest paths from a given source node to all other nodes in the graph. # Function Signature ```python def dijkstra(graph: List[List[int]], start: int) -> List[float]: pass ``` # Input - `graph`: A 2D list where `graph[i][j]` represents the weight of the edge from node `i` to node `j`. If there is no edge, `graph[i][j]` is `0`. - `start`: An integer representing the starting node (source) for Dijkstra\'s algorithm. # Output - A list of floats where the `i`-th element represents the shortest distance from the `start` node to the `i`-th node. # Requirements 1. Utilize the list and heapq modules from Python\'s standard library. 2. Initialize a distance list with `float(\'inf\')` values except the start node which should be `0`. 3. Use a priority queue to determine the next node to process. # Constraints - Assume all edge weights are non-negative. - The graph will have at least one node and at most 100 nodes. # Instructions 1. Initialize a priority queue with the starting node and its distance (0). 2. While the priority queue is not empty: - Extract the node with the smallest distance. - For each neighbor of this node, if the distance to the neighbor can be minimized, update its distance and push the neighbor and its updated distance into the priority queue. 3. Return the list of shortest distances. # Example Usage ```python import heapq def dijkstra(graph, start): n = len(graph) distances = [float(\'inf\')] * n distances[start] = 0 pq = [(0, start)] # priority queue of (distance, node) while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in enumerate(graph[current_node]): if weight > 0: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances # Example graph represented as an adjacency matrix graph = [ [0, 10, 20, 0], [10, 0, 0, 50], [20, 0, 0, 20], [0, 50, 20, 0] ] start_node = 0 print(\\"Shortest distances from node\\", start_node, \\":\\", dijkstra(graph, start_node)) ``` # Ensure all required modules are properly imported and utilized within your implementation.","solution":"import heapq from typing import List def dijkstra(graph: List[List[int]], start: int) -> List[float]: n = len(graph) distances = [float(\'inf\')] * n distances[start] = 0 pq = [(0, start)] # priority queue of (distance, node) while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in enumerate(graph[current_node]): if weight > 0: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"Your task is to write a function named `generate_triangle_pattern` that outputs an inverted right-angled triangle pattern of asterisks based on a specified height. The function should: - Take one parameter, `height`, which represents the number of rows in the triangle. - Print an inverted right-angled triangle where the number of asterisks in the first row is equal to the `height`, and the number decreases by one in each subsequent row until it reaches one asterisk in the last row. The function signature should be: ```python def generate_triangle_pattern(height: int): ``` # Example Usage ```python generate_triangle_pattern(5) ``` This would output: ``` ***** **** *** ** * ``` # Constraints - The height should be a positive integer (1  height  50). - The pattern should be printed directly from the function, not returned. - Handle the edge cases where the height is at its minimum and maximum values.","solution":"def generate_triangle_pattern(height: int): Prints an inverted right-angled triangle pattern of asterisks. Parameters: height (int): Number of rows in the triangle. if not (1 <= height <= 50): raise ValueError(\\"Height should be a positive integer between 1 and 50.\\") for row in range(height, 0, -1): print(\'*\' * row)"},{"question":"Implement a function named `find_longest_unique_substring` that finds and returns the longest substring with all unique characters from a given string. If there are multiple substrings of the same maximum length, return the first one found. This function should take in a single parameter: 1. `input_string` (a string) which is the string to process. The function should efficiently handle the string and ensure optimal performance with respect to time complexity. **Function Signature:** ```python def find_longest_unique_substring(input_string: str) -> str: pass ``` **Requirements:** - Utilize a sliding window technique to traverse the string. - Use a hash set to keep track of unique characters within the current window. - Update the longest unique substring when a longer one is found. - Return the first longest unique substring from the input string.","solution":"def find_longest_unique_substring(input_string: str) -> str: Finds the longest substring with all unique characters. Parameters: input_string (str): The string to process. Returns: str: The longest substring with all unique characters. n = len(input_string) if n == 0: return \\"\\" # Initialize pointers for the sliding window start = 0 end = 0 # Hash set to store unique characters unique_chars = set() # Variables to remember the longest substring max_length = 0 max_start = 0 while end < n: if input_string[end] not in unique_chars: # Add the character to the set and move the end pointer unique_chars.add(input_string[end]) end += 1 # Update the maximum length and starting position if end - start > max_length: max_length = end - start max_start = start else: # Remove the character from the set and move the start pointer unique_chars.remove(input_string[start]) start += 1 return input_string[max_start:max_start + max_length]"},{"question":"You are given a dataset containing information about various books available in a library. The goal is to create a search function that filters books based on multiple criteria and returns the relevant results in a structured format. The dataset is represented as a dictionary where each key is an ISBN number corresponding to a book, and the value is another dictionary containing the book\'s details. The dataset has the following structure: ```python books_data = { \\"978-3-16-148410-0\\": { \\"title\\": \\"Book Title 1\\", \\"author\\": \\"Author 1\\", \\"genre\\": \\"Genre 1\\", \\"year\\": 2000, \\"available\\": True }, \\"978-1-4028-9462-6\\": { \\"title\\": \\"Book Title 2\\", \\"author\\": \\"Author 2\\", \\"genre\\": \\"Genre 2\\", \\"year\\": 2010, \\"available\\": False }, # ... more books } ``` You need to write a function named `search_books` that accepts five parameters: - `books` (a dictionary): The dictionary containing the book data as described. - `author` (str, optional): An optional author\'s name to filter the books by author. - `genre` (str, optional): An optional genre to filter the books by genre. - `year_range` (tuple of two ints, optional): An optional tuple specifying the start and end years (inclusive) to filter the books by publication year. - `available` (bool, optional): An optional boolean to filter the books by their availability status. The function should return a list of dictionaries, each containing the details of a book that matches the criteria. The search should be case-insensitive for the `author` and `genre` filters. Here is the signature of the function: ```python def search_books(books, author=None, genre=None, year_range=None, available=None): # Implementation here ``` **Example Usage:** ```python search_books(books_data, author=\\"Author 1\\", genre=\\"Genre 1\\", year_range=(1995, 2005), available=True) ``` **Requirements:** 1. Filter by `author` if provided (case-insensitive). 2. Filter by `genre` if provided (case-insensitive). 3. Filter by `year_range` if provided. Both start and end years are inclusive. 4. Filter by `available` status if provided. **Assumptions:** 1. If no filters are provided, return all books in the dataset. 2. If multiple filters are provided, combine the filters to match the books that satisfy all criteria.","solution":"def search_books(books, author=None, genre=None, year_range=None, available=None): Search and filter the books dictionary based on given criteria. :param books: dictionary containing book data :param author: (optional) string to filter by author\'s name :param genre: (optional) string to filter by genre :param year_range: (optional) tuple of two integers to filter by publication year :param available: (optional) boolean to filter by availability status :return: list of dictionaries containing book details that match the criteria results = [] for isbn, book in books.items(): # Check author filter (case-insensitive) if author and author.lower() not in book[\'author\'].lower(): continue # Check genre filter (case-insensitive) if genre and genre.lower() not in book[\'genre\'].lower(): continue # Check year_range filter if year_range: start_year, end_year = year_range if not (start_year <= book[\'year\'] <= end_year): continue # Check available filter if available is not None and book[\'available\'] != available: continue # If all conditions are met, add the book to results results.append(book) return results"},{"question":"Simulate a DataFrame that represents hourly humidity readings for a specified date range and city. The humidity readings are randomly generated within a specified min and max range. Calculate the mean humidity for each day and add a column \'Mean Humidity\' to the DataFrame. Additionally, generate a bar plot to visualize the mean humidity for each day over the date range. The plot should include labeled axes (\'Date\' and \'Mean Humidity\'), a title (\'Daily Mean Humidity\'), and a legend (\'Mean Humidity\'). The function should output: 1. pd.DataFrame: A DataFrame with columns \'Date\', \'Hour\', \'Humidity\', and \'Mean Humidity\' 2. matplotlib.axes.Axes: The Axes object of the generated plot You should write self-contained code starting with: ``` import pandas as pd import datetime import random import matplotlib.pyplot as plt def task_func(start_date, end_date, city, min_humidity, max_humidity, seed=None): ```","solution":"import pandas as pd import datetime import random import matplotlib.pyplot as plt def task_func(start_date, end_date, city, min_humidity, max_humidity, seed=None): if seed is not None: random.seed(seed) date_range = pd.date_range(start=start_date, end=end_date, freq=\'H\') humidity_data = { \'Date\': [], \'Hour\': [], \'Humidity\': [] } for date in date_range: humidity_data[\'Date\'].append(date.date()) humidity_data[\'Hour\'].append(date.hour) humidity_data[\'Humidity\'].append(random.randint(min_humidity, max_humidity)) df = pd.DataFrame(humidity_data) mean_humidity_daily = df.groupby(\'Date\')[\'Humidity\'].mean().reset_index() mean_humidity_daily.columns = [\'Date\', \'Mean Humidity\'] df = df.merge(mean_humidity_daily, on=\'Date\') plt.figure(figsize=(10, 5)) ax = plt.gca() mean_humidity_daily.plot(kind=\'bar\', x=\'Date\', y=\'Mean Humidity\', ax=ax) ax.set_xlabel(\'Date\') ax.set_ylabel(\'Mean Humidity\') ax.set_title(\'Daily Mean Humidity\') ax.legend([\'Mean Humidity\']) plt.xticks(rotation=45) plt.tight_layout() return df, ax"},{"question":"Calculate the shortest path in a grid with obstacles. Given a grid represented as a list of lists of integers, where 0 signifies an empty cell and 1 signifies an obstacle, find the shortest path from the top-left corner to the bottom-right corner of the grid. If no such path exists, return -1. The function should use the Breadth-First Search algorithm for finding the shortest path. Ensure to handle edge cases such as grids with only obstacles or empty grids. The function should output with: int: The length of the shortest path or -1 if no path exists. You should write self-contained code starting with: ``` from collections import deque def task_func(grid): # Ensure the grid is not empty if not grid or not grid[0]: return -1 # Initialize parameters rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 # Directions for moving up, down, left, right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Breadth-First Search (BFS) initialization queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # Check if reached the bottom-right corner if (r, c) == (rows-1, cols-1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1 ```","solution":"from collections import deque def task_func(grid): Function to find the shortest path in a grid with obstacles using BFS. Parameters: grid (list of list of int): 2D grid where 0 is an empty cell and 1 is an obstacle. Returns: int: Length of the shortest path from top-left to bottom-right, or -1 if no path. # Ensure the grid is not empty if not grid or not grid[0]: return -1 # Initialize parameters rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 # Directions for moving up, down, left, right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Breadth-First Search (BFS) initialization queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # Check if reached the bottom-right corner if (r, c) == (rows-1, cols-1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are required to implement a function `rotate_matrix_90_degrees` that rotates an NxN matrix by 90 degrees in a clockwise direction. The input is a list of lists representing the matrix, and you need to return a new matrix that is the result of the rotation. # Constraints: 1. The input matrix will always be a square matrix (NxN). 2. You may not use any in-built Python functions that manipulate matrices, such as `zip` or similar. 3. Your solution should handle matrices of various sizes, including edge cases such as 1x1 matrices. # Example: ``` Input: [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Requirements: 1. Define the function `rotate_matrix_90_degrees` which accepts one parameter: the matrix to rotate. 2. The function should return a new matrix that is rotated 90 degrees in a clockwise direction. 3. Do not modify the input matrix directly. # Function Signature: ```python def rotate_matrix_90_degrees(matrix: list[list[int]]) -> list[list[int]]: # Your code here ```","solution":"def rotate_matrix_90_degrees(matrix): Rotates an NxN matrix by 90 degrees clockwise. :param matrix: List of lists representing the NxN matrix. :return: A new matrix that is rotated 90 degrees clockwise. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"You are tasked with writing a function `invert_case` that takes in one parameter: - `text` (a string containing multiple words) The function should return a new string where the case of each letter in the input string is inverted (uppercase letters become lowercase and vice versa). Non-alphabet characters should remain unchanged. # Function Signature: ```python def invert_case(text: str) -> str: ``` # Requirements: 1. Implement the function `invert_case` as described. 2. Use string methods to handle case conversion. 3. Preserve the order of characters in the original string. 4. Ensure that non-alphabet characters remain the same. # Example: ```python print(invert_case(\\"Hello World!\\")) # The output should be \\"hELLO wORLD!\\" print(invert_case(\\"Python3.8\\")) # The output should be \\"pYTHON3.8\\" ``` # Constraints: 1. The input `text` will be a non-empty string. 2. The length of `text` will not exceed 1000 characters. This problem will help you practice and understand string manipulation and character case conversion in Python.","solution":"def invert_case(text: str) -> str: Inverts the case of each letter in the input string. Parameters: text (str): The input string containing multiple words. Returns: str: A new string with the case of each letter inverted. return text.swapcase()"},{"question":"**K-Nearest Neighbors Classifier** Write a Python function called `knn_classifier` that implements a basic K-Nearest Neighbors (KNN) algorithm from scratch. The function should take three arguments: `train_data`, `test_data`, and `k`, where `train_data` is a list of tuples representing the training dataset (with features and label), `test_data` is a list of tuples representing the test dataset (with features), and `k` is the number of nearest neighbors to consider. **Function Definition:** ```python def knn_classifier(train_data, test_data, k): ``` **Function Steps:** 1. Define a helper function to calculate the Euclidean distance between two points. 2. For each point in the `test_data`, do the following: - Calculate the distance to every point in the `train_data`. - Sort these distances and select the `k` smallest distances. - Identify the labels of the `k` nearest neighbors. - Determine the most common label among the nearest neighbors (use majority voting). 3. Return a list of predicted labels corresponding to the `test_data`. **Example:** ```python train_data = [([2.1, 3.2], \'A\'), ([1.3, 3.1], \'B\'), ([4.1, 2.2], \'A\'), ([5.1, 6.2], \'B\')] test_data = [[3.0, 3.0], [4.0, 4.0]] k = 3 predicted_labels = knn_classifier(train_data, test_data, k) print(predicted_labels) ``` Assuming the above example, the function would output: ```python [\'A\', \'A\'] ``` **Note:** For simplicity, assume all features are numeric and there are no missing values in the dataset.","solution":"from collections import Counter import math def knn_classifier(train_data, test_data, k): def euclidean_distance(point1, point2): return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def get_neighbors(train_data, test_point, k): distances = [] for features, label in train_data: distance = euclidean_distance(features, test_point) distances.append((distance, label)) distances.sort(key=lambda x: x[0]) return distances[:k] def get_majority_label(neighbors): labels = [label for _, label in neighbors] most_common = Counter(labels).most_common(1) return most_common[0][0] predicted_labels = [] for test_point in test_data: neighbors = get_neighbors(train_data, test_point, k) majority_label = get_majority_label(neighbors) predicted_labels.append(majority_label) return predicted_labels"},{"question":"Given a list of integers, write a Python function to find all unique combinations in the list where the sum of the integers in each combination is equal to a target value. The function should return a list of lists, where each inner list is a unique combination. The function you need to implement is `find_combinations(numbers, target)`. The parameters are described as follows: - **`numbers`** (list of int): A list of integers wherein some integers might be repeated. - **`target`** (int): The target sum for each combination. Requirements: 1. Each combination should be unique (no permutation of the same combination should be included). 2. The numbers in the combinations can be used multiple times. 3. The order of combinations in the output does not matter. An example function signature is provided below: ```python def find_combinations(numbers, target): pass ``` Example: ```python numbers = [2, 3, 6, 7] target = 7 find_combinations(numbers, target) # Output: [[2, 2, 3], [7]] numbers = [2, 3, 5] target = 8 find_combinations(numbers, target) # Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] ```","solution":"def find_combinations(numbers, target): Finds all unique combinations in the list where the sum of the integers in each combination is equal to the target value. Args: numbers (list of int): The list of integers. target (int): The target sum for each combination. Returns: list of lists: A list containing unique combinations that sum to the target. def backtrack(start, target, path, result): if target == 0: result.append(list(path)) return if target < 0: return for i in range(start, len(numbers)): path.append(numbers[i]) backtrack(i, target - numbers[i], path, result) path.pop() result = [] numbers.sort() backtrack(0, target, [], result) return result"},{"question":"Given a collection of user data that includes names, phone numbers, and email addresses, you need to create a system to format and validate this data based on certain rules. Write a function `format_and_validate_user_data` that accepts a list of dictionaries where each dictionary contains a `name`, `phone`, and `email`, and processes the data according to the rules specified below. Data Details - The input data is a list of dictionaries with each dictionary representing a user. - Each dictionary has the keys: `name`, `phone`, and `email`. Example input: ```python user_data = [ {\'name\': \'John Doe\', \'phone\': \'123-456-7890\', \'email\': \'john.doe@example.com\'}, {\'name\': \'Jane Smith\', \'phone\': \'098-765-4321\', \'email\': \'jane.smith@example\'} ] ``` Function Signature ```python def format_and_validate_user_data(user_data: List[Dict[str, str]]) -> List[Dict[str, str]]: ``` Parameters 1. `user_data`: A list of dictionaries, where each dictionary contains three string keys: `name`, `phone`, and `email`. Returns - A list of dictionaries where each dictionary contains the formatted and validated data. The structure should match the input but with the applied formatting and validation. - If any phone number or email is invalid, it should replace the invalid value with \\"INVALID\\". Rules 1. **Name Formatting**: - Capitalize the first letter of each word in the name. 2. **Phone Number Validation**: - A valid phone number should match the format `XXX-XXX-XXXX` where `X` is a digit. - If the phone number is not in this format, replace it with \\"INVALID\\". 3. **Email Validation**: - An email is considered valid if it matches a basic pattern of `username@domain.extension`. - Check the presence of \\"@\\" and a \\".\\" after \\"@\\". - If the email is invalid, replace it with \\"INVALID\\". Example ```python formatted_data = format_and_validate_user_data([ {\'name\': \'alice WOnDERLand\', \'phone\': \'555-987-6543\', \'email\': \'alice@wonderland.com\'}, {\'name\': \'Peter Pan\', \'phone\': \'1234567890\', \'email\': \'peter@pan\'} ]) print(formatted_data) ``` Expected output: ```python [ {\'name\': \'Alice Wonderland\', \'phone\': \'555-987-6543\', \'email\': \'alice@wonderland.com\'}, {\'name\': \'Peter Pan\', \'phone\': \'INVALID\', \'email\': \'INVALID\'} ] ``` Your task is to implement the function `format_and_validate_user_data` using the built-in Python string and regex libraries.","solution":"import re from typing import List, Dict def format_and_validate_user_data(user_data: List[Dict[str, str]]) -> List[Dict[str, str]]: def is_valid_phone(phone: str) -> bool: return bool(re.match(r\'^d{3}-d{3}-d{4}\', phone)) def is_valid_email(email: str) -> bool: return bool(re.match(r\'^[^@]+@[^@]+.[^@]+\', email)) formatted_data = [] for user in user_data: formatted_user = {} formatted_user[\'name\'] = \' \'.join(word.capitalize() for word in user[\'name\'].split()) if is_valid_phone(user[\'phone\']): formatted_user[\'phone\'] = user[\'phone\'] else: formatted_user[\'phone\'] = \'INVALID\' if is_valid_email(user[\'email\']): formatted_user[\'email\'] = user[\'email\'] else: formatted_user[\'email\'] = \'INVALID\' formatted_data.append(formatted_user) return formatted_data"},{"question":"You have been provided with several JSON files, each containing detailed weather data for various cities over different periods. Each JSON file corresponds to data for a specific week and includes fields such as \\"City\\" and \\"Temperature\\". Your task is to write a function called `aggregate_weather_data` that consolidates the temperature data for New York and Los Angeles across the weeks given into a single pandas DataFrame. Your function should: 1. Accept a list of file paths as input, one for each week. 2. Read and filter the data to include only entries where the \\"City\\" is either \\"New York\\" or \\"Los Angeles\\". 3. Add a column named \\"Week\\" to each DataFrame to include the corresponding week of data. 4. Combine all these DataFrames into a single DataFrame. 5. Set the \\"Week\\" column as the index of the DataFrame. 6. Ensure the final DataFrame only contains the \\"City\\" and \\"Temperature\\" columns. **Function Signature:** ```python def aggregate_weather_data(files: List[str]) -> pd.DataFrame: ``` **Input:** - `files`: A list of strings where each string is a file path to a JSON file containing weather data. **Output:** - A consolidated DataFrame with the \\"Week\\" column set as the index and only including \\"City\\" and \\"Temperature\\" columns. **Example:** Suppose you have JSON files for different weeks stored in the following paths: - `week1.json` - `week2.json` - `week3.json` Each JSON file has the following structure: ```json [ {\\"City\\": \\"New York\\", \\"Temperature\\": 22.5, \\"Other Field\\": \\"value1\\"}, {\\"City\\": \\"Los Angeles\\", \\"Temperature\\": 25.3, \\"Other Field\\": \\"value2\\"}, ... ] ``` You should be able to call your function as follows: ```python files = [\\"week1.json\\", \\"week2.json\\", \\"week3.json\\"] result_df = aggregate_weather_data(files) print(result_df) ``` And the output should be a consolidated DataFrame with a structure similar to: ``` City Temperature Week week1 New York 22.5 week1 Los Angeles 25.3 ... ``` *Note:* Use the `pandas` library for reading and manipulating the DataFrames.","solution":"import pandas as pd from typing import List def aggregate_weather_data(files: List[str]) -> pd.DataFrame: dataframes = [] for i, file in enumerate(files): df = pd.read_json(file) # Filter for New York and Los Angeles df = df[df[\'City\'].isin([\'New York\', \'Los Angeles\'])] # Add Week column df[\'Week\'] = f\'week{i+1}\' dataframes.append(df) # Concatenate all dataframes consolidated_df = pd.concat(dataframes) # Set Week as the index consolidated_df.set_index(\'Week\', inplace=True) # Select only the required columns consolidated_df = consolidated_df[[\'City\', \'Temperature\']] return consolidated_df"},{"question":"**Problem Title: Implement a Dynamic Line Chart Using Matplotlib and Pandas** **Objective:** You are required to implement a function called `plot_dynamic_line_chart` that generates a dynamic line chart from a given Pandas DataFrame. This chart should display the evolution of several time series and allow for interactive exploration of individual series. Utilize `matplotlib` and `pandas` libraries to accomplish this task. **Function Signature:** ```python def plot_dynamic_line_chart(data: pd.DataFrame, title: str = \\"Dynamic Line Chart\\", xlabel: str = \\"X-axis\\", ylabel: str = \\"Y-axis\\") -> None: pass ``` **Input:** - `data`: A Pandas DataFrame where each column represents a different time series and rows represent sequential data points (e.g., time steps). - `title`: (Optional) A string title for the chart. - `xlabel`: (Optional) A string label for the x-axis. - `ylabel`: (Optional) A string label for the y-axis. **Output:** - The function should display an interactive matplotlib plot of the line chart. **Detailed Requirements:** 1. **Functionality**: Implement the `plot_dynamic_line_chart` function to plot multiple time series in a single chart. 2. **Interactivity**: Add interactive elements where: - Users can select which series to display/hide using a legend or checkbox. - The chart updates dynamically based on these user selections. 3. **Chart Elements**: - The x-axis should reflect the index of the DataFrame. - Each column in the DataFrame corresponds to a unique line in the chart. - The chart should have a title, and labeled x-axis and y-axis using the provided optional parameters. 4. **Library API**: - Use `matplotlib.pyplot.plot` for plotting the series. - Use `matplotlib.pyplot.gcf` to get the current figure, and `fig.canvas.mpl_connect` for interactive events. - Implement the interactive functionality using the `CheckButtons` widget from `matplotlib.widgets`. **Example:** ```python import pandas as pd import matplotlib.pyplot as plt from matplotlib.widgets import CheckButtons # Example DataFrame data = pd.DataFrame({ \'Series1\': [1, 3, 2, 4], \'Series2\': [4, 2, 5, 6], \'Series3\': [7, 8, 5, 3] }) def plot_dynamic_line_chart(data: pd.DataFrame, title: str = \\"Dynamic Line Chart\\", xlabel: str = \\"X-axis\\", ylabel: str = \\"Y-axis\\") -> None: fig, ax = plt.subplots() lines = [] visibility = [True] * data.shape[1] # default visibility is all lines visible for col in data.columns: line, = ax.plot(data.index, data[col], label=col) lines.append(line) ax.set_title(title) ax.set_xlabel(xlabel) ax.set_ylabel(ylabel) plt.subplots_adjust(left=0.2) # make space for CheckButtons # CheckButtons to toggle visibility of lines rax = plt.axes([0.05, 0.4, 0.1, 0.2]) # [left, bottom, width, height] labels = data.columns check = CheckButtons(rax, labels, visibility) def toggle_visibility(label: str): idx = list(labels).index(label) lines[idx].set_visible(not lines[idx].get_visible()) plt.draw() check.on_clicked(toggle_visibility) plt.legend() plt.show() # Calling the function plot_dynamic_line_chart(data) ``` **Note:** - Ensure compatibility with various DataFrame shapes and handle labels dynamically. - Use `matplotlib` effectively to support interactivity and dynamic updates.","solution":"import pandas as pd import matplotlib.pyplot as plt from matplotlib.widgets import CheckButtons def plot_dynamic_line_chart(data: pd.DataFrame, title: str = \\"Dynamic Line Chart\\", xlabel: str = \\"X-axis\\", ylabel: str = \\"Y-axis\\") -> None: Generates a dynamic line chart from a given Pandas DataFrame. Args: - data (pd.DataFrame): DataFrame with each column representing a time series. - title (str): Title of the chart. - xlabel (str): Label for the x-axis. - ylabel (str): Label for the y-axis. Displays interactive matplotlib plot. fig, ax = plt.subplots() lines = [] visibility = [True] * data.shape[1] # default visibility is all lines visible for col in data.columns: line, = ax.plot(data.index, data[col], label=col) lines.append(line) ax.set_title(title) ax.set_xlabel(xlabel) ax.set_ylabel(ylabel) plt.subplots_adjust(left=0.2) # make space for CheckButtons # CheckButtons to toggle visibility of lines rax = plt.axes([0.05, 0.4, 0.1, 0.2]) # [left, bottom, width, height] labels = data.columns check = CheckButtons(rax, labels, visibility) def toggle_visibility(label: str): idx = list(labels).index(label) lines[idx].set_visible(not lines[idx].get_visible()) plt.draw() check.on_clicked(toggle_visibility) plt.legend() plt.show()"},{"question":"You are tasked with implementing a function `find_closest_elements` that takes an array of sorted integers, a target integer, and a number `k`. The function should return the `k` integers in the array that are closest to the target integer. If there is a tie (i.e., two numbers are equally close to the target), the smaller number should be preferred. The order of the `k` integers in the output list should be the same as the order they appear in the input array. You need to implement this function using Python standard libraries only. The function should closely follow the following signature and requirements: ```python def find_closest_elements(arr: List[int], target: int, k: int) -> List[int]: Find the k closest integers to the target in a sorted array. Parameters: arr (List[int]): A list of sorted integers target (int): The target integer k (int): The number of closest integers to find Returns: List[int]: A list of k closest integers to the target pass ``` # Input Description - `arr` (List[int]): A list of sorted integers with length `n` where `1 <= n <= 10^4` and all elements are unique. - `target` (int): An integer representing the target value. - `k` (int): An integer representing the number of closest integers to find, where `1 <= k <= n`. # Output Description - Returns a list of `k` integers which are closest to the target integer. # Constraints - The input list `arr` is guaranteed to be sorted in ascending order. - If two numbers are equally close to the target, the smaller number is preferred. - The output list should maintain the same order as they appear in the input array. # Example Given: ```python arr = [1, 2, 3, 4, 5] target = 3 k = 4 find_closest_elements(arr, target, k) ``` The function should return `[1, 2, 3, 4]`. Given: ```python arr = [1, 2, 3, 4, 5] target = -1 k = 2 find_closest_elements(arr, target, k) ``` The function should return `[1, 2]`.","solution":"from typing import List def find_closest_elements(arr: List[int], target: int, k: int) -> List[int]: Find the k closest integers to the target in a sorted array. Parameters: arr (List[int]): A list of sorted integers target (int): The target integer k (int): The number of closest integers to find Returns: List[int]: A list of k closest integers to the target # Sort the array based on the difference with target, preferring smaller numbers in case of ties arr.sort(key=lambda x: (abs(x - target), x)) # Return the first k elements after sorting return sorted(arr[:k])"},{"question":"You are required to write a Python function named `prime_factors` that computes the prime factors of a given integer. The function should return a list containing the prime factors in ascending order. The function signature is as follows: ```python def prime_factors(n): n - an integer value to find prime factors for Function returns a list containing the prime factors of n in ascending order. ``` The function should: 1. Handle edge cases such as when `n` is less than 2 by returning an empty list. 2. Use efficient algorithms to determine the prime factors, such as trial division up to the square root of `n`. **Task:** - Implement the function `prime_factors` as described. - Ensure that your implementation is optimized for performance. **Example:** ```python # Example Usage n = 60 factors = prime_factors(n) print(factors) ``` Expected Output: ``` [2, 2, 3, 5] ``` Additional Example: ```python n = 97 factors = prime_factors(n) print(factors) ``` Expected Output: ``` [97] ```","solution":"def prime_factors(n): Returns a list containing the prime factors of n in ascending order. n - an integer value to find prime factors for if n < 2: return [] factors = [] divisor = 2 while n >= divisor * divisor: if n % divisor == 0: factors.append(divisor) n //= divisor else: divisor += 1 if n > 1: factors.append(n) return factors"},{"question":"You are tasked with writing a function that simulates the merging of intervals and then visualizes the resulting intervals as a horizontal bar chart. Each interval is defined by a start and end time. Your goal is to merge any overlapping intervals and then generate a bar chart image representing the merged intervals. **Requirements:** 1. Implement the function `merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]`, where: - `intervals` is a list of tuples where each tuple represents an interval with a start and end time. - The function should return a list of tuples representing the merged intervals. 2. Implement the function `visualize_intervals(intervals: List[Tuple[int, int]]) -> Image`, where: - `intervals` is a list of tuples representing the merged intervals. - The function should return a PIL Image object with a horizontal bar chart of the intervals using the `matplotlib` library. **Example:** ```python import matplotlib.pyplot as plt from PIL import Image import numpy as np intervals = [(1, 3), (2, 4), (5, 8), (7, 9)] def merge_intervals(intervals): intervals.sort(key=lambda x: x[0]) merged = [] for i in intervals: if merged and merged[-1][1] >= i[0]: merged[-1] = (merged[-1][0], max(merged[-1][1], i[1])) else: merged.append(i) return merged def visualize_intervals(intervals): fig, ax = plt.subplots() for i, (start, end) in enumerate(intervals): ax.broken_barh([(start, end - start)], (i - 0.4, 0.8)) ax.set_ylim(-1, len(intervals)) ax.set_xlim(0, max(end for start, end in intervals) + 1) ax.set_xlabel(\'Time\') ax.set_yticks([]) plt.tight_layout() # Convert Matplotlib figure to PIL Image fig.canvas.draw() image = Image.fromarray(np.array(fig.canvas.renderer._renderer)) plt.close(fig) return image merged = merge_intervals(intervals) result_image = visualize_intervals(merged) result_image.show() ``` **Hint**: Sorting intervals and overlapping merging can be done using a stacked approach, and convert the Matplotlib figure to a PIL Image using `Image.fromarray(np.array(fig.canvas.renderer._renderer))`.","solution":"from typing import List, Tuple import matplotlib.pyplot as plt from PIL import Image import numpy as np def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals. if not intervals: return [] # Sort intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If the list of merged intervals is empty or the current interval does not overlap with the previous, # append it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Otherwise, there is overlap, so we merge the current and previous intervals. merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged def visualize_intervals(intervals: List[Tuple[int, int]]) -> Image: Visualizes merged intervals as a horizontal bar chart image. fig, ax = plt.subplots() for i, (start, end) in enumerate(intervals): ax.broken_barh([(start, end - start)], (i - 0.4, 0.8), facecolors=\'blue\') ax.set_ylim(-1, len(intervals)) ax.set_xlim(0, max(end for start, end in intervals) + 1) ax.set_xlabel(\'Time\') ax.set_yticks([]) plt.tight_layout() # Convert Matplotlib figure to PIL Image fig.canvas.draw() image = Image.fromarray(np.array(fig.canvas.renderer._renderer)) plt.close(fig) return image"},{"question":"You are required to implement a function, `dice_coefficient`, that calculates the Dice Coefficient for two given binary images. The Dice Coefficient is a measure of similarity between two sets, and for binary images, it quantifies the overlap between the foreground of the images. The formula for the Dice Coefficient ( D ) between sets ( A ) and ( B ) is: [ D(A, B) = frac{2 times |A cap B|}{|A| + |B|} ] Where ( |A| ) is the number of foreground pixels (pixels with value 1) in image ( A ), and ( |A cap B| ) is the number of foreground pixels common to both images ( A ) and ( B ). Your task is to implement the following function: ```python import numpy as np def dice_coefficient(image1: np.ndarray, image2: np.ndarray) -> float: Calculate the Dice Coefficient for two binary images. Parameters: image1 (np.ndarray): First binary image as a numpy array. image2 (np.ndarray): Second binary image as a numpy array. Returns: float: The Dice Coefficient between the two images. # Your implementation here ``` # Constraints 1. `image1` and `image2` are binary images of the same size (same dimensions). 2. The images are represented as numpy arrays where the pixel values are either 0 or 1. # Examples 1. If `image1` is: ``` [[1, 0], [0, 1]] ``` And `image2` is: ``` [[1, 0], [1, 0]] ``` The Dice Coefficient is: ``` 0.5 ``` 2. If `image1` is: ``` [[1, 1], [0, 0]] ``` And `image2` is: ``` [[1, 1], [1, 0]] ``` The Dice Coefficient is: ``` 0.8 ```","solution":"import numpy as np def dice_coefficient(image1: np.ndarray, image2: np.ndarray) -> float: Calculate the Dice Coefficient for two binary images. Parameters: image1 (np.ndarray): First binary image as a numpy array. image2 (np.ndarray): Second binary image as a numpy array. Returns: float: The Dice Coefficient between the two images. if image1.shape != image2.shape: raise ValueError(\\"Both images must have the same dimensions\\") intersection = np.sum(image1 * image2) sum_image1 = np.sum(image1) sum_image2 = np.sum(image2) if sum_image1 + sum_image2 == 0: # Edge case: both images are empty return 1.0 if intersection == 0 else 0.0 dice = (2 * intersection) / (sum_image1 + sum_image2) return dice"},{"question":"Create a function to find the longest subarray with sum equal to a given target in an array of integers. Note that: The function should iterate through the array, using a hash map to store the cumulative sum at each index. If the difference between the current cumulative sum and the target has been seen before, it updates the maximum length of the subarray. The function should output: int: The length of the longest subarray that sums to the target. You should write self-contained code starting with: ``` def find_longest_subarray_with_sum(arr, target): ```","solution":"def find_longest_subarray_with_sum(arr, target): Finds the length of the longest subarray with sum equal to the given target. :param arr: List of integers :param target: Integer target sum :return: Integer length of the longest subarray sum_map = {} current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == target: max_length = i + 1 if (current_sum - target) in sum_map: max_length = max(max_length, i - sum_map[current_sum - target]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"You are required to write a function named `frequency_counter` which takes a list of strings and returns a dictionary where the keys are the unique strings from the input list, and the values are the counts of how often each string appears in the list. The primary goal of this task is to familiarize you with the following Python concepts: - Dictionary operations - Looping over lists - Conditional checks and updating dictionary values # Requirements: 1. **Create an empty dictionary** to store frequency counts. 2. **Iterate through each string** in the input list: - If the string is already a key in the dictionary, increment its value by 1. - Otherwise, add the string to the dictionary with a value of 1. 3. **Return the dictionary** containing the frequency counts of each string. # Function Signature: ```python def frequency_counter(strings): Returns a dictionary with the frequency of each unique string in the input list :param strings: list of strings to be counted :return: dictionary with string frequency counts ``` # Example: ```python input_strings = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] result = frequency_counter(input_strings) print(result) # Output: {\'apple\': 3, \'banana\': 2, \'orange\': 1} ``` In this example, the function should return a dictionary indicating that `apple` appears 3 times, `banana` appears 2 times, and `orange` appears 1 time in the input list.","solution":"def frequency_counter(strings): Returns a dictionary with the frequency of each unique string in the input list :param strings: list of strings to be counted :return: dictionary with string frequency counts frequency_dict = {} for string in strings: if string in frequency_dict: frequency_dict[string] += 1 else: frequency_dict[string] = 1 return frequency_dict"},{"question":"Write a function `generate_dynamic_function(base_constant)` that returns another function `dynamic_function(a, b)`. The function `dynamic_function(a, b)` should compute a specific mathematical operation involving logarithmic and power expressions based on the `base_constant`. Here are the steps to implement this: 1. Define an auxiliary function `aux_func`, which calculates: [ text{aux_func}(a, b) = frac{log(a)}{a^b + b^a} ] 2. Use the `aux_func` to define the final output of `dynamic_function`: [ text{dynamic_function}(a, b) = left(2 cdot text{base_constant}right) cdot left(1 + text{aux_func}(a, b)right) cdot (sin(a) + cos(b)) ] # Requirements: - Use `math.log`, `math.sin`, and `math.cos` appropriately in your calculations. - Return `dynamic_function` from `generate_dynamic_function`. # Example usage: ```python f = generate_dynamic_function(2.5) result = f(3, 4) ``` In the above example: - `f` is assigned to the resulting `dynamic_function(a, b)`. - `result` is the computed value when `a` is 3 and `b` is 4. # Note: - Assume `a` and `b` will always be positive numbers greater than 1 to avoid any mathematical inconsistencies. - Ensure to handle floating-point arithmetic accurately to avoid potential errors.","solution":"import math def generate_dynamic_function(base_constant): def aux_func(a, b): return math.log(a) / (a**b + b**a) def dynamic_function(a, b): return (2 * base_constant) * (1 + aux_func(a, b)) * (math.sin(a) + math.cos(b)) return dynamic_function"},{"question":"You are required to write a function `generate_composite_image` that creates a composite image by blending two given images using a specified alpha value. The resulting image should be saved to disk and displayed using the `PIL` (Python Imaging Library) package. The function should accept the paths to the two images and the alpha value as input parameters. The function should perform the following steps: 1. Open the two images using `PIL.Image.open`. 2. Ensure both images are of equal dimensions. If not, resize the second image to match the dimensions of the first image. 3. Blend the two images using the specified alpha value using `PIL.Image.blend`. 4. Save the resulting composite image to disk with the filename \\"composite_image.png\\". 5. Display the resulting composite image using `PIL.Image.show`. Here is the template: ```python from PIL import Image def generate_composite_image(image_path1, image_path2, alpha): # Ensure alpha is within the correct range if not (0.0 <= alpha <= 1.0): raise ValueError(\'Alpha value must be between 0 and 1\') # Open the two images image1 = Image.open(image_path1) image2 = Image.open(image_path2) # Resize image2 to match image1 dimensions if necessary if image1.size != image2.size: image2 = image2.resize(image1.size) # Blend the images using the specified alpha value composite_image = Image.blend(image1, image2, alpha) # Save the composite image composite_image.save(\\"composite_image.png\\") # Display the composite image composite_image.show() ``` Ensure you handle scenarios where the images might not be of the same dimensions and alpha values outside the range [0, 1].","solution":"from PIL import Image def generate_composite_image(image_path1, image_path2, alpha): Generates a composite image by blending two given images using the specified alpha value. Args: image_path1 (str): Path to the first image. image_path2 (str): Path to the second image. alpha (float): Blending factor, should be between 0 and 1 inclusive. # Ensure alpha is within the correct range if not (0.0 <= alpha <= 1.0): raise ValueError(\'Alpha value must be between 0 and 1\') # Open the two images image1 = Image.open(image_path1) image2 = Image.open(image_path2) # Resize image2 to match image1 dimensions if necessary if image1.size != image2.size: image2 = image2.resize(image1.size) # Blend the images using the specified alpha value composite_image = Image.blend(image1, image2, alpha) # Save the composite image composite_image.save(\\"composite_image.png\\") # Display the composite image composite_image.show()"},{"question":"You are developing a small social media platform where users can post short messages called \\"tweets.\\" As part of this platform, you need to implement a function that sanitizes a tweet before it is stored in the database. Sanitization involves detecting and removing any offensive words from the tweet. You are provided with a list of offensive words that should be removed and replaced with asterisks (*), where each asterisk represents a character of the original word. Write a function `sanitize_tweet` that takes a tweet as a string and a list of offensive words as arguments. The function should return the sanitized version of the tweet. If no offensive words are found, the tweet should be returned unchanged. Function signature: ```python def sanitize_tweet(tweet: str, offensive_words: list) -> str: pass ``` # Example: ```python tweet = \\"I hate when people are so annoying and stupid\\" offensive_words = [\\"hate\\", \\"stupid\\"] ``` Expected Output: ``` \\"I **** when people are so annoying and ******\\" ``` # Constraints: - The comparison of offensive words should be case-insensitive. - Only whole words should be replaced (e.g., \\"hatred\\" should not be replaced if \\"hate\\" is an offensive word). - Maintain the original spacing and punctuation in the tweet. - Offensive words have only alphabetical characters.","solution":"def sanitize_tweet(tweet: str, offensive_words: list) -> str: Sanitizes a tweet by replacing offensive words with asterisks. Each asterisk represents a character of the original offensive word. Parameters: tweet (str): The original tweet to be sanitized. offensive_words (list): A list of offensive words to be removed from the tweet. Returns: str: The sanitized tweet with offensive words replaced by asterisks. words = tweet.split() sanitized_words = [] offensive_words_lower = {word.lower() for word in offensive_words} for word in words: word_lower = word.lower().strip(\'.,!?\') if word_lower in offensive_words_lower: sanitized_word = \'*\' * len(word) sanitized_words.append(sanitized_word) else: sanitized_words.append(word) return \' \'.join(sanitized_words)"},{"question":"You are tasked to create a function called `distribute_candies_equally` that takes a list of integers representing the number of candies each child currently has and an integer representing total additional candies to distribute. The function should distribute the candies one by one in a round-robin fashion until all candies are distributed. The function should return the modified list of integers. **Function Signature:** ```python def distribute_candies_equally(candies: List[int], additional_candies: int) -> List[int]: ``` **Parameters:** - `candies`: A list of integers where each integer represents the number of candies each child currently has. - `additional_candies`: An integer representing the total additional candies to be distributed. **Requirements:** 1. Distribute additional candies one by one to each child in a round-robin manner until no additional candies remain. 2. The function should return the list of integers representing the updated number of candies each child has after distribution. **Example Usage:** ```python candies = [2, 3, 5] additional_candies = 5 print(distribute_candies_equally(candies, additional_candies)) ``` **Expected Outcome:** ```python [4, 5, 6] ``` In this example, 5 additional candies are distributed one by one as follows: - 1st candy to the 1st child: [3, 3, 5] - 2nd candy to the 2nd child: [3, 4, 5] - 3rd candy to the 3rd child: [3, 4, 6] - 4th candy to the 1st child: [4, 4, 6] - 5th candy to the 2nd child: [4, 5, 6]","solution":"from typing import List def distribute_candies_equally(candies: List[int], additional_candies: int) -> List[int]: n = len(candies) idx = 0 while additional_candies > 0: candies[idx % n] += 1 idx += 1 additional_candies -= 1 return candies"},{"question":"In this problem, you will create a basic inventory management system for a bookstore using Python\'s dictionary data structures. The functionality will be encapsulated within a class called `BookStore`. You are required to implement methods for adding new books, updating book quantities, removing books, and getting the current stock of a specific book. The `BookStore` class should include the following methods: 1. `add_book(title, quantity)`: Adds a new book with the given title and quantity to the inventory. If the book already exists, it should increase the quantity by the given amount. 2. `update_book_quantity(title, quantity)`: Updates the quantity of the given book title to the new quantity. If the book does not exist, it should print an appropriate message indicating that the book does not exist. 3. `remove_book(title)`: Removes the book with the given title from the inventory. If the book does not exist, it should print an appropriate message indicating that the book does not exist. 4. `get_stock(title)`: Returns the current quantity of the given book title. If the book does not exist, it should return `0`. Ensure that your methods handle edge cases, such as negative quantities for `add_book` and `update_book_quantity`. Here is the skeleton of the `BookStore` class to get you started: ```python class BookStore: def __init__(self): self.inventory = {} def add_book(self, title, quantity): pass # Implement this method def update_book_quantity(self, title, quantity): pass # Implement this method def remove_book(self, title): pass # Implement this method def get_stock(self, title): pass # Implement this method # Example usage: # bookstore = BookStore() # bookstore.add_book(\\"Python Programming\\", 10) # bookstore.update_book_quantity(\\"Python Programming\\", 15) # print(bookstore.get_stock(\\"Python Programming\\")) # Output: 15 # bookstore.remove_book(\\"Python Programming\\") # print(bookstore.get_stock(\\"Python Programming\\")) # Output: 0 ``` Write the necessary code to complete the `BookStore` class and ensure that it works as specified.","solution":"class BookStore: def __init__(self): self.inventory = {} def add_book(self, title, quantity): if quantity < 0: print(\\"Quantity cannot be negative.\\") return if title in self.inventory: self.inventory[title] += quantity else: self.inventory[title] = quantity def update_book_quantity(self, title, quantity): if quantity < 0: print(\\"Quantity cannot be negative.\\") return if title in self.inventory: self.inventory[title] = quantity else: print(\\"Book does not exist.\\") def remove_book(self, title): if title in self.inventory: del self.inventory[title] else: print(\\"Book does not exist.\\") def get_stock(self, title): return self.inventory.get(title, 0)"},{"question":"In this problem, you are required to write a function `order_statistic(arr, k)` that finds the k-th smallest element in an unsorted array. Your function should have an average time complexity of `O(n)`. You are allowed to use the Quickselect algorithm to achieve this. The Quickselect algorithm is similar to QuickSort and operates as follows: 1. Select a pivot element from the array. 2. Partition the array into two sub-arrays, those less than the pivot and those greater than the pivot. 3. Depending on the position of the pivot, recursively apply the algorithm to one of the sub-arrays. Your task is to implement the `order_statistic` function that utilizes the Quickselect algorithm to find the k-th smallest element in the given array. Function signature: ```python def order_statistic(arr, k): pass ``` # Input Your function should accept two inputs: 1. `arr` (list of integers): The list of integers from which we need to find the k-th smallest element. 2. `k` (integer): The order of the statistic we want to find (1-based index). # Output Your function should return an integer representing the k-th smallest element in the array. # Constraints 1. The array `arr` will contain at least 1 and at most 10^5 elements. 2. The value of `k` will be between 1 and the length of the array. # Examples ```python order_statistic([3, 1, 2, 1, 4, 5, 6], 3) # returns 2 order_statistic([10, 4, 5, 8, 6, 11, 26], 5) # returns 10 ``` # Notes - Ensure that the function handles duplicate elements correctly. - Optimize for performance to handle large inputs effectively. Implement the `order_statistic` function as described.","solution":"import random def partition(arr, low, high): pivot = arr[high] i = low for j in range(low, high): if arr[j] <= pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def quickselect(arr, low, high, k): if low < high: pivot_index = partition(arr, low, high) if pivot_index == k: return arr[pivot_index] elif pivot_index > k: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) return arr[low] def order_statistic(arr, k): return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"# Context You are working on a data processing project where you need to load a dataset from a CSV file and perform some basic preprocessing. The objective is to develop a function that reads a CSV file, filters out rows with any missing values, and normalizes each feature to a range between 0 and 1. # Specific Requirements Your function `preprocess_csv_data` should perform the following steps: 1. Read the CSV file into a Pandas DataFrame. 2. Remove any rows that contain missing (NaN) values. 3. Normalize all the numeric columns in the DataFrame such that each value in a column is scaled to a range between 0 and 1, inclusive. 4. Return the cleaned and normalized DataFrame. # Input/Output - **Input**: The function takes one parameter, `file_path`, which is a string representing the file path to the CSV file. - **Output**: The function returns a Pandas DataFrame that is cleaned and normalized. # Learning Objective This exercise aims to teach you the following: 1. How to read data from a CSV file into a Pandas DataFrame. 2. How to handle missing data by filtering out rows with missing values. 3. How to normalize data using feature scaling techniques in Pandas. # Function Signature ```python import pandas as pd def preprocess_csv_data(file_path: str) -> pd.DataFrame: # Your implementation here ``` # Assumptions - The CSV file will have a header row containing column names. - All missing values in the CSV file are represented as NaN. - You should use Pandas for data loading and preprocessing.","solution":"import pandas as pd from sklearn.preprocessing import MinMaxScaler def preprocess_csv_data(file_path: str) -> pd.DataFrame: Reads a CSV file, filters out rows with any missing values, and normalizes each feature to a range between 0 and 1. Parameters: file_path (str): The file path to the CSV file. Returns: pd.DataFrame: The cleaned and normalized DataFrame. # Read the CSV file into a DataFrame df = pd.read_csv(file_path) # Remove rows with missing values df = df.dropna() # Normalize numeric columns numeric_cols = df.select_dtypes(include=[\'number\']).columns scaler = MinMaxScaler() df[numeric_cols] = scaler.fit_transform(df[numeric_cols]) return df"},{"question":"In this problem, you will create a function to analyze and manipulate a list of integers. The goal is to write a function that partitions the list into two sublists, one containing all even numbers and the other containing all odd numbers, and then returns the sum of the maximum numbers from each sublist. Your task is to write a function `partition_and_sum` that follows these steps: 1. Partition the list into two sublists: one sublist containing all even integers and the other containing all odd integers. 2. Find the maximum integer in each sublist. 3. Return the sum of these maximum integers. If either sublist is empty, its maximum is considered to be `0`. Specifically, you need to: 1. Define the function `partition_and_sum(numbers)` where `numbers` is a list of integers. 2. Create two sublists, one for even numbers and one for odd numbers. 3. Find the maximum value of each sublist. If a sublist is empty, use `0` as the maximum value for that sublist. 4. Return the sum of these maximum values. For example: ```python assert partition_and_sum([4, 3, 8, 5, 11, -2]) == 19 # Max even = 8, Max odd = 11, Sum = 19 assert partition_and_sum([2, 4, 6, 8]) == 8 # Max even = 8, Max odd = 0, Sum = 8 assert partition_and_sum([1, 3, 5, 7]) == 7 # Max even = 0, Max odd = 7, Sum = 7 assert partition_and_sum([]) == 0 # Max even = 0, Max odd = 0, Sum = 0 assert partition_and_sum([-4, -1, -7, -8]) == -1 # Max even = -4, Max odd = -1, Sum = -5 ``` Implement the function `partition_and_sum(numbers)` based on the above guidelines.","solution":"def partition_and_sum(numbers): Partition the list into two sublists: one containing all even numbers and the other containing all odd numbers, and return the sum of the maximum numbers from each sublist. :param numbers: list of integers :return: sum of the maximum numbers of even and odd sublists even_numbers = [num for num in numbers if num % 2 == 0] odd_numbers = [num for num in numbers if num % 2 != 0] max_even = max(even_numbers) if even_numbers else 0 max_odd = max(odd_numbers) if odd_numbers else 0 return max_even + max_odd"},{"question":"You are required to implement a function that performs Run-Length Encoding (RLE) on a given 1D list of integers. RLE is a simple form of data compression in which runs of data (sequences in which the same data value occurs in many consecutive elements) are stored as a single data value and count. Specifically, you need to write a function named `run_length_encoding` that takes the following parameter: - `data`: a 1D list, array, or iterable of integers. The function should perform the following steps: 1. Traverse the dataset `data` to identify consecutive sequences of the same integer. 2. Capture the integer and the length of each consecutive sequence. 3. Return a list of tuples where each tuple consists of the integer followed by its run length. Function Signature: ```python def run_length_encoding(data): pass ``` Example: ```python data = [1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5] run_length_encoding(data) ``` Expected Output: ```python [(1, 2), (2, 1), (3, 3), (4, 2), (5, 5)] ``` In this example, the dataset `data` contains runs as follows: - Two `1`s - One `2` - Three `3`s - Two `4`s - Five `5`s The function returns these as a list of tuples, with each tuple representing the integer from the run and the length of that run.","solution":"def run_length_encoding(data): Performs Run-Length Encoding on the input list of integers. Args: data (list of int): The input list of integers. Returns: list of tuples: A list where each tuple contains an integer from the input list and its run length. if not data: return [] encoded = [] current_value = data[0] current_count = 1 for i in range(1, len(data)): if data[i] == current_value: current_count += 1 else: encoded.append((current_value, current_count)) current_value = data[i] current_count = 1 encoded.append((current_value, current_count)) # Append the last run return encoded"},{"question":"You are tasked with creating a function to analyze and validate the configuration of a network setup. The configuration is provided as a list of dictionaries, each representing a network device with various properties. Your goal is to identify any issues in the configuration and provide recommendations. # Function Specification **Function Name:** validate_network_config **Parameters:** - `configurations` (list of dict): A list of dictionaries where each dictionary represents a network device. Each dictionary contains the keys \'hostname\', \'ip_address\', \'subnet_mask\', and \'default_gateway\'. **Returns:** (list of dict): A list of dictionaries where each dictionary contains the hostname of the device and a list of issues found. # Task You need to perform the following in the `validate_network_config` function: 1. Validate that each device has a unique `hostname`. 2. Check that the `ip_address` is a valid IPv4 address. 3. Ensure the `subnet_mask` is valid and corresponds to a proper subnet mask. 4. Verify that the `default_gateway` is within the same subnet as the `ip_address` given the `subnet_mask`. 5. Generate a list of issues encountered for each device and return these in the resulting list of dictionaries. # Example Usage ```python configurations = [ { \'hostname\': \'router1\', \'ip_address\': \'192.168.1.1\', \'subnet_mask\': \'255.255.255.0\', \'default_gateway\': \'192.168.1.254\' }, { \'hostname\': \'router2\', \'ip_address\': \'10.0.0.1\', \'subnet_mask\': \'255.0.0.0\', \'default_gateway\': \'10.0.0.254\' }, { \'hostname\': \'router3\', \'ip_address\': \'192.168.1.2\', \'subnet_mask\': \'255.255.0.0\', \'default_gateway\': \'192.168.2.1\' } ] def is_valid_ip(ip): # Dummy IP validation implementation for demonstration purposes octets = ip.split(\'.\') if len(octets) != 4: return False for octet in octets: if not octet.isdigit() or not 0 <= int(octet) <= 255: return False return True def validate_network_config(configurations): issues_found = [] hostnames = set() for config in configurations: device_issues = [] hostname = config[\'hostname\'] ip_address = config[\'ip_address\'] subnet_mask = config[\'subnet_mask\'] default_gateway = config[\'default_gateway\'] if hostname in hostnames: device_issues.append(\'Hostname is not unique\') else: hostnames.add(hostname) if not is_valid_ip(ip_address): device_issues.append(\'Invalid IP address\') if not is_valid_ip(subnet_mask): device_issues.append(\'Invalid subnet mask\') if not is_valid_ip(default_gateway): device_issues.append(\'Invalid default gateway\') # Additional network subnet checks can be performed here issues_found.append({\'hostname\': hostname, \'issues\': device_issues}) return issues_found print(validate_network_config(configurations)) # Expected output: # [ # {\'hostname\': \'router1\', \'issues\': []}, # {\'hostname\': \'router2\', \'issues\': []}, # {\'hostname\': \'router3\', \'issues\': [\'Invalid subnet mask\', \'Default gateway is outside the subnet\']} # ] ```","solution":"import ipaddress def is_valid_ip(ip): Check if the given IP address is valid. try: ipaddress.ip_address(ip) return True except ValueError: return False def is_valid_subnet_mask(mask): Check if the given subnet mask is valid. try: ipaddress.IPv4Network(f\'0.0.0.0/{mask}\', strict=False) return True except ValueError: return False def is_same_subnet(ip, gateway, mask): Check if the IP address and default gateway are in the same subnet. ip_network = ipaddress.IPv4Network(f\'{ip}/{mask}\', strict=False) gateway_network = ipaddress.IPv4Network(f\'{gateway}/{mask}\', strict=False) return ip_network.network_address == gateway_network.network_address def validate_network_config(configurations): issues_found = [] hostnames = set() for config in configurations: device_issues = [] hostname = config[\'hostname\'] ip_address = config[\'ip_address\'] subnet_mask = config[\'subnet_mask\'] default_gateway = config[\'default_gateway\'] if hostname in hostnames: device_issues.append(\'Hostname is not unique\') else: hostnames.add(hostname) if not is_valid_ip(ip_address): device_issues.append(\'Invalid IP address\') if not is_valid_subnet_mask(subnet_mask): device_issues.append(\'Invalid subnet mask\') if not is_valid_ip(default_gateway): device_issues.append(\'Invalid default gateway\') if is_valid_ip(ip_address) and is_valid_ip(default_gateway) and is_valid_subnet_mask(subnet_mask): if not is_same_subnet(ip_address, default_gateway, subnet_mask): device_issues.append(\'Default gateway is outside the subnet\') issues_found.append({\'hostname\': hostname, \'issues\': device_issues}) return issues_found"},{"question":"You are required to create a function `detect_duplicate_users()` that processes a list of user profiles, identifies duplicates, and outputs unique user profiles to a new list. The function should use specific criteria to determine if two users are duplicates: 1. **Criteria for Duplicates**: - Two user profiles are considered duplicates if they have the exact same first name, last name, and email address. 2. **Function Requirements**: - Read the provided list of user profiles. - Eliminate duplicate profiles based on the given criteria. - Return a list of unique user profiles. # Input - A list of dictionaries, where each dictionary represents a user profile containing the keys: `\'first_name\'`, `\'last_name\'`, and `\'email\'`. # Output - A list of dictionaries representing unique user profiles. # Example Given the input list of user profiles: ```python profiles = [ {\'first_name\': \'John\', \'last_name\': \'Doe\', \'email\': \'john.doe@email.com\'}, {\'first_name\': \'Jane\', \'last_name\': \'Doe\', \'email\': \'jane.doe@email.com\'}, {\'first_name\': \'John\', \'last_name\': \'Doe\', \'email\': \'john.doe@email.com\'}, {\'first_name\': \'Jake\', \'last_name\': \'Smith\', \'email\': \'jake.smith@email.com\'} ] ``` The function should output: ```python unique_profiles = [ {\'first_name\': \'John\', \'last_name\': \'Doe\', \'email\': \'john.doe@email.com\'}, {\'first_name\': \'Jane\', \'last_name\': \'Doe\', \'email\': \'jane.doe@email.com\'}, {\'first_name\': \'Jake\', \'last_name\': \'Smith\', \'email\': \'jake.smith@email.com\'} ] ``` # Function Implementation Use this template as a guide to implement the `detect_duplicate_users` function: ```python def detect_duplicate_users(profiles): unique_profiles = [] seen = set() for profile in profiles: identifier = (profile[\'first_name\'], profile[\'last_name\'], profile[\'email\']) if identifier not in seen: seen.add(identifier) unique_profiles.append(profile) return unique_profiles # Example usage profiles = [ {\'first_name\': \'John\', \'last_name\': \'Doe\', \'email\': \'john.doe@email.com\'}, {\'first_name\': \'Jane\', \'last_name\': \'Doe\', \'email\': \'jane.doe@email.com\'}, {\'first_name\': \'John\', \'last_name\': \'Doe\', \'email\': \'john.doe@email.com\'}, {\'first_name\': \'Jake\', \'last_name\': \'Smith\', \'email\': \'jake.smith@email.com\'} ] print(detect_duplicate_users(profiles)) ```","solution":"def detect_duplicate_users(profiles): unique_profiles = [] seen = set() for profile in profiles: identifier = (profile[\'first_name\'], profile[\'last_name\'], profile[\'email\']) if identifier not in seen: seen.add(identifier) unique_profiles.append(profile) return unique_profiles"},{"question":"You are tasked with creating a function that manipulates and processes data from a given list of dictionaries. Each dictionary represents an employee with the keys \\"name\\", \\"age\\", and \\"department\\". Your function needs to perform two main tasks: group the employees by department and find the average age of employees in each department. **Function Specification:** - Function name: `process_employee_data` - Parameters: `employees` (a list of dictionaries, where each dictionary contains the keys \\"name\\", \\"age\\", and \\"department\\") - Returns: A tuple containing two elements: 1. A dictionary where the keys are department names and the values are lists of employee names in that department. 2. A dictionary where the keys are department names and the values are the average age of employees in that department. **Requirements:** - You must group the employees by their department. - Calculate the average age for employees within each department and ensure the age values are integers. **Example:** Given the input: ```python employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"HR\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"department\\": \\"Engineering\\"}, {\\"name\\": \\"Carol\\", \\"age\\": 28, \\"department\\": \\"HR\\"}, {\\"name\\": \\"Dave\\", \\"age\\": 35, \\"department\\": \\"Engineering\\"}, {\\"name\\": \\"Eve\\", \\"age\\": 40, \\"department\\": \\"Finance\\"} ] ``` The function call `process_employee_data(employees)` should return: ```python ( { \\"HR\\": [\\"Alice\\", \\"Carol\\"], \\"Engineering\\": [\\"Bob\\", \\"Dave\\"], \\"Finance\\": [\\"Eve\\"] }, { \\"HR\\": 29, \\"Engineering\\": 30, \\"Finance\\": 40 } ) ```","solution":"def process_employee_data(employees): Processes employee data to group by department and calculate average age. Parameters: employees (list): A list of dictionaries containing \\"name\\", \\"age\\", and \\"department\\". Returns: tuple: (dict of employee names grouped by department, dict of average age by department) department_groups = {} age_sums = {} age_counts = {} for employee in employees: dept = employee[\'department\'] name = employee[\'name\'] age = employee[\'age\'] if dept not in department_groups: department_groups[dept] = [] age_sums[dept] = 0 age_counts[dept] = 0 department_groups[dept].append(name) age_sums[dept] += age age_counts[dept] += 1 average_ages = {dept: age_sums[dept] // age_counts[dept] for dept in age_sums} return department_groups, average_ages"},{"question":"You are developing a software application that processes large datasets of numerical values. One of the critical operations in your application is to calculate the greatest common divisor (GCD) of the dataset\'s subsets efficiently. You need to implement a function `gcd_subset()` that computes the GCD of all subsets of a given size from the list of integers. Function Signature ```python def gcd_subset(numbers, subset_size): ``` Parameters - `numbers`: A list of integers representing the dataset. - `subset_size`: An integer representing the size of the subsets to consider. Requirements 1. Use combinations to generate all possible subsets of the list `numbers` with length equal to `subset_size`. 2. Calculate the GCD of each subset and return the maximum GCD found among these subsets. 3. You are allowed to use the `gcd` function from the `math` module and the `combinations` function from the `itertools` module. Example For the given list of numbers `[12, 15, 21, 30, 18, 28]` and a subset size of `3`, the all possible subsets of size 3 are: - (12, 15, 21) - (12, 15, 30) - (12, 15, 18) - (12, 15, 28) - (12, 21, 30) - (12, 21, 18) - (12, 21, 28) - (12, 30, 18) - (12, 30, 28) - (12, 18, 28) - (15, 21, 30) - (15, 21, 18) - (15, 21, 28) - (15, 30, 18) - (15, 30, 28) - (15, 18, 28) - (21, 30, 18) - (21, 30, 28) - (21, 18, 28) - (30, 18, 28) Among these subsets, the subset with the maximum GCD is `(12, 30, 18)` which has a GCD of `6`. Sample Output ```python numbers = [12, 15, 21, 30, 18, 28] subset_size = 3 print(gcd_subset(numbers, subset_size)) # Output: 6 ```","solution":"from math import gcd from itertools import combinations from functools import reduce def gcd_subset(numbers, subset_size): Calculate the greatest common divisor (GCD) of all subsets of a given size from the list of integers. Args: numbers (list): List of integers representing the dataset. subset_size (int): Size of the subsets to consider. Returns: int: The maximum GCD found among all subsets of the given size. def calculate_gcd_of_list(numbers): return reduce(gcd, numbers) max_gcd = 0 for subset in combinations(numbers, subset_size): subset_gcd = calculate_gcd_of_list(subset) if subset_gcd > max_gcd: max_gcd = subset_gcd return max_gcd"},{"question":"You are given the task of simulating a simple infectious disease spread model using the SIR (Susceptible, Infected, Recovered) model. Implement the following steps: 1. Implement a function `sir_model(y, t, beta, gamma)` which corresponds to the differential equations: [ begin{aligned} &frac{dS}{dt} = -beta cdot S cdot I &frac{dI}{dt} = beta cdot S cdot I - gamma cdot I &frac{dR}{dt} = gamma cdot I end{aligned} ] Where ( S ) is the number of susceptible people, ( I ) is the number of infected people, ( R ) is the number of recovered people, ( beta ) is the transmission rate, and ( gamma ) is the recovery rate. 2. Use `scipy.integrate.odeint` to solve the differential equations for a given initial number of susceptible, infected, and recovered individuals over a specified time range. 3. Visualize the results using `matplotlib.pyplot` to show the number of susceptible, infected, and recovered individuals over time. 4. Implement a `plot_sir_model` function which: - Takes in initial counts of susceptible (`S0`), infected (`I0`), recovered (`R0`) individuals, transmission rate (`beta`), recovery rate (`gamma`), and the time range (`days`). - Simulates the SIR model and plots the SIR curves using the required libraries. - Shows the resulting plot. Use the required functions from `numpy` and `matplotlib.pyplot` to complete this task. Function signature: ```python def plot_sir_model(S0: int, I0: int, R0: int, beta: float, gamma: float, days: int) -> None: pass ```","solution":"import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt def sir_model(y, t, beta, gamma): Compute the derivatives for the SIR model. :param y: Tuple containing the current values of S, I, and R. :param t: Time variable (not used in this context). :param beta: Transmission rate. :param gamma: Recovery rate. :return: Derivatives dS/dt, dI/dt, dR/dt. S, I, R = y dSdt = -beta * S * I dIdt = beta * S * I - gamma * I dRdt = gamma * I return dSdt, dIdt, dRdt def plot_sir_model(S0, I0, R0, beta, gamma, days): Plot the SIR model simulation results. :param S0: Initial number of susceptibles. :param I0: Initial number of infected. :param R0: Initial number of recovered. :param beta: Transmission rate. :param gamma: Recovery rate. :param days: Number of days to simulate. # Total population, N. N = S0 + I0 + R0 # Initial conditions vector y0 = S0, I0, R0 # A grid of time points (in days) t = np.linspace(0, days, days) # Integrate the SIR equations over the time grid, t. ret = odeint(sir_model, y0, t, args=(beta, gamma)) S, I, R = ret.T # Plot the data on three separate curves for S(t), I(t) and R(t) plt.figure(figsize=(10, 6)) plt.plot(t, S, \'b\', alpha=0.7, linewidth=2, label=\'Susceptible\') plt.plot(t, I, \'r\', alpha=0.7, linewidth=2, label=\'Infected\') plt.plot(t, R, \'g\', alpha=0.7, linewidth=2, label=\'Recovered\') plt.xlabel(\'Days\') plt.ylabel(\'Number of People\') plt.legend() plt.title(f\'SIR Model with beta={beta} and gamma={gamma}\') plt.grid(True) plt.show()"},{"question":"You are required to write a function named `generate_multiplication_table` that generates a multiplication table from 1 to a given integer n and writes it to a CSV file. Each cell in the table should contain the product of its respective row and column numbers. Key requirements for the function: 1. The function should create a multiplication table with values from 1 up to the specified integer n. 2. The resulting table should be written to a CSV file named `multiplication_table.csv`. 3. The function should ensure the CSV file has row and column headers indicating the multiplicands. The function signature is: ```python def generate_multiplication_table(n: int) -> None: pass ``` # Libraries to be used: - `csv` for writing data to the CSV file. - `pandas` for easier data manipulation and export to CSV format (optional but recommended). # Specifications: - **Input**: - `n` (int): The size of the multiplication table (1 to n). - **Output**: - A CSV file named `multiplication_table.csv` containing the multiplication table with row and column headers. # Example: Suppose you call the function with `n = 3`. The resulting CSV file `multiplication_table.csv` content should be: ``` ,1,2,3 1,1,2,3 2,2,4,6 3,3,6,9 ``` **Task**: Write the function `generate_multiplication_table` that creates the multiplication table up to `n`, and writes it to a file called `multiplication_table.csv` with appropriate headers.","solution":"import csv def generate_multiplication_table(n: int) -> None: Generates a multiplication table from 1 to n and writes it to a CSV file. Parameters: n (int): The size of the multiplication table (1 to n). # Open the target CSV file in write mode with open(\'multiplication_table.csv\', mode=\'w\', newline=\'\') as file: writer = csv.writer(file) # Write the header row header = [\'\'] + list(range(1, n + 1)) writer.writerow(header) # Write each row of the table for i in range(1, n + 1): row = [i] + [i * j for j in range(1, n + 1)] writer.writerow(row)"},{"question":"Define a function `find_mode` that finds the mode(s) of a given list of integers. The mode is the number that appears most frequently in a data set. If there\'s a tie for the most frequent values, the function should return all the tied values in ascending order. You are required to implement the function without using any external libraries like `collections.Counter`. Below is the expected function signature: ```python def find_mode(numbers: list[int]) -> list[int]: # your code here ``` # Requirements: 1. **Input**: - `numbers`: A list of integers 2. **Output**: - Returns a list of integers representing the mode(s) in ascending order. # Implementation Details: 1. Utilize a dictionary to count the frequency of each number in the list. 2. Iterate through the dictionary to find the maximum frequency. 3. Collect all numbers that have the maximum frequency. 4. Sort the result list to ensure it is in ascending order. # Example: ```python numbers = [4, 1, 2, 2, 3, 3, 4, 4] result = find_mode(numbers) print(result) # Expected output: [4] numbers = [1, 1, 2, 2, 3, 3] result = find_mode(numbers) print(result) # Expected output: [1, 2, 3] ``` # Edge Cases: 1. If the input list is empty, return an empty list. 2. If all numbers appear the same number of times, return all numbers in ascending order.","solution":"def find_mode(numbers: list[int]) -> list[int]: Finds the mode(s) of a given list of integers. If multiple modes exist, return them in ascending order. if not numbers: return [] # Dictionary to store the frequency of each number frequency_dict = {} for number in numbers: if number in frequency_dict: frequency_dict[number] += 1 else: frequency_dict[number] = 1 # Find the maximum frequency max_frequency = max(frequency_dict.values()) # Collect all numbers with the maximum frequency mode_list = [number for number, frequency in frequency_dict.items() if frequency == max_frequency] # Sort the result to ensure it is in ascending order mode_list.sort() return mode_list"},{"question":"Write a function that accepts a list of transaction records, where each record is a dictionary containing \'id\', \'amount\', and \'type\'. The function should return a summary dictionary with the total amount of transactions for each type. The function should output with: Dictionary: A dictionary where keys are types of transactions and values are the total amounts for these types. Args: transactions (list of dict): List of transaction records. Each record is a dictionary with: - \'id\' (int): Unique transaction ID. - \'amount\' (float): Amount of the transaction. - \'type\' (str): Type of the transaction (e.g., \'deposit\', \'withdrawal\'). You should write self-contained code starting with: ```python def summarize_transactions(transactions): ```","solution":"def summarize_transactions(transactions): Returns a summary dictionary with the total amount of transactions for each type. Args: transactions (list of dict): List of transaction records. Each record is a dictionary with: - \'id\' (int): Unique transaction ID. - \'amount\' (float): Amount of the transaction. - \'type\' (str): Type of the transaction (e.g., \'deposit\', \'withdrawal\'). Returns: dict: A dictionary where keys are types of transactions and values are the total amounts for these types. summary = {} for transaction in transactions: transaction_type = transaction[\'type\'] transaction_amount = transaction[\'amount\'] if transaction_type in summary: summary[transaction_type] += transaction_amount else: summary[transaction_type] = transaction_amount return summary"},{"question":"Machine Learning Model Evaluation: Regression Metrics In this problem, you are required to evaluate the performance of a regression model using various statistical metrics. Your task is to write a function named `evaluate_regression_model` that calculates and returns multiple evaluation metrics based on the provided predictions and actual values. The function will receive two arguments: `actual` and `predicted`. Here is the detailed description of each parameter: 1. `actual`: A list or numpy array that contains the actual target values. 2. `predicted`: A list or numpy array that contains the predicted target values generated by the regression model. The function should perform the following steps: 1. Import the necessary libraries from `sklearn` and `numpy`. 2. Calculate the Mean Absolute Error (MAE). 3. Calculate the Mean Squared Error (MSE). 4. Calculate the R-squared Score (R). 5. Return a dictionary containing the computed values for MAE, MSE, and R. **Note**: You should use the `mean_absolute_error`, `mean_squared_error`, and `r2_score` functions from the `sklearn.metrics` module to achieve this task. Example usage: ```python from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score import numpy as np def evaluate_regression_model(actual, predicted): mae = mean_absolute_error(actual, predicted) mse = mean_squared_error(actual, predicted) r2 = r2_score(actual, predicted) return {\'MAE\': mae, \'MSE\': mse, \'R\': r2} actual = np.array([3.0, -0.5, 2.0, 7.0]) predicted = np.array([2.5, 0.0, 2.0, 8.0]) metrics = evaluate_regression_model(actual, predicted) ``` This function should help in determining the effectiveness of a regression model by providing key performance metrics.","solution":"from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score import numpy as np def evaluate_regression_model(actual, predicted): Evaluates the regression model using MAE, MSE, and R metrics. Parameters: actual (list or numpy array): Actual target values. predicted (list or numpy array): Predicted target values by the model. Returns: dict: A dictionary containing the MAE, MSE, and R values. mae = mean_absolute_error(actual, predicted) mse = mean_squared_error(actual, predicted) r2 = r2_score(actual, predicted) return {\'MAE\': mae, \'MSE\': mse, \'R\': r2}"},{"question":"You are designing a system to manage and operate a series of events. Each event has a start time and an end time, and you need to implement a function that will determine if any of the events overlap. Function Signature: ```python def check_event_overlap(events: List[Tuple[int, int]]) -> bool: ``` # Requirements: 1. Using the `List` and `Tuple` types, validate and process the input events. 2. Ensure each event in the input list of events is a tuple containing exactly two integers, where the first integer is less than the second. If an event does not satisfy this condition, raise an assertion error with the message \'`each event must be a tuple (start_time, end_time) with start_time < end_time`\'. 3. Iterate through the list of events to detect any overlaps. Two events overlap if one event starts before another event ends. 4. Return `True` if any events overlap, otherwise return `False`. # Examples: Given the following inputs: ```python events = [(1, 3), (2, 4), (5, 6)] ``` The expected output should be: ```python True ``` Given the following inputs: ```python events = [(1, 2), (3, 4), (5, 6)] ``` The expected output should be: ```python False ``` Helper function (if needed): ```python def events_overlapping(event1: Tuple[int, int], event2: Tuple[int, int]) -> bool: # This function checks if two events overlap return not (event1[1] <= event2[0] or event2[1] <= event1[0]) ```","solution":"from typing import List, Tuple def events_overlapping(event1: Tuple[int, int], event2: Tuple[int, int]) -> bool: Checks if two events overlap. # There is no overlap if one event ends before the other starts return not (event1[1] <= event2[0] or event2[1] <= event1[0]) def check_event_overlap(events: List[Tuple[int, int]]) -> bool: Checks if any events in the given list overlap. # Validate input for event in events: assert isinstance(event, tuple) and len(event) == 2, \'each event must be a tuple (start_time, end_time) with start_time < end_time\' start, end = event assert isinstance(start, int) and isinstance(end, int) and start < end, \'each event must be a tuple (start_time, end_time) with start_time < end_time\' # Check for overlapping events events = sorted(events, key=lambda x: x[0]) # Sort events by start time for i in range(len(events) - 1): if events_overlapping(events[i], events[i+1]): return True return False"},{"question":"You need to implement a function named `longest_consecutive_subsequence` that finds the length of the longest consecutive elements sequence from an unsorted array of integers. # Requirements: 1. The function should accept one argument: - `nums`: A list of integers. 2. The function should: - Return the length of the longest consecutive elements sequence. - Should work in O(n) time complexity. # Explanation: - Your function should find all possible consecutive sequences and return the length of the longest one. - For example, in the array `[100, 4, 200, 1, 3, 2]`, the longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore the function should return its length, which is `4`. # Example Usage: ```python # Example 1 nums = [100, 4, 200, 1, 3, 2] print(longest_consecutive_subsequence(nums)) # Output: 4 # Example 2 nums = [1, 2, 0, 1] print(longest_consecutive_subsequence(nums)) # Output: 3 # Example 3 nums = [8, 7, 6, 5, 9, 10, 2, 1] print(longest_consecutive_subsequence(nums)) # Output: 6 ``` # Note: The function should handle edge cases such as an empty array, array with one element, or array with all duplicate elements.","solution":"def longest_consecutive_subsequence(nums): Finds the length of the longest consecutive elements sequence. Parameters: nums (list): A list of integers. Returns: int: The length of the longest consecutive elements sequence. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Given a list of integers, find the longest consecutive subsequence. A consecutive subsequence is a subset of numbers from the list that can be arranged in a sequence where each number is exactly one more than the preceding number. You need to return the length of this longest subsequence. The function should output: int: The length of the longest consecutive subsequence. You should write self-contained code starting with: ``` def longest_consecutive_subsequence(nums): ```","solution":"def longest_consecutive_subsequence(nums): if not nums: return 0 nums = set(nums) longest_streak = 0 for num in nums: if num - 1 not in nums: current_num = num current_streak = 1 while current_num + 1 in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a JSON file containing data on various medications, which includes fields like \'name\', \'type\', \'price\', and \'availability\'. Write a Python function that performs the following tasks: 1. Read the JSON file from a specified file path. 2. Filter the medications to only include those above a specified price threshold. 3. Group the filtered medications by their \'type\' field. 4. Sort each group of medications by their \'name\' field. 5. Save the resulting grouped and sorted data back to a specified output JSON file. Write self-contained code starting with: ``` import json def filter_and_sort_medications(input_json_path, output_json_path, price_threshold): ``` Additional requirements: - The JSON file should be read and written in UTF-8 encoding. - The output JSON file should ensure each medication entry is sorted within its group by the \'name\' field. - The \'availability\' field should not be included in the output JSON.","solution":"import json from collections import defaultdict def filter_and_sort_medications(input_json_path, output_json_path, price_threshold): Reads a JSON file of medications, filters them by price, groups by type, sorts by name, and writes the output to a specified file. Parameters: input_json_path (str): Path to the input JSON file. output_json_path (str): Path to the output JSON file. price_threshold (float): Minimum price to filter the medications. # Read the input JSON file with open(input_json_path, \'r\', encoding=\'utf-8\') as f: medications = json.load(f) # Filter medications by price threshold filtered_medications = [med for med in medications if med[\'price\'] > price_threshold] # Group medications by type grouped_medications = defaultdict(list) for med in filtered_medications: med_copy = {k: med[k] for k in med if k != \'availability\'} grouped_medications[med[\'type\']].append(med_copy) # Sort each group by name for type_group in grouped_medications.values(): type_group.sort(key=lambda x: x[\'name\']) # Write the output JSON file with open(output_json_path, \'w\', encoding=\'utf-8\') as f: json.dump(grouped_medications, f, indent=4)"},{"question":"Write a function `play_with_dataframes()` that demonstrates how to select, filter, and reorder data in `pandas` `DataFrame` by showcasing the following operations using the `pandas` library: 1. Create a `DataFrame` of shape (6, 4) with integer values ranging from `5` to `28`, with row indexes `\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'` and column labels `\'W\', \'X\', \'Y\', \'Z\'`. 2. Select and print only the rows where the values in column `\'W\'` are greater than `10`. 3. Select and print only the columns `\'W\'` and `\'Y\'`. 4. Select and print the values from rows `\'B\'` to `\'D\'` and columns `\'X\'` and `\'Z\'`. 5. Reorder the columns in the order `\'Z\', \'Y\', \'X\', \'W\'` and print the modified `DataFrame`. Ensure to import the necessary library and use the provided functions in the `pandas` library to achieve the desired outcomes. # Function Signature ```python def play_with_dataframes(): # Your code here ``` # Example Output ``` Original DataFrame: W X Y Z A 5 6 7 8 B 9 10 11 12 C 13 14 15 16 D 17 18 19 20 E 21 22 23 24 F 25 26 27 28 Rows where column \'W\' is greater than 10: W X Y Z C 13 14 15 16 D 17 18 19 20 E 21 22 23 24 F 25 26 27 28 Selected columns \'W\' and \'Y\': W Y A 5 7 B 9 11 C 13 15 D 17 19 E 21 23 F 25 27 Values from rows \'B\' to \'D\' and columns \'X\' and \'Z\': X Z B 10 12 C 14 16 D 18 20 DataFrame with reordered columns: Z Y X W A 8 7 6 5 B 12 11 10 9 C 16 15 14 13 D 20 19 18 17 E 24 23 22 21 F 28 27 26 25 ``` Use the `numpy.arange` function to generate a range of numbers where appropriate.","solution":"import pandas as pd import numpy as np def play_with_dataframes(): # Step 1: Create DataFrame data = np.arange(5, 29).reshape(6, 4) df = pd.DataFrame(data, index=[\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'], columns=[\'W\', \'X\', \'Y\', \'Z\']) print(\\"Original DataFrame:\\") print(df, end=\'nn\') # Step 2: Select rows where \'W\' > 10 df_w_gt_10 = df[df[\'W\'] > 10] print(\\"Rows where column \'W\' is greater than 10:\\") print(df_w_gt_10, end=\'nn\') # Step 3: Select columns \'W\' and \'Y\' df_w_y = df[[\'W\', \'Y\']] print(\\"Selected columns \'W\' and \'Y\':\\") print(df_w_y, end=\'nn\') # Step 4: Select values from rows \'B\' to \'D\' and columns \'X\' and \'Z\' df_b_to_d_x_z = df.loc[\'B\':\'D\', [\'X\', \'Z\']] print(\\"Values from rows \'B\' to \'D\' and columns \'X\' and \'Z\':\\") print(df_b_to_d_x_z, end=\'nn\') # Step 5: Reorder columns [\'Z\', \'Y\', \'X\', \'W\'] df_reordered = df[[\'Z\', \'Y\', \'X\', \'W\']] print(\\"DataFrame with reordered columns:\\") print(df_reordered, end=\'nn\') # Returning the dataframes for unit test purposes return df, df_w_gt_10, df_w_y, df_b_to_d_x_z, df_reordered"},{"question":"You are tasked with implementing a function `find_connected_components(graph)` that uses Depth-First Search (DFS) to identify and return all connected components of an undirected graph. The graph is represented as a dictionary where each key is a node and the associated value is a list of neighboring nodes. - **Input:** - `graph`: A dictionary representing an undirected graph where keys are node identifiers and values are lists of neighboring nodes. - **Output:** - This function should return a list of connected components, where each connected component is represented as a set of node identifiers. # Example Assume the graph is defined as follows: ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5], 7: [] } ``` If the function `find_connected_components(graph)` is executed, the output should be: ```python [{1, 2, 3, 4}, {5, 6}, {7}] ``` # Constraints 1. The graph is represented as an adjacency list. 2. All nodes are identified by unique integers. # Requirements Your implementation must utilize a depth-first search algorithm to explore the nodes in the graph. Use the following prototypes for reference: ```python def find_connected_components(graph): # Your implementation here ```","solution":"def find_connected_components(graph): def dfs(node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.add(current) stack.extend(neighbor for neighbor in graph[current] if neighbor not in visited) visited = set() components = [] for node in graph: if node not in visited: component = set() dfs(node, visited, component) components.append(component) return components"},{"question":"In this problem, you are required to implement a function that calculates the shortest path in a graph represented as an adjacency matrix. The algorithm you will implement is Dijkstra\'s algorithm. The function will be named `dijkstra` and will take the following parameters: 1. `graph`: A square matrix (2D list) representing the adjacency matrix of the graph. An element `graph[i][j]` will have the non-negative weight of the edge between nodes `i` and `j`, or float(\'inf\') if there is no direct edge between the nodes. 2. `start_node`: An integer representing the starting node for the algorithm. The function should perform the following steps: 1. Initialize the distance to the start node to 0 and to all other nodes to infinity. 2. Use a priority queue (you can use `heapq` from Python\'s standard library) to keep track of the nodes to explore. 3. While there are nodes left to explore in the priority queue: - Pop the node with the smallest distance from the priority queue. - For each of its neighboring nodes, calculate the distance through the current node and update the distance if this new distance is smaller. 4. Return a list containing the shortest distance from the start node to each node in the graph. Here\'s the template for the function you need to implement: ```python import heapq def dijkstra(graph, start_node): Compute the shortest path distances from the start node to all other nodes in the graph. Parameters: graph : list of lists Adjacency matrix representing the graph. start_node : int The starting node for the algorithm. Returns: list A list where the element at index `i` is the shortest distance from the start node to node `i`. n = len(graph) distances = [float(\'inf\')] * n distances[start_node] = 0 priority_queue = [(0, start_node)] visited = set() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) for neighbor, weight in enumerate(graph[current_node]): if weight != float(\'inf\') and neighbor not in visited: new_distance = current_distance + weight if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances ``` The `graph` parameter is a 2D list where `graph[i][j]` represents the weight of the edge from node `i` to node `j`. If there is no edge between the nodes, the weight is represented by `float(\'inf\')`. The `start_node` parameter is an integer indicating the starting node for calculating the shortest paths. For example, given the following graph as an adjacency matrix and starting node `0`: ```python graph = [ [0, 1, 4, float(\'inf\')], [1, 0, 4, 2], [4, 4, 0, 5], [float(\'inf\'), 2, 5, 0] ] start_node = 0 ``` The function call `dijkstra(graph, start_node)` should return `[0, 1, 4, 3]`, indicating that the shortest distance from node `0` to nodes `0, 1, 2,` and `3` are `0, 1, 4,` and `3`, respectively.","solution":"import heapq def dijkstra(graph, start_node): Compute the shortest path distances from the start node to all other nodes in the graph. Parameters: graph : list of lists Adjacency matrix representing the graph. start_node : int The starting node for the algorithm. Returns: list A list where the element at index `i` is the shortest distance from the start node to node `i`. n = len(graph) distances = [float(\'inf\')] * n distances[start_node] = 0 priority_queue = [(0, start_node)] visited = set() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) for neighbor, weight in enumerate(graph[current_node]): if weight != float(\'inf\') and neighbor not in visited: new_distance = current_distance + weight if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances"},{"question":"You are tasked with creating a Python function that merges two sorted arrays into a single sorted array without using any built-in sort functions. This function should demonstrate an understanding of the merge step in the merge sort algorithm. The function should be named `merge_sorted_arrays`. # Function Signature ```python def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: ``` # Parameters - `arr1` (List[int]): A sorted list of integers. - `arr2` (List[int]): A sorted list of integers. # Returns - (List[int]): A single sorted list that contains all elements from `arr1` and `arr2`. # Example ```python arr1 = [1, 3, 5, 7] arr2 = [2, 4, 6, 8] merged_array = merge_sorted_arrays(arr1, arr2) print(merged_array) # Output should be [1, 2, 3, 4, 5, 6, 7, 8] ``` # Instructions 1. Initialize an empty list to store the result and two indices, i and j, to 0. 2. Traverse both arrays, comparing the current elements of each. 3. Append the smaller element to the result list and advance the index. 4. If one list is exhausted before the other, append the remaining elements of the non-exhausted list to the result. 5. Return the merged and sorted result list. Note: The solution should take advantage of the fact that both input arrays are already sorted, ensuring efficiency especially for large datasets.","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. merged_array = [] i, j = 0, 0 # Traverse both arrays while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If any elements are left in arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # If any elements are left in arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"You are given a DataFrame that logs the activities of users on a website. Each row in the DataFrame represents an activity initiated by a user and contains the user\'s ID, a timestamp indicating when the activity was started, and the type of activity executed. The activities include events such as \'login\', \'view_page\', \'click_ad\', and \'logout\'. Your task is to write a Python function that processes this DataFrame and determines the session duration for each user, as well as the number and types of activities performed during each session. **Function to implement:** `analyze_user_sessions(activity_log_df: pd.DataFrame) -> pd.DataFrame` **Function details:** - **Input:** - `activity_log_df` (pandas DataFrame): A DataFrame with each row representing an activity and containing the following columns: - `user_id` (str): The ID of the user. - `timestamp` (str): The timestamp of the activity in the format \'YYYY-MM-DD HH:MM:SS\'. - `activity` (str): The type of activity (e.g., \'login\', \'view_page\', \'click_ad\', \'logout\'). - **Output:** - A DataFrame containing the following columns: - `user_id` (str): The ID of the user. - `session_start` (str): The timestamp of the first activity in the session. - `session_end` (str): The timestamp of the last activity in the session before a \'logout\'. - `session_duration` (float): The duration of the session in seconds. - `num_activities` (int): The total number of activities performed in the session. - `activity_counts` (dict): A dictionary with the count of each activity type performed in the session. **Rules for determining sessions:** 1. Each \'login\' marks the beginning of a new session. 2. A session ends when a \'logout\' activity occurs. If there are multiple logouts, the first one in a continuous block is considered as the end of the session. 3. if there are activities between logouts and the next login, they are not counted in any session. **Example:** ```python import pandas as pd from datetime import datetime # Sample DataFrame data = { \'user_id\': [\'user1\', \'user1\', \'user1\', \'user1\', \'user2\', \'user2\', \'user2\', \'user2\'], \'timestamp\': [\'2023-10-01 08:00:00\', \'2023-10-01 08:05:00\', \'2023-10-01 08:10:00\', \'2023-10-01 08:15:00\', \'2023-10-01 09:00:00\', \'2023-10-01 09:05:00\', \'2023-10-01 09:10:00\', \'2023-10-01 09:15:00\'], \'activity\': [\'login\', \'view_page\', \'click_ad\', \'logout\', \'login\', \'view_page\', \'logout\', \'login\'] } df = pd.DataFrame(data) # Call to the function result_df = analyze_user_sessions(df) print(result_df) ``` Modify and implement the `analyze_user_sessions` function such that it meets the specifications above.","solution":"import pandas as pd from datetime import datetime def analyze_user_sessions(activity_log_df: pd.DataFrame) -> pd.DataFrame: # Helper function to calculate the duration between two timestamps def calculate_duration(start, end): start_time = datetime.strptime(start, \'%Y-%m-%d %H:%M:%S\') end_time = datetime.strptime(end, \'%Y-%m-%d %H:%M:%S\') return (end_time - start_time).total_seconds() # Prepare a list to gather session info sessions = [] # Sort the log by user_id and timestamp activity_log_df = activity_log_df.sort_values(by=[\'user_id\', \'timestamp\']) # Iterate over each user for user_id, user_log_df in activity_log_df.groupby(\'user_id\'): # Initialize state variables for each user session_start = None session_end = None activities = [] activity_count = {} for index, row in user_log_df.iterrows(): timestamp = row[\'timestamp\'] activity = row[\'activity\'] if activity == \'login\': # If there\'s already an ongoing session, save it because a new one starts if session_start is not None: # Save the previous session session_duration = calculate_duration(session_start, session_end) sessions.append({ \'user_id\': user_id, \'session_start\': session_start, \'session_end\': session_end, \'session_duration\': session_duration, \'num_activities\': len(activities), \'activity_counts\': activity_count.copy() }) # Start a new session session_start = timestamp activities = [] activity_count = {} if session_start is not None: # Append activity details to the on-going session activities.append(activity) if activity in activity_count: activity_count[activity] += 1 else: activity_count[activity] = 1 # Update the session end time for each activity session_end = timestamp if activity == \'logout\' and session_start is not None: # Logout marks the end of the current session session_duration = calculate_duration(session_start, session_end) sessions.append({ \'user_id\': user_id, \'session_start\': session_start, \'session_end\': session_end, \'session_duration\': session_duration, \'num_activities\': len(activities), \'activity_counts\': activity_count.copy() }) # Reset for next session session_start = None activities = [] activity_count = {} # Convert the sessions list to a DataFrame sessions_df = pd.DataFrame(sessions) return sessions_df"},{"question":"Welcome to the world of matrix operations! In this exercise, you will write a function to perform matrix multiplication. The goal is to understand how to traverse and manipulate multi-dimensional arrays. In matrix multiplication, two matrices are multiplied together to form a new matrix. Each element of the resultant matrix is computed as the dot product of corresponding row from the first matrix and column from the second matrix. Your task is to write a function named `matrix_multiplication` that: 1. Takes two 2-dimensional lists (`matrix1` and `matrix2`) as arguments. 2. Ensures that the number of columns in `matrix1` matches the number of rows in `matrix2`. 3. Returns the product of the two matrices as a new 2-dimensional list. Here\'s a step-by-step breakdown: 1. Verify the dimensions of the matrices for multiplication compatibility. 2. Create an empty resultant matrix with the appropriate dimensions (rows of `matrix1` by columns of `matrix2`). 3. Iterate through rows of `matrix1` and columns of `matrix2` to calculate the dot product. 4. Populate the resultant matrix with the computed values. # Example: ```python def matrix_multiplication(matrix1, matrix2): rows_matrix1 = len(matrix1) cols_matrix1 = len(matrix1[0]) rows_matrix2 = len(matrix2) cols_matrix2 = len(matrix2[0]) if cols_matrix1 != rows_matrix2: raise ValueError(\\"Incompatible matrices for multiplication\\") result_matrix = [[0 for _ in range(cols_matrix2)] for _ in range(rows_matrix1)] for i in range(rows_matrix1): for j in range(cols_matrix2): for k in range(cols_matrix1): result_matrix[i][j] += matrix1[i][k] * matrix2[k][j] return result_matrix # Example usage matrix1 = [ [1, 2, 3], [4, 5, 6] ] matrix2 = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiplication(matrix1, matrix2) print(result) # Output: [[58, 64], [139, 154]] ``` This code should output the resultant matrix after multiplying `matrix1` by `matrix2`.","solution":"def matrix_multiplication(matrix1, matrix2): Multiplies two matrices (matrix1 and matrix2) and returns the resultant matrix. Raises ValueError if matrices are incompatible for multiplication. rows_matrix1 = len(matrix1) cols_matrix1 = len(matrix1[0]) rows_matrix2 = len(matrix2) cols_matrix2 = len(matrix2[0]) if cols_matrix1 != rows_matrix2: raise ValueError(\\"Incompatible matrices for multiplication\\") result_matrix = [[0 for _ in range(cols_matrix2)] for _ in range(rows_matrix1)] for i in range(rows_matrix1): for j in range(cols_matrix2): for k in range(cols_matrix1): result_matrix[i][j] += matrix1[i][k] * matrix2[k][j] return result_matrix # Example usage matrix1 = [ [1, 2, 3], [4, 5, 6] ] matrix2 = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiplication(matrix1, matrix2) print(result) # Output: [[58, 64], [139, 154]]"},{"question":"Write a function that reads a JSON configuration file and a list of environment variables, then merges the two into a single dictionary. If a key exists in both the JSON file and the environment variables, the value from the environment variables should take precedence. Ensure that the function raises an error if the JSON file does not exist or is empty, and the list of environment variables is also empty or missing. The function should output: ``` dict: A dictionary containing the merged configurations with environment variables taking precedence over the JSON file. ``` You should write self-contained code starting with: ``` import json import os def load_config(json_file, env_vars): ```","solution":"import json import os def load_config(json_file, env_vars): Reads a JSON configuration file and a list of environment variables, and merges the two into a single dictionary. Environment variables take precedence over the JSON file values. Parameters: - json_file: path to the JSON configuration file - env_vars: list of environment variable names to be merged Returns: - A dictionary containing merged configurations Raises: - FileNotFoundError if the JSON file does not exist - ValueError if the JSON file is empty or the env_vars list is empty or missing # Check if env_vars is valid if not env_vars: raise ValueError(\\"The list of environment variables is empty or missing.\\") try: with open(json_file, \'r\') as f: config = json.load(f) except FileNotFoundError: raise FileNotFoundError(f\\"The file {json_file} does not exist.\\") except json.JSONDecodeError: raise ValueError(f\\"The file {json_file} is empty or not a valid JSON.\\") # Merge environment variables for var in env_vars: env_value = os.getenv(var) if env_value is not None: config[var] = env_value return config"},{"question":"You are given a list of stock prices for a single stock on different days. Your task is to write a function `max_profit(prices)` that calculates the maximum possible profit from buying on one day and selling on another later day. If no profit is possible, return 0. **Function Details:** - **Function Name:** `max_profit` - **Input:** A list of integers, where each integer represents the stock price on a given day. - Example: `[7, 1, 5, 3, 6, 4]` - **Output:** An integer representing the maximum profit possible. If no profit can be made, return 0. **Requirements:** 1. Iterate through the list to identify the minimum buying price and the maximum selling price after the buying day. 2. Calculate the difference between the selling price and the buying price to find the profit. 3. Return the highest profit possible, or 0 if no profit can be made. **Example:** Given the list of stock prices: `[7, 1, 5, 3, 6, 4]` The function should return the highest possible profit, which in this case is `5` (buy on day 2 at price `1` and sell on day 5 at price `6`). **Example Usage:** ```python # Example Test Case print(max_profit([7, 1, 5, 3, 6, 4])) # Output: 5 print(max_profit([7, 6, 4, 3, 1])) # Output: 0 ``` You may assume that you have access to a helper function `calculate_diff`, which takes two prices and returns their difference. #","solution":"def max_profit(prices): Returns the maximum possible profit from buying and selling the stock on different days. If no profit is possible, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"Write a function that takes a string with words separated by spaces and returns a list of tuples where each tuple contains a word and its length. The function should consider punctuation marks as part of the words and preserve their positions. The function should start with: ``` def words_length(sentence): ```","solution":"def words_length(sentence): Takes a string with words separated by spaces and returns a list of tuples where each tuple contains a word and its length. # Split the sentence into words based on spaces words = sentence.split() # Create a list of tuples where each tuple is a word and its length words_with_length = [(word, len(word)) for word in words] return words_with_length"},{"question":"You are tasked with developing an automation tool for a book inventory management system used by a small bookstore. The bookstore maintains a text file where each line includes the title of a book, its author, the genre, and the available quantity, all separated by semicolons. Some book titles and authors might contain semicolons and will be enclosed in quotation marks. Your goal is to create a function `update_book_inventory(filename, updates)` that reads the inventory file, processes it, and updates the quantities based on a list of updates provided. The updates are in the form of tuples where the first element is the book title, and the second element is the quantity to add (can be negative if books were sold). # Your task: 1. Write the function `update_book_inventory(filename, updates)` where: - `filename`: A string representing the path to the text file containing the book inventory. - `updates`: A list of tuples in the form of `(book_title, quantity)`, where `book_title` corresponds to the title in the inventory, and `quantity` is an integer representing the change in quantity. 2. Read the file content and parse it, ensuring the book titles and authors are correctly interpreted even if they contain semicolons. 3. Update the quantities based on the provided list of updates. 4. Write the updated inventory back to the same file, maintaining the original format. Here is an example of how the data might look in the inventory file: ``` \\"Harry Potter; The Philosopher\'s Stone\\";J.K. Rowling;Fantasy;10 To Kill a Mockingbird;Harper Lee;Fiction;5 \\"The Great Gatsby\\";F. Scott Fitzgerald;Classic;2 ``` And an example of how to use `update_book_inventory(\'inventory.txt\', [(\'The Great Gatsby\', 3), (\'To Kill a Mockingbird\', -2)])` to update the quantities. After the function executes, the inventory file should be updated to: ``` \\"Harry Potter; The Philosopher\'s Stone\\";J.K. Rowling;Fantasy;10 To Kill a Mockingbird;Harper Lee;Fiction;3 \\"The Great Gatsby\\";F. Scott Fitzgerald;Classic;5 ``` # Constraints: - Assume that the input content is correctly formatted. - If an update is provided for a book title not present in the inventory, it should be ignored. - You should handle reading from and writing to the text file within the function using appropriate file handling mechanisms. - Use the `csv` module with `delimiter=\';\'` to handle parsing and writing the data, ensuring special cases like semicolons within quotes are properly managed.","solution":"import csv def update_book_inventory(filename, updates): # Read the inventory file with open(filename, mode=\'r\', newline=\'\', encoding=\'utf-8\') as file: reader = csv.reader(file, delimiter=\';\', quotechar=\'\\"\') inventory = list(reader) # Create a dict from the updates for quick lookup updates_dict = dict(updates) # Update the quantities for row in inventory: title = row[0].strip() if title in updates_dict: row[3] = str(int(row[3]) + updates_dict[title]) # Write the updated inventory back to the file with open(filename, mode=\'w\', newline=\'\', encoding=\'utf-8\') as file: writer = csv.writer(file, delimiter=\';\', quotechar=\'\\"\', quoting=csv.QUOTE_MINIMAL) writer.writerows(inventory)"},{"question":"Given an array of integers, you are to implement a function that finds a peak element in the array. A peak element is an element that is greater than its neighbors. In an array, the first and last elements are considered to have a single neighbor. For instance, for the first element, only the second element is considered its neighbor; for the last element, only the second last element is considered its neighbor. There may be multiple peak elements in the array, in which case you can return the index of any one of the peak elements. You need to implement the function `find_peak_element` which finds the index of any one peak element in the array. *Function Signature*: ```python def find_peak_element(nums: List[int]) -> int: ``` *Parameters*: - `nums` (List[int]): A list of integers representing the array. *Returns*: - An integer representing the index of any one peak element in the array. *Constraints*: - The array length will be at least 1. - If the array contains only one element, that element is by default a peak element. - The function should have a logarithmic time complexity. *Example*: ```python print(find_peak_element([1, 2, 3, 1])) # Output: 2 (The index of the value 3 which is a peak element) print(find_peak_element([1, 2, 1, 3, 5, 6, 4])) # Output: 5 (The index of the value 6 which is a peak element) ``` *Hints*: - Consider using a binary search approach to achieve logarithmic time complexity.","solution":"from typing import List def find_peak_element(nums: List[int]) -> int: Finds the index of a peak element in the array. A peak element is an element that is greater than its neighbors. def binary_search(left, right): if left == right: return left mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: return binary_search(left, mid) else: return binary_search(mid + 1, right) return binary_search(0, len(nums) - 1)"},{"question":"You are hired to develop a function that analyzes a numerical dataset and identifies trends in the data. Specifically, you need to write a function that identifies \\"local maxima\\" in a list of integers. A \\"local maximum\\" is defined as an element that is greater than its immediate neighbors. The first and last elements of the list can never be local maxima, as they do not have two neighbors. Your task is to implement the function `find_local_maxima` which takes a list of integers as input and returns a list of indices where the local maxima occur. **Function Signature:** ```python def find_local_maxima(data: list) -> list: pass ``` **Example Usage:** Suppose you have the following input: ```python data = [1, 3, 7, 1, 2, 6, 3, 2, 1] ``` After executing the function, you should expect: ```python local_maxima_indices = find_local_maxima(data) ``` A possible output might be: ``` [2, 5] # Indices of elements 7 and 6 ``` **Notes:** - The input list `data` is guaranteed to have at least three elements. - Adjacent elements are considered neighbors. - The function should be efficient with respect to both time and space complexity. - Make sure to handle edge cases such as multiple consecutive identical elements. #","solution":"def find_local_maxima(data): Finds local maxima in the dataset. Args: data (list of int): The input list of integers. Returns: list: The list of indices where local maxima occur. local_maxima_indices = [] # We ignore the first and last elements for i in range(1, len(data) - 1): if data[i] > data[i - 1] and data[i] > data[i + 1]: local_maxima_indices.append(i) return local_maxima_indices # Example Usage data = [1, 3, 7, 1, 2, 6, 3, 2, 1] local_maxima_indices = find_local_maxima(data) print(local_maxima_indices) # Output should be [2, 5] # Indices of elements 7 and 6"},{"question":"Given a URL, fetch the JSON data from the endpoint, transform it into a Pandas DataFrame, and calculate statistical summaries for its numeric columns. Additionally, visualize the distribution of one of the numeric columns using a histogram. The function should output: tuple: A tuple containing: - df_summary (pandas.DataFrame): Statistical summary of the DataFrame. - histogram (matplotlib.figure.Figure): A histogram plot of the specified numeric column. You should write self-contained code starting with: ``` import pandas as pd import matplotlib.pyplot as plt import requests def task_func(url, column_name): ```","solution":"import pandas as pd import matplotlib.pyplot as plt import requests def task_func(url, column_name): Fetch the JSON data from the given URL, transform it into a Pandas DataFrame, calculate statistical summaries for its numeric columns, and visualize the distribution of one of the numeric columns using a histogram. Args: - url (str): The URL to fetch the JSON data from. - column_name (str): The name of the numeric column to visualize in a histogram. Returns: - tuple: A tuple containing: - df_summary (pandas.DataFrame): Statistical summary of the DataFrame. - histogram (matplotlib.figure.Figure): A histogram plot of the specified numeric column. # Fetch the JSON data from the URL response = requests.get(url) data = response.json() # Transform the JSON data into a Pandas DataFrame df = pd.DataFrame(data) # Calculate statistical summaries for numeric columns df_summary = df.describe() # Create a histogram for the specified numeric column fig, ax = plt.subplots() df[column_name].hist(ax=ax, bins=30) ax.set_title(f\'Histogram of {column_name}\') ax.set_xlabel(column_name) ax.set_ylabel(\'Frequency\') plt.close(fig) # Close the figure to prevent it from being displayed in interactive environments return df_summary, fig"},{"question":"Write a Python function named `count_word_occurrences` that takes two arguments: `file_path`, a string representing the path to a text file, and `target_word`, a string representing the word to count. This function should read the file, count how many times `target_word` appears in the file (case insensitive), and return this count. Ensure the function handles any exceptions that might occur when trying to open and read the file, such as the file not existing, and print an appropriate error message in such cases. # Example Usage ```python count = count_word_occurrences(\'/path/to/textfile.txt\', \'example\') print(count) ``` If the word \\"example\\" appears 5 times in the file `/path/to/textfile.txt`, the function will return `5`. # Requirements - Use the `open` function to read the file. - Perform a case insensitive search for `target_word`. - Use exception handling to manage file I/O errors. # Detailed Library API Information - `open`: - `open(file, mode=\'r\', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`: Open file and return a corresponding file object. If the file cannot be opened, an `OSError` is raised. # Example Error Handling ```python try: with open(file_path, \'r\') as file: # process file except FileNotFoundError: print(f\\"Error: The file {file_path} does not exist.\\") except Exception as e: print(f\\"Error: {str(e)}\\") ```","solution":"def count_word_occurrences(file_path, target_word): Count the occurrences of target_word in the file at file_path (case insensitive). try: with open(file_path, \'r\', encoding=\'utf-8\') as file: content = file.read().lower() target_word_lower = target_word.lower() return content.split().count(target_word_lower) except FileNotFoundError: print(f\\"Error: The file {file_path} does not exist.\\") except Exception as e: print(f\\"Error: {str(e)}\\") return 0"},{"question":"In this problem, you are required to write a Python function to filter out common chocolates from two lists of chocolates and return a list of unique chocolates only present in one of the lists. Given two lists of chocolates, `list1` and `list2`, the function should identify chocolates that are unique to each list and combine these into a new list, which should then be sorted in alphabetical order. Function Name: `unique_chocolates` Parameters: - `list1`: list of strings, representing types of chocolates. - `list2`: list of strings, representing types of chocolates. Return: - A list of strings representing the unique chocolates, sorted alphabetically. Example: ```python def unique_chocolates(list1, list2): set1 = set(list1) set2 = set(list2) unique_to_list1 = set1 - set2 unique_to_list2 = set2 - set1 combined_unique = unique_to_list1.union(unique_to_list2) return sorted(combined_unique) # Example list1 = [\\"Mars\\", \\"Snickers\\", \\"Twix\\", \\"KitKat\\"] list2 = [\\"Snickers\\", \\"Galaxy\\", \\"Twix\\", \\"Dairy Milk\\"] print(unique_chocolates(list1, list2)) # Output: [\'Dairy Milk\', \'Galaxy\', \'KitKat\', \'Mars\'] ```","solution":"def unique_chocolates(list1, list2): Given two lists of chocolates, returns a list of unique chocolates that are present in only one of the lists, sorted alphabetically. set1 = set(list1) set2 = set(list2) unique_to_list1 = set1 - set2 unique_to_list2 = set2 - set1 combined_unique = unique_to_list1.union(unique_to_list2) return sorted(combined_unique)"},{"question":"Your task is to implement a function `continuous_subarray_sum(nums, k)` in Python that determines if the array has a continuous subarray of size at least two whose elements sum up to a multiple of `k`. The function should return `True` if such a contiguous subarray exists, and `False` otherwise. You are to consider both positive and negative integers in the array. Specifically, you should perform the following steps: 1. Initialize a dictionary to store the sum modulo `k` and its corresponding index. 2. Iterate through the array while keeping a running sum of the elements. 3. For each element, compute the running sum modulo `k`. 4. Check if the same modulo value has been seen before. If it has and the distance between the current index and the stored index is greater than or equal to 2, return `True`. 5. If the modulo value is not found and it\'s not at the initial position, store the current index. 6. If the loop completes without finding such a subarray, return `False`. Function Signature ```python def continuous_subarray_sum(nums, k): Determine if there exists a continuous subarray of at least two elements which sums to a multiple of k. Parameters: nums (List[int]): A list of integers. k (int): The integer to check for multiples of. Returns: bool: True if such a subarray exists, False otherwise. ``` Example Usage ```python # Sample input: continuous subarray with multiples of k nums = [23, 2, 4, 6, 7] k = 6 # The subarray [2, 4] sums to 6, which is a multiple of 6 print(continuous_subarray_sum(nums, k)) # Output: True # Sample input: no continuous subarray with multiples of k nums = [23, 2, 6, 4, 7] k = 13 # There is no subarray that sums to a multiple of 13 print(continuous_subarray_sum(nums, k)) # Output: False ```","solution":"def continuous_subarray_sum(nums, k): Determine if there exists a continuous subarray of at least two elements which sums to a multiple of k. Parameters: nums (List[int]): A list of integers. k (int): The integer to check for multiples of. Returns: bool: True if such a subarray exists, False otherwise. if k == 0: return any(nums[i] == 0 and nums[i + 1] == 0 for i in range(len(nums) - 1)) sum_modulo = {0: -1} # Initialize with remainder 0 and index -1 to handle the edge case cumulative_sum = 0 for i, num in enumerate(nums): cumulative_sum += num mod_value = cumulative_sum % k if mod_value in sum_modulo: if i - sum_modulo[mod_value] > 1: return True else: sum_modulo[mod_value] = i return False"},{"question":"In this programming task, you will create a function called `calculate_statistics` that processes a list of integers to compute several statistical measures. This function will utilize Python\'s built-in libraries for efficient computation. The `calculate_statistics` function should accept a list of integers and return a dictionary containing the following statistics: 1. `mean`: The average of the numbers in the list. 2. `median`: The middle value when the numbers in the list are sorted. If there is an even number of observations, the median is the average of the two middle numbers. 3. `mode`: The most frequent number(s) in the list. If there are multiple numbers with the same highest frequency, return all of them in a list. 4. `variance`: The variance of the numbers in the list, which measures the dispersion of the data. Compute it as the sum of squared differences from the mean, divided by the number of elements. Here\'s a precise description of what your function should do: 1. Calculate the `mean` as the sum of the list divided by the number of elements. 2. Calculate the `median` by sorting the list and finding the middle value(s). 3. Calculate the `mode` using the `collections.Counter` to count the frequency of each number, and return the number(s) with the highest frequency. 4. Calculate the `variance` by summing the squared differences between each number and the mean, then dividing by the number of elements. Utilize the following Python libraries and functions: - `statistics.mean` and `statistics.median` for mean and median calculations. - `collections.Counter` for mode calculation. - `math` library functions if necessary for variance calculation. Your task is to implement the `calculate_statistics` function correctly following the guidelines above.","solution":"import statistics from collections import Counter def calculate_statistics(numbers): Returns a dictionary with statistical measures (mean, median, mode, variance) of the numbers in the list. if not numbers: return {} # Calculate mean mean_value = statistics.mean(numbers) # Calculate median median_value = statistics.median(numbers) # Calculate mode(s) count = Counter(numbers) max_frequency = max(count.values()) mode_list = [k for k, v in count.items() if v == max_frequency] # Calculate variance variance_value = sum((x - mean_value) ** 2 for x in numbers) / len(numbers) return { \\"mean\\": mean_value, \\"median\\": median_value, \\"mode\\": mode_list if len(mode_list) > 1 else mode_list[0], \\"variance\\": variance_value }"},{"question":"You are given a large dataset represented as a DataFrame containing information about various books, including their `title`, `author`, `genre`, `pages` (number of pages), and `ratings` (average user rating out of 5). Your task is to write a function `book_summary(df)` which performs the following operations on this DataFrame: 1. Calculate the average number of pages for books in each genre. 2. Find the book with the highest rating in each genre. 3. Determine the top 3 authors with the most books in the dataset. 4. Plot a bar chart showing the average number of pages for each genre. The bar chart should: - have the title \\"Average Number of Pages by Genre\\", - have the x-axis labeled as \\"Genre\\", - have the y-axis labeled as \\"Average Number of Pages\\", - display each bar corresponding to different genres, - have genre names labeled appropriately on the x-axis. Please use the `matplotlib.pyplot.show` API to display the bar chart. Here is the starting point of the function: ```python def book_summary(df): import pandas as pd import matplotlib.pyplot as plt # Your code starts here ``` Use the following DataFrame structure: - `title`: Column containing the titles of the books. - `author`: Column containing the authors of the books. - `genre`: Column containing the genres of the books. - `pages`: Column containing the number of pages. - `ratings`: Column containing the average user ratings of the books.","solution":"def book_summary(df): import pandas as pd import matplotlib.pyplot as plt # Calculate the average number of pages for books in each genre avg_pages_by_genre = df.groupby(\'genre\')[\'pages\'].mean().reset_index(name=\'average_pages\') # Find the book with the highest rating in each genre idx = df.groupby(\'genre\')[\'ratings\'].idxmax() highest_rated_books = df.loc[idx] # Determine the top 3 authors with the most books in the dataset top_authors = df[\'author\'].value_counts().head(3).reset_index(name=\'book_count\').rename(columns={\'index\': \'author\'}) # Plot a bar chart showing the average number of pages for each genre plt.figure(figsize=(10, 6)) plt.bar(avg_pages_by_genre[\'genre\'], avg_pages_by_genre[\'average_pages\']) plt.xlabel(\'Genre\') plt.ylabel(\'Average Number of Pages\') plt.title(\'Average Number of Pages by Genre\') plt.xticks(rotation=45) plt.show() return avg_pages_by_genre, highest_rated_books, top_authors"},{"question":"You are tasked with creating a function `merge_and_sort_dicts` that merges two dictionaries into a new dictionary and sorts the combined dictionary by its values. The function should take two arguments: 1. `dict1`: The first dictionary to merge. 2. `dict2`: The second dictionary to merge. The function should perform the following steps: 1. Merge the two dictionaries. If there are duplicate keys, the values from `dict2` should overwrite those from `dict1`. 2. Sort the combined dictionary by values in ascending order. 3. Return the sorted dictionary. Note that the original dictionaries should not be modified. **Function Signature** ```python def merge_and_sort_dicts(dict1, dict2): pass ``` **Requirements and Constraints** - Handle dictionaries containing any type of sortable values (integers, floats, strings, etc.). - The resulting dictionary should maintain key-value pairs and be sorted by values. - The dictionaries may contain keys of any hashable type, but assume the combined dictionary can fit into memory.","solution":"def merge_and_sort_dicts(dict1, dict2): Merges two dictionaries and sorts the combined dictionary by its values in ascending order. # Merge the dictionaries. If there are duplicate keys, dict2\'s values overwrite dict1\'s values. combined_dict = {**dict1, **dict2} # Sort the combined dictionary by its values in ascending order and return it as a dictionary. sorted_dict = dict(sorted(combined_dict.items(), key=lambda item: item[1])) return sorted_dict"},{"question":"Create a function named `visualize_newton_method()` that demonstrates the Newton-Raphson method for finding the roots of the function ( f(x) = x^3 - 6x^2 + 11x - 6 ) using `matplotlib`. You will: 1. Collect an initial guess from the user. 2. Implement the Newton-Raphson method to iteratively find the root. 3. Plot the function ( f(x) ) within the range ([-2, 4]). 4. Animate the iterative steps on the plot starting from the initial guess, showing the tangent lines and the moving guess point until the method converges. The function should: - Request the initial guess from the user using `input`. - Plot the curve of the function ( f(x) ) within the specified range. - Highlight the current guess point in red on the plot. - Draw the tangent line at the current guess point. - Update and animate the position of the guess point iteratively until convergence, based on the Newton-Raphson update formula ( x_{n+1} = x_n - frac{f(x_n)}{f\'(x_n)} ). - Use \'matplotlib.pyplot.show\', \'matplotlib.pyplot.plot\', \'matplotlib.pyplot.scatter\', and \'matplotlib.pyplot.annotate\' meaningfully in the code. **Example Function Call:** ```python visualize_newton_method() ```","solution":"import numpy as np import matplotlib.pyplot as plt def f(x): Returns the function value of x^3 - 6x^2 + 11x - 6. return x**3 - 6*x**2 + 11*x - 6 def f_prime(x): Returns the derivative function value of 3x^2 - 12x + 11. return 3*x**2 - 12*x + 11 def newton_raphson(x0, tol=1e-6, max_iter=100): Implement the Newton-Raphson method. x = x0 iter_count = 0 history = [x] while abs(f(x)) > tol and iter_count < max_iter: x = x - f(x)/f_prime(x) history.append(x) iter_count += 1 return x, history def visualize_newton_method(): initial_guess = float(input(\\"Enter an initial guess: \\")) # Generate data points for plotting the function x = np.linspace(-2, 4, 400) y = f(x) # Get the root and history using Newton-Raphson method root, history = newton_raphson(initial_guess) # Set up the plot plt.figure(figsize=[10, 6]) plt.plot(x, y, label=r\'f(x) = x^3 - 6x^2 + 11x - 6\', color=\'blue\') plt.axhline(0, color=\'black\', linewidth=0.5) plt.axvline(0, color=\'black\', linewidth=0.5) # Animate the iterative steps for i, x_n in enumerate(history[:-1]): tangent_slope = f_prime(x_n) intercept = f(x_n) - tangent_slope * x_n tangent_line = tangent_slope * x + intercept plt.plot(x, tangent_line, linestyle=\'--\', color=\'red\', alpha=0.7) plt.scatter(x_n, f(x_n), color=\\"red\\", zorder=5) plt.annotate(f\'iter {i}\', xy=(x_n, f(x_n)), textcoords=\\"offset points\\", xytext=(0,10), ha=\'center\') # Highlight the final root plt.scatter(history[-1], f(history[-1]), color=\\"green\\", zorder=5) plt.annotate(f\'Rootn({history[-1]:.6f}, {f(history[-1]):.6f})\', xy=(history[-1], f(history[-1])), textcoords=\\"offset points\\", xytext=(0,10), ha=\'center\') plt.legend() plt.title(\\"Newton-Raphson Method Visualization\\") plt.xlabel(\\"x\\") plt.ylabel(\\"f(x)\\") plt.show()"},{"question":"In this problem, you are asked to write a function, `find_substring_occurrences`, which takes a string `s` and a substring `sub`. The function should return the number of times `sub` appears as a substring in `s`, without using any built-in string search functions such as `str.find()`, `str.count()`, or regexes. **Requirements:** 1. The function should be named `find_substring_occurrences`. 2. You must iterate over the string `s` manually. 3. Ensure to handle overlapping occurrences of `sub`. **Function Signature:** ```python def find_substring_occurrences(s: str, sub: str) -> int: pass ``` **Example Usage:** ```python >>> find_substring_occurrences(\'abababa\', \'aba\') 3 >>> find_substring_occurrences(\'aaaaaaa\', \'aa\') 6 ```","solution":"def find_substring_occurrences(s: str, sub: str) -> int: Returns the number of times `sub` appears as a substring in `s`. count = 0 sub_len = len(sub) for i in range(len(s) - sub_len + 1): if s[i:i + sub_len] == sub: count += 1 return count"},{"question":"Write a Python function named `process_transactions()` that reads a CSV file named \\"transactions.csv\\" and returns the total revenue. Each row in the file represents a transaction and contains three columns: \'product_id\', \'quantity\', and \'unit_price\'. The `quantity` column indicates the number of units sold and the `unit_price` represents the price of a single unit. Use the `pandas` library to read the CSV file and perform the necessary calculations. Your function should also handle cases where the CSV file does not exist or if any required column is missing by raising appropriate exceptions.","solution":"import pandas as pd import os def process_transactions(): Reads the \\"transactions.csv\\" file and returns the total revenue. If the file does not exist or any required column is missing, raises appropriate exceptions. file_path = \'transactions.csv\' if not os.path.exists(file_path): raise FileNotFoundError(f\\"The file {file_path} does not exist.\\") df = pd.read_csv(file_path) # Check if required columns are present required_columns = {\'product_id\', \'quantity\', \'unit_price\'} if not required_columns.issubset(df.columns): raise KeyError(f\\"One or more required columns {required_columns} are missing from the CSV file.\\") # Calculate total revenue df[\'quantity\'] = pd.to_numeric(df[\'quantity\'], errors=\'coerce\') df[\'unit_price\'] = pd.to_numeric(df[\'unit_price\'], errors=\'coerce\') total_revenue = (df[\'quantity\'] * df[\'unit_price\']).sum() return total_revenue"},{"question":"You are asked to write a Python function named `find_nearest_points` that identifies the pair of points in a 2D plane which are closest to each other. Your function should use a brute-force algorithm to ensure the pair with the minimum distance is found. **Function Specification:** **Function Name:** `find_nearest_points` **Parameters:** - `points`: A list of tuples, where each tuple contains two integers representing the x and y coordinates of a point on a 2D plane. **Returns:** - A tuple of two tuples, representing the pair of points closest to each other. **Details:** 1. The function should iterate through all possible pairs of points and calculate the Euclidean distance between them. 2. The Euclidean distance between two points (x1, y1) and (x2, y2) is given by: [ sqrt{(x2 - x1)^2 + (y2 - y1)^2} ] 3. The function should return the pair of points with the smallest distance between them. 4. If there are multiple pairs with the same minimum distance, return any one of them. 5. Handle edge cases where there are fewer than two points by raising a `ValueError`. Here is an example call to the function with sample points: `[(3, 4), (1, 1), (5, 1), (4, 0), (2, 3)]`. The expected result is `((3, 4), (2, 3))` or any other pair with the minimum distance of approximately 1.41. **Required Libraries**: - `math.sqrt`","solution":"import math def find_nearest_points(points): Identifies the pair of points in a 2D plane which are closest to each other using a brute-force algorithm. Parameters: points (list of tuples): List of tuples, each tuple contains two integers representing the x and y coordinates of a point on a 2D plane. Returns: tuple: A tuple of two tuples, representing the pair of points closest to each other. Raises: ValueError: If fewer than two points are provided. if len(points) < 2: raise ValueError(\\"At least two points are required\\") min_distance = float(\\"inf\\") closest_pair = (None, None) for i in range(len(points)): for j in range(i + 1, len(points)): point1 = points[i] point2 = points[j] distance = math.sqrt((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2) if distance < min_distance: min_distance = distance closest_pair = (point1, point2) return closest_pair"},{"question":"In this problem, you are required to implement a function named `find_magic_index` that determines if there is a magic index in a given array. A magic index in an array `A[0...n-1]` is defined as an index such that `A[i] = i`. The function should return the index if found, otherwise, it should return `-1`. To achieve this, the array provided will be a sorted array of distinct integers, which allows you to solve this problem efficiently using a modified binary search algorithm. You need to implement the function `find_magic_index(arr)`: Function Signature ```python def find_magic_index(arr: List[int]) -> int: ``` Parameters - `arr` (List[int]): A sorted list of distinct integers. Returns - `index` (int): The magic index if found, otherwise `-1`. # Detailed Procedure 1. **Binary Search**: Use a modified version of binary search to efficiently find the magic index. 2. **Initial Checks**: If the array is empty, immediately return `-1`. 3. **Search Logic**: During the binary search process, check if the middle element is the magic index. If `arr[mid]` is equal to `mid`, return `mid`. If `arr[mid]` is greater than `mid`, search the left half of the array. If `arr[mid]` is less than `mid`, search the right half of the array. 4. **No Magic Index**: If the loop completes without finding a magic index, return `-1`. # Example ```python arr = [-1, 0, 2, 4, 5] magic_index = find_magic_index(arr) print(magic_index) ``` Would output: ```python 2 ``` Since `arr[2] = 2`, index `2` is a magic index. Another example: ```python arr = [1, 2, 3, 4, 5] magic_index = find_magic_index(arr) print(magic_index) ``` Would output: ```python -1 ``` since no index `i` satisfies `arr[i] = i`. # Note: Do not forget to import the necessary `List` type from the `typing` library.","solution":"from typing import List def find_magic_index(arr: List[int]) -> int: def binary_search(arr, start, end): if start > end: return -1 mid = (start + end) // 2 if arr[mid] == mid: return mid elif arr[mid] > mid: return binary_search(arr, start, mid - 1) else: return binary_search(arr, mid + 1, end) return binary_search(arr, 0, len(arr) - 1)"},{"question":"You are tasked to create a class `SimpleDatabase` that simulates a basic in-memory database using Python dictionaries. The class should support the following operations: setting a value, getting a value, deleting a value, and counting the number of occurrences of a given value in the database. The class should have the following methods: - `__init__(self)`: Initializes an empty database. - `set(self, key: str, value: int) -> None`: Stores the given value under the given key. - `get(self, key: str) -> Optional[int]`: Returns the value associated with the given key or `None` if the key is not present in the database. - `delete(self, key: str) -> None`: Removes the key and its corresponding value from the database if the key exists. If the key doesn\'t exist, do nothing. - `count(self, value: int) -> int`: Returns the number of keys that have the given value. The `SimpleDatabase` class should manage the internal data using a dictionary for key-value pairs and another dictionary for counting the occurrences of each value. **Examples:** ```python db = SimpleDatabase() db.set(\'a\', 1) db.set(\'b\', 2) db.set(\'c\', 1) print(db.get(\'a\')) # Output: 1 print(db.get(\'b\')) # Output: 2 print(db.get(\'c\')) # Output: 1 print(db.get(\'d\')) # Output: None print(db.count(1)) # Output: 2 print(db.count(2)) # Output: 1 print(db.count(3)) # Output: 0 db.delete(\'a\') print(db.get(\'a\')) # Output: None print(db.count(1)) # Output: 1 db.delete(\'a\') # Should not affect the database ``` **Requirements:** - Handle all operations in constant time on average (O(1)). - Ensure the class appropriately manages values and counts when keys are updated or deleted. - Include proper error handling for edge cases (e.g., deleting a non-existing key). Here\'s how the class might be implemented: ```python class SimpleDatabase: def __init__(self): self.db = {} self.value_count = {} def set(self, key: str, value: int) -> None: if key in self.db: old_value = self.db[key] self.value_count[old_value] -= 1 if self.value_count[old_value] == 0: del self.value_count[old_value] self.db[key] = value if value in self.value_count: self.value_count[value] += 1 else: self.value_count[value] = 1 def get(self, key: str) -> Optional[int]: return self.db.get(key) def delete(self, key: str) -> None: if key in self.db: old_value = self.db.pop(key) self.value_count[old_value] -= 1 if self.value_count[old_value] == 0: del self.value_count[old_value] def count(self, value: int) -> int: return self.value_count.get(value, 0) ```","solution":"from typing import Optional class SimpleDatabase: def __init__(self): self.db = {} self.value_count = {} def set(self, key: str, value: int) -> None: if key in self.db: old_value = self.db[key] self.value_count[old_value] -= 1 if self.value_count[old_value] == 0: del self.value_count[old_value] self.db[key] = value if value in self.value_count: self.value_count[value] += 1 else: self.value_count[value] = 1 def get(self, key: str) -> Optional[int]: return self.db.get(key) def delete(self, key: str) -> None: if key in self.db: old_value = self.db.pop(key) self.value_count[old_value] -= 1 if self.value_count[old_value] == 0: del self.value_count[old_value] def count(self, value: int) -> int: return self.value_count.get(value, 0)"},{"question":"You are tasked with writing a function that determines if two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. The function should meet the following specifications: - **Name of the function:** `are_anagrams` - **Parameters:** - `str1` (str): The first string to check. - `str2` (str): The second string to check. - **Returns:** A boolean value (True or False) indicating whether the two strings are anagrams of each other. Your solution should ignore spaces and be case-insensitive. You can assume that the input strings will contain only alphabetic characters and spaces. To facilitate the implementation, you can use Python\'s `str.lower()` for case insensitivity and `str.replace()` to handle spaces. Further, you can use collections module to handle count dynamics. Refer to the documentation snippets provided for these methods: 1. **str.lower:** ``` Python Library Documentation: method lower in str str.lower = lower(self, /) Return a copy of the string with all the cased characters converted to lowercase. ``` 2. **str.replace:** ``` Python Library Documentation: method replace in str str.replace = replace(self, old, new, count=-1, /) Return a copy with all occurrences of substring old replaced by new. ``` 3. **collections.Counter:** ``` Python Library Documentation: class Counter in collections collections.Counter = Counter(*args, **kwargs) Dict subclass for counting hashable items. Examples: >>> Counter(\'abracadabra\').most_common(3) [(\'a\', 5), (\'b\', 2), (\'r\', 2)] ```","solution":"from collections import Counter def are_anagrams(str1, str2): Determine if two strings are anagrams of each other. Args: str1 (str): The first string to check. str2 (str): The second string to check. Returns: bool: True if the two strings are anagrams, False otherwise. # Prepare both strings by converting to lowercase and removing spaces clean_str1 = str1.replace(\\" \\", \\"\\").lower() clean_str2 = str2.replace(\\" \\", \\"\\").lower() # Use Counter to count the occurrence of each character return Counter(clean_str1) == Counter(clean_str2)"},{"question":"You are tasked with creating a text-based user authentication system in Python. The system will manage user accounts including registration, login, and password change functionalities. The function you need to create is called `UserAuthSystem`. This class should: 1. Maintain user data using an appropriate data structure (e.g., a dictionary) where the username is the key, and the corresponding password is the value. 2. Provide the following methods: - `register(username: str, password: str) -> str`: Adds a new user with the specified username and password. If the username already exists, return \\"Username already exists\\". Otherwise, return \\"User registered successfully\\". - `login(username: str, password: str) -> str`: Authenticates a user with the given username and password. If the username doesn\'t exist, return \\"User not found\\". If the password is incorrect, return \\"Incorrect password\\". Otherwise, return \\"Login successful\\". - `change_password(username: str, old_password: str, new_password: str) -> str`: Allows a user to change their password. If the username doesn\'t exist, return \\"User not found\\". If the old password is incorrect, return \\"Incorrect password\\". If the password is successfully changed, return \\"Password changed successfully\\". # Function Signature: ```python class UserAuthSystem: def __init__(self): pass def register(self, username: str, password: str) -> str: pass def login(self, username: str, password: str) -> str: pass def change_password(self, username: str, old_password: str, new_password: str) -> str: pass ``` # Example usage: ```python auth_system = UserAuthSystem() print(auth_system.register(\'alice\', \'password123\')) # Output: \\"User registered successfully\\" print(auth_system.register(\'alice\', \'password456\')) # Output: \\"Username already exists\\" print(auth_system.login(\'alice\', \'password123\')) # Output: \\"Login successful\\" print(auth_system.login(\'bob\', \'password123\')) # Output: \\"User not found\\" print(auth_system.login(\'alice\', \'wrongpassword\')) # Output: \\"Incorrect password\\" print(auth_system.change_password(\'alice\', \'password123\', \'newpassword\')) # Output: \\"Password changed successfully\\" print(auth_system.change_password(\'alice\', \'wrongpassword\', \'newpassword\')) # Output: \\"Incorrect password\\" ``` # Additional Notes: - **Hint**: Use a dictionary to store user data. - **Security Note**: For the purpose of this task, storing passwords in plain text is acceptable. However, in real-world applications, always use proper password hashing techniques.","solution":"class UserAuthSystem: def __init__(self): self.users = {} def register(self, username: str, password: str) -> str: if username in self.users: return \\"Username already exists\\" self.users[username] = password return \\"User registered successfully\\" def login(self, username: str, password: str) -> str: if username not in self.users: return \\"User not found\\" if self.users[username] != password: return \\"Incorrect password\\" return \\"Login successful\\" def change_password(self, username: str, old_password: str, new_password: str) -> str: if username not in self.users: return \\"User not found\\" if self.users[username] != old_password: return \\"Incorrect password\\" self.users[username] = new_password return \\"Password changed successfully\\""},{"question":"You are required to create a utility function that flattens a nested dictionary into a single-level dictionary with keys representing the path to the corresponding values in the nested structure. The function should handle dictionaries with arbitrary depth. The function should be named `flatten_dict` and take a single argument `d`, which is the nested dictionary. The keys in the resulting dictionary should be the concatenation of keys from each level of nesting, separated by a specified delimiter, which defaults to a period (`.`). Optionally, an additional parameter called `delimiter` can be passed to customize the separator used in the keys. Here\'s the breakdown of the task: 1. Implement the `flatten_dict` function. 2. Use recursion to traverse the nested dictionary and build the path for each value. 3. Concatenate the keys from each level using the specified delimiter to form the keys in the flattened dictionary. 4. The function should handle edge cases such as empty dictionaries or non-dictionary values at various levels of nesting. Example Implementation: ```python def flatten_dict(d, parent_key=\'\', delimiter=\'.\'): items = {} for k, v in d.items(): new_key = f\\"{parent_key}{delimiter}{k}\\" if parent_key else k if isinstance(v, dict): items.update(flatten_dict(v, new_key, delimiter=delimiter)) else: items[new_key] = v return items ``` Example Usage: ```python nested_dict = { \'a\': { \'b\': { \'c\': 1, \'d\': 2 }, \'e\': 3 }, \'f\': 4 } flattened = flatten_dict(nested_dict) print(flattened) # Output: {\'a.b.c\': 1, \'a.b.d\': 2, \'a.e\': 3, \'f\': 4} custom_delim_flattened = flatten_dict(nested_dict, delimiter=\'/\') print(custom_delim_flattened) # Output: {\'a/b/c\': 1, \'a/b/d\': 2, \'a/e\': 3, \'f\': 4} ```","solution":"def flatten_dict(d, parent_key=\'\', delimiter=\'.\'): Flattens a nested dictionary into a single-level dictionary with keys representing the path to the corresponding values in the nested structure. Args: d (dict): The nested dictionary to flatten. parent_key (str, optional): The base key for the current level of nesting. Defaults to \'\'. delimiter (str, optional): The separator for concatenating keys. Defaults to \'.\'. Returns: dict: A single-level dictionary with concatenated keys. items = {} for k, v in d.items(): new_key = f\\"{parent_key}{delimiter}{k}\\" if parent_key else k if isinstance(v, dict): items.update(flatten_dict(v, new_key, delimiter=delimiter)) else: items[new_key] = v return items"},{"question":"Sort Nested List You are required to create a function `sort_nested_list(nested_list:List[List[int]]) -> List[List[int]]` that sorts each sublist within a nested list in ascending order. # Function Requirements: 1. **Input**: - `nested_list` (List[List[int]]): A list containing multiple sublists; each sublist contains integers. 2. **Function Behavior**: - The function should sort each sublist in ascending order. - The function should return a new nested list with each sublist being sorted. # Assumptions: - The nested list is non-empty. - Each sublist within the nested list may vary in length. # Constraints: - Utilize nested list comprehensions, built-in list methods, or sorting algorithms for sorting each sublist. - Do not use external libraries for sorting. # Example Usage: ```python sort_nested_list([[3, 1, 2], [4, 6, 5], [7, 9, 8]]) ``` The function should return: ```python [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` ```python sort_nested_list([[10, 5], [1], [8, 6, 7]]) ``` The function should return: ```python [[5, 10], [1], [6, 7, 8]] ```","solution":"from typing import List def sort_nested_list(nested_list: List[List[int]]) -> List[List[int]]: Sorts each sublist within a nested list in ascending order. Parameters: nested_list (List[List[int]]): A list containing multiple sublists; each sublist contains integers. Returns: List[List[int]]: A new nested list with each sublist sorted in ascending order. return [sorted(sublist) for sublist in nested_list]"},{"question":"This function computes the Fibonacci sequence to the nth term using dynamic programming principles. It maintains a list to store previously computed values to optimize the computation process and avoid redundant calculations. The function should handle invalid inputs gracefully by returning an error message for non-positive integers. The function should output: int: The nth Fibonacci number. You should write self-contained code starting with: ``` def fibonacci(n): ```","solution":"def fibonacci(n): Returns the nth Fibonacci number using dynamic programming principles. Parameters: n (int): The position in the Fibonacci sequence to retrieve. Returns: int: The nth Fibonacci number or an error message for non-positive integers. if not isinstance(n, int) or n <= 0: return \\"Error: Input should be a positive integer.\\" # Base cases if n == 1: return 0 elif n == 2: return 1 # List to store Fibonacci numbers fib_seq = [0, 1] # Compute the Fibonacci sequence up to the nth term for i in range(2, n): fib_seq.append(fib_seq[-1] + fib_seq[-2]) return fib_seq[-1]"},{"question":"**Context:** Travelling Salesman Problem (TSP) is a well-known problem in combinatorial optimization. The goal is to find the shortest possible route that visits each city exactly once and returns to the origin city. Instead of finding the exact solution, a common approach is to use a heuristic algorithm to find an approximate solution. **Objective:** Write a function named `nearest_neighbor_tsp` that takes the following argument: - `cities`: a dictionary where keys are city names and values are tuples representing the coordinates (x, y) of the cities. The function should: 1. Start from any city (you can pick the first city in the dictionary as the starting point). 2. Use the nearest neighbor heuristic to construct a tour: at each step, choose the nearest unvisited city to travel to next. 3. Return the tour as a list of city names in the order they are visited. **Requirements:** - Use the `math.dist` function to calculate the Euclidean distance between two cities. **Example:** ```python cities = { \'A\': (0, 0), \'B\': (1, 2), \'C\': (4, 3), \'D\': (6, 1) } # The function should return a list with the tour visiting all cities in a near-optimal order. # Example output (actual output may vary depending on the implementation of nearest neighbor heuristic): # [\'A\', \'B\', \'C\', \'D\'] ```","solution":"import math def nearest_neighbor_tsp(cities): Solves the TSP using the nearest neighbor heuristic. Parameters: cities (dict): A dictionary where keys are city names and values are tuples of coordinates (x, y). Returns: list: A list of city names in the order they are visited. if not cities: return [] start_city = next(iter(cities)) unvisited = set(cities.keys()) tour = [start_city] unvisited.remove(start_city) current_city = start_city while unvisited: nearest_city = min(unvisited, key=lambda city: math.dist(cities[current_city], cities[city])) tour.append(nearest_city) unvisited.remove(nearest_city) current_city = nearest_city return tour"},{"question":"Write a function to generate a list of dictionaries representing a collection of books. Each dictionary should contain the keys \'Title\', \'Author\', \'Genre\', and \'Price\'. \'Title\' and \'Author\' should be randomly selected from given lists, \'Genre\' should be a random choice from a specified list of genres, and \'Price\' should be a float rounded to two decimal places between 5.99 and 49.99. Ensure that the combination of \'Title\' and \'Author\' is unique within the list. Set a random seed for reproducibility. The function should output a list of dictionaries with: - \'Title\': Randomly chosen from a predefined list of book titles. - \'Author\': Randomly chosen from a predefined list of authors. - \'Genre\': Randomly chosen from a list of genres. - \'Price\': Random float value between 5.99 and 49.99 inclusive, rounded to two decimal places. The code should start with: ``` import random def generate_books(num_books, random_seed=42): ``` Example usage of the function: ``` titles = [\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\"] authors = [\\"F. Scott Fitzgerald\\", \\"George Orwell\\", \\"Harper Lee\\", \\"Jane Austen\\"] genres = [\\"Fiction\\", \\"Science Fiction\\", \\"Historical Fiction\\", \\"Romance\\"] ``` Sample Output: ``` [ {\'Title\': \'1984\', \'Author\': \'George Orwell\', \'Genre\': \'Science Fiction\', \'Price\': 29.99}, {\'Title\': \'The Great Gatsby\', \'Author\': \'F. Scott Fitzgerald\', \'Genre\': \'Fiction\', \'Price\': 19.99}, # More dictionaries... ] ```","solution":"import random def generate_books(num_books, random_seed=42): Generate a list of dictionaries representing a collection of books. Args: - num_books (int): The number of books to generate. - random_seed (int, optional): Seed for the random number generator. Defaults to 42. Returns: - list of dict: A list of dictionaries, each representing a book with unique Title-Author combination. titles = [\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"The Catcher in the Rye\\", \\"Moby-Dick\\", \\"War and Peace\\", \\"The Odyssey\\", \\"Crime and Punishment\\", \\"The Brothers Karamazov\\"] authors = [\\"F. Scott Fitzgerald\\", \\"George Orwell\\", \\"Harper Lee\\", \\"Jane Austen\\", \\"J.D. Salinger\\", \\"Herman Melville\\", \\"Leo Tolstoy\\", \\"Homer\\", \\"Fyodor Dostoevsky\\", \\"Gustave Flaubert\\"] genres = [\\"Fiction\\", \\"Science Fiction\\", \\"Historical Fiction\\", \\"Romance\\", \\"Thriller\\", \\"Fantasy\\", \\"Mystery\\"] random.seed(random_seed) books = [] combinations = set() while len(books) < num_books: title = random.choice(titles) author = random.choice(authors) if (title, author) not in combinations: genre = random.choice(genres) price = round(random.uniform(5.99, 49.99), 2) books.append({\'Title\': title, \'Author\': author, \'Genre\': genre, \'Price\': price}) combinations.add((title, author)) return books"},{"question":"You need to implement a function called `reverseWords` that reverses the order of words in a given string. A word is defined as a sequence of non-space characters. The function should preserve the spaces that appear before and after the words in the string and only reverse the order of the words. The function signature is as follows: ```python def reverseWords(input_string): # Your code here ``` **Parameters:** - `input_string` (str): A string representing a sentence with words separated by whitespace characters. **Returns:** - `str`: A new string with the words in reverse order, maintaining the original whitespace formatting. **Instructions:** 1. Split the input string into words using `str.split()`, which automatically handles multiple spaces. 2. Reverse the list of words. 3. Join the reversed list of words back into a string using `\' \'.join()`. 4. Ensure to handle edge cases such as empty strings or strings with only spaces. **Example:** ```python input_string = \\" hello world! \\" reversed_string = reverseWords(input_string) print(reversed_string) # Should print \\" world! hello \\" ``` **Note:** - Pay attention to the spaces before and after the words, ensuring they remain in their original positions relative to the words.","solution":"def reverseWords(input_string): Reverses the order of words in the input string, preserving the spaces. Parameters: - input_string (str): The string containing the sentence to reverse. Returns: - str: A new string with the words in reverse order. if not input_string.strip(): # Check for empty string or string with only spaces return input_string # Split the input string by spaces words = input_string.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed words back into a string with a single space between them reversed_string = \' \'.join(reversed_words) # Find the leading and trailing spaces in the original string leading_spaces = len(input_string) - len(input_string.lstrip()) trailing_spaces = len(input_string) - len(input_string.rstrip()) # Reconstruct the final string with the preserved spaces return \' \' * leading_spaces + reversed_string + \' \' * trailing_spaces"},{"question":"You are tasked with writing a function that takes a list of integers and returns the maximum sum of non-adjacent elements. This type of problem is common in dynamic programming, where the challenge is to derive an optimal solution by breaking down the problem into simpler subproblems. Specifically, you need to implement a function called `max_sum_non_adjacent(arr)`. This function should take a list of integers `arr` and return an integer representing the maximum sum of the list\'s non-adjacent elements. Note that two elements are considered adjacent if they are consecutive in the list, and the problem should be solved efficiently to handle larger input sizes. The following requirements must be met: 1. The function should work for both positive and negative integers in the list. 2. You cannot use two consecutive elements to form the sum. 3. If the list is empty, the function should return 0. 4. If the list has only one element, the function should return that element. **Function Signature:** ```python def max_sum_non_adjacent(arr): # Your code here ``` **Example:** ```python >>> max_sum_non_adjacent([3, 2, 5, 10, 7]) 15 # Choosing 3, 10, and 7 yields the maximum sum of 20 without selecting adjacent numbers. >>> max_sum_non_adjacent([-2, 1, 3, -4, 5]) 8 # Choosing 1 and 5 yields the maximum sum of 6. >>> max_sum_non_adjacent([2, 4, 6, 2, 5]) 13 # Choosing 2, 6, and 5 yields the maximum sum of 13. ``` # Note: - The function should handle edge cases such as an empty list or a list with a single element efficiently.","solution":"def max_sum_non_adjacent(arr): Returns the maximum sum of non-adjacent elements from the list. # Edge cases if not arr: return 0 if len(arr) == 1: return arr[0] # Initialize incl (including the current element) and excl (excluding the current element) incl = arr[0] excl = 0 for i in range(1, len(arr)): # Current max excluding i new_excl = max(incl, excl) # Current max including i incl = excl + arr[i] excl = new_excl return max(incl, excl)"},{"question":"In this problem, you are tasked with writing a function that fetches weather information for a given location using the OpenWeatherMap API. The function should format and output this data in a structured way using the `pandas` library. You will specifically utilize the `pandas.DataFrame` class to accomplish this. The function will be named `get_weather_data`. It should take the following parameters: - `city` (a string): The name of the city for which you want to fetch the weather data. - `api_key` (a string): Your OpenWeatherMap API key. The function should retrieve the following data about the weather conditions in the given city: - Temperature - Humidity - Weather description - Wind speed - Coordinates (latitude and longitude) The data should be stored in a pandas DataFrame with the columns: `[\'temperature\', \'humidity\', \'weather_description\', \'wind_speed\', \'latitude\', \'longitude\']`. The function should return the DataFrame containing all the relevant information. Constraints: - You need to handle errors gracefully, such as the case where the city is not found. - Ensure that the API response is correctly processed and handle any missing fields appropriately. - Use the `pandas.DataFrame` to store and manipulate the data.","solution":"import requests import pandas as pd def get_weather_data(city, api_key): Fetch current weather data for a specified city using OpenWeatherMap API and return it as a pandas DataFrame. Parameters: city (str): The name of the city. api_key (str): OpenWeatherMap API key. Returns: pd.DataFrame: DataFrame containing weather data. url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\\" # Fetch data from the API response = requests.get(url) if response.status_code != 200: raise Exception(f\\"Error: Could not retrieve data for city: {city}\\") data = response.json() if \'main\' not in data or \'wind\' not in data or \'coord\' not in data or \'weather\' not in data: raise Exception(f\\"Error: Incomplete data for city: {city}\\") temperature = data[\'main\'].get(\'temp\', None) humidity = data[\'main\'].get(\'humidity\', None) weather_description = data[\'weather\'][0].get(\'description\', None) wind_speed = data[\'wind\'].get(\'speed\', None) latitude = data[\'coord\'].get(\'lat\', None) longitude = data[\'coord\'].get(\'lon\', None) weather_info = { \'temperature\': [temperature], \'humidity\': [humidity], \'weather_description\': [weather_description], \'wind_speed\': [wind_speed], \'latitude\': [latitude], \'longitude\': [longitude] } weather_df = pd.DataFrame(weather_info) return weather_df"},{"question":"Your task is to write a Python function, `categorize_students(participants, pass_mark)`, that categorizes students based on their scores into two groups: pass and fail. The function should read data from a dictionary, categorize each student, and return two lists: one with the names of students who passed and another with the names of students who failed. # Function Signature: ```python def categorize_students(participants: dict, pass_mark: int) -> tuple: ``` # Parameters: - `participants` (dict): A dictionary where keys are student names (strings) and values are their corresponding scores (integers). - `pass_mark` (int): The minimum score required to pass. # Returns: - A tuple of two lists: - The first list contains the names of students who passed. - The second list contains the names of students who failed. # Requirements and Constraints: - The order of names in the returned lists should match the order they appear in the `participants` dictionary. - Do not modify the input dictionary. # Example: ```python participants = { \\"Alice\\": 85, \\"Bob\\": 72, \\"Charlie\\": 60, \\"David\\": 90, \\"Eva\\": 55 } pass_mark = 70 ``` After calling `categorize_students(participants, pass_mark)`, the output should be: ```python ([\\"Alice\\", \\"Bob\\", \\"David\\"], [\\"Charlie\\", \\"Eva\\"]) ``` # Note: - Scores are always non-negative integers. - If there are no students in the input dictionary, return two empty lists.","solution":"def categorize_students(participants: dict, pass_mark: int) -> tuple: Categorizes students based on their scores into pass and fail groups. Parameters: participants (dict): Dictionary with student names as keys and scores as values. pass_mark (int): Minimum score required to pass. Returns: tuple: Two lists, the first list contains the names of students who passed, and the second list contains the names of students who failed. passed_students = [] failed_students = [] for student, score in participants.items(): if score >= pass_mark: passed_students.append(student) else: failed_students.append(student) return passed_students, failed_students"},{"question":"Your task is to write a function that implements a basic Linear Regression model using the `scikit-learn` library. The model should take an input dataset, fit the model to the data, and then return the model\'s coefficients and intercept. You will write a function `linear_regression_model(X_train, y_train)` which will include: 1. Importing the necessary `scikit-learn` classes and functions. 2. Creating an instance of the `LinearRegression` model. 3. Fitting the model to the provided training data. 4. Returning the coefficients and intercept of the fitted model. **Function Name**: `linear_regression_model` **Function Signature**: `def linear_regression_model(X_train, y_train):` **Parameters**: - `X_train` (ndarray): A 2D numpy array of shape `(n_samples, n_features)` containing the training data features. - `y_train` (ndarray): A 1D numpy array of shape `(n_samples,)` containing the target values. **Implementation Details**: 1. Use `from sklearn.linear_model import LinearRegression` to import the linear regression class. 2. Instantiate the `LinearRegression` model. 3. Fit the model using the `fit` method with `X_train` and `y_train` as arguments. 4. Retrieve the `coef_` and `intercept_` attributes from the fitted model. 5. Return the coefficients and intercept as a tuple. **Expected Outcome**: - The function should return a tuple `(coefficients, intercept)` where `coefficients` is a 1D numpy array of shape `(n_features,)` and `intercept` is a scalar value representing the model\'s intercept. **Example**: ```python # Example usage: X_train = np.array([[1, 2], [2, 3], [3, 4], [4, 5]]) y_train = np.array([2, 3, 4, 5]) coefficients, intercept = linear_regression_model(X_train, y_train) print(\\"Coefficients:\\", coefficients) print(\\"Intercept:\\", intercept) ``` The function should correctly output the coefficients and intercept for the provided training data using the `scikit-learn` library\'s linear regression functionality.","solution":"import numpy as np from sklearn.linear_model import LinearRegression def linear_regression_model(X_train, y_train): Fits a Linear Regression model to the given training data and returns coefficients and intercept. Parameters: - X_train (ndarray): 2D numpy array of shape (n_samples, n_features) containing the training data features. - y_train (ndarray): 1D numpy array of shape (n_samples,) containing the target values. Returns: - tuple: (coefficients, intercept), where coefficients is a 1D numpy array of shape (n_features,) and intercept is a scalar value. # Create an instance of LinearRegression model = LinearRegression() # Fit the model to the training data model.fit(X_train, y_train) # Retrieve the coefficients and intercept coefficients = model.coef_ intercept = model.intercept_ # Return the coefficients and intercept as a tuple return coefficients, intercept"},{"question":"Implement a function that takes a string and compresses it using the basic string compression method. The method involves counting the consecutive occurrences of characters and constructing a new string with the character followed by the count of its occurrences. If the compressed string is not shorter than the original string, the function should return the original string. The function should be case-sensitive. For example: - `>>> compress_string(\\"aabcccccaaa\\")` returns `\\"a2b1c5a3\\"` - `>>> compress_string(\\"abca\\")` returns `\\"abca\\"` The function should have the following structure: ``` def compress_string(s): ```","solution":"def compress_string(s): Compresses the input string using the basic string compression method. If the compressed string is not shorter than the original string, returns the original string. :param s: Input string :return: Compressed string or original string if compressed string is not shorter if not s: return s compressed_parts = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed_parts.append(s[i-1] + str(count)) count = 1 # Append the last character and its count compressed_parts.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed_parts) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Minimize Unique Characters in String You are assigned to write a function called `minimize_unique_characters` that reduces the number of unique characters in a given string `s` to at most `k` by replacing some characters. Your task is to transform the string `s` such that the number of distinct characters in the resulting string is minimized while the total number of distinct characters is less than or equal to `k`. Your function should accept two parameters: - `s` (str): The input string that needs to be processed. - `k` (int): The maximum number of unique characters allowed in the processed string. The function should return a new string that satisfies this condition. If it is not possible to reduce the unique characters to the desired limit `k`, return an empty string. # Example ```python s = \\"hello\\" k = 2 result = minimize_unique_characters(s) print(result) ``` Expected output might be similar to: ```python \\"heeee\\" or \\"lllll\\" or \\"ooooo\\" ``` # Constraints - The input string `s` will only contain lowercase English letters (`a` to `z`). - The integer `k` will be between 0 and `len(s)` inclusive. - If `k` is 0, return an empty string. # Note - Ensure that your function performs efficiently when handling large strings. - Handle edge cases such as `k` being greater than or equal to the current number of unique characters in the input string.","solution":"from collections import Counter def minimize_unique_characters(s, k): Reduces the number of unique characters in the string `s` to at most `k` by replacing characters. Parameters: s (str): The input string to be processed. k (int): The maximum number of unique characters allowed in the processed string. Returns: str: A new string with the number of unique characters minimized to be at most `k`. Returns an empty string if it is not possible to meet the requirement. if k == 0: return \\"\\" if k >= len(set(s)): return s # Get the frequency of each character in the input string frequency = Counter(s) # Sort characters by their frequency in descending order sorted_chars = sorted(frequency.items(), key=lambda item: item[1], reverse=True) # Select the top `k` most frequent characters top_k_chars = sorted_chars[:k] top_k_set = set(char for char, _ in top_k_chars) # Replace characters not in the top `k` set with a character from the top `k` replacement_char = top_k_chars[0][0] result = \'\'.join(char if char in top_k_set else replacement_char for char in s) return result"},{"question":"Write a Python function named `generate_multiplication_table` that generates a multiplication table for a given integer. The function should write the table to a text file with a specific format. Each line in the file should contain a single multiplication operation formatted as \\"<multiplier> x <multiplicand> = <product>\\". # Function Signature ```python def generate_multiplication_table(n, filename): pass ``` # Parameters - `n`: An integer representing the number whose multiplication table is to be generated. - `filename`: A string representing the name of the text file where the table will be written. # Instructions 1. Open the file specified by `filename` in write mode. 2. Write the multiplication table for the given integer `n` from `1` to `10` to the file. 3. Each line in the file should follow the format `\\"<n> x <i> = <product>\\"`, where `i` ranges from `1` to `10`. 4. Close the file after writing. # Example Usage ```python generate_multiplication_table(5, \\"table.txt\\") ``` After running this function, \\"table.txt\\" should contain: ``` 5 x 1 = 5 5 x 2 = 10 5 x 3 = 15 5 x 4 = 20 5 x 5 = 25 5 x 6 = 30 5 x 7 = 35 5 x 8 = 40 5 x 9 = 45 5 x 10 = 50 ``` In this example, the function will create a file named \\"table.txt\\" and write the multiplication table for the integer `5` to it.","solution":"def generate_multiplication_table(n, filename): Generates a multiplication table for the integer n and writes to a specified file. Parameters: n (int): The integer to generate multiplication table for. filename (str): The name of the file where the multiplication table will be written. with open(filename, \'w\') as file: for i in range(1, 11): line = f\\"{n} x {i} = {n * i}n\\" file.write(line)"},{"question":"# Problem Statement You have been hired to develop a real-time weather dashboard that fetches and displays current weather data for a given list of cities. Your task is to write a function that processes and displays weather data from the OpenWeatherMap API for a specified list of cities. You need to ensure robust handling of potential issues such as missing or malformed data. You will implement the following function: ```python def get_and_display_weather(cities: list) -> None: Fetches current weather data from the OpenWeatherMap API for a specified list of cities and displays it in a formatted table. The API endpoint to use is: \\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}\\" Requirements: - Handle missing or malformed data gracefully, ensuring the program does not crash. - Display weather information in degrees Celsius. The table should display the following columns: - City - Weather (e.g., clear sky, rain) - Temperature (C) - Humidity (%) - Wind Speed (m/s) Example of the table format: ``` +-------------+------------+-------------+-----------+------------+ | City | Weather | Temperature (C) | Humidity (%) | Wind Speed (m/s) | +-------------+------------+-------------+-----------+------------+ | New York | Clear sky | 22 | 55 | 5 | | Los Angeles | Cloudy | 18 | 60 | 3 | | ... | +-------------+------------+-------------+-----------+------------+ ``` Parameters: - cities: list of strings representing the city names. pass ``` # Input/Output Format - **Input**: A list of city names (e.g., [\\"New York\\", \\"Los Angeles\\", \\"Mumbai\\"]). - **Output**: The function should output the formatted table with the columns specified above. # Constraints - Do not assume the API will always return all required fields for each city. - Consider edge cases where some fields might be missing or improperly formatted. - Ensure that the temperature conversion to Celsius is accurate. # Performance Requirements - Efficient handling of network requests and JSON parsing. - Ensure the table can handle multiple cities without significant delay in processing time.","solution":"import requests from prettytable import PrettyTable API_KEY = \'your_openweathermap_api_key\' def get_and_display_weather(cities: list) -> None: Fetches current weather data from the OpenWeatherMap API for a specified list of cities and displays it in a formatted table. table = PrettyTable() table.field_names = [\\"City\\", \\"Weather\\", \\"Temperature (C)\\", \\"Humidity (%)\\", \\"Wind Speed (m/s)\\"] url = \\"http://api.openweathermap.org/data/2.5/weather\\" for city in cities: try: response = requests.get(url, params={\'q\': city, \'appid\': API_KEY, \'units\': \'metric\'}) data = response.json() if response.status_code != 200 or \'main\' not in data: raise ValueError(\\"Invalid response from API\\") weather = data[\'weather\'][0][\'description\'] temp = data[\'main\'][\'temp\'] humidity = data[\'main\'][\'humidity\'] wind_speed = data[\'wind\'][\'speed\'] table.add_row([city, weather, temp, humidity, wind_speed]) except Exception as e: table.add_row([city, \\"Data not available\\", \\"N/A\\", \\"N/A\\", \\"N/A\\"]) print(table)"},{"question":"# Problem Statement As a developer, you are responsible for creating a system that manages data records based on a set of predefined rules. One key functionality of this system is to evaluate and transform a series of data records based on specific operations. Objective Write a function `perform_operations(records: List[Tuple[int, int, int]], operations: List[str]) -> List[int]` that evaluates a list of data records and applies a series of operations to each record. Input * `records`: A list of tuples where each tuple contains three integers representing a data record `(a, b, c)`. * `operations`: A list of strings where each string represents an operation to be applied on the data records. Possible operations include: - `\\"SUM\\"`: Sum the values of `a`, `b`, and `c`. - `\\"PRODUCT\\"`: Multiply the values of `a`, `b`, and `c`. - `\\"MAX\\"`: Find the maximum value among `a`, `b`, and `c`. Output * A list of integers representing the result of applying each operation to each record. Constraints * `a`, `b`, and `c` are integers in the range -10^9 to 10^9 inclusive. * Length of `records` is between 1 and 10^5 inclusive. * Length of `operations` is between 1 and 10 inclusive. * Each operation string in `operations` is guaranteed to be valid and one of the specified operations. Requirements 1. Implement `perform_operations` such that it processes each record according to the operations provided. 2. Ensure that all operations are performed efficiently to handle large inputs. # Example ```python perform_operations([(1, 2, 3), (4, 5, 6)], [\\"SUM\\", \\"PRODUCT\\", \\"MAX\\"]) # Output: [6, 120, 3, 15, 120, 6] perform_operations([(-1, 2, -3), (0, 0, 0)], [\\"SUM\\", \\"MAX\\"]) # Output: [-2, 2, 0, 0] ``` Implement the function `perform_operations`.","solution":"from typing import List, Tuple def perform_operations(records: List[Tuple[int, int, int]], operations: List[str]) -> List[int]: results = [] for record in records: a, b, c = record for operation in operations: if operation == \\"SUM\\": results.append(a + b + c) elif operation == \\"PRODUCT\\": results.append(a * b * c) elif operation == \\"MAX\\": results.append(max(a, b, c)) return results"},{"question":"# Problem Statement Write a function that finds the first non-repeating character in a given string and returns its index. If all characters are repeated or the string is empty, return -1. The function must be case sensitive, meaning \'a\' and \'A\' are considered different characters. # Function Signature ```python def first_non_repeating_character(text: str) -> int: pass ``` # Input - `text` (str): A string consisting of alphabetic characters (both upper and lower case), digits, punctuation, and other special characters. The length of the string will not exceed 10^5 characters. # Output - (int): The index of the first non-repeating character. If all characters are repeated or the string is empty, return -1. # Constraints - The function should perform efficiently with a time complexity of O(n) where n is the length of the string. - The function should handle both upper and lower case letters distinctly. # Examples ```python assert first_non_repeating_character(\'aabbcc\') == -1 assert first_non_repeating_character(\'leetcode\') == 0 assert first_non_repeating_character(\'loveleetcode\') == 2 assert first_non_repeating_character(\'LeetCode\') == 0 assert first_non_repeating_character(\'\') == -1 assert first_non_repeating_character(\'aAbBcC\') == 0 ``` # Additional Notes - The solution should consider the character\'s case; \'a\' and \'A\' are different characters. - The function must be optimized to handle large input sizes efficiently.","solution":"def first_non_repeating_character(text: str) -> int: Finds the first non-repeating character in a given string and returns its index. If all characters are repeated or the string is empty, returns -1. char_count = {} # First pass to count all characters for char in text: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for index, char in enumerate(text): if char_count[char] == 1: return index return -1"},{"question":"# Compression and Decompression of Strings In this task, you are asked to write functions for compressing and decompressing a string using a simple run-length encoding algorithm. The idea is to store each character and its count if a character repeats consecutively. Input * For compression, a string `s` consisting of alphanumeric characters. * For decompression, a compressed string containing characters followed by their counts (only if the count is greater than 1). Output * For compression, a compressed version of the input string. * For decompression, the original string obtained from the compressed version. Function Signatures ```python def compress_string(s: str) -> str: Compress the given string using run-length encoding. Parameters: s (str): The input string to be compressed. Returns: str: The compressed string. def decompress_string(s: str) -> str: Decompress the given run-length encoded string. Parameters: s (str): The compressed string to be decompressed. Returns: str: The original string. ``` Requirements * The compression function should reduce the size of the string by encoding consecutive repetitions of characters. * Single occurrences of characters should remain unchanged in the compressed string. * The decompression function should restore the original string from the compressed version reliably. * You can assume that the input string for the `decompress_string` function is always a valid compressed string. Example Usage: ```python # Compress example original_str = \\"aaabbccccdd\\" compressed_str = compress_string(original_str) print(compressed_str) # Output: \\"a3b2c4d2\\" # Decompress example compressed_str = \\"a3b2c4d2\\" decompressed_str = decompress_string(compressed_str) print(decompressed_str) # Output: \\"aaabbccccdd\\" ``` Constraints - The maximum length of the input string `s` is 10^5 characters. - The functions should have time complexities that are linear with respect to the number of characters in the input string.","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for i in range(1, len(s)): if s[i] == current_char: count += 1 else: if count == 1: compressed.append(current_char) else: compressed.append(current_char + str(count)) current_char = s[i] count = 1 if count == 1: compressed.append(current_char) else: compressed.append(current_char + str(count)) return \'\'.join(compressed) def decompress_string(s: str) -> str: decompressed = [] i = 0 while i < len(s): char = s[i] j = i + 1 count = 0 while j < len(s) and s[j].isdigit(): count = count * 10 + int(s[j]) j += 1 if count == 0: decompressed.append(char) else: decompressed.append(char * count) i = j return \'\'.join(decompressed)"},{"question":"# Coding Assessment Question: Implementing a Simple File System Simulation Problem Statement You are tasked with implementing a simple file system simulation that supports basic file operations: creating files, writing to files, reading from files, and deleting files. The file system should be represented as a dictionary where keys are file names and values are file contents. # Requirements 1. **Class Definition**: Define a class `SimpleFileSystem`. 2. **Methods**: * `create_file(file_name: str) -> None`: Creates an empty file with the given name. Raises an exception if the file already exists. * `write_file(file_name: str, content: str) -> None`: Writes the given content to the specified file. Raises an exception if the file does not exist. * `read_file(file_name: str) -> str`: Reads and returns the content of the specified file. Raises an exception if the file does not exist. * `delete_file(file_name: str) -> None`: Deletes the specified file. Raises an exception if the file does not exist. 3. **Input**: * `file_name`: A string with a length ranging from **1 to 100**. * `content`: A string of length ranging from **0 to 10^6**. 4. **Output**: * `create_file`: Returns `None`. * `write_file`: Returns `None`. * `read_file`: Returns the content of the specified file as a string. * `delete_file`: Returns `None`. 5. **Constraints**: * File names are unique. * File content can be modified after creation. # Example ```python class SimpleFileSystem: def __init__(self): self.files = {} def create_file(self, file_name: str) -> None: if file_name in self.files: raise Exception(\\"File already exists\\") self.files[file_name] = \\"\\" def write_file(self, file_name: str, content: str) -> None: if file_name not in self.files: raise Exception(\\"File does not exist\\") self.files[file_name] = content def read_file(self, file_name: str) -> str: if file_name not in self.files: raise Exception(\\"File does not exist\\") return self.files[file_name] def delete_file(self, file_name: str) -> None: if file_name not in self.files: raise Exception(\\"File does not exist\\") del self.files[file_name] # Example Usage fs = SimpleFileSystem() fs.create_file(\\"test.txt\\") fs.write_file(\\"test.txt\\", \\"Hello, World!\\") print(fs.read_file(\\"test.txt\\")) # Output: \\"Hello, World!\\" fs.delete_file(\\"test.txt\\") ``` # Performance Requirements: * Ensure that file operations comply with the given time complexity: O(1) average-case for all operations. * The file system operations should handle up to 10^4 files efficiently.","solution":"class SimpleFileSystem: def __init__(self): self.files = {} def create_file(self, file_name: str) -> None: if file_name in self.files: raise Exception(\\"File already exists\\") self.files[file_name] = \\"\\" def write_file(self, file_name: str, content: str) -> None: if file_name not in self.files: raise Exception(\\"File does not exist\\") self.files[file_name] = content def read_file(self, file_name: str) -> str: if file_name not in self.files: raise Exception(\\"File does not exist\\") return self.files[file_name] def delete_file(self, file_name: str) -> None: if file_name not in self.files: raise Exception(\\"File does not exist\\") del self.files[file_name]"},{"question":"# Coding Question Context: You are developing a program to handle data entries for a library system. Specifically, you need to implement functionalities to add a new book, search for books by title, and list all books by a specific author. Ensuring the data structure used allows for efficient insertions and lookups is crucial. Prompt: Craft a class `Library` that supports the following methods: 1. `add_book(title: str, author: str) -> None`: - Adds a book with the provided title and author to the library system. 2. `search_by_title(title: str) -> str`: - Returns the author of the book with the given title. If the book is not found, return the string \\"Book not found\\". 3. `list_books_by_author(author: str) -> List[str]`: - Returns a list of titles of all books written by the specified author. The list should be sorted in lexicographical order. If no books are found, return an empty list. Input: * A series of method calls to `add_book`, `search_by_title`, and `list_books_by_author`. Output: * The appropriate return value for the `search_by_title` and `list_books_by_author` methods when called. Constraints: * Titles and authors are non-empty strings with a maximum length of 100 characters. * The system should handle up to (10^5) books efficiently. Example: ```python class Library: def __init__(self): # Initialize your data structures here pass def add_book(self, title: str, author: str) -> None: # Implement the functionality to add a book pass def search_by_title(self, title: str) -> str: # Implement the functionality to search for a book by title pass def list_books_by_author(self, author: str) -> List[str]: # Implement the functionality to list all books by a specific author pass # Example Usage library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(\\"Nineteen Eighty-Four\\", \\"George Orwell\\") library.add_book(\\"Animal Farm\\", \\"George Orwell\\") print(library.search_by_title(\\"Nineteen Eighty-Four\\")) # Output: \\"George Orwell\\" print(library.search_by_title(\\"The Catcher in the Rye\\")) # Output: \\"Book not found\\" print(library.list_books_by_author(\\"George Orwell\\")) # Output: [\\"Animal Farm\\", \\"Nineteen Eighty-Four\\"] print(library.list_books_by_author(\\"J.K. Rowling\\")) # Output: [] ``` Performance: * Ensure that the solution allows for quick insertions and lookups, suitable for managing a library\'s dataset efficiently.","solution":"from typing import List class Library: def __init__(self): self.books_by_title = {} self.books_by_author = {} def add_book(self, title: str, author: str) -> None: Adds a book with the provided title and author to the library system. self.books_by_title[title] = author if author not in self.books_by_author: self.books_by_author[author] = [] self.books_by_author[author].append(title) def search_by_title(self, title: str) -> str: Returns the author of the book with the given title. If the book is not found, returns \\"Book not found\\". return self.books_by_title.get(title, \\"Book not found\\") def list_books_by_author(self, author: str) -> List[str]: Returns a list of titles of all books written by the specified author. The list is sorted in lexicographical order. If no books are found, returns an empty list. if author in self.books_by_author: return sorted(self.books_by_author[author]) else: return [] # Example Usage library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(\\"Nineteen Eighty-Four\\", \\"George Orwell\\") library.add_book(\\"Animal Farm\\", \\"George Orwell\\") print(library.search_by_title(\\"Nineteen Eighty-Four\\")) # Output: \\"George Orwell\\" print(library.search_by_title(\\"The Catcher in the Rye\\")) # Output: \\"Book not found\\" print(library.list_books_by_author(\\"George Orwell\\")) # Output: [\\"Animal Farm\\", \\"Nineteen Eighty-Four\\"] print(library.list_books_by_author(\\"J.K. Rowling\\")) # Output: []"},{"question":"# Background You are given a set of lists, each containing unique integers. Two lists are considered equivalent if they contain the exact same integers (order does not matter). # Task Implement a function that determines if two lists are equivalent. The function should return `True` if the lists are equivalent and `False` otherwise. # Function Signature ```python def are_lists_equivalent(list1: list, list2: list) -> bool: pass ``` # Input - `list1` (list of int): A list containing unique integers. - `list2` (list of int): A list containing unique integers. # Output - `result` (bool): `True` if the two lists are equivalent, `False` otherwise. # Example ```python assert are_lists_equivalent([1, 2, 3], [3, 2, 1]) == True assert are_lists_equivalent([1, 2, 4], [3, 2, 1]) == False assert are_lists_equivalent([], []) == True ``` # Constraints - Each list contains no more than 1000 unique integers. - The integers in the lists range from -10^5 to 10^5.","solution":"def are_lists_equivalent(list1, list2): Determines if two lists are equivalent. Lists are considered equivalent if they contain the exact same integers, order does not matter. :param list1: List of unique integers. :param list2: List of unique integers. :return: True if the lists are equivalent, False otherwise. return sorted(list1) == sorted(list2)"},{"question":"# Sorting Letters by Frequency **Context**: You are given a string consisting of lowercase letters only. Your task is to sort the letters in the string by their frequency in descending order. Letters with the same frequency should appear in the order of their first appearance in the original string. **Task**: Implement a function that sorts the letters in the string by frequency and returns the resulting sorted string. **Function Signature**: ```python def sort_by_frequency(s: str) -> str: Sort the letters of the string \'s\' by their frequency in descending order. :param s: A string consisting of lowercase letters only. :return: A new string with letters sorted by frequency in descending order. ``` **Input**: * `s` (str): A string containing only lowercase letters (1 <= len(s) <= 10^5). **Output**: * Returns a string with the letters sorted by frequency in descending order. **Constraints**: * The function should handle very large input strings efficiently. * If two letters have the same frequency, they should appear in the order of their first appearance in the input string. **Performance Requirements**: * The function should run in O(n log n) time complexity, where n is the length of the input string. * Memory usage should be proportional to the input string size. **Example**: ```python # Example usage: s = \\"tree\\" result = sort_by_frequency(s) print(result) # Expected output: \\"eert\\" s = \\"banana\\" result = sort_by_frequency(s) print(result) # Expected output: \\"aaannb\\" ``` Ensure your implementation covers edge cases like strings with all unique characters or all identical characters, and optimizes for performance.","solution":"from collections import Counter def sort_by_frequency(s: str) -> str: Sort the letters of the string \'s\' by their frequency in descending order. :param s: A string consisting of lowercase letters only. :return: A new string with letters sorted by frequency in descending order. frequency_counter = Counter(s) # Sort by frequency first (-frequency to sort in descending order), then by first appearance sorted_characters = sorted(frequency_counter.keys(), key=lambda x: (-frequency_counter[x], s.index(x))) # Construct the result string based on sorted characters result = \'\'.join(char * frequency_counter[char] for char in sorted_characters) return result"},{"question":"# Context Sorting algorithms are fundamental to computer science. A common problem they address is arranging the elements of an array in a particular order. One such problem is to sort an array of integers in increasing order using the quicksort algorithm. # Problem Statement Write a function `quicksort(arr: List[int]) -> List[int]` that takes an array of integers and returns a new array with the integers sorted in increasing order using the quicksort algorithm. # Input - `arr`: a list of integers. # Output - A list of integers sorted in increasing order. # Constraints - The input list `arr` length will not exceed 10^5. - The integers in the list are between -10^9 and 10^9. # Example ```python >>> quicksort([3,6,8,10,1,2,1]) [1, 1, 2, 3, 6, 8, 10] >>> quicksort([1, 0, 0, -2, 5, 5]) [-2, 0, 0, 1, 5, 5] >>> quicksort([34, -5, 20, 10]) [-5, 10, 20, 34] ``` # Notes - Ensure that your quicksort implementation is efficient with an average case time complexity of O(n log n). - Use recursion and consider edge cases such as empty lists or lists with a single element.","solution":"from typing import List def quicksort(arr: List[int]) -> List[int]: Sorts a list of integers in increasing order using the quicksort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"# Problem Statement Write a function `sum_of_union_of_sets(sets: List[Set[int]]) -> int` that takes a list of sets and returns the sum of the union of all the sets. The union of a collection of sets is a set containing all elements that are in any of the sets. # Input Format - A list of sets, where each set contains integers. # Output Format - A single integer representing the sum of the union of all sets. # Constraints - The input list will contain between 1 and 100 sets, inclusive. - Each set will contain between 0 and 100 integers, inclusive. - Each integer ( x ) in a set will satisfy ( -10^6 leq x leq 10^6 ). # Performance Requirements - Your implementation should be efficient in both time and space complexity, considering the constraints. # Examples 1. `sum_of_union_of_sets([{1, 2, 3}, {3, 4, 5}])` should return `15` (union is {1, 2, 3, 4, 5}). 2. `sum_of_union_of_sets([{10, 20, 30}, {30, 40, 50}, {50, 60}])` should return `210` (union is {10, 20, 30, 40, 50, 60}). 3. `sum_of_union_of_sets([{1}, {2}, {3}, {4}])` should return `10` (union is {1, 2, 3, 4}). 4. `sum_of_union_of_sets([{1, 2, 3}, {3, 4, 5}, {5, 6}])` should return `21` (union is {1, 2, 3, 4, 5, 6}). # Additional Notes - Ensure that your function handles cases where sets may be empty correctly. # Function Signature ```python def sum_of_union_of_sets(sets: List[Set[int]]) -> int: pass ```","solution":"from typing import List, Set def sum_of_union_of_sets(sets: List[Set[int]]) -> int: Returns the sum of the union of all the sets in the list. Parameters: sets (List[Set[int]]): A list of sets, where each set contains integers. Returns: int: The sum of the union of all sets. # Create an empty set to store the union of all sets union_set = set() # Iterate through each set in the list and update the union set for s in sets: union_set.update(s) # Return the sum of the union set return sum(union_set)"},{"question":"# Coding Assessment Question You are tasked with writing a Python function to simulate a simple version of a URL shortening service. The service should generate a unique short URL for a given long URL and be able to decode it back to the original URL. **Function Description:** Write a class `URLShortener` that encapsulates the URL shortening functionality. Methods: - `encode(long_url: str) -> str`: This method takes a long URL and returns a unique shortened URL. - `decode(short_url: str) -> str`: This method takes a shortened URL and returns the original long URL. Input: - `long_url` (str): The original URL to be shortened. - `short_url` (str): The shortened version of the URL. Output: - For `encode`: A shortened URL (str) starting with `\\"http://short.url/\\"` followed by a unique code. - For `decode`: The original long URL (str) corresponding to the given short URL. Details: - The unique code in the shortened URL should be alphanumeric and case-sensitive. - There should be no collisions, i.e., every long URL should have a unique short URL, and vice versa. - The same long URL should always return the same short URL if encoded multiple times. Example: ```python shortener = URLShortener() short_url = shortener.encode(\\"https://www.example.com\\") print(short_url) # \\"http://short.url/1a2b3c\\" original_url = shortener.decode(short_url) print(original_url) # \\"https://www.example.com\\" ``` **Constraints:** - The unique code can have a maximum length of 6 characters. - You must store mappings between original URLs and their shortened versions without using external databases or modules that provide such functionality. - Implement the encoding and decoding in such a way that it scales for up to 1,000,000 unique URLs.","solution":"import hashlib class URLShortener: def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base_url = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: if long_url in self.url_to_code: return self.url_to_code[long_url] # Generate a unique code using the counter value self.counter += 1 unique_code = self._int_to_code(self.counter) short_url = self.base_url + unique_code self.url_to_code[long_url] = short_url self.code_to_url[unique_code] = long_url return short_url def decode(self, short_url: str) -> str: unique_code = short_url.split(\\"/\\")[-1] return self.code_to_url.get(unique_code, \\"\\") def _int_to_code(self, num: int) -> str: chars = \\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\" base = len(chars) code = [] while num > 0: code.append(chars[num % base]) num //= base return \\"\\".join(reversed(code)) # Example usage shortener = URLShortener() short_url = shortener.encode(\\"https://www.example.com\\") print(short_url) # E.g., \\"http://short.url/1\\" original_url = shortener.decode(short_url) print(original_url) # \\"https://www.example.com\\""},{"question":"# Problem Statement You are given a task of calculating the longest increasing subsequence (LIS) in a list of integers. Implement a function: 1. `longest_increasing_subsequence(nums: List[int]) -> int`: This function should compute the length of the longest increasing subsequence in the given list of integers. # Requirements * Use dynamic programming to compute the LIS efficiently. * Implement a `binary_search(dp: List[int], target: int) -> int` function that performs binary search on a sorted list `dp` to find the correct position to replace or expand the subsequence. * The `longest_increasing_subsequence` function should build the LIS using the patience sorting technique which involves the `binary_search` function for optimal complexity. # Function Definitions ```python from typing import List def binary_search(dp: List[int], target: int) -> int: # Your code here def longest_increasing_subsequence(nums: List[int]) -> int: # Your code here ``` # Input/Output Examples ```python assert binary_search([2, 5, 7, 10], 6) == 2 assert binary_search([1, 3, 5, 6, 8], 4) == 2 assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 ``` # Constraints * The length of the array, `n`, will be a non-negative integer (0  n  10^4). * The elements of the array, `nums[i]`, will be an integer (-10^9  nums[i]  10^9). * Your implementation should handle edge cases including an empty array. # Additional Context The longest increasing subsequence (LIS) is a classic problem in computer science with applications in various fields such as bioinformatics, data compression, and stock market analysis. Efficient solutions to this problem typically involve dynamic programming or patience sorting techniques. This exercise will test your ability to implement these concepts and optimize the solution for larger arrays.","solution":"from typing import List def binary_search(dp: List[int], target: int) -> int: Perform a binary search on the dp list to find the index where \'target\' should be inserted. This function will help in finding the correct position to replace or append elements to maintain the increasing subsequence. :param dp: List[int] - A sorted list where the binary search is applied. :param target: int - The target number to find its position in \'dp\'. :return: int - The index where \'target\' should be placed. left, right = 0, len(dp) - 1 while left <= right: mid = (left + right) // 2 if dp[mid] == target: return mid elif dp[mid] < target: left = mid + 1 else: right = mid - 1 return left def longest_increasing_subsequence(nums: List[int]) -> int: Calculate the length of the longest increasing subsequence using dynamic programming combined with binary search to optimize the process. :param nums: List[int] - A list of integers representing the sequence. :return: int - The length of the longest increasing subsequence. if not nums: return 0 dp = [] for num in nums: pos = binary_search(dp, num) if pos < len(dp): dp[pos] = num else: dp.append(num) return len(dp)"},{"question":"# Task: Implement a String Matching Algorithm Scenario You are provided with a list of words and a pattern string. Your task is to determine which words from the list match the given pattern. A word matches the pattern if there exists a bijection (one-to-one mapping) between characters in the pattern and characters in the word. Requirements 1. **Function Implementation**: Implement the function `find_and_replace_pattern(words, pattern)` in Python that achieves the following: * Takes as input: - `words`: a list of strings. - `pattern`: a string pattern. * Returns: - A list of strings from the input list that match the pattern. Input and Output Format * **Input**: * `words`: List of strings where each word has length `L` (1 <= `L` <= 20). * `pattern`: a string of length `L`. * **Output**: * List of strings that match the pattern. Constraints * Word list contains at most 1000 words. * Each word and the pattern consist only of lowercase English letters. * The pattern string and each word in `words` list all have the same length. Performance Requirements Your implementation should efficiently handle the case where the word list is large, avoiding unnecessary computations or nested loops as much as possible. Example * Input: `words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], pattern = \\"abb\\"` * Output: `[\\"mee\\", \\"aqq\\"]` *Explanation*: - \\"mee\\" matches the pattern \\"abb\\": (m -> a, e -> b). - \\"aqq\\" matches the pattern \\"abb\\": (a -> a, q -> b). - \\"abc\\" does not match the pattern \\"abb\\". - \\"deq\\" does not match the pattern \\"abb\\". - \\"dkd\\" does not match the pattern \\"abb\\". - \\"ccc\\" does not match the pattern \\"abb\\" (no bijection mapping between characters).","solution":"def find_and_replace_pattern(words, pattern): def normalize(word): mapping = {} normalized_word = [] next_char = \'a\' for char in word: if char not in mapping: mapping[char] = next_char next_char = chr(ord(next_char) + 1) normalized_word.append(mapping[char]) return \'\'.join(normalized_word) normalized_pattern = normalize(pattern) return [word for word in words if normalize(word) == normalized_pattern]"},{"question":"# Context Bob is developing an application that requires efficient manipulation of binary trees. One of the operations he needs to perform frequently is checking if a given binary tree is a valid Binary Search Tree (BST). Recall that a binary tree is a BST if and only if, for each node, all values in its left subtree are less than the node\'s value, and all values in its right subtree are greater than the node\'s value. # Task Write a function `is_valid_bst` that takes a binary tree represented as a dictionary and returns `True` if the tree is a valid BST and `False` otherwise. # Input - The input tree is represented as a dictionary where each key is the node identifier, and each value is a tuple `(left, right, value)`, where `left` and `right` are the identifiers of the left and right children, respectively, and `value` is the integer value of the node. A value of `None` for `left` or `right` indicates that there is no child on that side. # Output - A boolean value indicating whether the tree is a valid BST. # Example ```python tree = { 1: (2, 3, 10), 2: (None, None, 5), 3: (None, None, 20) } is_valid_bst(tree) ``` Expected Output: ``` True ``` # Constraints - The tree can have up to 1000 nodes. # Performance Requirements - Ensure that the function efficiently handles the validation process.","solution":"def is_valid_bst(tree): def validate(node_id, low=-float(\'inf\'), high=float(\'inf\')): if node_id is None: return True left, right, value = tree[node_id] if not (low < value < high): return False return validate(left, low, value) and validate(right, value, high) # Assuming the root node has the identifier 1 return validate(1) if tree else True"},{"question":"# Matrix Operations You are tasked with implementing additional operations for the `Matrix` class presented below. Specifically, you need to implement the following methods: 1. **Matrix Transposition**: * Implement a method `transpose` that returns the transpose of the matrix. * The transpose of a matrix is obtained by swapping rows with columns. * **Input**: A `Matrix` object. * **Output**: A new `Matrix` object representing the transposed matrix. 2. **Matrix Multiplication**: * Implement a method `matrix_multiply` that multiplies two matrices. * **Input**: Two `Matrix` objects. * **Output**: A new `Matrix` object representing the result of the matrix multiplication. * Note: Matrix multiplication is defined only if the number of columns in the first matrix equals the number of rows in the second matrix. **Function Signatures**: ```python def transpose(self) -> Matrix: ... def matrix_multiply(self, other: Matrix) -> Matrix: ... ``` **Constraints**: 1. For transpose: - There are no special constraints; the method should handle any m x n matrix. 2. For matrix multiplication: - Raise an exception if the number of columns in the first matrix does not match the number of rows in the second matrix. **Example Usage**: ```python m1 = Matrix([[1, 2, 3], [4, 5, 6]]) m2 = Matrix([[7, 8], [9, 10], [11, 12]]) # Matrix Transposition transposed_m1 = m1.transpose() print(transposed_m1) # Output: Matrix([[1, 4], [2, 5], [3, 6]]) # Matrix Multiplication result_multiply = m1.matrix_multiply(m2) print(result_multiply) # Output: Matrix([[58, 64], [139, 154]]) ``` **Class Definition**: The `Matrix` class should have an initializer that takes a list of lists (2D array) representing the matrix, with methods `transpose` and `matrix_multiply` as described above. ```python class Matrix: def __init__(self, data: list[list[float]]): self.data = data def transpose(self) -> \'Matrix\': rows = len(self.data) cols = len(self.data[0]) transposed_data = [[self.data[j][i] for j in range(rows)] for i in range(cols)] return Matrix(transposed_data) def matrix_multiply(self, other: \'Matrix\') -> \'Matrix\': if len(self.data[0]) != len(other.data): raise ValueError(\\"Incompatible matrices for multiplication\\") result_rows = len(self.data) result_cols = len(other.data[0]) result_data = [[0 for _ in range(result_cols)] for _ in range(result_rows)] for i in range(result_rows): for j in range(result_cols): result_data[i][j] = sum(self.data[i][k] * other.data[k][j] for k in range(len(other.data))) return Matrix(result_data) ``` This new question blends seamlessly with the provided sample question by maintaining similar tone, length, complexity, and programming concepts. It requires understanding and implementation of basic matrix operations, akin to the vector operations in the original question.","solution":"class Matrix: def __init__(self, data: list[list[float]]): self.data = data def transpose(self) -> \'Matrix\': rows = len(self.data) cols = len(self.data[0]) transposed_data = [[self.data[j][i] for j in range(rows)] for i in range(cols)] return Matrix(transposed_data) def matrix_multiply(self, other: \'Matrix\') -> \'Matrix\': if len(self.data[0]) != len(other.data): raise ValueError(\\"Incompatible matrices for multiplication\\") result_rows = len(self.data) result_cols = len(other.data[0]) result_data = [[0 for _ in range(result_cols)] for _ in range(result_rows)] for i in range(result_rows): for j in range(result_cols): result_data[i][j] = sum(self.data[i][k] * other.data[k][j] for k in range(len(other.data))) return Matrix(result_data)"},{"question":"# Minimum Steps to Equal Integers You are required to create a function that determines the minimum number of steps needed to make two given integers equal by either incrementing or decrementing them. Requirements: 1. Implement a function `min_steps_to_equal` that accepts two integer inputs `a` and `b`. 2. The function should return an integer representing the minimum number of steps required to make both integers equal. 3. In each step, you can either increment or decrement either integer by 1. Expected Input and Output: - Input: Two integers `a` and `b`. - Output: An integer representing the minimum steps to make `a` and `b` equal. Constraints: - The integers `a` and `b` can range from (-10^9) to (10^9). - The solution should handle large differences between `a` and `b` efficiently. Performance Requirements: - Time Complexity: (O(1)), as the solution should only involve simple arithmetic operations. - Space Complexity: (O(1)), given the constant space usage. # Example: ```python print(min_steps_to_equal(5, 10)) # Output: 5 print(min_steps_to_equal(-2, 3)) # Output: 5 print(min_steps_to_equal(15, -8)) # Output: 23 ``` Implement the function `min_steps_to_equal` to fulfill the above requirements.","solution":"def min_steps_to_equal(a, b): Returns the minimum number of steps needed to make two integers a and b equal by either incrementing or decrementing them. return abs(a - b)"},{"question":"# Scenario You are developing a simple command-line todo application where users can manage their tasks. Users should be able to add new tasks, mark tasks as completed, and list all tasks with their completion status. Your goal is to implement the core functionality of the application and test its behavior. # Task 1. Implement a class `TodoApp` that allows users to add tasks, mark them as complete, and list all tasks. 2. Write unit tests for your class to ensure it behaves as expected. # Requirements **Class Definition**: ```python class TodoApp: def __init__(self): # Initialize your data structure here pass def add_task(self, task: str) -> None: # Your implementation here pass def complete_task(self, task: str) -> None: # Your implementation here pass def list_tasks(self) -> list: # Your implementation here pass ``` # Example ```python # Example usage app = TodoApp() app.add_task(\\"Buy milk\\") app.add_task(\\"Read book\\") app.complete_task(\\"Buy milk\\") print(app.list_tasks()) # Expected output: [(\\"Buy milk\\", True), (\\"Read book\\", False)] ``` # Constraints - The `add_task` method should add a new task with a `False` completion status. - The `complete_task` method should set the completion status of a specified task to `True`. If the task is not found, it should raise a `ValueError`. - The `list_tasks` method should return a list of tuples containing the task and its completion status. # Testing - Use a testing framework like `unittest` to write your tests. - Ensure to test adding tasks, completing tasks, and listing tasks. - Verify that the appropriate exceptions are raised when trying to mark a non-existent task as complete. # Additional Information - Use assertions to check the correctness of the task addition, completion, and listing functionalities. - Make sure to handle edge cases, such as adding duplicate tasks (tasks with the same name).","solution":"class TodoApp: def __init__(self): self.tasks = {} def add_task(self, task: str) -> None: if task in self.tasks: raise ValueError(\\"Task already exists\\") self.tasks[task] = False def complete_task(self, task: str) -> None: if task not in self.tasks: raise ValueError(\\"Task does not exist\\") self.tasks[task] = True def list_tasks(self) -> list: return [(task, status) for task, status in self.tasks.items()]"},{"question":"# Coding Assessment Question Background & Context You are tasked with developing a part of a search engine that finds specific text patterns within a large collection of documents. One efficient way to search through text is by using the Knuth-Morris-Pratt (KMP) string matching algorithm, which preprocesses the pattern to create a partial match table (also known as the \\"failure function\\"). Task Write a function `search_pattern` that takes a pattern string and a text file path as input. The function should use the KMP algorithm to find all occurrences of the pattern within the text file and return their starting indices. Function Signature ```python def search_pattern(pattern: str, file_path: str) -> list: Finds all occurrences of the pattern in the text file and returns their starting indices. :param pattern: str, the pattern to search for within the file\'s text :param file_path: str, path to a text file containing the text to search within :return: list of integers representing the starting indices of each occurrence of the pattern ``` Input and Output Format * **Input**: - `pattern` (str): Pattern string you want to search for in the text. - `file_path` (str): Path to the text file containing the text to be searched. * **Output**: - Returns a list of integers, each representing a starting index where the pattern is found in the text. Constraints * The entire text files contents can fit into memory. * If the pattern is not found, the function should return an empty list. * Efficient implementation using the KMP algorithm is required to handle large text files. Example Suppose the text file at `file_path` contains the following text: ``` ababcabcabababd ``` And the pattern string is: ``` ababd ``` The `search_pattern` function should return: ``` [10] ``` Notes * The partial match table (failure function) is a critical component of the KMP algorithm. Implement it correctly to ensure the function\'s efficiency. * The file should be read as a single string of text. Here is an example of the content of the text file and how your function should process it: Text file content: ``` ababcabcabababd ``` Pattern: ``` ababd ``` Expected output: ``` [10] ```","solution":"def compute_partial_match_table(pattern): Computes the partial match table (also known as the failure function) for KMP algorithm. :param pattern: str, the pattern to preprocess. :return: list of integers, the partial match table. partial_match_table = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): while j > 0 and pattern[i] != pattern[j]: j = partial_match_table[j - 1] if pattern[i] == pattern[j]: j += 1 partial_match_table[i] = j return partial_match_table def search_pattern(pattern, file_path): Finds all occurrences of the pattern in the text file and returns their starting indices. :param pattern: str, the pattern to search for within the file\'s text. :param file_path: str, path to a text file containing the text to search within. :return: list of integers representing the starting indices of each occurrence of the pattern. with open(file_path, \'r\') as file: text = file.read() if not pattern or not text: return [] partial_match_table = compute_partial_match_table(pattern) pattern_length = len(pattern) text_length = len(text) result_indices = [] j = 0 for i in range(text_length): while j > 0 and text[i] != pattern[j]: j = partial_match_table[j - 1] if text[i] == pattern[j]: j += 1 if j == pattern_length: result_indices.append(i - j + 1) j = partial_match_table[j - 1] return result_indices"},{"question":"**Question**: Hamiltonian Path and Cycle Detection **Context**: Given a directed graph represented as an adjacency list, your task is to determine whether the graph has a Hamiltonian Path or Cycle and produce the traversal path if it exists. A Hamiltonian Path in a graph means a path that visits every vertex exactly once. A Hamiltonian Cycle is a path that visits every vertex exactly once and returns to the starting node. **Details**: 1. Implement a function `find_hamiltonian_path_or_cycle(graph: Dict[int, List[int]], max_node: int) -> None` that: - Takes a graph (as an adjacency list) and the maximum node number. - Prints if the graph has a Hamiltonian Path or Cycle, or none. - Prints the Hamiltonian Path/Cycle if it exists, otherwise prints \\"no path\\". 2. You may assume that the graph nodes are indexed from 1 to `max_node`. **Input Format**: - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of integers representing adjacent nodes. - `max_node`: An integer representing the maximum node identifier. **Output Format**: - Print statements explaining whether the graph has a Hamiltonian Path or Cycle, or none, followed by the path list if a path exists. **Constraints**: - The graph can be sparse with many nodes that might not have outgoing or incoming edges. - Nodes without outgoing edges are valid input but won\'t form a Hamiltonian path on their own. **Examples**: ```python def find_hamiltonian_path_or_cycle(graph, max_node): # Your implementation here # Example usage: g1 = {1: [2], 2: [3], 3: [4], 4: [1, 5], 5: []} find_hamiltonian_path_or_cycle(g1, 5) # Output: # graph has a Hamiltonian path # [1, 2, 3, 4, 5] g2 = {1: [2, 3], 2: [3, 4], 3: [4, 2], 4: [1, 5], 5: [3]} find_hamiltonian_path_or_cycle(g2, 5) # Output: # graph has a Hamiltonian cycle # [1, 2, 3, 4, 5, 1] g3 = {1: [], 2: [], 3: []} find_hamiltonian_path_or_cycle(g3, 3) # Output: # graph is not Hamiltonian # no path ```","solution":"def find_hamiltonian_path_or_cycle(graph, max_node): def is_hamiltonian_path(path): return len(path) == max_node and len(set(path)) == max_node def dfs(node, path): if is_hamiltonian_path(path): return path[:] for neighbor in graph[node]: if neighbor not in path: path.append(neighbor) result = dfs(neighbor, path) if result: return result path.pop() return None for start in range(1, max_node + 1): path = [start] hamiltonian_path = dfs(start, path) if hamiltonian_path: print(\\"graph has a Hamiltonian path\\") print(hamiltonian_path) if hamiltonian_path[0] in graph[hamiltonian_path[-1]]: print(\\"graph has a Hamiltonian cycle\\") print(hamiltonian_path + [hamiltonian_path[0]]) return print(\\"graph is not Hamiltonian\\") print(\\"no path\\")"},{"question":"# Coding Assessment Question **Problem Statement:** Implement a function to evaluate the determinant of a given square matrix using recursion. Given a matrix of size (n times n), the function should return its determinant. The input matrix will always be non-singular and will have integer elements. **Function Signature:** ```python def determinant(matrix: List[List[int]]) -> int: pass ``` **Input:** * `matrix`: A 2D list of integers representing the square matrix of dimensions ([n times n]). **Output:** * An integer representing the determinant of the matrix. **Constraints:** * The size of the matrix ([n times n]) will be such that (2 leq n leq 10). * All elements in the matrix are integers in the range ([-100, 100]). **Example:** ```python matrix1 = [[1, 2], [3, 4]] print(determinant(matrix1)) # Expected Output: -2 matrix2 = [[6, 1, 1], [4, -2, 5], [2, 8, 7]] print(determinant(matrix2)) # Expected Output: -306 ``` **Explanation:** - For the first example, the determinant is calculated as ( (1 times 4) - (2 times 3) = 4 - 6 = -2 ). - For the second example, the determinant is calculated using the recursive formula for determinant evaluation. **Notes:** * Use recursive function to handle matrix minors and compute the determinant. * Consider edge cases where the matrix size is very small, such as (2 times 2). * The matrix will be non-singular, so its determinant will always be non-zero. --- By incorporating this question into your coding assessment, the set of questions will maintain a consistent style, complexity, and topic alignment. This question requires understanding and applying mathematical concepts, thus effectively testing the candidate\'s abilities in a different but complementary aspect of matrix operations.","solution":"from typing import List def determinant(matrix: List[List[int]]) -> int: n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] # Function to get the minor matrix by removing the ith row and jth column def get_minor(mat, i, j): return [row[:j] + row[j+1:] for row in (mat[:i] + mat[i+1:])] det = 0 for c in range(n): det += ((-1)**c) * matrix[0][c] * determinant(get_minor(matrix, 0, c)) return det"},{"question":"# Question: Smallest Missing Positive Integer You are given an unsorted integer array `arr` of size `n`. Your task is to find the smallest positive integer that doesn\'t appear in the array. # Input Format - A list of integers `arr` where each integer can be between `[-2^31, 2^31 - 1]`. - The size `n` of the array (where ( 1 leq n leq 10^5 )). # Output Format - A single integer, the smallest positive integer not present in the array. # Requirements - Implement a function `find_missing_positive(arr: List[int]) -> int` which takes in the list of integers and returns the smallest positive integer not found in the list. # Constraints - The array may contain duplicate elements. - Aim to implement an efficient solution with optimal time and space complexity. # Performance - The solution should be able to handle an array size up to (10^5) efficiently. # Example ```python def test_find_missing_positive(): assert find_missing_positive([3, 4, -1, 1]) == 2 assert find_missing_positive([1, 2, 0]) == 3 assert find_missing_positive([7, 8, 9, 11, 12]) == 1 assert find_missing_positive([1, 2, 3, 4, 5, 6]) == 7 def main(): n = int(input().strip()) arr = list(map(int, input().strip().split())) print(find_missing_positive(arr)) if __name__ == \'__main__\': main() ``` Write an optimized function `find_missing_positive(arr: List[int]) -> int` to solve the given problem effectively.","solution":"def find_missing_positive(arr): Finds the smallest missing positive integer from the list. n = len(arr) # Phase 1: Mark elements outside the range [1, n] as n+1 (since we only need to find within the array length) for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Phase 2: Use the index as a hash key and mark presence of an element for i in range(n): num = abs(arr[i]) if num <= n: arr[num - 1] = -abs(arr[num - 1]) # Phase 3: Find the first positive number which means the index + 1 is missing for i in range(n): if arr[i] > 0: return i + 1 # If all numbers from 1 to n are present return n + 1"},{"question":"# Problem Context You need to create a function that parses a mathematical expression consisting of addition and multiplication of integers, and returns the result. The input will be provided as a string which is a valid mathematical expression containing non-negative integers, the addition operator `+`, and the multiplication operator `*`. # Task Implement a function `evaluate_expression(expression: str) -> int` that evaluates the mathematical expression following the standard order of operations (multiplication before addition). # Requirements * **Input**: * `expression`: A string representing a mathematical expression. * **Output**: An integer representing the result of the evaluated expression. * **Constraints**: * The expression will only contain non-negative integers, addition (`+`) and multiplication (`*`) operators. * The expression will not contain any spaces. * The expression will be non-empty and valid. # Examples ```python >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"3*3*3\\") 27 >>> evaluate_expression(\\"5+6+7\\") 18 >>> evaluate_expression(\\"1+1*1+1\\") 3 >>> evaluate_expression(\\"2*2*2*2\\") 16 ``` **Tip**: Process the expression respecting the order of operations. You might find it helpful to split the task into two passes: one to handle multiplication and another to handle addition.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of non-negative integers, addition (+) and multiplication (*) operators. Parameters: expression (str): A string representing a mathematical expression. Returns: int: Result of the evaluated expression. # Split by addition addition_parts = expression.split(\'+\') result = 0 for part in addition_parts: # Evaluate multiplication for each part multiplication_parts = map(int, part.split(\'*\')) product = 1 for num in multiplication_parts: product *= num # Add the product to the result result += product return result"},{"question":"# Problem: Efficient Matrix Diagonal Sum Context: You\'ve been hired to enhance the performance of a scientific computing application that frequently computes the diagonal sum of large square matrices. The current implementation uses a naive approach and does not meet the performance and memory constraints required for large datasets. Objective: Implement a function `optimized_diagonal_sum(matrix: List[List[int]]) -> int` that calculates the sum of the main diagonal of a square matrix, but optimizes the runtime performance and memory usage. # Constraints: - The input matrix is a non-null square matrix (same number of rows and columns). - Matrix dimensions `n` can be up to 1000 (i.e., an `n x n` matrix). - Each element of the matrix is an integer between -10^6 and 10^6. # Input: - `matrix`: A list of lists representing the square matrix of integers. # Output: - Return an integer representing the sum of the main diagonal elements of the matrix. # Performance Requirements: - Aim to reduce the time complexity of iterating through the matrix to O(n). Example: ```python def optimized_diagonal_sum(matrix: List[List[int]]) -> int: pass # your implementation here # Test cases print(optimized_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # 15 print(optimized_diagonal_sum([[5, 3, 1], [9, 7, 2], [4, 8, 6]])) # 18 print(optimized_diagonal_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]])) # 0 print(optimized_diagonal_sum([[1]])) # 1 print(optimized_diagonal_sum([[2, 1], [3, 4]])) # 6 ```","solution":"def optimized_diagonal_sum(matrix): Calculates the sum of the main diagonal of a square matrix. Args: matrix (list of list of int): The input square matrix. Returns: int: The sum of the main diagonal elements. n = len(matrix) diagonal_sum = 0 for i in range(n): diagonal_sum += matrix[i][i] return diagonal_sum"},{"question":"**Context**: You are building a feature for a social media application that suggests new friends to users. Each user is represented as a node in a graph, and friendships are represented as undirected edges between nodes. Your goal is to find and return a list of friend suggestions for a given user based on their immediate friends\' friends (friends of friends). **Task**: Implement the `suggest_friends` function, which takes the user\'s ID and the friendship graph and returns a list of friend suggestions for that user. Avoid suggesting the user\'s current friends or the user themselves. **Function Signature**: ```python def suggest_friends(graph: dict, user: str) -> list: Suggest friends for a user based on their friends\' friends. :param graph: dict, an adjacency list representing the friendship graph :param user: str, the user\'s ID for whom to suggest friends :return: list, a list of suggested friend IDs sorted lexicographically ``` # Input: - `graph` (dict): A dictionary representing the friendship graph. Each key is a user ID, and its value is a list of IDs representing that user\'s friends. - `user` (str): The user ID for whom to suggest friends. # Output: - A list of user IDs representing suggested friends, sorted lexicographically. # Constraints: - Each user is identified by a unique string ID. - The friendship graph is undirected, meaning if user A is friends with user B, then user B is friends with user A. - Do not suggest the user themselves or their current friends as friend suggestions. - If no suggestions are available, return an empty list. # Example: ```python graph = { \\"Alice\\": [\\"Bob\\", \\"Charlie\\"], \\"Bob\\": [\\"Alice\\", \\"Dave\\"], \\"Charlie\\": [\\"Alice\\", \\"Eve\\"], \\"Dave\\": [\\"Bob\\"], \\"Eve\\": [\\"Charlie\\", \\"Frank\\"], \\"Frank\\": [\\"Eve\\"], } assert suggest_friends(graph, \\"Alice\\") == [\\"Dave\\", \\"Eve\\"] assert suggest_friends(graph, \\"Bob\\") == [\\"Charlie\\", \\"Eve\\"] assert suggest_friends(graph, \\"Charlie\\") == [\\"Bob\\", \\"Frank\\"] assert suggest_friends(graph, \\"Dave\\") == [\\"Alice\\", \\"Eve\\"] assert suggest_friends(graph, \\"Frank\\") == [\\"Alice\\", \\"Charlie\\"] assert suggest_friends(graph, \\"Eve\\") == [\\"Alice\\", \\"Bob\\"] ``` # Note: - Consider edge cases such as users with no friends or users whose friends have no other connections. - Ensure your function is efficient and handles larger graphs appropriately.","solution":"def suggest_friends(graph: dict, user: str) -> list: Suggest friends for a user based on their friends\' friends. :param graph: dict, an adjacency list representing the friendship graph :param user: str, the user\'s ID for whom to suggest friends :return: list, a list of suggested friend IDs sorted lexicographically if user not in graph: return [] direct_friends = set(graph[user]) friend_suggestions = set() for friend in direct_friends: friends_of_friend = graph.get(friend, []) for fof in friends_of_friend: if fof != user and fof not in direct_friends: friend_suggestions.add(fof) return sorted(friend_suggestions)"},{"question":"# Problem Statement Write a function `diagonal_matrix(n: int) -> list[list[int]]` that generates an `n x n` matrix with 1s on the main diagonal and 0s elsewhere. The function should: 1. Handle invalid input gracefully (non-integer and negative values). 2. Return the matrix as a list of lists, where each inner list represents a row of the matrix. # Constraints 1. `n` must be a non-negative integer. # Input - An integer `n`. **Examples:** ```python diagonal_matrix(4) # Output: # [ # [1, 0, 0, 0], # [0, 1, 0, 0], # [0, 0, 1, 0], # [0, 0, 0, 1] # ] diagonal_matrix(2) # Output: # [ # [1, 0], # [0, 1] # ] ``` # Implementation Details - Raise a `ValueError` with the message `\\"The input must be a non-negative integer\\"` if the input is invalid. - Ensure the matrix is correctly formed with the main diagonal containing 1s and all other elements 0s.","solution":"def diagonal_matrix(n): Generates an n x n matrix with 1s on the main diagonal and 0s elsewhere. Args: n (int): Size of the matrix (number of rows and columns). Must be a non-negative integer. Returns: list[list[int]]: The generated matrix. Raises: ValueError: If the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"The input must be a non-negative integer\\") matrix = [[1 if i == j else 0 for j in range(n)] for i in range(n)] return matrix"},{"question":"# Question: Find the Position of the First Set Bit You are asked to implement a function that finds the position of the first set bit (bit with value `1`) in the binary representation of a positive integer. The positions start from `1` (least significant bit). Function Signature ```python def find_first_set_bit(n: int) -> int: pass ``` # Input * `n` (int): A positive integer ( (1 leq n leq 10^{9}) ) # Output * An integer representing the position of the first set bit in the binary representation of `n`. # Constraints 1. The input will always be a positive integer. 2. You should not use any built-in methods or libraries that directly solve the problem. # Performance Requirements 1. The function should run in constant time, O(1). # Example ```python assert find_first_set_bit(18) == 2 # binary: 10010 assert find_first_set_bit(36) == 3 # binary: 100100 assert find_first_set_bit(16) == 5 # binary: 10000 assert find_first_set_bit(58) == 2 # binary: 111010 assert find_first_set_bit(1) == 1 # binary: 1 ``` # Scenario You are developing a debugging tool for binary data analysis. One of the requirements is to find the position of the first set bit in the binary representation of various signals. Implement the `find_first_set_bit()` function to handle this functionality effectively. # Implementation Guidelines * Your implementation should handle the given constraints effectively. * Be sure to manage edge cases, including the smallest and largest possible input values within the given range.","solution":"def find_first_set_bit(n: int) -> int: Finds the position of the first set bit in the binary representation of `n`. Positions start from 1 (least significant bit). position = 1 while (n & 1) == 0: n >>= 1 position += 1 return position"},{"question":"# Problem Statement You are given an integer `n` and a list of `edges` representing an undirected graph where each edge is a tuple `(u, v)` indicating a connection between vertices `u` and `v`. Your task is to implement functions that compute various metrics of this graph to help analyze its connectivity and structure. Implement the following three functions: 1. `number_of_connected_components(n: int, edges: list[tuple[int, int]]) -> int` * **Input**: Integer `n` representing the number of vertices and a list of `edges` representing the connections. * **Output**: Integer representing the number of connected components in the graph. 2. `largest_connected_component_size(n: int, edges: list[tuple[int, int]]) -> int` * **Input**: Integer `n` representing the number of vertices and a list of `edges` representing the connections. * **Output**: Integer representing the size of the largest connected component in the graph. 3. `is_graph_cyclic(n: int, edges: list[tuple[int, int]]) -> bool` * **Input**: Integer `n` representing the number of vertices and a list of `edges` representing the connections. * **Output**: Boolean value indicating whether the graph contains any cycles. # Constraints: * `1 <= n <= 1000` * `0 <= len(edges) <= min(2000, n * (n - 1) // 2)` * `0 <= u, v < n` * `u != v` (no self-loops) * There are no duplicate edges. # Examples For an undirected graph with `n = 5` and `edges = [(0, 1), (1, 2), (3, 4)]`: 1. `number_of_connected_components(n, edges)` should return `2`. 2. `largest_connected_component_size(n, edges)` should return `3`. 3. `is_graph_cyclic(n, edges)` should return `False`. For an undirected graph with `n = 6` and `edges = [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)]`: 1. `number_of_connected_components(n, edges)` should return `2`. 2. `largest_connected_component_size(n, edges)` should return `3`. 3. `is_graph_cyclic(n, edges)` should return `True`. # Directions: * Implement each function as described. * Aim for optimal time and space complexity. * Consider edge cases like disconnected graphs, cycles, or isolated vertices.","solution":"def number_of_connected_components(n, edges): Returns the number of connected components in an undirected graph. Parameters: - n: Integer representing the number of vertices. - edges: List of tuples representing the connections between vertices. Returns: - Integer representing the number of connected components. def dfs(v, visited, adj_list): stack = [v] while stack: node = stack.pop() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * n count = 0 for i in range(n): if not visited[i]: count += 1 visited[i] = True dfs(i, visited, adj_list) return count def largest_connected_component_size(n, edges): Returns the size of the largest connected component in an undirected graph. Parameters: - n: Integer representing the number of vertices. - edges: List of tuples representing the connections between vertices. Returns: - Integer representing the size of the largest connected component. def dfs_size(v, visited, adj_list): size = 0 stack = [v] while stack: node = stack.pop() size += 1 for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) return size adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * n largest_size = 0 for i in range(n): if not visited[i]: visited[i] = True largest_size = max(largest_size, dfs_size(i, visited, adj_list)) return largest_size def is_graph_cyclic(n, edges): Checks if the undirected graph contains any cycles. Parameters: - n: Integer representing the number of vertices. - edges: List of tuples representing the connections between vertices. Returns: - Boolean value indicating whether the graph contains any cycles. def dfs(v, visited, parent, adj_list): stack = [(v, parent)] while stack: node, parent = stack.pop() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True stack.append((neighbor, node)) elif neighbor != parent: return True return False adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * n for i in range(n): if not visited[i]: visited[i] = True if dfs(i, visited, -1, adj_list): return True return False"},{"question":"# Question: Implement a Custom Command Line Argument Parser Background A command line argument parser is a common utility in many programming tasks. It processes command-line arguments passed to a program and provides an easy interface to access those arguments. For this task, you need to create a simplified version of a command line argument parser that can handle positional arguments, optional arguments, and flags. # Task 1. **Positional Arguments**: - Implement support for positional arguments which are mandatory and are provided in a specific order. 2. **Optional Arguments**: - Implement support for optional arguments that follow the format `--arg=value` or `-a value`. 3. **Flags**: - Implement support for flags which are boolean switches that do not take a value and are specified as `--flag` or `-f`. 4. **Error Handling**: - Ensure the parser handles erroneous input gracefully. For instance, raising appropriate exceptions when required arguments are missing, or invalid formats are provided. Function Signatures * `def parse_args(args: list[str], pos_args: list[str], opt_args: dict[str, str], flags: list[str]) -> dict` # Constraints * The `args` parameter will be a list of strings representing the command line input, e.g., `[\'program_name\', \'pos1\', \'--option=value\', \'-f\']`. * The `pos_args` parameter will be a list of strings representing the names of positional arguments, e.g., `[\'input_file\', \'output_file\']`. * The `opt_args` parameter will be a dictionary where keys are the option names and values are their default values, e.g., `{\'--log\': \'logfile.log\', \'-d\': \'data/\'}`. * The `flags` parameter will be a list of flag names, e.g., `[\'--verbose\', \'-v\']`. # Examples ```python args = [\'program_name\', \'input.txt\', \'output.txt\', \'--log=log.txt\', \'-v\'] pos_args = [\'input_file\', \'output_file\'] opt_args = {\'--log\': \'default.log\', \'-d\': \'default/\'} flags = [\'--verbose\', \'-v\'] parsed_arguments = parse_args(args, pos_args, opt_args, flags) # Expected Output: # { # \'input_file\': \'input.txt\', # \'output_file\': \'output.txt\', # \'--log\': \'log.txt\', # \'-d\': \'default/\', # \'--verbose\': True, # \'-v\': True # } ``` # Notes * Ensure your code handles invalid input gracefully, such as missing required positional arguments or incorrect formats for options and flags. * Document your code with appropriate comments and docstrings to ensure clarity.","solution":"def parse_args(args, pos_args, opt_args, flags): Parses command line arguments. :param args: List of input arguments. :param pos_args: List of positional arguments. :param opt_args: Dictionary of optional arguments with their default values. :param flags: List of flags. :return: Dictionary with parsed arguments. if not args: raise ValueError(\\"No arguments provided.\\") # Start parsing from the second argument as the first is the program name args = args[1:] # Initialize the result dictionary result = {key: None for key in pos_args} result.update(opt_args) result.update({flag: False for flag in flags}) # Parse positional arguments for i, pos_arg in enumerate(pos_args): if i >= len(args) or args[i].startswith(\'-\'): raise ValueError(f\\"Missing required positional argument: {pos_arg}\\") result[pos_arg] = args[i] # Parse the remaining arguments for options and flags i = len(pos_args) while i < len(args): arg = args[i] if arg in flags: # Handle flags result[arg] = True i += 1 elif \\"=\\" in arg: # Handle --arg=value format key, value = arg.split(\\"=\\", 1) if key in opt_args: result[key] = value else: raise ValueError(f\\"Unknown optional argument: {key}\\") i += 1 elif i + 1 < len(args) and args[i] in opt_args: # Handle -a value format key = args[i] value = args[i + 1] result[key] = value i += 2 else: raise ValueError(f\\"Unknown argument format: {arg}\\") return result"},{"question":"# Problem Description Write a function that takes a positive integer `n` and returns a list of strings representing the numbers from 1 to `n`. But for multiples of three, return \\"Fizz\\" instead of the number and for the multiples of five, return \\"Buzz\\". For numbers which are multiples of both three and five, return \\"FizzBuzz\\". # Function Signature ```python def fizz_buzz(n: int) -> list[str]: Generates a list of strings representing numbers from 1 to n with specific substitutions: - For multiples of three, use \\"Fizz\\". - For multiples of five, use \\"Buzz\\". - For multiples of both three and five, use \\"FizzBuzz\\". :param n: An integer up to which the numbers will be considered. :return: A list of strings with substitutions for Fizz, Buzz, and FizzBuzz. Examples: >>> fizz_buzz(5) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\'] >>> fizz_buzz(15) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\'] >>> fizz_buzz(1) [\'1\'] ``` # Input - A positive integer `n` (1  n  10). # Output - A list of `n` strings according to the rules specified: - Return \\"Fizz\\" for multiples of 3. - Return \\"Buzz\\" for multiples of 5. - Return \\"FizzBuzz\\" for multiples of both 3 and 5. - Return the number itself for all other cases. # Constraints - `n` will always be a positive integer within the range from 1 to 10. # Example ```python assert fizz_buzz(5) == [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\'] assert fizz_buzz(15) == [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\'] assert fizz_buzz(1) == [\'1\'] ```","solution":"def fizz_buzz(n: int) -> list[str]: Generates a list of strings representing numbers from 1 to n with specific substitutions: - For multiples of three, use \\"Fizz\\". - For multiples of five, use \\"Buzz\\". - For multiples of both three and five, use \\"FizzBuzz\\". :param n: An integer up to which the numbers will be considered. :return: A list of strings with substitutions for Fizz, Buzz, and FizzBuzz. Examples: >>> fizz_buzz(5) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\'] >>> fizz_buzz(15) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\'] >>> fizz_buzz(1) [\'1\'] result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"# Implement a Simple Chat Server with Asynchronous I/O You are asked to develop a simple chat server that supports multiple clients concurrently. The server should use asynchronous I/O to handle multiple connections efficiently and ensure that messages from any client are broadcasted to all connected clients. Function Specification: Implement the function `start_chat_server(host: str = \'localhost\', port: int = 12345) -> None`. This function should: 1. Create an asynchronous server socket that listens on the specified host and port. 2. Accept multiple client connections concurrently. 3. Relay any message received from a client to all other connected clients. 4. Implement error handling to manage network errors and sudden client disconnections. 5. Add logging to provide insights into the server\'s operation (connection events, message relay, errors, etc.). Input: - `host` (str): The host address on which the server listens. Defaults to `\'localhost\'`. - `port` (int): The port number on which the server listens. Defaults to `12345`. Constraints: - The server should handle an arbitrary number of clients. - The server should efficiently manage incoming and outgoing messages to and from clients. - Pay attention to performance and robustness, especially with concurrent client handling. - Use asynchronous I/O operations for socket interactions. - Ensure the server handles graceful shutdowns (e.g., using signal handlers for SIGINT). Example Usage: ```python if __name__ == \\"__main__\\": start_chat_server(\'0.0.0.0\', 12345) ``` In this example, the server will start, listen for incoming connections on all available network interfaces at port `12345`, and relay messages between clients. Notes: - You do not need to implement the client-side code, but you may write it for your testing purposes. - Consider Python\'s `asyncio` module for managing asynchronous socket operations. - Ensure your server closes all connections gracefully and handles partial reads/writes appropriately.","solution":"import asyncio import logging logging.basicConfig(level=logging.INFO) clients = [] async def handle_client(reader, writer): addr = writer.get_extra_info(\'peername\') logging.info(f\\"Client {addr} connected\\") clients.append((reader, writer)) try: while True: data = await reader.read(100) if not data: break message = data.decode() logging.info(f\\"Received message from {addr}: {message}\\") broadcast_message = f\\"{addr}: {message}\\" await send_to_all(broadcast_message) except (asyncio.CancelledError, asyncio.IncompleteReadError, ConnectionResetError): logging.info(f\\"Client {addr} disconnected\\") finally: clients.remove((reader, writer)) writer.close() await writer.wait_closed() logging.info(f\\"Client {addr} connection closed\\") async def send_to_all(message): for reader, writer in clients: writer.write(message.encode()) await writer.drain() async def start_chat_server(host=\'localhost\', port=12345): server = await asyncio.start_server(handle_client, host, port) addr = server.sockets[0].getsockname() logging.info(f\'Serving on {addr}\') async with server: await server.serve_forever()"},{"question":"# Problem Statement David is creating a simple command-line tool to manage statistics about a sequence of floating-point numbers he often needs to process. He needs a function that computes three key statistical measures from a list of numbers: the mean (average), the median, and the mode. Implement a function `compute_statistics(numbers: List[float]) -> Tuple[float, float, List[float]]` that takes a list of floating-point numbers and returns a tuple containing: 1. The mean (average) of the numbers as a floating-point number. 2. The median of the numbers as a floating-point number. 3. The mode of the numbers as a list of floating-point numbers (since there can be more than one mode). # Input: * `numbers` (1 <= len(numbers) <= 10^5): A list of floating-point numbers. # Output: * Returns a tuple (mean, median, mode). Example: * `compute_statistics([1.0, 2.0, 2.0, 3.0])` should return `(2.0, 2.0, [2.0])`. Explanation: * Mean: (1.0 + 2.0 + 2.0 + 3.0) / 4 = 2.0 * Median: - Sorting the numbers gives [1.0, 2.0, 2.0, 3.0] - The middle elements are 2.0 and 2.0 (even number of elements), so the median is (2.0 + 2.0) / 2 = 2.0 * Mode: The most frequent number is 2.0, so the mode is [2.0]. * `compute_statistics([1.0, 1.0, 2.5, 3.7, 3.7, 4.0])` should return `(2.65, 3.1, [1.0, 3.7])`. Explanation: * Mean: (1.0 + 1.0 + 2.5 + 3.7 + 3.7 + 4.0) / 6  2.65 * Median: - Sorting the numbers gives [1.0, 1.0, 2.5, 3.7, 3.7, 4.0] - The middle elements are 2.5 and 3.7 (even number of elements), so the median is (2.5 + 3.7) / 2  3.1 * Mode: The numbers 1.0 and 3.7 both appear most frequently (twice), so the mode is [1.0, 3.7]. # Constraints: * Ensure that the function handles cases where the mode is not unique. * The function should properly handle cases where the list length is even or odd. * Consider handling edge cases such as all numbers being the same or having floating-point precision issues.","solution":"from typing import List, Tuple from collections import Counter def compute_statistics(numbers: List[float]) -> Tuple[float, float, List[float]]: if not numbers: return (0.0, 0.0, []) n = len(numbers) # Compute mean mean = sum(numbers) / n # Compute median sorted_numbers = sorted(numbers) if n % 2 == 0: median = (sorted_numbers[n // 2 - 1] + sorted_numbers[n // 2]) / 2 else: median = sorted_numbers[n // 2] # Compute mode counts = Counter(numbers) max_freq = max(counts.values()) mode = [num for num, freq in counts.items() if freq == max_freq] return (mean, median, mode)"},{"question":"# Problem Description: You are working at a logistics company and your task is to determine the optimal route for a delivery truck to deliver packages to multiple destinations. The truck should start at the depot (which is also its final stop after deliveries), and visit each destination exactly once before returning to the depot. This is a classic Traveling Salesman Problem (TSP). # Function Signature: ```python def optimal_delivery_route(n: int, distances: List[List[int]]) -> int: pass ``` # Input: - `n`: An integer representing the number of locations including the depot. - `distances`: A 2D list where `distances[i][j]` represents the distance between location `i` and location `j`. # Output: - An integer representing the minimum distance the truck has to travel to deliver all packages and return to the depot. # Constraints: - (1 leq n leq 20) - (0 leq distances[i][j] leq 10^3) - `distances[i][i]` will be (0) - The matrix `distances` is symmetric, i.e., `distances[i][j] = distances[j][i]` # Example: ```python # Example Usage n = 4 distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] print(optimal_delivery_route(n, distances)) # Output: 80 ``` # Explanation: In the given example, the truck starts at the depot (location 0), and the optimal route that minimizes the travel distance is 0 -> 1 -> 3 -> 2 -> 0 with a total distance of 80. # Notes: - You can use dynamic programming or other optimization algorithms to solve the TSP within the given constraints. - Since the input size is relatively small (n  20), consider using a bitmask DP approach to explore all possible routes efficiently. # Edge Cases: - Verify that it handles the smallest possible input, where `n = 1`, and the distance matrix is `[[0]]`. - Ensure the function correctly calculates minimal routes even with varying distances between locations.","solution":"from typing import List def optimal_delivery_route(n: int, distances: List[List[int]]) -> int: # Initialize memoization table with -1 indicating uncalculated states memo = [[-1] * (1 << n) for _ in range(n)] def tsp(pos, mask): if mask == (1 << n) - 1: return distances[pos][0] if memo[pos][mask] != -1: return memo[pos][mask] answer = float(\'inf\') for city in range(n): if mask & (1 << city) == 0: new_mask = mask | (1 << city) answer = min(answer, distances[pos][city] + tsp(city, new_mask)) memo[pos][mask] = answer return answer # Start from the depot with only the depot visited return tsp(0, 1)"},{"question":"Infix to Postfix Conversion Given the function prototypes and descriptions below, implement an algorithm to convert an infix expression (containing various operators and parentheses) to a postfix expression. # Input - A string representing a valid infix expression consisting of: - Operands (single lowercase alphabetical characters, e.g., `a`, `b`, `c`, ...) - Operators (`+`, `-`, `*`, `/`, `^`) - Parentheses (`(` and `)`) # Output - A string representing the equivalent postfix expression. # Constraints - The infix expression will be non-empty and at most of length 100. - Assume the input expression is always valid. # Example ```python >>> infix_to_postfix(\\"a+b*c\\") \'abc*+\' >>> infix_to_postfix(\\"(a+b)*c\\") \'ab+c*\' >>> infix_to_postfix(\\"a+b*(c^d-e)^(f+g*h)-i\\") \'abcd^e-fgh*+^*+i-\' ``` # Task Implement the following Python function: ```python def infix_to_postfix(expression: str) -> str: # your code here ```","solution":"def infix_to_postfix(expression: str) -> str: precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2, \'^\': 3} stack = [] output = [] def has_higher_precedence(op1, op2): return precedence[op1] >= precedence[op2] for ch in expression: if ch.isalpha(): output.append(ch) elif ch == \'(\': stack.append(ch) elif ch == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() # pop \'(\' from stack else: # operator while stack and stack[-1] != \'(\' and has_higher_precedence(stack[-1], ch): output.append(stack.pop()) stack.append(ch) while stack: output.append(stack.pop()) return \'\'.join(output)"},{"question":"Problem Statement Write a function that takes an integer array representing the heights of terrain along a line and calculates the amount of water that could be trapped between the terrain after raining. The function should efficiently compute the total volume of trapped water using an O(N) algorithm. # Function Signature ```python def trap_rain_water(height: list[int]) -> int: ``` # Input - `height` (List of int): A list of non-negative integers representing the terrain heights, 0  len(height)  10^5, 0  height[i]  10^4. # Output - `int`: The total amount of trapped rainwater. # Constraints - Function should run in O(N) time complexity. - Function should handle edge cases such as an empty array or arrays with no gaps to trap water. # Example ```python >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_rain_water([]) 0 >>> trap_rain_water([3, 3, 3, 3]) 0 ``` # Guidelines 1. Begin by implementing the helper functions to maintain left and right maximum heights while iterating through the array. 2. Use two pointers to traverse the list from both ends and compute trapped water by comparing left and right maximum heights. 3. Ensure the implementation handles various edge cases and performs efficiently for large input sizes. # Performance Requirements The function should efficiently handle input lists up to 100,000 in length, ensuring optimal memory usage and linearly scaling with the input size. Focus on using constant space and avoid unnecessary computations.","solution":"def trap_rain_water(height: list[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the total trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"# Context You are designing a text auto-completion feature for a search engine. To achieve this, you will implement a Trie data structure that supports insertion and search operations. The Trie should allow users to add words and check if a word or prefix exists in the Trie. # Problem Statement Implement a `Trie` class that supports the following methods: - `insert(self, word)`: Inserts a word into the Trie. - `search(self, word)`: Returns `True` if the word is in the Trie, `False` otherwise. - `starts_with(self, prefix)`: Returns `True` if there is any word in the Trie that starts with the given prefix, `False` otherwise. # Requirements 1. The Trie should allow for efficient insertion and search operations. 2. Make sure to handle edge cases, such as inserting empty strings and checking for empty prefixes. 3. You are allowed to use internal helper methods if necessary. # Constraints - The words consist of lowercase English letters only. - The length of each word and prefix is between 1 and 1000. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): # Initialize the root of the Trie self.root = TrieNode() def insert(self, word): # Insert a word into the Trie pass def search(self, word): # Search for a word in the Trie pass def starts_with(self, prefix): # Check if there is any word in the Trie that starts with the given prefix pass ``` # Example Usage ```python trie = Trie() trie.insert(\\"hello\\") print(trie.search(\\"hello\\")) # Output: True print(trie.search(\\"hell\\")) # Output: False print(trie.starts_with(\\"hell\\")) # Output: True trie.insert(\\"hell\\") print(trie.search(\\"hell\\")) # Output: True ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True def search(self, word): current = self.root for letter in word: if letter not in current.children: return False current = current.children[letter] return current.is_end_of_word def starts_with(self, prefix): current = self.root for letter in prefix: if letter not in current.children: return False current = current.children[letter] return True"},{"question":"# Character Permutations Checker Create a function that determines whether two given strings are permutations of each other. Two strings are considered permutations if you can rearrange one to get the other using exactly the same characters and frequency. This function will help ensure that two strings contain precisely the same characters and the same number of each character. Function Signature ```python def are_permutations(str1: str, str2: str) -> bool: Checks if the two given strings are permutations of each other. :param str1: First input string. :param str2: Second input string. :return: True if the strings are permutations of each other, False otherwise. ``` Input & Output **Input**: - Two strings, `str1` and `str2`. **Output**: - A boolean value: `True` if the strings are permutations of each other, `False` otherwise. Constraints: - The function should be case-sensitive. - An empty string is considered a permutation of another empty string. - Strings can contain spaces and non-alphanumeric characters. Example ```python assert are_permutations(\\"listen\\", \\"silent\\") == True assert are_permutations(\\"triangle\\", \\"integral\\") == True assert are_permutations(\\"apple\\", \\"pale\\") == False assert are_permutations(\\"abcde\\", \\"edcba\\") == True assert are_permutations(\\"\\", \\"\\") == True assert are_permutations(\\"A gentleman\\", \\"Elegant man\\") == False # Case-sensitive ``` Implement the `are_permutations` function ensuring optimal performance and correct handling of edge cases.","solution":"def are_permutations(str1: str, str2: str) -> bool: Checks if the two given strings are permutations of each other. :param str1: First input string. :param str2: Second input string. :return: True if the strings are permutations of each other, False otherwise. if len(str1) != len(str2): return False # Using a hashmap (counter) to count the frequency of each character from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"# Subarray Sum Challenge Question You are given an array of integers and a target sum. Your task is to write a function that finds the length of the smallest contiguous subarray for which the sum `>=` the target sum. If no such subarray exists, return 0. Implement a function `min_subarray_len` that takes an integer list `nums` and an integer `target` and returns the length of the smallest contiguous subarray that meets the condition. Signature ```python def min_subarray_len(nums: list[int], target: int) -> int: ``` Input * **nums**: (list of int) A list of integers. ( 0 leq text{len}(nums) leq 10^5 ) * **target**: (int) The target sum. (0 leq text{target} leq 10^9 ) Output * Returns an integer representing the length of the smallest contiguous subarray for which the sum is greater than or equal to the target sum. If no such subarray exists, return 0. Example ```python >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 ``` Explanation: The smallest subarray with sum >= 7 is `[4,3]`. ```python >>> min_subarray_len([1, 4, 4], 4) 1 ``` Explanation: The smallest subarray with sum >= 4 is `[4]`. ```python >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 ``` Explanation: No subarray with sum >= 11 exists. Constraints 1. The function should be optimized for efficient computation given the constraints on the length of the array. 2. Handling negative numbers can be complex, so it is safe to assume all numbers in `nums` are non-negative for the purpose of this question. 3. Consider edge cases such as an empty array or target sum larger than the sum of all elements in `nums`. Implementation Notes 1. Utilize techniques such as sliding window or two-pointer approach to optimize the solution. 2. Avoid nested loops to ensure the algorithm runs efficiently on large inputs.","solution":"def min_subarray_len(nums: list[int], target: int) -> int: n = len(nums) min_len = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= nums[start] start += 1 return min_len if min_len <= n else 0"},{"question":"# Coding Challenge: Implementing a Balanced Binary Search Tree (BST) Given a sequence of integers, write a function to create a balanced Binary Search Tree (BST). A balanced BST ensures that for each node, the height difference between the left and right subtrees is at most 1. # Task Create a function `balanced_bst` that receives a list of integers as input and constructs a balanced Binary Search Tree. The tree nodes should be instances of the `TreeNode` class provided. # Function Signature ```python class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key def balanced_bst(nums: list[int]) -> TreeNode: ``` # Inputs - `nums`: A list of integers representing the sequence of numbers. # Outputs - Returns the root node of the balanced Binary Search Tree. # Constraints 1. The input list may be empty, in which case the function should return `None`. 2. The input list may contain duplicate integers. 3. The integers in the input list may be in any order. # Example ```python nums = [3, 1, 7, 5, 9, 8, 2] root = balanced_bst(nums) def inorder(root: TreeNode): return inorder(root.left) + [root.val] + inorder(root.right) if root else [] print(inorder(root)) # Expected Output (Ascending Order): # [1, 2, 3, 5, 7, 8, 9] ``` # Additional Information - You may use helper functions and additional classes if necessary. - Ensure the resulting BST is balanced and adheres to the properties of a BST. - Optimize for the construction speed and balanced height. # Hints - Consider sorting the list and using a divide-and-conquer approach. - Focus on constructing the tree bottom-up to make it balanced. - You can recursively assign the middle element of the sorted list as the root and repeat for left and right subtrees.","solution":"class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key def balanced_bst(nums: list[int]) -> TreeNode: Constructs a balanced BST from the given list of integers. if not nums: return None nums.sort() def build_bst(low, high): if low > high: return None mid = (low + high) // 2 root = TreeNode(nums[mid]) root.left = build_bst(low, mid - 1) root.right = build_bst(mid + 1, high) return root return build_bst(0, len(nums) - 1)"},{"question":"# Problem Statement You are given a string containing a list of words separated by spaces. Your task is to write a function that will return a dictionary where the keys are the distinct words in the string, and the values are the counts of occurrences of those words. # Input - A single string, `input_string`, containing a list of words separated by spaces. # Output - A dictionary where each key is a distinct word from the input string and each corresponding value is the number of times that word appears in the input string. # Constraints - The input string will only contain alphabetical characters and spaces. - The input string should be non-empty. # Function Signature ```python def word_count(input_string: str) -> dict: ``` # Examples ```python >>> word_count(\\"apple apple orange\\") {\'apple\': 2, \'orange\': 1} >>> word_count(\\"banana banana banana\\") {\'banana\': 3} >>> word_count(\\"word word word WORD\\") {\'word\': 4} >>> word_count(\\"this is a test this is only a test\\") {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 2, \'only\': 1} ``` # Implementation Guidance 1. Convert the input string to lowercase to ensure that the word count is case-insensitive. 2. Split the input string by spaces to obtain the list of words. 3. Create a dictionary to keep track of the occurrence count of each word. 4. Iterate through the list of words, updating the dictionary with the count of each word. # Note Consider implementing a helper function `_normalize_text` to convert the input string to lowercase and split it into words. ```python def word_count(input_string: str) -> dict: def _normalize_text(input_string: str): return input_string.lower().split() words = _normalize_text(input_string) word_count_dict = {} for word in words: if word in word_count_dict: word_count_dict[word] += 1 else: word_count_dict[word] = 1 return word_count_dict ```","solution":"def word_count(input_string: str) -> dict: Returns a dictionary with the count of each distinct word in the input string. Args: - input_string (str): The string containing a list of words separated by spaces. Returns: - dict: A dictionary where keys are distinct words and values are their counts. def _normalize_text(input_string: str): return input_string.lower().split() words = _normalize_text(input_string) word_count_dict = {} for word in words: if word in word_count_dict: word_count_dict[word] += 1 else: word_count_dict[word] = 1 return word_count_dict"},{"question":"# Coding Assessment Question **Problem Statement**: You are given a grid of size `n x m` where each cell contains a non-negative integer representing the cost to move across that cell. Your task is to find the minimum cost to traverse from the top-left cell `(0, 0)` to the bottom-right cell `(n-1, m-1)` using only rightward or downward movements. Implement this using dynamic programming. **Function Signature**: ```python def min_cost_traversal(grid: List[List[int]]) -> int: ``` **Input**: - `grid`: A 2D list of integers `grid` where `1 <= n, m <= 100` and each element `0 <= grid[i][j] <= 100`. **Output**: - Return an integer representing the minimum cost to traverse from `(0, 0)` to `(n-1, m-1)`. **Example**: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] Output: 7 Explanation: The path with the minimum cost is `1 -> 3 -> 1 -> 1 -> 1` starting from the top-left to the bottom-right, with a total cost of 7. ``` **Constraints**: - Each grid cell contains a non-negative integer cost. **Hints**: 1. Use a 2D list `dp` where `dp[i][j]` stores the minimum cost to reach cell `(i, j)`. 2. Initialize `dp[0][0]` with `grid[0][0]` and fill the first row and first column. 3. For each cell `(i, j)`, the minimum cost to reach it is the minimum of coming from the top `(i-1, j)` or from the left `(i, j-1)` plus the cost of the current cell. **Performance Requirements**: - The solution should have a time complexity of O(n * m). - The space complexity should be O(n * m). Write the function `min_cost_traversal` that accurately computes the minimum cost path for the given grid using dynamic programming. Consider all edge cases and constraints.","solution":"from typing import List def min_cost_traversal(grid: List[List[int]]) -> int: n = len(grid) m = len(grid[0]) # Create a dp array with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Initialize the start point dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the minimum cost to traverse the grid return dp[n-1][m-1]"},{"question":"# Problem Description You are given code for inverting a binary tree. Your task is to implement a function that will return a new binary tree where each node\'s left and right children are swapped. Ensure that the function works recursively. # Input and Output Format * **Input**: You will be given a binary tree root. Each node in the tree contains an integer value. * `root`: The root of the binary tree. * **Output**: Return the root of the new inverted binary tree. # Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * The values of the nodes are in the range `[0, 1000]`. # Implementation Requirements * Implement the function `invert_binary_tree(root: Node | None) -> Node | None`. # Example ```python from typing import Union class Node: def __init__(self, value: int = 0) -> None: self.value = value self.left: Union[Node, None] = None self.right: Union[Node, None] = None def invert_binary_tree(root: Node | None) -> Node | None: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the subtrees invert_binary_tree(root.left) invert_binary_tree(root.right) return root # Example to test the implementation def print_preorder(root: Node | None) -> None: if root: print(root.value) print_preorder(root.left) print_preorder(root.right) tree = Node(4) tree.left = Node(2) tree.right = Node(7) tree.left.left = Node(1) tree.left.right = Node(3) tree.right.left = Node(6) tree.right.right = Node(9) inverted_tree = invert_binary_tree(tree) print(\\"Inverted Tree is: \\") print_preorder(inverted_tree) ``` # Explanation Given the tree: ``` 4 / 2 7 / / 1 3 6 9 ``` The resulting inverted tree should be: ``` 4 / 7 2 / / 9 6 3 1 ```","solution":"from typing import Union class Node: def __init__(self, value: int = 0) -> None: self.value = value self.left: Union[Node, None] = None self.right: Union[Node, None] = None def invert_binary_tree(root: Union[Node, None]) -> Union[Node, None]: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the subtrees invert_binary_tree(root.left) invert_binary_tree(root.right) return root"},{"question":"# Question: Stock Profit Calculation with Transaction Fees **Context:** As a financial analyst, you are tasked with devising a strategy to maximize profit from stock trading while accounting for transaction fees. Each transaction incurs a certain fee, which reduces the effective profit from buying and selling stocks. **Problem Statement:** Write a function `max_profit(prices: List[int], fee: int) -> int` that calculates the maximum profit you can achieve from trading stocks, given their daily prices and a fixed transaction fee. You may buy and sell multiple times, but you must sell the stock before you buy again. **Requirements:** 1. The function should handle edge cases gracefully, such as scenarios with no prices or where the profit is negative after accounting for transaction fees. 2. Optimize the solution to run efficiently on larger datasets, as real-time calculations might be required. **Function Signature:** ```python def max_profit(prices: List[int], fee: int) -> int: pass ``` **Input:** * `prices`: A list of integers representing the daily stock prices. * `fee`: An integer representing the fixed transaction fee per trade. **Output:** * An integer representing the maximum profit after accounting for transaction fees. **Constraints:** * All prices and fees are non-negative integers. * The input list `prices` will have at most 100,000 elements. **Examples:** ```python # Example 1: max_profit([1, 3, 2, 8, 4, 9], 2) # Expected output: 8 # Example 2: max_profit([1, 3, 7, 5, 10, 3], 3) # Expected output: 6 # Example 3: max_profit([], 2) # Expected output: 0 # Example 4: max_profit([5, 5, 5, 5], 2) # Expected output: 0 ``` Ensure that your implementation is both time-efficient and handles various edge cases, including equal prices and high transaction fees that negate potential profits.","solution":"from typing import List def max_profit(prices: List[int], fee: int) -> int: if not prices: return 0 n = len(prices) cash = 0 # Keeps track of profit if we don\'t hold stock hold = -prices[0] # Keeps track of profit if we hold stock for i in range(1, n): cash = max(cash, hold + prices[i] - fee) hold = max(hold, cash - prices[i]) return cash"},{"question":"# Coding Task: Matrix Path Sum Calculation **Objective**: Implement an algorithm that calculates the minimum path sum in a matrix from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. Functions to Implement: 1. **`min_path_sum(matrix: List[List[int]]) -> int`**: - **Input**: - `matrix` (List of Lists of Integers): A 2D grid of integers representing the matrix. - **Output**: - Returns the minimum path sum from the top-left corner to the bottom-right corner (Integer). - **Constraints**: - `matrix` must be a non-empty list of non-empty lists of integers. - Each row in the matrix must have the same number of columns. - **Exception Handling**: - Raise `ValueError` if `matrix` is empty or any row in the matrix is empty. - Raise `TypeError` if `matrix` is not a list of lists of integers. **Example Usage**: ```python matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_sum(matrix) == 7 ``` **Notes**: - Use dynamic programming to optimize the solution. - Ensure the code handles edge cases like single-row or single-column matrices efficiently. **Hints**: - Consider that the minimum path sum to reach any cell in the first row or first column can only be obtained from the previous cell in the same row or column. - For other cells, the path can come from the left or from above, whichever has the smaller sum.","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: Calculate the minimum path sum in a matrix from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. :param matrix: List of Lists of integers representing the matrix :return: The minimum path sum from the top-left corner to the bottom-right corner if not matrix or not all(matrix): raise ValueError(\\"Matrix must be a non-empty list of non-empty lists.\\") rows, cols = len(matrix), len(matrix[0]) # Initialize the first cell for i in range(1, rows): matrix[i][0] += matrix[i - 1][0] for j in range(1, cols): matrix[0][j] += matrix[0][j - 1] # Calculate minimum path sum for each cell for i in range(1, rows): for j in range(1, cols): matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1]) return matrix[rows - 1][cols - 1]"},{"question":"# Reconstruct Binary Tree from Preorder and Inorder Traversal You are required to reconstruct a binary tree given its preorder and inorder traversal lists. Once the tree is reconstructed, your function should return the root of the binary tree. Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder: list[int], inorder: list[int]) -> TreeNode: ``` Input: - **preorder**: A list of integers representing the preorder traversal of the tree. - **inorder**: A list of integers representing the inorder traversal of the tree. Output: - The root of the reconstructed binary tree. Constraints: - Both `preorder` and `inorder` will contain the same set of unique integers. - The length of the traversals will be between 1 and 1000. - There are no repeated elements in the tree. Examples: ```python preorder = [3, 9, 20, 15, 7] inorder = [9, 3, 15, 20, 7] root = build_tree(preorder, inorder) # This should reconstruct the following binary tree: # 3 # / # 9 20 # / # 15 7 # The function would return the root node pointing to this tree. ``` Scenario: Consider you are given a list of tasks (nodes) with certain dependencies encoded in preorder and inorder traversals. Your task is to reconstruct this structure to understand the relationships better. This will help in visualizing the sequence and hierarchy of tasks. Note: You can assume that the tree generated from the given traversals is always valid.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder, inorder): if not preorder or not inorder: return None root_val = preorder[0] root = TreeNode(root_val) mid = inorder.index(root_val) root.left = build_tree(preorder[1:mid+1], inorder[:mid]) root.right = build_tree(preorder[mid+1:], inorder[mid+1:]) return root"},{"question":"# Coding Question Create a function that takes a list of strings and returns the length of the shortest possible concatenated string that contains all the given strings as substrings. This problem is similar to finding a superstring with overlaps. Function Signature ```python def shortest_superstring(strings: list[str]) -> int: # implementation goes here ``` # Requirements 1. **Input**: - `strings` (list of str): A list of non-empty strings. 2. **Output**: - Returns an integer indicating the length of the shortest concatenated string that contains all the input strings as substrings. # Constraints 1. The function must efficiently handle overlaps between strings to minimize the length of the resulting superstring. 2. The solution should be optimized for strings with a substantial degree of overlap. 3. The function must handle at least 1 and up to 10 strings, each with length between 1 and 20. # Example Scenarios Example 1: ```python shortest_superstring([\\"abc\\", \\"bcd\\", \\"cde\\"]) # Expected Output: 5 ``` Explanation: The shortest superstring is \\"abcde\\". Example 2: ```python shortest_superstring([\\"ab\\", \\"bc\\", \\"cd\\"]) # Expected Output: 4 ``` Explanation: The shortest superstring is \\"abcd\\". Example 3: ```python shortest_superstring([\\"xyz\\", \\"abc\\"]) # Expected Output: 6 ``` Explanation: The shortest superstring is \\"xyzabc\\" as there is no overlap between the two strings. # Notes - Consider using dynamic programming or backtracking strategies to efficiently combine the strings with overlapping. - To calculate the overlap efficiently, use string operations to match the suffix of one string with the prefix of another. - Your code should handle edge cases gracefully, such as input containing fully overlapping strings or no overlap at all. - Ensure your solution is well-commented to explain the approach and logic used in the implementation.","solution":"def shortest_superstring(strings: list[str]) -> int: from itertools import permutations def calculate_overlap(s1, s2): Calculate the maximum overlap length where s1\'s suffix matches s2\'s prefix. max_overlap = 0 min_len = min(len(s1), len(s2)) # Check s1\'s suffix with s2\'s prefix for i in range(1, min_len + 1): if s1[-i:] == s2[:i]: max_overlap = i return max_overlap def merge_strings(s1, s2, overlap): return s1 + s2[overlap:] min_len = float(\'inf\') for perm in permutations(strings): current_str = perm[0] for i in range(1, len(perm)): overlap = calculate_overlap(current_str, perm[i]) current_str = merge_strings(current_str, perm[i], overlap) min_len = min(min_len, len(current_str)) return min_len"},{"question":"# Coding Assessment Question: Validate Roman Numerals Objective: Implement a function to determine if a given string represents a valid Roman numeral. Detailed Requirements: 1. **Function Signature**: `def is_valid_roman_numeral(numeral: str) -> bool:` 2. **Input**: A single string, `numeral`, which may consist of characters: \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. 3. **Output**: A boolean value `True` if the `numeral` is a valid Roman numeral, `False` otherwise. 4. **Constraints**: - The input string must only contain Roman numeral characters. If it contains other characters, return `False`. - Ensure the Roman numeral is valid according to the standard rules: - \'I\' can be placed before \'V\' (5) and \'X\' (10) to make 4 and 9. - \'X\' can be placed before \'L\' (50) and \'C\' (100) to make 40 and 90. - \'C\' can be placed before \'D\' (500) and \'M\' (1000) to make 400 and 900. - Repeatable characters like \'I\', \'X\', \'C\', and \'M\' should not appear more than three times consecutively. - Non-repeatable characters like \'V\', \'L\', and \'D\' should not appear more than once. Performance: - Achieve a time complexity of O(n) and space complexity of O(1). Example: ```python assert is_valid_roman_numeral(\'XVI\') == True assert is_valid_roman_numeral(\'IV\') == True assert is_valid_roman_numeral(\'MCMXCIV\') == True assert is_valid_roman_numeral(\'VV\') == False assert is_valid_roman_numeral(\'IIII\') == False assert is_valid_roman_numeral(\'XL\') == True assert is_valid_roman_numeral(\'FXIV\') == False ``` Scenario: Develop a function to check if given Roman numeral inputs in a historical data application are valid. This will ensure the data integrity of Roman numeral records.","solution":"def is_valid_roman_numeral(numeral: str) -> bool: Checks if a given string is a valid Roman numeral. Roman numerals must follow rules and conventions set by the Roman numeral system. roman_numeral_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } valid_pairs = { \'I\': set([\'V\', \'X\']), \'X\': set([\'L\', \'C\']), \'C\': set([\'D\', \'M\']) } max_repeats = { \'I\': 3, \'X\': 3, \'C\': 3, \'M\': 3, \'V\': 1, \'L\': 1, \'D\': 1 } repeat_count = {} for i in range(len(numeral)): if numeral[i] not in roman_numeral_map: return False if numeral[i] not in repeat_count: repeat_count[numeral[i]] = 1 else: repeat_count[numeral[i]] += 1 if repeat_count[numeral[i]] > max_repeats[numeral[i]]: return False if i > 0 and roman_numeral_map[numeral[i]] > roman_numeral_map[numeral[i-1]]: if numeral[i-1] not in valid_pairs or numeral[i] not in valid_pairs[numeral[i-1]]: return False if repeat_count[numeral[i-1]] > 1: return False repeat_count = {} return True"},{"question":"# Question: Implement and Benchmark a Custom Priority Queue Context A Priority Queue is a type of data structure where each element is associated with a priority, and elements are served based on their priority (highest first). This question requires you to implement a basic Priority Queue using a binary heap and compare its performance to that of Python\'s built-in `queue.PriorityQueue`. Task 1. Implement a custom Priority Queue class called `CustomPriorityQueue` using a binary heap (min-heap). 2. Provide methods for inserting elements (`push`), retrieving the highest priority element (`pop`), and checking if the queue is empty (`is_empty`). 3. Benchmark your `CustomPriorityQueue` implementation against Python\'s `queue.PriorityQueue` with respect to insertion and removal operations. Function Signature ```python class CustomPriorityQueue: def __init__(self): pass def push(self, item: tuple): pass def pop(self) -> tuple: pass def is_empty(self) -> bool: pass def benchmark_priority_queues(custom_queue: CustomPriorityQueue, builtin_queue: queue.PriorityQueue, elements: List[Tuple[int, int]]) -> dict: pass ``` Input * A list of tuples where each tuple contains an item and its associated priority. * The `push` method takes a tuple `(priority, item)` where `priority` is an integer and `item` can be any data type. * The `benchmark_priority_queues` function takes: - `custom_queue`: an instance of `CustomPriorityQueue`. - `builtin_queue`: an instance of `queue.PriorityQueue`. - `elements`: a list of tuples representing elements with their respective priorities. Output * `CustomPriorityQueue` class should correctly implement the priority queue operations. * `benchmark_priority_queues` returns a dictionary with performance metrics for various operations. Constraints * 1 <= len(elements) <= 10^5 * Priorities and item values are assumed to be integers for simplicity. * The performance metrics should include the time taken for insertions (`push`), retrievals (`pop`), and total execution time for both queues. Example ```python >>> custom_queue = CustomPriorityQueue() >>> builtin_queue = queue.PriorityQueue() >>> elements = [(3, \'A\'), (1, \'B\'), (4, \'C\'), (2, \'D\')] >>> benchmark_priority_queues(custom_queue, builtin_queue, elements) { \'custom_insert_time\': 0.001, \'builtin_insert_time\': 0.002, \'custom_retrieve_time\': 0.0015, \'builtin_retrieve_time\': 0.003, \'custom_total_time\': 0.0025, \'builtin_total_time\': 0.005 } ``` Notes * Ensure the `CustomPriorityQueue` maintains the heap properties correctly. * Provide comprehensive testing and comparison between your custom implementation and the built-in priority queue. * Use a high-resolution timer to measure performance accurately. * Handle edge cases such as empty priority queues gracefully.","solution":"import heapq import queue from typing import List, Tuple import time class CustomPriorityQueue: def __init__(self): self._heap = [] def push(self, item: Tuple[int, int]): heapq.heappush(self._heap, item) def pop(self) -> Tuple[int, int]: return heapq.heappop(self._heap) def is_empty(self) -> bool: return len(self._heap) == 0 def benchmark_priority_queues(custom_queue: CustomPriorityQueue, builtin_queue: queue.PriorityQueue, elements: List[Tuple[int, int]]) -> dict: # Benchmark insertion for custom queue start_time = time.time() for element in elements: custom_queue.push(element) custom_insert_time = time.time() - start_time # Benchmark insertion for builtin queue start_time = time.time() for element in elements: builtin_queue.put(element) builtin_insert_time = time.time() - start_time # Benchmark retrieval for custom queue start_time = time.time() while not custom_queue.is_empty(): custom_queue.pop() custom_retrieve_time = time.time() - start_time # Benchmark retrieval for builtin queue start_time = time.time() while not builtin_queue.empty(): builtin_queue.get() builtin_retrieve_time = time.time() - start_time return { \'custom_insert_time\': custom_insert_time, \'builtin_insert_time\': builtin_insert_time, \'custom_retrieve_time\': custom_retrieve_time, \'builtin_retrieve_time\': builtin_retrieve_time, \'custom_total_time\': custom_insert_time + custom_retrieve_time, \'builtin_total_time\': builtin_insert_time + builtin_retrieve_time }"},{"question":"# Problem Statement You are given a binary tree where each node contains an integer value. Your task is to write a function that flattens the binary tree into a \\"linked list\\" in place. The \\"linked list\\" should use the right child pointer to point to the next node in the list and the left child pointer should always be None. The flattened \\"linked list\\" should be in the same order as a pre-order traversal of the binary tree. # Function Signature ```python def flatten_binary_tree(root: TreeNode) -> None: pass ``` # Input - `root`: A `TreeNode` object representing the root of the binary tree. A `TreeNode` has an integer `val`, `left` and `right` child attributes. # Output - The function should return `None`. The binary tree should be flattened in place. # Constraints - The number of nodes in the tree is in the range `[0, 2000]`. - `-100 <= Node.val <= 100` # Examples Example 1 ``` Input: 1 / 2 5 / 3 4 6 Output (flattened in place): 1 2 3 4 5 6 ``` Example 2 ``` Input: 0 1 Output (flattened in place): 0 1 ``` Example 3 ``` Input: 4 / 9 Output (flattened in place): 4 9 ``` # Notes - Be sure to preserve the original tree\'s structure in the flattened list. - Your implementation should work in place, without using extra space for another data structure like an array or list.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten_binary_tree(root: TreeNode) -> None: Flattens a binary tree to a linked list in place by using the right pointer as the next pointer according to pre-order traversal. if not root: return def flatten(node: TreeNode): Helper function to flatten the tree and return the last node in the flattened structure. if not node: return None # Flatten the left subtree left_tail = flatten(node.left) # Flatten the right subtree right_tail = flatten(node.right) # If there\'s a left subtree, we need to rewire the connections. if left_tail: left_tail.right = node.right node.right = node.left node.left = None # The new tail is the rightmost of right tail or left tail return right_tail if right_tail else left_tail if left_tail else node flatten(root)"},{"question":"# Coding Challenge Context: You are tasked with implementing an algorithm to find the largest product of consecutive numbers in an array. Objective: Write a function `largest_consecutive_product(arr: List[int], k: int) -> int` that takes a list of integers `arr` and an integer `k`, and returns the largest product of `k` consecutive elements in the array. Input: - The input will be a list of integers `arr` of length ( n ), where ( 1 leq n leq 10^5 ). - The input will also include an integer ( k ) where ( 1 leq k leq n ). Output: The output should be a single integer which is the largest product of `k` consecutive elements in the array. Constraints: - The function should handle various cases, including when the array contains negative numbers. - Ensure that the solution is efficient, especially for large values of `n`. Examples: ```python >>> largest_consecutive_product([1, 2, 3, 4, 5], 2) 20 >>> largest_consecutive_product([10, -10, 10, -10, 10], 3) 1000 >>> largest_consecutive_product([1, 2, 3, 4], 3) 24 >>> largest_consecutive_product([-1, -2, -3, -4], 2) 12 ``` Performance Requirement: While the performance of the code is critical due to the upper limit of ( n ), ensure that your approach remains efficient and runs within acceptable time limits for the given constraints. Good luck!","solution":"from typing import List def largest_consecutive_product(arr: List[int], k: int) -> int: Finds the largest product of `k` consecutive elements in the array. if k == 0 or len(arr) == 0 or len(arr) < k: return 0 # edge case where k is 0 or array is empty max_product = float(\'-inf\') current_product = 1 for i in range(len(arr)): current_product *= arr[i] if i >= k - 1: max_product = max(max_product, current_product) current_product //= arr[i - (k - 1)] return max_product"},{"question":"# Maze Pathfinding Implement an algorithm to find the shortest path in a maze from a given start to a destination using the Breadth-First Search (BFS) technique. The maze is represented as a 2D grid of 1s (walkable) and 0s (unwalkable). The path should avoid 0s and calculate the fewest number of steps needed to reach the destination. # Input and Output Input * `maze`: A 2D list of integers representing the grid, where 1 is a walkable cell and 0 is an unwalkable cell. * `start`: A tuple `(x, y)` representing the starting position in the maze. * `destination`: A tuple `(x_dest, y_dest)` representing the ending position in the maze. Output * An integer representing the number of steps in the shortest path from `start` to `destination`. If no path exists, return -1. # Constraints * Assume the maze dimensions are at most 100x100. * The start and destination positions are guaranteed to be walkable cells (1s). * You may move up, down, left, or right from one cell to an adjacent cell. # Example ```python maze = [ [1, 0, 1, 1, 1], [1, 1, 0, 1, 0], [0, 1, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1] ] start = (0, 0) destination = (4, 4) assert shortest_path(maze, start, destination) == 8 # One of the shortest paths ``` # Code Template ```python from collections import deque def shortest_path(maze, start, destination): rows, cols = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 1 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == destination: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # Return -1 if there is no valid path to the destination ```","solution":"from collections import deque def shortest_path(maze, start, destination): rows, cols = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 1 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == destination: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # Return -1 if there is no valid path to the destination"},{"question":"# Coding Assessment Question Context In various algorithms, especially those concerning data manipulation and analysis, its often necessary to find the segments of changing values within a sequence. This helps in identifying trends or patterns within the sequence. Task Implement a function `find_value_segments` in Python that finds and returns a list of segments where the values in the sequence are constant. A segment is represented as a tuple of the value and the start and end indices (inclusive) of that segment in the sequence. For example, given the sequence `[1, 1, 2, 2, 2, 3]`, the segments are `(1, 0, 1)`, `(2, 2, 4)`, and `(3, 5, 5)`. Function Signature ```python def find_value_segments(sequence: list[int]) -> list[tuple[int, int, int]]: pass ``` Input * **sequence**: a list of integers representing the sequence of values. Output * **segments**: a list of tuples `(value, start_index, end_index)` representing the segments of constant values in the sequence. Constraints * The length of the `sequence` will be in the range [1, 10^5]. * Each integer in the sequence will be in the range [-10^9, 10^9]. Examples ```python >>> find_value_segments([1, 1, 2, 2, 2, 3]) [(1, 0, 1), (2, 2, 4), (3, 5, 5)] >>> find_value_segments([7, 7, 7]) [(7, 0, 2)] >>> find_value_segments([1]) [(1, 0, 0)] ``` Additional Requirement * Ensure that your function has an efficient time complexity for handling the maximum constraint limits. * Handle boundary cases, such as sequences with a single element.","solution":"def find_value_segments(sequence: list[int]) -> list[tuple[int, int, int]]: if not sequence: return [] segments = [] start_index = 0 current_value = sequence[0] for i in range(1, len(sequence)): if sequence[i] != current_value: segments.append((current_value, start_index, i - 1)) start_index = i current_value = sequence[i] # Append the last segment segments.append((current_value, start_index, len(sequence) - 1)) return segments"},{"question":"# Coding Assessment Question You are provided with a section of data processing functions and your task is to implement a crucial function that enables sorting of a custom data structure efficiently. # Problem Statement Implement a function `sort_customers_by_purchase_amount(customers: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]` that sorts a list of customers based on their total purchase amount in descending order. # Input Format - A list of dictionaries, where each dictionary represents a customer with the following keys: - `\\"name\\"`: a string representing the name of the customer. - `\\"purchase_amount\\"`: an integer representing the total purchase amount of the customer. # Output Format - A list of dictionaries sorted by the `\\"purchase_amount\\"` in descending order. # Constraints - The list can contain up to 1000 customers. - The customers\' names are unique strings. - The purchase amounts are positive integers. # Example Input ```python customers = [ {\\"name\\": \\"Alice\\", \\"purchase_amount\\": 250}, {\\"name\\": \\"Bob\\", \\"purchase_amount\\": 150}, {\\"name\\": \\"Charlie\\", \\"purchase_amount\\": 500}, ] ``` Output ```python [ {\\"name\\": \\"Charlie\\", \\"purchase_amount\\": 500}, {\\"name\\": \\"Alice\\", \\"purchase_amount\\": 250}, {\\"name\\": \\"Bob\\", \\"purchase_amount\\": 150}, ] ``` # Explanation The function sorts the customers based on their purchase amount in descending order. Charlie has the highest purchase amount, followed by Alice and then Bob. # Function Signature ```python def sort_customers_by_purchase_amount(customers: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: # Your code here ``` # Guidelines * Ensure the function correctly sorts the list even when there are edge cases like customers with the same purchase amount. * Use efficient sorting algorithms to handle the input size within the constraints. * Maintain the integrity of the data structure, ensuring no data is lost or corrupted during sorting.","solution":"from typing import List, Dict, Union def sort_customers_by_purchase_amount(customers: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: Sorts a list of customers based on their total purchase amount in descending order. return sorted(customers, key=lambda x: x[\'purchase_amount\'], reverse=True)"},{"question":"# Context We\'ve explored various sorting algorithms and their implementations, specifically focusing on quicksort and mergesort due to their efficient average-case performance. Let\'s delve deeper into sorting with a twist, combining the principles of in-place modification and linear-time complexity. # Task Implement a new Python function called `dutch_national_flag` within the provided class that rearranges elements to solve the well-known Dutch National Flag problem. The function must arrange the elements in the list such that all instances of a specified color appear consecutively and in the correct order. # Input 1. List of integers, where each integer represents a color (0, 1, or 2). 2. The length of the list can be assumed to be at most (10^6). # Output 1. The same list, rearranged in-place such that all instances of the same color appear consecutively in the order of 0, 1, and 2. # Constraints 1. The elements in the list are only 0, 1, or 2. 2. Your algorithm should have a time complexity of O(N) and a space complexity of O(1), where N is the length of the list. # Function Signature ```python class SortColors: def dutch_national_flag(self, nums: List[int]) -> List[int]: # Your implementation here pass ``` # Example ```python sc = SortColors() nums = [2, 0, 2, 1, 1, 0] sc.dutch_national_flag(nums) print(nums) # Expected output: [0, 0, 1, 1, 2, 2] ``` Ensure your implementation aligns with the guidelines, and meets the performance and space constraints provided.","solution":"from typing import List class SortColors: def dutch_national_flag(self, nums: List[int]) -> List[int]: Rearrange elements in nums to solve the Dutch National Flag problem. All 0s will come first, followed by all 1s, followed by all 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1 return nums"},{"question":"# Rotated Sorted Array Search Given an array of integers `nums` that was originally sorted in ascending order and then potentially rotated at an unknown pivot index (for example, `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`), write a function `search` to find a given target value in the array. If the target exists, return its index. Otherwise, return `-1`. You must write an algorithm with `O(log n)` runtime complexity. # Input Format * `nums`: List of integers (0 <= len(nums) <= 5000, -10^4 <= nums[i] <= 10^4) * `target`: Integer (-10^4 <= target <= 10^4) # Output Format * Returns an integer which is the index of the target in `nums` if found, otherwise `-1`. # Constraints * `0 <= len(nums) <= 5000` * `-10^4 <= nums[i] <= 10^4` * `All elements in nums are unique.` * `-10^4 <= target <= 10^4` # Examples ```python # Example 1 search([4,5,6,7,0,1,2], 0) # Expected output: 4 # Example 2 search([4,5,6,7,0,1,2], 3) # Expected output: -1 # Example 3 search([1], 0) # Expected output: -1 ``` # Additional Requirements * Ensure that your implementation handles edge cases, such as input lists of different sizes including 0 and 1. * Consider scenarios where the array may contain the smallest possible size to detect performance or edge case issues. Write your function below: ```python def search(nums: list, target: int) -> int: Your implementation here. ```","solution":"def search(nums: list, target: int) -> int: Searches for the target in a rotated sorted array with O(log n) complexity. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# String Manipulation: Text Compression and Decompression You are tasked with implementing a class `TextManipulator` to compress and decompress strings using a simple encoding scheme. The scheme works by encoding repeated characters in the string with the character followed by the number of its repetitions. For example: - `\'aaabbcccc\'` would be compressed to `\'a3b2c4\'` - `\'aabbaa\'` would be compressed to `\'a2b2a2\'` And the decompression should reverse the compressed string back to its original form. Tasks: 1. **TextManipulator Class Implementation**: - **Compress Method**: Compress a given string following the described encoding scheme. - **Decompress Method**: Decompress a given encoded string back to its original form. Constraints: - Strings will consist of lowercase alphabetical characters only. - The length of the strings will be between 1 and 100 characters. Expected Input and Output Format: - **Input**: Method calls on an instance of `TextManipulator`. - **Output**: Results of the compression and decompression operations. Example: ```python # Create an instance of TextManipulator text_manipulator = TextManipulator() # Test compression compressed_text = text_manipulator.compress(\'aaabbcccc\') print(compressed_text) # Output: \'a3b2c4\' compressed_text = text_manipulator.compress(\'aabbaa\') print(compressed_text) # Output: \'a2b2a2\' # Test decompression original_text = text_manipulator.decompress(\'a3b2c4\') print(original_text) # Output: \'aaabbcccc\' original_text = text_manipulator.decompress(\'a2b2a2\') print(original_text) # Output: \'aabbaa\' ``` Implement the `TextManipulator` class such that it satisfies the constraints above, handling any edge cases appropriately.","solution":"class TextManipulator: def compress(self, text): Compresses a given string by encoding repeated characters with the character followed by the number of its repetitions. if not text: return \\"\\" compressed = [] i = 0 while i < len(text): count = 1 while i + 1 < len(text) and text[i] == text[i + 1]: i += 1 count += 1 compressed.append(f\\"{text[i]}{count}\\") i += 1 return \'\'.join(compressed) def decompress(self, compressed_text): Decompresses a given encoded string back to its original form. if not compressed_text: return \\"\\" decompressed = [] i = 0 while i < len(compressed_text): char = compressed_text[i] num = \\"\\" i += 1 while i < len(compressed_text) and compressed_text[i].isdigit(): num += compressed_text[i] i += 1 decompressed.append(char * int(num)) return \'\'.join(decompressed)"},{"question":"# Problem: Implement the A* Algorithm for Pathfinding You are tasked with implementing the A* (A-star) algorithm, a popular pathfinding and graph traversal algorithm often used in computer science and artificial intelligence. The A* algorithm finds the shortest path from a start node to a target node in a weighted grid where obstacles may be present. Your task is to write a function `a_star` which takes in the following parameters: - `grid` : A 2D list representing the grid. Each element in the grid is either a `0` (walkable tile) or `1` (obstacle). - `start` : A tuple `(x, y)` representing the starting coordinates. - `end` : A tuple `(x, y)` representing the target coordinates. The function should return a list of tuples representing the coordinates of the path from start to end, including both start and end. If there is no valid path, return an empty list. # Constraints: - The grid is at least 1x1 in size and consists of integers 0 and 1. - `start` and `end` coordinates are valid and within the grid bounds. - The start and end positions are always walkable (i.e., `grid[start[0]][start[1]] == 0` and `grid[end[0]][end[1]] == 0`). # Expected Function Signature: ```python def a_star(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` # Example: ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0] ] start = (0, 0) end = (4, 4) path = a_star(grid, start, end) print(path) # Output could be similar to: # [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` # Notes: 1. Ensure your implementation handles edge cases where no path is possible. 2. You may use data structures like priority queue (heapq) for efficient pathfinding. 3. Implement the Manhattan distance as a heuristic function.","solution":"from typing import List, Tuple import heapq def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) def a_star(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(grid), len(grid[0]) open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, end)} while open_set: _, current = heapq.heappop(open_set) if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) # Optional: ensure the start node is in the path path.reverse() return path x, y = current for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: neighbor = (x + dx, y + dy) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols: if grid[neighbor[0]][neighbor[1]] == 1: continue tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, end) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Problem: **Linked List Cycle Detection and Removal** You are given the task of enhancing a `LinkedList` class implementation with additional operations to assess your understanding of linked lists and their practical use. Specifically, you need to detect if there is a cycle in the linked list and remove it if present. New Operations: 1. **Detect Cycle**: Implement a function that checks whether the linked list contains a cycle. 2. **Remove Cycle**: Implement a function that removes the cycle from the linked list if there is one. Input and Output Formats: 1. **Detect Cycle**: - Input: None - Output: A boolean value indicating whether the linked list contains a cycle 2. **Remove Cycle**: - Input: None - Output: None # Constraints: - For `detect cycle`: Ensure the function performs in O(n) time complexity. - For `remove cycle`: Ensure that the cycle, if present, is removed and the linked list is restored to a linear structure. # Performance Requirements: - Maintain O(n) time complexity for both `detect cycle` and `remove cycle`. Example: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = ListNode(value) if not self.head: self.head = new_node return temp = self.head while temp.next: temp = temp.next temp.next = new_node def detect_cycle(self): slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self): slow, fast = self.head, self.head has_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if has_cycle: slow = self.head while slow != fast: slow = slow.next fast = fast.next fast_pointer = slow while fast_pointer.next != slow: fast_pointer = fast_pointer.next fast_pointer.next = None # Example usage: linked_list = LinkedList() linked_list.append(3) linked_list.append(2) linked_list.append(0) linked_list.append(-4) linked_list.head.next.next.next.next = linked_list.head.next print(linked_list.detect_cycle()) # Output: True linked_list.remove_cycle() print(linked_list.detect_cycle()) # Output: False ``` Implement these additional functions in the `LinkedList` class provided above and thoroughly test them to ensure correctness.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = ListNode(value) if not self.head: self.head = new_node return temp = self.head while temp.next: temp = temp.next temp.next = new_node def detect_cycle(self): slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self): slow, fast = self.head, self.head has_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if has_cycle: slow = self.head # Find the start of the cycle while slow != fast: slow = slow.next fast = fast.next # Find the node just before the start of the cycle and break the cycle current = slow while current.next != slow: current = current.next current.next = None"},{"question":"# Problem Statement: Optimized Prime Factorization Design a function to compute the prime factorization of an integer `n` using an efficient algorithm. The function should handle edge cases, ensure optimal performance for large `n`, and correctly manage system resources. # Requirements: 1. **Function Name**: `prime_factors(n: int) -> List[int]` 2. **Input**: Integer `n` (2  n  10^12) 3. **Output**: List of prime factors of `n` in ascending order. 4. **Constraints**: - If `n` is less than 2, raise a `ValueError` with the message \\"n must be greater than or equal to 2\\". - Ensure the function works efficiently for the upper limit of `n`. # Example: ```python >>> prime_factors(2) [2] >>> prime_factors(18) [2, 3, 3] >>> prime_factors(60) [2, 2, 3, 5] >>> prime_factors(1000000007) [1000000007] ``` # Performance Note: - The implementation should prioritize methods that are efficient in terms of both time and space for large values of `n`. - Consider trial division up to the square root of `n` and optimize by skipping even numbers after checking for divisibility by 2. # Hints: - Use the Sieve of Eratosthenes to precompute primes up to n for faster factorization. - Remember that if a number `n` was not divisible by any number up to its square root, then `n` itself is prime.","solution":"from typing import List def prime_factors(n: int) -> List[int]: if n < 2: raise ValueError(\\"n must be greater than or equal to 2\\") factors = [] # Check for number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point, so a skip of 2 (i.e. i = i + 2) can be used for i in range(3, int(n**0.5) + 1, 2): # While i divides n, add i and divide n while n % i == 0: factors.append(i) n = n // i # If n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# Question: Evaluate a Mathematical Expression You are tasked with evaluating a mathematical expression represented as a string. The string will contain integers and basic arithmetic operators (+, -, *, /). Your goal is to implement a function that accurately evaluates the expression while maintaining the order of operations. The operations should follow the normal mathematical precedence rules (PEMDAS/BODMAS). Objective Write a function `evaluate_expression(expression: str) -> int` that evaluates the given mathematical expression string and returns the result as an integer. Input Format - `expression` (string): The mathematical expression to evaluate (1  length of expression  1000). The expression will be a valid string containing integers and the operators +, -, *, and /. Output Format - Return an integer representing the evaluated result of the expression. Constraints - The input is guaranteed to be a valid mathematical expression. - Division should be treated as integer division. For example, `7 / 2` should return `3`. - The expression will not contain any whitespace. Example ```python >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100*2+12\\") 212 >>> evaluate_expression(\\"100*(2+12)\\") 1400 ``` Explanation 1. In the first example, `3 + 5 * 2` evaluates to `3 + 10` which results in `13`. 2. In the second example, `10 + 2 * 6` evaluates to `10 + 12` which results in `22`. 3. In the third example, `100 * 2 + 12` evaluates to `200 + 12` which results in `212`. 4. In the last example, parentheses indicate that `2 + 12` should be evaluated first resulting in `14`, and then `100 * 14` which results in `1400`. Use a stack to manage the operators and operands while respecting the mathematical precedence rules. # Implementation Requirements - Implement `evaluate_expression` to evaluate the given expression while respecting operator precedence. - Ensure integer division is correctly handled within the function.","solution":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression given as a string and return the result as an integer. def operate(op, second, first): if op == \'+\': return first + second if op == \'-\': return first - second if op == \'*\': return first * second if op == \'/\': return first // second def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 values = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i] == \')\': while operators and operators[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = operators.pop() values.append(operate(op, val2, val1)) operators.pop() else: while operators and precedence(operators[-1]) >= precedence(expression[i]): val2 = values.pop() val1 = values.pop() op = operators.pop() values.append(operate(op, val2, val1)) operators.append(expression[i]) i += 1 while operators: val2 = values.pop() val1 = values.pop() op = operators.pop() values.append(operate(op, val2, val1)) return values[-1]"},{"question":"# Scenario You are working on a logistics optimization problem involving package delivery. The company uses drones to deliver packages to various locations in a city. Each drone has a limited range and can deliver only a certain number of packages before returning to the base to recharge and restock. Given a list of package delivery locations and their distances from the base, you need to determine the optimal route for each drone to minimize the total delivery time while ensuring that no drone exceeds its maximum range or package capacity. # Task Your task is to create a function that plans the delivery routes for the drones. Each drone should be assigned a subset of the package locations such that the total distance traveled by the drone does not exceed its maximum range and the number of packages does not exceed its capacity. The goal is to minimize the total delivery time for all drones combined. **Function to Implement**: You need to implement the `plan_routes` function, which takes the following inputs: - `locations`: A list of tuples, each representing the coordinates `(x, y)` of a package delivery location. - `max_range`: An integer representing the maximum distance a drone can travel before returning to base. - `capacity`: An integer representing the maximum number of packages a drone can carry in one trip. The function should return a list of routes, where each route is a list of location indices that a single drone will visit. **Input and Output Formats**: - `locations`: List of tuples of size ( n ), each tuple containing two integers representing the coordinates. - `max_range`: Integer representing the maximum range of a drone. - `capacity`: Integer representing the maximum capacity for packages a drone can carry. **Example**: For instance, consider the base is located at (0, 0), and the package delivery locations and conditions are as follows: - `locations = [(1, 2), (3, 4), (5, 5), (7, 8)]` - `max_range = 10` - `capacity = 2` **Output**: - Return a list of routes, e.g., `[[0, 1], [2, 3]]`, indicating that drone 1 will deliver packages at locations 0 and 1, and drone 2 will deliver packages at locations 2 and 3. # Constraints: - Use a distance formula to compute the Euclidean distance between points. - Ensure no drone\'s route exceeds the given `max_range`. - Ensure no drone\'s route exceeds the given `capacity`. **Example Usage**: ```python locations = [(1, 2), (3, 4), (5, 5), (7, 8)] max_range = 10 capacity = 2 routes = plan_routes(locations, max_range, capacity) print(routes) # Example output: [[0, 1], [2, 3]] ``` Your solution should ensure that the routes optimize the total delivery time and comply with the drone constraints.","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points in 2D space. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def plan_routes(locations, max_range, capacity): Plans the delivery routes for drones such that each drone travels within its max range and capacity limits. base = (0, 0) routes = [] delivered = set() def can_add_to_route(route, loc_index): route_distance = euclidean_distance(base, locations[loc_index]) for i in range(len(route)): route_distance += euclidean_distance(locations[route[i]], locations[loc_index] if i == len(route) - 1 else locations[route[i+1]]) if route_distance > max_range: return False if len(route) >= capacity: return False return True while len(delivered) < len(locations): route = [] for i in range(len(locations)): if i not in delivered and can_add_to_route(route, i): route.append(i) delivered.add(i) routes.append(route) return routes"},{"question":"# Scenario You have been tasked with developing a feature extraction module for a natural language processing application. One significant feature that needs to be extracted is the Term Frequency-Inverse Document Frequency (TF-IDF) of words in a given set of documents. # Coding Challenge Implement the TF-IDF computation algorithm with the following functions in Python: * **Function 1**: `compute_term_frequencies(doc)` - This function computes the term frequency for each word in a given document. It returns a dictionary where keys are words and values are their respective term frequencies. ```python def compute_term_frequencies(doc: str) -> dict[str, float]: # Your code here ``` * **Function 2**: `compute_inverse_document_frequencies(docs)` - This function takes a list of documents as input and computes the inverse document frequency for each word across the documents. It returns a dictionary where keys are words and values are their inverse document frequencies. ```python def compute_inverse_document_frequencies(docs: list[str]) -> dict[str, float]: # Your code here ``` * **Function 3**: `compute_tfidf(doc, idf)` - This function computes the TF-IDF score for each word in a given document using the term frequencies and inverse document frequencies. It returns a dictionary where keys are words and values are their respective TF-IDF scores. ```python def compute_tfidf(doc: str, idf: dict[str, float]) -> dict[str, float]: # Your code here ``` Input * `doc` (str): A single document in the form of a string of text. * `docs` (list[str]): A list of documents, each document in the form of a string of text. * `idf` (dict[str, float]): A dictionary containing the inverse document frequencies for words. Output * `term_frequencies` (dict[str, float]): Dictionary of term frequencies for each word in a document. * `inverse_document_frequencies` (dict[str, float]): Dictionary of inverse document frequencies for each word across documents. * `tfidf_scores` (dict[str, float]): Dictionary of TF-IDF scores for each word in a document. # Constraints * Assume that the input documents are not empty. * Ignore case and punctuation while computing frequencies and scores. * Handle edge cases such as documents with unique words or very common words. # Example ```python if __name__ == \\"__main__\\": docs = [ \\"this is a sample document\\", \\"this document is the second document\\", \\"and this is the third one\\" ] idf = compute_inverse_document_frequencies(docs) print(\\"IDF:\\", idf) tfidf = compute_tfidf(docs[0], idf) print(\\"TF-IDF for first document:\\", tfidf) ```","solution":"import math import re from collections import defaultdict def preprocess(text): return re.findall(r\'bw+b\', text.lower()) def compute_term_frequencies(doc: str) -> dict: words = preprocess(doc) term_count = defaultdict(int) for word in words: term_count[word] += 1 total_terms = len(words) term_frequencies = {word: count / total_terms for word, count in term_count.items()} return term_frequencies def compute_inverse_document_frequencies(docs: list[str]) -> dict: doc_count = len(docs) word_doc_occurrence = defaultdict(int) for doc in docs: words = set(preprocess(doc)) for word in words: word_doc_occurrence[word] += 1 inverse_document_frequencies = {word: math.log(doc_count / count) for word, count in word_doc_occurrence.items()} return inverse_document_frequencies def compute_tfidf(doc: str, idf: dict[str, float]) -> dict: tf = compute_term_frequencies(doc) tfidf_scores = {word: tf[word] * idf.get(word, 0.0) for word in tf} return tfidf_scores"},{"question":"# Problem Statement: You are tasked with developing a function for an image processing application. One of the requirements is to generate a histogram of pixel values from a grayscale image, which will help in analyzing the distribution of pixel intensities. Your task is to implement a function that performs this operation efficiently. # Function Definition: ```python def generate_histogram(image: list[list[int]]) -> list[int]: Generate a histogram of pixel values from the given grayscale image. Parameters: - image: A 2D list of integers, where each integer represents a pixel value (0-255). Returns: - A list of integers representing the histogram of pixel values. ``` # Input and Output: - **Input**: - `image`: A 2D list of integers, where each integer `i` (0  `i`  255) represents a grayscale pixel value. - **Output**: A list of 256 integers representing the histogram of pixel values, where the value at index `i` corresponds to the number of times the pixel value `i` occurs in the image. # Constraints: - The dimensions of the image will not exceed 1000x1000 pixels. - Each pixel value lies within the valid range of 0 to 255. # Example: ```python generate_histogram([[0, 1, 2], [2, 1, 0], [3, 3, 4]]) # Output: [2, 2, 2, 2, 1, 0, 0, 0, ..., 0] (length: 256) generate_histogram([[255, 255], [255, 255]]) # Output: [0, 0, 0, ..., 4] (length: 256 with count 4 at index 255) generate_histogram([[0, 0, 0], [0, 0, 0]]) # Output: [6, 0, 0, ..., 0] (length: 256 with count 6 at index 0) ``` # Notes: - The function should efficiently count pixel values even for large images. - Remember to handle edge cases such as an empty image or images with uniform pixel values.","solution":"def generate_histogram(image: list[list[int]]) -> list[int]: Generate a histogram of pixel values from the given grayscale image. Parameters: - image: A 2D list of integers, where each integer represents a pixel value (0-255). Returns: - A list of integers representing the histogram of pixel values. # Initialize the histogram with 256 zeros histogram = [0] * 256 # Count the frequency of each pixel value for row in image: for pixel in row: histogram[pixel] += 1 return histogram"},{"question":"# Question Statement Array Pair Product In this exercise, you are required to implement a function that finds the maximum product of any two distinct elements in an array. The array can contain both positive and negative integers. Your function should be efficient in terms of both time and space complexity. # Function Signature ```python def max_pair_product(arr: List[int]) -> int: pass ``` # Input - A list of integers `arr` where the length of the list is between 2 and 10^5, inclusive, and each integer falls within the range `-10^5` to `10^5`. # Output - An integer which is the maximum product obtained from multiplying two distinct elements in the array. # Constraints - The array will contain at least two elements. - You should aim for an O(n) time complexity solution, avoiding a brute-force approach which would be O(n^2). - The result should fit within a 64-bit signed integer. # Example - `max_pair_product([1, 10, 2, 6, 5, 3])` should return `60` (6 * 10 = 60). - `max_pair_product([-10, -20, 5, 0, 2])` should return `200` (-10 * -20 = 200). - `max_pair_product([-1, -2, 1, 2])` should return `2` (-1 * -2 = 2). # Testing The function should also correctly handle edge cases, such as: - Arrays that contain both positive and negative numbers. - Arrays where the two largest (by absolute value) numbers are negative. - Arrays with large numbers near the limits of the integer range. Explanation Your implementation should: 1. Traverse the array to find the two largest and the two smallest elements. 2. Calculate the product of the two largest elements and the product of the two smallest elements. 3. Return the maximum of these two products.","solution":"from typing import List def max_pair_product(arr: List[int]) -> int: if len(arr) < 2: raise ValueError(\\"The input array must contain at least two elements.\\") max1 = max2 = float(\'-inf\') min1 = min2 = float(\'inf\') for num in arr: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2, min1 * min2)"},{"question":"# Problem Statement You are required to implement a simplified version of a k-nearest neighbors (k-NN) classifier. The algorithm needs to handle a variable number of neighbors (`k`) and be capable of classifying new data points based on the majority class of the nearest neighbors. Additionally, it should include a weighting mechanism to give more importance to closer neighbors. # Requirements 1. **Input**: - `X_train`: A two-dimensional numpy array where each row represents a training sample and each column represents a feature. - `y_train`: A one-dimensional numpy array of integer labels corresponding to the training samples. - `k` (int): The number of nearest neighbors to consider for classification. Default value: 5. - `X_test`: A two-dimensional numpy array where each row represents a test sample. 2. **Output**: - Method `fit(X_train, y_train)`: Train the k-NN model using the training data. - Method `predict(X_test)`: Predict the class labels for the test samples. # Constraints - The number of training samples and test samples will be at least 1 and less than or equal to 10,000. - The number of features in `X_train` and `X_test` will be at least 1 and less than or equal to 100. - The value of `k` will be at least 1 and less than or equal to the number of training samples. - The input arrays `X_train`, `y_train`, and `X_test` must be numpy arrays. # Example ```python # Sample inputs X_train = np.array([[1, 2], [2, 3], [3, 4], [5, 5]]) y_train = np.array([0, 0, 1, 1]) X_test = np.array([[1, 1], [3, 3], [5, 4]]) # Creating and training the k-NN classifier knn = KNearestNeighbors(k=3) knn.fit(X_train, y_train) # Predicting values predictions = knn.predict(X_test) print(f\\"Predictions for the test samples: {predictions}\\") ``` # Instructions: 1. Implement the class `KNearestNeighbors` with methods: - `__init__(self, k=5)`: Initialize the classifier with the number of neighbors. - `fit(self, X_train, y_train)`: Store the training data. - `distance(self, x1, x2)`: Compute the Euclidean distance between two points `x1` and `x2`. - `weighted_vote(self, neighbors)`: Perform a weighted vote where nearer neighbors have higher influence. - `predict(self, X_test)`: Predict the class labels for the test samples using the k-nearest neighbors. 2. Ensure efficient computation of distances for prediction. 3. Include a weighting mechanism in the `weighted_vote` method. The weight for each neighbor should be inversely proportional to its distance from the test point (e.g., weight = 1 / distance).","solution":"import numpy as np class KNearestNeighbors: def __init__(self, k=5): self.k = k self.X_train = None self.y_train = None def fit(self, X_train, y_train): self.X_train = X_train self.y_train = y_train def distance(self, x1, x2): return np.sqrt(np.sum((x1 - x2) ** 2)) def weighted_vote(self, neighbors): class_weights = {} for dist, label in neighbors: weight = 1 / (dist + 1e-5) # Add a small constant to avoid division by zero if label in class_weights: class_weights[label] += weight else: class_weights[label] = weight return max(class_weights, key=class_weights.get) def predict(self, X_test): predictions = [] for x_test in X_test: distances = [] for x_train, y_train in zip(self.X_train, self.y_train): dist = self.distance(x_train, x_test) distances.append((dist, y_train)) distances.sort(key=lambda x: x[0]) k_nearest_neighbors = distances[:self.k] predictions.append(self.weighted_vote(k_nearest_neighbors)) return np.array(predictions)"},{"question":"# K-Means Clustering Implementation **Scenario**: You are analyzing a large dataset to identify patterns and group similar data points. You decide to implement the K-Means Clustering algorithm, one of the popular unsupervised machine learning techniques used for clustering data into K clusters. Implement a function in Python to perform K-Means Clustering on a given dataset. # Function Signature ```python def k_means_clustering(data: np.ndarray, k: int, max_iterations: int = 300, tol: float = 1e-4) -> Tuple[np.ndarray, np.ndarray]: pass ``` # Input 1. `data` (numpy.ndarray): A dataset of shape (N, M) where N is the number of data points and M is the number of features. 2. `k` (int): The number of clusters. 3. `max_iterations` (int): Maximum number of iterations before the algorithm stops. Default is 300. 4. `tol` (float): Tolerance for convergence. Default is 1e-4. # Output - `Tuple[np.ndarray, np.ndarray]`: A tuple containing: - An (N,) shaped numpy array with the cluster index for each data point. - A (k, M) shaped numpy array with the final cluster centroids. # Constraints - The number of clusters `k` should be less than or equal to the number of data points `N`. - The algorithm should handle edge cases such as empty clusters during iterations and convergence before reaching the maximum number of iterations. - The solution should be approached iteratively, updating centroids until convergence criteria based on tolerance or maximum iterations. # Performance Requirements - The solution should work efficiently for reasonably large datasets, say up to 10,000 data points or more. # Examples ```python import numpy as np # Example 1: data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) k = 2 clusters, centroids = k_means_clustering(data, k) # Expected Output: # clusters -> array indicating the cluster index for each data point, e.g., array([0, 0, 1, 1, 0, 1]) # centroids -> array with the coordinates of the final cluster centroids, e.g., array([[1.1667, 1.4667], [7.3333, 9.0]]) # Example 2: data = np.array([ [2.0, 3.0], [2.5, 4.5], [5.0, 7.0], [8.0, 9.0], [0.5, 2.0] ]) k = 3 clusters, centroids = k_means_clustering(data, k) # The exact output may vary slightly due to initialization and iteration process, but it should converge properly within tolerance. ``` Write a function `k_means_clustering` following the provided function signature and satisfy the requirements outlined.","solution":"import numpy as np from typing import Tuple def k_means_clustering(data: np.ndarray, k: int, max_iterations: int = 300, tol: float = 1e-4) -> Tuple[np.ndarray, np.ndarray]: Perform K-Means Clustering on the given dataset. Parameters: data (numpy.ndarray): A dataset of shape (N, M) where N is the number of data points and M is the number of features. k (int): The number of clusters. max_iterations (int): Maximum number of iterations before the algorithm stops. Default is 300. tol (float): Tolerance for convergence. Default is 1e-4. Returns: Tuple[np.ndarray, np.ndarray]: A tuple containing: - An (N,) shaped numpy array with the cluster index for each data point. - A (k, M) shaped numpy array with the final cluster centroids. np.random.seed(42) # For reproducibility N, M = data.shape # Step 1: Initialize centroids randomly by selecting k data points initial_indices = np.random.choice(N, k, replace=False) centroids = data[initial_indices] for iteration in range(max_iterations): # Step 2: Assign each data point to the nearest centroid distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) cluster_indices = np.argmin(distances, axis=1) # Step 3: Recalculate centroids as the mean of assigned points new_centroids = np.array([data[cluster_indices == i].mean(axis=0) for i in range(k)]) # Step 4: Check for convergence (if centroid changes are smaller than tol) centroid_shifts = np.linalg.norm(new_centroids - centroids, axis=1) if np.all(centroid_shifts < tol): break centroids = new_centroids return cluster_indices, centroids"},{"question":"Scenario You are tasked with improving the customer experience in an online bookstore. A new feature requirement is to implement a book recommendation system that suggests books based on a customer\'s reading history. However, the bookstore wants to specifically promote books that are similar to the ones already read and highly rated by the customer. Your job is to write the function that generates the top N book recommendations for a given customer. Problem Statement Write a function `recommend_books` that, given a customer\'s reading history and a list of available books with their similarity scores, returns the top N recommended books. # Function Signature ```python def recommend_books(reading_history: List[str], available_books: List[Tuple[str, float]], n: int) -> List[str]: ``` # Input * A list of strings `reading_history` where each string represents a book title that the customer has read and rated highly. * A list of tuples `available_books` where each tuple contains: * The title of the book (a string). * The similarity score of the book with respect to the customer\'s reading history (a float value where 0 <= similarity score <= 1). * An integer `n` representing the number of top recommendations required. # Output * The function should return a list of strings containing the titles of the top N recommended books, sorted by their similarity scores in descending order. * If there are fewer than N books in `available_books`, return all the books sorted by similarity score. # Constraints * 1 <= length of reading_history <= 100 * 0 <= length of available_books <= 1000 * 1 <= n <= 100 * The similarity scores are unique for simplicity. # Example ```python reading_history = [\\"BookA\\", \\"BookB\\", \\"BookC\\"] available_books = [(\\"BookD\\", 0.9), (\\"BookE\\", 0.8), (\\"BookF\\", 0.85), (\\"BookG\\", 0.7)] n = 3 result = recommend_books(reading_history, available_books, n) # This should return the top 3 recommendations based on similarity scores # [\\"BookD\\", \\"BookF\\", \\"BookE\\"] ``` # Additional Information * The recommendations are purely based on the similarity scores provided, with no additional filtering needed. * Ensure your function runs efficiently to handle the upper bound of input sizes gracefully. * The function should prioritize the highest similarity scores for recommendations in case of ties.","solution":"from typing import List, Tuple def recommend_books(reading_history: List[str], available_books: List[Tuple[str, float]], n: int) -> List[str]: Generate the top N book recommendations based on the similarity scores of available books. :param reading_history: List of book titles the customer has read and rated highly :param available_books: List of tuples where each tuple contains a book title and its similarity score :param n: Number of top recommendations required :return: List of recommended book titles sorted by similarity scores in descending order # Sort the available_books based on the similarity score in descending order sorted_books = sorted(available_books, key=lambda x: x[1], reverse=True) # Get the top N book titles based on their sorted order top_n_books = [book[0] for book in sorted_books[:n]] return top_n_books"},{"question":"# Problem Statement Design a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]:` to rotate a given NxN matrix 90 degrees clockwise. # Inputs - A 2D list of integers representing an NxN matrix (1  N  1000). # Outputs - A 2D list representing the rotated matrix. # Constraints & Performance - ( 1 leq text{matrix}[i][j] leq 10^4 ) - Time Complexity: O(n^2) - Space Complexity: O(1), the rotation should be done in place if possible, otherwise note the additional space complexity. # Scenario for Context You are given an NxN matrix. The matrix is square and each element represents an integer. Your task is to rotate the matrix 90 degrees clockwise. # Sample Tests **Input**: ```python assert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] assert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]] ``` **Explanation**: - For the first matrix, rotating 90 degrees clockwise transforms the matrix as follows: ``` 1 2 3 7 4 1 4 5 6 -> 8 5 2 7 8 9 9 6 3 ``` - For the second matrix: ``` 1 2 3 1 3 4 -> 4 2 ```","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix 90 degrees clockwise. :param matrix: A 2D list of integers representing an NxN matrix :return: The rotated matrix n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - 1 - j][i] matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] matrix[j][n - 1 - i] = temp return matrix"},{"question":"Triangle Area Calculation You\'re required to implement a function that calculates the area of a triangle given the lengths of its three sides using Heron\'s formula. Function Specification 1. **Function name**: `triangle_area` - **Input**: `side1` (float), `side2` (float), `side3` (float) - the lengths of the three sides of the triangle. - **Output**: (float) - the area of the triangle. - **Constraints**: - `side1`, `side2`, and `side3` should be positive integers. - The input values should satisfy the triangle inequality condition. Implementation Details **triangle_area**: Formula: 1. Calculate the semi-perimeter ( s = frac{(a + b + c)}{2} ) 2. Calculate the area ( text{area} = sqrt{s times (s - a) times (s - b) times (s - c)} ) where `a`, `b`, and `c` are the lengths of the sides of the triangle. Example *Inputs*: ```python print(triangle_area(3, 4, 5)) # Expected output: 6.0 print(triangle_area(7, 10, 5)) # Expected output: 16.24807680927192 ``` *Outputs*: ```python 6.0 16.24807680927192 ``` If any side length is not valid (non-positive or not an integer), or if the sides do not satisfy the triangle inequality, the function should raise a `ValueError` with an appropriate message. Requirements - Implement and thoroughly test the function. - Handle edge cases and invalid inputs appropriately.","solution":"import math def triangle_area(side1, side2, side3): Calculate the area of a triangle using Heron\'s formula. Parameters: side1 (float): length of the first side of the triangle side2 (float): length of the second side of the triangle side3 (float): length of the third side of the triangle Returns: float: area of the triangle Raises: ValueError: If any side is not a positive integer or if the sides do not satisfy the triangle inequality # Check if the sides are positive numbers if not (side1 > 0 and side2 > 0 and side3 > 0): raise ValueError(\\"Sides must be positive numbers\\") # Check for triangle inequality if not (side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1): raise ValueError(\\"Sides do not satisfy the triangle inequality\\") # Calculate semi-perimeter s = (side1 + side2 + side3) / 2.0 # Calculate area using Heron\'s formula area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3)) return area"},{"question":"**String Permutation Checker** Write a function `is_permutation` that takes two strings as input and determines whether they are permutations of each other. In other words, the function should return `True` if one string can be rearranged to form the other string, and `False` otherwise. Your function should consider permutations in a case-sensitive manner (i.e., \'A\' is different from \'a\') and should also take into account any whitespace or special characters. # Function Signature ```python def is_permutation(s1: str, s2: str) -> bool: ``` # Input - `s1`: A string containing alphanumeric characters, whitespace, or special characters. - `s2`: Another string containing alphanumeric characters, whitespace, or special characters. # Output - Returns a boolean value `True` if `s1` and `s2` are permutations of each other, and `False` otherwise. # Constraints - The lengths of both strings will be between 0 and 100 inclusive. # Example ```python >>> is_permutation(\\"abc\\", \\"cba\\") True >>> is_permutation(\\"abc\\", \\"def\\") False >>> is_permutation(\\"A man, a plan, a canal, Panama\\", \\"A man, a plan, a canal, Panama \\") False >>> is_permutation(\\"1234\\", \\"4321\\") True >>> is_permutation(\\"abc!@\\", \\"@!cba\\") True ``` # Notes - String comparison should be case-sensitive. - Remember to consider strings with different lengths early to optimize performance. If the lengths are different, they cannot be permutations of each other. - Utilize efficient string operations and internal data structures to achieve optimal performance.","solution":"def is_permutation(s1: str, s2: str) -> bool: Determines if s1 is a permutation of s2. Parameters: s1 (str): First string. s2 (str): Second string. Returns: bool: True if s1 is a permutation of s2, False otherwise. # Early exit if the lengths of the strings are different if len(s1) != len(s2): return False # Sort both strings and compare return sorted(s1) == sorted(s2)"},{"question":"# Fibonacci Sequence Alignment Context The Fibonacci sequence is a classic series in mathematics where each number is the sum of the two preceding ones, usually starting with 0 and 1. More formally, the sequence is defined by: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) Given its significance in algorithms and mathematics, this challenge requires you to implement a function that aligns a given list of integers to the Fibonacci sequence by allowing only the numbers present in the sequence up to the maximum integer in the list. Task Write a Python function `fibonacci_filter(numbers: List[int]) -> List[int]` that takes a list of integers and returns a new list containing only those integers which appear in the Fibonacci sequence up to the maximum integer in the input list. Input * A list of integers `numbers` (1  len(numbers)  10^5, 0  numbers[i]  10^9) Output * A filtered list of integers which are part of the Fibonacci sequence up to the maximum value in the input list. Constraints * Your function should be optimized for performance. * The order of the resulting list should match the order of the input list integers. # Example ```python >>> fibonacci_filter([10, 15, 8, 34, 2]) [8, 34, 2] >>> fibonacci_filter([4, 6, 7, 22]) [] >>> fibonacci_filter([0, 1, 1, 2, 3, 5]) [0, 1, 1, 2, 3, 5] ``` Notes For this task, precompute the Fibonacci sequence up to the largest number in the list, which ensures the filtering is efficient. This can be done efficiently using an iterative approach, storing sequence numbers in a set for constant-time lookups.","solution":"def fibonacci_filter(numbers): Returns a list of numbers that are part of the Fibonacci sequence up to the maximum value in the input list. if not numbers: return [] max_num = max(numbers) fibs = set() a, b = 0, 1 fibs.add(a) while a <= max_num: fibs.add(a) a, b = b, a + b return [num for num in numbers if num in fibs]"},{"question":"# Scenario As part of an ongoing effort to optimize algorithms for large datasets, you are asked to develop an enhanced version of the \\"Merge Arrays\\" function. This function is frequently utilized in data processing tasks requiring the merging and deduplication of sorted arrays. # Task Write a function `optimized_merge_arrays` that merges multiple sorted arrays into a single, sorted, deduplicated list efficiently. # Function Signature ```python from typing import List def optimized_merge_arrays(arrays: List[List[int]]) -> List[int]: pass ``` # Input - `arrays` (List[List[int]]): A list of `n` lists, where each list contains sorted integers. The total number of integers across all lists does not exceed 10^6. # Output - Returns a new list containing all unique integers from the input lists, sorted in ascending order. # Constraints - Each inner list may be empty. - All integers in the lists are within the range of -10^6 to 10^6. # Examples ```python print(optimized_merge_arrays([[1, 3, 5], [2, 4, 6]])) # Output: [1, 2, 3, 4, 5, 6] print(optimized_merge_arrays([[1, 1, 3], [3, 3, 5], [2, 4, 6]])) # Output: [1, 2, 3, 4, 5, 6] print(optimized_merge_arrays([[], [2, 4, 6], [1, 3, 5]])) # Output: [1, 2, 3, 4, 5, 6] ``` # Hint Utilize a min-heap to efficiently merge and deduplicate the arrays. Ensure that the merged list maintains its sorted order while avoiding duplicate entries.","solution":"from typing import List import heapq def optimized_merge_arrays(arrays: List[List[int]]) -> List[int]: Merges multiple sorted arrays into a single sorted, deduplicated list. min_heap = [] for i, array in enumerate(arrays): if array: heapq.heappush(min_heap, (array[0], i, 0)) result = [] prev = None while min_heap: value, list_idx, element_idx = heapq.heappop(min_heap) if value != prev: result.append(value) prev = value if element_idx + 1 < len(arrays[list_idx]): next_value = arrays[list_idx][element_idx + 1] heapq.heappush(min_heap, (next_value, list_idx, element_idx + 1)) return result"},{"question":"# Problem Statement: Write a function that generates all possible permutations of a given length from a list of unique elements. The elements may be of any data type (integers, strings, floats, etc.). The function should make use of backtracking to ensure all permutations are produced efficiently. # Function Signature: ```python def generate_permutations(elements: list, n: int) -> list[tuple]: Generate all possible permutations of length n from the list elements. Args: elements (list): A list containing unique elements to generate permutations from. n (int): The length of each permutation. Returns: list[tuple]: A list containing tuples, each tuple representing a permutation of n elements. ``` # Input: - `elements` - A list of distinct elements. The elements can be integers, strings, floats, or any combination of these types. - `n` - An integer specifying the length of each permutation. # Output: - A list of tuples, where each tuple contains `n` elements in a particular order. # Constraints: - All elements within the list are unique. - `n` is a non-negative integer. # Requirements: 1. Implement the function `generate_permutations` using the principles of backtracking. 2. Handle edge cases effectively: - When `n` is 0, the result is a list containing an empty tuple. - When `n` is greater than the length of the list, return an empty list. 3. Ensure that the function is optimized for both performance and memory usage. # Sample Test Cases: ```python assert generate_permutations([10, 20, 30], 2) == [(10, 20), (10, 30), (20, 10), (20, 30), (30, 10), (30, 20)] assert generate_permutations([1, 2, 3], 1) == [(1,), (2,), (3,)] assert generate_permutations([\'a\', \'b\'], 2) == [(\'a\', \'b\'), (\'b\', \'a\')] assert generate_permutations([5], 1) == [(5,)] assert generate_permutations([12, \'x\', 15.6], 2) == [(12, \'x\'), (12, 15.6), (\'x\', 12), (\'x\', 15.6), (15.6, 12), (15.6, \'x\')] assert generate_permutations([], 0) == [()] assert generate_permutations([100, 200], 0) == [()] assert generate_permutations([1, 2, 3, 4], 3) == [(1, 2, 3), (1, 2, 4), (1, 3, 2), (1, 3, 4), (1, 4, 2), (1, 4, 3), (2, 1, 3), (2, 1, 4), (2, 3, 1), (2, 3, 4), (2, 4, 1), (2, 4, 3), (3, 1, 2), (3, 1, 4), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2), (4, 1, 2), (4, 1, 3), (4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)] ```","solution":"def generate_permutations(elements: list, n: int) -> list[tuple]: def backtrack(path, remaining): if len(path) == n: result.append(tuple(path)) return for i in range(len(remaining)): path.append(remaining[i]) backtrack(path, remaining[:i] + remaining[i+1:]) path.pop() if n == 0: return [()] if n > len(elements): return [] result = [] backtrack([], elements) return result"},{"question":"# Prime Factorization using Sieve of Eratosthenes **Objective**: Implement a function that computes the prime factorization of a given integer `n` using a modified Sieve of Eratosthenes. **Function Signature**: `def prime_factorization(n: int) -> dict:` **Requirements**: - **Inputs**: - A single integer `n`. - `n` must be a positive integer greater than 1. - **Outputs**: - A dictionary where the keys are the prime factors and the values are their respective exponents in the prime factorization of `n`. **Constraints**: - Raise a `ValueError` if `n` is not a positive integer greater than 1. - Ensure efficiency for values of `n` up to 10 million. **Example**: ```python >>> prime_factorization(28) {2: 2, 7: 1} >>> prime_factorization(100) {2: 2, 5: 2} ``` **Detailed Steps**: 1. Validate input to ensure `n` is a positive integer greater than 1. 2. Utilize the Sieve of Eratosthenes to find all prime numbers less than or equal to the square root of `n`. 3. Use the primes to determine the prime factors of `n` and their exponents: - Create an empty dictionary to hold the prime factors. - Iterate over each prime number: - While the prime number divides `n`, increment its count in the dictionary and divide `n` accordingly. 4. If `n` is still greater than 1 after the loop, it is a prime factor itself. **Scenario**: This task allows you to demonstrate your ability to implement a classic computer science algorithm (Sieve of Eratosthenes) and apply it to a commonly needed mathematical decomposition problem (prime factorization), thus showcasing both your efficiency in algorithm design and your skills in applying algorithms to solve practical problems.","solution":"def prime_factorization(n: int) -> dict: if n <= 1: raise ValueError(\\"Input must be a positive integer greater than 1\\") import math # Sieving prime numbers up to sqrt(n) def sieve(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i * i, limit + 1, i): is_prime[j] = False primes = [i for i, prime in enumerate(is_prime) if prime] return primes # Get the prime numbers up to sqrt(n) primes = sieve(int(math.sqrt(n)) + 1) factor_count = {} # Factorize n using primes for prime in primes: while n % prime == 0: if prime in factor_count: factor_count[prime] += 1 else: factor_count[prime] = 1 n //= prime # If n is still greater than 1, it is a prime factor itself if n > 1: factor_count[n] = 1 return factor_count"},{"question":"# Binary Tree Level Order Traversal **Context**: You are working on a data analysis tool that frequently requires analysis of hierarchical data structures. One common task is to traverse binary trees level by level, which is crucial for evaluating various statistics across different levels of a hierarchy. **Task**: Implement a function `level_order_traversal(root: TreeNode) -> List[List[int]]` that performs a level order traversal of a binary tree and returns the values of the nodes at each level as a list of lists. **Requirements**: 1. Define a class `TreeNode` for the nodes of the binary tree. 2. Implement the function to traverse the tree level by level. 3. Handle edge cases such as empty trees or trees with a single node. **Input**: * A binary tree represented by its root node `root`, where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output**: * A list of lists, where each inner list contains the values of the nodes at that level. **Constraints**: * The tree node values are integers. * The number of nodes in the tree is between `0` and `1000`. **Example**: ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(level_order_traversal(root)) # Output: [[3], [9, 20], [15, 7]] root = TreeNode(1) print(level_order_traversal(root)) # Output: [[1]] root = None print(level_order_traversal(root)) # Output: [] ``` **Edge Cases**: - `level_order_traversal(None)` should return `[]`. - `level_order_traversal(TreeNode(1))` should return `[[1]]`.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Problem Statement Design a function that detects cycles in a directed graph using Depth-First Search. You are required to determine if there is at least one cycle in the graph. # Function Signature ```python def has_cycle(graph: list[list[int]]) -> bool: pass ``` # Input - `graph`: A list of lists where each `graph[i]` contains a list of nodes that node `i` has directed edges to (0-indexed). # Output - Returns a boolean value: `True` if there is at least one cycle in the graph, otherwise `False`. # Constraints 1. The number of nodes will be between 1 and 10^5. 2. The number of edges will be between 0 and 10^5. # Examples ```python assert has_cycle([[1], [2], [0]]) == True assert has_cycle([[1, 2], [2], []]) == False ``` # Explanation 1. For the first example: - Node 0 has a directed edge to node 1. - Node 1 has a directed edge to node 2. - Node 2 has a directed edge to node 0. - This creates a cycle: 0 -> 1 -> 2 -> 0. 2. For the second example: - Node 0 has directed edges to nodes 1 and 2. - Node 1 has a directed edge to node 2. - Node 2 has no outgoing edges. - There is no cycle in this graph. # Scenario You are tasked with analyzing the dependencies between tasks in a project schedule. Each task may depend on one or more other tasks, potentially creating dependency cycles. Your goal is to determine if any dependency cycles exist, which would indicate that the project schedule is not feasible.","solution":"def has_cycle(graph: list[list[int]]) -> bool: def dfs(node): if visited[node] == 1: # node is being visited, so we have found a cycle return True if visited[node] == 2: # node is already fully visited return False visited[node] = 1 # mark as being visited for neighbor in graph[node]: if dfs(neighbor): return True visited[node] = 2 # mark as fully visited return False visited = [0] * len(graph) # 0: unvisited, 1: visiting, 2: visited for node in range(len(graph)): if visited[node] == 0: # if the node is unvisited if dfs(node): return True return False"},{"question":"# Matrix Manipulation Function Objective Implement a function that performs a specific matrix manipulation based on a provided operation name. Use the `MatrixManipulator` class to achieve this. Input The function will take: 1. **operation_name**: A string representing the operation to perform (e.g., \'transpose\', \'rotate\'). 2. **matrix**: A 2D numpy array on which the operation will be performed. Output The function should return the resulting matrix after the specified operation. Constraints - Ensure that the input matrix is a 2D numpy array. - The operation_name must be one of the supported operations in the `MatrixManipulator` class. - Handle any invalid operation_name inputs gracefully, returning the original matrix. Supported Operations - **transpose**: Transposes the matrix. - **rotate**: Rotates the matrix 90 degrees clockwise. Example Usage ```python # Example matrix matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Example function call result = manipulate_matrix(\\"rotate\\", matrix) print(result) # Expected output: # [[7 4 1] # [8 5 2] # [9 6 3]] ``` Implementation Details 1. Instantiate the `MatrixManipulator` class. 2. Use the appropriate method from the `MatrixManipulator` class to perform the desired operation. 3. Return the modified matrix or the original matrix if the operation_name is invalid. Function Signature ```python import numpy as np class MatrixManipulator: @staticmethod def transpose(matrix: np.ndarray) -> np.ndarray: return np.transpose(matrix) @staticmethod def rotate(matrix: np.ndarray) -> np.ndarray: return np.rot90(matrix, -1) def manipulate_matrix(operation_name: str, matrix: np.ndarray) -> np.ndarray: # Your implementation here pass ```","solution":"import numpy as np class MatrixManipulator: @staticmethod def transpose(matrix: np.ndarray) -> np.ndarray: return np.transpose(matrix) @staticmethod def rotate(matrix: np.ndarray) -> np.ndarray: return np.rot90(matrix, -1) def manipulate_matrix(operation_name: str, matrix: np.ndarray) -> np.ndarray: manipulator = MatrixManipulator() if operation_name == \\"transpose\\": return manipulator.transpose(matrix) elif operation_name == \\"rotate\\": return manipulator.rotate(matrix) else: return matrix"},{"question":"# Problem Statement You are given a string of lowercase English letters, and your task is to determine the most frequently occurring letter in the string. If there is a tie, return the alphabetically first letter among them. # Detailed Instructions Implement the function `most_frequent_letter(s: str) -> str` which takes a string `s` as input and returns a string, the most frequently occurring letter in the input string. # Input * A string `s` consisting of lowercase English letters where 1 <= len(s) <= 10^5. # Output * Return a single character, the most frequently occurring letter in the input string. # Example ```python assert most_frequent_letter(\\"aabbbcccc\\") == \\"c\\" # \'c\' occurs 4 times assert most_frequent_letter(\\"abbccc\\") == \\"c\\" # \'c\' occurs 3 times assert most_frequent_letter(\\"abcd\\") == \\"a\\" # all letters occur once, \'a\' is the alphabetically first ``` # Constraints * `1 <= len(s) <= 100000` * Achieve a solution with an optimal balance of readability and performance. # Notes 1. Use a dictionary or a collection counter to keep track of the frequency of each letter. 2. Ensure that your solution efficiently handles edge cases, such as when all letters occur once and the string length is very close to the upper constraint. Design your implementation to meet the given constraints efficiently. Focus on ensuring that the solution has optimal time and space complexity.","solution":"from collections import Counter def most_frequent_letter(s: str) -> str: Determine the most frequently occurring letter in the string s. If there is a tie, return the alphabetically first letter among them. # Count the frequency of each letter count = Counter(s) # Find the maximum frequency max_frequency = max(count.values()) # Collect all letters with the maximum frequency most_frequent_letters = [letter for letter, freq in count.items() if freq == max_frequency] # Return the alphabetically first letter among the most frequent ones return min(most_frequent_letters)"},{"question":"# Problem Description: Complete the implementation of a Binary Search Tree (BST) by adding the following method: **Task**: Implement a method find_min which finds and returns the minimum value in the Binary Search Tree. ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) return root def find_min(self): Finds the minimum value in the BST. Time complexity: O(h), where h is the height of the BST. @returns: The minimum value in the tree. Example: >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(2) >>> bst.find_min() 2 >>> bst.insert(1) >>> bst.find_min() 1 if self.root is None: return None current = self.root while current.left is not None: current = current.left return current.val ``` **Input**: - None **Output**: - The minimum value in the BST (int), or None if the tree is empty. # Constraints: - The BST implemented must support common operations such as insertion. - The find_min method must traverse the left subtree to find the minimum value. - Proper handling of edge cases (e.g., empty tree). # Example Consider a sample usage below: ```python # BST initialization bst = BST() # Inserting elements bst.insert(10) bst.insert(5) bst.insert(2) bst.insert(1) bst.insert(15) # Finding the minimum value print(bst.find_min()) # Output: 1 # Inserting more elements bst.insert(0) print(bst.find_min()) # Output: 0 ``` **Notes**: - Ensure proper traversal of the left subtree to find the minimum value. - Handle both empty and populated trees effectively. - Test for updating the minimum value as new nodes are inserted.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) return root def find_min(self): Finds the minimum value in the BST. Time complexity: O(h), where h is the height of the BST. @returns: The minimum value in the tree. Example: >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(2) >>> bst.find_min() 2 >>> bst.insert(1) >>> bst.find_min() 1 if self.root is None: return None current = self.root while current.left is not None: current = current.left return current.val"},{"question":"Question # Problem: You are tasked with implementing a function that processes a list of integer scores representing students\' performances in a course. Your function will categorize the scores into letter grades and provide a summary report of the grade distribution. # Function Signature: ```python def grade_summary(scores: list) -> dict: pass ``` # Input: - `scores`: A list of integers representing the scores of students. Each score will be in the range from 0 to 100 inclusive. # Output: - A dictionary containing the following keys and their respective values: - `\\"A\\"`: Count of scores between 90 and 100 (inclusive). - `\\"B\\"`: Count of scores between 80 and 89 (inclusive). - `\\"C\\"`: Count of scores between 70 and 79 (inclusive). - `\\"D\\"`: Count of scores between 60 and 69 (inclusive). - `\\"F\\"`: Count of scores below 60. # Constraints: - The `scores` list will contain at least one element and at most 100 elements. # Example: ```python scores = [89, 92, 76, 85, 67, 54, 91, 73, 88, 66] result = grade_summary(scores) # Expected output: # { # \\"A\\": 2, # \\"B\\": 3, # \\"C\\": 2, # \\"D\\": 2, # \\"F\\": 1 # } ``` # Notes: - Ensure the function accurately counts the scores that fall into each grade category. - Handle edge cases, such as scores at the boundaries of the grade ranges (e.g., exactly 60, 70, 80, 90). --- # Hints: - Use conditional statements to categorize and count each score. - Consider using a dictionary to store and update the counts for each grade category.","solution":"def grade_summary(scores): This function categorizes a list of scores into letter grades and provides a summary report of the grade distribution. grade_distribution = {\\"A\\": 0, \\"B\\": 0, \\"C\\": 0, \\"D\\": 0, \\"F\\": 0} for score in scores: if 90 <= score <= 100: grade_distribution[\\"A\\"] += 1 elif 80 <= score <= 89: grade_distribution[\\"B\\"] += 1 elif 70 <= score <= 79: grade_distribution[\\"C\\"] += 1 elif 60 <= score <= 69: grade_distribution[\\"D\\"] += 1 elif 0 <= score < 60: grade_distribution[\\"F\\"] += 1 else: raise ValueError(f\\"Invalid score: {score}\\") return grade_distribution"},{"question":"# Shape Perimeter Calculation You have been tasked with creating a function that calculates the total perimeter of a 2D structure composed of multiple geometric shapes, based on given inputs. Each shape and its dimensions are provided as input, and the structure includes both individual shapes and complex combinations where perimeter intersections need to be managed. Your function should be flexible enough to handle instructions to either add or subtract perimeters of the shapes, as specified. The instructions will be provided in a specific format, and the function should properly parse and execute these instructions while ensuring input validation and accurate perimeter calculation. # Instructions 1. **Function Signature**: ```python def total_perimeter(instructions: List[Dict[str, Any]]) -> float: ``` 2. **Inputs**: ```python [ {\\"shape\\": \\"rectangle\\", \\"length\\": 4, \\"width\\": 3, \\"operation\\": \\"add\\"}, {\\"shape\\": \\"circle\\", \\"radius\\": 2, \\"operation\\": \\"add\\"}, {\\"shape\\": \\"triangle\\", \\"sides\\": [3, 4, 5], \\"operation\\": \\"subtract\\"}, ... ] ``` * `shape`: A string indicating the type of shape (e.g., \\"rectangle\\", \\"circle\\", \\"triangle\\"). * Dimensions of the shape as needed. * `operation`: A string indicating whether to \\"add\\" or \\"subtract\\" the perimeter of the shape to/from the total perimeter. 3. **Output**: * A single float value representing the total computed perimeter after performing all the specified operations. 4. **Constraints**: * All dimensions will be non-negative numbers. * Input list can be empty, in which case the output should be `0.0`. 5. **Example**: ```python instructions = [ {\\"shape\\": \\"rectangle\\", \\"length\\": 4, \\"width\\": 3, \\"operation\\": \\"add\\"}, {\\"shape\\": \\"circle\\", \\"radius\\": 2, \\"operation\\": \\"add\\"}, {\\"shape\\": \\"triangle\\", \\"sides\\": [3, 4, 5], \\"operation\\": \\"subtract\\"} ] result = total_perimeter(instructions) print(result) # The total perimeter after performing the instructions ``` 6. **Hint**: Use the perimeter calculation formulas for individual shapes as follows: * Rectangle: (2 times (length + width)) * Circle: (2 times pi times radius) * Triangle: Sum of the three sides Implement the function `total_perimeter` such that it correctly processes the instructions and outputs the total perimeter.","solution":"import math from typing import List, Dict, Any def total_perimeter(instructions: List[Dict[str, Any]]) -> float: total = 0.0 for instruction in instructions: shape = instruction.get(\\"shape\\") operation = instruction.get(\\"operation\\") if shape == \\"rectangle\\": length = instruction.get(\\"length\\", 0) width = instruction.get(\\"width\\", 0) perimeter = 2 * (length + width) elif shape == \\"circle\\": radius = instruction.get(\\"radius\\", 0) perimeter = 2 * math.pi * radius elif shape == \\"triangle\\": sides = instruction.get(\\"sides\\", [0, 0, 0]) perimeter = sum(sides) else: # Invalid shape perimeter = 0 if operation == \\"add\\": total += perimeter elif operation == \\"subtract\\": total -= perimeter else: # Invalid operation, skip the instruction continue return total"},{"question":"**Problem Statement:** Write a function to check if a given set of strings can compose a valid sentence. The function should ensure that the sentence starts with an uppercase letter, ends with a period, and the words are space-separated. Additionally, no word should contain numbers or special characters, only lowercase and uppercase alphabets are allowed. **Function Signature:** ```python def is_valid_sentence(words: List[str]) -> bool: pass ``` # Input: - `words`: A list of strings representing the words of the sentence. # Output: - Returns `True` if the words can form a valid sentence, otherwise returns `False`. # Constraints: - The number of words in the list will be between `1` and `10^3`. - Words will contain between `1` and `50` characters. # Example: ```python # Given the list of words: # [\\"This\\", \\"is\\", \\"a\\", \\"valid\\", \\"sentence.\\"] # # The output should be: # is_valid_sentence(words) -> True ``` # Additional Examples: ```python # Given the list of words: # [\\"This\\", \\"is\\", \\"not\\", \\"valid\\", \\"sentence\\"] # # The output should be: # is_valid_sentence(words) -> False # Explanation: The sentence does not end with a period. # Given the list of words: # [\\"this\\", \\"is\\", \\"a\\", \\"valid\\", \\"sentence.\\"] # # The output should be: # is_valid_sentence(words) -> False # Explanation: The first word does not start with an uppercase letter. # Given the list of words: # [\\"This123\\", \\"is\\", \\"not\\", \\"valid.\\"] # # The output should be: # is_valid_sentence(words) -> False # Explanation: The first word contains numbers. ``` # Implementation Details: - Use regex or string methods to validate the conditions for a sentence. - Consider edge cases such as a single word in the list or words containing non-alphabet characters. - Assume the function only needs to check for the validity of sentence structure and not the grammatical correctness beyond the specified conditions. # Testing: Thoroughly test the function with diverse scenarios, including boundary cases and various invalid inputs to ensure robustness.","solution":"import re from typing import List def is_valid_sentence(words: List[str]) -> bool: This function checks if the given list of words can form a valid sentence. A valid sentence must satisfy the following conditions: - Starts with an uppercase letter. - Ends with a period. - All words should contain only alphabet characters (both lower and upper case). Parameters: - words: List[str] - A list of words making up the sentence. Returns: - bool - True if the words can form a valid sentence, otherwise False. if not words: return False sentence = \' \'.join(words) if not sentence[0].isupper(): return False if not sentence.endswith(\'.\'): return False # Check each word to ensure it contains only alphabetic characters for word in words: if not word.isalpha() and word != words[-1]: return False if word == words[-1] and not re.match(\\"^[A-Za-z]+[.]\\", word): return False return True"},{"question":"# Question: Implementing and Testing a Custom Matrix Transposition Function Context You are working on a project that requires matrix operations to efficiently handle data transformations. One common operation is the transposition of a matrix. You are required to implement a custom matrix transposition function and test its correctness with provided input matrices. Task 1. Implement a function named `transpose_matrix` that takes a 2D list (matrix) as input and returns its transpose. 2. Write a series of test cases to validate your `transpose_matrix` function using various input matrices. Requirements * **Function Specification**: - The function `transpose_matrix(matrix: list[list[int]]) -> list[list[int]]` should return a new matrix where the rows and columns have been swapped. * **Input/Output**: - Input: A 2D list representing the matrix to be transposed. - Output: A new 2D list representing the transposed matrix. * **Constraints**: - The input matrix can have varying dimensions but will have at least 1 row and 1 column. - You must handle non-square matrices correctly. * **Performance**: - Your implementation should efficiently handle matrices with dimensions up to 1000 x 1000. # Example ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] # Test cases to validate the solution matrix1 = [ [1, 2, 3], [4, 5, 6] ] matrix2 = [ [1, 4], [2, 5], [3, 6] ] matrix3 = [ [3] ] transposed_matrix1 = transpose_matrix(matrix1) assert transposed_matrix1 == [ [1, 4], [2, 5], [3, 6] ], f\'Error in test case 1: {transposed_matrix1}\' transposed_matrix2 = transpose_matrix(matrix2) assert transposed_matrix2 == [ [1, 2, 3], [4, 5, 6] ], f\'Error in test case 2: {transposed_matrix2}\' transposed_matrix3 = transpose_matrix(matrix3) assert transposed_matrix3 == [ [3] ], f\'Error in test case 3: {transposed_matrix3}\' ``` In this question, ensure you rigorously test the `transpose_matrix` function with multiple edge cases, such as non-square matrices and single-element matrices, to confirm its correctness and efficiency.","solution":"def transpose_matrix(matrix): return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"Question: # Context: You are required to develop a function that can determine the longest contiguous subarray that has the maximum sum. This problem is fundamental in understanding prefix sums and can be solved through a combination of linear algorithms and sliding windows for efficiency. # Challenge: Write a function `max_sum_subarray(arr: List[int]) -> Tuple[int, int, int]` that takes in a list of integers and returns the starting index, ending index (inclusive), and the sum of the longest contiguous subarray which has the maximum sum. # Input: - `arr`: A list of integers (both positive and negative). # Output: - A tuple of three integers: `(start_index, end_index, max_sum)`, where `start_index` and `end_index` define the bounds of the subarray and `max_sum` is the sum of the subarray. # Constraints: - The list can contain positive, negative, or zero values. - The length of `arr` will be at least 1 and at most 10^5. - Aim to implement the solution in O(n) time complexity. # Example: ```python def max_sum_subarray(arr: List[int]) -> Tuple[int, int, int]: Your code here assert max_sum_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4]) == (2, 6, 9) assert max_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == (3, 6, 6) assert max_sum_subarray([-1, -2, -3, -4]) == (0, 0, -1) ``` # Implementation Hints: - Use a modified version of Kadanes algorithm to keep track of the maximum sum subarray and update start and end indices accordingly. - Maintain variables to store the best sum seen so far along with corresponding indices. - It is essential to update the start index whenever a new subarray sum calculation begins. By proposing a real-world algorithmic challenge involving subarray maximization, this question remains consistent with the existing set in style, complexity, and scope.","solution":"from typing import List, Tuple def max_sum_subarray(arr: List[int]) -> Tuple[int, int, int]: Finds the subarray with the maximum sum and returns the starting index, ending index (inclusive), and the sum of that subarray. max_sum = curr_sum = arr[0] start = end = s = 0 for i in range(1, len(arr)): if curr_sum < 0: curr_sum = arr[i] s = i else: curr_sum += arr[i] if curr_sum > max_sum: max_sum = curr_sum start = s end = i return (start, end, max_sum)"},{"question":"# Question: Implement Most Frequent Elements Finder You have been provided with a list of integers, and your task is to implement a function that finds the k most frequent elements in this list. If there is a tie in frequency, the smaller element should be preferred. # Function Signature ```python def top_k_frequent(nums: list, k: int) -> list: Arguments: nums: A list of integers. k: An integer representing the number of top frequent elements to return. Returns: A list of k integers representing the most frequent elements, sorted by their frequency and then by their value if frequency is the same. ``` # Expected Input and Output * **Input**: * `nums`: A list of integers (length n). * `k`: An integer specifying the number of top frequent elements to find. * **Output**: * A list of k integers representing the most frequent elements. * **Constraints**: * 1  n  10^5 * -10^4  nums[i]  10^4 * 1  k  n # Example ```python >>> nums = [1, 1, 1, 2, 2, 3] >>> k = 2 >>> top_k_frequent(nums, k) [1, 2] >>> nums = [4, 4, 4, 5, 6, 6, 7, 7, 7] >>> k = 3 >>> top_k_frequent(nums, k) [4, 7, 6] ``` # Algorithm Steps 1. Use a dictionary to count the frequency of each element in the list. 2. Create a list of tuples where each tuple contains an element and its frequency. 3. Sort this list first by frequency in descending order, and then by element value in ascending order in case of frequency ties. 4. Extract the top k elements from the sorted list. 5. Return the result as a list of these k elements. # Performance The solution should handle input sizes up to 10^5 efficiently. Consider using heap or sorting techniques to optimize performance. # Notes * Edge cases include lists where all elements are unique or where there are ties in frequency with multiple elements. Ensure your function handles these effectively. * Adding comments or docstrings to your code will help in explaining the logic and steps used in your implementation.","solution":"from collections import Counter import heapq def top_k_frequent(nums: list, k: int) -> list: Returns the k most frequent elements in the list nums. If there is a tie in frequency, the smaller element is preferred. Arguments: nums: A list of integers. k: An integer representing the number of top frequent elements to return. Returns: A list of k integers representing the most frequent elements, sorted by their frequency and then by their value if frequency is the same. # Count the frequency of each element in nums frequency_counter = Counter(nums) # Use a heap to get the k most frequent elements # The heap uses negative frequency to get the largest frequencies heap = [(-freq, num) for num, freq in frequency_counter.items()] heapq.heapify(heap) # Extract the k elements with the highest frequency (and smallest number in case of ties) top_k_elements = [heapq.heappop(heap)[1] for _ in range(k)] return top_k_elements"},{"question":"# Problem Statement You are tasked with extending a partial implementation of the Least Squares Regression model to include Ridge Regression regularization. Ridge Regression adds a regularization term to the loss function, which helps prevent overfitting and manage multicollinearity in the data. Your main goals are: 1. **Implement Ridge Regression**: Modify the given least squares function to support Ridge Regression by adding a regularization term. The regularization term should be controlled by a parameter (lambda). 2. **Implement Cross-Validation**: Implement k-fold cross-validation to automatically tune the regularization parameter (lambda). You should select the (lambda) that results in the lowest average validation error across the k folds. # Task 1. **Modify the Loss Function**: Extend the ordinary least squares loss function to include a regularization term with parameter (lambda). 2. **Implement k-fold Cross-Validation**: Add functionality to split the dataset into k folds and evaluate different values of (lambda) to minimize validation error. You can use mean squared error (MSE) as the evaluation metric. # Input and Output * **Input**: * `X_train`: (N times M) NumPy array, feature matrix of the training data. * `y_train`: (N times 1) NumPy array, response vector of the training data. * `lambdas`: List of floats, candidate values for the regularization parameter (lambda). * `k` (optional): Integer, number of folds for cross-validation. (Default: 5) * **Output**: * Return the best (lambda) and the corresponding weight vector (w). # Example ```python import numpy as np X_train = np.array([ [1, 2], [2, 3], [3, 4], [4, 5] ]) y_train = np.array([ [2], [3], [4], [5] ]) lambdas = [0.01, 0.1, 1, 10] best_lambda, best_weights = ridge_regression_cross_validation(X_train, y_train, lambdas) print(\\"Best Lambda:\\", best_lambda) print(\\"Best Weights:\\", best_weights) ``` # Constraints * The input feature matrix will be provided as a NumPy array. * Ensure that the implementation is computationally efficient and handles large datasets gracefully. * Handle all potential scenarios, including when the feature matrix has highly correlated features. # Implementation Extend the code provided and define the function `ridge_regression_cross_validation`: ```python import numpy as np from sklearn.model_selection import KFold def ridge_regression_cross_validation(X_train, y_train, lambdas, k=5): best_lambda = None best_weights = None best_mse = float(\'inf\') kf = KFold(n_splits=k) for lam in lambdas: mse_sum = 0 for train_index, val_index in kf.split(X_train): X_t, X_v = X_train[train_index], X_train[val_index] y_t, y_v = y_train[train_index], y_train[val_index] # Add regularization term to the least squares solution I = np.eye(X_t.shape[1]) # ridge regression solution w = (XX + I)Xy w = np.linalg.inv(X_t.T @ X_t + lam * I) @ X_t.T @ y_t # Predict and calculate MSE on validation set y_pred_v = X_v @ w mse = np.mean((y_v - y_pred_v)**2) mse_sum += mse avg_mse = mse_sum / k if avg_mse < best_mse: best_mse = avg_mse best_lambda = lam best_weights = w return best_lambda, best_weights ```","solution":"import numpy as np from sklearn.model_selection import KFold def ridge_regression_cross_validation(X_train, y_train, lambdas, k=5): best_lambda = None best_weights = None best_mse = float(\'inf\') kf = KFold(n_splits=k) for lam in lambdas: mse_sum = 0 for train_index, val_index in kf.split(X_train): X_t, X_v = X_train[train_index], X_train[val_index] y_t, y_v = y_train[train_index], y_train[val_index] # Add regularization term to the least squares solution I = np.eye(X_t.shape[1]) # ridge regression solution w = (XX + I)Xy w = np.linalg.inv(X_t.T @ X_t + lam * I) @ X_t.T @ y_t # Predict and calculate MSE on validation set y_pred_v = X_v @ w mse = np.mean((y_v - y_pred_v)**2) mse_sum += mse avg_mse = mse_sum / k if avg_mse < best_mse: best_mse = avg_mse best_lambda = lam best_weights = w return best_lambda, best_weights"},{"question":"# Question: Hexadecimal to Binary Encoder Develop a function that converts a given hexadecimal string into its equivalent binary representation. Ensure that the binary results are padded to 4-bit groups. Function Signature ```python def hex_to_binary(hex_str: str) -> str: Convert a hexadecimal string to its binary equivalent. Parameters: hex_str (str): A string representing the hexadecimal value to be converted. Returns: str: The binary representation of the given hexadecimal value with each digit fitting in a 4-bit group. ``` # Input: * `hex_str`: A non-empty string consisting of valid hexadecimal characters (0-9, a-f, A-F). # Output: * Return a string representing the binary equivalent of the given hexadecimal input, in 4-bit padded groups. # Examples: ```python hex_to_binary(\'0\') -> \'0000\' hex_to_binary(\'A\') -> \'1010\' hex_to_binary(\'1f\') -> \'00011111\' hex_to_binary(\'10B\') -> \'000100001011\' hex_to_binary(\'bad\') -> \'101110101101\' ``` # Constraints: * The input string will always be a valid non-empty hexadecimal string. * Hexadecimal digits should be handled case-insensitively. * Ensure that the resulting binary string maintains a 4-bit boundary for each hex digit. # Performance Requirements: * The function should be efficient enough to handle large hexadecimal strings typically up to 10^6 characters in length. # Context: This function is part of a system that requires converting hexadecimal numbers to binary format for lower-level hardware processing. This conversion serves essential tasks in memory addressing, data encryption, and digital communication where binary representation is a must. **Note**: * Consider edge cases such as a single hex digit or very large strings within the provided constraints. * Ensure your function adheres to the formatting requirement, particularly the 4-bit grouping for binary digits.","solution":"def hex_to_binary(hex_str: str) -> str: Convert a hexadecimal string to its binary equivalent. Parameters: hex_str (str): A string representing the hexadecimal value to be converted. Returns: str: The binary representation of the given hexadecimal value with each digit fitting in a 4-bit group. hex_to_bin_map = { \'0\': \'0000\', \'1\': \'0001\', \'2\': \'0010\', \'3\': \'0011\', \'4\': \'0100\', \'5\': \'0101\', \'6\': \'0110\', \'7\': \'0111\', \'8\': \'1000\', \'9\': \'1001\', \'a\': \'1010\', \'b\': \'1011\', \'c\': \'1100\', \'d\': \'1101\', \'e\': \'1110\', \'f\': \'1111\', \'A\': \'1010\', \'B\': \'1011\', \'C\': \'1100\', \'D\': \'1101\', \'E\': \'1110\', \'F\': \'1111\' } binary_str = \'\'.join(hex_to_bin_map[c] for c in hex_str) return binary_str"},{"question":"# Problem Statement You are given a dictionary where keys are student names and values are lists of their test scores. You need to calculate the average score for each student and return a dictionary where each key is a student\'s name and its value is their average score rounded to two decimal places. # Function Signature ```python def calculate_student_averages(scores: dict) -> dict: pass ``` # Input * A dictionary where keys are strings (the student names) and values are lists of integers (the test scores). Each list will have at least one score and contain no more than 100 scores. No input lists will be empty. # Output * A dictionary where each key is a student\'s name and its value is their average score rounded to two decimal places. # Example ```python >>> calculate_student_averages({\'Alice\': [80, 90, 85], \'Bob\': [72, 88, 95], \'Charlie\': [100, 100, 94]}) {\'Alice\': 85.0, \'Bob\': 85.0, \'Charlie\': 98.0} >>> calculate_student_averages({\'David\': [60, 75, 82, 89], \'Eva\': [79, 88, 91]}) {\'David\': 76.5, \'Eva\': 86.0} ``` # Constraints * The input dictionary will always contain at least one student and each student will have at least one test score. * Test scores are integers between 0 and 100 inclusive. # Note To calculate the average, use the formula: [ text{average} = frac{sum text{scores}}{text{number of scores}} ] Round the result to two decimal places using the Python `round()` function.","solution":"def calculate_student_averages(scores: dict) -> dict: Calculate the average score of each student and return a dictionary where each key is a student\'s name and its value is their average score rounded to two decimal places. averages = {} for student, scores_list in scores.items(): average_score = round(sum(scores_list) / len(scores_list), 2) averages[student] = average_score return averages"},{"question":"# Problem Statement You are tasked with implementing a function that returns the number of subarrays with a sum equal to a given target integer `t` within a given list of integers. # Function Signature ```python def count_subarrays_with_sum(arr: list, t: int) -> int: Returns the number of subarrays that sum up to t within the given list arr. ``` # Input - `arr`: A list of integers (`n` where 1 <= n <= 100). - `t`: An integer (-1000 <= t <= 1000) representing the target sum. # Output - An integer representing the number of subarrays with a sum equal to `t`. # Constraints - The function should handle edge cases, including when `arr` is empty or when `t` is not achievable with any subarray. - Efficiency is key; aim for a solution that runs in linear time. - The elements in the list can be negative, zero, or positive, so ensure your approach accommodates this variety. # Example ```python >>> count_subarrays_with_sum([1, 2, 3], 3) 2 # [3], [1, 2] >>> count_subarrays_with_sum([1, -1, 1], 1) 3 # [1], [1, -1, 1], [-1, 1] >>> count_subarrays_with_sum([1, 2, 3], 6) 1 # [1, 2, 3] >>> count_subarrays_with_sum([-1, -1, 1], 0) 1 # [-1, 1] ``` # Performance Requirements - Aim for a solution with a time complexity of O(n) and space complexity of O(n). - The solution should be efficient enough to handle the upper limit constraint (n = 100) within a reasonable time frame. Good luck!","solution":"def count_subarrays_with_sum(arr, t): Returns the number of subarrays that sum up to t within the given list arr. count = 0 current_sum = 0 sum_dict = {0: 1} # Initialize with 0 sum having one count for edge cases. for num in arr: current_sum += num if current_sum - t in sum_dict: count += sum_dict[current_sum - t] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"# Coding Assessment Question Scenario You are tasked with implementing a feature in a recommendation system to suggest the top trending items. Trending items are determined based on the frequency of interactions (e.g., views, likes) within a given time frame. Your system should efficiently manage and identify the top `k` trending items from a stream of interactions. Task Implement a class `TrendingItems` that can process a stream of item interactions and return the top `k` trending items based on their frequency of interactions. Class Signature ```python class TrendingItems: def __init__(self, k: int): pass def add_interaction(self, item_id: int): pass def get_top_trending(self) -> List[int]: pass ``` Methods 1. `__init__(self, k: int)`: Initializes the object with the number of top trending items to track. 2. `add_interaction(self, item_id: int)`: Records an interaction with the specified item. 3. `get_top_trending(self) -> List[int]`: Returns a list of the top `k` trending items sorted by their frequency in descending order. In case of a tie in frequency, items with the smaller IDs come first. Input * `k (int)`: The number of top trending items to track. * `item_id (int)`: The ID of the item that is interacted with. Output * `get_top_trending` method returns a list of integers representing the IDs of the top `k` trending items. Constraints * The item IDs are non-negative integers. * The number of interactions can be very large. * The value of `k` is at least 1. Example ```python Example usage: ti = TrendingItems(3) ti.add_interaction(10) ti.add_interaction(20) ti.add_interaction(10) ti.add_interaction(30) ti.add_interaction(10) ti.add_interaction(20) # The top 3 trending items are [10, 20, 30] print(ti.get_top_trending()) # Output should be [10, 20, 30] ti.add_interaction(40) ti.add_interaction(40) ti.add_interaction(40) # The top 3 trending items are now [40, 10, 20] print(ti.get_top_trending()) # Output should be [40, 10, 20] ``` Notes * Emphasize efficiency given the potentially large number of interactions. * Ensure the implementation correctly handles varying frequencies and ties. * Consider space and time complexity when designing your solution.","solution":"from typing import List from collections import defaultdict, Counter class TrendingItems: def __init__(self, k: int): self.k = k self.item_count = Counter() def add_interaction(self, item_id: int): self.item_count[item_id] += 1 def get_top_trending(self) -> List[int]: # Sorting first by frequency (in descending order), then by item_id (in ascending order for ties) sorted_items = sorted(self.item_count.items(), key=lambda x: (-x[1], x[0])) return [item for item, _ in sorted_items[:self.k]]"},{"question":"# Prime Sum Pairs **Context**: You are developing a mathematical tool that performs computations with prime numbers. One of the features is to identify pairs of prime numbers that add up to a specific even number. This problem is based on a famous conjecture in number theory called the Goldbach conjecture, which asserts that every even integer greater than 2 is the sum of two prime numbers. **Task**: Implement the `prime_sum_pairs` function that finds all unique pairs of prime numbers whose sum equals a given even integer. # Function Signature: ```python def prime_sum_pairs(n: int) -> List[Tuple[int, int]]: n : an even integer greater than 2 returns: a list of tuples, where each tuple contains two prime numbers that sum up to n ``` # Constraints: 1. 4 <= n <= 10^6 2. The function should optimize for time complexity. 3. The pairs (p1, p2) and (p2, p1) are considered the same and should be returned once in the list. # Expected Input/Output: - **Input**: An even integer n greater than 2. - **Output**: A list of tuples, where each tuple consists of two prime numbers that add up to n. **Example**: ```python # Finds all unique pairs of prime numbers whose sum is 28 print(prime_sum_pairs(28)) # Expected output: [(5, 23), (11, 17)] # Finds all unique pairs of prime numbers whose sum is 10 print(prime_sum_pairs(10)) # Expected output: [(3, 7), (5, 5)] ``` # Additional Notes: - You may start by writing a helper function to determine if a number is prime. - Use an efficient algorithm to ensure that the computation is feasible for the higher end of the input constraint. - Make sure to handle the cases where there are multiple valid pairs. - Consider edge cases such as very small even numbers and ensure that no invalid pairs (e.g., using the same prime twice unless it\'s explicitly an allowed pair) are returned.","solution":"from typing import List, Tuple def sieve_of_eratosthenes(limit: int) -> List[bool]: Generate a list of booleans representing the primality of numbers from 0 to limit. True indicates that the number is prime. is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes. p = 2 while p * p <= limit: if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return is_prime def prime_sum_pairs(n: int) -> List[Tuple[int, int]]: Finds all unique pairs of prime numbers whose sum equals a given even integer n. is_prime = sieve_of_eratosthenes(n) pairs = [] for p1 in range(2, n // 2 + 1): p2 = n - p1 if is_prime[p1] and is_prime[p2]: pairs.append((p1, p2)) return pairs"},{"question":"# Problem Statement Scenario Alice has a collection of coding puzzles, each with a unique difficulty level represented by an integer. Bob wants to solve as many puzzles as he can from the collection, but he can only solve puzzles in increasing order of difficulty (i.e., he cannot solve a puzzle with a difficulty lower than one he has already solved). To help Bob maximize the number of puzzles he solves, Alice decides to filter out the puzzles such that the difficulty levels always increase. Your task is to write a function `max_increasing_puzzle_sequence` that takes a list of integers representing the difficulty levels of the puzzles and returns the length of the longest increasing subsequence of difficulty levels. Function Signature ```python def max_increasing_puzzle_sequence(puzzles: list[int]) -> int: pass ``` Inputs and Outputs * The function takes one parameter: * A list of integers, `puzzles`, where each integer represents the difficulty level of a puzzle. (1 leq text{len(puzzles)} leq 10^4) and each difficulty level is an integer within the range ([1, 10^6]). * The function returns: * An integer, representing the length of the longest increasing subsequence of difficulty levels that Bob can attempt in order. Example ```python assert max_increasing_puzzle_sequence([10, 5, 18, 7, 2, 9, 16]) == 4 assert max_increasing_puzzle_sequence([3, 10, 2, 1, 20]) == 3 assert max_increasing_puzzle_sequence([50, 3, 10, 7, 40, 80]) == 4 ``` Constraints 1. The list of difficulty levels must be processed to determine the longest increasing subsequence. 2. The function must handle large lists efficiently, with a length up to (10^4). # Performance Requirements * The function should have an efficient time complexity, ideally (O(n log n)) where (n) is the length of the puzzles list.","solution":"from bisect import bisect_left def max_increasing_puzzle_sequence(puzzles): Returns the length of the longest increasing subsequence of difficulty levels in puzzles. Args: puzzles (list of int): List of integers representing the difficulty levels of puzzles. Returns: int: Length of the longest increasing subsequence of difficulty levels. if not puzzles: return 0 lis = [] for difficulty in puzzles: pos = bisect_left(lis, difficulty) if pos == len(lis): lis.append(difficulty) else: lis[pos] = difficulty return len(lis)"},{"question":"# Context You are working on a data analysis project where you need to implement a class to handle operations on complex numbers. # Problem Statement Write a Python class `ComplexNumber` that supports the following functionalities: 1. **Initialization**: Should initialize a complex number with real and imaginary parts. 2. **Addition**: Implement addition of two complex numbers. 3. **Subtraction**: Implement subtraction of two complex numbers. 4. **Multiplication**: Implement multiplication of two complex numbers. 5. **Division**: Implement division of two complex numbers. 6. **Magnitude Calculation**: Implement a method to calculate the magnitude of a complex number. 7. **String Representation**: A method to return a string representation in a specific format. Additionally, implement a proper unit test suite to validate these functionalities. Ensure to cover edge cases, error handling, and numerical precision where applicable. # Implementation Details 1. **Initialization**: ```python class ComplexNumber: def __init__(self, real: float, imag: float) -> None: ... ``` 2. **Addition**: ```python def __add__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': ... ``` 3. **Subtraction**: ```python def __sub__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': ... ``` 4. **Multiplication**: ```python def __mul__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': ... ``` 5. **Division**: ```python def __truediv__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': ... ``` 6. **Magnitude Calculation**: ```python def magnitude(self) -> float: ... ``` 7. **String Representation**: ```python def __str__(self) -> str: ... ``` # Constraints - Ensure that all operations are defined between valid complex numbers. - Handle edge cases like division by zero appropriately. # Unit Tests Create a test class `TestComplexNumber` using `unittest` that validates all aspects of your implementation. Cover typical edge cases and error scenarios like division by zero. # Example ```python c1 = ComplexNumber(3, 4) c2 = ComplexNumber(1, 2) # Test Addition print(c1 + c2) # Should print a complex number with elements added. # Test Subtraction print(c1 - c2) # Should print a complex number with elements subtracted. # Test Multiplication print(c1 * c2) # Should print a complex number with elements multiplied. # Test Division print(c1 / c2) # Should print a complex number with elements divided. # Test Magnitude print(c1.magnitude()) # Should correctly compute and return the magnitude. # Test String Representation print(str(c1)) # Should return string in format \\"3 + 4i\\" ```","solution":"import math class ComplexNumber: def __init__(self, real: float, imag: float) -> None: self.real = real self.imag = imag def __add__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real + other.real, self.imag + other.imag) def __sub__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real - other.real, self.imag - other.imag) def __mul__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': real = self.real * other.real - self.imag * other.imag imag = self.real * other.imag + self.imag * other.real return ComplexNumber(real, imag) def __truediv__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': if other.real == 0 and other.imag == 0: raise ZeroDivisionError(\\"Cannot divide by zero-complex number\\") denom = other.real ** 2 + other.imag ** 2 real = (self.real * other.real + self.imag * other.imag) / denom imag = (self.imag * other.real - self.real * other.imag) / denom return ComplexNumber(real, imag) def magnitude(self) -> float: return math.sqrt(self.real ** 2 + self.imag ** 2) def __str__(self) -> str: return f\\"{self.real} + {self.imag}i\\""},{"question":"# Coding Assessment Question Objective: Write a function to identify and extract unique substrings of a specified length from a given string, ensuring all substrings are distinct. Description: You are given a string and an integer ( n ). Implement a function `extract_unique_substrings` that finds all unique substrings of length ( n ) within the given string. Return these substrings in a list. Input: - A string, ( s ), containing alphanumeric characters and/or spaces. - An integer, ( n ), specifying the length of substrings to extract. Output: - A list of all unique substrings of length ( n ) from the input string. Constraints: - 1  length of ( s )  1000 - 1  ( n )  length of ( s ) - Ensure that substrings do not overlap. Example: ```python input_str = \\"abcabc\\" n = 3 expected_output = [\\"abc\\", \\"bca\\", \\"cab\\"] ``` ```python input_str = \\"abcdefg\\" n = 2 expected_output = [\\"ab\\", \\"bc\\", \\"cd\\", \\"de\\", \\"ef\\", \\"fg\\"] ``` Function Signature: ```python def extract_unique_substrings(s: str, n: int) -> list: pass ``` Implementation Instructions: 1. Iterate through the string to extract substrings of the given length ( n ). 2. Ensure each substring is unique before adding it to the output list. 3. Consider edge cases such as ( n ) being greater than the length of ( s ) or string ( s ) containing special characters. 4. The function should be efficient in both time and space complexity.","solution":"def extract_unique_substrings(s: str, n: int) -> list: Returns all unique substrings of length n from the input string s. if n > len(s): return [] # No substrings possible if n is greater than string length unique_substrings = set() for i in range(len(s) - n + 1): substring = s[i:i + n] unique_substrings.add(substring) return list(unique_substrings)"},{"question":"# Context As an engineer, you are working on a system that handles URL shortening and redirection. One of the components of this system is generating a short unique identifier for each original URL, ensuring that the same URL always gets the same identifier and different URLs get different identifiers. # Task Implement a class `URLShortener` with the following methods: - `encode(long_url: str) -> str`: which generates a short unique identifier for the given `long_url`. - `decode(short_url: str) -> str`: which returns the original URL for a given `short_url`. # Constraints - The identical input `long_url` should always return the same `short_url`. - URLs consist of only characters in the set: `([\'A\'-\'Z\', \'a\'-\'z\', \'0\'-\'9\', \'-\', \'_\', \'.\', \'~\'])`. # Performance Requirements - The class should manage a large number of URLs efficiently. # Example ```python >>> url_shortener = URLShortener() >>> url_shortener.encode(\'https://www.example.com\') \'a1b2c3\' >>> url_shortener.decode(\'a1b2c3\') \'https://www.example.com\' >>> url_shortener.encode(\'https://www.openai.com\') \'k8d2f5\' >>> url_shortener.decode(\'k8d2f5\') \'https://www.openai.com\' ``` # Notes - One approach is to use hashing to generate the short URL, but ensure it avoids collisions. - Maintain a mapping from the short URL to the original long URL internally to handle decode requests properly. - Optional: You may think of implementing a mechanism to periodically check and clean expired or old mappings if there is a constraint on storage. However, this is not a requirement for this task.","solution":"import hashlib class URLShortener: def __init__(self): self.url_mapping = {} self.inverse_mapping = {} def encode(self, long_url: str) -> str: Generates a short unique identifier for the given long_url. if long_url in self.url_mapping: return self.url_mapping[long_url] short_url = self._generate_short_url(long_url) self.url_mapping[long_url] = short_url self.inverse_mapping[short_url] = long_url return short_url def decode(self, short_url: str) -> str: Returns the original URL for a given short_url. return self.inverse_mapping.get(short_url) def _generate_short_url(self, long_url: str) -> str: Use SHA256 hash of the URL and take the first 6 characters to create a short identifier. hasher = hashlib.sha256() hasher.update(long_url.encode(\'utf-8\')) short_hash = hasher.hexdigest()[:6] return short_hash"},{"question":"# Coding Assessment Question Context You have designed a data compression system that is highly efficient but sometimes generates duplicate entries. To ensure the system\'s output is optimized, you need to implement a function to remove consecutive duplicate entries from a list while maintaining the order of their first occurrence. Problem Write a function that removes consecutive duplicate entries from a list of strings. The function should return a new list that preserves the order of the first occurrence of each string. Specifications * **Function Signature**: `def remove_consecutive_duplicates(arr: list[str]) -> list[str]:` * **Input**: A list of strings `arr`. * **Output**: A new list of strings with consecutive duplicate entries removed. * **Constraints**: * The input list `arr` can have up to (10^6) strings. * Strings in the input list can contain any printable characters and have lengths of up to 100. Example ```python arr = [\\"apple\\", \\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"orange\\"] result = remove_consecutive_duplicates(arr) print(result) # Output: [\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"orange\\"] arr = [\\"cat\\", \\"cat\\", \\"cat\\", \\"dog\\", \\"dog\\", \\"mouse\\"] result = remove_consecutive_duplicates(arr) print(result) # Output: [\\"cat\\", \\"dog\\", \\"mouse\\"] arr = [] result = remove_consecutive_duplicates(arr) print(result) # Output: [] ``` Notes * This problem requires handling of sequences and maintaining order, which tests the ability to manage list operations efficiently. * Edge cases such as empty lists or lists with no consecutive duplicates should be carefully considered. * Focus on efficiency to handle the largest input constraint within a reasonable time frame.","solution":"def remove_consecutive_duplicates(arr: list[str]) -> list[str]: Returns a new list with consecutive duplicate entries removed. Parameters: arr (list): A list of strings. Returns: list: A new list with consecutive duplicates removed. if not arr: return [] result = [arr[0]] for char in arr[1:]: if char != result[-1]: result.append(char) return result"},{"question":"# Scenario: You are working on a data analysis project and need to implement a polynomial regression model. The model should be able to fit a polynomial of a specified degree to given data points and predict the output for new data points. # Task: Write a function that performs polynomial regression on a set of data points and predicts the output for a new set of input values. The function should use the least squares method to fit the polynomial. # Function Signature: ```python def polynomial_regression( x_train: np.ndarray, y_train: np.ndarray, x_new: np.ndarray, degree: int ) -> np.ndarray: pass ``` # Input: - `x_train`: A numpy ndarray of shape (n,) containing n floating-point numbers representing the input data points. - `y_train`: A numpy ndarray of shape (n,) containing n floating-point numbers representing the output data points corresponding to `x_train`. - `x_new`: A numpy ndarray of shape (m,) containing m floating-point numbers for which we need to predict the output. - `degree`: An integer representing the degree of the polynomial to be fitted. # Output: - Returns a numpy ndarray of shape (m,) where each element is the predicted output for the corresponding element in `x_new`. # Constraints: - Handle up to 10^5 data points efficiently. - Ensure the function can handle edge cases such as very small or large values in the input data. - The degree of the polynomial will be a non-negative integer less than the number of input data points. # Example: ```python >>> x_train = np.array([1, 2, 3, 4, 5]) >>> y_train = np.array([1.2, 1.9, 3.0, 4.1, 5.1]) >>> x_new = np.array([6, 7, 8]) >>> polynomial_regression(x_train, y_train, x_new, 2) array([ 6.2, 7.5, 8.8 ]) ``` # Notes: - Use numpy for efficient numerical computations. - Fit the polynomial using the least squares method and use it to predict the new values. - Focus on both accuracy and efficiency when implementing the function. - You may assume the input arrays are non-empty and valid.","solution":"import numpy as np def polynomial_regression(x_train: np.ndarray, y_train: np.ndarray, x_new: np.ndarray, degree: int) -> np.ndarray: Performs polynomial regression on the training data and predicts outputs for new inputs. Parameters: x_train (np.ndarray): Input data points for training (shape (n,)) y_train (np.ndarray): Output data points for training (shape (n,)) x_new (np.ndarray): New input values for which to predict the output (shape (m,)) degree (int): Degree of the polynomial to fit Returns: np.ndarray: Predicted output values for x_new (shape (m,)) # Create the Vandermonde matrix for the training data X = np.vander(x_train, degree + 1) # Compute the least-squares solution for the polynomial coefficients coeffs = np.linalg.lstsq(X, y_train, rcond=None)[0] # Create the Vandermonde matrix for the new input data X_new = np.vander(x_new, degree + 1) # Compute the predicted values using the polynomial coefficients y_new = X_new @ coeffs return y_new"},{"question":"# Coding Challenge: Implementing a Trie for Efficient Prefix Search Scenario: Imagine you are developing an autocomplete feature for a search engine. Users type part of a query, and you need to suggest complete queries that start with that prefix. This scenario can be solved using a Trie data structure, which is particularly well-suited for prefix-based search operations. Task: Implement a Trie with insert and search functionalities to assist in the autocomplete feature. You will need to insert a list of query strings into the Trie and then return all queries that start with a given prefix. Input: * A list of strings `queries` representing the database of query strings. * A string `prefix` representing the prefix to search for. Output: A list of strings that start with the given `prefix`, sorted lexicographically. Constraints: * The length of each query string and the prefix will be between (1) and (100). * There will be at most (10^5) queries. Example: Input: ``` queries = [\\"apple\\", \\"app\\", \\"application\\", \\"apt\\", \\"batman\\", \\"batch\\", \\"bat\\"] prefix = \\"ap\\" ``` Output: ``` [\\"app\\", \\"apple\\", \\"application\\", \\"apt\\"] ``` Implementation Details: - Define a class `Trie` with methods for inserting strings and searching for prefix matches. - Ensure your methods adhere to the provided input and output formats. - Use appropriate data structures and algorithms to ensure efficiency. ```python from typing import List, Dict class TrieNode: def __init__(self): self.children: Dict[str, TrieNode] = {} self.is_end_of_word: bool = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_prefix(self, prefix: str) -> List[str]: result = [] node = self.root for char in prefix: if char not in node.children: return result node = node.children[char] self._dfs(node, prefix, result) return sorted(result) def _dfs(self, node: TrieNode, prefix: str, result: List[str]) -> None: if node.is_end_of_word: result.append(prefix) for char, child_node in sorted(node.children.items()): self._dfs(child_node, prefix + char, result) def autocomplete(queries: List[str], prefix: str) -> List[str]: trie = Trie() for query in queries: trie.insert(query) return trie.search_prefix(prefix) # Example usage: if __name__ == \\"__main__\\": queries = [\\"apple\\", \\"app\\", \\"application\\", \\"apt\\", \\"batman\\", \\"batch\\", \\"bat\\"] prefix = \\"ap\\" print(autocomplete(queries, prefix)) ```","solution":"from typing import List, Dict class TrieNode: def __init__(self): self.children: Dict[str, TrieNode] = {} self.is_end_of_word: bool = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_prefix(self, prefix: str) -> List[str]: result = [] node = self.root for char in prefix: if char not in node.children: return result node = node.children[char] self._dfs(node, prefix, result) return sorted(result) def _dfs(self, node: TrieNode, prefix: str, result: List[str]) -> None: if node.is_end_of_word: result.append(prefix) for char, child_node in sorted(node.children.items()): self._dfs(child_node, prefix + char, result) def autocomplete(queries: List[str], prefix: str) -> List[str]: trie = Trie() for query in queries: trie.insert(query) return trie.search_prefix(prefix)"},{"question":"# Problem Statement You are to implement an algorithm to solve the 0/1 Knapsack Problem using dynamic programming. Write a function `knapsack` that determines the maximum value that can be obtained with a given weight limit, along with the selected items. # Input Format The function `knapsack` should accept the following parameters: ```python def knapsack(max_weight: int, weights: list, values: list) -> tuple[int, list]: # Implementation here ``` - `max_weight`: An integer representing the maximum weight capacity of the knapsack. - `weights`: A list of integers representing the weights of the items. - `values`: A list of integers representing the values of the items. # Output Format The function should return a tuple of: - An integer representing the maximum value that can be obtained. - A list of integers representing the indices of the items that comprise the maximum value in the knapsack. # Performance Requirements Your implementation should efficiently handle scenarios with up to 100 items. # Example ```python max_weight = 50 weights = [10, 20, 30] values = [60, 100, 120] maximum_value, selected_items = knapsack(max_weight, weights, values) print(maximum_value) # Output: 220 print(selected_items) # Output: [1, 2] ``` # Constraints - Each weight and value is a positive integer. - The number of items ranges from 1 to 100. - The maximum weight capacity of the knapsack is a positive integer up to 1000. # Task Implement the following steps to complete the assignment: 1. `initialize_dp_table`: Create and initialize the dynamic programming table. 2. `fill_dp_table`: Use dynamic programming to fill the table based on given weights and values. 3. `trace_selected_items`: Trace back through the DP table to determine which items were selected. 4. `knapsack`: Combine everything to compute the maximum value and the selected items indices. Ensure to handle edge cases and optimize performance within the given constraints.","solution":"def knapsack(max_weight, weights, values): n = len(weights) dp = [[0 for _ in range(max_weight + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(max_weight + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] maximum_value = dp[n][max_weight] w = max_weight selected_items = [] for i in range(n, 0, -1): if dp[i][w] != dp[i-1][w]: selected_items.append(i-1) w -= weights[i-1] selected_items.reverse() return (maximum_value, selected_items)"},{"question":"**Title**: Generate Random Passwords **Context**: Passwords are essential for safeguarding digital information. Given the security threats, it\'s crucial to generate strong, random passwords that comply with specific criteria. **Task**: Implement a function `generate_password(length: int, include_digits: bool, include_uppercase: bool, include_special: bool) -> str`. # Function: `generate_password` **Description**: Generate a random password of a specified length that may include digits, uppercase letters, and/or special characters based on the provided parameters. **Input**: - `length`: An integer representing the length of the password to be generated. Must be greater than or equal to 6. - `include_digits`: A boolean indicating whether the password should include digits. - `include_uppercase`: A boolean indicating whether the password should include uppercase letters. - `include_special`: A boolean indicating whether the password should include special characters (`@`, `#`, ``, `%`, `&`, `*`). **Output**: - A string representing the randomly generated password that meets the specified criteria. **Requirements and Constraints**: 1. The password must have a minimum length of 6. 2. If `include_digits` is True, the password must contain at least one digit. 3. If `include_uppercase` is True, the password must contain at least one uppercase letter. 4. If `include_special` is True, the password must contain at least one special character from the set (`@`, `#`, ``, `%`, `&`, `*`). 5. The generated password should be randomly formed every time the function is called, provided the same parameters. **Example Cases**: **Case 1**: ```python assert len(generate_password(6, True, True, False)) == 6 assert any(char.isdigit() for char in generate_password(6, True, False, False)) assert any(char.isupper() for char in generate_password(6, False, True, False)) assert not any(char.isdigit() for char in generate_password(6, False, False, True)) ``` **Case 2**: ```python password = generate_password(10, True, True, True) assert len(password) == 10 assert any(char.isdigit() for char in password) assert any(char.isupper() for char in password) assert any(char in \\"@#%&*\\" for char in password) ```","solution":"import random import string def generate_password(length: int, include_digits: bool, include_uppercase: bool, include_special: bool) -> str: Generates a random password with specified criteria. Parameters: length (int): Length of the password to be generated (minimum 6). include_digits (bool): Whether the password should include digits. include_uppercase (bool): Whether the password should include uppercase letters. include_special (bool): Whether the password should include special characters. Returns: str: The generated random password. if length < 6: raise ValueError(\\"Password length must be at least 6.\\") characters = string.ascii_lowercase if include_digits: characters += string.digits if include_uppercase: characters += string.ascii_uppercase if include_special: characters += \'@#%&*\' password = [random.choice(characters) for _ in range(length)] if include_digits: password[random.randint(0, length-1)] = random.choice(string.digits) if include_uppercase: password[random.randint(0, length-1)] = random.choice(string.ascii_uppercase) if include_special: password[random.randint(0, length-1)] = random.choice(\'@#%&*\') random.shuffle(password) return \'\'.join(password)"},{"question":"# Pathfinding in a Grid Maze Context Pathfinding algorithms are essential in robotics and AI, used for navigating agents through environments. One popular algorithm is A* (A-star), which combines features of uniform-cost search and pure heuristic search to efficiently find the shortest path from a start node to a goal node. In this task, you will implement the A* algorithm to find the shortest path through a grid-based maze. The grid is represented as a 2D list where `0` represents an open cell, and `1` represents an obstacle. The agent can move horizontally or vertically but not diagonally. The heuristic function to use for A* is the Manhattan distance. Task Implement the A* algorithm to navigate through a maze from a given start point to an end point. The function should return the path as a list of grid coordinates or an empty list if no path exists. Requirements 1. **Function Name**: `a_star_pathfinding` 2. **Inputs**: - `maze`: 2D list of integers representing the grid maze. - `start`: Tuple of two integers `(x, y)` representing the start position. - `goal`: Tuple of two integers `(x, y)` representing the goal position. 3. **Output**: - A list of tuples, each representing the grid coordinates of the path from start to goal, inclusive. - If there is no valid path, return an empty list. Constraints - The maze grid is guaranteed to have at least one valid path if `start` and `goal` are both on `0` cells. - The dimensions of the maze will be at most 100x100. - Start and goal positions will always be valid grid coordinates within the maze. Performance Requirements - Your solution should be optimized to handle the worst-case time complexity appropriately, ensuring efficient pathfinding. Example ```python def a_star_pathfinding(maze, start, goal): # Implementation of the A* algorithm # ... pass maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) path = a_star_pathfinding(maze, start, goal) print(path) # Expected Output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 4), (4, 4)] ```","solution":"import heapq def heuristic(a, b): Calculate the Manhattan distance between point a and point b. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def a_star_pathfinding(maze, start, goal): Implements the A* pathfinding algorithm to find the shortest path from start to goal in a grid maze. rows, cols = len(maze), len(maze[0]) open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: _, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: neighbor = (current[0] + dx, current[1] + dy) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and maze[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Task Description You need to implement a function to perform K-means clustering on a given dataset of 2D points. Your task involves generating clusters by assigning each point to the nearest cluster centroid, followed by updating the centroids based on the mean position of all points within a cluster. This process is repeated until the centroids no longer move significantly or a maximum number of iterations is reached. # Function to Implement `kmeans_clustering(points: List[Tuple[float, float]], k: int, max_iterations: int = 100, tolerance: float = 1e-4)` * **Inputs**: - `points` (List[Tuple[float, float]]): A list of tuples where each tuple represents the coordinates of a point in 2D space. - `k` (int): The number of desired clusters. - `max_iterations` (int): Maximum number of iterations the algorithm should perform. Default is 100. - `tolerance` (float): The threshold for centroid movement to determine convergence. Default is 1e-4. * **Output**: - Returns a tuple containing: - A list of centroids after clustering. - A dictionary mapping each centroid to the list of points assigned to it. # Constraints - Points are guaranteed to be unique and provided in the format: `[(x1, y1), (x2, y2), ...]` - It is guaranteed that `1 <= k <= len(points) <= 1000`. - The coordinates of the points are floating-point numbers. # Requirements 1. Implement the `kmeans_clustering` function that: - Randomly initializes `k` centroids from the input points. - Assigns each point to the nearest centroid. - Updates centroids based on the mean of the points assigned to them. - Repeats the process until centroids do not change significantly or the maximum number of iterations is reached. 2. Ensure the implementation is efficient and can handle edge cases such as points being equidistant from multiple centroids. # Example ```python # Example usage of the kmeans_clustering function points = [(1.0, 2.0), (2.0, 3.0), (3.0, 4.0), (5.0, 7.0), (6.0, 8.0)] k = 2 centroids, clusters = kmeans_clustering(points, k) print(f\\"Centroids: {centroids}\\") for centroid, assigned_points in clusters.items(): print(f\\"Cluster around centroid {centroid}: {assigned_points}\\") ``` # Notes * You may use any necessary libraries for random number generation and mathematical calculations. * Ensure your implementation adheres to the constraints and provides an optimal balance between performance and accuracy.","solution":"import random from typing import List, Tuple, Dict from collections import defaultdict def euclidean_distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float: return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5 def calculate_centroid(points: List[Tuple[float, float]]) -> Tuple[float, float]: x_coords = [p[0] for p in points] y_coords = [p[1] for p in points] centroid = (sum(x_coords) / len(points), sum(y_coords) / len(points)) return centroid def kmeans_clustering(points: List[Tuple[float, float]], k: int, max_iterations: int = 100, tolerance: float = 1e-4): # Initializing centroids randomly centroids = random.sample(points, k) for _ in range(max_iterations): clusters = defaultdict(list) # Assigning points to the nearest centroid for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] nearest_centroid = centroids[distances.index(min(distances))] clusters[nearest_centroid].append(point) # Updating centroids new_centroids = [] for centroid, cluster_points in clusters.items(): if cluster_points: new_centroid = calculate_centroid(cluster_points) new_centroids.append(new_centroid) else: new_centroids.append(centroid) # Checking for convergence centroid_shifts = [euclidean_distance(centroids[i], new_centroids[i]) for i in range(k)] if max(centroid_shifts) < tolerance: break centroids = new_centroids # Assigning points to final centroids final_clusters = defaultdict(list) for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] nearest_centroid = centroids[distances.index(min(distances))] final_clusters[nearest_centroid].append(point) return centroids, dict(final_clusters)"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with developing a feature for a text processing application that frequently needs to manipulate strings by inserting, removing, or replacing specific substrings. To optimize this feature, you decide to create a custom class that handles these operations efficiently. **Task**: Implement a `CustomString` class that allows insertion, removal, and replacement of substrings within an original string. Your implementation should ensure that these operations are performed efficiently, especially considering the length of the strings involved. **Class Signature**: ```python class CustomString: def __init__(self, initial_string: str): Initialize the CustomString with the given initial string. :param initial_string: str - The initial string to manipulate. def insert(self, index: int, substring: str) -> None: Insert a substring into the current string at the specified index. :param index: int - The position at which to insert the substring. :param substring: str - The substring to be inserted. def remove(self, substring: str) -> None: Remove the first occurrence of the specified substring. :param substring: str - The substring to be removed. def replace(self, old_substring: str, new_substring: str) -> None: Replace the first occurrence of an old substring with a new substring. :param old_substring: str - The substring to be replaced. :param new_substring: str - The substring to replace with. def get_string(self) -> str: Return the current state of the string. :return: str - The current string. ``` **Input**: - The `CustomString` class will be initialized with an initial string `initial_string` containing alphanumeric characters and special characters (0 <= length of initial_string <= 10^6). - The `insert` method will be called with an index `index` (0 <= index <= length of current string) and a `substring` (0 <= length of substring <= 10^6). - The `remove` method will be called with a `substring` (0 <= length of substring <= length of current string). - The `replace` method will be called with an `old_substring` and `new_substring` (0 <= length of old_substring, new_substring <= length of current string). **Output**: - The `get_string` method will return the current state of the string after all modifications. **Constraints**: - Ensure all methods handle cases where the specified substring does not exist or the index is out of bounds. - The class should maintain efficiency even for very large strings. **Example**: ```python cs = CustomString(\\"hello world\\") cs.insert(5, \\" beautiful\\") assert cs.get_string() == \\"hello beautiful world\\" cs.remove(\\"beautiful \\") assert cs.get_string() == \\"hello world\\" cs.replace(\\"world\\", \\"everyone\\") assert cs.get_string() == \\"hello everyone\\" ```","solution":"class CustomString: def __init__(self, initial_string: str): Initialize the CustomString with the given initial string. :param initial_string: str - The initial string to manipulate. self.string = initial_string def insert(self, index: int, substring: str) -> None: Insert a substring into the current string at the specified index. :param index: int - The position at which to insert the substring. :param substring: str - The substring to be inserted. if 0 <= index <= len(self.string): self.string = self.string[:index] + substring + self.string[index:] def remove(self, substring: str) -> None: Remove the first occurrence of the specified substring. :param substring: str - The substring to be removed. index = self.string.find(substring) if index != -1: self.string = self.string[:index] + self.string[index+len(substring):] def replace(self, old_substring: str, new_substring: str) -> None: Replace the first occurrence of an old substring with a new substring. :param old_substring: str - The substring to be replaced. :param new_substring: str - The substring to replace with. self.string = self.string.replace(old_substring, new_substring, 1) def get_string(self) -> str: Return the current state of the string. :return: str - The current string. return self.string"},{"question":"# Coding Challenge: Palindrome Number Checker with Extensible Criteria Objective Create a function to check if a given number is a palindrome. Additionally, implement extensible criteria checks such that the number needs to satisfy additional conditions, such as being even or a multiple of a certain number. Generate and handle random numbers for testing, and validate the additional criteria are met. Function Signatures 1. **Palindrome Check**: ```python def is_palindrome(number: int) -> bool: Checks if a given number is a palindrome. Parameters: number: int - The number to be checked. Returns: bool - True if the number is a palindrome, False otherwise. ``` 2. **Random Number Generation**: ```python def generate_random_number(range_start: int, range_end: int) -> int: Generates a random number within the given range. Parameters: range_start: int - The start of the range (inclusive). range_end: int - The end of the range (inclusive). Returns: int - A random integer within the given range. ``` 3. **Extensible Criteria Check**: ```python def check_criteria(number: int, criteria: list) -> bool: Checks if the number meets specific criteria. Parameters: number: int - The number to be checked. criteria: list - A list of functions representing the criteria. Returns: bool - True if the number meets all criteria, False otherwise. ``` Constraints * **Input Format**: * **is_palindrome**: `number` as an integer. * **generate_random_number**: `range_start` and `range_end` as integers. * **check_criteria**: `number` as an integer, `criteria` as a list of functions. * **Output Format**: * **is_palindrome**: Boolean indicating if the number is a palindrome. * **generate_random_number**: A single random integer. * **check_criteria**: Boolean indicating if the number meets all criteria. # Example ``` python >>> is_palindrome(121) True >>> is_palindrome(123) False >>> generate_random_number(100, 200) 145 >>> def is_even(number): ... return number % 2 == 0 >>> def is_multiple_of_five(number): ... return number % 5 == 0 >>> check_criteria(145, [is_even, is_palindrome]) False >>> check_criteria(145, [is_multiple_of_five, is_palindrome]) True ``` Additional Notes * Ensure all functions have proper docstrings and error-handling capabilities. For instance, `generate_random_number` should handle invalid input ranges. * Include tests for various edge cases and combinations of criteria in the main implementation.","solution":"def is_palindrome(number: int) -> bool: Checks if a given number is a palindrome. Parameters: number: int - The number to be checked. Returns: bool - True if the number is a palindrome, False otherwise. str_number = str(number) return str_number == str_number[::-1] import random def generate_random_number(range_start: int, range_end: int) -> int: Generates a random number within the given range. Parameters: range_start: int - The start of the range (inclusive). range_end: int - The end of the range (inclusive). Returns: int - A random integer within the given range. if range_start > range_end: raise ValueError(\\"range_start must be less than or equal to range_end\\") return random.randint(range_start, range_end) def check_criteria(number: int, criteria: list) -> bool: Checks if the number meets specific criteria. Parameters: number: int - The number to be checked. criteria: list - A list of functions representing the criteria. Returns: bool - True if the number meets all criteria, False otherwise. return all(criterion(number) for criterion in criteria)"},{"question":"# Problem Statement You are tasked with designing and implementing a function `convert_to_float(integer_list: List[int]) -> List[float]` that converts a list of integers into their respective floating-point representations. # Function Signature ```python from typing import List def convert_to_float(integer_list: List[int]) -> List[float]: pass ``` # Input * `integer_list`: A list of integers (e.g., `[1, 2, 3, 4, 5]`). # Output * A list of floating-point numbers where each floating-point number is the float equivalent of the corresponding integer in the input list (e.g., `[1.0, 2.0, 3.0, 4.0, 5.0]`). # Constraints * The list `integer_list` will contain between 1 and 1,000 elements. * Each element of the list will be an integer between `-10^6` and `10^6`. # Example ```python assert convert_to_float([1, 2, 3, 4, 5]) == [1.0, 2.0, 3.0, 4.0, 5.0] assert convert_to_float([-1, 0, 999, -1000000, 1000000]) == [-1.0, 0.0, 999.0, -1000000.0, 1000000.0] ``` # Notes * Consider edge cases such as when the list contains only negative numbers, zero, or a mix of both positive and negative numbers. * The purpose of this task is to ensure that you understand the process of type conversion in Python. efN","solution":"from typing import List def convert_to_float(integer_list: List[int]) -> List[float]: Converts a list of integers to a list of floating-point numbers. Args: integer_list (List[int]): A list of integers. Returns: List[float]: A list of floating-point numbers. return [float(integer) for integer in integer_list]"},{"question":"# Scenario: You are tasked with developing a module for a home automation system that controls various appliances based on a schedule. One such feature is the ability to determine if the current time is within any given list of scheduled time intervals when certain appliances should be activated. # Function Specification **Function name**: `is_within_schedule` **Input**: - `current_time` (str): A string representing the current time in \\"HH:MM\\" 24-hour format. - `schedules` (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings, representing the start and end times of an active interval in \\"HH:MM\\" 24-hour format. **Output**: - (bool): Returns `True` if the current time falls within any of the given time intervals, otherwise `False`. **Constraints**: - The time strings will be in \\"HH:MM\\" 24-hour format. - The `schedules` list will have at least one and at most 100 entries. - Each time in the schedule is valid and properly formatted. **Examples**: ```python >>> is_within_schedule(\\"14:30\\", [(\\"08:00\\", \\"12:00\\"), (\\"14:00\\", \\"18:00\\")]) True >>> is_within_schedule(\\"13:00\\", [(\\"08:00\\", \\"12:00\\"), (\\"14:00\\", \\"18:00\\")]) False >>> is_within_schedule(\\"22:00\\", [(\\"20:00\\", \\"23:59\\"), (\\"00:00\\", \\"06:00\\")]) True ``` # Task: Complete the implementation of the `is_within_schedule` function to correctly determine if the current time falls within any of the provided active intervals.","solution":"from typing import List, Tuple def is_within_schedule(current_time: str, schedules: List[Tuple[str, str]]) -> bool: current_hour, current_minute = map(int, current_time.split(\\":\\")) current_minutes_total = current_hour * 60 + current_minute for (start_time, end_time) in schedules: start_hour, start_minute = map(int, start_time.split(\\":\\")) start_minutes_total = start_hour * 60 + start_minute end_hour, end_minute = map(int, end_time.split(\\":\\")) end_minutes_total = end_hour * 60 + end_minute if start_minutes_total <= current_minutes_total <= end_minutes_total: return True return False"},{"question":"# Scenario You are developing a software module to efficiently manage a car fleet for a rental company. As part of this module, you need to track and allocate cars based on their availability and rental status. Implement a class-based solution in Python to handle these tasks effectively. # Task Write a class `CarFleet` to manage the fleet of cars and a function `process_requests(car_fleet: CarFleet, requests: list[dict]) -> dict` to process rental and return requests. The class `CarFleet` should have the following functionalities: - Allow adding new cars with a unique ID. - Track the status of each car (available or rented). - Rent out a car if it\'s available. - Return a car to the fleet. The function `process_requests` should: - Process each request from a list of rental requests. - Update the car fleet accordingly. - Return a dictionary summarizing the status of each car after processing the requests. # Input - `CarFleet` class with methods to manage cars. - `requests`: A list of dictionaries, each containing: - `type`: A string, either `\\"rent\\"` or `\\"return\\"`, indicating the request type. - `car_id`: An integer representing the car ID involved in the request. # Output - A dictionary with car IDs as keys and their status (`\\"available\\"` or `\\"rented\\"`) as values. # Constraints - Car IDs are unique integers starting from 1. - A car cannot be rented if it is already rented out. - A car cannot be returned if it is not currently rented. - The request list will have up to 1000 requests. # Example ```python # Define the class CarFleet and the function process_requests # (actual implementation will be done by the candidate) car_fleet = CarFleet() car_fleet.add_car(1) car_fleet.add_car(2) car_fleet.add_car(3) requests = [ {\\"type\\": \\"rent\\", \\"car_id\\": 1}, {\\"type\\": \\"rent\\", \\"car_id\\": 2}, {\\"type\\": \\"return\\", \\"car_id\\": 1}, {\\"type\\": \\"rent\\", \\"car_id\\": 1}, {\\"type\\": \\"rent\\", \\"car_id\\": 3}, ] # Expected output: # {1: \\"rented\\", 2: \\"rented\\", 3: \\"rented\\"} print(process_requests(car_fleet, requests)) ``` Implement the `CarFleet` class and the `process_requests` function: ```python class CarFleet: def __init__(self): self.cars = {} def add_car(self, car_id: int): if car_id not in self.cars: self.cars[car_id] = \\"available\\" def rent_car(self, car_id: int): if self.cars.get(car_id) == \\"available\\": self.cars[car_id] = \\"rented\\" def return_car(self, car_id: int): if self.cars.get(car_id) == \\"rented\\": self.cars[car_id] = \\"available\\" def get_status(self): return self.cars def process_requests(car_fleet: CarFleet, requests: list[dict]) -> dict: for request in requests: car_id = request[\\"car_id\\"] if request[\\"type\\"] == \\"rent\\": car_fleet.rent_car(car_id) elif request[\\"type\\"] == \\"return\\": car_fleet.return_car(car_id) return car_fleet.get_status() ```","solution":"class CarFleet: def __init__(self): self.cars = {} def add_car(self, car_id: int): if car_id not in self.cars: self.cars[car_id] = \\"available\\" def rent_car(self, car_id: int): if self.cars.get(car_id) == \\"available\\": self.cars[car_id] = \\"rented\\" def return_car(self, car_id: int): if self.cars.get(car_id) == \\"rented\\": self.cars[car_id] = \\"available\\" def get_status(self): return self.cars def process_requests(car_fleet: CarFleet, requests: list[dict]) -> dict: for request in requests: car_id = request[\\"car_id\\"] if request[\\"type\\"] == \\"rent\\": car_fleet.rent_car(car_id) elif request[\\"type\\"] == \\"return\\": car_fleet.return_car(car_id) return car_fleet.get_status()"},{"question":"# Least Prime Factor of a Number **Context**: In number theory, the least prime factor (LPF) of a number `n` greater than 1 is the smallest prime number that divides `n`. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Given an integer `n`, your task is to find the least prime factor of `n`. If `n` is less than 2, return 0 as there are no prime factors. **Task**: Write a function `least_prime_factor(n: int) -> int` that returns the least prime factor of `n`. **Function Signature**: ```python def least_prime_factor(n: int) -> int: pass ``` **Expected Output**: The function should return an integer representing the least prime factor of `n`. **Constraints**: - The given integer `n` will be in the range `[-1000, 1000]`. - If `n` is less than 2 (including negative numbers and zero), the function should return 0. **Example**: ```python print(least_prime_factor(15)) # Expected Output: 3 print(least_prime_factor(7)) # Expected Output: 7 print(least_prime_factor(1)) # Expected Output: 0 print(least_prime_factor(0)) # Expected Output: 0 print(least_prime_factor(-10)) # Expected Output: 0 ``` **Additional Requirements**: - Ensure your implementation is efficient. - Handle all edge cases such as negative numbers, zero, and one. **Hints**: - Remember the definition of prime numbers. - Use a loop or a similar construct to find the smallest divisor starting from 2 up to the square root of `n`.","solution":"def least_prime_factor(n: int) -> int: Returns the least prime factor of a positive integer n, or 0 if n is less than 2. if n < 2: return 0 # Check for smallest prime factor starting from 2 for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return i # If no factors found, n itself is prime return n"},{"question":"# Scenario In the realm of text-based data processing, computing the frequency of words is often a fundamental task. To enhance this process, the concept of stop wordscommon words that provide little value in text analysiscan be excluded from the frequency computation. **Your Task**: Implement a function that reads a block of text, processes it to exclude predefined stop words, and computes the frequency of the remaining words. The function should then print the words and their corresponding counts in descending order of frequency. # Input Format You will be given: 1. A string `text` representing the block of text to be processed. 2. A list of strings `stop_words` representing the words to be excluded from the frequency computation. # Output Format Your program should print: 1. The words and their respective counts in descending order of frequency. If two words have the same frequency, they should be ordered lexicographically. # Constraints 1. 1 <= len(text), len(stop_words) <= 10^6 2. The text consists of words separated by spaces and may include punctuation. 3. Words are case-insensitive (e.g., \\"Word\\" and \\"word\\" should be considered the same). 4. Punctuation marks should be excluded from words. # Example ```python text = \\"This is a sample text. This text is a simple example of text processing with stop words.\\" stop_words = [\\"is\\", \\"a\\", \\"of\\", \\"with\\"] ``` Expected output: ``` text: 3 this: 2 example: 1 processing: 1 sample: 1 simple: 1 stop: 1 words: 1 ``` # Function Signature ```python def word_frequency(text: str, stop_words: List[str]) -> None: # your code here ``` # Notes * Ensure your code is optimal and can handle large inputs efficiently. * Pay attention to handling different cases (e.g., different punctuations, mixed capitalizations). * Words should be treated case-insensitively but displayed in their original form in the output.","solution":"import re from collections import Counter from typing import List def word_frequency(text: str, stop_words: List[str]) -> None: # Normalize text to lowercase and remove punctuation text = text.lower() text = re.sub(r\'[^ws]\', \'\', text) # Split text into words words = text.split() # Filter out stop words stop_words_set = set(stop_words) filtered_words = [word for word in words if word not in stop_words_set] # Count word frequencies word_counts = Counter(filtered_words) # Sort words by frequency and then lexicographically sorted_word_counts = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Print the results for word, count in sorted_word_counts: print(f\\"{word}: {count}\\")"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase English letters and a dictionary `valid_substrings` containing valid substrings of `s`. Your task is to implement a function that returns the minimum number of segments needed to partition the string `s` such that every segment is a valid substring present in the `valid_substrings`. # Function Signature ```python def min_valid_partition(s: str, valid_substrings: set) -> int: pass ``` # Inputs - `s (str)`: A string consisting of lowercase English letters. - `valid_substrings (set)`: A set of strings representing valid substrings. # Outputs - `result (int)`: The minimum number of segments needed to partition the string such that every segment is present in `valid_substrings`. If it is not possible to partition `s` this way, return -1. # Constraints 1. (1 leq text{len}(s) leq 1000) 2. (1 leq text{len}(valid_substrings) leq 10^5) 3. Each substring in `valid_substrings` has a length between 1 and 100. # Examples ```python # Example 1 s = \\"applepenapple\\" valid_substrings = {\\"apple\\", \\"pen\\"} print(min_valid_partition(s, valid_substrings)) # Output: 3 # Explanation: The string can be partitioned as [\\"apple\\", \\"pen\\", \\"apple\\"]. # Example 2 s = \\"catsandog\\" valid_substrings = {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"} print(min_valid_partition(s, valid_substrings)) # Output: -1 # Explanation: There is no valid partitioning for the string. # Example 3 s = \\"leetcode\\" valid_substrings = {\\"leet\\", \\"code\\"} print(min_valid_partition(s, valid_substrings)) # Output: 2 # Explanation: The string can be partitioned as [\\"leet\\", \\"code\\"]. ``` # Notes - Ensure your solution handles edge cases where the string `s` is difficult to partition or not possible to partition. - The function should be efficiently implemented to handle large inputs within the given constraints. - This problem can be approached using dynamic programming or memoization to find the minimum partitions realistically. With this problem, you need to ensure proper validation and correct partitioning to solve it optimally within the provided constraints.","solution":"def min_valid_partition(s: str, valid_substrings: set) -> int: n = len(s) dp = [float(\'inf\')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for j in range(i): if s[j:i] in valid_substrings: dp[i] = min(dp[i], dp[j] + 1) return dp[n] if dp[n] != float(\'inf\') else -1"},{"question":"# Question: Majority Element Finder **Context** A majority element in an array of size `n` is an element that appears more than n/2 times (where x is the floor function, indicating the greatest integer less than or equal to x). For example: - In the array `[3, 3, 4, 2, 4, 4, 2, 4, 4]`, the majority element is `4` because it appears 5 times which is more than 9/2 = 4. - In the array `[3, 3, 4, 2, 4, 4, 2, 4]`, there is no majority element because no element appears more than 8/2 = 4 times. **Task** Write a function `find_majority_element(nums: List[int]) -> int` that finds the majority element in a list of integers. If no majority element exists, return `-1`. **Input** - `nums` is a list of integers (1 <= len(nums) <= 10^5, -10^9 <= nums[i] <= 10^9). **Output** - Return the majority element as an integer, or `-1` if no majority element exists. **Constraints** - You can assume that the input list will always have integers. **Examples** ```python >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) -1 >>> find_majority_element([1, 1, 1, 1, 2, 3, 4, 5, 6]) 1 ``` **Notes** - Use the above examples to test correctness. - Consider the performance implications for lists of the maximum length. - Think through edge cases within the input constraints. Write your function below: ```python def find_majority_element(nums: List[int]) -> int: # Your implementation here ```","solution":"from typing import List def find_majority_element(nums: List[int]) -> int: Returns the majority element if it exists, otherwise returns -1. A majority element is an element that appears more than floor(n/2) times. n = len(nums) count = {} majority_count = n // 2 for num in nums: if num in count: count[num] += 1 else: count[num] = 1 if count[num] > majority_count: return num return -1"},{"question":"**Context**: Binary search is a fundamental algorithm that efficiently locates a target value within a sorted list. Its efficiency reduces the time complexity to O(log n), significantly faster than a linear search, which operates in O(n). # Problem Statement Implement a binary search algorithm to find the first and last occurrence of a target value in a sorted list of integers. This is useful for range-related queries where repeated elements are present. # Requirements * **Function Name**: `find_first_and_last` * **Input**: - A sorted list of integers `collection`. - An integer `target` to search for. * **Output**: A tuple of integers representing the indices of the first and last occurrence of the target. If the target is not found, return `(-1, -1)`. # Constraints - Do not use built-in search functions. - Ensure the implementation accounts for the list being pre-sorted in ascending order. # Performance - The solution should run in O(log n) time complexity. - Maintain O(1) additional space complexity. # Example ```python def find_first_and_last(collection: list, target: int) -> tuple: # Your code here # Examples: print(find_first_and_last([1, 2, 2, 2, 3, 4, 5], 2)) # Output: (1, 3) print(find_first_and_last([1, 2, 3, 4, 5], 6)) # Output: (-1, -1) print(find_first_and_last([5, 7, 7, 8, 8, 10], 8)) # Output: (3, 4) print(find_first_and_last([], 3)) # Output: (-1, -1) ``` # Special Considerations - Handle edge cases such as an empty list, a list with no target occurrence, and a list where all elements are the same as the target. - Ensure your function returns in logarithmic time even if the target occurs multiple times. # Testing Develop a suite of unit tests to verify the correctness of the function across a variety of scenarios including edge cases, worst-case scenarios with large lists, and typical use cases.","solution":"def find_first_and_last(collection, target): Finds the first and last occurrence of the target in a sorted list. Parameters: collection (list): A sorted list of integers. target (int): The target value to find in the collection. Returns: tuple: A tuple containing the indices of the first and last occurrence of the target. If the target is not found, returns (-1, -1). def binary_search_left(collection, target): left, right = 0, len(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] < target: left = mid + 1 else: right = mid - 1 return left def binary_search_right(collection, target): left, right = 0, len(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] <= target: left = mid + 1 else: right = mid - 1 return right first = binary_search_left(collection, target) last = binary_search_right(collection, target) if first <= last and first < len(collection) and collection[first] == target: return first, last else: return -1, -1"},{"question":"# Context Sorting linked lists is a common problem in data structures and algorithms that tests understanding of both linked lists and sorting algorithms. One of the benefits of merge sort is that it can be adapted for linked lists in a way that leverages the linked structure for more efficient sorting. # Problem Statement Implement merge sort to sort a singly linked list of integers in ascending order. You must define a class `ListNode` for the linked list nodes, and a class `Solution` containing the method `mergeSort` that executes the sorting. # Requirements 1. **ListNode class with attributes**: - `val` (an integer, the value of the node) - `next` (the reference to the next node in the list) 2. **Solution class with method**: - `mergeSort(head: ListNode) -> ListNode`: Sorts the linked list starting from the `head` node and returns the head of the sorted list. # Input and Output Formats * **Input**: Your `mergeSort` method will take a single parameter, `head`, which is the head of the linked list to be sorted. Each ListNode contains an integer and a pointer to the next node. * **Output**: The output will be the head of the sorted linked list. # Constraints * The input linked list can be empty or have up to (10^5) nodes. * Each node contains an integer value. # Performance Considerations * Ensure that your solution operates in (O(n log n)) time complexity, where (n) is the number of nodes in the linked list. # Example ```python # Example usage (not necessary to include in implementation): list_nodes = [4, 2, 1, 3] head = ListNode(4) head.next = ListNode(2) head.next.next = ListNode(1) head.next.next.next = ListNode(3) solution = Solution() sorted_head = solution.mergeSort(head) result = [] node = sorted_head while node: result.append(node.val) node = node.next assert result == [1, 2, 3, 4] ``` # Edge Cases to Consider * An empty linked list (i.e., `head` is `None`). * A linked list with one node. * A linked list with two nodes. * A linked list that is already sorted. * A linked list with duplicate values. Implement the classes: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def mergeSort(self, head: ListNode) -> ListNode: if not head or not head.next: return head def getMiddle(node): slow, fast = node, node.next while fast and fast.next: slow = slow.next fast = fast.next.next return slow def merge(left, right): dummy = ListNode() tail = dummy while left and right: if left.val < right.val: tail.next = left left = left.next else: tail.next = right right = right.next tail = tail.next tail.next = left if left else right return dummy.next middle = getMiddle(head) nextToMiddle = middle.next middle.next = None left = self.mergeSort(head) right = self.mergeSort(nextToMiddle) return merge(left, right) ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def mergeSort(self, head: ListNode) -> ListNode: if not head or not head.next: return head def getMiddle(node): slow, fast = node, node.next while fast and fast.next: slow = slow.next fast = fast.next.next return slow def merge(left, right): dummy = ListNode() tail = dummy while left and right: if left.val <= right.val: tail.next = left left = left.next else: tail.next = right right = right.next tail = tail.next tail.next = left if left else right return dummy.next middle = getMiddle(head) nextToMiddle = middle.next middle.next = None left = self.mergeSort(head) right = self.mergeSort(nextToMiddle) return merge(left, right)"},{"question":"**Graph Traversal Challenge** # Problem Statement Given an undirected graph represented by a list of edges, write a function to find the **longest path** in the graph. The longest path is defined as the path that involves the maximum number of edges between any two nodes, where no node is visited more than once. The graph is given in the form of a list of edges, where each edge is represented as a tuple `(u, v)` indicating an edge between nodes `u` and `v`. Write a function `longest_path(edges: List[Tuple[int, int]]) -> List[int]` that returns the nodes in the longest path found in the graph. If multiple paths of the same length exist, return any one of them. # Input Format - `edges` (List[Tuple[int, int]]): A list of tuples representing the edges of the undirected graph. Each tuple `(u, v)` represents an edge between nodes `u` and `v`. (0  u, v  10^4) # Output Format - Return `path` (List[int]): A list of nodes representing the longest path in the graph. The path should start from one endpoint and end at the other endpoint of the longest path. # Constraints - The graph is connected and may have cycles. - The graph can have one or more longest paths of the same length. - Handle graphs with up to 10^4 nodes and edges. # Example ```python def longest_path(edges: List[Tuple[int, int]]) -> List[int]: # Your implementation here pass # Example usage: edges = [ (0, 1), (0, 2), (1, 3), (1, 4), (4, 5), (5, 6) ] print(longest_path(edges)) # Example output: [2,0,1,4,5,6] or any other valid longest path edges = [ (0, 1), (1, 2), (2, 3), (3, 4), (0, 5), (5, 6) ] print(longest_path(edges)) # Example output: [4,3,2,1,0,5,6] or any other valid longest path edges = [ (1, 2) ] print(longest_path(edges)) # Output: [1, 2] ``` # Hints 1. Use Depth-First Search (DFS) twice to find the longest path: - First DFS to find the farthest node from an arbitrary starting node. - Second DFS starting from the farthest node found in the first step to find the longest path in the graph. 2. Keep track of visited nodes to avoid cycles and ensure each node is visited only once during each DFS traversal.","solution":"from typing import List, Tuple from collections import defaultdict def longest_path(edges: List[Tuple[int, int]]) -> List[int]: # Convert edges to an adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) def dfs(node, visited): stack = [(node, [node])] longest = [] while stack: current_node, path = stack.pop() if len(path) > len(longest): longest = path for neighbor in adj_list[current_node]: if neighbor not in visited: visited.add(neighbor) stack.append((neighbor, path + [neighbor])) return longest # First DFS to find one farthest node from the starting node start_node = edges[0][0] visited = set([start_node]) farthest_path_from_start = dfs(start_node, visited) farthest_node = farthest_path_from_start[-1] # Second DFS to find the longest path from the farthest node found visited = set([farthest_node]) longest_path = dfs(farthest_node, visited) return longest_path"},{"question":"Context In data science, normalization is a common preprocessing step which is used to scale numerical features to fall within a specific range, typically 0 to 1. Min-max normalization is one such technique that rescales the values based on the formula: [ text{Normalized Value} = frac{text{Value} - text{Min Value}}{text{Max Value} - text{Min Value}} ] Problem You are given a vector of numeric values, and you need to implement the min-max normalization function as described: **Input**: - A vector of numeric values (integers or floats). For example, it could be a list or a numpy array. **Output**: - An array of the same size, where each element has been scaled to fall within the range [0,1]. **Function Signature**: ```python import numpy as np def min_max_normalize(vector: np.ndarray) -> np.ndarray: # your code here ``` # Constraints: 1. The input vector can be empty. 2. If all values in the vector are the same, return an array of zeros. 3. The input vector can be very large, ensure your solution is efficient. 4. You may use NumPy for this task. # Example: ```python >>> vector = np.array([1, 3, 2, 5, 4]) >>> min_max_normalize(vector) array([0. , 0.5 , 0.25, 1. , 0.75]) ``` Implement the `min_max_normalize` function to return the expected output.","solution":"import numpy as np def min_max_normalize(vector: np.ndarray) -> np.ndarray: Apply min-max normalization to the input vector of numeric values. Returns a numpy array with values normalized to the range [0, 1]. Parameters: vector (np.ndarray): Array of numeric values. Returns: np.ndarray: Normalized array with values in range [0, 1]. if len(vector) == 0: return np.array([]) min_val = np.min(vector) max_val = np.max(vector) if min_val == max_val: return np.zeros(vector.shape) normalized_vector = (vector - min_val) / (max_val - min_val) return normalized_vector"},{"question":"# Coding Assessment Question Write a function to sort a list of tuples based on the second element in each tuple. If two tuples have the same second element, they should be ordered based on their first element. Implement the function to handle edge cases such as an empty list or invalid inputs. Function Signature: ```python def sort_tuples_by_second_element(tuples: list[tuple]) -> list[tuple]: ``` # Input: - A list `tuples` containing tuples, where each tuple has exactly two elements (both integers). # Output: - A list of tuples sorted first by the second element of each tuple, and then by the first element if there is a tie. # Constraints: - All tuples in the input list will have exactly two integers. - The input list may be empty. - The input list and its elements are always provided. # Example: ```python >>> sort_tuples_by_second_element([(3, 4), (1, 2), (5, 2), (2, 3)]) [(1, 2), (5, 2), (2, 3), (3, 4)] >>> sort_tuples_by_second_element([(1, 2), (3, 2), (1, 1), (2, 1)]) [(1, 1), (2, 1), (1, 2), (3, 2)] >>> sort_tuples_by_second_element([]) [] ``` Detailed Explanation: - For the list [(3, 4), (1, 2), (5, 2), (2, 3)], sorting by the second element gives [(1, 2), (5, 2), (2, 3), (3, 4)]. Since (1, 2) and (5, 2) share the same second element, they are ordered by their first element. - For the list [(1, 2), (3, 2), (1, 1), (2, 1)], sorting by the second element gives [(1, 1), (2, 1), (1, 2), (3, 2)]. The tuples with the same second element (1, 1) and (2, 1) are ordered by their first element. - An empty list as input should return an empty list. Ensure that your function handles edge cases and invalid inputs appropriately, raising a `ValueError` where necessary.","solution":"def sort_tuples_by_second_element(tuples): Sort a list of tuples based on the second element in each tuple. If two tuples have the same second element, they are then ordered by the first element. Args: tuples (list of tuples): A list of tuples each containing exactly two integers. Returns: list of tuples: Sorted list of tuples. Raises: ValueError: If the input is not a list of tuples with exactly two integers each. if not isinstance(tuples, list): raise ValueError(\\"Input should be a list\\") for t in tuples: if not isinstance(t, tuple) or len(t) != 2 or not all(isinstance(i, int) for i in t): raise ValueError(\\"All elements of the input list should be tuples with exactly two integers each\\") return sorted(tuples, key=lambda x: (x[1], x[0]))"},{"question":"# Scenario You are tasked with developing a software utility for a traffic management system that detects traffic congestion on roads. The system gathers data on the number of vehicles passing a checkpoint over a period. Based on this data, the utility needs to classify the congestion level and provide the necessary action. Congestion levels are categorized as follows: - Low: Fewer than 30 vehicles per minute - Moderate: 30 to 60 vehicles per minute (inclusive) - Severe: More than 60 vehicles per minute Your task is to implement a function that classifies the congestion level based on the provided data. # Task Write a function: 1. **classify_congestion**: - **Input**: * `vehicles_per_minute` (float): the number of vehicles passing the checkpoint per minute. - **Output**: * Returns a string indicating the congestion level  either \\"Low\\", \\"Moderate\\", or \\"Severe\\". - **Constraints**: * The input must be a non-negative float value. - **Example**: ```python classify_congestion(45.5) # Returns \'Moderate\' ``` # Performance Requirements Your implementation should have a constant time complexity O(1) and space complexity O(1). # Additional Notes - Ensure to handle invalid inputs by raising a `ValueError` with an appropriate error message. - Validate your solution using unit tests to check for edge cases and typical scenarios.","solution":"def classify_congestion(vehicles_per_minute): Classifies the congestion level based on the number of vehicles passing per minute. Args: vehicles_per_minute (float): The number of vehicles passing the checkpoint per minute. Returns: str: The congestion level (\'Low\', \'Moderate\', \'Severe\'). Raises: ValueError: If the input is a negative value. if not isinstance(vehicles_per_minute, (int, float)) or vehicles_per_minute < 0: raise ValueError(\\"vehicles_per_minute must be a non-negative number\\") if vehicles_per_minute < 30: return \\"Low\\" elif 30 <= vehicles_per_minute <= 60: return \\"Moderate\\" else: return \\"Severe\\""},{"question":"# **Extract Unique Words from Sentences** Write a function `extract_unique_words(sentences: list[str]) -> list[str]` that takes a list of sentences and returns a list of unique words across all sentences in sorted order. For this task: 1. **Input:** - `sentences`: A list of sentences where each sentence is a non-empty string containing words separated by spaces. 2. **Output:** - A list of unique words sorted in alphabetical order (case-insensitive). 3. **Constraints:** - Sentences contain only alphabetical words and spaces. - All words within each sentence are separated by a single space. - Treat words with different cases as being the same (e.g., \\"Word\\", \\"word\\", and \\"WORD\\" are all the same). 4. **Examples:** ```python >>> extract_unique_words([\\"The quick brown fox\\", \\"jumps over the lazy dog\\", \\"THE LAZY DOG\\"]) [\'brown\', \'dog\', \'fox\', \'jumps\', \'lazy\', \'over\', \'quick\', \'the\'] >>> extract_unique_words([\\"Hello World\\", \\"hello WORLD\\", \\"HELLO world\\"]) [\'hello\', \'world\'] >>> extract_unique_words([\\"Python programming is fun\\", \\"programming in Python\\"]) [\'fun\', \'in\', \'is\', \'programming\', \'python\'] ``` # Requirements * Ensure the function treats words case-insensitively. * Utilize appropriate data structures to efficiently filter out duplicates and sort the words. * Handle edge cases such as an empty list or sentences with repeated words correctly.","solution":"def extract_unique_words(sentences): This function takes a list of sentences and returns a list of unique words sorted in alphabetical order (case-insensitive). unique_words = set() for sentence in sentences: words = sentence.split() for word in words: unique_words.add(word.lower()) return sorted(unique_words)"},{"question":"# Context Finding patterns or subsequences within a string is a common task in string processing and text analysis. One of the fundamental problems in this domain is checking if one string is a subsequence of another. # Task Implement a function to determine whether a given string `s` is a subsequence of another string `t`. A string `s` is considered a subsequence of `t` if all the characters of `s` can be found in `t` in the same relative order, but not necessarily consecutively. # Your Task Function Signature ```python def is_subsequence(s: str, t: str) -> bool: Determines if `s` is a subsequence of `t`. Parameters: - s: a string whose subsequence status needs to be checked. - t: the target string in which to check for the subsequence. Returns: - bool: True if `s` is a subsequence of `t`, otherwise False. ``` # Constraints - The length of `s` is at most `1000`. - The length of `t` is at most `100,000`. - Both strings `s` and `t` consist of lowercase English letters. # Example ```python print(is_subsequence(\\"abc\\", \\"ahbgdc\\")) # Output: True print(is_subsequence(\\"axc\\", \\"ahbgdc\\")) # Output: False print(is_subsequence(\\"ace\\", \\"abcde\\")) # Output: True print(is_subsequence(\\"aec\\", \\"abcde\\")) # Output: False ``` # Explanation 1. In the first example, all characters of \\"abc\\" can be found sequentially in \\"ahbgdc\\". 2. In the second example, \\"axc\\" cannot be formed from \\"ahbgdc\\" while maintaining order. 3. In the third example, \\"ace\\" is found in \\"abcde\\" in the same relative order. 4. In the fourth example, \\"aec\\" order cannot be maintained while traversing \\"abcde\\".","solution":"def is_subsequence(s: str, t: str) -> bool: Determines if `s` is a subsequence of `t`. Parameters: - s: a string whose subsequence status needs to be checked. - t: the target string in which to check for the subsequence. Returns: - bool: True if `s` is a subsequence of `t`, otherwise False. it = iter(t) return all(char in it for char in s)"},{"question":"# Question: Implementing a Basic Text Compression Algorithm Your task is to implement a simple text compression algorithm based on a substitution cipher. The algorithm will replace each character in the input string with a predefined unique character from a mapping. Function Specification ```python def compress_text(input_text: str, mapping: dict[str, str]) -> str: Compresses the given text using the specified character mapping. Parameters: input_text (str): The string to be compressed. mapping (dict): A dictionary where each key is a character in the input_text and each value is the character that the key should be replaced with. Returns: str: The compressed text. Raises: ValueError: If a character in the input_text is not present in the mapping. Examples: >>> compress_text(\\"hello\\", {\\"h\\": \\"x\\", \\"e\\": \\"y\\", \\"l\\": \\"z\\", \\"o\\": \\"w\\"}) \'xyzzw\' >>> compress_text(\\"abcd\\", {\\"a\\": \\"m\\", \\"b\\": \\"n\\", \\"c\\": \\"o\\", \\"d\\": \\"p\\"}) \'mnop\' >>> compress_text(\\"hello\\", {\\"h\\": \\"x\\", \\"e\\": \\"y\\", \\"l\\": \\"z\\"}) Traceback (most recent call last): ... ValueError: Character \'o\' not found in mapping. ``` Requirements 1. **Input Constraints**: * `input_text` will be a string consisting of alphanumeric characters and whitespace only. * `mapping` will be a dictionary where keys are single characters (alphanumeric or whitespace) and values are single characters. 2. **Output**: * The function should return a string that is the compressed version of `input_text`. * If any character in `input_text` is not found in `mapping`, raise a `ValueError` with an appropriate message. 3. **Edge Cases**: * Handle cases where `input_text` includes characters not in `mapping`. * Ensure that the mapping provides unique replacements for each character. Performance Considerations Your solution should efficiently compress the text by utilizing the mapping in a single pass through the input text. Ensure that the time complexity is linear with respect to the size of the input text.","solution":"def compress_text(input_text: str, mapping: dict) -> str: Compresses the given text using the specified character mapping. Parameters: input_text (str): The string to be compressed. mapping (dict): A dictionary where each key is a character in the input_text and each value is the character that the key should be replaced with. Returns: str: The compressed text. Raises: ValueError: If a character in the input_text is not present in the mapping. compressed_text = [] for char in input_text: if char not in mapping: raise ValueError(f\\"Character \'{char}\' not found in mapping.\\") compressed_text.append(mapping[char]) return \'\'.join(compressed_text)"},{"question":"# Coding Assessment Question Context You are developing a module for a math tutoring application designed to help students understand properties of various two-dimensional shapes. The next task on your list is to add functionality to compute properties of regular polygons. A specific focus is the regular hexagon, which is a six-sided polygon often encountered in geometry. Task Implement functions to calculate the perimeter and area of a regular hexagon. A regular hexagon has the following properties: * **Perimeter (P)**: ( P = 6 times s ) * **Area (A)**: ( A = frac{3 times sqrt{3}}{2} times s^2 ) - Here, `s` is the length of one side of the hexagon. Requirements * **Function Names**: - `hexagon_perimeter(side: float) -> float` - `hexagon_area(side: float) -> float` * **Input**: - A single float `side` representing the length of one side of the hexagon. * **Output**: - For `hexagon_perimeter`, return the perimeter as a float. - For `hexagon_area`, return the area as a float. * **Constraints**: - `side` must be a positive number; raise a `ValueError` if not. * **Performance**: - The implementation should be efficient, with each method operating in constant time. * **Tests**: - Include tests to validate your solution. For example: ```python >>> hexagon_perimeter(4) 24 >>> hexagon_area(4) 41.569219381653056 >>> hexagon_perimeter(-3) Traceback (most recent call last): ... ValueError: Length must be a positive number. ``` Bonus Extend your solution to include a third function `describe_hexagon(side: float) -> dict`, which returns a dictionary containing both the perimeter and area. Example: ```python >>> describe_hexagon(4) {\'perimeter\': 24, \'area\': 41.569219381653056} ```","solution":"import math def hexagon_perimeter(side: float) -> float: Calculate the perimeter of a regular hexagon. :param side: Length of one side of the hexagon. :return: Perimeter of the hexagon. if side <= 0: raise ValueError(\\"Length must be a positive number.\\") return 6 * side def hexagon_area(side: float) -> float: Calculate the area of a regular hexagon. :param side: Length of one side of the hexagon. :return: Area of the hexagon. if side <= 0: raise ValueError(\\"Length must be a positive number.\\") return (3 * math.sqrt(3) / 2) * side ** 2 def describe_hexagon(side: float) -> dict: Return a dictionary containing the perimeter and area of a regular hexagon. :param side: Length of one side of the hexagon. :return: Dictionary with \'perimeter\' and \'area\' keys. return { \\"perimeter\\": hexagon_perimeter(side), \\"area\\": hexagon_area(side) }"},{"question":"# Array Rotation Challenge You are given an array and a number of steps. Your task is to rotate the array to the right by the given number of steps. The rotation should be done in place, meaning that no additional arrays or data structures should be used. Detailed Instructions: 1. Write a function `rotate_array` with the following parameters: - `array`: A list of integers. - `steps`: A non-negative integer representing the number of steps to rotate the array to the right. 2. The function should perform the following tasks: - Handle the case where `steps` is greater than the length of the array. - Rotate the array in place and return the modified array. Constraints: - Do not use any additional libraries or modules. - The input array can be empty. In this case, return the array as is. - The input steps can be zero. In this case, return the array as is. Function Signature: ```python def rotate_array(array: list[int], steps: int) -> list[int]: ``` Example: ```python # Example 1: array = [1, 2, 3, 4, 5] steps = 2 print(rotate_array(array, steps)) # Output: [4, 5, 1, 2, 3] # Example 2: array = [1, 2, 3, 4, 5] steps = 5 print(rotate_array(array, steps)) # Output: [1, 2, 3, 4, 5] # Example 3: array = [] steps = 3 print(rotate_array(array, steps)) # Output: [] # Example 4: array = [7, 7, 7, 7] steps = 1 print(rotate_array(array, steps)) # Output: [7, 7, 7, 7] ```","solution":"def rotate_array(array, steps): Rotates the array to the right by the given number of steps in place. if not array: return array n = len(array) steps = steps % n # Handle cases where steps > n # Reverse the entire array reverse(array, 0, n - 1) # Reverse the first part reverse(array, 0, steps - 1) # Reverse the second part reverse(array, steps, n - 1) return array def reverse(array, start, end): Reverses the elements in the array from start to end indices. while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1"},{"question":"# Question: Customizable Caesar Cipher with Shift Sequence You are required to create an advanced version of the Caesar cipher that allows for a custom sequence of shifts instead of a single static shift value. The cipher should be able to handle both encryption and decryption by applying these shifts in a repeating manner over the plaintext. Requirements: 1. **Shift Sequence**: A list of integers representing the shifts to be applied in sequence for character substitution. 2. **Character Wraparound**: - If the shift results in a character going past \'Z\' or \'z\', it should wrap around within the alphabet. - The function should preserve the case (upper or lower) of the letters. - Non-alphabetic characters should remain unchanged. 3. **Input/Output**: - `message` (str): The input string to be processed. - `shift_sequence` (list[int]): A list of integers with shift values for the cipher. Example: ```python message = \\"Hello, World!\\" shift_sequence = [1, 2, 3] # apply shifts in this repeating order encrypted_message = customizable_caesar_encrypt(message, shift_sequence) decrypted_message = customizable_caesar_decrypt(encrypted_message, shift_sequence) assert decrypted_message == message ``` # Implementation: Implement the following two functions to complete this task: 1. `customizable_caesar_encrypt(message: str, shift_sequence: list[int]) -> str` 2. `customizable_caesar_decrypt(encrypted_message: str, shift_sequence: list[int]) -> str` Function Specs: 1. `customizable_caesar_encrypt`: - Args: `message` (str), `shift_sequence` (list[int]). - Returns: `encrypted_message` (str). - Functionality: Encrypt the message using the specified sequence of shifts. 2. `customizable_caesar_decrypt`: - Args: `encrypted_message` (str), `shift_sequence` (list[int]). - Returns: `decrypted_message` (str). - Functionality: Decrypt the message using the specified sequence of shifts. # Additional Info: - Ensure that the functions properly handle various lengths of shift sequences. - The functions should loop through the `shift_sequence` repeatedly if it is shorter than the `message`.","solution":"def customizable_caesar_encrypt(message, shift_sequence): encrypted_message = [] shift_len = len(shift_sequence) for i, character in enumerate(message): shift = shift_sequence[i % shift_len] if \'a\' <= character <= \'z\': encrypted_message.append(chr((ord(character) - ord(\'a\') + shift) % 26 + ord(\'a\'))) elif \'A\' <= character <= \'Z\': encrypted_message.append(chr((ord(character) - ord(\'A\') + shift) % 26 + ord(\'A\'))) else: encrypted_message.append(character) return \'\'.join(encrypted_message) def customizable_caesar_decrypt(encrypted_message, shift_sequence): decrypted_message = [] shift_len = len(shift_sequence) for i, character in enumerate(encrypted_message): shift = shift_sequence[i % shift_len] if \'a\' <= character <= \'z\': decrypted_message.append(chr((ord(character) - ord(\'a\') - shift) % 26 + ord(\'a\'))) elif \'A\' <= character <= \'Z\': decrypted_message.append(chr((ord(character) - ord(\'A\') - shift) % 26 + ord(\'A\'))) else: decrypted_message.append(character) return \'\'.join(decrypted_message)"},{"question":"# Problem Statement Create a function that simulates a simplified traffic light controller for an intersection with two perpendicular roads. # Requirements 1. Implement a class `TrafficLightController` that manages the states of traffic lights for an intersection. 2. The intersection has two roads: North-South (NS) and East-West (EW). Only one road can have a green light at any time. 3. The traffic light controller should switch the green light between the roads every `time_interval` seconds. 4. Traffic lights should follow this transition: Green  Yellow  Red  Green (of the other road)  Yellow  Red. 5. Implement methods to start the traffic light simulation and to get the current state of both NS and EW traffic lights. # Input - **time_interval**: Time in seconds for which the green light remains before switching (an integer). # Output - The class should provide a method to start the simulation and a method to get the current state of the traffic lights at any given time. # Implementation Guidelines 1. Use Python\'s `time` module to handle the light switching intervals. 2. Ensure the traffic lights switch in accordance with the given time interval. 3. Provide a method to fetch the current state of the traffic lights without halting the simulation. # Function Signature ```python import time from enum import Enum class LightState(Enum): RED = \\"Red\\" YELLOW = \\"Yellow\\" GREEN = \\"Green\\" class TrafficLightController: def __init__(self, time_interval: int): self.time_interval = time_interval self.ns_state = LightState.RED self.ew_state = LightState.RED def start(self) -> None: # Simulate the traffic light switching logic here pass def get_current_state(self) -> dict: # Return the current state of NS and EW traffic lights pass ``` # Example ```python controller = TrafficLightController(10) controller.start() # Simulating real-time checking (not instantaneous for actual implementation) time.sleep(12) print(controller.get_current_state()) # Possibly {\'NS\': \'Red\', \'EW\': \'Green\'} depending on the sleep duration time.sleep(20) print(controller.get_current_state()) # Possibly {\'NS\': \'Yellow\', \'EW\': \'Red\'} depending on the sleep duration ``` # Constraints - The simulation should run indefinitely once started until manually stopped. - The `get_current_state` method should be able to provide the traffic light states at any given point in real-time. - No external libraries should be used other than the standard Python library. Consider your implementation details carefully to ensure clarity, conciseness, and adherence to the problem requirements.","solution":"import time from enum import Enum from threading import Thread, Event class LightState(Enum): RED = \\"Red\\" YELLOW = \\"Yellow\\" GREEN = \\"Green\\" class TrafficLightController: def __init__(self, time_interval: int): self.time_interval = time_interval self.ns_state = LightState.GREEN self.ew_state = LightState.RED self.stop_event = Event() self.thread = None def start(self) -> None: self.thread = Thread(target=self._run) self.thread.start() def stop(self) -> None: self.stop_event.set() self.thread.join() def get_current_state(self) -> dict: return { \'NS\': self.ns_state.value, \'EW\': self.ew_state.value } def _run(self): while not self.stop_event.is_set(): time.sleep(self.time_interval) self._switch_lights() def _switch_lights(self): if self.ns_state == LightState.GREEN: self.ns_state = LightState.YELLOW elif self.ns_state == LightState.YELLOW: self.ns_state = LightState.RED self.ew_state = LightState.GREEN elif self.ew_state == LightState.GREEN: self.ew_state = LightState.YELLOW elif self.ew_state == LightState.YELLOW: self.ew_state = LightState.RED self.ns_state = LightState.GREEN"},{"question":"# Given Context You are developing a text processing script that parses a collection of text files to extract specific information. The script should read multiple text files from a directory, extract all the email addresses contained in those files, and write those email addresses to a new file. # Task 1. Implement a function `extract_emails(directory_path, output_file)` that: - Reads all `.txt` files from the directory specified by `directory_path`. - Extracts all email addresses from these files. - Writes the extracted email addresses, one per line, to `output_file`. # Input and Output Formats * **Function to implement**: * `extract_emails(directory_path: str, output_file: str) -> None` * **Constraints**: * Assume each email address is represented by the regular expression pattern `[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}`. * Skip files that cannot be read without crashing the script. Log a message for each skipped file. * Emails should not be duplicated in the output file. * Preserve the order of first occurrence of each email address across all files. # Example Scenario Assume you have a directory `sample_texts` with the following text files: - file1.txt: ``` Hello john.doe@example.com Contact: jane.doe@company.org for more info. ``` - file2.txt: ``` Reach us at support@domain.com or sales@domain.com. ``` The script should write the following to the specified output file: ``` john.doe@example.com jane.doe@company.org support@domain.com sales@domain.com ``` # Starter Code ```python import re import os from typing import List def extract_emails(directory_path: str, output_file: str) -> None: Extracts email addresses from text files in the given directory and writes them to an output file. Parameters: - directory_path: Path to the directory containing text files. - output_file: Path to the output file where emails will be written. email_pattern = re.compile(r\\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\") extracted_emails = [] for root, _, files in os.walk(directory_path): for file in files: if file.endswith(\'.txt\'): try: with open(os.path.join(root, file), \'r\') as f: content = f.read() emails = email_pattern.findall(content) for email in emails: if email not in extracted_emails: extracted_emails.append(email) except Exception as e: print(f\\"Could not read file {file}: {e}\\") with open(output_file, \'w\') as of: for email in extracted_emails: of.write(email + \'n\') ``` # Test Case To validate the function, you could use a directory `test_texts` with sample files similar to the description. Ensure that the generated output file matches the expected list of email addresses as discussed. ---","solution":"import re import os from typing import List def extract_emails(directory_path: str, output_file: str) -> None: Extracts email addresses from text files in the given directory and writes them to an output file. Parameters: - directory_path: Path to the directory containing text files. - output_file: Path to the output file where emails will be written. email_pattern = re.compile(r\\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\") extracted_emails = [] unique_emails = set() for root, _, files in os.walk(directory_path): for file in files: if file.endswith(\'.txt\'): try: with open(os.path.join(root, file), \'r\') as f: content = f.read() emails = email_pattern.findall(content) for email in emails: if email not in unique_emails: extracted_emails.append(email) unique_emails.add(email) except Exception as e: print(f\\"Could not read file {file}: {e}\\") with open(output_file, \'w\') as of: for email in extracted_emails: of.write(email + \'n\')"},{"question":"# Problem: Compare Character Frequencies Between Two Strings Given two strings, you need to determine if they are anagrams of each other. Two strings are considered anagrams if they can be rearranged to form the other string by only changing the order of their characters. The comparison should be case-insensitive and ignore any non-alphabetic characters. Implement the following function to compare character frequencies: Function: `are_anagrams(str1: str, str2: str) -> bool` Determines if the two given strings are anagrams of each other. **Parameters**: * `str1`: The first string to compare. * `str2`: The second string to compare. **Returns**: * `True` if the two strings are anagrams of each other, `False` otherwise. Constraints: * The input strings `str1` and `str2` can contain letters (both uppercase and lowercase), spaces, and punctuation marks. * The comparison should be case-insensitive. * All non-alphabet characters should be ignored during the comparison. # Example: ```python str1 = \\"Listen!\\" str2 = \\"Silent!!\\" print(are_anagrams(str1, str2)) # Expected Output: True str1 = \\"Hello\\" str2 = \\"Olelh!\\" print(are_anagrams(str1, str2)) # Expected Output: True str1 = \\"Apple\\" str2 = \\"Pabble\\" print(are_anagrams(str1, str2)) # Expected Output: False ``` Consider edge cases, such as: * Empty strings * Strings with only non-alphabet characters * Identical strings in different cases # Performance Requirements: * Implement the function to run in O(n) time, where n is the length of the longer string.","solution":"def are_anagrams(str1: str, str2: str) -> bool: Determines if two given strings are anagrams of each other. Parameters: str1 (str): The first string to compare. str2 (str): The second string to compare. Returns: bool: True if the two strings are anagrams, False otherwise. from collections import Counter import re # Helper function to clean and normalize the string def clean_string(s): # Remove non-alphabetical characters and lower the case return re.sub(r\'[^a-zA-Z]\', \'\', s).lower() clean_str1 = clean_string(str1) clean_str2 = clean_string(str2) return Counter(clean_str1) == Counter(clean_str2)"},{"question":"# Coding Challenge Context: You are required to simulate a basic encryption technique often used in ancient times, known as Caesar Cipher. In this problem, each letter in the plaintext is shifted a fixed number of places down or up the alphabet. Objective: Write a function `caesar_cipher(text: str, shift: int) -> str` that takes a string `text` and an integer `shift` and returns the encoded text using the Caesar Cipher technique. The encoding should retain the case of the original characters, and non-alphabet characters should remain unchanged. Input: The input will be a string `text` containing a mix of uppercase, lowercase letters, and potentially some special characters (punctuation, spaces, digits). The `shift` will be an integer where ( -26 leq text{shift} leq 26 ). Output: The output should be a single string which is the encoded text after applying the Caesar Cipher. Constraints: - Make sure to handle edge cases such as wrap-around of the alphabet. - Ensure the solution processes the string efficiently even with a large number of characters. Examples: ```python >>> caesar_cipher(\\"Hello, World!\\", 3) \'Khoor, Zruog!\' >>> caesar_cipher(\\"abcXYZ\\", -3) \'xyzUVW\' >>> caesar_cipher(\\"abcXYZ123!?\\", 0) \'abcXYZ123!?\' >>> caesar_cipher(\\"Complexity 101.\\", 5) \'Htrxqjcyqd 101.\' ``` Performance Requirement: Although typical text inputs are relatively small, ensure that your solution handles strings of significant length efficiently. Good luck!","solution":"def caesar_cipher(text: str, shift: int) -> str: Encodes the input text using the Caesar Cipher technique. :param text: The text to be encoded. :param shift: The number of places to shift each letter. :return: The encoded text. def shift_char(c, shift): if \'a\' <= c <= \'z\': offset = ord(\'a\') return chr((ord(c) - offset + shift) % 26 + offset) elif \'A\' <= c <= \'Z\': offset = ord(\'A\') return chr((ord(c) - offset + shift) % 26 + offset) else: return c return \'\'.join(shift_char(c, shift) for c in text)"},{"question":"Problem Statement Create a function that receives an integer list and a target integer and returns a tuple with the indices of two numbers from the list that add up to the target. If such a pair does not exist, the function should return an empty tuple. # Input: * A list of integers `nums` (1  len(nums)  10^5, (-10^9)  nums[i]  10^9). * An integer `target` (-10^9  target  10^9). # Output: * A tuple of two integers representing the indices of the two numbers from the list that add up to the target, or an empty tuple if such a pair does not exist. # Function signature: ```python def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: pass ``` # Example: ```python >>> find_two_sum([2, 7, 11, 15], 9) (0, 1) >>> find_two_sum([1, 2, 3, 4], 8) () >>> find_two_sum([-1, -2, -3, -4, -5], -8) (2, 4) ``` # Constraints: * The solution should have a time complexity of (O(n)). # Notes: * Assume that there will be at most one pair of indices that satisfy the condition. * Indices should be returned in the order they appear in the list (smaller index first).","solution":"from typing import List, Tuple def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: Finds two numbers in the list that add up to the target and returns their indices as a tuple. If such a pair does not exist, returns an empty tuple. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"# Problem Statement You are given an integer `n` and a sequence of `n` integers. Your task is to rearrange the sequence such that the difference between every two consecutive elements is minimized. Return the rearranged sequence as a list. # Input - An integer `n` representing the number of elements in the sequence. (1  n  10^5) - A sequence of `n` integers. Each integer `a_i` is such that -10^6  a_i  10^6. # Output - A list of integers representing the rearranged sequence with minimized differences between consecutive elements. # Constraints 1. The sequence can contain duplicate numbers, and all numbers in the given range. 2. It\'s possible for the sequence length to be 1, in which case the original sequence should be returned. 3. Optimize the solution to handle large inputs efficiently. # Requirements 1. Implement the function `rearrange_sequence(n: int, sequence: List[int]) -> List[int]` that adheres to the above constraints and solves the problem. 2. The function should achieve optimal time and space complexity. 3. Include appropriate comments and documentation for clarity. # Example Input ```python n = 5 sequence = [3, 4, 1, 100, 2] ``` Output ```python [1, 2, 3, 4, 100] ``` Explanation One valid rearrangement is given in the output, which minimizes the difference between consecutive elements. # Function Signature ```python from typing import List def rearrange_sequence(n: int, sequence: List[int]) -> List[int]: # Your code here pass ``` # Evaluation Your solution will be evaluated based on: 1. **Correctness**: Accurate rearrangement of the sequence to minimize consecutive element differences. 2. **Efficiency**: Use of efficient algorithms to handle large inputs. 3. **Code Quality**: Clear, readable, and well-commented code.","solution":"from typing import List def rearrange_sequence(n: int, sequence: List[int]) -> List[int]: Rearranges the given sequence such that the difference between every two consecutive elements is minimized. Parameters: n (int): The number of elements in the sequence. sequence (List[int]): The list of integers to be rearranged. Returns: List[int]: The rearranged sequence with minimized differences between consecutive elements. # The optimal way to minimize the difference between consecutive elements # is to sort the sequence. return sorted(sequence)"},{"question":"# Coding Assessment Question Scenario: You are tasked with implementing a function to compute the Greatest Common Divisor (GCD) of multiple integers. The GCD is significant in number theory and is used in various algorithms to determine the shared factors between numbers. Problem Statement: Implement a Python function `gcd_multiple(numbers: List[int]) -> int` that computes the GCD of a list of integers. Requirements: 1. The function should handle lists containing positive and negative integers. 2. Non-integer and non-numeric inputs should raise a `TypeError`. 3. The function should efficiently iterate through the list to compute the GCD of all provided integers. 4. To compute the GCD of the entire list, you must use the Euclidean algorithm, which is efficient and widely used. Input: - A list of integers `numbers`, which may contain both positive and negative numbers. Output: - An integer representing the GCD of the provided list of integers. Constraints: - You must use an efficient and iterative method for computing the GCD of the list. - Your solution should handle the list iteratively, ensuring a time complexity of (O(n log(max(text{numbers})))). Function Signature: ```python from typing import List def gcd_multiple(numbers: List[int]) -> int: ``` Example Cases: ```python assert gcd_multiple([24, 60, 36]) == 12 assert gcd_multiple([-8, 32, 16]) == 8 assert gcd_multiple([3, 7, 31]) == 1 assert gcd_multiple([0, 20, 30]) == 10 assert gcd_multiple([1024, 2048, 4096]) == 1024 ``` Additional Information: - Use Python\'s in-built `math.gcd` function for computing the GCD of two numbers as a helper. - The function should handle edge cases such as lists containing zeros, single-element lists, and all-negative numbers appropriately. Implement the `gcd_multiple` function as per the outlined requirements.","solution":"from typing import List from math import gcd from functools import reduce def gcd_multiple(numbers: List[int]) -> int: Returns the GCD of a list of integers. Raises a TypeError if the input list contains non-integer elements. if not all(isinstance(x, int) for x in numbers): raise TypeError(\\"All elements in the input list must be integers\\") def gcd_of_two(x, y): return gcd(abs(x), abs(y)) return reduce(gcd_of_two, numbers, 0)"},{"question":"# Longest Common Subsequence (LCS) You are given two sequences: a string `X` and another string `Y`. Your task is to implement the algorithm to find the longest common subsequence (LCS) of the two sequences. The LCS is the longest sequence that can be obtained from both `X` and `Y` without rearranging the order of characters, though characters may have gaps between them. # Task 1. Implement the `lcs_length` function to create and populate the LCS matrix. 2. Implement the `extract_lcs` function to extract the longest common subsequence from the LCS matrix. # Input - Two strings `X` and `Y`. # Output A string representing the Longest Common Subsequence (LCS) of `X` and `Y`. # Example ```python X = \\"AGGTAB\\" Y = \\"GXTXAYB\\" ``` **Output**: ``` GTAB ``` # Constraints - The sequences consist only of uppercase English letters. - 1  len(X), len(Y)  1000 # Notes 1. Utilize the provided function templates and ensure proper handling of edge cases like empty sequences. 2. Optimize for performance considering the constraints. ```python def lcs_length(X: str, Y: str) -> list[list[int]]: # Your implementation here def extract_lcs(L: list[list[int]], X: str, Y: str) -> str: # Your implementation here if __name__ == \\"__main__\\": X = input(\\"Enter the first sequence: \\") Y = input(\\"Enter the second sequence: \\") L = lcs_length(X, Y) lcs = extract_lcs(L, X, Y) print(lcs) ``` # Remarks * Test the implementation with different test cases provided in the examples. * Consider and properly handle edge cases. * Ensure your implementation is efficient and accurate.","solution":"def lcs_length(X: str, Y: str) -> list[list[int]]: m, n = len(X), len(Y) L = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) return L def extract_lcs(L: list[list[int]], X: str, Y: str) -> str: i, j = len(X), len(Y) lcs = [] while i > 0 and j > 0: if X[i - 1] == Y[j - 1]: lcs.append(X[i - 1]) i -= 1 j -= 1 elif L[i - 1][j] >= L[i][j - 1]: i -= 1 else: j -= 1 return \'\'.join(reversed(lcs))"},{"question":"# **Binary Tree to Linked List Conversion** You are given the implementation of a binary tree, and the objective is to convert this binary tree into a singly linked list where the values should appear in an in-order traversal format. # Task 1. **Convert Binary Tree to Linked List**: Implement a function that converts a given binary tree into a singly linked list. The resultant linked list should contain the nodes of the tree in the same order as an in-order traversal. 2. **Maintain Node Classes**: Utilize the provided `TreeNode` and `ListNode` classes in your solution. # Function Signature Implement the conversion function using the signature below: ```python def convert_bst_to_linked_list(root: TreeNode) -> ListNode: pass ``` # Input - **root**: The root node of the binary tree to be converted. # Output - Return the head node of the resultant singly linked list. # Class Definitions ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Constraints - The number of nodes in the binary tree is in the range `[1, 1000]`. - `-1000 <= Node.val <= 1000` # Example ```python # Binary Tree root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) # Expected Output: 1 -> 2 -> 3 -> 4 -> 5 linked_list_head = convert_bst_to_linked_list(root) while linked_list_head: print(linked_list_head.val, end=\\" -> \\") linked_list_head = linked_list_head.next ``` # Notes - Perform an in-order traversal of the binary tree to extract the values in the requisite order. - Construct the singly linked list by iterating through these values. - Analyze and test with additional trees of varying structures to verify the correctness of your implementation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def convert_bst_to_linked_list(root: TreeNode) -> ListNode: def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) values = in_order_traversal(root) dummy_head = ListNode(0) current = dummy_head for val in values: current.next = ListNode(val) current = current.next return dummy_head.next"},{"question":"# Question: You are tasked with implementing a genetic algorithm to solve a simple combinatorial optimization problem: finding the maximum value of a function within a given range. The algorithm should follow these steps: 1. **Initialization**: Generate an initial population of solutions randomly within the specified range. 2. **Fitness Evaluation**: Evaluate the fitness of each solution using the given function. 3. **Selection**: Select pairs of solutions for reproduction using roulette wheel selection based on fitness. 4. **Crossover**: Apply one-point crossover to generate new offspring. 5. **Mutation**: Apply a mutation operation with a given probability to introduce variations. 6. **Iteration**: Repeat the process for a specified number of generations or until convergence. **Function Signature**: ```python import random from typing import Callable, List, Tuple def genetic_algorithm( fnc: Callable[[float], float], x_min: float, x_max: float, population_size: int, generations: int, crossover_rate: float, mutation_rate: float ) -> Tuple[float, float]: pass ``` **Input**: - `fnc`: A function defining the optimization objective. - `x_min`: A float representing the minimum value of the range. - `x_max`: A float representing the maximum value of the range. - `population_size`: An integer representing the number of solutions in the population. - `generations`: An integer representing the number of generations to run the algorithm. - `crossover_rate`: A float between 0 and 1 representing the probability of crossover. - `mutation_rate`: A float between 0 and 1 representing the probability of mutation. **Output**: - A tuple containing the best solution found and its corresponding function value. **Example**: ```python >>> def fitness_function(x): >>> return -1 * (x ** 2) + 4 * x >>> >>> best_solution, best_fitness = genetic_algorithm(fitness_function, 0.0, 4.0, 50, 100, 0.7, 0.01) >>> print(f\\"Best Solution: {best_solution}, Fitness: {best_fitness}\\") ``` **Constraints**: - Ensure that the solution values are bounded within the [x_min, x_max] range during the process. - Precision of the solution should be up to six decimal places. **Implementation Details**: - Use roulette wheel selection for selecting parents based on their fitness values. - Apply one-point crossover to generate offspring. - Introduce small mutations to the offspring with the probability defined by `mutation_rate`. *Your task is to implement the `genetic_algorithm` function according to the described requirements.*","solution":"import random from typing import Callable, List, Tuple def genetic_algorithm( fnc: Callable[[float], float], x_min: float, x_max: float, population_size: int, generations: int, crossover_rate: float, mutation_rate: float ) -> Tuple[float, float]: # Initialize a population of random solutions within the specified range population = [random.uniform(x_min, x_max) for _ in range(population_size)] def evaluate_fitness(population: List[float]) -> List[float]: return [fnc(ind) for ind in population] def select_parents(population: List[float], fitnesses: List[float]) -> List[Tuple[float, float]]: total_fitness = sum(fitnesses) probs = [fit / total_fitness for fit in fitnesses] selected = random.choices(population, weights=probs, k=2) return [(selected[0], selected[1]) for _ in range(population_size // 2)] def crossover(parent1: float, parent2: float) -> Tuple[float, float]: if random.random() < crossover_rate: return (parent1, parent2) else: crossover_point = random.uniform(x_min, x_max) return ((parent1+crossover_point)/2, (parent2+crossover_point)/2) def mutate(individual: float) -> float: if random.random() < mutation_rate: mutation = random.uniform(-0.1, 0.1) mutated = individual + mutation return min(max(mutated, x_min), x_max) return individual best_individual = None best_fitness = -float(\'inf\') for generation in range(generations): fitnesses = evaluate_fitness(population) # Selection mating_pool = select_parents(population, fitnesses) # Crossover new_population = [] for parent1, parent2 in mating_pool: child1, child2 = crossover(parent1, parent2) new_population.append(child1) new_population.append(child2) # Mutation population = [mutate(ind) for ind in new_population] # Update best solution for individual in population: current_fitness = fnc(individual) if current_fitness > best_fitness: best_fitness = current_fitness best_individual = individual return best_individual, round(best_fitness, 6)"},{"question":"# Coding Assessment Question You are tasked with creating a simple version of a Markdown to HTML converter. Write a function that converts given Markdown text into well-formed HTML. The function should handle headers (up to H3), bold and italic text, and paragraphs. # Function Specifications Function: `markdown_to_html` **Input**: - A string containing Markdown-formatted text. **Output**: - A string containing the corresponding HTML-formatted text. **Requirements**: - Headers: - Convert lines starting with `#` to `<h1>`, `` to `<h2>`, and `#` to `<h3>`. - Bold text: - Convert text wrapped with `**` to be inside `<b>` tags. - Italic text: - Convert text wrapped with `_` to be inside `<i>` tags. - Paragraphs: - Any text not fitting the above rules should be encapsulated within `<p>` tags. # Examples ```python # Example for markdown_to_html print(markdown_to_html(\\"# Heading 1n Heading 2nSome **bold** text and some _italic_ text.nnAnother paragraph.\\")) # Output: \\"<h1>Heading 1</h1><h2>Heading 2</h2><p>Some <b>bold</b> text and some <i>italic</i> text.</p><p>Another paragraph.</p>\\" print(markdown_to_html(\\"# Heading 3nRegular text with no formatting.\\")) # Output: \\"<h3>Heading 3</h3><p>Regular text with no formatting.</p>\\" ``` Note: Handle edge cases such as empty inputs or inputs with no recognizable Markdown formatting, returning an empty string or the input wrapped in `<p>` tags respectively.","solution":"import re def markdown_to_html(markdown_text): Converts Markdown formatted text into HTML. html_text = [] if not markdown_text.strip(): return \\"\\" paragraphs = markdown_text.strip().split(\\"nn\\") for para in paragraphs: lines = para.split(\\"n\\") for line in lines: line = re.sub(r\\"(?<!)**(.*?)**\\", r\\"<b>1</b>\\", line) # Bold line = re.sub(r\\"(?<!)_(.*?)_\\", r\\"<i>1</i>\\", line) # Italic if line.startswith(\'# \'): html_text.append(f\\"<h3>{line[4:]}</h3>\\") elif line.startswith(\' \'): html_text.append(f\\"<h2>{line[3:]}</h2>\\") elif line.startswith(\'# \'): html_text.append(f\\"<h1>{line[2:]}</h1>\\") else: html_text.append(f\\"<p>{line}</p>\\") return \'\'.join(html_text)"},{"question":"# Data Structure Manipulation: Binary Search Tree Implementation In this task, you will be required to implement a custom Binary Search Tree (BST) with specific methods. The tree will store integer values and ensure the BST property where the left child contains values smaller than the parent node and the right child contains values larger than the parent node. Part A: CustomBinarySearchTree A binary search tree with the following methods: 1. `__init__(self)`: Initializes an empty tree. 2. `insert(self, data: int)`: Inserts a new integer into the BST. Duplicate values are not allowed; raise a `ValueError` for duplicates. 3. `find(self, data: int) -> bool`: Returns `True` if the value exists in the BST, `False` otherwise. 4. `delete(self, data: int)`: Removes the specified value from the BST. Raise a `ValueError` if the value does not exist. 5. `__str__(self) -> str`: Returns a string representation of the tree in an in-order traversal. # Input and Output * `insert(data)` accepts a single integer value to be inserted into the BST. * `find(data)` accepts a single integer value and returns a boolean indicating its presence. * `delete(data)` accepts a single integer value to be removed from the BST. * The BST instances should handle standard exceptions for duplicates and non-existent values correctly. # Example ```python # Create a new BST bst = CustomBinarySearchTree() # Insert elements bst.insert(15) bst.insert(10) bst.insert(20) bst.insert(8) bst.insert(12) print(bst) # In-order: [8, 10, 12, 15, 20] # Find elements bst.find(10) # True bst.find(5) # False # Delete elements bst.delete(10) print(bst) # In-order: [8, 12, 15, 20] bst.find(10) # False ``` # Performance Requirements Ensure that your implementation meets the specified time complexities: * `insert`: O(log n) average case, O(n) worst case * `find`: O(log n) average case, O(n) worst case * `delete`: O(log n) average case, O(n) worst case * String representation should be efficient. Implement the class `CustomBinarySearchTree` with the specified methods and ensure your code passes the above examples.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class CustomBinarySearchTree: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data == node.data: raise ValueError(\\"Duplicate value\\") elif data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) else: # data > node.data if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def find(self, data): return self._find(self.root, data) def _find(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._find(node.left, data) else: # data > node.data return self._find(node.right, data) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, data): if node is None: raise ValueError(\\"Value not found\\") if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: # data == node.data if node.left is None: return node.right if node.right is None: return node.left temp_val = self._min_value_node(node.right) node.data = temp_val.data node.right = self._delete(node.right, temp_val.data) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def __str__(self): elements = [] self._in_order_traversal(self.root, elements) return str(elements) def _in_order_traversal(self, node, elements): if node: self._in_order_traversal(node.left, elements) elements.append(node.data) self._in_order_traversal(node.right, elements)"},{"question":"# Question: Optimized Hash Map Implementation You are tasked with implementing a basic hash map data structure from scratch. Your implementation should provide efficient insertion, deletion, and retrieval operations. The hash map should use separate chaining to handle collisions. **Objectives:** 1. Implement a class `HashMap` with the following methods: - `put(key: str, value: int) -> None`: Associates the specified value with the specified key. - `get(key: str) -> int`: Retrieves the value associated with the specified key. If the key does not exist, it should raise a `KeyError` with the message \\"Key not found\\". - `remove(key: str) -> None`: Removes the key-value pair associated with the specified key. If the key does not exist, it should simply do nothing. 2. Ensure efficient handling of key collisions using separate chaining (each bucket in the hash map should maintain a list of (key, value) pairs). **Constraints:** - Keys are non-empty strings. - Values are integers. - The hash map should dynamically resize to maintain efficient performance. **Function Signatures:** - `class HashMap:` - `def __init__(self) -> None:` - `def put(self, key: str, value: int) -> None:` - `def get(self, key: str) -> int:` - `def remove(self, key: str) -> None:` **Example Usage:** ```python hash_map = HashMap() hash_map.put(\\"apple\\", 1) hash_map.put(\\"banana\\", 2) hash_map.put(\\"orange\\", 3) print(hash_map.get(\\"apple\\")) # Output: 1 print(hash_map.get(\\"banana\\")) # Output: 2 hash_map.put(\\"banana\\", 4) print(hash_map.get(\\"banana\\")) # Output: 4 hash_map.remove(\\"orange\\") print(hash_map.get(\\"orange\\")) # Raises KeyError: \\"Key not found\\" hash_map.remove(\\"lemon\\") # Does nothing as \\"lemon\\" is not in the map ``` Your task is to implement the `HashMap` class ensuring it behaves as described and efficiently handles insertion, deletion, and retrieval operations.","solution":"class HashMap: def __init__(self): self._initial_capacity = 8 self._size = 0 self._buckets = [[] for _ in range(self._initial_capacity)] def _hash(self, key): return hash(key) % len(self._buckets) def _resize(self): new_capacity = len(self._buckets) * 2 new_buckets = [[] for _ in range(new_capacity)] for bucket in self._buckets: for key, value in bucket: new_index = hash(key) % new_capacity new_buckets[new_index].append((key, value)) self._buckets = new_buckets def put(self, key: str, value: int) -> None: if self._size / len(self._buckets) > 0.7: self._resize() index = self._hash(key) bucket = self._buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self._size += 1 def get(self, key: str) -> int: index = self._hash(key) bucket = self._buckets[index] for k, v in bucket: if k == key: return v raise KeyError(\\"Key not found\\") def remove(self, key: str) -> None: index = self._hash(key) bucket = self._buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self._size -= 1 return"},{"question":"# Coding Task: Implement a Simple Moving Average (SMA) function # Background: A Simple Moving Average (SMA) is a statistical technique used in time series analysis to smooth out short-term volatility and highlight longer-term trends or cycles. It is widely used in analyzing financial data, especially stock prices. The SMA is calculated by averaging a fixed number of past values. # Task: Implement the **Simple Moving Average (SMA)** function. For a given input list of numbers and a specified period, the function should return a list with the SMA for each position starting from the first point where there are enough values to calculate it. # Function Signature: ```python def simple_moving_average(data: list[float], period: int) -> list[float]: pass ``` # Input: - `data`: A list of real numbers representing a time series. - `period`: An integer representing the number of data points to calculate each average. # Output: - A list of real numbers where each element is the SMA calculated over the specified period. # Examples: ```python >>> simple_moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] >>> simple_moving_average([10, 20, 30, 40], 2) [15.0, 25.0, 35.0] ``` # Constraints: * The `data` list contains at most 1000 elements. * Each element in the `data` list is a real number in the range of -10^6 to 10^6. * The `period` is at most 1000 and at least 1. # Notes: - The function should return an empty list if the period is greater than the length of the input list. - Ensure the implementation handles edge cases such as short data lists, very large or small values, and period values equal to the length of the list appropriately. - Aim for an efficient solution that minimizes unnecessary computations.","solution":"def simple_moving_average(data: list[float], period: int) -> list[float]: Calculate the Simple Moving Average (SMA) of a given list of numbers for the specified period. Parameters: data (list of float): The input list of real numbers representing a time series. period (int): The number of data points to calculate each average. Returns: list of float: The list of SMA values. if period > len(data) or period <= 0: return [] sma_values = [] for i in range(len(data) - period + 1): window = data[i:i + period] window_average = sum(window) / period sma_values.append(window_average) return sma_values"},{"question":"# Coding Assessment Task: Context: As a robotics engineer, you are developing a software module to navigate a robot through a grid while avoiding obstacles. The robot can move up, down, left, or right, but it can\'t move diagonally. Your task is to simulate this navigation. Problem Statement: Given a grid represented as a 2D list of integers where `0` indicates an open space and `1` indicates an obstacle, implement a function `can_reach` that determines if the robot can move from a starting position to a target position. Function Signature: ```python def can_reach(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> bool: pass ``` Input/Output: * **Input**: A 2D list `grid` representing the grid layout, a tuple `start` representing the robot\'s starting coordinates, and a tuple `target` representing the target coordinates. * **Output**: A boolean value indicating whether the robot can reach the target position from the starting position. Constraints: - The grid will have dimensions m x n, where 1  m, n  100. - Both `start` and `target` will be valid positions within the grid (i.e., not on obstacles). - The robot can only move in four directions: up, down, left, and right. Examples: ```python >>> grid = [ ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [1, 1, 0, 0], ... [0, 0, 0, 0] ... ] >>> can_reach(grid, (0, 0), (3, 3)) True >>> grid = [ ... [0, 1, 0, 0], ... [0, 0, 1, 1], ... [1, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> can_reach(grid, (0, 0), (3, 3)) False ``` Notes: 1. Use an algorithm appropriate for path-finding, such as BFS (Breadth-First Search) or DFS (Depth-First Search). 2. Ensure that your solution handles large grids efficiently. 3. Consider edge cases where the robot cannot move at all from the start position due to immediate obstacles.","solution":"from collections import deque def can_reach(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> bool: Determines if the robot can move from the start position to the target position in the grid while avoiding obstacles. :param grid: 2D list of integers where 0 indicates an open space and 1 indicates an obstacle. :param start: Tuple representing the starting coordinates (row, column). :param target: Tuple representing the target coordinates (row, column). :return: Boolean value indicating whether the robot can reach the target position. if not grid or start == target: return True rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = set() queue = deque([start]) visited.add(start) while queue: current = queue.popleft() if current == target: return True for dr, dc in directions: next_pos = (current[0] + dr, current[1] + dc) if 0 <= next_pos[0] < rows and 0 <= next_pos[1] < cols and next_pos not in visited and grid[next_pos[0]][next_pos[1]] == 0: visited.add(next_pos) queue.append(next_pos) return False"},{"question":"# Assessment Question: Maze Solver You are tasked with writing a function to determine if there is a path from the start to the destination in a given 2D grid maze. The grid is represented by a 2D list where \'0\' indicates an open cell and \'1\' indicates a wall. The player can move up, down, left, or right but cannot pass through walls. Given a maze, a start position, and a destination position, determine if a path exists from the start to the destination without crossing any walls. Consider the following constraints for your solution: - The start and destination positions are always within the grid bounds. - The start and the destination will never be a wall. - The function should return a boolean value indicating whether a path exists. Function Signature ```python def has_path(maze: list[list[int]], start: list[int], destination: list[int]) -> bool: pass ``` Input and Output Format: - Input: A 2D grid `maze` of integers (0s and 1s), a list `start` with two integers [start_row, start_col], and a list `destination` with two integers [dest_row, dest_col]. - Output: A boolean value `True` if there is a path from `start` to `destination`, otherwise `False`. Example ```python >>> maze = [ ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ] >>> start = [0, 4] >>> destination = [4, 4] >>> has_path(maze, start, destination) True >>> start = [0, 4] >>> destination = [3, 2] >>> has_path(maze, start, destination) False ``` Constraints 1. The dimensions of the grid `maze` will be between 1 and 100. 2. The grid values will be either 0 (open cell) or 1 (wall). 3. Positions are given in the format [row, col]. Performance Requirements - Ensure the function runs efficiently with an average time complexity of O(M x N), where M is the number of rows and N is the number of columns in the grid.","solution":"def has_path(maze: list[list[int]], start: list[int], destination: list[int]) -> bool: rows, cols = len(maze), len(maze[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if [r, c] == destination: return True if visited[r][c]: return False visited[r][c] = True # Explore in all 4 possible directions directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: nr, nc = r, c # Move in the current direction until hitting a wall or border while 0 <= nr + dr < rows and 0 <= nc + dc < cols and maze[nr + dr][nc + dc] == 0: nr += dr nc += dc # Recursively call dfs from the stopping point if dfs(nr, nc): return True return False return dfs(start[0], start[1])"},{"question":"# Prime Factorization and Sum of Divisors Objective: Implement a function that takes an integer as input, computes its prime factorization, and returns the sum of all its divisors. Description: Given an integer, perform the following steps: 1. Compute the prime factorization of the integer. 2. Using the prime factorization, calculate all divisors of the integer. 3. Return the sum of all the divisors. Function Definition: ```python def sum_of_divisors(n: int) -> int: Calculate the sum of all divisors of a given integer using its prime factorization. Args: n (int): The integer whose divisors sum is to be calculated. Returns: int: The sum of all the divisors of the integer. ``` Constraints: 1. The input integer `n` will be a positive integer (1  n  1_000_000). 2. The prime factorization should be efficient for large integers. 3. The divisor sum calculation must handle large factor sets effectively. Input: - `n`: A positive integer. Output: - An integer representing the sum of all divisors of `n`. Example: ```python # Example 1 n = 28 result = sum_of_divisors(n) print(result) # Expected output: 56 # Explanation: 28 has divisors [1, 2, 4, 7, 14, 28] and their sum is 56. # Example 2 n = 12 result = sum_of_divisors(n) print(result) # Expected output: 28 # Explanation: 12 has divisors [1, 2, 3, 4, 6, 12] and their sum is 28. ``` Edge Cases to Consider: 1. The smallest input value (n = 1) which has exactly one divisor (itself). 2. Large prime numbers which have only two divisors (1 and the number itself). 3. Powers of a single prime (e.g., n = 2^x) which have exponentially many divisors. Good luck!","solution":"def sum_of_divisors(n: int) -> int: def prime_factors(n): factors = {} d = 2 while d * d <= n: while (n % d) == 0: if d in factors: factors[d] += 1 else: factors[d] = 1 n //= d d += 1 if n > 1: factors[n] = 1 return factors def sum_divisors_from_factors(factors): sum_divisors = 1 for p, e in factors.items(): sum_p = (p**(e+1) - 1) // (p - 1) sum_divisors *= sum_p return sum_divisors factors = prime_factors(n) return sum_divisors_from_factors(factors)"},{"question":"# Question: Text Classification Using Naive Bayes Context You need to implement a Naive Bayes classifier to predict the category of textual data. Your task involves processing the text data, computing the necessary probabilities, and classifying new text based on the trained model. This model should be able to classify short text snippets into predefined categories. Task Implement the following functions within a Python class `NaiveBayesTextClassifier`: 1. `train(self, documents, labels)`: - Train the Naive Bayes classifier using the provided training documents and their respective labels. - Input: - `documents`: List of strings, each representing a text document. - `labels`: List of integers, each representing the category of the corresponding document. - Output: None. It should update the model parameters (e.g., probabilities of words given classes and class priors). 2. `predict(self, document)`: - Predict the category of a given document using the trained Naive Bayes classifier. - Input: - `document`: String, representing the text document to classify. - Output: Integer representing the predicted category. 3. `accuracy(self, test_documents, test_labels)`: - Calculate the accuracy of the classifier on a given test set. - Input: - `test_documents`: List of strings, each representing a text document. - `test_labels`: List of integers, each representing the true category of the corresponding document. - Output: Float, the classification accuracy as the ratio of correct predictions to the total number of predictions. Constraints - Use only Python standard libraries or numpy for your implementation. - Preprocess text by converting to lowercase and splitting into words. Remove punctuation and handle empty strings appropriately. - Work with a fixed set of categories (e.g., \'sports\', \'politics\', \'technology\') represented by integer labels (e.g., 0, 1, 2). - Assume the training and test sets are non-empty and follow a consistent format. # Solution Outline ```python import numpy as np import string class NaiveBayesTextClassifier: def __init__(self): self.word_probs = {} self.class_probs = {} def preprocess(self, document): # Convert to lowercase and remove punctuation translator = str.maketrans(\'\', \'\', string.punctuation) return document.lower().translate(translator).split() def train(self, documents, labels): # Calculate class priors unique_labels = set(labels) self.class_probs = {label: labels.count(label) / len(labels) for label in unique_labels} # Calculate word probabilities given classes word_counts = {label: {} for label in unique_labels} total_words = {label: 0 for label in unique_labels} for doc, label in zip(documents, labels): words = self.preprocess(doc) for word in words: if word not in word_counts[label]: word_counts[label][word] = 0 word_counts[label][word] += 1 total_words[label] += 1 self.word_probs = {label: {word: (count + 1) / (total_words[label] + len(word_counts[label])) for word, count in word_counts[label].items()} for label in unique_labels} def predict(self, document): words = self.preprocess(document) label_scores = {label: np.log(self.class_probs[label]) for label in self.class_probs} for word in words: for label in label_scores: if word in self.word_probs[label]: label_scores[label] += np.log(self.word_probs[label][word]) else: # Apply Laplace smoothing for words not in training data label_scores[label] += np.log(1 / (sum([len(v) for k, v in self.word_probs.items()]) + len(self.word_probs[label]))) return max(label_scores, key=label_scores.get) def accuracy(self, test_documents, test_labels): correct_predictions = sum(1 for doc, label in zip(test_documents, test_labels) if self.predict(doc) == label) return correct_predictions / len(test_labels) # Sample usage: nb_classifier = NaiveBayesTextClassifier() nb_classifier.train(training_documents, training_labels) accuracy = nb_classifier.accuracy(test_documents, test_labels) ```","solution":"import numpy as np import string from collections import defaultdict class NaiveBayesTextClassifier: def __init__(self): self.word_probs = {} self.class_probs = {} def preprocess(self, document): # Convert to lowercase and remove punctuation translator = str.maketrans(\'\', \'\', string.punctuation) return document.lower().translate(translator).split() def train(self, documents, labels): # Calculate class priors unique_labels = set(labels) self.class_probs = {label: labels.count(label) / len(labels) for label in unique_labels} # Calculate word probabilities given classes word_counts = {label: defaultdict(int) for label in unique_labels} total_words = {label: 0 for label in unique_labels} for doc, label in zip(documents, labels): words = self.preprocess(doc) for word in words: word_counts[label][word] += 1 total_words[label] += 1 self.word_probs = {label: {word: (count + 1) / (total_words[label] + len(word_counts[label])) for word, count in word_counts[label].items()} for label in unique_labels} def predict(self, document): words = self.preprocess(document) label_scores = {label: np.log(self.class_probs[label]) for label in self.class_probs} for word in words: for label in label_scores: if word in self.word_probs[label]: label_scores[label] += np.log(self.word_probs[label][word]) else: # Apply Laplace smoothing for words not in training data label_scores[label] += np.log(1 / (sum([len(v) for v in self.word_probs.values()]) + len(self.word_probs[label]))) return max(label_scores, key=label_scores.get) def accuracy(self, test_documents, test_labels): correct_predictions = sum(1 for doc, label in zip(test_documents, test_labels) if self.predict(doc) == label) return correct_predictions / len(test_labels)"},{"question":"# Coding Question: Determine Optimal Delivery Route You are tasked with developing a function for a delivery company that needs to find the shortest possible route to deliver packages to a list of delivery points. The delivery point coordinates are given as (x, y) pairs on a 2D plane. Write a function `shortest_route` that takes a list of tuples `points` where each tuple represents the coordinates of a delivery point. The function should: 1. Start from the first point in the list. 2. Visit all other points exactly once. 3. Return the total distance of the shortest route that visits all points exactly once and returns to the initial point. # Example ```python >>> shortest_route([(0, 0), (1, 1), (2, 2)]) 6.828 ``` Explanation: - Starting at point (0, 0). - The shortest route visiting all points and returning to the start is (0, 0) -> (1, 1) -> (2, 2) -> (0, 0). - The distance for each segment is calculated using the Euclidean distance formula: - Distance from (0, 0) to (1, 1): sqrt((1-0) + (1-0)) = sqrt(2)  1.414 - Distance from (1, 1) to (2, 2): sqrt((2-1) + (2-1)) = sqrt(2)  1.414 - Distance from (2, 2) to (0, 0): sqrt((2-0) + (2-0)) = sqrt(8)  2.828 - Total distance: 1.414 + 1.414 + 2.828 = 5.656 # Constraints 1. The number of points will be between 1 and 10, inclusive. 2. The coordinates are integer values. 3. If there is only one point, the route distance is zero, as the delivery person starts and ends at the same point. # Input - `points`: a list of tuples, each representing a point\'s coordinates (x, y) on a 2D plane. # Output - Returns a float representing the total distance of the shortest route, rounded to three decimal places. ```python def shortest_route(points: list[tuple[int, int]]) -> float: # Your implementation here ``` You need to ensure your solution finds the shortest possible route efficiently within the given constraints and handles the precision requirements of floating-point arithmetic.","solution":"import math from itertools import permutations def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_distance(route): distance = 0.0 for i in range(len(route) - 1): distance += euclidean_distance(route[i], route[i + 1]) # Adding the return trip to the starting point distance += euclidean_distance(route[-1], route[0]) return distance def shortest_route(points): if len(points) == 1: return 0.0 min_distance = float(\'inf\') for perm in permutations(points[1:]): candidate_route = [points[0]] + list(perm) route_distance = total_distance(candidate_route) if route_distance < min_distance: min_distance = route_distance return round(min_distance, 3)"},{"question":"# Coding Assessment Question: Implementing a Shortest Path Algorithm in a Weighted Graph Scenario: You are working on a navigation system development team. Your task is to implement an algorithm that can find the shortest path in a weighted graph, which will be used to suggest the quickest route between two points. Problem Statement: Write a Python function to find the shortest path between two nodes in a weighted graph using Dijkstra\'s algorithm. The function should be efficient and handle scenarios where there are disconnected nodes and cycles. Requirements: 1. Function: `find_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]` 2. Handle edge cases such as disconnected nodes and self-loops. 3. Provide clear error messages for invalid inputs such as non-existent nodes. 4. Ensure the solution has optimal time complexity suitable for large graphs. Input: - A dictionary `graph` where keys are node identifiers and values are lists of tuples `(neighbor, weight)` representing the weighted edges. - Two integers `start` and `end` representing the starting and ending nodes. Output: - A list of integers representing the sequence of nodes forming the shortest path from `start` to `end`. Constraints: - The graph is represented as an adjacency list with non-negative weights. - The nodes are identified by unique integers starting from 0. - The number of nodes should not exceed 10,000. Example: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } start = 0 end = 3 # Shortest Path shortest_path = find_shortest_path(graph, start, end) print(shortest_path) # e.g., [0, 2, 1, 3] ``` Additional Notes: - If there is no path from `start` to `end`, the function should return an empty list. - Consider using a priority queue to optimize the performance of Dijkstra\'s algorithm. - Your solution should be able to handle large graphs efficiently within reasonable time and space limits.","solution":"import heapq from typing import Dict, List, Tuple def find_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]: Finds the shortest path in a weighted graph using Dijkstra\'s algorithm. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The ending node. :return: A list of nodes representing the shortest path from start to end. if start not in graph or end not in graph: return [] # Priority Queue: stores (distance, node) pairs priority_queue = [(0, start)] # Dictionary to keep track of the shortest path to each node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Dictionary to reconstruct the shortest path previous = {node: None for node in graph} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end: break for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Reconstruct the path path = [] current_node = end while previous[current_node] is not None: path.append(current_node) current_node = previous[current_node] if path: path.append(start) path.reverse() return path"},{"question":"# Coding Assessment Question You are given a list of integers representing the daily temperature changes over a period of days. Your task is to write a function that calculates the second highest temperature change from this list. Function Specification Function Name: `second_highest_temp_change` Parameters: - `temperatures` (list of ints): A list of integers representing daily temperature changes. Returns: - An integer that is the second highest temperature change. Constraints - The list must contain at least two unique temperature values. - The elements of the list will be integers. - In case there is no second highest value, raise a `ValueError`. Examples ```python >>> second_highest_temp_change([10, 20, 30, 40, 50]) 40 >>> second_highest_temp_change([15, 15, -10, -20, 0]) 0 >>> second_highest_temp_change([100]) ValueError: List must contain at least two unique temperature changes ``` Write the function `second_highest_temp_change` to solve the problem using the constraints and requirements provided.","solution":"def second_highest_temp_change(temperatures): Returns the second highest temperature change from the list of temperatures. Parameters: temperatures (list of ints): A list of integers representing daily temperature changes. Returns: int: The second highest temperature change. Raises: ValueError: If the list does not contain at least two unique temperature values. if len(temperatures) < 2: raise ValueError(\\"List must contain at least two unique temperature changes\\") unique_temps = list(set(temperatures)) if len(unique_temps) < 2: raise ValueError(\\"List must contain at least two unique temperature changes\\") unique_temps.sort(reverse=True) return unique_temps[1]"},{"question":"# Question: Implement a Directory Tree Traversal Description You are given the path to a directory and must implement a function that lists all files in that directory and its subdirectories. The result should include the full path to each file. The output should be sorted lexicographically by the file paths. Function Signature ```python def list_all_files(directory_path: str) -> list[str]: pass ``` Input 1. `directory_path` (str): The path to the directory to be traversed. Output - Returns a list of strings, where each string is the full path to a file found within the directory and its subdirectories. Constraints 1. The directory structure can be arbitrarily deep. 2. The total number of files and directories combined will not exceed 100,000. 3. Directory and file names will contain only printable ASCII characters. 4. Assure that the function can handle edge cases, such as empty directories and large directory structures efficiently. Example ```python directory_path = \\"/example_directory\\" # Directory structure: # /example_directory #  file1.txt #  dir1 #   file2.txt #  dir2 #  file3.txt #  dir3 #  file4.txt result = list_all_files(directory_path) print(result) # Expected output: # [ # \\"/example_directory/dir1/file2.txt\\", # \\"/example_directory/dir2/dir3/file4.txt\\", # \\"/example_directory/dir2/file3.txt\\", # \\"/example_directory/file1.txt\\" # ] ``` Notes - Ensure that the function handles both relative and absolute paths correctly. - The function should be able to safely traverse through directory structures with symbolic links, breaking potential infinite loops caused by circular references. - Provide comprehensive test cases to validate the correctness and efficiency of your implementation.","solution":"import os def list_all_files(directory_path: str) -> list[str]: Returns a list of all files in the given directory and its subdirectories. The result includes full paths to each file, sorted lexicographically. Args: directory_path (str): The path to the directory to be traversed. Returns: list[str]: A sorted list of full paths to each file. file_paths = [] for root, dirs, files in os.walk(directory_path): for name in files: file_paths.append(os.path.join(root, name)) return sorted(file_paths)"},{"question":"# Problem Statement You are given an array of strings, where each string is a sentence containing multiple words separated by spaces. Your task is to identify the longest word from each sentence and return a dictionary where each key is the index of the sentence (starting from 0) and its corresponding value is the longest word in that sentence. In case of a tie (where multiple words have the same maximum length within a sentence), return the first such word that appears. # Function Signature ```python def longest_words(sentences: List[str]) -> Dict[int, str]: ``` # Input - `sentences`: A list of sentences. Each sentence is a string containing multiple words separated by spaces. (1 <= len(sentences) <= 10^4, 1 <= len(each sentence) <= 10^5) # Output - A dictionary where keys are the indices of the sentences and values are the longest words in those sentences. # Example ```python sentences = [ \\"I love programming\\", \\"Python is great\\", \\"Find the longest word in each sentence\\" ] print(longest_words(sentences)) # Output: {0: \\"programming\\", 1: \\"Python\\", 2: \\"sentence\\"} ``` # Constraints - Words consist of only alphabetic characters and are separated by spaces. - There are no punctuation marks or special characters in the sentences. - Each sentence will contain at least one word. # Notes 1. If multiple words are of the same maximum length, the first one encountered should be chosen. 2. Ensure that your function can handle sentences of varying lengths efficiently.","solution":"from typing import List, Dict def longest_words(sentences: List[str]) -> Dict[int, str]: Function to identify the longest word from each sentence and return a dictionary where the key is the index of the sentence and the value is the longest word in that sentence. Parameters: sentences (List[str]): A list of sentences. Returns: Dict[int, str]: A dictionary mapping sentence index to its longest word. result = {} for i, sentence in enumerate(sentences): words = sentence.split() longest_word = max(words, key=len, default=\\"\\") result[i] = longest_word return result"},{"question":"# Question: Validate Brackets **Scenario:** You are developing a parser for a new programming language and need to implement a function that verifies the correct use of brackets in the code. The brackets to be considered are `()`, `{}`, and `[]`. A string containing these brackets is said to be valid if the following conditions are met: 1. Each opening bracket has a corresponding closing bracket of the same type. 2. The pairs of brackets are properly nested. **Your Task:** Write a Python function `is_valid_brackets(s: str) -> bool` that determines whether a given string `s` containing only the characters `(`, `)`, `{`, `}`, `[`, and `]` is valid based on the rules mentioned. **Function Signature:** ```python def is_valid_brackets(s: str) -> bool: pass ``` **Input and Output:** * **Input:** A string `s` containing only the characters `(`, `)`, `{`, `}`, `[`, and `]`. * **Output:** A boolean value `True` if the string is valid, `False` otherwise. **Constraints:** * The length of the input string `s` does not exceed 1000. **Requirements:** * Use a stack to check for proper nesting and matching of brackets. * Ensure efficient performance in terms of both time and space complexity. **Examples:** ```python assert is_valid_brackets(\\"()\\") == True assert is_valid_brackets(\\"()[]{}\\") == True assert is_valid_brackets(\\"(]\\") == False assert is_valid_brackets(\\"([)]\\") == False assert is_valid_brackets(\\"{[]}\\") == True assert is_valid_brackets(\\"{[()]}\\") == True assert is_valid_brackets(\\"\\") == True # An empty string is considered valid ``` **Performance:** * Your solution should run in O(n) time complexity, where `n` is the length of the input string. * The space complexity should be O(n) due to the use of a stack. **Tips:** * Think about how a stack can help match opening and closing brackets in a last-in, first-out manner. * Handle edge cases such as an empty string, which should be considered valid.","solution":"def is_valid_brackets(s: str) -> bool: # Define a dictionary for matching brackets bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} # Stack to keep track of opening brackets stack = [] # Iterate through each character in the string for char in s: if char in bracket_map: # If the character is one of the closing brackets # Pop the topmost opening bracket from the stack if available; otherwise use a dummy value top_element = stack.pop() if stack else \'#\' # Check if the popped bracket matches the corresponding opening bracket if bracket_map[char] != top_element: return False else: # Push the opening bracket to the stack stack.append(char) # In the end, the stack should be empty if all opening brackets are properly closed return not stack"},{"question":"# Coding Assessment Question Scenario You are developing a utility for processing text files of variable length. One of the functions required is to reverse the content of a specified line within the file. This functionality aims to facilitate text manipulation operations for end-users without manually altering line order or content. Task Implement a function `reverse_line(filename: str, line_number: int) -> str` that reads a file, reverses the content of the specified line, and returns the reversed line as a string. Requirements * **Input**: A string `filename` representing the path to the text file and an integer `line_number` (1  line_number) * **Output**: A string which is the content of the specified line reversed. Constraints * Ensure the input `line_number` is >= 1. If the line number is beyond the total number of lines in the file, return an empty string. * Handle edge cases where the file is empty, missing, or the line number does not exist. * Efficiently handle large files by not loading the entire file into memory when unnecessary. Example ```python # Assuming \'sample.txt\' contains: # Line 1 # This is the second line # Another line here reverse_line(\'sample.txt\', 2) # Output: \\"enil dnoces eht si sihT\\" # Another example: reverse_line(\'sample.txt\', 4) # Output: \\"\\" ``` Notes * Make sure to properly handle file opening and closing operations. * If the specified file does not exist, handle the exception and return an appropriate message or error. * Consider using efficient file reading techniques to navigate directly to the desired line number without excessive memory use.","solution":"def reverse_line(filename: str, line_number: int) -> str: Reads a file, reverses the content of the specified line, and returns the reversed line as a string. Args: filename (str): The path to the text file. line_number (int): The line number to reverse (1-based index). Returns: str: The reversed content of the specified line, or an empty string if the line does not exist. try: with open(filename, \'r\') as file: for current_line_number, line in enumerate(file, start=1): if current_line_number == line_number: return line.strip()[::-1] return \\"\\" except FileNotFoundError: return \\"File not found\\""},{"question":"# Coding Assessment Question Scenario You are creating a geometric computation library that includes various algorithms for polygon manipulation. To evaluate your understanding of polygon properties, you decide to test students on their ability to determine if a given polygon is convex. Task Implement a function `is_convex_polygon` that checks if a given polygon is convex. A polygon is convex if all its interior angles are less than 180 degrees, meaning that the polygon does not curve inward at any point. Function Signature ```python def is_convex_polygon(vertices: List[Tuple[float, float]]) -> bool: ``` Parameters - `vertices`: A list of tuples, where each tuple contains two floats representing the coordinates (x, y) of a vertex of the polygon. The vertices are given in a counterclockwise order. Requirements 1. Determine if the polygon described by the input `vertices` is convex. 2. Handle edge cases such as polygons with fewer than 3 vertices (which cannot form a valid polygon). 3. Ensure the function works for both regular and irregular polygons. Example Usage ```python vertices1 = [(0, 0), (2, 0), (2, 2), (0, 2)] print(is_convex_polygon(vertices1)) # Output: True vertices2 = [(0, 0), (2, 0), (1, 1), (2, 2), (0, 2)] print(is_convex_polygon(vertices2)) # Output: False ``` Constraints - Assume the polygon is simple (i.e., its edges do not intersect). - The vertices are given in a counterclockwise order and there are no duplicate points. Performance Requirements - The function should have a time complexity of O(n), where n is the number of vertices of the polygon. # Explanation To check if a polygon is convex, traverse each vertex and calculate the sign of the cross product between the vectors formed by adjacent sides. If all cross products have the same sign, the polygon is convex. # Test Cases Test the function with both convex and non-convex polygons to ensure it accurately identifies convex shapes.","solution":"from typing import List, Tuple def is_convex_polygon(vertices: List[Tuple[float, float]]) -> bool: def cross_product_sign(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) n = len(vertices) if n < 3: return False first_sign = 0 for i in range(n): o = vertices[i] a = vertices[(i + 1) % n] b = vertices[(i + 2) % n] cross_product = cross_product_sign(o, a, b) if i == 0: first_sign = cross_product else: if cross_product * first_sign < 0: return False return True"},{"question":"Cartesian Product of Sets You are given two sets of integers. Your task is to compute the Cartesian product of these sets. The Cartesian product of two sets `A` and `B` is defined as the set of all ordered pairs `(a, b)` where `a` is an element of `A` and `b` is an element of `B`. # Function Signature ```python def cartesian_product(setA: Set[int], setB: Set[int]) -> Set[Tuple[int, int]]: pass ``` # Input and Output * **Input**: - `setA` (type: `Set[int]`): A set of integers. - `setB` (type: `Set[int]`): A set of integers. * **Output**: - (type: `Set[Tuple[int, int]]`): The Cartesian product of `setA` and `setB`. # Constraints * Elements in input sets `setA` and `setB` are distinct. * Set `setA` and `setB` may be of different sizes. # Example ```python # Test case 1: setA = {1, 2} setB = {3, 4} # Expected output: {(1, 3), (1, 4), (2, 3), (2, 4)} print(cartesian_product(setA, setB)) # Test case 2: setA = {5} setB = {6, 7} # Expected output: {(5, 6), (5, 7)} print(cartesian_product(setA, setB)) # Test case 3: setA = {8, 9} setB = {} # Expected output: set() print(cartesian_product(setA, setB)) ``` # Note - The resulting set should not contain any duplicate pairs. - Ensure to handle cases where either input set is empty appropriately. If one or both of the input sets are empty, the Cartesian product should also be an empty set.","solution":"from typing import Set, Tuple def cartesian_product(setA: Set[int], setB: Set[int]) -> Set[Tuple[int, int]]: Returns the Cartesian product of two sets of integers. product = set() for a in setA: for b in setB: product.add((a, b)) return product"},{"question":"# Context You are designing a messaging service that needs to ensure messages are delivered in the correct order. To support this, you need to implement a function that checks if the series of messages maintain the correct chronological order, where the messages are given with their respective timestamps. # Problem Statement Implement a function `is_in_order(timestamps: list[int]) -> bool` that takes a list of timestamps and determines if they are in non-decreasing chronological order. # Input - `timestamps`: A list of integers where each integer represents the timestamp of a message received. # Output - A boolean value, `True` if the timestamps are in non-decreasing order, `False` otherwise. # Constraints 1. The list can contain up to 10^5 timestamps. 2. Timestamps are non-negative integers. 3. Each timestamp is unique in the given list. # Examples ```python >>> is_in_order([1, 2, 3, 4, 5]) True >>> is_in_order([1, 3, 2, 4, 5]) False >>> is_in_order([1]) True >>> is_in_order([]) True >>> is_in_order([3, 3, 3, 3]) True ``` # Notes - The list [1, 2, 3, 4, 5] is in strictly increasing order and thus is considered to be in non-decreasing order. - The list [1, 3, 2, 4, 5] is not in non-decreasing order because the timestamp 2 comes after 3. - Single-element lists or empty lists are trivially in order. - The list [3, 3, 3, 3] is technically not a valid input based on the constraint that each timestamp is unique, but it showcases the edge case handling of non-decreasing order. Your implementation should aim to be efficient with a time complexity of O(n).","solution":"def is_in_order(timestamps: list[int]) -> bool: Determines if the given list of timestamps is in non-decreasing order. :param timestamps: List of integers representing timestamps :return: Boolean value indicating whether timestamps are in non-decreasing order for i in range(1, len(timestamps)): if timestamps[i] < timestamps[i - 1]: return False return True"},{"question":"# Coding Assessment Question Scenario You are developing a program to analyze athletes\' performance data. One key functionality is to compute the average scores from a list of scores for each athlete. The scores are provided as a list of lists, where each sublist contains the scores of a single athlete. It is essential to ensure that only non-negative scores contribute to the average calculation, i.e., negative scores should be ignored. Task Implement a function `average_scores` that takes a list of lists, where each list contains integers representing the scores of an athlete. The function should return a list of floats, where each float is the average score of the corresponding athlete. If an athlete has no valid non-negative scores, their average should be considered as `0.0`. Input - A list of lists of integers, `scores`, where `1  len(scores)  100` and each sublist contains between `0` to `50` scores ranging from `-100` to `100`. Output - A list of floats, where each float is the average of the non-negative scores of the corresponding athlete. The averages should be rounded to two decimal places. Constraints - The input list is non-empty. - Each score can range from -100 to 100. - A sublist might be empty or contain only negative scores. Examples ```python >>> average_scores([[10, 20, 30], [5, -1, -2, 10], [100, -100, 50, 50]]) [20.0, 7.5, 75.0] >>> average_scores([[15, 25, 35], [], [-5, -10, -20]]) [25.0, 0.0, 0.0] >>> average_scores([[10, -10, 10], [5, 5, 5], [20]]) [10.0, 5.0, 20.0] >>> average_scores([[-5], [-100, -200]]) [0.0, 0.0] >>> average_scores([[0, 0, 0], [70, 30]]) [0.0, 50.0] ``` Implementation ```python def average_scores(scores): Compute the average scores for each athlete. averages = [] for athlete_scores in scores: valid_scores = [score for score in athlete_scores if score >= 0] if valid_scores: avg_score = round(sum(valid_scores) / len(valid_scores), 2) else: avg_score = 0.0 averages.append(avg_score) return averages # Sample test cases to validate your function assert average_scores([[10, 20, 30], [5, -1, -2, 10], [100, -100, 50, 50]]) == [20.0, 7.5, 75.0] assert average_scores([[15, 25, 35], [], [-5, -10, -20]]) == [25.0, 0.0, 0.0] assert average_scores([[10, -10, 10], [5, 5, 5], [20]]) == [10.0, 5.0, 20.0] assert average_scores([[-5], [-100, -200]]) == [0.0, 0.0] assert average_scores([[0, 0, 0], [70, 30]]) == [0.0, 50.0] print(\\"All tests passed!\\") ```","solution":"def average_scores(scores): Compute the average scores for each athlete. averages = [] for athlete_scores in scores: valid_scores = [score for score in athlete_scores if score >= 0] if valid_scores: avg_score = round(sum(valid_scores) / len(valid_scores), 2) else: avg_score = 0.0 averages.append(avg_score) return averages"},{"question":"# Coding Assessment Question Scenario A logistics company needs to track and manage the cargo containers at its shipping yard. Each container can be either fully loaded, partially loaded, or empty. The system should be able to calculate the total weight of all containers, identify the heaviest and lightest containers, and categorize the containers based on their weight status (fully loaded, partially loaded, or empty). Objective Implement a class `Container` and a class `Shipyard` to manage the containers effectively. Description Your task is to create a container management system consisting of the following classes: 1. **Container class**: * **Attributes**: - `id` (int): Unique identifier for the container. - `weight` (float): Current weight of the container in tons. - `capacity` (float): Maximum capacity of the container in tons. * **Methods**: - `__init__(self, id: int, weight: float, capacity: float)`: Constructor to initialize the attributes. - `status(self) -> str`: Returns the status of the container as \\"Fully Loaded\\", \\"Partially Loaded\\", or \\"Empty\\". 2. **Shipyard class**: * **Attributes**: - `containers` (list): A list to store all container objects. * **Methods**: - `__init__(self)`: Constructor to initialize the `containers` list. - `add_container(self, container: Container)`: Adds a container to the `containers` list. - `total_weight(self) -> float`: Returns the total weight of all containers. - `heaviest_container(self) -> Container`: Returns the container object with the highest weight. - `lightest_container(self) -> Container`: Returns the container object with the lowest weight. - `categorize_containers(self) -> dict`: Returns a dictionary categorizing the containers into \\"Fully Loaded\\", \\"Partially Loaded\\", and \\"Empty\\". # Input and Output - **Container class**: - `id` (int): Unique identifier of the container. - `weight` (float): Current weight of the container in tons. - `capacity` (float): Maximum capacity of the container in tons. - Method calls: - `status()`: Returns a string indicating the status of the container (\\"Fully Loaded\\", \\"Partially Loaded\\", or \\"Empty\\"). - **Shipyard class**: - Method calls: - `add_container(container)`: Adds a container object to the list of containers. - `total_weight()`: Returns the total weight of all containers as a float. - `heaviest_container()`: Returns the container object with the heaviest weight. - `lightest_container()`: Returns the container object with the lightest weight. - `categorize_containers()`: Returns a dictionary with keys \\"Fully Loaded\\", \\"Partially Loaded\\", and \\"Empty\\", and values as lists of container objects. # Example ```python # Create container objects container1 = Container(1, 15, 20) container2 = Container(2, 20, 20) container3 = Container(3, 0, 20) # Create a Shipyard object shipyard = Shipyard() # Add containers to the shipyard shipyard.add_container(container1) shipyard.add_container(container2) shipyard.add_container(container3) # Get total weight of shipments print(shipyard.total_weight()) # Output: 35.0 # Get the heaviest and lightest containers print(shipyard.heaviest_container().id) # Output: 2 print(shipyard.lightest_container().id) # Output: 3 # Categorize containers categorized = shipyard.categorize_containers() print([container.id for container in categorized[\\"Fully Loaded\\"]]) # Output: [2] print([container.id for container in categorized[\\"Partially Loaded\\"]]) # Output: [1] print([container.id for container in categorized[\\"Empty\\"]]) # Output: [3] ``` # Implementation Details You should implement both classes and their methods to efficiently manage and categorize the containers based on their weights and capacities.","solution":"class Container: def __init__(self, id: int, weight: float, capacity: float): Initializes a container with given id, weight and capacity. self.id = id self.weight = weight self.capacity = capacity def status(self) -> str: Returns the status of the container: \\"Fully Loaded\\", \\"Partially Loaded\\", or \\"Empty\\". if self.weight == 0: return \\"Empty\\" elif self.weight == self.capacity: return \\"Fully Loaded\\" else: return \\"Partially Loaded\\" class Shipyard: def __init__(self): Initializes a Shipyard with an empty list of containers. self.containers = [] def add_container(self, container: Container): Adds a container to the shipyard. self.containers.append(container) def total_weight(self) -> float: Returns the total weight of all containers in the shipyard. return sum(container.weight for container in self.containers) def heaviest_container(self) -> Container: Returns the container with the highest weight. return max(self.containers, key=lambda container: container.weight) def lightest_container(self) -> Container: Returns the container with the lowest weight. return min(self.containers, key=lambda container: container.weight) def categorize_containers(self) -> dict: Categorizes the containers into \\"Fully Loaded\\", \\"Partially Loaded\\", and \\"Empty\\". categories = { \\"Fully Loaded\\": [], \\"Partially Loaded\\": [], \\"Empty\\": [] } for container in self.containers: status = container.status() categories[status].append(container) return categories"},{"question":"# Context You have been provided with a partial test suite for a custom implementation of a `Queue` using a singly linked list. The `Queue` should support common queue operations such as enqueue, dequeue, and checking if the queue is empty. # Task You are required to implement the `Queue` class that should pass the provided tests. Make sure the internal data structure accurately represents a queue and handles edge cases appropriately. # Requirements 1. **Constructor**: `Queue()` initializes an empty queue. 2. **Methods**: * `enqueue(self, value)`: Adds the value to the end of the queue. * `dequeue(self)`: Removes and returns the value from the front of the queue. If the queue is empty, raise an appropriate exception (e.g., `IndexError`). * `is_empty(self)`: Returns `True` if the queue is empty, otherwise `False`. * `peek(self)`: Returns the value at the front of the queue without removing it. If the queue is empty, raise an appropriate exception (e.g., `IndexError`). 3. **Constraints**: - Implement the queue using a singly linked list. - Ensure all operations can handle edge cases such as operations on an empty queue. - Maintain efficient performance for queue operations. # Example ```python # Example with basic operations q = Queue() assert q.is_empty() == True q.enqueue(1) q.enqueue(2) assert q.peek() == 1 assert q.is_empty() == False assert q.dequeue() == 1 assert q.dequeue() == 2 try: q.dequeue() except IndexError: pass # Expected behavior, as the queue is empty try: q.peek() except IndexError: pass # Expected behavior, as the queue is empty ``` You should ensure your implementation passes all the tests outlined in the provided test suite.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class Queue: def __init__(self): self.front = None self.rear = None def enqueue(self, value): new_node = Node(value) if self.rear is None: self.front = self.rear = new_node return self.rear.next = new_node self.rear = new_node def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") temp = self.front self.front = temp.next if self.front is None: self.rear = None return temp.value def is_empty(self): return self.front is None def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty queue\\") return self.front.value"},{"question":"**Context**: You are working on a simulated traffic control system that requires managing and maintaining a priority queue of vehicles at a busy intersection. Each vehicle is assigned a unique priority number, with lower numbers having higher priority. **Task**: Write a Python class that represents a priority queue for this traffic control system. Implement methods to add a vehicle to the queue, remove the highest priority vehicle, and retrieve the current highest priority vehicle without removal. **Requirements**: - Write a class `PriorityQueue` that: - Initializes with an empty priority queue. - Implements a `push` method to add a vehicle with a given priority. - Implements a `pop` method to remove and return the highest priority vehicle. - Implements a `peek` method to return the highest priority vehicle without removing it. **Function Signatures**: ```python class PriorityQueue: def __init__(self) -> None: ... def push(self, vehicle: str, priority: int) -> None: ... def pop(self) -> str: ... def peek(self) -> str: ... ``` **Input Format**: - `vehicle`: A string representing a vehicle identifier (e.g., \\"Car1\\", \\"Truck2\\"). - `priority`: An integer representing the priority of the vehicle, where a lower number means higher priority. **Output Format**: - For `pop`: A string representing the vehicle identifier of the highest priority vehicle. - For `peek`: A string representing the vehicle identifier of the highest priority vehicle. - If the queue is empty and `pop` or `peek` are called, raise an `IndexError`. **Example**: ```python pq = PriorityQueue() pq.push(\\"Car1\\", 5) pq.push(\\"Truck1\\", 1) pq.push(\\"Car2\\", 3) print(pq.peek()) # Output: \\"Truck1\\" print(pq.pop()) # Output: \\"Truck1\\" print(pq.pop()) # Output: \\"Car2\\" pq.push(\\"Bike1\\", 2) print(pq.peek()) # Output: \\"Bike1\\" ``` **Constraints**: - Priority values are non-negative integers. - Each vehicle identifier is unique in the queue at any given time. - Efficient handling for up to thousands of vehicles. - Must adhere to O(log n) time complexity for the `push` and `pop` operations due to the properties of priority queues. **Performance Notes**: - Your implementation should use an appropriate data structure to efficiently maintain the priority queue (e.g., a heap).","solution":"import heapq class PriorityQueue: def __init__(self) -> None: self._queue = [] self._index = 0 def push(self, vehicle: str, priority: int) -> None: heapq.heappush(self._queue, (priority, self._index, vehicle)) self._index += 1 def pop(self) -> str: if self.is_empty(): raise IndexError(\\"The priority queue is empty.\\") return heapq.heappop(self._queue)[2] def peek(self) -> str: if self.is_empty(): raise IndexError(\\"The priority queue is empty.\\") return self._queue[0][2] def is_empty(self) -> bool: return len(self._queue) == 0"},{"question":"**Task:** Design a function that generates a unique identifier for filenames based on their content using a custom hash function. # Scenario You are working on a file storage system that relies heavily on unique identifiers for managing files. To avoid collisions, you need to generate a unique hash value based on the file content. You will implement a custom hash function that incorporates various elements of the file content while adhering to specific constraints and parameters. # Implementation Write a function called `file_content_hash` with the following signature: ```python def file_content_hash(filename: str, salt: int = 2023, normalize_whitespace: bool = False) -> int: Computes a hash value for a file\'s content with optional enhancements. Parameters: - filename (str): The name of the file whose content is to be hashed. - salt (int): An additional integer to mix into the hash to provide better distribution (default is 2023). - normalize_whitespace (bool): If True, multiple consecutive whitespace characters (including newlines) are treated as a single space (default is False). Returns: - int: The computed hash value within the range of a 32-bit unsigned integer. ``` # Requirements 1. Read the content of the file specified by `filename`. 2. Implement a hashing mechanism that incorporates the content of the file and an additional salt value. 3. If `normalize_whitespace` is True, any sequence of whitespace characters in the file content should be treated as a single space character when hashing. 4. Return the final hash value as a 32-bit unsigned integer. 5. Handle file reading issues gracefully, such as file not found or read error exceptions. # Constraints - File contents are expected to be text and can include Unicode characters. - The salt value should be a positive integer. - The function should run efficiently even for large files, ideally maintaining O(n) time complexity relative to file size. # Example Usage ```python print(file_content_hash(\'example.txt\')) # Hash value based on the content of \'example.txt\' print(file_content_hash(\'example.txt\', normalize_whitespace=True)) # Same content, but with normalized whitespace print(file_content_hash(\'example.txt\', salt=12345)) # Same file but with a different salt value print(file_content_hash(\'anotherfile.txt\')) # Hash value for a different file print(file_content_hash(\'nonexistent.txt\')) # Should handle file not found gracefully ``` # Notes - Make sure to thoroughly test your function with various file contents, sizes, and configurations of the parameters. - Discuss any assumptions made or limitations encountered during the implementation.","solution":"import os def file_content_hash(filename: str, salt: int = 2023, normalize_whitespace: bool = False) -> int: Computes a hash value for a file\'s content with optional enhancements. Parameters: - filename (str): The name of the file whose content is to be hashed. - salt (int): An additional integer to mix into the hash to provide better distribution (default is 2023). - normalize_whitespace (bool): If True, multiple consecutive whitespace characters (including newlines) are treated as a single space (default is False). Returns: - int: The computed hash value within the range of a 32-bit unsigned integer. def normalize_spaces(content: str) -> str: import re # Replace sequences of whitespace with a single space return re.sub(r\'s+\', \' \', content) try: with open(filename, \'r\', encoding=\'utf-8\') as file: content = file.read() if normalize_whitespace: content = normalize_spaces(content) # Incorporate each character\'s Unicode code point and the salt into the hash hash_value = salt for character in content: hash_value = (hash_value * 31 + ord(character)) & 0xFFFFFFFF return hash_value except (FileNotFoundError, IOError): # Handle errors gracefully, return a specific hash code indicating failure return 0xFFFFFFFF"},{"question":"# Coding Question Context A famous computer scientist has recently developed a new sorting algorithm called \\"MagicSort\\". It uses a hybrid approach combining both quicksort and mergesort to achieve excellent performance for a wide range of data sizes and distributions. One unique aspect of MagicSort is its handling of duplicate values - they are magically sorted in a non-standard way. However, your task today is simpler. You need to implement a helper function for the MagicSort algorithm which removes all duplicates from a given list while maintaining the original order of the first occurrences of each value. Task Write a function `remove_duplicates(arr: List[int]) -> List[int]` that takes in a list of integers and returns a new list with duplicates removed, preserving the order of their first occurrence. # Function Signature ```python from typing import List def remove_duplicates(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers where each integer is in the range -10^6 to 10^6 and the length of the list is between 1 and 10^6. # Output - A list of integers with all duplicates removed, retaining only the first occurrence of each value. # Example ```python arr = [4, 5, 6, 4, 7, 5, 8, 9] output = remove_duplicates(arr) print(output) # Output should be [4, 5, 6, 7, 8, 9] arr = [1, 2, 2, 3, 3, 3, 4] output = remove_duplicates(arr) print(output) # Output should be [1, 2, 3, 4] ``` The function `remove_duplicates` should efficiently remove all duplicates from the input list while preserving the order of the first occurrence of each value.","solution":"from typing import List def remove_duplicates(arr: List[int]) -> List[int]: seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Coding Question: Managing Restaurant Orders Background A restaurant receives numerous orders during its business hours. Each order can be served within a specific time frame and provides different amounts of tip. The restaurant can only serve one order at a time, and thus the goal is to maximize the total tips earned by serving the optimal set of orders. Objective Write a function `max_tips(orders: list, tips: list, serve_time: list) -> int` that calculates the maximum tips the restaurant can earn based on the constraints. Input * A list of strings `orders` representing the unique IDs of the orders. * A list of integers `tips` where each integer represents the tip amount corresponding to each order. * A list of tuples `serve_time` where each tuple consists of two integers, the start time and end time, representing the time frame when the order can be served. Output * Return an integer representing the maximum tips that can be earned by optimally scheduling the orders. Constraints * The lengths of `orders`, `tips`, and `serve_time` are the same. * All elements in the `tips` list are non-negative. * The serve times are represented in a 24-hour format. Example ```python >>> max_tips([\\"A\\", \\"B\\", \\"C\\"], [100, 200, 150], [(1, 4), (2, 6), (5, 8)]) 300 >>> max_tips([\\"D\\", \\"E\\", \\"F\\"], [500, 100, 250], [(3, 5), (0, 2), (1, 7)]) 500 ``` Notes * The use of dynamic programming or greedy algorithms is recommended to achieve an optimal solution. * Ensure to handle edge cases such as: * Overlapping serve times where not all orders can be served. * Empty order, tips, or serve_time lists and logically handling them through appropriate error messages. Edge Cases * If any list (orders, tips, or serve_time) is empty, or contains non-positive values (except 0 for tips), the function should raise appropriate error messages. Validation In addition to the above cases, your solution should run efficiently for a large number of orders (up to 10^5).","solution":"def max_tips(orders, tips, serve_time): This function calculates the maximum tips the restaurant can earn based on the constraints of overlapping serve times. :param orders: List of strings representing unique order IDs. :param tips: List of integers representing the tip amounts. :param serve_time: List of tuples of two integers representing serve times. :return: Maximum tips that can be earned. if not orders or not tips or not serve_time: return 0 # Combining the orders\' information combined = list(zip(orders, tips, serve_time)) # Sorting orders based on end time for optimal scheduling combined.sort(key=lambda x: x[2][1]) # Initialize dp array where dp[i] represents the maximum tips # we can get from first i orders considering the constraints dp = [0] * len(combined) dp[0] = combined[0][1] for i in range(1, len(combined)): current_tip = combined[i][1] non_conflicting_tip = 0 for j in range(i-1, -1, -1): if combined[j][2][1] <= combined[i][2][0]: non_conflicting_tip = dp[j] break dp[i] = max(dp[i-1], current_tip + non_conflicting_tip) return dp[-1]"},{"question":"# Estimating Fibonacci Numbers (Efficiently) You are required to write a function to compute the nth Fibonacci number using an efficient approach. The Fibonacci sequence is defined as follows: [ F_0 = 0 ] [ F_1 = 1 ] [ F_{i} = F_{i-1} + F_{i-2} quad text{for} quad i geq 2 ] # Function Signature ```python def fibonacci_efficient(n: int) -> int: pass ``` # Input: * An integer `n` (0  n  10^5) # Output: * An integer, which is the nth Fibonacci number. # Constraints: * The input `n` will always be a non-negative integer within the specified range. * Your solution should handle very large values of `n` efficiently. # Example: ```python >>> fibonacci_efficient(0) 0 >>> fibonacci_efficient(1) 1 >>> fibonacci_efficient(10) 55 >>> fibonacci_efficient(50) 12586269025 ``` # Requirements: 1. Your algorithm should handle large values of `n` efficiently. 2. You should ensure that the computation is done in an optimal time complexity. 3. The function should compute the result using an iterative approach or optimized matrix exponentiation to ensure it runs in logarithmic time. # Scenario: The Fibonacci sequence is widely used in computer science and mathematical theories. Efficient computation of Fibonacci numbers is vital for applications such as algorithm design, dynamic programming, and financial modeling. **Performance Consideration**: Given the potentially large values for `n`, ensure that your algorithm can handle them efficiently, ideally in (O(log n)) time complexity using matrix exponentiation. --- This question aligns with the style, length, and complexity of the sample provided, ensuring it could seamlessly fit into the same assessment while testing similar algorithmic problem-solving skills.","solution":"def fibonacci_efficient(n: int) -> int: Returns the nth Fibonacci number. Uses matrix exponentiation to achieve optimal time complexity of O(log n). if n == 0: return 0 if n == 1: return 1 def multiply_matrices(a, b): return [[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]], [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power: if power % 2: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result fibonacci_matrix = [[1, 1], [1, 0]] result_matrix = matrix_power(fibonacci_matrix, n - 1) return result_matrix[0][0]"},{"question":"# Question Context You are tasked with designing a function that determines if it is possible to traverse from the top-left corner to the bottom-right corner of a matrix by moving only through specific values. Given a matrix of integers and a target value, write a function `can_traverse(matrix: List[List[int]], target: int) -> bool` that returns `True` if there exists a path from the top-left to the bottom-right corner, moving only through cells containing the target value, and `False` otherwise. Function Signature ```python Function to determine if a path exists from the top-left to the bottom-right corner of a matrix. :param matrix: A 2D list of integers. :param target: Target integer value allowed for traversal. :return: Boolean indicating existence of the path. def can_traverse(matrix: List[List[int]], target: int) -> bool: pass ``` Constraints * The matrix will be a non-empty list of lists with integers. * The matrix dimensions are within feasible computational limits (e.g., up to 200x200). * The traversal can only move up, down, left, or right. Example ```python # Example Usage matrix = [ [1, 2, 1], [1, 1, 2], [2, 1, 1] ] print(can_traverse(matrix, 1)) # Output: True matrix = [ [1, 2, 3], [4, 1, 5], [6, 7, 1] ] print(can_traverse(matrix, 1)) # Output: False ``` Notes * Implement breadth-first search (BFS) or depth-first search (DFS) to explore viable paths in the matrix. * Ensure your solution considers edge cases such as blocked paths or minimal matrix dimensions. * Optimize for time and space complexity, considering matrix size constraints.","solution":"from typing import List def can_traverse(matrix: List[List[int]], target: int) -> bool: Function to determine if a path exists from the top-left to the bottom-right corner of a matrix. :param matrix: A 2D list of integers. :param target: Target integer value allowed for traversal. :return: Boolean indicating existence of the path. if not matrix or matrix[0][0] != target or matrix[-1][-1] != target: return False rows, cols = len(matrix), len(matrix[0]) visited = [[False] * cols for _ in range(rows)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and matrix[x][y] == target and not visited[x][y] def bfs(): from collections import deque queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == rows - 1 and y == cols - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): visited[nx][ny] = True queue.append((nx, ny)) return False return bfs()"},{"question":"Coding Challenge: Shortest Path Calculation in a Weighted Grid # Objective: You are required to write a function that, given a grid of integers, calculates the shortest path from the top-left corner to the bottom-right corner. The weight of the path is the sum of the integers in each cell along the path. # Problem Description: You are given a grid of integers, where each cell contains a positive integer representing the cost to enter that cell. The goal is to move from the top-left cell to the bottom-right cell in such a way that the total cost is minimized. You can only move to the right or down from any cell. # Function Specification: Implement the following function: ```python def min_path_sum(grid: List[List[int]]) -> int: Calculate the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each step can either go to the right or down. Parameters: grid (List[List[int]]): A 2D list of positive integers representing the cost grid. Returns: int: The minimum path sum to travel from the top-left to the bottom-right corner. pass ``` # Input: * `grid`: A list of lists of integers representing the cost grid (1  len(grid)  100, 1  len(grid[0])  100, 1  grid[i][j]  100). # Output: * Returns an integer representing the minimum path sum. # Example: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(grid)) # Expected output: 7 grid = [ [1, 2, 3], [4, 5, 6] ] print(min_path_sum(grid)) # Expected output: 12 ``` # Constraints: * You may assume the answer can be represented within the range of an integer in Python. * The grid has at least one cell. # Additional Notes: * The path must start at the top-left corner (grid[0][0]) and end at the bottom-right corner (grid[-1][-1]). * You can only move right or down at any point in time. # Guideline: * Use dynamic programming to build up the solution. * Create a 2D DP array where each entry dp[i][j] represents the minimum path sum to reach cell (i, j). * Initialize the DP array with the values from the grid, and then iterate through to update the DP array with minimum sums. * The final answer will be in dp[-1][-1], representing the bottom-right corner of the grid. Good luck!","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Calculate the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each step can either go to the right or down. Parameters: grid (List[List[int]]): A 2D list of positive integers representing the cost grid. Returns: int: The minimum path sum to travel from the top-left to the bottom-right corner. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize DP array with the same dimensions as the grid dp = [[0] * cols for _ in range(rows)] # Set the start point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for col in range(1, cols): dp[0][col] = dp[0][col - 1] + grid[0][col] # Fill the first column (can only come from above) for row in range(1, rows): dp[row][0] = dp[row - 1][0] + grid[row][0] # Fill the rest of the DP table for row in range(1, rows): for col in range(1, cols): dp[row][col] = min(dp[row - 1][col], dp[row][col - 1]) + grid[row][col] return dp[-1][-1]"},{"question":"# Coding Assessment Question **Problem Statement:** Implement a function to perform matrix multiplication without using any external libraries. You are given two matrices (A) and (B) and you need to return their product (C). Matrix (A) is of size (m times n) and matrix (B) is of size (n times p). The resulting matrix (C) will be of size (m times p). **Function Signature:** ```python def matrix_multiplication( matrix_a: List[List[float]], matrix_b: List[List[float]] ) -> List[List[float]]: pass ``` **Input:** * `matrix_a`: A 2D list of floats representing the matrix (A) with dimensions ([m times n]). * `matrix_b`: A 2D list of floats representing the matrix (B) with dimensions ([n times p]). **Output:** * A 2D list of floats representing the product matrix (C) with dimensions ([m times p]). **Constraints:** * The dimensions of (A) and (B) will ensure they can be multiplied (i.e., the number of columns in (A) will equal the number of rows in (B)). * All dimensions will be bounded by (1) to (50). * Each element in the matrices will be a float within the range ([-1000.0, 1000.0]). **Example:** ```python matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] print(matrix_multiplication(matrix_a, matrix_b)) # Expected Output: [[58, 64], [139, 154]] ``` **Explanation:** The function should compute the matrix product by iteratively summing up the products of corresponding elements from rows of (A) and columns of (B) and store the results in the resultant matrix (C). **Notes:** * Ensure efficient iteration over matrix elements. * Validate matrix dimensions before computation. * Properly handle edge cases, such as matrices with minimal dimensions.","solution":"from typing import List def matrix_multiplication(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: # Get dimensions of input matrices m = len(matrix_a) n = len(matrix_a[0]) p = len(matrix_b[0]) # Initialize result matrix with zeros of size m x p result = [[0.0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Coding Question: Maximum Length of Pair Chain Context You are given a list of pairs of integers. Each pair ((a, b)) consists of two integers where (a < b). You need to find the longest chain of pairs that can be formed. A pair ((c, d)) can follow a pair ((a, b)) if and only if (b < c). Task Write a Python function `find_longest_chain(pairs: List[Tuple[int, int]]) -> int` that takes a list of pairs of integers and returns the length of the longest chain that can be formed. Input * A list `pairs` of tuples where each tuple contains two integers and is of the form ((a, b)). Each tuple satisfies the condition (a < b). Output * An integer representing the length of the longest chain of pairs that can be formed. Example ```python def find_longest_chain(pairs: List[Tuple[int, int]]) -> int: # Your code here # Test Cases print(find_longest_chain([(1, 2), (2, 3), (3, 4)])) # Output: 2 print(find_longest_chain([(1, 2), (7, 8), (4, 5)])) # Output: 3 print(find_longest_chain([(5, 24), (15, 25), (27, 40), (50, 60)])) # Output: 3 ``` Constraints - Each pair ((a, b)) satisfies (a < b). - The function should handle any reasonable number of pairs such as (0 leq text{len(pairs)} leq 1000). Write a solution implementing a sorting strategy first and then using dynamic programming or greedy approach to form the maximum length chain. Ensure your function is tested thoroughly to handle various edge cases including the smallest input sizes. Focus on achieving an efficient and clear implementation.","solution":"from typing import List, Tuple def find_longest_chain(pairs: List[Tuple[int, int]]) -> int: # Sort pairs based on the second value of the pairs pairs.sort(key=lambda x: x[1]) # Initialize variables to track the length of the chain and the end of the last added pair max_chain_length = 0 last_end = float(\'-inf\') for a, b in pairs: if a > last_end: # If the current pair can be added to the chain, update the last_end and increment the chain length last_end = b max_chain_length += 1 return max_chain_length"},{"question":"# Coding Assessment Question You are provided with a problem that involves analyzing data patterns within an array and efficiently determining specific subgroup characteristics. Your task is to implement a solution that adheres to the requirements outlined below. # Problem Statement Implement a function `find_maximum_subarray_sum(arr: list[int], k: int) -> int` which aims to find the maximal sum of a subarray with a length exactly `k`. Your function should address the following criteria: 1. Handle cases where the array may contain negative numbers. 2. Optimize the approach to accommodate large datasets and ensure efficient computation. 3. Validate the input to handle cases where `k` might be non-positive or greater than the length of the array seamlessly. # Input * `arr`: A list of integers representing the array to analyze. * `k`: An integer representing the exact length of the subarray. # Output * An integer representing the maximal sum of any subarray with a length of exactly `k`. # Constraints * The length of `arr` will be between 1 and (10^6). * The elements of `arr` will be in the range of [-(10^9), (10^9)]. * The value of `k` will be a positive integer. # Example Cases Example 1 ```python arr = [1, 2, 3, -2, 5] k = 3 assert find_maximum_subarray_sum(arr, k) == 6 # The subarray [1, 2, 3] has the maximum sum of 6 ``` Example 2 ```python arr = [-1, -2, -3, -4, -5] k = 2 assert find_maximum_subarray_sum(arr, k) == -3 # The subarray [-1, -2] has the least negative sum of -3 ``` Example 3 ```python arr = [4, 5, -1, 7, 8] k = 1 assert find_maximum_subarray_sum(arr, k) == 8 # The subarray [8] alone has the maximum sum of 8 ``` Example 4 ```python arr = [1, 2, 3, 4, 5] k = 5 assert find_maximum_subarray_sum(arr, k) == 15 # The entire array [1, 2, 3, 4, 5] is the subarray of length 5 with sum 15 ``` Example 5 ```python arr = [1] k = 1 assert find_maximum_subarray_sum(arr, k) == 1 # The subarray [1] alone has the sum of 1 ``` # Additional Notes: 1. Ensure the function checks the validity of `k` and handles scenarios where `k` is larger than the length of `arr` robustly. 2. The function should be implemented to run in linear time complexity to handle large arrays efficiently. --- This question aims to test the candidate\'s understanding of sliding window techniques and efficiency in handling large datasets with potential negative values within arrays.","solution":"def find_maximum_subarray_sum(arr: list[int], k: int) -> int: Finds the maximum sum of a subarray with length exactly k. if k <= 0 or k > len(arr): raise ValueError(\\"k should be a positive integer less than or equal to the length of the array\\") max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum = current_sum + arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Find All Duplicates in an Array Using Constant Space # Context: In software development, identifying duplicate entries can be crucial for data integrity and optimization. You are provided with an integer array where each element appears either once or twice. Your task is to find all the elements that appear twice. The array has a special constraint: it runs from 1 to `n` where `n` is the length of the array. Solve this problem in constant space without using extra data structures, and in O(n) time complexity. # Task: Implement a function `find_duplicates(nums: List[int]) -> List[int]` that returns a list of all duplicate numbers in the array `nums`, without using extra storage, apart from the output list. # Function Signature: ```python def find_duplicates(nums: List[int]) -> List[int]: ``` # Input: * **nums (List[int])**: Array of integers of length `n`, (1 le n leq 10^5), where each integer (1 leq nums[i] leq n). # Output: * **List[int]**: A list containing all duplicate numbers in the array. The order of duplicates in the output does not matter. # Constraints: * Each element in the array appears either once or twice. * No element appears more than twice. # Example: ```python assert find_duplicates([4,3,2,7,8,2,3,1]) == [2, 3] assert find_duplicates([1,1,2]) == [1] assert find_duplicates([1]) == [] ``` # Notes: Use the fact that the numbers are within the range `1` to `n`. This allows you to use the indices of the array to track which numbers have been seen. A common technique involves marking visited numbers by negating the number at the index of the absolute value of the current number (minus one). Ensure your solution does not exceed the allowed time complexity and that it uses only constant extra space aside from the output list.","solution":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(index + 1) else: nums[index] = -nums[index] return duplicates"},{"question":"Frequency Counting Task # Objective You are tasked with implementing a function to count the frequency of each element in a list and then return a sorted list of tuples based on frequency in descending order. If two elements have the same frequency, sort them in ascending order of their values. # Problem Statement Write a function `frequency_sort(input_list: list[int]) -> list[tuple[int, int]]` to count the frequency of each element in the input list and return a sorted list of tuples where each tuple contains an element and its frequency. # Implementation Details 1. **Input**: A list of integers. 2. **Output**: A list of tuples where each tuple consists of an element and its frequency, sorted by frequency in descending order, and by value in ascending order if frequencies are the same. # Function Signature ```python def frequency_sort(input_list: list[int]) -> list[tuple[int, int]]: pass ``` # Constraints 1. The input list can contain negative and positive integers. 2. Ensure the function operates efficiently, adhering to O(n log n) complexity where possible. # Example ```python example1 = [1, 3, 2, 2, 1, 2, 4, 1] example2 = [4, 4, 1, -1, 2, 3, 3, -1, -1] assert frequency_sort(example1) == [(1, 3), (2, 3), (3, 1), (4, 1)] assert frequency_sort(example2) == [(-1, 3), (4, 2), (3, 2), (1, 1), (2, 1)] ``` # Description The function `frequency_sort` follows these steps: 1. **Count Frequencies**: Use a dictionary to count the frequency of each element in the input list. 2. **Create Tuples**: Form a list of tuples from the dictionary, each containing an element and its frequency. 3. **Sort Tuples**: Sort the list of tuples first by frequency in descending order and then by elements in ascending order for those with the same frequency. # Notes - Handle edge cases like an empty list, and a list with only one unique element. - Python\'s `collections.Counter` may be useful for frequency counting. Ensure that your implementation passes all given test cases and performs efficiently for larger lists.","solution":"def frequency_sort(input_list: list[int]) -> list[tuple[int, int]]: from collections import Counter # Count the frequency of each element in input_list freq_count = Counter(input_list) # Create a list of tuples (element, frequency) freq_list = list(freq_count.items()) # Sort the list by frequency in descending order and by value in ascending order for equal frequencies sorted_list = sorted(freq_list, key=lambda x: (-x[1], x[0])) return sorted_list"},{"question":"# Question You are tasked with developing an optimized implementation for a financial portfolio\'s risk assessment model. You are provided with a class `Portfolio`, which currently supports basic financial metrics calculation for stocks in the portfolio. # Requirements Write a new method `calculate_var` in the given `Portfolio` class. This method should: 1. **Compute Value at Risk (VaR)** using the historical simulation method. 2. **Estimate the potential loss** with a given confidence level. 3. **Refine the calculation** by bootstrapping the historical returns to ensure robustness. # Function Signature ```python def calculate_var(self, confidence_level: float = 0.95, num_bootstraps: int = 1000) -> float: Calculate the Value at Risk (VaR) using bootstrapped historical returns. Args: confidence_level: The confidence level for VaR (default 0.95). num_bootstraps: Number of bootstrap samples to use for estimation (default 1000). Returns: Value at Risk at the specified confidence level. Example: >>> portfolio = Portfolio([100, 200, 300], [0.01, 0.015, -0.005]) >>> portfolio.calculate_var(0.99, 500) # doctest: +ELLIPSIS -3.0... pass ``` # Constraints 1. The method should use historical return data stored in the portfolio to estimate VaR. 2. Historical returns are provided during the `Portfolio` initialization. 3. Ensure bootstrapped samples are sufficient to provide a stable VaR estimate. # Input * `confidence_level`: A float between 0 and 1, representing the VaR confidence level. * `num_bootstraps`: An integer, representing the number of bootstrap samples to use for estimation. # Output * A float representing the Value at Risk at the specified confidence level. # Assumptions 1. The historical return data of each stock in the portfolio is valid and can be evaluated. 2. Adequate historical data is given for bootstrapping and calculations. 3. The function is to be used for percentages (return values) rather than absolute values. # Scenarios The implementation will be challenged to: 1. Efficiently handle a large number of bootstrap samples for accurate estimation. 2. Ensure the robustness of VaR calculations in varying market conditions. 3. Maintain consistency in handling inputs and edge cases like insufficient historical data.","solution":"import numpy as np class Portfolio: def __init__(self, values, returns): Initialize the portfolio with stock values and historical returns. Args: values: List of the current values of the stocks in the portfolio. returns: List of historical return data for the stocks in the portfolio. self.values = values self.returns = returns def calculate_var(self, confidence_level: float = 0.95, num_bootstraps: int = 1000) -> float: Calculate the Value at Risk (VaR) using bootstrapped historical returns. Args: confidence_level: The confidence level for VaR (default 0.95). num_bootstraps: Number of bootstrap samples to use for estimation (default 1000). Returns: Value at Risk at the specified confidence level. # Aggregate portfolio returns portfolio_returns = np.sum(np.array(self.returns) * np.array(self.values), axis=1) # Initiate an empty list to store simulated VaR values bootstrapped_vars = [] for _ in range(num_bootstraps): bootstrapped_sample = np.random.choice(portfolio_returns, size=len(portfolio_returns), replace=True) sorted_sample = np.sort(bootstrapped_sample) var_index = int((1 - confidence_level) * len(sorted_sample)) var = sorted_sample[var_index] bootstrapped_vars.append(var) # Calculate the average VaR from the bootstrapped samples final_var = np.mean(bootstrapped_vars) return final_var"},{"question":"**Context**: As part of a data processing pipeline, you need to implement a function that merges multiple sorted lists into one sorted list. This is a common task in scenarios like merging search results from different sources, combining sorted logs, etc. **Task**: Write a function `merge_k_sorted_lists` that merges `k` sorted lists into one sorted list. Use an efficient approach to perform the merge. # Function Signature ```python def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: pass ``` # Input * `lists`: A list of `k` sorted lists, where each list is sorted in non-decreasing order. # Output * Returns a single merged sorted list containing all the elements from the input lists. # Constraints * 0  len(lists)  10^4 * 0  len(lists[i])  10^3 * -10^6  lists[i][j]  10^6 * If `len(lists) == 0`, return an empty list. # Performance Requirement * The implementation should strive for a time complexity of (O(N log{k})), where (N) is the total number of elements across all lists. # Example ```python assert merge_k_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) == [1, 1, 2, 3, 4, 4, 5, 6] assert merge_k_sorted_lists([[], [1, 3, 4], [], [2, 6, 8]]) == [1, 2, 3, 4, 6, 8] assert merge_k_sorted_lists([[], [], []]) == [] assert merge_k_sorted_lists([[1, 2, 3]]) == [1, 2, 3] ``` Implement the `merge_k_sorted_lists` function such that it efficiently merges the `k` sorted input lists into a single sorted list.","solution":"from heapq import heappush, heappop from typing import List def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: Merges k sorted lists into one sorted list. min_heap = [] result = [] # Initialize the heap with the first element of each list. for index, lst in enumerate(lists): if lst: heappush(min_heap, (lst[0], index, 0)) while min_heap: # Extract the smallest element from heap val, list_index, element_index = heappop(min_heap) result.append(val) # If there are more elements in the same list, push the next element to the heap if element_index + 1 < len(lists[list_index]): next_tuple = (lists[list_index][element_index + 1], list_index, element_index + 1) heappush(min_heap, next_tuple) return result"},{"question":"# Detect Cycles in a Directed Graph You\'re tasked with developing a routine for detecting cycles in a directed graph representing various project dependencies. This is crucial to ensure there are no circular dependencies before a project is executed. **Objective**: Implement a robust `Graph` class to handle nodes and edges, with a method to detect cycles. **Requirements**: 1. **Initialization**: * Accept an integer `n` representing the number of nodes, and a list of tuples representing directed edges `(src, dst)`. 2. **Methods**: - `add_edge(src: int, dst: int) -> None`: * Add a directed edge from node `src` to node `dst`. - `has_cycle() -> bool`: * Detect and return `True` if there is at least one cycle in the graph; otherwise, return `False`. **Constraints**: * `1 <= n <= 10^5` * edges can be added incrementally, and `0 <= src, dst < n` * You are required to optimize for both time and space: * Time Complexity: O(V + E) * Space Complexity: O(V) **Example**: ```python # Create a new instance for a graph with 4 nodes graph = Graph(4) # Add edges graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) print(graph.has_cycle()) # Expected: False # Add a cycle graph.add_edge(3, 1) print(graph.has_cycle()) # Expected: True ``` In this task, you need to: - Construct the graph incrementally by adding edges. - Check if any cycles exist within the current structure of the graph. This is crucial for maintaining Dependency Management and in avoiding potential deadlocks. Make sure to implement an efficient algorithm that can handle large graphs, using Depth-First Search (DFS) and keeping track of the recursion stack to detect cycles.","solution":"class Graph: def __init__(self, n): Initializes the graph with n nodes. :param n: Number of nodes in the graph. self.n = n self.adjacency_list = [[] for _ in range(n)] def add_edge(self, src, dst): Adds a directed edge from src to dst. :param src: Source node. :param dst: Destination node. self.adjacency_list[src].append(dst) def has_cycle(self): Detects if there is a cycle in the graph. :return: True if there is a cycle, False otherwise. visited = [False] * self.n rec_stack = [False] * self.n def is_cyclic(v): # Mark the current node as visited and add to recursion stack visited[v] = True rec_stack[v] = True # Recur for all neighbours for neighbor in self.adjacency_list[v]: if not visited[neighbor]: if is_cyclic(neighbor): return True elif rec_stack[neighbor]: return True # The node needs to be popped from recursion stack before function ends rec_stack[v] = False return False for node in range(self.n): if not visited[node]: if is_cyclic(node): return True return False"},{"question":"# Question: File Size Formatter You need to create a utility function to format file sizes in a human-readable way. Given an integer file size in bytes, you will convert it into a string representing the size in the largest appropriate unit (e.g., KB, MB, GB) with one decimal place of precision. # Requirements: 1. Implement a function `format_file_size(size: int) -> str` that: - Accepts `size`: The file size in bytes as an integer. - Returns a string representing the file size in the largest suitable unit. 2. The size units follow these rules: - From bytes to kilobytes: divide by 1024 (e.g., 1 KB = 1024 bytes) - From kilobytes to megabytes: divide by 1024 (e.g., 1 MB = 1024 KB) - From megabytes to gigabytes: divide by 1024 (e.g., 1 GB = 1024 MB) - Continue converting up to terabytes if necessary. 3. The returned string should: - Include one decimal place for precision. - Append the appropriate unit (B, KB, MB, GB, TB). # Input: - An integer `size` representing the file size in bytes. # Output: - A string representing the formatted file size. # Constraints: - The input size will be a non-negative integer. - The function should handle sizes up to the range of terabytes efficiently. # Example: ```python assert format_file_size(500) == \\"500.0 B\\" assert format_file_size(2048) == \\"2.0 KB\\" assert format_file_size(1048576) == \\"1.0 MB\\" assert format_file_size(1073741824) == \\"1.0 GB\\" assert format_file_size(1099511627776) == \\"1.0 TB\\" ``` # Notes: - You may use helper functions if necessary to modularize your code. - Consider edge cases like sizes that exactly match the transition between units (e.g., 1024 bytes, 1048576 bytes). - Think about performance implications for large size values close to the upper limit.","solution":"def format_file_size(size: int) -> str: Converts a file size in bytes to a human-readable string with the largest appropriate unit. units = [\\"B\\", \\"KB\\", \\"MB\\", \\"GB\\", \\"TB\\"] unit_index = 0 while size >= 1024 and unit_index < len(units) - 1: size /= 1024 unit_index += 1 return f\\"{size:.1f} {units[unit_index]}\\""},{"question":"# Coding Challenge: Fibonacci Sequence and Arithmetic Progression Context: You are required to implement a set of functions that relate to sequence generation and arithmetic operations. These functions are fundamental in various applications, including mathematical computations and data analysis. Ensure your solutions are efficient and handle a wide range of inputs correctly. # Function 1: Fibonacci Sequence Generator **Description**: Write a function, `fibonacci_sequence(n: int) -> List[int]`, that takes a positive integer `n` and returns the first `n` terms of the Fibonacci sequence. The Fibonacci sequence starts with 0 and 1, and each subsequent term is the sum of the previous two terms. - **Input**: An integer `n` (1  n  10^5) - **Output**: A list of integers representing the first `n` terms of the Fibonacci sequence. - **Constraints**: - Ensure the function handles cases where `n` is very large efficiently. # Function 2: Arithmetic Progression Sum **Description**: Write a function, `arithmetic_progression_sum(a: int, d: int, n: int) -> int`, that takes three integers `a`, `d`, and `n`, and returns the sum of the first `n` terms of an arithmetic progression (AP) starting with `a` and having a common difference of `d`. - **Input**: Three integers `a`, `d`, and `n` (1  a  10^9, 1  d  10^9, 1  n  10^7) - **Output**: An integer representing the sum of the first `n` terms of the arithmetic progression. - **Constraints**: - Use an efficient formula to compute the sum without generating all terms when `n` is very large. ```python from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. pass # Implement the function def arithmetic_progression_sum(a: int, d: int, n: int) -> int: Returns the sum of the first n terms of an arithmetic progression with the first term a and common difference d. pass # Implement the function # Example Usage: # fibonacci_sequence(10) -> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # arithmetic_progression_sum(1, 3, 5) -> 35 # (1 + 4 + 7 + 10 + 13 = 35) ``` Notes: 1. Ensure that your solutions are optimized for the given constraints. 2. Your functions should include necessary input validation and handle edge cases appropriately.","solution":"from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] result = [0, 1] while len(result) < n: result.append(result[-1] + result[-2]) return result def arithmetic_progression_sum(a: int, d: int, n: int) -> int: Returns the sum of the first n terms of an arithmetic progression with the first term a and common difference d. return n * (2 * a + (n - 1) * d) // 2"},{"question":"# In-Place String Reversal Description You are tasked with implementing a function to reverse a given string in place using recursion. The function should not use any additional data structures or libraries for reversing the string. Implementation Implement the function `reverse_string_in_place(s: list[str], start: int, end: int) -> None` that takes a mutable list of characters `s`, and two integers `start` and `end` representing the start and end indices of the substring within `s` to be reversed. The function should reverse the substring in place. Constraints 1. The input string will have a length in the range 1  len(s)  10^4. 2. The `start` and `end` indices will always be valid within the bounds of the string. Function Signature ```python def reverse_string_in_place(s: list[str], start: int, end: int) -> None: pass ``` Input Format * A list of characters `s` representing the string to be reversed. * Two integers `start` and `end` denoting the start and end positions of the substring in `s` to be reversed. Output Format * There is no return value. The function should modify the list `s` in place to reverse the specified substring. Example Input: ```python s = [\'h\', \'e\', \'l\', \'l\', \'o\'] start = 0 end = 4 ``` Output: ```python # The list `s` should be modified to: [\'o\', \'l\', \'l\', \'e\', \'h\'] ``` Additional Information 1. The function should modify the input list `s` in place. 2. Handle edge cases such as reversing an empty substring or reversing a substring that encompasses the entire list of characters.","solution":"def reverse_string_in_place(s: list[str], start: int, end: int) -> None: Recursively reverses the string in place between the indices start and end. Args: s (list[str]): The list of characters to be reversed. start (int): The starting index of the substring to be reversed. end (int): The ending index of the substring to be reversed. if start >= end: return # Swap elements at start and end s[start], s[end] = s[end], s[start] # Recur for the next pair reverse_string_in_place(s, start+1, end-1)"},{"question":"# Context: In a distributed computing environment, tasks are often divided across multiple nodes for parallel processing. Each node has a limited amount of memory and processing power, and the goal is to minimize the computing time while ensuring that no node exceeds its memory limit. # Task: Implement a Python function `schedule_tasks(task_memory_requirements, node_memory_capacity)` that: 1. Distributes a list of tasks with known memory requirements among a fixed number of nodes. 2. Ensures that the total memory required by the tasks on any node does not exceed the node\'s available memory capacity. 3. Aims to balance the load as evenly as possible across the nodes. # Input: * `task_memory_requirements` (List[int]): A list of integers where each integer represents the memory requirement of a task. * `node_memory_capacity` (int): An integer representing the memory capacity of each node. * `num_nodes` (int): Number of nodes available for task distribution. # Output: * Returns a List[List[int]] where each inner list represents the tasks assigned to a particular node. # Constraints: * The list `task_memory_requirements` will contain between 1 and 100 tasks. * The memory requirement for each task will be between 1 and 100 units. * Memory capacity of each node will be between 1 and 1000 units. * The number of nodes will be between 1 and 10. # Requirements: * The function should efficiently allocate tasks to nodes without exceeding their memory capacity. * Tasks must be assigned to the minimum number of nodes required. If tasks cannot be reasonably distributed within the memory constraints, the function should raise a `ValueError`. # Example: ```python task_memory_requirements = [100, 200, 300, 400, 500, 600] node_memory_capacity = 700 num_nodes = 3 distribution = schedule_tasks(task_memory_requirements, node_memory_capacity, num_nodes) print(distribution) # Example Output: # [[100, 200, 300], [400], [500, 600]] ``` In the given example, the tasks are distributed across the available nodes in such a way that the total memory on any node does not exceed its capacity of 700 units. Note that the goal is to balance the load and use the minimum number of nodes. By creating this question, you engage participants in solving problems related to task scheduling and memory management, aligning well with the complexities of distributed computing and resource optimization techniques.","solution":"def schedule_tasks(task_memory_requirements, node_memory_capacity, num_nodes): Distributes tasks to nodes ensuring no node exceeds its memory capacity. Parameters: - task_memory_requirements (List[int]): Memory requirements for each task. - node_memory_capacity (int): Memory capacity of each node. - num_nodes (int): Number of available nodes. Returns: - List[List[int]]: A list of task lists, where each list represents the tasks assigned to a node. Raises: - ValueError if tasks cannot be reasonably distributed within the memory constraints. task_memory_requirements.sort(reverse=True) # Start with the largest tasks nodes = [[] for _ in range(num_nodes)] node_memory_used = [0] * num_nodes for task in task_memory_requirements: allocated = False for i in range(num_nodes): if node_memory_used[i] + task <= node_memory_capacity: nodes[i].append(task) node_memory_used[i] += task allocated = True break if not allocated: raise ValueError(\\"Tasks cannot be distributed within the given memory constraints.\\") return nodes"},{"question":"# Coding Question: Dynamic Programming for Coin Change Problem **Scenario**: You are working as a software engineer and are given the task of designing a system that helps determine the minimum number of coins needed to make a certain amount of change from a given set of coin denominations. Write a function `min_coins` that takes a list of coin denominations and an integer amount, and returns the minimum number of coins needed to make that amount. If it is not possible to make that amount with the given denominations, the function should return -1. Function Signature ```python def min_coins(coin_denominations: list, amount: int) -> int: Args: - coin_denominations (list): A list of positive integers representing coin denominations. - amount (int): The target amount of change. Returns: - int: The minimum number of coins needed to make the amount, or -1 if it\'s not possible. ``` Inputs - `coin_denominations`: A list of positive integers representing the available coin denominations. - `amount`: A non-negative integer representing the target amount for which change is to be made. Outputs - An integer representing the minimum number of coins needed to make the amount, or -1 if it is not possible. Constraints - Assume that you have an infinite supply of each of the given coin denominations. - The coin denominations list will have at least one coin and will contain distinct values. - The amount will be a non-negative integer. # Examples ```python # Example 1 coin_denominations = [1, 2, 5] amount = 11 # We can make change for 11 with 5 + 5 + 1 => 3 coins. print(min_coins(coin_denominations, amount)) # Output: 3 # Example 2 coin_denominations = [2] amount = 3 # It is not possible to make change for 3 using only denomination 2. print(min_coins(coin_denominations, amount)) # Output: -1 # Example 3 coin_denominations = [1, 2, 5, 10] amount = 27 # We can make change for 27 with 10 + 10 + 5 + 2 => 4 coins. print(min_coins(coin_denominations, amount)) # Output: 4 ``` # Notes - Use a dynamic programming approach to solve the problem efficiently. - Consider initializing the minimum number of coins required for each amount from 0 to the target amount. - Return -1 if no combination of given denominations can produce the target amount.","solution":"def min_coins(coin_denominations, amount): # Initialize the dp array with infinity dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Base case: 0 coins are needed to make the amount of 0 # Iterate over each denomination for coin in coin_denominations: for x in range(coin, amount + 1): if dp[x - coin] != float(\'inf\'): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, it means we cannot make the amount with the given denominations return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Problem Statement You are required to develop a function that calculates the minimum daily water intake needed for hydration. Your task is to create an optimized function that considers various factors such as weight, age, gender, and physical activity level. # Objectives 1. **Calculate daily water intake based on weight, age, gender, and physical activity level**. 2. **Incorporate different base water needs for different age groups and genders**. 3. **Adjust the water intake based on the level of physical activity**. # Requirements 1. Implement the function `calculate_daily_water_intake` which accepts the following parameters: * `weight` (float): The person\'s weight in kilograms. * `age` (int): The person\'s age in years. * `gender` (str): The person\'s gender, either \\"male\\" or \\"female\\". * `physical_activity_level` (str): A string representing the person\'s physical activity level, either \\"low\\", \\"moderate\\", or \\"high\\". 2. Calculate the base water need: * For males: - Age < 30: Base water need is 3.7 liters per day - Age >= 30: Base water need is 3.5 liters per day * For females: - Age < 30: Base water need is 2.7 liters per day - Age >= 30: Base water need is 2.5 liters per day 3. Adjust the water need based on physical activity level: * For \\"low\\" activity: Increase the base water need by 10% * For \\"moderate\\" activity: Increase the base water need by 20% * For \\"high\\" activity: Increase the base water need by 30% 4. Return the adjusted water intake value rounded to two decimal places. # Input Format * `weight`: A float representing the person\'s weight in kilograms. * `age`: An integer denoting the person\'s age. * `gender`: A string denoting the person\'s gender, either \\"male\\" or \\"female\\". * `physical_activity_level`: A string representing the person\'s physical activity level, either \\"low\\", \\"moderate\\", or \\"high\\". # Output Format A float representing the calculated daily water intake rounded to two decimal places. # Example ```python calculate_daily_water_intake(70, 25, \\"male\\", \\"high\\") # Output: 4.81 calculate_daily_water_intake(55, 35, \\"female\\", \\"moderate\\") # Output: 3.00 ``` # Constraint * The function should handle realistic ranges of weight (30-150 kg) and age (0-100 years).","solution":"def calculate_daily_water_intake(weight, age, gender, physical_activity_level): Calculates the minimum daily water intake needed for hydration based on weight, age, gender, and physical activity level. Parameters: weight (float): The person\'s weight in kilograms. age (int): The person\'s age in years. gender (str): The person\'s gender, either \\"male\\" or \\"female\\". physical_activity_level (str): A string representing the person\'s physical activity level, either \\"low\\", \\"moderate\\", or \\"high\\". Returns: float: The calculated daily water intake rounded to two decimal places. # Determine base water need based on age and gender if gender == \\"male\\": if age < 30: base_water_need = 3.7 else: base_water_need = 3.5 elif gender == \\"female\\": if age < 30: base_water_need = 2.7 else: base_water_need = 2.5 # Adjust the water need based on physical activity level if physical_activity_level == \\"low\\": base_water_need *= 1.10 elif physical_activity_level == \\"moderate\\": base_water_need *= 1.20 elif physical_activity_level == \\"high\\": base_water_need *= 1.30 return round(base_water_need, 2)"},{"question":"# Sum of Odd Positioned Elements in Zigzag Array You are to implement a function that takes a 2D list (matrix) and returns the sum of the elements that are located in odd positions when traversing the matrix in a zigzag manner. The zigzag traversal starts from the top-left element, moving right initially, and continues alternately changing direction after each row. # Function Signature ```python def sum_odd_positioned_elements(matrix: List[List[int]]) -> int: ``` # Input: * A 2D list `matrix` consisting of integers with dimensions `n x m` where `1 <= n, m <= 100`. # Output: * An integer sum of the elements located at the odd positions in the zigzag traversal. # Explanation: 1. The matrix is traversed in a zigzag pattern starting from the top-left. 2. The odd position starts from index 1, counting each element in the order of traversal. # Examples: ```python >>> sum_odd_positioned_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 18 # Elements in odd positions: 2, 4, 6, 8 (sum = 2 + 4 + 6 + 8 = 20) >>> sum_odd_positioned_elements([[10, 20], [30, 40], [50, 60]]) 90 # Elements in odd positions: 20, 30, 60 (sum = 20 + 30 + 60 = 110) >>> sum_odd_positioned_elements([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 6 # Elements in odd positions: 1, 1, 1, 1, 1, 1 (sum = 1 + 1 + 1 + 1 + 1 + 1 = 6) ``` # Additional Constraints: * Ensure the traversal alternates direction on each row, starting with left-to-right for the first row. * The matrix dimensions will always be valid and non-empty. # Requirements: * The solution should be efficient given the constraints. * Ensure the function correctly identifies and sums elements in odd positions of the zigzag pattern.","solution":"def sum_odd_positioned_elements(matrix): Returns the sum of the elements located in odd positions in the zigzag traversal of the given matrix. n = len(matrix) m = len(matrix[0]) zigzag = [] for i in range(n): if i % 2 == 0: zigzag.extend(matrix[i]) else: zigzag.extend(matrix[i][::-1]) return sum(zigzag[i] for i in range(1, len(zigzag), 2))"},{"question":"# Finding Longest Increasing Subsequence Context Consider you are working on a problem that involves finding the longest increasing subsequence (LIS) in a given list of integers. The longest increasing subsequence is defined as the longest subsequence where each element is strictly greater than the previous one. Subsequences are derived by deleting some or no elements without changing the order of the remaining elements. Task Write a function `longest_increasing_subsequence(arr: List[int]) -> int` that takes a list of integers `arr` and returns the length of the longest increasing subsequence. Input * A list of integers `arr` where `1  len(arr)  1000` and `-10^9  arr[i]  10^9`. Output * An integer representing the length of the longest increasing subsequence in the given list. Constraints * You should strive for a solution with a time complexity of O(n log n). Example For `arr = [10, 9, 2, 5, 3, 7, 101, 18]`: ```plaintext longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) => 4 ``` For `arr = [0, 1, 0, 3, 2, 3]`: ```plaintext longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) => 4 ``` Explanation - In the first example, the longest increasing subsequence is `[2, 3, 7, 101]` which has a length of 4. - In the second example, the longest increasing subsequence is `[0, 1, 2, 3]` which also has a length of 4. Implementation Construct this function with careful consideration of edge cases, performance bottlenecks, error scenarios, and potential optimizations. ```python from typing import List import bisect def longest_increasing_subsequence(arr: List[int]) -> int: Return the length of the longest increasing subsequence in the given list. if not arr: return 0 # Initialize the list to keep the smallest last element of all increasing subsequences # with length i+1 in temp[i]. temp = [] for num in arr: # Use binary search to find the correct position of num in temp pos = bisect.bisect_left(temp, num) # If pos is equal to len(temp), it means num is greater than any elements in temp if pos < len(temp): temp[pos] = num else: temp.append(num) return len(temp) ``` Write a solution in Python, considering edge cases and aiming for optimal performance.","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int]) -> int: Return the length of the longest increasing subsequence in the given list. if not arr: return 0 # Initialize the list to keep the smallest last element of all increasing subsequences # with length i+1 in temp[i]. temp = [] for num in arr: # Use binary search to find the correct position of num in temp pos = bisect.bisect_left(temp, num) # If pos is equal to len(temp), it means num is greater than any elements in temp if pos < len(temp): temp[pos] = num else: temp.append(num) return len(temp)"},{"question":"# Problem Statement You are required to implement a function that merges two sorted linked lists into one sorted linked list. The resulting list should only contain unique elements. The input linked lists are represented using nodes and the output should be a linked list node. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_unique_sorted_lists(list1, list2): Merge two sorted linked lists into a single sorted linked list containing unique elements. Parameters: list1 -- The head node of the first sorted linked list. list2 -- The head node of the second sorted linked list. Output: The head node of the new linked list containing unique values from both input lists. pass ``` # Example Usage ```python >>> # Helper function to convert list to linked list >>> def to_linked_list(lst): ... head = ListNode(lst[0]) ... current = head ... for value in lst[1:]: ... current.next = ListNode(value) ... current = current.next ... return head >>> # Helper function to convert linked list to list >>> def to_list(head): ... lst = [] ... current = head ... while current is not None: ... lst.append(current.val) ... current = current.next ... return lst >>> list1 = to_linked_list([1, 3, 5, 7]) >>> list2 = to_linked_list([2, 3, 6, 8, 10]) >>> merged_list = merge_unique_sorted_lists(list1, list2) >>> to_list(merged_list) [1, 2, 3, 5, 6, 7, 8, 10] ``` # Requirements 1. **Input Constraints**: - Both `list1` and `list2` are heads of sorted linked lists (each node having an integer value). - Linked lists may contain duplicate values within themselves, but need to be unique in the combined list. 2. **Output**: - The function should return the head of the merged linked list sorted in ascending order without duplicates. 3. **Performance Consideration**: - Ensure that the algorithm effectively handles list traversal without unnecessary overhead. - Maintain efficient memory usage while constructing the new linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_unique_sorted_lists(list1, list2): Merge two sorted linked lists into a single sorted linked list containing unique elements. dummy = ListNode() current = dummy unique_values = set() while list1 is not None and list2 is not None: if list1.val < list2.val: if list1.val not in unique_values: unique_values.add(list1.val) current.next = ListNode(list1.val) current = current.next list1 = list1.next elif list1.val > list2.val: if list2.val not in unique_values: unique_values.add(list2.val) current.next = ListNode(list2.val) current = current.next list2 = list2.next else: if list1.val not in unique_values: unique_values.add(list1.val) current.next = ListNode(list1.val) current = current.next list1 = list1.next list2 = list2.next while list1 is not None: if list1.val not in unique_values: unique_values.add(list1.val) current.next = ListNode(list1.val) current = current.next list1 = list1.next while list2 is not None: if list2.val not in unique_values: unique_values.add(list2.val) current.next = ListNode(list2.val) current = current.next list2 = list2.next return dummy.next"},{"question":"# Problem Description Write a function to determine if a given string containing only round parentheses (\'(\' and \')\') is valid. A string is considered valid if all the parentheses are correctly matched and closed in the correct order. You should use a stack data structure to solve this problem. The function should return `True` if the string is valid, and `False` otherwise. # Function Signature You need to implement the following function: ```python def is_valid_parentheses(s: str) -> bool: Determines if the input string of round parentheses is valid. Parameters: s (str): The input string containing only \'(\' and \')\'. Returns: bool: True if the string is valid, False otherwise. ``` # Input and Output * `is_valid_parentheses(s: str) -> bool` * Input: A string containing only \'(\' and \')\'. * Output: Returns `True` if the string is valid, `False` otherwise. # Example ```python print(is_valid_parentheses(\\"()\\")) # Output: True print(is_valid_parentheses(\\"()()\\")) # Output: True print(is_valid_parentheses(\\"(())\\")) # Output: True print(is_valid_parentheses(\\"(()\\")) # Output: False print(is_valid_parentheses(\\")(\\")) # Output: False print(is_valid_parentheses(\\"((())\\")) # Output: False print(is_valid_parentheses(\\"()(()(()))\\")) # Output: True ``` # Constraints * The length of the input string `s` will be between 1 and 1000. * Only the characters \'(\' and \')\' will be present in the input string. # Notes * Focus on the efficiency of your implementation. * Consider edge cases such as an empty string or a string with an odd number of characters.","solution":"def is_valid_parentheses(s: str) -> bool: Determines if the input string of round parentheses is valid. Parameters: s (str): The input string containing only \'(\' and \')\'. Returns: bool: True if the string is valid, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"# Problem Statement: Create a function that will generate the nth number in the Fibonacci sequence using an optimized approach such as Dynamic Programming. Given the large potential value of `n`, your solution should be efficient in both time and space complexity. Avoid using the recursive approach to prevent a stack overflow for large values of `n`. # Function Signature: ``` def fibonacci(n: int) -> int: ``` # Input: - `n`: an integer, representing the position in the Fibonacci sequence (0-indexed). # Output: - An integer representing the nth number in the Fibonacci sequence. # Constraints: * The input `n` will be an integer in the range [0, 50]. * The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2), for n > 1 # Example: Example 1: ``` Input: n = 0 Output: 0 ``` Example 2: ``` Input: n = 1 Output: 1 ``` Example 3: ``` Input: n = 10 Output: 55 ``` # Requirements: - Optimize for both time and space complexity. - Do not use a recursive approach. - Ensure the solution handles edge cases, such as the smallest and largest values of `n`. # Hint: Consider using an array or two variables to keep track of the last two Fibonacci numbers and iteratively build up to the nth number.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using an iterative approach with optimized space complexity. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement Given an integer `n`, write a function `count_binary_ones(n)` that returns the total number of `1`s in the binary representation of all integers from `1` to `n`. # Input - `n` (1  `n`  1000000), the upper bound integer. # Output - An integer representing the total count of `1`s in the binary representation of all integers from `1` to `n`. # Constraints - Consider optimizing your solution to handle the upper limit of `n` efficiently. - Use bitwise operations or any efficient algorithm to minimize time complexity. # Examples ```python def count_binary_ones(n: int) -> int: # Your code here # Example 1 # Input: # n = 5 # Output: # 7 # Explanation: # The binary representations of integers from 1 to 5 are: # 1 -> 1 # 2 -> 10 # 3 -> 11 # 4 -> 100 # 5 -> 101 # Total `1`s: 1 + 1 + 2 + 1 + 2 = 7 # Example 2 # Input: # n = 10 # Output: # 17 # Explanation: # The binary representations of integers from 1 to 10 are: # 1 -> 1 # 2 -> 10 # 3 -> 11 # 4 -> 100 # 5 -> 101 # 6 -> 110 # 7 -> 111 # 8 -> 1000 # 9 -> 1001 # 10 -> 1010 # Total `1`s = 1 + 1 + 2 + 1 + 2 + 2 + 3 + 1 + 2 + 2 = 17 ``` # Explanation For the input `5`: - The binary representations of integers from `1` to `5` are `1`, `10`, `11`, `100`, and `101` respectively. - The total number of `1`s in these representations is `7`. For the input `10`: - The binary representations of integers from `1` to `10` are `1`, `10`, `11`, `100`, `101`, `110`, `111`, `1000`, `1001`, and `1010` respectively. - The total number of `1`s in these representations is `17`. Implement a function `count_binary_ones` that efficiently calculates the total count of `1`s in the binary representation of all integers from `1` to `n`.","solution":"def count_binary_ones(n): Returns the total number of 1s in the binary representation of all integers from 1 to n. def count_ones(x): return bin(x).count(\'1\') return sum(count_ones(i) for i in range(1, n + 1))"},{"question":"# Merge Two Sorted Linked Lists You are given two singly linked lists, both of which are sorted in ascending order. Your task is to merge these two lists into a single sorted linked list in ascending order. The returned list should be made by splicing together the nodes of the two given lists. You must implement the `mergeTwoLists` function to achieve this task. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. Arguments: l1 -- ListNode, the head of the first linked list. l2 -- ListNode, the head of the second linked list. Returns: ListNode, the head of the merged linked list. # Your code goes below: pass ``` Input - `l1` and `l2`: ListNode, heads of two singly linked lists sorted in ascending order. - The node values may include negative numbers, zero, and positive numbers. - Lists can have different lengths, including zero (i.e., one or both lists can be empty). Output - Returns the head of the merged sorted linked list. Constraints - Any node either in `l1` or `l2` can hold integer values (the nodes\' integer values range is within -10^4 to 10^4). - Nodes are arranged in ascending order within both linked lists. # Example ```python # Example 1: # Input: l1 = 1 -> 2 -> 4, l2 = 1 -> 3 -> 4 # Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 l1 = ListNode(1, ListNode(2, ListNode(4))) l2 = ListNode(1, ListNode(3, ListNode(4))) result = mergeTwoLists(l1, l2) # Print the merged list while result: print(result.val, end=\\" -> \\") result = result.next # Expected Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> None # Example 2: # Input: l1 = null, l2 = 0 # Output: 0 l1 = None l2 = ListNode(0) result = mergeTwoLists(l1, l2) # Print the merged list while result: print(result.val, end=\\" -> \\") result = result.next # Expected Output: 0 -> None ``` # Performance Requirements - The solution should efficiently merge the two lists while maintaining the sorted order. - Ensure that the solution works within the constraints to handle large lists effectively.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. Arguments: l1 -- ListNode, the head of the first linked list. l2 -- ListNode, the head of the second linked list. Returns: ListNode, the head of the merged linked list. # Create a dummy node to serve as the start of the merged list dummy = ListNode() current = dummy # Traverse both lists, choosing the smaller current node each time while l1 is not None and l2 is not None: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # At most one of l1 and l2 can be non-null at this point, so connect the remaining nodes current.next = l1 if l1 is not None else l2 return dummy.next"},{"question":"Problem Statement In this problem, you are required to create a basic command-line tool that processes text files to perform a specific operation. You need to implement a function that identifies and returns the most frequently occurring words in a given text file. # Function Signature ```python def most_frequent_words(file_path: str, top_n: int) -> List[str]: :param file_path: the path to the text file to be processed. :param top_n: the number of most frequent words to return. :return: a list containing the top `top_n` most frequent words in the file. ``` # Input * A string (`file_path`) representing the path to the text file. * An integer (`top_n`) representing the number of most frequent words to return. # Output * A list of strings containing the `top_n` most frequent words in the file, sorted by frequency from highest to lowest. If multiple words have the same frequency, they should be sorted alphabetically. # Constraints * Words should be case-insensitive, i.e., \\"Word\\" and \\"word\\" should be considered the same word. * Ignore punctuation and special characters when counting words. * The input text file may be large, so the solution should be efficient in both time and space complexity. * Assume the file exists and is accessible. # Example Usage Consider a file `sample.txt` with the following content: ``` Hello world! This is a test file. The test file is used to test the most frequent words. Count the words that appear the most. ``` Invoking the function with `top_n = 3`: ```python top_words = most_frequent_words(\\"sample.txt\\", 3) print(top_words) # Output: [\'the\', \'test\', \'words\'] ``` # Hints * Reading the file and processing it in chunks might help in managing large files. * Using a dictionary to keep track of word counts can facilitate efficient counting. * Consider using Python\'s `collections.Counter` to simplify the frequency counting. * Ensure that your solution properly handles and ignores punctuation. # Additional Requirements * Write a small script or function for testing `most_frequent_words` with various files and parameters. * Different scenarios should include cases with varying word frequencies, punctuation handling, and large text files.","solution":"from collections import Counter import re from typing import List def most_frequent_words(file_path: str, top_n: int) -> List[str]: Returns the top `top_n` most frequent words in the file located at `file_path`. :param file_path: the path to the text file to be processed. :param top_n: the number of most frequent words to return. :return: a list of the most frequent words, sorted by frequency and then alphabetically. # Read file content with open(file_path, \'r\', encoding=\'utf-8\') as file: text = file.read().lower() # Use regex to find words and ignore punctuation words = re.findall(r\'bw+b\', text) # Count the frequency of each word word_counts = Counter(words) # Get the most common words sorted by frequency and then alphabetically most_common_words = sorted(word_counts.items(), key=lambda item: (-item[1], item[0])) # Extract the words from the sorted list and return the top_n words return [word for word, count in most_common_words[:top_n]]"},{"question":"# Move Zeroes to End You are tasked with writing a function that moves all the zeroes in a given list of integers to the end while maintaining the relative order of the non-zero elements. # Function Signature ```python def move_zeroes(nums: list[int]) -> list[int]: pass ``` # Input Format - A single list `nums` of integers. # Output Format - A list of integers with all zeroes moved to the end. # Constraints - The input list will have a length between 0 and 100,000 inclusive. - Each element of the list will be an integer between -10^9 and 10^9 inclusive. - An empty list should return an empty list. # Performance Requirements - The solution should be efficient, with a linear time complexity. # Example ```python >>> move_zeroes([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeroes([0, 0, 0, 0, 1]) [1, 0, 0, 0, 0] >>> move_zeroes([4, 2, 4]) [4, 2, 4] >>> move_zeroes([]) [] ```","solution":"def move_zeroes(nums: list[int]) -> list[int]: Moves all zeroes in the list to the end while maintaining the relative order of the non-zero elements. :param nums: List of integers :return: A new list with all zeroes moved to the end non_zero_index = 0 # First pass: Place all non-zero elements at the beginning of the array for i in range(len(nums)): if nums[i] != 0: nums[non_zero_index] = nums[i] non_zero_index += 1 # Second pass: Fill the rest of the array with zeroes for i in range(non_zero_index, len(nums)): nums[i] = 0 return nums"},{"question":"# Coding Question: Range Sum Query with Dynamic Updates You are given an array of integers. Your task is to implement a data structure that allows for dynamic updates of the array and can efficiently handle range sum queries. **Scenario**: You are developing a system where you frequently need to update values in an array and quickly compute the sum of elements in a specified range. To optimize these operations, you have decided to use a data structure that supports dynamic updates and efficient range queries. Implement a class `RangeSumQuery` that provides the following methods: - `__init__(self, nums: List[int])`: Initializes the object with the array `nums`. - `update(self, index: int, val: int)`: Updates the element of the array at index `index` to be `val`. - `sumRange(self, left: int, right: int) -> int`: Returns the sum of the elements between indices `left` and `right` inclusive. Class Signature ```python class RangeSumQuery: def __init__(self, nums: List[int]): pass def update(self, index: int, val: int): pass def sumRange(self, left: int, right: int) -> int: pass ``` Input * `nums` (List[int]): An initial array of integers. * `index` (int): The index of the array to be updated. * `val` (int): The new value to be assigned at the specified index. * `left` (int): The starting index for the range sum query. * `right` (int): The ending index for the range sum query. Output * `sumRange` returns an integer, the sum of the elements between indices `left` and `right` inclusive. Constraints * The array `nums` will have at most `10^4` elements. * `update` and `sumRange` operations will be called at most `10^4` times. * All elements of `nums` and all `val` values will be in the range of `[-10^4, 10^4]`. Examples ```python # Example 1 obj = RangeSumQuery([1, 3, 5]) assert obj.sumRange(0, 2) == 9 # Sum from index 0 to 2 = 1 + 3 + 5 = 9 obj.update(1, 2) # Update index 1 to value 2. Array becomes [1, 2, 5] assert obj.sumRange(0, 2) == 8 # Sum from index 0 to 2 = 1 + 2 + 5 = 8 # Example 2 obj = RangeSumQuery([-2, 0, 3, -5, 2, -1]) assert obj.sumRange(0, 2) == 1 # Sum from index 0 to 2 = -2 + 0 + 3 = 1 assert obj.sumRange(2, 5) == -1 # Sum from index 2 to 5 = 3 + -5 + 2 + -1 = -1 obj.update(5, 3) # Update index 5 to value 3. Array becomes [-2, 0, 3, -5, 2, 3] assert obj.sumRange(2, 5) == 3 # Sum from index 2 to 5 = 3 + -5 + 2 + 3 = 3 ``` Notes * Consider using a data structure that optimizes both the update and range sum query operations, such as a segment tree or a Fenwick tree (binary indexed tree). * Ensure your implementation handles edge cases and large inputs efficiently.","solution":"class RangeSumQuery: def __init__(self, nums): Initializes the object with the array nums. self.n = len(nums) self.nums = nums self.tree = [0] * (self.n + 1) for i in range(self.n): self._init_update(i, nums[i]) def _init_update(self, index, val): index += 1 while index <= self.n: self.tree[index] += val index += index & -index def update(self, index, val): Updates the element of the array at index index to be val. delta = val - self.nums[index] self.nums[index] = val index += 1 while index <= self.n: self.tree[index] += delta index += index & -index def sumRange(self, left, right): Returns the sum of the elements between indices left and right inclusive. return self._prefix_sum(right) - self._prefix_sum(left - 1) def _prefix_sum(self, index): summation = 0 index += 1 while index > 0: summation += self.tree[index] index -= index & -index return summation"},{"question":"Linked List Node Removal Optimization You are provided with a `LinkedList` class that contains nodes with integer values. Your task is to optimize the functionality of this class to efficiently remove a specific node from the list. The node to be removed will be provided as a reference, rather than by its value. 1. **Node Deletion**: * Implement a `remove_node` method that takes a reference to the node to be removed. * Ensure that the method updates the `next` pointers of the surrounding nodes correctly. 2. **Edge Case Handling**: * Handle edge cases where the node to be removed is the head node or the last node in the list. * If the list becomes empty after the removal, update the head of the list accordingly. **Input**: - A reference to the `node_to_remove`. **Output**: - A boolean indicating success (`True`) for a successful removal or failure (`False`) if the node is not found. **Performance Requirements**: - The removal should be done in O(1) time complexity. - Ensure no memory leaks by properly managing node pointers. **Constraints**: - The list can have at most 10^5 nodes. - Nodes will have unique integer values. - The node to be removed will always be a valid node within the list. **Example Usage**: ```python class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def remove_node(self, node_to_remove): # Your implementation here pass # Usage example linked_list = LinkedList() linked_list.append(1) linked_list.append(2) linked_list.append(3) node_to_delete = linked_list.head.next # Node with value 2 success = linked_list.remove_node(node_to_delete) print(success) # Expected output: True ``` Write the optimized `remove_node` method within the `LinkedList` class to achieve the described functionality.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def remove_node(self, node_to_remove): if self.head is None: return False if self.head == node_to_remove: self.head = self.head.next return True current = self.head while current.next and current.next != node_to_remove: current = current.next if current.next == node_to_remove: current.next = node_to_remove.next return True return False"},{"question":"# Order Checker with Strictly Increasing or Decreasing Validation Background You are given an array of integers. Your task is to determine if the array is strictly increasing or strictly decreasing. A strictly increasing array is one in which each subsequent element is greater than the previous, and a strictly decreasing array is one in which each subsequent element is smaller than the previous. This kind of checking is essential in sorting algorithms and data validation processes. Objective Write a function to check if a given integer array is strictly increasing or strictly decreasing. Ensure the function iterates through the list efficiently, considering edge cases. Task 1. Implement a function `is_strictly_ordered(nums: List[int]) -> bool` that takes a list of integers and returns `True` if the list is either strictly increasing or strictly decreasing, otherwise `False`. 2. Ensure your implementation handles edge cases of empty lists and single-element lists. 3. Optimize for best possible performance with minimal complexity. Function Signature ```python def is_strictly_ordered(nums: List[int]) -> bool: pass ``` Input - **nums**: A list of integers. 0 <= len(nums) <= 10^5, -10^5 <= nums[i] <= 10^5. Output - Return `True` if the input list is strictly ordered (either strictly increasing or strictly decreasing), otherwise return `False`. Constraints - Your solution should run in O(n) time complexity. Examples ```python >>> is_strictly_ordered([1, 2, 3, 4]) True >>> is_strictly_ordered([4, 3, 2, 1]) True >>> is_strictly_ordered([1, 2, 2, 3]) False >>> is_strictly_ordered([]) True >>> is_strictly_ordered([7]) True ``` Note Edge cases such as empty list or a single-element list should be handled correctly. A single-element list or an empty list is trivially strictly ordered.","solution":"from typing import List def is_strictly_ordered(nums: List[int]) -> bool: Check if the input list is strictly increasing or strictly decreasing. Args: nums: List of integers. Returns: bool: True if the list is strictly ordered, False otherwise. if len(nums) <= 1: return True increasing = decreasing = True for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: increasing = False if nums[i] >= nums[i - 1]: decreasing = False return increasing or decreasing"},{"question":"# Enumeration Challenge: Subset Sum Problem In this task, you are required to solve a classic problem in computer science: the Subset Sum Problem. This problem is relevant in real-world applications such as resource allocation and cryptographic systems. Scenario: You are developing inventory management software that helps users find possible subsets of items to meet a specific requirement in total value. Given a list of item values and a target value, you will need to determine if there is a subset of these items that exactly sums up to the target value. Objective: Implement a function `subset_sum` that determines if there exists a subset of the given list of item values that adds up to the target value. # Specifications: 1. Function: * `subset_sum` - Takes a list of integers (values of items) and a target integer value, and returns `True` if there exists a subset of the list that sums up to the target value, otherwise returns `False`. 2. Input/Output Formats: * **Input**: * `item_values`: a list of integers representing the values of items. * `target_value`: an integer representing the target value to achieve with a subset of items. * **Output**: * `True` if a subset with the exact sum exists, `False` otherwise. Function Signature: ```python def subset_sum(item_values: list, target_value: int) -> bool: pass ``` Example Usage: ```python item_values = [3, 34, 4, 12, 5, 2] target_value = 9 assert subset_sum(item_values, target_value) == True item_values = [3, 34, 4, 12, 5, 2] target_value = 30 assert subset_sum(item_values, target_value) == False ``` Constraints: * Item values are non-negative integers. * The number of items in the list can be up to 100. * Functions should handle large lists of item values efficiently. * Target value is a non-negative integer.","solution":"def subset_sum(item_values, target_value): n = len(item_values) dp = [[False] * (target_value + 1) for _ in range(n + 1)] # There is always a subset with sum 0, i.e., the empty subset for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target_value + 1): if item_values[i-1] > j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-item_values[i-1]] return dp[n][target_value]"},{"question":"# Smallest Unique Digit Sequence You are tasked with finding the next integer greater than a given integer (n) such that it does not contain any repeating digits. The sequence should consist of unique digits only. # Function Signature ```python def find_next_unique_digit_number(n: int) -> int: Finds the next integer greater than n consisting of unique digits. Args: n (int): The starting integer. Returns: int: The next integer greater than n with all unique digits. ``` # Input & Output - **Input**: A single integer (n) representing the starting point. - **Output**: Returns a single integer, the next number greater than (n) where every digit is unique. # Constraints - (0 leq n leq 10^9) - Ensure the solution efficiently handles the generation and checking of integers for unique digits. # Performance Requirements - The solution should strive for optimal efficiency, avoiding unnecessary checks and computations. # Examples ```python assert find_next_unique_digit_number(123) == 124 assert find_next_unique_digit_number(689) == 690 assert find_next_unique_digit_number(999) == 1023 ``` # Explanation For the input 123, the next number with all unique digits is 124. For the input 689, the next number with all unique digits is 690. For the input 999, the next number with all unique digits is 1023, as it is the smallest integer greater than 999 with non-repeating digits.","solution":"def has_unique_digits(number: int) -> bool: Check if a number has all unique digits. digits = str(number) return len(digits) == len(set(digits)) def find_next_unique_digit_number(n: int) -> int: Finds the next integer greater than n consisting of unique digits. current_num = n + 1 while not has_unique_digits(current_num): current_num += 1 return current_num"},{"question":"# Problem Description: Extend the functionality of the given Stack data structure implementation by adding the following method: **Task**: Implement a method `find_middle` which returns the middle element of the stack without removing it. If the stack has an even number of elements, return the lower middle element (i.e., the first of the two middle elements). ```python def find_middle(self) -> Any: Finds and returns the middle element of the stack without removing it. Time complexity: O(n) @returns: The middle element of the stack. Example: >>> my_stack = Stack() >>> my_stack.push(1) >>> my_stack.push(2) >>> my_stack.push(3) >>> my_stack.push(4) >>> my_stack.push(5) >>> my_stack.find_middle() 3 >>> my_stack.pop() 5 >>> my_stack.find_middle() 2 ``` **Input**: - There are no direct inputs to the method. The stack\'s current elements determine the output. **Output**: - The middle element of the stack (any type depending on the input elements). # Constraints: - The primary stack operations (push, pop, etc.) should remain functional and efficient. - The find_middle method must effectively determine the middle element regardless of stack size. - Proper handling of edge cases, such as an empty stack. # Example Consider a sample usage below: ```python # Stack initialization s = Stack() # Pushing elements s.push(10) s.push(20) s.push(30) s.push(40) s.push(50) # Finding middle element print(s.find_middle()) # Output: 30 # Popping an element s.pop() print(s.find_middle()) # Output: 20 # Edge case: Empty stack while not s.is_empty(): s.pop() print(s.find_middle()) # Output: None or an appropriate message. ``` **Notes**: - Ensure the method does not alter the stack\'s contents. - The method should be robust for both odd and even numbers of elements. - Consider the data structure\'s capacity to handle generic types for the stack elements.","solution":"class Stack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): self.items.append(item) def pop(self): if self.is_empty(): return None return self.items.pop() def peek(self): if self.is_empty(): return None return self.items[-1] def size(self): return len(self.items) def find_middle(self): if self.is_empty(): return None middle_index = (self.size() - 1) // 2 return self.items[middle_index]"},{"question":"# Problem Description You are tasked with implementing a simulation system that models the growth of a cellular automaton known as the \\"Game of Life.\\" The system will read an initial state from a file and simulate a given number of iterations. Your implementation needs to handle large grids efficiently by leveraging parallel processing and memory optimization techniques. # Function Specification You need to write a function `simulate_game_of_life` with the following signature: ```python def simulate_game_of_life(initial_state_file: str, max_iterations: int, output_file: str) -> None: ``` Input: - `initial_state_file`: A string representing the path to a file containing the initial state of the grid. The file format is as follows: - The first line contains two integers `rows` and `cols` (the dimensions of the grid). - The subsequent lines represent the grid, where each line consists of `cols` characters. A dot `.` represents a dead cell, and an asterisk `*` represents a live cell. - `max_iterations`: An integer indicating the number of iterations to simulate. - `output_file`: A string representing the path to the file where the final state of the grid will be saved after the simulation. The format should be identical to the input file format. Output: - The function will write the final state of the grid to the specified `output_file`. # Constraints: - Use parallel processing to optimize the simulation for grids larger than 100x100 cells. - Ensure the system properly handles edge cases (e.g., grid boundaries) and keeps memory usage minimal. # Example Usage ```python # Assume \'initial_state.txt\' contains: # 4 4 # .... # .**. # .**. # .... simulate_game_of_life(\'initial_state.txt\', 5, \'final_state.txt\') # After execution, \'final_state.txt\' should contain the grid state after 5 iterations: # 4 4 # .... # .**. # .**. # .... # Another example usage for a 5x5 grid with more iterations simulate_game_of_life(\'initial_state_5x5.txt\', 10, \'final_state_5x5.txt\') ``` # Performance Requirements - Ensure your solution utilizes parallel processing to improve performance on grids larger than 100x100 cells. - Properly manage memory and avoid unnecessary data duplication during computation. - The solution should be able to handle large inputs efficiently and provide the output in a timely manner.","solution":"import numpy as np from multiprocessing import Pool, cpu_count def read_initial_state(file_path): with open(file_path, \'r\') as file: lines = file.readlines() rows, cols = map(int, lines[0].split()) grid = np.array([list(line.strip()) for line in lines[1:]]) return grid, rows, cols def write_state_to_file(grid, file_path): rows, cols = grid.shape with open(file_path, \'w\') as file: file.write(f\'{rows} {cols}n\') for row in grid: file.write(\'\'.join(row) + \'n\') def count_live_neighbors(grid, x, y): neighbors_positions = [(i, j) for i in range(x-1, x+2) for j in range(y-1, y+2) if (i != x or j != y)] neighbors = [(i, j) for i, j in neighbors_positions if 0 <= i < grid.shape[0] and 0 <= j < grid.shape[1]] return sum(grid[i, j] == \'*\' for i, j in neighbors) def cell_next_state(args): grid, x, y = args live_neighbors = count_live_neighbors(grid, x, y) if grid[x, y] == \'*\': if live_neighbors < 2 or live_neighbors > 3: return (x, y, \'.\') else: return (x, y, \'*\') else: if live_neighbors == 3: return (x, y, \'*\') else: return (x, y, \'.\') def simulate_game_of_life_parallel(grid, iterations): for _ in range(iterations): with Pool(processes=cpu_count()) as pool: updated_cells = pool.map(cell_next_state, [(grid, x, y) for x in range(grid.shape[0]) for y in range(grid.shape[1])]) new_grid = np.copy(grid) for x, y, state in updated_cells: new_grid[x, y] = state grid = new_grid return grid def simulate_game_of_life(initial_state_file: str, max_iterations: int, output_file: str) -> None: grid, rows, cols = read_initial_state(initial_state_file) if rows > 100 and cols > 100: grid = simulate_game_of_life_parallel(grid, max_iterations) else: for _ in range(max_iterations): new_grid = np.copy(grid) for x in range(rows): for y in range(cols): new_grid[x, y] = cell_next_state((grid, x, y))[2] grid = new_grid write_state_to_file(grid, output_file)"},{"question":"# Problem Statement You are working on a data analysis task involving text processing. Your task is to construct a function that identifies and extracts all unique words from a given paragraph and sorts them based on their frequency in descending order. Words with the same frequency should be sorted alphabetically. # Function Signature ```python def extract_and_sort_words(paragraph: str) -> List[str]: This function takes a paragraph of text and returns a list of unique words sorted primarily by their frequency in descending order. Words with the same frequency are sorted alphabetically. Args: paragraph: str, a paragraph of text. Returns: List[str], a list of unique words sorted by frequency and then alphabetically within same frequency. ``` # Expected Input and Output - **Input**: - A string representing a paragraph of text. - **Output**: - A list of unique words sorted primarily by their frequency in descending order, and alphabetically for words with the same frequency. # Example ```python text = \\"This is a text. This text is a sample text, and it is a simple text.\\" result = extract_and_sort_words(text) print(result) # Output: [\'text\', \'a\', \'is\', \'this\', \'and\', \'it\', \'sample\', \'simple\'] ``` # Constraints * The input paragraph will contain only printable ASCII characters. * Words are case-insensitive and should be treated as lowercased. * Punctuation marks should be ignored when identifying words. * The length of the input paragraph will not exceed 10,000 characters. # Evaluation * **Correctness**: Ensure that your function produces the correct results as per the description. * **Efficiency**: The implementation should handle large input texts efficiently in terms of both time and space complexity. # Notes - Use regular expressions if needed to handle punctuation and whitespace. - Use appropriate data structures to ensure efficient tracking and sorting of word frequencies.","solution":"import re from collections import Counter from typing import List def extract_and_sort_words(paragraph: str) -> List[str]: This function takes a paragraph of text and returns a list of unique words sorted primarily by their frequency in descending order. Words with the same frequency are sorted alphabetically. Args: paragraph: str, a paragraph of text. Returns: List[str], a list of unique words sorted by frequency and then alphabetically within same frequency. # Convert the paragraph to lowercase to ensure case-insensitivity paragraph = paragraph.lower() # Use regular expression to replace punctuations with space and split to find words words = re.findall(r\'bw+b\', paragraph) # Count the frequency of each word word_count = Counter(words) # Sort words first alphabetically and then by frequency sorted_words = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) # Extract the words from the sorted word-count tuples sorted_word_list = [word for word, count in sorted_words] return sorted_word_list"},{"question":"# Problem: Longest Substring Without Repeating Characters Given a string `s`, find the length of the longest substring without repeating characters. The function should utilize the sliding window technique to solve the problem efficiently. **Input Format** - A single input line containing a string `s` (1  |s|  10^5), where `|s|` represents the size of the string. **Output Format** - An integer representing the length of the longest substring that does not contain any repeating characters. **Constraints** - The solution should have a time complexity of O(n), where `n` is the length of the input string. **Example** *Input:* ``` abcabcbb ``` *Output:* ``` 3 ``` *Explanation:* The answer is \\"abc\\", with the length of 3. *Input:* ``` bbbbb ``` *Output:* ``` 1 ``` *Explanation:* The answer is \\"b\\", with the length of 1. **Detailed Requirements** 1. Implement the function `longest_substring_without_repeating_characters(s: str) -> int`. 2. Use a sliding window approach with two pointers to keep track of the current substring being checked. 3. Utilize a hash set to store characters currently in the window to easily check for duplicates. 4. Include thorough handling of edge cases such as empty strings, single-character strings, and long strings with no repeating characters. To summarize your task: - Define a function `longest_substring_without_repeating_characters`. - Use the sliding window technique to ensure O(n) time complexity. - Properly handle edge cases and constraints as specified.","solution":"def longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. if not s: return 0 char_set = set() l = 0 max_length = 0 for r in range(len(s)): while s[r] in char_set: char_set.remove(s[l]) l += 1 char_set.add(s[r]) max_length = max(max_length, r - l + 1) return max_length"},{"question":"# Problem Statement You are required to implement a library management system\'s function that calculates and provides detailed reports on book popularity based on user borrowing history. The goal is to compute statistics that help the library staff understand borrowing trends over time. # Requirements 1. Implement a function `calculate_book_popularity(borrowing_records: List[Tuple[str, str, str]]) -> List[dict]` that: - Takes a list of tuples where each tuple contains three strings: the user\'s ID, the book\'s ID, and the borrowing date in the format \\"YYYY-MM-DD\\". - Outputs a list of dictionaries, each containing the book ID, the total number of times it was borrowed, and the ID of the user who borrowed it the most frequently. # Input - `borrowing_records`: A list of tuples, where each tuple is structured as `(user_id: str, book_id: str, borrow_date: str)`. # Output - Returns a list of dictionaries with the following format: ```python [ { \\"book_id\\": \\"value\\", \\"total_borrows\\": integer, \\"most_frequent_user\\": \\"value\\" }, ... ] ``` # Constraints - Ensure efficiency in processing and aggregating large volumes of records. - Handle cases where multiple users have borrowed the same book the highest number of times. - Maintain chronological correctness, ensuring date formats and related calculations are accurate. # Example ```python records = [ (\\"user1\\", \\"book1\\", \\"2023-01-10\\"), (\\"user2\\", \\"book1\\", \\"2023-01-15\\"), (\\"user1\\", \\"book2\\", \\"2023-02-10\\"), (\\"user1\\", \\"book1\\", \\"2023-03-05\\"), (\\"user3\\", \\"book2\\", \\"2023-03-15\\"), (\\"user2\\", \\"book2\\", \\"2023-03-20\\") ] result = calculate_book_popularity(records) print(result) # Expected Output # [ # { # \\"book_id\\": \\"book1\\", # \\"total_borrows\\": 3, # \\"most_frequent_user\\": \\"user1\\" # }, # { # \\"book_id\\": \\"book2\\", # \\"total_borrows\\": 3, # \\"most_frequent_user\\": \\"user1\\" # } # ] ``` # Function Signature ```python from typing import List, Tuple, dict def calculate_book_popularity(borrowing_records: List[Tuple[str, str, str]]) -> List[dict]: # Your implementation here pass ```","solution":"from typing import List, Tuple from collections import defaultdict def calculate_book_popularity(borrowing_records: List[Tuple[str, str, str]]) -> List[dict]: # Initialize dictionaries to hold borrow counts for books and borrow counts per user book_borrows = defaultdict(int) book_user_borrows = defaultdict(lambda: defaultdict(int)) # Process each record for user_id, book_id, borrow_date in borrowing_records: book_borrows[book_id] += 1 book_user_borrows[book_id][user_id] += 1 # Create result list result = [] for book_id, total_borrows in book_borrows.items(): most_frequent_user = max(book_user_borrows[book_id], key=book_user_borrows[book_id].get) result.append({ \\"book_id\\": book_id, \\"total_borrows\\": total_borrows, \\"most_frequent_user\\": most_frequent_user }) return result"},{"question":"# Coding Assessment Question Scenario You have been hired to develop a feature for a digital library system where users can search for books based on a set of keywords. The system needs to efficiently find all books that match any of the given keywords. Your task is to implement an efficient search algorithm to facilitate this functionality. Task Write a Python function `keyword_search` that implements a keyword-based search on a list of book titles. The function should receive a list of book titles and a list of keywords, and return a list of titles that contain any of the keywords. Function Signature ```python def keyword_search(titles: list, keywords: list) -> list: pass ``` Input * `titles` (list of str): A list of book titles, where each title is a string with a maximum length of 100 characters. * `keywords` (list of str): A list of keywords, where each keyword is a string with a maximum length of 20 characters. * 0 <= len(titles) <= 1000 * 0 <= len(keywords) <= 100 Output * List of strings: Titles that contain any of the keywords. The titles should be returned in the order they appear in the input list. Constraints * The function should handle cases where the titles or keywords list is empty. * The function should be case-insensitive. * Only exact matches of keywords should be considered (substring matches). * Avoid using built-in functions that directly solve the problem. Example ```python >>> keyword_search([\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"1984\\", \\"Moby-Dick\\"], [\\"kill\\", \\"1984\\", \\"whale\\"]) [\'To Kill a Mockingbird\', \'1984\'] >>> keyword_search([\\"Python Programming\\", \\"Introduction to Algorithms\\", \\"Clean Code\\"], [\\"code\\", \\"Data\\"]) [\'Clean Code\'] >>> keyword_search([\\"Alice in Wonderland\\", \\"A Tale of Two Cities\\"], [\\"wonder\\", \\"tale\\"]) [\'Alice in Wonderland\', \'A Tale of Two Cities\'] >>> keyword_search([], [\\"any\\"]) [] >>> keyword_search([\\"Book Title\\"], []) [] ``` Performance Requirements Ensure the function is efficient and can handle the full range of input constraints without significant performance bottlenecks.","solution":"def keyword_search(titles: list, keywords: list) -> list: Returns a list of book titles that contain any of the given keywords. if not titles or not keywords: return [] result = [] lower_keywords = {k.lower() for k in keywords} for title in titles: lower_title = title.lower() if any(keyword in lower_title for keyword in lower_keywords): result.append(title) return result"},{"question":"# Tree Map Implementation You are provided with a partial implementation of a Tree Map (sorted map implemented as a balanced binary search tree) in Python. Your task is to complete the implementation of the TreeMap class, focusing on the following components: 1. **Implement the `put` function** to insert a key-value pair into the tree. 2. **Implement the `get` function** to retrieve the value associated with a given key. 3. **Implement the `remove` function** to delete a key-value pair from the tree. 4. **Ensure the tree remains balanced** after insertion and deletion operations. # Input * Key-value pairs to be inserted into the tree (keys are assumed to be integers). * Keys for which values need to be retrieved or removed. # Output * For the `put` function: No output (it should just update the internal state of the TreeMap object). * For the `get` function: Return the value associated with the given key, or `None` if the key does not exist. * For the `remove` function: No output (it should just update the internal state of the TreeMap object). # Constraints * Keys are unique integers. * The TreeMap must handle edge cases such as balancing after an insertion or deletion and the removal of non-existent keys. # Example ```python # Initialize the TreeMap tree_map = TreeMap() # Insert key-value pairs into the tree tree_map.put(5, \\"five\\") tree_map.put(3, \\"three\\") tree_map.put(7, \\"seven\\") tree_map.put(2, \\"two\\") tree_map.put(4, \\"four\\") # Retrieve values associated with keys print(tree_map.get(3)) # Expected output: \\"three\\" print(tree_map.get(6)) # Expected output: None # Remove a key tree_map.remove(3) print(tree_map.get(3)) # Expected output: None ``` # Notes * Ensure your implementation maintains the tree balanced after each insertion or deletion. * Include appropriate error handling for operations on non-existent keys and any other edge cases. * You may use any self-balancing binary search tree algorithm (e.g., AVL Tree or Red-Black Tree) to implement the TreeMap class.","solution":"class TreeNode: def __init__(self, key, value, height=1): self.key = key self.value = value self.height = height self.left = None self.right = None class TreeMap: def __init__(self): self.root = None def put(self, key, value): if not self.root: self.root = TreeNode(key, value) else: self.root = self._put(self.root, key, value) def _put(self, node, key, value): if not node: return TreeNode(key, value) elif key < node.key: node.left = self._put(node.left, key, value) elif key > node.key: node.right = self._put(node.right, key, value) else: # key == node.key node.value = value return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def get(self, key): return self._get(self.root, key) def _get(self, node, key): if not node: return None elif key < node.key: return self._get(node.left, key) elif key > node.key: return self._get(node.right, key) else: return node.value def remove(self, key): if self.root: self.root = self._remove(self.root, key) def _remove(self, node, key): if not node: return node elif key < node.key: node.left = self._remove(node.left, key) elif key > node.key: node.right = self._remove(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min(node.right) node.key, node.value = temp.key, temp.value node.right = self._remove(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def _get_min(self, node): while node.left: node = node.left return node def _balance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x"},{"question":"# Problem Statement You are given a list of non-negative integers representing the lengths of sides of a triangle. Your task is to implement a function that determines if it is possible to form a triangle with three of these side lengths. A triangle is valid if and only if the sum of any two side lengths is greater than the third side length for all three sides. # Method Signature ```python def can_form_triangle(sides: List[int]) -> bool: Determine if any three side lengths can form a triangle. >>> can_form_triangle([2, 3, 4]) True >>> can_form_triangle([1, 2, 5]) False >>> can_form_triangle([10, 21, 22, 100, 101]) True ``` # Constraints * The list of sides will have between 3 to 1000 elements. * Each side length is a non-negative integer not exceeding 10^6. # Expectations * The function should return `True` if any three side lengths can form a valid triangle. * The function should return `False` otherwise. * The function should be efficient in both time and space complexity. # Examples ```python assert can_form_triangle([2, 3, 4]) == True assert can_form_triangle([1, 2, 5]) == False assert can_form_triangle([10, 21, 22, 100, 101]) == True assert can_form_triangle([2, 2, 2, 2, 5, 6, 12]) == True assert can_form_triangle([1, 1, 2]) == False ``` Implement the `can_form_triangle` function below: ```python def can_form_triangle(sides: List[int]) -> bool: # Your code goes here ```","solution":"from typing import List def can_form_triangle(sides: List[int]) -> bool: Determine if any three side lengths can form a triangle. n = len(sides) # We need at least 3 sides to form a triangle if n < 3: return False # Sort the side lengths in non-decreasing order sides.sort() # Iterate through the sorted side lengths and check the triangle inequality for i in range(n - 2): if sides[i] + sides[i + 1] > sides[i + 2]: return True return False"},{"question":"# Sliding Window Maximum Given an array of integers `nums` and a positive integer `k`, write a function `maxSlidingWindow(nums: List[int], k: int) -> List[int]` that returns the maximum value in each sliding window of size `k`. Requirements: 1. **maxSlidingWindow(nums: List[int], k: int) -> List[int]**: - Takes an integer array `nums` and an integer `k` as input. - Returns a list of integers representing the maximum value in each sliding window of size `k`. Constraints: - The array `nums` will have at least one element. - `1 <= k <= len(nums)`. Example: ```python Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 -> 3 1 [3 -1 -3] 5 3 6 7 -> 3 1 3 [-1 -3 5] 3 6 7 -> 5 1 3 -1 [-3 5 3] 6 7 -> 5 1 3 -1 -3 [5 3 6] 7 -> 6 1 3 -1 -3 5 [3 6 7] -> 7 ``` Note: - You may assume that all integers in the input array are within the range of a 32-bit signed integer. - Use a deque, list, or other suitable data structure to efficiently solve the sliding window maximum problem. - Aim to achieve an O(n) time complexity where n is the length of the array. **Hint**: Consider using a double-ended queue (deque) to maintain the indices of relevant elements in each sliding window. This can help in efficiently determining the maximum value in constant time for each window position.","solution":"from collections import deque from typing import List def maxSlidingWindow(nums: List[int], k: int) -> List[int]: Find the maximum value in each sliding window of size k in the list nums. if not nums: return [] result = [] dq = deque() # Store indices of useful elements for each window for i in range(len(nums)): # Remove elements not within the sliding window if dq and dq[0] < i - k + 1: dq.popleft() # Remove elements which are not greater than the current element while dq and nums[dq[-1]] <= nums[i]: dq.pop() dq.append(i) # The first element in deque is the largest of the window if i >= k - 1: result.append(nums[dq[0]]) return result"},{"question":"# Problem Statement Given a string `s` and a list of words `words`, your task is to determine if `s` can be segmented into a space-separated sequence of one or more words from `words`. You may assume that each word in `words` can be reused multiple times in the segmentation. # Function Signature ```python def word_break(s: str, words: List[str]) -> bool: ``` # Input * A string `s` where (1 leq |s| leq 300). * A list of strings `words` where each string length (1 leq |word_i| leq 20) and (1 leq text{len(words)} leq 1000). # Output * Return a boolean value `True` if `s` can be segmented as described, `False` otherwise. # Constraints 1. The input string `s` will only contain lowercase English letters. 2. Each word in the list `words` will also contain only lowercase English letters. 3. Your implementation should be efficient in terms of both time and memory usage. # Examples ```python >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"aaaab\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) False ``` # Explanation 1. **Example 1**: The string can be segmented as \\"leet code\\". 2. **Example 2**: The string can be segmented as \\"apple pen apple\\". 3. **Example 3**: No possible segmentation. 4. **Example 4**: The string cannot be fully segmented as no word in the list ends with \\"b\\". # Performance Requirements 1. Ensure that your implementation efficiently checks for possible segmentations. 2. Aim for a time complexity around (O(n cdot m)), where (n) is the length of the string `s` and (m) is the number of words in `words`.","solution":"from typing import List def word_break(s: str, words: List[str]) -> bool: word_set = set(words) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"# Problem Statement You are assigned the task of creating a text processing class that can perform various transformations on a given string. The class should include methods to convert the string to uppercase, lowercase, swap the case of all characters, and reverse the string. # Function Signature ```python class TextProcessor: def __init__(self, text): pass def to_uppercase(self): pass def to_lowercase(self): pass def swap_case(self): pass def reverse_text(self): pass ``` # Implementation Details Class Initialization * **Constructor**: - Accepts a single parameter `text`. Methods to Implement * **to_uppercase**: Converts the input text to uppercase. - Input: No input other than `self`. - Output: Uppercase version of the initialized text. * **to_lowercase**: Converts the input text to lowercase. - Input: No input other than `self`. - Output: Lowercase version of the initialized text. * **swap_case**: Swaps the case of all characters in the input text. - Input: No input other than `self`. - Output: Text with all character cases swapped. * **reverse_text**: Reverses the input text. - Input: No input other than `self`. - Output: Reversed version of the initialized text. Constraints 1. `text` is a string containing printable ASCII characters. 2. The length of `text` will not exceed 10^4 characters. # Example Usage ```python # Create a TextProcessor object with the initial text processor = TextProcessor(\\"Hello, World!\\") # Convert text to uppercase print(processor.to_uppercase()) # Output: \\"HELLO, WORLD!\\" # Convert text to lowercase print(processor.to_lowercase()) # Output: \\"hello, world!\\" # Swap the case of the text print(processor.swap_case()) # Output: \\"hELLO, wORLD!\\" # Reverse the text print(processor.reverse_text()) # Output: \\"!dlroW ,olleH\\" ``` Submit your implementation of the `TextProcessor` class.","solution":"class TextProcessor: def __init__(self, text): self.text = text def to_uppercase(self): return self.text.upper() def to_lowercase(self): return self.text.lower() def swap_case(self): return self.text.swapcase() def reverse_text(self): return self.text[::-1]"},{"question":"You are given a grid with various types of terrain. Each cell in the grid can be either water, land, or mountain. Your task is to determine the size of the largest connected component of land cells. Two land cells are connected if they are adjacent horizontally or vertically, but not diagonally. **Task**: Implement a function to compute the size of the largest connected component of land cells in the grid. **Function Signature**: ```python def largest_land_component(grid: List[List[str]]) -> int: Args: grid : List[List[str]] : A 2D list representing the terrain grid, where \'L\' represents land, \'W\' represents water, and \'M\' represents a mountain. Returns: int : The size of the largest connected component of land cells. ``` # Input * A 2D list `grid` representing the terrain where each cell is either \'L\' (land), \'W\' (water), or \'M\' (mountain). * The dimensions of the grid range from 1 x 1 to 1000 x 1000. # Output * An integer representing the size of the largest connected component of land cells. # Example ```python grid = [ [\'L\', \'L\', \'W\', \'M\'], [\'L\', \'W\', \'L\', \'L\'], [\'M\', \'L\', \'L\', \'W\'] ] print(largest_land_component(grid)) # Output: 4 ``` # Explanation - The largest connected component of land cells in the given grid is of size 4. # Constraints * Ensure your solution efficiently handles the constraints, utilizing depth-first search (DFS) or breadth-first search (BFS) to explore connected components.","solution":"def largest_land_component(grid): Args: grid : List[List[str]] : A 2D list representing the terrain grid, where \'L\' represents land, \'W\' represents water, and \'M\' represents a mountain. Returns: int : The size of the largest connected component of land cells. if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != \'L\': return 0 grid[x][y] = \'V\' # mark the cell as visited size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(x + dx, y + dy) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'L\': max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"# Fibonacci Sequence Calculation You are given a task to implement two methods to calculate the (n)-th Fibonacci number: the Recursive Method and the Iterative Method. To further assess understanding, design a function that compares the performance of both methods. Objective Create a function `compare_fib_methods(n: int) -> int` that: 1. Calculates the (n)-th Fibonacci number using both the recursive method and the iterative method. 2. Ensures both methods return the same result. 3. Returns the Fibonacci number if both methods match, else raises an error. Your task is to: - Implement the `compare_fib_methods` function. - Ensure proper handling of edge cases like (n = 0) and (n = 1). - Systematically handle any potential error scenarios. # Function Signature ```python def compare_fib_methods(n: int) -> int: pass ``` Input - `n`: An integer representing which Fibonacci number to calculate. Output - An integer that is the (n)-th Fibonacci number calculated by both methods. Example ```python # Example: Calculating the 10th Fibonacci number # Both methods should yield 55 print(compare_fib_methods(10)) ``` # Constraints - The input (n) will be a non-negative integer. - The result should match for both the recursive and iterative implementations. If not, raise an error. - Handle performance efficiently for larger (n) values. Make sure the results from both methods match accurately before returning the result.","solution":"def fibonacci_recursive(n): if n <= 1: return n return fibonacci_recursive(n-1) + fibonacci_recursive(n-2) def fibonacci_iterative(n): if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def compare_fib_methods(n): if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") fib_recursive = fibonacci_recursive(n) fib_iterative = fibonacci_iterative(n) if fib_recursive != fib_iterative: raise AssertionError(\\"Mismatch between recursive and iterative methods\\") return fib_recursive"},{"question":"# Coding Assessment Question **Title**: Implement Circular Buffer with Fixed Size **Objective**: Develop a circular buffer that supports typical queue operations with a fixed buffer size. Your task is to ensure efficient use of space and handling of overflow situations. **Context**: A circular buffer, also known as a ring buffer, is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure is ideal for applications where the input stream is steady and ongoing, like real-time data streams or buffering data for IO operations. **Task**: Write a `CircularBuffer` class that implements the following methods: `enqueue`, `dequeue`, `peek`, `is_full`, and `is_empty`. The buffer should handle overflow conditions by overwriting the oldest data when the buffer is full. # Requirements Class Definition ```python class CircularBuffer: def __init__(self, size: int): Initialize the circular buffer with a fixed size. Args: size (int): The size of the buffer. pass def enqueue(self, value: int) -> None: Add an element to the end of the buffer. Args: value (int): The value to be added. pass def dequeue(self) -> int: Remove and return the oldest element from the buffer. Returns: int: The value removed from the buffer. pass def peek(self) -> int: Get the value of the oldest element without removing it. Returns: int: The value at the front of the buffer. pass def is_full(self) -> bool: Check if the buffer is full. Returns: bool: True if the buffer is full, otherwise False. pass def is_empty(self) -> bool: Check if the buffer is empty. Returns: bool: True if the buffer is empty, otherwise False. pass ``` # Constraints and Input: 1. **Size**: The size of the buffer will always be a positive integer. 2. **Value**: The values added to the buffer will be integers. 3. **Operations**: All operations should work in constant time, O(1). Examples: **Example 1** ```python buffer = CircularBuffer(3) buffer.enqueue(1) buffer.enqueue(2) buffer.enqueue(3) print(buffer.dequeue()) # Output: 1 print(buffer.peek()) # Output: 2 buffer.enqueue(4) print(buffer.is_full()) # Output: True print(buffer.dequeue()) # Output: 2 print(buffer.dequeue()) # Output: 3 print(buffer.dequeue()) # Output: 4 print(buffer.is_empty()) # Output: True ``` **Example 2** ```python buffer = CircularBuffer(2) buffer.enqueue(10) buffer.enqueue(20) print(buffer.is_full()) # Output: True buffer.enqueue(30) print(buffer.peek()) # Output: 20 (10 gets overwritten) print(buffer.dequeue()) # Output: 20 print(buffer.dequeue()) # Output: 30 print(buffer.is_empty()) # Output: True ``` # Performance Requirements: - The solution should operate efficiently for buffer sizes up to 100 elements. # Assumptions: - You can assume valid input is provided for all methods.","solution":"class CircularBuffer: def __init__(self, size: int): Initialize the circular buffer with a fixed size. Args: size (int): The size of the buffer. self.size = size self.buffer = [None] * size self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, value: int) -> None: Add an element to the end of the buffer. Args: value (int): The value to be added. if self.is_full(): # Overwrite the oldest data self.head = (self.head + 1) % self.size else: self.count += 1 self.buffer[self.tail] = value self.tail = (self.tail + 1) % self.size def dequeue(self) -> int: Remove and return the oldest element from the buffer. Returns: int: The value removed from the buffer. if self.is_empty(): raise IndexError(\\"Buffer is empty\\") value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return value def peek(self) -> int: Get the value of the oldest element without removing it. Returns: int: The value at the front of the buffer. if self.is_empty(): raise IndexError(\\"Buffer is empty\\") return self.buffer[self.head] def is_full(self) -> bool: Check if the buffer is full. Returns: bool: True if the buffer is full, otherwise False. return self.count == self.size def is_empty(self) -> bool: Check if the buffer is empty. Returns: bool: True if the buffer is empty, otherwise False. return self.count == 0"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase letters and a list of words `words`, where each word is a subsequence of `s`. We define a word `w` as a good subsequence if there is a subsequence of `s` that matches `w` exactly and the length of `w` is the maximum possible among the given words. The task is to implement a function that returns all such good subsequences from the list of words and sorts them in lexicographical order. # Function Signature ```python def good_subsequences(s: str, words: List[str]) -> List[str]: ``` # Input * `s` (str): The string consisting of lowercase letters `1  |s|  10^4`. * `words` (List[str]): The list of words where each word is a subsequence of `s`. Each word in the list has a length between `1` and `|s|`. The number of words in the list does not exceed `10^3`. # Output * Return a list of all good subsequences sorted in lexicographical order. # Example ```python assert good_subsequences(\'abacb\', [\'ab\', \'abc\', \'bc\', \'ac\', \'b\']) == [\'abc\'] assert good_subsequences(\'xyz\', [\'x\', \'yz\', \'xy\', \'zzz\', \'xyz\']) == [\'xyz\'] assert good_subsequences(\'abbccc\', [\'a\', \'b\', \'ab\', \'c\', \'abc\']) == [\'abc\'] ``` # Constraints - `1  |s|  10^4` - The length of each word in `words` is between `1` and `|s|` - The number of words in `words` does not exceed `10^3`. # Hints 1. When several words are of the same maximal length, sort them and return all of them. 2. Use two pointers or dynamic programming to determine if a word is a subsequence of another string. 3. It might be useful to first identify the maximum length among the subsequences present in the list.","solution":"from typing import List def is_subsequence(s: str, word: str) -> bool: Check if word is a subsequence of s. it = iter(s) return all(char in it for char in word) def good_subsequences(s: str, words: List[str]) -> List[str]: max_length = 0 good_words = [] # Check each word if it is a subsequence of s and identify the maximum length for word in words: if is_subsequence(s, word): if len(word) > max_length: max_length = len(word) good_words = [word] elif len(word) == max_length: good_words.append(word) return sorted(good_words)"},{"question":"# Binary Search with Custom Comparator Context Binary Search is a fundamental algorithm in computer science for finding the position of a target value within a sorted array. It works by comparing the target value to the middle element and dividing the search interval in half. This algorithm can be extended to use custom comparators, making it versatile for different kinds of data and custom sorting orders. Objective Write a Python function to perform binary search on a sorted list using a custom comparator. Your implementation should allow for the specification of any order of comparison, accommodating descending orders or custom comparison strategies. Core Implementation Requirements 1. Implement a function `binary_search(arr, target, comparator)` with the following parameters: - `arr`: A list of elements sorted according to the provided comparator. - `target`: The value to search for within the list. - `comparator`: A function that takes two elements and returns: - A negative number if the first element is considered less than the second, - Zero if they are considered equal, - A positive number if the first element is considered greater than the second. 2. Your function should return the index of the target if found, or `-1` if the target is not present in the list. 3. Handle lists sorted in both ascending and descending orders via the custom comparator. Constraints - Ensure the list `arr` is pre-sorted according to the custom comparator. - Optimize the function to use O(log n) time complexity, where n is the number of elements in `arr`. Example Comparator Function A custom comparator for descending order: ```python def descending_comparator(a, b): return b - a ``` Example Usage Here\'s an example to illustrate the usage: ```python if __name__ == \\"__main__\\": arr = [9, 7, 5, 3, 1] # Custom comparator for descending order def descending_comparator(a, b): return b - a # Perform binary search for target 5 in descending order index = binary_search(arr, 5, descending_comparator) print(index) # Output: 2 # Perform binary search for a target not present index = binary_search(arr, 10, descending_comparator) print(index) # Output: -1 ``` Your task is to complete the `binary_search` function meeting the specified requirements.","solution":"def binary_search(arr, target, comparator): Perform binary search on a sorted array using a custom comparator. Parameters: arr (list): A list of elements sorted according to the provided comparator. target: The value to search for within the list. comparator (function): A function that compares two elements. Returns: int: The index of the target if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 comp_result = comparator(arr[mid], target) if comp_result == 0: return mid elif comp_result < 0: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: Implementing and Identifying Median of Running Stream Context You are working on an application that requires real-time statistical analysis of a continuous stream of data. One crucial task is to compute the median of the data received so far at any given point in time. Your role is to implement a class that manages the running stream and provide an efficient way to access the median. Task 1. Implement a class `RunningMedian` that: - Keeps track of the data stream. - Provides a method to add a new value to the stream. - Provides a method to retrieve the median of the current stream. 2. Test your implementation on a given sequence of numbers. Requirements * **Class Specification**: - The class will have a method `add_number(number: float) -> None`, which adds a new number to the stream. - The class will have a method `get_median() -> float`, which returns the median of the numbers in the stream. * **Constraints**: - The implementation should support adding numbers and retrieving the median in logarithmic time on average. - The stream can contain up to (10^5) numbers. * **Performance**: - Ensure the implementation efficiently manages large amounts of data. - The solution should handle both even and odd counts of numbers seamlessly. # Example ```python from heapq import heappush, heappop class RunningMedian: def __init__(self): # Min-heap for the larger half of the stream self.min_heap = [] # Max-heap for the smaller half of the stream self.max_heap = [] def add_number(self, number: float) -> None: if not self.max_heap or number <= -self.max_heap[0]: heappush(self.max_heap, -number) else: heappush(self.min_heap, number) # Balance the heaps if necessary if len(self.max_heap) > len(self.min_heap) + 1: heappush(self.min_heap, -heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heappush(self.max_heap, -heappop(self.min_heap)) def get_median(self) -> float: if len(self.min_heap) == len(self.max_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 return float(-self.max_heap[0]) # Example of adding numbers and retrieving medians rm = RunningMedian() numbers = [1, 5, 2, 10, -1] for num in numbers: rm.add_number(num) print(f\\"Added: {num}, Current Median: {rm.get_median()}\\") ``` This question assesses the candidate\'s ability to implement data structures, handle real-time processing, and work with heap operations to maintain efficient median calculation.","solution":"from heapq import heappush, heappop class RunningMedian: def __init__(self): # Min-heap for the larger half of the stream self.min_heap = [] # Max-heap for the smaller half of the stream (inverted) self.max_heap = [] def add_number(self, number: float) -> None: if not self.max_heap or number <= -self.max_heap[0]: heappush(self.max_heap, -number) else: heappush(self.min_heap, number) # Balance the heaps if len(self.max_heap) > len(self.min_heap) + 1: heappush(self.min_heap, -heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heappush(self.max_heap, -heappop(self.min_heap)) def get_median(self) -> float: if len(self.max_heap) == len(self.min_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 return float(-self.max_heap[0])"},{"question":"# Coding Assessment Question: Enhanced Weather Data Fetcher You are tasked to create an enhanced version of the `get_weather` function that retrieves weather data and provides additional features and improvements: 1. **Input Parameters and Constraints**: - `city` (str): The name of the city to fetch weather data for. - `days` (int): Number of days of weather data to return. Must be a positive integer  7 (default: 3). - `units` (str): Units for temperature (\'metric\', \'imperial\', or \'standard\'). Default is \'metric\'. - The function should use a default API key variable `weather_api_key` and access the OpenWeatherMap API. 2. **Function Output**: - Should return a list of dictionaries, each containing the following fields: - `date`: The date for the weather data. - `temperature`: The average temperature for the day. - `description`: A short weather description (e.g., \\"clear sky\\", \\"rain\\"). 3. **Error Handling**: - Properly handle network failures and timeouts. - Handle invalid input parameters (e.g., negative days, invalid city name). - Raise appropriate exceptions or return informative error messages. 4. **Performance Considerations**: - Implement error handling for API rate limits or large response sizes. - Consider introducing caching mechanisms for repeated queries if needed. # Function Signature ```python def enhanced_get_weather(city: str, days: int = 3, units: str = \'metric\') -> list: ``` # Example Usage ```python # Example call to the function forecast = enhanced_get_weather(\\"New York\\", days=2, units=\\"imperial\\") for day in forecast: print(f\\"Date: {day[\'date\']}, Temperature: {day[\'temperature\']}, Description: {day[\'description\']}\\") ``` # Notes - Use the `requests` library for HTTP requests. - Refer to the OpenWeatherMap API documentation for more details on available parameters and response structure: https://openweathermap.org/api","solution":"import requests def enhanced_get_weather(city: str, days: int = 3, units: str = \'metric\') -> list: Fetches weather data for a given city from the OpenWeatherMap API. Parameters: city (str): The name of the city to fetch weather data for. days (int): Number of days of weather data to return. Must be a positive integer  7 (default: 3). units (str): Units for temperature (\'metric\', \'imperial\', or \'standard\'). Default is \'metric\'. Returns: list: A list of dictionaries containing weather data. # Validate input parameters if not isinstance(city, str) or not city: raise ValueError(\\"Invalid city name\\") if not isinstance(days, int) or days <= 0 or days > 7: raise ValueError(\\"Days must be a positive integer  7\\") if units not in [\'metric\', \'imperial\', \'standard\']: raise ValueError(\\"Units must be \'metric\', \'imperial\', or \'standard\'\\") weather_api_key = \\"YOUR_API_KEY\\" # Replace with a valid API key url = f\\"http://api.openweathermap.org/data/2.5/forecast/daily?q={city}&cnt={days}&units={units}&appid={weather_api_key}\\" try: response = requests.get(url, timeout=10) response.raise_for_status() except requests.RequestException as e: raise RuntimeError(f\\"An error occurred while fetching weather data: {e}\\") data = response.json() forecast = [] for day_data in data.get(\\"list\\", []): day_forecast = { \'date\': day_data[\'dt\'], \'temperature\': day_data[\'temp\'][\'day\'], \'description\': day_data[\'weather\'][0][\'description\'] } forecast.append(day_forecast) return forecast"},{"question":"# Coding Assessment Question Context In computer science, a palindrome is a string that reads the same forward and backward. Given a string, your task is to determine the minimum number of character deletions required to make the given string a palindrome. Task Write a function `min_deletions_to_palindrome(s: str) -> int` that returns the minimum number of deletions needed to make the given string a palindrome. Input * A string (s) where (1 leq text{len}(s) leq 1000). Output * An integer representing the minimum number of deletions required to make the string a palindrome. Constraints * The function should efficiently handle the input length constraint. Example ```python def min_deletions_to_palindrome(s: str) -> int: # Implementation here pass # Example Usage print(min_deletions_to_palindrome(\\"abccba\\")) # Output: 0 print(min_deletions_to_palindrome(\\"abcdef\\")) # Output: 5 print(min_deletions_to_palindrome(\\"aebcbda\\")) # Output: 2 ``` # Requirements * Utilize dynamic programming to solve the problem. * Implement an efficient algorithm to compute the solution within the given constraints.","solution":"def min_deletions_to_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the given string a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for _ in range(n)] for _ in range(n)] # Build the table. dp[i][j] will be storing the minimum number of deletions required # to make the substring s[i to j] a palindrome. for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1 # The result is the minimum number of deletions required to make the whole string a palindrome return dp[0][n-1]"},{"question":"# Scenario You\'re building a statistics library that includes functions for various probability distributions. As part of this, you need to implement a function that calculates the binomial coefficient, which is a central element in computing probabilities for the binomial distribution. # Problem Statement Write a Python function `binomial_coefficient(n, k)` that returns the binomial coefficient \\"n choose k\\", which represents the number of ways to choose k items from n items without regard to the order of selection. Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` Input - `n` (int): The total number of items (0 <= n <= 50). - `k` (int): The number of items to choose (0 <= k <= n). Output - `int`: The binomial coefficient \\"n choose k\\". Constraints - Ensure that the implementation efficiently handles the given constraints. # Examples ```python # Example 1 assert binomial_coefficient(5, 2) == 10 # 5 choose 2 is 10 # Example 2 assert binomial_coefficient(6, 3) == 20 # 6 choose 3 is 20 # Example 3 assert binomial_coefficient(10, 0) == 1 # 10 choose 0 is 1 ``` # Notes - Recall the formula for the binomial coefficient: C(n, k) = n! / (k! * (n - k)!) - Focus on optimizing your function to handle larger values within the provided constraints. - Consider using dynamic programming or iterative approaches to avoid the inefficiencies of computing factorials directly for large `n`.","solution":"def binomial_coefficient(n: int, k: int) -> int: Computes the binomial coefficient (\\"n choose k\\"). if k > n: return 0 if k == 0 or n == k: return 1 # Take advantage of the symmetry property k = min(k, n - k) c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"# Coding Assessment Question **Balanced Brackets** Given a string containing just the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`, write a function to determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. **Function Signature:** ```python def is_balanced(s: str) -> bool: ``` **Input:** * A single string `s`, (1 leq len(s) leq 10^4), representing a sequence of brackets. **Output:** * Returns `True` if the brackets are balanced. * Returns `False` otherwise. **Constraints:** * Only the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'` are considered. **Examples:** ```python >>> is_balanced(\\"()\\") True >>> is_balanced(\\"()[]{}\\") True >>> is_balanced(\\"(]\\") False ``` **Context:** * This problem tests understanding of stack data structures and their application in validating sequence-related problems. * It is commonly used in parsing and interpreter implementations where matching constructs are crucial. **Requirements:** 1. Implement the stack-based approach to check for balanced brackets. 2. Ensure the solution handles edge cases such as empty strings and misordered pairs. 3. Optimize for performance to efficiently handle large inputs up to the maximum constraint.","solution":"def is_balanced(s: str) -> bool: stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or stack.pop() != matching_bracket[char]: return False else: return False return stack == []"},{"question":"Context You are working on a project that involves string manipulations, and one common task is extracting acronyms from given phrases. Acronyms are widely used to make communication terse and meaningful, especially in technical documentation. Task Implement a function that takes a phrase and returns its acronym. The acronym should consist of the first letter of each word in upper case. Function Specification ```python def generate_acronym(phrase: str) -> str: This function should return the acronym formed from the given phrase. Arguments: phrase (str): the input phrase from which to generate the acronym. Returns: str: The acronym formed by using the first letter of each word in the phrase, in uppercase. Example: >>> generate_acronym(\\"object oriented programming\\") \'OOP\' >>> generate_acronym(\\"As Soon As Possible\\") \'ASAP\' >>> generate_acronym(\\"random access memory\\") \'RAM\' >>> generate_acronym(\\"Central Processing Unit\\") \'CPU\' pass # Your code here ``` Constraints 1. The phrase will consist of alphabetic characters and spaces only. 2. Words in the phrase are separated by a single space. 3. The phrase will have at least one word. Performance Requirements The function should have a time complexity of O(n), where n is the length of the phrase, and a space complexity of O(k), where k is the number of words in the phrase. Your Task Implement the function `generate_acronym` as specified. Ensure that your function passes all the given test cases.","solution":"def generate_acronym(phrase: str) -> str: This function returns the acronym formed from the given phrase. Arguments: phrase (str): the input phrase from which to generate the acronym. Returns: str: The acronym formed by using the first letter of each word in the phrase, in uppercase. Example: >>> generate_acronym(\\"object oriented programming\\") \'OOP\' >>> generate_acronym(\\"As Soon As Possible\\") \'ASAP\' >>> generate_acronym(\\"random access memory\\") \'RAM\' >>> generate_acronym(\\"Central Processing Unit\\") \'CPU\' words = phrase.split() acronym = \'\'.join(word[0].upper() for word in words) return acronym"},{"question":"# Social Media Post Scheduler Background A social media manager is responsible for scheduling posts across various platforms. They want to automate the process of scheduling posts to ensure they are evenly distributed over a given period. They also want to balance the content by categorizing each post under one of several predefined topics, ensuring no topic is over-represented or under-represented. Problem Statement Create a system to automate the scheduling of social media posts while meeting the following requirements: 1. Distribute posts evenly across a given number of days. 2. Ensure that each topic is represented as evenly as possible within the period. Requirements 1. **Function Signatures and Definitions**: - `class Scheduler(days, posts)`: Constructor to initialize the scheduler with the number of days and a list of posts. Each post is represented as a dictionary with `content` and `topic` keys. - `def schedule()`: Distribute the posts evenly across the specified days. - `def get_schedule()`: Return the scheduled posts as a list of lists, where each inner list represents the posts for a single day. 2. **Input/Output**: - Initialize the scheduler with the number of days and posts. - Schedule the posts based on the requirements. - Retrieve the schedule using the `get_schedule` method. 3. **Constraints**: - The number of days should be a positive integer. - The list of posts should contain dictionaries with `content` and `topic`. - Each day should have at least one post, and the content should be balanced by topic as much as possible. Objectives - Understand the principles of scheduling and balancing workload. - Implement and test the scheduling functionality to ensure even distribution over time. - Optimize topic representation to avoid overloading any single topic. Implement the `Scheduler` class to achieve the specified functionality and constraints.","solution":"from collections import defaultdict import itertools class Scheduler: def __init__(self, days, posts): self.days = days self.posts = posts self.schedule_list = [[] for _ in range(days)] def schedule(self): # Count posts by topic topic_dict = defaultdict(list) for post in self.posts: topic_dict[post[\'topic\']].append(post) balanced_posts = [] while topic_dict: topics = list(topic_dict.keys()) for topic in topics: if topic_dict[topic]: balanced_posts.append(topic_dict[topic].pop(0)) if not topic_dict[topic]: del topic_dict[topic] # Distribute posts evenly across days day_index = 0 for post in balanced_posts: self.schedule_list[day_index].append(post) day_index = (day_index + 1) % self.days def get_schedule(self): return self.schedule_list"},{"question":"# Problem Statement You are given a list of integers. Your task is to implement a function that performs a \\"k-reverse\\" on the list. The \\"k-reverse\\" operation involves reversing every contiguous sublist of length `k`. If the number of elements in the list is not a multiple of `k`, the final sublist (if any) should also be reversed, even if its length is less than `k`. # Requirements Implement the function `k_reverse(arr: list, k: int) -> list` such that: 1. The function accepts a list of integers and an integer `k`. 2. It returns a new list with every sublist of length `k` reversed. The final sublist may be shorter if the length of the list is not a multiple of `k`. 3. If `k` is non-positive, the function should raise a `ValueError` with a message. # Input Format - `arr`: A list of integers. - `k`: An integer specifying the length of sublists to reverse. # Output Format - A list of integers with the modified sublists. # Constraints - You may assume the elements in the list are integers within the range [-10^6, 10^6]. - The size of the list `n` will be such that `1 <= n <= 10000`. - The value of `k` will be such that `1 <= k <= 1000`. # Performance Requirements Ensure that the function is optimized to handle the upper constraint limits efficiently. # Example 1. Example 1: - Input: `arr = [1, 2, 3, 4, 5, 6, 7, 8]`, `k = 3` - Output: `[3, 2, 1, 6, 5, 4, 8, 7]` 2. Example 2: - Input: `arr = [1, 2, 3, 4, 5]`, `k = 2` - Output: `[2, 1, 4, 3, 5]` 3. Example 3: - Input: `arr = [1, 2, 3, 4, 5]`, `k = 1` - Output: `[1, 2, 3, 4, 5]` # Edge Cases - `k` is greater than the length of the list. - `k` equals the length of the list. - `k` is one. - An empty list input. - Non-integer inputs for `k`. ```python def k_reverse(arr: list, k: int) -> list: :param arr: a list of integers :param k: length of sublists to reverse :return: a list with every sublist of length k reversed Raises: ValueError: If k is non-positive. if not isinstance(k, int) or k <= 0: raise ValueError(f\\"The input value of k must be a positive integer, but got {k}\\") n = len(arr) return [arr[i:i+k][::-1] for i in range(0, n, k)] # Flattening the result from list of lists to a single list flattened_list = [element for sublist in k_reverse(arr, k) for element in sublist] ``` Test your function with edge cases and various inputs to ensure robustness and correctness.","solution":"def k_reverse(arr: list, k: int) -> list: :param arr: a list of integers :param k: length of sublists to reverse :return: a list with every sublist of length k reversed Raises: ValueError: If k is non-positive. if not isinstance(k, int) or k <= 0: raise ValueError(f\\"The input value of k must be a positive integer, but got {k}\\") n = len(arr) result = [] for i in range(0, n, k): sublist = arr[i:i + k] result.extend(sublist[::-1]) return result"},{"question":"# Organize Students by Height **Scenario**: You are tasked with creating an algorithm to organize students for a group photo. Each student has a specific height, and they need to be arranged in three different rows such that the height difference between any two students adjacent to each other in any row is minimized. **Task**: Write a function `organize_students(heights: list[int]) -> tuple[list[int], list[int], list[int]]` that takes a list of students\' heights and arranges them into three rows following these rules: * Each row should have as close to the same number of students as possible. * Minimize the height difference between adjacent students within the same row. **Input**: * `heights` - A list of integers where each integer represents a student\'s height. **Output**: * Return a tuple containing three lists where each list represents a row of students\' heights. **Constraints**: * 1 <= len(heights) <= 1000 * All height values are distinct positive integers. **Example**: ```python >>> organize_students([150, 160, 170, 180, 190, 200, 210, 220, 230]) ([150, 180, 220], [160, 190, 230], [170, 200, 210]) >>> organize_students([130, 140, 150, 160, 170]) ([130, 150], [140, 160], [170]) ``` **Note**: - Make sure to allocate students evenly across the rows when their total count is not perfectly divisible by three. - Employ sorting and strategic splitting of the list to achieve the minimum height difference between students in each row. - Consider different methods to systematically distribute the students\' heights into rows to achieve the required conditions.","solution":"def organize_students(heights): Organizes students\' heights into three rows such that each row has as close to the same number of students as possible, and the height difference between adjacent students within the same row is minimized. Parameters: heights (list of int): List of students\' heights. Returns: tuple of list of int: A tuple with three lists where each list represents a row of students\' heights. # Sort the heights to minimize the height difference sorted_heights = sorted(heights) # Initialize three rows row1, row2, row3 = [], [], [] # Distribute the heights to minimize height difference in rows for i in range(len(sorted_heights)): if i % 3 == 0: row1.append(sorted_heights[i]) elif i % 3 == 1: row2.append(sorted_heights[i]) else: row3.append(sorted_heights[i]) return row1, row2, row3"},{"question":"# Problem Statement You are given a list of strings containing a mix of alphabets and numbers. Your task is to write a function that returns a new list of strings where each string is sorted such that all numerical characters appear before the alphabetical characters, and within the numerical and alphabetical sections, characters are in the same relative order as they appeared in the original string. # Input - A list of strings `str_list` where each string contains a mix of uppercase/lowercase alphabets and numbers. # Output - A list of strings with numbers sorted before alphabets while maintaining their relative order within each category. # Constraints - 1 <= length of each string in `str_list` <= 100 - 1 <= number of strings in `str_list` <= 100 # Example ```python sort_strings([\'a1b2c\',\'3d4e5f\']) ``` Expected Output: ```python [\'12abc\', \'345def\'] ``` # Implementation ```python from typing import List def sort_strings(str_list: List[str]) -> List[str]: sorted_list = [] for s in str_list: numbers = \'\'.join([ch for ch in s if ch.isdigit()]) letters = \'\'.join([ch for ch in s if ch.isalpha()]) sorted_list.append(numbers + letters) return sorted_list ``` # Note Ensure the function maintains the relative order of both numerical and alphabetical characters as they were in the input string but places all numerical characters before alphabetical characters in the result.","solution":"from typing import List def sort_strings(str_list: List[str]) -> List[str]: sorted_list = [] for s in str_list: numbers = \'\'.join([ch for ch in s if ch.isdigit()]) letters = \'\'.join([ch for ch in s if ch.isalpha()]) sorted_list.append(numbers + letters) return sorted_list"},{"question":"# Coding Challenge: Efficient Sentence Search Algorithm Scenario You are developing a text analysis tool that parses long documents and highlights sentences containing a specific target word. The current implementation is slow with large text files, so you need to optimize the search algorithm. Task Write a function `find_sentences_with_word(text, target_word)` that efficiently finds all the sentences containing a specified word. Expected Function Signature ```python def find_sentences_with_word(text: str, target_word: str) -> list: text: A string representing the entire text document. target_word: A string representing the word to search for within the document. ``` Input - A `text` string of arbitrary length containing multiple sentences. - A `target_word` string representing the word to be found in the sentences. Output - A list of strings, where each string is a sentence from the text that contains the target word. Constraints - **Performance Requirement**: Your algorithm should handle documents of up to 1 million characters efficiently. Focus on minimizing the time complexity of the search operation. - The sentences are considered to be separated by periods (`.`), exclamation points (`!`), and question marks (`?`). - The target word match should be case-insensitive. Example ```python text = (\\"This is a sample document. It contains several sentences. \\" \\"Each sentence needs to be scanned for the target word. \\" \\"Once found, the sentence will be added to the result. \\" \\"This example helps to demonstrate the sentence search algorithm.\\") target_word = \\"sentence\\" # Find and print all sentences containing the target word matching_sentences = find_sentences_with_word(text, target_word) print(matching_sentences) # Output: [\'It contains several sentences.\', \'Each sentence needs to be scanned for the target word.\'] ``` Additional Information - Pay attention to edge cases such as when the text does not contain any sentences with the target word, or when the text is empty. - Consider using regular expressions or string processing libraries to aid in sentence splitting and word matching.","solution":"import re def find_sentences_with_word(text: str, target_word: str) -> list: This function takes a text string and a target word, and returns a list of sentences that contain the target word. Parameters: text (str): The text to search through. target_word (str): The word to search for in the text. Returns: list: A list of sentences that contain the target word. sentences = re.split(r\'[.!?]\', text) target_word_lower = target_word.lower() results = [] for sentence in sentences: words = re.findall(r\'bw+b\', sentence.lower()) if target_word_lower in words: cleaned_sentence = sentence.strip() if cleaned_sentence: results.append(cleaned_sentence.strip()) return results"},{"question":"# Coding Assessment Question Scenario You are developing a feature for a digital wallet application. One of the critical functions you need is to determine whether a given transaction history contains any duplicate transactions based on their transaction IDs. Each transaction is represented as a dictionary containing information such as transaction ID, amount, date, and description. Task Implement a Python function to identify if there are any duplicate transactions in a list of transactions by checking the transaction IDs. Function Signature ```python def has_duplicate_transactions(transactions: List[Dict[str, Union[int, str, float]]]) -> bool: ``` Input - `transactions`: A list of dictionaries, each representing a transaction with the following keys: - `id`: An integer representing the transaction ID. - `amount`: A float representing the transaction amount. - `date`: A string representing the transaction date. - `description`: A string representing the transaction description. Output - A boolean value indicating whether there are duplicate transactions based on the transaction IDs. Constraints - Each dictionary will always contain the keys `id`, `amount`, `date`, and `description`. - `id` will be a non-negative integer (0  id  10^6). - `amount` will be a non-negative float (0.0  amount  10^6). - `date` will be a valid date string in the format \'YYYY-MM-DD\'. - The number of transactions can range from 1 to 10^5. Example ```python transactions = [ {\\"id\\": 101, \\"amount\\": 150.0, \\"date\\": \\"2022-01-01\\", \\"description\\": \\"Grocery shopping\\"}, {\\"id\\": 102, \\"amount\\": 200.0, \\"date\\": \\"2022-01-02\\", \\"description\\": \\"Utility bill\\"}, {\\"id\\": 103, \\"amount\\": 50.0, \\"date\\": \\"2022-01-03\\", \\"description\\": \\"Coffee\\"}, {\\"id\\": 101, \\"amount\\": 150.0, \\"date\\": \\"2022-01-01\\", \\"description\\": \\"Grocery shopping\\"} # Duplicate ] assert has_duplicate_transactions(transactions) == True transactions = [ {\\"id\\": 101, \\"amount\\": 100.0, \\"date\\": \\"2022-01-01\\", \\"description\\": \\"Book purchase\\"}, {\\"id\\": 102, \\"amount\\": 150.0, \\"date\\": \\"2022-02-01\\", \\"description\\": \\"Grocery shopping\\"} ] assert has_duplicate_transactions(transactions) == False ``` Note Consider optimizing for time complexity given the potentially large number of transactions. Ensure the function correctly identifies duplicates based on transaction IDs.","solution":"from typing import List, Dict, Union def has_duplicate_transactions(transactions: List[Dict[str, Union[int, str, float]]]) -> bool: Determines if there are any duplicate transactions based on transaction IDs. :param transactions: List of dictionaries, each representing a transaction. :return: Boolean value indicating if there are any duplicate transactions based on IDs. seen_ids = set() for transaction in transactions: transaction_id = transaction[\\"id\\"] if transaction_id in seen_ids: return True seen_ids.add(transaction_id) return False"},{"question":"# Coding Question Context Graph traversal algorithms are essential in many applications, providing ways to navigate through nodes efficiently. One key algorithm in this domain is the Breadth-First Search (BFS) which explores nodes layer by layer. BFS can be particularly useful for finding the shortest path in unweighted graphs. Task Implement a function `bfs_shortest_path` that finds the shortest path between two vertices in an unweighted graph using the Breadth-First Search algorithm. Function Signature ```python def bfs_shortest_path(graph: dict, start: str, target: str) -> list: Find the shortest path between start and target vertices in an unweighted graph using BFS. :param graph: A dictionary where keys are vertices and values are lists of adjacent vertices. :param start: The starting vertex (string). :param target: The target vertex (string). :return: A list of vertices representing the shortest path, or an empty list if no path found. ``` Input - `graph`: A dictionary representing an unweighted graph. For example: ```python { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } ``` - `start`: A string representing the starting vertex. - `target`: A string representing the target vertex. Output - A list of vertices representing the shortest path from `start` to `target`. If there is no path, return an empty list. Example Usage ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(bfs_shortest_path(graph, \'A\', \'F\')) # [\'A\', \'C\', \'F\'] print(bfs_shortest_path(graph, \'D\', \'C\')) # [\'D\', \'B\', \'A\', \'C\'] print(bfs_shortest_path(graph, \'A\', \'G\')) # [] ``` Constraints - All vertices in the graph are represented as strings. - The graph may not necessarily be connected. - The graph won\'t contain any self-loops or parallel edges. - The graph will have at least one vertex.","solution":"from collections import deque def bfs_shortest_path(graph: dict, start: str, target: str) -> list: Find the shortest path between start and target vertices in an unweighted graph using BFS. :param graph: A dictionary where keys are vertices and values are lists of adjacent vertices. :param start: The starting vertex (string). :param target: The target vertex (string). :return: A list of vertices representing the shortest path, or an empty list if no path found. if start not in graph or target not in graph: return [] queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node == target: return path if node not in visited: visited.add(node) for neighbor in graph[node]: new_path = list(path) new_path.append(neighbor) queue.append(new_path) return []"},{"question":"# Problem Statement **Largest Common Substring** You are given two strings, `A` and `B`. Your task is to find the length of the longest common substring between the two strings. A substring is defined as a contiguous sequence of characters within a string. # Task Write a function `longest_common_substring(A: str, B: str) -> int` that takes two strings `A` and `B` as input and returns an integer representing the length of the longest common substring between them. # Input Format * Two strings, `A` and `B`. # Output Format * An integer representing the length of the longest common substring. # Constraints * ( 1 leq text{len}(A), text{len}(B) leq 10^3 ) * Strings `A` and `B` will consist of lowercase English letters. # Performance Requirements * The solution should efficiently handle the upper limit of the input constraints. # Example *Example 1:* Input: ``` A = \\"abcde\\" B = \\"abfce\\" ``` Output: ``` 2 ``` Explanation: The longest common substring is \\"ab\\". *Example 2:* Input: ``` A = \\"abcdefgh\\" B = \\"xyzabcmn\\" ``` Output: ``` 3 ``` Explanation: The longest common substring is \\"abc\\". *Example 3:* Input: ``` A = \\"abc\\" B = \\"def\\" ``` Output: ``` 0 ``` Explanation: There is no common substring between the given strings. # Notes * Make sure your function handles all edge cases efficiently. * The solution should work within the constraints ensuring optimal performance. Implement the function `longest_common_substring` as specified: ```python def longest_common_substring(A: str, B: str) -> int: pass ```","solution":"def longest_common_substring(A, B): Returns the length of the longest common substring between A and B. # Initialize a 2D array to store the lengths of longest common suffixes dp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)] max_length = 0 for i in range(1, len(A) + 1): for j in range(1, len(B) + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"# Question: Write a function `set_difference(list1: list[int], list2: list[int]) -> list[int]` that takes two lists of integers and returns a new list containing all the elements that are in the first list but not in the second list. The resulting list should be sorted in ascending order and must not contain any duplicate values. Function Signature: ```python def set_difference(list1: list[int], list2: list[int]) -> list[int]: pass ``` Input: - `list1`: A list of integers. - `list2`: A list of integers. Output: - A list of integers containing the set difference of `list1` and `list2`, sorted in ascending order without duplicate values. Constraints: 1. The lists can have any number of elements, including zero. 2. Both lists may contain duplicate values. 3. Elements of both lists are integers. Examples: ```python assert set_difference([1, 2, 2, 3, 4], [2, 3]) == [1, 4] assert set_difference([10, 20, 20, 30, 40], [20, 30, 50]) == [10, 40] assert set_difference([5, 5, 5, 6], [5]) == [6] assert set_difference([], [1, 2, 3]) == [] assert set_difference([1, 2, 3], []) == [1, 2, 3] ``` Notes: - You are expected to implement an efficient solution that minimizes unnecessary computations. - Handle edge cases such as empty lists or lists with all duplicated values. - Ensure that the output list is properly sorted and free of duplicates.","solution":"def set_difference(list1: list[int], list2: list[int]) -> list[int]: Return a sorted list containing elements that are in list1 but not in list2. Remove duplicates from the result. # Convert list2 to a set for faster lookup set2 = set(list2) # Use a set comprehension to remove elements present in list2 and remove duplicates difference_set = {item for item in list1 if item not in set2} # Convert the set to a sorted list before returning return sorted(difference_set)"},{"question":"# Problem Statement You are asked to implement a function that reverses the words in a given string, but the words themselves should remain in the original order. The function should handle multiple spaces and punctuation correctly, without using any built-in functions like `split()` or `join()`. # Function Signature ```python def reverse_words(s: str) -> str: pass ``` # Input * `s` (string): A string containing words separated by one or more spaces. It might include punctuation. # Output * Return a new string where each word in the input string is reversed, but the order of the words remains the same. # Constraints * The input string will have at most length 10,000. * Avoid using built-in functions like `split()` or `join()`. # Examples ```python assert reverse_words(\\"hello world!\\") == \\"olleh !dlrow\\" assert reverse_words(\\" this is a test \\") == \\" siht si a tset \\" assert reverse_words(\\"Python is fun!\\") == \\"nohtyP si !nuf\\" assert reverse_words(\\"Practice makes perfect.\\") == \\"ecitcarP sekam .tcefrep\\" ``` # Special Notes Consider testing your function thoroughly to handle edge cases such as: * Strings with multiple consecutive spaces. * Strings with punctuation. * Very long strings. Provide appropriate documentation and comments within your code to ensure clarity and maintainability.","solution":"def reverse_words(s: str) -> str: Reverses each word in the input string but maintains their original order. Args: s (str): Input string with words separated by one or more spaces. Returns: str: New string where each word is reversed but their order is preserved. result = [] word = [] for char in s: if char.isspace(): if word: # if word list is not empty result.extend(word[::-1]) word = [] result.append(char) else: word.append(char) if word: # if there\'s a word left at the end result.extend(word[::-1]) return \'\'.join(result)"},{"question":"# Data Analysis and Visualization with Pandas and Matplotlib You have been given a CSV file containing sales data for a retail company with the following columns: - `date` (string): The date of the transaction in the format \\"YYYY-MM-DD\\". - `store` (string): The store where the transaction took place. - `product` (string): The product sold. - `quantity` (integer): The quantity of the product sold. - `price` (float): The price of the product. You need to implement a function to perform some basic data analysis and visualization tasks. The function should: 1. Load the data from the CSV file. 2. Compute the total sales for each product across all stores. 3. Identify the store with the highest total sales. 4. Create a bar plot showing the total sales for each product. **Function Requirements** 1. **Function Name**: `analyze_sales_data(file_path: str) -> dict` 2. **Input**: - `file_path` (str): The file path to the CSV file. 3. **Output**: - A dictionary with the following structure: ```python { \\"total_sales_per_product\\": dict, # {product_name: total_sales} \\"top_selling_store\\": str, # store name \\"chart\\": plt.Figure # Matplotlib figure object } ``` 4. **Constraints**: - Handle file-not-found and file reading errors gracefully. - Ensure the function handles large datasets efficiently. **Performance Requirements** - Ensure the solution does not consume excessive memory and runs efficiently on large datasets. **Example Usage** ```python result = analyze_sales_data(\\"sales_data.csv\\") # Example output # { # \\"total_sales_per_product\\": { # \\"Product A\\": 15000.0, # \\"Product B\\": 12000.0, # ... # }, # \\"top_selling_store\\": \\"Store 1\\", # \\"chart\\": <matplotlib.figure.Figure object at 0x...> # } ``` **Hints** 1. Use the `pandas` library to load and manipulate the CSV data. 2. Use the `matplotlib.pyplot` library for creating the bar plot. 3. Raise appropriate exceptions or messages for errors encountered. 4. Compute total sales by multiplying quantity and price for each transaction. Good luck!","solution":"import pandas as pd import matplotlib.pyplot as plt def analyze_sales_data(file_path: str) -> dict: try: # Load data from CSV file data = pd.read_csv(file_path) # Compute total sales for each product across all stores data[\'total_price\'] = data[\'quantity\'] * data[\'price\'] total_sales_per_product = data.groupby(\'product\')[\'total_price\'].sum().to_dict() # Identify the store with the highest total sales total_sales_per_store = data.groupby(\'store\')[\'total_price\'].sum() top_selling_store = total_sales_per_store.idxmax() # Create a bar plot showing the total sales for each product plt.figure(figsize=(10, 6)) plt.bar(total_sales_per_product.keys(), total_sales_per_product.values()) plt.xlabel(\'Product\') plt.ylabel(\'Total Sales\') plt.title(\'Total Sales for Each Product\') plt.xticks(rotation=45) plt.tight_layout() chart = plt.gcf() # Get current figure # Return results in the specified format return { \\"total_sales_per_product\\": total_sales_per_product, \\"top_selling_store\\": top_selling_store, \\"chart\\": chart } except FileNotFoundError: print(f\\"Error: The file {file_path} does not exist.\\") return {} except pd.errors.EmptyDataError: print(f\\"Error: The file {file_path} is empty.\\") return {} except Exception as e: print(f\\"An error occurred: {e}\\") return {}"},{"question":"# Tries and Autocompletion Objective You are tasked with completing the implementation of a Trie (prefix tree) to support autocompletion functionality. Problem Statement A `Trie` is a tree data structure used for efficient retrieval of keys in datasets of strings. Implement the following methods to enable autocompletion: 1. **`insert(self, word: str)`** * **Description**: This method inserts a word into the Trie. * **Input**: - `word`: a string to be inserted into the Trie. * **Output**: None 2. **`autocomplete(self, prefix: str) -> List[str]`** * **Description**: This method returns all words in the Trie that have the given prefix. * **Input**: - `prefix`: a string representing the prefix of the words to be completed. * **Output**: A list of strings representing all words in the Trie that start with the given prefix. Constraints: 1. The Trie should support insertion and autocompletion of lowercase English letters (`a-z`). 2. The number of words in the Trie will not exceed 10,000. 3. The length of each word will not exceed 100 characters. 4. The total length of all words in the Trie will not exceed 1,000,000 characters. Performance Requirements: The insertion operation should have an average time complexity of (O(m)), where (m) is the length of the word. The autocomplete operation should have an average time complexity of (O(n)), where (n) is the number of nodes accessed in the Trie. Below is the scaffold of the `Trie` class. You need to complete the methods as described above. ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(self, prefix: str) -> List[str]: def dfs(node, path, results): if node.is_end_of_word: results.append(path) for char, child in node.children.items(): dfs(child, path + char, results) node = self.root results = [] for char in prefix: if char in node.children: node = node.children[char] else: return results # Early return if prefix is not found dfs(node, prefix, results) return results ``` # Example Usage ```python trie = Trie() trie.insert(\'cat\') trie.insert(\'car\') trie.insert(\'dog\') trie.insert(\'dodge\') print(trie.autocomplete(\'ca\')) # Should print [\'cat\', \'car\'] print(trie.autocomplete(\'do\')) # Should print [\'dog\', \'dodge\'] print(trie.autocomplete(\'a\')) # Should print [] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(self, prefix: str) -> list: def dfs(node, path, results): if node.is_end_of_word: results.append(path) for char, child in node.children.items(): dfs(child, path + char, results) node = self.root results = [] for char in prefix: if char in node.children: node = node.children[char] else: return results # Early return if prefix is not found dfs(node, prefix, results) return results"},{"question":"# Sorting and Removing Duplicates from a List of Tuples Problem Statement: You are tasked with processing a list of tuples containing pairs of integers. Your goal is to remove any duplicate tuples (considering tuples with the same integers in different orders as duplicates) and return the list sorted in ascending order based on the first element of each tuple. If two tuples have the same first element, the second element will determine the order. Function Specifications: 1. **`process_tuples(tuples: List[Tuple[int, int]]) -> List[Tuple[int, int]]`**: - **Input**: - `tuples`: A list of tuples, where each tuple consists of two integers. - **Output**: - A list of tuples with no duplicates, sorted in ascending order as described. Constraints: - Each tuple contains exactly two integers. - The list can contain up to 10^4 tuples. - Integers within the tuples can be both positive and negative and will be within the range of -10^6 to 10^6. Example Usage: ```python tuples = [(3, 4), (1, 2), (2, 1), (2, 1), (4, 3)] # Expected output: [(1, 2), (2, 1), (3, 4)] result = process_tuples(tuples) ``` Notes: - Tuples (a, b) and (b, a) are considered the same and should be treated as duplicates. - The function should return a sorted list with each unique tuple appearing only once.","solution":"def process_tuples(tuples): Remove duplicate tuples (considering the order of integers within the tuple) and return the list sorted in ascending order based on the first element of each tuple. If two tuples have the same first element, the second element will determine the order. # Create a set to store unique tuples with normalized order unique_tuples = set() for t in tuples: normalized_tuple = tuple(sorted(t)) unique_tuples.add(normalized_tuple) # Convert the set back to a list and sort it sorted_unique_tuples = sorted(unique_tuples) return sorted_unique_tuples"},{"question":"# Problem Statement A social networking application needs a feature to find the most influential users based on their follower count. You are required to implement a feature that ranks users based on their popularity (number of followers). You will implement a class `User` and a class `SocialNetwork` to manage the users and their follower relationships. Your implementation should provide efficient methods to add users, follow other users, and retrieve the top `k` most followed users. # Requirements 1. **Add User**: Implement a method to add a new user to the social network. 2. **Follow**: Implement a method for one user to follow another user. 3. **Unfollow**: Implement a method for one user to unfollow another user. 4. **Get Top K Users**: Implement a method to retrieve the `k` users with the highest follower count. 5. **Get Followers Count**: Implement a method to retrieve the number of followers for a given user. # Function Signatures You should define the following methods in `User` and `SocialNetwork` classes: ```python class User: def __init__(self, user_id: int) -> None: pass class SocialNetwork: def __init__(self) -> None: pass def add_user(self, user_id: int) -> None: pass def follow(self, follower_id: int, followee_id: int) -> None: pass def unfollow(self, follower_id: int, followee_id: int) -> None: pass def get_top_k_users(self, k: int) -> List[int]: pass def get_followers_count(self, user_id: int) -> int: pass ``` # Input/Output Format: - **Add User**: Should take a single integer as user ID. - **Follow**: Should take two integers representing the follower\'s and followee\'s user IDs. - **Unfollow**: Should take two integers representing the follower\'s and followee\'s user IDs. - **Get Top K Users**: Should take an integer `k` and return a list of user IDs. - **Get Followers Count**: Should take a single integer as user ID and return the number of followers that user has. # Constraints - The user IDs are unique. - Implementations should aim for efficiency in terms of both time and space. - You can assume that both `follower_id` and `followee_id` exist in the social network while making follow or unfollow operations. - `k` will always be less than or equal to the number of users in the network. # Example Usage: ```python sn = SocialNetwork() sn.add_user(1) sn.add_user(2) sn.add_user(3) sn.follow(2, 1) sn.follow(3, 1) print(sn.get_followers_count(1)) # Output: 2 print(sn.get_top_k_users(1)) # Output: [1] sn.unfollow(3, 1) print(sn.get_followers_count(1)) # Output: 1 print(sn.get_top_k_users(2)) # Output: [1, 2] ``` # Notes: - Ensure that the methods handle edge cases, such as trying to follow or unfollow users that do not exist, gracefully. - Include appropriate error handling and raise exceptions where applicable.","solution":"class User: def __init__(self, user_id: int) -> None: self.user_id = user_id self.followers = set() def add_follower(self, follower_id: int) -> None: self.followers.add(follower_id) def remove_follower(self, follower_id: int) -> None: self.followers.discard(follower_id) def get_followers_count(self) -> int: return len(self.followers) class SocialNetwork: def __init__(self) -> None: self.users = {} def add_user(self, user_id: int) -> None: if user_id not in self.users: self.users[user_id] = User(user_id) def follow(self, follower_id: int, followee_id: int) -> None: if follower_id in self.users and followee_id in self.users: self.users[followee_id].add_follower(follower_id) def unfollow(self, follower_id: int, followee_id: int) -> None: if follower_id in self.users and followee_id in self.users: self.users[followee_id].remove_follower(follower_id) def get_top_k_users(self, k: int) -> list: sorted_users = sorted(self.users.values(), key=lambda x: x.get_followers_count(), reverse=True) return [user.user_id for user in sorted_users[:k]] def get_followers_count(self, user_id: int) -> int: if user_id in self.users: return self.users[user_id].get_followers_count() return 0 # or raise an exception if user does not exist"},{"question":"# Problem Statement You are required to implement a function that returns the Kth largest element in a stream. The stream is represented as a sequence of integers provided one-by-one, and you need to efficiently update and maintain the Kth largest element as the stream is processed. # Function Signature ```python class KthLargest: def __init__(self, k: int, nums: List[int]): Initialize the KthLargest class with an integer k and a list of integers nums. Parameters: k (int): The K position from the largest element. nums (List[int]): The initial list of integers. pass def add(self, val: int) -> int: Adds an integer val to the stream and returns the Kth largest element. Parameters: val (int): The new integer to add to the stream. Returns: int: The Kth largest element in the modified stream. Example: >>> kthLargest = KthLargest(3, [4, 5, 8, 2]) >>> kthLargest.add(3) 4 >>> kthLargest.add(5) 5 >>> kthLargest.add(10) 5 >>> kthLargest.add(9) 8 >>> kthLargest.add(4) 8 pass ``` # Constraints - The value of `k` is always between 1 and the length of `nums` plus the number of elements added so far. - The values in `nums` and each `val` are between -10^4 and 10^4. - The number of calls to the `add` method will not exceed 10^4. # Performance Requirements - The solution should efficiently handle additions and queries to maintain the Kth largest element. # Example Usage ```python kthLargest = KthLargest(3, [4, 5, 8, 2]) assert kthLargest.add(3) == 4 assert kthLargest.add(5) == 5 assert kthLargest.add(10) == 5 assert kthLargest.add(9) == 8 assert kthLargest.add(4) == 8 ``` # Implementation Notes Consider using a heap data structure to maintain the Kth largest element efficiently.","solution":"import heapq from typing import List class KthLargest: def __init__(self, k: int, nums: List[int]): self.k = k self.min_heap = nums heapq.heapify(self.min_heap) while len(self.min_heap) > k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) else: if val > self.min_heap[0]: heapq.heappushpop(self.min_heap, val) return self.min_heap[0]"},{"question":"# Coding Question: Implement Matrix Transposition with Memory Efficiency Context Transposing a matrix is a fundamental operation in linear algebra, where one flips a matrix over its diagonal, switching the row and column indices of the matrix. Efficiently transposing a large matrix in memory-constrained environments can be challenging. Task **Implement a function that transposes a given matrix represented as a list of lists, ensuring that the implementation is memory efficient.** Input * `matrix` (List[List[int]]): A list of lists where each inner list represents a row of the matrix. Output * Transposed matrix (List[List[int]]), where rows are columns of the original matrix and vice versa. Requirements * Efficient handling of large matrices with a focus on memory efficiency. * Avoid creating unnecessary additional structures that could consume significant extra memory. Constraints * The input matrix can have up to `10^5` elements in total. * The matrix is guaranteed to be rectangular, where all rows have the same number of columns. # Example ```python >>> transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose([[7, 8]]) [[7], [8]] >>> transpose([[1], [2], [3]]) [[1, 2, 3]] ``` # Implementation Notes 1. Use nested list comprehensions for a concise implementation. 2. Ensure the function handles matrices of varying dimensions effectively. 3. Focus on minimizing the additional memory used during the transposition process. ```python from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Transpose the given matrix. return [[matrix[row][col] for row in range(len(matrix))] for col in range(len(matrix[0]))] # Test cases if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Transpose the given matrix. Parameters: matrix (List[List[int]]): A 2D list representing the matrix to be transposed. Returns: List[List[int]]: The transposed matrix. # If the matrix is empty, return an empty list if not matrix: return [] # Transpose the matrix using list comprehension return [[matrix[row][col] for row in range(len(matrix))] for col in range(len(matrix[0]))]"},{"question":"# Inverse Matrix Calculation Context In linear algebra, finding the inverse of a matrix is a fundamental operation that is used in various applications, including solving systems of linear equations. You are given a square matrix and your task is to implement a function to find its inverse. Task Implement a function `invert_matrix(matrix: list[list[float]]) -> list[list[float]]` that calculates the inverse of a given square matrix. Input and Output Formats * **Input**: - `matrix`: A list of `n` lists, each containing `n` float values representing the elements of the square matrix (with `n` rows and `n` columns). * **Output**: - A list of lists of floats representing the inverse of the given matrix. If the matrix is singular (i.e., it does not have an inverse), raise a `ValueError`. Constraints * The input matrix is guaranteed to be square and `2  n  10`. * The matrix elements will be real numbers and are such that inverting is possible (i.e., non-singular). Performance Requirements - Ensure your function efficiently handles matrices at the upper constraint limit. - Consider numerical stability and precision aspects when implementing the matrix inversion. Example ```python def invert_matrix(matrix: list[list[float]]) -> list[list[float]]: # Your implementation here # Example usage: matrix = [ [4, 7], [2, 6] ] inverse = invert_matrix(matrix) print(\\"Inverse of the matrix is:\\") for row in inverse: print(\\" \\".join(f\\"{elem:.4f}\\" for elem in row)) ``` Expected Output: ``` Inverse of the matrix is: 0.6000 -0.7000 -0.2000 0.4000 ``` Notes * Ensure you handle cases where the matrix is close to being singular appropriately. * Implement the inversion using an algorithm suitable for small matrices to maintain efficiency and readability. * Pay attention to floating-point precision and ensure your solution provides accurate results.","solution":"import numpy as np def invert_matrix(matrix: list[list[float]]) -> list[list[float]]: Calculates the inverse of a given square matrix. Args: matrix (list[list[float]]): The matrix to be inverted, guaranteed to be square. Returns: list[list[float]]: The inverse of the input matrix. Raises: ValueError: If the matrix does not have an inverse (is singular). np_matrix = np.array(matrix) try: np_inverse = np.linalg.inv(np_matrix) except np.linalg.LinAlgError: raise ValueError(\\"The matrix is singular and cannot be inverted.\\") return np_inverse.tolist()"},{"question":"# Context As a software developer, you are tasked with implementing a utility function for converting a decimal number (base 10) into its corresponding binary representation (base 2). This function will be part of a larger system that performs various number base conversions for educational tools. # Task Implement a function that converts a non-negative integer into its binary representation. The function should handle the conversion without using Python\'s built-in binary conversion functions. # Function Signature ```python def decimal_to_binary(n: int) -> str: ``` # Input - `n` (integer): Non-negative integer that needs to be converted to its binary representation. # Output - Returns a string representing the binary form of the input integer `n`. # Examples ```python assert decimal_to_binary(0) == \'0\' assert decimal_to_binary(5) == \'101\' assert decimal_to_binary(15) == \'1111\' assert decimal_to_binary(8) == \'1000\' ``` # Constraints 1. The input integer `n` will always be non-negative (i.e., 0 or greater). 2. The function should efficiently handle typical input sizes, including large integers up to several million. # Edge Cases 1. The function should return `\\"0\\"` for an input of 0. 2. The implementation should avoid using Python\'s built-in functions for binary conversion (e.g., `bin()`), and instead use arithmetic operations and loops to achieve the conversion.","solution":"def decimal_to_binary(n: int) -> str: if n == 0: return \'0\' binary_str = \'\' while n > 0: binary_str = str(n % 2) + binary_str n = n // 2 return binary_str"},{"question":"Stock Trading with Cooldown You are given an array where each element represents the price of a stock on a given day. You can complete as many transactions as you like, but you must wait for one day after you sell before you can buy again (i.e., cooldown for one day). Implement a function to find the maximum profit you can achieve given the stock price list with the cooldown constraint. Write your solution as a dynamic programming problem. Function Signature: ```python def max_profit_with_cooldown(prices: List[int]) -> int: # Your code here ``` Requirements: - Implement a function `max_profit_with_cooldown(prices: List[int]) -> int` that computes the maximum possible profit following the cooldown rules. - Ensure the function handles edge cases and empty input gracefully. Constraints: - The length of `prices` list will be between 0 and (10^5). - Each element of the `prices` list represents the stock price on a given day and will be a non-negative integer. Input/Output Examples: ```python assert max_profit_with_cooldown([1, 2, 3, 0, 2]) == 3 assert max_profit_with_cooldown([6, 1, 6, 4, 3, 0, 2]) == 7 assert max_profit_with_cooldown([1]) == 0 assert max_profit_with_cooldown([]) == 0 ``` Note: - On day i, you can choose to either buy the stock, sell the stock, or do nothing. - If you sell the stock on day i, you can only buy the stock from day i+2 (due to cooldown). - Ensure your solution efficiently handles large inputs and considers edge cases.","solution":"from typing import List def max_profit_with_cooldown(prices: List[int]) -> int: if not prices: return 0 n = len(prices) if n == 1: return 0 # DP arrays sell = [0] * n buy = [0] * n cooldown = [0] * n # Initialization buy[0] = -prices[0] sell[0] = 0 cooldown[0] = 0 for i in range(1, n): buy[i] = max(buy[i-1], cooldown[i-1] - prices[i]) sell[i] = max(sell[i-1], buy[i-1] + prices[i]) cooldown[i] = max(cooldown[i-1], sell[i-1]) return max(sell[n-1], cooldown[n-1])"},{"question":"# Problem Statement You are given an array of integers, where some integers appear twice and others appear once. Your task is to write a function that finds all the integers that appear only once in the array. # Function Signature ```python def find_unique_elements(arr: [int]) -> [int]: pass ``` # Input * The input is a list of integers `arr` where 1  len(arr)  10^5 and each integer in the array is between -10^5 and 10^5. * The function should raise a `TypeError` if the input is not a list of integers. # Output * The function should return a list of integers that appear exactly once in the array, sorted in ascending order. # Constraints * Implement the function with O(n) time complexity. * Implement the function with O(n) space complexity. # Examples ```python find_unique_elements([4, 3, 2, 7, 8, 2, 3, 1]) # Output: [1, 4, 7, 8] find_unique_elements([2, 2]) # Output: [] find_unique_elements([5, 1, 7, 1, 8, 8, 7, 6]) # Output: [5, 6] find_unique_elements([1, 1, 1, 2, 2, 3, 3]) # Output: [] find_unique_elements([-1, -1, -2, -3, -3, -4, -5]) # Output: [-2, -4, -5] ``` # Notes * The input validation should ensure that the function only accepts a list of integers. * Duplicate elements in the array can appear consecutively or non-consecutively. * The function should filter out elements that appear more than once in the array. * The result list should be sorted in ascending order before returning.","solution":"def find_unique_elements(arr): Returns a list of integers that appear exactly once in the input array, sorted in ascending order. The function will raise a TypeError if the input is not a list of integers. if not isinstance(arr, list): raise TypeError(\\"Input should be a list\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"All elements in the input list should be integers\\") from collections import Counter element_count = Counter(arr) unique_elements = [elem for elem, count in element_count.items() if count == 1] return sorted(unique_elements)"},{"question":"# Coding Assessment Question Context: You are given a list of prices representing the cost of different commodities on different days. Your task is to calculate the maximum profit that can be achieved by buying and selling these commodities exactly once. You must ensure that you buy before you sell. Task: Implement a function `max_profit(prices: List[int]) -> int` that takes a list of integers `prices` representing the prices of a commodity on different days and returns the maximum profit that can be achieved by buying and selling once. If no profit is possible, return 0. Input: - `prices` (0 <= len(prices) <= 10^5, 0 <= prices[i] <= 10^5) Output: - An integer representing the maximum profit. Function Signature: ```python def max_profit(prices: List[int]) -> int: pass ``` Example: ```python assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 ``` Constraints: - Ensure the solution has an optimal time complexity of O(n), where n is the length of the prices list. - Use constant space, targeting a space complexity of O(1). Notes: - Carefully handle edge cases such as empty lists and lists with all non-increasing prices. - Ensure your solution accurately computes the maximum profit without causing overflow errors.","solution":"from typing import List def max_profit(prices: List[int]) -> int: Function to calculate the maximum profit that can be achieved by buying and selling commodities exactly once. :param prices: List of integers representing the prices of a commodity on different days. :return: Integer representing the maximum profit. If no profit is possible, return 0. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Scenario You are a software developer for a car rental company. Your team is working on a feature that helps to determine the optimal rental price for different car categories based on several factors, including demand and supply. # Problem Statement Write a function `optimal_rental_price(base_price: float, days: int, is_peak_season: bool, car_category: str) -> float` that computes the optimal rental price for a car. The final price is calculated based on the following parameters: 1. **Base Price**: The original price to rent a car per day. 2. **Days**: The number of days the car is rented. 3. **Is Peak Season**: A boolean value indicating whether it is peak season or not. If it is peak season, a 20% increase in the total price is applied. 4. **Car Category**: The category of the car. There are three categories: - \\"economy\\" (no additional charges) - \\"standard\\" (10% increase in total price) - \\"luxury\\" (30% increase in total price) # Function Signature ```python def optimal_rental_price(base_price: float, days: int, is_peak_season: bool, car_category: str) -> float: ``` # Input * `base_price` (float): The base price per day to rent the car. Constraints: `0 <= base_price <= 1000` * `days` (int): The number of days the car is rented. Constraints: `0 <= days <= 365` * `is_peak_season` (bool): A boolean indicating whether it is peak season or not. * `car_category` (str): The category of the car, which can be one of \\"economy\\", \\"standard\\", or \\"luxury\\". # Output * A float representing the final rental price, rounded to 2 decimal places. # Constraints 1. `0 <= base_price <= 1000` 2. `0 <= days <= 365` 3. `car_category` must be one of \\"economy\\", \\"standard\\", or \\"luxury\\". # Examples ```python assert optimal_rental_price(100.0, 5, False, \\"economy\\") == 500.00 assert optimal_rental_price(100.0, 5, True, \\"economy\\") == 600.00 assert optimal_rental_price(100.0, 5, False, \\"standard\\") == 550.00 assert optimal_rental_price(100.0, 5, True, \\"luxury\\") == 780.00 ``` # Note * The function should handle different combinations of peak season status and car categories. * Ensure that you correctly apply the rounding to 2 decimal places when returning the final price.","solution":"def optimal_rental_price(base_price: float, days: int, is_peak_season: bool, car_category: str) -> float: Computes the optimal rental price for a car based on base price, number of rental days, whether it is peak season or not, and the car category. total_price = base_price * days # Apply peak season surcharge if is_peak_season: total_price *= 1.20 # Apply car category surcharge if car_category == \\"standard\\": total_price *= 1.10 elif car_category == \\"luxury\\": total_price *= 1.30 return round(total_price, 2)"},{"question":"# Sparse Matrix-Vector Multiplication You are given the task of implementing a function to perform multiplication of a sparse matrix and a vector. A sparse matrix is a matrix in which most of the elements are zero. This problem requires you to leverage the sparsity of the matrix to perform multiplication efficiently. Write a function `sparse_matrix_vector_multiplication(sparse_matrix: Dict[Tuple[int, int], float], vector: List[float], matrix_shape: Tuple[int, int]) -> List[float]` that takes: - `sparse_matrix`: a dictionary where keys are tuples representing the (row, column) indices of non-zero elements in the matrix, and values are the corresponding non-zero elements. - `vector`: a list of float numbers representing the vector to be multiplied. - `matrix_shape`: a tuple (m, n) representing the shape of the sparse matrix. The function should output a list of float numbers representing the result of the matrix-vector multiplication. Constraints: 1. The length of the vector must be equal to the number of columns in the sparse matrix. 2. The matrix shape must be consistent with the indices in the sparse matrix dictionary. 3. The shape (m, n) of the matrix defines it as having `m` rows and `n` columns. Expected Input/Output: - Input: ``` python sparse_matrix = {(0, 1): 3.0, (2, 3): 5.0} vector = [1.0, 2.0, 3.0, 4.0] matrix_shape = (4, 4) ``` - Output: ``` python [6.0, 0.0, 20.0, 0.0] ``` Example: ``` python sparse_matrix = {(0, 1): 3.0, (2, 3): 5.0, (3, 0): 1.0} vector = [1.0, 2.0, 3.0, 4.0] matrix_shape = (4, 4) print(sparse_matrix_vector_multiplication(sparse_matrix, vector, matrix_shape)) # Output: [6.0, 0.0, 20.0, 1.0] ``` Notes: 1. Ensure your function validates the input for consistency in matrix shape and vector length. 2. Handle potential errors and raise appropriate exceptions with descriptive error messages. 3. Optimize your implementation to take advantage of the sparsity of the matrix. Do not convert the sparse matrix into a dense one.","solution":"from typing import Dict, Tuple, List def sparse_matrix_vector_multiplication(sparse_matrix: Dict[Tuple[int, int], float], vector: List[float], matrix_shape: Tuple[int, int]) -> List[float]: m, n = matrix_shape # Validate the input matrix shape for (row, col) in sparse_matrix.keys(): if row < 0 or row >= m or col < 0 or col >= n: raise ValueError(f\\"Matrix index ({row},{col}) out of bounds for shape {matrix_shape}\\") # Validate the input vector length if len(vector) != n: raise ValueError(f\\"Vector length {len(vector)} does not match number of matrix columns {n}\\") # Initialize the result vector with zeros result = [0.0] * m # Perform the multiplication for (row, col), value in sparse_matrix.items(): result[row] += value * vector[col] return result"},{"question":"# Prime Number Checker: Identifying Primality Context Sarah is working on optimizing an algorithm to identify prime numbers, which is a fundamental task in number theory with various applications in cryptography and computer science. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Sarah needs a function that efficiently checks whether a given number is prime. Task Implement a function `is_prime(n: int) -> bool` that determines if a given integer `n` is a prime number. Your function should focus on efficiency and handle large inputs gracefully. Input Format - A single integer `n` where `1 <= n <= 10^9`. Output Format - Return `True` if `n` is a prime number, otherwise `False`. Constraints - A prime number is a number greater than 1 with no divisors other than 1 and itself. - The function should efficiently handle the input size constraint. Examples ```python assert is_prime(2) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(1) == False assert is_prime(1000000007) == True ``` Requirements 1. Implement the `is_prime` function with the specified constraints. 2. Ensure that the solution is optimized for performance.","solution":"def is_prime(n: int) -> bool: Determines if a given integer n is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False sqrt_n = int(n ** 0.5) + 1 for i in range(3, sqrt_n, 2): if n % i == 0: return False return True"},{"question":"# Binary Tree Height and Tree Balancing You are given a binary tree data structure and need to implement two functions related to the tree: 1. `tree_height(root: TreeNode) -> int`: This function calculates and returns the height of the binary tree. The height is defined as the number of edges in the longest path from the root to a leaf. 2. `is_balanced(root: TreeNode) -> bool`: This function checks whether the binary tree is height-balanced. A binary tree is considered height-balanced if the height of the two subtrees of any node never differ by more than one. Task Your task is to write a function `analyze_tree(root: TreeNode) -> tuple` that combines the functionality of the above two functions: - The function should compute the height of the binary tree. - It should also check if the binary tree is balanced. - Return a tuple containing the height of the tree and a boolean indicating whether the tree is balanced. Input: - `root` (TreeNode or None): The root node of the binary tree, or None if the tree is empty. Output: - A tuple of the form (`height`, `is_balanced`). Here, - `height` (int): The height of the binary tree. - `is_balanced` (bool): True if the tree is balanced, otherwise False. Constraints: - Nodes\' values in the tree are arbitrary. - A null tree (when `root` is None) is considered balanced with height -1. Example: 1. **Input**: ``` 1 / 2 3 / 4 5 / 6 ``` **Output**: (3, False) 2. **Input**: ``` 1 / 2 3 / 4 5 6 ``` **Output**: (2, True) 3. **Input**: None **Output**: (-1, True) 4. **Input**: ``` 10 / 20 / 30 / 40 ``` **Output**: (3, False) Additional Requirements: - Ensure the helper functions `tree_height` and `is_balanced` handle edge cases such as a single node tree or large imbalances efficiently. - Consider using an optimized approach to avoid unnecessary re-computations during the tree traversal.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def analyze_tree(root: TreeNode) -> tuple: Analyzes the given binary tree to determine its height and whether it is balanced. def get_height_and_check_balanced(node): Helper function to determine the height of the tree and check if it\'s balanced. It returns a tuple (height, is_balanced). if not node: return -1, True left_height, left_balanced = get_height_and_check_balanced(node.left) right_height, right_balanced = get_height_and_check_balanced(node.right) current_height = 1 + max(left_height, right_height) is_current_balanced = (abs(left_height - right_height) <= 1) and left_balanced and right_balanced return current_height, is_current_balanced height, is_balanced = get_height_and_check_balanced(root) return height, is_balanced"},{"question":"# Context Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. # Problem You are required to implement a function `binary_search(arr: list[int], x: int) -> int` that accepts a sorted list of integers and an integer to search for. The function should return the index of the integer if it is present in the list, otherwise, it should return -1. # Detailed Requirements 1. **Sorted Input**: Assume the input list `arr` is sorted in ascending order. 2. **Binary Search Implementation**: - Use the binary search algorithm to find the element. - Return the index of the element if found, otherwise, return -1. 3. **Edge Case Handling**: - If the list is empty, your function should return -1. 4. **Return Value**: The function returns an integer representing the index of the found element or -1 if not found. # Function Signature ```python def binary_search(arr: list[int], x: int) -> int: ``` # Example ```python >>> binary_search(arr=[1, 2, 3, 4, 5], x=3) 2 >>> binary_search(arr=[1, 2, 3, 4, 5], x=6) -1 >>> binary_search(arr=[-10, -5, 0, 5, 10], x=-5) 1 >>> binary_search(arr=[], x=1) -1 ``` # Constraints 1. The input list will have at most 10^5 elements. 2. The elements in the input list will be integers. 3. The integer to search for will be within the range of the input list elements. # Notes - Implement the binary search algorithm ensuring it is efficient with O(log n) complexity. - Ensure the function handles different edge cases appropriately, including cases where multiple elements could be the search key. Return the index of any occurrence.","solution":"def binary_search(arr: list[int], x: int) -> int: Binary search function to find the index of element x in sorted list arr. If x is not found, returns -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == x: return mid elif arr[mid] < x: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement You are tasked with developing a function that determines whether a given string can be interpreted as a valid arithmetic expression consisting of single-digit numbers and the operators `+`, `-`, `*`, and `/`. The function should also evaluate the expression if it\'s valid and return the result. # Input 1. A string representing the arithmetic expression. The string may contain spaces, which should be ignored. # Output 1. If the expression is valid, return the evaluated result in integer form. 2. If the expression is not valid, return `None`. # Function Signature ```python def evaluate_expression(expression: str) -> Optional[int]: # Your code here ``` # Example ```python # Example 1 assert evaluate_expression(\\"3 + 5\\") == 8 # Example 2 assert evaluate_expression(\\" 2*3 - 4 /2 \\") == 4 # Example 3 assert evaluate_expression(\\"3 / 0\\") == None # Example 4 assert evaluate_expression(\\"3 + a\\") == None ``` # Constraints 1. The input string length is between 1 and 100, inclusive. 2. The arithmetic operations involve integer division, following Pythons integer division rules. 3. The expression will not have any parentheses. 4. Division by zero should be handled gracefully by returning `None`. 5. The expression will not contain consecutive operators. 6. The expression will not start or end with an operator. # Notes - Consider using Pythons built-in `eval` function to facilitate expressions evaluation. However, ensure to preprocess the string to handle spaces and validity checks before any evaluation. - Handle edge cases such as invalid characters, incorrect expression structure, and division by zero appropriately.","solution":"import re from typing import Optional def evaluate_expression(expression: str) -> Optional[int]: # Remove all spaces from the input string expression = expression.replace(\\" \\", \\"\\") # Check for invalid characters if not re.fullmatch(r\'[0-9+-*/]+\', expression): return None # Check for consecutive operators and invalid start/end if re.search(r\'[+-*/]{2,}\', expression) or expression[0] in \'+-*/\' or expression[-1] in \'+-*/\': return None try: # Use eval to evaluate the expression after validation result = eval(expression) # If all operations involve integers, result should be an integer if isinstance(result, int): return result else: return int(result) except ZeroDivisionError: return None except Exception: return None"},{"question":"# Problem Statement You are working on a game where characters can have different types of skills. Each skill has a power level associated with it. Your task is to implement a function `find_max_skill_combo(skill_powers, k)` that returns the maximum total power from a combination of exactly `k` distinct skills. # Function Signature ```python def find_max_skill_combo(skill_powers: list[int], k: int) -> int: pass ``` # Input - `skill_powers`: A list of integers representing the power levels of different skills. - `k`: An integer, the number of distinct skills to select. # Output - An integer, the maximum total power from selecting exactly `k` distinct skills. # Constraints - The length of `skill_powers` will be between 1 and 10^5. - Each element in `skill_powers` is between 1 and 10^5. - `k` will be a positive integer and `k`  length of `skill_powers`. # Example ```python find_max_skill_combo([10, 20, 30, 40, 50], 3) # Expected output: 120 (selecting skills with power levels 30, 40, and 50) find_max_skill_combo([5, 8, 12, 3, 7], 2) # Expected output: 20 (selecting skills with power levels 8 and 12) ``` # Notes - The function needs to handle large lists efficiently due to the potential constraint sizes. - Consider edge cases, such as when `skill_powers` contains duplicate values and proper selection must be ensured. - Use sorting or other suitable algorithmic techniques to achieve optimal performance.","solution":"def find_max_skill_combo(skill_powers, k): Returns the maximum total power from a combination of exactly k distinct skills. # Sort the skill_powers list in descending order to pick the largest k elements skill_powers.sort(reverse=True) # Sum the top k elements return sum(skill_powers[:k])"},{"question":"# Coding Assessment Question Context You have been asked to implement a function that efficiently finds the nth Fibonacci number. The traditional recursive approach for calculating Fibonacci numbers is not optimal due to its exponential time complexity. You are required to optimize this function to run in linear time. # Pre-requisites: - Understanding of the Fibonacci sequence. - Familiarity with iterative algorithms. Task Implement a function `nth_fibonacci(n: int) -> int` that calculates the nth Fibonacci number efficiently using an iterative approach. Input - `n` (int): The position (0-indexed) in the Fibonacci sequence for which you need to find the Fibonacci number. (0  n  50) Output - (int): The nth Fibonacci number. Example ```python >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(6) 8 >>> nth_fibonacci(10) 55 ``` # Notes: - The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1","solution":"def nth_fibonacci(n): Returns the nth Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Additional Question: Find the Missing Number in a Series Objective: Implement a function to find the missing number in an arithmetic progression series. Write performance-optimized code and analyze the efficiency. Problem Statement: You are tasked to find the one missing number from a list of integers that forms an arithmetic progression (AP) series except for one missing element. Given an array of `n - 1` integers representing a sequence of length `n` where one element is missing, identify and return the missing element. Implementation Details: **Function: `find_missing_number(arr: List[int]) -> int`** - Input: A list of `n - 1` integers, which are the elements of the arithmetic progression sequence with one missing element. - Output: The missing integer. - Method: Implement an optimized solution using the properties of arithmetic progression and the sum formula. Constraints: - The input list will have at least 2 and at most 10,000 integers. - The integers in the list are guaranteed to form an arithmetic sequence except for the one missing element. - Use the sum formula for arithmetic progression to find the missing number efficiently. Performance Requirements: - Ensure the implementation handles large lists of up to 10,000 elements efficiently. - Aim for a solution that operates in linear time complexity, O(n). Example: ```python find_missing_number([1, 4, 7, 13, 16]) => 10 # Arithmetic progression: 1, 4, 7, 10, 13, 16 find_missing_number([5, 10, 20, 25]) => 15 # Arithmetic progression: 5, 10, 15, 20, 25 ``` Evaluation: Your implementation will be evaluated based on: - Correctness of logic. - Handling of edge cases. - Efficiency and optimality of the solution. - Adherence to time and space complexity. # Explanation: To ensure the question integrates well with the original set, it introduces a novel problem (finding a missing number in an AP series) while maintaining the same style of complexity and constraints. The original and new questions both require efficient algorithm implementations and performance evaluations, aligning well with the overarching theme.","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Returns the missing number in an arithmetic progression. n = len(arr) + 1 total_sum = n * (arr[0] + arr[-1]) // 2 actual_sum = sum(arr) missing_number = total_sum - actual_sum return missing_number"},{"question":"# Question Context: You have been assigned to create a utility that analyzes strings for the presence of a certain pattern. This will test your ability to use regular expressions or other string manipulation techniques effectively. Problem Statement: Define a function `pattern_count(s: str, pattern: str) -> int` that calculates the number of times a given pattern appears in the string `s`. Function Signature: ```python def pattern_count(s: str, pattern: str) -> int: pass ``` Input: * A string `s` (1  len(s)  10^6) - the main text body in which to search for the pattern. * A string `pattern` (1  len(pattern)  100) - the pattern to search for within `s`. Output: * An integer representing the count of non-overlapping occurrences of `pattern` in `s`. Constraints: 1. Ensure your solution performs efficiently even when `s` is very large (up to 10^6 characters). 2. The pattern must be counted in a case-sensitive manner (e.g., \'a\' is different from \'A\'). Example: ```python assert pattern_count(\\"abababab\\", \\"ab\\") == 4 assert pattern_count(\\"aaaa\\", \\"aa\\") == 2 assert pattern_count(\\"mississippi\\", \\"issi\\") == 1 ``` Additional Context: Consider using efficient string-searching algorithms or libraries such as Pythons `re` module for regular expressions. Be mindful of different edge cases, like when the pattern is not found in the string, or when the pattern has overlapping segments within the string.","solution":"def pattern_count(s: str, pattern: str) -> int: Calculates the number of non-overlapping occurrences of a given pattern in the string. # If the pattern length is greater than the string length, return 0 if len(pattern) > len(s): return 0 count = 0 index = 0 # Loop through the string and count non-overlapping occurrences while index <= len(s) - len(pattern): # Check if the substring starting at \'index\' matches the pattern if s[index:index + len(pattern)] == pattern: count += 1 index += len(pattern) else: index += 1 return count"},{"question":"# Matrix Spiral Order Extraction You are required to implement a function that extracts elements from a 2D matrix in a spiral order, starting from the top-left corner and proceeding clockwise. Description: Implement a function `spiral_order(matrix)` which returns the elements of `matrix` in a spiral order. Input: - `matrix`: A 2D list of integers representing the matrix. Output: - Returns a list of integers containing the elements of `matrix` in spiral order. Constraints: - The dimensions of the matrix are such that 1 <= rows, columns <= 100. Requirements: - Your function should handle both square and rectangular matrices effectively. - Ensure that the solution is efficient and runs in a reasonable time frame for the given constraints. Additional Details: 1. The function should be able to handle edge cases such as a single row or a single column. 2. Pay special attention to matrices where the number of rows is not equal to the number of columns. You are provided with sample input and expected output below for reference: Sample Input 1: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Sample Output 1: ```python [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Sample Input 2: ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] ``` Sample Output 2: ```python [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] ``` Implement the `spiral_order` function accordingly. Starter Code: ```python def spiral_order(matrix): # Your code here pass ``` Your task is to complete the `spiral_order` function to achieve the described functionality.","solution":"def spiral_order(matrix): if not matrix: return [] result = [] while matrix: # Take the first row result += matrix.pop(0) # Take the last element of each remaining row, if any if matrix and matrix[0]: for row in matrix: result.append(row.pop()) # Take the last row\'s elements in reverse order if matrix: result += matrix.pop()[::-1] # Take the first element of each remaining row in reverse order, if any if matrix and matrix[0]: for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"# Question: Implement Binary Search for Sorted List You are provided with a sorted list of integers and a target integer to find within that list. Your task is to write a function that implements the binary search algorithm to determine whether the target integer exists in the list. Objective Implement the binary search algorithm that efficiently searches for a target number in a sorted list and returns the index of the target if found, or -1 if the target is not found. Expected Input and Output * **Input**: A sorted list of integers and a target integer. ```python [int, int, ..., int], int ``` * **Output**: The index of the target integer in the list if found, otherwise -1. ```python int ``` Constraints * The input list will have at most 100,000 elements. * Each integer in the list will fit within the 32-bit signed integer range: [2, 2  1]. * The list is guaranteed to be sorted in ascending order. Performance Requirements * Time complexity: O(log n) * Space complexity: O(1) Scenario Imagine you are working as a developer for a financial application where you need to frequently look up stock prices in a large, sorted dataset. The binary search algorithm is critical for ensuring these lookups are performed efficiently. # Your Task: Write a Python function `binary_search` that takes a sorted list of integers and a target integer, and returns the index of the target integer in the list if it exists, otherwise -1. ```python def binary_search(sorted_list, target): :param sorted_list: sorted list of integers :param target: integer to find :return: index of target integer if found, -1 otherwise # Implement your binary search logic here pass ``` **Note**: Do not use any libraries or built-in functions that directly solve the problem. Focus on implementing the binary search algorithm principles. **Example**: ```python >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 4) 3 >>> binary_search([1, 3, 5, 7, 9], 2) -1 ```","solution":"def binary_search(sorted_list, target): :param sorted_list: sorted list of integers :param target: integer to find :return: index of target integer if found, -1 otherwise left, right = 0, len(sorted_list) - 1 while left <= right: mid = (left + right) // 2 if sorted_list[mid] == target: return mid elif sorted_list[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement Write a function `find_critical_connections` that, given the number of servers and a list of connections between them, determines the critical connections in the network. A critical connection is any connection that, if removed, will make some servers unable to communicate with each other. The servers are represented as vertices and connections as edges in an undirected graph. # Input - `n`: an integer representing the number of servers, labeled from `0` to `n-1`. - `connections`: a list of pairs representing the connections between servers, where each pair `[u, v]` represents a bidirectional connection between server `u` and server `v`. # Output The function should return a list of all critical connections in any order. Each connection should be represented as a pair `[u, v]` where `u < v`. # Constraints - 2 <= `n` <= 10^4 - 1 <= `len(connections)` <= 10^5 - 0 <= `u, v` < `n` - `u` != `v` - There are no duplicate connections. # Example ```python def find_critical_connections(n, connections): # Your implementation here test_n = 5 test_connections = [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4]] print(find_critical_connections(test_n, test_connections)) # Expected output: [[1, 3], [3, 4]] ``` # Scenario You are managing the network infrastructure of a company where multiple servers are interconnected. To ensure the reliability of the network, you need to find out which connections are critical and could disrupt communication between servers if they fail.","solution":"from collections import defaultdict def find_critical_connections(n, connections): Finds all critical connections in a network. :param n: Number of servers :param connections: List of connections between servers :return: List of critical connections # Helper function to perform DFS and find bridges def dfs(node, parent, discovery_time, low_time, time, graph, result): discovery_time[node] = low_time[node] = time[0] time[0] += 1 for neighbor in graph[node]: if discovery_time[neighbor] == -1: # If neighbor is not visited dfs(neighbor, node, discovery_time, low_time, time, graph, result) # Check if the subtree rooted at neighbor has a connection back to one of the ancestors of node low_time[node] = min(low_time[node], low_time[neighbor]) # If the lowest vertex reachable from subtree under neighbor is below node in DFS tree if low_time[neighbor] > discovery_time[node]: result.append([node, neighbor]) elif neighbor != parent: # Update low value if neighbor is not parent low_time[node] = min(low_time[node], discovery_time[neighbor]) # Initialize graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Initialize discovery and low time arrays discovery_time = [-1] * n low_time = [-1] * n time = [0] # Mutable time object so it can be updated in DFS result = [] # Run DFS from each node (in case the graph is not connected) for i in range(n): if discovery_time[i] == -1: dfs(i, -1, discovery_time, low_time, time, graph, result) # Sort the result to ensure each connection is in ascending order critical_connections = [sorted(conn) for conn in result] return critical_connections"},{"question":"# Problem Statement: You are developing a ticket booking system for an event. The system needs to handle the maximum number of attendees while ensuring that each ticket sold is unique. You have a list of ticket numbers ordered from the smallest to the largest. Your task is to identify the largest contiguous subset of unique ticket numbers. # Function Signature: ```python def max_contiguous_tickets(tickets: List[int]) -> List[int]: ``` # Input: * `tickets` (a list of integers): A list of integers representing ticket numbers, sorted in ascending order. # Output: * Returns a list of integers representing the largest contiguous subset of unique ticket numbers. # Constraints: * Each integer in the list `tickets` is unique. * The length of `tickets` is at least 1 and at most (10^6). # Performance Requirements: * Your solution should efficiently handle the identification of the largest contiguous subset in linear time due to the potential large size of input. # Example: ```python assert max_contiguous_tickets([1, 2, 3, 5, 6, 7, 8]) == [5, 6, 7, 8] assert max_contiguous_tickets([15, 16, 17, 20, 21, 22, 23, 24]) == [20, 21, 22, 23, 24] ``` # Notes: 1. A contiguous subset is defined as a sequence of ticket numbers in which the difference between consecutive ticket numbers is exactly 1. 2. If there are multiple subsets with the same maximum length, return the earliest occurring subset. 3. Consider edge cases where the input list might contain only one element.","solution":"def max_contiguous_tickets(tickets): Returns the largest contiguous subset of unique ticket numbers. if not tickets: return [] max_length = 0 max_start = 0 current_length = 1 current_start = 0 for i in range(1, len(tickets)): if tickets[i] == tickets[i - 1] + 1: current_length += 1 else: if current_length > max_length: max_length = current_length max_start = current_start current_start = i current_length = 1 if current_length > max_length: max_length = current_length max_start = current_start return tickets[max_start:max_start + max_length]"},{"question":"# Array Rotation In the world of data manipulation, rotating arrays is a common operation. You need to write a function that rotates an array to the right by a given number of steps. # Function Specification **Function Name**: `rotate_array` **Input**: 1. `arr` (List[int]): A list of integers to be rotated. 2. `steps` (int): Number of steps to rotate the array. **Output**: - Returns a list of integers that represents the rotated array. # Constraints: - The length of the array will not exceed 10^5 elements. - The number of steps is a non-negative integer. - If the number of steps is greater than the length of the array, rotate the array by `steps % len(arr)` steps. # Examples: ```python rotate_array([1, 2, 3, 4, 5], 2) # Output: [4, 5, 1, 2, 3] rotate_array([1, 2, 3, 4], 4) # Output: [1, 2, 3, 4] rotate_array([1, 2, 3, 4], 5) # Output: [4, 1, 2, 3] rotate_array([], 3) # Output: [] ``` # Additional Notes: Ensure that your implementation handles edge cases such as: * Empty arrays * Arrays with length 1 * Steps that are greater than the length of the array Write the function `rotate_array` such that it efficiently rotates the given array by the specified number of steps.","solution":"def rotate_array(arr, steps): Rotates the array to the right by the given number of steps. Parameters: arr (List[int]): A list of integers to be rotated. steps (int): Number of steps to rotate the array. Returns: List[int]: The rotated array. if not arr: return [] n = len(arr) steps = steps % n # Reduce the number of steps to < n return arr[-steps:] + arr[:-steps]"},{"question":"Consider a sorted list of integers and an integer `target`. Implement a Python function `find_closest(nums, target)` which finds the number in the list that is closest to the given target. If there are two numbers equally close to the target, return the smaller number. * **Input**: - `nums`: a list of sorted integers. - `target`: an integer. * **Output**: - Returns the integer from the list that is closest to the target. * **Constraints**: - The list `nums` will have at least one element. - The list `nums` will contain unique elements. * **Additional Specifications**: - Raise a ValueError if the list `nums` is empty. - Ensure your solution efficiently handles large lists. * **Example**: ```python nums = [1, 3, 5, 8, 10] target = 7 closest = find_closest(nums, target) print(closest) # Example output: 8 nums = [1, 2, 3] target = 4 closest = find_closest(nums, target) print(closest) # Example output: 3 ``` This question requires understanding of binary search and techniques to handle edge cases effectively.","solution":"def find_closest(nums, target): Finds the number in the sorted list nums that is closest to the given target. If there are two numbers equally close to the target, returns the smaller number. if not nums: raise ValueError(\\"The input list nums is empty.\\") low, high = 0, len(nums) - 1 # If the target is less than or equal to the first element, return the first element if target <= nums[low]: return nums[low] # If the target is greater than or equal to the last element, return the last element if target >= nums[high]: return nums[high] # Binary search to find the closest number while low <= high: mid = (low + high) // 2 if nums[mid] == target: return nums[mid] if target < nums[mid]: high = mid - 1 else: low = mid + 1 # Post-processing to determine the closest if (abs(nums[low] - target) < abs(nums[high] - target)) or (abs(nums[low] - target) == abs(nums[high] - target) and nums[low] < nums[high]): return nums[low] else: return nums[high]"},{"question":"# Question: # [Question 2]: Subarray Sum Problem Given an array of integers, write a function to find the subarray with the maximum possible sum. Your task is to implement an efficient algorithm to find this subarray sum. # Requirements: 1. **Input**: A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. 2. **Output**: An integer representing the maximum subarray sum. 3. **Constraints**: Your solution should handle large arrays efficiently, ideally in linear time. # Hint: Consider using Kadane\'s Algorithm to achieve an optimal solution. # Example: ```python def max_subarray_sum(arr: List[int]) -> int: pass # Example Test Cases print(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # Output: 6 print(max_subarray_sum([1, 2, 3, 4, 5])) # Output: 15 ```","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Function to find the subarray with the maximum possible sum using Kadane\'s Algorithm. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Given a list of tasks, each identified by an integer id, and a list of prerequisite pairs, where each pair `[a, b]` indicates that task `a` must be completed before task `b`, implement a function `can_finish(num_tasks: int, prerequisites: List[List[int]]) -> bool` that determines if it is possible to finish all tasks. # Input - **Integer** `num_tasks` representing the total number of tasks, where tasks are indexed from `0` to `num_tasks - 1`. - **List** of pairs `prerequisites`, where each element is a pair `[a, b]` indicating that task `a` is a prerequisite for task `b`. # Output - **Boolean** value: - `True` if it is possible to finish all tasks. - `False` if it is not possible to finish all tasks (due to cyclic dependencies). # Constraints 1. (1 leq num_tasks leq 10^4) 2. (0 leq text{len(prerequisites)} leq 10^5) # Example ```python num_tasks_1 = 2 prerequisites_1 = [[1, 0]] print(can_finish(num_tasks_1, prerequisites_1)) # Output: True num_tasks_2 = 2 prerequisites_2 = [[1, 0], [0, 1]] print(can_finish(num_tasks_2, prerequisites_2)) # Output: False ``` Implement the function `can_finish(num_tasks: int, prerequisites: List[List[int]]) -> bool` to complete this task. Notes - You might want to use topological sorting using Kahn\'s algorithm (BFS) or DFS with cycle detection to solve this problem. - Make sure to handle edge cases where there are no prerequisites.","solution":"from typing import List def can_finish(num_tasks: int, prerequisites: List[List[int]]) -> bool: from collections import deque, defaultdict # create an in-degree list and an adjacency list in_degree = [0] * num_tasks adjacency_list = defaultdict(list) # populate the in-degree and adjacency list for dest, src in prerequisites: in_degree[dest] += 1 adjacency_list[src].append(dest) # initialize the queue with nodes having 0 in-degree queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) visited_count = 0 # process the queue while queue: task = queue.popleft() visited_count += 1 for neighbor in adjacency_list[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # if we visited all the tasks, return True, else False return visited_count == num_tasks"},{"question":"# Problem Statement You are required to implement a queue data structure that supports the basic queue operations with enhanced performance and edge case handling, utilizing a circular array approach. # Task 1. Implement the `Queue` class using a circular array to achieve O(1) complexity for enqueue and dequeue operations. 2. Add exception handling for operations on an empty queue. 3. Ensure all queue operations are robust by testing various edge cases. # Requirements - Implement the `Queue` class that uses a circular array to manage the queue elements. - Modify the `dequeue` and `front` methods to raise exceptions when called on an empty queue. - Ensure the `enqueue`, `dequeue`, `front`, and `is_empty` methods function correctly. - Validate functionality with provided sample inputs. # Example Cases Here are some cases demonstrating the expected behavior of your `Queue`: ```python queue = Queue(5) assert queue.is_empty() == True try: queue.dequeue() except IndexError: print(\\"Exception caught: Dequeue from an empty queue\\") queue.enqueue(1) assert queue.is_empty() == False queue.enqueue(2) queue.enqueue(3) queue.enqueue(4) queue.enqueue(5) assert queue.front() == 1 try: queue.enqueue(6) except OverflowError: print(\\"Exception caught: Enqueue to a full queue\\") assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() == 3 assert queue.dequeue() == 4 assert queue.dequeue() == 5 try: queue.front() except IndexError: print(\\"Exception caught: Front from an empty queue\\") ``` You need to implement the `Queue` class to meet the above requirements. # Expected Function Signatures ```python class Queue(Generic[T]): def __init__(self, capacity: int) -> None: ... def enqueue(self, data: T) -> None: ... def dequeue(self) -> T | None: ... def front(self) -> T | None: ... def is_empty(self) -> bool: ... def is_full(self) -> bool: ... ``` # Constraints - Handle integer elements in the queue. - Focus on code efficiency and handle potential edge cases robustly.","solution":"class Queue: def __init__(self, capacity): Initialize the queue with a fixed capacity. self.capacity = capacity self.queue = [None] * capacity self.front_index = 0 self.rear_index = -1 self.size = 0 def enqueue(self, data): Adds an element to the rear of the queue. Raises OverflowError if the queue is full. if self.is_full(): raise OverflowError(\\"Enqueue to a full queue\\") self.rear_index = (self.rear_index + 1) % self.capacity self.queue[self.rear_index] = data self.size += 1 def dequeue(self): Removes and returns the front element of the queue. Raises IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Dequeue from an empty queue\\") front_element = self.queue[self.front_index] self.queue[self.front_index] = None self.front_index = (self.front_index + 1) % self.capacity self.size -= 1 return front_element def front(self): Returns the front element of the queue without removing it. Raises IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Front from an empty queue\\") return self.queue[self.front_index] def is_empty(self): Checks if the queue is empty. return self.size == 0 def is_full(self): Checks if the queue is full. return self.size == self.capacity"},{"question":"# Problem Statement Given a string `sentence` and an integer `k`, your task is to reverse the words in the sentence using groups of `k`. If there are fewer than `k` words in the final group, reverse all of the remaining words. Words in the sentence are separated by a single space. Implement the function `reverse_words_in_groups(sentence: str, k: int) -> str` which returns the modified sentence after reversing words in groups of `k`. # Function Signature ```python def reverse_words_in_groups(sentence: str, k: int) -> str: pass ``` # Input * `sentence` (string): A non-empty string containing lowercase English letters and spaces. * `k` (integer): A positive integer representing the group size. # Output * Returns a string with the words reversed in groups of `k`. # Constraints * 1 <= len(sentence) <= 10^4 * 1 <= k <= len(sentence.split()) # Example 1. Input: `sentence = \\"the quick brown fox jumps over the lazy dog\\", k = 3` Output: `\\"brown quick the over jumps fox dog lazy the\\"` Explanation: The words are reversed in groups of 3: [\\"the quick brown\\"] -> [\\"brown quick the\\"], [\\"fox jumps over\\"] -> [\\"over jumps fox\\"], and [\\"the lazy dog\\"] -> [\\"dog lazy the\\"]. 2. Input: `sentence = \\"hello there world\\", k = 2` Output: `\\"there hello world\\"` Explanation: The words are reversed in groups of 2: [\\"hello there\\"] -> [\\"there hello\\"], and [\\"world\\"] -> [\\"world\\"]. 3. Input: `sentence = \\"a b c d e f g\\", k = 4` Output: `\\"d c b a g f e\\"` Explanation: The words are reversed in groups of 4: [\\"a b c d\\"] -> [\\"d c b a\\"], and [\\"e f g\\"] -> [\\"g f e\\"]. # Notes 1. Words are separated by a single space, and there are no leading or trailing spaces in the input string. 2. Ensure that the output string maintains proper spacing with words separated by a single space. 3. Handle edge cases where groups may not completely match `k` and need to reverse the remaining words. # Hints * Use the `split()` method to divide the sentence into words. * Iterate over the words in steps of `k` and reverse the groups accordingly.","solution":"def reverse_words_in_groups(sentence: str, k: int) -> str: words = sentence.split() result = [] for i in range(0, len(words), k): group = words[i:i+k] reversed_group = group[::-1] result.extend(reversed_group) return \' \'.join(result)"},{"question":"Check if All Characters Have Equal Frequency You are tasked with implementing a function to verify if all characters in a given string appear with the same frequency. The function should determine whether each character in the string appears the same number of times, and return `True` if they do, otherwise return `False`. # Input - A string `s` consisting of lowercase English letters. # Output - A Boolean value `True` if all characters in the string appear with the same frequency, `False` otherwise. # Constraints - The length of the string `s` is between 1 and 100, inclusive. # Example ```python def has_equal_char_frequency(s: str) -> bool: Determine whether all characters in the string have the same frequency. :param s: str :return: Boolean >>> has_equal_char_frequency(\\"aabb\\") True >>> has_equal_char_frequency(\\"aab\\") False >>> has_equal_char_frequency(\\"abcabc\\") True >>> has_equal_char_frequency(\\"xxyyzz\\") True >>> has_equal_char_frequency(\\"abcc\\") False from collections import Counter freq = Counter(s) return len(set(freq.values())) == 1 if __name__ == \\"__main__\\": print(has_equal_char_frequency(\\"aaabbb\\")) ``` # Task: Implement the `has_equal_char_frequency` function to check if all characters in the input string `s` appear with the same frequency. Ensure your solution correctly handles all provided test cases.","solution":"def has_equal_char_frequency(s: str) -> bool: Determine whether all characters in the string have the same frequency. :param s: str :return: Boolean from collections import Counter freq = Counter(s) return len(set(freq.values())) == 1"},{"question":"# Coding Question Implement a function in Python that processes a collection of data represented as a list of dictionaries and extracts subsets of data based on specific filtering criteria. The data represents a collection of books, with each dictionary containing details such as title, author, genre, and publication year. Function Requirements: - **Function Name**: `filter_books` - **Inputs**: - `books` (list of dict): A collection of book details. Each dictionary may include keys such as \\"title\\", \\"author\\", \\"genre\\", and \\"year\\". - `author` (str): Filter books by author\'s name (optional, default = None). - `genre` (str): Filter books by genre (optional, default = None). - `year` (int): Filter books by publication year (optional, default = None). - **Outputs**: - A list of dictionaries, each representing a book that matches the provided filtering criteria. If no criteria are specified, return all books. Constraints: - Handle cases where the filtering criteria do not match any books by returning an empty list. - If none of the books match the provided filters, indicate this with an appropriate message. - Ensure that your function is efficient for collections of up to 10,000 books. # Example Usage ```python books = [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author 1\\", \\"genre\\": \\"Fiction\\", \\"year\\": 2020}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author 2\\", \\"genre\\": \\"Non-Fiction\\", \\"year\\": 2018}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author 1\\", \\"genre\\": \\"Fiction\\", \\"year\\": 2016}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author 3\\", \\"genre\\": \\"Science\\", \\"year\\": 2021}, ] filtered_books = filter_books(books, author=\\"Author 1\\", genre=\\"Fiction\\") print(filtered_books) ``` # Expected Output for Example Usage ```python [ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author 1\\", \\"genre\\": \\"Fiction\\", \\"year\\": 2020}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author 1\\", \\"genre\\": \\"Fiction\\", \\"year\\": 2016}, ] ``` # Example Solution Signature ```python def filter_books( books: list, author: str | None = None, genre: str | None = None, year: int | None = None ) -> list: # Your code here pass ```","solution":"def filter_books(books, author=None, genre=None, year=None): Filters a list of books based on given criteria. Parameters: books (list of dict): The collection of book details. author (str, optional): The author to filter by. genre (str, optional): The genre to filter by. year (int, optional): The publication year to filter by. Returns: list of dict: A list of books that match the filter criteria. filtered_books = [] for book in books: if author and book.get(\\"author\\") != author: continue if genre and book.get(\\"genre\\") != genre: continue if year and book.get(\\"year\\") != year: continue filtered_books.append(book) return filtered_books"},{"question":"# Problem Statement You are required to implement a function that computes the factorial of a given non-negative integer. The result should be returned as a string to handle large numbers. # Detailed Instructions * **Function Name**: `compute_factorial` * **Input**: - `n` - an integer representing the number for which the factorial is to be computed. * **Output**: - Returns a string representing the factorial of the given number. # Requirements 1. If `n` is less than 0, return \\"Invalid input\\". 2. Assume the input will always be an integer. 3. Factorial, denoted as n!, is the product of all positive integers less than or equal to n. 4. Use iterative computation instead of recursion to avoid stack overflow on large input. # Examples ```python >>> compute_factorial(5) \'120\' >>> compute_factorial(10) \'3628800\' >>> compute_factorial(0) \'1\' >>> compute_factorial(-3) \'Invalid input\' >>> compute_factorial(20) \'2432902008176640000\' ``` # Constraints * `-10^6 <= n <= 10^6` # Performance Requirements * The function should efficiently compute the factorial for large values of `n`. * The function should handle edge cases and invalid inputs gracefully, providing accurate results for valid input within the defined ranges. Good luck!","solution":"def compute_factorial(n): Computes the factorial of a given non-negative integer n. :param n: Integer, the number for which the factorial is to be computed. :return: A string representing the factorial of the given number or \'Invalid input\' if n is negative. if n < 0: return \\"Invalid input\\" result = 1 for i in range(2, n + 1): result *= i return str(result)"},{"question":"# Scenario You are given an integer `n`. Your task is to generate a Pascal\'s Triangle with `n` rows and then return the sum of all the elements in those `n` rows. Pascal\'s Triangle is a triangular array of the binomial coefficients. # Problem Statement Write a function `sum_pascals_triangle` that takes a single integer input `n` (1 <= n <= 1000) and returns the sum of all the elements in the first `n` rows of Pascal\'s Triangle. # Input Format A single integer `n`. # Output Format An integer representing the sum of all elements in the first `n` rows of Pascal\'s Triangle. # Constraints * 1 <= n <= 1000 # Function Signature ```python def sum_pascals_triangle(n: int) -> int: # implementation here ``` # Examples Example 1 **Input**: ```python 3 ``` **Output**: ```python 8 ``` **Explanation**: The first 3 rows of Pascal\'s Triangle are: ``` 1 1 1 1 2 1 ``` Sum = 1 + (1 + 1) + (1 + 2 + 1) = 8 Example 2 **Input**: ```python 4 ``` **Output**: ```python 15 ``` **Explanation**: The first 4 rows of Pascal\'s Triangle are: ``` 1 1 1 1 2 1 1 3 3 1 ``` Sum = 1 + (1 + 1) + (1 + 2 + 1) + (1 + 3 + 3 + 1) = 15 # Implementation Notes * Note that the sum of all elements in row `i` of Pascal\'s Triangle is `2^i`. * The task can be simplified by leveraging the properties of Pascal\'s Triangle.","solution":"def sum_pascals_triangle(n: int) -> int: Calculates the sum of all elements in the first \'n\' rows of Pascal\'s Triangle. Since sum of all elements in row \'i\' is 2^i, we just need to calculate the sum of 2^0 + 2^1 + 2^2 + ... + 2^(n-1). This can be simplified using the formula for the sum of a geometric series. return (2 ** n) - 1"},{"question":"# Single Number II Finder You are tasked with designing a function to find the unique number in a list where every other number appears exactly three times. This problem tests your understanding of bitwise operations and array processing. Objective Implement a function that takes a list of integers as input and returns the number that appears exactly once, while every other number appears exactly three times. Function Signature ```python def single_number(nums: list[int]) -> int: pass ``` Expected Input and Output * **Input**: A list of integers, e.g., `[2, 2, 3, 2]`. * **Output**: The integer that appears only once, e.g., `3`. Constraints * The list will contain at least one integer. * All integers can be positive or negative, and the list will include the single number guaranteed to appear only once. * You should aim to achieve an optimal time complexity for large lists (e.g., O(n) time complexity). * The solution should use constant extra space (O(1) space complexity). Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1) Additional Requirements 1. Implement the solution without using extra collections (e.g., lists, dictionaries, sets). 2. Handle cases where the single number is negative. 3. Ensure that the function is efficient and meets the given constraints. Example Code Ensure your solution correctly handles the following test cases: ```python # Test cases assert single_number([2, 2, 3, 2]) == 3 assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 assert single_number([-2, -2, 1, -2]) == 1 assert single_number([1, 1, 1, 2]) == 2 # Edge cases assert single_number([30000, 500, 100, 30000, 100, 30000, 100]) == 500 assert single_number([-1, -1, -1, -2]) == -2 assert single_number([7]) == 7 ``` Context This problem leverages the properties of bitwise operations to efficiently identify the unique number in a list where other numbers appear exactly three times. It challenges you to think beyond traditional linear search and sorting techniques and to implement a space-efficient solution.","solution":"def single_number(nums: list[int]) -> int: Given a list of integers where every integer except one appears exactly three times, returns the integer that appears only once. # Initialize variables to store bits that appear once and twice once, twice = 0, 0 for num in nums: # The careful use of & and ~ to update `once` and `twice` once = ~twice & (once ^ num) twice = ~once & (twice ^ num) return once"},{"question":"Question You are provided with a collection of movie titles and you need to write a function to determine if a given string can be formed by concatenating one or more of these movie titles. Write a Python function `can_form_by_movies` that checks if a given string `s` can be formed by concatenating one or more of the provided movie titles. # Function Signature ```python def can_form_by_movies(movies: List[str], s: str) -> bool: ``` # Input - `movies` (List of strings): A list of movie titles, where each title is a non-empty string of length <= 100. - `s` (string): The target string (length <= 1000). # Output - `bool`: Return `True` if `s` can be formed by concatenating one or more of the movie titles, otherwise return `False`. # Constraints - Each movie title is a non-empty string with a maximum length of 100. - The collection of movie titles can contain up to 50 titles. - The length of the target string `s` is at most 1000. # Example ```python >>> can_form_by_movies([\\"starwars\\", \\"the\\", \\"empire\\", \\"strikesback\\"], \\"theempirestrikesback\\") True >>> can_form_by_movies([\\"harry\\", \\"potter\\", \\"and\\", \\"the\\", \\"philosopher\\", \\"stone\\"], \\"harrypotterandthephilosopherstone\\") True >>> can_form_by_movies([\\"lord\\", \\"of\\", \\"the\\", \\"rings\\"], \\"lordoftherings\\") True >>> can_form_by_movies([\\"interstellar\\", \\"gravity\\", \\"inception\\"], \\"gravityinterstellar\\") True >>> can_form_by_movies([\\"a\\", \\"long\\", \\"time\\", \\"ago\\"], \\"alongtimeagoinalaxyfarfaraway\\") False ``` # Considerations - Efficiently check for possible concatenations using either string manipulation techniques or dynamic programming. - Handle edge cases like overlapping movie titles or incomplete concatenations.","solution":"from typing import List def can_form_by_movies(movies: List[str], s: str) -> bool: if not s: return True dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for movie in movies: if dp[i - len(movie)] and s[i - len(movie):i] == movie: dp[i] = True break return dp[len(s)]"},{"question":"# Problem Statement: You are asked to write a function that finds the sum of all digits in the factorial of a given number. # Background: A factorial of a non-negative integer ( n ) is the product of all positive integers less than or equal to ( n ). The factorial of a number grows very quickly and can result in very large numbers even for relatively small ( n ). # Function Requirements: Implement the following function: ```python def sum_of_factorial_digits(n: int) -> int: Computes the sum of all digits in the factorial of n. :param n: The number whose factorial\'s digit sum is to be computed. :return: The sum of all digits in n! Example: >>> sum_of_factorial_digits(5) 3 # Your implementation here ``` # Constraints: * (0 leq n leq 100) # Expected Input and Output: * **Input**: A single integer ( n ) * **Output**: An integer representing the sum of all digits in the factorial of ( n ) # Examples: ```python # Example 1 assert sum_of_factorial_digits(5) == 3 # since 5! = 120, and 1 + 2 + 0 = 3 # Example 2 assert sum_of_factorial_digits(10) == 27 # since 10! = 3628800, and 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 # Example 3 assert sum_of_factorial_digits(0) == 1 # since 0! = 1, and the sum of digits is 1 ``` # Notes: - Factorials for numbers up to 100 can result in very large integers, so be mindful of potential performance considerations. - Use Python\'s arbitrary-precision integer capabilities to handle large numbers. # Performance: - Aim for a solution that handles the factorial calculation efficiently, considering the possible large size of the result for ( n = 100 ). Implement the function keeping in mind the correctness, performance, and handling of large integers.","solution":"import math def sum_of_factorial_digits(n: int) -> int: Computes the sum of all digits in the factorial of n. :param n: The number whose factorial\'s digit sum is to be computed. :return: The sum of all digits in n! factorial_result = math.factorial(n) return sum(int(digit) for digit in str(factorial_result))"},{"question":"# Context You have been hired to develop a utility for analyzing text files. One of the features required is to generate a summary of word frequencies in the text. To achieve this, you need to count the occurrence of each word in the text, ignoring case and punctuation. # Task Implement the `word_count` function that takes a string representing the contents of a text file and returns a dictionary where the keys are words and the values are the counts of those words. Words are considered to be sequences of characters separated by whitespace or punctuation. # Function Signature ```python def word_count(text: str) -> dict: pass ``` # Input * `text` (str): A string containing the text data from a file. The string length can vary from 0 to 100,000 characters. # Output * A dictionary with words as keys and their frequency counts as values. # Constraints * The function should ignore case and punctuation when counting words. * The dictionary should contain words as lowercase strings. * The input string can include letters, numbers, and punctuation. # Examples ```python print(word_count(\\"Hello world! Hello!\\")) # Output: {\'hello\': 2, \'world\': 1} print(word_count(\\"\\")) # Output: {} print(word_count(\\"Testing, one, two, three. Testing, one, two.\\")) # Output: {\'testing\': 2, \'one\': 2, \'two\': 2, \'three\': 1} ``` # Performance Requirements The function should efficiently handle the input within the given constraints up to 100,000 characters. # Additional Instructions * Ensure your implementation is purely in Python and does not depend on any external libraries. * Include inline comments to document the main steps of your algorithm. * Utilize appropriate string and dictionary methods to achieve the desired functionality.","solution":"import re from collections import defaultdict def word_count(text: str) -> dict: Returns a dictionary with words as keys and their frequency counts as values. The function ignores case and punctuation. # Use regular expressions to find words and ignore punctuation words = re.findall(r\'bw+b\', text.lower()) # Initialize a defaultdict to count the occurrences of each word word_counts = defaultdict(int) # Iterate through the words and count their occurrences for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"# Context You have been given a task to track the scores of players in a gaming tournament. The scores need to be analyzed to determine the top-performing players. # Task Write a function `top_scorers(scores: list[tuple[str, int]], n: int) -> list[tuple[str, int]]` that finds the top `n` players with the highest scores. Use the Insertion Sort algorithm to sort the list. # Function Signature ```python def top_scorers(scores: list[tuple[str, int]], n: int) -> list[tuple[str, int]]: Finds the top \'n\' players with the highest scores using the insertion sort algorithm. :param scores: A list of tuples, each containing a string player name and an integer score. :param n: An integer representing the number of top players to return. :return: A sorted list of the top \'n\' players based on their scores in descending order. ``` # Input * `scores`: A list of tuples, where each tuple consists of a string (the player name) and an integer (the player\'s score). For example: `[(\\"Alice\\", 88), (\\"Bob\\", 95), (\\"Charlie\\", 90)]` * `n`: An integer representing the number of top players to return. # Output * A sorted list of tuples containing the top `n` players based on their scores in descending order. # Constraints * 0  len(scores)  10^3 * 0  n  len(scores) * Each player name is unique and contains only alphabetical characters. # Examples 1. Input: `[(\\"Alice\\", 88), (\\"Bob\\", 95), (\\"Charlie\\", 90)]`, `n = 2` Output: `[(\\"Bob\\", 95), (\\"Charlie\\", 90)]` 2. Input: `[(\\"Alice\\", 75), (\\"Bob\\", 85), (\\"Charlie\\", 95), (\\"David\\", 65)]`, `n = 3` Output: `[(\\"Charlie\\", 95), (\\"Bob\\", 85), (\\"Alice\\", 75)]` # Notes * Ensure the function handles edge cases appropriately, such as when the list is empty or when `n` is 0. * In cases where `n` is greater than the number of players, return the entire list sorted by scores in descending order.","solution":"def top_scorers(scores, n): Finds the top \'n\' players with the highest scores using the insertion sort algorithm. :param scores: A list of tuples, each containing a string player name and an integer score. :param n: An integer representing the number of top players to return. :return: A sorted list of the top \'n\' players based on their scores in descending order. # Perform insertion sort on the scores based on the scores in descending order for i in range(1, len(scores)): key = scores[i] j = i - 1 while j >= 0 and key[1] > scores[j][1]: scores[j + 1] = scores[j] j -= 1 scores[j + 1] = key # Return the top n scores return scores[:n]"},{"question":"# Problem Statement: You are asked to build a function to manage a bookstore\'s inventory. The inventory consists of books categorized by genres such as Fiction, Non-Fiction, Science, and History. Each book entry includes the book title, author, genre, and the number of copies available. Your task is to implement a system to add new books, update the number of copies available, and retrieve the list of books for a specific genre. Implement a Python class `BookStore` which: 1. Initializes an empty inventory. 2. Has a method `add_book(title: str, author: str, genre: str, copies: int) -> None` to add a new book to the inventory. If the book already exists (same title and author), it adds the copies to the existing entry. 3. Has a method `update_copies(title: str, author: str, copies: int) -> None` to update the number of copies available for a specific book. If the book does not exist, it should add the book with the given number of copies. 4. Has a method `get_books_by_genre(genre: str) -> List[Dict[str, Any]]` that retrieves all books for a specific genre. Each book should be presented as a dictionary with keys \\"title\\", \\"author\\", and \\"copies\\". 5. Handles cases where attempting to update or retrieve a non-existent genre gracefully. Constraints * The `title` and `author` are unique for each book. * The number of copies should always be a non-negative integer. * The genre will always be a non-empty string. Example: ```python # Initialize the bookstore bookstore = BookStore() # Add books to the inventory bookstore.add_book(title=\\"1984\\", author=\\"George Orwell\\", genre=\\"Fiction\\", copies=5) bookstore.add_book(title=\\"A Brief History of Time\\", author=\\"Stephen Hawking\\", genre=\\"Science\\", copies=3) # Update copies for an existing book bookstore.update_copies(title=\\"1984\\", author=\\"George Orwell\\", copies=10) # Retrieve books by genre print(bookstore.get_books_by_genre(genre=\\"Fiction\\")) ``` This should output (considering JSON format for better readability): ```json [ { \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"copies\\": 10 } ] ``` # Class Definition Template: ```python from typing import List, Dict, Any class BookStore: def __init__(self): # Initialize an empty inventory self.inventory = {} def add_book(self, title: str, author: str, genre: str, copies: int) -> None: # Implement the logic to add a new book or update the copies if the book already exists pass def update_copies(self, title: str, author: str, copies: int) -> None: # Implement the logic to update the number of copies of an existing book or add the book if it doesn\'t exist pass def get_books_by_genre(self, genre: str) -> List[Dict[str, Any]]: # Implement the logic to retrieve books by genre pass ``` Make sure to properly handle edge cases and ensure the system\'s robustness in managing the inventory.","solution":"from typing import List, Dict, Any class BookStore: def __init__(self): # Initialize an empty inventory self.inventory = {} def add_book(self, title: str, author: str, genre: str, copies: int) -> None: # Implement the logic to add a new book or update the copies if the book already exists book_id = (title, author) if book_id in self.inventory: self.inventory[book_id][\'copies\'] += copies else: self.inventory[book_id] = { \\"title\\": title, \\"author\\": author, \\"genre\\": genre, \\"copies\\": copies } def update_copies(self, title: str, author: str, copies: int) -> None: # Implement the logic to update the number of copies of an existing book or add the book if it doesn\'t exist book_id = (title, author) if book_id in self.inventory: self.inventory[book_id][\'copies\'] = copies else: self.inventory[book_id] = { \\"title\\": title, \\"author\\": author, \\"genre\\": \\"\\", # Genre is unknown if adding through update_copies \\"copies\\": copies } def get_books_by_genre(self, genre: str) -> List[Dict[str, Any]]: # Implement the logic to retrieve books by genre return [ {key: value for key, value in book.items() if key != \'genre\'} for book in self.inventory.values() if book[\'genre\'] == genre ]"},{"question":"# String Manipulations and Validations As a software developer, you are tasked with implementing various string manipulation and validation functions. Task: Implement the following functions: 1. **Check Palindrome**: Determine if a given string is a palindrome. 2. **Anagram Validation**: Check if two given strings are anagrams of each other. 3. **Longest Substring Without Repeating Characters**: Find the length of the longest substring without repeating characters. 4. **String Compression**: Compress the string using the counts of repeated characters. For example, the string `\\"aabcccccaaa\\"` would become `\\"a2b1c5a3\\"`. If the compressed string is not smaller than the original string, return the original string. Specifications: * **Input Format**: - For palindrome check: A single string `s`. - For anagram validation: Two strings `s1` and `s2`. - For longest substring: A single string `s`. - For string compression: A single string `s`. * **Output Format**: - **Palindrome**: Return `True` or `False`. - **Anagram**: Return `True` or `False`. - **Longest Substring Without Repeating Characters**: Return the length of the longest substring. - **String Compression**: Return the compressed string or the original string if compression does not shorten it. * **Constraints**: - 1  len(s), len(s1), len(s2)  1000 - Strings contain only lowercase English letters. Example: ```python Input: Check Palindrome: \\"racecar\\" Output: True Input: Anagram Validation: \\"listen\\" \\"silent\\" Output: True Input: Longest Substring Without Repeating Characters: \\"pwwkew\\" Output: 3 # \\"wke\\" Input: String Compression: \\"aabcccccaaa\\" Output: \\"a2b1c5a3\\" ``` # Notes: - For the **Check Palindrome** function, ignore case sensitivity and non-alphanumeric characters. - For the **Anagram Validation** function, consider case sensitivity, and spaces are ignored. - For the **Longest Substring Without Repeating Characters**, aim to use an efficient algorithm, ideally with linear time complexity. - For the **String Compression**, consider edge cases like an input string with no repeating characters or an already compressed-like input string.","solution":"import re from collections import Counter def is_palindrome(s): Determine if a given string is a palindrome. s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() return s == s[::-1] def are_anagrams(s1, s2): Check if two given strings are anagrams of each other. s1 = s1.replace(\\" \\", \\"\\").lower() s2 = s2.replace(\\" \\", \\"\\").lower() return Counter(s1) == Counter(s2) def longest_substring_without_repeating(s): Find the length of the longest substring without repeating characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length def compress_string(s): Compress the string using the counts of repeated characters. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem Statement You are tasked with implementing a function to convert a given integer to its Roman numeral representation. The function should take an integer as input and return a string representing the Roman numeral. Implement the function: 1. `int_to_roman(num: int) -> str` Function Definition * **`int_to_roman`**: * **Input**: * `num` (int): The integer to be converted (must be between 1 and 3999 inclusive). * **Output**: * `str`: The Roman numeral representation of the integer input. Constraints * `num` should be between 1 and 3999 inclusive. Error Handling * If `num` is not within the range of 1 to 3999, raise a `ValueError` with the message: `\\"Input number must be between 1 and 3999 inclusive\\"`. Examples * `int_to_roman(3)` should return `\'III\'`. * `int_to_roman(58)` should return `\'LVIII\'`. * `int_to_roman(3999)` should return `\'MMMCMXCIX\'`. * `int_to_roman(4000)` should raise a `ValueError`. Taking the above examples, please create a function that converts an integer to a Roman numeral by managing different numeral combinations and ensuring the constraints are met.","solution":"def int_to_roman(num: int) -> str: if num < 1 or num > 3999: raise ValueError(\\"Input number must be between 1 and 3999 inclusive\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syb[i] num -= val[i] i += 1 return roman_numeral"},{"question":"# Advanced Sorting Algorithm: Tim Sort Implementation # Scenario You are working on a performance-critical application where efficient sorting is crucial. Python\'s built-in sorting function uses Tim Sort, a hybrid sorting algorithm derived from merge sort and insertion sort. You need to implement your version of Tim Sort to better understand its mechanism and guarantee its performance. # Task Write a Python function `tim_sort` that sorts a given list of integers using the Tim Sort algorithm. Your implementation must break down the list into small runs, sort them using insertion sort, and then merge these runs using a modified merge sort to form the sorted list. # Function Signature ```python def tim_sort(arr: List[int]) -> List[int] ``` # Input 1. `arr` (List[int]): A list of integers that needs to be sorted. # Output * Returns a sorted list of integers. # Constraints 1. The function should not use Python\'s built-in sort function. 2. The lengths of `arr` should be between 1 and (10^5). 3. Integer values in `arr` should be between (-10^9) and (10^9). # Hint * Tim Sort operates by identifying small sublists (runs) and sorting them using insertion sort, then merging these sorted runs using a merge strategy. * Typical run size for Tim Sort is 32 or 64, but you can experiment with different sizes. * Focus on implementing the run identification and merging process effectively. # Performance Requirement * The implemented solution should have a time complexity close to (O(n log n)) in the average case. * Space complexity should be (O(n)) for auxiliary storage during merge operations. # Example ```python def insertion_sort(arr: List[int], left: int, right: int) -> None: for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], l: int, m: int, r: int) -> None: n1, n2 = m - l + 1, r - m left, right = arr[l:m + 1], arr[m + 1:r + 1] i, j, k = 0, 0, l while i < n1 and j < n2: if left[i] <= right[j]: arr[k] = left[i] i += 1 else: arr[k] = right[j] j += 1 k += 1 while i < n1: arr[k] = left[i] i += 1 k += 1 while j < n2: arr[k] = right[j] j += 1 k += 1 def tim_sort(arr: List[int]) -> List[int]: min_run = 32 n = len(arr) for start in range(0, n, min_run): end = min(start + min_run - 1, n - 1) insertion_sort(arr, start, end) size = min_run while size < n: for left in range(0, n, 2 * size): mid = min(n - 1, left + size - 1) right = min((left + 2 * size - 1), (n - 1)) if mid < right: merge(arr, left, mid, right) size = 2 * size return arr # Example usage: unsorted_list = [3, 4, 1, 5, 2] sorted_list = tim_sort(unsorted_list) print(sorted_list) # Expected output: [1, 2, 3, 4, 5] ``` # Notes * Consider edge cases such as an already sorted list, a reverse sorted list, and lists with repeated elements. * This task will solidify your understanding of hybrid sorting techniques and their practical applications.","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int) -> None: for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], l: int, m: int, r: int) -> None: n1, n2 = m - l + 1, r - m left, right = arr[l:m + 1], arr[m + 1:r + 1] i, j, k = 0, 0, l while i < n1 and j < n2: if left[i] <= right[j]: arr[k] = left[i] i += 1 else: arr[k] = right[j] j += 1 k += 1 while i < n1: arr[k] = left[i] i += 1 k += 1 while j < n2: arr[k] = right[j] j += 1 k += 1 def tim_sort(arr: List[int]) -> List[int]: min_run = 32 n = len(arr) for start in range(0, n, min_run): end = min(start + min_run - 1, n - 1) insertion_sort(arr, start, end) size = min_run while size < n: for left in range(0, n, 2 * size): mid = min(n - 1, left + size - 1) right = min((left + 2 * size - 1), (n - 1)) if mid < right: merge(arr, left, mid, right) size = 2 * size return arr"},{"question":"# Question: Binary Search with Range Limitation Context: Binary Search is a classic algorithm for finding an element in a sorted array. You are required to implement an enhanced version of Binary Search that not only finds the target but also works within a specified index range. Task: Write a function `range_limited_binary_search(sequence, target, start, end)` that performs a binary search on the sorted `sequence` to find `target` within the indices `start` to `end` (inclusive). Your function should return the index of `target` if found, or `None` if `target` is not within the range. Input: * `sequence`: A sorted list of integers. * `target`: An integer value to search for in the sequence. * `start`: An integer representing the starting index for the search range (inclusive). * `end`: An integer representing the ending index for the search range (inclusive). Output: * The index of `target` within the specified range if found, otherwise `None`. Examples: ```python >>> range_limited_binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 5, 2, 6) 4 >>> range_limited_binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 2, 2, 6) None >>> range_limited_binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 7, 0, 8) 6 >>> range_limited_binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 10, 3, 5) None >>> range_limited_binary_search([1, 1, 1, 1, 1, 1, 1, 1, 1], 1, 0, 8) 4 ``` Constraints: * The input list `sequence` is guaranteed to be sorted in non-decreasing order. * 0 <= `start` <= `end` < len(`sequence`) * The function should handle large input sizes efficiently, leveraging the binary search algorithm\'s properties to minimize the number of comparisons.","solution":"def range_limited_binary_search(sequence, target, start, end): Performs a binary search to find the target within the specified range in the sorted sequence. Args: sequence: A sorted list of integers. target: An integer value to search for. start: The starting index for the search range (inclusive). end: The ending index for the search range (inclusive). Returns: The index of the target if found within the specified range; otherwise, None. left, right = start, end while left <= right: mid = (left + right) // 2 if sequence[mid] == target: return mid elif sequence[mid] < target: left = mid + 1 else: right = mid - 1 return None"},{"question":"# Find the Missing Number # Problem Statement You are required to implement a function `find_missing_number` that takes a list of unique integers ranging from 1 to `n` (inclusive) and finds the missing number from that range. The list is guaranteed to have exactly one number missing. # Function Signature ```python def find_missing_number(nums: list) -> int: pass ``` # Input * A list of unique integers `nums` of length `n-1`, where `1 <= len(nums) <= 10^6` and the numbers range from 1 to `n`. # Output * Return the single missing number from the list. # Example ```python >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([1]) 2 >>> find_missing_number([2, 3, 4, 5]) 1 ``` # Explanation - The numbers in the list `[3, 7, 1, 2, 8, 4, 5]` range from 1 to 8. The number 6 is missing. - The numbers in the list `[1, 2, 3, 5]` range from 1 to 5. The number 4 is missing. - The list `[1]` ranges from 1 to 2. The number 2 is missing. - The numbers in the list `[2, 3, 4, 5]` range from 1 to 5. The number 1 is missing. # Constraints - The list will always contain numbers ranging from 1 to `n` with exactly one number missing. - The numbers in the list are unique. # Implementation Notes - You can use mathematical formulas or other efficient techniques to solve this problem. - Consider the sum of the first `n` natural numbers to help in finding the missing number (`n` being the length of the list plus one). ```python def find_missing_number(nums: list) -> int: n = len(nums) + 1 total_sum = n * (n + 1) // 2 return total_sum - sum(nums) ``` This problem tests the ability to manipulate and analyze sequences of numbers efficiently.","solution":"def find_missing_number(nums: list) -> int: Returns the missing number from the list of integers ranging from 1 to n. n = len(nums) + 1 total_sum = n * (n + 1) // 2 return total_sum - sum(nums)"},{"question":"# Coding Challenge: Binary search is one of the most efficient search algorithms for finding an item from a sorted list of items. Your objective is to implement a binary search algorithm that searches for a target value in a list and returns the index of the target if found, or -1 if the target is not present in the list. Additionally, the algorithm should be modified to work with a generic type using comparator functions. # Objective: Write a function `generic_binary_search` that: 1. Takes a sorted list of elements and a target value. 2. Uses a comparator function to perform the search. 3. Returns the index of the target if found, or -1 if not found. Expected Input and Output: * **Input**: * A sorted list of elements. * A target value to search for. * A comparator function that defines the comparison logic between elements. * **Output**: * An integer representing the index of the target value if found, or -1 if the target is not found. Performance Requirements: * The function should have a time complexity of O(log n). Constraints and Considerations: * Consider edge cases such as empty lists. * Ensure the solution works for various data types by leveraging comparator functions. * The comparator function should take two parameters and return an integer (-1, 0, 1). # Example: ```python def generic_binary_search(sorted_list: list, target, comparator) -> int: pass def int_comparator(a, b): if a < b: return -1 elif a > b: return 1 else: return 0 def string_comparator(a, b): if a < b: return -1 elif a > b: return 1 else: return 0 print(generic_binary_search([1, 2, 3, 4, 5, 6], 4, int_comparator)) # Expected output: 3 print(generic_binary_search([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"cherry\\", string_comparator)) # Expected output: 2 print(generic_binary_search([1, 2, 3, 4, 5, 6], 7, int_comparator)) # Expected output: -1 print(generic_binary_search([], 1, int_comparator)) # Expected output: -1 ``` # Note: * You are required to provide a detailed explanation of your implementation choices and any assumptions made.","solution":"def generic_binary_search(sorted_list, target, comparator): Performs a binary search for the target value in a sorted list using a comparator function. :param sorted_list: A list of sorted elements. :param target: The target value to search for. :param comparator: A comparator function that takes two arguments and returns -1, 0, or 1. :return: The index of the target value if found, or -1 if the target is not found. left, right = 0, len(sorted_list) - 1 while left <= right: mid = (left + right) // 2 comp_result = comparator(target, sorted_list[mid]) if comp_result == 0: return mid elif comp_result < 0: right = mid - 1 else: left = mid + 1 return -1"},{"question":"# Context In a social network graph, users are represented as nodes, and friendships are represented as edges between nodes. Each user node can have zero or more posts, and each post has a timestamp. # Objective Write a function `get_most_recent_post` that returns the most recent post among all the friends of the given user within the social network graph. You need to define a `User` class and a `Post` class, as well as implement the functionality to traverse the graph to find the most recent post. # Required Implementations 1. **Define `Post` Class**: - A post must have: - `content`: A string representing the content of the post. - `timestamp`: An integer representing the timestamp of the post. 2. **Define `User` Class**: - A user must have: - `id`: A unique identifier for the user (integer). - `posts`: A list of `Post` objects. - `friends`: A list of `User` objects representing the user\'s friends. 3. **Most Recent Post Function**: - `get_most_recent_post(user: User) -> Optional[Post]` - Arguments: * `user`: The user node from which to start the search. - Returns: - The most recent `Post` object among all friends of the given user. If no posts are found, return `None`. # Constraints - The graph is guaranteed to have no cycles, i.e., it is a tree with the given user as the root. - The number of users will not exceed (10^4). - The timestamps for posts are guaranteed to be unique. # Example Usage ```python # Suppose you have the following users and posts post1 = Post(content=\\"Hello, world!\\", timestamp=1) post2 = Post(content=\\"Good morning\\", timestamp=2) post3 = Post(content=\\"Happy birthday\\", timestamp=3) user_a = User(id=1) user_b = User(id=2) user_c = User(id=3) user_a.posts.extend([post1]) user_b.posts.extend([post2]) user_c.posts.extend([post3]) # Establish friendships user_a.friends.extend([user_b, user_c]) # Example of getting the most recent post among friends: result = get_most_recent_post(user_a) # Expected output: post3 print(result.content) # \\"Happy birthday\\" ``` # Performance Requirements The solution must efficiently traverse the graph to find the most recent post, ensuring that it does so within the constraints of time and space. Implement your `Post`, `User` classes, and `get_most_recent_post` function below. Ensure robust handling of edge cases for accurate and efficient search results.","solution":"from typing import List, Optional class Post: def __init__(self, content: str, timestamp: int): self.content = content self.timestamp = timestamp class User: def __init__(self, user_id: int): self.id = user_id self.posts: List[Post] = [] self.friends: List[\'User\'] = [] def get_most_recent_post(user: User) -> Optional[Post]: most_recent_post = None def dfs(current_user: User): nonlocal most_recent_post for post in current_user.posts: if most_recent_post is None or post.timestamp > most_recent_post.timestamp: most_recent_post = post for friend in current_user.friends: dfs(friend) for friend in user.friends: dfs(friend) return most_recent_post"},{"question":"# Question Scenario You are designing a function to smooth a sequence of numbers for a data science project. One common technique is the moving average, which helps smooth out short-term fluctuations and highlight longer-term trends in the data. Task Implement a function that computes the moving average of a given 1-dimensional numpy array of numerical values. The function should use a specified window size and return the moving averages as a new numpy array. The moving average should be calculated using the \'valid\' mode of numpy\'s `convolve` function, meaning only those values that are fully overlapped by the window are included. Function Signature ```python def moving_average(sequence: np.ndarray, window_size: int) -> np.ndarray: ``` Input - `sequence` (np.ndarray): A 1-dimensional numpy array of numerical values. - `window_size` (int): A positive integer indicating the length of the window for computing the moving average. Output - `np.ndarray`: A 1-dimensional numpy array containing the moving averages. Constraints - The input array will have at least one element and contain at most (10^6) elements. - The `window_size` will be a positive integer less than or equal to the length of the input array. Examples ```python >>> moving_average(np.array([1, 2, 3, 4, 5, 6, 7]), 3) array([2., 3., 4., 5., 6.]) >>> moving_average(np.array([10, 20, 30, 40, 50]), 2) array([15., 25., 35., 45.]) ``` Additional Notes - Use the \'valid\' mode of numpy\'s `convolve` to ensure the correct output length. - The moving average at each position is the mean of the `window_size` elements centered at that position. - You may assume all inputs are valid and no input validation is required.","solution":"import numpy as np def moving_average(sequence: np.ndarray, window_size: int) -> np.ndarray: Computes the moving average of a given 1-dimensional numpy array. Parameters: sequence (np.ndarray): A 1-dimensional numpy array of numerical values. window_size (int): Length of the window for computing the moving average. Returns: np.ndarray: A 1-dimensional numpy array containing the moving averages. window = np.ones(window_size) / window_size return np.convolve(sequence, window, mode=\'valid\')"},{"question":"# Coding Assessment Question **Problem Statement**: You are given a list of integers. Your task is to write a function `find_largest_unique_number` that returns the largest integer in the list that appears exactly once. If there is no unique number, return `-1`. If the input list is invalid (not a list, contains non-integer elements), the function should raise a `ValueError` with a message \\"Input must be a list of integers\\". **Function Signature**: ```python def find_largest_unique_number(numbers: list) -> int: pass ``` **Input**: * A list of integers `numbers` (`1 <= len(numbers) <= 10^5`). **Output**: * An integer representing the largest number that appears exactly once, or -1 if no unique number is found. **Constraints**: * The input must be a list of integers. If the input is not valid, raise a `ValueError` with the message \\"Input must be a list of integers\\". **Examples**: ```python assert find_largest_unique_number([4, 4, 5, 2, 3, 2]) == 5 assert find_largest_unique_number([3, 3, 3, 3]) == -1 assert find_largest_unique_number([7, 1, 2, 9, 2, 7, 10]) == 10 assert find_largest_unique_number([8, 8, 8, 7, 9, 9, 6, 4, 5]) == 7 try: find_largest_unique_number(\\"invalid\\") except ValueError as e: assert str(e) == \\"Input must be a list of integers\\" try: find_largest_unique_number([1, 2, 3, \'four\']) except ValueError as e: assert str(e) == \\"Input must be a list of integers\\" try: find_largest_unique_number({1: \'one\', 2: \'two\'}) except ValueError as e: assert str(e) == \\"Input must be a list of integers\\" ``` **Performance Requirement**: You should ensure that the function runs efficiently for large input sizes up to `10^5` elements.","solution":"def find_largest_unique_number(numbers: list) -> int: Returns the largest integer that appears exactly once in the list. Raises ValueError if input is not a list of integers. if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers\\") if not all(isinstance(x, int) for x in numbers): raise ValueError(\\"Input must be a list of integers\\") from collections import Counter count = Counter(numbers) # Filter the numbers that appear exactly once unique_numbers = [num for num, cnt in count.items() if cnt == 1] # Return the largest unique number, or -1 if none found return max(unique_numbers, default=-1)"},{"question":"# Matrix Transposition Application Context In data processing and scientific computing, matrix transposition is a common operation where rows of a matrix are swapped with columns. This can be useful in various linear algebra computations, data manipulation, and optimization problems. Problem Statement Implement a function in Python that calculates the transpose of a given 2D NumPy array. Given a matrix represented as a 2D array of shape ( m times n ), return its transpose, which will be an array of shape ( n times m ). Function Signature ```python def transpose_matrix(matrix: np.ndarray) -> np.ndarray: Transposes a given 2D NumPy array (matrix). Parameters: matrix: np.ndarray - Input 2D array representing the matrix. Returns: np.ndarray - Transposed matrix. ``` Input/Output Formats - **Input**: A 2D NumPy ndarray `matrix` of shape ( m times n ). - **Output**: A 2D NumPy ndarray of shape ( n times m ), which is the transpose of the input matrix. Constraints - The input matrix will contain only integers. - The function should leverage NumPy functionalities for efficient computation. - Expected to handle both small and large matrices efficiently. Examples ```python >>> transpose_matrix(np.array([[1, 2, 3], [4, 5, 6]])) array([[1, 4], [2, 5], [3, 6]]) >>> transpose_matrix(np.array([[7, 8], [9, 10], [11, 12]])) array([[ 7, 9, 11], [ 8, 10, 12]]) ``` Scenarios to Consider - Rectangular matrices of different dimensions, e.g., more rows than columns and vice versa. - Square matrices where ( m = n ). - Edge cases like matrices with a single row or single column. - Ensuring datatype consistency after transposition. Implement the `transpose_matrix` function efficiently and test it with various edge cases to ensure robustness.","solution":"import numpy as np def transpose_matrix(matrix: np.ndarray) -> np.ndarray: Transposes a given 2D NumPy array (matrix). Parameters: matrix: np.ndarray - Input 2D array representing the matrix. Returns: np.ndarray - Transposed matrix. return matrix.T"},{"question":"# Frequency Counter with Case Insensitivity You are tasked with writing a function that counts the frequency of each character in a given string in a case-insensitive manner. The function should return a dictionary where the keys are the characters and the values are their respective frequencies. Function Signature ```python def count_characters(input_string: str) -> dict: Returns a dictionary representing the frequency of each character in the input string, case-insensitive. Args: input_string (str): The string whose characters\' frequencies are to be counted. Returns: dict: A dictionary with characters as keys and their frequencies as values. ``` Example ```python >>> count_characters(\'Programming\') {\'p\': 1, \'r\': 2, \'o\': 1, \'g\': 2, \'a\': 1, \'m\': 2, \'i\': 1, \'n\': 1} >>> count_characters(\'aAaA\') {\'a\': 4} ``` # Requirements 1. **Case Insensitivity**: - The function should treat \'a\' and \'A\' as the same character. 2. **Output Format**: - The output should be a dictionary where the keys are lowercase characters and values are their frequencies. 3. **Constraints**: - The function should handle any printable ASCII characters. - The function should ignore non-alphabetic characters (digits, spaces, punctuation, etc.). # Objective This question tests the student\'s understanding of: - Iterating over characters in a string. - Case-insensitive character manipulation. - Using dictionaries to count and store frequencies. - String cleaning and filtering for specific character types.","solution":"def count_characters(input_string: str) -> dict: Returns a dictionary representing the frequency of each character in the input string, case-insensitive. Args: input_string (str): The string whose characters\' frequencies are to be counted. Returns: dict: A dictionary with lowercase alphabetic characters as keys and their frequencies as values. frequency = {} for char in input_string: if char.isalpha(): char = char.lower() if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# ASCII Art Generation You are tasked with implementing a function that generates a simple ASCII art given a specific pattern and size. The pattern involves drawing a right-angled triangle using a specific character. **Function Signature**: ```python def generate_ascii_triangle(size: int, char: str) -> list: pass ``` **Input**: * `size`: A non-negative integer representing the size of the triangle. This determines the number of rows and the maximum width of the triangle. * `char`: A single character string used to draw the triangle. **Output**: * A list of strings, where each string represents a row in the triangle. **Constraints**: * ( 0 leq size leq 100 ) * `char` is a single character string. # Example: ```python >>> generate_ascii_triangle(0, \'*\') [] >>> generate_ascii_triangle(3, \'*\') [\'*\', \'**\', \'***\'] >>> generate_ascii_triangle(5, \'#\') [\'#\', \'\', \'#\', \'\', \'#\'] >>> generate_ascii_triangle(4, \'+\') [\'+\', \'++\', \'+++\', \'++++\'] ``` # Requirements: - Ensure the inputs are validated within the function, raising appropriate exceptions for invalid inputs. - The function should handle edge cases, including a size of 0 which should return an empty list. - Provide a thorough set of test cases to verify the correctness of your implementation. - Make sure the function is efficient and easy to understand. # Hints: - Consider using string multiplication and list comprehensions to simplify the implementation.","solution":"def generate_ascii_triangle(size: int, char: str) -> list: Generates a right-angled triangle ASCII art. Args: size (int): The number of rows and the maximum width of the triangle. char (str): A single character string used to draw the triangle. Returns: list: A list of strings, each string representing a row in the triangle. Raises: ValueError: If size is negative or char is not a single character. if not isinstance(size, int) or size < 0: raise ValueError(\\"Size must be a non-negative integer.\\") if not isinstance(char, str) or len(char) != 1: raise ValueError(\\"Char must be a single character string.\\") return [char * (i + 1) for i in range(size)]"},{"question":"# Coding Challenge: Anagram Pair Counter **Scenario**: Given a list of strings, you need to determine how many pairs of strings are anagrams of each other. Two strings are anagrams if they contain the same characters in the same frequencies, but possibly in a different order. **Task**: Write a Python function `count_anagram_pairs(strings: List[str]) -> int` that computes the number of unique pairs of anagrams in the list. **Input**: - `strings`: A list of strings consisting of lowercase alphabetical characters. **Output**: - Return an integer which represents the number of unique pairs of anagrams. **Constraints**: - Length of `strings` will be between 1 and 10,000. - Each string within `strings` will have a length between 1 and 100. **Example**: ```python >>> count_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"goolge\\", \\"abc\\", \\"cab\\", \\"bac\\", \\"dog\\", \\"god\\"]) 6 ``` **Explanation**: The anagram pairs are: - (\\"listen\\", \\"silent\\") - (\\"listen\\", \\"enlist\\") - (\\"silent\\", \\"enlist\\") - (\\"google\\", \\"goolge\\") - (\\"abc\\", \\"cab\\") - (\\"abc\\", \\"bac\\") - (\\"cab\\", \\"bac\\") - (\\"dog\\", \\"god\\") Total pairs: 6 (considering each pair uniquely once). **Implementation Notes**: - Use a dictionary to keep track of the frequency of each sorted string. - Iterate through the list of strings, sort each string, and use the sorted string as the key in the dictionary. - Count the number of pairs using combinations or efficient arithmetic. **Hint**: - Sorting a string and using it as a key can help in identifying anagrams efficiently.","solution":"from typing import List from collections import defaultdict def count_anagram_pairs(strings: List[str]) -> int: Returns the count of unique pairs of anagrams in the given list of strings. anagram_map = defaultdict(int) # Count the occurrence of each anagram signature for string in strings: sorted_str = \'\'.join(sorted(string)) anagram_map[sorted_str] += 1 # Calculate the number of pairs for all possible anagram groups total_pairs = 0 for count in anagram_map.values(): if count > 1: total_pairs += (count * (count - 1)) // 2 return total_pairs"},{"question":"# Problem Statement You are given the task of rotating an n x n 2D matrix by 90 degrees clockwise. Its important to perform this rotation in-place, meaning you should not allocate another 2D matrix to perform the rotation. **Function Signature:** ```python def rotate_matrix(mat: List[List[int]]) -> None: Modifies the input matrix in place by rotating it 90 degrees clockwise. Parameters: mat (List[List[int]]): The n x n 2D matrix to be rotated. Returns: None ``` # Input - A square matrix `mat` represented by a list of lists of integers, where each list is of length `n` (1  n  1000). # Output - The function modifies the matrix in-place and does not return anything. # Constraints - Do not use any additional 2D matrix for the rotation. Only in-place operations are permitted. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ] rotate_matrix(matrix) assert matrix == [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] ```","solution":"from typing import List def rotate_matrix(mat: List[List[int]]) -> None: Modifies the input matrix in place by rotating it 90 degrees clockwise. Parameters: mat (List[List[int]]): The n x n 2D matrix to be rotated. Returns: None n = len(mat) # Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse()"},{"question":"# Coding Assessment Question Context and Scenario: You are implementing an online marketplace where users can post offers for various products. Each offer has a unique identifier and includes information on the product category, price, and user rating. The marketplace frequently requires filtering offers based on price and rating ranges. Task: 1. **Function 1: Filter Offers by Price Range** Write a function `filter_offers_price(offers, min_price, max_price)` that filters the offers based on a given price range. The function should return a list of offers whose prices fall within the specified range (inclusive). ```python def filter_offers_price(offers: list[dict], min_price: float, max_price: float) -> list[dict]: Filter offers by the given price range. :param offers: A list of offer dictionaries. :param min_price: The minimum price. :param max_price: The maximum price. :return: A list of offers within the price range. pass ``` **Example:** ```python offers = [ {\\"id\\": 1, \\"category\\": \\"electronics\\", \\"price\\": 299.99, \\"rating\\": 4.5}, {\\"id\\": 2, \\"category\\": \\"home\\", \\"price\\": 99.99, \\"rating\\": 4.0}, {\\"id\\": 3, \\"category\\": \\"fashion\\", \\"price\\": 49.99, \\"rating\\": 3.8}, {\\"id\\": 4, \\"category\\": \\"beauty\\", \\"price\\": 19.99, \\"rating\\": 4.7}, ] result = filter_offers_price(offers, 50.00, 300.00) print(result) # Output: [{\\"id\\": 1, \\"category\\": \\"electronics\\", \\"price\\": 299.99, \\"rating\\": 4.5}, {\\"id\\": 2, \\"category\\": \\"home\\", \\"price\\": 99.99, \\"rating\\": 4.0}] ``` 2. **Function 2: Filter Offers by Rating Range** Write a function `filter_offers_rating(offers, min_rating, max_rating)` that filters the offers based on a given rating range. The function should return a list of offers whose ratings fall within the specified range (inclusive). ```python def filter_offers_rating(offers: list[dict], min_rating: float, max_rating: float) -> list[dict]: Filter offers by the given rating range. :param offers: A list of offer dictionaries. :param min_rating: The minimum rating. :param max_rating: The maximum rating. :return: A list of offers within the rating range. pass ``` **Example:** ```python offers = [ {\\"id\\": 1, \\"category\\": \\"electronics\\", \\"price\\": 299.99, \\"rating\\": 4.5}, {\\"id\\": 2, \\"category\\": \\"home\\", \\"price\\": 99.99, \\"rating\\": 4.0}, {\\"id\\": 3, \\"category\\": \\"fashion\\", \\"price\\": 49.99, \\"rating\\": 3.8}, {\\"id\\": 4, \\"category\\": \\"beauty\\", \\"price\\": 19.99, \\"rating\\": 4.7}, ] result = filter_offers_rating(offers, 4.0, 5.0) print(result) # Output: [{\\"id\\": 1, \\"category\\": \\"electronics\\", \\"price\\": 299.99, \\"rating\\": 4.5}, {\\"id\\": 2, \\"category\\": \\"home\\", \\"price\\": 99.99, \\"rating\\": 4.0}, {\\"id\\": 4, \\"category\\": \\"beauty\\", \\"price\\": 19.99, \\"rating\\": 4.7}] ``` Constraints: - Offers are represented as dictionaries containing keys: \'id\', \'category\', \'price\', and \'rating\'. - Returns a list of offers that satisfy the given constraints. - Handle edge cases where the input offer list could be empty or none of the offers fall within the specified range. Performance Requirements: - Ensure that the filtering operations are efficient, with a linear time complexity based on the number of offers. - Your solution should be able to handle large lists of offers efficiently up to ( 10^6 ) elements.","solution":"def filter_offers_price(offers, min_price, max_price): Filter offers by the given price range. :param offers: A list of offer dictionaries. :param min_price: The minimum price. :param max_price: The maximum price. :return: A list of offers within the price range. return [offer for offer in offers if min_price <= offer[\'price\'] <= max_price] def filter_offers_rating(offers, min_rating, max_rating): Filter offers by the given rating range. :param offers: A list of offer dictionaries. :param min_rating: The minimum rating. :param max_rating: The maximum rating. :return: A list of offers within the rating range. return [offer for offer in offers if min_rating <= offer[\'rating\'] <= max_rating]"},{"question":"# Find the Longest Subsequence with a Given Sum You are given a list of integers and a target sum, and your task is to write a function that finds the longest contiguous subsequence within the list that adds up to exactly the target sum. If there are multiple subsequences with the same length, return the one that occurs first. The function should be defined as: ```python def longest_subsequence_with_sum(arr: List[int], target: int) -> List[int]: pass ``` # Input - `arr`: A list of integers. - `target`: An integer representing the target sum. # Output - Returns a list of integers representing the longest contiguous subsequence that adds up to the target sum. If no such subsequence exists, return an empty list. # Constraints - 1  len(arr)  1000 - -1000  arr[i]  1000 - -10^6  target  10^6 # Example Input ```python arr = [1, 2, 3, 7, 5] target = 12 ``` # Example Output ```python [2, 3, 7] ``` # Example Input ```python arr = [1, -1, 5, -2, 3, 4, 1, 2] target = 5 ``` # Example Output ```python [-1, 5, -2, 3, 4] ``` # Example Input ```python arr = [1, 2, 3] target = 6 ``` # Example Output ```python [] ``` # Instructions 1. Implement your function inside the provided template. 2. Ensure your code is efficient, taking into account the given constraints. 3. Handle all edge cases, including cases with negative and zero values in the array.","solution":"from typing import List def longest_subsequence_with_sum(arr: List[int], target: int) -> List[int]: max_len = 0 start_index = -1 n = len(arr) for i in range(n): current_sum = 0 for j in range(i, n): current_sum += arr[j] if current_sum == target: current_length = j - i + 1 if current_length > max_len: max_len = current_length start_index = i if start_index == -1: return [] else: return arr[start_index:start_index + max_len]"},{"question":"# Context: There is a special set of prime numbers known as circular primes. A circular prime is a prime number that remains prime when its digits are rotated in any way. For example, 197 is a circular prime because 197, 971, and 719 are all prime. # Task: Write a function `circular_prime_count(limit)` that takes an integer `limit` and returns the count of circular primes that are less than the given `limit`. # Input: - `limit`: an integer representing the upper limit to check for circular primes (exclusive). # Output: - An integer representing the count of circular primes less than `limit`. # Constraints: - `1 <= limit <= 10^6` # Example: ```python limit = 100 assert circular_prime_count(limit) == 13 # The circular primes less than 100 are: # 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97 limit = 1000 assert circular_prime_count(limit) == 25 # The circular primes less than 1000 include the above 13, plus: # 113, 131, 197, 199, 311, 337, 373, 719, 733, 919, and 971 ``` # Performance Requirements: - The function should be optimized to handle the input constraints efficiently, considering the computational complexity of checking for prime numbers and their rotations.","solution":"from sympy import isprime def rotate_string(s): return [s[i:] + s[:i] for i in range(len(s))] def is_circular_prime(n): str_n = str(n) rotations = rotate_string(str_n) return all(isprime(int(r)) for r in rotations) def circular_prime_count(limit): count = 0 for num in range(2, limit): if is_circular_prime(num): count += 1 return count"},{"question":"# Scenario: You are tasked with creating a powerful text transformation tool that allows users to apply a series of transformation rules on a given text. Each rule specifies a target substring and the string it should be replaced with. # Task: Write a function `apply_transformations` that takes two arguments: 1. `text` (string): The initial text on which transformations are to be applied. 2. `transformations` (list of tuples): A list of tuple transformations where each tuple contains two strings, the target substring and the replacement substring. # Input Formats: - The `text` string (length n): 1 <= n <= 100000 - The `transformations` list: 1 <= len(transformations) <= 1000 - Each target and replacement string in the transformations list: 1 <= len(target), len(replacement) <= 1000 # Output Format: - The text string after all transformations have been applied sequentially. # Constraints: - Apply the transformations in the given order. - Handle cases where transformations may overlap or affect portions of text that previous transformations have already modified. # Example: ```python text = \\"the quick brown fox jumps over the lazy dog\\" transformations = [ (\\"quick\\", \\"slow\\"), (\\"brown\\", \\"white\\"), (\\"lazy dog\\", \\"active cat\\") ] # Expected Output: # \\"the slow white fox jumps over the active cat\\" ``` # Hint: Consider using powerful string manipulation techniques to ensure the transformations are applied efficiently and correctly. # Implementation: Implement the `apply_transformations` function to process the text based on the provided transformation rules. ```python def apply_transformations(text: str, transformations: list[tuple[str, str]]) -> str: for target, replacement in transformations: text = text.replace(target, replacement) return text text = \\"the quick brown fox jumps over the lazy dog\\" transformations = [(\\"quick\\", \\"slow\\"), (\\"brown\\", \\"white\\"), (\\"lazy dog\\", \\"active cat\\")] print(apply_transformations(text, transformations)) # Expected Output: \\"the slow white fox jumps over the active cat\\" ```","solution":"def apply_transformations(text: str, transformations: list[tuple[str, str]]) -> str: Apply a series of transformation rules on a given text. Parameters: text (str): The initial text on which transformations are to be applied. transformations (list of tuples): A list of tuple transformations where each tuple contains two strings, the target substring and the replacement substring. Returns: str: The text after all transformations have been applied. for target, replacement in transformations: text = text.replace(target, replacement) return text"},{"question":"# Matrix Transpose and Multiplication You are tasked with implementing a complete matrix manipulation suite supporting matrix transpose and matrix multiplication operations using object-oriented programming. Class Description: Design a class **`Matrix`** to represent a matrix and encapsulate the following functionalities: Methods to Implement: 1. **`__init__(self, data: List[List[int]])`**: - Initialize the matrix with a list of lists containing integers. 2. **`transpose(self) -> \'Matrix\'`**: - Return the transpose of the matrix. 3. **`__mul__(self, other: \'Matrix\') -> \'Matrix\'`**: - Implement matrix multiplication between this matrix and another matrix `other`. 4. **`__str__(self) -> str`**: - Return a string representation of the matrix for easy visualization. Additional requirements: * Ensure the class methods handle edge cases, such as invalid dimensions for matrix multiplication. * Provide proper error messages for invalid operations like multiplication of incompatible matrices. Example: Consider the following matrices: ``` Matrix A: 1 2 3 4 5 6 Matrix B: 7 8 9 10 11 12 ``` The transpose of Matrix A would be: ``` Matrix A Transpose: 1 4 2 5 3 6 ``` The product of Matrix A and Matrix B would be: ``` Matrix A * Matrix B: 58 64 139 154 ``` Provide a test suite that demonstrates the correct usage and functionality of these matrix operations. Input: - Two matrices as lists of lists, each containing integers. Output: - The transposed matrix and the result of the matrix multiplication if applicable. Performance Constraints: - Efficiently handle matrices up to 500x500 in size. - Ensure operations are optimized for time complexity. Implementation: Implement the matrix class and functions in Python with the necessary error handling and optimizations. Demonstrate the use of this class with multiple examples to ensure the correctness of operations.","solution":"class Matrix: def __init__(self, data): self.data = data self.rows = len(data) self.cols = len(data[0]) if data else 0 def transpose(self): transposed_data = [[self.data[j][i] for j in range(self.rows)] for i in range(self.cols)] return Matrix(transposed_data) def __mul__(self, other): if self.cols != other.rows: raise ValueError(\\"Cannot multiply: incompatible matrix dimensions\\") result_data = [[sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) for j in range(other.cols)] for i in range(self.rows)] return Matrix(result_data) def __str__(self): return \'n\'.join([\' \'.join(map(str, row)) for row in self.data])"},{"question":"# Problem Statement You are given a list of integers where each integer appears exactly twice, except for one integer which appears exactly once. Your task is to find the single integer that appears only once. # Function Signature ```python def find_single_number(nums: list[int]) -> int: pass ``` # Input - `nums`: A list of integers where each element appears twice except for one. # Output - Return the single integer that appears only once. # Constraints - The length of the list (n) will be at most 10^5. - Each integer in the list is within the range of -10^5 to 10^5. # Example ```python nums = [4, 1, 2, 1, 2] output = find_single_number(nums) # Expected output: 4 ``` # Implementation Details - Utilize bitwise XOR operation to find the single integer in linear time (O(n)) with constant space (O(1)). - Ensure correct handling of both positive and negative integers within the given range. # Problem Statement You are given a string containing only lowercase letters. Your task is to return the length of the longest substring without repeating characters. # Function Signature ```python def longest_unique_substring(s: str) -> int: pass ``` # Input - `s`: A string consisting of only lowercase letters. The length of the string will be at most 10^5. # Output - Return the length of the longest substring without repeating characters. # Constraints - The string length (n) will be at most 10^5. - The string contains only lowercase English letters. # Example ```python s = \\"abcabcbb\\" output = longest_unique_substring(s) # Expected output: 3 (The substring \\"abc\\" is the longest without repeating characters) ``` # Implementation Details - Use the sliding window technique with a set to track characters in the current window. - Ensure the solution operates in linear time (O(n)) with respect to the length of the string.","solution":"def find_single_number(nums): Returns the single integer that appears only once in the list. unique_number = 0 for num in nums: unique_number ^= num return unique_number def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. char_set = set() left, max_length = 0, 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem Statement You are required to implement a function that finds all paths from a starting node to an ending node in a given directed graph. The function should return a list of paths, where each path is represented as a list of nodes. # Input * A dictionary `graph` representing the adjacency list of the directed graph, where keys are node identifiers and values are lists of adjacent nodes. * A string `start` representing the starting node. * A string `end` representing the ending node. # Output * A list of lists, where each inner list represents a path from the starting node to the ending node. # Constraints * The graph may be connected or disconnected. * Node identifiers are strings. * The starting node and ending node will always be present in the graph. * If there are no paths from the starting node to the ending node, return an empty list. # Performance Requirements * The function should have a time complexity that allows it to compute valid paths in a reasonable time for typical inputs. # Scenario Consider the graph represented as an adjacency list: ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } ``` The starting node is `\\"A\\"` and the ending node is `\\"D\\"`. The function should return `[[\\"A\\", \\"B\\", \\"D\\"], [\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [\\"A\\", \\"C\\", \\"D\\"]]`. # Function Signature ```python def find_all_paths(graph: dict[str, list[str]], start: str, end: str) -> list[list[str]]: pass ```","solution":"def find_all_paths(graph, start, end): def dfs(current, end, path): path.append(current) if current == end: paths.append(path.copy()) else: for neighbor in graph.get(current, []): if neighbor not in path: # avoid cycles dfs(neighbor, end, path) path.pop() paths = [] dfs(start, end, []) return paths"},{"question":"**Task**: Write a function `find_connected_components(graph: List[List[int]]) -> List[List[int]]` that finds all the connected components in an undirected graph. The graph is represented as an adjacency matrix where `graph[i][j] = 1` indicates a direct edge between nodes `i` and `j`, and `graph[i][j] = 0` otherwise. **Requirements**: - Implement a depth-first search (DFS) or breadth-first search (BFS) approach to traverse the graph. - Identify and collect all connected components, where each component is a list of node indices. - Ensure any disconnected nodes are handled as single-node components. **Input/Output Specification**: - **Input**: `graph` - An adjacency matrix representing the graph. - **Output**: A list of lists, where each inner list contains the node indices of a connected component. - **Constraints**: - The adjacency matrix will be square, i.e., `len(graph) == len(graph[0])`. - All node indices will be non-negative integers. **Performance**: Aim for O(V + E) time complexity, where V is the number of vertices and E is the number of edges. **Scenario**: Given a graph with multiple nodes, determine all separate groups (connected components) of nodes. Each group of nodes is directly or indirectly connected through a sequence of edges. **Example**: - Input: `graph = [[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 1, 0]]` - Output: `[[0, 1, 2], [3, 4]]` **Edge Cases**: - An empty graph (`graph = []`). - A graph with no edges (each node is its own component). Implement and thoroughly test the `find_connected_components` function to handle various scenarios and edge cases.","solution":"from typing import List def find_connected_components(graph: List[List[int]]) -> List[List[int]]: def dfs(node, component): for neighbor, isConnected in enumerate(graph[node]): if isConnected and neighbor not in visited: visited.add(neighbor) component.append(neighbor) dfs(neighbor, component) visited = set() components = [] for i in range(len(graph)): if i not in visited: visited.add(i) component = [i] dfs(i, component) components.append(component) return components"},{"question":"# **In-Place Quick Sort Function Implementation** You are required to implement an in-place quick sort algorithm in Python. Quick sort is a divide-and-conquer algorithm where the list is divided into sublists around a pivot element. Each sublist is then sorted independently. The sorting should be done without using extra space for another list, achieving in-place sorting. Function Specifications: - **Function Name**: `inplace_quick_sort` - **Input**: A list of comparable elements (e.g., integers, floats, strings). - **Output**: The same list, with the elements sorted in non-decreasing order. Constraints: * The input list can have up to (10^5) elements. * The elements can be any type that supports comparison operations. Performance Requirements: * The function must run in average O(n log n) time complexity, but handle worst-case O(n^2) when the pivot selection is poor. * The space complexity must be O(1), besides the recursive stack space. * Avoid creating new lists or using significant additional memory. Example: ```python arr = [5, 9, 8, 7, 1, 2, 7] inplace_quick_sort(arr) assert arr == [1, 2, 5, 7, 7, 8, 9] arr = [4, 3, 2, 1] inplace_quick_sort(arr) assert arr == [1, 2, 3, 4] arr = [\'c\', \'b\', \'a\'] inplace_quick_sort(arr) assert arr == [\'a\', \'b\', \'c\'] arr = [0.3, 0.2, 0.1] inplace_quick_sort(arr) assert arr == [0.1, 0.2, 0.3] arr = [] inplace_quick_sort(arr) assert arr == [] ``` # Additional Challenge: Ensure the function can handle edge cases such as: 1. An empty list (`[]`). 2. Lists with one element (e.g., `[1]`). 3. Lists with non-numeric comparable elements (e.g., `[\'a\', \'b\', \'c\']`). 4. Lists with negative and decimal numbers (e.g., `[-2, -9, -1, -4]`, `[1.1, 1, 0.0, -1, -1.1]`). # Hint: Consider how you can choose an effective pivot to avoid worst-case scenarios and how to partition the list in place, moving elements around within the current list rather than using additional space.","solution":"def inplace_quick_sort(arr): def partition(low, high): pivot = arr[(low + high) // 2] left = low right = high while left <= right: while arr[left] < pivot: left += 1 while arr[right] > pivot: right -= 1 if left <= right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 return left def quick_sort(low, high): if low < high: pi = partition(low, high) quick_sort(low, pi - 1) quick_sort(pi, high) if arr: quick_sort(0, len(arr) - 1)"},{"question":"Array Duplicate Removal and Sums You are given an array of integers that may contain duplicates. Your task is to remove all duplicates and then calculate the sum of the remaining integers. Task Write a function `remove_duplicates_and_sum` that takes a list of integers and returns the sum of the unique integers in the list. # Function Signature ```python def remove_duplicates_and_sum(nums: list[int]) -> int: ``` # Input * `nums` (1  `len(nums)`  100,000): A list of integers where each integer can range from `-10^6` to `10^6`. # Output A single integer representing the sum of the unique integers in the list. # Example ```python >>> remove_duplicates_and_sum([3, 3, 3, 5, 6, 7]) 18 >>> remove_duplicates_and_sum([1, 2, 2, 5, 6, 6, 7, 10]) 31 ``` # Constraints - Focus on achieving an efficient solution to handle potentially large lists and range of integer values. - Consider the use of appropriate data structures like sets to handle duplicates removal and summation efficiently. # Hints - Using a set for unique integer storage can provide an easy way to eliminate duplicates. - Simply summing the elements of the set will give you the desired result.","solution":"def remove_duplicates_and_sum(nums: list[int]) -> int: Removes duplicates from the list and returns the sum of the unique integers. return sum(set(nums))"},{"question":"# Stock Price Prediction using Linear Regression You are given a dataset composed of past stock prices, and your task is to predict future stock prices using a simple linear regression model. The dataset includes the dates (as integers indicating the number of days since a certain day) and the corresponding stock prices. **Input**: * A `train_dates` list of integers representing the dates of the training samples. * A `train_prices` list of floats representing the stock prices on the respective dates of the training samples. * A `test_dates` list of integers for which you need to predict the stock prices. **Output**: * A list of predicted stock prices for each test date. **Function Signature**: ```python def predict_stock_prices(train_dates: list[int], train_prices: list[float], test_dates: list[int]) -> list[float]: # Function implementation ``` **Constraints**: * The length of `train_dates` and `train_prices` is the same and ranges from 1 to 50. * The length of `test_dates` ranges from 1 to 10. * Dates are positive integers, and prices are non-negative floats. **Example**: ```python # Training Data train_dates = [1, 2, 3, 4, 5] train_prices = [100.0, 101.0, 102.0, 103.0, 104.0] # Test Data test_dates = [6, 7] # Expected Output # Using a simple linear regression model, the predictions might be: # The price on day 6 is expected to be around 105.0 # The price on day 7 is expected to be around 106.0 print(predict_stock_prices(train_dates, train_prices, test_dates)) # Output: [105.0, 106.0] ``` Ensure to consider the edge cases and handle floating-point precision appropriately in your implementation.","solution":"from sklearn.linear_model import LinearRegression import numpy as np def predict_stock_prices(train_dates: list[int], train_prices: list[float], test_dates: list[int]) -> list[float]: Predicts stock prices for the given test dates based on the training data using Linear Regression. Args: train_dates (list[int]): List of integers representing the dates of the training samples. train_prices (list[float]): List of floats representing the stock prices at the respective dates of training samples. test_dates (list[int]): List of integers for which the stock prices need to be predicted. Returns: list[float]: List of predicted stock prices for each test date. # Convert lists to numpy arrays for compatibility with sklearn x_train = np.array(train_dates).reshape(-1, 1) y_train = np.array(train_prices) x_test = np.array(test_dates).reshape(-1, 1) # Initialize and train the linear regression model model = LinearRegression() model.fit(x_train, y_train) # Predict stock prices for test dates y_pred = model.predict(x_test) # Convert the numpy array predictions back to list and return return y_pred.tolist()"},{"question":"# Matrix Multiplication and Verification Background Matrix multiplication is a fundamental operation in numerous mathematical and computational fields. Verifying the correctness and efficiency of a matrix multiplication implementation can ensure robust data processing capabilities for various applications. Objective Implement a function to perform matrix multiplication and verify the result against a built-in numpy function for correctness. Problem Statement Write a function `matrix_multiplication` that takes two 2D numpy arrays representing matrices `A` and `B`, performs their multiplication, and returns the resulting matrix. Also, write a function `verify_multiplication` to compare the result of your implementation to the result obtained using numpy\'s built-in matrix multiplication. Function Signatures ```python def matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: pass def verify_multiplication(A: np.ndarray, B: np.ndarray, result: np.ndarray) -> bool: pass ``` Inputs * `A`: A 2D numpy array of shape `(n, k)` representing the first matrix. * `B`: A 2D numpy array of shape `(k, m)` representing the second matrix. * `result`: A 2D numpy array of shape `(n, m)` representing the output of your matrix multiplication function. Outputs 1. The `matrix_multiplication` function returns a 2D numpy array representing the product of matrices `A` and `B`. 2. The `verify_multiplication` function returns a boolean value indicating whether the result matches the product computed using numpy\'s built-in function. Constraints * All input matrices will have integer values. * The dimensions of matrices `A` and `B` will be such that they can be multiplied. Requirements * Implement the matrix multiplication without using external libraries besides numpy. * Ensure the multiplication handles large matrices efficiently. Example ```python import numpy as np A = np.array([ [1, 2, 3], [4, 5, 6] ]) B = np.array([ [7, 8], [9, 10], [11, 12] ]) result = matrix_multiplication(A, B) is_correct = verify_multiplication(A, B, result) print(result) # Expected output: # [ # [ 58, 64], # [139, 154] # ] print(is_correct) # Expected output: # True ``` Performance Considerations Ensure that the solution can handle matrix sizes up to 500x500 efficiently.","solution":"import numpy as np def matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: Multiplies two matrices A and B using matrix multiplication rules. Assumes that the number of columns in A matches the number of rows in B. n, k = A.shape k, m = B.shape result = np.zeros((n, m), dtype=int) for i in range(n): for j in range(m): result[i, j] = sum(A[i, l] * B[l, j] for l in range(k)) return result def verify_multiplication(A: np.ndarray, B: np.ndarray, result: np.ndarray) -> bool: Verifies if the result of matrix multiplication matches the numpy dot product. expected = np.dot(A, B) return np.array_equal(result, expected)"},{"question":"# Question Create a function that reverses the digits of a non-negative integer without converting it into a string. The function should return the reversed number. Function Signature ```python def reverse_digits(number: int) -> int: pass ``` Input * `number` (int): A non-negative integer. Output * (int): The reversed number. Constraints * `number` is within the range of 0 to 10^9. * The input is guaranteed to be an integer and non-negative. Performance Requirements * Your function should have a time complexity of O(d), where d is the number of digits in `number`. * Space complexity should be O(1), utilizing a constant amount of space. Example ```python >>> reverse_digits(1234) 4321 >>> reverse_digits(100) 1 >>> reverse_digits(4000) 4 ``` Additional Notes The solution should reverse the digits mathematically without converting the number to a string or using any built-in reverse methods.","solution":"def reverse_digits(number: int) -> int: Reverses the digits of a non-negative integer without converting it into a string. reversed_number = 0 while number > 0: last_digit = number % 10 reversed_number = reversed_number * 10 + last_digit number //= 10 return reversed_number"},{"question":"# Implement a Circular Queue A circular queue is a linear data structure that follows the First In First Out (FIFO) principle but wraps around to the beginning if there is space available. **Implement the class `CircularQueue`:** Methods: * `__init__(self, k: int) -> None`: Initialize your data structure with a fixed capacity (`k`). * `enQueue(self, value: int) -> bool`: Insert an element into the circular queue. Return `True` if the operation is successful. * `deQueue(self) -> bool`: Delete an element from the circular queue. Return `True` if the operation is successful. * `Front(self) -> int`: Get the front item from the queue. If the queue is empty, return -1. * `Rear(self) -> int`: Get the last item from the queue. If the queue is empty, return -1. * `isEmpty(self) -> bool`: Check whether the circular queue is empty or not. * `isFull(self) -> bool`: Check whether the circular queue is full or not. Constraints: * You must solve the problem without using the built-in queue library. * Maximum number of calls to the methods is 10^4. Example: ```python queue = CircularQueue(3) assert queue.enQueue(1) == True assert queue.enQueue(2) == True assert queue.enQueue(3) == True assert queue.enQueue(4) == False assert queue.Rear() == 3 assert queue.isFull() == True assert queue.deQueue() == True assert queue.enQueue(4) == True assert queue.Rear() == 4 assert queue.Front() == 2 assert queue.isEmpty() == False ``` Performance Requirements: * All operations must be performed in O(1) time complexity. Note: Handle edge cases such as dequeuing from an empty queue and enqueuing to a full queue properly.","solution":"class CircularQueue: def __init__(self, k: int) -> None: Initialize your data structure with a fixed capacity of k. self.queue = [0] * k self.head = -1 self.tail = -1 self.max_size = k def enQueue(self, value: int) -> bool: Insert an element into the circular queue. Return True if the operation is successful. if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.max_size self.queue[self.tail] = value return True def deQueue(self) -> bool: Delete an element from the circular queue. Return True if the operation is successful. if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.max_size return True def Front(self) -> int: Get the front item from the queue. If the queue is empty, return -1. if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: Get the last item from the queue. If the queue is empty, return -1. if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: Check whether the circular queue is empty or not. return self.head == -1 def isFull(self) -> bool: Check whether the circular queue is full or not. return (self.tail + 1) % self.max_size == self.head"},{"question":"# Implementing a Basic Calculator # Objective Write a function that takes a string expression containing a basic mathematical operation and returns the result as an integer. The mathematical operation can include addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). # Input * A single string containing a mathematical expression. * The expression will be in the form `operand1 operator operand2` where `operand1` and `operand2` are integers, and `operator` is one of the following: `+`, `-`, `*`, `/`. * The input will be valid and will not include any spaces other than those separating the operands and operator. # Output * Return an integer representing the result of the operation. * For division, use floor division (integer division) to ensure the result is an integer. # Constraints * Do not use the `eval` function to solve this problem. * Function signature should be: `def basic_calculator(expression: str) -> int`. # Example ```python def basic_calculator(expression: str) -> int: # Implement the function here # Example Usage: print(basic_calculator(\\"3 + 4\\")) # Output: 7 print(basic_calculator(\\"10 - 3\\")) # Output: 7 print(basic_calculator(\\"6 * 7\\")) # Output: 42 print(basic_calculator(\\"8 / 2\\")) # Output: 4 ``` # Notes 1. The input string will always be in a valid format as specified. 2. The division operator (`/`) should perform integer division, which means the result should be the floor value of the division. 3. Negative results and operations with negative numbers should be correctly handled. 4. Assume there won\'t be any spaces within the operands or the operator itself, only between them.","solution":"def basic_calculator(expression: str) -> int: Evaluates a basic mathematical expression. Parameters: expression (str): The mathematical expression in the form \\"operand1 operator operand2\\". Returns: int: The result of the mathematical operation. tokens = expression.split() operand1 = int(tokens[0]) operator = tokens[1] operand2 = int(tokens[2]) if operator == \'+\': return operand1 + operand2 elif operator == \'-\': return operand1 - operand2 elif operator == \'*\': return operand1 * operand2 elif operator == \'/\': return operand1 // operand2 # floor division else: raise ValueError(f\\"Unsupported operator: {operator}\\")"},{"question":"# Question: Matrix Rotation Validation You are required to implement a function that checks if one matrix can be obtained by rotating another matrix by 90 degrees clockwise a certain number of times. The function should verify this for 0, 90, 180, and 270 degrees rotations. Function Specification Define the function `is_rotated_matrix` as follows: ```python def is_rotated_matrix(mat1: List[List[int]], mat2: List[List[int]]) -> bool: Checks if mat2 can be obtained by rotating mat1 by 0, 90, 180, or 270 degrees clockwise. :param mat1: A 2D list representing the original matrix. :param mat2: A 2D list representing the matrix to compare. :return: True if mat2 can be obtained by rotating mat1 by 0, 90, 180, or 270 degrees clockwise, False otherwise. ``` Input and Output Format: - **Input**: - `mat1`: A 2D list of integers representing the first matrix. The dimensions of the matrix are `n x n` where `1 <= n <= 10`. - `mat2`: A 2D list of integers representing the second matrix of the same dimensions as `mat1`. - **Output**: - Return a boolean value: `True` if `mat2` can be obtained by rotating `mat1` by 0, 90, 180, or 270 degrees clockwise; otherwise return `False`. Constraints: - The matrices are square matrices with the same dimensions. - Elements of the matrices are integers. Example: ```python mat1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mat2 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] print(is_rotated_matrix(mat1, mat2)) # Output: True ``` In this example, `mat2` is `mat1` rotated by 270 degrees clockwise. Additional Requirements: - Ensure your function can handle edge cases, such as matrices that are already equal or those that require multiple 90-degree rotations. - Aim for an efficient solution that minimizes unnecessary computations.","solution":"from typing import List def rotate_90_degrees_clockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def is_rotated_matrix(mat1: List[List[int]], mat2: List[List[int]]) -> bool: if mat1 == mat2: return True rotated = mat1 for _ in range(3): rotated = rotate_90_degrees_clockwise(rotated) if rotated == mat2: return True return False"},{"question":"# Generating Friendly Pair Numbers You are tasked with finding \\"friendly pairs\\" below a given limit. A friendly pair ( (m, n) ) consists of two different positive integers such that the sum of the divisors (including 1 but excluding the number itself) of each number is equal to the other. For example, ( (220, 284) ) is a friendly pair because the sum of the divisors of 220 is 284, and the sum of the divisors of 284 is 220. # Function Requirements You need to implement the function `find_friendly_pairs(limit: int = 10000) -> list[tuple[int, int]]` following these requirements: 1. **Input**: - `limit` (int): A positive integer defining the upper bound (exclusive) for checking friendly pairs. Default value is `10000`. 2. **Output**: - A list of tuples, where each tuple represents a friendly pair below the given `limit`. # Steps: 1. **Divisor Sum Calculation**: - Write a helper function to calculate the sum of proper divisors for any given number. 2. **Pair Identification**: - For each number from 1 up to `limit - 1`, calculate the sum of its proper divisors and check if it forms a friendly pair. 3. **Uniqueness**: - Ensure friendly pairs are unique and avoid duplicate entries. For instance, (220, 284) and (284, 220) should be regarded as the same pair. # Constraints: - The function should efficiently handle the default limit within reasonable execution time and space. - Only include pairs where both numbers are below the specified limit. # Example: ```python >>> find_friendly_pairs(10000) [(220, 284), (1184, 1210)] ``` # Implementation: Write your solution as a function in Python. ```python def find_friendly_pairs(limit: int = 10000) -> list[tuple[int, int]]: def sum_of_divisors(n: int) -> int: result = 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: result += i if i != n // i: result += n // i return result pairs = [] sum_divisors = {} for number in range(2, limit): sum_divisors[number] = sum_of_divisors(number) for a in range(2, limit): b = sum_divisors[a] if b > a and b < limit and sum_divisors.get(b) == a: pairs.append((a, b)) return pairs ``` Provide accompanying explanations for critical parts and document any assumptions or constraints.","solution":"def find_friendly_pairs(limit: int = 10000) -> list[tuple[int, int]]: def sum_of_divisors(n: int) -> int: Calculate the sum of proper divisors of n. Parameters: n (int): The number to calculate the sum of proper divisors for. Returns: int: The sum of proper divisors of n. result = 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: result += i if i != n // i: result += n // i return result pairs = [] sum_divisors = {} # Calculate the sum of proper divisors for each number up to the limit for number in range(2, limit): sum_divisors[number] = sum_of_divisors(number) # Identify friendly pairs for a in range(2, limit): b = sum_divisors[a] if b > a and b < limit and sum_divisors.get(b) == a: pairs.append((a, b)) return pairs"},{"question":"# Question: Validate Balanced Parentheses with Minimum Moves You need to validate if a sequence of parentheses is balanced and determine the minimum number of moves required to make it balanced if it\'s not. A sequence of parentheses is balanced if every opening parenthesis \'(\' has a corresponding closing parenthesis \')\', and the parentheses are properly nested. # Requirements: 1. Write a function `min_moves_to_balance(sequence: str) -> int` that takes a string of parentheses and returns the minimum number of moves required to balance it. 2. A move consists of either inserting a single parenthesis at any position or removing a single parenthesis. 3. Only consider the standard parentheses \'(\' and \')\' in the input string. 4. If the input is already balanced, the function should return 0. # Constraints: * The input string length will be between 0 and 200,000 characters. # Expected Input and Output: **Input**: A string `sequence` **Output**: An integer representing the minimum number of moves required to balance the input sequence ```python def min_moves_to_balance(sequence: str) -> int: >>> min_moves_to_balance(\\"(()\\") 1 >>> min_moves_to_balance(\\")(\\") 2 >>> min_moves_to_balance(\\"()()\\") 0 >>> min_moves_to_balance(\\"())(()\\") 2 pass ``` # Explanation: - You need to demonstrate a clear understanding of stack data structures and counting techniques. - Consider using a stack to track unmatched parentheses and counting to determine the number of insertions or removals required. - Aim to optimize the counting and validation process to handle large input efficiently. # Performance Requirement: * Ensure that the solution runs efficiently within the provided constraints.","solution":"def min_moves_to_balance(sequence: str) -> int: Returns the minimum number of moves required to balance the given sequence of parentheses. A move consists of either inserting or removing a single parenthesis. >>> min_moves_to_balance(\\"(()\\") 1 >>> min_moves_to_balance(\\")(\\") 2 >>> min_moves_to_balance(\\"()()\\") 0 >>> min_moves_to_balance(\\"())(()\\") 2 # Track the number of unmatched opening and closing parentheses unmatched_open = 0 unmatched_close = 0 for char in sequence: if char == \'(\': unmatched_open += 1 elif char == \')\': # If there is an unmatched opening parenthesis, match it with this closing one if unmatched_open > 0: unmatched_open -= 1 else: unmatched_close += 1 # The total number of moves to balance is the sum of unmatched opening and closing parentheses return unmatched_open + unmatched_close"},{"question":"# Scenario You are developing a data processing application that includes a feature to extract and format specific key-value pair entries from JSON objects. Users need the ability to extract values associated with particular keys from deeply nested JSON objects while ignoring any other content. # Problem Statement Implement a Python function called `extract_keys` that extracts the values for specified keys from a given JSON object, including nested structures. # Function Signature ```python def extract_keys(json_obj: dict, keys: set) -> dict: ``` # Inputs * `json_obj`: A dictionary representing the JSON object. This dictionary may contain other dictionaries and/or lists as nested structures. * `keys`: A set of strings representing the keys to be extracted from the JSON object. # Outputs * A dictionary containing only the key-value pairs for the specified keys. If a key is not found in the JSON object, it should not be included in the output. # Constraints * The function must handle errors gracefully and should raise a `TypeError` with the message \\"Invalid JSON object\\" if the input is not a dictionary. * The function should handle deeply nested structures and find keys at any level within the JSON object. # Performance Requirements * The solution should have a time complexity of O(n), where n is the total number of items in the JSON object including all nested structures. # Example ```python json_data = { \\"name\\": \\"John\\", \\"age\\": 30, \\"address\\": { \\"city\\": \\"New York\\", \\"zip\\": \\"10001\\" }, \\"contacts\\": [ { \\"type\\": \\"email\\", \\"value\\": \\"john@example.com\\" }, { \\"type\\": \\"phone\\", \\"value\\": \\"123-456-7890\\" } ] } keys_to_extract = {\\"name\\", \\"city\\", \\"value\\"} assert extract_keys(json_data, keys_to_extract) == { \\"name\\": \\"John\\", \\"city\\": \\"New York\\", \\"value\\": \\"john@example.com\\" } try: extract_keys(\\"invalid_input\\", keys_to_extract) except TypeError as e: assert str(e) == \\"Invalid JSON object\\" ``` Implement the `extract_keys` function to meet the given requirements and optimize for performance. Ensure the code is robust and capable of handling various nested JSON structures with appropriate error handling. Provide clear and readable code documentation.","solution":"def extract_keys(json_obj: dict, keys: set) -> dict: Extracts the values for specified keys from a given JSON object, including nested structures. Parameters: json_obj (dict): A dictionary representing the JSON object. keys (set): A set of strings representing the keys to be extracted from the JSON object. Returns: dict: A dictionary containing only the key-value pairs for the specified keys. Raises: TypeError: If json_obj is not a dictionary. if not isinstance(json_obj, dict): raise TypeError(\\"Invalid JSON object\\") result = {} def _extract(json_obj): if isinstance(json_obj, dict): for k, v in json_obj.items(): if k in keys: result[k] = v if isinstance(v, (dict, list)): _extract(v) elif isinstance(json_obj, list): for item in json_obj: _extract(item) _extract(json_obj) return result"},{"question":"# Longest Consecutive Sequence Implement a function to find the longest consecutive elements sequence from an unsorted array of integers. The sequence should be able to handle both positive and negative numbers, and the result should be returned in O(n) time complexity, making efficient use of hash sets. Implementation Function `def longest_consecutive(nums: List[int]) -> int:` # Input - A list `nums` where `nums` is an unsorted array: - Length of `nums` is `n` (0  n  10^5). - Elements of `nums` are integers within the range -10^9 to 10^9. # Output - An integer representing the length of the longest consecutive sequence in the array. # Examples ```python >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 # The longest consecutive sequence is [1, 2, 3, 4] >>> longest_consecutive([0, -1, 3, 7, 2, 0, 1, 1, -2]) 6 # The longest consecutive sequence is [-2, -1, 0, 1, 2, 3] >>> longest_consecutive([9]) 1 # The longest consecutive sequence is [9] >>> longest_consecutive([-1, -2, -3, -4, -5]) 5 # The longest consecutive sequence is [-5, -4, -3, -2, -1] >>> longest_consecutive([5, 5, 8, 9, 10]) 3 # The longest consecutive sequence is [8, 9, 10] ``` # Constraints 1. The function should run in O(n) time complexity. 2. Handle edge cases, including empty arrays and arrays with only one element. 3. Return the length of the longest consecutive sequence, not the sequence itself. Note Utilize hash set to achieve the desired time complexity, ensuring all potential elements are considered only once during the sequence formation.","solution":"from typing import List def longest_consecutive(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) longest = 0 for num in num_set: if num - 1 not in num_set: # start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest = max(longest, current_streak) return longest"},{"question":"# Question: Flatten Nested List You are required to implement a function that flattens a nested list. Flattening a list means converting a list which may have several nested lists into a single list with all the elements at the same level. Function Signature ```python def flatten_list(nested_list: list) -> list: pass ``` # Input 1. `nested_list`: A list which may have multiple nested lists within it. The depth and complexity of nesting can vary. # Output * Returns a single list containing all the elements from the nested structure in a flattened form. # Constraints - The function should handle lists of any depth. - Maintain the order of elements as they appear in the original nested list. - Lists may contain any data type (integers, strings, floats, etc.) # Example ```python nested_list = [1, [2, [3, 4], 5], 6, [7, [8, 9]], 10] flat_list = flatten_list(nested_list) print(flat_list) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` # Explanation In this example: - The input list `[1, [2, [3, 4], 5], 6, [7, [8, 9]], 10]` contains several nested lists. - The function `flatten_list` should return a single list `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` containing all the elements in the same order as they appear in the original structure.","solution":"def flatten_list(nested_list: list) -> list: Flattens a nested list into a single list with all elements at the same level. Parameters: nested_list (list): A list that may contain nested lists of varying depth. Returns: list: A single flattened list with all elements in the same order as they appear in the original list. flat_list = [] def _flatten(sublist): for element in sublist: if isinstance(element, list): _flatten(element) else: flat_list.append(element) _flatten(nested_list) return flat_list"},{"question":"# Question: You are tasked with developing a function to transform a given binary tree structure into its mirrored version (flipped horizontally). Specifically, you need to optimize the `mirror_binary_tree` function to invert the tree in-place without using additional data structures. Function Signature: ```python def mirror_binary_tree(root: TreeNode) -> TreeNode: ``` # Requirements: 1. Traverse the tree and swap the left and right child nodes of each node recursively. 2. Ensure the function modifies the tree in-place and returns the root of the mirrored tree. 3. Handle edge cases such as: - An empty tree (root is `None`). 4. Validate correctness using the provided test cases and create additional tests if necessary. # Expected input and output formats: - **Input**: A binary tree represented by its root node. - **Output**: The root node of the mirrored binary tree. # Performance requirements: - **Aim for O(n)** time complexity for `mirror_binary_tree`, where `n` is the number of nodes in the binary tree. # Sample Test Cases: ```python # Helper function to create a binary tree from a list of values (for testing purposes) def create_binary_tree(values: List[int]) -> TreeNode: return ... # Helper function to convert a mirrored binary tree back to a list of values (for testing purposes) def convert_tree_to_list(root: TreeNode) -> List[int]: return ... # Example tree: 1 # / # 2 3 # / / # 4 5 6 7 # # Mirrored tree: 1 # / # 3 2 # / / # 7 6 5 4 root = create_binary_tree([1, 2, 3, 4, 5, 6, 7]) mirrored_root = mirror_binary_tree(root) assert convert_tree_to_list(mirrored_root) == [1, 3, 2, 7, 6, 5, 4] # Edge case: Single node tree root = create_binary_tree([1]) mirrored_root = mirror_binary_tree(root) assert convert_tree_to_list(mirrored_root) == [1] # Edge case: Empty tree root = create_binary_tree([]) mirrored_root = mirror_binary_tree(root) assert mirrored_root is None ``` # Additional Context: - Use depth-first traversal (either pre-order or post-order) to achieve an efficient in-place mirroring of the binary tree. - Ensure no additional space is utilized other than the call stack for recursion.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_binary_tree(root: TreeNode) -> TreeNode: if root is None: return None # Recursively mirror the left and right subtrees mirror_binary_tree(root.left) mirror_binary_tree(root.right) # Swap the left and right children root.left, root.right = root.right, root.left return root def create_binary_tree(values): if not values: return None nodes = [None if val is None else TreeNode(val) for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def convert_tree_to_list(root): if not root: return [] result, queue = [], [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) while result and result[-1] is None: result.pop() return result"},{"question":"# Coding Question: Implement Custom `min` Function Objective Write a function that emulates the behavior of Python\'s built-in `min` function. The function should work with any iterable and handle various edge cases appropriately. Function Signature ```python def custom_min(iterable, key=None): Return the smallest item in the iterable based on the key (if provided). ``` Description **You need to implement a function `custom_min(iterable, key=None)` that returns the smallest item in the provided iterable. If the `key` parameter is specified, the smallest item should be determined based on the return value of the key function applied to each item.** Input and Output Formats **Input**: * An iterable (e.g., list, tuple, set) containing comparable items. * An optional `key` parameter (default is `None`), which is a function of one argument that extracts a comparison key from each element in the iterable. **Output**: * The smallest item from the provided iterable. Constraints 1. The function should raise a `ValueError` if the input iterable is empty. 2. The function should support various iterable types and should handle the presence of the `key` parameter accurately. 3. The function should mimic the behavior and edge cases of the built-in `min` function. Examples ```python >>> custom_min([3, 1, 4, 1, 5, 9]) 1 >>> custom_min((\'apple\', \'banana\', \'cherry\')) \'apple\' >>> custom_min([\'apple\', \'banana\', \'cherry\'], key=len) \'cherry\' >>> custom_min({2, 3, 1}) 1 >>> custom_min([], key=lambda x: x) Traceback (most recent call last): ... ValueError: custom_min() arg is an empty sequence ``` Implementation Notes * Compare items directly if no key function is provided. * If a key function is provided, compare items using the key function\'s return values. * Ensure compatibility with various types of iterables including lists, tuples, and sets. * Handle edge cases such as empty iterables by raising appropriate exceptions. ```python def custom_min(iterable, key=None): if len(iterable) == 0: raise ValueError(\\"custom_min() arg is an empty sequence\\") iterator = iter(iterable) min_item = next(iterator) for item in iterator: if key: if key(item) < key(min_item): min_item = item else: if item < min_item: min_item = item return min_item ```","solution":"def custom_min(iterable, key=None): Return the smallest item in the iterable based on the key (if provided). :param iterable: An iterable from which to find the minimum element. :param key: A function that extracts the comparison key from each element in the iterable. :return: The smallest item in the iterable. :raises ValueError: If the input iterable is empty. iterator = iter(iterable) try: min_item = next(iterator) except StopIteration: raise ValueError(\\"custom_min() arg is an empty sequence\\") for item in iterator: if key is None: if item < min_item: min_item = item else: if key(item) < key(min_item): min_item = item return min_item"},{"question":"# Longest Increasing Subsequence (LIS) with Dynamic Programming You are required to implement an algorithm to find the length of the longest increasing subsequence (LIS) in a given list of integers using dynamic programming to ensure efficient time complexity. **Scenario**: A data analyst is trying to determine the longest period of consistent improvement in a series of monthly sales figures. Each month\'s sales figure is provided in a sequential list, and the analyst needs to identify the longest subsequence where each subsequent sales figure is greater than the previous one. Develop a function to determine this length. **Function Specification**: ```python def longest_increasing_subsequence(nums: list) -> int: :param nums: List of integers representing monthly sales figures. :return: Length of the longest increasing subsequence. ``` **Input and Output Formats**: * Input: * `nums`  List of n integers representing the sales figures. * Output: * An integer representing the length of the longest increasing subsequence. **Constraints**: * `0 <= n <= 1000` * `-10^9 <= nums[i] <= 10^9` **Performance Requirements**: * Ensure your solution runs efficiently with the given constraints using dynamic programming. **Examples**: ```python # Example 1 print(longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])) # Output: 4 (The LIS is [2, 3, 7, 101]) # Example 2 print(longest_increasing_subsequence([0, 1, 0, 3, 2, 3])) # Output: 4 (The LIS is [0, 1, 2, 3]) # Example 3 print(longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7])) # Output: 1 (The LIS is [7]) ``` Ensure your function handles edge cases properly and runs efficiently within the provided constraints.","solution":"def longest_increasing_subsequence(nums: list) -> int: Returns the length of the longest increasing subsequence in a list of integers. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Number of Islands An application involves the detection of separate clusters of land in a grid, commonly visualized as islands. You are tasked with writing a function to count the number of distinct islands in a given 2D grid map. Each cell in the grid is either \'1\' (representing land) or \'0\' (representing water). An island is formed by connecting adjacent lands horizontally or vertically. The grid is completely surrounded by water, and each cell is either explicitly connected or isolated. Task Write a Python function `num_islands(grid: List[List[str]]) -> int` that finds the number of islands in a given grid. Function Signature ```python from typing import List def num_islands(grid: List[List[str]]) -> int: pass ``` Details 1. **Traversal**: Traverse the grid using Depth First Search (DFS) or Breadth First Search (BFS) to mark connected components (islands). 2. **Counting**: Count each connected component as an island. Input * `grid`: A 2D list (list of lists) of characters \'1\' and \'0\' representing the map (1  len(grid), len(grid[i])  300). Output * An integer representing the number of distinct islands. Example ```python grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] output = num_islands(grid) print(output) # Returns: 3 ``` Constraints * Ensure that your solution can efficiently handle the maximum grid dimensions. * The grid is fully surrounded by water, meaning there is no land connected with the grid boundaries. Notes 1. Implement the traversal in such a manner to properly mark visited cells without revisiting. 2. Consider edge cases like fully water grid, fully land grid, or single row/column grids. 3. Optimize the space by utilizing the grid itself for marking visited cells if applicable.","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == \'0\': return grid[x][y] = \'0\' # Mark the land visited by sinking the island directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up for dx, dy in directions: dfs(x + dx, y + dy) num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': num_islands += 1 dfs(i, j) return num_islands"},{"question":"# Problem Statement You are given two strings: a target string `target` and a source string `source`. The task is to determine if `source` can be transformed into `target` by performing a series of operations. The allowed operations are: 1. Append a character to the end of the string. 2. Remove the last character of the string. 3. Replace the last character of the string with another character. Return the minimum number of operations required to transform `source` into `target`. If it is impossible to do so, return -1. # Function Signature Write a function: ```python def min_operations(source: str, target: str) -> int: # Your implementation here ``` # Input and Output Input: * `source`: A string representing the initial string. `source` will have a length that does not exceed 100. * `target`: A string representing the desired string. `target` will have a length that does not exceed 100. Output: * An integer representing the minimum number of operations required to transform `source` into `target`. If it\'s impossible, return -1. # Constraints * The length of both `source` and `target` will be between 0 and 100. * Both `source` and `target` will only contain lowercase English letters. # Examples ```python assert min_operations(\\"abc\\", \\"ab\\") == 1 # Remove \'c\' assert min_operations(\\"abc\\", \\"adc\\") == 1 # Replace \'b\' with \'d\' assert min_operations(\\"abc\\", \\"abcd\\") == 1 # Append \'d\' assert min_operations(\\"abc\\", \\"abc\\") == 0 # No operations needed assert min_operations(\\"abc\\", \\"xyz\\") == -1 # Impossible transformation ``` # Notes * You should handle the edge cases where `source` and/or `target` might be empty strings. * The function should return -1 if transforming `source` into `target` is impossible under the given set of operations.","solution":"def min_operations(source: str, target: str) -> int: m = len(source) n = len(target) # If either string is empty, the number of operations is equal to the length of the other string if m == 0: return n if n == 0: return m # Use a 2D DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Same last character, no new operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove last character dp[i][j - 1], # Append character dp[i - 1][j - 1] # Replace last character ) result = dp[m][n] return result if result < m + n else -1 # Return -1 if transformation is impossible"},{"question":"# Ohm\'s Law Voltage Drop Calculation You are tasked with implementing a function to calculate the voltage drop across a resistor in an electrical circuit using Ohm\'s Law. The voltage drop is determined by the current flowing through the resistor and its resistance. Your function should take the following inputs: - `current` (float): The current flowing through the resistor in amperes (A). - `resistance` (float): The resistance of the resistor in ohms (). The voltage drop, (V), should be calculated using the formula: [ V = I cdot R ] where: * (I) is the current, and * (R) is the resistance. Your implementation should validate the input values: - Both current and resistance should be positive values. If any of the conditions are violated, your function should raise a ValueError with an appropriate message. # Function Signature ```python def voltage_drop(current: float, resistance: float) -> float: pass ``` # Input * current (float): A positive float representing the current in amperes. * resistance (float): A positive float representing the resistance in ohms. # Output * float: The computed voltage drop, or an exception raised for invalid inputs. # Constraints * Inputs must both be positive floats. # Example ```python # Example usage voltage_drop(current=2.0, resistance=5.0) # Output: 10.0 voltage_drop(current=-2.0, resistance=5.0) # Output: ValueError: Current should be positive ``` # Hints Make sure to handle the edge cases and input validation appropriately to avoid errors during computation. Use straightforward arithmetic operations to implement the formula.","solution":"def voltage_drop(current: float, resistance: float) -> float: Calculate the voltage drop across a resistor using Ohm\'s Law. Parameters: current (float): The current flowing through the resistor in amperes (A). Must be positive. resistance (float): The resistance of the resistor in ohms (). Must be positive. Returns: float: The calculated voltage drop. Raises: ValueError: If current or resistance are not positive numbers. if current <= 0: raise ValueError(\\"Current should be positive\\") if resistance <= 0: raise ValueError(\\"Resistance should be positive\\") return current * resistance"},{"question":"Task # Finding Non-Repeating Character in a String **Background**: Given a string, your task is to find the first non-repeating character in it. This question helps evaluate your understanding of string manipulation, use of data structures for counting and efficient searching techniques. **Problem Statement**: Implement a function `first_non_repeating_char(s: str) -> str` that takes a string `s` and returns the first non-repeating character in the string. If all characters are repeating, return an empty string. # Implementation Details 1. **Character Counting**: Use a dictionary or collections.Counter to count occurrences of each character in the string. 2. **Non-Repeating Character Identification**: Iterate through the string to identify the first character that appears exactly once. # Function Signature ```python def first_non_repeating_char(s: str) -> str: pass ``` # Input * `s`: A string consisting of alphanumeric characters and possibly special characters. The length of `s` will be between 1 and 10^6. # Output * Returns a single character string representing the first non-repeating character, or an empty string if no such character exists. # Example ```python assert first_non_repeating_char(\\"aabcc\\") == \\"b\\" assert first_non_repeating_char(\\"aabbcc\\") == \\"\\" assert first_non_repeating_char(\\"leetcode\\") == \\"l\\" assert first_non_repeating_char(\\"frequency\\") == \\"f\\" ``` # Constraints * Consider both uppercase and lowercase letters as distinct characters. * Optimize for time and space, considering edge cases associated with large inputs. * The function should work correctly for both small and large strings, and handle any non-alphabetic characters appropriately.","solution":"def first_non_repeating_char(s: str) -> str: Finds the first non-repeating character in the string. Parameters: s (str): The input string Returns: str: The first non-repeating character or an empty string if all characters are repeating from collections import Counter # Count occurrences of each character using Counter count = Counter(s) # Iterate through the string to find the first non-repeating character for char in s: if count[char] == 1: return char # If no non-repeating character is found, return empty string return \\"\\""},{"question":"# Summing Fibonacci Sequence Modulo n You are tasked with calculating the sum of a Fibonacci sequence up to a given term `n`, and then taking the result modulo a given integer `m`. The Fibonacci sequence starts with `0` and `1`, and each subsequent number is the sum of the previous two. Function Signature ```python def fibonacci_sum_modulo(n: int, m: int) -> int: Calculates the sum of the first `n` Fibonacci numbers modulo `m`. Parameters: n (int): The term up to which the Fibonacci sequence should be summed (0-indexed). m (int): The modulus value. Returns: int: The sum of the first `n` Fibonacci numbers modulo `m`. Raises: ValueError: If `n` is negative or `m` is not a positive integer. ``` Input - `n`: A non-negative integer (0 <= n <= 10^6), indicating the term up to which the Fibonacci sequence should be summed. - `m`: A positive integer (1 <= m <= 10^9), the modulus value. Output - Returns an integer representing the sum of the first `n` Fibonacci numbers, taken modulo `m`. Constraints - Your solution should be efficient and handle large values of `n` and `m` seamlessly. - Consider edge cases such as `n` or `m` being the smallest possible values. Examples ```python >>> fibonacci_sum_modulo(5, 10) 2 # The first six Fibonacci numbers are 0, 1, 1, 2, 3, 5; their sum is 12, 12 % 10 = 2 >>> fibonacci_sum_modulo(0, 100) 0 # The first Fibonacci number is 0; 0 % 100 is 0 >>> fibonacci_sum_modulo(10, 7) 3 # The first eleven Fibonacci numbers are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55; their sum is 143, 143 % 7 = 3 >>> fibonacci_sum_modulo(50, 13) 9 # Long computation, observe constraints with large inputs ```","solution":"def fibonacci_sum_modulo(n: int, m: int) -> int: Calculates the sum of the first `n` Fibonacci numbers modulo `m`. Parameters: n (int): The term up to which the Fibonacci sequence should be summed (0-indexed). m (int): The modulus value. Returns: int: The sum of the first `n` Fibonacci numbers modulo `m`. Raises: ValueError: If `n` is negative or `m` is not a positive integer. if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if m <= 0: raise ValueError(\\"m must be a positive integer.\\") if n == 0: return 0 # Initialize the first two Fib numbers and the cumulative sum fib = [0, 1] fib_sum = 1 if n == 1: return fib_sum % m # Calculate Fibonacci terms and their sum up to the nth term for i in range(2, n + 1): fib.append(fib[-1] + fib[-2]) fib_sum += fib[-1] return fib_sum % m"},{"question":"# Scenario A data scientist is building a feature to automatically encode categorical variables into a numerical format while working on a machine learning problem. They decide to implement a label encoding mechanism, which assigns a unique integer to each unique category. However, the data may contain both string and integer categories, and they should handle these appropriately. # Task Write a Python function `label_encode(categories: List[Union[str, int]]) -> Dict[Union[str, int], int]` that takes a list of categories (either strings or integers) and returns a dictionary mapping each unique category to a unique integer. The mapping should start from 0 and be incremented by 1 for each new category encountered in the order they appear in the input list. # Requirements - Ensure the function works for a mix of string and integer categories. - The encoded integers should start from 0 and increment by 1 for each new category. # Input and Output - **Input**: A list of categories `categories` which can be a mix of strings and integers. - **Output**: A dictionary mapping each unique category to a unique integer. # Constraints - The input list will have between 1 and 10,000 elements. - Categories are either strings or integers. Mixing types for the same category should be treated as distinct items. # Examples ```python >>> label_encode([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\"]) {\'apple\': 0, \'banana\': 1, \'orange\': 2} >>> label_encode([1, \\"one\\", 2, \\"two\\", 1]) {1: 0, \'one\': 1, 2: 2, \'two\': 3} >>> label_encode([10, 10, 20, \\"10\\", \\"10\\"]) {10: 0, 20: 1, \'10\': 2} >>> label_encode([]) {} ``` **Notes** - Use a loop to iterate over the input list and a dictionary to store the mappings. - The order in which categories appear in the list should be preserved in the numerical encoding.","solution":"from typing import List, Union, Dict def label_encode(categories: List[Union[str, int]]) -> Dict[Union[str, int], int]: Encodes a list of categories (strings or integers) into a dictionary mapping each unique category to a unique integer. Parameters: categories (List[Union[str, int]]): The list of categories to encode. Returns: Dict[Union[str, int], int]: A dictionary with keys as unique categories and values as unique integers. encoding_map = {} current_index = 0 for category in categories: if category not in encoding_map: encoding_map[category] = current_index current_index += 1 return encoding_map"},{"question":"# Matrix Transformation and Querying You are given a matrix of integers. Your task is to implement an algorithm that rotates the matrix 90 degrees clockwise and then calculates the sum of elements in a submatrix defined by two given coordinates. # Requirements 1. **Function**: `matrix_rotation_and_sum(matrix: List[List[int]], top_left: Tuple[int, int], bottom_right: Tuple[int, int]) -> int` 2. **Inputs**: - `matrix` - A 2D list of integers representing the matrix to be rotated. - `top_left` - A tuple `(r1, c1)` representing the top-left coordinate of the submatrix. - `bottom_right` - A tuple `(r2, c2)` representing the bottom-right coordinate of the submatrix. 3. **Output**: - An integer representing the sum of the elements within the specified submatrix after the matrix has been rotated 90 degrees clockwise. 4. **Constraints**: - The input matrix is guaranteed to be non-empty and rectangular (i.e., all rows have the same number of columns). - The top-left and bottom-right coordinates are valid and within the bounds of the matrix. # Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Rotated matrix: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] assert matrix_rotation_and_sum(matrix, (0, 0), (1, 1)) == 24 # sum of [7, 4, 8, 5] matrix2 = [ [1, 2], [3, 4] ] # Rotated matrix: # [ # [3, 1], # [4, 2] # ] assert matrix_rotation_and_sum(matrix2, (0, 0), (1, 0)) == 7 # sum of [3, 4] ``` # Notes - You should first rotate the matrix 90 degrees clockwise. - After rotation, you should then calculate the sum of the submatrix defined by `(r1, c1)` and `(r2, c2)` (inclusive). - Ensure the rotated matrix transformation is correctly implemented. - Handle edge cases such as small matrices and submatrices that span the entire matrix.","solution":"from typing import List, Tuple def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise. rows, cols = len(matrix), len(matrix[0]) rotated_matrix = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated_matrix[c][rows - 1 - r] = matrix[r][c] return rotated_matrix def matrix_rotation_and_sum(matrix: List[List[int]], top_left: Tuple[int, int], bottom_right: Tuple[int, int]) -> int: Rotates the matrix 90 degrees clockwise and calculates the sum of elements in the submatrix defined by top_left and bottom_right coordinates. # Rotate the given matrix 90 degrees clockwise rotated_matrix = rotate_matrix_90_clockwise(matrix) # Extract the coordinates r1, c1 = top_left r2, c2 = bottom_right # Calculate the sum of elements in the specified submatrix submatrix_sum = 0 for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): submatrix_sum += rotated_matrix[r][c] return submatrix_sum"},{"question":"# Programming Question **Scenario** A logistics company is refining its operations to calculate and track the travel time of its fleet moving between multiple cities. The system needs to calculate the average speed of vehicles based on the distance traveled and the time taken. You are tasked with building a function to support this capability. **Problem Statement** Implement a function `calculate_average_speed` that computes the average speed of a vehicle given the distance traveled and the time taken. The function should return the result in either kilometers per hour or miles per hour based on specified units. You may assume the conversions: 1 kilometer per hour (km/h) = 0.621371 miles per hour (mph) 1 mile per hour (mph) = 1.60934 kilometers per hour (km/h) **Function Signature** ```python def calculate_average_speed(distance: float, time: float, unit: str) -> float: pass ``` **Input** - `distance` (float): The distance traveled by the vehicle. - `time` (float): The time taken to travel the given distance (in hours). - `unit` (str): The unit of the average speed to be returned, either \'km/h\' or \'mph\'. **Output** - (float): The average speed in the specified units, rounded to 2 decimal places. **Constraints** - The input `unit` is always valid and will be either \'km/h\' or \'mph\'. - The `distance` and `time` will be positive values. **Examples** ```python # Example 1 # Calculate average speed of 150 kilometers in 3 hours in km/h print(calculate_average_speed(150, 3, \'km/h\')) # Output: 50.00 # Example 2 # Calculate average speed of 150 kilometers in 3 hours in mph print(calculate_average_speed(150, 3, \'mph\')) # Output: 31.07 # Example 3 # Calculate average speed of 100 miles in 2 hours in mph print(calculate_average_speed(100, 2, \'mph\')) # Output: 50.00 # Example 4 # Calculate average speed of 100 miles in 2 hours in km/h print(calculate_average_speed(100, 2, \'km/h\')) # Output: 80.47 ``` **Notes** - Ensure that the output is rounded to 2 decimal places. - You may need to handle conversion appropriately based on the provided unit. - Consider edge cases where conversions between units are required for accurate results.","solution":"def calculate_average_speed(distance: float, time: float, unit: str) -> float: if unit == \'km/h\': average_speed = distance / time elif unit == \'mph\': average_speed = (distance / time) * 0.621371 return round(average_speed, 2)"},{"question":"A city has a grid of cells where each cell can either be water or land. You are given a \\"height map\\" of this grid where each cell contains an integer height. Your task is to determine the number of distinct islands that can be formed. An island is defined as a group of connected land cells (horizontally, vertically, and diagonally) that have the same height. **Task**: Count the number of distinct islands on the grid where an island is identified by connected cells of the same height. **Function Signature**: ```python def count_islands(height_map: List[List[int]]) -> int: Args: height_map : List[List[int]] : 2D list where each element represents the height at a specific cell in the grid. Returns: int : Number of distinct islands in the height map. ``` # Input * List of lists `height_map` representing the grid (1  len(height_map)  300, 1  len(height_map[0])  300). * `height_map[i][j]` is an integer representing the height at cell `(i, j)` (1  height_map[i][j]  1000). # Output * Integer count representing the number of distinct islands of same-height cells. # Example ```python height_map = [ [1, 2, 2, 3], [1, 2, 2, 3], [1, 1, 1, 3], [4, 4, 4, 4] ] print(count_islands(height_map)) # Output: 4 ``` # Explanation - There are 4 distinct islands: 1. The island containing the cells with the height `1` in the top-left. 2. The island containing the cells with the height `2` in the top-middle. 3. The island containing the cells with the height `3` in the top-right. 4. The island containing the cells with the height `4` in the bottom. # Constraints * Plan your solution to manage large input sizes effectively, implementing an appropriate graph traversal technique such as Depth-First Search (DFS) or Breadth-First Search (BFS).","solution":"from typing import List def count_islands(height_map: List[List[int]]) -> int: def dfs(x, y, h): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and height_map[nx][ny] == h: visited[nx][ny] = True stack.append((nx, ny)) if not height_map: return 0 rows, cols = len(height_map), len(height_map[0]) visited = [[False] * cols for _ in range(rows)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] islands_count = 0 for i in range(rows): for j in range(cols): if not visited[i][j]: islands_count += 1 visited[i][j] = True dfs(i, j, height_map[i][j]) return islands_count"},{"question":"# Question: Array Median Finder and Data Stream Processor Context In data analysis and statistics, the median of a set of numbers is often a more robust measure of central tendency compared to the mean. Real-time data processing systems frequently need to calculate the median on-the-fly as new data points arrive. Designing an efficient algorithm to achieve this can be challenging, especially when dealing with potentially unbounded streams of data. Task Implement a class `MedianFinder` that supports adding integers to a data stream and finding the median of the current stream efficiently. Class Definition 1. **MedianFinder** ```python class MedianFinder: def __init__(self): Initializes the MedianFinder with empty data streams. ... def add_num(self, num: int) -> None: Adds a number to the data stream. Args: num : The integer to add to the data stream. Returns: None ... def find_median(self) -> float: Finds the median of the current data stream. Returns: The median as a float. ... ``` Input Constraints - Numbers added to the data stream are in the range of `-10^5 <= num <= 10^5`. - The median can be an integer or a float, depending on whether the number of elements in the data stream is odd or even. Output - For `add_num`, there is no output, the method just updates the internal state. - For `find_median`, return a float representing the median of the current data stream. Requirements - The `find_median` method must have an efficient time complexity to handle potentially large data streams. - Ensure the implementation handles edge cases gracefully (e.g., finding the median on an empty data stream). Examples ```python # Example for MedianFinder class mf = MedianFinder() mf.add_num(1) mf.add_num(2) print(mf.find_median()) # Output: 1.5 mf.add_num(3) print(mf.find_median()) # Output: 2.0 mf.add_num(4) mf.add_num(5) print(mf.find_median()) # Output: 3.0 ``` Write your implementation for the `MedianFinder` class below.","solution":"import heapq class MedianFinder: def __init__(self): Initializes the MedianFinder with empty data streams. self.min_heap = [] # Min heap to store the larger half of the numbers self.max_heap = [] # Max heap to store the smaller half of the numbers def add_num(self, num: int) -> None: Adds a number to the data stream. Args: num : The integer to add to the data stream. Returns: None if not self.max_heap or num < -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) # Balance the heaps if necessary if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: Finds the median of the current data stream. Returns: The median as a float. if len(self.max_heap) == len(self.min_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 else: return -self.max_heap[0] if len(self.max_heap) > len(self.min_heap) else self.min_heap[0]"},{"question":"# Problem Statement You are tasked with implementing a word frequency analysis feature for a text processing application. This feature will allow users to input a block of text and obtain a list of words sorted by their frequency of occurrence. The words should be case insensitive, meaning \\"Hello\\" and \\"hello\\" should be treated as the same word. Additionally, the output should exclude common stop words. # Input: - A block of text as a single string. # Output: - A list of tuples, where each tuple contains a word and its frequency, sorted by frequency in descending order. If two words have the same frequency, they should be sorted alphabetically. # Constraints: - The text will contain only alphabetic characters and spaces. - The output list should exclude common stop words (e.g., \\"and\\", \\"the\\", \\"is\\", etc.). - The comparison of words should be case insensitive. # Requirements: 1. Implement the function `word_frequency_analysis(text: str) -> List[Tuple[str, int]]` that processes the input text string and outputs a sorted list of word-frequency tuples. 2. Ensure common stop words are not included in the output. 3. Word frequencies should be accurate and case insensitive. 4. The result should be sorted first by frequency (in descending order) and then alphabetically if frequencies are the same. # Example Usage: ```python >>> text = \\"Hello world! Hello everyone. This is a simple test, isn\'t it wonderful to have a simple test?\\" >>> word_frequency_analysis(text) [(\'hello\', 2), (\'simple\', 2), (\'test\', 2), (\'a\', 1), (\'everyone\', 1), (\'have\', 1), (\'isnt\', 1), (\'it\', 1), (\'this\', 1), (\'to\', 1), (\'wonderful\', 1), (\'world\', 1)] >>> text = \\"Python is great. Python can be used for many applications. Learning Python is fun!\\" >>> word_frequency_analysis(text) [(\'python\', 3), (\'is\', 2), (\'applications\', 1), (\'be\', 1), (\'can\', 1), (\'for\', 1), (\'fun\', 1), (\'great\', 1), (\'learning\', 1), (\'many\', 1), (\'used\', 1)] ``` # Error Scenarios: No specific error handling is required for this task as long as the input follows the given constraints. # Stop Words List: Use the following stop words for this task: ``` STOP_WORDS = {\'and\', \'or\', \'but\', \'so\', \'a\', \'an\', \'the\', \'is\', \'are\', \'was\', \'were\', \'it\', \'to\', \'at\', \'on\', \'in\', \'with\', \'for\', \'of\', \'by\', \'this\', \'that\', \'these\', \'those\'} ```","solution":"from typing import List, Tuple from collections import Counter import re STOP_WORDS = {\'and\', \'or\', \'but\', \'so\', \'a\', \'an\', \'the\', \'is\', \'are\', \'was\', \'were\', \'it\', \'to\', \'at\', \'on\', \'in\', \'with\', \'for\', \'of\', \'by\', \'this\', \'that\', \'these\', \'those\'} def word_frequency_analysis(text: str) -> List[Tuple[str, int]]: # Convert the text to lowercase to make it case insensitive text = text.lower() # Remove non-alphabetic characters and tokenize words words = re.findall(r\'b[a-z]+b\', text) # Filter out the stop words words = [word for word in words if word not in STOP_WORDS] # Count the frequency of each word word_counts = Counter(words) # Sort the words first by frequency (in descending order) and then alphabetically sorted_word_counts = sorted(word_counts.items(), key=lambda pair: (-pair[1], pair[0])) return sorted_word_counts"},{"question":"# Matrix Multiplication Validator Context In computer science, matrix multiplication is a fundamental operation often used in various areas like graphics, cryptography, and machine learning. Given two matrices, the product of these matrices can only be computed if the number of columns in the first matrix is equal to the number of rows in the second matrix. Your task is to implement a function that validates if two matrices can be multiplied and then performs the multiplication if they are compatible. Task Write a function `matrix_multiplication` that takes two matrices as input, verifies whether they can be multiplied, and returns the resulting matrix. If they cannot be multiplied, return an appropriate error message. Function Signature ```python def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> Union[List[List[int]], str]: pass ``` Input * `A` (List[List[int]]): The first matrix, a list of lists where each inner list represents a row. * `B` (List[List[int]]): The second matrix, a list of lists where each inner list represents a row. Output * If the matrices `A` and `B` can be multiplied, return the resulting matrix (List[List[int]]). * Otherwise, return a string `Matrices cannot be multiplied`. Constraints * Each matrix `A` and `B` must be a valid matrix consisting of integers. * The dimensions of the matrices must be within reasonable limits (e.g., 1  rows, columns  100). Requirements * Ensure the algorithm efficiently checks for multiplication compatibility and performs the multiplication if possible. * Handle edge cases such as empty matrices or incompatible dimensions. Example ```python # Example 1: A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] # Can multiply: Dimensions are 2x2 and 2x2 matrix_multiplication(A, B) # Output: [[19, 22], [43, 50]] since the product of the matrices is: # | 1 2 | | 5 6 | = | 1*5 + 2*7 1*6 + 2*8 | = | 19 22 | # | 3 4 | * | 7 8 | = | 3*5 + 4*7 3*6 + 4*8 | = | 43 50 | # Example 2: A = [ [1, 2, 3] ] B = [ [4], [5], [6] ] # Can multiply: Dimensions are 1x3 and 3x1 matrix_multiplication(A, B) # Output: [[32]] since the product is: # | 1 2 3 | | 4 | = | 1*4 + 2*5 + 3*6 | = | 32 | # | 5 | # | 6 | # Example 3: A = [ [1, 2] ] B = [ [1], [2], [3] ] # Cannot multiply: Dimensions are 1x2 and 3x1 which are incompatible matrix_multiplication(A, B) # Output: \\"Matrices cannot be multiplied\\" # Example 4: A = [] B = [ [1, 2], [3, 4] ] # Cannot multiply: First matrix is empty matrix_multiplication(A, B) # Output: \\"Matrices cannot be multiplied\\" ``` NOTE: Focus on validating the compatibility and performing the necessary operations to multiply the matrices. Utilizing existing libraries or implementing basic matrix operations from scratch are both acceptable approaches.","solution":"from typing import List, Union def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> Union[List[List[int]], str]: # Check if either matrix is empty if not A or not B or not A[0] or not B[0]: return \\"Matrices cannot be multiplied\\" # Get the dimensions of matrices A and B rows_A, cols_A = len(A), len(A[0]) rows_B, cols_B = len(B), len(B[0]) # Check for compatibility if cols_A != rows_B: return \\"Matrices cannot be multiplied\\" # Initialize the result matrix with zeros result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform the multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Problem Statement You are developing an application for a library that manages a list of books and their respective qualities. One of the functionalities required is to filter out books based on their length and condition. A book is represented as a dictionary with the following structure: ```python { \'title\': str, \'author\': str, \'pages\': int, \'condition\': str } ``` Here: - `title` is the title of the book. - `author` is the author of the book. - `pages` is the number of pages in the book. - `condition` is the condition of the book (either \'new\', \'good\', \'fair\', or \'poor\'). Your task is to create a function `filter_books(books: list, min_pages: int, condition: str) -> list` that filters the books based on the minimum number of pages and the condition provided. Function Signature ```python def filter_books(books: list, min_pages: int, condition: str) -> list: pass ``` Input and Output - **Input**: - A list of dictionaries, where each dictionary represents a book. - An integer `min_pages` representing the minimum number of pages a book must have. - A string `condition` denoting the required condition quality of the book (\'new\', \'good\', \'fair\', or \'poor\'). - **Output**: - A list of dictionaries representing books that meet the specified criteria of having at least `min_pages` pages and matching the specified `condition`. Constraints - The list `books` will contain at most 1000 book dictionaries. - Each book dictionary will contain valid data types for each field. - The `condition` string will always be one of \'new\', \'good\', \'fair\', or \'poor\'. - `min_pages` will always be a non-negative integer. # Examples ```python >>> books = [ ... {\'title\': \'Book A\', \'author\': \'Author A\', \'pages\': 100, \'condition\': \'new\'}, ... {\'title\': \'Book B\', \'author\': \'Author B\', \'pages\': 150, \'condition\': \'good\'}, ... {\'title\': \'Book C\', \'author\': \'Author C\', \'pages\': 120, \'condition\': \'fair\'}, ... {\'title\': \'Book D\', \'author\': \'Author D\', \'pages\': 80, \'condition\': \'new\'}, ... {\'title\': \'Book E\', \'author\': \'Author E\', \'pages\': 220, \'condition\': \'poor\'} ... ] >>> filter_books(books, 100, \'new\') [ {\'title\': \'Book A\', \'author\': \'Author A\', \'pages\': 100, \'condition\': \'new\'} ] >>> filter_books(books, 200, \'poor\') [ {\'title\': \'Book E\', \'author\': \'Author E\', \'pages\': 220, \'condition\': \'poor\'} ] >>> filter_books(books, 120, \'good\') [ {\'title\': \'Book B\', \'author\': \'Author B\', \'pages\': 150, \'condition\': \'good\'} ] >>> filter_books(books, 90, \'fair\') [ {\'title\': \'Book C\', \'author\': \'Author C\', \'pages\': 120, \'condition\': \'fair\'} ] >>> filter_books(books, 250, \'fair\') [] ``` Ensure that the function handles the provided examples correctly and meets the specifications outlined above.","solution":"def filter_books(books, min_pages, condition): Filters the list of books based on the minimum number of pages and condition. Parameters: books (list): A list of dictionaries where each dictionary represents a book. min_pages (int): Minimum number of pages the book must have. condition (str): The condition the book must meet. Returns: list: A list of dictionaries representing books that meet the criteria. return [book for book in books if book[\'pages\'] >= min_pages and book[\'condition\'] == condition]"},{"question":"# Problem Statement: Write a Python function that takes as input a list of strings representing filenames and returns a dictionary where the keys are the filenames and the values are the number of lines in each corresponding file. Your function should handle cases where a file may not exist or is unreadable due to permissions, returning a message indicating the error. Additionally, handle files that may be empty. # Function Signature: ```python def count_lines_in_files(filenames: list) -> dict: Counts the number of lines in each file provided in the filenames list. Parameters: filenames (list): A list of strings, where each string is a filename. Returns: dict: A dictionary with filenames as keys and the number of lines as values. If a file cannot be read, the value should be an error message string. ``` # Input: - `filenames`: A list of strings where each string represents a filename to be processed. # Output: - A dictionary where keys are filenames and values are either an integer representing the number of lines in the file or an error message string. # Example Invocation: ```python # Count lines in the provided list of files result = count_lines_in_files([\'file1.txt\', \'file2.txt\', \'file3.txt\']) ``` # Constraints: 1. **File Handling**: The function should appropriately handle non-existent files and files that cannot be read due to permissions issues. 2. **Edge Cases**: Consider and handle edge cases where files may be empty. 3. **Performance**: Ensure the function efficiently handles the reading of potentially large files without unnecessary delays. # Example Output: For the input `[\'file1.txt\', \'file2.txt\', \'file3.txt\']`, assume: - `file1.txt` has 10 lines, - `file2.txt` does not exist, - `file3.txt` is unreadable due to permissions, The output could be: ```python { \'file1.txt\': 10, \'file2.txt\': \'Error: File does not exist\', \'file3.txt\': \'Error: Permission denied\' } ``` # Notes: - The error message strings should be human-readable and standardized as shown in the example output. - Ensure the function is well-commented and documents the steps involved in handling different edge cases.","solution":"def count_lines_in_files(filenames): Counts the number of lines in each file provided in the filenames list. Parameters: filenames (list): A list of strings, where each string is a filename. Returns: dict: A dictionary with filenames as keys and the number of lines as values. If a file cannot be read, the value should be an error message string. result = {} for filename in filenames: try: with open(filename, \'r\') as file: count = sum(1 for line in file) result[filename] = count except FileNotFoundError: result[filename] = \'Error: File does not exist\' except PermissionError: result[filename] = \'Error: Permission denied\' except Exception as e: result[filename] = f\'Error: {str(e)}\' return result"},{"question":"# Problem: Character Frequency Encoder You are designing a character frequency encoder that transforms messages into a frequency-based code. Each character in the message is replaced by its frequency within the message, sorted alphabetically by the character. The encoding should be case-insensitive. Implement the following function to encode a given message: Function: `encode_message(message: str) -> str` Encodes the given message based on character frequencies. **Parameters**: * `message`: A string message to be encoded. **Returns**: * A string representing the encoded message, which consists of space-separated pairs of characters and their frequencies. Constraints: * The `message` string can contain letters (both uppercase and lowercase), numbers, spaces, and punctuation. # Example: ```python message = \\"Hello World!\\" encoded_message = encode_message(message) print(encoded_message) # Expected Output: \\"d1 e1 h1 l3 o2 r1 w1\\" ``` Consider edge cases, such as: * Empty message * Message with only non-alphabet characters * Mixed-case messages # Performance Requirements: * Implement the function to run in O(n log n) time due to sorting, where n is the length of the message.","solution":"def encode_message(message: str) -> str: Encodes the given message based on character frequencies. Parameters: message (str): A string message to be encoded. Returns: str: A string representing the encoded message, which consists of space-separated pairs of characters and their frequencies. from collections import Counter # Make the message lower case for case insensitivity message = message.lower() # Count the frequencies of each character in the message frequencies = Counter(message) # Filter out non-alphabetic characters and sort by character sorted_frequencies = sorted((char, freq) for char, freq in frequencies.items() if char.isalpha()) # Format the frequency counts into the desired output format encoded_message = \\" \\".join(f\\"{char}{freq}\\" for char, freq in sorted_frequencies) return encoded_message"},{"question":"Palindrome Permutation Checker # Objective Implement a function to check if any permutation of a given string can form a palindrome. Your solution should demonstrate your understanding of string manipulation and hash map usage. # Function Signature ```python def can_permute_palindrome(s: str) -> bool: ``` # Input 1. `s` (str): The input string consisting of lowercase alphabets only. # Output * bool: Return `True` if any permutation of the input string can form a palindrome, otherwise return `False`. # Constraints * The input string length is `1 <= len(s) <= 10^5`. # Example ```python >>> can_permute_palindrome(\'civic\') True >>> can_permute_palindrome(\'ivicc\') True >>> can_permute_palindrome(\'hello\') False >>> can_permute_palindrome(\'a\') True ``` # Notes 1. A string can form a palindrome if at most one character occurs an odd number of times. 2. Make sure to handle strings of varying lengths efficiently. # Hints 1. Use a hash map or dictionary to count the occurrences of each character. 2. Check the counts to determine if a palindrome permutation is possible by ensuring no more than one character has an odd count.","solution":"def can_permute_palindrome(s: str) -> bool: Checks if any permutation of the input string can form a palindrome. from collections import Counter char_count = Counter(s) odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1"},{"question":"# Coding Assessment Question Scenario You have joined a tech startup as a software developer. Your current project involves analyzing networks of computers. One of the tasks is to determine the shortest path between two computers in a network, where the network is represented as a graph with nodes (computers) and edges (direct connections). Task Write a function `shortest_path(connections: List[Tuple[int, int]], start: int, end: int) -> int` that computes the minimum number of edges in the shortest path from the start node to the end node in an undirected graph. If no path exists, return -1. Function Signature ```python def shortest_path(connections: List[Tuple[int, int]], start: int, end: int) -> int: ``` Input - `connections` (List[Tuple[int, int]]): A list of tuples representing the edges of the graph. - `start` (int): The starting node. - `end` (int): The destination node. Output - Returns the minimum number of edges in the shortest path between the start and end nodes as an integer. - If no path exists, returns -1. Constraints - All nodes are represented by non-negative integers. - There will be no self-loops or multiple edges between two nodes. - The graph represented by the connections will be undirected. Example ```python >>> shortest_path([(0, 1), (1, 2), (2, 3)], 0, 3) 3 >>> shortest_path([(0, 1), (1, 2), (0, 2), (2, 3)], 0, 3) 2 >>> shortest_path([(0, 1), (2, 3)], 0, 3) -1 ``` Notes - Use a breadth-first search (BFS) algorithm to find the shortest path in an unweighted graph. - Ensure inputs are validated and handle edge cases such as no connections or nodes not being part of the graph.","solution":"from typing import List, Tuple from collections import deque, defaultdict def shortest_path(connections: List[Tuple[int, int]], start: int, end: int) -> int: if start == end: return 0 # Create the graph as an adjacency list graph = defaultdict(list) for (u, v) in connections: graph[u].append(v) graph[v].append(u) # Initialize the BFS queue = deque([(start, 0)]) # (current_node, current_distance) visited = set() visited.add(start) # Perform BFS while queue: current_node, current_distance = queue.popleft() for neighbor in graph[current_node]: if neighbor == end: return current_distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + 1)) # If we have exhausted the search and didn\'t find the end node return -1"},{"question":"# Problem Statement You are required to implement a function that performs Matrix Multiplication using the naive O(n) algorithm. The function will take two 2D matrices as input and return their product as a 2D matrix. # Function Signature ```python def matrix_multiplication(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: pass ``` # Expected Input and Output Formats - **Input**: - `matrix_a`: A 2D list of integers representing the first matrix with dimensions `m x n`. - `matrix_b`: A 2D list of integers representing the second matrix with dimensions `n x p`. - **Output**: - A 2D list of integers representing the product matrix with dimensions `m x p`. # Constraints and Limitations 1. Assume all integer values in the matrices are within the range of -100 to 100. 2. Dimensions of both matrices will not exceed 100 x 100. 3. The matrices are well-formed (all rows are of equal length). # Example ```python matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [5, 6], [7, 8] ] # Expected output: # [ # [19, 22], # [43, 50] # ] assert matrix_multiplication(matrix_a, matrix_b) == [ [19, 22], [43, 50] ], \\"Test case failed\\" ``` - In this example, the first matrix `[[1, 2], [3, 4]]` is multiplied by the second matrix `[[5, 6], [7, 8]]` to produce the result matrix `[[19, 22], [43, 50]]`. # Performance Requirements - The solution should efficiently handle the matrix dimensions provided within the limit. - Edge cases, such as mismatched dimensions where multiplication is not possible, should be handled with an appropriate error message or exception. # Scenario Consider an application in computer graphics where transformation matrices need to be applied to coordinate points to manipulate images. Your implementation of the matrix multiplication function will facilitate these transformations to produce the desired graphical effects.","solution":"from typing import List def matrix_multiplication(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Performs matrix multiplication on two 2D matrices. Args: matrix_a (List[List[int]]): The first matrix with dimensions m x n. matrix_b (List[List[int]]): The second matrix with dimensions n x p. Returns: List[List[int]]: The resulting matrix with dimensions m x p. # Get the dimensions of the matrices m = len(matrix_a) n = len(matrix_a[0]) p = len(matrix_b[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for __ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Coding Challenge: Palindrome Check Using Recursion Create a function that checks if a string is a palindrome by using recursion. This exercise will test your understanding of string manipulation, recursion fundamentals, and algorithm design. Problem Description Implement a function named `is_palindrome` that takes a single string as input and returns a boolean indicating whether the string is a palindrome. Function Signature: ```python def is_palindrome(s: str) -> bool: ``` Input: * `s`: A single string. The string can contain letters and be of any length, including an empty string. Output: * Returns `True` if the string is a palindrome, otherwise returns `False`. Example: ```python assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"level\\") == True assert is_palindrome(\\"hello\\") == False assert is_palindrome(\\"\\") == True assert is_palindrome(\\"Able was I ere I saw Elba\\") == False ``` Constraints: * The solution must use a recursive approach to determine if the string is a palindrome. * Ignore character case during comparison. * Avoid using loops (for/while) in the solution. * Execution time should be compatible with typical recursive function performance on reasonably sized strings. Additional Considerations: Handle empty strings and strings with one character correctly, and ensure that the function is case-insensitive (e.g., \\"A\\" and \\"a\\" should be considered the same). *Note: For this challenge, assume the input string does not contain any spaces or punctuation marks, allowing you to focus on the recursiveness and character comparison.*","solution":"def is_palindrome(s: str) -> bool: s = s.lower() # make the string case-insensitive length = len(s) # Base cases: if string is empty or has 1 character, it\'s a palindrome if length <= 1: return True # Check the first and last characters if s[0] != s[-1]: return False # Remove the first and last characters and call recursively return is_palindrome(s[1:-1])"},{"question":"# Task Scheduling with Dependencies You\'re in charge of scheduling multiple tasks in a project, where some tasks depend on the completion of others. Given a list of tasks and their dependencies, determine the minimum number of days required to complete all tasks if each task takes exactly one day to finish. Function Signature ```python def min_days_to_complete_tasks(n: int, dependencies: list) -> int: Args: - n (int): The number of tasks numbered from 0 to n-1. - dependencies (list): A list of tuples (a, b) where task `a` must be completed before task `b`. Returns: - int: The minimum number of days required to complete all tasks. ``` Input * `n` : An integer representing the number of tasks (0  n  1000). * `dependencies` : A list of tuples, where each tuple `(a, b)` indicates that task `a` must be completed before task `b`. Output * An integer representing the minimum number of days required to complete all tasks. Constraints * 0  len(dependencies)  3000 * There are no circular dependencies. Example ```python >>> min_days_to_complete_tasks(4, [(0, 1), (1, 2), (2, 3)]) 4 >>> min_days_to_complete_tasks(3, [(0, 1), (1, 2), (0, 2)]) 3 >>> min_days_to_complete_tasks(5, [(0, 1), (1, 2), (3, 4)]) 3 >>> min_days_to_complete_tasks(6, []) 1 ``` # Expectations 1. **Correctness**: Your solution should correctly determine the minimum number of days required, considering all dependencies. 2. **Efficiency**: The solution should handle the upper limits of inputs efficiently without significant performance degradation. 3. **Edge Cases**: Ensure to handle edge cases such as no dependencies, tasks with shared dependencies, and multiple independent task chains. Implement your function `min_days_to_complete_tasks` based on the above specifications. You can test your solution with the provided examples.","solution":"def min_days_to_complete_tasks(n, dependencies): Returns the minimum number of days required to complete all tasks given the dependencies. Args: - n (int): The number of tasks numbered from 0 to n-1. - dependencies (list): A list of tuples (a, b) where task `a` must be completed before task `b`. Returns: - int: The minimum number of days required to complete all tasks. from collections import defaultdict, deque # Create an adjacency list for the graph adj_list = defaultdict(list) in_degree = [0] * n # Fill adjacency list and in_degree array for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Queue initialization for nodes with no incoming edges (in_degree 0) queue = deque() for i in range(n): if in_degree[i] == 0: queue.append(i) # Track the number of days needed to complete each task days_needed = [0] * n while queue: current = queue.popleft() for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Update days needed for neighbor days_needed[neighbor] = max(days_needed[neighbor], days_needed[current] + 1) # The minimum number of days required is the maximum value in days_needed return max(days_needed) + 1 if dependencies else 1"},{"question":"# Question: Implement and Test Enhanced File Analysis Tool Context: You are tasked with improving an existing file analysis tool that reads files, processes their content to count word frequencies, and generates a summary report. The existing implementation lacks support for batch processing of multiple files and efficient handling of large data. Requirements: 1. **Batch Processing**: Extend the functionality to accept a list of file paths and process multiple files concurrently. 2. **Concurrency**: Use threading or asynchronous capabilities to handle multiple files efficiently. 3. **Improved Error Handling**: Enhance error handling to manage partial failures and provide a summary of failed and successful file analyses. Main Function Specification: ```python def analyze_files(file_paths: List[str]) -> Dict[str, Union[Dict[str, int], str]]: Given a list of file paths, return the word frequency analysis for each file. Parameters: file_paths (List[str]): List of file paths to analyze. Returns: Dict[str, Union[Dict[str, int], str]]: A dictionary mapping each file path to its word frequency analysis or an error message in case of a failure. pass ``` * **Input**: A list of file paths. * **Output**: A dictionary with file paths as keys and either their corresponding word frequency dictionary or an appropriate error message as values. Constraints: - The function should handle up to 10 files in one call efficiently. - Handle any file read or parsing errors gracefully and return corresponding error messages for failed file paths. - The word frequency analysis for each file should be performed concurrently to minimize total execution time. * **Example**: ```python file_paths = [\\"file1.txt\\", \\"file2.txt\\"] # Assume file1.txt contains \\"hello world hello\\" # and file2.txt contains \\"hello universe\\" expected_output = { \\"file1.txt\\": {\\"hello\\": 2, \\"world\\": 1}, \\"file2.txt\\": {\\"hello\\": 1, \\"universe\\": 1} } assert analyze_files(file_paths) == expected_output ``` Performance Requirements: - Ensure the function can process the maximum number of files within a reasonable time limit (e.g., < 10 seconds). Note: Provide a well-documented and tested solution showcasing your understanding of concurrency, error handling, and file processing in Python.","solution":"import os from typing import List, Dict, Union from concurrent.futures import ThreadPoolExecutor, as_completed def count_words(file_path: str) -> Union[Dict[str, int], str]: Reads a file and counts the frequency of each word. Parameters: file_path (str): Path to the file to be processed. Returns: Union[Dict[str, int], str]: A dictionary with word frequencies or an error message if file reading fails. try: with open(file_path, \'r\') as f: text = f.read() words = text.split() word_count = {} for word in words: word = word.lower() word_count[word] = word_count.get(word, 0) + 1 return word_count except Exception as e: return str(e) def analyze_files(file_paths: List[str]) -> Dict[str, Union[Dict[str, int], str]]: Given a list of file paths, return the word frequency analysis for each file. Parameters: file_paths (List[str]): List of file paths to analyze. Returns: Dict[str, Union[Dict[str, int], str]]: A dictionary mapping each file path to its word frequency analysis or an error message in case of a failure. results = {} with ThreadPoolExecutor(max_workers=10) as executor: future_to_file = {executor.submit(count_words, file_path): file_path for file_path in file_paths} for future in as_completed(future_to_file): file_path = future_to_file[future] try: result = future.result() results[file_path] = result except Exception as e: results[file_path] = str(e) return results"},{"question":"# Question Background Radix Sort is an efficient, non-comparative sorting algorithm that processes the individual digits of each number. It works by sorting the numbers on the least significant digit first and then moving to more significant digits. This method of sorting is particularly useful for sorting numbers with a fixed number of digits. Problem Implement a function `radix_sort` that sorts a list of non-negative integers using the Radix Sort algorithm. Function Signature ```python def radix_sort(arr: list) -> list: :param arr: List of non-negative integers to be sorted. :return: Sorted list of integers in ascending order. pass ``` Requirements - The function should handle lists of varying lengths and integer values. - Implement the sorting with consideration to the maximum number of digits across all numbers in the input list. - Optimize the sorting process to handle typical edge cases efficiently, such as lists with duplicate values or already sorted lists. Example ```python # Example input list input_list = [170, 45, 75, 90, 802, 24, 2, 66] # Calling the radix_sort function with provided list sorted_list = radix_sort(input_list) # The expected output should be # [2, 24, 45, 66, 75, 90, 170, 802] ``` In this example, the `radix_sort` function should correctly sort the list of integers `[170, 45, 75, 90, 802, 24, 2, 66]` into ascending order.","solution":"def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(len(arr)): arr[i] = output[i] def radix_sort(arr): if not arr: return [] max_val = max(arr) exp = 1 while max_val // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Image Segmentation Coding Question Context Imagine you are working on an image processing project where you need to partition an image into multiple regions based on pixel intensity. To simplify, we will use a 2D list representing the pixel intensities of a grayscale image. Your task is to identify and label connected components using the 4-connectivity rule (left, right, up, and down). Your Task Write a function that takes a 2D list of integers representing pixel intensities and returns a 2D list of the same dimensions where each connected component (group of connected pixels with the same intensity) is labeled with a unique integer. Function Signature ```python def label_connected_components(image: List[List[int]]) -> List[List[int]]: # your code here ``` Input - `image` (List[List[int]]): A 2D list of integers where each element represents the pixel intensity of the image. Output - Returns a 2D list of the same size as the input where each element represents the label of the connected component. Constraints - 1  number of rows in `image`  100 - 1  number of columns in `image`  100 - Pixel intensity values (integers) are between 0 and 255. Example ```python image = [ [1, 2, 2, 2, 3], [1, 1, 1, 2, 3], [4, 4, 1, 2, 3], [5, 4, 4, 4, 3] ] output = [ [1, 2, 2, 2, 3], [1, 1, 1, 2, 3], [4, 4, 1, 2, 3], [5, 4, 4, 4, 3] ] >>> label_connected_components([ [1, 2, 2, 2, 3], [1, 1, 1, 2, 3], [4, 4, 1, 2, 3], [5, 4, 4, 4, 3] ]) [ [1, 2, 2, 2, 3], [1, 1, 1, 2, 3], [4, 4, 1, 2, 3], [5, 4, 4, 4, 3] ] ``` Edge Cases to Consider - An image with all pixels having the same intensity. - An image where every pixel has a unique intensity. - Small images, e.g., `1x1`, `2x2`. The goal is to create an algorithm that carefully traverses the image while correctly labeling each distinct region keeping similar complexity and coverage in line with the provided samples.","solution":"from typing import List def label_connected_components(image: List[List[int]]) -> List[List[int]]: def dfs(x, y, label): stack = [(x, y)] while stack: cx, cy = stack.pop() if (0 <= cx < rows and 0 <= cy < cols and visited[cx][cy] == 0 and image[cx][cy] == initial_intensity): visited[cx][cy] = label stack.extend([(cx - 1, cy), (cx + 1, cy), (cx, cy - 1), (cx, cy + 1)]) rows, cols = len(image), len(image[0]) visited = [[0] * cols for _ in range(rows)] label_counter = 1 for i in range(rows): for j in range(cols): if visited[i][j] == 0: initial_intensity = image[i][j] dfs(i, j, label_counter) label_counter += 1 return visited"},{"question":"# Context You are responsible for managing a social network platform where users can follow each other and post content. To encourage engagement, the platform provides a feature to recommend new users to follow based on mutual connections and interests. # Objective Develop a recommendation engine that suggests a list of potential users for a given user to follow. Your implementation should consider mutual connections and shared interests to compute recommendations. # Function Definitions 1. `add_user(user_id: int, interests: list[str])`: - Adds a new user with a unique identifier and a list of interests. 2. `follow(follower_id: int, followee_id: int)`: - Establishes a follow relationship between two users. 3. `recommend(user_id: int) -> list[int]`: - Recommends a list of user IDs for the given user to follow, based on mutual connections and common interests. 4. `reset()`: - Resets the social network to its initial state. # Input and Output Formats - **add_user(user_id: int, interests: list[str])** * `user_id`: Integer, unique identifier for the user. * `interests`: List of strings, representing user interest areas. - **follow(follower_id: int, followee_id: int)** * `follower_id`: Integer, ID of the user who will follow. * `followee_id`: Integer, ID of the user to be followed. - **recommend(user_id: int) -> list[int]** * `user_id`: Integer, the ID of the user for whom recommendations are to be generated. * Returns: List of integers, recommended user IDs to follow. - **reset()** * No return value. Resets internal state. # Constraints - User IDs are unique positive integers. - Each interest is a non-empty string. - A user cannot follow themselves. - Any user can follow any other user, but redundant follow actions should be ignored. # Example Usage ```python # Adding users add_user(1, [\\"music\\", \\"sports\\"]) add_user(2, [\\"music\\", \\"art\\"]) add_user(3, [\\"sports\\", \\"travel\\"]) # Creating follow relationships follow(1, 2) follow(2, 3) follow(1, 3) # Getting recommendations for user 1 print(recommend(1)) # Example output: [2, 3] # Reset network reset() ``` # Task Implement the functions `add_user`, `follow`, `recommend`, and `reset` following the detailed guidelines and constraints.","solution":"class SocialNetwork: def __init__(self): self.users = {} self.followers = {} self.following = {} def add_user(self, user_id: int, interests: list[str]): if user_id not in self.users: self.users[user_id] = set(interests) self.followers[user_id] = set() self.following[user_id] = set() def follow(self, follower_id: int, followee_id: int): if follower_id != followee_id: if followee_id in self.users and follower_id in self.users: self.following[follower_id].add(followee_id) self.followers[followee_id].add(follower_id) def recommend(self, user_id: int) -> list[int]: if user_id not in self.users: return [] recommendations = {} user_interests = self.users[user_id] for followee in self.following[user_id]: for potential_follow in self.following[followee]: if potential_follow != user_id and potential_follow not in self.following[user_id]: shared_interests = len(self.users[potential_follow].intersection(user_interests)) recommendations[potential_follow] = recommendations.get(potential_follow, 0) + 1 + shared_interests sorted_recommendations = sorted(recommendations, key=lambda x: (-recommendations[x], x)) return sorted_recommendations def reset(self): self.__init__() # Instance of the SocialNetwork class social_network = SocialNetwork() def add_user(user_id: int, interests: list[str]): social_network.add_user(user_id, interests) def follow(follower_id: int, followee_id: int): social_network.follow(follower_id, followee_id) def recommend(user_id: int) -> list[int]: return social_network.recommend(user_id) def reset(): social_network.reset()"},{"question":"# Coding Challenge: Extend a Simple Text Editor Context You have been provided with a simple text editor implemented as a class `SimpleTextEditor`, which supports basic operations like inserting characters and deleting the last character. Now, there are some advanced functionalities required to enhance the editor\'s usability. Task You need to extend the `SimpleTextEditor` class with two additional functions: 1. **Undo**: This operation undoes the last operation performed on the text editor (either insertion or deletion). 2. **Redo**: This operation redoes the last undone operation (only if an undo was performed before). Specifications **Operation 1: Undo** - **Function Signature**: `def undo(self):` - **Output**: It does not return anything but undoes the last performed operation on the text editor. **Operation 2: Redo** - **Function Signature**: `def redo(self):` - **Output**: It does not return anything but redoes the last undone operation on the text editor if applicable. Additional Requirements - Ensure that the editor maintains the correct state even after performing multiple undo and redo operations. - Implement appropriate checks to handle cases where undo or redo operations are not applicable. - Keep track of the operations history to facilitate undo and redo functionalities. # Example Usage ```python # Initialize a simple text editor editor = SimpleTextEditor() # Insert characters editor.insert(\'h\') editor.insert(\'e\') editor.insert(\'l\') editor.insert(\'l\') editor.insert(\'o\') # Current text: \\"hello\\" print(editor.get_text()) # Should print \\"hello\\" # Delete last character editor.delete_last() # Current text: \\"hell\\" print(editor.get_text()) # Should print \\"hell\\" # Perform undo operation editor.undo() # Current text: \\"hello\\" print(editor.get_text()) # Should print \\"hello\\" # Perform redo operation editor.redo() # Current text: \\"hell\\" print(editor.get_text()) # Should print \\"hell\\" ``` # Constraints - The text editor should handle a maximum of 5000 operations. - Inputs for insert operations are single lowercase English letters. - Ensure that the operations are performed efficiently and in a manner that maintains the text editor\'s correctness. **Nota Bene**: Modify the `SimpleTextEditor` class as necessary to implement the new functionalities.","solution":"class SimpleTextEditor: def __init__(self): self.text = [] self.operation_history = [] self.undo_stack = [] def insert(self, char): self.text.append(char) self.operation_history.append((\\"insert\\", char)) self.undo_stack.clear() def delete_last(self): if self.text: char = self.text.pop() self.operation_history.append((\\"delete\\", char)) self.undo_stack.clear() def get_text(self): return \'\'.join(self.text) def undo(self): if not self.operation_history: return last_op, char = self.operation_history.pop() if last_op == \\"insert\\": self.text.pop() self.undo_stack.append((last_op, char)) elif last_op == \\"delete\\": self.text.append(char) self.undo_stack.append((last_op, char)) def redo(self): if not self.undo_stack: return last_op, char = self.undo_stack.pop() if last_op == \\"insert\\": self.text.append(char) self.operation_history.append((last_op, char)) elif last_op == \\"delete\\": self.text.pop() self.operation_history.append((last_op, char))"},{"question":"# Problem Statement Context Sorting is a fundamental concept in computer science, and there are many algorithms to sort data efficiently. Merge Sort is a popular sorting algorithm that uses the divide-and-conquer approach to sort elements. It divides the list into halves, recursively sorts them, and then merges the sorted halves to produce a final sorted list. Task Implement the Merge Sort algorithm in Python to sort a list of integers in non-decreasing order. Specifications 1. Your function should be named `merge_sort` and accept a single parameter which is a list of integers. 2. The function should return a new sorted list of integers. Example Given the list: ```python [38, 27, 43, 3, 9, 82, 10] ``` Your function should return: ``` [3, 9, 10, 27, 38, 43, 82] ``` Constraints - You may not use any built-in sort functions. - The list can contain up to 10,000 integers. - Each integer in the list can be in the range `-100,000` to `100,000`. Notes - Ensure that your implementation uses the merge sort algorithm as described. - The functionality of the merge sort algorithm includes splitting the list, recursively sorting the sublists, and then merging the sorted sublists.","solution":"def merge_sort(arr): Sorts a list of integers using the Merge Sort algorithm. if len(arr) <= 1: return arr def merge(left, right): sorted_array = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_array.append(left[left_index]) left_index += 1 else: sorted_array.append(right[right_index]) right_index += 1 # Append the remaining elements from left or right sorted_array.extend(left[left_index:]) sorted_array.extend(right[right_index:]) return sorted_array mid_point = len(arr) // 2 left_half = merge_sort(arr[:mid_point]) right_half = merge_sort(arr[mid_point:]) return merge(left_half, right_half)"},{"question":"# Coding Assessment Question Scenario You are maintaining an account management system that tracks user login attempts. The system collects data on login attempts and provides information on successful logins. Unfortunately, you no longer have the direct data on failed logins, but you can infer it from the provided information. Objective Write a function `count_failed_logins` that calculates the number of failed login attempts given the total login attempts and the successful login attempts. Function Signature ```python def count_failed_logins(total_attempts: int, successful_attempts: int) -> int: Given the total number of login attempts and the number of successful logins, calculate and return the number of failed login attempts. Parameters: total_attempts (int): The total number of login attempts. successful_attempts (int): The number of successful login attempts. Returns: int: The number of failed login attempts. ``` Input 1. `total_attempts` (int): The total number of login attempts (1  total_attempts  10^6). 2. `successful_attempts` (int): The number of successful login attempts (0  successful_attempts  total_attempts). Output * An integer representing the number of failed login attempts. Constraints * The number of failed login attempts should be 0 or more. Example ```python count_failed_logins(100, 80) # Output: 20 count_failed_logins(50, 50) # Output: 0 count_failed_logins(30, 5) # Output: 25 ``` Requirements * Ensure the function accurately calculates the number of failed attempts. * Consider edge cases such as when all login attempts are successful or when there are no successful login attempts.","solution":"def count_failed_logins(total_attempts: int, successful_attempts: int) -> int: Given the total number of login attempts and the number of successful logins, calculate and return the number of failed login attempts. Parameters: total_attempts (int): The total number of login attempts. successful_attempts (int): The number of successful login attempts. Returns: int: The number of failed login attempts. return total_attempts - successful_attempts"},{"question":"# Sum of Unique Elements Objective You are required to write a Python function that calculates the sum of all unique elements in a list of integers. The implementation should efficiently handle lists with a large number of elements. Problem Statement Given a list of integers `nums`, implement a function `sum_of_unique(nums: List[int]) -> int` that returns the sum of all integers that appear exactly once in the list. You should also write a test suite to verify your implementation handles various cases correctly. Input and Output Format * **Input**: A list of integers `nums` where (0 <= len(nums) <= 10^6) and each integer `nums[i]` is within the range (-10^9 <= nums[i] <= 10^9). * **Output**: An integer representing the sum of all unique elements in the list. Constraints * The list can be empty or contain up to 1,000,000 elements. * Ensure your solution handles large lists efficiently. Performance Requirements * Time Complexity: O(n), where n is the length of the list. * Space Complexity: O(n), for additional data structures to keep track of frequencies. Example 1 * **Input**: `nums = [1, 2, 3, 2, 1]` * **Output**: `3` Example 2 * **Input**: `nums = [4, 5, 6, 7, 8, 4, 5]` * **Output**: `21` Example 3 * **Input**: `nums = []` * **Output**: `0` Tasks 1. Implement the function `sum_of_unique(nums: List[int]) -> int`. 2. Write a suite of test cases to ensure your implementation is correct, considering edge cases like empty lists, lists with all elements the same, and very large lists. Notes * Use appropriate data structures to track the frequency of each element in the list. * Ensure your function is well-tested for edge cases and performance limits.","solution":"from typing import List def sum_of_unique(nums: List[int]) -> int: This function returns the sum of all unique integers in the list `nums`. An integer is considered unique if it appears exactly once in the list. frequency = {} # First pass: count the frequency of each number for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Second pass: sum up only the unique numbers unique_sum = 0 for num, count in frequency.items(): if count == 1: unique_sum += num return unique_sum"},{"question":"# Stack Implementation You are required to implement a stack data structure using two queues. Your stack implementation should support the following operations: - `push(element)`: Adds an element to the top of the stack. - `pop()`: Removes and returns the top element of the stack. - `top()`: Returns the top element without removing it. - `is_empty()`: Returns `True` if the stack is empty, else `False`. # Function Signatures ```python class MyStack: def __init__(self): pass def push(self, element: int) -> None: pass def pop(self) -> int: pass def top(self) -> int: pass def is_empty(self) -> bool: pass ``` # Example ```python stack = MyStack() stack.push(1) stack.push(2) stack.push(3) print(stack.top()) # Outputs: 3 print(stack.pop()) # Outputs: 3 print(stack.pop()) # Outputs: 2 print(stack.is_empty()) # Outputs: False print(stack.pop()) # Outputs: 1 print(stack.is_empty()) # Outputs: True ``` # Constraints & Edge Cases * The stack should handle at least 10^4 operations efficiently. * Consider edge cases such as popping or getting the top element from an empty stack. * Assure that queue operations (enqueuing and dequeuing) are used effectively to maintain the stack behavior. # Performance * Your solution should aim for O(1) amortized time complexity for each operation, but achieving up to O(n) for individual operations is acceptable. * Space complexity should remain within acceptable limits ensuring the solution is practical for up to 10^4 elements. Write your implementation of the `MyStack` class: ```python class MyStack: def __init__(self): self.queue1 = collections.deque() self.queue2 = collections.deque() def push(self, element: int) -> None: # Always enqueue in queue1 self.queue1.append(element) def pop(self) -> int: # Ensure all elements except one are transferred to queue2 while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) # The last element of queue1 is to be popped top_element = self.queue1.popleft() # Swap the queues self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def top(self) -> int: # Ensure all elements except one are transferred to queue2 while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) # Peek the last element of queue1 top_element = self.queue1.popleft() # Place it back into queue1 (since top operation should not remove it) self.queue2.append(top_element) # Swap the queues self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def is_empty(self) -> bool: return not self.queue1 ```","solution":"import collections class MyStack: def __init__(self): self.queue1 = collections.deque() self.queue2 = collections.deque() def push(self, element: int) -> None: self.queue1.append(element) def pop(self) -> int: while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) top_element = self.queue1.popleft() self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def top(self) -> int: while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) top_element = self.queue1.popleft() self.queue2.append(top_element) self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def is_empty(self) -> bool: return len(self.queue1) == 0"},{"question":"# Validate Bracket Sequences Scenario: You are helping to build a syntax checker for a new programming language. One of the basic requirements is to ensure that the sequences of parentheses, brackets, and curly braces in the code are balanced and properly nested. Task: Implement a Python function `validate_brackets(sequence: str) -> bool` that checks if the given sequence of brackets is valid. A valid sequence means that each open bracket has a corresponding closing bracket and the brackets are properly nested. Function Requirements: * **Input**: * `sequence` (str): A string containing a sequence of brackets (`\'(){}[]\'`). * **Output**: * Returns `True` if the sequence is valid, otherwise returns `False`. * **Constraints**: * The input string will only contain the characters `\'(){}[]\'`. * **Performance Requirements**: * The function should run in linear time, O(n). Example Usage: ```python assert validate_brackets(\\"()\\") == True assert validate_brackets(\\"()[]{}\\") == True assert validate_brackets(\\"(]\\") == False assert validate_brackets(\\"([)]\\") == False assert validate_brackets(\\"{[]}\\") == True ``` Additional Scenarios & Edge Cases to Consider: * Empty sequence: ```python assert validate_brackets(\\"\\") == True ``` * Single type but nested brackets: ```python assert validate_brackets(\\"[[[]]]\\") == True assert validate_brackets(\\"[][][]\\") == True ``` * Mixed multiple types: ```python assert validate_brackets(\\"{[()]}\\") == True assert validate_brackets(\\"{[({})]}\\") == True assert validate_brackets(\\"{[(])}\\") == False ``` Implement the function `validate_brackets` to fulfill these requirements.","solution":"def validate_brackets(sequence: str) -> bool: Returns True if the sequence of brackets is valid, otherwise False. bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} open_brackets = set(bracket_map.values()) stack = [] for char in sequence: if char in open_brackets: stack.append(char) elif char in bracket_map: if not stack or stack[-1] != bracket_map[char]: return False stack.pop() return len(stack) == 0"},{"question":"# File Path Normalization Develop a function that takes a string representing a file path in a Unix-like file system and normalizes the path. The normalization process involves resolving references such as `.` (current directory) and `..` (parent directory), removing any redundant slashes, and ensuring that the resulting path is an absolute path. # Input: - A single string representing the file path. The path may include the following components: - `.` for the current directory. - `..` for the parent directory. - Multiple slashes (`//`) which should be treated as a single slash. - The path may be relative or absolute. # Output: - A single string representing the normalized absolute path. # Constraints: - The input path string will consist of printable ASCII characters. - The maximum length of the input string is 500. # Example: ```python def normalize_path(path): pass print(normalize_path(\\"/home//foo/\\")) # Output: \\"/home/foo\\" print(normalize_path(\\"/a/./b/../../c/\\")) # Output: \\"/c\\" print(normalize_path(\\"/../\\")) # Output: \\"/\\" print(normalize_path(\\"/home/user/../user2/\\")) # Output: \\"/home/user2\\" print(normalize_path(\\"/../../\\")) # Output: \\"/\\" print(normalize_path(\\"a/b/c/../../d/\\")) # Output: \\"/a/d\\" ``` # Requirements: 1. Implement the `normalize_path` function to transform the given file path into its normalized absolute path format. 2. Ensure that the function handles edge cases properly, such as handling extra slashes and resolving `.` and `..` correctly. 3. The result should always be an absolute path (starting with a slash `/`).","solution":"def normalize_path(path): Normalizes the given Unix-like file path by resolving \'.\', \'..\', and redundant slashes. Parameters: path (str): The input file path. Returns: str: The normalized absolute path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if len(stack) > 0: stack.pop() else: stack.append(part) normalized_path = \'/\' + \'/\'.join(stack) return normalized_path"},{"question":"# Inventory Management System You are tasked with developing a basic inventory management system for a small store that sells various products. Each product has a unique identifier, a name, a price, and a quantity in stock. The system should be able to add new products, update the stock of existing products, and calculate the total value of the inventory. # Task Write a class `Inventory` that manages the store\'s products. The class should have methods to add a new product, update product stock, and calculate the total value of the inventory. # Details * Each product is represented as a dictionary with the following keys: - `id`: Unique string identifier for the product. - `name`: String name of the product. - `price`: Float representing the price of the product per unit. - `quantity`: Integer representing the number of units in stock. * The `Inventory` class should support: - `add_product(product)`: Adds a new product to the inventory. If a product with the same `id` already exists, it should raise a `ValueError`. - `update_stock(product_id, quantity)`: Updates the stock of the given product by adding the passed quantity. If the product does not exist, it should raise a `ValueError`. - `total_inventory_value()`: Returns the total value of the inventory, calculated as the sum of the product of the price and quantity of all products. # Example ```python inventory = Inventory() inventory.add_product({\'id\': \'P001\', \'name\': \'Widget\', \'price\': 10.0, \'quantity\': 5}) inventory.add_product({\'id\': \'P002\', \'name\': \'Gadget\', \'price\': 15.0, \'quantity\': 3}) inventory.update_stock(\'P001\', 10) # Calculating total value # Total value = (10.0 * 15) + (15.0 * 3) = 150.0 + 45.0 = 195.0 print(inventory.total_inventory_value()) # Output: 195.0 ``` **Function signatures:** ```python class Inventory: def __init__(self): pass def add_product(self, product: dict) -> None: pass def update_stock(self, product_id: str, quantity: int) -> None: pass def total_inventory_value(self) -> float: pass ```","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product: dict) -> None: product_id = product[\'id\'] if product_id in self.products: raise ValueError(\\"Product with this ID already exists.\\") self.products[product_id] = product def update_stock(self, product_id: str, quantity: int) -> None: if product_id not in self.products: raise ValueError(\\"Product not found.\\") self.products[product_id][\'quantity\'] += quantity def total_inventory_value(self) -> float: total_value = 0.0 for product in self.products.values(): total_value += product[\'price\'] * product[\'quantity\'] return total_value"},{"question":"# Problem Statement: Given a binary tree, write a function to print its boundary nodes in an anti-clockwise direction starting from the root. The boundary includes the left boundary, leaves, and the right boundary in that order. The left boundary is defined as the path from the root to the left-most node. The right boundary is defined as the path from the root to the right-most node. The leaf nodes are mentioned bottom-up, from left to right. Function Signature: ```python def print_boundary(root: TreeNode) -> List[int]: pass ``` Expected Input: * `root`: A `TreeNode` representing the root of the binary tree. Expected Output: * A list of integers representing the boundary nodes in anti-clockwise direction. Constraints: * The number of nodes in the binary tree is between 1 and 1000. * Node values are unique integers. Examples: ```python # Example 1: # Input: # 1 # / # 2 3 # / / # 4 5 6 7 # # Output: [1, 2, 4, 5, 6, 7, 3] # # Example 2: # Input: # 20 # / # 8 # / # 4 12 # / # 10 14 # # Output: [20, 8, 4, 10, 14, 12] ``` # Additional Information: 1. The `TreeNode` class is pre-defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` 2. Ensure to handle each part of the boundary - the left boundary, the leaves, and the right boundary separately and combine their results in the specified order. 3. The root should only be included once (as part of the left boundary). Solution Approach: * Perform a pre-order traversal for the left boundary nodes excluding leaf nodes. * Perform a post-order traversal for the leaf nodes. * Perform a reverse post-order traversal for the right boundary nodes excluding leaf nodes. * Combine the results considering the provided order of boundaries.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def print_boundary(root: TreeNode) -> list: def is_leaf(node): return node.left is None and node.right is None def add_left_boundary(node, boundary): while node: if not is_leaf(node): boundary.append(node.val) if node.left: node = node.left else: node = node.right def add_right_boundary(node, boundary): stack = [] while node: if not is_leaf(node): stack.append(node.val) if node.right: node = node.right else: node = node.left while stack: boundary.append(stack.pop()) def add_leaves(node, boundary): if node is None: return if is_leaf(node): boundary.append(node.val) add_leaves(node.left, boundary) add_leaves(node.right, boundary) if not root: return [] boundary_nodes = [] # Adding root node if not is_leaf(root): boundary_nodes.append(root.val) # Adding left boundary add_left_boundary(root.left, boundary_nodes) # Adding leaf nodes add_leaves(root, boundary_nodes) # Adding right boundary add_right_boundary(root.right, boundary_nodes) return boundary_nodes"},{"question":"# Problem Statement Implementation of a function to perform matrix multiplication on two given matrices. The function should comfortably handle various sizes of matrices while ensuring valid constraints of matrix multiplication are maintained. # Requirements Implement the following function: 1. **matrix_multiplication(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]**: - Function to multiply two matrices. - Input: Two 2D lists `matrix_a` and `matrix_b` representing the input matrices. - Output: A 2D list representing the resulting matrix after multiplication of `matrix_a` with `matrix_b`. # Constraints - The number of columns in `matrix_a` must be equal to the number of rows in `matrix_b`. - Matrices may contain decimals. - Matrices must not be empty and will always be properly rectangular (i.e., inner lists are of equal length). # Performance Requirements - The expected time complexity is O(n^3) where n is the dimension of the square matrices. - The expected space complexity is O(n^2). # Example ```python def test_matrix_multiplication(): assert matrix_multiplication([ [1.0, 4.0], [2.0, 5.0], [3.0, 6.0] ], [ [7.0, 8.0, 9.0], [10.0, 11.0, 12.0] ]) == [ [47.0, 52.0, 57.0], [64.0, 71.0, 78.0], [81.0, 90.0, 99.0] ] assert matrix_multiplication([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0] ], [ [7.0, 8.0], [9.0, 10.0], [11.0, 12.0] ]) == [ [58.0, 64.0], [139.0, 154.0] ] assert matrix_multiplication([ [1.0] ], [ [2.0] ]) == [ [2.0] ] test_matrix_multiplication() ``` # Notes * Ensure the function handles invalid inputs gracefully (e.g., dimension mismatches) by raising an appropriate exception. * Precision is essential; ensure proper handling of floating-point arithmetic to avoid rounding errors.","solution":"from typing import List def matrix_multiplication(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: Multiplies two matrices and returns the result as a new matrix. # Check if the matrices are valid for multiplication if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Number of columns in matrix_a must be equal to number of rows in matrix_b\\") # Initialize result matrix with zeros result = [[0.0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Perform matrix multiplication for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Array Length Matcher You are tasked with writing a function to determine if two arrays can be made equal by adding zero or more elements to one or both arrays, so they eventually contain the same elements, regardless of order and frequency. The function should return a boolean value indicating if this is possible. # Function Signature: ```python def can_match_arrays(arr1: list[int], arr2: list[int]) -> bool: pass ``` # Input * `arr1` (list): A list of integers. * `arr2` (list): Another list of integers. # Output * A boolean value indicating whether the two arrays can be made equal. # Constraints * All elements in the input lists are integers in the range `-10^3` to `10^3`. * The length of each list is between `1` and `10^6`. # Example ```python # Example 1 print(can_match_arrays([1, 2, 3], [3, 1, 2])) # Output: True (both arrays already have the same elements) # Example 2 print(can_match_arrays([1, 2, 2, 3], [1, 3, 2, 2])) # Output: True (both arrays already have the same elements in the same frequency) # Example 3 print(can_match_arrays([1, 2, 3], [1, 2])) # Output: False (they can never be made equal) # Example 4 print(can_match_arrays([1], [1, 1])) # Output: False (they can never be made equal) ``` # Scenario: You\'re developing a data synchronization module that checks if two sets of data from different sources can be considered equivalent by possibly adding more data entries. This function helps ensure that the final datasets align. Your solution should handle large inputs efficiently and should properly validate that the given inputs are lists of integers within the constraints mentioned.","solution":"from collections import Counter def can_match_arrays(arr1: list[int], arr2: list[int]) -> bool: Determines if two arrays can be made equal by adding zero or more elements to one or both arrays, so they eventually contain the same elements, regardless of order and frequency. counter1 = Counter(arr1) counter2 = Counter(arr2) return counter1 == counter2"},{"question":"# Problem Description You are tasked with implementing a function that converts a positive integer from decimal to its corresponding Roman numeral representation. Roman numerals are commonly used in various historical documents and clocks, and your function should accurately perform this conversion. # Function Signature ```python def int_to_roman(num: int) -> str: ``` # Input An integer `num` that represents the number to be converted. The value should be in the range from 1 to 3999 (inclusive). # Output A string representing the Roman numeral equivalent of the given integer. # Constraints 1. `num` is an integer. 2. 1 <= `num` <= 3999 # Example ```python >>> int_to_roman(3) \'III\' >>> int_to_roman(58) \'LVIII\' >>> int_to_roman(1994) \'MCMXCIV\' ``` # Detailed Steps 1. **Validation**: Ensure the provided integer is within the valid range. 2. Use a list of numerals sorted in descending order along with their corresponding values. 3. Iteratively subtract the highest possible numeral value from `num`, appending the corresponding numeral to the result. 4. Repeat the process until `num` is reduced to zero. # Roman Numerals ``` Symbol Value I 1 IV 4 V 5 IX 9 X 10 XL 40 L 50 XC 90 C 100 CD 400 D 500 CM 900 M 1000 ``` # Edge Cases - Validate and handle the minimum and maximum values. - Accurately handle numbers that require subtraction rules (like 4, 9, 40, 90, etc.). Use this design to ensure your implementation is clear, meets the problem requirements, and effectively converts decimal numbers to Roman numerals.","solution":"def int_to_roman(num: int) -> str: Converts an integer within the range 1 to 3999 to its corresponding Roman numeral. # Define the Roman numeral mappings in descending order val_to_roman = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] roman_numeral = \\"\\" for value, symbol in val_to_roman: # Keep adding the symbol for as long as we can subtract the value from num while num >= value: roman_numeral += symbol num -= value return roman_numeral"},{"question":"# Task Allocation in Parallel Processing You are given an incomplete implementation of a function that distributes tasks evenly across multiple processors in a parallel processing system. Your task is to complete this function. Function Signature ```python def distribute_tasks(tasks: List[int], num_processors: int) -> List[List[int]]: ``` Parameters * **tasks** (List[int]): A list of task durations in seconds. * **num_processors** (int): The number of processors available. Returns * **List[List[int]]**: A list of lists, where each inner list contains task durations allocated to a processor. Constraints 1. The number of tasks will be at least 1 and at most 100. 2. The duration of each task will be between 1 and 1000 seconds. 3. The number of processors will be at least 1 and at most 10. 4. The function should raise a `ValueError` with an appropriate message if `num_processors` is less than or equal to 0. Examples ```python >>> distribute_tasks([100, 200, 300, 400, 500], 2) [[100, 300, 500], [200, 400]] >>> distribute_tasks([50, 75, 200, 150, 300, 100], 3) [[50, 150], [75, 300], [200, 100]] >>> distribute_tasks([10, 20, 30, 40, 50], 5) [[10], [20], [30], [40], [50]] ``` Additional Notes * The tasks should be distributed in a round-robin manner starting from the first task for the first processor, the second task for the second processor, and so on. * Ensure that the function raises an appropriate exception with the message: - `\\"Number of processors must be greater than 0\\"` for a non-positive number of processors. Implement the `distribute_tasks` function according to the provided specifications.","solution":"def distribute_tasks(tasks, num_processors): Distributes tasks evenly across the given number of processors in a round-robin manner. Parameters: tasks (List[int]): A list of task durations in seconds. num_processors (int): The number of processors available. Returns: List[List[int]]: A list of lists, where each inner list contains task durations allocated to a processor. if num_processors <= 0: raise ValueError(\\"Number of processors must be greater than 0\\") # Initialize the result with empty lists for each processor result = [[] for _ in range(num_processors)] # Distribute the tasks in a round-robin manner for i, task in enumerate(tasks): result[i % num_processors].append(task) return result"},{"question":"**Binary Tree Operations** You are required to implement a set of binary tree operations, including adding a node, finding a node, in-order traversal, pre-order traversal, post-order traversal, and calculating the height of the tree. You should adhere to the following function signatures and specifications: ```python class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None def add_node(root: TreeNode, value: int) -> TreeNode: Adds a node with the given value to the binary search tree. :param root: The root of the binary search tree. :param value: The value to be added. :return: The root of the modified binary search tree. def find_node(root: TreeNode, value: int) -> bool: Finds if a node with the given value exists in the binary search tree. :param root: The root of the binary search tree. :param value: The value to be found. :return: True if the value exists, False otherwise. def in_order_traversal(root: TreeNode) -> List[int]: Performs an in-order traversal of the binary search tree. :param root: The root of the binary search tree. :return: A list of elements in in-order. def pre_order_traversal(root: TreeNode) -> List[int]: Performs a pre-order traversal of the binary search tree. :param root: The root of the binary search tree. :return: A list of elements in pre-order. def post_order_traversal(root: TreeNode) -> List[int]: Performs a post-order traversal of the binary search tree. :param root: The root of the binary search tree. :return: A list of elements in post-order. def calculate_height(root: TreeNode) -> int: Calculates the height of the binary tree. :param root: The root of the binary tree. :return: The height of the tree. ``` # Constraints: 1. Assume all input values for the nodes are integers. 2. The operations should efficiently handle binary trees with up to 10^5 nodes. 3. The tree will always be well-formed (no cycles or malformed structures). # Testing: You should ensure your implementations pass the following test cases: - Adding Nodes: Test adding nodes to an initially empty tree and a non-empty tree. - Finding Nodes: Test finding existing and non-existing values in various tree configurations. - Traversals: Test all three types of traversals (in-order, pre-order, post-order) in different tree structures (balanced, unbalanced, etc.). - Calculating Height: Test calculation of tree height in balanced, unbalanced, and single-node trees.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None def add_node(root: TreeNode, value: int) -> TreeNode: if not root: return TreeNode(value) if value < root.value: root.left = add_node(root.left, value) else: root.right = add_node(root.right, value) return root def find_node(root: TreeNode, value: int) -> bool: if not root: return False if root.value == value: return True if value < root.value: return find_node(root.left, value) else: return find_node(root.right, value) def in_order_traversal(root: TreeNode) -> list: result = [] if root: result = in_order_traversal(root.left) result.append(root.value) result += in_order_traversal(root.right) return result def pre_order_traversal(root: TreeNode) -> list: result = [] if root: result.append(root.value) result += pre_order_traversal(root.left) result += pre_order_traversal(root.right) return result def post_order_traversal(root: TreeNode) -> list: result = [] if root: result = post_order_traversal(root.left) result += post_order_traversal(root.right) result.append(root.value) return result def calculate_height(root: TreeNode) -> int: if not root: return 0 return 1 + max(calculate_height(root.left), calculate_height(root.right))"},{"question":"# Coding Assessment Question **Problem Statement:** You are given a string containing a sequence of lowercase letters and spaces. Your task is to find the length of the longest substring without repeating characters. Spaces should be treated as valid characters and should be included in the substring length. Write a function `length_of_longest_substring` that takes a single string as input and returns the length of the longest substring without repeating characters. **Function Signature:** ```python def length_of_longest_substring(s: str) -> int: pass ``` **Input:** - `s`: A string (1 <= len(s) <= 1000) containing lowercase letters and spaces. **Output:** - Returns an integer representing the length of the longest substring without repeating characters. **Examples:** ```python s = \\"abcdefg\\" print(length_of_longest_substring(s)) # Output: 7 s = \\"abc abcbb\\" print(length_of_longest_substring(s)) # Output: 4 (\\"abc \\") s = \\"bbbbb\\" print(length_of_longest_substring(s)) # Output: 1 s = \\"pwwkew\\" print(length_of_longest_substring(s)) # Output: 3 (\\"wke\\") s = \\"dvdf\\" print(length_of_longest_substring(s)) # Output: 3 (\\"vdf\\") ``` **Constraints:** - The function should efficiently handle the input string up to a length of 1000. - Consider the possibility of spaces occurring in the string and treat them as legitimate non-repeating characters within a substring.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. if not s: return 0 char_map = {} start, max_length = 0, 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Coding Question: Vehicle Monitoring System **Context**: You are tasked with developing a monitoring system for a fleet of electric vehicles (EVs). Given the vehicle\'s battery capacity, power consumption rate, and average speed, you need to compute three critical performance indicators: 1. The maximum distance the vehicle can travel on a full charge. 2. The total time the vehicle can operate on a full charge. 3. The required charging time to fully charge the battery from an empty state. To determine these values, you will utilize fundamental arithmetic calculations. **Task**: Implement three functions: 1. `max_distance(battery_capacity: float, power_consumption: float) -> float` 2. `total_operation_time(battery_capacity: float, power_consumption: float) -> float` 3. `charging_time(battery_capacity: float, charge_power: float) -> float` These functions should validate the inputs and compute the required performance indicators based on the provided formulas and constraints. **Constraints**: - Battery capacity (`battery_capacity`) must be a positive number, representing kWh. - Power consumption (`power_consumption`) must be a positive number, representing kW. - Charging power (`charge_power`) must be a positive number, representing kW. - All outputs should be rounded to two decimal places. **Formulas**: - Maximum distance: [ text{distance} = frac{{text{battery capacity}} times text{average speed}}{text{power consumption}} ] - Total operation time: [ text{operation time} = frac{{text{battery capacity}}}{text{power consumption}} ] - Charging time: [ text{charging time} = frac{{text{battery capacity}}}{text{charge power}} ] Here, the battery capacity is given in kWh, power consumption in kW, and charge power in kW. **Input/Output**: - **Input**: Float numbers representing battery capacity, power consumption, and average speed or charge power. - **Output**: Three float numbers representing maximum distance, total operation time, and charging time respectively. **Examples**: ```python assert max_distance(75, 15) == 5.00 # Assuming average speed is 75 kph assert total_operation_time(75, 15) == 5.00 assert charging_time(75, 10) == 7.50 assert max_distance(100, 20) == 5.00 # Assuming average speed is 100 kph assert total_operation_time(100, 20) == 5.00 assert charging_time(100, 25) == 4.00 ``` Write the functions based on the provided formulas and constraints, ensuring to handle invalid inputs appropriately.","solution":"def max_distance(battery_capacity: float, power_consumption: float, average_speed: float) -> float: Calculates the maximum distance the vehicle can travel on a full charge. Parameters: battery_capacity (float): The battery capacity in kWh. power_consumption (float): The power consumption rate in kW. average_speed (float): The average speed in kph. Returns: float: The maximum distance in kilometers, rounded to two decimal places. if battery_capacity <= 0 or power_consumption <= 0 or average_speed <= 0: raise ValueError(\\"All parameters must be positive values.\\") distance = (battery_capacity * average_speed) / power_consumption return round(distance, 2) def total_operation_time(battery_capacity: float, power_consumption: float) -> float: Calculates the total time the vehicle can operate on a full charge. Parameters: battery_capacity (float): The battery capacity in kWh. power_consumption (float): The power consumption rate in kW. Returns: float: The total operation time in hours, rounded to two decimal places. if battery_capacity <= 0 or power_consumption <= 0: raise ValueError(\\"Both parameters must be positive values.\\") operation_time = battery_capacity / power_consumption return round(operation_time, 2) def charging_time(battery_capacity: float, charge_power: float) -> float: Calculates the required charging time to fully charge the battery from an empty state. Parameters: battery_capacity (float): The battery capacity in kWh. charge_power (float): The charge power in kW. Returns: float: The charging time in hours, rounded to two decimal places. if battery_capacity <= 0 or charge_power <= 0: raise ValueError(\\"Both parameters must be positive values.\\") time_to_charge = battery_capacity / charge_power return round(time_to_charge, 2)"},{"question":"# Kth Smallest Element in a Sorted Matrix Assessment Question You are designing a feature for data analysis where you need to find specific ranked elements in processed datasets. One of the key functionalities you plan to implement is identifying the k-th smallest element in a sorted matrix. A matrix is considered sorted if each of its rows and columns is sorted in non-decreasing order. Task: Write a function `kth_smallest_element(matrix: List[List[int]], k: int) -> int` that takes two arguments as input: - `matrix` (List[List[int]]): A list of n x n integers where each row and each column is sorted in non-decreasing order. - `k` (int): The position (1-indexed) of the element to find in the entire sorted order of the matrix. The function should return an integer representing the k-th smallest element in the matrix. Input: - It is guaranteed that the input matrix will be a square matrix of size up to 100 x 100. - The value of `k` will always be valid such that `1 <= k <= n^2`. Output: - Return an integer representing the k-th smallest element in the matrix. Examples: ```python >>> kth_smallest_element([ [1, 5, 9], [10, 11, 13], [12, 13, 15] ], 8) 13 >>> kth_smallest_element([ [1, 2], [1, 3] ], 2) 1 >>> kth_smallest_element([ [1, 2], [3, 4] ], 3) 3 ``` Constraints: - The function should efficiently handle matrices of size up to 100 x 100. - The function should use algorithms that optimally find the k-th smallest element, taking advantage of the sorted property of the matrix.","solution":"import heapq from typing import List def kth_smallest_element(matrix: List[List[int]], k: int) -> int: Finds the k-th smallest element in a sorted n x n matrix. Args: matrix: List of List of integers where each row and column is sorted in non-decreasing order. k: An integer representing the position of the element to find in the sorted order of the matrix. Returns: An integer representing the k-th smallest element in the matrix. n = len(matrix) min_heap = [] # Push the first element of each row onto the heap. for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Remove the smallest element from the heap k times. for _ in range(k): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return element"},{"question":"Problem Statement Write a function `max_subarray_sum` that, given an integer array `nums`, finds the maximum sum of a contiguous subarray. This problem needs to be solved using Kadanes Algorithm, which should have a linear runtime complexity. # Function Signature ```python def max_subarray_sum(nums: List[int]) -> int: pass ``` # Input * `nums` (List[int]): A list of integers. * 1 <= len(nums) <= 10^5 * -10^4 <= nums[i] <= 10^4 # Output * The function should return a single integer, representing the maximum sum of a contiguous subarray in the input array `nums`. # Example Input ```python nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] ``` Output ```python 6 ``` # Scenario Alex is working on analyzing the stock prices using historical data. He wants to find the period where the stock prices have the maximum increase. Given a list of daily changes in stock price, Alex needs a program to determine the maximum profit he could have made by buying stock on one day and selling it on another day without multiple buys or sells in between. # Constraints * The function should be optimized for large input sizes to avoid performance issues. * Consider edge cases such as all negative numbers or arrays containing a single element. # Example Test Cases ```python assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum([1]) == 1 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 assert max_subarray_sum([-4, -3, -2, -1]) == -1 ```","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Finds the maximum sum of a contiguous subarray using Kadane\'s Algorithm. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Task: Validate and Process Student Grades Problem Statement You are provided with a function that processes a list of student grades and returns the highest, lowest, and average grades. The current function does basic processing but lacks proper validation, efficient calculation, and edge case handling. Your task is to enhance this function to include additional validation checks, optimize its performance, and ensure it handles edge cases correctly. Function Signature ```python def process_grades(grades: list[float]) -> dict[str, float]: pass ``` Input - `grades` (list[float]): A list of student grades, where each grade is a float between 0 and 100 inclusive. Output - A **dictionary** containing the keys: `highest`, `lowest`, and `average`, with corresponding float values representing the highest grade, the lowest grade, and the average grade respectively. Constraints 1. The `grades` list should not be empty. 2. Each grade in the list must be within the range of 0 to 100 inclusive. 3. If invalid inputs are provided, raise appropriate `ValueError`. Example ```python >>> process_grades([85, 92, 78, 94, 88]) {\'highest\': 94.0, \'lowest\': 78.0, \'average\': 87.4} >>> process_grades([50, 50, 50]) {\'highest\': 50.0, \'lowest\': 50.0, \'average\': 50.0} >>> process_grades([]) Traceback (most recent call last): ... ValueError: The grades list should not be empty >>> process_grades([85, -92, 78]) Traceback (most recent call last): ... ValueError: Invalid grade found: -92. Grade must be between 0 and 100 inclusive >>> process_grades([85, \'A\', 78]) Traceback (most recent call last): ... ValueError: All grades must be numbers ``` Requirements - Implement validations to check for empty lists and grades outside the valid range. - Ensure the function handles edge cases (such as lists with all the same values). - Optimize performance for calculating the required statistics while maintaining code clarity.","solution":"def process_grades(grades: list[float]) -> dict[str, float]: Processes a list of student grades and returns a dictionary with the highest, lowest, and average grades. Parameters: grades (list of float): A list of student grades, where each grade is a float between 0 and 100 inclusive. Returns: dict: A dictionary with keys \'highest\', \'lowest\', and \'average\' with corresponding float values. Raises: ValueError: If the grades list is empty or contains invalid grades. if not grades: raise ValueError(\\"The grades list should not be empty\\") for grade in grades: if not isinstance(grade, (float, int)): raise ValueError(\\"All grades must be numbers\\") if grade < 0 or grade > 100: raise ValueError(f\\"Invalid grade found: {grade}. Grade must be between 0 and 100 inclusive\\") highest = max(grades) lowest = min(grades) average = sum(grades) / len(grades) return {\'highest\': highest, \'lowest\': lowest, \'average\': average}"},{"question":"# Problem Statement You are required to complete a Python class representing a circular queue. A circular queue, unlike a linear queue, wraps around upon reaching the end of the capacity, forming a circle-like structure which allows elements to be enqueued at one end and dequeued from the other. Your task is to implement the following methods in the `CircularQueue` class: 1. **Enqueue**: Adds an element to the back of the queue. 2. **Dequeue**: Removes and returns the element from the front of the queue. 3. **Front**: Returns (without removing) the front element of the queue. 4. **Is_Empty**: Checks if the queue is empty. 5. **Is_Full**: Checks if the queue is full. # Expected Input and Output 1. **Enqueue**: - **Input**: An element to add to the queue. - **Output**: None (modifies the queue in place) - **Example**: ```python q = CircularQueue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) q.enqueue(4) # Output: OverflowError (\\"Queue is full\\") ``` 2. **Dequeue**: - **Input**: None (called on an instance) - **Output**: The element at the front of the queue. - **Example**: ```python q = CircularQueue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) x = q.dequeue() # Output: 1 ``` 3. **Front**: - **Input**: None (called on an instance) - **Output**: The element at the front of the queue. - **Example**: ```python q = CircularQueue(3) q.enqueue(1) q.enqueue(2) q.front() # Output: 1 ``` 4. **Is_Empty**: - **Input**: None (called on an instance) - **Output**: Boolean indicating if the queue is empty. - **Example**: ```python q = CircularQueue(3) q.is_empty() # Output: True ``` 5. **Is_Full**: - **Input**: None (called on an instance) - **Output**: Boolean indicating if the queue is full. - **Example**: ```python q = CircularQueue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) q.is_full() # Output: True ``` # Constraints * The class should internally manage the circular structure without using any additional data structures. * Capacity of the queue will be provided during initialization and will not change. * The elements in the queue can be of any data type, but it\'s assumed they all are handled consistently. Implement the required methods to support the above operations, ensuring efficient management of the circular queue\'s capacity and elements.","solution":"class CircularQueue: def __init__(self, k): self.k = k self.queue = [None] * k self.head = -1 self.tail = -1 def enqueue(self, value): if self.is_full(): raise OverflowError(\\"Queue is full\\") if self.is_empty(): self.head = 0 self.tail = (self.tail + 1) % self.k self.queue[self.tail] = value def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") result = self.queue[self.head] if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.k return result def front(self): if self.is_empty(): return None return self.queue[self.head] def is_empty(self): return self.head == -1 def is_full(self): return (self.tail + 1) % self.k == self.head"},{"question":"# Scenario You are working as a junior developer at a tech company that specializes in voice processing software. Your task is to develop a function that will smooth out abrupt changes in volume in a recorded audio signal. Abrupt volume spikes can often be the result of noise or sudden loud sounds that need to be attenuated for a smoother listening experience. # Task Write a Python function `smooth_audio_signal` to smooth out the abrupt volume changes in an audio signal. The function should take a list of integers representing the audio signal and return a new list where each element is the average of itself and its two neighbors (previous and next). For the first element, only the first two elements should be averaged and for the last element, only the last two elements should be averaged. # Input - `audio_signal` (List[int]): A list of integers where each integer represents the volume of an audio signal at a given moment in time. # Output - Return a list of integers representing the smoothed audio signal. # Constraints 1. The length of the `audio_signal` must be at least 3. # Examples ```python >>> smooth_audio_signal([10, 20, 30, 40, 50]) [15, 20, 30, 40, 45] >>> smooth_audio_signal([5, 10, 15, 10, 5]) [7, 10, 11, 10, 7] >>> smooth_audio_signal([1, 2, 3, 4, 5]) [1, 2, 3, 4, 4] >>> smooth_audio_signal([100, 200, 300, 400, 500]) [150, 200, 300, 400, 450] >>> smooth_audio_signal([90, 100, 110]) [45, 100, 55] ```","solution":"def smooth_audio_signal(audio_signal): Smooths out abrupt volume changes in an audio signal. Parameters ---------- audio_signal: List[int] A list of integers where each integer represents the volume of an audio signal at a given moment in time. Returns ------- List[int] A new list where each element is the average of itself and its two neighbors (previous and next). n = len(audio_signal) smoothed_signal = [] # Handle first element smoothed_signal.append((audio_signal[0] + audio_signal[1]) // 2) # Handle elements from the second to the second to last for i in range(1, n-1): smoothed_value = (audio_signal[i-1] + audio_signal[i] + audio_signal[i+1]) // 3 smoothed_signal.append(smoothed_value) # Handle last element smoothed_signal.append((audio_signal[-2] + audio_signal[-1]) // 2) return smoothed_signal"},{"question":"Coding Assessment Question Context: As part of a robotics software team, you are in charge of implementing a pathfinding algorithm for a robot in a grid. The robot starts at the top left corner and aims to reach the bottom right corner. The grid cells can either be passable (represented by `0`) or impassable (represented by `1`). Your task is to find the shortest path, if one exists, from the starting position to the ending position. Task: 1. Implement the Breadth-First Search (BFS) algorithm to find the shortest path in a grid. 2. Include a function to accept the grid from users and showcase the shortest path or indicate if no path is possible. Requirements: 1. **Function `bfs_shortest_path(grid: List[List[int]]) -> int`** - Receive a 2D list representing the grid. - Return the length of the shortest path from the top left corner to the bottom right corner, or `-1` if no path exists. 2. **Function `main()`** - Accept the number of rows and columns for the grid. - Accept the grid\'s cell values from the user. - Use the `bfs_shortest_path` function to find and print the shortest path length or indicate if no path is found. Constraints: - The grid will have dimensions <= 20x20 to ensure the algorithm runs efficiently. - The grid will always have at least one cell `(1x1)`. Example: For an input grid: ``` [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] ``` - `bfs_shortest_path` should return `9`, as the shortest path length from the top-left to the bottom-right corner traversing around the obstacles. In the case where the grid is such that no path exists from the top-left to the bottom-right corner, the function should return `-1`. For instance: ``` [ [0, 1], [1, 0] ] ``` - `bfs_shortest_path` should return `-1`. Additional Input: If the grid size is: - `2` (rows) - `2` (columns) Input grid: ``` [ [0, 1], [1, 0] ] ``` Expected output: - `-1` (no path) Input grid: ``` [ [0, 0], [0, 0] ] ``` Expected output: - `3` (shortest path from top left to bottom right corner) Ensure to handle different edge cases like all `0`s or all `1`s in the grid efficiently.","solution":"from collections import deque from typing import List, Tuple def bfs_shortest_path(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we\'ve reached the bottom-right corner if r == rows - 1 and c == cols - 1: return dist # Check all possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) # If no path is found return -1 def main(): rows = int(input(\\"Enter the number of rows: \\")) cols = int(input(\\"Enter the number of columns: \\")) grid = [] for i in range(rows): row = list(map(int, input(f\\"Enter row {i+1}: \\").strip().split())) grid.append(row) result = bfs_shortest_path(grid) if result == -1: print(\\"No path found.\\") else: print(f\\"Shortest path length: {result}\\")"},{"question":"# Problem Statement You are asked to compute the maximum possible value of an expression formed by inserting parentheses to a given mathematical expression containing only integers and the addition (+) operator. # Function Signature ```python def max_expression_value(expression: str) -> int: # Your code implementation here ``` # Input 1. **expression** (str): A string representing a mathematical expression composed of integers and the \\"+\\" operator. * 1 <= len(expression) <= 50 * The expression contains only digits and the `+` symbol. # Output * **int**: The maximum value of the expression when parentheses are inserted optimally. # Constraints * The input string will not contain any invalid characters. * Leading zeros will not be present. * The expression is valid and contains at least one \\"+\\" operator. # Examples ```python assert max_expression_value(\\"1+2+3\\") == 6 assert max_expression_value(\\"1+9+1\\") == 11 assert max_expression_value(\\"10+20\\") == 30 ``` # Explanation * For the first example, the maximum possible value of `1+2+3` is 6. * For the second example, the maximum possible value of `1+9+1` is 11. * For the third example, the maximum possible value of `10+20` is 30. # Requirements 1. Implement the function to compute the maximum possible value when parentheses are optimally inserted. 2. Ensure your solution is efficient and handles edge cases properly.","solution":"def max_expression_value(expression: str) -> int: Given a mathematical expression containing only integers and the addition (+) operator, compute the maximum possible value of the expression by optimally inserting parentheses. # The task is quite simple, since the addition operator is associative. # We can safely assume that the maximum value of an expression with just \'+\' operators # will be achieved by simply evaluating the expression as it is. # Split the expression on \'+\' and convert to integers, then just sum them up. numbers = map(int, expression.split(\'+\')) return sum(numbers)"},{"question":"# Problem Statement You are given a string that contains alphanumeric characters and spaces. The goal is to reverse each word individually while keeping the words\' order intact. Whitespace should be maintained as they are between words, but no leading or trailing spaces exist in the input. Function Description Implement the function `reverse_words_in_string` which has the following signature: ```python def reverse_words_in_string(s: str) -> str: :param s: a string containing words separated by spaces :return: a string with each word reversed but the words\' order preserved ``` Input - `s`: A string with words separated by single spaces (`1 <= len(s) <= 10^5`, `s` contains only alphanumeric characters and spaces, no leading or trailing spaces, and no multiple spaces between words). Output - A string where each word is reversed but the order of the words is preserved. Constraints - The function should handle large strings efficiently. - Each word should be reversed individually, while the overall order of words remains unchanged. Example ```python print(reverse_words_in_string(\\"hello world\\")) # Expected Output: \\"olleh dlrow\\" print(reverse_words_in_string(\\"python is fun\\")) # Expected Output: \\"nohtyp si nuf\\" print(reverse_words_in_string(\\"a b c\\")) # Expected Output: \\"a b c\\" ``` # Notes - Ensure that you test your implementation with various scenarios, including those with maximum input sizes, and consider edge cases like single-word inputs or single-character words.","solution":"def reverse_words_in_string(s: str) -> str: Reverses each word in the string while keeping the word order intact. :param s: a string containing words separated by spaces :return: a string with each word reversed but the words\' order preserved return \' \'.join(word[::-1] for word in s.split())"},{"question":"# Problem Description You are given a function that removes all instances of a specified value from a linked list. Your task is to implement a modified version of this function to remove all nodes from the linked list whose values follow a given pattern. # Input and Output Format * **Input**: You will be given two arguments: * `head`: The head node of the linked list. * `pattern`: A function that takes an integer and returns a boolean. * **Output**: Return the head node of the updated linked list after all nodes satisfying the pattern have been removed. # Constraints * The number of nodes in the linked list is in the range `[0, 1000]`. * Node values and the pattern function do not have any constraints beyond those necessary for the comparison (e.g., the function might check for even numbers, multiples of a given number, etc.). # Implementation Requirements * Implement the function `remove_nodes_by_pattern(head: Node | None, pattern: Callable[[int], bool]) -> Node | None`. # Example ```python from typing import Callable, Union class Node: def __init__(self, value: int = 0) -> None: self.value = value self.next: Union[Node, None] = None def remove_nodes_by_pattern(head: Node | None, pattern: Callable[[int], bool]) -> Node | None: dummy = Node(0) dummy.next = head prev, current = dummy, head while current is not None: if pattern(current.value): prev.next = current.next else: prev = current current = current.next return dummy.next # Example to test the implementation def print_linked_list(head: Node | None) -> None: while head: print(head.value, end=\\" \\") head = head.next # Define the pattern function def is_even(value: int) -> bool: return value % 2 == 0 # Create a linked list: 1 -> 2 -> 3 -> 4 -> 5 head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) # Remove nodes whose values are even updated_head = remove_nodes_by_pattern(head, is_even) print_linked_list(updated_head) ``` # Explanation Given the linked list: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` And the pattern function that returns `True` for even values, the resulting linked list should be: ``` 1 -> 3 -> 5 ```","solution":"from typing import Callable, Union class Node: def __init__(self, value: int = 0) -> None: self.value = value self.next: Union[\'Node\', None] = None def remove_nodes_by_pattern(head: Node | None, pattern: Callable[[int], bool]) -> Node | None: dummy = Node(0) dummy.next = head prev, current = dummy, head while current is not None: if pattern(current.value): prev.next = current.next else: prev = current current = current.next return dummy.next"},{"question":"# Problem Statement You are working as a software engineer tasked with developing a component for generating and analyzing radio-frequency identification (RFID) tags. Each RFID tag consists of a sequence of digits, and one of the critical features of your software is to count how often specific patterns appear within these tags. # Task Write a function `pattern_count` that determines the number of times a given pattern of digits appears in a list of RFID tags. # Function Signature ```python def pattern_count(tags: List[str], pattern: str) -> int: ``` # Inputs - `tags` (List[str]): A list of strings, where each string represents an RFID tag consisting of digits. - `pattern` (str): A string representing the digit pattern to look for in the RFID tags. # Output - Returns an integer representing the number of times the digit pattern appears across all RFID tags. # Constraints - `1 <= len(tags) <= 1000` - `1 <= len(tags[i]) <= 100` - `1 <= len(pattern) <= 10` - Tags consist of digits (\'0\'-\'9\') and are non-empty. - The pattern is non-empty. # Example ```python tags = [\\"123456789\\", \\"987654321\\", \\"567891234\\", \\"234567890\\"] pattern = \\"567\\" assert pattern_count(tags, pattern) == 3 # The pattern \\"567\\" appears three times in the list of RFID tags. ``` # Explanation - **Pattern Matching**: Iterate through each RFID tag and search for the occurrences of the specified pattern. - **Accumulating Results**: Keep a cumulative count of all matches found across the entire list of tags. # Notes - Consider optimizing your search to handle large lists and longer tags efficiently. - Patterns might overlap within a tag, e.g., the pattern \\"121\\" appears twice in \\"121212\\".","solution":"def pattern_count(tags, pattern): Returns the number of times a given pattern appears in a list of RFID tags. Parameters: tags (List[str]): A list of RFID tags (strings). pattern (str): The digit pattern to search for within the tags. Returns: int: The total number of times the pattern appears in the list of tags. count = 0 pattern_length = len(pattern) for tag in tags: tag_length = len(tag) for i in range(tag_length - pattern_length + 1): if tag[i:i+pattern_length] == pattern: count += 1 return count"},{"question":"# Maximal Square Submatrix Challenge Objective Implement the following function to find the size of the largest square submatrix with all 1s in a given binary matrix: ```python from typing import List def maximal_square(matrix: List[List[int]]) -> int: Finds the size of the largest square submatrix with all 1s. Parameters: matrix (List[List[int]]): A binary matrix with 0s and 1s. Returns: int: The size of the largest square submatrix with all 1s. pass ``` Input Format * A binary matrix `matrix` represented as a list of lists of integers: `[[0, 1, 0], [1, 1, 1], ...]` Output Format * An integer representing the size of the largest square submatrix with all 1s. Constraints * Matrix should be a valid non-empty list of lists with integers 0 or 1. * Each inner list (row) must have the same length. * Return 0 if no such square submatrix exists. Example ```python matrix = [ [0, 1, 1, 0, 1], [1, 1, 0, 1, 0], [0, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0] ] print(maximal_square(matrix)) # Expected output: 2 ``` Notes * Consider edge cases such as matrices with all 0s or all 1s, and matrices with different row and column dimensions. * Use dynamic programming for an optimized solution with a time complexity of O(n * m), where n is the number of rows and m is the number of columns. * Ensure your implementation handles invalid input gracefully. * You may use helper functions or classes if necessary to structure your code.","solution":"from typing import List def maximal_square(matrix: List[List[int]]) -> int: if not matrix: return 0 rows = len(matrix) cols = len(matrix[0]) max_side = 0 # Create a DP table initialized to 0 dp = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # First row or first column only can form size 1 else: # Update DP table with minimum of the three adjoining squares + 1 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 # Keep track of the maximum side length max_side = max(max_side, dp[i][j]) # The area of the largest square is side length squared return max_side"},{"question":"# Implement a Stack Using Queues **Objective:** Create a class that uses two queues to implement the functionality of a stack. **Class Signature:** ```python class StackUsingQueues: def __init__(self): # Initialize your data structures here def push(self, x: int): # Push element x onto stack def pop(self) -> int: # Removes the element on top of the stack and returns that element def top(self) -> int: # Get the top element def empty(self) -> bool: # Returns whether the stack is empty ``` **Description:** You must implement a stack where insertion (push operation) and deletion (pop operation) are executed using two queues. The operations should adhere to the LIFO (Last In, First Out) principle. **Methods:** 1. `__init__` - Initializes the stack. 2. `push(self, x: int)` - Pushes element `x` onto the stack. 3. `pop(self) -> int` - Removes the element on the top of the stack and returns that element. 4. `top(self) -> int` - Retrieves the element on the top of the stack without removing it. 5. `empty(self) -> bool` - Returns whether the stack is empty. **Constraints:** - The methods `push`, `pop`, `top`, and `empty` must run in optimal average time complexity. - You may assume that all operations are valid (for example, `pop` or `top` operations are never called on an empty stack). **Scenario:** Consider you are designing a system that needs to track a history of actions and must be able to undo the most recent action efficiently. This stack implementation will allow you to add actions to history and undo them by using the `pop` method. **Example:** ```python # Initializing the stack stack = StackUsingQueues() # Example operations stack.push(10) stack.push(20) print(stack.top()) # Should return 20 print(stack.pop()) # Should remove and return 20 print(stack.empty()) # Should return False ``` The class `StackUsingQueues` should enable you to simulate stack operations effectively using two queues, ensuring LIFO behavior and efficient operation times.","solution":"from collections import deque class StackUsingQueues: def __init__(self): self.queue1 = deque() self.queue2 = deque() def push(self, x: int): self.queue2.append(x) while self.queue1: self.queue2.append(self.queue1.popleft()) self.queue1, self.queue2 = self.queue2, self.queue1 def pop(self) -> int: return self.queue1.popleft() def top(self) -> int: return self.queue1[0] def empty(self) -> bool: return not self.queue1"},{"question":"You are given a list of strings where each string consists of lowercase letters. Your task is to implement a function that groups the strings into clusters such that all strings in a cluster are anagrams of each other. # Task: Write a function `group_anagrams` that takes a list of strings and returns a list of lists, where each list contains strings that are anagrams of each other. # Specifications: * **Input**: A list of strings where each string has up to 100 lowercase letters. * **Output**: A list of lists, where each sublist contains strings that are anagrams of each other. # Requirements: * The function should handle inputs efficiently and group anagrams correctly. * Do not use memory-intensive methods for large lists. * The order of the strings within the groups does not matter, nor does the order of the groups themselves. # Example: ```python def group_anagrams(strings: list) -> list: pass # Example Usage: # group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) should return [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] ``` # Constraints: * Use of built-in data structures like dictionaries is permitted for efficient grouping. * Avoid redundant computations and ensure your function scales well with larger inputs.","solution":"def group_anagrams(strings): from collections import defaultdict anagrams = defaultdict(list) for s in strings: sorted_s = \'\'.join(sorted(s)) anagrams[sorted_s].append(s) return list(anagrams.values())"},{"question":"Problem Description You have been hired to design a water reservoir management system for a series of reservoirs situated along a river. The reservoirs allow water to flow from one to the next in sequence, and each reservoir can hold a certain maximum volume of water. Your task is to determine the maximum volume of water that can be stored across all reservoirs without overlapping their maximum capacities when given a certain volume of water to distribute. # Input - An integer `n` representing the number of reservoirs. - An integer `v` representing the total volume of water to distribute. - A list of integers of length `n` where each integer represents the maximum capacity of the corresponding reservoir. # Output - An integer representing the maximum volume of water that can be stored in the reservoirs without exceeding the given total volume and without exceeding each reservoir\'s individual capacity. # Function Signature ```python def max_water_distributed(n: int, v: int, capacities: list[int]) -> int: pass ``` # Constraints - `1 <= n <= 1000` - `0 <= v <= 10^6` - `1 <= capacities[i] <= 10^6` for all `0 <= i < n` # Example ```python n = 5 v = 20 capacities = [5, 10, 8, 7, 6] print(max_water_distributed(n, v, capacities)) # Output: 20 ``` # Notes - Distribute the water in such a way that the total amount of water does not exceed the sum of the maximum capacities of the reservoirs. - If the total water `v` is less than or equal to the sum of the maximum capacities, distribute all `v` amount. - If the total water `v` is more than the sum of the maximum capacities, distribute up to the sum of maximum capacities.","solution":"def max_water_distributed(n: int, v: int, capacities: list[int]) -> int: Determine the maximum volume of water that can be stored in the reservoirs without exceeding the given total volume `v` and without exceeding each reservoir\'s individual capacity. total_capacity = sum(capacities) return min(total_capacity, v)"},{"question":"# Problem Statement You are tasked with implementing a function that rotates a square 2D list (matrix) by 90 degrees clockwise. Given the constraints and requirements outlined below, write a function that adheres to the described behavior. # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a square 2D list (matrix) by 90 degrees clockwise and returns the result. :param matrix: A square 2D list of integers. :return: The 90-degree clockwise rotated matrix. Requirements: - If the matrix is empty, return an empty list. - The matrix must be square (same number of rows and columns). If the matrix is not square, raise a ValueError with the message \\"The matrix must be square\\". Examples: >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: The matrix must be square >>> rotate_matrix([]) [] pass ``` # Constraints - Your implementation should focus on correctness and handle the stated edge cases explicitly. - Use list comprehensions or built-in methods to simplify the implementation and optimize performance. - Ensure your function passes all the provided examples and additional edge cases you consider necessary. # Submission Please submit your function implementation along with a brief explanation of your approach and any additional test cases you added to ensure correctness.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a square 2D list (matrix) by 90 degrees clockwise and returns the result. :param matrix: A square 2D list of integers. :return: The 90-degree clockwise rotated matrix. Requirements: - If the matrix is empty, return an empty list. - The matrix must be square (same number of rows and columns). If the matrix is not square, raise a ValueError with the message \\"The matrix must be square\\". if not matrix: return [] n = len(matrix) for row in matrix: if len(row) != n: raise ValueError(\\"The matrix must be square\\") return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)]"},{"question":"# Binary Tree Paths Objective You are required to find all root-to-leaf paths in a binary tree. Each path should be represented as a string in the format \\"root->node1->node2->...->leaf\\". Requirements 1. **Function Signature**: `binary_tree_paths(root: Optional[TreeNode]) -> list[str]` 2. **Input**: * `root`: A reference to the root of the binary tree where TreeNode is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 3. **Output**: * A list of strings, where each string represents a root-to-leaf path in the format mentioned above. Constraints * Implement a recursive and/or iterative solution that efficiently traverses the binary tree to find all paths. * Handle edge cases such as an empty tree (where root is None) and a tree with only one node. * Ensure your solution has a time complexity of O(n), where n is the number of nodes in the tree. Performance Requirements * Given that n can be up to 10^4, make sure your solution is optimized for larger binary trees. Scenario Imagine you are developing a function to help with navigation in a mobile app. The binary tree represents various routes, and you need to list all possible paths from the starting point (root) to different destinations (leaves). Example ```python # Example usage: # Create a binary tree: # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) print(binary_tree_paths(root)) # Expected Output: [\'1->2->5\', \'1->3\'] # Another binary tree: # 1 # # 2 # # 5 root2 = TreeNode(1) root2.right = TreeNode(2) root2.right.right = TreeNode(5) print(binary_tree_paths(root2)) # Expected Output: [\'1->2->5\'] # Single node tree: root3 = TreeNode(1) print(binary_tree_paths(root3)) # Expected Output: [\'1\'] # Empty tree: print(binary_tree_paths(None)) # Expected Output: [] ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: def construct_paths(node: TreeNode, path: str): if node: path += str(node.val) if not node.left and not node.right: # if reach a leaf paths.append(path) # update paths else: path += \'->\' # extend the current path construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \'\') return paths"},{"question":"**Question: \\"Router Packet Simulation using Discrete Event Simulation\\"** **Context**: Network engineers often use discrete event simulations to understand packet flow in routers. Imagine a situation where you need to study packet flow within a router buffer over a given time. You have to simulate packet arrivals and processing to determine the number of packets in the buffer at any point in time. **Task**: Implement the function `router_packet_simulation` to estimate the packet count in a router buffer over a given period based on arrival and processing rates. # Function Signature: ```python def router_packet_simulation(arrival_rate: float, processing_rate: float, time_span: float, step_size: float) -> np.ndarray: ``` # Input: - `arrival_rate` (float): Average number of packets arriving per unit time (). - `processing_rate` (float): Average number of packets processed per unit time (). - `time_span` (float): The total duration for which the simulation runs. Must be positive. - `step_size` (float): The time increment for each step in the simulation. Must be positive. # Output: - Return a numpy array containing the estimated count of packets in the buffer at each timestep. # Constraints: - Assume Poisson process for packet arrivals. - Assume packets are processed immediately if the buffer is non-empty. - The buffer size can grow indefinitely (no overflow). # Example: ```python # Example input arrival_rate = 5.0 processing_rate = 3.0 time_span = 10.0 step_size = 1.0 # Call the function packet_counts = router_packet_simulation(arrival_rate, processing_rate, time_span, step_size) ``` In this example, given the `arrival_rate` of 5 packets per unit time and the `processing_rate` of 3 packets per unit time over a `time_span` of 10 minutes in steps of 1 minute, the array `packet_counts` should reflect the growth or decline of packets in the buffer over time. Note: Your solution should accurately model the random nature of packet arrivals and processing, implementing the discrete event simulation accurately to reflect typical network traffic scenarios.","solution":"import numpy as np def router_packet_simulation(arrival_rate: float, processing_rate: float, time_span: float, step_size: float) -> np.ndarray: Simulates the packet flow in a router buffer. :param arrival_rate: Average number of packets arriving per unit time :param processing_rate: Average number of packets processed per unit time :param time_span: Total duration for which the simulation runs :param step_size: The time increment for each step in the simulation :return: A numpy array containing the estimated count of packets in the buffer at each time step total_steps = int(time_span / step_size) packet_counts = np.zeros(total_steps + 1) current_buffer = 0 for step in range(1, total_steps + 1): # Calculate arrivals and departures arrivals = np.random.poisson(arrival_rate * step_size) departures = np.random.poisson(processing_rate * step_size) # Update the buffer size current_buffer += arrivals - departures if current_buffer < 0: current_buffer = 0 # Record the buffer size packet_counts[step] = current_buffer return packet_counts"},{"question":"# Problem Statement Context In software development, string manipulation is a common and essential task. Writing functions that can handle various string operations efficiently is crucial. Often, developers need to check if two strings are isomorphic. Two strings are considered isomorphic if the characters in one string can be replaced to get the second string. Task Your task is to implement a function `is_isomorphic(s1: str, s2: str) -> bool` in Python. The function should determine if the two given strings are isomorphic. For two strings to be isomorphic, all occurrences of a character in the first string can be replaced to get the second string, while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Specifications 1. The function should accept two strings as input arguments. 2. The function should return a boolean value: `True` if the strings are isomorphic, and `False` otherwise. Example If `s1` and `s2` are: ```python s1 = \\"egg\\" s2 = \\"add\\" ``` The function should return `True` because \'e\' can be replaced by \'a\', and \'g\' can be replaced by \'d\'. If `s1` and `s2` are: ```python s1 = \\"foo\\" s2 = \\"bar\\" ``` The function should return `False` because \'o\' cannot be replaced by two different characters. Constraints - The length of `s1` and `s2` will be in the range [1, 100,000]. - The strings will contain only lowercase English characters.","solution":"def is_isomorphic(s1: str, s2: str) -> bool: Determine if two strings are isomorphic. Two strings s1 and s2 are isomorphic if the characters in s1 can be replaced to get s2 while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Parameters: s1 (str): First string s2 (str): Second string Returns: bool: True if the strings are isomorphic, False otherwise if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 in mapping_s1_to_s2: if mapping_s1_to_s2[char1] != char2: return False else: mapping_s1_to_s2[char1] = char2 if char2 in mapping_s2_to_s1: if mapping_s2_to_s1[char2] != char1: return False else: mapping_s2_to_s1[char2] = char1 return True"},{"question":"# **Coding Question** **Question Title**: Implement In-Place Matrix Transposition with Diagonal Check **Description**: In this task, you are required to implement an in-place transposition of a square matrix, while ensuring that the diagonals remain unchanged. The transposition of a matrix involves swapping its rows and columns. However, since we want the diagonal elements to remain unchanged, you need to adjust the usual transposition process accordingly. **Function Signature**: ```python def transpose_in_place(matrix: list[list[int]]) -> None: ``` **Parameters**: - `matrix` (list[list[int]]): A 2D list of integers representing a square matrix (n x n). **Returns**: - `None`: The function modifies the input matrix in place and does not return anything. **Constraints**: - The matrix is always square (number of rows equals the number of columns). - Elements of the matrix can be any integer. **Examples**: ```python >>> m = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> transpose_in_place(m) >>> m [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] >>> m = [ ... [10, 15], ... [20, 25] ... ] >>> transpose_in_place(m) >>> m [ [10, 20], [15, 25] ] ``` **Notes**: 1. Ensure that the function modifies the matrix in place and efficiently handles the transposition. 2. Pay special attention to edge cases, such as single-element matrices. 3. Consider the time and space complexity of your solution and aim for an optimal approach.","solution":"def transpose_in_place(matrix: list[list[int]]) -> None: Transposes a square matrix in place while ensuring that the diagonal elements remain unchanged. Args: matrix (list[list[int]]): A 2D list representing a square matrix. Returns: None n = len(matrix) for i in range(n): for j in range(i + 1, n): # Swap elements matrix[i][j] and matrix[j][i] matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Minimum Spanning Tree with Prims Algorithm You are tasked with implementing Prim\'s algorithm to find the Minimum Spanning Tree (MST) of a given undirected, weighted graph. The MST is a subset of the edges that form a tree and include all the vertices, where the total weight of all the edges in the tree is minimized. # Specifications 1. **Function**: `prims_algorithm(graph: Dict[int, List[Tuple[int, float]]], start_vertex: int) -> Tuple[List[Tuple[int, int, float]], float]` * **Inputs**: * `graph`: A dictionary where the keys are vertices and the values are lists of tuples. Each tuple contains a neighboring vertex and the weight of the edge connecting them. * `start_vertex`: An integer representing the vertex from which to start building the MST. * **Output**: * A tuple containing a list of edges in the MST and the total weight of the MST. Each edge is represented as a tuple `(u, v, w)` where `u` and `v` are vertices connected by the edge with weight `w`. # Constraints * The number of vertices `V` can be up to `10^5`. * The number of edges `E` can be up to `10^6`. # Performance Requirements * Ensure the solution is efficient and runs within a reasonable time frame for large input sizes. * Handle edge cases such as graphs with disconnected components gracefully by building the MST for the connected component containing the start vertex. # Example ```python graph = { 0: [(1, 10), (2, 6), (3, 5)], 1: [(0, 10), (3, 15)], 2: [(0, 6), (3, 4)], 3: [(0, 5), (1, 15), (2, 4)] } start_vertex = 0 mst, total_weight = prims_algorithm(graph, start_vertex) print(mst) # Expected Output: [(0, 3, 5), (3, 2, 4), (0, 1, 10)] or some other valid MST print(total_weight) # Expected Output: 19.0 ``` **Note**: You may design and use additional helper functions or classes as required to complete the implementation.","solution":"import heapq def prims_algorithm(graph, start_vertex): Implements Prim\'s algorithm to find the Minimum Spanning Tree (MST) of a graph. :param graph: A dictionary representation of a weighted undirected graph. The keys are vertices and the values are lists of tuples (neighbor, weight). :param start_vertex: The vertex from which to start building the MST. :return: A tuple containing a list of edges in the MST and the total weight of the MST. mst = [] total_weight = 0.0 visited = set() min_heap = [(0, start_vertex, None)] # (weight, current_vertex, previous_vertex) while min_heap: weight, current_vertex, previous_vertex = heapq.heappop(min_heap) if current_vertex in visited: continue visited.add(current_vertex) if previous_vertex is not None: mst.append((previous_vertex, current_vertex, weight)) total_weight += weight for neighbor, edge_weight in graph[current_vertex]: if neighbor not in visited: heapq.heappush(min_heap, (edge_weight, neighbor, current_vertex)) return mst, total_weight"},{"question":"New Question # Function Signature ```python def detect_cycle(graph: dict) -> bool: pass ``` # Input * `graph` (dict): A dictionary representation of a directed graph where keys are node identifiers (integers or strings) and values are lists of nodes representing directed edges. # Output * Returns `True` if the graph contains a cycle, otherwise `False`. # Constraints * The keys and values within the dictionary are unique node identifiers. * The graph does not contain any parallel edges (i.e., no multiple edges between the same pair of nodes). # Requirements 1. Implement the DFS algorithm to traverse the graph. 2. Use an auxiliary data structure to keep track of visited nodes. 3. Use another data structure to keep track of the recursion stack (to track back edges). 4. Return `True` if a cycle is detected, otherwise `False`. # Example ```python # Example 1: graph = { \'A\': [\'B\'], \'B\': [\'C\', \'D\'], \'C\': [\'E\'], \'D\': [\'E\'], \'E\': [\'B\'] } detect_cycle(graph) # should return True since there is a cycle formed by the nodes B -> C -> E -> B # Example 2: graph = { 1: [2], 2: [3], 3: [] } detect_cycle(graph) # should return False since there are no cycles. ``` **Hint**: You might find it useful to use two sets: one to keep track of visited nodes, and another for nodes currently in the recursion stack (to catch back edges).","solution":"def detect_cycle(graph: dict) -> bool: def dfs(node, visited, rec_stack): if node not in visited: visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited and dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Question: Merge Sorted Arrays You are given two sorted arrays `nums1` and `nums2`, and you need to merge them into a single sorted array. The arrays may contain duplicates, but the result should not have any duplicates. # Input: - `nums1`: A list of integers, sorted in non-decreasing order. `1 <= len(nums1) <= 1000`. - `nums2`: A list of integers, sorted in non-decreasing order. `1 <= len(nums2) <= 1000`. # Output: - A list of integers representing the merged sorted array without duplicates. # Constraints: - Each list contains integers in the range from `-1000` to `1000`. # Examples: ```python merge_arrays([1, 2, 2, 3], [2, 3, 4]) # Expected output: [1, 2, 3, 4] merge_arrays([0, 2, 5], [1, 2, 3, 4]) # Expected output: [0, 1, 2, 3, 4, 5] merge_arrays([-5, -3, -1], [-6, -3, 2, 3]) # Expected output: [-6, -5, -3, -1, 2, 3] ``` # Requirements: 1. Your function should handle merging and removing duplicates efficiently. 2. Consider edge cases such as empty arrays and arrays with no overlap.","solution":"def merge_arrays(nums1, nums2): Merges two sorted arrays into a single sorted array without duplicates. merged_set = set(nums1) | set(nums2) return sorted(merged_set)"},{"question":"# Problem Description You are tasked with enhancing a linked list data structure with new functionalities. Your task is to add specific operations to the linked list and handle edge cases effectively. # Objectives 1. Implement the `reverse_in_groups` method, which reverses the linked list in groups of a given size. 2. Improve the linked list to handle cycle detection and removal. 3. Implement a merge operation that merges two sorted linked lists into a single sorted linked list. # Requirements Part 1: `reverse_in_groups` * **Function Signature**: `def reverse_in_groups(self, k: int) -> None:` * **Inputs**: An integer `k` representing the group size. * **Outputs**: The linked list is modified in place to reverse every k nodes. If there are fewer than k nodes left at the end, those nodes should remain as is. * **Constraints**: - Nodes contain integer values. Part 2: Cycle Detection and Removal * **Enhance the `LinkedList` class**: - Add a method to detect if there is a cycle in the list. - Add a method to remove the cycle if detected. * **Modify the traversal methods** to handle cycles properly: - Ensure traversal methods do not enter into infinite loops due to cycles. Part 3: Merging Sorted Linked Lists - Implement a method to merge two sorted linked lists and return a new sorted linked list. # Input and Output Format ```python # Example for Part 1 ll = LinkedList() ll.insert(1, 2, 3, 4, 5, 6, 7, 8, 9) ll.reverse_in_groups(4) print(ll) # Output should be 4->3->2->1->8->7->6->5->9 # Example for Part 2 ll = LinkedList() ll.insert(1, 2, 3, 4, 5) ll.create_cycle(3) # Creates a cycle where last node points to node with value 3 print(ll.detect_cycle()) # Output should be True ll.remove_cycle() print(ll.detect_cycle()) # Output should be False # Example for Part 3 ll1 = LinkedList() ll1.insert(1, 3, 5) ll2 = LinkedList() ll2.insert(2, 4, 6) merged_ll = LinkedList.merge_sorted_lists(ll1, ll2) print(merged_ll) # Output should be 1->2->3->4->5->6 ``` Performance and Constraints - Ensure time complexity remains efficient even after adding the enhancements. - Handle edge cases such as empty linked lists or very large lists. # Function Details 1. `reverse_in_groups(self, k: int) -> None` 2. `insert(self, *values) -> Self` 3. `detect_cycle(self) -> bool` 4. `remove_cycle(self) -> None` 5. `merge_sorted_lists(ll1: LinkedList, ll2: LinkedList) -> LinkedList` 6. Other necessary helper functions and methods. # Scenario Imagine you are developing a data processing system where chunks of data are being processed in parallel. You need a linked list that can handle group-based operations, detect and remove cycles to prevent infinite loops, and merge sorted datasets efficiently. By adding these functionalities to the linked list, you can ensure efficient data processing and manipulation, making the system robust and reliable. --- This new question follows the same style and complexity as the provided sample, covering additional linked list functionalities which complement the BST functionalities in the original question.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, *values): for value in values: new_node = Node(value) if not self.head: self.head = new_node last_node = self.head else: last_node.next = new_node last_node = new_node return self def reverse_in_groups(self, k: int) -> None: self.head = self._reverse_in_groups(self.head, k) def _reverse_in_groups(self, head, k): current = head prev = None next = None count = 0 # reverse first k nodes of the linked list while current is not None and count < k: next = current.next current.next = prev prev = current current = next count += 1 # next is now a pointer to (k+1)th node # recursively call for the list starting from current. # And make rest of the list as next of first node if next is not None: head.next = self._reverse_in_groups(next, k) # prev is new head of the input list return prev def detect_cycle(self) -> bool: slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self) -> None: if self.head is None: return slow, fast = self.head, self.head # Detect if a cycle is present cycle_detected = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if not cycle_detected: return # Remove the cycle slow = self.head while slow != fast: slow = slow.next fast = fast.next # To find the node that starts the cycle cycle_start = slow # To find the previous node to cycle_start temp = cycle_start while temp.next != cycle_start: temp = temp.next # Break the cycle temp.next = None @staticmethod def merge_sorted_lists(ll1, ll2): dummy = Node(-1) tail = dummy a, b = ll1.head, ll2.head while a is not None and b is not None: if a.value <= b.value: tail.next = a a = a.next else: tail.next = b b = b.next tail = tail.next if a is not None: tail.next = a else: tail.next = b merged_list = LinkedList() merged_list.head = dummy.next return merged_list def __str__(self): values = [] current = self.head while current: values.append(str(current.value)) current = current.next return \\"->\\".join(values) def create_cycle(self, value): cycle_node = None current = self.head while current.next: if current.value == value: cycle_node = current current = current.next current.next = cycle_node"},{"question":"# Objective Write a function to find the minimum depth of a binary tree, which is defined as the shortest path from the root node to the nearest leaf node. # Problem Description Given the root of a binary tree, implement a function `minDepth(root: TreeNode | None) -> int` to find the minimum depth of the tree. The minimum depth is defined as the shortest distance from the root node to any leaf node. # Input and Output Formats * **Input**: A reference to the root of a binary tree. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: An integer representing the minimum depth of the binary tree. # Constraints 1. The number of nodes in the tree is in the range `[0, 10000]`. 2. `-1000 <= Node.val <= 1000` 3. Consider the tree with no children nodes as a valid input. 4. Assume all node values are integers within the given range. # Performance Requirements * The function should perform in O(n) time complexity best utilizing methods such as Breadth-First Search (BFS) due to the expansive node range. # Function Signature Example ```python def minDepth(root: TreeNode | None) -> int: # Your code here pass ``` # Edge Cases 1. The tree is null. 2. The tree has only one node. 3. Tree is skewed, either left-heavy or right-heavy. 4. Tree with multiple leaves at different depths. # Testing Use the provided examples to test different scenarios and edge cases.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root: TreeNode | None) -> int: if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return 0"},{"question":"# Question You are working on a web application that helps users manage their task lists. Each task has start and end times, and tasks can overlap. Your goal is to implement a function that merges overlapping tasks into a single task. For example, if you have tasks that span from 1 to 3 and another from 2 to 5, these should be merged into a single task spanning from 1 to 5. Implement the function `merge_tasks(tasks: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that merges overlapping tasks. # Function Signature ```python def merge_tasks(tasks: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ``` # Input * `tasks`: A list of tuples where each tuple represents a task with start and end times `(start_time, end_time)`. The start and end times are inclusive and given as integers. The list can contain 0 or more tasks. # Output * Returns a list of merged tasks represented as tuples `(merged_start_time, merged_end_time)`. # Constraints 1. Tasks are represented as tuples of two integers. 2. Each task\'s start time is less than or equal to its end time. 3. The tasks are not necessarily provided in sorted order. 4. Start and end times are non-negative integers. # Example ```python print(merge_tasks([(1, 3), (2, 5), (8, 10), (9, 12)])) # Expected Output: [(1, 5), (8, 12)] print(merge_tasks([(1, 2), (2, 3), (3, 4)])) # Expected Output: [(1, 4)] ``` # Notes * Ensure that merged tasks are returned in increasing order of their start times. * If there are no tasks or only one task, simply return the input list. * You may create additional helper functions if needed to modularize your solution.","solution":"from typing import List, Tuple def merge_tasks(tasks: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not tasks: return [] # Sort tasks based on the start time tasks.sort(key=lambda x: x[0]) # Initialize the list of merged tasks with the first task merged_tasks = [tasks[0]] for current_task in tasks[1:]: last_merged_task = merged_tasks[-1] # Check if the current task overlaps with the last merged task if current_task[0] <= last_merged_task[1]: # Merge the tasks by extending the end time merged_tasks[-1] = (last_merged_task[0], max(last_merged_task[1], current_task[1])) else: # If no overlap, just add the current task to merged tasks list merged_tasks.append(current_task) return merged_tasks"},{"question":"# Coding Assessment Question Scenario: You are part of a software development team working on a text editor. One of your tasks is to implement an auto-complete system that suggests words based on the prefix the user has typed so far. Task: Implement a function `autocomplete(dictionary, prefix)` that returns a list of words from the `dictionary` that start with the given `prefix`. The words in the dictionary are all lowercase and the prefix is also expected to be in lowercase. Function Signature: ```python def autocomplete(dictionary: List[str], prefix: str) -> List[str]: ``` Input: - `dictionary`: A list of strings representing the dictionary words. - `prefix`: A string indicating the prefix typed by the user. Output: - Returns a list of strings from the dictionary that start with the given prefix. The list should be sorted in ascending lexicographical order. Constraints: - The dictionary contains between 1 and 1000 words. - Each word in the dictionary has a length between 1 and 100 characters. - The prefix has a length between 1 and 100 characters. Example: ```python dictionary = [\\"apple\\", \\"app\\", \\"application\\", \\"apply\\", \\"apt\\", \\"bat\\", \\"bath\\", \\"batman\\"] prefix = \\"app\\" print(autocomplete(dictionary, prefix)) # Expected Output: [\\"app\\", \\"apple\\", \\"application\\", \\"apply\\"] prefix = \\"ba\\" print(autocomplete(dictionary, prefix)) # Expected Output: [\\"bat\\", \\"bath\\", \\"batman\\"] ``` Notes: - Ensure your implementation handles cases where no words match the prefix by returning an empty list. - Optimize your implementation for performance to handle the upper limit of the constraints effectively. - Be careful with edge cases where the prefix might partially match the end of a word in the dictionary.","solution":"from typing import List def autocomplete(dictionary: List[str], prefix: str) -> List[str]: Returns a list of words from the dictionary that start with the given prefix. The list is sorted in ascending lexicographical order. return sorted([word for word in dictionary if word.startswith(prefix)])"},{"question":"# Anagrams Checker with Character Frequency Background An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For instance, \\"listen\\" and \\"silent\\" are anagrams of each other. Task Implement a function to check if two strings are anagrams of each other. Extend this function with an additional parameter to ignore character case during the comparison. # Function Signature ```python def are_anagrams( str1: str, str2: str, ignore_case: bool = False ) -> bool: Checks if two strings are anagrams of each other with an option to ignore character case. Parameters: - str1 (str): The first string to compare. - str2 (str): The second string to compare. - ignore_case (bool): If True, the comparison ignores character case. Returns: - bool: True if the strings are anagrams of each other, False otherwise. ``` # Input Constraints - `str1` and `str2` are non-empty strings containing only alphabetic characters. # Output - Return `True` if the strings are anagrams of each other; otherwise, return `False`. # Examples ```python # Basic Anagram Check print(are_anagrams(\\"listen\\", \\"silent\\")) # Expected output: True # Anagram Check with Different Cases print(are_anagrams(\\"Listen\\", \\"Silent\\", ignore_case=True)) # Expected output: True # Not Anagrams Check print(are_anagrams(\\"hello\\", \\"world\\")) # Expected output: False # Case-Sensitive Not Anagrams print(are_anagrams(\\"Listen\\", \\"Silent\\")) # Expected output: False ```","solution":"def are_anagrams(str1: str, str2: str, ignore_case: bool = False) -> bool: Checks if two strings are anagrams of each other with an option to ignore character case. Parameters: - str1 (str): The first string to compare. - str2 (str): The second string to compare. - ignore_case (bool): If True, the comparison ignores character case. Returns: - bool: True if the strings are anagrams of each other, False otherwise. if ignore_case: str1 = str1.lower() str2 = str2.lower() return sorted(str1) == sorted(str2)"},{"question":"# Programming Question: Minimum Hop Count in Network Path You are tasked with solving a network routing problem. Specifically, given a list of bidirectional connections between nodes in a network, you need to determine the minimum number of hops (i.e., edges traversed) required to travel from a starting node to a target node. A hop is defined as a direct connection between two nodes. If no such path exists, your function should return `-1`. Write a Python function: ```python def min_hop_count(connections: List[Tuple[int, int]], start: int, end: int) -> int: pass ``` # Input * `connections` is a list of tuples, where each tuple signifies a bidirectional connection between two nodes. The nodes are labeled with non-negative integers. * `start` is an integer representing the starting node. * `end` is an integer representing the target node. # Output * Return an integer representing the minimum number of hops required to travel from `start` to `end`. If no path exists, return `-1`. # Constraints * The number of nodes in the network does not exceed 10^4. * The number of connections in the network does not exceed 10^5. * Assume all node labels are valid and are within the bounds of the connection tuples provided. # Example ```python >>> min_hop_count([(0, 1), (1, 2), (2, 3), (1, 4), (4, 5)], 0, 5) 3 >>> min_hop_count([(0, 1), (1, 2), (2, 3), (1, 4), (4, 5)], 0, 6) -1 >>> min_hop_count([(0, 1), (1, 2), (2, 3), (3, 4)], 0, 4) 4 ``` # Notes: * The function should efficiently handle large networks using appropriate graph traversal algorithms. * Consider both breadth-first search (BFS) for its optimality in finding the shortest path in unweighted graphs. * Optimize the data structures used to store connections for faster lookups and traversals.","solution":"from typing import List, Tuple from collections import deque, defaultdict def min_hop_count(connections: List[Tuple[int, int]], start: int, end: int) -> int: if start == end: return 0 # Create adjacency list representation of the graph. graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Perform BFS to find the shortest path. queue = deque([(start, 0)]) # Each element in the queue is a tuple (current_node, current_hop_count) visited = set() visited.add(start) while queue: current_node, current_hop_count = queue.popleft() for neighbor in graph[current_node]: if neighbor == end: return current_hop_count + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_hop_count + 1)) return -1 # If no path is found"},{"question":"# Scenario: You have been hired as a backend developer by a logistics company. One of your primary tasks is to develop a system that helps in managing and maintaining the inventory of items in the warehouse. The company needs a function to check whether the sequence of items being added and removed from the inventory follows a valid pattern - specifically, whether the items are always added and removed in pairs, and maintain the correct item types. # Task: Implement a function `is_valid_inventory_sequence` to determine if the sequence of items being added and removed follows a valid pattern. # Requirements: 1. **Input Parameters**: - `operations`: A list of strings where each string represents either \'add:item_type\' or \'remove:item_type\'. 2. **Output**: - Return True if the operations result in a valid inventory sequence, otherwise return False. # Constraints: 1. Each operation is in the form of \'add:item_type\' or \'remove:item_type\'. 2. The inventory should never have more `remove` operations than `add` operations at any given time. 3. The sequence must end with a balance where all added items have been removed. # Function Signature: ```python def is_valid_inventory_sequence(operations: List[str]) -> bool: pass ``` # Examples: ```python >>> is_valid_inventory_sequence([\'add:apple\', \'add:banana\', \'remove:banana\', \'remove:apple\']) True >>> is_valid_inventory_sequence([\'add:apple\', \'add:banana\', \'remove:banana\', \'remove:grape\']) False >>> is_valid_inventory_sequence([\'add:apple\', \'remove:apple\', \'remove:apple\']) False >>> is_valid_inventory_sequence([\'add:apple\', \'add:banana\', \'remove:apple\', \'remove:banana\']) False ``` In this problem, you need to parse the sequence of operations and ensure that items being added and removed conform to the valid inventory sequence rules. This requires careful handling of the types of items being added/removed and maintaining the balance of operations.","solution":"from typing import List def is_valid_inventory_sequence(operations: List[str]) -> bool: inventory = [] for operation in operations: action, item = operation.split(\':\') if action == \'add\': inventory.append(item) elif action == \'remove\': if not inventory or inventory[-1] != item: return False inventory.pop() return len(inventory) == 0"},{"question":"# Scenario: As a software engineer, you have been tasked with creating a utility that helps in managing users\' online interaction timings. You need to implement a function that converts a string representation of a time interval into its corresponding number of seconds. # Function Specification: You are to implement a function called `convert_to_seconds` that adheres to the following: Input: - `time_interval` (str): a string representing the time interval in the format \\"HH:MM:SS\\", where: - `HH` is always two digits and signifies hours (00-99). - `MM` is always two digits and signifies minutes (00-59). - `SS` is always two digits and signifies seconds (00-59). Output: - Returns an integer that represents the total number of seconds. # Constraints: - If the `time_interval` is not in the correct format, raise a `ValueError` with the message \\"Invalid time format\\". - Ensure that the time values fall within their respective ranges; otherwise, raise a `ValueError` with the message \\"Time values out of range\\". # Examples: ```python >>> convert_to_seconds(\\"02:30:45\\") 9045 >>> convert_to_seconds(\\"00:59:59\\") 3599 >>> convert_to_seconds(\\"99:59:59\\") 359999 >>> convert_to_seconds(\\"123:59:59\\") Traceback (most recent call last): ... ValueError: Time values out of range >>> convert_to_seconds(\\"12:30\\") Traceback (most recent call last): ... ValueError: Invalid time format ``` # Implementation Details: Consider using string manipulation techniques to ensure the input string adheres to the specified format. Be strict about validating each part of the string to ensure correctness. Handle edge cases effectively to cover all possible errors and scenarios.","solution":"def convert_to_seconds(time_interval): Converts a time interval in the format \\"HH:MM:SS\\" to its total number of seconds. Args: time_interval (str): A string representation of time in \\"HH:MM:SS\\" format. Returns: int: Total number of seconds represented by the time interval. Raises: ValueError: If the time format is invalid or time values are out of range. parts = time_interval.split(\':\') if len(parts) != 3: raise ValueError(\\"Invalid time format\\") try: hours = int(parts[0]) minutes = int(parts[1]) seconds = int(parts[2]) except ValueError: raise ValueError(\\"Invalid time format\\") if not (0 <= hours <= 99): raise ValueError(\\"Time values out of range\\") if not (0 <= minutes < 60): raise ValueError(\\"Time values out of range\\") if not (0 <= seconds < 60): raise ValueError(\\"Time values out of range\\") total_seconds = hours * 3600 + minutes * 60 + seconds return total_seconds"},{"question":"# Problem Statement You are given a list of non-negative integers representing points scored in a series of games by a player. Your task is to write a function that calculates the player\'s maximum and minimum scores, as well as the average score over all games. You also need to identify the longest streak of consecutive games in which the player scored more than a specified threshold value. Function Signature ```python def analyze_scores(scores: list[int], threshold: int) -> tuple[int, int, float, int]: ``` Parameters * **scores**: A list of non-negative integers representing the scores. * **threshold**: A non-negative integer representing the score threshold. Returns * A tuple of four elements: 1. **max_score**: An integer representing the maximum score. 2. **min_score**: An integer representing the minimum score. 3. **average_score**: A float representing the average score rounded to two decimal places. 4. **longest_streak**: An integer representing the longest streak of consecutive games with scores greater than the threshold. Input Constraints * The list of scores can contain up to 10^5 elements. * Each score and the threshold is a non-negative integer not exceeding 10^9. Example ```python scores = [24, 50, 38, 27, 19, 45, 55, 23, 31, 18] threshold = 25 assert analyze_scores(scores, threshold) == (55, 18, 33.0, 3) ``` # Explanation - In the provided example, the maximum score is 55, the minimum score is 18, and the average score is 33.0. - The longest streak of consecutive games with scores greater than 25 is 3 (scores 50, 38, 27).","solution":"def analyze_scores(scores: list[int], threshold: int) -> tuple[int, int, float, int]: max_score = max(scores) min_score = min(scores) average_score = round(sum(scores) / len(scores), 2) longest_streak = 0 current_streak = 0 for score in scores: if score > threshold: current_streak += 1 longest_streak = max(longest_streak, current_streak) else: current_streak = 0 return (max_score, min_score, average_score, longest_streak)"},{"question":"# Coding Assessment Question Problem Context: In a given list of integers, a \\"peak\\" element is defined as an element that is strictly greater than its neighbors. For a list with multiple peaks, return the index of any one of the peaks. For simplicity, assume that: - \'A\' list always contains at least one peak element, - the first and last elements are considered to have only one neighbor. Task: Write a function to find the index of a peak element in a list of integers. Your solution should aim for an O(log n) runtime complexity. Function Signature: ```python def find_peak_element(nums: List[int]) -> int: ``` Input: * A list \'nums\' of integers, where (1 leq len(nums) leq 10^4): The given list of integers. Output: * An integer: The index of any one peak element. Constraints: * Ensure the solution runs in reasonable time for large values within the constraint. Example: ```python >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) 1 or 5 >>> find_peak_element([1]) 0 >>> find_peak_element([1, 2]) 1 ``` Notes: * The peak search algorithm should be optimized for better performance (hint: think binary search). * Consider both edge cases and usual cases when implementing the solution to ensure robustness. Hints: * Binary Search can help achieve the desired O(log n) complexity. * Pay attention to boundary elements when checking for peak conditions.","solution":"def find_peak_element(nums): Finds the index of a peak element in the list \'nums\'. A peak element is an element that is strictly greater than its neighbors. :param nums: List[int] - The input list of integers. :return: int - The index of one of the peak elements. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: # If mid is greater than mid + 1, then peak is in the left half right = mid else: # If mid is less than or equal to mid + 1, then peak is in the right half left = mid + 1 return left"},{"question":"# Matrix Flipping Game You are tasked with completing a function that determines the minimum number of moves required to make all elements in a binary matrix the same. Each move consists of selecting any submatrix within the matrix and flipping all its elements (turning 0s into 1s and 1s into 0s). Function Signature ```python def min_flips_to_uniform(matrix: List[List[int]]) -> int: pass ``` # Input - `matrix` (List[List[int]]): A 2D list of integers (0s or 1s) representing the binary matrix. # Output - An integer: The minimum number of moves required to make all elements in the matrix the same (all 0s or all 1s). # Constraints - The matrix dimensions will be between 1x1 and 50x50. - The matrix will contain only 0s and 1s. # Examples * `min_flips_to_uniform([[0, 0], [1, 0]])` should return `1`. * `min_flips_to_uniform([[1, 0, 0], [0, 0, 0], [1, 1, 0]])` should return `3`. * `min_flips_to_uniform([[1, 1], [1, 1]])` should return `0`. * `min_flips_to_uniform([[0, 1], [0, 1]])` should return `1`. # Hints - Consider the impact of flipping different submatrices and how they overlap. - A greedy approach focusing on the largest submatrices might prove helpful. - It may also be helpful to keep track of the number of isolated 0s and 1s. Implement this function ensuring that it adheres to the constraints and handles all edge cases appropriately.","solution":"def min_flips_to_uniform(matrix): Determines the minimum number of moves required to make all elements in a binary matrix the same. Args: matrix (List[List[int]]): A 2D list of integers (0s or 1s) representing the binary matrix. Returns: int: The minimum number of moves required to make all elements in the matrix the same. rows = len(matrix) cols = len(matrix[0]) if rows > 0 else 0 # Total count of 0s and 1s count_0 = sum(row.count(0) for row in matrix) count_1 = rows * cols - count_0 # Return the minimum flips required return min(count_0, count_1)"},{"question":"Breadth-First Search (BFS) Traversal You are tasked with implementing a function that performs a breadth-first traversal (or level-order traversal) on a binary tree. Function: `bfs_traversal` Write a function to perform BFS traversal on a binary tree and return the sequence of visited nodes in a list. **Signature**: ```python def bfs_traversal(root: TreeNode) -> List[int]: pass ``` **Input**: - A `TreeNode` object named `root` representing the root of a binary tree. Each `TreeNode` object has three attributes: `val` (an integer representing the node\'s value), `left` (a reference to the left child), and `right` (a reference to the right child). **Output**: - A list of integers representing the values of nodes in the order they were visited during BFS traversal. **Constraints**: - The number of nodes in the binary tree is at most 10^4. - The value of each node is an integer between `-10^5` and `10^5`. - Handle the case where the tree is empty (i.e., `root` is `None`), returning an empty list. **Example**: Given the binary tree: ``` 1 / 2 3 / / 4 5 6 / 7 ``` ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.left = TreeNode(5) root.right.right = TreeNode(6) root.right.left.left = TreeNode(7) bfs_traversal(root) # should return [1, 2, 3, 4, 5, 6, 7] ``` # Implementation Hints - Use a queue to facilitate the level-order traversal. - Enqueue the root node first, then iteratively dequeue nodes, enqueueing their children. **Definition for a binary tree node**: ```python class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None ``` Include proper error handling for empty trees by returning an empty list in such cases.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, x: int): self.val = x self.left = None self.right = None def bfs_traversal(root: Optional[TreeNode]) -> List[int]: Perform BFS traversal on a binary tree and return a list of visited nodes. if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"**Question:** # Subarray Product Less Than K Given an array of positive integers `nums` and a positive integer `k`, write a function `num_subarray_product_less_than_k(nums: List[int], k: int) -> int` that returns the number of (contiguous) subarrays where the product of all the elements in the subarray is less than `k`. # Input: - `nums` (List[int]): the list of positive integers. (1 <= len(nums) <= 10^4, 1 <= nums[i] <= 1000) - `k` (int): the target product value. (0 <= k <= 10^9) # Output: - (int): The number of contiguous subarrays where the product of all elements is less than `k`. # Example: ```python # Example Case 1 # Input: nums = [10, 5, 2, 6], k = 100 # Output: 8 # Example Case 2 # Input: nums = [1, 2, 3], k = 0 # Output: 0 # Example Case 3 # Input: nums = [1, 1, 1], k = 2 # Output: 6 ``` # Constraints: - The array `nums` contains only positive integers. - `k` can be zero or a positive integer. - Handle large inputs efficiently to ensure the function runs within time limits for the maximum input size. # Hints: 1. Consider using the sliding window technique to efficiently find all valid subarrays. 2. Keep track of the current product and adjust the window size to maintain the product less than `k`. Write your function implementation below: ```python def num_subarray_product_less_than_k(nums: List[int], k: int) -> int: if k == 0: return 0 prod = 1 left = 0 count = 0 for right in range(len(nums)): prod *= nums[right] while prod >= k and left <= right: prod //= nums[left] left += 1 count += right - left + 1 return count # Testing the function print(num_subarray_product_less_than_k([10, 5, 2, 6], 100)) # Output: 8 print(num_subarray_product_less_than_k([1, 2, 3], 0)) # Output: 0 print(num_subarray_product_less_than_k([1, 1, 1], 2)) # Output: 6 ```","solution":"from typing import List def num_subarray_product_less_than_k(nums: List[int], k: int) -> int: if k <= 1: return 0 prod = 1 left = 0 count = 0 for right in range(len(nums)): prod *= nums[right] while prod >= k and left <= right: prod //= nums[left] left += 1 count += right - left + 1 return count"},{"question":"# Problem Statement You are given a function that returns the daily stock prices of a company over a certain period. Your task is to implement an algorithm that identifies periods of maximum profit for both buying and selling stocks. Specifically, you should find the best day to buy and the best day to sell to maximize the profit. # Requirements 1. Implement a function named `max_profit_days` that takes: * A list of stock prices `prices` (a list of floats). 2. The `max_profit_days` function should: * Return a tuple with two integers: the day (index) to buy and the day (index) to sell to achieve the maximum profit. * Return (-1, -1) if no profit can be made. # Input Format ```python max_profit_days(prices: List[float]) -> Tuple[int, int] ``` # Output Format * Returns a tuple of two integers. # Constraints * The length of the list `prices` should be at least 2. * Stock prices are always non-negative numbers. # Example ```python # Example usage of the function: prices = [7, 1, 5, 3, 6, 4] buy_day, sell_day = max_profit_days(prices) print(f\\"Buy on day {buy_day} and sell on day {sell_day}\\") ``` *Expected Output*: Buy on day 1 and sell on day 4 # Notes * Ensure your algorithm runs efficiently even for larger lists of stock prices. * Remember to handle edge cases, such as when prices are continuously decreasing. # Explanation In the given example, the best scenario is to buy on day 1 when the price is 1 and sell on day 4 when the price is 6, yielding the maximum profit of 5.","solution":"from typing import List, Tuple def max_profit_days(prices: List[float]) -> Tuple[int, int]: if not prices or len(prices) < 2: return -1, -1 min_price_index = 0 max_profit = 0 buy_day = -1 sell_day = -1 for current_day in range(1, len(prices)): if prices[current_day] - prices[min_price_index] > max_profit: max_profit = prices[current_day] - prices[min_price_index] buy_day = min_price_index sell_day = current_day if prices[current_day] < prices[min_price_index]: min_price_index = current_day if buy_day == -1 or sell_day == -1: return -1, -1 else: return buy_day, sell_day"},{"question":"# Path Finder with Obstacles You are tasked with implementing a function to determine if there is a path from the top-left to the bottom-right corner of a 2D grid. The grid contains obstacles that block the path. Function Signature ```python def is_path(matrix: List[List[int]]) -> bool: ``` Expected Input and Output * **Input**: * `matrix` (List[List[int]]): A 2D list representing the grid. Each element is either `0` (empty) or `1` (obstacle). - `matrix[i][j] = 0` indicates that the cell at row `i` and column `j` is passable. - `matrix[i][j] = 1` indicates that the cell at row `i` and column `j` is blocked. * The top-left corner of the grid is always `matrix[0][0]`, and the bottom-right corner is `matrix[-1][-1]`. * **Output**: * A boolean value `True` if there is a valid path from the top-left to the bottom-right corner, `False` otherwise. Constraints * The grid dimensions are between `1x1` and `100x100`. * The grid contains at least two cells (`1x2`, `2x1`) when the matrix size is minimal. Examples ```python assert is_path([[0, 0, 1], [0, 1, 0], [1, 0, 0]]) == True assert is_path([[0, 1], [1, 0]]) == False assert is_path([[0, 0, 0], [1, 1, 0], [1, 0, 0]]) == True assert is_path([[0, 1, 1], [0, 1, 1], [1, 1, 0]]) == False assert is_path([[0]]) == True ``` Instructions 1. **Implement the function**: Implement the `is_path` function using any pathfinding algorithm such as BFS or DFS. 2. **Edge cases**: Ensure that your function handles small grids, grids filled with obstacles, and edge cells correctly. 3. **Performance**: Make sure the function runs efficiently even for the upper bound grid size. # Notes - Consider both the time complexity and space complexity of your implementation. - The input grid is guaranteed to have well-defined start and end points (`matrix[0][0]` and `matrix[-1][-1]`, respectively). - You may assume all inputs are valid according to the constraints specified.","solution":"from typing import List def is_path(matrix: List[List[int]]) -> bool: if not matrix or matrix[0][0] == 1 or matrix[-1][-1] == 1: return False rows, cols = len(matrix), len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(x, y): if x == rows - 1 and y == cols - 1: return True visited[x][y] = True directions = [(1, 0), (0, 1), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and matrix[nx][ny] == 0: if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"**Problem Statement**: You are given a binary search tree (BST) with unique integer keys and a target integer key. Your task is to find whether the target key exists within the BST and, if not, return the nearest smaller and larger keys (if they exist). **Definition**: * The **nearest smaller key** is the largest value in the BST that is less than the key. * The **nearest larger key** is the smallest value in the BST that is greater than the key. * If the key exists in the BST, simply return the key itself. Write a function `find_nearest_key(root: Node | None, key: int) -> tuple[int | None, int | None, int | None]` that takes in the root of the BST and the target key, and returns a tuple containing the nearest smaller key, the key itself (or None if not found), and the nearest larger key respectively. **Function Signature**: ```python def find_nearest_key(root: Node | None, key: int) -> tuple[int | None, int | None, int | None]: pass ``` **Input**: * `root`: The root node of the BST (could be `None` for an empty tree). * `key`: An integer key for which to find the nearest keys and/or check existence. **Output**: * A tuple `(nearest_smaller, found_key, nearest_larger)`, where: * `nearest_smaller` is the nearest smaller key, or `None` if no such value exists. * `found_key` is the key itself if it exists in the tree, otherwise `None`. * `nearest_larger` is the nearest larger key, or `None` if no such value exists. **Examples**: ```python # Example 1 root = Node(10) root.left = Node(5) root.right = Node(20) root.left.left = Node(3) root.left.right = Node(7) root.right.left = Node(15) root.right.right = Node(25) print(find_nearest_key(root, 8)) # Output: (7, None, 10) print(find_nearest_key(root, 15)) # Output: (10, 15, 20) print(find_nearest_key(root, -1)) # Output: (None, None, 3) print(find_nearest_key(root, 30)) # Output: (25, None, None) # Example 2 with a smaller BST root = Node(6) root.left = Node(2) root.right = Node(8) root.left.left = Node(1) root.left.right = Node(4) print(find_nearest_key(root, 5)) # Output: (4, None, 6) print(find_nearest_key(root, 0)) # Output: (None, None, 1) ``` **Constraints**: * The tree contains unique integer keys. * The key provided is an integer. **Notes**: * The function must handle both balanced and unbalanced BSTs. * Efficient solutions that run in O(h) time, where h is the height of the BST, are expected.","solution":"class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right def find_nearest_key(root: Node | None, key: int) -> tuple[int | None, int | None, int | None]: nearest_smaller = None nearest_larger = None found_key = None current = root while current is not None: if key < current.key: # Candidate for nearest larger nearest_larger = current.key current = current.left elif key > current.key: # Candidate for nearest smaller nearest_smaller = current.key current = current.right else: found_key = current.key return (nearest_smaller, found_key, nearest_larger) return (nearest_smaller, found_key, nearest_larger)"},{"question":"# Context: You have been given an array of integers where each element appears exactly twice, except for one unique element that appears only once. # Task: Implement a function `find_unique_element(arr: List[int]) -> int` that finds and returns the unique element in the given array. # Specifications: - **Input**: A list of integers, where each integer appears exactly twice except for one integer which appears only once. - **Output**: The unique integer. - **Constraints**: - The length of the array will not exceed (10^6). - The integers in the array can be both positive and negative. # Implementation: - **Function**: ```python def find_unique_element(arr: List[int]) -> int: pass ``` - Your solution should be efficient in both time and space. Its recommend to aim for a linear time complexity solution. # Example: Input: ```python arr = [2, 3, 5, 2, 3] ``` Output: ```python 5 ``` In this example, 5 is the only number that appears exactly once in the array.","solution":"from typing import List def find_unique_element(arr: List[int]) -> int: This function finds and returns the unique element in the given list of integers. Each element in the list appears exactly twice, except for one element which appears only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"# Context As a software engineer working on an e-commerce platform, you frequently deal with processing and analyzing large sets of order data. One common task is to identify the most frequently ordered products. # Task Implement a function that finds the top `n` most frequently ordered products from a list of orders. Each order contains a list of product IDs, and the function should return a list of product IDs sorted by their frequency in descending order. In case of a tie in frequency, product IDs should be sorted in ascending order. # Function Signature ```python def top_n_products(orders: List[List[int]], n: int) -> List[int]: ``` # Input - `orders` (list of lists of integers): A list where each element is another list representing an order containing product IDs. - `n` (integer): The number of top frequently ordered products to return. # Output - Returns a list of integers representing the product IDs of the top `n` most frequently ordered products. # Examples ```python assert top_n_products([[1, 2, 3], [1, 4, 5, 2], [1, 2, 4], [2, 3, 4, 1]], 2) == [1, 2] assert top_n_products([[1, 2], [2, 3], [1, 3, 2], [4, 2]], 3) == [2, 1, 3] assert top_n_products([[1, 2, 3], [1], [3, 3], [2, 1], [5, 6, 1, 2, 3, 4]], 4) == [1, 3, 2, 5] ``` # Constraints 1. The individual order lists and product IDs within the orders are non-empty. 2. The number of orders and the number of products in each order can vary. 3. The product IDs are positive integers. 4. The value of `n` will always be less than or equal to the total number of unique products. # Edge Cases 1. The function should handle cases where all orders contain distinct product IDs. 2. In case `n` is larger than the number of unique products, the function should return all unique products sorted by their frequency correctly.","solution":"from collections import Counter from typing import List def top_n_products(orders: List[List[int]], n: int) -> List[int]: Finds the top `n` most frequently ordered products from a list of orders. Parameters: orders (List[List[int]]): A list where each element is another list representing an order containing product IDs. n (int): The number of top frequently ordered products to return. Returns: List[int]: A list of integers representing the product IDs of the top `n` most frequently ordered products. # Flatten the list of orders all_products = [product for order in orders for product in order] # Count the frequency of each product product_counts = Counter(all_products) # Sort products by frequency (high to low), then by product ID (low to high) sorted_products = sorted(product_counts.items(), key=lambda item: (-item[1], item[0])) # Extract the top `n` products based on the sorted list top_products = [product for product, count in sorted_products[:n]] return top_products"},{"question":"# Coding Assessment Question Scenario: You are optimizing the inventory management system for a retail company. The system must keep an exact count of each product\'s stock levels and verify if the current stock can fulfill certain orders. An order is considered fulfillable if the number of each product requested in the order does not exceed the available stock. Objective: Write a function named `can_fulfill_orders` that: - Accepts two parameters: a dictionary `inventory` and a list of dictionaries `orders`. - `inventory` is a dictionary where keys are product names and values are integers representing the stock of each product. - `orders` is a list of dictionaries where each dictionary represents a single order. Keys are product names and values are integers representing the required quantity of each product for that order. - Returns a list of booleans where each element corresponds to whether the respective order in `orders` can be fulfilled. Implementation Requirements: - **Input**: A dictionary `inventory` and a list of dictionaries `orders`. - **Output**: A list of booleans. - Use efficient algorithms to handle checking stock levels against orders. - Ensure your code can handle up to 10^5 entries for both products and orders. Function Signature: ```python def can_fulfill_orders(inventory: dict, orders: list) -> list: pass ``` Constraints: - `inventory` will contain product names as strings and stock levels as non-negative integers (up to 10^6). - Each order in `orders` will contain product names as strings and required quantities as non-negative integers (up to 10^6). Example: ```python inventory = {\'apple\': 5, \'banana\': 3, \'orange\': 10} orders = [{\'apple\': 2, \'banana\': 2}, {\'apple\': 5, \'orange\': 5}, {\'banana\': 4}] assert can_fulfill_orders(inventory, orders) == [True, True, False] inventory = {\'shampoo\': 20, \'soap\': 15} orders = [{\'shampoo\': 5, \'soap\': 5}, {\'shampoo\': 25}, {\'soap\': 10}] assert can_fulfill_orders(inventory, orders) == [True, False, True] ``` You should not rely on any specific library for performing the checks and should ensure your solution efficiently handles the given constraints. **Note**: Provide comprehensive tests to validate your implementation, considering edge cases such as empty inventories or orders and large inputs.","solution":"def can_fulfill_orders(inventory: dict, orders: list) -> list: Returns a list of booleans indicating whether each order can be fulfilled given the inventory. result = [] for order in orders: can_fulfill = True for product, quantity in order.items(): if product not in inventory or inventory[product] < quantity: can_fulfill = False break result.append(can_fulfill) return result"},{"question":"# Coding Assessment Question: Write a function `find_subarray_sum_count(arr: List[int], target: int) -> int` that takes a list of integers `arr` and an integer `target`, and returns the count of contiguous subarrays whose sum is equal to `target`. **Function Signature** ```python from typing import List def find_subarray_sum_count(arr: List[int], target: int) -> int: pass ``` **Input** - `arr`: A list of integers of length between 1 and 10000. - `target`: An integer that may be positive, negative, or zero. **Output** - An integer representing the number of contiguous subarrays in `arr` whose sum equals `target`. **Example** ```python assert find_subarray_sum_count([1, 2, 3], 3) == 2 # subarrays: [1, 2] and [3] assert find_subarray_sum_count([1, -1, 1], 1) == 3 # subarrays: [1], [1, -1, 1], [1] assert find_subarray_sum_count([1, 1, 1], 2) == 2 # subarrays: [1, 1] (twice) ``` **Constraints and Conditions** - You must handle the array length efficiently. - Consider the possibility of integers being both negative and positive. - Your function should aim for an optimal solution in terms of time complexity, possibly O(n). **Performance Considerations** - Aim to minimize time complexity to handle inputs up to 10000 efficiently. **Scenario** You are implementing a feature for financial analysis software that needs to find specific patterns in transactions. The algorithm should efficiently identify sums of transaction values over short periods to meet various query requirements.","solution":"from typing import List from collections import defaultdict def find_subarray_sum_count(arr: List[int], target: int) -> int: count = 0 current_sum = 0 prefix_sum_counts = defaultdict(int) prefix_sum_counts[0] = 1 for num in arr: current_sum += num if (current_sum - target) in prefix_sum_counts: count += prefix_sum_counts[current_sum - target] prefix_sum_counts[current_sum] += 1 return count"},{"question":"# Problem Statement You are required to implement a function that identifies the n-th most common element in a list of integers. If there are ties (multiple elements with the same frequency), the tied elements should be sorted by their values in ascending order, and then the n-th one is selected. # Function Signature ```python def nth_most_common(nums: list[int], n: int) -> int: pass ``` # Input and Output The function should take: * `nums`: a list of integers where the n-th most common element is to be identified. * `n`: an integer representing which \\"most common\\" element to identify. The function should return an integer; the n-th most common element in the list based on the rules described. # Constraints * The length of the list `nums` will be between 1 and 10^5. * All elements in `nums` will be integers between -10^9 and 10^9. * `n` will be a positive integer less than or equal to the number of unique elements in `nums`. # Explanation and Example To find the n-th most common element: 1. Calculate the frequency of each distinct element in the list. 2. Sort the elements by their frequency in descending order. 3. If there are ties (elements with the same frequency), sort these tied elements by their values in ascending order. 4. Return the n-th most common element. Example ```python nth_most_common([1, 2, 3, 2, 3, 3, 4, 4, 4, 4], 2) ``` In this example: 1. The frequency of the elements is: ``` { 1: 1, 2: 2, 3: 3, 4: 4 } ``` 2. Sorting by frequency in descending order yields: ``` [(4, 4), (3, 3), (2, 2), (1, 1)] ``` 3. Since we need the 2nd most common element, we select `3`. Thus, the function will return: ``` 3 ``` # Note Ensure to handle the following edge cases: * Lists with all unique elements and n equal to the length of the list. * Lists with all identical elements, where n would be 1. * Handling ties correctly by sorting tied elements based on their values.","solution":"from collections import Counter def nth_most_common(nums: list[int], n: int) -> int: Returns the n-th most common element in the list of integers `nums`. In case of ties, the elements have to be sorted by their values in ascending order before selecting the n-th element. # Count the frequency of each element count = Counter(nums) # Convert the count dictionary to a sorted list of (element, frequency) tuples # First sort by element in ascending order, then by frequency in descending order sorted_count = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Return the n-th most common element return sorted_count[n-1][0]"},{"question":"# Matrix Transpose **Problem Statement**: You are required to implement a function to transpose a given matrix. Transposing a matrix involves swapping the matrix\'s rows and columns. **Function Signature**: ```python def transpose(matrix: List[List[int]]) -> List[List[int]]: Approach: - Create an empty matrix with dimensions equal to the transpose of the input matrix. - Iterate through each element of the matrix. - Map and store each element into its transposed position in the new matrix. Params: - matrix (List[List[int]]): A 2D list representing the input matrix. Returns: - List[List[int]]: The transposed matrix. pass ``` **Input**: * `matrix` - A 2D list (list of lists) with integers representing the input matrix. **Output**: * A 2D list (list of lists) representing the transposed matrix. **Constraints**: * The input matrix will have at least one element. * The matrix is not necessarily square (number of rows may not equal number of columns). **Example**: ```python matrix1 = [ [1, 2, 3], [4, 5, 6] ] # Transposing matrix1 yields: # [ # [1, 4], # [2, 5], # [3, 6] # ] print(transpose(matrix1)) # Output: [[1, 4], [2, 5], [3, 6]] matrix2 = [ [1, 0, 3], [2, 0, 4] ] # Transposing matrix2 yields: # [ # [1, 2], # [0, 0], # [3, 4] # ] print(transpose(matrix2)) # Output: [[1, 2], [0, 0], [3, 4]] ``` **Note**: - Verify your function with diverse input matrices including edge cases such as single row or single column matrices. - Ensure that the transposition correctly handles non-square matrices and correctly maps rows to columns and vice versa.","solution":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Transpose the given matrix. Params: - matrix (List[List[int]]): A 2D list representing the input matrix. Returns: - List[List[int]]: The transposed matrix. # Create an empty transposed matrix with switched dimensions transposed = [[0] * len(matrix) for _ in range(len(matrix[0]))] # Fill the transposed matrix with swapped rows and columns for i in range(len(matrix)): for j in range(len(matrix[0])): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Regular Expression Parser and Matcher You are required to implement a simplified regular expression parser and matcher that can handle basic regex patterns in Python. This will assess your comprehension of string manipulation and pattern matching. Problem Statement Design and implement two functions: 1. `regex_parser(pattern)`: Converts a simplified regex pattern into a corresponding data structure for easier matching. 2. `regex_matcher(parsed_pattern, text)`: Matches the text against the parsed regex pattern and returns whether it matches or not. # Function Definitions: 1. **`regex_parser(pattern)`**: - **Input**: A string `pattern` representing a simplified regex pattern. The pattern may include characters `[a-zA-Z0-9]`, the dot character `\'.\'` representing any character, and the asterisk `\'*\'` which means the preceding character can repeat zero or more times. - **Output**: A parsed representation of the pattern, such as a list or a tree structure, that can be used for matching. 2. **`regex_matcher(parsed_pattern, text)`**: - **Input**: The parsed representation of the regex pattern and a string `text` to match against the pattern. - **Output**: A boolean value indicating whether the text matches the regex pattern. Example: ```python pattern = \\"a.*b\\" parsed_pattern = regex_parser(pattern) text = \\"aAaBb\\" is_match = regex_matcher(parsed_pattern, text) print(f\\"Pattern: {pattern}, Text: {text}, Match: {is_match}\\") ``` Expected Output: - Pattern: a.*b - Text: aAaBb - Match: True # Additional Requirements: - Handle edge cases like empty patterns and text strings. - The asterisk `\'*\'` should apply only to the preceding character. - Optimize your implementation for efficient pattern matching. - Ensure your solution is not overly dependent on built-in regex libraries and demonstrates a clear understanding of the concepts. You may define helper classes and methods as needed to structure your parsed representation and facilitate the matching process.","solution":"def regex_parser(pattern): Parses a simplified regex pattern into a list of tuples, where each tuple contains: - Character or special character (like .) - Boolean indicating if the character is followed by * parsed_pattern = [] i = 0 while i < len(pattern): if i + 1 < len(pattern) and pattern[i + 1] == \'*\': parsed_pattern.append((pattern[i], True)) i += 2 else: parsed_pattern.append((pattern[i], False)) i += 1 return parsed_pattern def regex_matcher(parsed_pattern, text): Matches the text against the parsed regex pattern. def match(i, j): # If we reach the end of both the pattern and the text, it\'s a match if i == len(parsed_pattern): return j == len(text) # Check if we have a match at the current position current_char, is_star = parsed_pattern[i] match_here = j < len(text) and (current_char == text[j] or current_char == \'.\') if is_star: # If there is a star, we can either skip it or match one char and continue return (match(i + 1, j) or (match_here and match(i, j + 1))) else: return match_here and match(i + 1, j + 1) return match(0, 0)"},{"question":"# Fibonacci Sequence with Specific Modulo Condition You are required to implement a function `fibonacci_mod_sequence(n: int, mod: int) -> list[int]` that generates the Fibonacci sequence up to the nth term and applies a modulo operation with the given modulus value to each term in the sequence. # Function Signature ```python def fibonacci_mod_sequence(n: int, mod: int) -> list[int]: pass ``` # Input - `n`: an integer representing the number of terms in the Fibonacci sequence to generate. - `mod`: an integer value that specifies the modulus for each term in the sequence. # Output - Return a list of integers where each element is a term in the Fibonacci sequence modulo the given `mod` value. # Constraints - If `n` is 0, negative, or not an integer, return an empty list. - If `mod` is less than or equal to 1, return a list of zeros with the length of `n`. - Ensure your solution is efficient and handles large values of `n`. # Examples ```python >>> fibonacci_mod_sequence(10, 5) [0, 1, 1, 2, 3, 0, 3, 3, 1, 4] >>> fibonacci_mod_sequence(-3, 10) [] >>> fibonacci_mod_sequence(5, 1) [0, 0, 0, 0, 0] >>> fibonacci_mod_sequence(0, 3) [] >>> fibonacci_mod_sequence(7, 100) [0, 1, 1, 2, 3, 5, 8] ``` # Explanation - The first example generates the first 10 terms of the Fibonacci sequence and applies the modulo 5 operation to each term. - The second example returns an empty list because `n` is negative. - The third example returns a list of zeros because any number modulo 1 is 0. - The fourth example returns an empty list because `n` is 0. - The fifth example generates the first 7 terms of the Fibonacci sequence and applies the modulo 100 operation to each term. Ensure the function accurately handles all edge cases and meets performance requirements for large values of `n`.","solution":"def fibonacci_mod_sequence(n: int, mod: int) -> list[int]: if not isinstance(n, int) or n <= 0: return [] if mod <= 1: return [0] * n sequence = [0, 1] for i in range(2, n): next_fib = (sequence[-1] + sequence[-2]) % mod sequence.append(next_fib) return sequence[:n]"},{"question":"# Question: Implement an Interval Intersection Finder Scenario: A scheduling system needs to find the intersections between two lists of time intervals. Each interval in the list represents a busy time slot for a resource, and a scheduler wants to identify all the overlapping intervals to manage resource allocation effectively. Requirements: Implement a `find_intersections(intervals1: List[List[int]], intervals2: List[List[int]]) -> List[List[int]]` function, where each interval is represented as a pair of integers [start, end] (inclusive), and returns a list of intersecting intervals from both input lists. Constraints: 1. Each interval list is sorted by the start time. 2. The intervals within each list are non-overlapping. 3. Overlapping intervals are found if they share any timeframe. Input/Output Formats: * `intervals1: List[List[int]]` - a list of intervals e.g., [[1, 3], [5, 6]] * `intervals2: List[List[int]]` - another list of intervals e.g., [[2, 4], [7, 8]] * `find_intersections(intervals1, intervals2) -> List[List[int]]` - the list of intersecting intervals Example: ```python def find_intersections(intervals1, intervals2): intersections = [] i, j = 0, 0 while i < len(intervals1) and j < len(intervals2): a1, a2 = intervals1[i] b1, b2 = intervals2[j] # Check if intervals overlap if a1 <= b2 and b1 <= a2: # Append the intersection intersections.append([max(a1, b1), min(a2, b2)]) # Move the pointers if a2 < b2: i += 1 else: j += 1 return intersections # Example usage: intervals1 = [[1, 3], [5, 9]] intervals2 = [[2, 6], [8, 10]] print(find_intersections(intervals1, intervals2)) # Expected output: [[2, 3], [5, 6], [8, 9]] ``` Explanation: - The function uses two pointers to traverse through both interval lists. - It checks for overlapping intervals and maintains a list of these intersections. - The time complexity of this solution is O(n + m), where n and m are the lengths of `intervals1` and `intervals2` respectively.","solution":"def find_intersections(intervals1, intervals2): intersections = [] i, j = 0, 0 while i < len(intervals1) and j < len(intervals2): a1, a2 = intervals1[i] b1, b2 = intervals2[j] # Check if intervals overlap if a1 <= b2 and b1 <= a2: # Append the intersection intersections.append([max(a1, b1), min(a2, b2)]) # Move the pointers if a2 < b2: i += 1 else: j += 1 return intersections # Example usage: # intervals1 = [[1, 3], [5, 9]] # intervals2 = [[2, 6], [8, 10]] # print(find_intersections(intervals1, intervals2)) # Expected output: [[2, 3], [5, 6], [8, 9]]"},{"question":"# Coding Assessment Question You have been provided with the implementation of the Leaky ReLU (Leaky Rectified Linear Unit) function, a commonly used activation function in neural networks. To further test your knowledge of activation functions and their modifications, you are tasked with implementing a custom activation function called the Parametric Rectified Linear Unit (PReLU). # Scenario Your task is to implement an activation function called PReLU (Parametric Rectified Linear Unit). PReLU allows the model to learn the slope of the negative region during training. # Function Definition Implement the function `parametric_rectified_linear_unit` that takes a vector of K real numbers and a real number, `alpha`, and applies the PReLU function to each element of the vector. # Mathematical Definition For an input element x, the PReLU function f(x) is defined as follows: ``` f(x) = x if x > 0 f(x) = alpha * x if x <= 0 ``` where `alpha` is a learnable parameter that controls the slope of the negative region. # Function Signature ```python def parametric_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray: pass ``` # Input * `vector` (np.ndarray): An array containing K real numbers. * `alpha` (float): The alpha parameter that controls the slope of the negative region. # Output * Returns (np.ndarray): An array in which the PReLU function has been applied to each element. # Constraints * The input vector must be a NumPy array of real numbers. * The value of alpha will be a non-negative real number. # Performance Requirements Your implementation must perform the calculation efficiently in O(K) time and use O(K) auxiliary space. # Examples ```python >>> parametric_rectified_linear_unit(vector=np.array([2.3, 0.6, -2, -3.8]), alpha=0.01) array([ 2.3 , 0.6 , -0.02, -0.038]) >>> parametric_rectified_linear_unit(vector=np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.1) array([-0.92 , -0.03 , 0.45 , -0.456]) ```","solution":"import numpy as np def parametric_rectified_linear_unit(vector: np.ndarray, alpha: float) -> np.ndarray: Applies the PReLU function to each element in the input vector. Parameters: vector (np.ndarray): An array containing K real numbers. alpha (float): The alpha parameter that controls the slope of the negative region. Returns: np.ndarray: An array with the PReLU function applied to each element. return np.where(vector > 0, vector, alpha * vector)"},{"question":"# Coding Question on List Manipulation and Sorting Context Manipulating and sorting lists are fundamental operations in programming that find use in numerous real-world applications. You\'re tasked with creating a function that rearranges a list of integers to meet specific criteria. Problem Design a function `rearrange_list(nums)`, where `nums` is a list of integers. The function should rearrange the list such that: 1. All even numbers appear before all odd numbers. 2. Even and odd numbers should each be sorted independently in descending order. Requirements To achieve this: 1. Separate the list into even and odd numbers. 2. Sort the even numbers in descending order. 3. Sort the odd numbers in descending order. 4. Combine the two sorted lists, with even numbers first, following by odd numbers. 5. Return the rearranged list. Input and Output * **Input**: - A list of integers `nums` (e.g., `[5, 2, 8, 7, 3, 4, 6, 1]`). * **Output**: - A list of integers arranged such that all even numbers appear before odd numbers, both sorted in descending order. Implementation Constraints * Handle lists of varying lengths. * Ensure both sorting and rearrangement are performed efficiently. Example ```python def rearrange_list(nums): # Your code here # Example: print(rearrange_list([5, 2, 8, 7, 3, 4, 6, 1])) # Expected output: [8, 6, 4, 2, 7, 5, 3, 1] ``` Your function definition for `rearrange_list(nums)` should accurately rearrange and sort the list according to the criteria and produce the expected output for the given example. Ensure that your solution is efficient for potentially large inputs.","solution":"def rearrange_list(nums): Rearranges the list such that all even numbers appear before all odd numbers. Both even and odd numbers are sorted independently in descending order. even_nums = [num for num in nums if num % 2 == 0] odd_nums = [num for num in nums if num % 2 != 0] even_nums_sorted = sorted(even_nums, reverse=True) odd_nums_sorted = sorted(odd_nums, reverse=True) return even_nums_sorted + odd_nums_sorted"},{"question":"# Question: Linked List Advanced Algorithms Context: Consider a class implemented to represent a singly linked list in a programming language of your choice. The linked list supports basic operations such as adding a node to the end, removing a node, and traversing the list to print all nodes. Task: Extend the functionality of the given linked list class with the following advanced methods: 1. `rotate_list(k)`: Rotate the linked list to the right by `k` positions. 2. `reverse_sublist(start, end)`: Reverse the sublist of the linked list from position `start` to position `end` (positions are 1-based). 3. `detect_cycle()`: Detect if the linked list has a cycle. If a cycle is detected, return the node at which the cycle begins. If no cycle is found, return None. Implementation Details: - **rotate_list(k)**: - Input: `k` (number representing the positions to rotate the list). - Output: None (modifies the list in place). - **reverse_sublist(start, end)**: - Input: `start` (start position of the sublist), `end` (end position of the sublist). - Output: None (modifies the list in place). - **detect_cycle()**: - Input: None. - Output: Node at the start of the cycle if one exists, otherwise None. Constraints: - The linked list will have at most 10000 nodes. - `rotate_list(k)` assumes `k` is a non-negative integer. - `reverse_sublist(start, end)` assumes `start` and `end` are valid positions within the list and `start` <= `end`. - Nodes in the linked list are represented by integers. Example: ```python class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def add_node(self, value): # Implementation to add a node with the given value to the end of the list. def rotate_list(self, k): # Implementation goes here def reverse_sublist(self, start, end): # Implementation goes here def detect_cycle(self): # Implementation goes here # Example Usage linked_list = LinkedList() linked_list.add_node(1) linked_list.add_node(2) linked_list.add_node(3) linked_list.add_node(4) linked_list.add_node(5) # Requirement linked_list.rotate_list(2) # Before rotation: 1 -> 2 -> 3 -> 4 -> 5 # After rotation: 4 -> 5 -> 1 -> 2 -> 3 linked_list.reverse_sublist(2, 4) # Before reversing sublist: 4 -> 5 -> 1 -> 2 -> 3 # After reversing sublist: 4 -> 2 -> 1 -> 5 -> 3 cycle_node = linked_list.detect_cycle() # If there is a cycle, cycle_node should point to the start of the cycle ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def add_node(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def rotate_list(self, k): if not self.head or k == 0: return # Compute the length of the linked list current = self.head length = 1 while current.next: current = current.next length += 1 # Ensure k is within bounds k = k % length if k == 0: return # Make the list circular current.next = self.head # Find the new end of the list steps_to_new_head = length - k new_end = self.head for _ in range(steps_to_new_head - 1): new_end = new_end.next # Break the circle self.head = new_end.next new_end.next = None def reverse_sublist(self, start, end): if not self.head or start == end: return dummy = Node(0) dummy.next = self.head prev = dummy # Move prev to the node before start for _ in range(start - 1): prev = prev.next # Reverse the sublist from start to end current = prev.next for _ in range(end - start): temp = current.next current.next = temp.next temp.next = prev.next prev.next = temp self.head = dummy.next def detect_cycle(self): slow = self.head fast = self.head # Finding the meeting point if there\'s any cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle detected if not fast or not fast.next: return None # Find the start of the cycle slow = self.head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Sorting Books by Their Titles Context You are working at a library, and one of your tasks is to help maintain the order of books on the shelves. The books are organized by their titles in alphabetical order. Given a list of book titles, you need to sort them alphabetically. Task Write a function `sort_books(titles: List[str]) -> List[str]` that sorts a list of book titles in alphabetical order. The function should return a new list with the titles sorted. Requirements * **Input Format**: - `titles` (List[str]): A list of book titles where each title is a non-empty string consisting of alphabetical characters and spaces. * **Output Format**: - (List[str]): A list of book titles sorted alphabetically (case-insensitive). * **Constraints**: - Each title will only contain uppercase and lowercase alphabetical characters and spaces. - The length of the list `titles` will not exceed 10^5. - The length of each title will not exceed 100 characters. Performance * The function should handle sorting up to 10^5 book titles efficiently. Example Usage ```python # Example 1 titles = [\\"The Great Gatsby\\", \\"Moby Dick\\", \\"Hamlet\\", \\"War and Peace\\"] sorted_titles = sort_books(titles) print(sorted_titles) # Output: [\'Hamlet\', \'Moby Dick\', \'The Great Gatsby\', \'War and Peace\'] # Example 2 titles = [\\"A Tale of Two Cities\\", \\"a tale of two cities\\", \\"Pride and Prejudice\\"] sorted_titles = sort_books(titles) print(sorted_titles) # Output: [\'A Tale of Two Cities\', \'a tale of two cities\', \'Pride and Prejudice\'] ``` Edge Cases * Mixing uppercase and lowercase titles. * Titles with spaces should be sorted lexicographically based on the first differing character.","solution":"from typing import List def sort_books(titles: List[str]) -> List[str]: Sorts a list of book titles in alphabetical order (case-insensitive). Parameters: - titles (List[str]): A list of book titles where each title is a non-empty string. Returns: - List[str]: A list of book titles sorted alphabetically (case-insensitive). return sorted(titles, key=lambda title: title.lower())"},{"question":"# Problem Statement You are required to implement a function that identifies whether a given number is a power of two. Additionally, you should also implement a function that finds the next power of two that is greater than or equal to the given number. # Function 1: `is_power_of_two(n: int) -> bool` * **Input Parameters**: - `n` (int): A non-negative integer. * **Output**: - Returns a boolean indicating whether `n` is a power of two (True) or not (False). * **Constraints**: - 0 <= `n` <= 10^9. # Function 2: `next_power_of_two(n: int) -> int` * **Input Parameters**: - `n` (int): A non-negative integer. * **Output**: - Returns the smallest power of two greater than or equal to `n`. * **Constraints**: - 0 <= `n` <= 10^9. # Requirements: 1. Implement `is_power_of_two(n: int) -> bool`. 2. Implement `next_power_of_two(n: int) -> int`. 3. Ensure efficient computation for both functions. # Examples: Example 1 ```python >>> is_power_of_two(16) True ``` Example 2 ```python >>> next_power_of_two(17) 32 ``` Example 3 ```python >>> is_power_of_two(18) False ``` Example 4 ```python >>> next_power_of_two(1) 1 ``` # Explanation: 1. `is_power_of_two(16)` returns True because 16 is a power of two (2^4). 2. `next_power_of_two(17)` returns 32 because the next power of two greater than 17 is 32 (2^5). 3. `is_power_of_two(18)` returns False because 18 is not a power of two. 4. `next_power_of_two(1)` returns 1 because 1 is already a power of two (2^0).","solution":"def is_power_of_two(n: int) -> bool: Returns whether a given number n is a power of two. return n > 0 and (n & (n - 1)) == 0 def next_power_of_two(n: int) -> int: Returns the smallest power of two greater than or equal to n. if n <= 1: return 1 power = 1 while power < n: power <<= 1 return power"},{"question":"**Context:** Sorting an array of integers is a fundamental task in computer science. Merge Sort is a well-known and efficient, comparison-based, divide-and-conquer sorting algorithm. Your task is to implement a variant of Merge Sort that sorts integers in descending order. **Question:** Write a function `merge_sort_desc(arr: List[int]) -> List[int]` that sorts an array of integers `arr` in descending order using the Merge Sort algorithm. **Guidelines:** 1. Divide the array into two halves recursively until each sub-array contains a single element or is empty. 2. Merge the sub-arrays to produce new sorted (in descending order) sub-arrays. 3. Continue the process until you obtain a fully sorted array in descending order. **Expected Input and Output:** - **Input:** A list of integers `arr`. For example `[5, 3, 8, 4, 2]` - **Output:** A sorted list of integers in descending order. For instance, the input `[5, 3, 8, 4, 2]` should return `[8, 5, 4, 3, 2]`. **Function Signature:** ```python from typing import List def merge_sort_desc(arr: List[int]) -> List[int]: pass ``` **Constraints:** - The array may contain up to (10^5) elements. - Array size can be any positive integer.","solution":"from typing import List def merge_sort_desc(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort_desc(arr[:mid]) right_half = merge_sort_desc(arr[mid:]) return merge_descending(left_half, right_half) def merge_descending(left: List[int], right: List[int]) -> List[int]: result = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] > right[right_index]: result.append(left[left_index]) left_index += 1 else: result.append(right[right_index]) right_index += 1 result.extend(left[left_index:]) result.extend(right[right_index:]) return result"},{"question":"# Coding Question: Implement the following two functions for the `TreeNode` class provided: 1. **Function to check if the tree is balanced**: Implement a method `is_balanced` to determine if the tree is balanced. A balanced tree is defined as one where the depth of all leaf nodes or any internal node does not vary by more than one. ```python class TreeNode: # existing methods... def is_balanced(self) -> bool: Check if the tree is balanced. Returns: True if the tree is balanced, False otherwise. >>> TreeNode(1).is_balanced() True >>> TreeNode(1, TreeNode(2), TreeNode(3)).is_balanced() True >>> TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(5))), TreeNode(3)).is_balanced() False # Your implementation here ``` 2. **Function to perform preorder traversal**: Implement a method `preorder_traversal` which returns a list of node values using a preorder traversal. ```python class TreeNode: # existing methods... def preorder_traversal(self) -> list[int]: Return the values of the tree nodes in preorder traversal. Returns: A list of node values in preorder. >>> TreeNode(1).preorder_traversal() [1] >>> TreeNode(1, TreeNode(2), TreeNode(3)).preorder_traversal() [1, 2, 3] >>> TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)).preorder_traversal() [1, 2, 4, 3] # Your implementation here ``` # Constraints: * The tree node values are integers. * The tree may be unbalanced. * The maximum depth of the tree is not greater than 1000. # Examples: ```python root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) print(root.is_balanced()) # Output: True print(root.preorder_traversal()) # Output: [1, 2, 4, 3] root_unbalanced = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(5))), TreeNode(3)) print(root_unbalanced.is_balanced()) # Output: False print(root_unbalanced.preorder_traversal()) # Output: [1, 2, 4, 5, 3] ``` # Additional Notes: * Ensure the methods correctly handle trees with only one node and empty subtrees (`null` nodes). * The implementation should be efficient in both time and space complexity for large trees.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(self) -> bool: Check if the tree is balanced. Returns: True if the tree is balanced, False otherwise. def check_balance_and_height(node): if not node: return True, 0 left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) if not left_balanced or not right_balanced: return False, 0 # Node is balanced if the height difference of subtrees is at most 1 if abs(left_height - right_height) > 1: return False, 0 return True, max(left_height, right_height) + 1 balanced, _ = check_balance_and_height(self) return balanced def preorder_traversal(self) -> list[int]: Return the values of the tree nodes in preorder traversal. Returns: A list of node values in preorder. def traverse(node): if not node: return [] return [node.value] + traverse(node.left) + traverse(node.right) return traverse(self)"},{"question":"# Coding Challenge: Efficiently Balancing Binary Search Tree Given an unbalanced binary search tree (BST), your task is to efficiently balance it such that the depth of the two subtrees of every node differ by at most one. # Task Implement the `balance_bst` function that takes the root of a BST and returns the root of the balanced BST. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: ``` # Inputs - `root`: The root node of a binary search tree. Each node has an attribute `val`, and pointers `left` and `right` pointing to its children nodes. # Outputs - Returns the root node of the balanced binary search tree. # Constraints 1. The input BST can have up to 10,000 nodes. 2. Each node\'s value is unique and follows the BST property. 3. You must maintain the original BST ordering after balancing. 4. Aim for an optimal time and space complexity. # Example ```python # Example tree: # 10 # / # 5 20 # / # 1 7 30 root = TreeNode(10) root.left = TreeNode(5, TreeNode(1), TreeNode(7)) root.right = TreeNode(20, None, TreeNode(30)) balanced_root = balance_bst(root) # Expected output balanced tree: # 10 # / # 5 20 # / / # 1 7 15 30 ``` # Additional Information - The provided `TreeNode` class can be used without any modification. - Consider implementing an in-order traversal to first collect tree nodes, then use them to construct a balanced binary search tree. - Ensure to maintain optimal space complexity by avoiding unnecessary data structures. # Hints - An in-order traversal of a BST yields nodes in a sorted order. - Use a recursive function to construct a balanced tree from a sorted list of nodes. - Pay attention to edge cases such as an empty tree or a tree with a single node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node] + inorder_traversal(node.right) def sorted_list_to_bst(nodes, start, end): if start > end: return None mid = (start + end) // 2 node = nodes[mid] node.left = sorted_list_to_bst(nodes, start, mid - 1) node.right = sorted_list_to_bst(nodes, mid + 1, end) return node nodes = inorder_traversal(root) return sorted_list_to_bst(nodes, 0, len(nodes) - 1)"},{"question":"# Binary Tree Zigzag Level Order Traversal Coding Assessment Question Context You are working on enhancing a software system that processes hierarchical data structures, specifically binary trees. The system needs to handle data traversal in various ways to support different query requirements. Your task is to implement a function that performs a zigzag (or spiral) level order traversal on a binary tree. Description Write a function `zigzag_level_order(root: TreeNode | None) -> list[list[int]]` that returns the zigzag level order traversal of the given binary tree. The zigzag pattern means that the first level is traversed from left to right, the second level from right to left, and so on. Each node of the binary tree consists of: ```python @dataclass class TreeNode: val: int left: TreeNode | None = None right: TreeNode | None = None ``` # Input - A reference to the root node of the binary tree. # Output - A list of lists, where each inner list contains the values of the nodes at that level in zigzag order. # Constraints - The number of nodes in the tree is within the range `[0, 2000]`. - Node values can be any integer within the range `[-10^5, 10^5]`. - If the input root is `None`, return an empty list. # Example ```python # Given the following binary tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) result = zigzag_level_order(root) # The function should return the following zigzag level order traversal: # [ # [3], # [20, 9], # [15, 7] # ] ``` # Notes - You should aim for an efficient time complexity and consider edge cases such as trees with a single node or highly unbalanced trees. - Ensure that the tree traversal alternates correctly between left-to-right and right-to-left at each level. Implement the `zigzag_level_order` function to achieve the above requirements.","solution":"from collections import deque from typing import List, Optional from dataclasses import dataclass @dataclass class TreeNode: val: int left: Optional[\'TreeNode\'] = None right: Optional[\'TreeNode\'] = None def zigzag_level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) level_nodes = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"# Matrix Traversal  Diagonal Summation Scenario You are part of a team working on data analytics software that involves a lot of matrix manipulations. One of the tasks requires summing up the diagonals of large matrices efficiently. The diagonal sum is critical for the performance of some machine learning algorithms your team is developing. Task Implement the function `diagonal_sum` which takes a square matrix (a list of lists) and returns the sum of both the primary diagonal and the secondary diagonal. However, to optimize for larger matrices, ensure the sums are computed in a single pass with minimum iterations. Requirements * **Function Signature**: ```python def diagonal_sum(matrix: list[list[int]]) -> tuple[int, int]: ``` * **Inputs**: - `matrix` (list[list[int]]): A square matrix, where each element is an integer. * **Outputs**: - (tuple[int, int]): A tuple consisting of two integers representing the primary diagonal sum and the secondary diagonal sum respectively. * **Constraints**: - The matrix will always be square (same number of rows and columns). - Each list within the main list will have the same length as the number of lists. - The matrix size will be `1 <= size <= 10^3`. - If the matrix size is 0 (an empty list), return `(0, 0)`. * **Performance Requirements**: - Aim for a time complexity of O(n) with a single pass through the matrix. - Ensure space complexity remains O(1) besides the input matrix. Example ```python >>> diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) (15, 15) >>> diagonal_sum([ ... [2, 3], ... [4, 5] ... ]) (7, 7) >>> diagonal_sum([[5]]) (5, 5) >>> diagonal_sum([]) (0, 0) ```","solution":"def diagonal_sum(matrix): Returns the sum of the primary diagonal and the secondary diagonal of a square matrix. if not matrix or not matrix[0]: # handle the case of empty or invalid matrix return (0, 0) n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - i - 1] return (primary_diagonal_sum, secondary_diagonal_sum)"},{"question":"Find the Longest Substring Without Repeating Characters You need to implement a function that finds the longest substring without repeating characters from a given string. # Function Signature ```python def longest_unique_substring(s: str) -> str: Finds the longest substring without repeating characters. Args: s (str): The input string. Returns: str: The longest substring without repeating characters. Raises: ValueError: If s is not a string. Example: >>> longest_unique_substring(\\"abcabcbb\\") \'abc\' >>> longest_unique_substring(\\"bbbbb\\") \'b\' >>> longest_unique_substring(\\"pwwkew\\") \'wke\' >>> longest_unique_substring(\\"aab\\") \'ab\' >>> longest_unique_substring(\\"dvdf\\") \'vdf\' ``` # Constraints * You may assume that input strings will only contain lowercase English letters. * The input string will not be empty. # Implementation Requirements Implement the `longest_unique_substring` function: * Use a sliding window approach to keep track of the current substring without repeating characters. * Use a set or dictionary to keep track of characters in the current window. * Iterate through the string and update the window start and end indices accordingly. * Return the longest found substring. # Edge Cases to Consider * Strings with one character (e.g., \\"a\\" should return \\"a\\"). * Strings where all characters are unique (e.g., \\"abcde\\" should return \\"abcde\\"). * Strings where all characters are the same (e.g., \\"aaaaa\\" should return \\"a\\"). # Example Test ```python print(longest_unique_substring(\\"abcabcbb\\")) # Output: \\"abc\\" print(longest_unique_substring(\\"bbbbb\\")) # Output: \\"b\\" print(longest_unique_substring(\\"pwwkew\\")) # Output: \\"wke\\" print(longest_unique_substring(\\"aab\\")) # Output: \\"ab\\" print(longest_unique_substring(\\"dvdf\\")) # Output: \\"vdf\\" ``` **Write your implementation of the `longest_unique_substring` function below:**","solution":"def longest_unique_substring(s: str) -> str: if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") start = 0 max_len = 0 max_substr = \\"\\" char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_length = end - start + 1 if current_length > max_len: max_len = current_length max_substr = s[start:end+1] return max_substr"},{"question":"# Inventory Management System You are tasked with creating an inventory management system using Python that manages products in a warehouse. The system should support adding new products, updating quantities, and querying current stock levels. Each product has: 1. **Product ID**: A unique identifier represented as a string. 2. **Name**: A string representing the name of the product. 3. **Quantity**: An integer representing how many units are currently in stock. You need to: 1. Implement a class `Inventory` with methods to manage the inventory. 2. Implement methods to add a new product, update stock, and query the stock level for a product. # Input * Commands to manage the inventory in the form of strings, such as \\"add\\", \\"update\\", and \\"query\\". # Output * The result of the query command, providing the current stock level of a product. # Constraints * Assume inputs are well-formed commands. # Example ```python class Inventory: def __init__(self): self.items = {} def add_product(self, product_id: str, name: str, quantity: int) -> None: # Add a new product to the inventory. def update_quantity(self, product_id: str, quantity: int) -> None: # Update the quantity of a specific product. def query_quantity(self, product_id: str) -> int: # Query the current stock level of a specific product. # Example usage: inventory = Inventory() inventory.add_product(\\"001\\", \\"Laptop\\", 10) inventory.add_product(\\"002\\", \\"Keyboard\\", 20) inventory.update_quantity(\\"002\\", 15) assert inventory.query_quantity(\\"001\\") == 10 assert inventory.query_quantity(\\"002\\") == 15 ``` Implement the following methods: 1. **`__init__`**: Constructor for initializing the inventory. 2. **add_product**: Method to add a new product to the inventory. 3. **update_quantity**: Method to update the quantity of a product in the inventory. 4. **query_quantity**: Method to query the current stock level of a product.","solution":"class Inventory: def __init__(self): self.items = {} def add_product(self, product_id: str, name: str, quantity: int) -> None: Adds a new product to the inventory. If the product already exists, it will not be added again. if product_id not in self.items: self.items[product_id] = {\'name\': name, \'quantity\': quantity} def update_quantity(self, product_id: str, quantity: int) -> None: Updates the quantity of a specific product. If the product does not exist, no changes are made. if product_id in self.items: self.items[product_id][\'quantity\'] = quantity def query_quantity(self, product_id: str) -> int: Queries the current stock level of a specific product. Returns the quantity if the product exists, otherwise returns 0. if product_id in self.items: return self.items[product_id][\'quantity\'] return 0"},{"question":"# Circular Buffer: Wrapper Implementation and Edge Cases You are required to implement a circular buffer data structure that handles edge cases gracefully and includes additional utility methods. # Task Implement a class `CircularBuffer` which has the following methods: 1. `enqueue(element)`: Adds `element` to the buffer. If the buffer is full, it should overwrite the oldest data. 2. `dequeue()`: Removes and returns the oldest element from the buffer. If the buffer is empty, it should raise an `IndexError` with the message \\"Buffer is empty\\". 3. `size()`: Returns the number of elements currently in the buffer. 4. `is_empty()`: Returns `True` if the buffer is empty, `False` otherwise. 5. `is_full()`: Returns `True` if the buffer is full, `False` otherwise. 6. `peek()`: Returns the oldest element without removing it. If the buffer is empty, it should raise an `IndexError` with the message \\"Buffer is empty\\". # Specifications Method 1: `enqueue` - **Input**: `element` - the element to be added. - **Output**: None. Method 2: `dequeue` - **Input**: None. - **Output**: The oldest element in the buffer. Method 3: `size` - **Input**: None. - **Output**: The number of elements in the buffer. Method 4: `is_empty` - **Input**: None. - **Output**: `True` if the buffer is empty, `False` otherwise. Method 5: `is_full` - **Input**: None. - **Output**: `True` if the buffer is full, `False` otherwise. Method 6: `peek` - **Input**: None. - **Output**: The oldest element in the buffer. # Constraints 1. The buffer size is given at the time of initialization. 2. Elements can be any value of any data type. 3. Operations should be performed in O(1) time complexity. # Example ```python >>> buffer = CircularBuffer(3) >>> buffer.enqueue(1) >>> buffer.enqueue(2) >>> buffer.enqueue(3) >>> buffer.size() 3 >>> buffer.is_full() True >>> buffer.enqueue(4) >>> buffer.dequeue() 2 >>> buffer.dequeue() 3 >>> buffer.enqueue(5) >>> buffer.size() 2 >>> buffer.is_empty() False >>> buffer.peek() 3 >>> buffer.dequeue() 3 >>> buffer.dequeue() 5 >>> buffer.is_empty() True >>> buffer.peek() # should raise IndexError: Buffer is empty IndexError: Buffer is empty ``` # Implementation ```python class CircularBuffer: def __init__(self, size: int): self.buffer = [None] * size self.size = size self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, element): if self.is_full(): self.head = (self.head + 1) % self.size else: self.count += 1 self.buffer[self.tail] = element self.tail = (self.tail + 1) % self.size def dequeue(self): if self.is_empty(): raise IndexError(\\"Buffer is empty\\") element = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return element def size(self): return self.count def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.size def peek(self): if self.is_empty(): raise IndexError(\\"Buffer is empty\\") return self.buffer[self.head] ```","solution":"class CircularBuffer: def __init__(self, size: int): self.buffer = [None] * size self.size = size self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, element): if self.is_full(): self.head = (self.head + 1) % self.size else: self.count += 1 self.buffer[self.tail] = element self.tail = (self.tail + 1) % self.size def dequeue(self): if self.is_empty(): raise IndexError(\\"Buffer is empty\\") element = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return element def current_size(self): return self.count def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.size def peek(self): if self.is_empty(): raise IndexError(\\"Buffer is empty\\") return self.buffer[self.head]"},{"question":"# Background In computer graphics, a common problem is to determine the shortest distance from a point to a line segment. This is useful in various applications such as collision detection, object alignment, and more. Given a line segment defined by two endpoints and a point in 2D space, the shortest distance can be calculated using vector mathematics. # Problem Statement Write a function `shortest_distance(point: Tuple[float, float], segment_start: Tuple[float, float], segment_end: Tuple[float, float]) -> float` that calculates the shortest distance from a given point to a line segment defined by two endpoints. # Input - `point`: A tuple of two floats representing the coordinates (x, y) of the point. - `segment_start`: A tuple of two floats representing the coordinates (x, y) of the starting point of the line segment. - `segment_end`: A tuple of two floats representing the coordinates (x, y) of the ending point of the line segment. # Output - A float representing the shortest distance from the point to the line segment. # Constraints - The coordinates of the point, starting point, and ending point must be real numbers. - The segment defined by `segment_start` and `segment_end` must be non-degenerate (i.e., `segment_start` should not be equal to `segment_end`). # Example ```python point = (3, 4) segment_start = (0, 0) segment_end = (5, 5) result = shortest_distance(point, segment_start, segment_end) print(result) # Output should be approximately 0.7071 ``` # Notes - Use vector projections to find the point on the line segment closest to the given point, and then calculate the Euclidean distance. - Ensure your function handles edge cases where the point projects beyond the endpoints of the segment by clamping the projection point to the segment endpoints. # Hints - Calculate the projection of the point onto the line defined by the segment. - If the projection lies outside the segment, compute the distance to the nearest endpoint. - Use the Pythagorean theorem to compute the distances.","solution":"from typing import Tuple import math def shortest_distance(point: Tuple[float, float], segment_start: Tuple[float, float], segment_end: Tuple[float, float]) -> float: px, py = point sx, sy = segment_start ex, ey = segment_end # Calculate the vector from segment_start to segment_end segment_vector_x = ex - sx segment_vector_y = ey - sy # Calculate the vector from segment_start to the point point_vector_x = px - sx point_vector_y = py - sy # Calculate the dot product of the above two vectors dot_product = point_vector_x * segment_vector_x + point_vector_y * segment_vector_y seg_len_squared = segment_vector_x**2 + segment_vector_y**2 # Project point onto the line defined by segment_start and segment_end t = dot_product / seg_len_squared if seg_len_squared != 0 else -1 # Clamp t to the range [0, 1] t = max(0, min(1, t)) # Find the closest point on the segment closest_x = sx + t * segment_vector_x closest_y = sy + t * segment_vector_y # Calculate the distance from the point to the closest point on the segment distance = math.sqrt((px - closest_x)**2 + (py - closest_y)**2) return distance"},{"question":"# Question: Problem Statement: You are assigned to implement a digital circuit using only NOR gates to simulate the AND gate function. The AND gate outputs True (1) only when both inputs are True. Function Signature: ```python def and_using_nor(input_1: int, input_2: int) -> int: Compute the AND operation using only NOR gates :param input_1: First boolean input (0 or 1) :param input_2: Second boolean input (0 or 1) :return: Result of AND operation (0 or 1) ``` Input: - `input_1`: An integer, either 0 or 1. - `input_2`: An integer, either 0 or 1. Output: - An integer (0 or 1), representing the AND of the input values. Example: ```python >>> and_using_nor(0, 0) 0 >>> and_using_nor(0, 1) 0 >>> and_using_nor(1, 0) 0 >>> and_using_nor(1, 1) 1 ``` Constraints: - Input values will always be either 0 or 1. - The function must use only NOR gates as defined in the provided `nor_gate` function. Performance Requirements: The function should operate in constant time O(1) due to fixed operations versus input size. Hint: You may use the provided `nor_gate` function to build the AND logic. Recall that the AND can be represented in terms of NOR gates using the following logic: - `A AND B` can be achieved by using De Morgan\'s laws and constructing a specific sequence of NOR operations. # Note: Ensure you handle all boolean combinations as per the truth table of AND. ```python def nor_gate(input_1: int, input_2: int) -> int: return int(not (input_1 or input_2)) ``` Good luck!","solution":"def nor_gate(input_1: int, input_2: int) -> int: return int(not (input_1 or input_2)) def and_using_nor(input_1: int, input_2: int) -> int: Compute the AND operation using only NOR gates :param input_1: First boolean input (0 or 1) :param input_2: Second boolean input (0 or 1) :return: Result of AND operation (0 or 1) # NOR(x, x) = NOT(x) # AND can be constructed with the following series of NOR gates: # A AND B = NOR(NOR(A, A), NOR(B, B)) not_input_1 = nor_gate(input_1, input_1) not_input_2 = nor_gate(input_2, input_2) result = nor_gate(not_input_1, not_input_2) return result"},{"question":"# Comparing Two Version Numbers Write a function that compares two version numbers represented as strings. Each version number contains one or more numbers separated by dots. A version number is considered greater if the first non-matching number in the version string is greater. If no such number is found, then the version numbers are considered equal. Function Signature ```python def compare_versions(version1: str, version2: str) -> int: pass ``` Input * `version1` (str): The first version number string. * `version2` (str): The second version number string. Output * `int`: Return `1` if `version1` is greater than `version2`, `-1` if `version1` is less than `version2`, and `0` if they are equal. Constraints * Both version strings may contain up to 1000 characters. * Version strings contain only digits and dots. * Version numbers do not have leading zeros (except for 0 itself). Examples ```python print(compare_versions(\\"1.01\\", \\"1.001\\")) # should output 0 print(compare_versions(\\"1.0\\", \\"1.0.0\\")) # should output 0 print(compare_versions(\\"0.1\\", \\"1.1\\")) # should output -1 print(compare_versions(\\"1.2.3\\", \\"1.2.2\\")) # should output 1 ``` Explanation - In the first example, \\"1.01\\" and \\"1.001\\" are considered equal because leading zeros do not make a difference. - In the second example, \\"1.0\\" and \\"1.0.0\\" are equivalent as trailing zeroes in the version number do not change the version\'s value. - The third example shows that \\"0.1\\" is less than \\"1.1\\". - In the fourth example, \\"1.2.3\\" is greater than \\"1.2.2\\" as the third section of the version number has a greater value in `version1`.","solution":"def compare_versions(version1: str, version2: str) -> int: def to_int_list(version): return [int(x) for x in version.split(\'.\')] v1_list = to_int_list(version1) v2_list = to_int_list(version2) # Normalize lengths max_length = max(len(v1_list), len(v2_list)) v1_list.extend([0] * (max_length - len(v1_list))) v2_list.extend([0] * (max_length - len(v2_list))) # Compare for v1_part, v2_part in zip(v1_list, v2_list): if v1_part > v2_part: return 1 elif v1_part < v2_part: return -1 return 0"},{"question":"# Problem Statement: Cumulative Sum with Early Termination You are required to implement a function `cumulative_sum_until_limit` that calculates the cumulative sum of a list of numerical values but stops and discards the rest of the list if a given limit is surpassed by any cumulative sum during the process. The function should return the cumulative sum up to the point before the limit was surpassed or the total sum if the limit is never surpassed. # Function Signature: ```python def cumulative_sum_until_limit(numbers: list, limit: float) -> float: Calculates cumulative sum of the list elements until the limit is surpassed. Parameters: numbers (list): A list of numerical (float or int) values. limit (float): The cumulative sum limit. Returns: float: The cumulative sum up to the point before the limit was surpassed. Raises: TypeError: If the input numbers list contains non-numerical types or if the limit is not a numerical type. pass ``` # Input: - A list `numbers` which contains elements of numerical types (float or int). - A numerical limit `limit` which is a float. # Output: - Returns the cumulative sum of the list elements up to the point before the sum surpasses the given limit. # Constraints: - The function should handle both integers and floating-point numbers. - The function should raise a `TypeError` if the `numbers` list contains non-numerical elements or if the `limit` is not a numerical type. # Examples: ```python >>> cumulative_sum_until_limit([1, 2, 3, 4], 10) 10 >>> cumulative_sum_until_limit([1, 2, 3, 4], 5) 3 >>> cumulative_sum_until_limit([1.5, 2.5, -1.5, 3.5], 4) 2.5 >>> cumulative_sum_until_limit([1, 1, 1], 5) 3 >>> cumulative_sum_until_limit([], 10) 0 >>> cumulative_sum_until_limit([2, \'a\', 3], 10) Traceback (most recent call last): ... TypeError: All elements in the list must be numerical types >>> cumulative_sum_until_limit([1, 2, 3], \'limit\') Traceback (most recent call last): ... TypeError: Limit must be a numerical type ``` # Additional Notes: - Ensure the solution is efficient and comprehensive. - Include test cases that cover edge cases, typical scenarios, and exceptional situations.","solution":"def cumulative_sum_until_limit(numbers, limit): Calculates cumulative sum of the list elements until the limit is surpassed. Parameters: numbers (list): A list of numerical (float or int) values. limit (float): The cumulative sum limit. Returns: float: The cumulative sum up to the point before the limit was surpassed. Raises: TypeError: If the input numbers list contains non-numerical types or if the limit is not a numerical type. # Validate if the limit is a numerical type if not isinstance(limit, (int, float)): raise TypeError(\\"Limit must be a numerical type\\") # Validate if all elements in numbers are numerical types if not all(isinstance(i, (int, float)) for i in numbers): raise TypeError(\\"All elements in the list must be numerical types\\") cumulative_sum = 0 for number in numbers: cumulative_sum += number if cumulative_sum > limit: return cumulative_sum - number return cumulative_sum"},{"question":"# Problem Statement You need to implement a function that takes a list of integers and returns a new list with the same integers sorted, but every prime number in the list should appear at the beginning in their original relative order, followed by the non-prime numbers in their original relative order. # Function Signature ```python def sort_primes(lst: list) -> list: ``` # Input - A list of integers `lst`. # Output - A list of integers where prime numbers appear first in their original relative order, followed by non-prime numbers in their original relative order. # Constraints - `0 <= len(lst) <= 10^5` - Each integer in `lst` satisfies `0 <= lst[i] <= 10^6` # Example ```python assert sort_primes([3, 6, 2, 7, 8, 1]) == [3, 2, 7, 6, 8, 1] assert sort_primes([10, 11, 13, 14, 15]) == [11, 13, 10, 14, 15] assert sort_primes([]) == [] ``` # Explanation For the list `[3, 6, 2, 7, 8, 1]`: 1. Identify prime numbers: 3, 2, 7 2. Identify non-prime numbers: 6, 8, 1 3. Maintain their relative order: [3, 2, 7] followed by [6, 8, 1] This results in the list `[3, 2, 7, 6, 8, 1]`. # Edge Cases to Consider - The list might be empty, and the function should return an empty list. - The list may contain large numbers, so the function should efficiently determine primality without excessive computation time. Implement the function ensuring efficiency and correctness. Handle the primality test efficiently since `lst` can be very large.","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sort_primes(lst): Returns a new list with prime numbers at the beginning in their original relative order, followed by non-prime numbers in their original relative order. primes = [] non_primes = [] for num in lst: if is_prime(num): primes.append(num) else: non_primes.append(num) return primes + non_primes"},{"question":"# In-Memory Key-Value Store with Expiration Background An in-memory key-value store is a data storage paradigm designed to hold data in the system memory. This data can be quickly accessed by using keys. In some applications, it is essential to associate expiration times with the keys to ensure that stale data is automatically purged. Problem Statement You are tasked with implementing a simple in-memory key-value store that supports setting key-value pairs with an optional expiration time. If a key has an expiration time, it should automatically be removed from the store after the expiration time has passed. Requirements 1. **Function Signatures and Definitions**: - `class KeyValueStore()`: Constructor to initialize the key-value store. - `def set(key, value, ttl=None)`: Set a key-value pair in the store with an optional time-to-live (ttl) in seconds. - `def get(key)`: Retrieve the value associated with the key. If the key does not exist, return `None`. - `def delete(key)`: Remove the key-value pair from the store if it exists. - `def exists(key)`: Check if a key is present in the store and has not expired. - `def clear_expired()`: Manually clear all expired keys from the store. 2. **Input/Output**: - Initialize the key-value store. - Support setting, getting, and deleting key-value pairs along with existence checks. - Handle automatic expiration of keys. 3. **Constraints**: - `ttl` should be a non-negative integer representing the time-to-live in seconds. - Keys should be unique strings, and values can be any data type. - The store must support at least 100,000 keys without significant performance degradation. - Use the current time to determine time-to-live expiry. Objectives - Understand in-memory storage mechanisms. - Implement functionality to handle data with expiration. - Ensure efficient access and manipulation of the key-value pairs. Implement the `KeyValueStore` class with the specified persistence functionality, catering to the TTL expiration feature.","solution":"import time class KeyValueStore: def __init__(self): self.store = {} def set(self, key, value, ttl=None): expiry = None if ttl is not None: expiry = time.time() + ttl self.store[key] = (value, expiry) def get(self, key): if key in self.store: value, expiry = self.store[key] if expiry is None or time.time() < expiry: return value return None def delete(self, key): if key in self.store: del self.store[key] def exists(self, key): if key in self.store: value, expiry = self.store[key] if expiry is None or time.time() < expiry: return True return False def clear_expired(self): current_time = time.time() keys_to_delete = [key for key, (value, expiry) in self.store.items() if expiry is not None and current_time >= expiry] for key in keys_to_delete: del self.store[key]"},{"question":"# Coding Assessment Question You need to implement two functions that deal with character sequences and their frequency distributions. The tasks are to determine if a list of characters forms a palindrome and to count the frequency of each character in a string. Task **Function 1:** `is_palindrome(characters: list) -> bool` Implement a function to verify if a given list of characters forms a palindrome. A palindrome is a sequence that reads the same backward as forward. - **Input** - `characters` (list): A list of characters to check for the palindrome property. - **Output** - Returns `True` if the sequence is a palindrome, `False` otherwise. - **Constraints** - The `characters` list can contain any characters. - The `characters` must be a non-empty list. - **Examples** ```python assert is_palindrome([\'a\', \'b\', \'c\', \'b\', \'a\']) == True assert is_palindrome([\'a\', \'b\', \'c\']) == False ``` **Function 2:** `char_frequency(text: str) -> dict` Implement a function to calculate the frequency of each character in a given string. - **Input** - `text` (str): A string for which the character frequency is calculated. - **Output** - Returns a dictionary where keys represent the characters and values represent their respective frequencies. - **Constraints** - The `text` can be any valid string, including empty strings. - The function should consider case sensitivity. - **Examples** ```python assert char_frequency(\\"hello\\") == {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} assert char_frequency(\\"AaBbCc\\") == {\'A\': 1, \'a\': 1, \'B\': 1, \'b\': 1, \'C\': 1, \'c\': 1} ``` Implement these functions considering the constraints and edge cases and aim for optimal performance.","solution":"def is_palindrome(characters): Check if the given list of characters is a palindrome. Args: characters (list): A list of characters. Returns: bool: True if the list is a palindrome, False otherwise. return characters == characters[::-1] def char_frequency(text): Calculate the frequency of each character in the given text. Args: text (str): The input text. Returns: dict: A dictionary with characters as keys and their frequencies as values. frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Longest Increasing Subsequence In a thriving city, the city planners need to design an infrastructure sequence that maximizes efficiency and growth. This sequence can be represented as a series of construction projects, where each project has an associated time of completion. The planners aim to find the longest sequence of projects such that each subsequent project in the sequence is completed later than the previous one. You are tasked with implementing an algorithm to find the length of the longest increasing subsequence (LIS) of project completion times. **Function Signature**: ```python def longest_increasing_subsequence(project_times: List[int]) -> int: ``` **Input**: * `project_times`: (List of Integers) A list where each integer represents the time of completion for a project. **Output**: * An integer representing the length of the longest increasing subsequence of project times. **Constraints**: * 1  len(project_times)  1000 * Each time of completion `t` will be a unique integer in the range 1  t  10^6 **Example**: ```python >>> project_times = [3, 4, 1, 5, 6, 2, 7] >>> longest_increasing_subsequence(project_times) 5 Explanation: The longest increasing subsequence is [1, 2, 5, 6, 7] ``` Implement the `longest_increasing_subsequence` function: **Important Considerations**: * Ensure an efficient solution in terms of both time and space complexity. * Utilize dynamic programming or other advanced techniques to achieve optimal performance. Good luck!","solution":"from typing import List def longest_increasing_subsequence(project_times: List[int]) -> int: if not project_times: return 0 n = len(project_times) dp = [1] * n for i in range(1, n): for j in range(i): if project_times[i] > project_times[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Problem Description Create a function that determines if a given positive integer `num` is a Mersenne prime. A Mersenne prime is a prime number that is one less than a power of two, i.e., it is a number of the form `2^p - 1` where `p` is also a prime number. # Constraints * The function should correctly handle all positive integers `num` in the range `[2, 10^6]`. * You may assume that checking for primality is feasible within these input constraints. # Input * An integer `num` (2  num  10^6). # Output * A boolean value: `True` if `num` is a Mersenne prime, `False` otherwise. # Function Signature ```python def is_mersenne_prime(num: int) -> bool: ``` # Example ```python >>> is_mersenne_prime(3) True >>> is_mersenne_prime(7) True >>> is_mersenne_prime(15) False >>> is_mersenne_prime(31) True >>> is_mersenne_prime(1023) False ``` # Approach 1. Check if the number is a Mersenne number. This involves verifying if `num + 1` is a power of two. 2. If it is a Mersenne number, check if the exponent `p` (`log2(num + 1)`) is a prime number. 3. Return `True` if both conditions are met; otherwise, return `False`. # Note - Use efficient algorithms for prime number checking to ensure the solution works within the given constraints. - Consider using mathematical properties of Mersenne primes for optimized checking.","solution":"import math def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_mersenne_prime(num: int) -> bool: if num < 2: return False p = math.log2(num + 1) if p.is_integer() and is_prime(int(p)): return is_prime(num) return False"},{"question":"# Coding Assessment Question: Weather Data Analysis Scenario You are a data analyst for a weather station tasked with analyzing temperature data collected from various sensors over a period. Your goal is to implement methods to compute key temperature statistics to understand patterns in the data. Problem Statement Implement a Python class `TemperatureAnalysis` with methods to initialize the temperature data and compute the following statistics: 1. **Mean Temperature**: [ text{Mean} = frac{1}{N} sum_{i=1}^{N} T_i ] 2. **Median Temperature**: The median requires sorting the temperature data and finding the middle value. If there is an even number of observations, the median is the average of the two middle values. 3. **Temperature Anomalies**: The anomaly for each temperature value is calculated as the difference between the temperature and the mean temperature. [ text{Anomaly}(T_i) = T_i - text{Mean} ] Requirements 1. The class should be initialized with an array of temperature readings. 2. It should have a method `set_temperature_data` to update the temperature data. 3. Implement methods to calculate the `mean_temperature`, `median_temperature`, and `temperature_anomalies`. 4. The calculations should handle edge cases like empty data arrays gracefully. Input/Output Format - **Input**: An array representing temperature readings. - Example: ```python temperatures = np.array([25.3, 26.7, 24.1, 23.4, 28.9, 27.1, 30.2], dtype=\'float32\') ``` - **Output**: - A floating-point number for mean and median temperatures. - An array of the same shape for temperature anomalies. - **Constraints**: - The array will contain floating-point numbers representing temperatures. - The length of the array can vary and may contain a large number of observations. **Performance**: The solution should efficiently handle large arrays. Example Scenario ```python # Example input data (simplified) temperatures = np.array([25.3, 26.7, 24.1, 23.4, 28.9, 27.1, 30.2], dtype=\'float32\') # Initializing the class ta = TemperatureAnalysis(temperatures=temperatures) # Computing Mean Temperature mean_temp = ta.mean_temperature() print(\\"Mean Temperature:\\", mean_temp) # Computing Median Temperature median_temp = ta.median_temperature() print(\\"Median Temperature:\\", median_temp) # Computing Temperature Anomalies anomalies = ta.temperature_anomalies() print(\\"Temperature Anomalies:\\", anomalies) # Updating temperature data new_temperatures = np.array([22.1, 21.7, 23.9, 24.3, 26.2], dtype=\'float32\') ta.set_temperature_data(new_temperatures) # Recomputing Mean Temperature mean_temp = ta.mean_temperature() print(\\"Mean Temperature after update:\\", mean_temp) ``` **Implementation Details**: - Ensure all formulas match the specified ones. - Use numpy operations for efficiency. - Handle potential issues like empty arrays by returning appropriate values or raising exceptions.","solution":"import numpy as np class TemperatureAnalysis: def __init__(self, temperatures): self.temperatures = np.array(temperatures, dtype=\'float32\') def set_temperature_data(self, temperatures): self.temperatures = np.array(temperatures, dtype=\'float32\') def mean_temperature(self): if len(self.temperatures) == 0: return float(\'nan\') return np.mean(self.temperatures) def median_temperature(self): if len(self.temperatures) == 0: return float(\'nan\') return np.median(self.temperatures) def temperature_anomalies(self): if len(self.temperatures) == 0: return np.array([]) mean = self.mean_temperature() return self.temperatures - mean"},{"question":"# Validating Hex Color Codes # Objective Write a function that validates whether a given string represents a valid hexadecimal color code in CSS. A valid hex color code must adhere to the following rules: 1. It starts with the \'#\' character. 2. It is followed by exactly 6 characters, which can be digits (0-9) or letters from the set (a-f or A-F). # Input * A single string representing the potential hex color code. # Output * Return `True` if the string is a valid hex color code, otherwise return `False`. # Constraints * Do not use any external libraries (standard library functions are allowed). * Function signature should be: `def is_hex_color_valid(hex_color: str) -> bool`. # Example ```python def is_hex_color_valid(hex_color: str) -> bool: # Implement the function here # Example Usage: print(is_hex_color_valid(\\"#1A2B3C\\")) # Output: True print(is_hex_color_valid(\\"#ABCDEF\\")) # Output: True print(is_hex_color_valid(\\"#1A2B3G\\")) # Output: False ``` # Notes 1. The input string must start with a \'#\' character. 2. The following 6 characters must be valid hexadecimal digits (0-9, a-f, A-F). 3. Any string not matching these conditions is considered invalid.","solution":"def is_hex_color_valid(hex_color: str) -> bool: Validate if the given string is a valid hexadecimal color code. Parameters: hex_color (str): The string to be validated. Returns: bool: True if the string is a valid hex color code, False otherwise. if len(hex_color) != 7 or hex_color[0] != \'#\': return False for char in hex_color[1:]: if not (char.isdigit() or \'a\' <= char <= \'f\' or \'A\' <= char <= \'F\'): return False return True"},{"question":"# Context Dynamic programming is a powerful technique used to solve problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant computations. One classic example is the problem of finding the number of unique paths in a grid. # Question Write a function `unique_paths` that calculates the number of unique paths from the top-left corner to the bottom-right corner in an m x n grid. You can only move right or down at each step. Assume m and n are positive integers. # Function Signature ```python def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n grid from top-left to bottom-right. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: The number of unique paths. ``` # Input * `m`: An integer representing the number of rows in the grid, e.g., `3` * `n`: An integer representing the number of columns in the grid, e.g., `7` # Output * The number of unique paths from the top-left to the bottom-right in the grid, e.g., `28` for a 3 x 7 grid # Constraints * The values of `m` and `n` will be positive integers and within a reasonable size for computation in a coding assessment, typically `1 <= m, n <= 100`. # Examples ```python assert unique_paths(3, 7) == 28 assert unique_paths(3, 2) == 3 assert unique_paths(7, 3) == 28 assert unique_paths(3, 3) == 6 assert unique_paths(1, 1) == 1 ```","solution":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n grid from top-left to bottom-right. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: The number of unique paths. # Create a 2D list with dimensions m x n initialized to 0 dp = [[0] * n for _ in range(m)] # Fill the first row and first column with 1s since there\'s only one way to get to those cells for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the answer return dp[m-1][n-1]"},{"question":"# Find the Longest Increasing Path in a Matrix You are provided with an `M x N` matrix of integers. Starting from any cell, you can move in any of the four cardinal directions (left, right, up, down) to reach a neighboring cell. Your task is to determine the length of the longest path of increasing values in the matrix. Function Signature ```python def longest_increasing_path(matrix: List[List[int]]) -> int: Returns the length of the longest path of strictly increasing values in the matrix. ``` Input * `matrix` (List[List[int]]): A 2D list of integers representing the matrix. Output * Returns the length of the longest path of increasing values (int). Constraints * The matrix must be a list of lists where each inner list is of the same length. * Each cell contains an integer value. * The matrix size is guaranteed to be at least 1x1 and at most 200x200. Examples ```python assert longest_increasing_path([ [9, 9, 4], [6, 6, 8], [2, 1, 1] ]) == 4 assert longest_increasing_path([ [3, 4, 5], [3, 2, 6], [2, 2, 1] ]) == 4 assert longest_increasing_path([[7]]) == 1 ``` Scenario Imagine you are working in a software company developing a game where characters need to collect treasures in a grid-like map. The character can only move to cells with larger values to collect more significantly valuable treasures. To maximize the character\'s collecting efficiency, you need to determine the longest path of increasing values on the grid. Your function will be vital for optimizing the treasure collection strategy in the game.","solution":"from typing import List def longest_increasing_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) cache = [[-1] * cols for _ in range(rows)] def dfs(x, y): if cache[x][y] != -1: return cache[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) cache[x][y] = max_length return max_length max_path = 0 for i in range(rows): for j in range(cols): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"# Coding Assessment Question **Context:** Sorting algorithms are fundamental in computer science and often serve as introductory topics for problem-solving. Merge sort is a divide-and-conquer algorithm that divides the unsorted list into n sublists, each containing one element (a list of one element is considered sorted), and repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining. **Task:** Write a function named `merge_sort` in Python to sort an array of integers using the merge sort algorithm. **Function Signature:** ```python def merge_sort(arr: List[int]) -> List[int]: ``` **Input:** - `arr`: A list of integers that needs to be sorted. **Output:** - A new list of integers that is sorted in ascending order. **Constraints:** - The list can contain negative numbers. - All elements in the list are integers. **Example:** ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([-3, -1, -2, 2, 3, 1, 0]) [-3, -2, -1, 0, 1, 2, 3] >>> merge_sort([3]) [3] >>> merge_sort([]) [] ``` **Note:** - Do not use any built-in sorting functions or libraries (such as `sorted` or the `sort` method for lists). - Ensure your function handles empty lists and lists with one element properly.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the merge sort algorithm. Args: arr (List[int]): A list of integers to be sorted. Returns: List[int]: A new list of integers sorted in ascending order. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] <= right[right_idx]: merged.append(left[left_idx]) left_idx += 1 else: merged.append(right[right_idx]) right_idx += 1 # Add the remaining elements merged.extend(left[left_idx:]) merged.extend(right[right_idx:]) return merged # Divide the list into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"# Question In computer science, a queue is a linear data structure that follows a First-In-First-Out (FIFO) order. However, sometimes we need a special kind of queue known as a priority queue, where each element has a priority associated with it, and elements are dequeued in the order of their priority rather than their insertion order. You need to implement a basic priority queue class in Python. The priority queue should support two primary operations: - `enqueue(item, priority)`: Adds an item to the queue with the given priority. - `dequeue()`: Removes and returns the item with the highest priority (the lowest numerical value of priority), or `None` if the queue is empty. For the sake of simplicity, assume that: - If two items have the same priority, return the one that was enqueued first. - Priorities are positive integers, and lower numbers indicate higher priorities (e.g., the item with priority 1 is dequeued before the item with priority 2). Class Signature: ```python class PriorityQueue: def __init__(self): pass def enqueue(self, item: any, priority: int): pass def dequeue(self) -> any: pass ``` Example Usage: ```python pq = PriorityQueue() pq.enqueue(\'A\', 2) pq.enqueue(\'B\', 1) pq.enqueue(\'C\', 3) print(pq.dequeue()) # Output: \'B\' print(pq.dequeue()) # Output: \'A\' print(pq.dequeue()) # Output: \'C\' print(pq.dequeue()) # Output: None ``` Edge Cases: - If `dequeue()` is called on an empty queue, it should return `None`. - The priority queue should handle elements with the same priority by dequeuing them in the order they were enqueued. Use the following skeleton code to get started: ```python import heapq class PriorityQueue: def __init__(self): self.heap = [] self.counter = 0 def enqueue(self, item: any, priority: int): # Increment the counter to maintain FIFO order for same-priority items self.counter += 1 heapq.heappush(self.heap, (priority, self.counter, item)) def dequeue(self) -> any: if not self.heap: return None return heapq.heappop(self.heap)[2] ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.counter = 0 def enqueue(self, item: any, priority: int): # Increment the counter to maintain FIFO order for same-priority items self.counter += 1 heapq.heappush(self.heap, (priority, self.counter, item)) def dequeue(self) -> any: if not self.heap: return None return heapq.heappop(self.heap)[2]"}]'),S={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},L={class:"card-container"},R={key:0,class:"empty-state"},O=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")},"  ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,O)):u("",!0)])}const Y=c(S,[["render",D],["__scopeId","data-v-aa075ba8"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/13.md","filePath":"library/13.md"}'),j={name:"library/13.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,U as default};
